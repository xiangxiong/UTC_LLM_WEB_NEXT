/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "_sc_client_node_modules_mermaid_dist_mindmap-definition-617cf8dd_js";
exports.ids = ["_sc_client_node_modules_mermaid_dist_mindmap-definition-617cf8dd_js"];
exports.modules = {

/***/ "(sc_client)/./node_modules/cose-base/cose-base.js":
/*!*********************************************!*\
  !*** ./node_modules/cose-base/cose-base.js ***!
  \*********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory(__webpack_require__(/*! layout-base */ \"(sc_client)/./node_modules/layout-base/layout-base.js\"));\n\telse {}\n})(this, function(__WEBPACK_EXTERNAL_MODULE_0__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_643__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_643__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__nested_webpack_require_643__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__nested_webpack_require_643__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__nested_webpack_require_643__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__nested_webpack_require_643__.d = function(exports, name, getter) {\n/******/ \t\tif(!__nested_webpack_require_643__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__nested_webpack_require_643__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__nested_webpack_require_643__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__nested_webpack_require_643__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__nested_webpack_require_643__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __nested_webpack_require_643__(__nested_webpack_require_643__.s = 7);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __nested_webpack_require_3185__) {\n\n\"use strict\";\n\n\nvar FDLayoutConstants = __nested_webpack_require_3185__(0).FDLayoutConstants;\n\nfunction CoSEConstants() {}\n\n//CoSEConstants inherits static props in FDLayoutConstants\nfor (var prop in FDLayoutConstants) {\n  CoSEConstants[prop] = FDLayoutConstants[prop];\n}\n\nCoSEConstants.DEFAULT_USE_MULTI_LEVEL_SCALING = false;\nCoSEConstants.DEFAULT_RADIAL_SEPARATION = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\nCoSEConstants.DEFAULT_COMPONENT_SEPERATION = 60;\nCoSEConstants.TILE = true;\nCoSEConstants.TILING_PADDING_VERTICAL = 10;\nCoSEConstants.TILING_PADDING_HORIZONTAL = 10;\nCoSEConstants.TREE_REDUCTION_ON_INCREMENTAL = false; // make this true when cose is used incrementally as a part of other non-incremental layout\n\nmodule.exports = CoSEConstants;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __nested_webpack_require_4002__) {\n\n\"use strict\";\n\n\nvar FDLayoutEdge = __nested_webpack_require_4002__(0).FDLayoutEdge;\n\nfunction CoSEEdge(source, target, vEdge) {\n  FDLayoutEdge.call(this, source, target, vEdge);\n}\n\nCoSEEdge.prototype = Object.create(FDLayoutEdge.prototype);\nfor (var prop in FDLayoutEdge) {\n  CoSEEdge[prop] = FDLayoutEdge[prop];\n}\n\nmodule.exports = CoSEEdge;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __nested_webpack_require_4409__) {\n\n\"use strict\";\n\n\nvar LGraph = __nested_webpack_require_4409__(0).LGraph;\n\nfunction CoSEGraph(parent, graphMgr, vGraph) {\n  LGraph.call(this, parent, graphMgr, vGraph);\n}\n\nCoSEGraph.prototype = Object.create(LGraph.prototype);\nfor (var prop in LGraph) {\n  CoSEGraph[prop] = LGraph[prop];\n}\n\nmodule.exports = CoSEGraph;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __nested_webpack_require_4790__) {\n\n\"use strict\";\n\n\nvar LGraphManager = __nested_webpack_require_4790__(0).LGraphManager;\n\nfunction CoSEGraphManager(layout) {\n  LGraphManager.call(this, layout);\n}\n\nCoSEGraphManager.prototype = Object.create(LGraphManager.prototype);\nfor (var prop in LGraphManager) {\n  CoSEGraphManager[prop] = LGraphManager[prop];\n}\n\nmodule.exports = CoSEGraphManager;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __nested_webpack_require_5205__) {\n\n\"use strict\";\n\n\nvar FDLayoutNode = __nested_webpack_require_5205__(0).FDLayoutNode;\nvar IMath = __nested_webpack_require_5205__(0).IMath;\n\nfunction CoSENode(gm, loc, size, vNode) {\n  FDLayoutNode.call(this, gm, loc, size, vNode);\n}\n\nCoSENode.prototype = Object.create(FDLayoutNode.prototype);\nfor (var prop in FDLayoutNode) {\n  CoSENode[prop] = FDLayoutNode[prop];\n}\n\nCoSENode.prototype.move = function () {\n  var layout = this.graphManager.getLayout();\n  this.displacementX = layout.coolingFactor * (this.springForceX + this.repulsionForceX + this.gravitationForceX) / this.noOfChildren;\n  this.displacementY = layout.coolingFactor * (this.springForceY + this.repulsionForceY + this.gravitationForceY) / this.noOfChildren;\n\n  if (Math.abs(this.displacementX) > layout.coolingFactor * layout.maxNodeDisplacement) {\n    this.displacementX = layout.coolingFactor * layout.maxNodeDisplacement * IMath.sign(this.displacementX);\n  }\n\n  if (Math.abs(this.displacementY) > layout.coolingFactor * layout.maxNodeDisplacement) {\n    this.displacementY = layout.coolingFactor * layout.maxNodeDisplacement * IMath.sign(this.displacementY);\n  }\n\n  // a simple node, just move it\n  if (this.child == null) {\n    this.moveBy(this.displacementX, this.displacementY);\n  }\n  // an empty compound node, again just move it\n  else if (this.child.getNodes().length == 0) {\n      this.moveBy(this.displacementX, this.displacementY);\n    }\n    // non-empty compound node, propogate movement to children as well\n    else {\n        this.propogateDisplacementToChildren(this.displacementX, this.displacementY);\n      }\n\n  layout.totalDisplacement += Math.abs(this.displacementX) + Math.abs(this.displacementY);\n\n  this.springForceX = 0;\n  this.springForceY = 0;\n  this.repulsionForceX = 0;\n  this.repulsionForceY = 0;\n  this.gravitationForceX = 0;\n  this.gravitationForceY = 0;\n  this.displacementX = 0;\n  this.displacementY = 0;\n};\n\nCoSENode.prototype.propogateDisplacementToChildren = function (dX, dY) {\n  var nodes = this.getChild().getNodes();\n  var node;\n  for (var i = 0; i < nodes.length; i++) {\n    node = nodes[i];\n    if (node.getChild() == null) {\n      node.moveBy(dX, dY);\n      node.displacementX += dX;\n      node.displacementY += dY;\n    } else {\n      node.propogateDisplacementToChildren(dX, dY);\n    }\n  }\n};\n\nCoSENode.prototype.setPred1 = function (pred1) {\n  this.pred1 = pred1;\n};\n\nCoSENode.prototype.getPred1 = function () {\n  return pred1;\n};\n\nCoSENode.prototype.getPred2 = function () {\n  return pred2;\n};\n\nCoSENode.prototype.setNext = function (next) {\n  this.next = next;\n};\n\nCoSENode.prototype.getNext = function () {\n  return next;\n};\n\nCoSENode.prototype.setProcessed = function (processed) {\n  this.processed = processed;\n};\n\nCoSENode.prototype.isProcessed = function () {\n  return processed;\n};\n\nmodule.exports = CoSENode;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __nested_webpack_require_8085__) {\n\n\"use strict\";\n\n\nvar FDLayout = __nested_webpack_require_8085__(0).FDLayout;\nvar CoSEGraphManager = __nested_webpack_require_8085__(4);\nvar CoSEGraph = __nested_webpack_require_8085__(3);\nvar CoSENode = __nested_webpack_require_8085__(5);\nvar CoSEEdge = __nested_webpack_require_8085__(2);\nvar CoSEConstants = __nested_webpack_require_8085__(1);\nvar FDLayoutConstants = __nested_webpack_require_8085__(0).FDLayoutConstants;\nvar LayoutConstants = __nested_webpack_require_8085__(0).LayoutConstants;\nvar Point = __nested_webpack_require_8085__(0).Point;\nvar PointD = __nested_webpack_require_8085__(0).PointD;\nvar Layout = __nested_webpack_require_8085__(0).Layout;\nvar Integer = __nested_webpack_require_8085__(0).Integer;\nvar IGeometry = __nested_webpack_require_8085__(0).IGeometry;\nvar LGraph = __nested_webpack_require_8085__(0).LGraph;\nvar Transform = __nested_webpack_require_8085__(0).Transform;\n\nfunction CoSELayout() {\n  FDLayout.call(this);\n\n  this.toBeTiled = {}; // Memorize if a node is to be tiled or is tiled\n}\n\nCoSELayout.prototype = Object.create(FDLayout.prototype);\n\nfor (var prop in FDLayout) {\n  CoSELayout[prop] = FDLayout[prop];\n}\n\nCoSELayout.prototype.newGraphManager = function () {\n  var gm = new CoSEGraphManager(this);\n  this.graphManager = gm;\n  return gm;\n};\n\nCoSELayout.prototype.newGraph = function (vGraph) {\n  return new CoSEGraph(null, this.graphManager, vGraph);\n};\n\nCoSELayout.prototype.newNode = function (vNode) {\n  return new CoSENode(this.graphManager, vNode);\n};\n\nCoSELayout.prototype.newEdge = function (vEdge) {\n  return new CoSEEdge(null, null, vEdge);\n};\n\nCoSELayout.prototype.initParameters = function () {\n  FDLayout.prototype.initParameters.call(this, arguments);\n  if (!this.isSubLayout) {\n    if (CoSEConstants.DEFAULT_EDGE_LENGTH < 10) {\n      this.idealEdgeLength = 10;\n    } else {\n      this.idealEdgeLength = CoSEConstants.DEFAULT_EDGE_LENGTH;\n    }\n\n    this.useSmartIdealEdgeLengthCalculation = CoSEConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION;\n    this.springConstant = FDLayoutConstants.DEFAULT_SPRING_STRENGTH;\n    this.repulsionConstant = FDLayoutConstants.DEFAULT_REPULSION_STRENGTH;\n    this.gravityConstant = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH;\n    this.compoundGravityConstant = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH;\n    this.gravityRangeFactor = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR;\n    this.compoundGravityRangeFactor = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR;\n\n    // variables for tree reduction support\n    this.prunedNodesAll = [];\n    this.growTreeIterations = 0;\n    this.afterGrowthIterations = 0;\n    this.isTreeGrowing = false;\n    this.isGrowthFinished = false;\n\n    // variables for cooling\n    this.coolingCycle = 0;\n    this.maxCoolingCycle = this.maxIterations / FDLayoutConstants.CONVERGENCE_CHECK_PERIOD;\n    this.finalTemperature = FDLayoutConstants.CONVERGENCE_CHECK_PERIOD / this.maxIterations;\n    this.coolingAdjuster = 1;\n  }\n};\n\nCoSELayout.prototype.layout = function () {\n  var createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\n  if (createBendsAsNeeded) {\n    this.createBendpoints();\n    this.graphManager.resetAllEdges();\n  }\n\n  this.level = 0;\n  return this.classicLayout();\n};\n\nCoSELayout.prototype.classicLayout = function () {\n  this.nodesWithGravity = this.calculateNodesToApplyGravitationTo();\n  this.graphManager.setAllNodesToApplyGravitation(this.nodesWithGravity);\n  this.calcNoOfChildrenForAllNodes();\n  this.graphManager.calcLowestCommonAncestors();\n  this.graphManager.calcInclusionTreeDepths();\n  this.graphManager.getRoot().calcEstimatedSize();\n  this.calcIdealEdgeLengths();\n\n  if (!this.incremental) {\n    var forest = this.getFlatForest();\n\n    // The graph associated with this layout is flat and a forest\n    if (forest.length > 0) {\n      this.positionNodesRadially(forest);\n    }\n    // The graph associated with this layout is not flat or a forest\n    else {\n        // Reduce the trees when incremental mode is not enabled and graph is not a forest \n        this.reduceTrees();\n        // Update nodes that gravity will be applied\n        this.graphManager.resetAllNodesToApplyGravitation();\n        var allNodes = new Set(this.getAllNodes());\n        var intersection = this.nodesWithGravity.filter(function (x) {\n          return allNodes.has(x);\n        });\n        this.graphManager.setAllNodesToApplyGravitation(intersection);\n\n        this.positionNodesRandomly();\n      }\n  } else {\n    if (CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL) {\n      // Reduce the trees in incremental mode if only this constant is set to true \n      this.reduceTrees();\n      // Update nodes that gravity will be applied\n      this.graphManager.resetAllNodesToApplyGravitation();\n      var allNodes = new Set(this.getAllNodes());\n      var intersection = this.nodesWithGravity.filter(function (x) {\n        return allNodes.has(x);\n      });\n      this.graphManager.setAllNodesToApplyGravitation(intersection);\n    }\n  }\n\n  this.initSpringEmbedder();\n  this.runSpringEmbedder();\n\n  return true;\n};\n\nCoSELayout.prototype.tick = function () {\n  this.totalIterations++;\n\n  if (this.totalIterations === this.maxIterations && !this.isTreeGrowing && !this.isGrowthFinished) {\n    if (this.prunedNodesAll.length > 0) {\n      this.isTreeGrowing = true;\n    } else {\n      return true;\n    }\n  }\n\n  if (this.totalIterations % FDLayoutConstants.CONVERGENCE_CHECK_PERIOD == 0 && !this.isTreeGrowing && !this.isGrowthFinished) {\n    if (this.isConverged()) {\n      if (this.prunedNodesAll.length > 0) {\n        this.isTreeGrowing = true;\n      } else {\n        return true;\n      }\n    }\n\n    this.coolingCycle++;\n\n    if (this.layoutQuality == 0) {\n      // quality - \"draft\"\n      this.coolingAdjuster = this.coolingCycle;\n    } else if (this.layoutQuality == 1) {\n      // quality - \"default\"\n      this.coolingAdjuster = this.coolingCycle / 3;\n    }\n\n    // cooling schedule is based on http://www.btluke.com/simanf1.html -> cooling schedule 3\n    this.coolingFactor = Math.max(this.initialCoolingFactor - Math.pow(this.coolingCycle, Math.log(100 * (this.initialCoolingFactor - this.finalTemperature)) / Math.log(this.maxCoolingCycle)) / 100 * this.coolingAdjuster, this.finalTemperature);\n    this.animationPeriod = Math.ceil(this.initialAnimationPeriod * Math.sqrt(this.coolingFactor));\n  }\n  // Operations while tree is growing again \n  if (this.isTreeGrowing) {\n    if (this.growTreeIterations % 10 == 0) {\n      if (this.prunedNodesAll.length > 0) {\n        this.graphManager.updateBounds();\n        this.updateGrid();\n        this.growTree(this.prunedNodesAll);\n        // Update nodes that gravity will be applied\n        this.graphManager.resetAllNodesToApplyGravitation();\n        var allNodes = new Set(this.getAllNodes());\n        var intersection = this.nodesWithGravity.filter(function (x) {\n          return allNodes.has(x);\n        });\n        this.graphManager.setAllNodesToApplyGravitation(intersection);\n\n        this.graphManager.updateBounds();\n        this.updateGrid();\n        this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;\n      } else {\n        this.isTreeGrowing = false;\n        this.isGrowthFinished = true;\n      }\n    }\n    this.growTreeIterations++;\n  }\n  // Operations after growth is finished\n  if (this.isGrowthFinished) {\n    if (this.isConverged()) {\n      return true;\n    }\n    if (this.afterGrowthIterations % 10 == 0) {\n      this.graphManager.updateBounds();\n      this.updateGrid();\n    }\n    this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL * ((100 - this.afterGrowthIterations) / 100);\n    this.afterGrowthIterations++;\n  }\n\n  var gridUpdateAllowed = !this.isTreeGrowing && !this.isGrowthFinished;\n  var forceToNodeSurroundingUpdate = this.growTreeIterations % 10 == 1 && this.isTreeGrowing || this.afterGrowthIterations % 10 == 1 && this.isGrowthFinished;\n\n  this.totalDisplacement = 0;\n  this.graphManager.updateBounds();\n  this.calcSpringForces();\n  this.calcRepulsionForces(gridUpdateAllowed, forceToNodeSurroundingUpdate);\n  this.calcGravitationalForces();\n  this.moveNodes();\n  this.animate();\n\n  return false; // Layout is not ended yet return false\n};\n\nCoSELayout.prototype.getPositionsData = function () {\n  var allNodes = this.graphManager.getAllNodes();\n  var pData = {};\n  for (var i = 0; i < allNodes.length; i++) {\n    var rect = allNodes[i].rect;\n    var id = allNodes[i].id;\n    pData[id] = {\n      id: id,\n      x: rect.getCenterX(),\n      y: rect.getCenterY(),\n      w: rect.width,\n      h: rect.height\n    };\n  }\n\n  return pData;\n};\n\nCoSELayout.prototype.runSpringEmbedder = function () {\n  this.initialAnimationPeriod = 25;\n  this.animationPeriod = this.initialAnimationPeriod;\n  var layoutEnded = false;\n\n  // If aminate option is 'during' signal that layout is supposed to start iterating\n  if (FDLayoutConstants.ANIMATE === 'during') {\n    this.emit('layoutstarted');\n  } else {\n    // If aminate option is 'during' tick() function will be called on index.js\n    while (!layoutEnded) {\n      layoutEnded = this.tick();\n    }\n\n    this.graphManager.updateBounds();\n  }\n};\n\nCoSELayout.prototype.calculateNodesToApplyGravitationTo = function () {\n  var nodeList = [];\n  var graph;\n\n  var graphs = this.graphManager.getGraphs();\n  var size = graphs.length;\n  var i;\n  for (i = 0; i < size; i++) {\n    graph = graphs[i];\n\n    graph.updateConnected();\n\n    if (!graph.isConnected) {\n      nodeList = nodeList.concat(graph.getNodes());\n    }\n  }\n\n  return nodeList;\n};\n\nCoSELayout.prototype.createBendpoints = function () {\n  var edges = [];\n  edges = edges.concat(this.graphManager.getAllEdges());\n  var visited = new Set();\n  var i;\n  for (i = 0; i < edges.length; i++) {\n    var edge = edges[i];\n\n    if (!visited.has(edge)) {\n      var source = edge.getSource();\n      var target = edge.getTarget();\n\n      if (source == target) {\n        edge.getBendpoints().push(new PointD());\n        edge.getBendpoints().push(new PointD());\n        this.createDummyNodesForBendpoints(edge);\n        visited.add(edge);\n      } else {\n        var edgeList = [];\n\n        edgeList = edgeList.concat(source.getEdgeListToNode(target));\n        edgeList = edgeList.concat(target.getEdgeListToNode(source));\n\n        if (!visited.has(edgeList[0])) {\n          if (edgeList.length > 1) {\n            var k;\n            for (k = 0; k < edgeList.length; k++) {\n              var multiEdge = edgeList[k];\n              multiEdge.getBendpoints().push(new PointD());\n              this.createDummyNodesForBendpoints(multiEdge);\n            }\n          }\n          edgeList.forEach(function (edge) {\n            visited.add(edge);\n          });\n        }\n      }\n    }\n\n    if (visited.size == edges.length) {\n      break;\n    }\n  }\n};\n\nCoSELayout.prototype.positionNodesRadially = function (forest) {\n  // We tile the trees to a grid row by row; first tree starts at (0,0)\n  var currentStartingPoint = new Point(0, 0);\n  var numberOfColumns = Math.ceil(Math.sqrt(forest.length));\n  var height = 0;\n  var currentY = 0;\n  var currentX = 0;\n  var point = new PointD(0, 0);\n\n  for (var i = 0; i < forest.length; i++) {\n    if (i % numberOfColumns == 0) {\n      // Start of a new row, make the x coordinate 0, increment the\n      // y coordinate with the max height of the previous row\n      currentX = 0;\n      currentY = height;\n\n      if (i != 0) {\n        currentY += CoSEConstants.DEFAULT_COMPONENT_SEPERATION;\n      }\n\n      height = 0;\n    }\n\n    var tree = forest[i];\n\n    // Find the center of the tree\n    var centerNode = Layout.findCenterOfTree(tree);\n\n    // Set the staring point of the next tree\n    currentStartingPoint.x = currentX;\n    currentStartingPoint.y = currentY;\n\n    // Do a radial layout starting with the center\n    point = CoSELayout.radialLayout(tree, centerNode, currentStartingPoint);\n\n    if (point.y > height) {\n      height = Math.floor(point.y);\n    }\n\n    currentX = Math.floor(point.x + CoSEConstants.DEFAULT_COMPONENT_SEPERATION);\n  }\n\n  this.transform(new PointD(LayoutConstants.WORLD_CENTER_X - point.x / 2, LayoutConstants.WORLD_CENTER_Y - point.y / 2));\n};\n\nCoSELayout.radialLayout = function (tree, centerNode, startingPoint) {\n  var radialSep = Math.max(this.maxDiagonalInTree(tree), CoSEConstants.DEFAULT_RADIAL_SEPARATION);\n  CoSELayout.branchRadialLayout(centerNode, null, 0, 359, 0, radialSep);\n  var bounds = LGraph.calculateBounds(tree);\n\n  var transform = new Transform();\n  transform.setDeviceOrgX(bounds.getMinX());\n  transform.setDeviceOrgY(bounds.getMinY());\n  transform.setWorldOrgX(startingPoint.x);\n  transform.setWorldOrgY(startingPoint.y);\n\n  for (var i = 0; i < tree.length; i++) {\n    var node = tree[i];\n    node.transform(transform);\n  }\n\n  var bottomRight = new PointD(bounds.getMaxX(), bounds.getMaxY());\n\n  return transform.inverseTransformPoint(bottomRight);\n};\n\nCoSELayout.branchRadialLayout = function (node, parentOfNode, startAngle, endAngle, distance, radialSeparation) {\n  // First, position this node by finding its angle.\n  var halfInterval = (endAngle - startAngle + 1) / 2;\n\n  if (halfInterval < 0) {\n    halfInterval += 180;\n  }\n\n  var nodeAngle = (halfInterval + startAngle) % 360;\n  var teta = nodeAngle * IGeometry.TWO_PI / 360;\n\n  // Make polar to java cordinate conversion.\n  var cos_teta = Math.cos(teta);\n  var x_ = distance * Math.cos(teta);\n  var y_ = distance * Math.sin(teta);\n\n  node.setCenter(x_, y_);\n\n  // Traverse all neighbors of this node and recursively call this\n  // function.\n  var neighborEdges = [];\n  neighborEdges = neighborEdges.concat(node.getEdges());\n  var childCount = neighborEdges.length;\n\n  if (parentOfNode != null) {\n    childCount--;\n  }\n\n  var branchCount = 0;\n\n  var incEdgesCount = neighborEdges.length;\n  var startIndex;\n\n  var edges = node.getEdgesBetween(parentOfNode);\n\n  // If there are multiple edges, prune them until there remains only one\n  // edge.\n  while (edges.length > 1) {\n    //neighborEdges.remove(edges.remove(0));\n    var temp = edges[0];\n    edges.splice(0, 1);\n    var index = neighborEdges.indexOf(temp);\n    if (index >= 0) {\n      neighborEdges.splice(index, 1);\n    }\n    incEdgesCount--;\n    childCount--;\n  }\n\n  if (parentOfNode != null) {\n    //assert edges.length == 1;\n    startIndex = (neighborEdges.indexOf(edges[0]) + 1) % incEdgesCount;\n  } else {\n    startIndex = 0;\n  }\n\n  var stepAngle = Math.abs(endAngle - startAngle) / childCount;\n\n  for (var i = startIndex; branchCount != childCount; i = ++i % incEdgesCount) {\n    var currentNeighbor = neighborEdges[i].getOtherEnd(node);\n\n    // Don't back traverse to root node in current tree.\n    if (currentNeighbor == parentOfNode) {\n      continue;\n    }\n\n    var childStartAngle = (startAngle + branchCount * stepAngle) % 360;\n    var childEndAngle = (childStartAngle + stepAngle) % 360;\n\n    CoSELayout.branchRadialLayout(currentNeighbor, node, childStartAngle, childEndAngle, distance + radialSeparation, radialSeparation);\n\n    branchCount++;\n  }\n};\n\nCoSELayout.maxDiagonalInTree = function (tree) {\n  var maxDiagonal = Integer.MIN_VALUE;\n\n  for (var i = 0; i < tree.length; i++) {\n    var node = tree[i];\n    var diagonal = node.getDiagonal();\n\n    if (diagonal > maxDiagonal) {\n      maxDiagonal = diagonal;\n    }\n  }\n\n  return maxDiagonal;\n};\n\nCoSELayout.prototype.calcRepulsionRange = function () {\n  // formula is 2 x (level + 1) x idealEdgeLength\n  return 2 * (this.level + 1) * this.idealEdgeLength;\n};\n\n// Tiling methods\n\n// Group zero degree members whose parents are not to be tiled, create dummy parents where needed and fill memberGroups by their dummp parent id's\nCoSELayout.prototype.groupZeroDegreeMembers = function () {\n  var self = this;\n  // array of [parent_id x oneDegreeNode_id]\n  var tempMemberGroups = {}; // A temporary map of parent node and its zero degree members\n  this.memberGroups = {}; // A map of dummy parent node and its zero degree members whose parents are not to be tiled\n  this.idToDummyNode = {}; // A map of id to dummy node \n\n  var zeroDegree = []; // List of zero degree nodes whose parents are not to be tiled\n  var allNodes = this.graphManager.getAllNodes();\n\n  // Fill zero degree list\n  for (var i = 0; i < allNodes.length; i++) {\n    var node = allNodes[i];\n    var parent = node.getParent();\n    // If a node has zero degree and its parent is not to be tiled if exists add that node to zeroDegres list\n    if (this.getNodeDegreeWithChildren(node) === 0 && (parent.id == undefined || !this.getToBeTiled(parent))) {\n      zeroDegree.push(node);\n    }\n  }\n\n  // Create a map of parent node and its zero degree members\n  for (var i = 0; i < zeroDegree.length; i++) {\n    var node = zeroDegree[i]; // Zero degree node itself\n    var p_id = node.getParent().id; // Parent id\n\n    if (typeof tempMemberGroups[p_id] === \"undefined\") tempMemberGroups[p_id] = [];\n\n    tempMemberGroups[p_id] = tempMemberGroups[p_id].concat(node); // Push node to the list belongs to its parent in tempMemberGroups\n  }\n\n  // If there are at least two nodes at a level, create a dummy compound for them\n  Object.keys(tempMemberGroups).forEach(function (p_id) {\n    if (tempMemberGroups[p_id].length > 1) {\n      var dummyCompoundId = \"DummyCompound_\" + p_id; // The id of dummy compound which will be created soon\n      self.memberGroups[dummyCompoundId] = tempMemberGroups[p_id]; // Add dummy compound to memberGroups\n\n      var parent = tempMemberGroups[p_id][0].getParent(); // The parent of zero degree nodes will be the parent of new dummy compound\n\n      // Create a dummy compound with calculated id\n      var dummyCompound = new CoSENode(self.graphManager);\n      dummyCompound.id = dummyCompoundId;\n      dummyCompound.paddingLeft = parent.paddingLeft || 0;\n      dummyCompound.paddingRight = parent.paddingRight || 0;\n      dummyCompound.paddingBottom = parent.paddingBottom || 0;\n      dummyCompound.paddingTop = parent.paddingTop || 0;\n\n      self.idToDummyNode[dummyCompoundId] = dummyCompound;\n\n      var dummyParentGraph = self.getGraphManager().add(self.newGraph(), dummyCompound);\n      var parentGraph = parent.getChild();\n\n      // Add dummy compound to parent the graph\n      parentGraph.add(dummyCompound);\n\n      // For each zero degree node in this level remove it from its parent graph and add it to the graph of dummy parent\n      for (var i = 0; i < tempMemberGroups[p_id].length; i++) {\n        var node = tempMemberGroups[p_id][i];\n\n        parentGraph.remove(node);\n        dummyParentGraph.add(node);\n      }\n    }\n  });\n};\n\nCoSELayout.prototype.clearCompounds = function () {\n  var childGraphMap = {};\n  var idToNode = {};\n\n  // Get compound ordering by finding the inner one first\n  this.performDFSOnCompounds();\n\n  for (var i = 0; i < this.compoundOrder.length; i++) {\n\n    idToNode[this.compoundOrder[i].id] = this.compoundOrder[i];\n    childGraphMap[this.compoundOrder[i].id] = [].concat(this.compoundOrder[i].getChild().getNodes());\n\n    // Remove children of compounds\n    this.graphManager.remove(this.compoundOrder[i].getChild());\n    this.compoundOrder[i].child = null;\n  }\n\n  this.graphManager.resetAllNodes();\n\n  // Tile the removed children\n  this.tileCompoundMembers(childGraphMap, idToNode);\n};\n\nCoSELayout.prototype.clearZeroDegreeMembers = function () {\n  var self = this;\n  var tiledZeroDegreePack = this.tiledZeroDegreePack = [];\n\n  Object.keys(this.memberGroups).forEach(function (id) {\n    var compoundNode = self.idToDummyNode[id]; // Get the dummy compound\n\n    tiledZeroDegreePack[id] = self.tileNodes(self.memberGroups[id], compoundNode.paddingLeft + compoundNode.paddingRight);\n\n    // Set the width and height of the dummy compound as calculated\n    compoundNode.rect.width = tiledZeroDegreePack[id].width;\n    compoundNode.rect.height = tiledZeroDegreePack[id].height;\n  });\n};\n\nCoSELayout.prototype.repopulateCompounds = function () {\n  for (var i = this.compoundOrder.length - 1; i >= 0; i--) {\n    var lCompoundNode = this.compoundOrder[i];\n    var id = lCompoundNode.id;\n    var horizontalMargin = lCompoundNode.paddingLeft;\n    var verticalMargin = lCompoundNode.paddingTop;\n\n    this.adjustLocations(this.tiledMemberPack[id], lCompoundNode.rect.x, lCompoundNode.rect.y, horizontalMargin, verticalMargin);\n  }\n};\n\nCoSELayout.prototype.repopulateZeroDegreeMembers = function () {\n  var self = this;\n  var tiledPack = this.tiledZeroDegreePack;\n\n  Object.keys(tiledPack).forEach(function (id) {\n    var compoundNode = self.idToDummyNode[id]; // Get the dummy compound by its id\n    var horizontalMargin = compoundNode.paddingLeft;\n    var verticalMargin = compoundNode.paddingTop;\n\n    // Adjust the positions of nodes wrt its compound\n    self.adjustLocations(tiledPack[id], compoundNode.rect.x, compoundNode.rect.y, horizontalMargin, verticalMargin);\n  });\n};\n\nCoSELayout.prototype.getToBeTiled = function (node) {\n  var id = node.id;\n  //firstly check the previous results\n  if (this.toBeTiled[id] != null) {\n    return this.toBeTiled[id];\n  }\n\n  //only compound nodes are to be tiled\n  var childGraph = node.getChild();\n  if (childGraph == null) {\n    this.toBeTiled[id] = false;\n    return false;\n  }\n\n  var children = childGraph.getNodes(); // Get the children nodes\n\n  //a compound node is not to be tiled if all of its compound children are not to be tiled\n  for (var i = 0; i < children.length; i++) {\n    var theChild = children[i];\n\n    if (this.getNodeDegree(theChild) > 0) {\n      this.toBeTiled[id] = false;\n      return false;\n    }\n\n    //pass the children not having the compound structure\n    if (theChild.getChild() == null) {\n      this.toBeTiled[theChild.id] = false;\n      continue;\n    }\n\n    if (!this.getToBeTiled(theChild)) {\n      this.toBeTiled[id] = false;\n      return false;\n    }\n  }\n  this.toBeTiled[id] = true;\n  return true;\n};\n\n// Get degree of a node depending of its edges and independent of its children\nCoSELayout.prototype.getNodeDegree = function (node) {\n  var id = node.id;\n  var edges = node.getEdges();\n  var degree = 0;\n\n  // For the edges connected\n  for (var i = 0; i < edges.length; i++) {\n    var edge = edges[i];\n    if (edge.getSource().id !== edge.getTarget().id) {\n      degree = degree + 1;\n    }\n  }\n  return degree;\n};\n\n// Get degree of a node with its children\nCoSELayout.prototype.getNodeDegreeWithChildren = function (node) {\n  var degree = this.getNodeDegree(node);\n  if (node.getChild() == null) {\n    return degree;\n  }\n  var children = node.getChild().getNodes();\n  for (var i = 0; i < children.length; i++) {\n    var child = children[i];\n    degree += this.getNodeDegreeWithChildren(child);\n  }\n  return degree;\n};\n\nCoSELayout.prototype.performDFSOnCompounds = function () {\n  this.compoundOrder = [];\n  this.fillCompexOrderByDFS(this.graphManager.getRoot().getNodes());\n};\n\nCoSELayout.prototype.fillCompexOrderByDFS = function (children) {\n  for (var i = 0; i < children.length; i++) {\n    var child = children[i];\n    if (child.getChild() != null) {\n      this.fillCompexOrderByDFS(child.getChild().getNodes());\n    }\n    if (this.getToBeTiled(child)) {\n      this.compoundOrder.push(child);\n    }\n  }\n};\n\n/**\n* This method places each zero degree member wrt given (x,y) coordinates (top left).\n*/\nCoSELayout.prototype.adjustLocations = function (organization, x, y, compoundHorizontalMargin, compoundVerticalMargin) {\n  x += compoundHorizontalMargin;\n  y += compoundVerticalMargin;\n\n  var left = x;\n\n  for (var i = 0; i < organization.rows.length; i++) {\n    var row = organization.rows[i];\n    x = left;\n    var maxHeight = 0;\n\n    for (var j = 0; j < row.length; j++) {\n      var lnode = row[j];\n\n      lnode.rect.x = x; // + lnode.rect.width / 2;\n      lnode.rect.y = y; // + lnode.rect.height / 2;\n\n      x += lnode.rect.width + organization.horizontalPadding;\n\n      if (lnode.rect.height > maxHeight) maxHeight = lnode.rect.height;\n    }\n\n    y += maxHeight + organization.verticalPadding;\n  }\n};\n\nCoSELayout.prototype.tileCompoundMembers = function (childGraphMap, idToNode) {\n  var self = this;\n  this.tiledMemberPack = [];\n\n  Object.keys(childGraphMap).forEach(function (id) {\n    // Get the compound node\n    var compoundNode = idToNode[id];\n\n    self.tiledMemberPack[id] = self.tileNodes(childGraphMap[id], compoundNode.paddingLeft + compoundNode.paddingRight);\n\n    compoundNode.rect.width = self.tiledMemberPack[id].width;\n    compoundNode.rect.height = self.tiledMemberPack[id].height;\n  });\n};\n\nCoSELayout.prototype.tileNodes = function (nodes, minWidth) {\n  var verticalPadding = CoSEConstants.TILING_PADDING_VERTICAL;\n  var horizontalPadding = CoSEConstants.TILING_PADDING_HORIZONTAL;\n  var organization = {\n    rows: [],\n    rowWidth: [],\n    rowHeight: [],\n    width: 0,\n    height: minWidth, // assume minHeight equals to minWidth\n    verticalPadding: verticalPadding,\n    horizontalPadding: horizontalPadding\n  };\n\n  // Sort the nodes in ascending order of their areas\n  nodes.sort(function (n1, n2) {\n    if (n1.rect.width * n1.rect.height > n2.rect.width * n2.rect.height) return -1;\n    if (n1.rect.width * n1.rect.height < n2.rect.width * n2.rect.height) return 1;\n    return 0;\n  });\n\n  // Create the organization -> tile members\n  for (var i = 0; i < nodes.length; i++) {\n    var lNode = nodes[i];\n\n    if (organization.rows.length == 0) {\n      this.insertNodeToRow(organization, lNode, 0, minWidth);\n    } else if (this.canAddHorizontal(organization, lNode.rect.width, lNode.rect.height)) {\n      this.insertNodeToRow(organization, lNode, this.getShortestRowIndex(organization), minWidth);\n    } else {\n      this.insertNodeToRow(organization, lNode, organization.rows.length, minWidth);\n    }\n\n    this.shiftToLastRow(organization);\n  }\n\n  return organization;\n};\n\nCoSELayout.prototype.insertNodeToRow = function (organization, node, rowIndex, minWidth) {\n  var minCompoundSize = minWidth;\n\n  // Add new row if needed\n  if (rowIndex == organization.rows.length) {\n    var secondDimension = [];\n\n    organization.rows.push(secondDimension);\n    organization.rowWidth.push(minCompoundSize);\n    organization.rowHeight.push(0);\n  }\n\n  // Update row width\n  var w = organization.rowWidth[rowIndex] + node.rect.width;\n\n  if (organization.rows[rowIndex].length > 0) {\n    w += organization.horizontalPadding;\n  }\n\n  organization.rowWidth[rowIndex] = w;\n  // Update compound width\n  if (organization.width < w) {\n    organization.width = w;\n  }\n\n  // Update height\n  var h = node.rect.height;\n  if (rowIndex > 0) h += organization.verticalPadding;\n\n  var extraHeight = 0;\n  if (h > organization.rowHeight[rowIndex]) {\n    extraHeight = organization.rowHeight[rowIndex];\n    organization.rowHeight[rowIndex] = h;\n    extraHeight = organization.rowHeight[rowIndex] - extraHeight;\n  }\n\n  organization.height += extraHeight;\n\n  // Insert node\n  organization.rows[rowIndex].push(node);\n};\n\n//Scans the rows of an organization and returns the one with the min width\nCoSELayout.prototype.getShortestRowIndex = function (organization) {\n  var r = -1;\n  var min = Number.MAX_VALUE;\n\n  for (var i = 0; i < organization.rows.length; i++) {\n    if (organization.rowWidth[i] < min) {\n      r = i;\n      min = organization.rowWidth[i];\n    }\n  }\n  return r;\n};\n\n//Scans the rows of an organization and returns the one with the max width\nCoSELayout.prototype.getLongestRowIndex = function (organization) {\n  var r = -1;\n  var max = Number.MIN_VALUE;\n\n  for (var i = 0; i < organization.rows.length; i++) {\n\n    if (organization.rowWidth[i] > max) {\n      r = i;\n      max = organization.rowWidth[i];\n    }\n  }\n\n  return r;\n};\n\n/**\n* This method checks whether adding extra width to the organization violates\n* the aspect ratio(1) or not.\n*/\nCoSELayout.prototype.canAddHorizontal = function (organization, extraWidth, extraHeight) {\n\n  var sri = this.getShortestRowIndex(organization);\n\n  if (sri < 0) {\n    return true;\n  }\n\n  var min = organization.rowWidth[sri];\n\n  if (min + organization.horizontalPadding + extraWidth <= organization.width) return true;\n\n  var hDiff = 0;\n\n  // Adding to an existing row\n  if (organization.rowHeight[sri] < extraHeight) {\n    if (sri > 0) hDiff = extraHeight + organization.verticalPadding - organization.rowHeight[sri];\n  }\n\n  var add_to_row_ratio;\n  if (organization.width - min >= extraWidth + organization.horizontalPadding) {\n    add_to_row_ratio = (organization.height + hDiff) / (min + extraWidth + organization.horizontalPadding);\n  } else {\n    add_to_row_ratio = (organization.height + hDiff) / organization.width;\n  }\n\n  // Adding a new row for this node\n  hDiff = extraHeight + organization.verticalPadding;\n  var add_new_row_ratio;\n  if (organization.width < extraWidth) {\n    add_new_row_ratio = (organization.height + hDiff) / extraWidth;\n  } else {\n    add_new_row_ratio = (organization.height + hDiff) / organization.width;\n  }\n\n  if (add_new_row_ratio < 1) add_new_row_ratio = 1 / add_new_row_ratio;\n\n  if (add_to_row_ratio < 1) add_to_row_ratio = 1 / add_to_row_ratio;\n\n  return add_to_row_ratio < add_new_row_ratio;\n};\n\n//If moving the last node from the longest row and adding it to the last\n//row makes the bounding box smaller, do it.\nCoSELayout.prototype.shiftToLastRow = function (organization) {\n  var longest = this.getLongestRowIndex(organization);\n  var last = organization.rowWidth.length - 1;\n  var row = organization.rows[longest];\n  var node = row[row.length - 1];\n\n  var diff = node.width + organization.horizontalPadding;\n\n  // Check if there is enough space on the last row\n  if (organization.width - organization.rowWidth[last] > diff && longest != last) {\n    // Remove the last element of the longest row\n    row.splice(-1, 1);\n\n    // Push it to the last row\n    organization.rows[last].push(node);\n\n    organization.rowWidth[longest] = organization.rowWidth[longest] - diff;\n    organization.rowWidth[last] = organization.rowWidth[last] + diff;\n    organization.width = organization.rowWidth[instance.getLongestRowIndex(organization)];\n\n    // Update heights of the organization\n    var maxHeight = Number.MIN_VALUE;\n    for (var i = 0; i < row.length; i++) {\n      if (row[i].height > maxHeight) maxHeight = row[i].height;\n    }\n    if (longest > 0) maxHeight += organization.verticalPadding;\n\n    var prevTotal = organization.rowHeight[longest] + organization.rowHeight[last];\n\n    organization.rowHeight[longest] = maxHeight;\n    if (organization.rowHeight[last] < node.height + organization.verticalPadding) organization.rowHeight[last] = node.height + organization.verticalPadding;\n\n    var finalTotal = organization.rowHeight[longest] + organization.rowHeight[last];\n    organization.height += finalTotal - prevTotal;\n\n    this.shiftToLastRow(organization);\n  }\n};\n\nCoSELayout.prototype.tilingPreLayout = function () {\n  if (CoSEConstants.TILE) {\n    // Find zero degree nodes and create a compound for each level\n    this.groupZeroDegreeMembers();\n    // Tile and clear children of each compound\n    this.clearCompounds();\n    // Separately tile and clear zero degree nodes for each level\n    this.clearZeroDegreeMembers();\n  }\n};\n\nCoSELayout.prototype.tilingPostLayout = function () {\n  if (CoSEConstants.TILE) {\n    this.repopulateZeroDegreeMembers();\n    this.repopulateCompounds();\n  }\n};\n\n// -----------------------------------------------------------------------------\n// Section: Tree Reduction methods\n// -----------------------------------------------------------------------------\n// Reduce trees \nCoSELayout.prototype.reduceTrees = function () {\n  var prunedNodesAll = [];\n  var containsLeaf = true;\n  var node;\n\n  while (containsLeaf) {\n    var allNodes = this.graphManager.getAllNodes();\n    var prunedNodesInStepTemp = [];\n    containsLeaf = false;\n\n    for (var i = 0; i < allNodes.length; i++) {\n      node = allNodes[i];\n      if (node.getEdges().length == 1 && !node.getEdges()[0].isInterGraph && node.getChild() == null) {\n        prunedNodesInStepTemp.push([node, node.getEdges()[0], node.getOwner()]);\n        containsLeaf = true;\n      }\n    }\n    if (containsLeaf == true) {\n      var prunedNodesInStep = [];\n      for (var j = 0; j < prunedNodesInStepTemp.length; j++) {\n        if (prunedNodesInStepTemp[j][0].getEdges().length == 1) {\n          prunedNodesInStep.push(prunedNodesInStepTemp[j]);\n          prunedNodesInStepTemp[j][0].getOwner().remove(prunedNodesInStepTemp[j][0]);\n        }\n      }\n      prunedNodesAll.push(prunedNodesInStep);\n      this.graphManager.resetAllNodes();\n      this.graphManager.resetAllEdges();\n    }\n  }\n  this.prunedNodesAll = prunedNodesAll;\n};\n\n// Grow tree one step \nCoSELayout.prototype.growTree = function (prunedNodesAll) {\n  var lengthOfPrunedNodesInStep = prunedNodesAll.length;\n  var prunedNodesInStep = prunedNodesAll[lengthOfPrunedNodesInStep - 1];\n\n  var nodeData;\n  for (var i = 0; i < prunedNodesInStep.length; i++) {\n    nodeData = prunedNodesInStep[i];\n\n    this.findPlaceforPrunedNode(nodeData);\n\n    nodeData[2].add(nodeData[0]);\n    nodeData[2].add(nodeData[1], nodeData[1].source, nodeData[1].target);\n  }\n\n  prunedNodesAll.splice(prunedNodesAll.length - 1, 1);\n  this.graphManager.resetAllNodes();\n  this.graphManager.resetAllEdges();\n};\n\n// Find an appropriate position to replace pruned node, this method can be improved\nCoSELayout.prototype.findPlaceforPrunedNode = function (nodeData) {\n\n  var gridForPrunedNode;\n  var nodeToConnect;\n  var prunedNode = nodeData[0];\n  if (prunedNode == nodeData[1].source) {\n    nodeToConnect = nodeData[1].target;\n  } else {\n    nodeToConnect = nodeData[1].source;\n  }\n  var startGridX = nodeToConnect.startX;\n  var finishGridX = nodeToConnect.finishX;\n  var startGridY = nodeToConnect.startY;\n  var finishGridY = nodeToConnect.finishY;\n\n  var upNodeCount = 0;\n  var downNodeCount = 0;\n  var rightNodeCount = 0;\n  var leftNodeCount = 0;\n  var controlRegions = [upNodeCount, rightNodeCount, downNodeCount, leftNodeCount];\n\n  if (startGridY > 0) {\n    for (var i = startGridX; i <= finishGridX; i++) {\n      controlRegions[0] += this.grid[i][startGridY - 1].length + this.grid[i][startGridY].length - 1;\n    }\n  }\n  if (finishGridX < this.grid.length - 1) {\n    for (var i = startGridY; i <= finishGridY; i++) {\n      controlRegions[1] += this.grid[finishGridX + 1][i].length + this.grid[finishGridX][i].length - 1;\n    }\n  }\n  if (finishGridY < this.grid[0].length - 1) {\n    for (var i = startGridX; i <= finishGridX; i++) {\n      controlRegions[2] += this.grid[i][finishGridY + 1].length + this.grid[i][finishGridY].length - 1;\n    }\n  }\n  if (startGridX > 0) {\n    for (var i = startGridY; i <= finishGridY; i++) {\n      controlRegions[3] += this.grid[startGridX - 1][i].length + this.grid[startGridX][i].length - 1;\n    }\n  }\n  var min = Integer.MAX_VALUE;\n  var minCount;\n  var minIndex;\n  for (var j = 0; j < controlRegions.length; j++) {\n    if (controlRegions[j] < min) {\n      min = controlRegions[j];\n      minCount = 1;\n      minIndex = j;\n    } else if (controlRegions[j] == min) {\n      minCount++;\n    }\n  }\n\n  if (minCount == 3 && min == 0) {\n    if (controlRegions[0] == 0 && controlRegions[1] == 0 && controlRegions[2] == 0) {\n      gridForPrunedNode = 1;\n    } else if (controlRegions[0] == 0 && controlRegions[1] == 0 && controlRegions[3] == 0) {\n      gridForPrunedNode = 0;\n    } else if (controlRegions[0] == 0 && controlRegions[2] == 0 && controlRegions[3] == 0) {\n      gridForPrunedNode = 3;\n    } else if (controlRegions[1] == 0 && controlRegions[2] == 0 && controlRegions[3] == 0) {\n      gridForPrunedNode = 2;\n    }\n  } else if (minCount == 2 && min == 0) {\n    var random = Math.floor(Math.random() * 2);\n    if (controlRegions[0] == 0 && controlRegions[1] == 0) {\n      ;\n      if (random == 0) {\n        gridForPrunedNode = 0;\n      } else {\n        gridForPrunedNode = 1;\n      }\n    } else if (controlRegions[0] == 0 && controlRegions[2] == 0) {\n      if (random == 0) {\n        gridForPrunedNode = 0;\n      } else {\n        gridForPrunedNode = 2;\n      }\n    } else if (controlRegions[0] == 0 && controlRegions[3] == 0) {\n      if (random == 0) {\n        gridForPrunedNode = 0;\n      } else {\n        gridForPrunedNode = 3;\n      }\n    } else if (controlRegions[1] == 0 && controlRegions[2] == 0) {\n      if (random == 0) {\n        gridForPrunedNode = 1;\n      } else {\n        gridForPrunedNode = 2;\n      }\n    } else if (controlRegions[1] == 0 && controlRegions[3] == 0) {\n      if (random == 0) {\n        gridForPrunedNode = 1;\n      } else {\n        gridForPrunedNode = 3;\n      }\n    } else {\n      if (random == 0) {\n        gridForPrunedNode = 2;\n      } else {\n        gridForPrunedNode = 3;\n      }\n    }\n  } else if (minCount == 4 && min == 0) {\n    var random = Math.floor(Math.random() * 4);\n    gridForPrunedNode = random;\n  } else {\n    gridForPrunedNode = minIndex;\n  }\n\n  if (gridForPrunedNode == 0) {\n    prunedNode.setCenter(nodeToConnect.getCenterX(), nodeToConnect.getCenterY() - nodeToConnect.getHeight() / 2 - FDLayoutConstants.DEFAULT_EDGE_LENGTH - prunedNode.getHeight() / 2);\n  } else if (gridForPrunedNode == 1) {\n    prunedNode.setCenter(nodeToConnect.getCenterX() + nodeToConnect.getWidth() / 2 + FDLayoutConstants.DEFAULT_EDGE_LENGTH + prunedNode.getWidth() / 2, nodeToConnect.getCenterY());\n  } else if (gridForPrunedNode == 2) {\n    prunedNode.setCenter(nodeToConnect.getCenterX(), nodeToConnect.getCenterY() + nodeToConnect.getHeight() / 2 + FDLayoutConstants.DEFAULT_EDGE_LENGTH + prunedNode.getHeight() / 2);\n  } else {\n    prunedNode.setCenter(nodeToConnect.getCenterX() - nodeToConnect.getWidth() / 2 - FDLayoutConstants.DEFAULT_EDGE_LENGTH - prunedNode.getWidth() / 2, nodeToConnect.getCenterY());\n  }\n};\n\nmodule.exports = CoSELayout;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __nested_webpack_require_45620__) {\n\n\"use strict\";\n\n\nvar coseBase = {};\n\ncoseBase.layoutBase = __nested_webpack_require_45620__(0);\ncoseBase.CoSEConstants = __nested_webpack_require_45620__(1);\ncoseBase.CoSEEdge = __nested_webpack_require_45620__(2);\ncoseBase.CoSEGraph = __nested_webpack_require_45620__(3);\ncoseBase.CoSEGraphManager = __nested_webpack_require_45620__(4);\ncoseBase.CoSELayout = __nested_webpack_require_45620__(6);\ncoseBase.CoSENode = __nested_webpack_require_45620__(5);\n\nmodule.exports = coseBase;\n\n/***/ })\n/******/ ]);\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvY29zZS1iYXNlL2Nvc2UtYmFzZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLElBQUksSUFBeUQ7QUFDN0QsMkJBQTJCLG1CQUFPLENBQUMsMEVBQWE7QUFDaEQsTUFBTSxFQUsyQztBQUNqRCxDQUFDO0FBQ0QscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDhCQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSw4QkFBbUI7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QjtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7QUFDN0I7QUFDQTtBQUNBLFVBQVUsOEJBQW1CLHVCQUF1QjtBQUNwRDtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7QUFDN0IsZUFBZSw4QkFBbUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QjtBQUNBLG9DQUFvQyw0QkFBNEI7QUFDaEUsMENBQTBDO0FBQzFDLFdBQVcsOEJBQW1CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4QkFBbUIsa0NBQWtDO0FBQy9EO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QjtBQUNBO0FBQ0EsaUJBQWlCLDhCQUFtQixDQUFDLDhCQUFtQjtBQUN4RCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLCtCQUFtQjs7QUFFcEQ7OztBQUdBLHdCQUF3QiwrQkFBbUI7O0FBRTNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDs7QUFFckQ7O0FBRUEs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QUNBLGtCQUFrQiwyQkFBMkI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBOztBQUVBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxnQ0FBbUI7O0FBRXBEOzs7QUFHQTs7QUFFQSxzQkFBc0IsZ0NBQW1CO0FBQ3pDLHlCQUF5QixnQ0FBbUI7QUFDNUMsb0JBQW9CLGdDQUFtQjtBQUN2QyxxQkFBcUIsZ0NBQW1CO0FBQ3hDLDRCQUE0QixnQ0FBbUI7QUFDL0Msc0JBQXNCLGdDQUFtQjtBQUN6QyxvQkFBb0IsZ0NBQW1COztBQUV2Qzs7QUFFQSxPQUFPO0FBQ1A7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2hhdGdwdC1uZXh0LXdlYi8uL25vZGVfbW9kdWxlcy9jb3NlLWJhc2UvY29zZS1iYXNlLmpzP2Y4NDgiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwibGF5b3V0LWJhc2VcIikpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW1wibGF5b3V0LWJhc2VcIl0sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiY29zZUJhc2VcIl0gPSBmYWN0b3J5KHJlcXVpcmUoXCJsYXlvdXQtYmFzZVwiKSk7XG5cdGVsc2Vcblx0XHRyb290W1wiY29zZUJhc2VcIl0gPSBmYWN0b3J5KHJvb3RbXCJsYXlvdXRCYXNlXCJdKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMF9fKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGlkZW50aXR5IGZ1bmN0aW9uIGZvciBjYWxsaW5nIGhhcm1vbnkgaW1wb3J0cyB3aXRoIHRoZSBjb3JyZWN0IGNvbnRleHRcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5pID0gZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4vKioqKioqLyBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4vKioqKioqLyBcdFx0XHRcdGdldDogZ2V0dGVyXG4vKioqKioqLyBcdFx0XHR9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gNyk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8wX187XG5cbi8qKiovIH0pLFxuLyogMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgRkRMYXlvdXRDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApLkZETGF5b3V0Q29uc3RhbnRzO1xuXG5mdW5jdGlvbiBDb1NFQ29uc3RhbnRzKCkge31cblxuLy9Db1NFQ29uc3RhbnRzIGluaGVyaXRzIHN0YXRpYyBwcm9wcyBpbiBGRExheW91dENvbnN0YW50c1xuZm9yICh2YXIgcHJvcCBpbiBGRExheW91dENvbnN0YW50cykge1xuICBDb1NFQ29uc3RhbnRzW3Byb3BdID0gRkRMYXlvdXRDb25zdGFudHNbcHJvcF07XG59XG5cbkNvU0VDb25zdGFudHMuREVGQVVMVF9VU0VfTVVMVElfTEVWRUxfU0NBTElORyA9IGZhbHNlO1xuQ29TRUNvbnN0YW50cy5ERUZBVUxUX1JBRElBTF9TRVBBUkFUSU9OID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSDtcbkNvU0VDb25zdGFudHMuREVGQVVMVF9DT01QT05FTlRfU0VQRVJBVElPTiA9IDYwO1xuQ29TRUNvbnN0YW50cy5USUxFID0gdHJ1ZTtcbkNvU0VDb25zdGFudHMuVElMSU5HX1BBRERJTkdfVkVSVElDQUwgPSAxMDtcbkNvU0VDb25zdGFudHMuVElMSU5HX1BBRERJTkdfSE9SSVpPTlRBTCA9IDEwO1xuQ29TRUNvbnN0YW50cy5UUkVFX1JFRFVDVElPTl9PTl9JTkNSRU1FTlRBTCA9IGZhbHNlOyAvLyBtYWtlIHRoaXMgdHJ1ZSB3aGVuIGNvc2UgaXMgdXNlZCBpbmNyZW1lbnRhbGx5IGFzIGEgcGFydCBvZiBvdGhlciBub24taW5jcmVtZW50YWwgbGF5b3V0XG5cbm1vZHVsZS5leHBvcnRzID0gQ29TRUNvbnN0YW50cztcblxuLyoqKi8gfSksXG4vKiAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBGRExheW91dEVkZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApLkZETGF5b3V0RWRnZTtcblxuZnVuY3Rpb24gQ29TRUVkZ2Uoc291cmNlLCB0YXJnZXQsIHZFZGdlKSB7XG4gIEZETGF5b3V0RWRnZS5jYWxsKHRoaXMsIHNvdXJjZSwgdGFyZ2V0LCB2RWRnZSk7XG59XG5cbkNvU0VFZGdlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRkRMYXlvdXRFZGdlLnByb3RvdHlwZSk7XG5mb3IgKHZhciBwcm9wIGluIEZETGF5b3V0RWRnZSkge1xuICBDb1NFRWRnZVtwcm9wXSA9IEZETGF5b3V0RWRnZVtwcm9wXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDb1NFRWRnZTtcblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBMR3JhcGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApLkxHcmFwaDtcblxuZnVuY3Rpb24gQ29TRUdyYXBoKHBhcmVudCwgZ3JhcGhNZ3IsIHZHcmFwaCkge1xuICBMR3JhcGguY2FsbCh0aGlzLCBwYXJlbnQsIGdyYXBoTWdyLCB2R3JhcGgpO1xufVxuXG5Db1NFR3JhcGgucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShMR3JhcGgucHJvdG90eXBlKTtcbmZvciAodmFyIHByb3AgaW4gTEdyYXBoKSB7XG4gIENvU0VHcmFwaFtwcm9wXSA9IExHcmFwaFtwcm9wXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDb1NFR3JhcGg7XG5cbi8qKiovIH0pLFxuLyogNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgTEdyYXBoTWFuYWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oMCkuTEdyYXBoTWFuYWdlcjtcblxuZnVuY3Rpb24gQ29TRUdyYXBoTWFuYWdlcihsYXlvdXQpIHtcbiAgTEdyYXBoTWFuYWdlci5jYWxsKHRoaXMsIGxheW91dCk7XG59XG5cbkNvU0VHcmFwaE1hbmFnZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShMR3JhcGhNYW5hZ2VyLnByb3RvdHlwZSk7XG5mb3IgKHZhciBwcm9wIGluIExHcmFwaE1hbmFnZXIpIHtcbiAgQ29TRUdyYXBoTWFuYWdlcltwcm9wXSA9IExHcmFwaE1hbmFnZXJbcHJvcF07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ29TRUdyYXBoTWFuYWdlcjtcblxuLyoqKi8gfSksXG4vKiA1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBGRExheW91dE5vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApLkZETGF5b3V0Tm9kZTtcbnZhciBJTWF0aCA9IF9fd2VicGFja19yZXF1aXJlX18oMCkuSU1hdGg7XG5cbmZ1bmN0aW9uIENvU0VOb2RlKGdtLCBsb2MsIHNpemUsIHZOb2RlKSB7XG4gIEZETGF5b3V0Tm9kZS5jYWxsKHRoaXMsIGdtLCBsb2MsIHNpemUsIHZOb2RlKTtcbn1cblxuQ29TRU5vZGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShGRExheW91dE5vZGUucHJvdG90eXBlKTtcbmZvciAodmFyIHByb3AgaW4gRkRMYXlvdXROb2RlKSB7XG4gIENvU0VOb2RlW3Byb3BdID0gRkRMYXlvdXROb2RlW3Byb3BdO1xufVxuXG5Db1NFTm9kZS5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxheW91dCA9IHRoaXMuZ3JhcGhNYW5hZ2VyLmdldExheW91dCgpO1xuICB0aGlzLmRpc3BsYWNlbWVudFggPSBsYXlvdXQuY29vbGluZ0ZhY3RvciAqICh0aGlzLnNwcmluZ0ZvcmNlWCArIHRoaXMucmVwdWxzaW9uRm9yY2VYICsgdGhpcy5ncmF2aXRhdGlvbkZvcmNlWCkgLyB0aGlzLm5vT2ZDaGlsZHJlbjtcbiAgdGhpcy5kaXNwbGFjZW1lbnRZID0gbGF5b3V0LmNvb2xpbmdGYWN0b3IgKiAodGhpcy5zcHJpbmdGb3JjZVkgKyB0aGlzLnJlcHVsc2lvbkZvcmNlWSArIHRoaXMuZ3Jhdml0YXRpb25Gb3JjZVkpIC8gdGhpcy5ub09mQ2hpbGRyZW47XG5cbiAgaWYgKE1hdGguYWJzKHRoaXMuZGlzcGxhY2VtZW50WCkgPiBsYXlvdXQuY29vbGluZ0ZhY3RvciAqIGxheW91dC5tYXhOb2RlRGlzcGxhY2VtZW50KSB7XG4gICAgdGhpcy5kaXNwbGFjZW1lbnRYID0gbGF5b3V0LmNvb2xpbmdGYWN0b3IgKiBsYXlvdXQubWF4Tm9kZURpc3BsYWNlbWVudCAqIElNYXRoLnNpZ24odGhpcy5kaXNwbGFjZW1lbnRYKTtcbiAgfVxuXG4gIGlmIChNYXRoLmFicyh0aGlzLmRpc3BsYWNlbWVudFkpID4gbGF5b3V0LmNvb2xpbmdGYWN0b3IgKiBsYXlvdXQubWF4Tm9kZURpc3BsYWNlbWVudCkge1xuICAgIHRoaXMuZGlzcGxhY2VtZW50WSA9IGxheW91dC5jb29saW5nRmFjdG9yICogbGF5b3V0Lm1heE5vZGVEaXNwbGFjZW1lbnQgKiBJTWF0aC5zaWduKHRoaXMuZGlzcGxhY2VtZW50WSk7XG4gIH1cblxuICAvLyBhIHNpbXBsZSBub2RlLCBqdXN0IG1vdmUgaXRcbiAgaWYgKHRoaXMuY2hpbGQgPT0gbnVsbCkge1xuICAgIHRoaXMubW92ZUJ5KHRoaXMuZGlzcGxhY2VtZW50WCwgdGhpcy5kaXNwbGFjZW1lbnRZKTtcbiAgfVxuICAvLyBhbiBlbXB0eSBjb21wb3VuZCBub2RlLCBhZ2FpbiBqdXN0IG1vdmUgaXRcbiAgZWxzZSBpZiAodGhpcy5jaGlsZC5nZXROb2RlcygpLmxlbmd0aCA9PSAwKSB7XG4gICAgICB0aGlzLm1vdmVCeSh0aGlzLmRpc3BsYWNlbWVudFgsIHRoaXMuZGlzcGxhY2VtZW50WSk7XG4gICAgfVxuICAgIC8vIG5vbi1lbXB0eSBjb21wb3VuZCBub2RlLCBwcm9wb2dhdGUgbW92ZW1lbnQgdG8gY2hpbGRyZW4gYXMgd2VsbFxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLnByb3BvZ2F0ZURpc3BsYWNlbWVudFRvQ2hpbGRyZW4odGhpcy5kaXNwbGFjZW1lbnRYLCB0aGlzLmRpc3BsYWNlbWVudFkpO1xuICAgICAgfVxuXG4gIGxheW91dC50b3RhbERpc3BsYWNlbWVudCArPSBNYXRoLmFicyh0aGlzLmRpc3BsYWNlbWVudFgpICsgTWF0aC5hYnModGhpcy5kaXNwbGFjZW1lbnRZKTtcblxuICB0aGlzLnNwcmluZ0ZvcmNlWCA9IDA7XG4gIHRoaXMuc3ByaW5nRm9yY2VZID0gMDtcbiAgdGhpcy5yZXB1bHNpb25Gb3JjZVggPSAwO1xuICB0aGlzLnJlcHVsc2lvbkZvcmNlWSA9IDA7XG4gIHRoaXMuZ3Jhdml0YXRpb25Gb3JjZVggPSAwO1xuICB0aGlzLmdyYXZpdGF0aW9uRm9yY2VZID0gMDtcbiAgdGhpcy5kaXNwbGFjZW1lbnRYID0gMDtcbiAgdGhpcy5kaXNwbGFjZW1lbnRZID0gMDtcbn07XG5cbkNvU0VOb2RlLnByb3RvdHlwZS5wcm9wb2dhdGVEaXNwbGFjZW1lbnRUb0NoaWxkcmVuID0gZnVuY3Rpb24gKGRYLCBkWSkge1xuICB2YXIgbm9kZXMgPSB0aGlzLmdldENoaWxkKCkuZ2V0Tm9kZXMoKTtcbiAgdmFyIG5vZGU7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBub2RlID0gbm9kZXNbaV07XG4gICAgaWYgKG5vZGUuZ2V0Q2hpbGQoKSA9PSBudWxsKSB7XG4gICAgICBub2RlLm1vdmVCeShkWCwgZFkpO1xuICAgICAgbm9kZS5kaXNwbGFjZW1lbnRYICs9IGRYO1xuICAgICAgbm9kZS5kaXNwbGFjZW1lbnRZICs9IGRZO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLnByb3BvZ2F0ZURpc3BsYWNlbWVudFRvQ2hpbGRyZW4oZFgsIGRZKTtcbiAgICB9XG4gIH1cbn07XG5cbkNvU0VOb2RlLnByb3RvdHlwZS5zZXRQcmVkMSA9IGZ1bmN0aW9uIChwcmVkMSkge1xuICB0aGlzLnByZWQxID0gcHJlZDE7XG59O1xuXG5Db1NFTm9kZS5wcm90b3R5cGUuZ2V0UHJlZDEgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBwcmVkMTtcbn07XG5cbkNvU0VOb2RlLnByb3RvdHlwZS5nZXRQcmVkMiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHByZWQyO1xufTtcblxuQ29TRU5vZGUucHJvdG90eXBlLnNldE5leHQgPSBmdW5jdGlvbiAobmV4dCkge1xuICB0aGlzLm5leHQgPSBuZXh0O1xufTtcblxuQ29TRU5vZGUucHJvdG90eXBlLmdldE5leHQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuZXh0O1xufTtcblxuQ29TRU5vZGUucHJvdG90eXBlLnNldFByb2Nlc3NlZCA9IGZ1bmN0aW9uIChwcm9jZXNzZWQpIHtcbiAgdGhpcy5wcm9jZXNzZWQgPSBwcm9jZXNzZWQ7XG59O1xuXG5Db1NFTm9kZS5wcm90b3R5cGUuaXNQcm9jZXNzZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBwcm9jZXNzZWQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvU0VOb2RlO1xuXG4vKioqLyB9KSxcbi8qIDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIEZETGF5b3V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKS5GRExheW91dDtcbnZhciBDb1NFR3JhcGhNYW5hZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcbnZhciBDb1NFR3JhcGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xudmFyIENvU0VOb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBDb1NFRWRnZSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG52YXIgQ29TRUNvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG52YXIgRkRMYXlvdXRDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApLkZETGF5b3V0Q29uc3RhbnRzO1xudmFyIExheW91dENvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oMCkuTGF5b3V0Q29uc3RhbnRzO1xudmFyIFBvaW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKS5Qb2ludDtcbnZhciBQb2ludEQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApLlBvaW50RDtcbnZhciBMYXlvdXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApLkxheW91dDtcbnZhciBJbnRlZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKS5JbnRlZ2VyO1xudmFyIElHZW9tZXRyeSA9IF9fd2VicGFja19yZXF1aXJlX18oMCkuSUdlb21ldHJ5O1xudmFyIExHcmFwaCA9IF9fd2VicGFja19yZXF1aXJlX18oMCkuTEdyYXBoO1xudmFyIFRyYW5zZm9ybSA9IF9fd2VicGFja19yZXF1aXJlX18oMCkuVHJhbnNmb3JtO1xuXG5mdW5jdGlvbiBDb1NFTGF5b3V0KCkge1xuICBGRExheW91dC5jYWxsKHRoaXMpO1xuXG4gIHRoaXMudG9CZVRpbGVkID0ge307IC8vIE1lbW9yaXplIGlmIGEgbm9kZSBpcyB0byBiZSB0aWxlZCBvciBpcyB0aWxlZFxufVxuXG5Db1NFTGF5b3V0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRkRMYXlvdXQucHJvdG90eXBlKTtcblxuZm9yICh2YXIgcHJvcCBpbiBGRExheW91dCkge1xuICBDb1NFTGF5b3V0W3Byb3BdID0gRkRMYXlvdXRbcHJvcF07XG59XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLm5ld0dyYXBoTWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGdtID0gbmV3IENvU0VHcmFwaE1hbmFnZXIodGhpcyk7XG4gIHRoaXMuZ3JhcGhNYW5hZ2VyID0gZ207XG4gIHJldHVybiBnbTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLm5ld0dyYXBoID0gZnVuY3Rpb24gKHZHcmFwaCkge1xuICByZXR1cm4gbmV3IENvU0VHcmFwaChudWxsLCB0aGlzLmdyYXBoTWFuYWdlciwgdkdyYXBoKTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLm5ld05vZGUgPSBmdW5jdGlvbiAodk5vZGUpIHtcbiAgcmV0dXJuIG5ldyBDb1NFTm9kZSh0aGlzLmdyYXBoTWFuYWdlciwgdk5vZGUpO1xufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUubmV3RWRnZSA9IGZ1bmN0aW9uICh2RWRnZSkge1xuICByZXR1cm4gbmV3IENvU0VFZGdlKG51bGwsIG51bGwsIHZFZGdlKTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLmluaXRQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkge1xuICBGRExheW91dC5wcm90b3R5cGUuaW5pdFBhcmFtZXRlcnMuY2FsbCh0aGlzLCBhcmd1bWVudHMpO1xuICBpZiAoIXRoaXMuaXNTdWJMYXlvdXQpIHtcbiAgICBpZiAoQ29TRUNvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIIDwgMTApIHtcbiAgICAgIHRoaXMuaWRlYWxFZGdlTGVuZ3RoID0gMTA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaWRlYWxFZGdlTGVuZ3RoID0gQ29TRUNvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIO1xuICAgIH1cblxuICAgIHRoaXMudXNlU21hcnRJZGVhbEVkZ2VMZW5ndGhDYWxjdWxhdGlvbiA9IENvU0VDb25zdGFudHMuREVGQVVMVF9VU0VfU01BUlRfSURFQUxfRURHRV9MRU5HVEhfQ0FMQ1VMQVRJT047XG4gICAgdGhpcy5zcHJpbmdDb25zdGFudCA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfU1BSSU5HX1NUUkVOR1RIO1xuICAgIHRoaXMucmVwdWxzaW9uQ29uc3RhbnQgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX1JFUFVMU0lPTl9TVFJFTkdUSDtcbiAgICB0aGlzLmdyYXZpdHlDb25zdGFudCA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfR1JBVklUWV9TVFJFTkdUSDtcbiAgICB0aGlzLmNvbXBvdW5kR3Jhdml0eUNvbnN0YW50ID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9DT01QT1VORF9HUkFWSVRZX1NUUkVOR1RIO1xuICAgIHRoaXMuZ3Jhdml0eVJhbmdlRmFjdG9yID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9HUkFWSVRZX1JBTkdFX0ZBQ1RPUjtcbiAgICB0aGlzLmNvbXBvdW5kR3Jhdml0eVJhbmdlRmFjdG9yID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9DT01QT1VORF9HUkFWSVRZX1JBTkdFX0ZBQ1RPUjtcblxuICAgIC8vIHZhcmlhYmxlcyBmb3IgdHJlZSByZWR1Y3Rpb24gc3VwcG9ydFxuICAgIHRoaXMucHJ1bmVkTm9kZXNBbGwgPSBbXTtcbiAgICB0aGlzLmdyb3dUcmVlSXRlcmF0aW9ucyA9IDA7XG4gICAgdGhpcy5hZnRlckdyb3d0aEl0ZXJhdGlvbnMgPSAwO1xuICAgIHRoaXMuaXNUcmVlR3Jvd2luZyA9IGZhbHNlO1xuICAgIHRoaXMuaXNHcm93dGhGaW5pc2hlZCA9IGZhbHNlO1xuXG4gICAgLy8gdmFyaWFibGVzIGZvciBjb29saW5nXG4gICAgdGhpcy5jb29saW5nQ3ljbGUgPSAwO1xuICAgIHRoaXMubWF4Q29vbGluZ0N5Y2xlID0gdGhpcy5tYXhJdGVyYXRpb25zIC8gRkRMYXlvdXRDb25zdGFudHMuQ09OVkVSR0VOQ0VfQ0hFQ0tfUEVSSU9EO1xuICAgIHRoaXMuZmluYWxUZW1wZXJhdHVyZSA9IEZETGF5b3V0Q29uc3RhbnRzLkNPTlZFUkdFTkNFX0NIRUNLX1BFUklPRCAvIHRoaXMubWF4SXRlcmF0aW9ucztcbiAgICB0aGlzLmNvb2xpbmdBZGp1c3RlciA9IDE7XG4gIH1cbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLmxheW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNyZWF0ZUJlbmRzQXNOZWVkZWQgPSBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9DUkVBVEVfQkVORFNfQVNfTkVFREVEO1xuICBpZiAoY3JlYXRlQmVuZHNBc05lZWRlZCkge1xuICAgIHRoaXMuY3JlYXRlQmVuZHBvaW50cygpO1xuICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnJlc2V0QWxsRWRnZXMoKTtcbiAgfVxuXG4gIHRoaXMubGV2ZWwgPSAwO1xuICByZXR1cm4gdGhpcy5jbGFzc2ljTGF5b3V0KCk7XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5jbGFzc2ljTGF5b3V0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLm5vZGVzV2l0aEdyYXZpdHkgPSB0aGlzLmNhbGN1bGF0ZU5vZGVzVG9BcHBseUdyYXZpdGF0aW9uVG8oKTtcbiAgdGhpcy5ncmFwaE1hbmFnZXIuc2V0QWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24odGhpcy5ub2Rlc1dpdGhHcmF2aXR5KTtcbiAgdGhpcy5jYWxjTm9PZkNoaWxkcmVuRm9yQWxsTm9kZXMoKTtcbiAgdGhpcy5ncmFwaE1hbmFnZXIuY2FsY0xvd2VzdENvbW1vbkFuY2VzdG9ycygpO1xuICB0aGlzLmdyYXBoTWFuYWdlci5jYWxjSW5jbHVzaW9uVHJlZURlcHRocygpO1xuICB0aGlzLmdyYXBoTWFuYWdlci5nZXRSb290KCkuY2FsY0VzdGltYXRlZFNpemUoKTtcbiAgdGhpcy5jYWxjSWRlYWxFZGdlTGVuZ3RocygpO1xuXG4gIGlmICghdGhpcy5pbmNyZW1lbnRhbCkge1xuICAgIHZhciBmb3Jlc3QgPSB0aGlzLmdldEZsYXRGb3Jlc3QoKTtcblxuICAgIC8vIFRoZSBncmFwaCBhc3NvY2lhdGVkIHdpdGggdGhpcyBsYXlvdXQgaXMgZmxhdCBhbmQgYSBmb3Jlc3RcbiAgICBpZiAoZm9yZXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMucG9zaXRpb25Ob2Rlc1JhZGlhbGx5KGZvcmVzdCk7XG4gICAgfVxuICAgIC8vIFRoZSBncmFwaCBhc3NvY2lhdGVkIHdpdGggdGhpcyBsYXlvdXQgaXMgbm90IGZsYXQgb3IgYSBmb3Jlc3RcbiAgICBlbHNlIHtcbiAgICAgICAgLy8gUmVkdWNlIHRoZSB0cmVlcyB3aGVuIGluY3JlbWVudGFsIG1vZGUgaXMgbm90IGVuYWJsZWQgYW5kIGdyYXBoIGlzIG5vdCBhIGZvcmVzdCBcbiAgICAgICAgdGhpcy5yZWR1Y2VUcmVlcygpO1xuICAgICAgICAvLyBVcGRhdGUgbm9kZXMgdGhhdCBncmF2aXR5IHdpbGwgYmUgYXBwbGllZFxuICAgICAgICB0aGlzLmdyYXBoTWFuYWdlci5yZXNldEFsbE5vZGVzVG9BcHBseUdyYXZpdGF0aW9uKCk7XG4gICAgICAgIHZhciBhbGxOb2RlcyA9IG5ldyBTZXQodGhpcy5nZXRBbGxOb2RlcygpKTtcbiAgICAgICAgdmFyIGludGVyc2VjdGlvbiA9IHRoaXMubm9kZXNXaXRoR3Jhdml0eS5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICByZXR1cm4gYWxsTm9kZXMuaGFzKHgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ncmFwaE1hbmFnZXIuc2V0QWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24oaW50ZXJzZWN0aW9uKTtcblxuICAgICAgICB0aGlzLnBvc2l0aW9uTm9kZXNSYW5kb21seSgpO1xuICAgICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChDb1NFQ29uc3RhbnRzLlRSRUVfUkVEVUNUSU9OX09OX0lOQ1JFTUVOVEFMKSB7XG4gICAgICAvLyBSZWR1Y2UgdGhlIHRyZWVzIGluIGluY3JlbWVudGFsIG1vZGUgaWYgb25seSB0aGlzIGNvbnN0YW50IGlzIHNldCB0byB0cnVlIFxuICAgICAgdGhpcy5yZWR1Y2VUcmVlcygpO1xuICAgICAgLy8gVXBkYXRlIG5vZGVzIHRoYXQgZ3Jhdml0eSB3aWxsIGJlIGFwcGxpZWRcbiAgICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnJlc2V0QWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24oKTtcbiAgICAgIHZhciBhbGxOb2RlcyA9IG5ldyBTZXQodGhpcy5nZXRBbGxOb2RlcygpKTtcbiAgICAgIHZhciBpbnRlcnNlY3Rpb24gPSB0aGlzLm5vZGVzV2l0aEdyYXZpdHkuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiBhbGxOb2Rlcy5oYXMoeCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnNldEFsbE5vZGVzVG9BcHBseUdyYXZpdGF0aW9uKGludGVyc2VjdGlvbik7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5pbml0U3ByaW5nRW1iZWRkZXIoKTtcbiAgdGhpcy5ydW5TcHJpbmdFbWJlZGRlcigpO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUudGljayA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy50b3RhbEl0ZXJhdGlvbnMrKztcblxuICBpZiAodGhpcy50b3RhbEl0ZXJhdGlvbnMgPT09IHRoaXMubWF4SXRlcmF0aW9ucyAmJiAhdGhpcy5pc1RyZWVHcm93aW5nICYmICF0aGlzLmlzR3Jvd3RoRmluaXNoZWQpIHtcbiAgICBpZiAodGhpcy5wcnVuZWROb2Rlc0FsbC5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmlzVHJlZUdyb3dpbmcgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy50b3RhbEl0ZXJhdGlvbnMgJSBGRExheW91dENvbnN0YW50cy5DT05WRVJHRU5DRV9DSEVDS19QRVJJT0QgPT0gMCAmJiAhdGhpcy5pc1RyZWVHcm93aW5nICYmICF0aGlzLmlzR3Jvd3RoRmluaXNoZWQpIHtcbiAgICBpZiAodGhpcy5pc0NvbnZlcmdlZCgpKSB7XG4gICAgICBpZiAodGhpcy5wcnVuZWROb2Rlc0FsbC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuaXNUcmVlR3Jvd2luZyA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmNvb2xpbmdDeWNsZSsrO1xuXG4gICAgaWYgKHRoaXMubGF5b3V0UXVhbGl0eSA9PSAwKSB7XG4gICAgICAvLyBxdWFsaXR5IC0gXCJkcmFmdFwiXG4gICAgICB0aGlzLmNvb2xpbmdBZGp1c3RlciA9IHRoaXMuY29vbGluZ0N5Y2xlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5sYXlvdXRRdWFsaXR5ID09IDEpIHtcbiAgICAgIC8vIHF1YWxpdHkgLSBcImRlZmF1bHRcIlxuICAgICAgdGhpcy5jb29saW5nQWRqdXN0ZXIgPSB0aGlzLmNvb2xpbmdDeWNsZSAvIDM7XG4gICAgfVxuXG4gICAgLy8gY29vbGluZyBzY2hlZHVsZSBpcyBiYXNlZCBvbiBodHRwOi8vd3d3LmJ0bHVrZS5jb20vc2ltYW5mMS5odG1sIC0+IGNvb2xpbmcgc2NoZWR1bGUgM1xuICAgIHRoaXMuY29vbGluZ0ZhY3RvciA9IE1hdGgubWF4KHRoaXMuaW5pdGlhbENvb2xpbmdGYWN0b3IgLSBNYXRoLnBvdyh0aGlzLmNvb2xpbmdDeWNsZSwgTWF0aC5sb2coMTAwICogKHRoaXMuaW5pdGlhbENvb2xpbmdGYWN0b3IgLSB0aGlzLmZpbmFsVGVtcGVyYXR1cmUpKSAvIE1hdGgubG9nKHRoaXMubWF4Q29vbGluZ0N5Y2xlKSkgLyAxMDAgKiB0aGlzLmNvb2xpbmdBZGp1c3RlciwgdGhpcy5maW5hbFRlbXBlcmF0dXJlKTtcbiAgICB0aGlzLmFuaW1hdGlvblBlcmlvZCA9IE1hdGguY2VpbCh0aGlzLmluaXRpYWxBbmltYXRpb25QZXJpb2QgKiBNYXRoLnNxcnQodGhpcy5jb29saW5nRmFjdG9yKSk7XG4gIH1cbiAgLy8gT3BlcmF0aW9ucyB3aGlsZSB0cmVlIGlzIGdyb3dpbmcgYWdhaW4gXG4gIGlmICh0aGlzLmlzVHJlZUdyb3dpbmcpIHtcbiAgICBpZiAodGhpcy5ncm93VHJlZUl0ZXJhdGlvbnMgJSAxMCA9PSAwKSB7XG4gICAgICBpZiAodGhpcy5wcnVuZWROb2Rlc0FsbC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnVwZGF0ZUJvdW5kcygpO1xuICAgICAgICB0aGlzLnVwZGF0ZUdyaWQoKTtcbiAgICAgICAgdGhpcy5ncm93VHJlZSh0aGlzLnBydW5lZE5vZGVzQWxsKTtcbiAgICAgICAgLy8gVXBkYXRlIG5vZGVzIHRoYXQgZ3Jhdml0eSB3aWxsIGJlIGFwcGxpZWRcbiAgICAgICAgdGhpcy5ncmFwaE1hbmFnZXIucmVzZXRBbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbigpO1xuICAgICAgICB2YXIgYWxsTm9kZXMgPSBuZXcgU2V0KHRoaXMuZ2V0QWxsTm9kZXMoKSk7XG4gICAgICAgIHZhciBpbnRlcnNlY3Rpb24gPSB0aGlzLm5vZGVzV2l0aEdyYXZpdHkuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgcmV0dXJuIGFsbE5vZGVzLmhhcyh4KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnNldEFsbE5vZGVzVG9BcHBseUdyYXZpdGF0aW9uKGludGVyc2VjdGlvbik7XG5cbiAgICAgICAgdGhpcy5ncmFwaE1hbmFnZXIudXBkYXRlQm91bmRzKCk7XG4gICAgICAgIHRoaXMudXBkYXRlR3JpZCgpO1xuICAgICAgICB0aGlzLmNvb2xpbmdGYWN0b3IgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0NPT0xJTkdfRkFDVE9SX0lOQ1JFTUVOVEFMO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5pc1RyZWVHcm93aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNHcm93dGhGaW5pc2hlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZ3Jvd1RyZWVJdGVyYXRpb25zKys7XG4gIH1cbiAgLy8gT3BlcmF0aW9ucyBhZnRlciBncm93dGggaXMgZmluaXNoZWRcbiAgaWYgKHRoaXMuaXNHcm93dGhGaW5pc2hlZCkge1xuICAgIGlmICh0aGlzLmlzQ29udmVyZ2VkKCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy5hZnRlckdyb3d0aEl0ZXJhdGlvbnMgJSAxMCA9PSAwKSB7XG4gICAgICB0aGlzLmdyYXBoTWFuYWdlci51cGRhdGVCb3VuZHMoKTtcbiAgICAgIHRoaXMudXBkYXRlR3JpZCgpO1xuICAgIH1cbiAgICB0aGlzLmNvb2xpbmdGYWN0b3IgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0NPT0xJTkdfRkFDVE9SX0lOQ1JFTUVOVEFMICogKCgxMDAgLSB0aGlzLmFmdGVyR3Jvd3RoSXRlcmF0aW9ucykgLyAxMDApO1xuICAgIHRoaXMuYWZ0ZXJHcm93dGhJdGVyYXRpb25zKys7XG4gIH1cblxuICB2YXIgZ3JpZFVwZGF0ZUFsbG93ZWQgPSAhdGhpcy5pc1RyZWVHcm93aW5nICYmICF0aGlzLmlzR3Jvd3RoRmluaXNoZWQ7XG4gIHZhciBmb3JjZVRvTm9kZVN1cnJvdW5kaW5nVXBkYXRlID0gdGhpcy5ncm93VHJlZUl0ZXJhdGlvbnMgJSAxMCA9PSAxICYmIHRoaXMuaXNUcmVlR3Jvd2luZyB8fCB0aGlzLmFmdGVyR3Jvd3RoSXRlcmF0aW9ucyAlIDEwID09IDEgJiYgdGhpcy5pc0dyb3d0aEZpbmlzaGVkO1xuXG4gIHRoaXMudG90YWxEaXNwbGFjZW1lbnQgPSAwO1xuICB0aGlzLmdyYXBoTWFuYWdlci51cGRhdGVCb3VuZHMoKTtcbiAgdGhpcy5jYWxjU3ByaW5nRm9yY2VzKCk7XG4gIHRoaXMuY2FsY1JlcHVsc2lvbkZvcmNlcyhncmlkVXBkYXRlQWxsb3dlZCwgZm9yY2VUb05vZGVTdXJyb3VuZGluZ1VwZGF0ZSk7XG4gIHRoaXMuY2FsY0dyYXZpdGF0aW9uYWxGb3JjZXMoKTtcbiAgdGhpcy5tb3ZlTm9kZXMoKTtcbiAgdGhpcy5hbmltYXRlKCk7XG5cbiAgcmV0dXJuIGZhbHNlOyAvLyBMYXlvdXQgaXMgbm90IGVuZGVkIHlldCByZXR1cm4gZmFsc2Vcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLmdldFBvc2l0aW9uc0RhdGEgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBhbGxOb2RlcyA9IHRoaXMuZ3JhcGhNYW5hZ2VyLmdldEFsbE5vZGVzKCk7XG4gIHZhciBwRGF0YSA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHJlY3QgPSBhbGxOb2Rlc1tpXS5yZWN0O1xuICAgIHZhciBpZCA9IGFsbE5vZGVzW2ldLmlkO1xuICAgIHBEYXRhW2lkXSA9IHtcbiAgICAgIGlkOiBpZCxcbiAgICAgIHg6IHJlY3QuZ2V0Q2VudGVyWCgpLFxuICAgICAgeTogcmVjdC5nZXRDZW50ZXJZKCksXG4gICAgICB3OiByZWN0LndpZHRoLFxuICAgICAgaDogcmVjdC5oZWlnaHRcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHBEYXRhO1xufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUucnVuU3ByaW5nRW1iZWRkZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuaW5pdGlhbEFuaW1hdGlvblBlcmlvZCA9IDI1O1xuICB0aGlzLmFuaW1hdGlvblBlcmlvZCA9IHRoaXMuaW5pdGlhbEFuaW1hdGlvblBlcmlvZDtcbiAgdmFyIGxheW91dEVuZGVkID0gZmFsc2U7XG5cbiAgLy8gSWYgYW1pbmF0ZSBvcHRpb24gaXMgJ2R1cmluZycgc2lnbmFsIHRoYXQgbGF5b3V0IGlzIHN1cHBvc2VkIHRvIHN0YXJ0IGl0ZXJhdGluZ1xuICBpZiAoRkRMYXlvdXRDb25zdGFudHMuQU5JTUFURSA9PT0gJ2R1cmluZycpIHtcbiAgICB0aGlzLmVtaXQoJ2xheW91dHN0YXJ0ZWQnKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBJZiBhbWluYXRlIG9wdGlvbiBpcyAnZHVyaW5nJyB0aWNrKCkgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgb24gaW5kZXguanNcbiAgICB3aGlsZSAoIWxheW91dEVuZGVkKSB7XG4gICAgICBsYXlvdXRFbmRlZCA9IHRoaXMudGljaygpO1xuICAgIH1cblxuICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnVwZGF0ZUJvdW5kcygpO1xuICB9XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5jYWxjdWxhdGVOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvblRvID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm9kZUxpc3QgPSBbXTtcbiAgdmFyIGdyYXBoO1xuXG4gIHZhciBncmFwaHMgPSB0aGlzLmdyYXBoTWFuYWdlci5nZXRHcmFwaHMoKTtcbiAgdmFyIHNpemUgPSBncmFwaHMubGVuZ3RoO1xuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgIGdyYXBoID0gZ3JhcGhzW2ldO1xuXG4gICAgZ3JhcGgudXBkYXRlQ29ubmVjdGVkKCk7XG5cbiAgICBpZiAoIWdyYXBoLmlzQ29ubmVjdGVkKSB7XG4gICAgICBub2RlTGlzdCA9IG5vZGVMaXN0LmNvbmNhdChncmFwaC5nZXROb2RlcygpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbm9kZUxpc3Q7XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5jcmVhdGVCZW5kcG9pbnRzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZWRnZXMgPSBbXTtcbiAgZWRnZXMgPSBlZGdlcy5jb25jYXQodGhpcy5ncmFwaE1hbmFnZXIuZ2V0QWxsRWRnZXMoKSk7XG4gIHZhciB2aXNpdGVkID0gbmV3IFNldCgpO1xuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVkZ2UgPSBlZGdlc1tpXTtcblxuICAgIGlmICghdmlzaXRlZC5oYXMoZWRnZSkpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBlZGdlLmdldFNvdXJjZSgpO1xuICAgICAgdmFyIHRhcmdldCA9IGVkZ2UuZ2V0VGFyZ2V0KCk7XG5cbiAgICAgIGlmIChzb3VyY2UgPT0gdGFyZ2V0KSB7XG4gICAgICAgIGVkZ2UuZ2V0QmVuZHBvaW50cygpLnB1c2gobmV3IFBvaW50RCgpKTtcbiAgICAgICAgZWRnZS5nZXRCZW5kcG9pbnRzKCkucHVzaChuZXcgUG9pbnREKCkpO1xuICAgICAgICB0aGlzLmNyZWF0ZUR1bW15Tm9kZXNGb3JCZW5kcG9pbnRzKGVkZ2UpO1xuICAgICAgICB2aXNpdGVkLmFkZChlZGdlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBlZGdlTGlzdCA9IFtdO1xuXG4gICAgICAgIGVkZ2VMaXN0ID0gZWRnZUxpc3QuY29uY2F0KHNvdXJjZS5nZXRFZGdlTGlzdFRvTm9kZSh0YXJnZXQpKTtcbiAgICAgICAgZWRnZUxpc3QgPSBlZGdlTGlzdC5jb25jYXQodGFyZ2V0LmdldEVkZ2VMaXN0VG9Ob2RlKHNvdXJjZSkpO1xuXG4gICAgICAgIGlmICghdmlzaXRlZC5oYXMoZWRnZUxpc3RbMF0pKSB7XG4gICAgICAgICAgaWYgKGVkZ2VMaXN0Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHZhciBrO1xuICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IGVkZ2VMaXN0Lmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgIHZhciBtdWx0aUVkZ2UgPSBlZGdlTGlzdFtrXTtcbiAgICAgICAgICAgICAgbXVsdGlFZGdlLmdldEJlbmRwb2ludHMoKS5wdXNoKG5ldyBQb2ludEQoKSk7XG4gICAgICAgICAgICAgIHRoaXMuY3JlYXRlRHVtbXlOb2Rlc0ZvckJlbmRwb2ludHMobXVsdGlFZGdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWRnZUxpc3QuZm9yRWFjaChmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICAgICAgdmlzaXRlZC5hZGQoZWRnZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodmlzaXRlZC5zaXplID09IGVkZ2VzLmxlbmd0aCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5wb3NpdGlvbk5vZGVzUmFkaWFsbHkgPSBmdW5jdGlvbiAoZm9yZXN0KSB7XG4gIC8vIFdlIHRpbGUgdGhlIHRyZWVzIHRvIGEgZ3JpZCByb3cgYnkgcm93OyBmaXJzdCB0cmVlIHN0YXJ0cyBhdCAoMCwwKVxuICB2YXIgY3VycmVudFN0YXJ0aW5nUG9pbnQgPSBuZXcgUG9pbnQoMCwgMCk7XG4gIHZhciBudW1iZXJPZkNvbHVtbnMgPSBNYXRoLmNlaWwoTWF0aC5zcXJ0KGZvcmVzdC5sZW5ndGgpKTtcbiAgdmFyIGhlaWdodCA9IDA7XG4gIHZhciBjdXJyZW50WSA9IDA7XG4gIHZhciBjdXJyZW50WCA9IDA7XG4gIHZhciBwb2ludCA9IG5ldyBQb2ludEQoMCwgMCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb3Jlc3QubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaSAlIG51bWJlck9mQ29sdW1ucyA9PSAwKSB7XG4gICAgICAvLyBTdGFydCBvZiBhIG5ldyByb3csIG1ha2UgdGhlIHggY29vcmRpbmF0ZSAwLCBpbmNyZW1lbnQgdGhlXG4gICAgICAvLyB5IGNvb3JkaW5hdGUgd2l0aCB0aGUgbWF4IGhlaWdodCBvZiB0aGUgcHJldmlvdXMgcm93XG4gICAgICBjdXJyZW50WCA9IDA7XG4gICAgICBjdXJyZW50WSA9IGhlaWdodDtcblxuICAgICAgaWYgKGkgIT0gMCkge1xuICAgICAgICBjdXJyZW50WSArPSBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfQ09NUE9ORU5UX1NFUEVSQVRJT047XG4gICAgICB9XG5cbiAgICAgIGhlaWdodCA9IDA7XG4gICAgfVxuXG4gICAgdmFyIHRyZWUgPSBmb3Jlc3RbaV07XG5cbiAgICAvLyBGaW5kIHRoZSBjZW50ZXIgb2YgdGhlIHRyZWVcbiAgICB2YXIgY2VudGVyTm9kZSA9IExheW91dC5maW5kQ2VudGVyT2ZUcmVlKHRyZWUpO1xuXG4gICAgLy8gU2V0IHRoZSBzdGFyaW5nIHBvaW50IG9mIHRoZSBuZXh0IHRyZWVcbiAgICBjdXJyZW50U3RhcnRpbmdQb2ludC54ID0gY3VycmVudFg7XG4gICAgY3VycmVudFN0YXJ0aW5nUG9pbnQueSA9IGN1cnJlbnRZO1xuXG4gICAgLy8gRG8gYSByYWRpYWwgbGF5b3V0IHN0YXJ0aW5nIHdpdGggdGhlIGNlbnRlclxuICAgIHBvaW50ID0gQ29TRUxheW91dC5yYWRpYWxMYXlvdXQodHJlZSwgY2VudGVyTm9kZSwgY3VycmVudFN0YXJ0aW5nUG9pbnQpO1xuXG4gICAgaWYgKHBvaW50LnkgPiBoZWlnaHQpIHtcbiAgICAgIGhlaWdodCA9IE1hdGguZmxvb3IocG9pbnQueSk7XG4gICAgfVxuXG4gICAgY3VycmVudFggPSBNYXRoLmZsb29yKHBvaW50LnggKyBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfQ09NUE9ORU5UX1NFUEVSQVRJT04pO1xuICB9XG5cbiAgdGhpcy50cmFuc2Zvcm0obmV3IFBvaW50RChMYXlvdXRDb25zdGFudHMuV09STERfQ0VOVEVSX1ggLSBwb2ludC54IC8gMiwgTGF5b3V0Q29uc3RhbnRzLldPUkxEX0NFTlRFUl9ZIC0gcG9pbnQueSAvIDIpKTtcbn07XG5cbkNvU0VMYXlvdXQucmFkaWFsTGF5b3V0ID0gZnVuY3Rpb24gKHRyZWUsIGNlbnRlck5vZGUsIHN0YXJ0aW5nUG9pbnQpIHtcbiAgdmFyIHJhZGlhbFNlcCA9IE1hdGgubWF4KHRoaXMubWF4RGlhZ29uYWxJblRyZWUodHJlZSksIENvU0VDb25zdGFudHMuREVGQVVMVF9SQURJQUxfU0VQQVJBVElPTik7XG4gIENvU0VMYXlvdXQuYnJhbmNoUmFkaWFsTGF5b3V0KGNlbnRlck5vZGUsIG51bGwsIDAsIDM1OSwgMCwgcmFkaWFsU2VwKTtcbiAgdmFyIGJvdW5kcyA9IExHcmFwaC5jYWxjdWxhdGVCb3VuZHModHJlZSk7XG5cbiAgdmFyIHRyYW5zZm9ybSA9IG5ldyBUcmFuc2Zvcm0oKTtcbiAgdHJhbnNmb3JtLnNldERldmljZU9yZ1goYm91bmRzLmdldE1pblgoKSk7XG4gIHRyYW5zZm9ybS5zZXREZXZpY2VPcmdZKGJvdW5kcy5nZXRNaW5ZKCkpO1xuICB0cmFuc2Zvcm0uc2V0V29ybGRPcmdYKHN0YXJ0aW5nUG9pbnQueCk7XG4gIHRyYW5zZm9ybS5zZXRXb3JsZE9yZ1koc3RhcnRpbmdQb2ludC55KTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRyZWUubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbm9kZSA9IHRyZWVbaV07XG4gICAgbm9kZS50cmFuc2Zvcm0odHJhbnNmb3JtKTtcbiAgfVxuXG4gIHZhciBib3R0b21SaWdodCA9IG5ldyBQb2ludEQoYm91bmRzLmdldE1heFgoKSwgYm91bmRzLmdldE1heFkoKSk7XG5cbiAgcmV0dXJuIHRyYW5zZm9ybS5pbnZlcnNlVHJhbnNmb3JtUG9pbnQoYm90dG9tUmlnaHQpO1xufTtcblxuQ29TRUxheW91dC5icmFuY2hSYWRpYWxMYXlvdXQgPSBmdW5jdGlvbiAobm9kZSwgcGFyZW50T2ZOb2RlLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgZGlzdGFuY2UsIHJhZGlhbFNlcGFyYXRpb24pIHtcbiAgLy8gRmlyc3QsIHBvc2l0aW9uIHRoaXMgbm9kZSBieSBmaW5kaW5nIGl0cyBhbmdsZS5cbiAgdmFyIGhhbGZJbnRlcnZhbCA9IChlbmRBbmdsZSAtIHN0YXJ0QW5nbGUgKyAxKSAvIDI7XG5cbiAgaWYgKGhhbGZJbnRlcnZhbCA8IDApIHtcbiAgICBoYWxmSW50ZXJ2YWwgKz0gMTgwO1xuICB9XG5cbiAgdmFyIG5vZGVBbmdsZSA9IChoYWxmSW50ZXJ2YWwgKyBzdGFydEFuZ2xlKSAlIDM2MDtcbiAgdmFyIHRldGEgPSBub2RlQW5nbGUgKiBJR2VvbWV0cnkuVFdPX1BJIC8gMzYwO1xuXG4gIC8vIE1ha2UgcG9sYXIgdG8gamF2YSBjb3JkaW5hdGUgY29udmVyc2lvbi5cbiAgdmFyIGNvc190ZXRhID0gTWF0aC5jb3ModGV0YSk7XG4gIHZhciB4XyA9IGRpc3RhbmNlICogTWF0aC5jb3ModGV0YSk7XG4gIHZhciB5XyA9IGRpc3RhbmNlICogTWF0aC5zaW4odGV0YSk7XG5cbiAgbm9kZS5zZXRDZW50ZXIoeF8sIHlfKTtcblxuICAvLyBUcmF2ZXJzZSBhbGwgbmVpZ2hib3JzIG9mIHRoaXMgbm9kZSBhbmQgcmVjdXJzaXZlbHkgY2FsbCB0aGlzXG4gIC8vIGZ1bmN0aW9uLlxuICB2YXIgbmVpZ2hib3JFZGdlcyA9IFtdO1xuICBuZWlnaGJvckVkZ2VzID0gbmVpZ2hib3JFZGdlcy5jb25jYXQobm9kZS5nZXRFZGdlcygpKTtcbiAgdmFyIGNoaWxkQ291bnQgPSBuZWlnaGJvckVkZ2VzLmxlbmd0aDtcblxuICBpZiAocGFyZW50T2ZOb2RlICE9IG51bGwpIHtcbiAgICBjaGlsZENvdW50LS07XG4gIH1cblxuICB2YXIgYnJhbmNoQ291bnQgPSAwO1xuXG4gIHZhciBpbmNFZGdlc0NvdW50ID0gbmVpZ2hib3JFZGdlcy5sZW5ndGg7XG4gIHZhciBzdGFydEluZGV4O1xuXG4gIHZhciBlZGdlcyA9IG5vZGUuZ2V0RWRnZXNCZXR3ZWVuKHBhcmVudE9mTm9kZSk7XG5cbiAgLy8gSWYgdGhlcmUgYXJlIG11bHRpcGxlIGVkZ2VzLCBwcnVuZSB0aGVtIHVudGlsIHRoZXJlIHJlbWFpbnMgb25seSBvbmVcbiAgLy8gZWRnZS5cbiAgd2hpbGUgKGVkZ2VzLmxlbmd0aCA+IDEpIHtcbiAgICAvL25laWdoYm9yRWRnZXMucmVtb3ZlKGVkZ2VzLnJlbW92ZSgwKSk7XG4gICAgdmFyIHRlbXAgPSBlZGdlc1swXTtcbiAgICBlZGdlcy5zcGxpY2UoMCwgMSk7XG4gICAgdmFyIGluZGV4ID0gbmVpZ2hib3JFZGdlcy5pbmRleE9mKHRlbXApO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICBuZWlnaGJvckVkZ2VzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICAgIGluY0VkZ2VzQ291bnQtLTtcbiAgICBjaGlsZENvdW50LS07XG4gIH1cblxuICBpZiAocGFyZW50T2ZOb2RlICE9IG51bGwpIHtcbiAgICAvL2Fzc2VydCBlZGdlcy5sZW5ndGggPT0gMTtcbiAgICBzdGFydEluZGV4ID0gKG5laWdoYm9yRWRnZXMuaW5kZXhPZihlZGdlc1swXSkgKyAxKSAlIGluY0VkZ2VzQ291bnQ7XG4gIH0gZWxzZSB7XG4gICAgc3RhcnRJbmRleCA9IDA7XG4gIH1cblxuICB2YXIgc3RlcEFuZ2xlID0gTWF0aC5hYnMoZW5kQW5nbGUgLSBzdGFydEFuZ2xlKSAvIGNoaWxkQ291bnQ7XG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGJyYW5jaENvdW50ICE9IGNoaWxkQ291bnQ7IGkgPSArK2kgJSBpbmNFZGdlc0NvdW50KSB7XG4gICAgdmFyIGN1cnJlbnROZWlnaGJvciA9IG5laWdoYm9yRWRnZXNbaV0uZ2V0T3RoZXJFbmQobm9kZSk7XG5cbiAgICAvLyBEb24ndCBiYWNrIHRyYXZlcnNlIHRvIHJvb3Qgbm9kZSBpbiBjdXJyZW50IHRyZWUuXG4gICAgaWYgKGN1cnJlbnROZWlnaGJvciA9PSBwYXJlbnRPZk5vZGUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBjaGlsZFN0YXJ0QW5nbGUgPSAoc3RhcnRBbmdsZSArIGJyYW5jaENvdW50ICogc3RlcEFuZ2xlKSAlIDM2MDtcbiAgICB2YXIgY2hpbGRFbmRBbmdsZSA9IChjaGlsZFN0YXJ0QW5nbGUgKyBzdGVwQW5nbGUpICUgMzYwO1xuXG4gICAgQ29TRUxheW91dC5icmFuY2hSYWRpYWxMYXlvdXQoY3VycmVudE5laWdoYm9yLCBub2RlLCBjaGlsZFN0YXJ0QW5nbGUsIGNoaWxkRW5kQW5nbGUsIGRpc3RhbmNlICsgcmFkaWFsU2VwYXJhdGlvbiwgcmFkaWFsU2VwYXJhdGlvbik7XG5cbiAgICBicmFuY2hDb3VudCsrO1xuICB9XG59O1xuXG5Db1NFTGF5b3V0Lm1heERpYWdvbmFsSW5UcmVlID0gZnVuY3Rpb24gKHRyZWUpIHtcbiAgdmFyIG1heERpYWdvbmFsID0gSW50ZWdlci5NSU5fVkFMVUU7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVlLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5vZGUgPSB0cmVlW2ldO1xuICAgIHZhciBkaWFnb25hbCA9IG5vZGUuZ2V0RGlhZ29uYWwoKTtcblxuICAgIGlmIChkaWFnb25hbCA+IG1heERpYWdvbmFsKSB7XG4gICAgICBtYXhEaWFnb25hbCA9IGRpYWdvbmFsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYXhEaWFnb25hbDtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLmNhbGNSZXB1bHNpb25SYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gZm9ybXVsYSBpcyAyIHggKGxldmVsICsgMSkgeCBpZGVhbEVkZ2VMZW5ndGhcbiAgcmV0dXJuIDIgKiAodGhpcy5sZXZlbCArIDEpICogdGhpcy5pZGVhbEVkZ2VMZW5ndGg7XG59O1xuXG4vLyBUaWxpbmcgbWV0aG9kc1xuXG4vLyBHcm91cCB6ZXJvIGRlZ3JlZSBtZW1iZXJzIHdob3NlIHBhcmVudHMgYXJlIG5vdCB0byBiZSB0aWxlZCwgY3JlYXRlIGR1bW15IHBhcmVudHMgd2hlcmUgbmVlZGVkIGFuZCBmaWxsIG1lbWJlckdyb3VwcyBieSB0aGVpciBkdW1tcCBwYXJlbnQgaWQnc1xuQ29TRUxheW91dC5wcm90b3R5cGUuZ3JvdXBaZXJvRGVncmVlTWVtYmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICAvLyBhcnJheSBvZiBbcGFyZW50X2lkIHggb25lRGVncmVlTm9kZV9pZF1cbiAgdmFyIHRlbXBNZW1iZXJHcm91cHMgPSB7fTsgLy8gQSB0ZW1wb3JhcnkgbWFwIG9mIHBhcmVudCBub2RlIGFuZCBpdHMgemVybyBkZWdyZWUgbWVtYmVyc1xuICB0aGlzLm1lbWJlckdyb3VwcyA9IHt9OyAvLyBBIG1hcCBvZiBkdW1teSBwYXJlbnQgbm9kZSBhbmQgaXRzIHplcm8gZGVncmVlIG1lbWJlcnMgd2hvc2UgcGFyZW50cyBhcmUgbm90IHRvIGJlIHRpbGVkXG4gIHRoaXMuaWRUb0R1bW15Tm9kZSA9IHt9OyAvLyBBIG1hcCBvZiBpZCB0byBkdW1teSBub2RlIFxuXG4gIHZhciB6ZXJvRGVncmVlID0gW107IC8vIExpc3Qgb2YgemVybyBkZWdyZWUgbm9kZXMgd2hvc2UgcGFyZW50cyBhcmUgbm90IHRvIGJlIHRpbGVkXG4gIHZhciBhbGxOb2RlcyA9IHRoaXMuZ3JhcGhNYW5hZ2VyLmdldEFsbE5vZGVzKCk7XG5cbiAgLy8gRmlsbCB6ZXJvIGRlZ3JlZSBsaXN0XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbm9kZSA9IGFsbE5vZGVzW2ldO1xuICAgIHZhciBwYXJlbnQgPSBub2RlLmdldFBhcmVudCgpO1xuICAgIC8vIElmIGEgbm9kZSBoYXMgemVybyBkZWdyZWUgYW5kIGl0cyBwYXJlbnQgaXMgbm90IHRvIGJlIHRpbGVkIGlmIGV4aXN0cyBhZGQgdGhhdCBub2RlIHRvIHplcm9EZWdyZXMgbGlzdFxuICAgIGlmICh0aGlzLmdldE5vZGVEZWdyZWVXaXRoQ2hpbGRyZW4obm9kZSkgPT09IDAgJiYgKHBhcmVudC5pZCA9PSB1bmRlZmluZWQgfHwgIXRoaXMuZ2V0VG9CZVRpbGVkKHBhcmVudCkpKSB7XG4gICAgICB6ZXJvRGVncmVlLnB1c2gobm9kZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gQ3JlYXRlIGEgbWFwIG9mIHBhcmVudCBub2RlIGFuZCBpdHMgemVybyBkZWdyZWUgbWVtYmVyc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHplcm9EZWdyZWUubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbm9kZSA9IHplcm9EZWdyZWVbaV07IC8vIFplcm8gZGVncmVlIG5vZGUgaXRzZWxmXG4gICAgdmFyIHBfaWQgPSBub2RlLmdldFBhcmVudCgpLmlkOyAvLyBQYXJlbnQgaWRcblxuICAgIGlmICh0eXBlb2YgdGVtcE1lbWJlckdyb3Vwc1twX2lkXSA9PT0gXCJ1bmRlZmluZWRcIikgdGVtcE1lbWJlckdyb3Vwc1twX2lkXSA9IFtdO1xuXG4gICAgdGVtcE1lbWJlckdyb3Vwc1twX2lkXSA9IHRlbXBNZW1iZXJHcm91cHNbcF9pZF0uY29uY2F0KG5vZGUpOyAvLyBQdXNoIG5vZGUgdG8gdGhlIGxpc3QgYmVsb25ncyB0byBpdHMgcGFyZW50IGluIHRlbXBNZW1iZXJHcm91cHNcbiAgfVxuXG4gIC8vIElmIHRoZXJlIGFyZSBhdCBsZWFzdCB0d28gbm9kZXMgYXQgYSBsZXZlbCwgY3JlYXRlIGEgZHVtbXkgY29tcG91bmQgZm9yIHRoZW1cbiAgT2JqZWN0LmtleXModGVtcE1lbWJlckdyb3VwcykuZm9yRWFjaChmdW5jdGlvbiAocF9pZCkge1xuICAgIGlmICh0ZW1wTWVtYmVyR3JvdXBzW3BfaWRdLmxlbmd0aCA+IDEpIHtcbiAgICAgIHZhciBkdW1teUNvbXBvdW5kSWQgPSBcIkR1bW15Q29tcG91bmRfXCIgKyBwX2lkOyAvLyBUaGUgaWQgb2YgZHVtbXkgY29tcG91bmQgd2hpY2ggd2lsbCBiZSBjcmVhdGVkIHNvb25cbiAgICAgIHNlbGYubWVtYmVyR3JvdXBzW2R1bW15Q29tcG91bmRJZF0gPSB0ZW1wTWVtYmVyR3JvdXBzW3BfaWRdOyAvLyBBZGQgZHVtbXkgY29tcG91bmQgdG8gbWVtYmVyR3JvdXBzXG5cbiAgICAgIHZhciBwYXJlbnQgPSB0ZW1wTWVtYmVyR3JvdXBzW3BfaWRdWzBdLmdldFBhcmVudCgpOyAvLyBUaGUgcGFyZW50IG9mIHplcm8gZGVncmVlIG5vZGVzIHdpbGwgYmUgdGhlIHBhcmVudCBvZiBuZXcgZHVtbXkgY29tcG91bmRcblxuICAgICAgLy8gQ3JlYXRlIGEgZHVtbXkgY29tcG91bmQgd2l0aCBjYWxjdWxhdGVkIGlkXG4gICAgICB2YXIgZHVtbXlDb21wb3VuZCA9IG5ldyBDb1NFTm9kZShzZWxmLmdyYXBoTWFuYWdlcik7XG4gICAgICBkdW1teUNvbXBvdW5kLmlkID0gZHVtbXlDb21wb3VuZElkO1xuICAgICAgZHVtbXlDb21wb3VuZC5wYWRkaW5nTGVmdCA9IHBhcmVudC5wYWRkaW5nTGVmdCB8fCAwO1xuICAgICAgZHVtbXlDb21wb3VuZC5wYWRkaW5nUmlnaHQgPSBwYXJlbnQucGFkZGluZ1JpZ2h0IHx8IDA7XG4gICAgICBkdW1teUNvbXBvdW5kLnBhZGRpbmdCb3R0b20gPSBwYXJlbnQucGFkZGluZ0JvdHRvbSB8fCAwO1xuICAgICAgZHVtbXlDb21wb3VuZC5wYWRkaW5nVG9wID0gcGFyZW50LnBhZGRpbmdUb3AgfHwgMDtcblxuICAgICAgc2VsZi5pZFRvRHVtbXlOb2RlW2R1bW15Q29tcG91bmRJZF0gPSBkdW1teUNvbXBvdW5kO1xuXG4gICAgICB2YXIgZHVtbXlQYXJlbnRHcmFwaCA9IHNlbGYuZ2V0R3JhcGhNYW5hZ2VyKCkuYWRkKHNlbGYubmV3R3JhcGgoKSwgZHVtbXlDb21wb3VuZCk7XG4gICAgICB2YXIgcGFyZW50R3JhcGggPSBwYXJlbnQuZ2V0Q2hpbGQoKTtcblxuICAgICAgLy8gQWRkIGR1bW15IGNvbXBvdW5kIHRvIHBhcmVudCB0aGUgZ3JhcGhcbiAgICAgIHBhcmVudEdyYXBoLmFkZChkdW1teUNvbXBvdW5kKTtcblxuICAgICAgLy8gRm9yIGVhY2ggemVybyBkZWdyZWUgbm9kZSBpbiB0aGlzIGxldmVsIHJlbW92ZSBpdCBmcm9tIGl0cyBwYXJlbnQgZ3JhcGggYW5kIGFkZCBpdCB0byB0aGUgZ3JhcGggb2YgZHVtbXkgcGFyZW50XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRlbXBNZW1iZXJHcm91cHNbcF9pZF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0ZW1wTWVtYmVyR3JvdXBzW3BfaWRdW2ldO1xuXG4gICAgICAgIHBhcmVudEdyYXBoLnJlbW92ZShub2RlKTtcbiAgICAgICAgZHVtbXlQYXJlbnRHcmFwaC5hZGQobm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLmNsZWFyQ29tcG91bmRzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY2hpbGRHcmFwaE1hcCA9IHt9O1xuICB2YXIgaWRUb05vZGUgPSB7fTtcblxuICAvLyBHZXQgY29tcG91bmQgb3JkZXJpbmcgYnkgZmluZGluZyB0aGUgaW5uZXIgb25lIGZpcnN0XG4gIHRoaXMucGVyZm9ybURGU09uQ29tcG91bmRzKCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvbXBvdW5kT3JkZXIubGVuZ3RoOyBpKyspIHtcblxuICAgIGlkVG9Ob2RlW3RoaXMuY29tcG91bmRPcmRlcltpXS5pZF0gPSB0aGlzLmNvbXBvdW5kT3JkZXJbaV07XG4gICAgY2hpbGRHcmFwaE1hcFt0aGlzLmNvbXBvdW5kT3JkZXJbaV0uaWRdID0gW10uY29uY2F0KHRoaXMuY29tcG91bmRPcmRlcltpXS5nZXRDaGlsZCgpLmdldE5vZGVzKCkpO1xuXG4gICAgLy8gUmVtb3ZlIGNoaWxkcmVuIG9mIGNvbXBvdW5kc1xuICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnJlbW92ZSh0aGlzLmNvbXBvdW5kT3JkZXJbaV0uZ2V0Q2hpbGQoKSk7XG4gICAgdGhpcy5jb21wb3VuZE9yZGVyW2ldLmNoaWxkID0gbnVsbDtcbiAgfVxuXG4gIHRoaXMuZ3JhcGhNYW5hZ2VyLnJlc2V0QWxsTm9kZXMoKTtcblxuICAvLyBUaWxlIHRoZSByZW1vdmVkIGNoaWxkcmVuXG4gIHRoaXMudGlsZUNvbXBvdW5kTWVtYmVycyhjaGlsZEdyYXBoTWFwLCBpZFRvTm9kZSk7XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5jbGVhclplcm9EZWdyZWVNZW1iZXJzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB0aWxlZFplcm9EZWdyZWVQYWNrID0gdGhpcy50aWxlZFplcm9EZWdyZWVQYWNrID0gW107XG5cbiAgT2JqZWN0LmtleXModGhpcy5tZW1iZXJHcm91cHMpLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGNvbXBvdW5kTm9kZSA9IHNlbGYuaWRUb0R1bW15Tm9kZVtpZF07IC8vIEdldCB0aGUgZHVtbXkgY29tcG91bmRcblxuICAgIHRpbGVkWmVyb0RlZ3JlZVBhY2tbaWRdID0gc2VsZi50aWxlTm9kZXMoc2VsZi5tZW1iZXJHcm91cHNbaWRdLCBjb21wb3VuZE5vZGUucGFkZGluZ0xlZnQgKyBjb21wb3VuZE5vZGUucGFkZGluZ1JpZ2h0KTtcblxuICAgIC8vIFNldCB0aGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgZHVtbXkgY29tcG91bmQgYXMgY2FsY3VsYXRlZFxuICAgIGNvbXBvdW5kTm9kZS5yZWN0LndpZHRoID0gdGlsZWRaZXJvRGVncmVlUGFja1tpZF0ud2lkdGg7XG4gICAgY29tcG91bmROb2RlLnJlY3QuaGVpZ2h0ID0gdGlsZWRaZXJvRGVncmVlUGFja1tpZF0uaGVpZ2h0O1xuICB9KTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLnJlcG9wdWxhdGVDb21wb3VuZHMgPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIGkgPSB0aGlzLmNvbXBvdW5kT3JkZXIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgbENvbXBvdW5kTm9kZSA9IHRoaXMuY29tcG91bmRPcmRlcltpXTtcbiAgICB2YXIgaWQgPSBsQ29tcG91bmROb2RlLmlkO1xuICAgIHZhciBob3Jpem9udGFsTWFyZ2luID0gbENvbXBvdW5kTm9kZS5wYWRkaW5nTGVmdDtcbiAgICB2YXIgdmVydGljYWxNYXJnaW4gPSBsQ29tcG91bmROb2RlLnBhZGRpbmdUb3A7XG5cbiAgICB0aGlzLmFkanVzdExvY2F0aW9ucyh0aGlzLnRpbGVkTWVtYmVyUGFja1tpZF0sIGxDb21wb3VuZE5vZGUucmVjdC54LCBsQ29tcG91bmROb2RlLnJlY3QueSwgaG9yaXpvbnRhbE1hcmdpbiwgdmVydGljYWxNYXJnaW4pO1xuICB9XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5yZXBvcHVsYXRlWmVyb0RlZ3JlZU1lbWJlcnMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHRpbGVkUGFjayA9IHRoaXMudGlsZWRaZXJvRGVncmVlUGFjaztcblxuICBPYmplY3Qua2V5cyh0aWxlZFBhY2spLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGNvbXBvdW5kTm9kZSA9IHNlbGYuaWRUb0R1bW15Tm9kZVtpZF07IC8vIEdldCB0aGUgZHVtbXkgY29tcG91bmQgYnkgaXRzIGlkXG4gICAgdmFyIGhvcml6b250YWxNYXJnaW4gPSBjb21wb3VuZE5vZGUucGFkZGluZ0xlZnQ7XG4gICAgdmFyIHZlcnRpY2FsTWFyZ2luID0gY29tcG91bmROb2RlLnBhZGRpbmdUb3A7XG5cbiAgICAvLyBBZGp1c3QgdGhlIHBvc2l0aW9ucyBvZiBub2RlcyB3cnQgaXRzIGNvbXBvdW5kXG4gICAgc2VsZi5hZGp1c3RMb2NhdGlvbnModGlsZWRQYWNrW2lkXSwgY29tcG91bmROb2RlLnJlY3QueCwgY29tcG91bmROb2RlLnJlY3QueSwgaG9yaXpvbnRhbE1hcmdpbiwgdmVydGljYWxNYXJnaW4pO1xuICB9KTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLmdldFRvQmVUaWxlZCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHZhciBpZCA9IG5vZGUuaWQ7XG4gIC8vZmlyc3RseSBjaGVjayB0aGUgcHJldmlvdXMgcmVzdWx0c1xuICBpZiAodGhpcy50b0JlVGlsZWRbaWRdICE9IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy50b0JlVGlsZWRbaWRdO1xuICB9XG5cbiAgLy9vbmx5IGNvbXBvdW5kIG5vZGVzIGFyZSB0byBiZSB0aWxlZFxuICB2YXIgY2hpbGRHcmFwaCA9IG5vZGUuZ2V0Q2hpbGQoKTtcbiAgaWYgKGNoaWxkR3JhcGggPT0gbnVsbCkge1xuICAgIHRoaXMudG9CZVRpbGVkW2lkXSA9IGZhbHNlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBjaGlsZHJlbiA9IGNoaWxkR3JhcGguZ2V0Tm9kZXMoKTsgLy8gR2V0IHRoZSBjaGlsZHJlbiBub2Rlc1xuXG4gIC8vYSBjb21wb3VuZCBub2RlIGlzIG5vdCB0byBiZSB0aWxlZCBpZiBhbGwgb2YgaXRzIGNvbXBvdW5kIGNoaWxkcmVuIGFyZSBub3QgdG8gYmUgdGlsZWRcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0aGVDaGlsZCA9IGNoaWxkcmVuW2ldO1xuXG4gICAgaWYgKHRoaXMuZ2V0Tm9kZURlZ3JlZSh0aGVDaGlsZCkgPiAwKSB7XG4gICAgICB0aGlzLnRvQmVUaWxlZFtpZF0gPSBmYWxzZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvL3Bhc3MgdGhlIGNoaWxkcmVuIG5vdCBoYXZpbmcgdGhlIGNvbXBvdW5kIHN0cnVjdHVyZVxuICAgIGlmICh0aGVDaGlsZC5nZXRDaGlsZCgpID09IG51bGwpIHtcbiAgICAgIHRoaXMudG9CZVRpbGVkW3RoZUNoaWxkLmlkXSA9IGZhbHNlO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmdldFRvQmVUaWxlZCh0aGVDaGlsZCkpIHtcbiAgICAgIHRoaXMudG9CZVRpbGVkW2lkXSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICB0aGlzLnRvQmVUaWxlZFtpZF0gPSB0cnVlO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIEdldCBkZWdyZWUgb2YgYSBub2RlIGRlcGVuZGluZyBvZiBpdHMgZWRnZXMgYW5kIGluZGVwZW5kZW50IG9mIGl0cyBjaGlsZHJlblxuQ29TRUxheW91dC5wcm90b3R5cGUuZ2V0Tm9kZURlZ3JlZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHZhciBpZCA9IG5vZGUuaWQ7XG4gIHZhciBlZGdlcyA9IG5vZGUuZ2V0RWRnZXMoKTtcbiAgdmFyIGRlZ3JlZSA9IDA7XG5cbiAgLy8gRm9yIHRoZSBlZGdlcyBjb25uZWN0ZWRcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlZGdlID0gZWRnZXNbaV07XG4gICAgaWYgKGVkZ2UuZ2V0U291cmNlKCkuaWQgIT09IGVkZ2UuZ2V0VGFyZ2V0KCkuaWQpIHtcbiAgICAgIGRlZ3JlZSA9IGRlZ3JlZSArIDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWdyZWU7XG59O1xuXG4vLyBHZXQgZGVncmVlIG9mIGEgbm9kZSB3aXRoIGl0cyBjaGlsZHJlblxuQ29TRUxheW91dC5wcm90b3R5cGUuZ2V0Tm9kZURlZ3JlZVdpdGhDaGlsZHJlbiA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHZhciBkZWdyZWUgPSB0aGlzLmdldE5vZGVEZWdyZWUobm9kZSk7XG4gIGlmIChub2RlLmdldENoaWxkKCkgPT0gbnVsbCkge1xuICAgIHJldHVybiBkZWdyZWU7XG4gIH1cbiAgdmFyIGNoaWxkcmVuID0gbm9kZS5nZXRDaGlsZCgpLmdldE5vZGVzKCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICBkZWdyZWUgKz0gdGhpcy5nZXROb2RlRGVncmVlV2l0aENoaWxkcmVuKGNoaWxkKTtcbiAgfVxuICByZXR1cm4gZGVncmVlO1xufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUucGVyZm9ybURGU09uQ29tcG91bmRzID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmNvbXBvdW5kT3JkZXIgPSBbXTtcbiAgdGhpcy5maWxsQ29tcGV4T3JkZXJCeURGUyh0aGlzLmdyYXBoTWFuYWdlci5nZXRSb290KCkuZ2V0Tm9kZXMoKSk7XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5maWxsQ29tcGV4T3JkZXJCeURGUyA9IGZ1bmN0aW9uIChjaGlsZHJlbikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGNoaWxkLmdldENoaWxkKCkgIT0gbnVsbCkge1xuICAgICAgdGhpcy5maWxsQ29tcGV4T3JkZXJCeURGUyhjaGlsZC5nZXRDaGlsZCgpLmdldE5vZGVzKCkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5nZXRUb0JlVGlsZWQoY2hpbGQpKSB7XG4gICAgICB0aGlzLmNvbXBvdW5kT3JkZXIucHVzaChjaGlsZCk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiogVGhpcyBtZXRob2QgcGxhY2VzIGVhY2ggemVybyBkZWdyZWUgbWVtYmVyIHdydCBnaXZlbiAoeCx5KSBjb29yZGluYXRlcyAodG9wIGxlZnQpLlxuKi9cbkNvU0VMYXlvdXQucHJvdG90eXBlLmFkanVzdExvY2F0aW9ucyA9IGZ1bmN0aW9uIChvcmdhbml6YXRpb24sIHgsIHksIGNvbXBvdW5kSG9yaXpvbnRhbE1hcmdpbiwgY29tcG91bmRWZXJ0aWNhbE1hcmdpbikge1xuICB4ICs9IGNvbXBvdW5kSG9yaXpvbnRhbE1hcmdpbjtcbiAgeSArPSBjb21wb3VuZFZlcnRpY2FsTWFyZ2luO1xuXG4gIHZhciBsZWZ0ID0geDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG9yZ2FuaXphdGlvbi5yb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHJvdyA9IG9yZ2FuaXphdGlvbi5yb3dzW2ldO1xuICAgIHggPSBsZWZ0O1xuICAgIHZhciBtYXhIZWlnaHQgPSAwO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCByb3cubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBsbm9kZSA9IHJvd1tqXTtcblxuICAgICAgbG5vZGUucmVjdC54ID0geDsgLy8gKyBsbm9kZS5yZWN0LndpZHRoIC8gMjtcbiAgICAgIGxub2RlLnJlY3QueSA9IHk7IC8vICsgbG5vZGUucmVjdC5oZWlnaHQgLyAyO1xuXG4gICAgICB4ICs9IGxub2RlLnJlY3Qud2lkdGggKyBvcmdhbml6YXRpb24uaG9yaXpvbnRhbFBhZGRpbmc7XG5cbiAgICAgIGlmIChsbm9kZS5yZWN0LmhlaWdodCA+IG1heEhlaWdodCkgbWF4SGVpZ2h0ID0gbG5vZGUucmVjdC5oZWlnaHQ7XG4gICAgfVxuXG4gICAgeSArPSBtYXhIZWlnaHQgKyBvcmdhbml6YXRpb24udmVydGljYWxQYWRkaW5nO1xuICB9XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS50aWxlQ29tcG91bmRNZW1iZXJzID0gZnVuY3Rpb24gKGNoaWxkR3JhcGhNYXAsIGlkVG9Ob2RlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy50aWxlZE1lbWJlclBhY2sgPSBbXTtcblxuICBPYmplY3Qua2V5cyhjaGlsZEdyYXBoTWFwKS5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgIC8vIEdldCB0aGUgY29tcG91bmQgbm9kZVxuICAgIHZhciBjb21wb3VuZE5vZGUgPSBpZFRvTm9kZVtpZF07XG5cbiAgICBzZWxmLnRpbGVkTWVtYmVyUGFja1tpZF0gPSBzZWxmLnRpbGVOb2RlcyhjaGlsZEdyYXBoTWFwW2lkXSwgY29tcG91bmROb2RlLnBhZGRpbmdMZWZ0ICsgY29tcG91bmROb2RlLnBhZGRpbmdSaWdodCk7XG5cbiAgICBjb21wb3VuZE5vZGUucmVjdC53aWR0aCA9IHNlbGYudGlsZWRNZW1iZXJQYWNrW2lkXS53aWR0aDtcbiAgICBjb21wb3VuZE5vZGUucmVjdC5oZWlnaHQgPSBzZWxmLnRpbGVkTWVtYmVyUGFja1tpZF0uaGVpZ2h0O1xuICB9KTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLnRpbGVOb2RlcyA9IGZ1bmN0aW9uIChub2RlcywgbWluV2lkdGgpIHtcbiAgdmFyIHZlcnRpY2FsUGFkZGluZyA9IENvU0VDb25zdGFudHMuVElMSU5HX1BBRERJTkdfVkVSVElDQUw7XG4gIHZhciBob3Jpem9udGFsUGFkZGluZyA9IENvU0VDb25zdGFudHMuVElMSU5HX1BBRERJTkdfSE9SSVpPTlRBTDtcbiAgdmFyIG9yZ2FuaXphdGlvbiA9IHtcbiAgICByb3dzOiBbXSxcbiAgICByb3dXaWR0aDogW10sXG4gICAgcm93SGVpZ2h0OiBbXSxcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IG1pbldpZHRoLCAvLyBhc3N1bWUgbWluSGVpZ2h0IGVxdWFscyB0byBtaW5XaWR0aFxuICAgIHZlcnRpY2FsUGFkZGluZzogdmVydGljYWxQYWRkaW5nLFxuICAgIGhvcml6b250YWxQYWRkaW5nOiBob3Jpem9udGFsUGFkZGluZ1xuICB9O1xuXG4gIC8vIFNvcnQgdGhlIG5vZGVzIGluIGFzY2VuZGluZyBvcmRlciBvZiB0aGVpciBhcmVhc1xuICBub2Rlcy5zb3J0KGZ1bmN0aW9uIChuMSwgbjIpIHtcbiAgICBpZiAobjEucmVjdC53aWR0aCAqIG4xLnJlY3QuaGVpZ2h0ID4gbjIucmVjdC53aWR0aCAqIG4yLnJlY3QuaGVpZ2h0KSByZXR1cm4gLTE7XG4gICAgaWYgKG4xLnJlY3Qud2lkdGggKiBuMS5yZWN0LmhlaWdodCA8IG4yLnJlY3Qud2lkdGggKiBuMi5yZWN0LmhlaWdodCkgcmV0dXJuIDE7XG4gICAgcmV0dXJuIDA7XG4gIH0pO1xuXG4gIC8vIENyZWF0ZSB0aGUgb3JnYW5pemF0aW9uIC0+IHRpbGUgbWVtYmVyc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGxOb2RlID0gbm9kZXNbaV07XG5cbiAgICBpZiAob3JnYW5pemF0aW9uLnJvd3MubGVuZ3RoID09IDApIHtcbiAgICAgIHRoaXMuaW5zZXJ0Tm9kZVRvUm93KG9yZ2FuaXphdGlvbiwgbE5vZGUsIDAsIG1pbldpZHRoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuY2FuQWRkSG9yaXpvbnRhbChvcmdhbml6YXRpb24sIGxOb2RlLnJlY3Qud2lkdGgsIGxOb2RlLnJlY3QuaGVpZ2h0KSkge1xuICAgICAgdGhpcy5pbnNlcnROb2RlVG9Sb3cob3JnYW5pemF0aW9uLCBsTm9kZSwgdGhpcy5nZXRTaG9ydGVzdFJvd0luZGV4KG9yZ2FuaXphdGlvbiksIG1pbldpZHRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pbnNlcnROb2RlVG9Sb3cob3JnYW5pemF0aW9uLCBsTm9kZSwgb3JnYW5pemF0aW9uLnJvd3MubGVuZ3RoLCBtaW5XaWR0aCk7XG4gICAgfVxuXG4gICAgdGhpcy5zaGlmdFRvTGFzdFJvdyhvcmdhbml6YXRpb24pO1xuICB9XG5cbiAgcmV0dXJuIG9yZ2FuaXphdGlvbjtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLmluc2VydE5vZGVUb1JvdyA9IGZ1bmN0aW9uIChvcmdhbml6YXRpb24sIG5vZGUsIHJvd0luZGV4LCBtaW5XaWR0aCkge1xuICB2YXIgbWluQ29tcG91bmRTaXplID0gbWluV2lkdGg7XG5cbiAgLy8gQWRkIG5ldyByb3cgaWYgbmVlZGVkXG4gIGlmIChyb3dJbmRleCA9PSBvcmdhbml6YXRpb24ucm93cy5sZW5ndGgpIHtcbiAgICB2YXIgc2Vjb25kRGltZW5zaW9uID0gW107XG5cbiAgICBvcmdhbml6YXRpb24ucm93cy5wdXNoKHNlY29uZERpbWVuc2lvbik7XG4gICAgb3JnYW5pemF0aW9uLnJvd1dpZHRoLnB1c2gobWluQ29tcG91bmRTaXplKTtcbiAgICBvcmdhbml6YXRpb24ucm93SGVpZ2h0LnB1c2goMCk7XG4gIH1cblxuICAvLyBVcGRhdGUgcm93IHdpZHRoXG4gIHZhciB3ID0gb3JnYW5pemF0aW9uLnJvd1dpZHRoW3Jvd0luZGV4XSArIG5vZGUucmVjdC53aWR0aDtcblxuICBpZiAob3JnYW5pemF0aW9uLnJvd3Nbcm93SW5kZXhdLmxlbmd0aCA+IDApIHtcbiAgICB3ICs9IG9yZ2FuaXphdGlvbi5ob3Jpem9udGFsUGFkZGluZztcbiAgfVxuXG4gIG9yZ2FuaXphdGlvbi5yb3dXaWR0aFtyb3dJbmRleF0gPSB3O1xuICAvLyBVcGRhdGUgY29tcG91bmQgd2lkdGhcbiAgaWYgKG9yZ2FuaXphdGlvbi53aWR0aCA8IHcpIHtcbiAgICBvcmdhbml6YXRpb24ud2lkdGggPSB3O1xuICB9XG5cbiAgLy8gVXBkYXRlIGhlaWdodFxuICB2YXIgaCA9IG5vZGUucmVjdC5oZWlnaHQ7XG4gIGlmIChyb3dJbmRleCA+IDApIGggKz0gb3JnYW5pemF0aW9uLnZlcnRpY2FsUGFkZGluZztcblxuICB2YXIgZXh0cmFIZWlnaHQgPSAwO1xuICBpZiAoaCA+IG9yZ2FuaXphdGlvbi5yb3dIZWlnaHRbcm93SW5kZXhdKSB7XG4gICAgZXh0cmFIZWlnaHQgPSBvcmdhbml6YXRpb24ucm93SGVpZ2h0W3Jvd0luZGV4XTtcbiAgICBvcmdhbml6YXRpb24ucm93SGVpZ2h0W3Jvd0luZGV4XSA9IGg7XG4gICAgZXh0cmFIZWlnaHQgPSBvcmdhbml6YXRpb24ucm93SGVpZ2h0W3Jvd0luZGV4XSAtIGV4dHJhSGVpZ2h0O1xuICB9XG5cbiAgb3JnYW5pemF0aW9uLmhlaWdodCArPSBleHRyYUhlaWdodDtcblxuICAvLyBJbnNlcnQgbm9kZVxuICBvcmdhbml6YXRpb24ucm93c1tyb3dJbmRleF0ucHVzaChub2RlKTtcbn07XG5cbi8vU2NhbnMgdGhlIHJvd3Mgb2YgYW4gb3JnYW5pemF0aW9uIGFuZCByZXR1cm5zIHRoZSBvbmUgd2l0aCB0aGUgbWluIHdpZHRoXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5nZXRTaG9ydGVzdFJvd0luZGV4ID0gZnVuY3Rpb24gKG9yZ2FuaXphdGlvbikge1xuICB2YXIgciA9IC0xO1xuICB2YXIgbWluID0gTnVtYmVyLk1BWF9WQUxVRTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG9yZ2FuaXphdGlvbi5yb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG9yZ2FuaXphdGlvbi5yb3dXaWR0aFtpXSA8IG1pbikge1xuICAgICAgciA9IGk7XG4gICAgICBtaW4gPSBvcmdhbml6YXRpb24ucm93V2lkdGhbaV07XG4gICAgfVxuICB9XG4gIHJldHVybiByO1xufTtcblxuLy9TY2FucyB0aGUgcm93cyBvZiBhbiBvcmdhbml6YXRpb24gYW5kIHJldHVybnMgdGhlIG9uZSB3aXRoIHRoZSBtYXggd2lkdGhcbkNvU0VMYXlvdXQucHJvdG90eXBlLmdldExvbmdlc3RSb3dJbmRleCA9IGZ1bmN0aW9uIChvcmdhbml6YXRpb24pIHtcbiAgdmFyIHIgPSAtMTtcbiAgdmFyIG1heCA9IE51bWJlci5NSU5fVkFMVUU7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmdhbml6YXRpb24ucm93cy5sZW5ndGg7IGkrKykge1xuXG4gICAgaWYgKG9yZ2FuaXphdGlvbi5yb3dXaWR0aFtpXSA+IG1heCkge1xuICAgICAgciA9IGk7XG4gICAgICBtYXggPSBvcmdhbml6YXRpb24ucm93V2lkdGhbaV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHI7XG59O1xuXG4vKipcbiogVGhpcyBtZXRob2QgY2hlY2tzIHdoZXRoZXIgYWRkaW5nIGV4dHJhIHdpZHRoIHRvIHRoZSBvcmdhbml6YXRpb24gdmlvbGF0ZXNcbiogdGhlIGFzcGVjdCByYXRpbygxKSBvciBub3QuXG4qL1xuQ29TRUxheW91dC5wcm90b3R5cGUuY2FuQWRkSG9yaXpvbnRhbCA9IGZ1bmN0aW9uIChvcmdhbml6YXRpb24sIGV4dHJhV2lkdGgsIGV4dHJhSGVpZ2h0KSB7XG5cbiAgdmFyIHNyaSA9IHRoaXMuZ2V0U2hvcnRlc3RSb3dJbmRleChvcmdhbml6YXRpb24pO1xuXG4gIGlmIChzcmkgPCAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgbWluID0gb3JnYW5pemF0aW9uLnJvd1dpZHRoW3NyaV07XG5cbiAgaWYgKG1pbiArIG9yZ2FuaXphdGlvbi5ob3Jpem9udGFsUGFkZGluZyArIGV4dHJhV2lkdGggPD0gb3JnYW5pemF0aW9uLndpZHRoKSByZXR1cm4gdHJ1ZTtcblxuICB2YXIgaERpZmYgPSAwO1xuXG4gIC8vIEFkZGluZyB0byBhbiBleGlzdGluZyByb3dcbiAgaWYgKG9yZ2FuaXphdGlvbi5yb3dIZWlnaHRbc3JpXSA8IGV4dHJhSGVpZ2h0KSB7XG4gICAgaWYgKHNyaSA+IDApIGhEaWZmID0gZXh0cmFIZWlnaHQgKyBvcmdhbml6YXRpb24udmVydGljYWxQYWRkaW5nIC0gb3JnYW5pemF0aW9uLnJvd0hlaWdodFtzcmldO1xuICB9XG5cbiAgdmFyIGFkZF90b19yb3dfcmF0aW87XG4gIGlmIChvcmdhbml6YXRpb24ud2lkdGggLSBtaW4gPj0gZXh0cmFXaWR0aCArIG9yZ2FuaXphdGlvbi5ob3Jpem9udGFsUGFkZGluZykge1xuICAgIGFkZF90b19yb3dfcmF0aW8gPSAob3JnYW5pemF0aW9uLmhlaWdodCArIGhEaWZmKSAvIChtaW4gKyBleHRyYVdpZHRoICsgb3JnYW5pemF0aW9uLmhvcml6b250YWxQYWRkaW5nKTtcbiAgfSBlbHNlIHtcbiAgICBhZGRfdG9fcm93X3JhdGlvID0gKG9yZ2FuaXphdGlvbi5oZWlnaHQgKyBoRGlmZikgLyBvcmdhbml6YXRpb24ud2lkdGg7XG4gIH1cblxuICAvLyBBZGRpbmcgYSBuZXcgcm93IGZvciB0aGlzIG5vZGVcbiAgaERpZmYgPSBleHRyYUhlaWdodCArIG9yZ2FuaXphdGlvbi52ZXJ0aWNhbFBhZGRpbmc7XG4gIHZhciBhZGRfbmV3X3Jvd19yYXRpbztcbiAgaWYgKG9yZ2FuaXphdGlvbi53aWR0aCA8IGV4dHJhV2lkdGgpIHtcbiAgICBhZGRfbmV3X3Jvd19yYXRpbyA9IChvcmdhbml6YXRpb24uaGVpZ2h0ICsgaERpZmYpIC8gZXh0cmFXaWR0aDtcbiAgfSBlbHNlIHtcbiAgICBhZGRfbmV3X3Jvd19yYXRpbyA9IChvcmdhbml6YXRpb24uaGVpZ2h0ICsgaERpZmYpIC8gb3JnYW5pemF0aW9uLndpZHRoO1xuICB9XG5cbiAgaWYgKGFkZF9uZXdfcm93X3JhdGlvIDwgMSkgYWRkX25ld19yb3dfcmF0aW8gPSAxIC8gYWRkX25ld19yb3dfcmF0aW87XG5cbiAgaWYgKGFkZF90b19yb3dfcmF0aW8gPCAxKSBhZGRfdG9fcm93X3JhdGlvID0gMSAvIGFkZF90b19yb3dfcmF0aW87XG5cbiAgcmV0dXJuIGFkZF90b19yb3dfcmF0aW8gPCBhZGRfbmV3X3Jvd19yYXRpbztcbn07XG5cbi8vSWYgbW92aW5nIHRoZSBsYXN0IG5vZGUgZnJvbSB0aGUgbG9uZ2VzdCByb3cgYW5kIGFkZGluZyBpdCB0byB0aGUgbGFzdFxuLy9yb3cgbWFrZXMgdGhlIGJvdW5kaW5nIGJveCBzbWFsbGVyLCBkbyBpdC5cbkNvU0VMYXlvdXQucHJvdG90eXBlLnNoaWZ0VG9MYXN0Um93ID0gZnVuY3Rpb24gKG9yZ2FuaXphdGlvbikge1xuICB2YXIgbG9uZ2VzdCA9IHRoaXMuZ2V0TG9uZ2VzdFJvd0luZGV4KG9yZ2FuaXphdGlvbik7XG4gIHZhciBsYXN0ID0gb3JnYW5pemF0aW9uLnJvd1dpZHRoLmxlbmd0aCAtIDE7XG4gIHZhciByb3cgPSBvcmdhbml6YXRpb24ucm93c1tsb25nZXN0XTtcbiAgdmFyIG5vZGUgPSByb3dbcm93Lmxlbmd0aCAtIDFdO1xuXG4gIHZhciBkaWZmID0gbm9kZS53aWR0aCArIG9yZ2FuaXphdGlvbi5ob3Jpem9udGFsUGFkZGluZztcblxuICAvLyBDaGVjayBpZiB0aGVyZSBpcyBlbm91Z2ggc3BhY2Ugb24gdGhlIGxhc3Qgcm93XG4gIGlmIChvcmdhbml6YXRpb24ud2lkdGggLSBvcmdhbml6YXRpb24ucm93V2lkdGhbbGFzdF0gPiBkaWZmICYmIGxvbmdlc3QgIT0gbGFzdCkge1xuICAgIC8vIFJlbW92ZSB0aGUgbGFzdCBlbGVtZW50IG9mIHRoZSBsb25nZXN0IHJvd1xuICAgIHJvdy5zcGxpY2UoLTEsIDEpO1xuXG4gICAgLy8gUHVzaCBpdCB0byB0aGUgbGFzdCByb3dcbiAgICBvcmdhbml6YXRpb24ucm93c1tsYXN0XS5wdXNoKG5vZGUpO1xuXG4gICAgb3JnYW5pemF0aW9uLnJvd1dpZHRoW2xvbmdlc3RdID0gb3JnYW5pemF0aW9uLnJvd1dpZHRoW2xvbmdlc3RdIC0gZGlmZjtcbiAgICBvcmdhbml6YXRpb24ucm93V2lkdGhbbGFzdF0gPSBvcmdhbml6YXRpb24ucm93V2lkdGhbbGFzdF0gKyBkaWZmO1xuICAgIG9yZ2FuaXphdGlvbi53aWR0aCA9IG9yZ2FuaXphdGlvbi5yb3dXaWR0aFtpbnN0YW5jZS5nZXRMb25nZXN0Um93SW5kZXgob3JnYW5pemF0aW9uKV07XG5cbiAgICAvLyBVcGRhdGUgaGVpZ2h0cyBvZiB0aGUgb3JnYW5pemF0aW9uXG4gICAgdmFyIG1heEhlaWdodCA9IE51bWJlci5NSU5fVkFMVUU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3cubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyb3dbaV0uaGVpZ2h0ID4gbWF4SGVpZ2h0KSBtYXhIZWlnaHQgPSByb3dbaV0uaGVpZ2h0O1xuICAgIH1cbiAgICBpZiAobG9uZ2VzdCA+IDApIG1heEhlaWdodCArPSBvcmdhbml6YXRpb24udmVydGljYWxQYWRkaW5nO1xuXG4gICAgdmFyIHByZXZUb3RhbCA9IG9yZ2FuaXphdGlvbi5yb3dIZWlnaHRbbG9uZ2VzdF0gKyBvcmdhbml6YXRpb24ucm93SGVpZ2h0W2xhc3RdO1xuXG4gICAgb3JnYW5pemF0aW9uLnJvd0hlaWdodFtsb25nZXN0XSA9IG1heEhlaWdodDtcbiAgICBpZiAob3JnYW5pemF0aW9uLnJvd0hlaWdodFtsYXN0XSA8IG5vZGUuaGVpZ2h0ICsgb3JnYW5pemF0aW9uLnZlcnRpY2FsUGFkZGluZykgb3JnYW5pemF0aW9uLnJvd0hlaWdodFtsYXN0XSA9IG5vZGUuaGVpZ2h0ICsgb3JnYW5pemF0aW9uLnZlcnRpY2FsUGFkZGluZztcblxuICAgIHZhciBmaW5hbFRvdGFsID0gb3JnYW5pemF0aW9uLnJvd0hlaWdodFtsb25nZXN0XSArIG9yZ2FuaXphdGlvbi5yb3dIZWlnaHRbbGFzdF07XG4gICAgb3JnYW5pemF0aW9uLmhlaWdodCArPSBmaW5hbFRvdGFsIC0gcHJldlRvdGFsO1xuXG4gICAgdGhpcy5zaGlmdFRvTGFzdFJvdyhvcmdhbml6YXRpb24pO1xuICB9XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS50aWxpbmdQcmVMYXlvdXQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChDb1NFQ29uc3RhbnRzLlRJTEUpIHtcbiAgICAvLyBGaW5kIHplcm8gZGVncmVlIG5vZGVzIGFuZCBjcmVhdGUgYSBjb21wb3VuZCBmb3IgZWFjaCBsZXZlbFxuICAgIHRoaXMuZ3JvdXBaZXJvRGVncmVlTWVtYmVycygpO1xuICAgIC8vIFRpbGUgYW5kIGNsZWFyIGNoaWxkcmVuIG9mIGVhY2ggY29tcG91bmRcbiAgICB0aGlzLmNsZWFyQ29tcG91bmRzKCk7XG4gICAgLy8gU2VwYXJhdGVseSB0aWxlIGFuZCBjbGVhciB6ZXJvIGRlZ3JlZSBub2RlcyBmb3IgZWFjaCBsZXZlbFxuICAgIHRoaXMuY2xlYXJaZXJvRGVncmVlTWVtYmVycygpO1xuICB9XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS50aWxpbmdQb3N0TGF5b3V0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAoQ29TRUNvbnN0YW50cy5USUxFKSB7XG4gICAgdGhpcy5yZXBvcHVsYXRlWmVyb0RlZ3JlZU1lbWJlcnMoKTtcbiAgICB0aGlzLnJlcG9wdWxhdGVDb21wb3VuZHMoKTtcbiAgfVxufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFNlY3Rpb246IFRyZWUgUmVkdWN0aW9uIG1ldGhvZHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBSZWR1Y2UgdHJlZXMgXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5yZWR1Y2VUcmVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHBydW5lZE5vZGVzQWxsID0gW107XG4gIHZhciBjb250YWluc0xlYWYgPSB0cnVlO1xuICB2YXIgbm9kZTtcblxuICB3aGlsZSAoY29udGFpbnNMZWFmKSB7XG4gICAgdmFyIGFsbE5vZGVzID0gdGhpcy5ncmFwaE1hbmFnZXIuZ2V0QWxsTm9kZXMoKTtcbiAgICB2YXIgcHJ1bmVkTm9kZXNJblN0ZXBUZW1wID0gW107XG4gICAgY29udGFpbnNMZWFmID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBub2RlID0gYWxsTm9kZXNbaV07XG4gICAgICBpZiAobm9kZS5nZXRFZGdlcygpLmxlbmd0aCA9PSAxICYmICFub2RlLmdldEVkZ2VzKClbMF0uaXNJbnRlckdyYXBoICYmIG5vZGUuZ2V0Q2hpbGQoKSA9PSBudWxsKSB7XG4gICAgICAgIHBydW5lZE5vZGVzSW5TdGVwVGVtcC5wdXNoKFtub2RlLCBub2RlLmdldEVkZ2VzKClbMF0sIG5vZGUuZ2V0T3duZXIoKV0pO1xuICAgICAgICBjb250YWluc0xlYWYgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29udGFpbnNMZWFmID09IHRydWUpIHtcbiAgICAgIHZhciBwcnVuZWROb2Rlc0luU3RlcCA9IFtdO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwcnVuZWROb2Rlc0luU3RlcFRlbXAubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHBydW5lZE5vZGVzSW5TdGVwVGVtcFtqXVswXS5nZXRFZGdlcygpLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgcHJ1bmVkTm9kZXNJblN0ZXAucHVzaChwcnVuZWROb2Rlc0luU3RlcFRlbXBbal0pO1xuICAgICAgICAgIHBydW5lZE5vZGVzSW5TdGVwVGVtcFtqXVswXS5nZXRPd25lcigpLnJlbW92ZShwcnVuZWROb2Rlc0luU3RlcFRlbXBbal1bMF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwcnVuZWROb2Rlc0FsbC5wdXNoKHBydW5lZE5vZGVzSW5TdGVwKTtcbiAgICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnJlc2V0QWxsTm9kZXMoKTtcbiAgICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnJlc2V0QWxsRWRnZXMoKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5wcnVuZWROb2Rlc0FsbCA9IHBydW5lZE5vZGVzQWxsO1xufTtcblxuLy8gR3JvdyB0cmVlIG9uZSBzdGVwIFxuQ29TRUxheW91dC5wcm90b3R5cGUuZ3Jvd1RyZWUgPSBmdW5jdGlvbiAocHJ1bmVkTm9kZXNBbGwpIHtcbiAgdmFyIGxlbmd0aE9mUHJ1bmVkTm9kZXNJblN0ZXAgPSBwcnVuZWROb2Rlc0FsbC5sZW5ndGg7XG4gIHZhciBwcnVuZWROb2Rlc0luU3RlcCA9IHBydW5lZE5vZGVzQWxsW2xlbmd0aE9mUHJ1bmVkTm9kZXNJblN0ZXAgLSAxXTtcblxuICB2YXIgbm9kZURhdGE7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJ1bmVkTm9kZXNJblN0ZXAubGVuZ3RoOyBpKyspIHtcbiAgICBub2RlRGF0YSA9IHBydW5lZE5vZGVzSW5TdGVwW2ldO1xuXG4gICAgdGhpcy5maW5kUGxhY2Vmb3JQcnVuZWROb2RlKG5vZGVEYXRhKTtcblxuICAgIG5vZGVEYXRhWzJdLmFkZChub2RlRGF0YVswXSk7XG4gICAgbm9kZURhdGFbMl0uYWRkKG5vZGVEYXRhWzFdLCBub2RlRGF0YVsxXS5zb3VyY2UsIG5vZGVEYXRhWzFdLnRhcmdldCk7XG4gIH1cblxuICBwcnVuZWROb2Rlc0FsbC5zcGxpY2UocHJ1bmVkTm9kZXNBbGwubGVuZ3RoIC0gMSwgMSk7XG4gIHRoaXMuZ3JhcGhNYW5hZ2VyLnJlc2V0QWxsTm9kZXMoKTtcbiAgdGhpcy5ncmFwaE1hbmFnZXIucmVzZXRBbGxFZGdlcygpO1xufTtcblxuLy8gRmluZCBhbiBhcHByb3ByaWF0ZSBwb3NpdGlvbiB0byByZXBsYWNlIHBydW5lZCBub2RlLCB0aGlzIG1ldGhvZCBjYW4gYmUgaW1wcm92ZWRcbkNvU0VMYXlvdXQucHJvdG90eXBlLmZpbmRQbGFjZWZvclBydW5lZE5vZGUgPSBmdW5jdGlvbiAobm9kZURhdGEpIHtcblxuICB2YXIgZ3JpZEZvclBydW5lZE5vZGU7XG4gIHZhciBub2RlVG9Db25uZWN0O1xuICB2YXIgcHJ1bmVkTm9kZSA9IG5vZGVEYXRhWzBdO1xuICBpZiAocHJ1bmVkTm9kZSA9PSBub2RlRGF0YVsxXS5zb3VyY2UpIHtcbiAgICBub2RlVG9Db25uZWN0ID0gbm9kZURhdGFbMV0udGFyZ2V0O1xuICB9IGVsc2Uge1xuICAgIG5vZGVUb0Nvbm5lY3QgPSBub2RlRGF0YVsxXS5zb3VyY2U7XG4gIH1cbiAgdmFyIHN0YXJ0R3JpZFggPSBub2RlVG9Db25uZWN0LnN0YXJ0WDtcbiAgdmFyIGZpbmlzaEdyaWRYID0gbm9kZVRvQ29ubmVjdC5maW5pc2hYO1xuICB2YXIgc3RhcnRHcmlkWSA9IG5vZGVUb0Nvbm5lY3Quc3RhcnRZO1xuICB2YXIgZmluaXNoR3JpZFkgPSBub2RlVG9Db25uZWN0LmZpbmlzaFk7XG5cbiAgdmFyIHVwTm9kZUNvdW50ID0gMDtcbiAgdmFyIGRvd25Ob2RlQ291bnQgPSAwO1xuICB2YXIgcmlnaHROb2RlQ291bnQgPSAwO1xuICB2YXIgbGVmdE5vZGVDb3VudCA9IDA7XG4gIHZhciBjb250cm9sUmVnaW9ucyA9IFt1cE5vZGVDb3VudCwgcmlnaHROb2RlQ291bnQsIGRvd25Ob2RlQ291bnQsIGxlZnROb2RlQ291bnRdO1xuXG4gIGlmIChzdGFydEdyaWRZID4gMCkge1xuICAgIGZvciAodmFyIGkgPSBzdGFydEdyaWRYOyBpIDw9IGZpbmlzaEdyaWRYOyBpKyspIHtcbiAgICAgIGNvbnRyb2xSZWdpb25zWzBdICs9IHRoaXMuZ3JpZFtpXVtzdGFydEdyaWRZIC0gMV0ubGVuZ3RoICsgdGhpcy5ncmlkW2ldW3N0YXJ0R3JpZFldLmxlbmd0aCAtIDE7XG4gICAgfVxuICB9XG4gIGlmIChmaW5pc2hHcmlkWCA8IHRoaXMuZ3JpZC5sZW5ndGggLSAxKSB7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0R3JpZFk7IGkgPD0gZmluaXNoR3JpZFk7IGkrKykge1xuICAgICAgY29udHJvbFJlZ2lvbnNbMV0gKz0gdGhpcy5ncmlkW2ZpbmlzaEdyaWRYICsgMV1baV0ubGVuZ3RoICsgdGhpcy5ncmlkW2ZpbmlzaEdyaWRYXVtpXS5sZW5ndGggLSAxO1xuICAgIH1cbiAgfVxuICBpZiAoZmluaXNoR3JpZFkgPCB0aGlzLmdyaWRbMF0ubGVuZ3RoIC0gMSkge1xuICAgIGZvciAodmFyIGkgPSBzdGFydEdyaWRYOyBpIDw9IGZpbmlzaEdyaWRYOyBpKyspIHtcbiAgICAgIGNvbnRyb2xSZWdpb25zWzJdICs9IHRoaXMuZ3JpZFtpXVtmaW5pc2hHcmlkWSArIDFdLmxlbmd0aCArIHRoaXMuZ3JpZFtpXVtmaW5pc2hHcmlkWV0ubGVuZ3RoIC0gMTtcbiAgICB9XG4gIH1cbiAgaWYgKHN0YXJ0R3JpZFggPiAwKSB7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0R3JpZFk7IGkgPD0gZmluaXNoR3JpZFk7IGkrKykge1xuICAgICAgY29udHJvbFJlZ2lvbnNbM10gKz0gdGhpcy5ncmlkW3N0YXJ0R3JpZFggLSAxXVtpXS5sZW5ndGggKyB0aGlzLmdyaWRbc3RhcnRHcmlkWF1baV0ubGVuZ3RoIC0gMTtcbiAgICB9XG4gIH1cbiAgdmFyIG1pbiA9IEludGVnZXIuTUFYX1ZBTFVFO1xuICB2YXIgbWluQ291bnQ7XG4gIHZhciBtaW5JbmRleDtcbiAgZm9yICh2YXIgaiA9IDA7IGogPCBjb250cm9sUmVnaW9ucy5sZW5ndGg7IGorKykge1xuICAgIGlmIChjb250cm9sUmVnaW9uc1tqXSA8IG1pbikge1xuICAgICAgbWluID0gY29udHJvbFJlZ2lvbnNbal07XG4gICAgICBtaW5Db3VudCA9IDE7XG4gICAgICBtaW5JbmRleCA9IGo7XG4gICAgfSBlbHNlIGlmIChjb250cm9sUmVnaW9uc1tqXSA9PSBtaW4pIHtcbiAgICAgIG1pbkNvdW50Kys7XG4gICAgfVxuICB9XG5cbiAgaWYgKG1pbkNvdW50ID09IDMgJiYgbWluID09IDApIHtcbiAgICBpZiAoY29udHJvbFJlZ2lvbnNbMF0gPT0gMCAmJiBjb250cm9sUmVnaW9uc1sxXSA9PSAwICYmIGNvbnRyb2xSZWdpb25zWzJdID09IDApIHtcbiAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gMTtcbiAgICB9IGVsc2UgaWYgKGNvbnRyb2xSZWdpb25zWzBdID09IDAgJiYgY29udHJvbFJlZ2lvbnNbMV0gPT0gMCAmJiBjb250cm9sUmVnaW9uc1szXSA9PSAwKSB7XG4gICAgICBncmlkRm9yUHJ1bmVkTm9kZSA9IDA7XG4gICAgfSBlbHNlIGlmIChjb250cm9sUmVnaW9uc1swXSA9PSAwICYmIGNvbnRyb2xSZWdpb25zWzJdID09IDAgJiYgY29udHJvbFJlZ2lvbnNbM10gPT0gMCkge1xuICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAzO1xuICAgIH0gZWxzZSBpZiAoY29udHJvbFJlZ2lvbnNbMV0gPT0gMCAmJiBjb250cm9sUmVnaW9uc1syXSA9PSAwICYmIGNvbnRyb2xSZWdpb25zWzNdID09IDApIHtcbiAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gMjtcbiAgICB9XG4gIH0gZWxzZSBpZiAobWluQ291bnQgPT0gMiAmJiBtaW4gPT0gMCkge1xuICAgIHZhciByYW5kb20gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyKTtcbiAgICBpZiAoY29udHJvbFJlZ2lvbnNbMF0gPT0gMCAmJiBjb250cm9sUmVnaW9uc1sxXSA9PSAwKSB7XG4gICAgICA7XG4gICAgICBpZiAocmFuZG9tID09IDApIHtcbiAgICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAxO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY29udHJvbFJlZ2lvbnNbMF0gPT0gMCAmJiBjb250cm9sUmVnaW9uc1syXSA9PSAwKSB7XG4gICAgICBpZiAocmFuZG9tID09IDApIHtcbiAgICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAyO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY29udHJvbFJlZ2lvbnNbMF0gPT0gMCAmJiBjb250cm9sUmVnaW9uc1szXSA9PSAwKSB7XG4gICAgICBpZiAocmFuZG9tID09IDApIHtcbiAgICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAzO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY29udHJvbFJlZ2lvbnNbMV0gPT0gMCAmJiBjb250cm9sUmVnaW9uc1syXSA9PSAwKSB7XG4gICAgICBpZiAocmFuZG9tID09IDApIHtcbiAgICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAyO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY29udHJvbFJlZ2lvbnNbMV0gPT0gMCAmJiBjb250cm9sUmVnaW9uc1szXSA9PSAwKSB7XG4gICAgICBpZiAocmFuZG9tID09IDApIHtcbiAgICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAzO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocmFuZG9tID09IDApIHtcbiAgICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAzO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChtaW5Db3VudCA9PSA0ICYmIG1pbiA9PSAwKSB7XG4gICAgdmFyIHJhbmRvbSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDQpO1xuICAgIGdyaWRGb3JQcnVuZWROb2RlID0gcmFuZG9tO1xuICB9IGVsc2Uge1xuICAgIGdyaWRGb3JQcnVuZWROb2RlID0gbWluSW5kZXg7XG4gIH1cblxuICBpZiAoZ3JpZEZvclBydW5lZE5vZGUgPT0gMCkge1xuICAgIHBydW5lZE5vZGUuc2V0Q2VudGVyKG5vZGVUb0Nvbm5lY3QuZ2V0Q2VudGVyWCgpLCBub2RlVG9Db25uZWN0LmdldENlbnRlclkoKSAtIG5vZGVUb0Nvbm5lY3QuZ2V0SGVpZ2h0KCkgLyAyIC0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSCAtIHBydW5lZE5vZGUuZ2V0SGVpZ2h0KCkgLyAyKTtcbiAgfSBlbHNlIGlmIChncmlkRm9yUHJ1bmVkTm9kZSA9PSAxKSB7XG4gICAgcHJ1bmVkTm9kZS5zZXRDZW50ZXIobm9kZVRvQ29ubmVjdC5nZXRDZW50ZXJYKCkgKyBub2RlVG9Db25uZWN0LmdldFdpZHRoKCkgLyAyICsgRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSCArIHBydW5lZE5vZGUuZ2V0V2lkdGgoKSAvIDIsIG5vZGVUb0Nvbm5lY3QuZ2V0Q2VudGVyWSgpKTtcbiAgfSBlbHNlIGlmIChncmlkRm9yUHJ1bmVkTm9kZSA9PSAyKSB7XG4gICAgcHJ1bmVkTm9kZS5zZXRDZW50ZXIobm9kZVRvQ29ubmVjdC5nZXRDZW50ZXJYKCksIG5vZGVUb0Nvbm5lY3QuZ2V0Q2VudGVyWSgpICsgbm9kZVRvQ29ubmVjdC5nZXRIZWlnaHQoKSAvIDIgKyBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIICsgcHJ1bmVkTm9kZS5nZXRIZWlnaHQoKSAvIDIpO1xuICB9IGVsc2Uge1xuICAgIHBydW5lZE5vZGUuc2V0Q2VudGVyKG5vZGVUb0Nvbm5lY3QuZ2V0Q2VudGVyWCgpIC0gbm9kZVRvQ29ubmVjdC5nZXRXaWR0aCgpIC8gMiAtIEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggLSBwcnVuZWROb2RlLmdldFdpZHRoKCkgLyAyLCBub2RlVG9Db25uZWN0LmdldENlbnRlclkoKSk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29TRUxheW91dDtcblxuLyoqKi8gfSksXG4vKiA3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBjb3NlQmFzZSA9IHt9O1xuXG5jb3NlQmFzZS5sYXlvdXRCYXNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbmNvc2VCYXNlLkNvU0VDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuY29zZUJhc2UuQ29TRUVkZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuY29zZUJhc2UuQ29TRUdyYXBoID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbmNvc2VCYXNlLkNvU0VHcmFwaE1hbmFnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuY29zZUJhc2UuQ29TRUxheW91dCA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5jb3NlQmFzZS5Db1NFTm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbm1vZHVsZS5leHBvcnRzID0gY29zZUJhc2U7XG5cbi8qKiovIH0pXG4vKioqKioqLyBdKTtcbn0pOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/cose-base/cose-base.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/cytoscape-cose-bilkent/cytoscape-cose-bilkent.js":
/*!***********************************************************************!*\
  !*** ./node_modules/cytoscape-cose-bilkent/cytoscape-cose-bilkent.js ***!
  \***********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory(__webpack_require__(/*! cose-base */ \"(sc_client)/./node_modules/cose-base/cose-base.js\"));\n\telse {}\n})(this, function(__WEBPACK_EXTERNAL_MODULE_0__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_659__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_659__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__nested_webpack_require_659__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__nested_webpack_require_659__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__nested_webpack_require_659__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__nested_webpack_require_659__.d = function(exports, name, getter) {\n/******/ \t\tif(!__nested_webpack_require_659__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__nested_webpack_require_659__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__nested_webpack_require_659__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__nested_webpack_require_659__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__nested_webpack_require_659__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __nested_webpack_require_659__(__nested_webpack_require_659__.s = 1);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __nested_webpack_require_3201__) {\n\n\"use strict\";\n\n\nvar LayoutConstants = __nested_webpack_require_3201__(0).layoutBase.LayoutConstants;\nvar FDLayoutConstants = __nested_webpack_require_3201__(0).layoutBase.FDLayoutConstants;\nvar CoSEConstants = __nested_webpack_require_3201__(0).CoSEConstants;\nvar CoSELayout = __nested_webpack_require_3201__(0).CoSELayout;\nvar CoSENode = __nested_webpack_require_3201__(0).CoSENode;\nvar PointD = __nested_webpack_require_3201__(0).layoutBase.PointD;\nvar DimensionD = __nested_webpack_require_3201__(0).layoutBase.DimensionD;\n\nvar defaults = {\n  // Called on `layoutready`\n  ready: function ready() {},\n  // Called on `layoutstop`\n  stop: function stop() {},\n  // 'draft', 'default' or 'proof\" \n  // - 'draft' fast cooling rate \n  // - 'default' moderate cooling rate \n  // - \"proof\" slow cooling rate\n  quality: 'default',\n  // include labels in node dimensions\n  nodeDimensionsIncludeLabels: false,\n  // number of ticks per frame; higher is faster but more jerky\n  refresh: 30,\n  // Whether to fit the network view after when done\n  fit: true,\n  // Padding on fit\n  padding: 10,\n  // Whether to enable incremental mode\n  randomize: true,\n  // Node repulsion (non overlapping) multiplier\n  nodeRepulsion: 4500,\n  // Ideal edge (non nested) length\n  idealEdgeLength: 50,\n  // Divisor to compute edge forces\n  edgeElasticity: 0.45,\n  // Nesting factor (multiplier) to compute ideal edge length for nested edges\n  nestingFactor: 0.1,\n  // Gravity force (constant)\n  gravity: 0.25,\n  // Maximum number of iterations to perform\n  numIter: 2500,\n  // For enabling tiling\n  tile: true,\n  // Type of layout animation. The option set is {'during', 'end', false}\n  animate: 'end',\n  // Duration for animate:end\n  animationDuration: 500,\n  // Represents the amount of the vertical space to put between the zero degree members during the tiling operation(can also be a function)\n  tilingPaddingVertical: 10,\n  // Represents the amount of the horizontal space to put between the zero degree members during the tiling operation(can also be a function)\n  tilingPaddingHorizontal: 10,\n  // Gravity range (constant) for compounds\n  gravityRangeCompound: 1.5,\n  // Gravity force (constant) for compounds\n  gravityCompound: 1.0,\n  // Gravity range (constant)\n  gravityRange: 3.8,\n  // Initial cooling factor for incremental layout\n  initialEnergyOnIncremental: 0.5\n};\n\nfunction extend(defaults, options) {\n  var obj = {};\n\n  for (var i in defaults) {\n    obj[i] = defaults[i];\n  }\n\n  for (var i in options) {\n    obj[i] = options[i];\n  }\n\n  return obj;\n};\n\nfunction _CoSELayout(_options) {\n  this.options = extend(defaults, _options);\n  getUserOptions(this.options);\n}\n\nvar getUserOptions = function getUserOptions(options) {\n  if (options.nodeRepulsion != null) CoSEConstants.DEFAULT_REPULSION_STRENGTH = FDLayoutConstants.DEFAULT_REPULSION_STRENGTH = options.nodeRepulsion;\n  if (options.idealEdgeLength != null) CoSEConstants.DEFAULT_EDGE_LENGTH = FDLayoutConstants.DEFAULT_EDGE_LENGTH = options.idealEdgeLength;\n  if (options.edgeElasticity != null) CoSEConstants.DEFAULT_SPRING_STRENGTH = FDLayoutConstants.DEFAULT_SPRING_STRENGTH = options.edgeElasticity;\n  if (options.nestingFactor != null) CoSEConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = options.nestingFactor;\n  if (options.gravity != null) CoSEConstants.DEFAULT_GRAVITY_STRENGTH = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH = options.gravity;\n  if (options.numIter != null) CoSEConstants.MAX_ITERATIONS = FDLayoutConstants.MAX_ITERATIONS = options.numIter;\n  if (options.gravityRange != null) CoSEConstants.DEFAULT_GRAVITY_RANGE_FACTOR = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR = options.gravityRange;\n  if (options.gravityCompound != null) CoSEConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = options.gravityCompound;\n  if (options.gravityRangeCompound != null) CoSEConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = options.gravityRangeCompound;\n  if (options.initialEnergyOnIncremental != null) CoSEConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = options.initialEnergyOnIncremental;\n\n  if (options.quality == 'draft') LayoutConstants.QUALITY = 0;else if (options.quality == 'proof') LayoutConstants.QUALITY = 2;else LayoutConstants.QUALITY = 1;\n\n  CoSEConstants.NODE_DIMENSIONS_INCLUDE_LABELS = FDLayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = LayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = options.nodeDimensionsIncludeLabels;\n  CoSEConstants.DEFAULT_INCREMENTAL = FDLayoutConstants.DEFAULT_INCREMENTAL = LayoutConstants.DEFAULT_INCREMENTAL = !options.randomize;\n  CoSEConstants.ANIMATE = FDLayoutConstants.ANIMATE = LayoutConstants.ANIMATE = options.animate;\n  CoSEConstants.TILE = options.tile;\n  CoSEConstants.TILING_PADDING_VERTICAL = typeof options.tilingPaddingVertical === 'function' ? options.tilingPaddingVertical.call() : options.tilingPaddingVertical;\n  CoSEConstants.TILING_PADDING_HORIZONTAL = typeof options.tilingPaddingHorizontal === 'function' ? options.tilingPaddingHorizontal.call() : options.tilingPaddingHorizontal;\n};\n\n_CoSELayout.prototype.run = function () {\n  var ready;\n  var frameId;\n  var options = this.options;\n  var idToLNode = this.idToLNode = {};\n  var layout = this.layout = new CoSELayout();\n  var self = this;\n\n  self.stopped = false;\n\n  this.cy = this.options.cy;\n\n  this.cy.trigger({ type: 'layoutstart', layout: this });\n\n  var gm = layout.newGraphManager();\n  this.gm = gm;\n\n  var nodes = this.options.eles.nodes();\n  var edges = this.options.eles.edges();\n\n  this.root = gm.addRoot();\n  this.processChildrenList(this.root, this.getTopMostNodes(nodes), layout);\n\n  for (var i = 0; i < edges.length; i++) {\n    var edge = edges[i];\n    var sourceNode = this.idToLNode[edge.data(\"source\")];\n    var targetNode = this.idToLNode[edge.data(\"target\")];\n    if (sourceNode !== targetNode && sourceNode.getEdgesBetween(targetNode).length == 0) {\n      var e1 = gm.add(layout.newEdge(), sourceNode, targetNode);\n      e1.id = edge.id();\n    }\n  }\n\n  var getPositions = function getPositions(ele, i) {\n    if (typeof ele === \"number\") {\n      ele = i;\n    }\n    var theId = ele.data('id');\n    var lNode = self.idToLNode[theId];\n\n    return {\n      x: lNode.getRect().getCenterX(),\n      y: lNode.getRect().getCenterY()\n    };\n  };\n\n  /*\n   * Reposition nodes in iterations animatedly\n   */\n  var iterateAnimated = function iterateAnimated() {\n    // Thigs to perform after nodes are repositioned on screen\n    var afterReposition = function afterReposition() {\n      if (options.fit) {\n        options.cy.fit(options.eles, options.padding);\n      }\n\n      if (!ready) {\n        ready = true;\n        self.cy.one('layoutready', options.ready);\n        self.cy.trigger({ type: 'layoutready', layout: self });\n      }\n    };\n\n    var ticksPerFrame = self.options.refresh;\n    var isDone;\n\n    for (var i = 0; i < ticksPerFrame && !isDone; i++) {\n      isDone = self.stopped || self.layout.tick();\n    }\n\n    // If layout is done\n    if (isDone) {\n      // If the layout is not a sublayout and it is successful perform post layout.\n      if (layout.checkLayoutSuccess() && !layout.isSubLayout) {\n        layout.doPostLayout();\n      }\n\n      // If layout has a tilingPostLayout function property call it.\n      if (layout.tilingPostLayout) {\n        layout.tilingPostLayout();\n      }\n\n      layout.isLayoutFinished = true;\n\n      self.options.eles.nodes().positions(getPositions);\n\n      afterReposition();\n\n      // trigger layoutstop when the layout stops (e.g. finishes)\n      self.cy.one('layoutstop', self.options.stop);\n      self.cy.trigger({ type: 'layoutstop', layout: self });\n\n      if (frameId) {\n        cancelAnimationFrame(frameId);\n      }\n\n      ready = false;\n      return;\n    }\n\n    var animationData = self.layout.getPositionsData(); // Get positions of layout nodes note that all nodes may not be layout nodes because of tiling\n\n    // Position nodes, for the nodes whose id does not included in data (because they are removed from their parents and included in dummy compounds)\n    // use position of their ancestors or dummy ancestors\n    options.eles.nodes().positions(function (ele, i) {\n      if (typeof ele === \"number\") {\n        ele = i;\n      }\n      // If ele is a compound node, then its position will be defined by its children\n      if (!ele.isParent()) {\n        var theId = ele.id();\n        var pNode = animationData[theId];\n        var temp = ele;\n        // If pNode is undefined search until finding position data of its first ancestor (It may be dummy as well)\n        while (pNode == null) {\n          pNode = animationData[temp.data('parent')] || animationData['DummyCompound_' + temp.data('parent')];\n          animationData[theId] = pNode;\n          temp = temp.parent()[0];\n          if (temp == undefined) {\n            break;\n          }\n        }\n        if (pNode != null) {\n          return {\n            x: pNode.x,\n            y: pNode.y\n          };\n        } else {\n          return {\n            x: ele.position('x'),\n            y: ele.position('y')\n          };\n        }\n      }\n    });\n\n    afterReposition();\n\n    frameId = requestAnimationFrame(iterateAnimated);\n  };\n\n  /*\n  * Listen 'layoutstarted' event and start animated iteration if animate option is 'during'\n  */\n  layout.addListener('layoutstarted', function () {\n    if (self.options.animate === 'during') {\n      frameId = requestAnimationFrame(iterateAnimated);\n    }\n  });\n\n  layout.runLayout(); // Run cose layout\n\n  /*\n   * If animate option is not 'during' ('end' or false) perform these here (If it is 'during' similar things are already performed)\n   */\n  if (this.options.animate !== \"during\") {\n    self.options.eles.nodes().not(\":parent\").layoutPositions(self, self.options, getPositions); // Use layout positions to reposition the nodes it considers the options parameter\n    ready = false;\n  }\n\n  return this; // chaining\n};\n\n//Get the top most ones of a list of nodes\n_CoSELayout.prototype.getTopMostNodes = function (nodes) {\n  var nodesMap = {};\n  for (var i = 0; i < nodes.length; i++) {\n    nodesMap[nodes[i].id()] = true;\n  }\n  var roots = nodes.filter(function (ele, i) {\n    if (typeof ele === \"number\") {\n      ele = i;\n    }\n    var parent = ele.parent()[0];\n    while (parent != null) {\n      if (nodesMap[parent.id()]) {\n        return false;\n      }\n      parent = parent.parent()[0];\n    }\n    return true;\n  });\n\n  return roots;\n};\n\n_CoSELayout.prototype.processChildrenList = function (parent, children, layout) {\n  var size = children.length;\n  for (var i = 0; i < size; i++) {\n    var theChild = children[i];\n    var children_of_children = theChild.children();\n    var theNode;\n\n    var dimensions = theChild.layoutDimensions({\n      nodeDimensionsIncludeLabels: this.options.nodeDimensionsIncludeLabels\n    });\n\n    if (theChild.outerWidth() != null && theChild.outerHeight() != null) {\n      theNode = parent.add(new CoSENode(layout.graphManager, new PointD(theChild.position('x') - dimensions.w / 2, theChild.position('y') - dimensions.h / 2), new DimensionD(parseFloat(dimensions.w), parseFloat(dimensions.h))));\n    } else {\n      theNode = parent.add(new CoSENode(this.graphManager));\n    }\n    // Attach id to the layout node\n    theNode.id = theChild.data(\"id\");\n    // Attach the paddings of cy node to layout node\n    theNode.paddingLeft = parseInt(theChild.css('padding'));\n    theNode.paddingTop = parseInt(theChild.css('padding'));\n    theNode.paddingRight = parseInt(theChild.css('padding'));\n    theNode.paddingBottom = parseInt(theChild.css('padding'));\n\n    //Attach the label properties to compound if labels will be included in node dimensions  \n    if (this.options.nodeDimensionsIncludeLabels) {\n      if (theChild.isParent()) {\n        var labelWidth = theChild.boundingBox({ includeLabels: true, includeNodes: false }).w;\n        var labelHeight = theChild.boundingBox({ includeLabels: true, includeNodes: false }).h;\n        var labelPos = theChild.css(\"text-halign\");\n        theNode.labelWidth = labelWidth;\n        theNode.labelHeight = labelHeight;\n        theNode.labelPos = labelPos;\n      }\n    }\n\n    // Map the layout node\n    this.idToLNode[theChild.data(\"id\")] = theNode;\n\n    if (isNaN(theNode.rect.x)) {\n      theNode.rect.x = 0;\n    }\n\n    if (isNaN(theNode.rect.y)) {\n      theNode.rect.y = 0;\n    }\n\n    if (children_of_children != null && children_of_children.length > 0) {\n      var theNewGraph;\n      theNewGraph = layout.getGraphManager().add(layout.newGraph(), theNode);\n      this.processChildrenList(theNewGraph, children_of_children, layout);\n    }\n  }\n};\n\n/**\n * @brief : called on continuous layouts to stop them before they finish\n */\n_CoSELayout.prototype.stop = function () {\n  this.stopped = true;\n\n  return this; // chaining\n};\n\nvar register = function register(cytoscape) {\n  //  var Layout = getLayout( cytoscape );\n\n  cytoscape('layout', 'cose-bilkent', _CoSELayout);\n};\n\n// auto reg for globals\nif (typeof cytoscape !== 'undefined') {\n  register(cytoscape);\n}\n\nmodule.exports = register;\n\n/***/ })\n/******/ ]);\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvY3l0b3NjYXBlLWNvc2UtYmlsa2VudC9jeXRvc2NhcGUtY29zZS1iaWxrZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsSUFBSSxJQUF5RDtBQUM3RCwyQkFBMkIsbUJBQU8sQ0FBQyxvRUFBVztBQUM5QyxNQUFNLEVBS3FEO0FBQzNELENBQUM7QUFDRCxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsOEJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLDhCQUFtQjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QjtBQUNBO0FBQ0EsVUFBVSw4QkFBbUIsdUJBQXVCO0FBQ3BEO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QixlQUFlLDhCQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCO0FBQ0Esb0NBQW9DLDRCQUE0QjtBQUNoRSwwQ0FBMEM7QUFDMUMsV0FBVyw4QkFBbUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQixrQ0FBa0M7QUFDL0Q7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCO0FBQ0E7QUFDQSxpQkFBaUIsOEJBQW1CLENBQUMsOEJBQW1CO0FBQ3hELFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsK0JBQW1COztBQUVwRDs7O0FBR0Esc0JBQXNCLCtCQUFtQjtBQUN6Qyx3QkFBd0IsK0JBQW1CO0FBQzNDLG9CQUFvQiwrQkFBbUI7QUFDdkMsaUJBQWlCLCtCQUFt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QUVBLGVBQWU7QUFDZjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NoYXRncHQtbmV4dC13ZWIvLi9ub2RlX21vZHVsZXMvY3l0b3NjYXBlLWNvc2UtYmlsa2VudC9jeXRvc2NhcGUtY29zZS1iaWxrZW50LmpzP2EyNjkiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiY29zZS1iYXNlXCIpKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtcImNvc2UtYmFzZVwiXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJjeXRvc2NhcGVDb3NlQmlsa2VudFwiXSA9IGZhY3RvcnkocmVxdWlyZShcImNvc2UtYmFzZVwiKSk7XG5cdGVsc2Vcblx0XHRyb290W1wiY3l0b3NjYXBlQ29zZUJpbGtlbnRcIl0gPSBmYWN0b3J5KHJvb3RbXCJjb3NlQmFzZVwiXSk7XG59KSh0aGlzLCBmdW5jdGlvbihfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzBfXykge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBpZGVudGl0eSBmdW5jdGlvbiBmb3IgY2FsbGluZyBoYXJtb255IGltcG9ydHMgd2l0aCB0aGUgY29ycmVjdCBjb250ZXh0XG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uaSA9IGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuLyoqKioqKi8gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuLyoqKioqKi8gXHRcdFx0XHRnZXQ6IGdldHRlclxuLyoqKioqKi8gXHRcdFx0fSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDEpO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMF9fO1xuXG4vKioqLyB9KSxcbi8qIDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIExheW91dENvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oMCkubGF5b3V0QmFzZS5MYXlvdXRDb25zdGFudHM7XG52YXIgRkRMYXlvdXRDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApLmxheW91dEJhc2UuRkRMYXlvdXRDb25zdGFudHM7XG52YXIgQ29TRUNvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oMCkuQ29TRUNvbnN0YW50cztcbnZhciBDb1NFTGF5b3V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKS5Db1NFTGF5b3V0O1xudmFyIENvU0VOb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKS5Db1NFTm9kZTtcbnZhciBQb2ludEQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApLmxheW91dEJhc2UuUG9pbnREO1xudmFyIERpbWVuc2lvbkQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApLmxheW91dEJhc2UuRGltZW5zaW9uRDtcblxudmFyIGRlZmF1bHRzID0ge1xuICAvLyBDYWxsZWQgb24gYGxheW91dHJlYWR5YFxuICByZWFkeTogZnVuY3Rpb24gcmVhZHkoKSB7fSxcbiAgLy8gQ2FsbGVkIG9uIGBsYXlvdXRzdG9wYFxuICBzdG9wOiBmdW5jdGlvbiBzdG9wKCkge30sXG4gIC8vICdkcmFmdCcsICdkZWZhdWx0JyBvciAncHJvb2ZcIiBcbiAgLy8gLSAnZHJhZnQnIGZhc3QgY29vbGluZyByYXRlIFxuICAvLyAtICdkZWZhdWx0JyBtb2RlcmF0ZSBjb29saW5nIHJhdGUgXG4gIC8vIC0gXCJwcm9vZlwiIHNsb3cgY29vbGluZyByYXRlXG4gIHF1YWxpdHk6ICdkZWZhdWx0JyxcbiAgLy8gaW5jbHVkZSBsYWJlbHMgaW4gbm9kZSBkaW1lbnNpb25zXG4gIG5vZGVEaW1lbnNpb25zSW5jbHVkZUxhYmVsczogZmFsc2UsXG4gIC8vIG51bWJlciBvZiB0aWNrcyBwZXIgZnJhbWU7IGhpZ2hlciBpcyBmYXN0ZXIgYnV0IG1vcmUgamVya3lcbiAgcmVmcmVzaDogMzAsXG4gIC8vIFdoZXRoZXIgdG8gZml0IHRoZSBuZXR3b3JrIHZpZXcgYWZ0ZXIgd2hlbiBkb25lXG4gIGZpdDogdHJ1ZSxcbiAgLy8gUGFkZGluZyBvbiBmaXRcbiAgcGFkZGluZzogMTAsXG4gIC8vIFdoZXRoZXIgdG8gZW5hYmxlIGluY3JlbWVudGFsIG1vZGVcbiAgcmFuZG9taXplOiB0cnVlLFxuICAvLyBOb2RlIHJlcHVsc2lvbiAobm9uIG92ZXJsYXBwaW5nKSBtdWx0aXBsaWVyXG4gIG5vZGVSZXB1bHNpb246IDQ1MDAsXG4gIC8vIElkZWFsIGVkZ2UgKG5vbiBuZXN0ZWQpIGxlbmd0aFxuICBpZGVhbEVkZ2VMZW5ndGg6IDUwLFxuICAvLyBEaXZpc29yIHRvIGNvbXB1dGUgZWRnZSBmb3JjZXNcbiAgZWRnZUVsYXN0aWNpdHk6IDAuNDUsXG4gIC8vIE5lc3RpbmcgZmFjdG9yIChtdWx0aXBsaWVyKSB0byBjb21wdXRlIGlkZWFsIGVkZ2UgbGVuZ3RoIGZvciBuZXN0ZWQgZWRnZXNcbiAgbmVzdGluZ0ZhY3RvcjogMC4xLFxuICAvLyBHcmF2aXR5IGZvcmNlIChjb25zdGFudClcbiAgZ3Jhdml0eTogMC4yNSxcbiAgLy8gTWF4aW11bSBudW1iZXIgb2YgaXRlcmF0aW9ucyB0byBwZXJmb3JtXG4gIG51bUl0ZXI6IDI1MDAsXG4gIC8vIEZvciBlbmFibGluZyB0aWxpbmdcbiAgdGlsZTogdHJ1ZSxcbiAgLy8gVHlwZSBvZiBsYXlvdXQgYW5pbWF0aW9uLiBUaGUgb3B0aW9uIHNldCBpcyB7J2R1cmluZycsICdlbmQnLCBmYWxzZX1cbiAgYW5pbWF0ZTogJ2VuZCcsXG4gIC8vIER1cmF0aW9uIGZvciBhbmltYXRlOmVuZFxuICBhbmltYXRpb25EdXJhdGlvbjogNTAwLFxuICAvLyBSZXByZXNlbnRzIHRoZSBhbW91bnQgb2YgdGhlIHZlcnRpY2FsIHNwYWNlIHRvIHB1dCBiZXR3ZWVuIHRoZSB6ZXJvIGRlZ3JlZSBtZW1iZXJzIGR1cmluZyB0aGUgdGlsaW5nIG9wZXJhdGlvbihjYW4gYWxzbyBiZSBhIGZ1bmN0aW9uKVxuICB0aWxpbmdQYWRkaW5nVmVydGljYWw6IDEwLFxuICAvLyBSZXByZXNlbnRzIHRoZSBhbW91bnQgb2YgdGhlIGhvcml6b250YWwgc3BhY2UgdG8gcHV0IGJldHdlZW4gdGhlIHplcm8gZGVncmVlIG1lbWJlcnMgZHVyaW5nIHRoZSB0aWxpbmcgb3BlcmF0aW9uKGNhbiBhbHNvIGJlIGEgZnVuY3Rpb24pXG4gIHRpbGluZ1BhZGRpbmdIb3Jpem9udGFsOiAxMCxcbiAgLy8gR3Jhdml0eSByYW5nZSAoY29uc3RhbnQpIGZvciBjb21wb3VuZHNcbiAgZ3Jhdml0eVJhbmdlQ29tcG91bmQ6IDEuNSxcbiAgLy8gR3Jhdml0eSBmb3JjZSAoY29uc3RhbnQpIGZvciBjb21wb3VuZHNcbiAgZ3Jhdml0eUNvbXBvdW5kOiAxLjAsXG4gIC8vIEdyYXZpdHkgcmFuZ2UgKGNvbnN0YW50KVxuICBncmF2aXR5UmFuZ2U6IDMuOCxcbiAgLy8gSW5pdGlhbCBjb29saW5nIGZhY3RvciBmb3IgaW5jcmVtZW50YWwgbGF5b3V0XG4gIGluaXRpYWxFbmVyZ3lPbkluY3JlbWVudGFsOiAwLjVcbn07XG5cbmZ1bmN0aW9uIGV4dGVuZChkZWZhdWx0cywgb3B0aW9ucykge1xuICB2YXIgb2JqID0ge307XG5cbiAgZm9yICh2YXIgaSBpbiBkZWZhdWx0cykge1xuICAgIG9ialtpXSA9IGRlZmF1bHRzW2ldO1xuICB9XG5cbiAgZm9yICh2YXIgaSBpbiBvcHRpb25zKSB7XG4gICAgb2JqW2ldID0gb3B0aW9uc1tpXTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG5mdW5jdGlvbiBfQ29TRUxheW91dChfb3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBleHRlbmQoZGVmYXVsdHMsIF9vcHRpb25zKTtcbiAgZ2V0VXNlck9wdGlvbnModGhpcy5vcHRpb25zKTtcbn1cblxudmFyIGdldFVzZXJPcHRpb25zID0gZnVuY3Rpb24gZ2V0VXNlck9wdGlvbnMob3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5ub2RlUmVwdWxzaW9uICE9IG51bGwpIENvU0VDb25zdGFudHMuREVGQVVMVF9SRVBVTFNJT05fU1RSRU5HVEggPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX1JFUFVMU0lPTl9TVFJFTkdUSCA9IG9wdGlvbnMubm9kZVJlcHVsc2lvbjtcbiAgaWYgKG9wdGlvbnMuaWRlYWxFZGdlTGVuZ3RoICE9IG51bGwpIENvU0VDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSCA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggPSBvcHRpb25zLmlkZWFsRWRnZUxlbmd0aDtcbiAgaWYgKG9wdGlvbnMuZWRnZUVsYXN0aWNpdHkgIT0gbnVsbCkgQ29TRUNvbnN0YW50cy5ERUZBVUxUX1NQUklOR19TVFJFTkdUSCA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfU1BSSU5HX1NUUkVOR1RIID0gb3B0aW9ucy5lZGdlRWxhc3RpY2l0eTtcbiAgaWYgKG9wdGlvbnMubmVzdGluZ0ZhY3RvciAhPSBudWxsKSBDb1NFQ29uc3RhbnRzLlBFUl9MRVZFTF9JREVBTF9FREdFX0xFTkdUSF9GQUNUT1IgPSBGRExheW91dENvbnN0YW50cy5QRVJfTEVWRUxfSURFQUxfRURHRV9MRU5HVEhfRkFDVE9SID0gb3B0aW9ucy5uZXN0aW5nRmFjdG9yO1xuICBpZiAob3B0aW9ucy5ncmF2aXR5ICE9IG51bGwpIENvU0VDb25zdGFudHMuREVGQVVMVF9HUkFWSVRZX1NUUkVOR1RIID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9HUkFWSVRZX1NUUkVOR1RIID0gb3B0aW9ucy5ncmF2aXR5O1xuICBpZiAob3B0aW9ucy5udW1JdGVyICE9IG51bGwpIENvU0VDb25zdGFudHMuTUFYX0lURVJBVElPTlMgPSBGRExheW91dENvbnN0YW50cy5NQVhfSVRFUkFUSU9OUyA9IG9wdGlvbnMubnVtSXRlcjtcbiAgaWYgKG9wdGlvbnMuZ3Jhdml0eVJhbmdlICE9IG51bGwpIENvU0VDb25zdGFudHMuREVGQVVMVF9HUkFWSVRZX1JBTkdFX0ZBQ1RPUiA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfR1JBVklUWV9SQU5HRV9GQUNUT1IgPSBvcHRpb25zLmdyYXZpdHlSYW5nZTtcbiAgaWYgKG9wdGlvbnMuZ3Jhdml0eUNvbXBvdW5kICE9IG51bGwpIENvU0VDb25zdGFudHMuREVGQVVMVF9DT01QT1VORF9HUkFWSVRZX1NUUkVOR1RIID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9DT01QT1VORF9HUkFWSVRZX1NUUkVOR1RIID0gb3B0aW9ucy5ncmF2aXR5Q29tcG91bmQ7XG4gIGlmIChvcHRpb25zLmdyYXZpdHlSYW5nZUNvbXBvdW5kICE9IG51bGwpIENvU0VDb25zdGFudHMuREVGQVVMVF9DT01QT1VORF9HUkFWSVRZX1JBTkdFX0ZBQ1RPUiA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQ09NUE9VTkRfR1JBVklUWV9SQU5HRV9GQUNUT1IgPSBvcHRpb25zLmdyYXZpdHlSYW5nZUNvbXBvdW5kO1xuICBpZiAob3B0aW9ucy5pbml0aWFsRW5lcmd5T25JbmNyZW1lbnRhbCAhPSBudWxsKSBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfQ09PTElOR19GQUNUT1JfSU5DUkVNRU5UQUwgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0NPT0xJTkdfRkFDVE9SX0lOQ1JFTUVOVEFMID0gb3B0aW9ucy5pbml0aWFsRW5lcmd5T25JbmNyZW1lbnRhbDtcblxuICBpZiAob3B0aW9ucy5xdWFsaXR5ID09ICdkcmFmdCcpIExheW91dENvbnN0YW50cy5RVUFMSVRZID0gMDtlbHNlIGlmIChvcHRpb25zLnF1YWxpdHkgPT0gJ3Byb29mJykgTGF5b3V0Q29uc3RhbnRzLlFVQUxJVFkgPSAyO2Vsc2UgTGF5b3V0Q29uc3RhbnRzLlFVQUxJVFkgPSAxO1xuXG4gIENvU0VDb25zdGFudHMuTk9ERV9ESU1FTlNJT05TX0lOQ0xVREVfTEFCRUxTID0gRkRMYXlvdXRDb25zdGFudHMuTk9ERV9ESU1FTlNJT05TX0lOQ0xVREVfTEFCRUxTID0gTGF5b3V0Q29uc3RhbnRzLk5PREVfRElNRU5TSU9OU19JTkNMVURFX0xBQkVMUyA9IG9wdGlvbnMubm9kZURpbWVuc2lvbnNJbmNsdWRlTGFiZWxzO1xuICBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfSU5DUkVNRU5UQUwgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0lOQ1JFTUVOVEFMID0gTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfSU5DUkVNRU5UQUwgPSAhb3B0aW9ucy5yYW5kb21pemU7XG4gIENvU0VDb25zdGFudHMuQU5JTUFURSA9IEZETGF5b3V0Q29uc3RhbnRzLkFOSU1BVEUgPSBMYXlvdXRDb25zdGFudHMuQU5JTUFURSA9IG9wdGlvbnMuYW5pbWF0ZTtcbiAgQ29TRUNvbnN0YW50cy5USUxFID0gb3B0aW9ucy50aWxlO1xuICBDb1NFQ29uc3RhbnRzLlRJTElOR19QQURESU5HX1ZFUlRJQ0FMID0gdHlwZW9mIG9wdGlvbnMudGlsaW5nUGFkZGluZ1ZlcnRpY2FsID09PSAnZnVuY3Rpb24nID8gb3B0aW9ucy50aWxpbmdQYWRkaW5nVmVydGljYWwuY2FsbCgpIDogb3B0aW9ucy50aWxpbmdQYWRkaW5nVmVydGljYWw7XG4gIENvU0VDb25zdGFudHMuVElMSU5HX1BBRERJTkdfSE9SSVpPTlRBTCA9IHR5cGVvZiBvcHRpb25zLnRpbGluZ1BhZGRpbmdIb3Jpem9udGFsID09PSAnZnVuY3Rpb24nID8gb3B0aW9ucy50aWxpbmdQYWRkaW5nSG9yaXpvbnRhbC5jYWxsKCkgOiBvcHRpb25zLnRpbGluZ1BhZGRpbmdIb3Jpem9udGFsO1xufTtcblxuX0NvU0VMYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJlYWR5O1xuICB2YXIgZnJhbWVJZDtcbiAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gIHZhciBpZFRvTE5vZGUgPSB0aGlzLmlkVG9MTm9kZSA9IHt9O1xuICB2YXIgbGF5b3V0ID0gdGhpcy5sYXlvdXQgPSBuZXcgQ29TRUxheW91dCgpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgc2VsZi5zdG9wcGVkID0gZmFsc2U7XG5cbiAgdGhpcy5jeSA9IHRoaXMub3B0aW9ucy5jeTtcblxuICB0aGlzLmN5LnRyaWdnZXIoeyB0eXBlOiAnbGF5b3V0c3RhcnQnLCBsYXlvdXQ6IHRoaXMgfSk7XG5cbiAgdmFyIGdtID0gbGF5b3V0Lm5ld0dyYXBoTWFuYWdlcigpO1xuICB0aGlzLmdtID0gZ207XG5cbiAgdmFyIG5vZGVzID0gdGhpcy5vcHRpb25zLmVsZXMubm9kZXMoKTtcbiAgdmFyIGVkZ2VzID0gdGhpcy5vcHRpb25zLmVsZXMuZWRnZXMoKTtcblxuICB0aGlzLnJvb3QgPSBnbS5hZGRSb290KCk7XG4gIHRoaXMucHJvY2Vzc0NoaWxkcmVuTGlzdCh0aGlzLnJvb3QsIHRoaXMuZ2V0VG9wTW9zdE5vZGVzKG5vZGVzKSwgbGF5b3V0KTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVkZ2UgPSBlZGdlc1tpXTtcbiAgICB2YXIgc291cmNlTm9kZSA9IHRoaXMuaWRUb0xOb2RlW2VkZ2UuZGF0YShcInNvdXJjZVwiKV07XG4gICAgdmFyIHRhcmdldE5vZGUgPSB0aGlzLmlkVG9MTm9kZVtlZGdlLmRhdGEoXCJ0YXJnZXRcIildO1xuICAgIGlmIChzb3VyY2VOb2RlICE9PSB0YXJnZXROb2RlICYmIHNvdXJjZU5vZGUuZ2V0RWRnZXNCZXR3ZWVuKHRhcmdldE5vZGUpLmxlbmd0aCA9PSAwKSB7XG4gICAgICB2YXIgZTEgPSBnbS5hZGQobGF5b3V0Lm5ld0VkZ2UoKSwgc291cmNlTm9kZSwgdGFyZ2V0Tm9kZSk7XG4gICAgICBlMS5pZCA9IGVkZ2UuaWQoKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZ2V0UG9zaXRpb25zID0gZnVuY3Rpb24gZ2V0UG9zaXRpb25zKGVsZSwgaSkge1xuICAgIGlmICh0eXBlb2YgZWxlID09PSBcIm51bWJlclwiKSB7XG4gICAgICBlbGUgPSBpO1xuICAgIH1cbiAgICB2YXIgdGhlSWQgPSBlbGUuZGF0YSgnaWQnKTtcbiAgICB2YXIgbE5vZGUgPSBzZWxmLmlkVG9MTm9kZVt0aGVJZF07XG5cbiAgICByZXR1cm4ge1xuICAgICAgeDogbE5vZGUuZ2V0UmVjdCgpLmdldENlbnRlclgoKSxcbiAgICAgIHk6IGxOb2RlLmdldFJlY3QoKS5nZXRDZW50ZXJZKClcbiAgICB9O1xuICB9O1xuXG4gIC8qXG4gICAqIFJlcG9zaXRpb24gbm9kZXMgaW4gaXRlcmF0aW9ucyBhbmltYXRlZGx5XG4gICAqL1xuICB2YXIgaXRlcmF0ZUFuaW1hdGVkID0gZnVuY3Rpb24gaXRlcmF0ZUFuaW1hdGVkKCkge1xuICAgIC8vIFRoaWdzIHRvIHBlcmZvcm0gYWZ0ZXIgbm9kZXMgYXJlIHJlcG9zaXRpb25lZCBvbiBzY3JlZW5cbiAgICB2YXIgYWZ0ZXJSZXBvc2l0aW9uID0gZnVuY3Rpb24gYWZ0ZXJSZXBvc2l0aW9uKCkge1xuICAgICAgaWYgKG9wdGlvbnMuZml0KSB7XG4gICAgICAgIG9wdGlvbnMuY3kuZml0KG9wdGlvbnMuZWxlcywgb3B0aW9ucy5wYWRkaW5nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFyZWFkeSkge1xuICAgICAgICByZWFkeSA9IHRydWU7XG4gICAgICAgIHNlbGYuY3kub25lKCdsYXlvdXRyZWFkeScsIG9wdGlvbnMucmVhZHkpO1xuICAgICAgICBzZWxmLmN5LnRyaWdnZXIoeyB0eXBlOiAnbGF5b3V0cmVhZHknLCBsYXlvdXQ6IHNlbGYgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciB0aWNrc1BlckZyYW1lID0gc2VsZi5vcHRpb25zLnJlZnJlc2g7XG4gICAgdmFyIGlzRG9uZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGlja3NQZXJGcmFtZSAmJiAhaXNEb25lOyBpKyspIHtcbiAgICAgIGlzRG9uZSA9IHNlbGYuc3RvcHBlZCB8fCBzZWxmLmxheW91dC50aWNrKCk7XG4gICAgfVxuXG4gICAgLy8gSWYgbGF5b3V0IGlzIGRvbmVcbiAgICBpZiAoaXNEb25lKSB7XG4gICAgICAvLyBJZiB0aGUgbGF5b3V0IGlzIG5vdCBhIHN1YmxheW91dCBhbmQgaXQgaXMgc3VjY2Vzc2Z1bCBwZXJmb3JtIHBvc3QgbGF5b3V0LlxuICAgICAgaWYgKGxheW91dC5jaGVja0xheW91dFN1Y2Nlc3MoKSAmJiAhbGF5b3V0LmlzU3ViTGF5b3V0KSB7XG4gICAgICAgIGxheW91dC5kb1Bvc3RMYXlvdXQoKTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgbGF5b3V0IGhhcyBhIHRpbGluZ1Bvc3RMYXlvdXQgZnVuY3Rpb24gcHJvcGVydHkgY2FsbCBpdC5cbiAgICAgIGlmIChsYXlvdXQudGlsaW5nUG9zdExheW91dCkge1xuICAgICAgICBsYXlvdXQudGlsaW5nUG9zdExheW91dCgpO1xuICAgICAgfVxuXG4gICAgICBsYXlvdXQuaXNMYXlvdXRGaW5pc2hlZCA9IHRydWU7XG5cbiAgICAgIHNlbGYub3B0aW9ucy5lbGVzLm5vZGVzKCkucG9zaXRpb25zKGdldFBvc2l0aW9ucyk7XG5cbiAgICAgIGFmdGVyUmVwb3NpdGlvbigpO1xuXG4gICAgICAvLyB0cmlnZ2VyIGxheW91dHN0b3Agd2hlbiB0aGUgbGF5b3V0IHN0b3BzIChlLmcuIGZpbmlzaGVzKVxuICAgICAgc2VsZi5jeS5vbmUoJ2xheW91dHN0b3AnLCBzZWxmLm9wdGlvbnMuc3RvcCk7XG4gICAgICBzZWxmLmN5LnRyaWdnZXIoeyB0eXBlOiAnbGF5b3V0c3RvcCcsIGxheW91dDogc2VsZiB9KTtcblxuICAgICAgaWYgKGZyYW1lSWQpIHtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoZnJhbWVJZCk7XG4gICAgICB9XG5cbiAgICAgIHJlYWR5ID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGFuaW1hdGlvbkRhdGEgPSBzZWxmLmxheW91dC5nZXRQb3NpdGlvbnNEYXRhKCk7IC8vIEdldCBwb3NpdGlvbnMgb2YgbGF5b3V0IG5vZGVzIG5vdGUgdGhhdCBhbGwgbm9kZXMgbWF5IG5vdCBiZSBsYXlvdXQgbm9kZXMgYmVjYXVzZSBvZiB0aWxpbmdcblxuICAgIC8vIFBvc2l0aW9uIG5vZGVzLCBmb3IgdGhlIG5vZGVzIHdob3NlIGlkIGRvZXMgbm90IGluY2x1ZGVkIGluIGRhdGEgKGJlY2F1c2UgdGhleSBhcmUgcmVtb3ZlZCBmcm9tIHRoZWlyIHBhcmVudHMgYW5kIGluY2x1ZGVkIGluIGR1bW15IGNvbXBvdW5kcylcbiAgICAvLyB1c2UgcG9zaXRpb24gb2YgdGhlaXIgYW5jZXN0b3JzIG9yIGR1bW15IGFuY2VzdG9yc1xuICAgIG9wdGlvbnMuZWxlcy5ub2RlcygpLnBvc2l0aW9ucyhmdW5jdGlvbiAoZWxlLCBpKSB7XG4gICAgICBpZiAodHlwZW9mIGVsZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBlbGUgPSBpO1xuICAgICAgfVxuICAgICAgLy8gSWYgZWxlIGlzIGEgY29tcG91bmQgbm9kZSwgdGhlbiBpdHMgcG9zaXRpb24gd2lsbCBiZSBkZWZpbmVkIGJ5IGl0cyBjaGlsZHJlblxuICAgICAgaWYgKCFlbGUuaXNQYXJlbnQoKSkge1xuICAgICAgICB2YXIgdGhlSWQgPSBlbGUuaWQoKTtcbiAgICAgICAgdmFyIHBOb2RlID0gYW5pbWF0aW9uRGF0YVt0aGVJZF07XG4gICAgICAgIHZhciB0ZW1wID0gZWxlO1xuICAgICAgICAvLyBJZiBwTm9kZSBpcyB1bmRlZmluZWQgc2VhcmNoIHVudGlsIGZpbmRpbmcgcG9zaXRpb24gZGF0YSBvZiBpdHMgZmlyc3QgYW5jZXN0b3IgKEl0IG1heSBiZSBkdW1teSBhcyB3ZWxsKVxuICAgICAgICB3aGlsZSAocE5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgIHBOb2RlID0gYW5pbWF0aW9uRGF0YVt0ZW1wLmRhdGEoJ3BhcmVudCcpXSB8fCBhbmltYXRpb25EYXRhWydEdW1teUNvbXBvdW5kXycgKyB0ZW1wLmRhdGEoJ3BhcmVudCcpXTtcbiAgICAgICAgICBhbmltYXRpb25EYXRhW3RoZUlkXSA9IHBOb2RlO1xuICAgICAgICAgIHRlbXAgPSB0ZW1wLnBhcmVudCgpWzBdO1xuICAgICAgICAgIGlmICh0ZW1wID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwTm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHBOb2RlLngsXG4gICAgICAgICAgICB5OiBwTm9kZS55XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogZWxlLnBvc2l0aW9uKCd4JyksXG4gICAgICAgICAgICB5OiBlbGUucG9zaXRpb24oJ3knKVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGFmdGVyUmVwb3NpdGlvbigpO1xuXG4gICAgZnJhbWVJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShpdGVyYXRlQW5pbWF0ZWQpO1xuICB9O1xuXG4gIC8qXG4gICogTGlzdGVuICdsYXlvdXRzdGFydGVkJyBldmVudCBhbmQgc3RhcnQgYW5pbWF0ZWQgaXRlcmF0aW9uIGlmIGFuaW1hdGUgb3B0aW9uIGlzICdkdXJpbmcnXG4gICovXG4gIGxheW91dC5hZGRMaXN0ZW5lcignbGF5b3V0c3RhcnRlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc2VsZi5vcHRpb25zLmFuaW1hdGUgPT09ICdkdXJpbmcnKSB7XG4gICAgICBmcmFtZUlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGl0ZXJhdGVBbmltYXRlZCk7XG4gICAgfVxuICB9KTtcblxuICBsYXlvdXQucnVuTGF5b3V0KCk7IC8vIFJ1biBjb3NlIGxheW91dFxuXG4gIC8qXG4gICAqIElmIGFuaW1hdGUgb3B0aW9uIGlzIG5vdCAnZHVyaW5nJyAoJ2VuZCcgb3IgZmFsc2UpIHBlcmZvcm0gdGhlc2UgaGVyZSAoSWYgaXQgaXMgJ2R1cmluZycgc2ltaWxhciB0aGluZ3MgYXJlIGFscmVhZHkgcGVyZm9ybWVkKVxuICAgKi9cbiAgaWYgKHRoaXMub3B0aW9ucy5hbmltYXRlICE9PSBcImR1cmluZ1wiKSB7XG4gICAgc2VsZi5vcHRpb25zLmVsZXMubm9kZXMoKS5ub3QoXCI6cGFyZW50XCIpLmxheW91dFBvc2l0aW9ucyhzZWxmLCBzZWxmLm9wdGlvbnMsIGdldFBvc2l0aW9ucyk7IC8vIFVzZSBsYXlvdXQgcG9zaXRpb25zIHRvIHJlcG9zaXRpb24gdGhlIG5vZGVzIGl0IGNvbnNpZGVycyB0aGUgb3B0aW9ucyBwYXJhbWV0ZXJcbiAgICByZWFkeSA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuXG4vL0dldCB0aGUgdG9wIG1vc3Qgb25lcyBvZiBhIGxpc3Qgb2Ygbm9kZXNcbl9Db1NFTGF5b3V0LnByb3RvdHlwZS5nZXRUb3BNb3N0Tm9kZXMgPSBmdW5jdGlvbiAobm9kZXMpIHtcbiAgdmFyIG5vZGVzTWFwID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBub2Rlc01hcFtub2Rlc1tpXS5pZCgpXSA9IHRydWU7XG4gIH1cbiAgdmFyIHJvb3RzID0gbm9kZXMuZmlsdGVyKGZ1bmN0aW9uIChlbGUsIGkpIHtcbiAgICBpZiAodHlwZW9mIGVsZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgZWxlID0gaTtcbiAgICB9XG4gICAgdmFyIHBhcmVudCA9IGVsZS5wYXJlbnQoKVswXTtcbiAgICB3aGlsZSAocGFyZW50ICE9IG51bGwpIHtcbiAgICAgIGlmIChub2Rlc01hcFtwYXJlbnQuaWQoKV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudCgpWzBdO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIHJvb3RzO1xufTtcblxuX0NvU0VMYXlvdXQucHJvdG90eXBlLnByb2Nlc3NDaGlsZHJlbkxpc3QgPSBmdW5jdGlvbiAocGFyZW50LCBjaGlsZHJlbiwgbGF5b3V0KSB7XG4gIHZhciBzaXplID0gY2hpbGRyZW4ubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgIHZhciB0aGVDaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgIHZhciBjaGlsZHJlbl9vZl9jaGlsZHJlbiA9IHRoZUNoaWxkLmNoaWxkcmVuKCk7XG4gICAgdmFyIHRoZU5vZGU7XG5cbiAgICB2YXIgZGltZW5zaW9ucyA9IHRoZUNoaWxkLmxheW91dERpbWVuc2lvbnMoe1xuICAgICAgbm9kZURpbWVuc2lvbnNJbmNsdWRlTGFiZWxzOiB0aGlzLm9wdGlvbnMubm9kZURpbWVuc2lvbnNJbmNsdWRlTGFiZWxzXG4gICAgfSk7XG5cbiAgICBpZiAodGhlQ2hpbGQub3V0ZXJXaWR0aCgpICE9IG51bGwgJiYgdGhlQ2hpbGQub3V0ZXJIZWlnaHQoKSAhPSBudWxsKSB7XG4gICAgICB0aGVOb2RlID0gcGFyZW50LmFkZChuZXcgQ29TRU5vZGUobGF5b3V0LmdyYXBoTWFuYWdlciwgbmV3IFBvaW50RCh0aGVDaGlsZC5wb3NpdGlvbigneCcpIC0gZGltZW5zaW9ucy53IC8gMiwgdGhlQ2hpbGQucG9zaXRpb24oJ3knKSAtIGRpbWVuc2lvbnMuaCAvIDIpLCBuZXcgRGltZW5zaW9uRChwYXJzZUZsb2F0KGRpbWVuc2lvbnMudyksIHBhcnNlRmxvYXQoZGltZW5zaW9ucy5oKSkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhlTm9kZSA9IHBhcmVudC5hZGQobmV3IENvU0VOb2RlKHRoaXMuZ3JhcGhNYW5hZ2VyKSk7XG4gICAgfVxuICAgIC8vIEF0dGFjaCBpZCB0byB0aGUgbGF5b3V0IG5vZGVcbiAgICB0aGVOb2RlLmlkID0gdGhlQ2hpbGQuZGF0YShcImlkXCIpO1xuICAgIC8vIEF0dGFjaCB0aGUgcGFkZGluZ3Mgb2YgY3kgbm9kZSB0byBsYXlvdXQgbm9kZVxuICAgIHRoZU5vZGUucGFkZGluZ0xlZnQgPSBwYXJzZUludCh0aGVDaGlsZC5jc3MoJ3BhZGRpbmcnKSk7XG4gICAgdGhlTm9kZS5wYWRkaW5nVG9wID0gcGFyc2VJbnQodGhlQ2hpbGQuY3NzKCdwYWRkaW5nJykpO1xuICAgIHRoZU5vZGUucGFkZGluZ1JpZ2h0ID0gcGFyc2VJbnQodGhlQ2hpbGQuY3NzKCdwYWRkaW5nJykpO1xuICAgIHRoZU5vZGUucGFkZGluZ0JvdHRvbSA9IHBhcnNlSW50KHRoZUNoaWxkLmNzcygncGFkZGluZycpKTtcblxuICAgIC8vQXR0YWNoIHRoZSBsYWJlbCBwcm9wZXJ0aWVzIHRvIGNvbXBvdW5kIGlmIGxhYmVscyB3aWxsIGJlIGluY2x1ZGVkIGluIG5vZGUgZGltZW5zaW9ucyAgXG4gICAgaWYgKHRoaXMub3B0aW9ucy5ub2RlRGltZW5zaW9uc0luY2x1ZGVMYWJlbHMpIHtcbiAgICAgIGlmICh0aGVDaGlsZC5pc1BhcmVudCgpKSB7XG4gICAgICAgIHZhciBsYWJlbFdpZHRoID0gdGhlQ2hpbGQuYm91bmRpbmdCb3goeyBpbmNsdWRlTGFiZWxzOiB0cnVlLCBpbmNsdWRlTm9kZXM6IGZhbHNlIH0pLnc7XG4gICAgICAgIHZhciBsYWJlbEhlaWdodCA9IHRoZUNoaWxkLmJvdW5kaW5nQm94KHsgaW5jbHVkZUxhYmVsczogdHJ1ZSwgaW5jbHVkZU5vZGVzOiBmYWxzZSB9KS5oO1xuICAgICAgICB2YXIgbGFiZWxQb3MgPSB0aGVDaGlsZC5jc3MoXCJ0ZXh0LWhhbGlnblwiKTtcbiAgICAgICAgdGhlTm9kZS5sYWJlbFdpZHRoID0gbGFiZWxXaWR0aDtcbiAgICAgICAgdGhlTm9kZS5sYWJlbEhlaWdodCA9IGxhYmVsSGVpZ2h0O1xuICAgICAgICB0aGVOb2RlLmxhYmVsUG9zID0gbGFiZWxQb3M7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTWFwIHRoZSBsYXlvdXQgbm9kZVxuICAgIHRoaXMuaWRUb0xOb2RlW3RoZUNoaWxkLmRhdGEoXCJpZFwiKV0gPSB0aGVOb2RlO1xuXG4gICAgaWYgKGlzTmFOKHRoZU5vZGUucmVjdC54KSkge1xuICAgICAgdGhlTm9kZS5yZWN0LnggPSAwO1xuICAgIH1cblxuICAgIGlmIChpc05hTih0aGVOb2RlLnJlY3QueSkpIHtcbiAgICAgIHRoZU5vZGUucmVjdC55ID0gMDtcbiAgICB9XG5cbiAgICBpZiAoY2hpbGRyZW5fb2ZfY2hpbGRyZW4gIT0gbnVsbCAmJiBjaGlsZHJlbl9vZl9jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgdGhlTmV3R3JhcGg7XG4gICAgICB0aGVOZXdHcmFwaCA9IGxheW91dC5nZXRHcmFwaE1hbmFnZXIoKS5hZGQobGF5b3V0Lm5ld0dyYXBoKCksIHRoZU5vZGUpO1xuICAgICAgdGhpcy5wcm9jZXNzQ2hpbGRyZW5MaXN0KHRoZU5ld0dyYXBoLCBjaGlsZHJlbl9vZl9jaGlsZHJlbiwgbGF5b3V0KTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQGJyaWVmIDogY2FsbGVkIG9uIGNvbnRpbnVvdXMgbGF5b3V0cyB0byBzdG9wIHRoZW0gYmVmb3JlIHRoZXkgZmluaXNoXG4gKi9cbl9Db1NFTGF5b3V0LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnN0b3BwZWQgPSB0cnVlO1xuXG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxudmFyIHJlZ2lzdGVyID0gZnVuY3Rpb24gcmVnaXN0ZXIoY3l0b3NjYXBlKSB7XG4gIC8vICB2YXIgTGF5b3V0ID0gZ2V0TGF5b3V0KCBjeXRvc2NhcGUgKTtcblxuICBjeXRvc2NhcGUoJ2xheW91dCcsICdjb3NlLWJpbGtlbnQnLCBfQ29TRUxheW91dCk7XG59O1xuXG4vLyBhdXRvIHJlZyBmb3IgZ2xvYmFsc1xuaWYgKHR5cGVvZiBjeXRvc2NhcGUgIT09ICd1bmRlZmluZWQnKSB7XG4gIHJlZ2lzdGVyKGN5dG9zY2FwZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVnaXN0ZXI7XG5cbi8qKiovIH0pXG4vKioqKioqLyBdKTtcbn0pOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/cytoscape-cose-bilkent/cytoscape-cose-bilkent.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/cytoscape/dist/cytoscape.umd.js":
/*!******************************************************!*\
  !*** ./node_modules/cytoscape/dist/cytoscape.umd.js ***!
  \******************************************************/
/***/ (function(module) {

eval("/**\n * Copyright (c) 2016-2023, The Cytoscape Consortium.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the Software), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n * of the Software, and to permit persons to whom the Software is furnished to do\n * so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n(function (global, factory) {\n   true ? module.exports = factory() :\n  0;\n})(this, (function () { 'use strict';\n\n  function _typeof(obj) {\n    \"@babel/helpers - typeof\";\n\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n      return typeof obj;\n    } : function (obj) {\n      return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    }, _typeof(obj);\n  }\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n      writable: false\n    });\n    return Constructor;\n  }\n\n  function _defineProperty$1(obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  function _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n  }\n\n  function _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n  }\n\n  function _iterableToArrayLimit(arr, i) {\n    var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n    if (_i == null) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n\n    var _s, _e;\n\n    try {\n      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  function _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n  }\n\n  function _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n\n    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n\n  function _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var window$1 = typeof window === 'undefined' ? null : window; // eslint-disable-line no-undef\n\n  var navigator = window$1 ? window$1.navigator : null;\n  window$1 ? window$1.document : null;\n\n  var typeofstr = _typeof('');\n\n  var typeofobj = _typeof({});\n\n  var typeoffn = _typeof(function () {});\n\n  var typeofhtmlele = typeof HTMLElement === \"undefined\" ? \"undefined\" : _typeof(HTMLElement);\n\n  var instanceStr = function instanceStr(obj) {\n    return obj && obj.instanceString && fn$6(obj.instanceString) ? obj.instanceString() : null;\n  };\n\n  var string = function string(obj) {\n    return obj != null && _typeof(obj) == typeofstr;\n  };\n  var fn$6 = function fn(obj) {\n    return obj != null && _typeof(obj) === typeoffn;\n  };\n  var array = function array(obj) {\n    return !elementOrCollection(obj) && (Array.isArray ? Array.isArray(obj) : obj != null && obj instanceof Array);\n  };\n  var plainObject = function plainObject(obj) {\n    return obj != null && _typeof(obj) === typeofobj && !array(obj) && obj.constructor === Object;\n  };\n  var object = function object(obj) {\n    return obj != null && _typeof(obj) === typeofobj;\n  };\n  var number$1 = function number(obj) {\n    return obj != null && _typeof(obj) === _typeof(1) && !isNaN(obj);\n  };\n  var integer = function integer(obj) {\n    return number$1(obj) && Math.floor(obj) === obj;\n  };\n  var htmlElement = function htmlElement(obj) {\n    if ('undefined' === typeofhtmlele) {\n      return undefined;\n    } else {\n      return null != obj && obj instanceof HTMLElement;\n    }\n  };\n  var elementOrCollection = function elementOrCollection(obj) {\n    return element(obj) || collection(obj);\n  };\n  var element = function element(obj) {\n    return instanceStr(obj) === 'collection' && obj._private.single;\n  };\n  var collection = function collection(obj) {\n    return instanceStr(obj) === 'collection' && !obj._private.single;\n  };\n  var core = function core(obj) {\n    return instanceStr(obj) === 'core';\n  };\n  var stylesheet = function stylesheet(obj) {\n    return instanceStr(obj) === 'stylesheet';\n  };\n  var event = function event(obj) {\n    return instanceStr(obj) === 'event';\n  };\n  var emptyString = function emptyString(obj) {\n    if (obj === undefined || obj === null) {\n      // null is empty\n      return true;\n    } else if (obj === '' || obj.match(/^\\s+$/)) {\n      return true; // empty string is empty\n    }\n\n    return false; // otherwise, we don't know what we've got\n  };\n  var domElement = function domElement(obj) {\n    if (typeof HTMLElement === 'undefined') {\n      return false; // we're not in a browser so it doesn't matter\n    } else {\n      return obj instanceof HTMLElement;\n    }\n  };\n  var boundingBox = function boundingBox(obj) {\n    return plainObject(obj) && number$1(obj.x1) && number$1(obj.x2) && number$1(obj.y1) && number$1(obj.y2);\n  };\n  var promise = function promise(obj) {\n    return object(obj) && fn$6(obj.then);\n  };\n  var ms = function ms() {\n    return navigator && navigator.userAgent.match(/msie|trident|edge/i);\n  }; // probably a better way to detect this...\n\n  var memoize$1 = function memoize(fn, keyFn) {\n    if (!keyFn) {\n      keyFn = function keyFn() {\n        if (arguments.length === 1) {\n          return arguments[0];\n        } else if (arguments.length === 0) {\n          return 'undefined';\n        }\n\n        var args = [];\n\n        for (var i = 0; i < arguments.length; i++) {\n          args.push(arguments[i]);\n        }\n\n        return args.join('$');\n      };\n    }\n\n    var memoizedFn = function memoizedFn() {\n      var self = this;\n      var args = arguments;\n      var ret;\n      var k = keyFn.apply(self, args);\n      var cache = memoizedFn.cache;\n\n      if (!(ret = cache[k])) {\n        ret = cache[k] = fn.apply(self, args);\n      }\n\n      return ret;\n    };\n\n    memoizedFn.cache = {};\n    return memoizedFn;\n  };\n\n  var camel2dash = memoize$1(function (str) {\n    return str.replace(/([A-Z])/g, function (v) {\n      return '-' + v.toLowerCase();\n    });\n  });\n  var dash2camel = memoize$1(function (str) {\n    return str.replace(/(-\\w)/g, function (v) {\n      return v[1].toUpperCase();\n    });\n  });\n  var prependCamel = memoize$1(function (prefix, str) {\n    return prefix + str[0].toUpperCase() + str.substring(1);\n  }, function (prefix, str) {\n    return prefix + '$' + str;\n  });\n  var capitalize = function capitalize(str) {\n    if (emptyString(str)) {\n      return str;\n    }\n\n    return str.charAt(0).toUpperCase() + str.substring(1);\n  };\n\n  var number = '(?:[-+]?(?:(?:\\\\d+|\\\\d*\\\\.\\\\d+)(?:[Ee][+-]?\\\\d+)?))';\n  var rgba = 'rgb[a]?\\\\((' + number + '[%]?)\\\\s*,\\\\s*(' + number + '[%]?)\\\\s*,\\\\s*(' + number + '[%]?)(?:\\\\s*,\\\\s*(' + number + '))?\\\\)';\n  var rgbaNoBackRefs = 'rgb[a]?\\\\((?:' + number + '[%]?)\\\\s*,\\\\s*(?:' + number + '[%]?)\\\\s*,\\\\s*(?:' + number + '[%]?)(?:\\\\s*,\\\\s*(?:' + number + '))?\\\\)';\n  var hsla = 'hsl[a]?\\\\((' + number + ')\\\\s*,\\\\s*(' + number + '[%])\\\\s*,\\\\s*(' + number + '[%])(?:\\\\s*,\\\\s*(' + number + '))?\\\\)';\n  var hslaNoBackRefs = 'hsl[a]?\\\\((?:' + number + ')\\\\s*,\\\\s*(?:' + number + '[%])\\\\s*,\\\\s*(?:' + number + '[%])(?:\\\\s*,\\\\s*(?:' + number + '))?\\\\)';\n  var hex3 = '\\\\#[0-9a-fA-F]{3}';\n  var hex6 = '\\\\#[0-9a-fA-F]{6}';\n\n  var ascending = function ascending(a, b) {\n    if (a < b) {\n      return -1;\n    } else if (a > b) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n  var descending = function descending(a, b) {\n    return -1 * ascending(a, b);\n  };\n\n  var extend = Object.assign != null ? Object.assign.bind(Object) : function (tgt) {\n    var args = arguments;\n\n    for (var i = 1; i < args.length; i++) {\n      var obj = args[i];\n\n      if (obj == null) {\n        continue;\n      }\n\n      var keys = Object.keys(obj);\n\n      for (var j = 0; j < keys.length; j++) {\n        var k = keys[j];\n        tgt[k] = obj[k];\n      }\n    }\n\n    return tgt;\n  };\n\n  var hex2tuple = function hex2tuple(hex) {\n    if (!(hex.length === 4 || hex.length === 7) || hex[0] !== '#') {\n      return;\n    }\n\n    var shortHex = hex.length === 4;\n    var r, g, b;\n    var base = 16;\n\n    if (shortHex) {\n      r = parseInt(hex[1] + hex[1], base);\n      g = parseInt(hex[2] + hex[2], base);\n      b = parseInt(hex[3] + hex[3], base);\n    } else {\n      r = parseInt(hex[1] + hex[2], base);\n      g = parseInt(hex[3] + hex[4], base);\n      b = parseInt(hex[5] + hex[6], base);\n    }\n\n    return [r, g, b];\n  }; // get [r, g, b, a] from hsl(0, 0, 0) or hsla(0, 0, 0, 0)\n\n  var hsl2tuple = function hsl2tuple(hsl) {\n    var ret;\n    var h, s, l, a, r, g, b;\n\n    function hue2rgb(p, q, t) {\n      if (t < 0) t += 1;\n      if (t > 1) t -= 1;\n      if (t < 1 / 6) return p + (q - p) * 6 * t;\n      if (t < 1 / 2) return q;\n      if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n      return p;\n    }\n\n    var m = new RegExp('^' + hsla + '$').exec(hsl);\n\n    if (m) {\n      // get hue\n      h = parseInt(m[1]);\n\n      if (h < 0) {\n        h = (360 - -1 * h % 360) % 360;\n      } else if (h > 360) {\n        h = h % 360;\n      }\n\n      h /= 360; // normalise on [0, 1]\n\n      s = parseFloat(m[2]);\n\n      if (s < 0 || s > 100) {\n        return;\n      } // saturation is [0, 100]\n\n\n      s = s / 100; // normalise on [0, 1]\n\n      l = parseFloat(m[3]);\n\n      if (l < 0 || l > 100) {\n        return;\n      } // lightness is [0, 100]\n\n\n      l = l / 100; // normalise on [0, 1]\n\n      a = m[4];\n\n      if (a !== undefined) {\n        a = parseFloat(a);\n\n        if (a < 0 || a > 1) {\n          return;\n        } // alpha is [0, 1]\n\n      } // now, convert to rgb\n      // code from http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript\n\n\n      if (s === 0) {\n        r = g = b = Math.round(l * 255); // achromatic\n      } else {\n        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n        var p = 2 * l - q;\n        r = Math.round(255 * hue2rgb(p, q, h + 1 / 3));\n        g = Math.round(255 * hue2rgb(p, q, h));\n        b = Math.round(255 * hue2rgb(p, q, h - 1 / 3));\n      }\n\n      ret = [r, g, b, a];\n    }\n\n    return ret;\n  }; // get [r, g, b, a] from rgb(0, 0, 0) or rgba(0, 0, 0, 0)\n\n  var rgb2tuple = function rgb2tuple(rgb) {\n    var ret;\n    var m = new RegExp('^' + rgba + '$').exec(rgb);\n\n    if (m) {\n      ret = [];\n      var isPct = [];\n\n      for (var i = 1; i <= 3; i++) {\n        var channel = m[i];\n\n        if (channel[channel.length - 1] === '%') {\n          isPct[i] = true;\n        }\n\n        channel = parseFloat(channel);\n\n        if (isPct[i]) {\n          channel = channel / 100 * 255; // normalise to [0, 255]\n        }\n\n        if (channel < 0 || channel > 255) {\n          return;\n        } // invalid channel value\n\n\n        ret.push(Math.floor(channel));\n      }\n\n      var atLeastOneIsPct = isPct[1] || isPct[2] || isPct[3];\n      var allArePct = isPct[1] && isPct[2] && isPct[3];\n\n      if (atLeastOneIsPct && !allArePct) {\n        return;\n      } // must all be percent values if one is\n\n\n      var alpha = m[4];\n\n      if (alpha !== undefined) {\n        alpha = parseFloat(alpha);\n\n        if (alpha < 0 || alpha > 1) {\n          return;\n        } // invalid alpha value\n\n\n        ret.push(alpha);\n      }\n    }\n\n    return ret;\n  };\n  var colorname2tuple = function colorname2tuple(color) {\n    return colors[color.toLowerCase()];\n  };\n  var color2tuple = function color2tuple(color) {\n    return (array(color) ? color : null) || colorname2tuple(color) || hex2tuple(color) || rgb2tuple(color) || hsl2tuple(color);\n  };\n  var colors = {\n    // special colour names\n    transparent: [0, 0, 0, 0],\n    // NB alpha === 0\n    // regular colours\n    aliceblue: [240, 248, 255],\n    antiquewhite: [250, 235, 215],\n    aqua: [0, 255, 255],\n    aquamarine: [127, 255, 212],\n    azure: [240, 255, 255],\n    beige: [245, 245, 220],\n    bisque: [255, 228, 196],\n    black: [0, 0, 0],\n    blanchedalmond: [255, 235, 205],\n    blue: [0, 0, 255],\n    blueviolet: [138, 43, 226],\n    brown: [165, 42, 42],\n    burlywood: [222, 184, 135],\n    cadetblue: [95, 158, 160],\n    chartreuse: [127, 255, 0],\n    chocolate: [210, 105, 30],\n    coral: [255, 127, 80],\n    cornflowerblue: [100, 149, 237],\n    cornsilk: [255, 248, 220],\n    crimson: [220, 20, 60],\n    cyan: [0, 255, 255],\n    darkblue: [0, 0, 139],\n    darkcyan: [0, 139, 139],\n    darkgoldenrod: [184, 134, 11],\n    darkgray: [169, 169, 169],\n    darkgreen: [0, 100, 0],\n    darkgrey: [169, 169, 169],\n    darkkhaki: [189, 183, 107],\n    darkmagenta: [139, 0, 139],\n    darkolivegreen: [85, 107, 47],\n    darkorange: [255, 140, 0],\n    darkorchid: [153, 50, 204],\n    darkred: [139, 0, 0],\n    darksalmon: [233, 150, 122],\n    darkseagreen: [143, 188, 143],\n    darkslateblue: [72, 61, 139],\n    darkslategray: [47, 79, 79],\n    darkslategrey: [47, 79, 79],\n    darkturquoise: [0, 206, 209],\n    darkviolet: [148, 0, 211],\n    deeppink: [255, 20, 147],\n    deepskyblue: [0, 191, 255],\n    dimgray: [105, 105, 105],\n    dimgrey: [105, 105, 105],\n    dodgerblue: [30, 144, 255],\n    firebrick: [178, 34, 34],\n    floralwhite: [255, 250, 240],\n    forestgreen: [34, 139, 34],\n    fuchsia: [255, 0, 255],\n    gainsboro: [220, 220, 220],\n    ghostwhite: [248, 248, 255],\n    gold: [255, 215, 0],\n    goldenrod: [218, 165, 32],\n    gray: [128, 128, 128],\n    grey: [128, 128, 128],\n    green: [0, 128, 0],\n    greenyellow: [173, 255, 47],\n    honeydew: [240, 255, 240],\n    hotpink: [255, 105, 180],\n    indianred: [205, 92, 92],\n    indigo: [75, 0, 130],\n    ivory: [255, 255, 240],\n    khaki: [240, 230, 140],\n    lavender: [230, 230, 250],\n    lavenderblush: [255, 240, 245],\n    lawngreen: [124, 252, 0],\n    lemonchiffon: [255, 250, 205],\n    lightblue: [173, 216, 230],\n    lightcoral: [240, 128, 128],\n    lightcyan: [224, 255, 255],\n    lightgoldenrodyellow: [250, 250, 210],\n    lightgray: [211, 211, 211],\n    lightgreen: [144, 238, 144],\n    lightgrey: [211, 211, 211],\n    lightpink: [255, 182, 193],\n    lightsalmon: [255, 160, 122],\n    lightseagreen: [32, 178, 170],\n    lightskyblue: [135, 206, 250],\n    lightslategray: [119, 136, 153],\n    lightslategrey: [119, 136, 153],\n    lightsteelblue: [176, 196, 222],\n    lightyellow: [255, 255, 224],\n    lime: [0, 255, 0],\n    limegreen: [50, 205, 50],\n    linen: [250, 240, 230],\n    magenta: [255, 0, 255],\n    maroon: [128, 0, 0],\n    mediumaquamarine: [102, 205, 170],\n    mediumblue: [0, 0, 205],\n    mediumorchid: [186, 85, 211],\n    mediumpurple: [147, 112, 219],\n    mediumseagreen: [60, 179, 113],\n    mediumslateblue: [123, 104, 238],\n    mediumspringgreen: [0, 250, 154],\n    mediumturquoise: [72, 209, 204],\n    mediumvioletred: [199, 21, 133],\n    midnightblue: [25, 25, 112],\n    mintcream: [245, 255, 250],\n    mistyrose: [255, 228, 225],\n    moccasin: [255, 228, 181],\n    navajowhite: [255, 222, 173],\n    navy: [0, 0, 128],\n    oldlace: [253, 245, 230],\n    olive: [128, 128, 0],\n    olivedrab: [107, 142, 35],\n    orange: [255, 165, 0],\n    orangered: [255, 69, 0],\n    orchid: [218, 112, 214],\n    palegoldenrod: [238, 232, 170],\n    palegreen: [152, 251, 152],\n    paleturquoise: [175, 238, 238],\n    palevioletred: [219, 112, 147],\n    papayawhip: [255, 239, 213],\n    peachpuff: [255, 218, 185],\n    peru: [205, 133, 63],\n    pink: [255, 192, 203],\n    plum: [221, 160, 221],\n    powderblue: [176, 224, 230],\n    purple: [128, 0, 128],\n    red: [255, 0, 0],\n    rosybrown: [188, 143, 143],\n    royalblue: [65, 105, 225],\n    saddlebrown: [139, 69, 19],\n    salmon: [250, 128, 114],\n    sandybrown: [244, 164, 96],\n    seagreen: [46, 139, 87],\n    seashell: [255, 245, 238],\n    sienna: [160, 82, 45],\n    silver: [192, 192, 192],\n    skyblue: [135, 206, 235],\n    slateblue: [106, 90, 205],\n    slategray: [112, 128, 144],\n    slategrey: [112, 128, 144],\n    snow: [255, 250, 250],\n    springgreen: [0, 255, 127],\n    steelblue: [70, 130, 180],\n    tan: [210, 180, 140],\n    teal: [0, 128, 128],\n    thistle: [216, 191, 216],\n    tomato: [255, 99, 71],\n    turquoise: [64, 224, 208],\n    violet: [238, 130, 238],\n    wheat: [245, 222, 179],\n    white: [255, 255, 255],\n    whitesmoke: [245, 245, 245],\n    yellow: [255, 255, 0],\n    yellowgreen: [154, 205, 50]\n  };\n\n  var setMap = function setMap(options) {\n    var obj = options.map;\n    var keys = options.keys;\n    var l = keys.length;\n\n    for (var i = 0; i < l; i++) {\n      var key = keys[i];\n\n      if (plainObject(key)) {\n        throw Error('Tried to set map with object key');\n      }\n\n      if (i < keys.length - 1) {\n        // extend the map if necessary\n        if (obj[key] == null) {\n          obj[key] = {};\n        }\n\n        obj = obj[key];\n      } else {\n        // set the value\n        obj[key] = options.value;\n      }\n    }\n  }; // gets the value in a map even if it's not built in places\n\n  var getMap = function getMap(options) {\n    var obj = options.map;\n    var keys = options.keys;\n    var l = keys.length;\n\n    for (var i = 0; i < l; i++) {\n      var key = keys[i];\n\n      if (plainObject(key)) {\n        throw Error('Tried to get map with object key');\n      }\n\n      obj = obj[key];\n\n      if (obj == null) {\n        return obj;\n      }\n    }\n\n    return obj;\n  }; // deletes the entry in the map\n\n  /**\n   * Checks if `value` is the\n   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n   * @example\n   *\n   * _.isObject({});\n   * // => true\n   *\n   * _.isObject([1, 2, 3]);\n   * // => true\n   *\n   * _.isObject(_.noop);\n   * // => true\n   *\n   * _.isObject(null);\n   * // => false\n   */\n  function isObject(value) {\n    var type = typeof value;\n    return value != null && (type == 'object' || type == 'function');\n  }\n\n  var isObject_1 = isObject;\n\n  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\n  function createCommonjsModule(fn, module) {\n  \treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n  }\n\n  /** Detect free variable `global` from Node.js. */\n  var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;\n\n  var _freeGlobal = freeGlobal;\n\n  /** Detect free variable `self`. */\n  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n  /** Used as a reference to the global object. */\n  var root = _freeGlobal || freeSelf || Function('return this')();\n\n  var _root = root;\n\n  /**\n   * Gets the timestamp of the number of milliseconds that have elapsed since\n   * the Unix epoch (1 January 1970 00:00:00 UTC).\n   *\n   * @static\n   * @memberOf _\n   * @since 2.4.0\n   * @category Date\n   * @returns {number} Returns the timestamp.\n   * @example\n   *\n   * _.defer(function(stamp) {\n   *   console.log(_.now() - stamp);\n   * }, _.now());\n   * // => Logs the number of milliseconds it took for the deferred invocation.\n   */\n  var now = function() {\n    return _root.Date.now();\n  };\n\n  var now_1 = now;\n\n  /** Used to match a single whitespace character. */\n  var reWhitespace = /\\s/;\n\n  /**\n   * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace\n   * character of `string`.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {number} Returns the index of the last non-whitespace character.\n   */\n  function trimmedEndIndex(string) {\n    var index = string.length;\n\n    while (index-- && reWhitespace.test(string.charAt(index))) {}\n    return index;\n  }\n\n  var _trimmedEndIndex = trimmedEndIndex;\n\n  /** Used to match leading whitespace. */\n  var reTrimStart = /^\\s+/;\n\n  /**\n   * The base implementation of `_.trim`.\n   *\n   * @private\n   * @param {string} string The string to trim.\n   * @returns {string} Returns the trimmed string.\n   */\n  function baseTrim(string) {\n    return string\n      ? string.slice(0, _trimmedEndIndex(string) + 1).replace(reTrimStart, '')\n      : string;\n  }\n\n  var _baseTrim = baseTrim;\n\n  /** Built-in value references. */\n  var Symbol$1 = _root.Symbol;\n\n  var _Symbol = Symbol$1;\n\n  /** Used for built-in method references. */\n  var objectProto$5 = Object.prototype;\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty$4 = objectProto$5.hasOwnProperty;\n\n  /**\n   * Used to resolve the\n   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n   * of values.\n   */\n  var nativeObjectToString$1 = objectProto$5.toString;\n\n  /** Built-in value references. */\n  var symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;\n\n  /**\n   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n   *\n   * @private\n   * @param {*} value The value to query.\n   * @returns {string} Returns the raw `toStringTag`.\n   */\n  function getRawTag(value) {\n    var isOwn = hasOwnProperty$4.call(value, symToStringTag$1),\n        tag = value[symToStringTag$1];\n\n    try {\n      value[symToStringTag$1] = undefined;\n      var unmasked = true;\n    } catch (e) {}\n\n    var result = nativeObjectToString$1.call(value);\n    if (unmasked) {\n      if (isOwn) {\n        value[symToStringTag$1] = tag;\n      } else {\n        delete value[symToStringTag$1];\n      }\n    }\n    return result;\n  }\n\n  var _getRawTag = getRawTag;\n\n  /** Used for built-in method references. */\n  var objectProto$4 = Object.prototype;\n\n  /**\n   * Used to resolve the\n   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n   * of values.\n   */\n  var nativeObjectToString = objectProto$4.toString;\n\n  /**\n   * Converts `value` to a string using `Object.prototype.toString`.\n   *\n   * @private\n   * @param {*} value The value to convert.\n   * @returns {string} Returns the converted string.\n   */\n  function objectToString(value) {\n    return nativeObjectToString.call(value);\n  }\n\n  var _objectToString = objectToString;\n\n  /** `Object#toString` result references. */\n  var nullTag = '[object Null]',\n      undefinedTag = '[object Undefined]';\n\n  /** Built-in value references. */\n  var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;\n\n  /**\n   * The base implementation of `getTag` without fallbacks for buggy environments.\n   *\n   * @private\n   * @param {*} value The value to query.\n   * @returns {string} Returns the `toStringTag`.\n   */\n  function baseGetTag(value) {\n    if (value == null) {\n      return value === undefined ? undefinedTag : nullTag;\n    }\n    return (symToStringTag && symToStringTag in Object(value))\n      ? _getRawTag(value)\n      : _objectToString(value);\n  }\n\n  var _baseGetTag = baseGetTag;\n\n  /**\n   * Checks if `value` is object-like. A value is object-like if it's not `null`\n   * and has a `typeof` result of \"object\".\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n   * @example\n   *\n   * _.isObjectLike({});\n   * // => true\n   *\n   * _.isObjectLike([1, 2, 3]);\n   * // => true\n   *\n   * _.isObjectLike(_.noop);\n   * // => false\n   *\n   * _.isObjectLike(null);\n   * // => false\n   */\n  function isObjectLike(value) {\n    return value != null && typeof value == 'object';\n  }\n\n  var isObjectLike_1 = isObjectLike;\n\n  /** `Object#toString` result references. */\n  var symbolTag = '[object Symbol]';\n\n  /**\n   * Checks if `value` is classified as a `Symbol` primitive or object.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n   * @example\n   *\n   * _.isSymbol(Symbol.iterator);\n   * // => true\n   *\n   * _.isSymbol('abc');\n   * // => false\n   */\n  function isSymbol(value) {\n    return typeof value == 'symbol' ||\n      (isObjectLike_1(value) && _baseGetTag(value) == symbolTag);\n  }\n\n  var isSymbol_1 = isSymbol;\n\n  /** Used as references for various `Number` constants. */\n  var NAN = 0 / 0;\n\n  /** Used to detect bad signed hexadecimal string values. */\n  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n  /** Used to detect binary string values. */\n  var reIsBinary = /^0b[01]+$/i;\n\n  /** Used to detect octal string values. */\n  var reIsOctal = /^0o[0-7]+$/i;\n\n  /** Built-in method references without a dependency on `root`. */\n  var freeParseInt = parseInt;\n\n  /**\n   * Converts `value` to a number.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to process.\n   * @returns {number} Returns the number.\n   * @example\n   *\n   * _.toNumber(3.2);\n   * // => 3.2\n   *\n   * _.toNumber(Number.MIN_VALUE);\n   * // => 5e-324\n   *\n   * _.toNumber(Infinity);\n   * // => Infinity\n   *\n   * _.toNumber('3.2');\n   * // => 3.2\n   */\n  function toNumber(value) {\n    if (typeof value == 'number') {\n      return value;\n    }\n    if (isSymbol_1(value)) {\n      return NAN;\n    }\n    if (isObject_1(value)) {\n      var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n      value = isObject_1(other) ? (other + '') : other;\n    }\n    if (typeof value != 'string') {\n      return value === 0 ? value : +value;\n    }\n    value = _baseTrim(value);\n    var isBinary = reIsBinary.test(value);\n    return (isBinary || reIsOctal.test(value))\n      ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n      : (reIsBadHex.test(value) ? NAN : +value);\n  }\n\n  var toNumber_1 = toNumber;\n\n  /** Error message constants. */\n  var FUNC_ERROR_TEXT$1 = 'Expected a function';\n\n  /* Built-in method references for those with the same name as other `lodash` methods. */\n  var nativeMax = Math.max,\n      nativeMin = Math.min;\n\n  /**\n   * Creates a debounced function that delays invoking `func` until after `wait`\n   * milliseconds have elapsed since the last time the debounced function was\n   * invoked. The debounced function comes with a `cancel` method to cancel\n   * delayed `func` invocations and a `flush` method to immediately invoke them.\n   * Provide `options` to indicate whether `func` should be invoked on the\n   * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n   * with the last arguments provided to the debounced function. Subsequent\n   * calls to the debounced function return the result of the last `func`\n   * invocation.\n   *\n   * **Note:** If `leading` and `trailing` options are `true`, `func` is\n   * invoked on the trailing edge of the timeout only if the debounced function\n   * is invoked more than once during the `wait` timeout.\n   *\n   * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n   * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n   *\n   * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n   * for details over the differences between `_.debounce` and `_.throttle`.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Function\n   * @param {Function} func The function to debounce.\n   * @param {number} [wait=0] The number of milliseconds to delay.\n   * @param {Object} [options={}] The options object.\n   * @param {boolean} [options.leading=false]\n   *  Specify invoking on the leading edge of the timeout.\n   * @param {number} [options.maxWait]\n   *  The maximum time `func` is allowed to be delayed before it's invoked.\n   * @param {boolean} [options.trailing=true]\n   *  Specify invoking on the trailing edge of the timeout.\n   * @returns {Function} Returns the new debounced function.\n   * @example\n   *\n   * // Avoid costly calculations while the window size is in flux.\n   * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n   *\n   * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n   * jQuery(element).on('click', _.debounce(sendMail, 300, {\n   *   'leading': true,\n   *   'trailing': false\n   * }));\n   *\n   * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n   * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n   * var source = new EventSource('/stream');\n   * jQuery(source).on('message', debounced);\n   *\n   * // Cancel the trailing debounced invocation.\n   * jQuery(window).on('popstate', debounced.cancel);\n   */\n  function debounce(func, wait, options) {\n    var lastArgs,\n        lastThis,\n        maxWait,\n        result,\n        timerId,\n        lastCallTime,\n        lastInvokeTime = 0,\n        leading = false,\n        maxing = false,\n        trailing = true;\n\n    if (typeof func != 'function') {\n      throw new TypeError(FUNC_ERROR_TEXT$1);\n    }\n    wait = toNumber_1(wait) || 0;\n    if (isObject_1(options)) {\n      leading = !!options.leading;\n      maxing = 'maxWait' in options;\n      maxWait = maxing ? nativeMax(toNumber_1(options.maxWait) || 0, wait) : maxWait;\n      trailing = 'trailing' in options ? !!options.trailing : trailing;\n    }\n\n    function invokeFunc(time) {\n      var args = lastArgs,\n          thisArg = lastThis;\n\n      lastArgs = lastThis = undefined;\n      lastInvokeTime = time;\n      result = func.apply(thisArg, args);\n      return result;\n    }\n\n    function leadingEdge(time) {\n      // Reset any `maxWait` timer.\n      lastInvokeTime = time;\n      // Start the timer for the trailing edge.\n      timerId = setTimeout(timerExpired, wait);\n      // Invoke the leading edge.\n      return leading ? invokeFunc(time) : result;\n    }\n\n    function remainingWait(time) {\n      var timeSinceLastCall = time - lastCallTime,\n          timeSinceLastInvoke = time - lastInvokeTime,\n          timeWaiting = wait - timeSinceLastCall;\n\n      return maxing\n        ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)\n        : timeWaiting;\n    }\n\n    function shouldInvoke(time) {\n      var timeSinceLastCall = time - lastCallTime,\n          timeSinceLastInvoke = time - lastInvokeTime;\n\n      // Either this is the first call, activity has stopped and we're at the\n      // trailing edge, the system time has gone backwards and we're treating\n      // it as the trailing edge, or we've hit the `maxWait` limit.\n      return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n        (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n    }\n\n    function timerExpired() {\n      var time = now_1();\n      if (shouldInvoke(time)) {\n        return trailingEdge(time);\n      }\n      // Restart the timer.\n      timerId = setTimeout(timerExpired, remainingWait(time));\n    }\n\n    function trailingEdge(time) {\n      timerId = undefined;\n\n      // Only invoke if we have `lastArgs` which means `func` has been\n      // debounced at least once.\n      if (trailing && lastArgs) {\n        return invokeFunc(time);\n      }\n      lastArgs = lastThis = undefined;\n      return result;\n    }\n\n    function cancel() {\n      if (timerId !== undefined) {\n        clearTimeout(timerId);\n      }\n      lastInvokeTime = 0;\n      lastArgs = lastCallTime = lastThis = timerId = undefined;\n    }\n\n    function flush() {\n      return timerId === undefined ? result : trailingEdge(now_1());\n    }\n\n    function debounced() {\n      var time = now_1(),\n          isInvoking = shouldInvoke(time);\n\n      lastArgs = arguments;\n      lastThis = this;\n      lastCallTime = time;\n\n      if (isInvoking) {\n        if (timerId === undefined) {\n          return leadingEdge(lastCallTime);\n        }\n        if (maxing) {\n          // Handle invocations in a tight loop.\n          clearTimeout(timerId);\n          timerId = setTimeout(timerExpired, wait);\n          return invokeFunc(lastCallTime);\n        }\n      }\n      if (timerId === undefined) {\n        timerId = setTimeout(timerExpired, wait);\n      }\n      return result;\n    }\n    debounced.cancel = cancel;\n    debounced.flush = flush;\n    return debounced;\n  }\n\n  var debounce_1 = debounce;\n\n  var performance = window$1 ? window$1.performance : null;\n  var pnow = performance && performance.now ? function () {\n    return performance.now();\n  } : function () {\n    return Date.now();\n  };\n\n  var raf = function () {\n    if (window$1) {\n      if (window$1.requestAnimationFrame) {\n        return function (fn) {\n          window$1.requestAnimationFrame(fn);\n        };\n      } else if (window$1.mozRequestAnimationFrame) {\n        return function (fn) {\n          window$1.mozRequestAnimationFrame(fn);\n        };\n      } else if (window$1.webkitRequestAnimationFrame) {\n        return function (fn) {\n          window$1.webkitRequestAnimationFrame(fn);\n        };\n      } else if (window$1.msRequestAnimationFrame) {\n        return function (fn) {\n          window$1.msRequestAnimationFrame(fn);\n        };\n      }\n    }\n\n    return function (fn) {\n      if (fn) {\n        setTimeout(function () {\n          fn(pnow());\n        }, 1000 / 60);\n      }\n    };\n  }();\n\n  var requestAnimationFrame = function requestAnimationFrame(fn) {\n    return raf(fn);\n  };\n  var performanceNow = pnow;\n\n  var DEFAULT_HASH_SEED = 9261;\n  var K = 65599; // 37 also works pretty well\n\n  var DEFAULT_HASH_SEED_ALT = 5381;\n  var hashIterableInts = function hashIterableInts(iterator) {\n    var seed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_HASH_SEED;\n    // sdbm/string-hash\n    var hash = seed;\n    var entry;\n\n    for (;;) {\n      entry = iterator.next();\n\n      if (entry.done) {\n        break;\n      }\n\n      hash = hash * K + entry.value | 0;\n    }\n\n    return hash;\n  };\n  var hashInt = function hashInt(num) {\n    var seed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_HASH_SEED;\n    // sdbm/string-hash\n    return seed * K + num | 0;\n  };\n  var hashIntAlt = function hashIntAlt(num) {\n    var seed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_HASH_SEED_ALT;\n    // djb2/string-hash\n    return (seed << 5) + seed + num | 0;\n  };\n  var combineHashes = function combineHashes(hash1, hash2) {\n    return hash1 * 0x200000 + hash2;\n  };\n  var combineHashesArray = function combineHashesArray(hashes) {\n    return hashes[0] * 0x200000 + hashes[1];\n  };\n  var hashArrays = function hashArrays(hashes1, hashes2) {\n    return [hashInt(hashes1[0], hashes2[0]), hashIntAlt(hashes1[1], hashes2[1])];\n  };\n  var hashIntsArray = function hashIntsArray(ints, seed) {\n    var entry = {\n      value: 0,\n      done: false\n    };\n    var i = 0;\n    var length = ints.length;\n    var iterator = {\n      next: function next() {\n        if (i < length) {\n          entry.value = ints[i++];\n        } else {\n          entry.done = true;\n        }\n\n        return entry;\n      }\n    };\n    return hashIterableInts(iterator, seed);\n  };\n  var hashString = function hashString(str, seed) {\n    var entry = {\n      value: 0,\n      done: false\n    };\n    var i = 0;\n    var length = str.length;\n    var iterator = {\n      next: function next() {\n        if (i < length) {\n          entry.value = str.charCodeAt(i++);\n        } else {\n          entry.done = true;\n        }\n\n        return entry;\n      }\n    };\n    return hashIterableInts(iterator, seed);\n  };\n  var hashStrings = function hashStrings() {\n    return hashStringsArray(arguments);\n  };\n  var hashStringsArray = function hashStringsArray(strs) {\n    var hash;\n\n    for (var i = 0; i < strs.length; i++) {\n      var str = strs[i];\n\n      if (i === 0) {\n        hash = hashString(str);\n      } else {\n        hash = hashString(str, hash);\n      }\n    }\n\n    return hash;\n  };\n\n  /*global console */\n  var warningsEnabled = true;\n  var warnSupported = console.warn != null; // eslint-disable-line no-console\n\n  var traceSupported = console.trace != null; // eslint-disable-line no-console\n\n  var MAX_INT$1 = Number.MAX_SAFE_INTEGER || 9007199254740991;\n  var trueify = function trueify() {\n    return true;\n  };\n  var falsify = function falsify() {\n    return false;\n  };\n  var zeroify = function zeroify() {\n    return 0;\n  };\n  var noop$1 = function noop() {};\n  var error = function error(msg) {\n    throw new Error(msg);\n  };\n  var warnings = function warnings(enabled) {\n    if (enabled !== undefined) {\n      warningsEnabled = !!enabled;\n    } else {\n      return warningsEnabled;\n    }\n  };\n  var warn = function warn(msg) {\n    /* eslint-disable no-console */\n    if (!warnings()) {\n      return;\n    }\n\n    if (warnSupported) {\n      console.warn(msg);\n    } else {\n      console.log(msg);\n\n      if (traceSupported) {\n        console.trace();\n      }\n    }\n  };\n  /* eslint-enable */\n\n  var clone = function clone(obj) {\n    return extend({}, obj);\n  }; // gets a shallow copy of the argument\n\n  var copy = function copy(obj) {\n    if (obj == null) {\n      return obj;\n    }\n\n    if (array(obj)) {\n      return obj.slice();\n    } else if (plainObject(obj)) {\n      return clone(obj);\n    } else {\n      return obj;\n    }\n  };\n  var copyArray$1 = function copyArray(arr) {\n    return arr.slice();\n  };\n  var uuid = function uuid(a, b\n  /* placeholders */\n  ) {\n    for ( // loop :)\n    b = a = ''; // b - result , a - numeric letiable\n    a++ < 36; //\n    b += a * 51 & 52 // if \"a\" is not 9 or 14 or 19 or 24\n    ? //  return a random number or 4\n    (a ^ 15 // if \"a\" is not 15\n    ? // generate a random number from 0 to 15\n    8 ^ Math.random() * (a ^ 20 ? 16 : 4) // unless \"a\" is 20, in which case a random number from 8 to 11\n    : 4 //  otherwise 4\n    ).toString(16) : '-' //  in other cases (if \"a\" is 9,14,19,24) insert \"-\"\n    ) {\n    }\n\n    return b;\n  };\n  var _staticEmptyObject = {};\n  var staticEmptyObject = function staticEmptyObject() {\n    return _staticEmptyObject;\n  };\n  var defaults$g = function defaults(_defaults) {\n    var keys = Object.keys(_defaults);\n    return function (opts) {\n      var filledOpts = {};\n\n      for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        var optVal = opts == null ? undefined : opts[key];\n        filledOpts[key] = optVal === undefined ? _defaults[key] : optVal;\n      }\n\n      return filledOpts;\n    };\n  };\n  var removeFromArray = function removeFromArray(arr, ele, oneCopy) {\n    for (var i = arr.length - 1; i >= 0; i--) {\n      if (arr[i] === ele) {\n        arr.splice(i, 1);\n\n        if (oneCopy) {\n          break;\n        }\n      }\n    }\n  };\n  var clearArray = function clearArray(arr) {\n    arr.splice(0, arr.length);\n  };\n  var push = function push(arr, otherArr) {\n    for (var i = 0; i < otherArr.length; i++) {\n      var el = otherArr[i];\n      arr.push(el);\n    }\n  };\n  var getPrefixedProperty = function getPrefixedProperty(obj, propName, prefix) {\n    if (prefix) {\n      propName = prependCamel(prefix, propName); // e.g. (labelWidth, source) => sourceLabelWidth\n    }\n\n    return obj[propName];\n  };\n  var setPrefixedProperty = function setPrefixedProperty(obj, propName, prefix, value) {\n    if (prefix) {\n      propName = prependCamel(prefix, propName); // e.g. (labelWidth, source) => sourceLabelWidth\n    }\n\n    obj[propName] = value;\n  };\n\n  /* global Map */\n  var ObjectMap = /*#__PURE__*/function () {\n    function ObjectMap() {\n      _classCallCheck(this, ObjectMap);\n\n      this._obj = {};\n    }\n\n    _createClass(ObjectMap, [{\n      key: \"set\",\n      value: function set(key, val) {\n        this._obj[key] = val;\n        return this;\n      }\n    }, {\n      key: \"delete\",\n      value: function _delete(key) {\n        this._obj[key] = undefined;\n        return this;\n      }\n    }, {\n      key: \"clear\",\n      value: function clear() {\n        this._obj = {};\n      }\n    }, {\n      key: \"has\",\n      value: function has(key) {\n        return this._obj[key] !== undefined;\n      }\n    }, {\n      key: \"get\",\n      value: function get(key) {\n        return this._obj[key];\n      }\n    }]);\n\n    return ObjectMap;\n  }();\n\n  var Map$2 = typeof Map !== 'undefined' ? Map : ObjectMap;\n\n  /* global Set */\n  var undef = \"undefined\" ;\n\n  var ObjectSet = /*#__PURE__*/function () {\n    function ObjectSet(arrayOrObjectSet) {\n      _classCallCheck(this, ObjectSet);\n\n      this._obj = Object.create(null);\n      this.size = 0;\n\n      if (arrayOrObjectSet != null) {\n        var arr;\n\n        if (arrayOrObjectSet.instanceString != null && arrayOrObjectSet.instanceString() === this.instanceString()) {\n          arr = arrayOrObjectSet.toArray();\n        } else {\n          arr = arrayOrObjectSet;\n        }\n\n        for (var i = 0; i < arr.length; i++) {\n          this.add(arr[i]);\n        }\n      }\n    }\n\n    _createClass(ObjectSet, [{\n      key: \"instanceString\",\n      value: function instanceString() {\n        return 'set';\n      }\n    }, {\n      key: \"add\",\n      value: function add(val) {\n        var o = this._obj;\n\n        if (o[val] !== 1) {\n          o[val] = 1;\n          this.size++;\n        }\n      }\n    }, {\n      key: \"delete\",\n      value: function _delete(val) {\n        var o = this._obj;\n\n        if (o[val] === 1) {\n          o[val] = 0;\n          this.size--;\n        }\n      }\n    }, {\n      key: \"clear\",\n      value: function clear() {\n        this._obj = Object.create(null);\n      }\n    }, {\n      key: \"has\",\n      value: function has(val) {\n        return this._obj[val] === 1;\n      }\n    }, {\n      key: \"toArray\",\n      value: function toArray() {\n        var _this = this;\n\n        return Object.keys(this._obj).filter(function (key) {\n          return _this.has(key);\n        });\n      }\n    }, {\n      key: \"forEach\",\n      value: function forEach(callback, thisArg) {\n        return this.toArray().forEach(callback, thisArg);\n      }\n    }]);\n\n    return ObjectSet;\n  }();\n\n  var Set$1 = (typeof Set === \"undefined\" ? \"undefined\" : _typeof(Set)) !== undef ? Set : ObjectSet;\n\n  var Element = function Element(cy, params) {\n    var restore = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n    if (cy === undefined || params === undefined || !core(cy)) {\n      error('An element must have a core reference and parameters set');\n      return;\n    }\n\n    var group = params.group; // try to automatically infer the group if unspecified\n\n    if (group == null) {\n      if (params.data && params.data.source != null && params.data.target != null) {\n        group = 'edges';\n      } else {\n        group = 'nodes';\n      }\n    } // validate group\n\n\n    if (group !== 'nodes' && group !== 'edges') {\n      error('An element must be of type `nodes` or `edges`; you specified `' + group + '`');\n      return;\n    } // make the element array-like, just like a collection\n\n\n    this.length = 1;\n    this[0] = this; // NOTE: when something is added here, add also to ele.json()\n\n    var _p = this._private = {\n      cy: cy,\n      single: true,\n      // indicates this is an element\n      data: params.data || {},\n      // data object\n      position: params.position || {\n        x: 0,\n        y: 0\n      },\n      // (x, y) position pair\n      autoWidth: undefined,\n      // width and height of nodes calculated by the renderer when set to special 'auto' value\n      autoHeight: undefined,\n      autoPadding: undefined,\n      compoundBoundsClean: false,\n      // whether the compound dimensions need to be recalculated the next time dimensions are read\n      listeners: [],\n      // array of bound listeners\n      group: group,\n      // string; 'nodes' or 'edges'\n      style: {},\n      // properties as set by the style\n      rstyle: {},\n      // properties for style sent from the renderer to the core\n      styleCxts: [],\n      // applied style contexts from the styler\n      styleKeys: {},\n      // per-group keys of style property values\n      removed: true,\n      // whether it's inside the vis; true if removed (set true here since we call restore)\n      selected: params.selected ? true : false,\n      // whether it's selected\n      selectable: params.selectable === undefined ? true : params.selectable ? true : false,\n      // whether it's selectable\n      locked: params.locked ? true : false,\n      // whether the element is locked (cannot be moved)\n      grabbed: false,\n      // whether the element is grabbed by the mouse; renderer sets this privately\n      grabbable: params.grabbable === undefined ? true : params.grabbable ? true : false,\n      // whether the element can be grabbed\n      pannable: params.pannable === undefined ? group === 'edges' ? true : false : params.pannable ? true : false,\n      // whether the element has passthrough panning enabled\n      active: false,\n      // whether the element is active from user interaction\n      classes: new Set$1(),\n      // map ( className => true )\n      animation: {\n        // object for currently-running animations\n        current: [],\n        queue: []\n      },\n      rscratch: {},\n      // object in which the renderer can store information\n      scratch: params.scratch || {},\n      // scratch objects\n      edges: [],\n      // array of connected edges\n      children: [],\n      // array of children\n      parent: params.parent && params.parent.isNode() ? params.parent : null,\n      // parent ref\n      traversalCache: {},\n      // cache of output of traversal functions\n      backgrounding: false,\n      // whether background images are loading\n      bbCache: null,\n      // cache of the current bounding box\n      bbCacheShift: {\n        x: 0,\n        y: 0\n      },\n      // shift applied to cached bb to be applied on next get\n      bodyBounds: null,\n      // bounds cache of element body, w/o overlay\n      overlayBounds: null,\n      // bounds cache of element body, including overlay\n      labelBounds: {\n        // bounds cache of labels\n        all: null,\n        source: null,\n        target: null,\n        main: null\n      },\n      arrowBounds: {\n        // bounds cache of edge arrows\n        source: null,\n        target: null,\n        'mid-source': null,\n        'mid-target': null\n      }\n    };\n\n    if (_p.position.x == null) {\n      _p.position.x = 0;\n    }\n\n    if (_p.position.y == null) {\n      _p.position.y = 0;\n    } // renderedPosition overrides if specified\n\n\n    if (params.renderedPosition) {\n      var rpos = params.renderedPosition;\n      var pan = cy.pan();\n      var zoom = cy.zoom();\n      _p.position = {\n        x: (rpos.x - pan.x) / zoom,\n        y: (rpos.y - pan.y) / zoom\n      };\n    }\n\n    var classes = [];\n\n    if (array(params.classes)) {\n      classes = params.classes;\n    } else if (string(params.classes)) {\n      classes = params.classes.split(/\\s+/);\n    }\n\n    for (var i = 0, l = classes.length; i < l; i++) {\n      var cls = classes[i];\n\n      if (!cls || cls === '') {\n        continue;\n      }\n\n      _p.classes.add(cls);\n    }\n\n    this.createEmitter();\n    var bypass = params.style || params.css;\n\n    if (bypass) {\n      warn('Setting a `style` bypass at element creation should be done only when absolutely necessary.  Try to use the stylesheet instead.');\n      this.style(bypass);\n    }\n\n    if (restore === undefined || restore) {\n      this.restore();\n    }\n  };\n\n  var defineSearch = function defineSearch(params) {\n    params = {\n      bfs: params.bfs || !params.dfs,\n      dfs: params.dfs || !params.bfs\n    }; // from pseudocode on wikipedia\n\n    return function searchFn(roots, fn, directed) {\n      var options;\n\n      if (plainObject(roots) && !elementOrCollection(roots)) {\n        options = roots;\n        roots = options.roots || options.root;\n        fn = options.visit;\n        directed = options.directed;\n      }\n\n      directed = arguments.length === 2 && !fn$6(fn) ? fn : directed;\n      fn = fn$6(fn) ? fn : function () {};\n      var cy = this._private.cy;\n      var v = roots = string(roots) ? this.filter(roots) : roots;\n      var Q = [];\n      var connectedNodes = [];\n      var connectedBy = {};\n      var id2depth = {};\n      var V = {};\n      var j = 0;\n      var found;\n\n      var _this$byGroup = this.byGroup(),\n          nodes = _this$byGroup.nodes,\n          edges = _this$byGroup.edges; // enqueue v\n\n\n      for (var i = 0; i < v.length; i++) {\n        var vi = v[i];\n        var viId = vi.id();\n\n        if (vi.isNode()) {\n          Q.unshift(vi);\n\n          if (params.bfs) {\n            V[viId] = true;\n            connectedNodes.push(vi);\n          }\n\n          id2depth[viId] = 0;\n        }\n      }\n\n      var _loop = function _loop() {\n        var v = params.bfs ? Q.shift() : Q.pop();\n        var vId = v.id();\n\n        if (params.dfs) {\n          if (V[vId]) {\n            return \"continue\";\n          }\n\n          V[vId] = true;\n          connectedNodes.push(v);\n        }\n\n        var depth = id2depth[vId];\n        var prevEdge = connectedBy[vId];\n        var src = prevEdge != null ? prevEdge.source() : null;\n        var tgt = prevEdge != null ? prevEdge.target() : null;\n        var prevNode = prevEdge == null ? undefined : v.same(src) ? tgt[0] : src[0];\n        var ret = void 0;\n        ret = fn(v, prevEdge, prevNode, j++, depth);\n\n        if (ret === true) {\n          found = v;\n          return \"break\";\n        }\n\n        if (ret === false) {\n          return \"break\";\n        }\n\n        var vwEdges = v.connectedEdges().filter(function (e) {\n          return (!directed || e.source().same(v)) && edges.has(e);\n        });\n\n        for (var _i2 = 0; _i2 < vwEdges.length; _i2++) {\n          var e = vwEdges[_i2];\n          var w = e.connectedNodes().filter(function (n) {\n            return !n.same(v) && nodes.has(n);\n          });\n          var wId = w.id();\n\n          if (w.length !== 0 && !V[wId]) {\n            w = w[0];\n            Q.push(w);\n\n            if (params.bfs) {\n              V[wId] = true;\n              connectedNodes.push(w);\n            }\n\n            connectedBy[wId] = e;\n            id2depth[wId] = id2depth[vId] + 1;\n          }\n        }\n      };\n\n      while (Q.length !== 0) {\n        var _ret = _loop();\n\n        if (_ret === \"continue\") continue;\n        if (_ret === \"break\") break;\n      }\n\n      var connectedEles = cy.collection();\n\n      for (var _i = 0; _i < connectedNodes.length; _i++) {\n        var node = connectedNodes[_i];\n        var edge = connectedBy[node.id()];\n\n        if (edge != null) {\n          connectedEles.push(edge);\n        }\n\n        connectedEles.push(node);\n      }\n\n      return {\n        path: cy.collection(connectedEles),\n        found: cy.collection(found)\n      };\n    };\n  }; // search, spanning trees, etc\n\n\n  var elesfn$v = {\n    breadthFirstSearch: defineSearch({\n      bfs: true\n    }),\n    depthFirstSearch: defineSearch({\n      dfs: true\n    })\n  }; // nice, short mathematical alias\n\n  elesfn$v.bfs = elesfn$v.breadthFirstSearch;\n  elesfn$v.dfs = elesfn$v.depthFirstSearch;\n\n  var heap$1 = createCommonjsModule(function (module, exports) {\n  // Generated by CoffeeScript 1.8.0\n  (function() {\n    var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;\n\n    floor = Math.floor, min = Math.min;\n\n\n    /*\n    Default comparison function to be used\n     */\n\n    defaultCmp = function(x, y) {\n      if (x < y) {\n        return -1;\n      }\n      if (x > y) {\n        return 1;\n      }\n      return 0;\n    };\n\n\n    /*\n    Insert item x in list a, and keep it sorted assuming a is sorted.\n    \n    If x is already in a, insert it to the right of the rightmost x.\n    \n    Optional args lo (default 0) and hi (default a.length) bound the slice\n    of a to be searched.\n     */\n\n    insort = function(a, x, lo, hi, cmp) {\n      var mid;\n      if (lo == null) {\n        lo = 0;\n      }\n      if (cmp == null) {\n        cmp = defaultCmp;\n      }\n      if (lo < 0) {\n        throw new Error('lo must be non-negative');\n      }\n      if (hi == null) {\n        hi = a.length;\n      }\n      while (lo < hi) {\n        mid = floor((lo + hi) / 2);\n        if (cmp(x, a[mid]) < 0) {\n          hi = mid;\n        } else {\n          lo = mid + 1;\n        }\n      }\n      return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);\n    };\n\n\n    /*\n    Push item onto heap, maintaining the heap invariant.\n     */\n\n    heappush = function(array, item, cmp) {\n      if (cmp == null) {\n        cmp = defaultCmp;\n      }\n      array.push(item);\n      return _siftdown(array, 0, array.length - 1, cmp);\n    };\n\n\n    /*\n    Pop the smallest item off the heap, maintaining the heap invariant.\n     */\n\n    heappop = function(array, cmp) {\n      var lastelt, returnitem;\n      if (cmp == null) {\n        cmp = defaultCmp;\n      }\n      lastelt = array.pop();\n      if (array.length) {\n        returnitem = array[0];\n        array[0] = lastelt;\n        _siftup(array, 0, cmp);\n      } else {\n        returnitem = lastelt;\n      }\n      return returnitem;\n    };\n\n\n    /*\n    Pop and return the current smallest value, and add the new item.\n    \n    This is more efficient than heappop() followed by heappush(), and can be\n    more appropriate when using a fixed size heap. Note that the value\n    returned may be larger than item! That constrains reasonable use of\n    this routine unless written as part of a conditional replacement:\n        if item > array[0]\n          item = heapreplace(array, item)\n     */\n\n    heapreplace = function(array, item, cmp) {\n      var returnitem;\n      if (cmp == null) {\n        cmp = defaultCmp;\n      }\n      returnitem = array[0];\n      array[0] = item;\n      _siftup(array, 0, cmp);\n      return returnitem;\n    };\n\n\n    /*\n    Fast version of a heappush followed by a heappop.\n     */\n\n    heappushpop = function(array, item, cmp) {\n      var _ref;\n      if (cmp == null) {\n        cmp = defaultCmp;\n      }\n      if (array.length && cmp(array[0], item) < 0) {\n        _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];\n        _siftup(array, 0, cmp);\n      }\n      return item;\n    };\n\n\n    /*\n    Transform list into a heap, in-place, in O(array.length) time.\n     */\n\n    heapify = function(array, cmp) {\n      var i, _i, _len, _ref1, _results, _results1;\n      if (cmp == null) {\n        cmp = defaultCmp;\n      }\n      _ref1 = (function() {\n        _results1 = [];\n        for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }\n        return _results1;\n      }).apply(this).reverse();\n      _results = [];\n      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n        i = _ref1[_i];\n        _results.push(_siftup(array, i, cmp));\n      }\n      return _results;\n    };\n\n\n    /*\n    Update the position of the given item in the heap.\n    This function should be called every time the item is being modified.\n     */\n\n    updateItem = function(array, item, cmp) {\n      var pos;\n      if (cmp == null) {\n        cmp = defaultCmp;\n      }\n      pos = array.indexOf(item);\n      if (pos === -1) {\n        return;\n      }\n      _siftdown(array, 0, pos, cmp);\n      return _siftup(array, pos, cmp);\n    };\n\n\n    /*\n    Find the n largest elements in a dataset.\n     */\n\n    nlargest = function(array, n, cmp) {\n      var elem, result, _i, _len, _ref;\n      if (cmp == null) {\n        cmp = defaultCmp;\n      }\n      result = array.slice(0, n);\n      if (!result.length) {\n        return result;\n      }\n      heapify(result, cmp);\n      _ref = array.slice(n);\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        elem = _ref[_i];\n        heappushpop(result, elem, cmp);\n      }\n      return result.sort(cmp).reverse();\n    };\n\n\n    /*\n    Find the n smallest elements in a dataset.\n     */\n\n    nsmallest = function(array, n, cmp) {\n      var elem, los, result, _i, _j, _len, _ref, _ref1, _results;\n      if (cmp == null) {\n        cmp = defaultCmp;\n      }\n      if (n * 10 <= array.length) {\n        result = array.slice(0, n).sort(cmp);\n        if (!result.length) {\n          return result;\n        }\n        los = result[result.length - 1];\n        _ref = array.slice(n);\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          elem = _ref[_i];\n          if (cmp(elem, los) < 0) {\n            insort(result, elem, 0, null, cmp);\n            result.pop();\n            los = result[result.length - 1];\n          }\n        }\n        return result;\n      }\n      heapify(array, cmp);\n      _results = [];\n      for (_j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; 0 <= _ref1 ? ++_j : --_j) {\n        _results.push(heappop(array, cmp));\n      }\n      return _results;\n    };\n\n    _siftdown = function(array, startpos, pos, cmp) {\n      var newitem, parent, parentpos;\n      if (cmp == null) {\n        cmp = defaultCmp;\n      }\n      newitem = array[pos];\n      while (pos > startpos) {\n        parentpos = (pos - 1) >> 1;\n        parent = array[parentpos];\n        if (cmp(newitem, parent) < 0) {\n          array[pos] = parent;\n          pos = parentpos;\n          continue;\n        }\n        break;\n      }\n      return array[pos] = newitem;\n    };\n\n    _siftup = function(array, pos, cmp) {\n      var childpos, endpos, newitem, rightpos, startpos;\n      if (cmp == null) {\n        cmp = defaultCmp;\n      }\n      endpos = array.length;\n      startpos = pos;\n      newitem = array[pos];\n      childpos = 2 * pos + 1;\n      while (childpos < endpos) {\n        rightpos = childpos + 1;\n        if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {\n          childpos = rightpos;\n        }\n        array[pos] = array[childpos];\n        pos = childpos;\n        childpos = 2 * pos + 1;\n      }\n      array[pos] = newitem;\n      return _siftdown(array, startpos, pos, cmp);\n    };\n\n    Heap = (function() {\n      Heap.push = heappush;\n\n      Heap.pop = heappop;\n\n      Heap.replace = heapreplace;\n\n      Heap.pushpop = heappushpop;\n\n      Heap.heapify = heapify;\n\n      Heap.updateItem = updateItem;\n\n      Heap.nlargest = nlargest;\n\n      Heap.nsmallest = nsmallest;\n\n      function Heap(cmp) {\n        this.cmp = cmp != null ? cmp : defaultCmp;\n        this.nodes = [];\n      }\n\n      Heap.prototype.push = function(x) {\n        return heappush(this.nodes, x, this.cmp);\n      };\n\n      Heap.prototype.pop = function() {\n        return heappop(this.nodes, this.cmp);\n      };\n\n      Heap.prototype.peek = function() {\n        return this.nodes[0];\n      };\n\n      Heap.prototype.contains = function(x) {\n        return this.nodes.indexOf(x) !== -1;\n      };\n\n      Heap.prototype.replace = function(x) {\n        return heapreplace(this.nodes, x, this.cmp);\n      };\n\n      Heap.prototype.pushpop = function(x) {\n        return heappushpop(this.nodes, x, this.cmp);\n      };\n\n      Heap.prototype.heapify = function() {\n        return heapify(this.nodes, this.cmp);\n      };\n\n      Heap.prototype.updateItem = function(x) {\n        return updateItem(this.nodes, x, this.cmp);\n      };\n\n      Heap.prototype.clear = function() {\n        return this.nodes = [];\n      };\n\n      Heap.prototype.empty = function() {\n        return this.nodes.length === 0;\n      };\n\n      Heap.prototype.size = function() {\n        return this.nodes.length;\n      };\n\n      Heap.prototype.clone = function() {\n        var heap;\n        heap = new Heap();\n        heap.nodes = this.nodes.slice(0);\n        return heap;\n      };\n\n      Heap.prototype.toArray = function() {\n        return this.nodes.slice(0);\n      };\n\n      Heap.prototype.insert = Heap.prototype.push;\n\n      Heap.prototype.top = Heap.prototype.peek;\n\n      Heap.prototype.front = Heap.prototype.peek;\n\n      Heap.prototype.has = Heap.prototype.contains;\n\n      Heap.prototype.copy = Heap.prototype.clone;\n\n      return Heap;\n\n    })();\n\n    (function(root, factory) {\n      {\n        return module.exports = factory();\n      }\n    })(this, function() {\n      return Heap;\n    });\n\n  }).call(commonjsGlobal);\n  });\n\n  var heap = heap$1;\n\n  var dijkstraDefaults = defaults$g({\n    root: null,\n    weight: function weight(edge) {\n      return 1;\n    },\n    directed: false\n  });\n  var elesfn$u = {\n    dijkstra: function dijkstra(options) {\n      if (!plainObject(options)) {\n        var args = arguments;\n        options = {\n          root: args[0],\n          weight: args[1],\n          directed: args[2]\n        };\n      }\n\n      var _dijkstraDefaults = dijkstraDefaults(options),\n          root = _dijkstraDefaults.root,\n          weight = _dijkstraDefaults.weight,\n          directed = _dijkstraDefaults.directed;\n\n      var eles = this;\n      var weightFn = weight;\n      var source = string(root) ? this.filter(root)[0] : root[0];\n      var dist = {};\n      var prev = {};\n      var knownDist = {};\n\n      var _this$byGroup = this.byGroup(),\n          nodes = _this$byGroup.nodes,\n          edges = _this$byGroup.edges;\n\n      edges.unmergeBy(function (ele) {\n        return ele.isLoop();\n      });\n\n      var getDist = function getDist(node) {\n        return dist[node.id()];\n      };\n\n      var setDist = function setDist(node, d) {\n        dist[node.id()] = d;\n        Q.updateItem(node);\n      };\n\n      var Q = new heap(function (a, b) {\n        return getDist(a) - getDist(b);\n      });\n\n      for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n        dist[node.id()] = node.same(source) ? 0 : Infinity;\n        Q.push(node);\n      }\n\n      var distBetween = function distBetween(u, v) {\n        var uvs = (directed ? u.edgesTo(v) : u.edgesWith(v)).intersect(edges);\n        var smallestDistance = Infinity;\n        var smallestEdge;\n\n        for (var _i = 0; _i < uvs.length; _i++) {\n          var edge = uvs[_i];\n\n          var _weight = weightFn(edge);\n\n          if (_weight < smallestDistance || !smallestEdge) {\n            smallestDistance = _weight;\n            smallestEdge = edge;\n          }\n        }\n\n        return {\n          edge: smallestEdge,\n          dist: smallestDistance\n        };\n      };\n\n      while (Q.size() > 0) {\n        var u = Q.pop();\n        var smalletsDist = getDist(u);\n        var uid = u.id();\n        knownDist[uid] = smalletsDist;\n\n        if (smalletsDist === Infinity) {\n          continue;\n        }\n\n        var neighbors = u.neighborhood().intersect(nodes);\n\n        for (var _i2 = 0; _i2 < neighbors.length; _i2++) {\n          var v = neighbors[_i2];\n          var vid = v.id();\n          var vDist = distBetween(u, v);\n          var alt = smalletsDist + vDist.dist;\n\n          if (alt < getDist(v)) {\n            setDist(v, alt);\n            prev[vid] = {\n              node: u,\n              edge: vDist.edge\n            };\n          }\n        } // for\n\n      } // while\n\n\n      return {\n        distanceTo: function distanceTo(node) {\n          var target = string(node) ? nodes.filter(node)[0] : node[0];\n          return knownDist[target.id()];\n        },\n        pathTo: function pathTo(node) {\n          var target = string(node) ? nodes.filter(node)[0] : node[0];\n          var S = [];\n          var u = target;\n          var uid = u.id();\n\n          if (target.length > 0) {\n            S.unshift(target);\n\n            while (prev[uid]) {\n              var p = prev[uid];\n              S.unshift(p.edge);\n              S.unshift(p.node);\n              u = p.node;\n              uid = u.id();\n            }\n          }\n\n          return eles.spawn(S);\n        }\n      };\n    }\n  };\n\n  var elesfn$t = {\n    // kruskal's algorithm (finds min spanning tree, assuming undirected graph)\n    // implemented from pseudocode from wikipedia\n    kruskal: function kruskal(weightFn) {\n      weightFn = weightFn || function (edge) {\n        return 1;\n      };\n\n      var _this$byGroup = this.byGroup(),\n          nodes = _this$byGroup.nodes,\n          edges = _this$byGroup.edges;\n\n      var numNodes = nodes.length;\n      var forest = new Array(numNodes);\n      var A = nodes; // assumes byGroup() creates new collections that can be safely mutated\n\n      var findSetIndex = function findSetIndex(ele) {\n        for (var i = 0; i < forest.length; i++) {\n          var eles = forest[i];\n\n          if (eles.has(ele)) {\n            return i;\n          }\n        }\n      }; // start with one forest per node\n\n\n      for (var i = 0; i < numNodes; i++) {\n        forest[i] = this.spawn(nodes[i]);\n      }\n\n      var S = edges.sort(function (a, b) {\n        return weightFn(a) - weightFn(b);\n      });\n\n      for (var _i = 0; _i < S.length; _i++) {\n        var edge = S[_i];\n        var u = edge.source()[0];\n        var v = edge.target()[0];\n        var setUIndex = findSetIndex(u);\n        var setVIndex = findSetIndex(v);\n        var setU = forest[setUIndex];\n        var setV = forest[setVIndex];\n\n        if (setUIndex !== setVIndex) {\n          A.merge(edge); // combine forests for u and v\n\n          setU.merge(setV);\n          forest.splice(setVIndex, 1);\n        }\n      }\n\n      return A;\n    }\n  };\n\n  var aStarDefaults = defaults$g({\n    root: null,\n    goal: null,\n    weight: function weight(edge) {\n      return 1;\n    },\n    heuristic: function heuristic(edge) {\n      return 0;\n    },\n    directed: false\n  });\n  var elesfn$s = {\n    // Implemented from pseudocode from wikipedia\n    aStar: function aStar(options) {\n      var cy = this.cy();\n\n      var _aStarDefaults = aStarDefaults(options),\n          root = _aStarDefaults.root,\n          goal = _aStarDefaults.goal,\n          heuristic = _aStarDefaults.heuristic,\n          directed = _aStarDefaults.directed,\n          weight = _aStarDefaults.weight;\n\n      root = cy.collection(root)[0];\n      goal = cy.collection(goal)[0];\n      var sid = root.id();\n      var tid = goal.id();\n      var gScore = {};\n      var fScore = {};\n      var closedSetIds = {};\n      var openSet = new heap(function (a, b) {\n        return fScore[a.id()] - fScore[b.id()];\n      });\n      var openSetIds = new Set$1();\n      var cameFrom = {};\n      var cameFromEdge = {};\n\n      var addToOpenSet = function addToOpenSet(ele, id) {\n        openSet.push(ele);\n        openSetIds.add(id);\n      };\n\n      var cMin, cMinId;\n\n      var popFromOpenSet = function popFromOpenSet() {\n        cMin = openSet.pop();\n        cMinId = cMin.id();\n        openSetIds[\"delete\"](cMinId);\n      };\n\n      var isInOpenSet = function isInOpenSet(id) {\n        return openSetIds.has(id);\n      };\n\n      addToOpenSet(root, sid);\n      gScore[sid] = 0;\n      fScore[sid] = heuristic(root); // Counter\n\n      var steps = 0; // Main loop\n\n      while (openSet.size() > 0) {\n        popFromOpenSet();\n        steps++; // If we've found our goal, then we are done\n\n        if (cMinId === tid) {\n          var path = [];\n          var pathNode = goal;\n          var pathNodeId = tid;\n          var pathEdge = cameFromEdge[pathNodeId];\n\n          for (;;) {\n            path.unshift(pathNode);\n\n            if (pathEdge != null) {\n              path.unshift(pathEdge);\n            }\n\n            pathNode = cameFrom[pathNodeId];\n\n            if (pathNode == null) {\n              break;\n            }\n\n            pathNodeId = pathNode.id();\n            pathEdge = cameFromEdge[pathNodeId];\n          }\n\n          return {\n            found: true,\n            distance: gScore[cMinId],\n            path: this.spawn(path),\n            steps: steps\n          };\n        } // Add cMin to processed nodes\n\n\n        closedSetIds[cMinId] = true; // Update scores for neighbors of cMin\n        // Take into account if graph is directed or not\n\n        var vwEdges = cMin._private.edges;\n\n        for (var i = 0; i < vwEdges.length; i++) {\n          var e = vwEdges[i]; // edge must be in set of calling eles\n\n          if (!this.hasElementWithId(e.id())) {\n            continue;\n          } // cMin must be the source of edge if directed\n\n\n          if (directed && e.data('source') !== cMinId) {\n            continue;\n          }\n\n          var wSrc = e.source();\n          var wTgt = e.target();\n          var w = wSrc.id() !== cMinId ? wSrc : wTgt;\n          var wid = w.id(); // node must be in set of calling eles\n\n          if (!this.hasElementWithId(wid)) {\n            continue;\n          } // if node is in closedSet, ignore it\n\n\n          if (closedSetIds[wid]) {\n            continue;\n          } // New tentative score for node w\n\n\n          var tempScore = gScore[cMinId] + weight(e); // Update gScore for node w if:\n          //   w not present in openSet\n          // OR\n          //   tentative gScore is less than previous value\n          // w not in openSet\n\n          if (!isInOpenSet(wid)) {\n            gScore[wid] = tempScore;\n            fScore[wid] = tempScore + heuristic(w);\n            addToOpenSet(w, wid);\n            cameFrom[wid] = cMin;\n            cameFromEdge[wid] = e;\n            continue;\n          } // w already in openSet, but with greater gScore\n\n\n          if (tempScore < gScore[wid]) {\n            gScore[wid] = tempScore;\n            fScore[wid] = tempScore + heuristic(w);\n            cameFrom[wid] = cMin;\n            cameFromEdge[wid] = e;\n          }\n        } // End of neighbors update\n\n      } // End of main loop\n      // If we've reached here, then we've not reached our goal\n\n\n      return {\n        found: false,\n        distance: undefined,\n        path: undefined,\n        steps: steps\n      };\n    }\n  }; // elesfn\n\n  var floydWarshallDefaults = defaults$g({\n    weight: function weight(edge) {\n      return 1;\n    },\n    directed: false\n  });\n  var elesfn$r = {\n    // Implemented from pseudocode from wikipedia\n    floydWarshall: function floydWarshall(options) {\n      var cy = this.cy();\n\n      var _floydWarshallDefault = floydWarshallDefaults(options),\n          weight = _floydWarshallDefault.weight,\n          directed = _floydWarshallDefault.directed;\n\n      var weightFn = weight;\n\n      var _this$byGroup = this.byGroup(),\n          nodes = _this$byGroup.nodes,\n          edges = _this$byGroup.edges;\n\n      var N = nodes.length;\n      var Nsq = N * N;\n\n      var indexOf = function indexOf(node) {\n        return nodes.indexOf(node);\n      };\n\n      var atIndex = function atIndex(i) {\n        return nodes[i];\n      }; // Initialize distance matrix\n\n\n      var dist = new Array(Nsq);\n\n      for (var n = 0; n < Nsq; n++) {\n        var j = n % N;\n        var i = (n - j) / N;\n\n        if (i === j) {\n          dist[n] = 0;\n        } else {\n          dist[n] = Infinity;\n        }\n      } // Initialize matrix used for path reconstruction\n      // Initialize distance matrix\n\n\n      var next = new Array(Nsq);\n      var edgeNext = new Array(Nsq); // Process edges\n\n      for (var _i = 0; _i < edges.length; _i++) {\n        var edge = edges[_i];\n        var src = edge.source()[0];\n        var tgt = edge.target()[0];\n\n        if (src === tgt) {\n          continue;\n        } // exclude loops\n\n\n        var s = indexOf(src);\n        var t = indexOf(tgt);\n        var st = s * N + t; // source to target index\n\n        var _weight = weightFn(edge); // Check if already process another edge between same 2 nodes\n\n\n        if (dist[st] > _weight) {\n          dist[st] = _weight;\n          next[st] = t;\n          edgeNext[st] = edge;\n        } // If undirected graph, process 'reversed' edge\n\n\n        if (!directed) {\n          var ts = t * N + s; // target to source index\n\n          if (!directed && dist[ts] > _weight) {\n            dist[ts] = _weight;\n            next[ts] = s;\n            edgeNext[ts] = edge;\n          }\n        }\n      } // Main loop\n\n\n      for (var k = 0; k < N; k++) {\n        for (var _i2 = 0; _i2 < N; _i2++) {\n          var ik = _i2 * N + k;\n\n          for (var _j = 0; _j < N; _j++) {\n            var ij = _i2 * N + _j;\n            var kj = k * N + _j;\n\n            if (dist[ik] + dist[kj] < dist[ij]) {\n              dist[ij] = dist[ik] + dist[kj];\n              next[ij] = next[ik];\n            }\n          }\n        }\n      }\n\n      var getArgEle = function getArgEle(ele) {\n        return (string(ele) ? cy.filter(ele) : ele)[0];\n      };\n\n      var indexOfArgEle = function indexOfArgEle(ele) {\n        return indexOf(getArgEle(ele));\n      };\n\n      var res = {\n        distance: function distance(from, to) {\n          var i = indexOfArgEle(from);\n          var j = indexOfArgEle(to);\n          return dist[i * N + j];\n        },\n        path: function path(from, to) {\n          var i = indexOfArgEle(from);\n          var j = indexOfArgEle(to);\n          var fromNode = atIndex(i);\n\n          if (i === j) {\n            return fromNode.collection();\n          }\n\n          if (next[i * N + j] == null) {\n            return cy.collection();\n          }\n\n          var path = cy.collection();\n          var prev = i;\n          var edge;\n          path.merge(fromNode);\n\n          while (i !== j) {\n            prev = i;\n            i = next[i * N + j];\n            edge = edgeNext[prev * N + i];\n            path.merge(edge);\n            path.merge(atIndex(i));\n          }\n\n          return path;\n        }\n      };\n      return res;\n    } // floydWarshall\n\n  }; // elesfn\n\n  var bellmanFordDefaults = defaults$g({\n    weight: function weight(edge) {\n      return 1;\n    },\n    directed: false,\n    root: null\n  });\n  var elesfn$q = {\n    // Implemented from pseudocode from wikipedia\n    bellmanFord: function bellmanFord(options) {\n      var _this = this;\n\n      var _bellmanFordDefaults = bellmanFordDefaults(options),\n          weight = _bellmanFordDefaults.weight,\n          directed = _bellmanFordDefaults.directed,\n          root = _bellmanFordDefaults.root;\n\n      var weightFn = weight;\n      var eles = this;\n      var cy = this.cy();\n\n      var _this$byGroup = this.byGroup(),\n          edges = _this$byGroup.edges,\n          nodes = _this$byGroup.nodes;\n\n      var numNodes = nodes.length;\n      var infoMap = new Map$2();\n      var hasNegativeWeightCycle = false;\n      var negativeWeightCycles = [];\n      root = cy.collection(root)[0]; // in case selector passed\n\n      edges.unmergeBy(function (edge) {\n        return edge.isLoop();\n      });\n      var numEdges = edges.length;\n\n      var getInfo = function getInfo(node) {\n        var obj = infoMap.get(node.id());\n\n        if (!obj) {\n          obj = {};\n          infoMap.set(node.id(), obj);\n        }\n\n        return obj;\n      };\n\n      var getNodeFromTo = function getNodeFromTo(to) {\n        return (string(to) ? cy.$(to) : to)[0];\n      };\n\n      var distanceTo = function distanceTo(to) {\n        return getInfo(getNodeFromTo(to)).dist;\n      };\n\n      var pathTo = function pathTo(to) {\n        var thisStart = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : root;\n        var end = getNodeFromTo(to);\n        var path = [];\n        var node = end;\n\n        for (;;) {\n          if (node == null) {\n            return _this.spawn();\n          }\n\n          var _getInfo = getInfo(node),\n              edge = _getInfo.edge,\n              pred = _getInfo.pred;\n\n          path.unshift(node[0]);\n\n          if (node.same(thisStart) && path.length > 0) {\n            break;\n          }\n\n          if (edge != null) {\n            path.unshift(edge);\n          }\n\n          node = pred;\n        }\n\n        return eles.spawn(path);\n      }; // Initializations { dist, pred, edge }\n\n\n      for (var i = 0; i < numNodes; i++) {\n        var node = nodes[i];\n        var info = getInfo(node);\n\n        if (node.same(root)) {\n          info.dist = 0;\n        } else {\n          info.dist = Infinity;\n        }\n\n        info.pred = null;\n        info.edge = null;\n      } // Edges relaxation\n\n\n      var replacedEdge = false;\n\n      var checkForEdgeReplacement = function checkForEdgeReplacement(node1, node2, edge, info1, info2, weight) {\n        var dist = info1.dist + weight;\n\n        if (dist < info2.dist && !edge.same(info1.edge)) {\n          info2.dist = dist;\n          info2.pred = node1;\n          info2.edge = edge;\n          replacedEdge = true;\n        }\n      };\n\n      for (var _i = 1; _i < numNodes; _i++) {\n        replacedEdge = false;\n\n        for (var e = 0; e < numEdges; e++) {\n          var edge = edges[e];\n          var src = edge.source();\n          var tgt = edge.target();\n\n          var _weight = weightFn(edge);\n\n          var srcInfo = getInfo(src);\n          var tgtInfo = getInfo(tgt);\n          checkForEdgeReplacement(src, tgt, edge, srcInfo, tgtInfo, _weight); // If undirected graph, we need to take into account the 'reverse' edge\n\n          if (!directed) {\n            checkForEdgeReplacement(tgt, src, edge, tgtInfo, srcInfo, _weight);\n          }\n        }\n\n        if (!replacedEdge) {\n          break;\n        }\n      }\n\n      if (replacedEdge) {\n        // Check for negative weight cycles\n        var negativeWeightCycleIds = [];\n\n        for (var _e = 0; _e < numEdges; _e++) {\n          var _edge = edges[_e];\n\n          var _src = _edge.source();\n\n          var _tgt = _edge.target();\n\n          var _weight2 = weightFn(_edge);\n\n          var srcDist = getInfo(_src).dist;\n          var tgtDist = getInfo(_tgt).dist;\n\n          if (srcDist + _weight2 < tgtDist || !directed && tgtDist + _weight2 < srcDist) {\n            if (!hasNegativeWeightCycle) {\n              warn('Graph contains a negative weight cycle for Bellman-Ford');\n              hasNegativeWeightCycle = true;\n            }\n\n            if (options.findNegativeWeightCycles !== false) {\n              var negativeNodes = [];\n\n              if (srcDist + _weight2 < tgtDist) {\n                negativeNodes.push(_src);\n              }\n\n              if (!directed && tgtDist + _weight2 < srcDist) {\n                negativeNodes.push(_tgt);\n              }\n\n              var numNegativeNodes = negativeNodes.length;\n\n              for (var n = 0; n < numNegativeNodes; n++) {\n                var start = negativeNodes[n];\n                var cycle = [start];\n                cycle.push(getInfo(start).edge);\n                var _node = getInfo(start).pred;\n\n                while (cycle.indexOf(_node) === -1) {\n                  cycle.push(_node);\n                  cycle.push(getInfo(_node).edge);\n                  _node = getInfo(_node).pred;\n                }\n\n                cycle = cycle.slice(cycle.indexOf(_node));\n                var smallestId = cycle[0].id();\n                var smallestIndex = 0;\n\n                for (var c = 2; c < cycle.length; c += 2) {\n                  if (cycle[c].id() < smallestId) {\n                    smallestId = cycle[c].id();\n                    smallestIndex = c;\n                  }\n                }\n\n                cycle = cycle.slice(smallestIndex).concat(cycle.slice(0, smallestIndex));\n                cycle.push(cycle[0]);\n                var cycleId = cycle.map(function (el) {\n                  return el.id();\n                }).join(\",\");\n\n                if (negativeWeightCycleIds.indexOf(cycleId) === -1) {\n                  negativeWeightCycles.push(eles.spawn(cycle));\n                  negativeWeightCycleIds.push(cycleId);\n                }\n              }\n            } else {\n              break;\n            }\n          }\n        }\n      }\n\n      return {\n        distanceTo: distanceTo,\n        pathTo: pathTo,\n        hasNegativeWeightCycle: hasNegativeWeightCycle,\n        negativeWeightCycles: negativeWeightCycles\n      };\n    } // bellmanFord\n\n  }; // elesfn\n\n  var sqrt2 = Math.sqrt(2); // Function which colapses 2 (meta) nodes into one\n  // Updates the remaining edge lists\n  // Receives as a paramater the edge which causes the collapse\n\n  var collapse = function collapse(edgeIndex, nodeMap, remainingEdges) {\n    if (remainingEdges.length === 0) {\n      error(\"Karger-Stein must be run on a connected (sub)graph\");\n    }\n\n    var edgeInfo = remainingEdges[edgeIndex];\n    var sourceIn = edgeInfo[1];\n    var targetIn = edgeInfo[2];\n    var partition1 = nodeMap[sourceIn];\n    var partition2 = nodeMap[targetIn];\n    var newEdges = remainingEdges; // re-use array\n    // Delete all edges between partition1 and partition2\n\n    for (var i = newEdges.length - 1; i >= 0; i--) {\n      var edge = newEdges[i];\n      var src = edge[1];\n      var tgt = edge[2];\n\n      if (nodeMap[src] === partition1 && nodeMap[tgt] === partition2 || nodeMap[src] === partition2 && nodeMap[tgt] === partition1) {\n        newEdges.splice(i, 1);\n      }\n    } // All edges pointing to partition2 should now point to partition1\n\n\n    for (var _i = 0; _i < newEdges.length; _i++) {\n      var _edge = newEdges[_i];\n\n      if (_edge[1] === partition2) {\n        // Check source\n        newEdges[_i] = _edge.slice(); // copy\n\n        newEdges[_i][1] = partition1;\n      } else if (_edge[2] === partition2) {\n        // Check target\n        newEdges[_i] = _edge.slice(); // copy\n\n        newEdges[_i][2] = partition1;\n      }\n    } // Move all nodes from partition2 to partition1\n\n\n    for (var _i2 = 0; _i2 < nodeMap.length; _i2++) {\n      if (nodeMap[_i2] === partition2) {\n        nodeMap[_i2] = partition1;\n      }\n    }\n\n    return newEdges;\n  }; // Contracts a graph until we reach a certain number of meta nodes\n\n\n  var contractUntil = function contractUntil(metaNodeMap, remainingEdges, size, sizeLimit) {\n    while (size > sizeLimit) {\n      // Choose an edge randomly\n      var edgeIndex = Math.floor(Math.random() * remainingEdges.length); // Collapse graph based on edge\n\n      remainingEdges = collapse(edgeIndex, metaNodeMap, remainingEdges);\n      size--;\n    }\n\n    return remainingEdges;\n  };\n\n  var elesfn$p = {\n    // Computes the minimum cut of an undirected graph\n    // Returns the correct answer with high probability\n    kargerStein: function kargerStein() {\n      var _this = this;\n\n      var _this$byGroup = this.byGroup(),\n          nodes = _this$byGroup.nodes,\n          edges = _this$byGroup.edges;\n\n      edges.unmergeBy(function (edge) {\n        return edge.isLoop();\n      });\n      var numNodes = nodes.length;\n      var numEdges = edges.length;\n      var numIter = Math.ceil(Math.pow(Math.log(numNodes) / Math.LN2, 2));\n      var stopSize = Math.floor(numNodes / sqrt2);\n\n      if (numNodes < 2) {\n        error('At least 2 nodes are required for Karger-Stein algorithm');\n        return undefined;\n      } // Now store edge destination as indexes\n      // Format for each edge (edge index, source node index, target node index)\n\n\n      var edgeIndexes = [];\n\n      for (var i = 0; i < numEdges; i++) {\n        var e = edges[i];\n        edgeIndexes.push([i, nodes.indexOf(e.source()), nodes.indexOf(e.target())]);\n      } // We will store the best cut found here\n\n\n      var minCutSize = Infinity;\n      var minCutEdgeIndexes = [];\n      var minCutNodeMap = new Array(numNodes); // Initial meta node partition\n\n      var metaNodeMap = new Array(numNodes);\n      var metaNodeMap2 = new Array(numNodes);\n\n      var copyNodesMap = function copyNodesMap(from, to) {\n        for (var _i3 = 0; _i3 < numNodes; _i3++) {\n          to[_i3] = from[_i3];\n        }\n      }; // Main loop\n\n\n      for (var iter = 0; iter <= numIter; iter++) {\n        // Reset meta node partition\n        for (var _i4 = 0; _i4 < numNodes; _i4++) {\n          metaNodeMap[_i4] = _i4;\n        } // Contract until stop point (stopSize nodes)\n\n\n        var edgesState = contractUntil(metaNodeMap, edgeIndexes.slice(), numNodes, stopSize);\n        var edgesState2 = edgesState.slice(); // copy\n        // Create a copy of the colapsed nodes state\n\n        copyNodesMap(metaNodeMap, metaNodeMap2); // Run 2 iterations starting in the stop state\n\n        var res1 = contractUntil(metaNodeMap, edgesState, stopSize, 2);\n        var res2 = contractUntil(metaNodeMap2, edgesState2, stopSize, 2); // Is any of the 2 results the best cut so far?\n\n        if (res1.length <= res2.length && res1.length < minCutSize) {\n          minCutSize = res1.length;\n          minCutEdgeIndexes = res1;\n          copyNodesMap(metaNodeMap, minCutNodeMap);\n        } else if (res2.length <= res1.length && res2.length < minCutSize) {\n          minCutSize = res2.length;\n          minCutEdgeIndexes = res2;\n          copyNodesMap(metaNodeMap2, minCutNodeMap);\n        }\n      } // end of main loop\n      // Construct result\n\n\n      var cut = this.spawn(minCutEdgeIndexes.map(function (e) {\n        return edges[e[0]];\n      }));\n      var partition1 = this.spawn();\n      var partition2 = this.spawn(); // traverse metaNodeMap for best cut\n\n      var witnessNodePartition = minCutNodeMap[0];\n\n      for (var _i5 = 0; _i5 < minCutNodeMap.length; _i5++) {\n        var partitionId = minCutNodeMap[_i5];\n        var node = nodes[_i5];\n\n        if (partitionId === witnessNodePartition) {\n          partition1.merge(node);\n        } else {\n          partition2.merge(node);\n        }\n      } // construct components corresponding to each disjoint subset of nodes\n\n\n      var constructComponent = function constructComponent(subset) {\n        var component = _this.spawn();\n\n        subset.forEach(function (node) {\n          component.merge(node);\n          node.connectedEdges().forEach(function (edge) {\n            // ensure edge is within calling collection and edge is not in cut\n            if (_this.contains(edge) && !cut.contains(edge)) {\n              component.merge(edge);\n            }\n          });\n        });\n        return component;\n      };\n\n      var components = [constructComponent(partition1), constructComponent(partition2)];\n      var ret = {\n        cut: cut,\n        components: components,\n        // n.b. partitions are included to be compatible with the old api spec\n        // (could be removed in a future major version)\n        partition1: partition1,\n        partition2: partition2\n      };\n      return ret;\n    }\n  }; // elesfn\n\n  var copyPosition = function copyPosition(p) {\n    return {\n      x: p.x,\n      y: p.y\n    };\n  };\n  var modelToRenderedPosition = function modelToRenderedPosition(p, zoom, pan) {\n    return {\n      x: p.x * zoom + pan.x,\n      y: p.y * zoom + pan.y\n    };\n  };\n  var renderedToModelPosition = function renderedToModelPosition(p, zoom, pan) {\n    return {\n      x: (p.x - pan.x) / zoom,\n      y: (p.y - pan.y) / zoom\n    };\n  };\n  var array2point = function array2point(arr) {\n    return {\n      x: arr[0],\n      y: arr[1]\n    };\n  };\n  var min = function min(arr) {\n    var begin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : arr.length;\n    var min = Infinity;\n\n    for (var i = begin; i < end; i++) {\n      var val = arr[i];\n\n      if (isFinite(val)) {\n        min = Math.min(val, min);\n      }\n    }\n\n    return min;\n  };\n  var max = function max(arr) {\n    var begin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : arr.length;\n    var max = -Infinity;\n\n    for (var i = begin; i < end; i++) {\n      var val = arr[i];\n\n      if (isFinite(val)) {\n        max = Math.max(val, max);\n      }\n    }\n\n    return max;\n  };\n  var mean = function mean(arr) {\n    var begin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : arr.length;\n    var total = 0;\n    var n = 0;\n\n    for (var i = begin; i < end; i++) {\n      var val = arr[i];\n\n      if (isFinite(val)) {\n        total += val;\n        n++;\n      }\n    }\n\n    return total / n;\n  };\n  var median = function median(arr) {\n    var begin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : arr.length;\n    var copy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    var sort = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    var includeHoles = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n\n    if (copy) {\n      arr = arr.slice(begin, end);\n    } else {\n      if (end < arr.length) {\n        arr.splice(end, arr.length - end);\n      }\n\n      if (begin > 0) {\n        arr.splice(0, begin);\n      }\n    } // all non finite (e.g. Infinity, NaN) elements must be -Infinity so they go to the start\n\n\n    var off = 0; // offset from non-finite values\n\n    for (var i = arr.length - 1; i >= 0; i--) {\n      var v = arr[i];\n\n      if (includeHoles) {\n        if (!isFinite(v)) {\n          arr[i] = -Infinity;\n          off++;\n        }\n      } else {\n        // just remove it if we don't want to consider holes\n        arr.splice(i, 1);\n      }\n    }\n\n    if (sort) {\n      arr.sort(function (a, b) {\n        return a - b;\n      }); // requires copy = true if you don't want to change the orig\n    }\n\n    var len = arr.length;\n    var mid = Math.floor(len / 2);\n\n    if (len % 2 !== 0) {\n      return arr[mid + 1 + off];\n    } else {\n      return (arr[mid - 1 + off] + arr[mid + off]) / 2;\n    }\n  };\n  var deg2rad = function deg2rad(deg) {\n    return Math.PI * deg / 180;\n  };\n  var getAngleFromDisp = function getAngleFromDisp(dispX, dispY) {\n    return Math.atan2(dispY, dispX) - Math.PI / 2;\n  };\n  var log2 = Math.log2 || function (n) {\n    return Math.log(n) / Math.log(2);\n  };\n  var signum = function signum(x) {\n    if (x > 0) {\n      return 1;\n    } else if (x < 0) {\n      return -1;\n    } else {\n      return 0;\n    }\n  };\n  var dist = function dist(p1, p2) {\n    return Math.sqrt(sqdist(p1, p2));\n  };\n  var sqdist = function sqdist(p1, p2) {\n    var dx = p2.x - p1.x;\n    var dy = p2.y - p1.y;\n    return dx * dx + dy * dy;\n  };\n  var inPlaceSumNormalize = function inPlaceSumNormalize(v) {\n    var length = v.length; // First, get sum of all elements\n\n    var total = 0;\n\n    for (var i = 0; i < length; i++) {\n      total += v[i];\n    } // Now, divide each by the sum of all elements\n\n\n    for (var _i = 0; _i < length; _i++) {\n      v[_i] = v[_i] / total;\n    }\n\n    return v;\n  };\n\n  var qbezierAt = function qbezierAt(p0, p1, p2, t) {\n    return (1 - t) * (1 - t) * p0 + 2 * (1 - t) * t * p1 + t * t * p2;\n  };\n  var qbezierPtAt = function qbezierPtAt(p0, p1, p2, t) {\n    return {\n      x: qbezierAt(p0.x, p1.x, p2.x, t),\n      y: qbezierAt(p0.y, p1.y, p2.y, t)\n    };\n  };\n  var lineAt = function lineAt(p0, p1, t, d) {\n    var vec = {\n      x: p1.x - p0.x,\n      y: p1.y - p0.y\n    };\n    var vecDist = dist(p0, p1);\n    var normVec = {\n      x: vec.x / vecDist,\n      y: vec.y / vecDist\n    };\n    t = t == null ? 0 : t;\n    d = d != null ? d : t * vecDist;\n    return {\n      x: p0.x + normVec.x * d,\n      y: p0.y + normVec.y * d\n    };\n  };\n  var bound = function bound(min, val, max) {\n    return Math.max(min, Math.min(max, val));\n  }; // makes a full bb (x1, y1, x2, y2, w, h) from implicit params\n\n  var makeBoundingBox = function makeBoundingBox(bb) {\n    if (bb == null) {\n      return {\n        x1: Infinity,\n        y1: Infinity,\n        x2: -Infinity,\n        y2: -Infinity,\n        w: 0,\n        h: 0\n      };\n    } else if (bb.x1 != null && bb.y1 != null) {\n      if (bb.x2 != null && bb.y2 != null && bb.x2 >= bb.x1 && bb.y2 >= bb.y1) {\n        return {\n          x1: bb.x1,\n          y1: bb.y1,\n          x2: bb.x2,\n          y2: bb.y2,\n          w: bb.x2 - bb.x1,\n          h: bb.y2 - bb.y1\n        };\n      } else if (bb.w != null && bb.h != null && bb.w >= 0 && bb.h >= 0) {\n        return {\n          x1: bb.x1,\n          y1: bb.y1,\n          x2: bb.x1 + bb.w,\n          y2: bb.y1 + bb.h,\n          w: bb.w,\n          h: bb.h\n        };\n      }\n    }\n  };\n  var copyBoundingBox = function copyBoundingBox(bb) {\n    return {\n      x1: bb.x1,\n      x2: bb.x2,\n      w: bb.w,\n      y1: bb.y1,\n      y2: bb.y2,\n      h: bb.h\n    };\n  };\n  var clearBoundingBox = function clearBoundingBox(bb) {\n    bb.x1 = Infinity;\n    bb.y1 = Infinity;\n    bb.x2 = -Infinity;\n    bb.y2 = -Infinity;\n    bb.w = 0;\n    bb.h = 0;\n  };\n  var updateBoundingBox = function updateBoundingBox(bb1, bb2) {\n    // update bb1 with bb2 bounds\n    bb1.x1 = Math.min(bb1.x1, bb2.x1);\n    bb1.x2 = Math.max(bb1.x2, bb2.x2);\n    bb1.w = bb1.x2 - bb1.x1;\n    bb1.y1 = Math.min(bb1.y1, bb2.y1);\n    bb1.y2 = Math.max(bb1.y2, bb2.y2);\n    bb1.h = bb1.y2 - bb1.y1;\n  };\n  var expandBoundingBoxByPoint = function expandBoundingBoxByPoint(bb, x, y) {\n    bb.x1 = Math.min(bb.x1, x);\n    bb.x2 = Math.max(bb.x2, x);\n    bb.w = bb.x2 - bb.x1;\n    bb.y1 = Math.min(bb.y1, y);\n    bb.y2 = Math.max(bb.y2, y);\n    bb.h = bb.y2 - bb.y1;\n  };\n  var expandBoundingBox = function expandBoundingBox(bb) {\n    var padding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    bb.x1 -= padding;\n    bb.x2 += padding;\n    bb.y1 -= padding;\n    bb.y2 += padding;\n    bb.w = bb.x2 - bb.x1;\n    bb.h = bb.y2 - bb.y1;\n    return bb;\n  };\n  var expandBoundingBoxSides = function expandBoundingBoxSides(bb) {\n    var padding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0];\n    var top, right, bottom, left;\n\n    if (padding.length === 1) {\n      top = right = bottom = left = padding[0];\n    } else if (padding.length === 2) {\n      top = bottom = padding[0];\n      left = right = padding[1];\n    } else if (padding.length === 4) {\n      var _padding = _slicedToArray(padding, 4);\n\n      top = _padding[0];\n      right = _padding[1];\n      bottom = _padding[2];\n      left = _padding[3];\n    }\n\n    bb.x1 -= left;\n    bb.x2 += right;\n    bb.y1 -= top;\n    bb.y2 += bottom;\n    bb.w = bb.x2 - bb.x1;\n    bb.h = bb.y2 - bb.y1;\n    return bb;\n  };\n\n  var assignBoundingBox = function assignBoundingBox(bb1, bb2) {\n    bb1.x1 = bb2.x1;\n    bb1.y1 = bb2.y1;\n    bb1.x2 = bb2.x2;\n    bb1.y2 = bb2.y2;\n    bb1.w = bb1.x2 - bb1.x1;\n    bb1.h = bb1.y2 - bb1.y1;\n  };\n  var boundingBoxesIntersect = function boundingBoxesIntersect(bb1, bb2) {\n    // case: one bb to right of other\n    if (bb1.x1 > bb2.x2) {\n      return false;\n    }\n\n    if (bb2.x1 > bb1.x2) {\n      return false;\n    } // case: one bb to left of other\n\n\n    if (bb1.x2 < bb2.x1) {\n      return false;\n    }\n\n    if (bb2.x2 < bb1.x1) {\n      return false;\n    } // case: one bb above other\n\n\n    if (bb1.y2 < bb2.y1) {\n      return false;\n    }\n\n    if (bb2.y2 < bb1.y1) {\n      return false;\n    } // case: one bb below other\n\n\n    if (bb1.y1 > bb2.y2) {\n      return false;\n    }\n\n    if (bb2.y1 > bb1.y2) {\n      return false;\n    } // otherwise, must have some overlap\n\n\n    return true;\n  };\n  var inBoundingBox = function inBoundingBox(bb, x, y) {\n    return bb.x1 <= x && x <= bb.x2 && bb.y1 <= y && y <= bb.y2;\n  };\n  var pointInBoundingBox = function pointInBoundingBox(bb, pt) {\n    return inBoundingBox(bb, pt.x, pt.y);\n  };\n  var boundingBoxInBoundingBox = function boundingBoxInBoundingBox(bb1, bb2) {\n    return inBoundingBox(bb1, bb2.x1, bb2.y1) && inBoundingBox(bb1, bb2.x2, bb2.y2);\n  };\n  var roundRectangleIntersectLine = function roundRectangleIntersectLine(x, y, nodeX, nodeY, width, height, padding) {\n    var cornerRadius = getRoundRectangleRadius(width, height);\n    var halfWidth = width / 2;\n    var halfHeight = height / 2; // Check intersections with straight line segments\n\n    var straightLineIntersections; // Top segment, left to right\n\n    {\n      var topStartX = nodeX - halfWidth + cornerRadius - padding;\n      var topStartY = nodeY - halfHeight - padding;\n      var topEndX = nodeX + halfWidth - cornerRadius + padding;\n      var topEndY = topStartY;\n      straightLineIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, topStartX, topStartY, topEndX, topEndY, false);\n\n      if (straightLineIntersections.length > 0) {\n        return straightLineIntersections;\n      }\n    } // Right segment, top to bottom\n\n    {\n      var rightStartX = nodeX + halfWidth + padding;\n      var rightStartY = nodeY - halfHeight + cornerRadius - padding;\n      var rightEndX = rightStartX;\n      var rightEndY = nodeY + halfHeight - cornerRadius + padding;\n      straightLineIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, rightStartX, rightStartY, rightEndX, rightEndY, false);\n\n      if (straightLineIntersections.length > 0) {\n        return straightLineIntersections;\n      }\n    } // Bottom segment, left to right\n\n    {\n      var bottomStartX = nodeX - halfWidth + cornerRadius - padding;\n      var bottomStartY = nodeY + halfHeight + padding;\n      var bottomEndX = nodeX + halfWidth - cornerRadius + padding;\n      var bottomEndY = bottomStartY;\n      straightLineIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, bottomStartX, bottomStartY, bottomEndX, bottomEndY, false);\n\n      if (straightLineIntersections.length > 0) {\n        return straightLineIntersections;\n      }\n    } // Left segment, top to bottom\n\n    {\n      var leftStartX = nodeX - halfWidth - padding;\n      var leftStartY = nodeY - halfHeight + cornerRadius - padding;\n      var leftEndX = leftStartX;\n      var leftEndY = nodeY + halfHeight - cornerRadius + padding;\n      straightLineIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, leftStartX, leftStartY, leftEndX, leftEndY, false);\n\n      if (straightLineIntersections.length > 0) {\n        return straightLineIntersections;\n      }\n    } // Check intersections with arc segments\n\n    var arcIntersections; // Top Left\n\n    {\n      var topLeftCenterX = nodeX - halfWidth + cornerRadius;\n      var topLeftCenterY = nodeY - halfHeight + cornerRadius;\n      arcIntersections = intersectLineCircle(x, y, nodeX, nodeY, topLeftCenterX, topLeftCenterY, cornerRadius + padding); // Ensure the intersection is on the desired quarter of the circle\n\n      if (arcIntersections.length > 0 && arcIntersections[0] <= topLeftCenterX && arcIntersections[1] <= topLeftCenterY) {\n        return [arcIntersections[0], arcIntersections[1]];\n      }\n    } // Top Right\n\n    {\n      var topRightCenterX = nodeX + halfWidth - cornerRadius;\n      var topRightCenterY = nodeY - halfHeight + cornerRadius;\n      arcIntersections = intersectLineCircle(x, y, nodeX, nodeY, topRightCenterX, topRightCenterY, cornerRadius + padding); // Ensure the intersection is on the desired quarter of the circle\n\n      if (arcIntersections.length > 0 && arcIntersections[0] >= topRightCenterX && arcIntersections[1] <= topRightCenterY) {\n        return [arcIntersections[0], arcIntersections[1]];\n      }\n    } // Bottom Right\n\n    {\n      var bottomRightCenterX = nodeX + halfWidth - cornerRadius;\n      var bottomRightCenterY = nodeY + halfHeight - cornerRadius;\n      arcIntersections = intersectLineCircle(x, y, nodeX, nodeY, bottomRightCenterX, bottomRightCenterY, cornerRadius + padding); // Ensure the intersection is on the desired quarter of the circle\n\n      if (arcIntersections.length > 0 && arcIntersections[0] >= bottomRightCenterX && arcIntersections[1] >= bottomRightCenterY) {\n        return [arcIntersections[0], arcIntersections[1]];\n      }\n    } // Bottom Left\n\n    {\n      var bottomLeftCenterX = nodeX - halfWidth + cornerRadius;\n      var bottomLeftCenterY = nodeY + halfHeight - cornerRadius;\n      arcIntersections = intersectLineCircle(x, y, nodeX, nodeY, bottomLeftCenterX, bottomLeftCenterY, cornerRadius + padding); // Ensure the intersection is on the desired quarter of the circle\n\n      if (arcIntersections.length > 0 && arcIntersections[0] <= bottomLeftCenterX && arcIntersections[1] >= bottomLeftCenterY) {\n        return [arcIntersections[0], arcIntersections[1]];\n      }\n    }\n    return []; // if nothing\n  };\n  var inLineVicinity = function inLineVicinity(x, y, lx1, ly1, lx2, ly2, tolerance) {\n    var t = tolerance;\n    var x1 = Math.min(lx1, lx2);\n    var x2 = Math.max(lx1, lx2);\n    var y1 = Math.min(ly1, ly2);\n    var y2 = Math.max(ly1, ly2);\n    return x1 - t <= x && x <= x2 + t && y1 - t <= y && y <= y2 + t;\n  };\n  var inBezierVicinity = function inBezierVicinity(x, y, x1, y1, x2, y2, x3, y3, tolerance) {\n    var bb = {\n      x1: Math.min(x1, x3, x2) - tolerance,\n      x2: Math.max(x1, x3, x2) + tolerance,\n      y1: Math.min(y1, y3, y2) - tolerance,\n      y2: Math.max(y1, y3, y2) + tolerance\n    }; // if outside the rough bounding box for the bezier, then it can't be a hit\n\n    if (x < bb.x1 || x > bb.x2 || y < bb.y1 || y > bb.y2) {\n      // console.log('bezier out of rough bb')\n      return false;\n    } else {\n      // console.log('do more expensive check');\n      return true;\n    }\n  };\n  var solveQuadratic = function solveQuadratic(a, b, c, val) {\n    c -= val;\n    var r = b * b - 4 * a * c;\n\n    if (r < 0) {\n      return [];\n    }\n\n    var sqrtR = Math.sqrt(r);\n    var denom = 2 * a;\n    var root1 = (-b + sqrtR) / denom;\n    var root2 = (-b - sqrtR) / denom;\n    return [root1, root2];\n  };\n  var solveCubic = function solveCubic(a, b, c, d, result) {\n    // Solves a cubic function, returns root in form [r1, i1, r2, i2, r3, i3], where\n    // r is the real component, i is the imaginary component\n    // An implementation of the Cardano method from the year 1545\n    // http://en.wikipedia.org/wiki/Cubic_function#The_nature_of_the_roots\n    var epsilon = 0.00001; // avoid division by zero while keeping the overall expression close in value\n\n    if (a === 0) {\n      a = epsilon;\n    }\n\n    b /= a;\n    c /= a;\n    d /= a;\n    var discriminant, q, r, dum1, s, t, term1, r13;\n    q = (3.0 * c - b * b) / 9.0;\n    r = -(27.0 * d) + b * (9.0 * c - 2.0 * (b * b));\n    r /= 54.0;\n    discriminant = q * q * q + r * r;\n    result[1] = 0;\n    term1 = b / 3.0;\n\n    if (discriminant > 0) {\n      s = r + Math.sqrt(discriminant);\n      s = s < 0 ? -Math.pow(-s, 1.0 / 3.0) : Math.pow(s, 1.0 / 3.0);\n      t = r - Math.sqrt(discriminant);\n      t = t < 0 ? -Math.pow(-t, 1.0 / 3.0) : Math.pow(t, 1.0 / 3.0);\n      result[0] = -term1 + s + t;\n      term1 += (s + t) / 2.0;\n      result[4] = result[2] = -term1;\n      term1 = Math.sqrt(3.0) * (-t + s) / 2;\n      result[3] = term1;\n      result[5] = -term1;\n      return;\n    }\n\n    result[5] = result[3] = 0;\n\n    if (discriminant === 0) {\n      r13 = r < 0 ? -Math.pow(-r, 1.0 / 3.0) : Math.pow(r, 1.0 / 3.0);\n      result[0] = -term1 + 2.0 * r13;\n      result[4] = result[2] = -(r13 + term1);\n      return;\n    }\n\n    q = -q;\n    dum1 = q * q * q;\n    dum1 = Math.acos(r / Math.sqrt(dum1));\n    r13 = 2.0 * Math.sqrt(q);\n    result[0] = -term1 + r13 * Math.cos(dum1 / 3.0);\n    result[2] = -term1 + r13 * Math.cos((dum1 + 2.0 * Math.PI) / 3.0);\n    result[4] = -term1 + r13 * Math.cos((dum1 + 4.0 * Math.PI) / 3.0);\n    return;\n  };\n  var sqdistToQuadraticBezier = function sqdistToQuadraticBezier(x, y, x1, y1, x2, y2, x3, y3) {\n    // Find minimum distance by using the minimum of the distance\n    // function between the given point and the curve\n    // This gives the coefficients of the resulting cubic equation\n    // whose roots tell us where a possible minimum is\n    // (Coefficients are divided by 4)\n    var a = 1.0 * x1 * x1 - 4 * x1 * x2 + 2 * x1 * x3 + 4 * x2 * x2 - 4 * x2 * x3 + x3 * x3 + y1 * y1 - 4 * y1 * y2 + 2 * y1 * y3 + 4 * y2 * y2 - 4 * y2 * y3 + y3 * y3;\n    var b = 1.0 * 9 * x1 * x2 - 3 * x1 * x1 - 3 * x1 * x3 - 6 * x2 * x2 + 3 * x2 * x3 + 9 * y1 * y2 - 3 * y1 * y1 - 3 * y1 * y3 - 6 * y2 * y2 + 3 * y2 * y3;\n    var c = 1.0 * 3 * x1 * x1 - 6 * x1 * x2 + x1 * x3 - x1 * x + 2 * x2 * x2 + 2 * x2 * x - x3 * x + 3 * y1 * y1 - 6 * y1 * y2 + y1 * y3 - y1 * y + 2 * y2 * y2 + 2 * y2 * y - y3 * y;\n    var d = 1.0 * x1 * x2 - x1 * x1 + x1 * x - x2 * x + y1 * y2 - y1 * y1 + y1 * y - y2 * y; // debug(\"coefficients: \" + a / a + \", \" + b / a + \", \" + c / a + \", \" + d / a);\n\n    var roots = []; // Use the cubic solving algorithm\n\n    solveCubic(a, b, c, d, roots);\n    var zeroThreshold = 0.0000001;\n    var params = [];\n\n    for (var index = 0; index < 6; index += 2) {\n      if (Math.abs(roots[index + 1]) < zeroThreshold && roots[index] >= 0 && roots[index] <= 1.0) {\n        params.push(roots[index]);\n      }\n    }\n\n    params.push(1.0);\n    params.push(0.0);\n    var minDistanceSquared = -1;\n    var curX, curY, distSquared;\n\n    for (var i = 0; i < params.length; i++) {\n      curX = Math.pow(1.0 - params[i], 2.0) * x1 + 2.0 * (1 - params[i]) * params[i] * x2 + params[i] * params[i] * x3;\n      curY = Math.pow(1 - params[i], 2.0) * y1 + 2 * (1.0 - params[i]) * params[i] * y2 + params[i] * params[i] * y3;\n      distSquared = Math.pow(curX - x, 2) + Math.pow(curY - y, 2); // debug('distance for param ' + params[i] + \": \" + Math.sqrt(distSquared));\n\n      if (minDistanceSquared >= 0) {\n        if (distSquared < minDistanceSquared) {\n          minDistanceSquared = distSquared;\n        }\n      } else {\n        minDistanceSquared = distSquared;\n      }\n    }\n\n    return minDistanceSquared;\n  };\n  var sqdistToFiniteLine = function sqdistToFiniteLine(x, y, x1, y1, x2, y2) {\n    var offset = [x - x1, y - y1];\n    var line = [x2 - x1, y2 - y1];\n    var lineSq = line[0] * line[0] + line[1] * line[1];\n    var hypSq = offset[0] * offset[0] + offset[1] * offset[1];\n    var dotProduct = offset[0] * line[0] + offset[1] * line[1];\n    var adjSq = dotProduct * dotProduct / lineSq;\n\n    if (dotProduct < 0) {\n      return hypSq;\n    }\n\n    if (adjSq > lineSq) {\n      return (x - x2) * (x - x2) + (y - y2) * (y - y2);\n    }\n\n    return hypSq - adjSq;\n  };\n  var pointInsidePolygonPoints = function pointInsidePolygonPoints(x, y, points) {\n    var x1, y1, x2, y2;\n    var y3; // Intersect with vertical line through (x, y)\n\n    var up = 0; // let down = 0;\n\n    for (var i = 0; i < points.length / 2; i++) {\n      x1 = points[i * 2];\n      y1 = points[i * 2 + 1];\n\n      if (i + 1 < points.length / 2) {\n        x2 = points[(i + 1) * 2];\n        y2 = points[(i + 1) * 2 + 1];\n      } else {\n        x2 = points[(i + 1 - points.length / 2) * 2];\n        y2 = points[(i + 1 - points.length / 2) * 2 + 1];\n      }\n\n      if (x1 == x && x2 == x) ; else if (x1 >= x && x >= x2 || x1 <= x && x <= x2) {\n        y3 = (x - x1) / (x2 - x1) * (y2 - y1) + y1;\n\n        if (y3 > y) {\n          up++;\n        } // if( y3 < y ){\n        // down++;\n        // }\n\n      } else {\n        continue;\n      }\n    }\n\n    if (up % 2 === 0) {\n      return false;\n    } else {\n      return true;\n    }\n  };\n  var pointInsidePolygon = function pointInsidePolygon(x, y, basePoints, centerX, centerY, width, height, direction, padding) {\n    var transformedPoints = new Array(basePoints.length); // Gives negative angle\n\n    var angle;\n\n    if (direction[0] != null) {\n      angle = Math.atan(direction[1] / direction[0]);\n\n      if (direction[0] < 0) {\n        angle = angle + Math.PI / 2;\n      } else {\n        angle = -angle - Math.PI / 2;\n      }\n    } else {\n      angle = direction;\n    }\n\n    var cos = Math.cos(-angle);\n    var sin = Math.sin(-angle); //    console.log(\"base: \" + basePoints);\n\n    for (var i = 0; i < transformedPoints.length / 2; i++) {\n      transformedPoints[i * 2] = width / 2 * (basePoints[i * 2] * cos - basePoints[i * 2 + 1] * sin);\n      transformedPoints[i * 2 + 1] = height / 2 * (basePoints[i * 2 + 1] * cos + basePoints[i * 2] * sin);\n      transformedPoints[i * 2] += centerX;\n      transformedPoints[i * 2 + 1] += centerY;\n    }\n\n    var points;\n\n    if (padding > 0) {\n      var expandedLineSet = expandPolygon(transformedPoints, -padding);\n      points = joinLines(expandedLineSet);\n    } else {\n      points = transformedPoints;\n    }\n\n    return pointInsidePolygonPoints(x, y, points);\n  };\n  var pointInsideRoundPolygon = function pointInsideRoundPolygon(x, y, basePoints, centerX, centerY, width, height) {\n    var cutPolygonPoints = new Array(basePoints.length);\n    var halfW = width / 2;\n    var halfH = height / 2;\n    var cornerRadius = getRoundPolygonRadius(width, height);\n    var squaredCornerRadius = cornerRadius * cornerRadius;\n\n    for (var i = 0; i < basePoints.length / 4; i++) {\n      var sourceUv = void 0,\n          destUv = void 0;\n\n      if (i === 0) {\n        sourceUv = basePoints.length - 2;\n      } else {\n        sourceUv = i * 4 - 2;\n      }\n\n      destUv = i * 4 + 2;\n      var px = centerX + halfW * basePoints[i * 4];\n      var py = centerY + halfH * basePoints[i * 4 + 1];\n      var cosTheta = -basePoints[sourceUv] * basePoints[destUv] - basePoints[sourceUv + 1] * basePoints[destUv + 1];\n      var offset = cornerRadius / Math.tan(Math.acos(cosTheta) / 2);\n      var cp0x = px - offset * basePoints[sourceUv];\n      var cp0y = py - offset * basePoints[sourceUv + 1];\n      var cp1x = px + offset * basePoints[destUv];\n      var cp1y = py + offset * basePoints[destUv + 1];\n      cutPolygonPoints[i * 4] = cp0x;\n      cutPolygonPoints[i * 4 + 1] = cp0y;\n      cutPolygonPoints[i * 4 + 2] = cp1x;\n      cutPolygonPoints[i * 4 + 3] = cp1y;\n      var orthx = basePoints[sourceUv + 1];\n      var orthy = -basePoints[sourceUv];\n      var cosAlpha = orthx * basePoints[destUv] + orthy * basePoints[destUv + 1];\n\n      if (cosAlpha < 0) {\n        orthx *= -1;\n        orthy *= -1;\n      }\n\n      var cx = cp0x + orthx * cornerRadius;\n      var cy = cp0y + orthy * cornerRadius;\n      var squaredDistance = Math.pow(cx - x, 2) + Math.pow(cy - y, 2);\n\n      if (squaredDistance <= squaredCornerRadius) {\n        return true;\n      }\n    }\n\n    return pointInsidePolygonPoints(x, y, cutPolygonPoints);\n  };\n  var joinLines = function joinLines(lineSet) {\n    var vertices = new Array(lineSet.length / 2);\n    var currentLineStartX, currentLineStartY, currentLineEndX, currentLineEndY;\n    var nextLineStartX, nextLineStartY, nextLineEndX, nextLineEndY;\n\n    for (var i = 0; i < lineSet.length / 4; i++) {\n      currentLineStartX = lineSet[i * 4];\n      currentLineStartY = lineSet[i * 4 + 1];\n      currentLineEndX = lineSet[i * 4 + 2];\n      currentLineEndY = lineSet[i * 4 + 3];\n\n      if (i < lineSet.length / 4 - 1) {\n        nextLineStartX = lineSet[(i + 1) * 4];\n        nextLineStartY = lineSet[(i + 1) * 4 + 1];\n        nextLineEndX = lineSet[(i + 1) * 4 + 2];\n        nextLineEndY = lineSet[(i + 1) * 4 + 3];\n      } else {\n        nextLineStartX = lineSet[0];\n        nextLineStartY = lineSet[1];\n        nextLineEndX = lineSet[2];\n        nextLineEndY = lineSet[3];\n      }\n\n      var intersection = finiteLinesIntersect(currentLineStartX, currentLineStartY, currentLineEndX, currentLineEndY, nextLineStartX, nextLineStartY, nextLineEndX, nextLineEndY, true);\n      vertices[i * 2] = intersection[0];\n      vertices[i * 2 + 1] = intersection[1];\n    }\n\n    return vertices;\n  };\n  var expandPolygon = function expandPolygon(points, pad) {\n    var expandedLineSet = new Array(points.length * 2);\n    var currentPointX, currentPointY, nextPointX, nextPointY;\n\n    for (var i = 0; i < points.length / 2; i++) {\n      currentPointX = points[i * 2];\n      currentPointY = points[i * 2 + 1];\n\n      if (i < points.length / 2 - 1) {\n        nextPointX = points[(i + 1) * 2];\n        nextPointY = points[(i + 1) * 2 + 1];\n      } else {\n        nextPointX = points[0];\n        nextPointY = points[1];\n      } // Current line: [currentPointX, currentPointY] to [nextPointX, nextPointY]\n      // Assume CCW polygon winding\n\n\n      var offsetX = nextPointY - currentPointY;\n      var offsetY = -(nextPointX - currentPointX); // Normalize\n\n      var offsetLength = Math.sqrt(offsetX * offsetX + offsetY * offsetY);\n      var normalizedOffsetX = offsetX / offsetLength;\n      var normalizedOffsetY = offsetY / offsetLength;\n      expandedLineSet[i * 4] = currentPointX + normalizedOffsetX * pad;\n      expandedLineSet[i * 4 + 1] = currentPointY + normalizedOffsetY * pad;\n      expandedLineSet[i * 4 + 2] = nextPointX + normalizedOffsetX * pad;\n      expandedLineSet[i * 4 + 3] = nextPointY + normalizedOffsetY * pad;\n    }\n\n    return expandedLineSet;\n  };\n  var intersectLineEllipse = function intersectLineEllipse(x, y, centerX, centerY, ellipseWradius, ellipseHradius) {\n    var dispX = centerX - x;\n    var dispY = centerY - y;\n    dispX /= ellipseWradius;\n    dispY /= ellipseHradius;\n    var len = Math.sqrt(dispX * dispX + dispY * dispY);\n    var newLength = len - 1;\n\n    if (newLength < 0) {\n      return [];\n    }\n\n    var lenProportion = newLength / len;\n    return [(centerX - x) * lenProportion + x, (centerY - y) * lenProportion + y];\n  };\n  var checkInEllipse = function checkInEllipse(x, y, width, height, centerX, centerY, padding) {\n    x -= centerX;\n    y -= centerY;\n    x /= width / 2 + padding;\n    y /= height / 2 + padding;\n    return x * x + y * y <= 1;\n  }; // Returns intersections of increasing distance from line's start point\n\n  var intersectLineCircle = function intersectLineCircle(x1, y1, x2, y2, centerX, centerY, radius) {\n    // Calculate d, direction vector of line\n    var d = [x2 - x1, y2 - y1]; // Direction vector of line\n\n    var f = [x1 - centerX, y1 - centerY];\n    var a = d[0] * d[0] + d[1] * d[1];\n    var b = 2 * (f[0] * d[0] + f[1] * d[1]);\n    var c = f[0] * f[0] + f[1] * f[1] - radius * radius;\n    var discriminant = b * b - 4 * a * c;\n\n    if (discriminant < 0) {\n      return [];\n    }\n\n    var t1 = (-b + Math.sqrt(discriminant)) / (2 * a);\n    var t2 = (-b - Math.sqrt(discriminant)) / (2 * a);\n    var tMin = Math.min(t1, t2);\n    var tMax = Math.max(t1, t2);\n    var inRangeParams = [];\n\n    if (tMin >= 0 && tMin <= 1) {\n      inRangeParams.push(tMin);\n    }\n\n    if (tMax >= 0 && tMax <= 1) {\n      inRangeParams.push(tMax);\n    }\n\n    if (inRangeParams.length === 0) {\n      return [];\n    }\n\n    var nearIntersectionX = inRangeParams[0] * d[0] + x1;\n    var nearIntersectionY = inRangeParams[0] * d[1] + y1;\n\n    if (inRangeParams.length > 1) {\n      if (inRangeParams[0] == inRangeParams[1]) {\n        return [nearIntersectionX, nearIntersectionY];\n      } else {\n        var farIntersectionX = inRangeParams[1] * d[0] + x1;\n        var farIntersectionY = inRangeParams[1] * d[1] + y1;\n        return [nearIntersectionX, nearIntersectionY, farIntersectionX, farIntersectionY];\n      }\n    } else {\n      return [nearIntersectionX, nearIntersectionY];\n    }\n  };\n  var midOfThree = function midOfThree(a, b, c) {\n    if (b <= a && a <= c || c <= a && a <= b) {\n      return a;\n    } else if (a <= b && b <= c || c <= b && b <= a) {\n      return b;\n    } else {\n      return c;\n    }\n  }; // (x1,y1)=>(x2,y2) intersect with (x3,y3)=>(x4,y4)\n\n  var finiteLinesIntersect = function finiteLinesIntersect(x1, y1, x2, y2, x3, y3, x4, y4, infiniteLines) {\n    var dx13 = x1 - x3;\n    var dx21 = x2 - x1;\n    var dx43 = x4 - x3;\n    var dy13 = y1 - y3;\n    var dy21 = y2 - y1;\n    var dy43 = y4 - y3;\n    var ua_t = dx43 * dy13 - dy43 * dx13;\n    var ub_t = dx21 * dy13 - dy21 * dx13;\n    var u_b = dy43 * dx21 - dx43 * dy21;\n\n    if (u_b !== 0) {\n      var ua = ua_t / u_b;\n      var ub = ub_t / u_b;\n      var flptThreshold = 0.001;\n\n      var _min = 0 - flptThreshold;\n\n      var _max = 1 + flptThreshold;\n\n      if (_min <= ua && ua <= _max && _min <= ub && ub <= _max) {\n        return [x1 + ua * dx21, y1 + ua * dy21];\n      } else {\n        if (!infiniteLines) {\n          return [];\n        } else {\n          return [x1 + ua * dx21, y1 + ua * dy21];\n        }\n      }\n    } else {\n      if (ua_t === 0 || ub_t === 0) {\n        // Parallel, coincident lines. Check if overlap\n        // Check endpoint of second line\n        if (midOfThree(x1, x2, x4) === x4) {\n          return [x4, y4];\n        } // Check start point of second line\n\n\n        if (midOfThree(x1, x2, x3) === x3) {\n          return [x3, y3];\n        } // Endpoint of first line\n\n\n        if (midOfThree(x3, x4, x2) === x2) {\n          return [x2, y2];\n        }\n\n        return [];\n      } else {\n        // Parallel, non-coincident\n        return [];\n      }\n    }\n  }; // math.polygonIntersectLine( x, y, basePoints, centerX, centerY, width, height, padding )\n  // intersect a node polygon (pts transformed)\n  //\n  // math.polygonIntersectLine( x, y, basePoints, centerX, centerY )\n  // intersect the points (no transform)\n\n  var polygonIntersectLine = function polygonIntersectLine(x, y, basePoints, centerX, centerY, width, height, padding) {\n    var intersections = [];\n    var intersection;\n    var transformedPoints = new Array(basePoints.length);\n    var doTransform = true;\n\n    if (width == null) {\n      doTransform = false;\n    }\n\n    var points;\n\n    if (doTransform) {\n      for (var i = 0; i < transformedPoints.length / 2; i++) {\n        transformedPoints[i * 2] = basePoints[i * 2] * width + centerX;\n        transformedPoints[i * 2 + 1] = basePoints[i * 2 + 1] * height + centerY;\n      }\n\n      if (padding > 0) {\n        var expandedLineSet = expandPolygon(transformedPoints, -padding);\n        points = joinLines(expandedLineSet);\n      } else {\n        points = transformedPoints;\n      }\n    } else {\n      points = basePoints;\n    }\n\n    var currentX, currentY, nextX, nextY;\n\n    for (var _i2 = 0; _i2 < points.length / 2; _i2++) {\n      currentX = points[_i2 * 2];\n      currentY = points[_i2 * 2 + 1];\n\n      if (_i2 < points.length / 2 - 1) {\n        nextX = points[(_i2 + 1) * 2];\n        nextY = points[(_i2 + 1) * 2 + 1];\n      } else {\n        nextX = points[0];\n        nextY = points[1];\n      }\n\n      intersection = finiteLinesIntersect(x, y, centerX, centerY, currentX, currentY, nextX, nextY);\n\n      if (intersection.length !== 0) {\n        intersections.push(intersection[0], intersection[1]);\n      }\n    }\n\n    return intersections;\n  };\n  var roundPolygonIntersectLine = function roundPolygonIntersectLine(x, y, basePoints, centerX, centerY, width, height, padding) {\n    var intersections = [];\n    var intersection;\n    var lines = new Array(basePoints.length);\n    var halfW = width / 2;\n    var halfH = height / 2;\n    var cornerRadius = getRoundPolygonRadius(width, height);\n\n    for (var i = 0; i < basePoints.length / 4; i++) {\n      var sourceUv = void 0,\n          destUv = void 0;\n\n      if (i === 0) {\n        sourceUv = basePoints.length - 2;\n      } else {\n        sourceUv = i * 4 - 2;\n      }\n\n      destUv = i * 4 + 2;\n      var px = centerX + halfW * basePoints[i * 4];\n      var py = centerY + halfH * basePoints[i * 4 + 1];\n      var cosTheta = -basePoints[sourceUv] * basePoints[destUv] - basePoints[sourceUv + 1] * basePoints[destUv + 1];\n      var offset = cornerRadius / Math.tan(Math.acos(cosTheta) / 2);\n      var cp0x = px - offset * basePoints[sourceUv];\n      var cp0y = py - offset * basePoints[sourceUv + 1];\n      var cp1x = px + offset * basePoints[destUv];\n      var cp1y = py + offset * basePoints[destUv + 1];\n\n      if (i === 0) {\n        lines[basePoints.length - 2] = cp0x;\n        lines[basePoints.length - 1] = cp0y;\n      } else {\n        lines[i * 4 - 2] = cp0x;\n        lines[i * 4 - 1] = cp0y;\n      }\n\n      lines[i * 4] = cp1x;\n      lines[i * 4 + 1] = cp1y;\n      var orthx = basePoints[sourceUv + 1];\n      var orthy = -basePoints[sourceUv];\n      var cosAlpha = orthx * basePoints[destUv] + orthy * basePoints[destUv + 1];\n\n      if (cosAlpha < 0) {\n        orthx *= -1;\n        orthy *= -1;\n      }\n\n      var cx = cp0x + orthx * cornerRadius;\n      var cy = cp0y + orthy * cornerRadius;\n      intersection = intersectLineCircle(x, y, centerX, centerY, cx, cy, cornerRadius);\n\n      if (intersection.length !== 0) {\n        intersections.push(intersection[0], intersection[1]);\n      }\n    }\n\n    for (var _i3 = 0; _i3 < lines.length / 4; _i3++) {\n      intersection = finiteLinesIntersect(x, y, centerX, centerY, lines[_i3 * 4], lines[_i3 * 4 + 1], lines[_i3 * 4 + 2], lines[_i3 * 4 + 3], false);\n\n      if (intersection.length !== 0) {\n        intersections.push(intersection[0], intersection[1]);\n      }\n    }\n\n    if (intersections.length > 2) {\n      var lowestIntersection = [intersections[0], intersections[1]];\n      var lowestSquaredDistance = Math.pow(lowestIntersection[0] - x, 2) + Math.pow(lowestIntersection[1] - y, 2);\n\n      for (var _i4 = 1; _i4 < intersections.length / 2; _i4++) {\n        var squaredDistance = Math.pow(intersections[_i4 * 2] - x, 2) + Math.pow(intersections[_i4 * 2 + 1] - y, 2);\n\n        if (squaredDistance <= lowestSquaredDistance) {\n          lowestIntersection[0] = intersections[_i4 * 2];\n          lowestIntersection[1] = intersections[_i4 * 2 + 1];\n          lowestSquaredDistance = squaredDistance;\n        }\n      }\n\n      return lowestIntersection;\n    }\n\n    return intersections;\n  };\n  var shortenIntersection = function shortenIntersection(intersection, offset, amount) {\n    var disp = [intersection[0] - offset[0], intersection[1] - offset[1]];\n    var length = Math.sqrt(disp[0] * disp[0] + disp[1] * disp[1]);\n    var lenRatio = (length - amount) / length;\n\n    if (lenRatio < 0) {\n      lenRatio = 0.00001;\n    }\n\n    return [offset[0] + lenRatio * disp[0], offset[1] + lenRatio * disp[1]];\n  };\n  var generateUnitNgonPointsFitToSquare = function generateUnitNgonPointsFitToSquare(sides, rotationRadians) {\n    var points = generateUnitNgonPoints(sides, rotationRadians);\n    points = fitPolygonToSquare(points);\n    return points;\n  };\n  var fitPolygonToSquare = function fitPolygonToSquare(points) {\n    var x, y;\n    var sides = points.length / 2;\n    var minX = Infinity,\n        minY = Infinity,\n        maxX = -Infinity,\n        maxY = -Infinity;\n\n    for (var i = 0; i < sides; i++) {\n      x = points[2 * i];\n      y = points[2 * i + 1];\n      minX = Math.min(minX, x);\n      maxX = Math.max(maxX, x);\n      minY = Math.min(minY, y);\n      maxY = Math.max(maxY, y);\n    } // stretch factors\n\n\n    var sx = 2 / (maxX - minX);\n    var sy = 2 / (maxY - minY);\n\n    for (var _i5 = 0; _i5 < sides; _i5++) {\n      x = points[2 * _i5] = points[2 * _i5] * sx;\n      y = points[2 * _i5 + 1] = points[2 * _i5 + 1] * sy;\n      minX = Math.min(minX, x);\n      maxX = Math.max(maxX, x);\n      minY = Math.min(minY, y);\n      maxY = Math.max(maxY, y);\n    }\n\n    if (minY < -1) {\n      for (var _i6 = 0; _i6 < sides; _i6++) {\n        y = points[2 * _i6 + 1] = points[2 * _i6 + 1] + (-1 - minY);\n      }\n    }\n\n    return points;\n  };\n  var generateUnitNgonPoints = function generateUnitNgonPoints(sides, rotationRadians) {\n    var increment = 1.0 / sides * 2 * Math.PI;\n    var startAngle = sides % 2 === 0 ? Math.PI / 2.0 + increment / 2.0 : Math.PI / 2.0;\n    startAngle += rotationRadians;\n    var points = new Array(sides * 2);\n    var currentAngle;\n\n    for (var i = 0; i < sides; i++) {\n      currentAngle = i * increment + startAngle;\n      points[2 * i] = Math.cos(currentAngle); // x\n\n      points[2 * i + 1] = Math.sin(-currentAngle); // y\n    }\n\n    return points;\n  }; // Set the default radius, unless half of width or height is smaller than default\n\n  var getRoundRectangleRadius = function getRoundRectangleRadius(width, height) {\n    return Math.min(width / 4, height / 4, 8);\n  }; // Set the default radius\n\n  var getRoundPolygonRadius = function getRoundPolygonRadius(width, height) {\n    return Math.min(width / 10, height / 10, 8);\n  };\n  var getCutRectangleCornerLength = function getCutRectangleCornerLength() {\n    return 8;\n  };\n  var bezierPtsToQuadCoeff = function bezierPtsToQuadCoeff(p0, p1, p2) {\n    return [p0 - 2 * p1 + p2, 2 * (p1 - p0), p0];\n  }; // get curve width, height, and control point position offsets as a percentage of node height / width\n\n  var getBarrelCurveConstants = function getBarrelCurveConstants(width, height) {\n    return {\n      heightOffset: Math.min(15, 0.05 * height),\n      widthOffset: Math.min(100, 0.25 * width),\n      ctrlPtOffsetPct: 0.05\n    };\n  };\n\n  var pageRankDefaults = defaults$g({\n    dampingFactor: 0.8,\n    precision: 0.000001,\n    iterations: 200,\n    weight: function weight(edge) {\n      return 1;\n    }\n  });\n  var elesfn$o = {\n    pageRank: function pageRank(options) {\n      var _pageRankDefaults = pageRankDefaults(options),\n          dampingFactor = _pageRankDefaults.dampingFactor,\n          precision = _pageRankDefaults.precision,\n          iterations = _pageRankDefaults.iterations,\n          weight = _pageRankDefaults.weight;\n\n      var cy = this._private.cy;\n\n      var _this$byGroup = this.byGroup(),\n          nodes = _this$byGroup.nodes,\n          edges = _this$byGroup.edges;\n\n      var numNodes = nodes.length;\n      var numNodesSqd = numNodes * numNodes;\n      var numEdges = edges.length; // Construct transposed adjacency matrix\n      // First lets have a zeroed matrix of the right size\n      // We'll also keep track of the sum of each column\n\n      var matrix = new Array(numNodesSqd);\n      var columnSum = new Array(numNodes);\n      var additionalProb = (1 - dampingFactor) / numNodes; // Create null matrix\n\n      for (var i = 0; i < numNodes; i++) {\n        for (var j = 0; j < numNodes; j++) {\n          var n = i * numNodes + j;\n          matrix[n] = 0;\n        }\n\n        columnSum[i] = 0;\n      } // Now, process edges\n\n\n      for (var _i = 0; _i < numEdges; _i++) {\n        var edge = edges[_i];\n        var srcId = edge.data('source');\n        var tgtId = edge.data('target'); // Don't include loops in the matrix\n\n        if (srcId === tgtId) {\n          continue;\n        }\n\n        var s = nodes.indexOfId(srcId);\n        var t = nodes.indexOfId(tgtId);\n        var w = weight(edge);\n\n        var _n = t * numNodes + s; // Update matrix\n\n\n        matrix[_n] += w; // Update column sum\n\n        columnSum[s] += w;\n      } // Add additional probability based on damping factor\n      // Also, take into account columns that have sum = 0\n\n\n      var p = 1.0 / numNodes + additionalProb; // Shorthand\n      // Traverse matrix, column by column\n\n      for (var _j = 0; _j < numNodes; _j++) {\n        if (columnSum[_j] === 0) {\n          // No 'links' out from node jth, assume equal probability for each possible node\n          for (var _i2 = 0; _i2 < numNodes; _i2++) {\n            var _n2 = _i2 * numNodes + _j;\n\n            matrix[_n2] = p;\n          }\n        } else {\n          // Node jth has outgoing link, compute normalized probabilities\n          for (var _i3 = 0; _i3 < numNodes; _i3++) {\n            var _n3 = _i3 * numNodes + _j;\n\n            matrix[_n3] = matrix[_n3] / columnSum[_j] + additionalProb;\n          }\n        }\n      } // Compute dominant eigenvector using power method\n\n\n      var eigenvector = new Array(numNodes);\n      var temp = new Array(numNodes);\n      var previous; // Start with a vector of all 1's\n      // Also, initialize a null vector which will be used as shorthand\n\n      for (var _i4 = 0; _i4 < numNodes; _i4++) {\n        eigenvector[_i4] = 1;\n      }\n\n      for (var iter = 0; iter < iterations; iter++) {\n        // Temp array with all 0's\n        for (var _i5 = 0; _i5 < numNodes; _i5++) {\n          temp[_i5] = 0;\n        } // Multiply matrix with previous result\n\n\n        for (var _i6 = 0; _i6 < numNodes; _i6++) {\n          for (var _j2 = 0; _j2 < numNodes; _j2++) {\n            var _n4 = _i6 * numNodes + _j2;\n\n            temp[_i6] += matrix[_n4] * eigenvector[_j2];\n          }\n        }\n\n        inPlaceSumNormalize(temp);\n        previous = eigenvector;\n        eigenvector = temp;\n        temp = previous;\n        var diff = 0; // Compute difference (squared module) of both vectors\n\n        for (var _i7 = 0; _i7 < numNodes; _i7++) {\n          var delta = previous[_i7] - eigenvector[_i7];\n          diff += delta * delta;\n        } // If difference is less than the desired threshold, stop iterating\n\n\n        if (diff < precision) {\n          break;\n        }\n      } // Construct result\n\n\n      var res = {\n        rank: function rank(node) {\n          node = cy.collection(node)[0];\n          return eigenvector[nodes.indexOf(node)];\n        }\n      };\n      return res;\n    } // pageRank\n\n  }; // elesfn\n\n  var defaults$f = defaults$g({\n    root: null,\n    weight: function weight(edge) {\n      return 1;\n    },\n    directed: false,\n    alpha: 0\n  });\n  var elesfn$n = {\n    degreeCentralityNormalized: function degreeCentralityNormalized(options) {\n      options = defaults$f(options);\n      var cy = this.cy();\n      var nodes = this.nodes();\n      var numNodes = nodes.length;\n\n      if (!options.directed) {\n        var degrees = {};\n        var maxDegree = 0;\n\n        for (var i = 0; i < numNodes; i++) {\n          var node = nodes[i]; // add current node to the current options object and call degreeCentrality\n\n          options.root = node;\n          var currDegree = this.degreeCentrality(options);\n\n          if (maxDegree < currDegree.degree) {\n            maxDegree = currDegree.degree;\n          }\n\n          degrees[node.id()] = currDegree.degree;\n        }\n\n        return {\n          degree: function degree(node) {\n            if (maxDegree === 0) {\n              return 0;\n            }\n\n            if (string(node)) {\n              // from is a selector string\n              node = cy.filter(node);\n            }\n\n            return degrees[node.id()] / maxDegree;\n          }\n        };\n      } else {\n        var indegrees = {};\n        var outdegrees = {};\n        var maxIndegree = 0;\n        var maxOutdegree = 0;\n\n        for (var _i = 0; _i < numNodes; _i++) {\n          var _node = nodes[_i];\n\n          var id = _node.id(); // add current node to the current options object and call degreeCentrality\n\n\n          options.root = _node;\n\n          var _currDegree = this.degreeCentrality(options);\n\n          if (maxIndegree < _currDegree.indegree) maxIndegree = _currDegree.indegree;\n          if (maxOutdegree < _currDegree.outdegree) maxOutdegree = _currDegree.outdegree;\n          indegrees[id] = _currDegree.indegree;\n          outdegrees[id] = _currDegree.outdegree;\n        }\n\n        return {\n          indegree: function indegree(node) {\n            if (maxIndegree == 0) {\n              return 0;\n            }\n\n            if (string(node)) {\n              // from is a selector string\n              node = cy.filter(node);\n            }\n\n            return indegrees[node.id()] / maxIndegree;\n          },\n          outdegree: function outdegree(node) {\n            if (maxOutdegree === 0) {\n              return 0;\n            }\n\n            if (string(node)) {\n              // from is a selector string\n              node = cy.filter(node);\n            }\n\n            return outdegrees[node.id()] / maxOutdegree;\n          }\n        };\n      }\n    },\n    // degreeCentralityNormalized\n    // Implemented from the algorithm in Opsahl's paper\n    // \"Node centrality in weighted networks: Generalizing degree and shortest paths\"\n    // check the heading 2 \"Degree\"\n    degreeCentrality: function degreeCentrality(options) {\n      options = defaults$f(options);\n      var cy = this.cy();\n      var callingEles = this;\n      var _options = options,\n          root = _options.root,\n          weight = _options.weight,\n          directed = _options.directed,\n          alpha = _options.alpha;\n      root = cy.collection(root)[0];\n\n      if (!directed) {\n        var connEdges = root.connectedEdges().intersection(callingEles);\n        var k = connEdges.length;\n        var s = 0; // Now, sum edge weights\n\n        for (var i = 0; i < connEdges.length; i++) {\n          s += weight(connEdges[i]);\n        }\n\n        return {\n          degree: Math.pow(k, 1 - alpha) * Math.pow(s, alpha)\n        };\n      } else {\n        var edges = root.connectedEdges();\n        var incoming = edges.filter(function (edge) {\n          return edge.target().same(root) && callingEles.has(edge);\n        });\n        var outgoing = edges.filter(function (edge) {\n          return edge.source().same(root) && callingEles.has(edge);\n        });\n        var k_in = incoming.length;\n        var k_out = outgoing.length;\n        var s_in = 0;\n        var s_out = 0; // Now, sum incoming edge weights\n\n        for (var _i2 = 0; _i2 < incoming.length; _i2++) {\n          s_in += weight(incoming[_i2]);\n        } // Now, sum outgoing edge weights\n\n\n        for (var _i3 = 0; _i3 < outgoing.length; _i3++) {\n          s_out += weight(outgoing[_i3]);\n        }\n\n        return {\n          indegree: Math.pow(k_in, 1 - alpha) * Math.pow(s_in, alpha),\n          outdegree: Math.pow(k_out, 1 - alpha) * Math.pow(s_out, alpha)\n        };\n      }\n    } // degreeCentrality\n\n  }; // elesfn\n  // nice, short mathematical alias\n\n  elesfn$n.dc = elesfn$n.degreeCentrality;\n  elesfn$n.dcn = elesfn$n.degreeCentralityNormalised = elesfn$n.degreeCentralityNormalized;\n\n  var defaults$e = defaults$g({\n    harmonic: true,\n    weight: function weight() {\n      return 1;\n    },\n    directed: false,\n    root: null\n  });\n  var elesfn$m = {\n    closenessCentralityNormalized: function closenessCentralityNormalized(options) {\n      var _defaults = defaults$e(options),\n          harmonic = _defaults.harmonic,\n          weight = _defaults.weight,\n          directed = _defaults.directed;\n\n      var cy = this.cy();\n      var closenesses = {};\n      var maxCloseness = 0;\n      var nodes = this.nodes();\n      var fw = this.floydWarshall({\n        weight: weight,\n        directed: directed\n      }); // Compute closeness for every node and find the maximum closeness\n\n      for (var i = 0; i < nodes.length; i++) {\n        var currCloseness = 0;\n        var node_i = nodes[i];\n\n        for (var j = 0; j < nodes.length; j++) {\n          if (i !== j) {\n            var d = fw.distance(node_i, nodes[j]);\n\n            if (harmonic) {\n              currCloseness += 1 / d;\n            } else {\n              currCloseness += d;\n            }\n          }\n        }\n\n        if (!harmonic) {\n          currCloseness = 1 / currCloseness;\n        }\n\n        if (maxCloseness < currCloseness) {\n          maxCloseness = currCloseness;\n        }\n\n        closenesses[node_i.id()] = currCloseness;\n      }\n\n      return {\n        closeness: function closeness(node) {\n          if (maxCloseness == 0) {\n            return 0;\n          }\n\n          if (string(node)) {\n            // from is a selector string\n            node = cy.filter(node)[0].id();\n          } else {\n            // from is a node\n            node = node.id();\n          }\n\n          return closenesses[node] / maxCloseness;\n        }\n      };\n    },\n    // Implemented from pseudocode from wikipedia\n    closenessCentrality: function closenessCentrality(options) {\n      var _defaults2 = defaults$e(options),\n          root = _defaults2.root,\n          weight = _defaults2.weight,\n          directed = _defaults2.directed,\n          harmonic = _defaults2.harmonic;\n\n      root = this.filter(root)[0]; // we need distance from this node to every other node\n\n      var dijkstra = this.dijkstra({\n        root: root,\n        weight: weight,\n        directed: directed\n      });\n      var totalDistance = 0;\n      var nodes = this.nodes();\n\n      for (var i = 0; i < nodes.length; i++) {\n        var n = nodes[i];\n\n        if (!n.same(root)) {\n          var d = dijkstra.distanceTo(n);\n\n          if (harmonic) {\n            totalDistance += 1 / d;\n          } else {\n            totalDistance += d;\n          }\n        }\n      }\n\n      return harmonic ? totalDistance : 1 / totalDistance;\n    } // closenessCentrality\n\n  }; // elesfn\n  // nice, short mathematical alias\n\n  elesfn$m.cc = elesfn$m.closenessCentrality;\n  elesfn$m.ccn = elesfn$m.closenessCentralityNormalised = elesfn$m.closenessCentralityNormalized;\n\n  var defaults$d = defaults$g({\n    weight: null,\n    directed: false\n  });\n  var elesfn$l = {\n    // Implemented from the algorithm in the paper \"On Variants of Shortest-Path Betweenness Centrality and their Generic Computation\" by Ulrik Brandes\n    betweennessCentrality: function betweennessCentrality(options) {\n      var _defaults = defaults$d(options),\n          directed = _defaults.directed,\n          weight = _defaults.weight;\n\n      var weighted = weight != null;\n      var cy = this.cy(); // starting\n\n      var V = this.nodes();\n      var A = {};\n      var _C = {};\n      var max = 0;\n      var C = {\n        set: function set(key, val) {\n          _C[key] = val;\n\n          if (val > max) {\n            max = val;\n          }\n        },\n        get: function get(key) {\n          return _C[key];\n        }\n      }; // A contains the neighborhoods of every node\n\n      for (var i = 0; i < V.length; i++) {\n        var v = V[i];\n        var vid = v.id();\n\n        if (directed) {\n          A[vid] = v.outgoers().nodes(); // get outgoers of every node\n        } else {\n          A[vid] = v.openNeighborhood().nodes(); // get neighbors of every node\n        }\n\n        C.set(vid, 0);\n      }\n\n      var _loop = function _loop(s) {\n        var sid = V[s].id();\n        var S = []; // stack\n\n        var P = {};\n        var g = {};\n        var d = {};\n        var Q = new heap(function (a, b) {\n          return d[a] - d[b];\n        }); // queue\n        // init dictionaries\n\n        for (var _i = 0; _i < V.length; _i++) {\n          var _vid = V[_i].id();\n\n          P[_vid] = [];\n          g[_vid] = 0;\n          d[_vid] = Infinity;\n        }\n\n        g[sid] = 1; // sigma\n\n        d[sid] = 0; // distance to s\n\n        Q.push(sid);\n\n        while (!Q.empty()) {\n          var _v = Q.pop();\n\n          S.push(_v);\n\n          if (weighted) {\n            for (var j = 0; j < A[_v].length; j++) {\n              var w = A[_v][j];\n              var vEle = cy.getElementById(_v);\n              var edge = void 0;\n\n              if (vEle.edgesTo(w).length > 0) {\n                edge = vEle.edgesTo(w)[0];\n              } else {\n                edge = w.edgesTo(vEle)[0];\n              }\n\n              var edgeWeight = weight(edge);\n              w = w.id();\n\n              if (d[w] > d[_v] + edgeWeight) {\n                d[w] = d[_v] + edgeWeight;\n\n                if (Q.nodes.indexOf(w) < 0) {\n                  //if w is not in Q\n                  Q.push(w);\n                } else {\n                  // update position if w is in Q\n                  Q.updateItem(w);\n                }\n\n                g[w] = 0;\n                P[w] = [];\n              }\n\n              if (d[w] == d[_v] + edgeWeight) {\n                g[w] = g[w] + g[_v];\n                P[w].push(_v);\n              }\n            }\n          } else {\n            for (var _j = 0; _j < A[_v].length; _j++) {\n              var _w = A[_v][_j].id();\n\n              if (d[_w] == Infinity) {\n                Q.push(_w);\n                d[_w] = d[_v] + 1;\n              }\n\n              if (d[_w] == d[_v] + 1) {\n                g[_w] = g[_w] + g[_v];\n\n                P[_w].push(_v);\n              }\n            }\n          }\n        }\n\n        var e = {};\n\n        for (var _i2 = 0; _i2 < V.length; _i2++) {\n          e[V[_i2].id()] = 0;\n        }\n\n        while (S.length > 0) {\n          var _w2 = S.pop();\n\n          for (var _j2 = 0; _j2 < P[_w2].length; _j2++) {\n            var _v2 = P[_w2][_j2];\n            e[_v2] = e[_v2] + g[_v2] / g[_w2] * (1 + e[_w2]);\n          }\n\n          if (_w2 != V[s].id()) {\n            C.set(_w2, C.get(_w2) + e[_w2]);\n          }\n        }\n      };\n\n      for (var s = 0; s < V.length; s++) {\n        _loop(s);\n      }\n\n      var ret = {\n        betweenness: function betweenness(node) {\n          var id = cy.collection(node).id();\n          return C.get(id);\n        },\n        betweennessNormalized: function betweennessNormalized(node) {\n          if (max == 0) {\n            return 0;\n          }\n\n          var id = cy.collection(node).id();\n          return C.get(id) / max;\n        }\n      }; // alias\n\n      ret.betweennessNormalised = ret.betweennessNormalized;\n      return ret;\n    } // betweennessCentrality\n\n  }; // elesfn\n  // nice, short mathematical alias\n\n  elesfn$l.bc = elesfn$l.betweennessCentrality;\n\n  // Implemented by Zoe Xi @zoexi for GSOC 2016\n  /* eslint-disable no-unused-vars */\n\n  var defaults$c = defaults$g({\n    expandFactor: 2,\n    // affects time of computation and cluster granularity to some extent: M * M\n    inflateFactor: 2,\n    // affects cluster granularity (the greater the value, the more clusters): M(i,j) / E(j)\n    multFactor: 1,\n    // optional self loops for each node. Use a neutral value to improve cluster computations.\n    maxIterations: 20,\n    // maximum number of iterations of the MCL algorithm in a single run\n    attributes: [// attributes/features used to group nodes, ie. similarity values between nodes\n    function (edge) {\n      return 1;\n    }]\n  });\n  /* eslint-enable */\n\n  var setOptions$3 = function setOptions(options) {\n    return defaults$c(options);\n  };\n  /* eslint-enable */\n\n\n  var getSimilarity$1 = function getSimilarity(edge, attributes) {\n    var total = 0;\n\n    for (var i = 0; i < attributes.length; i++) {\n      total += attributes[i](edge);\n    }\n\n    return total;\n  };\n\n  var addLoops = function addLoops(M, n, val) {\n    for (var i = 0; i < n; i++) {\n      M[i * n + i] = val;\n    }\n  };\n\n  var normalize = function normalize(M, n) {\n    var sum;\n\n    for (var col = 0; col < n; col++) {\n      sum = 0;\n\n      for (var row = 0; row < n; row++) {\n        sum += M[row * n + col];\n      }\n\n      for (var _row = 0; _row < n; _row++) {\n        M[_row * n + col] = M[_row * n + col] / sum;\n      }\n    }\n  }; // TODO: blocked matrix multiplication?\n\n\n  var mmult = function mmult(A, B, n) {\n    var C = new Array(n * n);\n\n    for (var i = 0; i < n; i++) {\n      for (var j = 0; j < n; j++) {\n        C[i * n + j] = 0;\n      }\n\n      for (var k = 0; k < n; k++) {\n        for (var _j = 0; _j < n; _j++) {\n          C[i * n + _j] += A[i * n + k] * B[k * n + _j];\n        }\n      }\n    }\n\n    return C;\n  };\n\n  var expand = function expand(M, n, expandFactor\n  /** power **/\n  ) {\n    var _M = M.slice(0);\n\n    for (var p = 1; p < expandFactor; p++) {\n      M = mmult(M, _M, n);\n    }\n\n    return M;\n  };\n\n  var inflate = function inflate(M, n, inflateFactor\n  /** r **/\n  ) {\n    var _M = new Array(n * n); // M(i,j) ^ inflatePower\n\n\n    for (var i = 0; i < n * n; i++) {\n      _M[i] = Math.pow(M[i], inflateFactor);\n    }\n\n    normalize(_M, n);\n    return _M;\n  };\n\n  var hasConverged = function hasConverged(M, _M, n2, roundFactor) {\n    // Check that both matrices have the same elements (i,j)\n    for (var i = 0; i < n2; i++) {\n      var v1 = Math.round(M[i] * Math.pow(10, roundFactor)) / Math.pow(10, roundFactor); // truncate to 'roundFactor' decimal places\n\n      var v2 = Math.round(_M[i] * Math.pow(10, roundFactor)) / Math.pow(10, roundFactor);\n\n      if (v1 !== v2) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  var assign$2 = function assign(M, n, nodes, cy) {\n    var clusters = [];\n\n    for (var i = 0; i < n; i++) {\n      var cluster = [];\n\n      for (var j = 0; j < n; j++) {\n        // Row-wise attractors and elements that they attract belong in same cluster\n        if (Math.round(M[i * n + j] * 1000) / 1000 > 0) {\n          cluster.push(nodes[j]);\n        }\n      }\n\n      if (cluster.length !== 0) {\n        clusters.push(cy.collection(cluster));\n      }\n    }\n\n    return clusters;\n  };\n\n  var isDuplicate = function isDuplicate(c1, c2) {\n    for (var i = 0; i < c1.length; i++) {\n      if (!c2[i] || c1[i].id() !== c2[i].id()) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  var removeDuplicates = function removeDuplicates(clusters) {\n    for (var i = 0; i < clusters.length; i++) {\n      for (var j = 0; j < clusters.length; j++) {\n        if (i != j && isDuplicate(clusters[i], clusters[j])) {\n          clusters.splice(j, 1);\n        }\n      }\n    }\n\n    return clusters;\n  };\n\n  var markovClustering = function markovClustering(options) {\n    var nodes = this.nodes();\n    var edges = this.edges();\n    var cy = this.cy(); // Set parameters of algorithm:\n\n    var opts = setOptions$3(options); // Map each node to its position in node array\n\n    var id2position = {};\n\n    for (var i = 0; i < nodes.length; i++) {\n      id2position[nodes[i].id()] = i;\n    } // Generate stochastic matrix M from input graph G (should be symmetric/undirected)\n\n\n    var n = nodes.length,\n        n2 = n * n;\n\n    var M = new Array(n2),\n        _M;\n\n    for (var _i = 0; _i < n2; _i++) {\n      M[_i] = 0;\n    }\n\n    for (var e = 0; e < edges.length; e++) {\n      var edge = edges[e];\n      var _i2 = id2position[edge.source().id()];\n      var j = id2position[edge.target().id()];\n      var sim = getSimilarity$1(edge, opts.attributes);\n      M[_i2 * n + j] += sim; // G should be symmetric and undirected\n\n      M[j * n + _i2] += sim;\n    } // Begin Markov cluster algorithm\n    // Step 1: Add self loops to each node, ie. add multFactor to matrix diagonal\n\n\n    addLoops(M, n, opts.multFactor); // Step 2: M = normalize( M );\n\n    normalize(M, n);\n    var isStillMoving = true;\n    var iterations = 0;\n\n    while (isStillMoving && iterations < opts.maxIterations) {\n      isStillMoving = false; // Step 3:\n\n      _M = expand(M, n, opts.expandFactor); // Step 4:\n\n      M = inflate(_M, n, opts.inflateFactor); // Step 5: check to see if ~steady state has been reached\n\n      if (!hasConverged(M, _M, n2, 4)) {\n        isStillMoving = true;\n      }\n\n      iterations++;\n    } // Build clusters from matrix\n\n\n    var clusters = assign$2(M, n, nodes, cy); // Remove duplicate clusters due to symmetry of graph and M matrix\n\n    clusters = removeDuplicates(clusters);\n    return clusters;\n  };\n\n  var markovClustering$1 = {\n    markovClustering: markovClustering,\n    mcl: markovClustering\n  };\n\n  // Common distance metrics for clustering algorithms\n\n  var identity = function identity(x) {\n    return x;\n  };\n\n  var absDiff = function absDiff(p, q) {\n    return Math.abs(q - p);\n  };\n\n  var addAbsDiff = function addAbsDiff(total, p, q) {\n    return total + absDiff(p, q);\n  };\n\n  var addSquaredDiff = function addSquaredDiff(total, p, q) {\n    return total + Math.pow(q - p, 2);\n  };\n\n  var sqrt = function sqrt(x) {\n    return Math.sqrt(x);\n  };\n\n  var maxAbsDiff = function maxAbsDiff(currentMax, p, q) {\n    return Math.max(currentMax, absDiff(p, q));\n  };\n\n  var getDistance = function getDistance(length, getP, getQ, init, visit) {\n    var post = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : identity;\n    var ret = init;\n    var p, q;\n\n    for (var dim = 0; dim < length; dim++) {\n      p = getP(dim);\n      q = getQ(dim);\n      ret = visit(ret, p, q);\n    }\n\n    return post(ret);\n  };\n\n  var distances = {\n    euclidean: function euclidean(length, getP, getQ) {\n      if (length >= 2) {\n        return getDistance(length, getP, getQ, 0, addSquaredDiff, sqrt);\n      } else {\n        // for single attr case, more efficient to avoid sqrt\n        return getDistance(length, getP, getQ, 0, addAbsDiff);\n      }\n    },\n    squaredEuclidean: function squaredEuclidean(length, getP, getQ) {\n      return getDistance(length, getP, getQ, 0, addSquaredDiff);\n    },\n    manhattan: function manhattan(length, getP, getQ) {\n      return getDistance(length, getP, getQ, 0, addAbsDiff);\n    },\n    max: function max(length, getP, getQ) {\n      return getDistance(length, getP, getQ, -Infinity, maxAbsDiff);\n    }\n  }; // in case the user accidentally doesn't use camel case\n\n  distances['squared-euclidean'] = distances['squaredEuclidean'];\n  distances['squaredeuclidean'] = distances['squaredEuclidean'];\n  function clusteringDistance (method, length, getP, getQ, nodeP, nodeQ) {\n    var impl;\n\n    if (fn$6(method)) {\n      impl = method;\n    } else {\n      impl = distances[method] || distances.euclidean;\n    }\n\n    if (length === 0 && fn$6(method)) {\n      return impl(nodeP, nodeQ);\n    } else {\n      return impl(length, getP, getQ, nodeP, nodeQ);\n    }\n  }\n\n  var defaults$b = defaults$g({\n    k: 2,\n    m: 2,\n    sensitivityThreshold: 0.0001,\n    distance: 'euclidean',\n    maxIterations: 10,\n    attributes: [],\n    testMode: false,\n    testCentroids: null\n  });\n\n  var setOptions$2 = function setOptions(options) {\n    return defaults$b(options);\n  };\n  /* eslint-enable */\n\n\n  var getDist = function getDist(type, node, centroid, attributes, mode) {\n    var noNodeP = mode !== 'kMedoids';\n    var getP = noNodeP ? function (i) {\n      return centroid[i];\n    } : function (i) {\n      return attributes[i](centroid);\n    };\n\n    var getQ = function getQ(i) {\n      return attributes[i](node);\n    };\n\n    var nodeP = centroid;\n    var nodeQ = node;\n    return clusteringDistance(type, attributes.length, getP, getQ, nodeP, nodeQ);\n  };\n\n  var randomCentroids = function randomCentroids(nodes, k, attributes) {\n    var ndim = attributes.length;\n    var min = new Array(ndim);\n    var max = new Array(ndim);\n    var centroids = new Array(k);\n    var centroid = null; // Find min, max values for each attribute dimension\n\n    for (var i = 0; i < ndim; i++) {\n      min[i] = nodes.min(attributes[i]).value;\n      max[i] = nodes.max(attributes[i]).value;\n    } // Build k centroids, each represented as an n-dim feature vector\n\n\n    for (var c = 0; c < k; c++) {\n      centroid = [];\n\n      for (var _i = 0; _i < ndim; _i++) {\n        centroid[_i] = Math.random() * (max[_i] - min[_i]) + min[_i]; // random initial value\n      }\n\n      centroids[c] = centroid;\n    }\n\n    return centroids;\n  };\n\n  var classify = function classify(node, centroids, distance, attributes, type) {\n    var min = Infinity;\n    var index = 0;\n\n    for (var i = 0; i < centroids.length; i++) {\n      var dist = getDist(distance, node, centroids[i], attributes, type);\n\n      if (dist < min) {\n        min = dist;\n        index = i;\n      }\n    }\n\n    return index;\n  };\n\n  var buildCluster = function buildCluster(centroid, nodes, assignment) {\n    var cluster = [];\n    var node = null;\n\n    for (var n = 0; n < nodes.length; n++) {\n      node = nodes[n];\n\n      if (assignment[node.id()] === centroid) {\n        //console.log(\"Node \" + node.id() + \" is associated with medoid #: \" + m);\n        cluster.push(node);\n      }\n    }\n\n    return cluster;\n  };\n\n  var haveValuesConverged = function haveValuesConverged(v1, v2, sensitivityThreshold) {\n    return Math.abs(v2 - v1) <= sensitivityThreshold;\n  };\n\n  var haveMatricesConverged = function haveMatricesConverged(v1, v2, sensitivityThreshold) {\n    for (var i = 0; i < v1.length; i++) {\n      for (var j = 0; j < v1[i].length; j++) {\n        var diff = Math.abs(v1[i][j] - v2[i][j]);\n\n        if (diff > sensitivityThreshold) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  };\n\n  var seenBefore = function seenBefore(node, medoids, n) {\n    for (var i = 0; i < n; i++) {\n      if (node === medoids[i]) return true;\n    }\n\n    return false;\n  };\n\n  var randomMedoids = function randomMedoids(nodes, k) {\n    var medoids = new Array(k); // For small data sets, the probability of medoid conflict is greater,\n    // so we need to check to see if we've already seen or chose this node before.\n\n    if (nodes.length < 50) {\n      // Randomly select k medoids from the n nodes\n      for (var i = 0; i < k; i++) {\n        var node = nodes[Math.floor(Math.random() * nodes.length)]; // If we've already chosen this node to be a medoid, don't choose it again (for small data sets).\n        // Instead choose a different random node.\n\n        while (seenBefore(node, medoids, i)) {\n          node = nodes[Math.floor(Math.random() * nodes.length)];\n        }\n\n        medoids[i] = node;\n      }\n    } else {\n      // Relatively large data set, so pretty safe to not check and just select random nodes\n      for (var _i2 = 0; _i2 < k; _i2++) {\n        medoids[_i2] = nodes[Math.floor(Math.random() * nodes.length)];\n      }\n    }\n\n    return medoids;\n  };\n\n  var findCost = function findCost(potentialNewMedoid, cluster, attributes) {\n    var cost = 0;\n\n    for (var n = 0; n < cluster.length; n++) {\n      cost += getDist('manhattan', cluster[n], potentialNewMedoid, attributes, 'kMedoids');\n    }\n\n    return cost;\n  };\n\n  var kMeans = function kMeans(options) {\n    var cy = this.cy();\n    var nodes = this.nodes();\n    var node = null; // Set parameters of algorithm: # of clusters, distance metric, etc.\n\n    var opts = setOptions$2(options); // Begin k-means algorithm\n\n    var clusters = new Array(opts.k);\n    var assignment = {};\n    var centroids; // Step 1: Initialize centroid positions\n\n    if (opts.testMode) {\n      if (typeof opts.testCentroids === 'number') {\n        // TODO: implement a seeded random number generator.\n        opts.testCentroids;\n        centroids = randomCentroids(nodes, opts.k, opts.attributes);\n      } else if (_typeof(opts.testCentroids) === 'object') {\n        centroids = opts.testCentroids;\n      } else {\n        centroids = randomCentroids(nodes, opts.k, opts.attributes);\n      }\n    } else {\n      centroids = randomCentroids(nodes, opts.k, opts.attributes);\n    }\n\n    var isStillMoving = true;\n    var iterations = 0;\n\n    while (isStillMoving && iterations < opts.maxIterations) {\n      // Step 2: Assign nodes to the nearest centroid\n      for (var n = 0; n < nodes.length; n++) {\n        node = nodes[n]; // Determine which cluster this node belongs to: node id => cluster #\n\n        assignment[node.id()] = classify(node, centroids, opts.distance, opts.attributes, 'kMeans');\n      } // Step 3: For each of the k clusters, update its centroid\n\n\n      isStillMoving = false;\n\n      for (var c = 0; c < opts.k; c++) {\n        // Get all nodes that belong to this cluster\n        var cluster = buildCluster(c, nodes, assignment);\n\n        if (cluster.length === 0) {\n          // If cluster is empty, break out early & move to next cluster\n          continue;\n        } // Update centroids by calculating avg of all nodes within the cluster.\n\n\n        var ndim = opts.attributes.length;\n        var centroid = centroids[c]; // [ dim_1, dim_2, dim_3, ... , dim_n ]\n\n        var newCentroid = new Array(ndim);\n        var sum = new Array(ndim);\n\n        for (var d = 0; d < ndim; d++) {\n          sum[d] = 0.0;\n\n          for (var i = 0; i < cluster.length; i++) {\n            node = cluster[i];\n            sum[d] += opts.attributes[d](node);\n          }\n\n          newCentroid[d] = sum[d] / cluster.length; // Check to see if algorithm has converged, i.e. when centroids no longer change\n\n          if (!haveValuesConverged(newCentroid[d], centroid[d], opts.sensitivityThreshold)) {\n            isStillMoving = true;\n          }\n        }\n\n        centroids[c] = newCentroid;\n        clusters[c] = cy.collection(cluster);\n      }\n\n      iterations++;\n    }\n\n    return clusters;\n  };\n\n  var kMedoids = function kMedoids(options) {\n    var cy = this.cy();\n    var nodes = this.nodes();\n    var node = null;\n    var opts = setOptions$2(options); // Begin k-medoids algorithm\n\n    var clusters = new Array(opts.k);\n    var medoids;\n    var assignment = {};\n    var curCost;\n    var minCosts = new Array(opts.k); // minimum cost configuration for each cluster\n    // Step 1: Initialize k medoids\n\n    if (opts.testMode) {\n      if (typeof opts.testCentroids === 'number') ; else if (_typeof(opts.testCentroids) === 'object') {\n        medoids = opts.testCentroids;\n      } else {\n        medoids = randomMedoids(nodes, opts.k);\n      }\n    } else {\n      medoids = randomMedoids(nodes, opts.k);\n    }\n\n    var isStillMoving = true;\n    var iterations = 0;\n\n    while (isStillMoving && iterations < opts.maxIterations) {\n      // Step 2: Assign nodes to the nearest medoid\n      for (var n = 0; n < nodes.length; n++) {\n        node = nodes[n]; // Determine which cluster this node belongs to: node id => cluster #\n\n        assignment[node.id()] = classify(node, medoids, opts.distance, opts.attributes, 'kMedoids');\n      }\n\n      isStillMoving = false; // Step 3: For each medoid m, and for each node associated with mediod m,\n      // select the node with the lowest configuration cost as new medoid.\n\n      for (var m = 0; m < medoids.length; m++) {\n        // Get all nodes that belong to this medoid\n        var cluster = buildCluster(m, nodes, assignment);\n\n        if (cluster.length === 0) {\n          // If cluster is empty, break out early & move to next cluster\n          continue;\n        }\n\n        minCosts[m] = findCost(medoids[m], cluster, opts.attributes); // original cost\n        // Select different medoid if its configuration has the lowest cost\n\n        for (var _n = 0; _n < cluster.length; _n++) {\n          curCost = findCost(cluster[_n], cluster, opts.attributes);\n\n          if (curCost < minCosts[m]) {\n            minCosts[m] = curCost;\n            medoids[m] = cluster[_n];\n            isStillMoving = true;\n          }\n        }\n\n        clusters[m] = cy.collection(cluster);\n      }\n\n      iterations++;\n    }\n\n    return clusters;\n  };\n\n  var updateCentroids = function updateCentroids(centroids, nodes, U, weight, opts) {\n    var numerator, denominator;\n\n    for (var n = 0; n < nodes.length; n++) {\n      for (var c = 0; c < centroids.length; c++) {\n        weight[n][c] = Math.pow(U[n][c], opts.m);\n      }\n    }\n\n    for (var _c = 0; _c < centroids.length; _c++) {\n      for (var dim = 0; dim < opts.attributes.length; dim++) {\n        numerator = 0;\n        denominator = 0;\n\n        for (var _n2 = 0; _n2 < nodes.length; _n2++) {\n          numerator += weight[_n2][_c] * opts.attributes[dim](nodes[_n2]);\n          denominator += weight[_n2][_c];\n        }\n\n        centroids[_c][dim] = numerator / denominator;\n      }\n    }\n  };\n\n  var updateMembership = function updateMembership(U, _U, centroids, nodes, opts) {\n    // Save previous step\n    for (var i = 0; i < U.length; i++) {\n      _U[i] = U[i].slice();\n    }\n\n    var sum, numerator, denominator;\n    var pow = 2 / (opts.m - 1);\n\n    for (var c = 0; c < centroids.length; c++) {\n      for (var n = 0; n < nodes.length; n++) {\n        sum = 0;\n\n        for (var k = 0; k < centroids.length; k++) {\n          // against all other centroids\n          numerator = getDist(opts.distance, nodes[n], centroids[c], opts.attributes, 'cmeans');\n          denominator = getDist(opts.distance, nodes[n], centroids[k], opts.attributes, 'cmeans');\n          sum += Math.pow(numerator / denominator, pow);\n        }\n\n        U[n][c] = 1 / sum;\n      }\n    }\n  };\n\n  var assign$1 = function assign(nodes, U, opts, cy) {\n    var clusters = new Array(opts.k);\n\n    for (var c = 0; c < clusters.length; c++) {\n      clusters[c] = [];\n    }\n\n    var max;\n    var index;\n\n    for (var n = 0; n < U.length; n++) {\n      // for each node (U is N x C matrix)\n      max = -Infinity;\n      index = -1; // Determine which cluster the node is most likely to belong in\n\n      for (var _c2 = 0; _c2 < U[0].length; _c2++) {\n        if (U[n][_c2] > max) {\n          max = U[n][_c2];\n          index = _c2;\n        }\n      }\n\n      clusters[index].push(nodes[n]);\n    } // Turn every array into a collection of nodes\n\n\n    for (var _c3 = 0; _c3 < clusters.length; _c3++) {\n      clusters[_c3] = cy.collection(clusters[_c3]);\n    }\n\n    return clusters;\n  };\n\n  var fuzzyCMeans = function fuzzyCMeans(options) {\n    var cy = this.cy();\n    var nodes = this.nodes();\n    var opts = setOptions$2(options); // Begin fuzzy c-means algorithm\n\n    var clusters;\n    var centroids;\n    var U;\n\n    var _U;\n\n    var weight; // Step 1: Initialize letiables.\n\n    _U = new Array(nodes.length);\n\n    for (var i = 0; i < nodes.length; i++) {\n      // N x C matrix\n      _U[i] = new Array(opts.k);\n    }\n\n    U = new Array(nodes.length);\n\n    for (var _i3 = 0; _i3 < nodes.length; _i3++) {\n      // N x C matrix\n      U[_i3] = new Array(opts.k);\n    }\n\n    for (var _i4 = 0; _i4 < nodes.length; _i4++) {\n      var total = 0;\n\n      for (var j = 0; j < opts.k; j++) {\n        U[_i4][j] = Math.random();\n        total += U[_i4][j];\n      }\n\n      for (var _j = 0; _j < opts.k; _j++) {\n        U[_i4][_j] = U[_i4][_j] / total;\n      }\n    }\n\n    centroids = new Array(opts.k);\n\n    for (var _i5 = 0; _i5 < opts.k; _i5++) {\n      centroids[_i5] = new Array(opts.attributes.length);\n    }\n\n    weight = new Array(nodes.length);\n\n    for (var _i6 = 0; _i6 < nodes.length; _i6++) {\n      // N x C matrix\n      weight[_i6] = new Array(opts.k);\n    } // end init FCM\n\n\n    var isStillMoving = true;\n    var iterations = 0;\n\n    while (isStillMoving && iterations < opts.maxIterations) {\n      isStillMoving = false; // Step 2: Calculate the centroids for each step.\n\n      updateCentroids(centroids, nodes, U, weight, opts); // Step 3: Update the partition matrix U.\n\n      updateMembership(U, _U, centroids, nodes, opts); // Step 4: Check for convergence.\n\n      if (!haveMatricesConverged(U, _U, opts.sensitivityThreshold)) {\n        isStillMoving = true;\n      }\n\n      iterations++;\n    } // Assign nodes to clusters with highest probability.\n\n\n    clusters = assign$1(nodes, U, opts, cy);\n    return {\n      clusters: clusters,\n      degreeOfMembership: U\n    };\n  };\n\n  var kClustering = {\n    kMeans: kMeans,\n    kMedoids: kMedoids,\n    fuzzyCMeans: fuzzyCMeans,\n    fcm: fuzzyCMeans\n  };\n\n  // Implemented by Zoe Xi @zoexi for GSOC 2016\n  var defaults$a = defaults$g({\n    distance: 'euclidean',\n    // distance metric to compare nodes\n    linkage: 'min',\n    // linkage criterion : how to determine the distance between clusters of nodes\n    mode: 'threshold',\n    // mode:'threshold' => clusters must be threshold distance apart\n    threshold: Infinity,\n    // the distance threshold\n    // mode:'dendrogram' => the nodes are organised as leaves in a tree (siblings are close), merging makes clusters\n    addDendrogram: false,\n    // whether to add the dendrogram to the graph for viz\n    dendrogramDepth: 0,\n    // depth at which dendrogram branches are merged into the returned clusters\n    attributes: [] // array of attr functions\n\n  });\n  var linkageAliases = {\n    'single': 'min',\n    'complete': 'max'\n  };\n\n  var setOptions$1 = function setOptions(options) {\n    var opts = defaults$a(options);\n    var preferredAlias = linkageAliases[opts.linkage];\n\n    if (preferredAlias != null) {\n      opts.linkage = preferredAlias;\n    }\n\n    return opts;\n  };\n\n  var mergeClosest = function mergeClosest(clusters, index, dists, mins, opts) {\n    // Find two closest clusters from cached mins\n    var minKey = 0;\n    var min = Infinity;\n    var dist;\n    var attrs = opts.attributes;\n\n    var getDist = function getDist(n1, n2) {\n      return clusteringDistance(opts.distance, attrs.length, function (i) {\n        return attrs[i](n1);\n      }, function (i) {\n        return attrs[i](n2);\n      }, n1, n2);\n    };\n\n    for (var i = 0; i < clusters.length; i++) {\n      var key = clusters[i].key;\n      var _dist = dists[key][mins[key]];\n\n      if (_dist < min) {\n        minKey = key;\n        min = _dist;\n      }\n    }\n\n    if (opts.mode === 'threshold' && min >= opts.threshold || opts.mode === 'dendrogram' && clusters.length === 1) {\n      return false;\n    }\n\n    var c1 = index[minKey];\n    var c2 = index[mins[minKey]];\n    var merged; // Merge two closest clusters\n\n    if (opts.mode === 'dendrogram') {\n      merged = {\n        left: c1,\n        right: c2,\n        key: c1.key\n      };\n    } else {\n      merged = {\n        value: c1.value.concat(c2.value),\n        key: c1.key\n      };\n    }\n\n    clusters[c1.index] = merged;\n    clusters.splice(c2.index, 1);\n    index[c1.key] = merged; // Update distances with new merged cluster\n\n    for (var _i = 0; _i < clusters.length; _i++) {\n      var cur = clusters[_i];\n\n      if (c1.key === cur.key) {\n        dist = Infinity;\n      } else if (opts.linkage === 'min') {\n        dist = dists[c1.key][cur.key];\n\n        if (dists[c1.key][cur.key] > dists[c2.key][cur.key]) {\n          dist = dists[c2.key][cur.key];\n        }\n      } else if (opts.linkage === 'max') {\n        dist = dists[c1.key][cur.key];\n\n        if (dists[c1.key][cur.key] < dists[c2.key][cur.key]) {\n          dist = dists[c2.key][cur.key];\n        }\n      } else if (opts.linkage === 'mean') {\n        dist = (dists[c1.key][cur.key] * c1.size + dists[c2.key][cur.key] * c2.size) / (c1.size + c2.size);\n      } else {\n        if (opts.mode === 'dendrogram') dist = getDist(cur.value, c1.value);else dist = getDist(cur.value[0], c1.value[0]);\n      }\n\n      dists[c1.key][cur.key] = dists[cur.key][c1.key] = dist; // distance matrix is symmetric\n    } // Update cached mins\n\n\n    for (var _i2 = 0; _i2 < clusters.length; _i2++) {\n      var key1 = clusters[_i2].key;\n\n      if (mins[key1] === c1.key || mins[key1] === c2.key) {\n        var _min = key1;\n\n        for (var j = 0; j < clusters.length; j++) {\n          var key2 = clusters[j].key;\n\n          if (dists[key1][key2] < dists[key1][_min]) {\n            _min = key2;\n          }\n        }\n\n        mins[key1] = _min;\n      }\n\n      clusters[_i2].index = _i2;\n    } // Clean up meta data used for clustering\n\n\n    c1.key = c2.key = c1.index = c2.index = null;\n    return true;\n  };\n\n  var getAllChildren = function getAllChildren(root, arr, cy) {\n    if (!root) return;\n\n    if (root.value) {\n      arr.push(root.value);\n    } else {\n      if (root.left) getAllChildren(root.left, arr);\n      if (root.right) getAllChildren(root.right, arr);\n    }\n  };\n\n  var buildDendrogram = function buildDendrogram(root, cy) {\n    if (!root) return '';\n\n    if (root.left && root.right) {\n      var leftStr = buildDendrogram(root.left, cy);\n      var rightStr = buildDendrogram(root.right, cy);\n      var node = cy.add({\n        group: 'nodes',\n        data: {\n          id: leftStr + ',' + rightStr\n        }\n      });\n      cy.add({\n        group: 'edges',\n        data: {\n          source: leftStr,\n          target: node.id()\n        }\n      });\n      cy.add({\n        group: 'edges',\n        data: {\n          source: rightStr,\n          target: node.id()\n        }\n      });\n      return node.id();\n    } else if (root.value) {\n      return root.value.id();\n    }\n  };\n\n  var buildClustersFromTree = function buildClustersFromTree(root, k, cy) {\n    if (!root) return [];\n    var left = [],\n        right = [],\n        leaves = [];\n\n    if (k === 0) {\n      // don't cut tree, simply return all nodes as 1 single cluster\n      if (root.left) getAllChildren(root.left, left);\n      if (root.right) getAllChildren(root.right, right);\n      leaves = left.concat(right);\n      return [cy.collection(leaves)];\n    } else if (k === 1) {\n      // cut at root\n      if (root.value) {\n        // leaf node\n        return [cy.collection(root.value)];\n      } else {\n        if (root.left) getAllChildren(root.left, left);\n        if (root.right) getAllChildren(root.right, right);\n        return [cy.collection(left), cy.collection(right)];\n      }\n    } else {\n      if (root.value) {\n        return [cy.collection(root.value)];\n      } else {\n        if (root.left) left = buildClustersFromTree(root.left, k - 1, cy);\n        if (root.right) right = buildClustersFromTree(root.right, k - 1, cy);\n        return left.concat(right);\n      }\n    }\n  };\n  /* eslint-enable */\n\n\n  var hierarchicalClustering = function hierarchicalClustering(options) {\n    var cy = this.cy();\n    var nodes = this.nodes(); // Set parameters of algorithm: linkage type, distance metric, etc.\n\n    var opts = setOptions$1(options);\n    var attrs = opts.attributes;\n\n    var getDist = function getDist(n1, n2) {\n      return clusteringDistance(opts.distance, attrs.length, function (i) {\n        return attrs[i](n1);\n      }, function (i) {\n        return attrs[i](n2);\n      }, n1, n2);\n    }; // Begin hierarchical algorithm\n\n\n    var clusters = [];\n    var dists = []; // distances between each pair of clusters\n\n    var mins = []; // closest cluster for each cluster\n\n    var index = []; // hash of all clusters by key\n    // In agglomerative (bottom-up) clustering, each node starts as its own cluster\n\n    for (var n = 0; n < nodes.length; n++) {\n      var cluster = {\n        value: opts.mode === 'dendrogram' ? nodes[n] : [nodes[n]],\n        key: n,\n        index: n\n      };\n      clusters[n] = cluster;\n      index[n] = cluster;\n      dists[n] = [];\n      mins[n] = 0;\n    } // Calculate the distance between each pair of clusters\n\n\n    for (var i = 0; i < clusters.length; i++) {\n      for (var j = 0; j <= i; j++) {\n        var dist = void 0;\n\n        if (opts.mode === 'dendrogram') {\n          // modes store cluster values differently\n          dist = i === j ? Infinity : getDist(clusters[i].value, clusters[j].value);\n        } else {\n          dist = i === j ? Infinity : getDist(clusters[i].value[0], clusters[j].value[0]);\n        }\n\n        dists[i][j] = dist;\n        dists[j][i] = dist;\n\n        if (dist < dists[i][mins[i]]) {\n          mins[i] = j; // Cache mins: closest cluster to cluster i is cluster j\n        }\n      }\n    } // Find the closest pair of clusters and merge them into a single cluster.\n    // Update distances between new cluster and each of the old clusters, and loop until threshold reached.\n\n\n    var merged = mergeClosest(clusters, index, dists, mins, opts);\n\n    while (merged) {\n      merged = mergeClosest(clusters, index, dists, mins, opts);\n    }\n\n    var retClusters; // Dendrogram mode builds the hierarchy and adds intermediary nodes + edges\n    // in addition to returning the clusters.\n\n    if (opts.mode === 'dendrogram') {\n      retClusters = buildClustersFromTree(clusters[0], opts.dendrogramDepth, cy);\n      if (opts.addDendrogram) buildDendrogram(clusters[0], cy);\n    } else {\n      // Regular mode simply returns the clusters\n      retClusters = new Array(clusters.length);\n      clusters.forEach(function (cluster, i) {\n        // Clean up meta data used for clustering\n        cluster.key = cluster.index = null;\n        retClusters[i] = cy.collection(cluster.value);\n      });\n    }\n\n    return retClusters;\n  };\n\n  var hierarchicalClustering$1 = {\n    hierarchicalClustering: hierarchicalClustering,\n    hca: hierarchicalClustering\n  };\n\n  // Implemented by Zoe Xi @zoexi for GSOC 2016\n  var defaults$9 = defaults$g({\n    distance: 'euclidean',\n    // distance metric to compare attributes between two nodes\n    preference: 'median',\n    // suitability of a data point to serve as an exemplar\n    damping: 0.8,\n    // damping factor between [0.5, 1)\n    maxIterations: 1000,\n    // max number of iterations to run\n    minIterations: 100,\n    // min number of iterations to run in order for clustering to stop\n    attributes: [// functions to quantify the similarity between any two points\n      // e.g. node => node.data('weight')\n    ]\n  });\n\n  var setOptions = function setOptions(options) {\n    var dmp = options.damping;\n    var pref = options.preference;\n\n    if (!(0.5 <= dmp && dmp < 1)) {\n      error(\"Damping must range on [0.5, 1).  Got: \".concat(dmp));\n    }\n\n    var validPrefs = ['median', 'mean', 'min', 'max'];\n\n    if (!(validPrefs.some(function (v) {\n      return v === pref;\n    }) || number$1(pref))) {\n      error(\"Preference must be one of [\".concat(validPrefs.map(function (p) {\n        return \"'\".concat(p, \"'\");\n      }).join(', '), \"] or a number.  Got: \").concat(pref));\n    }\n\n    return defaults$9(options);\n  };\n  /* eslint-enable */\n\n\n  var getSimilarity = function getSimilarity(type, n1, n2, attributes) {\n    var attr = function attr(n, i) {\n      return attributes[i](n);\n    }; // nb negative because similarity should have an inverse relationship to distance\n\n\n    return -clusteringDistance(type, attributes.length, function (i) {\n      return attr(n1, i);\n    }, function (i) {\n      return attr(n2, i);\n    }, n1, n2);\n  };\n\n  var getPreference = function getPreference(S, preference) {\n    // larger preference = greater # of clusters\n    var p = null;\n\n    if (preference === 'median') {\n      p = median(S);\n    } else if (preference === 'mean') {\n      p = mean(S);\n    } else if (preference === 'min') {\n      p = min(S);\n    } else if (preference === 'max') {\n      p = max(S);\n    } else {\n      // Custom preference number, as set by user\n      p = preference;\n    }\n\n    return p;\n  };\n\n  var findExemplars = function findExemplars(n, R, A) {\n    var indices = [];\n\n    for (var i = 0; i < n; i++) {\n      if (R[i * n + i] + A[i * n + i] > 0) {\n        indices.push(i);\n      }\n    }\n\n    return indices;\n  };\n\n  var assignClusters = function assignClusters(n, S, exemplars) {\n    var clusters = [];\n\n    for (var i = 0; i < n; i++) {\n      var index = -1;\n      var max = -Infinity;\n\n      for (var ei = 0; ei < exemplars.length; ei++) {\n        var e = exemplars[ei];\n\n        if (S[i * n + e] > max) {\n          index = e;\n          max = S[i * n + e];\n        }\n      }\n\n      if (index > 0) {\n        clusters.push(index);\n      }\n    }\n\n    for (var _ei = 0; _ei < exemplars.length; _ei++) {\n      clusters[exemplars[_ei]] = exemplars[_ei];\n    }\n\n    return clusters;\n  };\n\n  var assign = function assign(n, S, exemplars) {\n    var clusters = assignClusters(n, S, exemplars);\n\n    for (var ei = 0; ei < exemplars.length; ei++) {\n      var ii = [];\n\n      for (var c = 0; c < clusters.length; c++) {\n        if (clusters[c] === exemplars[ei]) {\n          ii.push(c);\n        }\n      }\n\n      var maxI = -1;\n      var maxSum = -Infinity;\n\n      for (var i = 0; i < ii.length; i++) {\n        var sum = 0;\n\n        for (var j = 0; j < ii.length; j++) {\n          sum += S[ii[j] * n + ii[i]];\n        }\n\n        if (sum > maxSum) {\n          maxI = i;\n          maxSum = sum;\n        }\n      }\n\n      exemplars[ei] = ii[maxI];\n    }\n\n    clusters = assignClusters(n, S, exemplars);\n    return clusters;\n  };\n\n  var affinityPropagation = function affinityPropagation(options) {\n    var cy = this.cy();\n    var nodes = this.nodes();\n    var opts = setOptions(options); // Map each node to its position in node array\n\n    var id2position = {};\n\n    for (var i = 0; i < nodes.length; i++) {\n      id2position[nodes[i].id()] = i;\n    } // Begin affinity propagation algorithm\n\n\n    var n; // number of data points\n\n    var n2; // size of matrices\n\n    var S; // similarity matrix (1D array)\n\n    var p; // preference/suitability of a data point to serve as an exemplar\n\n    var R; // responsibility matrix (1D array)\n\n    var A; // availability matrix (1D array)\n\n    n = nodes.length;\n    n2 = n * n; // Initialize and build S similarity matrix\n\n    S = new Array(n2);\n\n    for (var _i = 0; _i < n2; _i++) {\n      S[_i] = -Infinity; // for cases where two data points shouldn't be linked together\n    }\n\n    for (var _i2 = 0; _i2 < n; _i2++) {\n      for (var j = 0; j < n; j++) {\n        if (_i2 !== j) {\n          S[_i2 * n + j] = getSimilarity(opts.distance, nodes[_i2], nodes[j], opts.attributes);\n        }\n      }\n    } // Place preferences on the diagonal of S\n\n\n    p = getPreference(S, opts.preference);\n\n    for (var _i3 = 0; _i3 < n; _i3++) {\n      S[_i3 * n + _i3] = p;\n    } // Initialize R responsibility matrix\n\n\n    R = new Array(n2);\n\n    for (var _i4 = 0; _i4 < n2; _i4++) {\n      R[_i4] = 0.0;\n    } // Initialize A availability matrix\n\n\n    A = new Array(n2);\n\n    for (var _i5 = 0; _i5 < n2; _i5++) {\n      A[_i5] = 0.0;\n    }\n\n    var old = new Array(n);\n    var Rp = new Array(n);\n    var se = new Array(n);\n\n    for (var _i6 = 0; _i6 < n; _i6++) {\n      old[_i6] = 0.0;\n      Rp[_i6] = 0.0;\n      se[_i6] = 0;\n    }\n\n    var e = new Array(n * opts.minIterations);\n\n    for (var _i7 = 0; _i7 < e.length; _i7++) {\n      e[_i7] = 0;\n    }\n\n    var iter;\n\n    for (iter = 0; iter < opts.maxIterations; iter++) {\n      // main algorithmic loop\n      // Update R responsibility matrix\n      for (var _i8 = 0; _i8 < n; _i8++) {\n        var max = -Infinity,\n            max2 = -Infinity,\n            maxI = -1,\n            AS = 0.0;\n\n        for (var _j = 0; _j < n; _j++) {\n          old[_j] = R[_i8 * n + _j];\n          AS = A[_i8 * n + _j] + S[_i8 * n + _j];\n\n          if (AS >= max) {\n            max2 = max;\n            max = AS;\n            maxI = _j;\n          } else if (AS > max2) {\n            max2 = AS;\n          }\n        }\n\n        for (var _j2 = 0; _j2 < n; _j2++) {\n          R[_i8 * n + _j2] = (1 - opts.damping) * (S[_i8 * n + _j2] - max) + opts.damping * old[_j2];\n        }\n\n        R[_i8 * n + maxI] = (1 - opts.damping) * (S[_i8 * n + maxI] - max2) + opts.damping * old[maxI];\n      } // Update A availability matrix\n\n\n      for (var _i9 = 0; _i9 < n; _i9++) {\n        var sum = 0;\n\n        for (var _j3 = 0; _j3 < n; _j3++) {\n          old[_j3] = A[_j3 * n + _i9];\n          Rp[_j3] = Math.max(0, R[_j3 * n + _i9]);\n          sum += Rp[_j3];\n        }\n\n        sum -= Rp[_i9];\n        Rp[_i9] = R[_i9 * n + _i9];\n        sum += Rp[_i9];\n\n        for (var _j4 = 0; _j4 < n; _j4++) {\n          A[_j4 * n + _i9] = (1 - opts.damping) * Math.min(0, sum - Rp[_j4]) + opts.damping * old[_j4];\n        }\n\n        A[_i9 * n + _i9] = (1 - opts.damping) * (sum - Rp[_i9]) + opts.damping * old[_i9];\n      } // Check for convergence\n\n\n      var K = 0;\n\n      for (var _i10 = 0; _i10 < n; _i10++) {\n        var E = A[_i10 * n + _i10] + R[_i10 * n + _i10] > 0 ? 1 : 0;\n        e[iter % opts.minIterations * n + _i10] = E;\n        K += E;\n      }\n\n      if (K > 0 && (iter >= opts.minIterations - 1 || iter == opts.maxIterations - 1)) {\n        var _sum = 0;\n\n        for (var _i11 = 0; _i11 < n; _i11++) {\n          se[_i11] = 0;\n\n          for (var _j5 = 0; _j5 < opts.minIterations; _j5++) {\n            se[_i11] += e[_j5 * n + _i11];\n          }\n\n          if (se[_i11] === 0 || se[_i11] === opts.minIterations) {\n            _sum++;\n          }\n        }\n\n        if (_sum === n) {\n          // then we have convergence\n          break;\n        }\n      }\n    } // Identify exemplars (cluster centers)\n\n\n    var exemplarsIndices = findExemplars(n, R, A); // Assign nodes to clusters\n\n    var clusterIndices = assign(n, S, exemplarsIndices);\n    var clusters = {};\n\n    for (var c = 0; c < exemplarsIndices.length; c++) {\n      clusters[exemplarsIndices[c]] = [];\n    }\n\n    for (var _i12 = 0; _i12 < nodes.length; _i12++) {\n      var pos = id2position[nodes[_i12].id()];\n\n      var clusterIndex = clusterIndices[pos];\n\n      if (clusterIndex != null) {\n        // the node may have not been assigned a cluster if no valid attributes were specified\n        clusters[clusterIndex].push(nodes[_i12]);\n      }\n    }\n\n    var retClusters = new Array(exemplarsIndices.length);\n\n    for (var _c = 0; _c < exemplarsIndices.length; _c++) {\n      retClusters[_c] = cy.collection(clusters[exemplarsIndices[_c]]);\n    }\n\n    return retClusters;\n  };\n\n  var affinityPropagation$1 = {\n    affinityPropagation: affinityPropagation,\n    ap: affinityPropagation\n  };\n\n  var hierholzerDefaults = defaults$g({\n    root: undefined,\n    directed: false\n  });\n  var elesfn$k = {\n    hierholzer: function hierholzer(options) {\n      if (!plainObject(options)) {\n        var args = arguments;\n        options = {\n          root: args[0],\n          directed: args[1]\n        };\n      }\n\n      var _hierholzerDefaults = hierholzerDefaults(options),\n          root = _hierholzerDefaults.root,\n          directed = _hierholzerDefaults.directed;\n\n      var eles = this;\n      var dflag = false;\n      var oddIn;\n      var oddOut;\n      var startVertex;\n      if (root) startVertex = string(root) ? this.filter(root)[0].id() : root[0].id();\n      var nodes = {};\n      var edges = {};\n\n      if (directed) {\n        eles.forEach(function (ele) {\n          var id = ele.id();\n\n          if (ele.isNode()) {\n            var ind = ele.indegree(true);\n            var outd = ele.outdegree(true);\n            var d1 = ind - outd;\n            var d2 = outd - ind;\n\n            if (d1 == 1) {\n              if (oddIn) dflag = true;else oddIn = id;\n            } else if (d2 == 1) {\n              if (oddOut) dflag = true;else oddOut = id;\n            } else if (d2 > 1 || d1 > 1) {\n              dflag = true;\n            }\n\n            nodes[id] = [];\n            ele.outgoers().forEach(function (e) {\n              if (e.isEdge()) nodes[id].push(e.id());\n            });\n          } else {\n            edges[id] = [undefined, ele.target().id()];\n          }\n        });\n      } else {\n        eles.forEach(function (ele) {\n          var id = ele.id();\n\n          if (ele.isNode()) {\n            var d = ele.degree(true);\n\n            if (d % 2) {\n              if (!oddIn) oddIn = id;else if (!oddOut) oddOut = id;else dflag = true;\n            }\n\n            nodes[id] = [];\n            ele.connectedEdges().forEach(function (e) {\n              return nodes[id].push(e.id());\n            });\n          } else {\n            edges[id] = [ele.source().id(), ele.target().id()];\n          }\n        });\n      }\n\n      var result = {\n        found: false,\n        trail: undefined\n      };\n      if (dflag) return result;else if (oddOut && oddIn) {\n        if (directed) {\n          if (startVertex && oddOut != startVertex) {\n            return result;\n          }\n\n          startVertex = oddOut;\n        } else {\n          if (startVertex && oddOut != startVertex && oddIn != startVertex) {\n            return result;\n          } else if (!startVertex) {\n            startVertex = oddOut;\n          }\n        }\n      } else {\n        if (!startVertex) startVertex = eles[0].id();\n      }\n\n      var walk = function walk(v) {\n        var currentNode = v;\n        var subtour = [v];\n        var adj, adjTail, adjHead;\n\n        while (nodes[currentNode].length) {\n          adj = nodes[currentNode].shift();\n          adjTail = edges[adj][0];\n          adjHead = edges[adj][1];\n\n          if (currentNode != adjHead) {\n            nodes[adjHead] = nodes[adjHead].filter(function (e) {\n              return e != adj;\n            });\n            currentNode = adjHead;\n          } else if (!directed && currentNode != adjTail) {\n            nodes[adjTail] = nodes[adjTail].filter(function (e) {\n              return e != adj;\n            });\n            currentNode = adjTail;\n          }\n\n          subtour.unshift(adj);\n          subtour.unshift(currentNode);\n        }\n\n        return subtour;\n      };\n\n      var trail = [];\n      var subtour = [];\n      subtour = walk(startVertex);\n\n      while (subtour.length != 1) {\n        if (nodes[subtour[0]].length == 0) {\n          trail.unshift(eles.getElementById(subtour.shift()));\n          trail.unshift(eles.getElementById(subtour.shift()));\n        } else {\n          subtour = walk(subtour.shift()).concat(subtour);\n        }\n      }\n\n      trail.unshift(eles.getElementById(subtour.shift())); // final node\n\n      for (var d in nodes) {\n        if (nodes[d].length) {\n          return result;\n        }\n      }\n\n      result.found = true;\n      result.trail = this.spawn(trail, true);\n      return result;\n    }\n  };\n\n  var hopcroftTarjanBiconnected = function hopcroftTarjanBiconnected() {\n    var eles = this;\n    var nodes = {};\n    var id = 0;\n    var edgeCount = 0;\n    var components = [];\n    var stack = [];\n    var visitedEdges = {};\n\n    var buildComponent = function buildComponent(x, y) {\n      var i = stack.length - 1;\n      var cutset = [];\n      var component = eles.spawn();\n\n      while (stack[i].x != x || stack[i].y != y) {\n        cutset.push(stack.pop().edge);\n        i--;\n      }\n\n      cutset.push(stack.pop().edge);\n      cutset.forEach(function (edge) {\n        var connectedNodes = edge.connectedNodes().intersection(eles);\n        component.merge(edge);\n        connectedNodes.forEach(function (node) {\n          var nodeId = node.id();\n          var connectedEdges = node.connectedEdges().intersection(eles);\n          component.merge(node);\n\n          if (!nodes[nodeId].cutVertex) {\n            component.merge(connectedEdges);\n          } else {\n            component.merge(connectedEdges.filter(function (edge) {\n              return edge.isLoop();\n            }));\n          }\n        });\n      });\n      components.push(component);\n    };\n\n    var biconnectedSearch = function biconnectedSearch(root, currentNode, parent) {\n      if (root === parent) edgeCount += 1;\n      nodes[currentNode] = {\n        id: id,\n        low: id++,\n        cutVertex: false\n      };\n      var edges = eles.getElementById(currentNode).connectedEdges().intersection(eles);\n\n      if (edges.size() === 0) {\n        components.push(eles.spawn(eles.getElementById(currentNode)));\n      } else {\n        var sourceId, targetId, otherNodeId, edgeId;\n        edges.forEach(function (edge) {\n          sourceId = edge.source().id();\n          targetId = edge.target().id();\n          otherNodeId = sourceId === currentNode ? targetId : sourceId;\n\n          if (otherNodeId !== parent) {\n            edgeId = edge.id();\n\n            if (!visitedEdges[edgeId]) {\n              visitedEdges[edgeId] = true;\n              stack.push({\n                x: currentNode,\n                y: otherNodeId,\n                edge: edge\n              });\n            }\n\n            if (!(otherNodeId in nodes)) {\n              biconnectedSearch(root, otherNodeId, currentNode);\n              nodes[currentNode].low = Math.min(nodes[currentNode].low, nodes[otherNodeId].low);\n\n              if (nodes[currentNode].id <= nodes[otherNodeId].low) {\n                nodes[currentNode].cutVertex = true;\n                buildComponent(currentNode, otherNodeId);\n              }\n            } else {\n              nodes[currentNode].low = Math.min(nodes[currentNode].low, nodes[otherNodeId].id);\n            }\n          }\n        });\n      }\n    };\n\n    eles.forEach(function (ele) {\n      if (ele.isNode()) {\n        var nodeId = ele.id();\n\n        if (!(nodeId in nodes)) {\n          edgeCount = 0;\n          biconnectedSearch(nodeId, nodeId);\n          nodes[nodeId].cutVertex = edgeCount > 1;\n        }\n      }\n    });\n    var cutVertices = Object.keys(nodes).filter(function (id) {\n      return nodes[id].cutVertex;\n    }).map(function (id) {\n      return eles.getElementById(id);\n    });\n    return {\n      cut: eles.spawn(cutVertices),\n      components: components\n    };\n  };\n\n  var hopcroftTarjanBiconnected$1 = {\n    hopcroftTarjanBiconnected: hopcroftTarjanBiconnected,\n    htbc: hopcroftTarjanBiconnected,\n    htb: hopcroftTarjanBiconnected,\n    hopcroftTarjanBiconnectedComponents: hopcroftTarjanBiconnected\n  };\n\n  var tarjanStronglyConnected = function tarjanStronglyConnected() {\n    var eles = this;\n    var nodes = {};\n    var index = 0;\n    var components = [];\n    var stack = [];\n    var cut = eles.spawn(eles);\n\n    var stronglyConnectedSearch = function stronglyConnectedSearch(sourceNodeId) {\n      stack.push(sourceNodeId);\n      nodes[sourceNodeId] = {\n        index: index,\n        low: index++,\n        explored: false\n      };\n      var connectedEdges = eles.getElementById(sourceNodeId).connectedEdges().intersection(eles);\n      connectedEdges.forEach(function (edge) {\n        var targetNodeId = edge.target().id();\n\n        if (targetNodeId !== sourceNodeId) {\n          if (!(targetNodeId in nodes)) {\n            stronglyConnectedSearch(targetNodeId);\n          }\n\n          if (!nodes[targetNodeId].explored) {\n            nodes[sourceNodeId].low = Math.min(nodes[sourceNodeId].low, nodes[targetNodeId].low);\n          }\n        }\n      });\n\n      if (nodes[sourceNodeId].index === nodes[sourceNodeId].low) {\n        var componentNodes = eles.spawn();\n\n        for (;;) {\n          var nodeId = stack.pop();\n          componentNodes.merge(eles.getElementById(nodeId));\n          nodes[nodeId].low = nodes[sourceNodeId].index;\n          nodes[nodeId].explored = true;\n\n          if (nodeId === sourceNodeId) {\n            break;\n          }\n        }\n\n        var componentEdges = componentNodes.edgesWith(componentNodes);\n        var component = componentNodes.merge(componentEdges);\n        components.push(component);\n        cut = cut.difference(component);\n      }\n    };\n\n    eles.forEach(function (ele) {\n      if (ele.isNode()) {\n        var nodeId = ele.id();\n\n        if (!(nodeId in nodes)) {\n          stronglyConnectedSearch(nodeId);\n        }\n      }\n    });\n    return {\n      cut: cut,\n      components: components\n    };\n  };\n\n  var tarjanStronglyConnected$1 = {\n    tarjanStronglyConnected: tarjanStronglyConnected,\n    tsc: tarjanStronglyConnected,\n    tscc: tarjanStronglyConnected,\n    tarjanStronglyConnectedComponents: tarjanStronglyConnected\n  };\n\n  var elesfn$j = {};\n  [elesfn$v, elesfn$u, elesfn$t, elesfn$s, elesfn$r, elesfn$q, elesfn$p, elesfn$o, elesfn$n, elesfn$m, elesfn$l, markovClustering$1, kClustering, hierarchicalClustering$1, affinityPropagation$1, elesfn$k, hopcroftTarjanBiconnected$1, tarjanStronglyConnected$1].forEach(function (props) {\n    extend(elesfn$j, props);\n  });\n\n  /*!\n  Embeddable Minimum Strictly-Compliant Promises/A+ 1.1.1 Thenable\n  Copyright (c) 2013-2014 Ralf S. Engelschall (http://engelschall.com)\n  Licensed under The MIT License (http://opensource.org/licenses/MIT)\n  */\n\n  /*  promise states [Promises/A+ 2.1]  */\n  var STATE_PENDING = 0;\n  /*  [Promises/A+ 2.1.1]  */\n\n  var STATE_FULFILLED = 1;\n  /*  [Promises/A+ 2.1.2]  */\n\n  var STATE_REJECTED = 2;\n  /*  [Promises/A+ 2.1.3]  */\n\n  /*  promise object constructor  */\n\n  var api = function api(executor) {\n    /*  optionally support non-constructor/plain-function call  */\n    if (!(this instanceof api)) return new api(executor);\n    /*  initialize object  */\n\n    this.id = 'Thenable/1.0.7';\n    this.state = STATE_PENDING;\n    /*  initial state  */\n\n    this.fulfillValue = undefined;\n    /*  initial value  */\n\n    /*  [Promises/A+ 1.3, 2.1.2.2]  */\n\n    this.rejectReason = undefined;\n    /*  initial reason */\n\n    /*  [Promises/A+ 1.5, 2.1.3.2]  */\n\n    this.onFulfilled = [];\n    /*  initial handlers  */\n\n    this.onRejected = [];\n    /*  initial handlers  */\n\n    /*  provide optional information-hiding proxy  */\n\n    this.proxy = {\n      then: this.then.bind(this)\n    };\n    /*  support optional executor function  */\n\n    if (typeof executor === 'function') executor.call(this, this.fulfill.bind(this), this.reject.bind(this));\n  };\n  /*  promise API methods  */\n\n\n  api.prototype = {\n    /*  promise resolving methods  */\n    fulfill: function fulfill(value) {\n      return deliver(this, STATE_FULFILLED, 'fulfillValue', value);\n    },\n    reject: function reject(value) {\n      return deliver(this, STATE_REJECTED, 'rejectReason', value);\n    },\n\n    /*  \"The then Method\" [Promises/A+ 1.1, 1.2, 2.2]  */\n    then: function then(onFulfilled, onRejected) {\n      var curr = this;\n      var next = new api();\n      /*  [Promises/A+ 2.2.7]  */\n\n      curr.onFulfilled.push(resolver(onFulfilled, next, 'fulfill'));\n      /*  [Promises/A+ 2.2.2/2.2.6]  */\n\n      curr.onRejected.push(resolver(onRejected, next, 'reject'));\n      /*  [Promises/A+ 2.2.3/2.2.6]  */\n\n      execute(curr);\n      return next.proxy;\n      /*  [Promises/A+ 2.2.7, 3.3]  */\n    }\n  };\n  /*  deliver an action  */\n\n  var deliver = function deliver(curr, state, name, value) {\n    if (curr.state === STATE_PENDING) {\n      curr.state = state;\n      /*  [Promises/A+ 2.1.2.1, 2.1.3.1]  */\n\n      curr[name] = value;\n      /*  [Promises/A+ 2.1.2.2, 2.1.3.2]  */\n\n      execute(curr);\n    }\n\n    return curr;\n  };\n  /*  execute all handlers  */\n\n\n  var execute = function execute(curr) {\n    if (curr.state === STATE_FULFILLED) execute_handlers(curr, 'onFulfilled', curr.fulfillValue);else if (curr.state === STATE_REJECTED) execute_handlers(curr, 'onRejected', curr.rejectReason);\n  };\n  /*  execute particular set of handlers  */\n\n\n  var execute_handlers = function execute_handlers(curr, name, value) {\n    /* global setImmediate: true */\n\n    /* global setTimeout: true */\n\n    /*  short-circuit processing  */\n    if (curr[name].length === 0) return;\n    /*  iterate over all handlers, exactly once  */\n\n    var handlers = curr[name];\n    curr[name] = [];\n    /*  [Promises/A+ 2.2.2.3, 2.2.3.3]  */\n\n    var func = function func() {\n      for (var i = 0; i < handlers.length; i++) {\n        handlers[i](value);\n      }\n      /*  [Promises/A+ 2.2.5]  */\n\n    };\n    /*  execute procedure asynchronously  */\n\n    /*  [Promises/A+ 2.2.4, 3.1]  */\n\n\n    if (typeof setImmediate === 'function') setImmediate(func);else setTimeout(func, 0);\n  };\n  /*  generate a resolver function  */\n\n\n  var resolver = function resolver(cb, next, method) {\n    return function (value) {\n      if (typeof cb !== 'function')\n        /*  [Promises/A+ 2.2.1, 2.2.7.3, 2.2.7.4]  */\n        next[method].call(next, value);\n        /*  [Promises/A+ 2.2.7.3, 2.2.7.4]  */\n      else {\n        var result;\n\n        try {\n          result = cb(value);\n        }\n        /*  [Promises/A+ 2.2.2.1, 2.2.3.1, 2.2.5, 3.2]  */\n        catch (e) {\n          next.reject(e);\n          /*  [Promises/A+ 2.2.7.2]  */\n\n          return;\n        }\n\n        resolve(next, result);\n        /*  [Promises/A+ 2.2.7.1]  */\n      }\n    };\n  };\n  /*  \"Promise Resolution Procedure\"  */\n\n  /*  [Promises/A+ 2.3]  */\n\n\n  var resolve = function resolve(promise, x) {\n    /*  sanity check arguments  */\n\n    /*  [Promises/A+ 2.3.1]  */\n    if (promise === x || promise.proxy === x) {\n      promise.reject(new TypeError('cannot resolve promise with itself'));\n      return;\n    }\n    /*  surgically check for a \"then\" method\n      (mainly to just call the \"getter\" of \"then\" only once)  */\n\n\n    var then;\n\n    if (_typeof(x) === 'object' && x !== null || typeof x === 'function') {\n      try {\n        then = x.then;\n      }\n      /*  [Promises/A+ 2.3.3.1, 3.5]  */\n      catch (e) {\n        promise.reject(e);\n        /*  [Promises/A+ 2.3.3.2]  */\n\n        return;\n      }\n    }\n    /*  handle own Thenables    [Promises/A+ 2.3.2]\n      and similar \"thenables\" [Promises/A+ 2.3.3]  */\n\n\n    if (typeof then === 'function') {\n      var resolved = false;\n\n      try {\n        /*  call retrieved \"then\" method */\n\n        /*  [Promises/A+ 2.3.3.3]  */\n        then.call(x,\n        /*  resolvePromise  */\n\n        /*  [Promises/A+ 2.3.3.3.1]  */\n        function (y) {\n          if (resolved) return;\n          resolved = true;\n          /*  [Promises/A+ 2.3.3.3.3]  */\n\n          if (y === x)\n            /*  [Promises/A+ 3.6]  */\n            promise.reject(new TypeError('circular thenable chain'));else resolve(promise, y);\n        },\n        /*  rejectPromise  */\n\n        /*  [Promises/A+ 2.3.3.3.2]  */\n        function (r) {\n          if (resolved) return;\n          resolved = true;\n          /*  [Promises/A+ 2.3.3.3.3]  */\n\n          promise.reject(r);\n        });\n      } catch (e) {\n        if (!resolved)\n          /*  [Promises/A+ 2.3.3.3.3]  */\n          promise.reject(e);\n        /*  [Promises/A+ 2.3.3.3.4]  */\n      }\n\n      return;\n    }\n    /*  handle other values  */\n\n\n    promise.fulfill(x);\n    /*  [Promises/A+ 2.3.4, 2.3.3.4]  */\n  }; // so we always have Promise.all()\n\n\n  api.all = function (ps) {\n    return new api(function (resolveAll, rejectAll) {\n      var vals = new Array(ps.length);\n      var doneCount = 0;\n\n      var fulfill = function fulfill(i, val) {\n        vals[i] = val;\n        doneCount++;\n\n        if (doneCount === ps.length) {\n          resolveAll(vals);\n        }\n      };\n\n      for (var i = 0; i < ps.length; i++) {\n        (function (i) {\n          var p = ps[i];\n          var isPromise = p != null && p.then != null;\n\n          if (isPromise) {\n            p.then(function (val) {\n              fulfill(i, val);\n            }, function (err) {\n              rejectAll(err);\n            });\n          } else {\n            var val = p;\n            fulfill(i, val);\n          }\n        })(i);\n      }\n    });\n  };\n\n  api.resolve = function (val) {\n    return new api(function (resolve, reject) {\n      resolve(val);\n    });\n  };\n\n  api.reject = function (val) {\n    return new api(function (resolve, reject) {\n      reject(val);\n    });\n  };\n\n  var Promise$1 = typeof Promise !== 'undefined' ? Promise : api; // eslint-disable-line no-undef\n\n  var Animation = function Animation(target, opts, opts2) {\n    var isCore = core(target);\n    var isEle = !isCore;\n\n    var _p = this._private = extend({\n      duration: 1000\n    }, opts, opts2);\n\n    _p.target = target;\n    _p.style = _p.style || _p.css;\n    _p.started = false;\n    _p.playing = false;\n    _p.hooked = false;\n    _p.applying = false;\n    _p.progress = 0;\n    _p.completes = [];\n    _p.frames = [];\n\n    if (_p.complete && fn$6(_p.complete)) {\n      _p.completes.push(_p.complete);\n    }\n\n    if (isEle) {\n      var pos = target.position();\n      _p.startPosition = _p.startPosition || {\n        x: pos.x,\n        y: pos.y\n      };\n      _p.startStyle = _p.startStyle || target.cy().style().getAnimationStartStyle(target, _p.style);\n    }\n\n    if (isCore) {\n      var pan = target.pan();\n      _p.startPan = {\n        x: pan.x,\n        y: pan.y\n      };\n      _p.startZoom = target.zoom();\n    } // for future timeline/animations impl\n\n\n    this.length = 1;\n    this[0] = this;\n  };\n\n  var anifn = Animation.prototype;\n  extend(anifn, {\n    instanceString: function instanceString() {\n      return 'animation';\n    },\n    hook: function hook() {\n      var _p = this._private;\n\n      if (!_p.hooked) {\n        // add to target's animation queue\n        var q;\n        var tAni = _p.target._private.animation;\n\n        if (_p.queue) {\n          q = tAni.queue;\n        } else {\n          q = tAni.current;\n        }\n\n        q.push(this); // add to the animation loop pool\n\n        if (elementOrCollection(_p.target)) {\n          _p.target.cy().addToAnimationPool(_p.target);\n        }\n\n        _p.hooked = true;\n      }\n\n      return this;\n    },\n    play: function play() {\n      var _p = this._private; // autorewind\n\n      if (_p.progress === 1) {\n        _p.progress = 0;\n      }\n\n      _p.playing = true;\n      _p.started = false; // needs to be started by animation loop\n\n      _p.stopped = false;\n      this.hook(); // the animation loop will start the animation...\n\n      return this;\n    },\n    playing: function playing() {\n      return this._private.playing;\n    },\n    apply: function apply() {\n      var _p = this._private;\n      _p.applying = true;\n      _p.started = false; // needs to be started by animation loop\n\n      _p.stopped = false;\n      this.hook(); // the animation loop will apply the animation at this progress\n\n      return this;\n    },\n    applying: function applying() {\n      return this._private.applying;\n    },\n    pause: function pause() {\n      var _p = this._private;\n      _p.playing = false;\n      _p.started = false;\n      return this;\n    },\n    stop: function stop() {\n      var _p = this._private;\n      _p.playing = false;\n      _p.started = false;\n      _p.stopped = true; // to be removed from animation queues\n\n      return this;\n    },\n    rewind: function rewind() {\n      return this.progress(0);\n    },\n    fastforward: function fastforward() {\n      return this.progress(1);\n    },\n    time: function time(t) {\n      var _p = this._private;\n\n      if (t === undefined) {\n        return _p.progress * _p.duration;\n      } else {\n        return this.progress(t / _p.duration);\n      }\n    },\n    progress: function progress(p) {\n      var _p = this._private;\n      var wasPlaying = _p.playing;\n\n      if (p === undefined) {\n        return _p.progress;\n      } else {\n        if (wasPlaying) {\n          this.pause();\n        }\n\n        _p.progress = p;\n        _p.started = false;\n\n        if (wasPlaying) {\n          this.play();\n        }\n      }\n\n      return this;\n    },\n    completed: function completed() {\n      return this._private.progress === 1;\n    },\n    reverse: function reverse() {\n      var _p = this._private;\n      var wasPlaying = _p.playing;\n\n      if (wasPlaying) {\n        this.pause();\n      }\n\n      _p.progress = 1 - _p.progress;\n      _p.started = false;\n\n      var swap = function swap(a, b) {\n        var _pa = _p[a];\n\n        if (_pa == null) {\n          return;\n        }\n\n        _p[a] = _p[b];\n        _p[b] = _pa;\n      };\n\n      swap('zoom', 'startZoom');\n      swap('pan', 'startPan');\n      swap('position', 'startPosition'); // swap styles\n\n      if (_p.style) {\n        for (var i = 0; i < _p.style.length; i++) {\n          var prop = _p.style[i];\n          var name = prop.name;\n          var startStyleProp = _p.startStyle[name];\n          _p.startStyle[name] = prop;\n          _p.style[i] = startStyleProp;\n        }\n      }\n\n      if (wasPlaying) {\n        this.play();\n      }\n\n      return this;\n    },\n    promise: function promise(type) {\n      var _p = this._private;\n      var arr;\n\n      switch (type) {\n        case 'frame':\n          arr = _p.frames;\n          break;\n\n        default:\n        case 'complete':\n        case 'completed':\n          arr = _p.completes;\n      }\n\n      return new Promise$1(function (resolve, reject) {\n        arr.push(function () {\n          resolve();\n        });\n      });\n    }\n  });\n  anifn.complete = anifn.completed;\n  anifn.run = anifn.play;\n  anifn.running = anifn.playing;\n\n  var define$3 = {\n    animated: function animated() {\n      return function animatedImpl() {\n        var self = this;\n        var selfIsArrayLike = self.length !== undefined;\n        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n\n        var cy = this._private.cy || this;\n\n        if (!cy.styleEnabled()) {\n          return false;\n        }\n\n        var ele = all[0];\n\n        if (ele) {\n          return ele._private.animation.current.length > 0;\n        }\n      };\n    },\n    // animated\n    clearQueue: function clearQueue() {\n      return function clearQueueImpl() {\n        var self = this;\n        var selfIsArrayLike = self.length !== undefined;\n        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n\n        var cy = this._private.cy || this;\n\n        if (!cy.styleEnabled()) {\n          return this;\n        }\n\n        for (var i = 0; i < all.length; i++) {\n          var ele = all[i];\n          ele._private.animation.queue = [];\n        }\n\n        return this;\n      };\n    },\n    // clearQueue\n    delay: function delay() {\n      return function delayImpl(time, complete) {\n        var cy = this._private.cy || this;\n\n        if (!cy.styleEnabled()) {\n          return this;\n        }\n\n        return this.animate({\n          delay: time,\n          duration: time,\n          complete: complete\n        });\n      };\n    },\n    // delay\n    delayAnimation: function delayAnimation() {\n      return function delayAnimationImpl(time, complete) {\n        var cy = this._private.cy || this;\n\n        if (!cy.styleEnabled()) {\n          return this;\n        }\n\n        return this.animation({\n          delay: time,\n          duration: time,\n          complete: complete\n        });\n      };\n    },\n    // delay\n    animation: function animation() {\n      return function animationImpl(properties, params) {\n        var self = this;\n        var selfIsArrayLike = self.length !== undefined;\n        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n\n        var cy = this._private.cy || this;\n        var isCore = !selfIsArrayLike;\n        var isEles = !isCore;\n\n        if (!cy.styleEnabled()) {\n          return this;\n        }\n\n        var style = cy.style();\n        properties = extend({}, properties, params);\n        var propertiesEmpty = Object.keys(properties).length === 0;\n\n        if (propertiesEmpty) {\n          return new Animation(all[0], properties); // nothing to animate\n        }\n\n        if (properties.duration === undefined) {\n          properties.duration = 400;\n        }\n\n        switch (properties.duration) {\n          case 'slow':\n            properties.duration = 600;\n            break;\n\n          case 'fast':\n            properties.duration = 200;\n            break;\n        }\n\n        if (isEles) {\n          properties.style = style.getPropsList(properties.style || properties.css);\n          properties.css = undefined;\n        }\n\n        if (isEles && properties.renderedPosition != null) {\n          var rpos = properties.renderedPosition;\n          var pan = cy.pan();\n          var zoom = cy.zoom();\n          properties.position = renderedToModelPosition(rpos, zoom, pan);\n        } // override pan w/ panBy if set\n\n\n        if (isCore && properties.panBy != null) {\n          var panBy = properties.panBy;\n          var cyPan = cy.pan();\n          properties.pan = {\n            x: cyPan.x + panBy.x,\n            y: cyPan.y + panBy.y\n          };\n        } // override pan w/ center if set\n\n\n        var center = properties.center || properties.centre;\n\n        if (isCore && center != null) {\n          var centerPan = cy.getCenterPan(center.eles, properties.zoom);\n\n          if (centerPan != null) {\n            properties.pan = centerPan;\n          }\n        } // override pan & zoom w/ fit if set\n\n\n        if (isCore && properties.fit != null) {\n          var fit = properties.fit;\n          var fitVp = cy.getFitViewport(fit.eles || fit.boundingBox, fit.padding);\n\n          if (fitVp != null) {\n            properties.pan = fitVp.pan;\n            properties.zoom = fitVp.zoom;\n          }\n        } // override zoom (& potentially pan) w/ zoom obj if set\n\n\n        if (isCore && plainObject(properties.zoom)) {\n          var vp = cy.getZoomedViewport(properties.zoom);\n\n          if (vp != null) {\n            if (vp.zoomed) {\n              properties.zoom = vp.zoom;\n            }\n\n            if (vp.panned) {\n              properties.pan = vp.pan;\n            }\n          } else {\n            properties.zoom = null; // an inavalid zoom (e.g. no delta) gets automatically destroyed\n          }\n        }\n\n        return new Animation(all[0], properties);\n      };\n    },\n    // animate\n    animate: function animate() {\n      return function animateImpl(properties, params) {\n        var self = this;\n        var selfIsArrayLike = self.length !== undefined;\n        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n\n        var cy = this._private.cy || this;\n\n        if (!cy.styleEnabled()) {\n          return this;\n        }\n\n        if (params) {\n          properties = extend({}, properties, params);\n        } // manually hook and run the animation\n\n\n        for (var i = 0; i < all.length; i++) {\n          var ele = all[i];\n          var queue = ele.animated() && (properties.queue === undefined || properties.queue);\n          var ani = ele.animation(properties, queue ? {\n            queue: true\n          } : undefined);\n          ani.play();\n        }\n\n        return this; // chaining\n      };\n    },\n    // animate\n    stop: function stop() {\n      return function stopImpl(clearQueue, jumpToEnd) {\n        var self = this;\n        var selfIsArrayLike = self.length !== undefined;\n        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n\n        var cy = this._private.cy || this;\n\n        if (!cy.styleEnabled()) {\n          return this;\n        }\n\n        for (var i = 0; i < all.length; i++) {\n          var ele = all[i];\n          var _p = ele._private;\n          var anis = _p.animation.current;\n\n          for (var j = 0; j < anis.length; j++) {\n            var ani = anis[j];\n            var ani_p = ani._private;\n\n            if (jumpToEnd) {\n              // next iteration of the animation loop, the animation\n              // will go straight to the end and be removed\n              ani_p.duration = 0;\n            }\n          } // clear the queue of future animations\n\n\n          if (clearQueue) {\n            _p.animation.queue = [];\n          }\n\n          if (!jumpToEnd) {\n            _p.animation.current = [];\n          }\n        } // we have to notify (the animation loop doesn't do it for us on `stop`)\n\n\n        cy.notify('draw');\n        return this;\n      };\n    } // stop\n\n  }; // define\n\n  /**\n   * Checks if `value` is classified as an `Array` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n   * @example\n   *\n   * _.isArray([1, 2, 3]);\n   * // => true\n   *\n   * _.isArray(document.body.children);\n   * // => false\n   *\n   * _.isArray('abc');\n   * // => false\n   *\n   * _.isArray(_.noop);\n   * // => false\n   */\n  var isArray = Array.isArray;\n\n  var isArray_1 = isArray;\n\n  /** Used to match property names within property paths. */\n  var reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n      reIsPlainProp = /^\\w*$/;\n\n  /**\n   * Checks if `value` is a property name and not a property path.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @param {Object} [object] The object to query keys on.\n   * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n   */\n  function isKey(value, object) {\n    if (isArray_1(value)) {\n      return false;\n    }\n    var type = typeof value;\n    if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n        value == null || isSymbol_1(value)) {\n      return true;\n    }\n    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n      (object != null && value in Object(object));\n  }\n\n  var _isKey = isKey;\n\n  /** `Object#toString` result references. */\n  var asyncTag = '[object AsyncFunction]',\n      funcTag = '[object Function]',\n      genTag = '[object GeneratorFunction]',\n      proxyTag = '[object Proxy]';\n\n  /**\n   * Checks if `value` is classified as a `Function` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n   * @example\n   *\n   * _.isFunction(_);\n   * // => true\n   *\n   * _.isFunction(/abc/);\n   * // => false\n   */\n  function isFunction(value) {\n    if (!isObject_1(value)) {\n      return false;\n    }\n    // The use of `Object#toString` avoids issues with the `typeof` operator\n    // in Safari 9 which returns 'object' for typed arrays and other constructors.\n    var tag = _baseGetTag(value);\n    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n  }\n\n  var isFunction_1 = isFunction;\n\n  /** Used to detect overreaching core-js shims. */\n  var coreJsData = _root['__core-js_shared__'];\n\n  var _coreJsData = coreJsData;\n\n  /** Used to detect methods masquerading as native. */\n  var maskSrcKey = (function() {\n    var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || '');\n    return uid ? ('Symbol(src)_1.' + uid) : '';\n  }());\n\n  /**\n   * Checks if `func` has its source masked.\n   *\n   * @private\n   * @param {Function} func The function to check.\n   * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n   */\n  function isMasked(func) {\n    return !!maskSrcKey && (maskSrcKey in func);\n  }\n\n  var _isMasked = isMasked;\n\n  /** Used for built-in method references. */\n  var funcProto$1 = Function.prototype;\n\n  /** Used to resolve the decompiled source of functions. */\n  var funcToString$1 = funcProto$1.toString;\n\n  /**\n   * Converts `func` to its source code.\n   *\n   * @private\n   * @param {Function} func The function to convert.\n   * @returns {string} Returns the source code.\n   */\n  function toSource(func) {\n    if (func != null) {\n      try {\n        return funcToString$1.call(func);\n      } catch (e) {}\n      try {\n        return (func + '');\n      } catch (e) {}\n    }\n    return '';\n  }\n\n  var _toSource = toSource;\n\n  /**\n   * Used to match `RegExp`\n   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n   */\n  var reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n  /** Used to detect host constructors (Safari). */\n  var reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n  /** Used for built-in method references. */\n  var funcProto = Function.prototype,\n      objectProto$3 = Object.prototype;\n\n  /** Used to resolve the decompiled source of functions. */\n  var funcToString = funcProto.toString;\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty$3 = objectProto$3.hasOwnProperty;\n\n  /** Used to detect if a method is native. */\n  var reIsNative = RegExp('^' +\n    funcToString.call(hasOwnProperty$3).replace(reRegExpChar, '\\\\$&')\n    .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n  );\n\n  /**\n   * The base implementation of `_.isNative` without bad shim checks.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a native function,\n   *  else `false`.\n   */\n  function baseIsNative(value) {\n    if (!isObject_1(value) || _isMasked(value)) {\n      return false;\n    }\n    var pattern = isFunction_1(value) ? reIsNative : reIsHostCtor;\n    return pattern.test(_toSource(value));\n  }\n\n  var _baseIsNative = baseIsNative;\n\n  /**\n   * Gets the value at `key` of `object`.\n   *\n   * @private\n   * @param {Object} [object] The object to query.\n   * @param {string} key The key of the property to get.\n   * @returns {*} Returns the property value.\n   */\n  function getValue$1(object, key) {\n    return object == null ? undefined : object[key];\n  }\n\n  var _getValue = getValue$1;\n\n  /**\n   * Gets the native function at `key` of `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {string} key The key of the method to get.\n   * @returns {*} Returns the function if it's native, else `undefined`.\n   */\n  function getNative(object, key) {\n    var value = _getValue(object, key);\n    return _baseIsNative(value) ? value : undefined;\n  }\n\n  var _getNative = getNative;\n\n  /* Built-in method references that are verified to be native. */\n  var nativeCreate = _getNative(Object, 'create');\n\n  var _nativeCreate = nativeCreate;\n\n  /**\n   * Removes all key-value entries from the hash.\n   *\n   * @private\n   * @name clear\n   * @memberOf Hash\n   */\n  function hashClear() {\n    this.__data__ = _nativeCreate ? _nativeCreate(null) : {};\n    this.size = 0;\n  }\n\n  var _hashClear = hashClear;\n\n  /**\n   * Removes `key` and its value from the hash.\n   *\n   * @private\n   * @name delete\n   * @memberOf Hash\n   * @param {Object} hash The hash to modify.\n   * @param {string} key The key of the value to remove.\n   * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n   */\n  function hashDelete(key) {\n    var result = this.has(key) && delete this.__data__[key];\n    this.size -= result ? 1 : 0;\n    return result;\n  }\n\n  var _hashDelete = hashDelete;\n\n  /** Used to stand-in for `undefined` hash values. */\n  var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';\n\n  /** Used for built-in method references. */\n  var objectProto$2 = Object.prototype;\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty$2 = objectProto$2.hasOwnProperty;\n\n  /**\n   * Gets the hash value for `key`.\n   *\n   * @private\n   * @name get\n   * @memberOf Hash\n   * @param {string} key The key of the value to get.\n   * @returns {*} Returns the entry value.\n   */\n  function hashGet(key) {\n    var data = this.__data__;\n    if (_nativeCreate) {\n      var result = data[key];\n      return result === HASH_UNDEFINED$1 ? undefined : result;\n    }\n    return hasOwnProperty$2.call(data, key) ? data[key] : undefined;\n  }\n\n  var _hashGet = hashGet;\n\n  /** Used for built-in method references. */\n  var objectProto$1 = Object.prototype;\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty$1 = objectProto$1.hasOwnProperty;\n\n  /**\n   * Checks if a hash value for `key` exists.\n   *\n   * @private\n   * @name has\n   * @memberOf Hash\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n  function hashHas(key) {\n    var data = this.__data__;\n    return _nativeCreate ? (data[key] !== undefined) : hasOwnProperty$1.call(data, key);\n  }\n\n  var _hashHas = hashHas;\n\n  /** Used to stand-in for `undefined` hash values. */\n  var HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n  /**\n   * Sets the hash `key` to `value`.\n   *\n   * @private\n   * @name set\n   * @memberOf Hash\n   * @param {string} key The key of the value to set.\n   * @param {*} value The value to set.\n   * @returns {Object} Returns the hash instance.\n   */\n  function hashSet(key, value) {\n    var data = this.__data__;\n    this.size += this.has(key) ? 0 : 1;\n    data[key] = (_nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n    return this;\n  }\n\n  var _hashSet = hashSet;\n\n  /**\n   * Creates a hash object.\n   *\n   * @private\n   * @constructor\n   * @param {Array} [entries] The key-value pairs to cache.\n   */\n  function Hash(entries) {\n    var index = -1,\n        length = entries == null ? 0 : entries.length;\n\n    this.clear();\n    while (++index < length) {\n      var entry = entries[index];\n      this.set(entry[0], entry[1]);\n    }\n  }\n\n  // Add methods to `Hash`.\n  Hash.prototype.clear = _hashClear;\n  Hash.prototype['delete'] = _hashDelete;\n  Hash.prototype.get = _hashGet;\n  Hash.prototype.has = _hashHas;\n  Hash.prototype.set = _hashSet;\n\n  var _Hash = Hash;\n\n  /**\n   * Removes all key-value entries from the list cache.\n   *\n   * @private\n   * @name clear\n   * @memberOf ListCache\n   */\n  function listCacheClear() {\n    this.__data__ = [];\n    this.size = 0;\n  }\n\n  var _listCacheClear = listCacheClear;\n\n  /**\n   * Performs a\n   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n   * comparison between two values to determine if they are equivalent.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to compare.\n   * @param {*} other The other value to compare.\n   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n   * @example\n   *\n   * var object = { 'a': 1 };\n   * var other = { 'a': 1 };\n   *\n   * _.eq(object, object);\n   * // => true\n   *\n   * _.eq(object, other);\n   * // => false\n   *\n   * _.eq('a', 'a');\n   * // => true\n   *\n   * _.eq('a', Object('a'));\n   * // => false\n   *\n   * _.eq(NaN, NaN);\n   * // => true\n   */\n  function eq(value, other) {\n    return value === other || (value !== value && other !== other);\n  }\n\n  var eq_1 = eq;\n\n  /**\n   * Gets the index at which the `key` is found in `array` of key-value pairs.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} key The key to search for.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function assocIndexOf(array, key) {\n    var length = array.length;\n    while (length--) {\n      if (eq_1(array[length][0], key)) {\n        return length;\n      }\n    }\n    return -1;\n  }\n\n  var _assocIndexOf = assocIndexOf;\n\n  /** Used for built-in method references. */\n  var arrayProto = Array.prototype;\n\n  /** Built-in value references. */\n  var splice = arrayProto.splice;\n\n  /**\n   * Removes `key` and its value from the list cache.\n   *\n   * @private\n   * @name delete\n   * @memberOf ListCache\n   * @param {string} key The key of the value to remove.\n   * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n   */\n  function listCacheDelete(key) {\n    var data = this.__data__,\n        index = _assocIndexOf(data, key);\n\n    if (index < 0) {\n      return false;\n    }\n    var lastIndex = data.length - 1;\n    if (index == lastIndex) {\n      data.pop();\n    } else {\n      splice.call(data, index, 1);\n    }\n    --this.size;\n    return true;\n  }\n\n  var _listCacheDelete = listCacheDelete;\n\n  /**\n   * Gets the list cache value for `key`.\n   *\n   * @private\n   * @name get\n   * @memberOf ListCache\n   * @param {string} key The key of the value to get.\n   * @returns {*} Returns the entry value.\n   */\n  function listCacheGet(key) {\n    var data = this.__data__,\n        index = _assocIndexOf(data, key);\n\n    return index < 0 ? undefined : data[index][1];\n  }\n\n  var _listCacheGet = listCacheGet;\n\n  /**\n   * Checks if a list cache value for `key` exists.\n   *\n   * @private\n   * @name has\n   * @memberOf ListCache\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n  function listCacheHas(key) {\n    return _assocIndexOf(this.__data__, key) > -1;\n  }\n\n  var _listCacheHas = listCacheHas;\n\n  /**\n   * Sets the list cache `key` to `value`.\n   *\n   * @private\n   * @name set\n   * @memberOf ListCache\n   * @param {string} key The key of the value to set.\n   * @param {*} value The value to set.\n   * @returns {Object} Returns the list cache instance.\n   */\n  function listCacheSet(key, value) {\n    var data = this.__data__,\n        index = _assocIndexOf(data, key);\n\n    if (index < 0) {\n      ++this.size;\n      data.push([key, value]);\n    } else {\n      data[index][1] = value;\n    }\n    return this;\n  }\n\n  var _listCacheSet = listCacheSet;\n\n  /**\n   * Creates an list cache object.\n   *\n   * @private\n   * @constructor\n   * @param {Array} [entries] The key-value pairs to cache.\n   */\n  function ListCache(entries) {\n    var index = -1,\n        length = entries == null ? 0 : entries.length;\n\n    this.clear();\n    while (++index < length) {\n      var entry = entries[index];\n      this.set(entry[0], entry[1]);\n    }\n  }\n\n  // Add methods to `ListCache`.\n  ListCache.prototype.clear = _listCacheClear;\n  ListCache.prototype['delete'] = _listCacheDelete;\n  ListCache.prototype.get = _listCacheGet;\n  ListCache.prototype.has = _listCacheHas;\n  ListCache.prototype.set = _listCacheSet;\n\n  var _ListCache = ListCache;\n\n  /* Built-in method references that are verified to be native. */\n  var Map$1 = _getNative(_root, 'Map');\n\n  var _Map = Map$1;\n\n  /**\n   * Removes all key-value entries from the map.\n   *\n   * @private\n   * @name clear\n   * @memberOf MapCache\n   */\n  function mapCacheClear() {\n    this.size = 0;\n    this.__data__ = {\n      'hash': new _Hash,\n      'map': new (_Map || _ListCache),\n      'string': new _Hash\n    };\n  }\n\n  var _mapCacheClear = mapCacheClear;\n\n  /**\n   * Checks if `value` is suitable for use as unique object key.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n   */\n  function isKeyable(value) {\n    var type = typeof value;\n    return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n      ? (value !== '__proto__')\n      : (value === null);\n  }\n\n  var _isKeyable = isKeyable;\n\n  /**\n   * Gets the data for `map`.\n   *\n   * @private\n   * @param {Object} map The map to query.\n   * @param {string} key The reference key.\n   * @returns {*} Returns the map data.\n   */\n  function getMapData(map, key) {\n    var data = map.__data__;\n    return _isKeyable(key)\n      ? data[typeof key == 'string' ? 'string' : 'hash']\n      : data.map;\n  }\n\n  var _getMapData = getMapData;\n\n  /**\n   * Removes `key` and its value from the map.\n   *\n   * @private\n   * @name delete\n   * @memberOf MapCache\n   * @param {string} key The key of the value to remove.\n   * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n   */\n  function mapCacheDelete(key) {\n    var result = _getMapData(this, key)['delete'](key);\n    this.size -= result ? 1 : 0;\n    return result;\n  }\n\n  var _mapCacheDelete = mapCacheDelete;\n\n  /**\n   * Gets the map value for `key`.\n   *\n   * @private\n   * @name get\n   * @memberOf MapCache\n   * @param {string} key The key of the value to get.\n   * @returns {*} Returns the entry value.\n   */\n  function mapCacheGet(key) {\n    return _getMapData(this, key).get(key);\n  }\n\n  var _mapCacheGet = mapCacheGet;\n\n  /**\n   * Checks if a map value for `key` exists.\n   *\n   * @private\n   * @name has\n   * @memberOf MapCache\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n  function mapCacheHas(key) {\n    return _getMapData(this, key).has(key);\n  }\n\n  var _mapCacheHas = mapCacheHas;\n\n  /**\n   * Sets the map `key` to `value`.\n   *\n   * @private\n   * @name set\n   * @memberOf MapCache\n   * @param {string} key The key of the value to set.\n   * @param {*} value The value to set.\n   * @returns {Object} Returns the map cache instance.\n   */\n  function mapCacheSet(key, value) {\n    var data = _getMapData(this, key),\n        size = data.size;\n\n    data.set(key, value);\n    this.size += data.size == size ? 0 : 1;\n    return this;\n  }\n\n  var _mapCacheSet = mapCacheSet;\n\n  /**\n   * Creates a map cache object to store key-value pairs.\n   *\n   * @private\n   * @constructor\n   * @param {Array} [entries] The key-value pairs to cache.\n   */\n  function MapCache(entries) {\n    var index = -1,\n        length = entries == null ? 0 : entries.length;\n\n    this.clear();\n    while (++index < length) {\n      var entry = entries[index];\n      this.set(entry[0], entry[1]);\n    }\n  }\n\n  // Add methods to `MapCache`.\n  MapCache.prototype.clear = _mapCacheClear;\n  MapCache.prototype['delete'] = _mapCacheDelete;\n  MapCache.prototype.get = _mapCacheGet;\n  MapCache.prototype.has = _mapCacheHas;\n  MapCache.prototype.set = _mapCacheSet;\n\n  var _MapCache = MapCache;\n\n  /** Error message constants. */\n  var FUNC_ERROR_TEXT = 'Expected a function';\n\n  /**\n   * Creates a function that memoizes the result of `func`. If `resolver` is\n   * provided, it determines the cache key for storing the result based on the\n   * arguments provided to the memoized function. By default, the first argument\n   * provided to the memoized function is used as the map cache key. The `func`\n   * is invoked with the `this` binding of the memoized function.\n   *\n   * **Note:** The cache is exposed as the `cache` property on the memoized\n   * function. Its creation may be customized by replacing the `_.memoize.Cache`\n   * constructor with one whose instances implement the\n   * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n   * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Function\n   * @param {Function} func The function to have its output memoized.\n   * @param {Function} [resolver] The function to resolve the cache key.\n   * @returns {Function} Returns the new memoized function.\n   * @example\n   *\n   * var object = { 'a': 1, 'b': 2 };\n   * var other = { 'c': 3, 'd': 4 };\n   *\n   * var values = _.memoize(_.values);\n   * values(object);\n   * // => [1, 2]\n   *\n   * values(other);\n   * // => [3, 4]\n   *\n   * object.a = 2;\n   * values(object);\n   * // => [1, 2]\n   *\n   * // Modify the result cache.\n   * values.cache.set(object, ['a', 'b']);\n   * values(object);\n   * // => ['a', 'b']\n   *\n   * // Replace `_.memoize.Cache`.\n   * _.memoize.Cache = WeakMap;\n   */\n  function memoize(func, resolver) {\n    if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n      throw new TypeError(FUNC_ERROR_TEXT);\n    }\n    var memoized = function() {\n      var args = arguments,\n          key = resolver ? resolver.apply(this, args) : args[0],\n          cache = memoized.cache;\n\n      if (cache.has(key)) {\n        return cache.get(key);\n      }\n      var result = func.apply(this, args);\n      memoized.cache = cache.set(key, result) || cache;\n      return result;\n    };\n    memoized.cache = new (memoize.Cache || _MapCache);\n    return memoized;\n  }\n\n  // Expose `MapCache`.\n  memoize.Cache = _MapCache;\n\n  var memoize_1 = memoize;\n\n  /** Used as the maximum memoize cache size. */\n  var MAX_MEMOIZE_SIZE = 500;\n\n  /**\n   * A specialized version of `_.memoize` which clears the memoized function's\n   * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n   *\n   * @private\n   * @param {Function} func The function to have its output memoized.\n   * @returns {Function} Returns the new memoized function.\n   */\n  function memoizeCapped(func) {\n    var result = memoize_1(func, function(key) {\n      if (cache.size === MAX_MEMOIZE_SIZE) {\n        cache.clear();\n      }\n      return key;\n    });\n\n    var cache = result.cache;\n    return result;\n  }\n\n  var _memoizeCapped = memoizeCapped;\n\n  /** Used to match property names within property paths. */\n  var rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n  /** Used to match backslashes in property paths. */\n  var reEscapeChar = /\\\\(\\\\)?/g;\n\n  /**\n   * Converts `string` to a property path array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the property path array.\n   */\n  var stringToPath = _memoizeCapped(function(string) {\n    var result = [];\n    if (string.charCodeAt(0) === 46 /* . */) {\n      result.push('');\n    }\n    string.replace(rePropName, function(match, number, quote, subString) {\n      result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n    });\n    return result;\n  });\n\n  var _stringToPath = stringToPath;\n\n  /**\n   * A specialized version of `_.map` for arrays without support for iteratee\n   * shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns the new mapped array.\n   */\n  function arrayMap(array, iteratee) {\n    var index = -1,\n        length = array == null ? 0 : array.length,\n        result = Array(length);\n\n    while (++index < length) {\n      result[index] = iteratee(array[index], index, array);\n    }\n    return result;\n  }\n\n  var _arrayMap = arrayMap;\n\n  /** Used as references for various `Number` constants. */\n  var INFINITY$1 = 1 / 0;\n\n  /** Used to convert symbols to primitives and strings. */\n  var symbolProto = _Symbol ? _Symbol.prototype : undefined,\n      symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n  /**\n   * The base implementation of `_.toString` which doesn't convert nullish\n   * values to empty strings.\n   *\n   * @private\n   * @param {*} value The value to process.\n   * @returns {string} Returns the string.\n   */\n  function baseToString(value) {\n    // Exit early for strings to avoid a performance hit in some environments.\n    if (typeof value == 'string') {\n      return value;\n    }\n    if (isArray_1(value)) {\n      // Recursively convert values (susceptible to call stack limits).\n      return _arrayMap(value, baseToString) + '';\n    }\n    if (isSymbol_1(value)) {\n      return symbolToString ? symbolToString.call(value) : '';\n    }\n    var result = (value + '');\n    return (result == '0' && (1 / value) == -INFINITY$1) ? '-0' : result;\n  }\n\n  var _baseToString = baseToString;\n\n  /**\n   * Converts `value` to a string. An empty string is returned for `null`\n   * and `undefined` values. The sign of `-0` is preserved.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to convert.\n   * @returns {string} Returns the converted string.\n   * @example\n   *\n   * _.toString(null);\n   * // => ''\n   *\n   * _.toString(-0);\n   * // => '-0'\n   *\n   * _.toString([1, 2, 3]);\n   * // => '1,2,3'\n   */\n  function toString$1(value) {\n    return value == null ? '' : _baseToString(value);\n  }\n\n  var toString_1 = toString$1;\n\n  /**\n   * Casts `value` to a path array if it's not one.\n   *\n   * @private\n   * @param {*} value The value to inspect.\n   * @param {Object} [object] The object to query keys on.\n   * @returns {Array} Returns the cast property path array.\n   */\n  function castPath(value, object) {\n    if (isArray_1(value)) {\n      return value;\n    }\n    return _isKey(value, object) ? [value] : _stringToPath(toString_1(value));\n  }\n\n  var _castPath = castPath;\n\n  /** Used as references for various `Number` constants. */\n  var INFINITY = 1 / 0;\n\n  /**\n   * Converts `value` to a string key if it's not a string or symbol.\n   *\n   * @private\n   * @param {*} value The value to inspect.\n   * @returns {string|symbol} Returns the key.\n   */\n  function toKey(value) {\n    if (typeof value == 'string' || isSymbol_1(value)) {\n      return value;\n    }\n    var result = (value + '');\n    return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n  }\n\n  var _toKey = toKey;\n\n  /**\n   * The base implementation of `_.get` without support for default values.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array|string} path The path of the property to get.\n   * @returns {*} Returns the resolved value.\n   */\n  function baseGet(object, path) {\n    path = _castPath(path, object);\n\n    var index = 0,\n        length = path.length;\n\n    while (object != null && index < length) {\n      object = object[_toKey(path[index++])];\n    }\n    return (index && index == length) ? object : undefined;\n  }\n\n  var _baseGet = baseGet;\n\n  /**\n   * Gets the value at `path` of `object`. If the resolved value is\n   * `undefined`, the `defaultValue` is returned in its place.\n   *\n   * @static\n   * @memberOf _\n   * @since 3.7.0\n   * @category Object\n   * @param {Object} object The object to query.\n   * @param {Array|string} path The path of the property to get.\n   * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n   * @returns {*} Returns the resolved value.\n   * @example\n   *\n   * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n   *\n   * _.get(object, 'a[0].b.c');\n   * // => 3\n   *\n   * _.get(object, ['a', '0', 'b', 'c']);\n   * // => 3\n   *\n   * _.get(object, 'a.b.c', 'default');\n   * // => 'default'\n   */\n  function get(object, path, defaultValue) {\n    var result = object == null ? undefined : _baseGet(object, path);\n    return result === undefined ? defaultValue : result;\n  }\n\n  var get_1 = get;\n\n  var defineProperty = (function() {\n    try {\n      var func = _getNative(Object, 'defineProperty');\n      func({}, '', {});\n      return func;\n    } catch (e) {}\n  }());\n\n  var _defineProperty = defineProperty;\n\n  /**\n   * The base implementation of `assignValue` and `assignMergeValue` without\n   * value checks.\n   *\n   * @private\n   * @param {Object} object The object to modify.\n   * @param {string} key The key of the property to assign.\n   * @param {*} value The value to assign.\n   */\n  function baseAssignValue(object, key, value) {\n    if (key == '__proto__' && _defineProperty) {\n      _defineProperty(object, key, {\n        'configurable': true,\n        'enumerable': true,\n        'value': value,\n        'writable': true\n      });\n    } else {\n      object[key] = value;\n    }\n  }\n\n  var _baseAssignValue = baseAssignValue;\n\n  /** Used for built-in method references. */\n  var objectProto = Object.prototype;\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty = objectProto.hasOwnProperty;\n\n  /**\n   * Assigns `value` to `key` of `object` if the existing value is not equivalent\n   * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n   * for equality comparisons.\n   *\n   * @private\n   * @param {Object} object The object to modify.\n   * @param {string} key The key of the property to assign.\n   * @param {*} value The value to assign.\n   */\n  function assignValue(object, key, value) {\n    var objValue = object[key];\n    if (!(hasOwnProperty.call(object, key) && eq_1(objValue, value)) ||\n        (value === undefined && !(key in object))) {\n      _baseAssignValue(object, key, value);\n    }\n  }\n\n  var _assignValue = assignValue;\n\n  /** Used as references for various `Number` constants. */\n  var MAX_SAFE_INTEGER = 9007199254740991;\n\n  /** Used to detect unsigned integer values. */\n  var reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n  /**\n   * Checks if `value` is a valid array-like index.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n   */\n  function isIndex(value, length) {\n    var type = typeof value;\n    length = length == null ? MAX_SAFE_INTEGER : length;\n\n    return !!length &&\n      (type == 'number' ||\n        (type != 'symbol' && reIsUint.test(value))) &&\n          (value > -1 && value % 1 == 0 && value < length);\n  }\n\n  var _isIndex = isIndex;\n\n  /**\n   * The base implementation of `_.set`.\n   *\n   * @private\n   * @param {Object} object The object to modify.\n   * @param {Array|string} path The path of the property to set.\n   * @param {*} value The value to set.\n   * @param {Function} [customizer] The function to customize path creation.\n   * @returns {Object} Returns `object`.\n   */\n  function baseSet(object, path, value, customizer) {\n    if (!isObject_1(object)) {\n      return object;\n    }\n    path = _castPath(path, object);\n\n    var index = -1,\n        length = path.length,\n        lastIndex = length - 1,\n        nested = object;\n\n    while (nested != null && ++index < length) {\n      var key = _toKey(path[index]),\n          newValue = value;\n\n      if (key === '__proto__' || key === 'constructor' || key === 'prototype') {\n        return object;\n      }\n\n      if (index != lastIndex) {\n        var objValue = nested[key];\n        newValue = customizer ? customizer(objValue, key, nested) : undefined;\n        if (newValue === undefined) {\n          newValue = isObject_1(objValue)\n            ? objValue\n            : (_isIndex(path[index + 1]) ? [] : {});\n        }\n      }\n      _assignValue(nested, key, newValue);\n      nested = nested[key];\n    }\n    return object;\n  }\n\n  var _baseSet = baseSet;\n\n  /**\n   * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,\n   * it's created. Arrays are created for missing index properties while objects\n   * are created for all other missing properties. Use `_.setWith` to customize\n   * `path` creation.\n   *\n   * **Note:** This method mutates `object`.\n   *\n   * @static\n   * @memberOf _\n   * @since 3.7.0\n   * @category Object\n   * @param {Object} object The object to modify.\n   * @param {Array|string} path The path of the property to set.\n   * @param {*} value The value to set.\n   * @returns {Object} Returns `object`.\n   * @example\n   *\n   * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n   *\n   * _.set(object, 'a[0].b.c', 4);\n   * console.log(object.a[0].b.c);\n   * // => 4\n   *\n   * _.set(object, ['x', '0', 'y', 'z'], 5);\n   * console.log(object.x[0].y.z);\n   * // => 5\n   */\n  function set(object, path, value) {\n    return object == null ? object : _baseSet(object, path, value);\n  }\n\n  var set_1 = set;\n\n  /**\n   * Copies the values of `source` to `array`.\n   *\n   * @private\n   * @param {Array} source The array to copy values from.\n   * @param {Array} [array=[]] The array to copy values to.\n   * @returns {Array} Returns `array`.\n   */\n  function copyArray(source, array) {\n    var index = -1,\n        length = source.length;\n\n    array || (array = Array(length));\n    while (++index < length) {\n      array[index] = source[index];\n    }\n    return array;\n  }\n\n  var _copyArray = copyArray;\n\n  /**\n   * Converts `value` to a property path array.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Util\n   * @param {*} value The value to convert.\n   * @returns {Array} Returns the new property path array.\n   * @example\n   *\n   * _.toPath('a.b.c');\n   * // => ['a', 'b', 'c']\n   *\n   * _.toPath('a[0].b.c');\n   * // => ['a', '0', 'b', 'c']\n   */\n  function toPath(value) {\n    if (isArray_1(value)) {\n      return _arrayMap(value, _toKey);\n    }\n    return isSymbol_1(value) ? [value] : _copyArray(_stringToPath(toString_1(value)));\n  }\n\n  var toPath_1 = toPath;\n\n  var define$2 = {\n    // access data field\n    data: function data(params) {\n      var defaults = {\n        field: 'data',\n        bindingEvent: 'data',\n        allowBinding: false,\n        allowSetting: false,\n        allowGetting: false,\n        settingEvent: 'data',\n        settingTriggersEvent: false,\n        triggerFnName: 'trigger',\n        immutableKeys: {},\n        // key => true if immutable\n        updateStyle: false,\n        beforeGet: function beforeGet(self) {},\n        beforeSet: function beforeSet(self, obj) {},\n        onSet: function onSet(self) {},\n        canSet: function canSet(self) {\n          return true;\n        }\n      };\n      params = extend({}, defaults, params);\n      return function dataImpl(name, value) {\n        var p = params;\n        var self = this;\n        var selfIsArrayLike = self.length !== undefined;\n        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n\n        var single = selfIsArrayLike ? self[0] : self; // .data('foo', ...)\n\n        if (string(name)) {\n          // set or get property\n          var isPathLike = name.indexOf('.') !== -1; // there might be a normal field with a dot \n\n          var path = isPathLike && toPath_1(name); // .data('foo')\n\n          if (p.allowGetting && value === undefined) {\n            // get\n            var ret;\n\n            if (single) {\n              p.beforeGet(single); // check if it's path and a field with the same name doesn't exist\n\n              if (path && single._private[p.field][name] === undefined) {\n                ret = get_1(single._private[p.field], path);\n              } else {\n                ret = single._private[p.field][name];\n              }\n            }\n\n            return ret; // .data('foo', 'bar')\n          } else if (p.allowSetting && value !== undefined) {\n            // set\n            var valid = !p.immutableKeys[name];\n\n            if (valid) {\n              var change = _defineProperty$1({}, name, value);\n\n              p.beforeSet(self, change);\n\n              for (var i = 0, l = all.length; i < l; i++) {\n                var ele = all[i];\n\n                if (p.canSet(ele)) {\n                  if (path && single._private[p.field][name] === undefined) {\n                    set_1(ele._private[p.field], path, value);\n                  } else {\n                    ele._private[p.field][name] = value;\n                  }\n                }\n              } // update mappers if asked\n\n\n              if (p.updateStyle) {\n                self.updateStyle();\n              } // call onSet callback\n\n\n              p.onSet(self);\n\n              if (p.settingTriggersEvent) {\n                self[p.triggerFnName](p.settingEvent);\n              }\n            }\n          } // .data({ 'foo': 'bar' })\n\n        } else if (p.allowSetting && plainObject(name)) {\n          // extend\n          var obj = name;\n          var k, v;\n          var keys = Object.keys(obj);\n          p.beforeSet(self, obj);\n\n          for (var _i = 0; _i < keys.length; _i++) {\n            k = keys[_i];\n            v = obj[k];\n\n            var _valid = !p.immutableKeys[k];\n\n            if (_valid) {\n              for (var j = 0; j < all.length; j++) {\n                var _ele = all[j];\n\n                if (p.canSet(_ele)) {\n                  _ele._private[p.field][k] = v;\n                }\n              }\n            }\n          } // update mappers if asked\n\n\n          if (p.updateStyle) {\n            self.updateStyle();\n          } // call onSet callback\n\n\n          p.onSet(self);\n\n          if (p.settingTriggersEvent) {\n            self[p.triggerFnName](p.settingEvent);\n          } // .data(function(){ ... })\n\n        } else if (p.allowBinding && fn$6(name)) {\n          // bind to event\n          var fn = name;\n          self.on(p.bindingEvent, fn); // .data()\n        } else if (p.allowGetting && name === undefined) {\n          // get whole object\n          var _ret;\n\n          if (single) {\n            p.beforeGet(single);\n            _ret = single._private[p.field];\n          }\n\n          return _ret;\n        }\n\n        return self; // maintain chainability\n      }; // function\n    },\n    // data\n    // remove data field\n    removeData: function removeData(params) {\n      var defaults = {\n        field: 'data',\n        event: 'data',\n        triggerFnName: 'trigger',\n        triggerEvent: false,\n        immutableKeys: {} // key => true if immutable\n\n      };\n      params = extend({}, defaults, params);\n      return function removeDataImpl(names) {\n        var p = params;\n        var self = this;\n        var selfIsArrayLike = self.length !== undefined;\n        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n        // .removeData('foo bar')\n\n        if (string(names)) {\n          // then get the list of keys, and delete them\n          var keys = names.split(/\\s+/);\n          var l = keys.length;\n\n          for (var i = 0; i < l; i++) {\n            // delete each non-empty key\n            var key = keys[i];\n\n            if (emptyString(key)) {\n              continue;\n            }\n\n            var valid = !p.immutableKeys[key]; // not valid if immutable\n\n            if (valid) {\n              for (var i_a = 0, l_a = all.length; i_a < l_a; i_a++) {\n                all[i_a]._private[p.field][key] = undefined;\n              }\n            }\n          }\n\n          if (p.triggerEvent) {\n            self[p.triggerFnName](p.event);\n          } // .removeData()\n\n        } else if (names === undefined) {\n          // then delete all keys\n          for (var _i_a = 0, _l_a = all.length; _i_a < _l_a; _i_a++) {\n            var _privateFields = all[_i_a]._private[p.field];\n\n            var _keys = Object.keys(_privateFields);\n\n            for (var _i2 = 0; _i2 < _keys.length; _i2++) {\n              var _key = _keys[_i2];\n              var validKeyToDelete = !p.immutableKeys[_key];\n\n              if (validKeyToDelete) {\n                _privateFields[_key] = undefined;\n              }\n            }\n          }\n\n          if (p.triggerEvent) {\n            self[p.triggerFnName](p.event);\n          }\n        }\n\n        return self; // maintain chaining\n      }; // function\n    } // removeData\n\n  }; // define\n\n  var define$1 = {\n    eventAliasesOn: function eventAliasesOn(proto) {\n      var p = proto;\n      p.addListener = p.listen = p.bind = p.on;\n      p.unlisten = p.unbind = p.off = p.removeListener;\n      p.trigger = p.emit; // this is just a wrapper alias of .on()\n\n      p.pon = p.promiseOn = function (events, selector) {\n        var self = this;\n        var args = Array.prototype.slice.call(arguments, 0);\n        return new Promise$1(function (resolve, reject) {\n          var callback = function callback(e) {\n            self.off.apply(self, offArgs);\n            resolve(e);\n          };\n\n          var onArgs = args.concat([callback]);\n          var offArgs = onArgs.concat([]);\n          self.on.apply(self, onArgs);\n        });\n      };\n    }\n  }; // define\n\n  // use this module to cherry pick functions into your prototype\n  var define = {};\n  [define$3, define$2, define$1].forEach(function (m) {\n    extend(define, m);\n  });\n\n  var elesfn$i = {\n    animate: define.animate(),\n    animation: define.animation(),\n    animated: define.animated(),\n    clearQueue: define.clearQueue(),\n    delay: define.delay(),\n    delayAnimation: define.delayAnimation(),\n    stop: define.stop()\n  };\n\n  var elesfn$h = {\n    classes: function classes(_classes) {\n      var self = this;\n\n      if (_classes === undefined) {\n        var ret = [];\n\n        self[0]._private.classes.forEach(function (cls) {\n          return ret.push(cls);\n        });\n\n        return ret;\n      } else if (!array(_classes)) {\n        // extract classes from string\n        _classes = (_classes || '').match(/\\S+/g) || [];\n      }\n\n      var changed = [];\n      var classesSet = new Set$1(_classes); // check and update each ele\n\n      for (var j = 0; j < self.length; j++) {\n        var ele = self[j];\n        var _p = ele._private;\n        var eleClasses = _p.classes;\n        var changedEle = false; // check if ele has all of the passed classes\n\n        for (var i = 0; i < _classes.length; i++) {\n          var cls = _classes[i];\n          var eleHasClass = eleClasses.has(cls);\n\n          if (!eleHasClass) {\n            changedEle = true;\n            break;\n          }\n        } // check if ele has classes outside of those passed\n\n\n        if (!changedEle) {\n          changedEle = eleClasses.size !== _classes.length;\n        }\n\n        if (changedEle) {\n          _p.classes = classesSet;\n          changed.push(ele);\n        }\n      } // trigger update style on those eles that had class changes\n\n\n      if (changed.length > 0) {\n        this.spawn(changed).updateStyle().emit('class');\n      }\n\n      return self;\n    },\n    addClass: function addClass(classes) {\n      return this.toggleClass(classes, true);\n    },\n    hasClass: function hasClass(className) {\n      var ele = this[0];\n      return ele != null && ele._private.classes.has(className);\n    },\n    toggleClass: function toggleClass(classes, toggle) {\n      if (!array(classes)) {\n        // extract classes from string\n        classes = classes.match(/\\S+/g) || [];\n      }\n\n      var self = this;\n      var toggleUndefd = toggle === undefined;\n      var changed = []; // eles who had classes changed\n\n      for (var i = 0, il = self.length; i < il; i++) {\n        var ele = self[i];\n        var eleClasses = ele._private.classes;\n        var changedEle = false;\n\n        for (var j = 0; j < classes.length; j++) {\n          var cls = classes[j];\n          var hasClass = eleClasses.has(cls);\n          var changedNow = false;\n\n          if (toggle || toggleUndefd && !hasClass) {\n            eleClasses.add(cls);\n            changedNow = true;\n          } else if (!toggle || toggleUndefd && hasClass) {\n            eleClasses[\"delete\"](cls);\n            changedNow = true;\n          }\n\n          if (!changedEle && changedNow) {\n            changed.push(ele);\n            changedEle = true;\n          }\n        } // for j classes\n\n      } // for i eles\n      // trigger update style on those eles that had class changes\n\n\n      if (changed.length > 0) {\n        this.spawn(changed).updateStyle().emit('class');\n      }\n\n      return self;\n    },\n    removeClass: function removeClass(classes) {\n      return this.toggleClass(classes, false);\n    },\n    flashClass: function flashClass(classes, duration) {\n      var self = this;\n\n      if (duration == null) {\n        duration = 250;\n      } else if (duration === 0) {\n        return self; // nothing to do really\n      }\n\n      self.addClass(classes);\n      setTimeout(function () {\n        self.removeClass(classes);\n      }, duration);\n      return self;\n    }\n  };\n  elesfn$h.className = elesfn$h.classNames = elesfn$h.classes;\n\n  var tokens = {\n    metaChar: '[\\\\!\\\\\"\\\\#\\\\$\\\\%\\\\&\\\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\.\\\\/\\\\:\\\\;\\\\<\\\\=\\\\>\\\\?\\\\@\\\\[\\\\]\\\\^\\\\`\\\\{\\\\|\\\\}\\\\~]',\n    // chars we need to escape in let names, etc\n    comparatorOp: '=|\\\\!=|>|>=|<|<=|\\\\$=|\\\\^=|\\\\*=',\n    // binary comparison op (used in data selectors)\n    boolOp: '\\\\?|\\\\!|\\\\^',\n    // boolean (unary) operators (used in data selectors)\n    string: '\"(?:\\\\\\\\\"|[^\"])*\"' + '|' + \"'(?:\\\\\\\\'|[^'])*'\",\n    // string literals (used in data selectors) -- doublequotes | singlequotes\n    number: number,\n    // number literal (used in data selectors) --- e.g. 0.1234, 1234, 12e123\n    meta: 'degree|indegree|outdegree',\n    // allowed metadata fields (i.e. allowed functions to use from Collection)\n    separator: '\\\\s*,\\\\s*',\n    // queries are separated by commas, e.g. edge[foo = 'bar'], node.someClass\n    descendant: '\\\\s+',\n    child: '\\\\s+>\\\\s+',\n    subject: '\\\\$',\n    group: 'node|edge|\\\\*',\n    directedEdge: '\\\\s+->\\\\s+',\n    undirectedEdge: '\\\\s+<->\\\\s+'\n  };\n  tokens.variable = '(?:[\\\\w-.]|(?:\\\\\\\\' + tokens.metaChar + '))+'; // a variable name can have letters, numbers, dashes, and periods\n\n  tokens.className = '(?:[\\\\w-]|(?:\\\\\\\\' + tokens.metaChar + '))+'; // a class name has the same rules as a variable except it can't have a '.' in the name\n\n  tokens.value = tokens.string + '|' + tokens.number; // a value literal, either a string or number\n\n  tokens.id = tokens.variable; // an element id (follows variable conventions)\n\n  (function () {\n    var ops, op, i; // add @ variants to comparatorOp\n\n    ops = tokens.comparatorOp.split('|');\n\n    for (i = 0; i < ops.length; i++) {\n      op = ops[i];\n      tokens.comparatorOp += '|@' + op;\n    } // add ! variants to comparatorOp\n\n\n    ops = tokens.comparatorOp.split('|');\n\n    for (i = 0; i < ops.length; i++) {\n      op = ops[i];\n\n      if (op.indexOf('!') >= 0) {\n        continue;\n      } // skip ops that explicitly contain !\n\n\n      if (op === '=') {\n        continue;\n      } // skip = b/c != is explicitly defined\n\n\n      tokens.comparatorOp += '|\\\\!' + op;\n    }\n  })();\n\n  /**\n   * Make a new query object\n   *\n   * @prop type {Type} The type enum (int) of the query\n   * @prop checks List of checks to make against an ele to test for a match\n   */\n  var newQuery = function newQuery() {\n    return {\n      checks: []\n    };\n  };\n\n  /**\n   * A check type enum-like object.  Uses integer values for fast match() lookup.\n   * The ordering does not matter as long as the ints are unique.\n   */\n  var Type = {\n    /** E.g. node */\n    GROUP: 0,\n\n    /** A collection of elements */\n    COLLECTION: 1,\n\n    /** A filter(ele) function */\n    FILTER: 2,\n\n    /** E.g. [foo > 1] */\n    DATA_COMPARE: 3,\n\n    /** E.g. [foo] */\n    DATA_EXIST: 4,\n\n    /** E.g. [?foo] */\n    DATA_BOOL: 5,\n\n    /** E.g. [[degree > 2]] */\n    META_COMPARE: 6,\n\n    /** E.g. :selected */\n    STATE: 7,\n\n    /** E.g. #foo */\n    ID: 8,\n\n    /** E.g. .foo */\n    CLASS: 9,\n\n    /** E.g. #foo <-> #bar */\n    UNDIRECTED_EDGE: 10,\n\n    /** E.g. #foo -> #bar */\n    DIRECTED_EDGE: 11,\n\n    /** E.g. $#foo -> #bar */\n    NODE_SOURCE: 12,\n\n    /** E.g. #foo -> $#bar */\n    NODE_TARGET: 13,\n\n    /** E.g. $#foo <-> #bar */\n    NODE_NEIGHBOR: 14,\n\n    /** E.g. #foo > #bar */\n    CHILD: 15,\n\n    /** E.g. #foo #bar */\n    DESCENDANT: 16,\n\n    /** E.g. $#foo > #bar */\n    PARENT: 17,\n\n    /** E.g. $#foo #bar */\n    ANCESTOR: 18,\n\n    /** E.g. #foo > $bar > #baz */\n    COMPOUND_SPLIT: 19,\n\n    /** Always matches, useful placeholder for subject in `COMPOUND_SPLIT` */\n    TRUE: 20\n  };\n\n  var stateSelectors = [{\n    selector: ':selected',\n    matches: function matches(ele) {\n      return ele.selected();\n    }\n  }, {\n    selector: ':unselected',\n    matches: function matches(ele) {\n      return !ele.selected();\n    }\n  }, {\n    selector: ':selectable',\n    matches: function matches(ele) {\n      return ele.selectable();\n    }\n  }, {\n    selector: ':unselectable',\n    matches: function matches(ele) {\n      return !ele.selectable();\n    }\n  }, {\n    selector: ':locked',\n    matches: function matches(ele) {\n      return ele.locked();\n    }\n  }, {\n    selector: ':unlocked',\n    matches: function matches(ele) {\n      return !ele.locked();\n    }\n  }, {\n    selector: ':visible',\n    matches: function matches(ele) {\n      return ele.visible();\n    }\n  }, {\n    selector: ':hidden',\n    matches: function matches(ele) {\n      return !ele.visible();\n    }\n  }, {\n    selector: ':transparent',\n    matches: function matches(ele) {\n      return ele.transparent();\n    }\n  }, {\n    selector: ':grabbed',\n    matches: function matches(ele) {\n      return ele.grabbed();\n    }\n  }, {\n    selector: ':free',\n    matches: function matches(ele) {\n      return !ele.grabbed();\n    }\n  }, {\n    selector: ':removed',\n    matches: function matches(ele) {\n      return ele.removed();\n    }\n  }, {\n    selector: ':inside',\n    matches: function matches(ele) {\n      return !ele.removed();\n    }\n  }, {\n    selector: ':grabbable',\n    matches: function matches(ele) {\n      return ele.grabbable();\n    }\n  }, {\n    selector: ':ungrabbable',\n    matches: function matches(ele) {\n      return !ele.grabbable();\n    }\n  }, {\n    selector: ':animated',\n    matches: function matches(ele) {\n      return ele.animated();\n    }\n  }, {\n    selector: ':unanimated',\n    matches: function matches(ele) {\n      return !ele.animated();\n    }\n  }, {\n    selector: ':parent',\n    matches: function matches(ele) {\n      return ele.isParent();\n    }\n  }, {\n    selector: ':childless',\n    matches: function matches(ele) {\n      return ele.isChildless();\n    }\n  }, {\n    selector: ':child',\n    matches: function matches(ele) {\n      return ele.isChild();\n    }\n  }, {\n    selector: ':orphan',\n    matches: function matches(ele) {\n      return ele.isOrphan();\n    }\n  }, {\n    selector: ':nonorphan',\n    matches: function matches(ele) {\n      return ele.isChild();\n    }\n  }, {\n    selector: ':compound',\n    matches: function matches(ele) {\n      if (ele.isNode()) {\n        return ele.isParent();\n      } else {\n        return ele.source().isParent() || ele.target().isParent();\n      }\n    }\n  }, {\n    selector: ':loop',\n    matches: function matches(ele) {\n      return ele.isLoop();\n    }\n  }, {\n    selector: ':simple',\n    matches: function matches(ele) {\n      return ele.isSimple();\n    }\n  }, {\n    selector: ':active',\n    matches: function matches(ele) {\n      return ele.active();\n    }\n  }, {\n    selector: ':inactive',\n    matches: function matches(ele) {\n      return !ele.active();\n    }\n  }, {\n    selector: ':backgrounding',\n    matches: function matches(ele) {\n      return ele.backgrounding();\n    }\n  }, {\n    selector: ':nonbackgrounding',\n    matches: function matches(ele) {\n      return !ele.backgrounding();\n    }\n  }].sort(function (a, b) {\n    // n.b. selectors that are starting substrings of others must have the longer ones first\n    return descending(a.selector, b.selector);\n  });\n\n  var lookup = function () {\n    var selToFn = {};\n    var s;\n\n    for (var i = 0; i < stateSelectors.length; i++) {\n      s = stateSelectors[i];\n      selToFn[s.selector] = s.matches;\n    }\n\n    return selToFn;\n  }();\n\n  var stateSelectorMatches = function stateSelectorMatches(sel, ele) {\n    return lookup[sel](ele);\n  };\n  var stateSelectorRegex = '(' + stateSelectors.map(function (s) {\n    return s.selector;\n  }).join('|') + ')';\n\n  // so that values get compared properly in Selector.filter()\n\n  var cleanMetaChars = function cleanMetaChars(str) {\n    return str.replace(new RegExp('\\\\\\\\(' + tokens.metaChar + ')', 'g'), function (match, $1) {\n      return $1;\n    });\n  };\n\n  var replaceLastQuery = function replaceLastQuery(selector, examiningQuery, replacementQuery) {\n    selector[selector.length - 1] = replacementQuery;\n  }; // NOTE: add new expression syntax here to have it recognised by the parser;\n  // - a query contains all adjacent (i.e. no separator in between) expressions;\n  // - the current query is stored in selector[i]\n  // - you need to check the query objects in match() for it actually filter properly, but that's pretty straight forward\n\n\n  var exprs = [{\n    name: 'group',\n    // just used for identifying when debugging\n    query: true,\n    regex: '(' + tokens.group + ')',\n    populate: function populate(selector, query, _ref) {\n      var _ref2 = _slicedToArray(_ref, 1),\n          group = _ref2[0];\n\n      query.checks.push({\n        type: Type.GROUP,\n        value: group === '*' ? group : group + 's'\n      });\n    }\n  }, {\n    name: 'state',\n    query: true,\n    regex: stateSelectorRegex,\n    populate: function populate(selector, query, _ref3) {\n      var _ref4 = _slicedToArray(_ref3, 1),\n          state = _ref4[0];\n\n      query.checks.push({\n        type: Type.STATE,\n        value: state\n      });\n    }\n  }, {\n    name: 'id',\n    query: true,\n    regex: '\\\\#(' + tokens.id + ')',\n    populate: function populate(selector, query, _ref5) {\n      var _ref6 = _slicedToArray(_ref5, 1),\n          id = _ref6[0];\n\n      query.checks.push({\n        type: Type.ID,\n        value: cleanMetaChars(id)\n      });\n    }\n  }, {\n    name: 'className',\n    query: true,\n    regex: '\\\\.(' + tokens.className + ')',\n    populate: function populate(selector, query, _ref7) {\n      var _ref8 = _slicedToArray(_ref7, 1),\n          className = _ref8[0];\n\n      query.checks.push({\n        type: Type.CLASS,\n        value: cleanMetaChars(className)\n      });\n    }\n  }, {\n    name: 'dataExists',\n    query: true,\n    regex: '\\\\[\\\\s*(' + tokens.variable + ')\\\\s*\\\\]',\n    populate: function populate(selector, query, _ref9) {\n      var _ref10 = _slicedToArray(_ref9, 1),\n          variable = _ref10[0];\n\n      query.checks.push({\n        type: Type.DATA_EXIST,\n        field: cleanMetaChars(variable)\n      });\n    }\n  }, {\n    name: 'dataCompare',\n    query: true,\n    regex: '\\\\[\\\\s*(' + tokens.variable + ')\\\\s*(' + tokens.comparatorOp + ')\\\\s*(' + tokens.value + ')\\\\s*\\\\]',\n    populate: function populate(selector, query, _ref11) {\n      var _ref12 = _slicedToArray(_ref11, 3),\n          variable = _ref12[0],\n          comparatorOp = _ref12[1],\n          value = _ref12[2];\n\n      var valueIsString = new RegExp('^' + tokens.string + '$').exec(value) != null;\n\n      if (valueIsString) {\n        value = value.substring(1, value.length - 1);\n      } else {\n        value = parseFloat(value);\n      }\n\n      query.checks.push({\n        type: Type.DATA_COMPARE,\n        field: cleanMetaChars(variable),\n        operator: comparatorOp,\n        value: value\n      });\n    }\n  }, {\n    name: 'dataBool',\n    query: true,\n    regex: '\\\\[\\\\s*(' + tokens.boolOp + ')\\\\s*(' + tokens.variable + ')\\\\s*\\\\]',\n    populate: function populate(selector, query, _ref13) {\n      var _ref14 = _slicedToArray(_ref13, 2),\n          boolOp = _ref14[0],\n          variable = _ref14[1];\n\n      query.checks.push({\n        type: Type.DATA_BOOL,\n        field: cleanMetaChars(variable),\n        operator: boolOp\n      });\n    }\n  }, {\n    name: 'metaCompare',\n    query: true,\n    regex: '\\\\[\\\\[\\\\s*(' + tokens.meta + ')\\\\s*(' + tokens.comparatorOp + ')\\\\s*(' + tokens.number + ')\\\\s*\\\\]\\\\]',\n    populate: function populate(selector, query, _ref15) {\n      var _ref16 = _slicedToArray(_ref15, 3),\n          meta = _ref16[0],\n          comparatorOp = _ref16[1],\n          number = _ref16[2];\n\n      query.checks.push({\n        type: Type.META_COMPARE,\n        field: cleanMetaChars(meta),\n        operator: comparatorOp,\n        value: parseFloat(number)\n      });\n    }\n  }, {\n    name: 'nextQuery',\n    separator: true,\n    regex: tokens.separator,\n    populate: function populate(selector, query) {\n      var currentSubject = selector.currentSubject;\n      var edgeCount = selector.edgeCount;\n      var compoundCount = selector.compoundCount;\n      var lastQ = selector[selector.length - 1];\n\n      if (currentSubject != null) {\n        lastQ.subject = currentSubject;\n        selector.currentSubject = null;\n      }\n\n      lastQ.edgeCount = edgeCount;\n      lastQ.compoundCount = compoundCount;\n      selector.edgeCount = 0;\n      selector.compoundCount = 0; // go on to next query\n\n      var nextQuery = selector[selector.length++] = newQuery();\n      return nextQuery; // this is the new query to be filled by the following exprs\n    }\n  }, {\n    name: 'directedEdge',\n    separator: true,\n    regex: tokens.directedEdge,\n    populate: function populate(selector, query) {\n      if (selector.currentSubject == null) {\n        // undirected edge\n        var edgeQuery = newQuery();\n        var source = query;\n        var target = newQuery();\n        edgeQuery.checks.push({\n          type: Type.DIRECTED_EDGE,\n          source: source,\n          target: target\n        }); // the query in the selector should be the edge rather than the source\n\n        replaceLastQuery(selector, query, edgeQuery);\n        selector.edgeCount++; // we're now populating the target query with expressions that follow\n\n        return target;\n      } else {\n        // source/target\n        var srcTgtQ = newQuery();\n        var _source = query;\n\n        var _target = newQuery();\n\n        srcTgtQ.checks.push({\n          type: Type.NODE_SOURCE,\n          source: _source,\n          target: _target\n        }); // the query in the selector should be the neighbourhood rather than the node\n\n        replaceLastQuery(selector, query, srcTgtQ);\n        selector.edgeCount++;\n        return _target; // now populating the target with the following expressions\n      }\n    }\n  }, {\n    name: 'undirectedEdge',\n    separator: true,\n    regex: tokens.undirectedEdge,\n    populate: function populate(selector, query) {\n      if (selector.currentSubject == null) {\n        // undirected edge\n        var edgeQuery = newQuery();\n        var source = query;\n        var target = newQuery();\n        edgeQuery.checks.push({\n          type: Type.UNDIRECTED_EDGE,\n          nodes: [source, target]\n        }); // the query in the selector should be the edge rather than the source\n\n        replaceLastQuery(selector, query, edgeQuery);\n        selector.edgeCount++; // we're now populating the target query with expressions that follow\n\n        return target;\n      } else {\n        // neighbourhood\n        var nhoodQ = newQuery();\n        var node = query;\n        var neighbor = newQuery();\n        nhoodQ.checks.push({\n          type: Type.NODE_NEIGHBOR,\n          node: node,\n          neighbor: neighbor\n        }); // the query in the selector should be the neighbourhood rather than the node\n\n        replaceLastQuery(selector, query, nhoodQ);\n        return neighbor; // now populating the neighbor with following expressions\n      }\n    }\n  }, {\n    name: 'child',\n    separator: true,\n    regex: tokens.child,\n    populate: function populate(selector, query) {\n      if (selector.currentSubject == null) {\n        // default: child query\n        var parentChildQuery = newQuery();\n        var child = newQuery();\n        var parent = selector[selector.length - 1];\n        parentChildQuery.checks.push({\n          type: Type.CHILD,\n          parent: parent,\n          child: child\n        }); // the query in the selector should be the '>' itself\n\n        replaceLastQuery(selector, query, parentChildQuery);\n        selector.compoundCount++; // we're now populating the child query with expressions that follow\n\n        return child;\n      } else if (selector.currentSubject === query) {\n        // compound split query\n        var compound = newQuery();\n        var left = selector[selector.length - 1];\n        var right = newQuery();\n        var subject = newQuery();\n\n        var _child = newQuery();\n\n        var _parent = newQuery(); // set up the root compound q\n\n\n        compound.checks.push({\n          type: Type.COMPOUND_SPLIT,\n          left: left,\n          right: right,\n          subject: subject\n        }); // populate the subject and replace the q at the old spot (within left) with TRUE\n\n        subject.checks = query.checks; // take the checks from the left\n\n        query.checks = [{\n          type: Type.TRUE\n        }]; // checks under left refs the subject implicitly\n        // set up the right q\n\n        _parent.checks.push({\n          type: Type.TRUE\n        }); // parent implicitly refs the subject\n\n\n        right.checks.push({\n          type: Type.PARENT,\n          // type is swapped on right side queries\n          parent: _parent,\n          child: _child // empty for now\n\n        });\n        replaceLastQuery(selector, left, compound); // update the ref since we moved things around for `query`\n\n        selector.currentSubject = subject;\n        selector.compoundCount++;\n        return _child; // now populating the right side's child\n      } else {\n        // parent query\n        // info for parent query\n        var _parent2 = newQuery();\n\n        var _child2 = newQuery();\n\n        var pcQChecks = [{\n          type: Type.PARENT,\n          parent: _parent2,\n          child: _child2\n        }]; // the parent-child query takes the place of the query previously being populated\n\n        _parent2.checks = query.checks; // the previous query contains the checks for the parent\n\n        query.checks = pcQChecks; // pc query takes over\n\n        selector.compoundCount++;\n        return _child2; // we're now populating the child\n      }\n    }\n  }, {\n    name: 'descendant',\n    separator: true,\n    regex: tokens.descendant,\n    populate: function populate(selector, query) {\n      if (selector.currentSubject == null) {\n        // default: descendant query\n        var ancChQuery = newQuery();\n        var descendant = newQuery();\n        var ancestor = selector[selector.length - 1];\n        ancChQuery.checks.push({\n          type: Type.DESCENDANT,\n          ancestor: ancestor,\n          descendant: descendant\n        }); // the query in the selector should be the '>' itself\n\n        replaceLastQuery(selector, query, ancChQuery);\n        selector.compoundCount++; // we're now populating the descendant query with expressions that follow\n\n        return descendant;\n      } else if (selector.currentSubject === query) {\n        // compound split query\n        var compound = newQuery();\n        var left = selector[selector.length - 1];\n        var right = newQuery();\n        var subject = newQuery();\n\n        var _descendant = newQuery();\n\n        var _ancestor = newQuery(); // set up the root compound q\n\n\n        compound.checks.push({\n          type: Type.COMPOUND_SPLIT,\n          left: left,\n          right: right,\n          subject: subject\n        }); // populate the subject and replace the q at the old spot (within left) with TRUE\n\n        subject.checks = query.checks; // take the checks from the left\n\n        query.checks = [{\n          type: Type.TRUE\n        }]; // checks under left refs the subject implicitly\n        // set up the right q\n\n        _ancestor.checks.push({\n          type: Type.TRUE\n        }); // ancestor implicitly refs the subject\n\n\n        right.checks.push({\n          type: Type.ANCESTOR,\n          // type is swapped on right side queries\n          ancestor: _ancestor,\n          descendant: _descendant // empty for now\n\n        });\n        replaceLastQuery(selector, left, compound); // update the ref since we moved things around for `query`\n\n        selector.currentSubject = subject;\n        selector.compoundCount++;\n        return _descendant; // now populating the right side's descendant\n      } else {\n        // ancestor query\n        // info for parent query\n        var _ancestor2 = newQuery();\n\n        var _descendant2 = newQuery();\n\n        var adQChecks = [{\n          type: Type.ANCESTOR,\n          ancestor: _ancestor2,\n          descendant: _descendant2\n        }]; // the parent-child query takes the place of the query previously being populated\n\n        _ancestor2.checks = query.checks; // the previous query contains the checks for the parent\n\n        query.checks = adQChecks; // pc query takes over\n\n        selector.compoundCount++;\n        return _descendant2; // we're now populating the child\n      }\n    }\n  }, {\n    name: 'subject',\n    modifier: true,\n    regex: tokens.subject,\n    populate: function populate(selector, query) {\n      if (selector.currentSubject != null && selector.currentSubject !== query) {\n        warn('Redefinition of subject in selector `' + selector.toString() + '`');\n        return false;\n      }\n\n      selector.currentSubject = query;\n      var topQ = selector[selector.length - 1];\n      var topChk = topQ.checks[0];\n      var topType = topChk == null ? null : topChk.type;\n\n      if (topType === Type.DIRECTED_EDGE) {\n        // directed edge with subject on the target\n        // change to target node check\n        topChk.type = Type.NODE_TARGET;\n      } else if (topType === Type.UNDIRECTED_EDGE) {\n        // undirected edge with subject on the second node\n        // change to neighbor check\n        topChk.type = Type.NODE_NEIGHBOR;\n        topChk.node = topChk.nodes[1]; // second node is subject\n\n        topChk.neighbor = topChk.nodes[0]; // clean up unused fields for new type\n\n        topChk.nodes = null;\n      }\n    }\n  }];\n  exprs.forEach(function (e) {\n    return e.regexObj = new RegExp('^' + e.regex);\n  });\n\n  /**\n   * Of all the expressions, find the first match in the remaining text.\n   * @param {string} remaining The remaining text to parse\n   * @returns The matched expression and the newly remaining text `{ expr, match, name, remaining }`\n   */\n\n  var consumeExpr = function consumeExpr(remaining) {\n    var expr;\n    var match;\n    var name;\n\n    for (var j = 0; j < exprs.length; j++) {\n      var e = exprs[j];\n      var n = e.name;\n      var m = remaining.match(e.regexObj);\n\n      if (m != null) {\n        match = m;\n        expr = e;\n        name = n;\n        var consumed = m[0];\n        remaining = remaining.substring(consumed.length);\n        break; // we've consumed one expr, so we can return now\n      }\n    }\n\n    return {\n      expr: expr,\n      match: match,\n      name: name,\n      remaining: remaining\n    };\n  };\n  /**\n   * Consume all the leading whitespace\n   * @param {string} remaining The text to consume\n   * @returns The text with the leading whitespace removed\n   */\n\n\n  var consumeWhitespace = function consumeWhitespace(remaining) {\n    var match = remaining.match(/^\\s+/);\n\n    if (match) {\n      var consumed = match[0];\n      remaining = remaining.substring(consumed.length);\n    }\n\n    return remaining;\n  };\n  /**\n   * Parse the string and store the parsed representation in the Selector.\n   * @param {string} selector The selector string\n   * @returns `true` if the selector was successfully parsed, `false` otherwise\n   */\n\n\n  var parse = function parse(selector) {\n    var self = this;\n    var remaining = self.inputText = selector;\n    var currentQuery = self[0] = newQuery();\n    self.length = 1;\n    remaining = consumeWhitespace(remaining); // get rid of leading whitespace\n\n    for (;;) {\n      var exprInfo = consumeExpr(remaining);\n\n      if (exprInfo.expr == null) {\n        warn('The selector `' + selector + '`is invalid');\n        return false;\n      } else {\n        var args = exprInfo.match.slice(1); // let the token populate the selector object in currentQuery\n\n        var ret = exprInfo.expr.populate(self, currentQuery, args);\n\n        if (ret === false) {\n          return false; // exit if population failed\n        } else if (ret != null) {\n          currentQuery = ret; // change the current query to be filled if the expr specifies\n        }\n      }\n\n      remaining = exprInfo.remaining; // we're done when there's nothing left to parse\n\n      if (remaining.match(/^\\s*$/)) {\n        break;\n      }\n    }\n\n    var lastQ = self[self.length - 1];\n\n    if (self.currentSubject != null) {\n      lastQ.subject = self.currentSubject;\n    }\n\n    lastQ.edgeCount = self.edgeCount;\n    lastQ.compoundCount = self.compoundCount;\n\n    for (var i = 0; i < self.length; i++) {\n      var q = self[i]; // in future, this could potentially be allowed if there were operator precedence and detection of invalid combinations\n\n      if (q.compoundCount > 0 && q.edgeCount > 0) {\n        warn('The selector `' + selector + '` is invalid because it uses both a compound selector and an edge selector');\n        return false;\n      }\n\n      if (q.edgeCount > 1) {\n        warn('The selector `' + selector + '` is invalid because it uses multiple edge selectors');\n        return false;\n      } else if (q.edgeCount === 1) {\n        warn('The selector `' + selector + '` is deprecated.  Edge selectors do not take effect on changes to source and target nodes after an edge is added, for performance reasons.  Use a class or data selector on edges instead, updating the class or data of an edge when your app detects a change in source or target nodes.');\n      }\n    }\n\n    return true; // success\n  };\n  /**\n   * Get the selector represented as a string.  This value uses default formatting,\n   * so things like spacing may differ from the input text passed to the constructor.\n   * @returns {string} The selector string\n   */\n\n\n  var toString = function toString() {\n    if (this.toStringCache != null) {\n      return this.toStringCache;\n    }\n\n    var clean = function clean(obj) {\n      if (obj == null) {\n        return '';\n      } else {\n        return obj;\n      }\n    };\n\n    var cleanVal = function cleanVal(val) {\n      if (string(val)) {\n        return '\"' + val + '\"';\n      } else {\n        return clean(val);\n      }\n    };\n\n    var space = function space(val) {\n      return ' ' + val + ' ';\n    };\n\n    var checkToString = function checkToString(check, subject) {\n      var type = check.type,\n          value = check.value;\n\n      switch (type) {\n        case Type.GROUP:\n          {\n            var group = clean(value);\n            return group.substring(0, group.length - 1);\n          }\n\n        case Type.DATA_COMPARE:\n          {\n            var field = check.field,\n                operator = check.operator;\n            return '[' + field + space(clean(operator)) + cleanVal(value) + ']';\n          }\n\n        case Type.DATA_BOOL:\n          {\n            var _operator = check.operator,\n                _field = check.field;\n            return '[' + clean(_operator) + _field + ']';\n          }\n\n        case Type.DATA_EXIST:\n          {\n            var _field2 = check.field;\n            return '[' + _field2 + ']';\n          }\n\n        case Type.META_COMPARE:\n          {\n            var _operator2 = check.operator,\n                _field3 = check.field;\n            return '[[' + _field3 + space(clean(_operator2)) + cleanVal(value) + ']]';\n          }\n\n        case Type.STATE:\n          {\n            return value;\n          }\n\n        case Type.ID:\n          {\n            return '#' + value;\n          }\n\n        case Type.CLASS:\n          {\n            return '.' + value;\n          }\n\n        case Type.PARENT:\n        case Type.CHILD:\n          {\n            return queryToString(check.parent, subject) + space('>') + queryToString(check.child, subject);\n          }\n\n        case Type.ANCESTOR:\n        case Type.DESCENDANT:\n          {\n            return queryToString(check.ancestor, subject) + ' ' + queryToString(check.descendant, subject);\n          }\n\n        case Type.COMPOUND_SPLIT:\n          {\n            var lhs = queryToString(check.left, subject);\n            var sub = queryToString(check.subject, subject);\n            var rhs = queryToString(check.right, subject);\n            return lhs + (lhs.length > 0 ? ' ' : '') + sub + rhs;\n          }\n\n        case Type.TRUE:\n          {\n            return '';\n          }\n      }\n    };\n\n    var queryToString = function queryToString(query, subject) {\n      return query.checks.reduce(function (str, chk, i) {\n        return str + (subject === query && i === 0 ? '$' : '') + checkToString(chk, subject);\n      }, '');\n    };\n\n    var str = '';\n\n    for (var i = 0; i < this.length; i++) {\n      var query = this[i];\n      str += queryToString(query, query.subject);\n\n      if (this.length > 1 && i < this.length - 1) {\n        str += ', ';\n      }\n    }\n\n    this.toStringCache = str;\n    return str;\n  };\n  var parse$1 = {\n    parse: parse,\n    toString: toString\n  };\n\n  var valCmp = function valCmp(fieldVal, operator, value) {\n    var matches;\n    var isFieldStr = string(fieldVal);\n    var isFieldNum = number$1(fieldVal);\n    var isValStr = string(value);\n    var fieldStr, valStr;\n    var caseInsensitive = false;\n    var notExpr = false;\n    var isIneqCmp = false;\n\n    if (operator.indexOf('!') >= 0) {\n      operator = operator.replace('!', '');\n      notExpr = true;\n    }\n\n    if (operator.indexOf('@') >= 0) {\n      operator = operator.replace('@', '');\n      caseInsensitive = true;\n    }\n\n    if (isFieldStr || isValStr || caseInsensitive) {\n      fieldStr = !isFieldStr && !isFieldNum ? '' : '' + fieldVal;\n      valStr = '' + value;\n    } // if we're doing a case insensitive comparison, then we're using a STRING comparison\n    // even if we're comparing numbers\n\n\n    if (caseInsensitive) {\n      fieldVal = fieldStr = fieldStr.toLowerCase();\n      value = valStr = valStr.toLowerCase();\n    }\n\n    switch (operator) {\n      case '*=':\n        matches = fieldStr.indexOf(valStr) >= 0;\n        break;\n\n      case '$=':\n        matches = fieldStr.indexOf(valStr, fieldStr.length - valStr.length) >= 0;\n        break;\n\n      case '^=':\n        matches = fieldStr.indexOf(valStr) === 0;\n        break;\n\n      case '=':\n        matches = fieldVal === value;\n        break;\n\n      case '>':\n        isIneqCmp = true;\n        matches = fieldVal > value;\n        break;\n\n      case '>=':\n        isIneqCmp = true;\n        matches = fieldVal >= value;\n        break;\n\n      case '<':\n        isIneqCmp = true;\n        matches = fieldVal < value;\n        break;\n\n      case '<=':\n        isIneqCmp = true;\n        matches = fieldVal <= value;\n        break;\n\n      default:\n        matches = false;\n        break;\n    } // apply the not op, but null vals for inequalities should always stay non-matching\n\n\n    if (notExpr && (fieldVal != null || !isIneqCmp)) {\n      matches = !matches;\n    }\n\n    return matches;\n  };\n  var boolCmp = function boolCmp(fieldVal, operator) {\n    switch (operator) {\n      case '?':\n        return fieldVal ? true : false;\n\n      case '!':\n        return fieldVal ? false : true;\n\n      case '^':\n        return fieldVal === undefined;\n    }\n  };\n  var existCmp = function existCmp(fieldVal) {\n    return fieldVal !== undefined;\n  };\n  var data$1 = function data(ele, field) {\n    return ele.data(field);\n  };\n  var meta = function meta(ele, field) {\n    return ele[field]();\n  };\n\n  /** A lookup of `match(check, ele)` functions by `Type` int */\n\n  var match = [];\n  /**\n   * Returns whether the query matches for the element\n   * @param query The `{ type, value, ... }` query object\n   * @param ele The element to compare against\n  */\n\n  var matches$1 = function matches(query, ele) {\n    return query.checks.every(function (chk) {\n      return match[chk.type](chk, ele);\n    });\n  };\n\n  match[Type.GROUP] = function (check, ele) {\n    var group = check.value;\n    return group === '*' || group === ele.group();\n  };\n\n  match[Type.STATE] = function (check, ele) {\n    var stateSelector = check.value;\n    return stateSelectorMatches(stateSelector, ele);\n  };\n\n  match[Type.ID] = function (check, ele) {\n    var id = check.value;\n    return ele.id() === id;\n  };\n\n  match[Type.CLASS] = function (check, ele) {\n    var cls = check.value;\n    return ele.hasClass(cls);\n  };\n\n  match[Type.META_COMPARE] = function (check, ele) {\n    var field = check.field,\n        operator = check.operator,\n        value = check.value;\n    return valCmp(meta(ele, field), operator, value);\n  };\n\n  match[Type.DATA_COMPARE] = function (check, ele) {\n    var field = check.field,\n        operator = check.operator,\n        value = check.value;\n    return valCmp(data$1(ele, field), operator, value);\n  };\n\n  match[Type.DATA_BOOL] = function (check, ele) {\n    var field = check.field,\n        operator = check.operator;\n    return boolCmp(data$1(ele, field), operator);\n  };\n\n  match[Type.DATA_EXIST] = function (check, ele) {\n    var field = check.field;\n        check.operator;\n    return existCmp(data$1(ele, field));\n  };\n\n  match[Type.UNDIRECTED_EDGE] = function (check, ele) {\n    var qA = check.nodes[0];\n    var qB = check.nodes[1];\n    var src = ele.source();\n    var tgt = ele.target();\n    return matches$1(qA, src) && matches$1(qB, tgt) || matches$1(qB, src) && matches$1(qA, tgt);\n  };\n\n  match[Type.NODE_NEIGHBOR] = function (check, ele) {\n    return matches$1(check.node, ele) && ele.neighborhood().some(function (n) {\n      return n.isNode() && matches$1(check.neighbor, n);\n    });\n  };\n\n  match[Type.DIRECTED_EDGE] = function (check, ele) {\n    return matches$1(check.source, ele.source()) && matches$1(check.target, ele.target());\n  };\n\n  match[Type.NODE_SOURCE] = function (check, ele) {\n    return matches$1(check.source, ele) && ele.outgoers().some(function (n) {\n      return n.isNode() && matches$1(check.target, n);\n    });\n  };\n\n  match[Type.NODE_TARGET] = function (check, ele) {\n    return matches$1(check.target, ele) && ele.incomers().some(function (n) {\n      return n.isNode() && matches$1(check.source, n);\n    });\n  };\n\n  match[Type.CHILD] = function (check, ele) {\n    return matches$1(check.child, ele) && matches$1(check.parent, ele.parent());\n  };\n\n  match[Type.PARENT] = function (check, ele) {\n    return matches$1(check.parent, ele) && ele.children().some(function (c) {\n      return matches$1(check.child, c);\n    });\n  };\n\n  match[Type.DESCENDANT] = function (check, ele) {\n    return matches$1(check.descendant, ele) && ele.ancestors().some(function (a) {\n      return matches$1(check.ancestor, a);\n    });\n  };\n\n  match[Type.ANCESTOR] = function (check, ele) {\n    return matches$1(check.ancestor, ele) && ele.descendants().some(function (d) {\n      return matches$1(check.descendant, d);\n    });\n  };\n\n  match[Type.COMPOUND_SPLIT] = function (check, ele) {\n    return matches$1(check.subject, ele) && matches$1(check.left, ele) && matches$1(check.right, ele);\n  };\n\n  match[Type.TRUE] = function () {\n    return true;\n  };\n\n  match[Type.COLLECTION] = function (check, ele) {\n    var collection = check.value;\n    return collection.has(ele);\n  };\n\n  match[Type.FILTER] = function (check, ele) {\n    var filter = check.value;\n    return filter(ele);\n  };\n\n  var filter = function filter(collection) {\n    var self = this; // for 1 id #foo queries, just get the element\n\n    if (self.length === 1 && self[0].checks.length === 1 && self[0].checks[0].type === Type.ID) {\n      return collection.getElementById(self[0].checks[0].value).collection();\n    }\n\n    var selectorFunction = function selectorFunction(element) {\n      for (var j = 0; j < self.length; j++) {\n        var query = self[j];\n\n        if (matches$1(query, element)) {\n          return true;\n        }\n      }\n\n      return false;\n    };\n\n    if (self.text() == null) {\n      selectorFunction = function selectorFunction() {\n        return true;\n      };\n    }\n\n    return collection.filter(selectorFunction);\n  }; // filter\n  // does selector match a single element?\n\n\n  var matches = function matches(ele) {\n    var self = this;\n\n    for (var j = 0; j < self.length; j++) {\n      var query = self[j];\n\n      if (matches$1(query, ele)) {\n        return true;\n      }\n    }\n\n    return false;\n  }; // matches\n\n\n  var matching = {\n    matches: matches,\n    filter: filter\n  };\n\n  var Selector = function Selector(selector) {\n    this.inputText = selector;\n    this.currentSubject = null;\n    this.compoundCount = 0;\n    this.edgeCount = 0;\n    this.length = 0;\n\n    if (selector == null || string(selector) && selector.match(/^\\s*$/)) ; else if (elementOrCollection(selector)) {\n      this.addQuery({\n        checks: [{\n          type: Type.COLLECTION,\n          value: selector.collection()\n        }]\n      });\n    } else if (fn$6(selector)) {\n      this.addQuery({\n        checks: [{\n          type: Type.FILTER,\n          value: selector\n        }]\n      });\n    } else if (string(selector)) {\n      if (!this.parse(selector)) {\n        this.invalid = true;\n      }\n    } else {\n      error('A selector must be created from a string; found ');\n    }\n  };\n\n  var selfn = Selector.prototype;\n  [parse$1, matching].forEach(function (p) {\n    return extend(selfn, p);\n  });\n\n  selfn.text = function () {\n    return this.inputText;\n  };\n\n  selfn.size = function () {\n    return this.length;\n  };\n\n  selfn.eq = function (i) {\n    return this[i];\n  };\n\n  selfn.sameText = function (otherSel) {\n    return !this.invalid && !otherSel.invalid && this.text() === otherSel.text();\n  };\n\n  selfn.addQuery = function (q) {\n    this[this.length++] = q;\n  };\n\n  selfn.selector = selfn.toString;\n\n  var elesfn$g = {\n    allAre: function allAre(selector) {\n      var selObj = new Selector(selector);\n      return this.every(function (ele) {\n        return selObj.matches(ele);\n      });\n    },\n    is: function is(selector) {\n      var selObj = new Selector(selector);\n      return this.some(function (ele) {\n        return selObj.matches(ele);\n      });\n    },\n    some: function some(fn, thisArg) {\n      for (var i = 0; i < this.length; i++) {\n        var ret = !thisArg ? fn(this[i], i, this) : fn.apply(thisArg, [this[i], i, this]);\n\n        if (ret) {\n          return true;\n        }\n      }\n\n      return false;\n    },\n    every: function every(fn, thisArg) {\n      for (var i = 0; i < this.length; i++) {\n        var ret = !thisArg ? fn(this[i], i, this) : fn.apply(thisArg, [this[i], i, this]);\n\n        if (!ret) {\n          return false;\n        }\n      }\n\n      return true;\n    },\n    same: function same(collection) {\n      // cheap collection ref check\n      if (this === collection) {\n        return true;\n      }\n\n      collection = this.cy().collection(collection);\n      var thisLength = this.length;\n      var collectionLength = collection.length; // cheap length check\n\n      if (thisLength !== collectionLength) {\n        return false;\n      } // cheap element ref check\n\n\n      if (thisLength === 1) {\n        return this[0] === collection[0];\n      }\n\n      return this.every(function (ele) {\n        return collection.hasElementWithId(ele.id());\n      });\n    },\n    anySame: function anySame(collection) {\n      collection = this.cy().collection(collection);\n      return this.some(function (ele) {\n        return collection.hasElementWithId(ele.id());\n      });\n    },\n    allAreNeighbors: function allAreNeighbors(collection) {\n      collection = this.cy().collection(collection);\n      var nhood = this.neighborhood();\n      return collection.every(function (ele) {\n        return nhood.hasElementWithId(ele.id());\n      });\n    },\n    contains: function contains(collection) {\n      collection = this.cy().collection(collection);\n      var self = this;\n      return collection.every(function (ele) {\n        return self.hasElementWithId(ele.id());\n      });\n    }\n  };\n  elesfn$g.allAreNeighbours = elesfn$g.allAreNeighbors;\n  elesfn$g.has = elesfn$g.contains;\n  elesfn$g.equal = elesfn$g.equals = elesfn$g.same;\n\n  var cache = function cache(fn, name) {\n    return function traversalCache(arg1, arg2, arg3, arg4) {\n      var selectorOrEles = arg1;\n      var eles = this;\n      var key;\n\n      if (selectorOrEles == null) {\n        key = '';\n      } else if (elementOrCollection(selectorOrEles) && selectorOrEles.length === 1) {\n        key = selectorOrEles.id();\n      }\n\n      if (eles.length === 1 && key) {\n        var _p = eles[0]._private;\n        var tch = _p.traversalCache = _p.traversalCache || {};\n        var ch = tch[name] = tch[name] || [];\n        var hash = hashString(key);\n        var cacheHit = ch[hash];\n\n        if (cacheHit) {\n          return cacheHit;\n        } else {\n          return ch[hash] = fn.call(eles, arg1, arg2, arg3, arg4);\n        }\n      } else {\n        return fn.call(eles, arg1, arg2, arg3, arg4);\n      }\n    };\n  };\n\n  var elesfn$f = {\n    parent: function parent(selector) {\n      var parents = []; // optimisation for single ele call\n\n      if (this.length === 1) {\n        var parent = this[0]._private.parent;\n\n        if (parent) {\n          return parent;\n        }\n      }\n\n      for (var i = 0; i < this.length; i++) {\n        var ele = this[i];\n        var _parent = ele._private.parent;\n\n        if (_parent) {\n          parents.push(_parent);\n        }\n      }\n\n      return this.spawn(parents, true).filter(selector);\n    },\n    parents: function parents(selector) {\n      var parents = [];\n      var eles = this.parent();\n\n      while (eles.nonempty()) {\n        for (var i = 0; i < eles.length; i++) {\n          var ele = eles[i];\n          parents.push(ele);\n        }\n\n        eles = eles.parent();\n      }\n\n      return this.spawn(parents, true).filter(selector);\n    },\n    commonAncestors: function commonAncestors(selector) {\n      var ancestors;\n\n      for (var i = 0; i < this.length; i++) {\n        var ele = this[i];\n        var parents = ele.parents();\n        ancestors = ancestors || parents;\n        ancestors = ancestors.intersect(parents); // current list must be common with current ele parents set\n      }\n\n      return ancestors.filter(selector);\n    },\n    orphans: function orphans(selector) {\n      return this.stdFilter(function (ele) {\n        return ele.isOrphan();\n      }).filter(selector);\n    },\n    nonorphans: function nonorphans(selector) {\n      return this.stdFilter(function (ele) {\n        return ele.isChild();\n      }).filter(selector);\n    },\n    children: cache(function (selector) {\n      var children = [];\n\n      for (var i = 0; i < this.length; i++) {\n        var ele = this[i];\n        var eleChildren = ele._private.children;\n\n        for (var j = 0; j < eleChildren.length; j++) {\n          children.push(eleChildren[j]);\n        }\n      }\n\n      return this.spawn(children, true).filter(selector);\n    }, 'children'),\n    siblings: function siblings(selector) {\n      return this.parent().children().not(this).filter(selector);\n    },\n    isParent: function isParent() {\n      var ele = this[0];\n\n      if (ele) {\n        return ele.isNode() && ele._private.children.length !== 0;\n      }\n    },\n    isChildless: function isChildless() {\n      var ele = this[0];\n\n      if (ele) {\n        return ele.isNode() && ele._private.children.length === 0;\n      }\n    },\n    isChild: function isChild() {\n      var ele = this[0];\n\n      if (ele) {\n        return ele.isNode() && ele._private.parent != null;\n      }\n    },\n    isOrphan: function isOrphan() {\n      var ele = this[0];\n\n      if (ele) {\n        return ele.isNode() && ele._private.parent == null;\n      }\n    },\n    descendants: function descendants(selector) {\n      var elements = [];\n\n      function add(eles) {\n        for (var i = 0; i < eles.length; i++) {\n          var ele = eles[i];\n          elements.push(ele);\n\n          if (ele.children().nonempty()) {\n            add(ele.children());\n          }\n        }\n      }\n\n      add(this.children());\n      return this.spawn(elements, true).filter(selector);\n    }\n  };\n\n  function forEachCompound(eles, fn, includeSelf, recursiveStep) {\n    var q = [];\n    var did = new Set$1();\n    var cy = eles.cy();\n    var hasCompounds = cy.hasCompoundNodes();\n\n    for (var i = 0; i < eles.length; i++) {\n      var ele = eles[i];\n\n      if (includeSelf) {\n        q.push(ele);\n      } else if (hasCompounds) {\n        recursiveStep(q, did, ele);\n      }\n    }\n\n    while (q.length > 0) {\n      var _ele = q.shift();\n\n      fn(_ele);\n      did.add(_ele.id());\n\n      if (hasCompounds) {\n        recursiveStep(q, did, _ele);\n      }\n    }\n\n    return eles;\n  }\n\n  function addChildren(q, did, ele) {\n    if (ele.isParent()) {\n      var children = ele._private.children;\n\n      for (var i = 0; i < children.length; i++) {\n        var child = children[i];\n\n        if (!did.has(child.id())) {\n          q.push(child);\n        }\n      }\n    }\n  } // very efficient version of eles.add( eles.descendants() ).forEach()\n  // for internal use\n\n\n  elesfn$f.forEachDown = function (fn) {\n    var includeSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    return forEachCompound(this, fn, includeSelf, addChildren);\n  };\n\n  function addParent(q, did, ele) {\n    if (ele.isChild()) {\n      var parent = ele._private.parent;\n\n      if (!did.has(parent.id())) {\n        q.push(parent);\n      }\n    }\n  }\n\n  elesfn$f.forEachUp = function (fn) {\n    var includeSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    return forEachCompound(this, fn, includeSelf, addParent);\n  };\n\n  function addParentAndChildren(q, did, ele) {\n    addParent(q, did, ele);\n    addChildren(q, did, ele);\n  }\n\n  elesfn$f.forEachUpAndDown = function (fn) {\n    var includeSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    return forEachCompound(this, fn, includeSelf, addParentAndChildren);\n  }; // aliases\n\n\n  elesfn$f.ancestors = elesfn$f.parents;\n\n  var fn$5, elesfn$e;\n  fn$5 = elesfn$e = {\n    data: define.data({\n      field: 'data',\n      bindingEvent: 'data',\n      allowBinding: true,\n      allowSetting: true,\n      settingEvent: 'data',\n      settingTriggersEvent: true,\n      triggerFnName: 'trigger',\n      allowGetting: true,\n      immutableKeys: {\n        'id': true,\n        'source': true,\n        'target': true,\n        'parent': true\n      },\n      updateStyle: true\n    }),\n    removeData: define.removeData({\n      field: 'data',\n      event: 'data',\n      triggerFnName: 'trigger',\n      triggerEvent: true,\n      immutableKeys: {\n        'id': true,\n        'source': true,\n        'target': true,\n        'parent': true\n      },\n      updateStyle: true\n    }),\n    scratch: define.data({\n      field: 'scratch',\n      bindingEvent: 'scratch',\n      allowBinding: true,\n      allowSetting: true,\n      settingEvent: 'scratch',\n      settingTriggersEvent: true,\n      triggerFnName: 'trigger',\n      allowGetting: true,\n      updateStyle: true\n    }),\n    removeScratch: define.removeData({\n      field: 'scratch',\n      event: 'scratch',\n      triggerFnName: 'trigger',\n      triggerEvent: true,\n      updateStyle: true\n    }),\n    rscratch: define.data({\n      field: 'rscratch',\n      allowBinding: false,\n      allowSetting: true,\n      settingTriggersEvent: false,\n      allowGetting: true\n    }),\n    removeRscratch: define.removeData({\n      field: 'rscratch',\n      triggerEvent: false\n    }),\n    id: function id() {\n      var ele = this[0];\n\n      if (ele) {\n        return ele._private.data.id;\n      }\n    }\n  }; // aliases\n\n  fn$5.attr = fn$5.data;\n  fn$5.removeAttr = fn$5.removeData;\n  var data = elesfn$e;\n\n  var elesfn$d = {};\n\n  function defineDegreeFunction(callback) {\n    return function (includeLoops) {\n      var self = this;\n\n      if (includeLoops === undefined) {\n        includeLoops = true;\n      }\n\n      if (self.length === 0) {\n        return;\n      }\n\n      if (self.isNode() && !self.removed()) {\n        var degree = 0;\n        var node = self[0];\n        var connectedEdges = node._private.edges;\n\n        for (var i = 0; i < connectedEdges.length; i++) {\n          var edge = connectedEdges[i];\n\n          if (!includeLoops && edge.isLoop()) {\n            continue;\n          }\n\n          degree += callback(node, edge);\n        }\n\n        return degree;\n      } else {\n        return;\n      }\n    };\n  }\n\n  extend(elesfn$d, {\n    degree: defineDegreeFunction(function (node, edge) {\n      if (edge.source().same(edge.target())) {\n        return 2;\n      } else {\n        return 1;\n      }\n    }),\n    indegree: defineDegreeFunction(function (node, edge) {\n      if (edge.target().same(node)) {\n        return 1;\n      } else {\n        return 0;\n      }\n    }),\n    outdegree: defineDegreeFunction(function (node, edge) {\n      if (edge.source().same(node)) {\n        return 1;\n      } else {\n        return 0;\n      }\n    })\n  });\n\n  function defineDegreeBoundsFunction(degreeFn, callback) {\n    return function (includeLoops) {\n      var ret;\n      var nodes = this.nodes();\n\n      for (var i = 0; i < nodes.length; i++) {\n        var ele = nodes[i];\n        var degree = ele[degreeFn](includeLoops);\n\n        if (degree !== undefined && (ret === undefined || callback(degree, ret))) {\n          ret = degree;\n        }\n      }\n\n      return ret;\n    };\n  }\n\n  extend(elesfn$d, {\n    minDegree: defineDegreeBoundsFunction('degree', function (degree, min) {\n      return degree < min;\n    }),\n    maxDegree: defineDegreeBoundsFunction('degree', function (degree, max) {\n      return degree > max;\n    }),\n    minIndegree: defineDegreeBoundsFunction('indegree', function (degree, min) {\n      return degree < min;\n    }),\n    maxIndegree: defineDegreeBoundsFunction('indegree', function (degree, max) {\n      return degree > max;\n    }),\n    minOutdegree: defineDegreeBoundsFunction('outdegree', function (degree, min) {\n      return degree < min;\n    }),\n    maxOutdegree: defineDegreeBoundsFunction('outdegree', function (degree, max) {\n      return degree > max;\n    })\n  });\n  extend(elesfn$d, {\n    totalDegree: function totalDegree(includeLoops) {\n      var total = 0;\n      var nodes = this.nodes();\n\n      for (var i = 0; i < nodes.length; i++) {\n        total += nodes[i].degree(includeLoops);\n      }\n\n      return total;\n    }\n  });\n\n  var fn$4, elesfn$c;\n\n  var beforePositionSet = function beforePositionSet(eles, newPos, silent) {\n    for (var i = 0; i < eles.length; i++) {\n      var ele = eles[i];\n\n      if (!ele.locked()) {\n        var oldPos = ele._private.position;\n        var delta = {\n          x: newPos.x != null ? newPos.x - oldPos.x : 0,\n          y: newPos.y != null ? newPos.y - oldPos.y : 0\n        };\n\n        if (ele.isParent() && !(delta.x === 0 && delta.y === 0)) {\n          ele.children().shift(delta, silent);\n        }\n\n        ele.dirtyBoundingBoxCache();\n      }\n    }\n  };\n\n  var positionDef = {\n    field: 'position',\n    bindingEvent: 'position',\n    allowBinding: true,\n    allowSetting: true,\n    settingEvent: 'position',\n    settingTriggersEvent: true,\n    triggerFnName: 'emitAndNotify',\n    allowGetting: true,\n    validKeys: ['x', 'y'],\n    beforeGet: function beforeGet(ele) {\n      ele.updateCompoundBounds();\n    },\n    beforeSet: function beforeSet(eles, newPos) {\n      beforePositionSet(eles, newPos, false);\n    },\n    onSet: function onSet(eles) {\n      eles.dirtyCompoundBoundsCache();\n    },\n    canSet: function canSet(ele) {\n      return !ele.locked();\n    }\n  };\n  fn$4 = elesfn$c = {\n    position: define.data(positionDef),\n    // position but no notification to renderer\n    silentPosition: define.data(extend({}, positionDef, {\n      allowBinding: false,\n      allowSetting: true,\n      settingTriggersEvent: false,\n      allowGetting: false,\n      beforeSet: function beforeSet(eles, newPos) {\n        beforePositionSet(eles, newPos, true);\n      },\n      onSet: function onSet(eles) {\n        eles.dirtyCompoundBoundsCache();\n      }\n    })),\n    positions: function positions(pos, silent) {\n      if (plainObject(pos)) {\n        if (silent) {\n          this.silentPosition(pos);\n        } else {\n          this.position(pos);\n        }\n      } else if (fn$6(pos)) {\n        var _fn = pos;\n        var cy = this.cy();\n        cy.startBatch();\n\n        for (var i = 0; i < this.length; i++) {\n          var ele = this[i];\n\n          var _pos = void 0;\n\n          if (_pos = _fn(ele, i)) {\n            if (silent) {\n              ele.silentPosition(_pos);\n            } else {\n              ele.position(_pos);\n            }\n          }\n        }\n\n        cy.endBatch();\n      }\n\n      return this; // chaining\n    },\n    silentPositions: function silentPositions(pos) {\n      return this.positions(pos, true);\n    },\n    shift: function shift(dim, val, silent) {\n      var delta;\n\n      if (plainObject(dim)) {\n        delta = {\n          x: number$1(dim.x) ? dim.x : 0,\n          y: number$1(dim.y) ? dim.y : 0\n        };\n        silent = val;\n      } else if (string(dim) && number$1(val)) {\n        delta = {\n          x: 0,\n          y: 0\n        };\n        delta[dim] = val;\n      }\n\n      if (delta != null) {\n        var cy = this.cy();\n        cy.startBatch();\n\n        for (var i = 0; i < this.length; i++) {\n          var ele = this[i]; // exclude any node that is a descendant of the calling collection\n\n          if (cy.hasCompoundNodes() && ele.isChild() && ele.ancestors().anySame(this)) {\n            continue;\n          }\n\n          var pos = ele.position();\n          var newPos = {\n            x: pos.x + delta.x,\n            y: pos.y + delta.y\n          };\n\n          if (silent) {\n            ele.silentPosition(newPos);\n          } else {\n            ele.position(newPos);\n          }\n        }\n\n        cy.endBatch();\n      }\n\n      return this;\n    },\n    silentShift: function silentShift(dim, val) {\n      if (plainObject(dim)) {\n        this.shift(dim, true);\n      } else if (string(dim) && number$1(val)) {\n        this.shift(dim, val, true);\n      }\n\n      return this;\n    },\n    // get/set the rendered (i.e. on screen) positon of the element\n    renderedPosition: function renderedPosition(dim, val) {\n      var ele = this[0];\n      var cy = this.cy();\n      var zoom = cy.zoom();\n      var pan = cy.pan();\n      var rpos = plainObject(dim) ? dim : undefined;\n      var setting = rpos !== undefined || val !== undefined && string(dim);\n\n      if (ele && ele.isNode()) {\n        // must have an element and must be a node to return position\n        if (setting) {\n          for (var i = 0; i < this.length; i++) {\n            var _ele = this[i];\n\n            if (val !== undefined) {\n              // set one dimension\n              _ele.position(dim, (val - pan[dim]) / zoom);\n            } else if (rpos !== undefined) {\n              // set whole position\n              _ele.position(renderedToModelPosition(rpos, zoom, pan));\n            }\n          }\n        } else {\n          // getting\n          var pos = ele.position();\n          rpos = modelToRenderedPosition(pos, zoom, pan);\n\n          if (dim === undefined) {\n            // then return the whole rendered position\n            return rpos;\n          } else {\n            // then return the specified dimension\n            return rpos[dim];\n          }\n        }\n      } else if (!setting) {\n        return undefined; // for empty collection case\n      }\n\n      return this; // chaining\n    },\n    // get/set the position relative to the parent\n    relativePosition: function relativePosition(dim, val) {\n      var ele = this[0];\n      var cy = this.cy();\n      var ppos = plainObject(dim) ? dim : undefined;\n      var setting = ppos !== undefined || val !== undefined && string(dim);\n      var hasCompoundNodes = cy.hasCompoundNodes();\n\n      if (ele && ele.isNode()) {\n        // must have an element and must be a node to return position\n        if (setting) {\n          for (var i = 0; i < this.length; i++) {\n            var _ele2 = this[i];\n            var parent = hasCompoundNodes ? _ele2.parent() : null;\n            var hasParent = parent && parent.length > 0;\n            var relativeToParent = hasParent;\n\n            if (hasParent) {\n              parent = parent[0];\n            }\n\n            var origin = relativeToParent ? parent.position() : {\n              x: 0,\n              y: 0\n            };\n\n            if (val !== undefined) {\n              // set one dimension\n              _ele2.position(dim, val + origin[dim]);\n            } else if (ppos !== undefined) {\n              // set whole position\n              _ele2.position({\n                x: ppos.x + origin.x,\n                y: ppos.y + origin.y\n              });\n            }\n          }\n        } else {\n          // getting\n          var pos = ele.position();\n\n          var _parent = hasCompoundNodes ? ele.parent() : null;\n\n          var _hasParent = _parent && _parent.length > 0;\n\n          var _relativeToParent = _hasParent;\n\n          if (_hasParent) {\n            _parent = _parent[0];\n          }\n\n          var _origin = _relativeToParent ? _parent.position() : {\n            x: 0,\n            y: 0\n          };\n\n          ppos = {\n            x: pos.x - _origin.x,\n            y: pos.y - _origin.y\n          };\n\n          if (dim === undefined) {\n            // then return the whole rendered position\n            return ppos;\n          } else {\n            // then return the specified dimension\n            return ppos[dim];\n          }\n        }\n      } else if (!setting) {\n        return undefined; // for empty collection case\n      }\n\n      return this; // chaining\n    }\n  }; // aliases\n\n  fn$4.modelPosition = fn$4.point = fn$4.position;\n  fn$4.modelPositions = fn$4.points = fn$4.positions;\n  fn$4.renderedPoint = fn$4.renderedPosition;\n  fn$4.relativePoint = fn$4.relativePosition;\n  var position = elesfn$c;\n\n  var fn$3, elesfn$b;\n  fn$3 = elesfn$b = {};\n\n  elesfn$b.renderedBoundingBox = function (options) {\n    var bb = this.boundingBox(options);\n    var cy = this.cy();\n    var zoom = cy.zoom();\n    var pan = cy.pan();\n    var x1 = bb.x1 * zoom + pan.x;\n    var x2 = bb.x2 * zoom + pan.x;\n    var y1 = bb.y1 * zoom + pan.y;\n    var y2 = bb.y2 * zoom + pan.y;\n    return {\n      x1: x1,\n      x2: x2,\n      y1: y1,\n      y2: y2,\n      w: x2 - x1,\n      h: y2 - y1\n    };\n  };\n\n  elesfn$b.dirtyCompoundBoundsCache = function () {\n    var silent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var cy = this.cy();\n\n    if (!cy.styleEnabled() || !cy.hasCompoundNodes()) {\n      return this;\n    }\n\n    this.forEachUp(function (ele) {\n      if (ele.isParent()) {\n        var _p = ele._private;\n        _p.compoundBoundsClean = false;\n        _p.bbCache = null;\n\n        if (!silent) {\n          ele.emitAndNotify('bounds');\n        }\n      }\n    });\n    return this;\n  };\n\n  elesfn$b.updateCompoundBounds = function () {\n    var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var cy = this.cy(); // not possible to do on non-compound graphs or with the style disabled\n\n    if (!cy.styleEnabled() || !cy.hasCompoundNodes()) {\n      return this;\n    } // save cycles when batching -- but bounds will be stale (or not exist yet)\n\n\n    if (!force && cy.batching()) {\n      return this;\n    }\n\n    function update(parent) {\n      if (!parent.isParent()) {\n        return;\n      }\n\n      var _p = parent._private;\n      var children = parent.children();\n      var includeLabels = parent.pstyle('compound-sizing-wrt-labels').value === 'include';\n      var min = {\n        width: {\n          val: parent.pstyle('min-width').pfValue,\n          left: parent.pstyle('min-width-bias-left'),\n          right: parent.pstyle('min-width-bias-right')\n        },\n        height: {\n          val: parent.pstyle('min-height').pfValue,\n          top: parent.pstyle('min-height-bias-top'),\n          bottom: parent.pstyle('min-height-bias-bottom')\n        }\n      };\n      var bb = children.boundingBox({\n        includeLabels: includeLabels,\n        includeOverlays: false,\n        // updating the compound bounds happens outside of the regular\n        // cache cycle (i.e. before fired events)\n        useCache: false\n      });\n      var pos = _p.position; // if children take up zero area then keep position and fall back on stylesheet w/h\n\n      if (bb.w === 0 || bb.h === 0) {\n        bb = {\n          w: parent.pstyle('width').pfValue,\n          h: parent.pstyle('height').pfValue\n        };\n        bb.x1 = pos.x - bb.w / 2;\n        bb.x2 = pos.x + bb.w / 2;\n        bb.y1 = pos.y - bb.h / 2;\n        bb.y2 = pos.y + bb.h / 2;\n      }\n\n      function computeBiasValues(propDiff, propBias, propBiasComplement) {\n        var biasDiff = 0;\n        var biasComplementDiff = 0;\n        var biasTotal = propBias + propBiasComplement;\n\n        if (propDiff > 0 && biasTotal > 0) {\n          biasDiff = propBias / biasTotal * propDiff;\n          biasComplementDiff = propBiasComplement / biasTotal * propDiff;\n        }\n\n        return {\n          biasDiff: biasDiff,\n          biasComplementDiff: biasComplementDiff\n        };\n      }\n\n      function computePaddingValues(width, height, paddingObject, relativeTo) {\n        // Assuming percentage is number from 0 to 1\n        if (paddingObject.units === '%') {\n          switch (relativeTo) {\n            case 'width':\n              return width > 0 ? paddingObject.pfValue * width : 0;\n\n            case 'height':\n              return height > 0 ? paddingObject.pfValue * height : 0;\n\n            case 'average':\n              return width > 0 && height > 0 ? paddingObject.pfValue * (width + height) / 2 : 0;\n\n            case 'min':\n              return width > 0 && height > 0 ? width > height ? paddingObject.pfValue * height : paddingObject.pfValue * width : 0;\n\n            case 'max':\n              return width > 0 && height > 0 ? width > height ? paddingObject.pfValue * width : paddingObject.pfValue * height : 0;\n\n            default:\n              return 0;\n          }\n        } else if (paddingObject.units === 'px') {\n          return paddingObject.pfValue;\n        } else {\n          return 0;\n        }\n      }\n\n      var leftVal = min.width.left.value;\n\n      if (min.width.left.units === 'px' && min.width.val > 0) {\n        leftVal = leftVal * 100 / min.width.val;\n      }\n\n      var rightVal = min.width.right.value;\n\n      if (min.width.right.units === 'px' && min.width.val > 0) {\n        rightVal = rightVal * 100 / min.width.val;\n      }\n\n      var topVal = min.height.top.value;\n\n      if (min.height.top.units === 'px' && min.height.val > 0) {\n        topVal = topVal * 100 / min.height.val;\n      }\n\n      var bottomVal = min.height.bottom.value;\n\n      if (min.height.bottom.units === 'px' && min.height.val > 0) {\n        bottomVal = bottomVal * 100 / min.height.val;\n      }\n\n      var widthBiasDiffs = computeBiasValues(min.width.val - bb.w, leftVal, rightVal);\n      var diffLeft = widthBiasDiffs.biasDiff;\n      var diffRight = widthBiasDiffs.biasComplementDiff;\n      var heightBiasDiffs = computeBiasValues(min.height.val - bb.h, topVal, bottomVal);\n      var diffTop = heightBiasDiffs.biasDiff;\n      var diffBottom = heightBiasDiffs.biasComplementDiff;\n      _p.autoPadding = computePaddingValues(bb.w, bb.h, parent.pstyle('padding'), parent.pstyle('padding-relative-to').value);\n      _p.autoWidth = Math.max(bb.w, min.width.val);\n      pos.x = (-diffLeft + bb.x1 + bb.x2 + diffRight) / 2;\n      _p.autoHeight = Math.max(bb.h, min.height.val);\n      pos.y = (-diffTop + bb.y1 + bb.y2 + diffBottom) / 2;\n    }\n\n    for (var i = 0; i < this.length; i++) {\n      var ele = this[i];\n      var _p = ele._private;\n\n      if (!_p.compoundBoundsClean || force) {\n        update(ele);\n\n        if (!cy.batching()) {\n          _p.compoundBoundsClean = true;\n        }\n      }\n    }\n\n    return this;\n  };\n\n  var noninf = function noninf(x) {\n    if (x === Infinity || x === -Infinity) {\n      return 0;\n    }\n\n    return x;\n  };\n\n  var updateBounds = function updateBounds(b, x1, y1, x2, y2) {\n    // don't update with zero area boxes\n    if (x2 - x1 === 0 || y2 - y1 === 0) {\n      return;\n    } // don't update with null dim\n\n\n    if (x1 == null || y1 == null || x2 == null || y2 == null) {\n      return;\n    }\n\n    b.x1 = x1 < b.x1 ? x1 : b.x1;\n    b.x2 = x2 > b.x2 ? x2 : b.x2;\n    b.y1 = y1 < b.y1 ? y1 : b.y1;\n    b.y2 = y2 > b.y2 ? y2 : b.y2;\n    b.w = b.x2 - b.x1;\n    b.h = b.y2 - b.y1;\n  };\n\n  var updateBoundsFromBox = function updateBoundsFromBox(b, b2) {\n    if (b2 == null) {\n      return b;\n    }\n\n    return updateBounds(b, b2.x1, b2.y1, b2.x2, b2.y2);\n  };\n\n  var prefixedProperty = function prefixedProperty(obj, field, prefix) {\n    return getPrefixedProperty(obj, field, prefix);\n  };\n\n  var updateBoundsFromArrow = function updateBoundsFromArrow(bounds, ele, prefix) {\n    if (ele.cy().headless()) {\n      return;\n    }\n\n    var _p = ele._private;\n    var rstyle = _p.rstyle;\n    var halfArW = rstyle.arrowWidth / 2;\n    var arrowType = ele.pstyle(prefix + '-arrow-shape').value;\n    var x;\n    var y;\n\n    if (arrowType !== 'none') {\n      if (prefix === 'source') {\n        x = rstyle.srcX;\n        y = rstyle.srcY;\n      } else if (prefix === 'target') {\n        x = rstyle.tgtX;\n        y = rstyle.tgtY;\n      } else {\n        x = rstyle.midX;\n        y = rstyle.midY;\n      } // always store the individual arrow bounds\n\n\n      var bbs = _p.arrowBounds = _p.arrowBounds || {};\n      var bb = bbs[prefix] = bbs[prefix] || {};\n      bb.x1 = x - halfArW;\n      bb.y1 = y - halfArW;\n      bb.x2 = x + halfArW;\n      bb.y2 = y + halfArW;\n      bb.w = bb.x2 - bb.x1;\n      bb.h = bb.y2 - bb.y1;\n      expandBoundingBox(bb, 1);\n      updateBounds(bounds, bb.x1, bb.y1, bb.x2, bb.y2);\n    }\n  };\n\n  var updateBoundsFromLabel = function updateBoundsFromLabel(bounds, ele, prefix) {\n    if (ele.cy().headless()) {\n      return;\n    }\n\n    var prefixDash;\n\n    if (prefix) {\n      prefixDash = prefix + '-';\n    } else {\n      prefixDash = '';\n    }\n\n    var _p = ele._private;\n    var rstyle = _p.rstyle;\n    var label = ele.pstyle(prefixDash + 'label').strValue;\n\n    if (label) {\n      var halign = ele.pstyle('text-halign');\n      var valign = ele.pstyle('text-valign');\n      var labelWidth = prefixedProperty(rstyle, 'labelWidth', prefix);\n      var labelHeight = prefixedProperty(rstyle, 'labelHeight', prefix);\n      var labelX = prefixedProperty(rstyle, 'labelX', prefix);\n      var labelY = prefixedProperty(rstyle, 'labelY', prefix);\n      var marginX = ele.pstyle(prefixDash + 'text-margin-x').pfValue;\n      var marginY = ele.pstyle(prefixDash + 'text-margin-y').pfValue;\n      var isEdge = ele.isEdge();\n      var rotation = ele.pstyle(prefixDash + 'text-rotation');\n      var outlineWidth = ele.pstyle('text-outline-width').pfValue;\n      var borderWidth = ele.pstyle('text-border-width').pfValue;\n      var halfBorderWidth = borderWidth / 2;\n      var padding = ele.pstyle('text-background-padding').pfValue;\n      var marginOfError = 2; // expand to work around browser dimension inaccuracies\n\n      var lh = labelHeight;\n      var lw = labelWidth;\n      var lw_2 = lw / 2;\n      var lh_2 = lh / 2;\n      var lx1, lx2, ly1, ly2;\n\n      if (isEdge) {\n        lx1 = labelX - lw_2;\n        lx2 = labelX + lw_2;\n        ly1 = labelY - lh_2;\n        ly2 = labelY + lh_2;\n      } else {\n        switch (halign.value) {\n          case 'left':\n            lx1 = labelX - lw;\n            lx2 = labelX;\n            break;\n\n          case 'center':\n            lx1 = labelX - lw_2;\n            lx2 = labelX + lw_2;\n            break;\n\n          case 'right':\n            lx1 = labelX;\n            lx2 = labelX + lw;\n            break;\n        }\n\n        switch (valign.value) {\n          case 'top':\n            ly1 = labelY - lh;\n            ly2 = labelY;\n            break;\n\n          case 'center':\n            ly1 = labelY - lh_2;\n            ly2 = labelY + lh_2;\n            break;\n\n          case 'bottom':\n            ly1 = labelY;\n            ly2 = labelY + lh;\n            break;\n        }\n      } // shift by margin and expand by outline and border\n\n\n      lx1 += marginX - Math.max(outlineWidth, halfBorderWidth) - padding - marginOfError;\n      lx2 += marginX + Math.max(outlineWidth, halfBorderWidth) + padding + marginOfError;\n      ly1 += marginY - Math.max(outlineWidth, halfBorderWidth) - padding - marginOfError;\n      ly2 += marginY + Math.max(outlineWidth, halfBorderWidth) + padding + marginOfError; // always store the unrotated label bounds separately\n\n      var bbPrefix = prefix || 'main';\n      var bbs = _p.labelBounds;\n      var bb = bbs[bbPrefix] = bbs[bbPrefix] || {};\n      bb.x1 = lx1;\n      bb.y1 = ly1;\n      bb.x2 = lx2;\n      bb.y2 = ly2;\n      bb.w = lx2 - lx1;\n      bb.h = ly2 - ly1;\n      var isAutorotate = isEdge && rotation.strValue === 'autorotate';\n      var isPfValue = rotation.pfValue != null && rotation.pfValue !== 0;\n\n      if (isAutorotate || isPfValue) {\n        var theta = isAutorotate ? prefixedProperty(_p.rstyle, 'labelAngle', prefix) : rotation.pfValue;\n        var cos = Math.cos(theta);\n        var sin = Math.sin(theta); // rotation point (default value for center-center)\n\n        var xo = (lx1 + lx2) / 2;\n        var yo = (ly1 + ly2) / 2;\n\n        if (!isEdge) {\n          switch (halign.value) {\n            case 'left':\n              xo = lx2;\n              break;\n\n            case 'right':\n              xo = lx1;\n              break;\n          }\n\n          switch (valign.value) {\n            case 'top':\n              yo = ly2;\n              break;\n\n            case 'bottom':\n              yo = ly1;\n              break;\n          }\n        }\n\n        var rotate = function rotate(x, y) {\n          x = x - xo;\n          y = y - yo;\n          return {\n            x: x * cos - y * sin + xo,\n            y: x * sin + y * cos + yo\n          };\n        };\n\n        var px1y1 = rotate(lx1, ly1);\n        var px1y2 = rotate(lx1, ly2);\n        var px2y1 = rotate(lx2, ly1);\n        var px2y2 = rotate(lx2, ly2);\n        lx1 = Math.min(px1y1.x, px1y2.x, px2y1.x, px2y2.x);\n        lx2 = Math.max(px1y1.x, px1y2.x, px2y1.x, px2y2.x);\n        ly1 = Math.min(px1y1.y, px1y2.y, px2y1.y, px2y2.y);\n        ly2 = Math.max(px1y1.y, px1y2.y, px2y1.y, px2y2.y);\n      }\n\n      var bbPrefixRot = bbPrefix + 'Rot';\n      var bbRot = bbs[bbPrefixRot] = bbs[bbPrefixRot] || {};\n      bbRot.x1 = lx1;\n      bbRot.y1 = ly1;\n      bbRot.x2 = lx2;\n      bbRot.y2 = ly2;\n      bbRot.w = lx2 - lx1;\n      bbRot.h = ly2 - ly1;\n      updateBounds(bounds, lx1, ly1, lx2, ly2);\n      updateBounds(_p.labelBounds.all, lx1, ly1, lx2, ly2);\n    }\n\n    return bounds;\n  }; // get the bounding box of the elements (in raw model position)\n\n\n  var boundingBoxImpl = function boundingBoxImpl(ele, options) {\n    var cy = ele._private.cy;\n    var styleEnabled = cy.styleEnabled();\n    var headless = cy.headless();\n    var bounds = makeBoundingBox();\n    var _p = ele._private;\n    var isNode = ele.isNode();\n    var isEdge = ele.isEdge();\n    var ex1, ex2, ey1, ey2; // extrema of body / lines\n\n    var x, y; // node pos\n\n    var rstyle = _p.rstyle;\n    var manualExpansion = isNode && styleEnabled ? ele.pstyle('bounds-expansion').pfValue : [0]; // must use `display` prop only, as reading `compound.width()` causes recursion\n    // (other factors like width values will be considered later in this function anyway)\n\n    var isDisplayed = function isDisplayed(ele) {\n      return ele.pstyle('display').value !== 'none';\n    };\n\n    var displayed = !styleEnabled || isDisplayed(ele) // must take into account connected nodes b/c of implicit edge hiding on display:none node\n    && (!isEdge || isDisplayed(ele.source()) && isDisplayed(ele.target()));\n\n    if (displayed) {\n      // displayed suffices, since we will find zero area eles anyway\n      var overlayOpacity = 0;\n      var overlayPadding = 0;\n\n      if (styleEnabled && options.includeOverlays) {\n        overlayOpacity = ele.pstyle('overlay-opacity').value;\n\n        if (overlayOpacity !== 0) {\n          overlayPadding = ele.pstyle('overlay-padding').value;\n        }\n      }\n\n      var underlayOpacity = 0;\n      var underlayPadding = 0;\n\n      if (styleEnabled && options.includeUnderlays) {\n        underlayOpacity = ele.pstyle('underlay-opacity').value;\n\n        if (underlayOpacity !== 0) {\n          underlayPadding = ele.pstyle('underlay-padding').value;\n        }\n      }\n\n      var padding = Math.max(overlayPadding, underlayPadding);\n      var w = 0;\n      var wHalf = 0;\n\n      if (styleEnabled) {\n        w = ele.pstyle('width').pfValue;\n        wHalf = w / 2;\n      }\n\n      if (isNode && options.includeNodes) {\n        var pos = ele.position();\n        x = pos.x;\n        y = pos.y;\n\n        var _w = ele.outerWidth();\n\n        var halfW = _w / 2;\n        var h = ele.outerHeight();\n        var halfH = h / 2; // handle node dimensions\n        /////////////////////////\n\n        ex1 = x - halfW;\n        ex2 = x + halfW;\n        ey1 = y - halfH;\n        ey2 = y + halfH;\n        updateBounds(bounds, ex1, ey1, ex2, ey2);\n      } else if (isEdge && options.includeEdges) {\n        if (styleEnabled && !headless) {\n          var curveStyle = ele.pstyle('curve-style').strValue; // handle edge dimensions (rough box estimate)\n          //////////////////////////////////////////////\n\n          ex1 = Math.min(rstyle.srcX, rstyle.midX, rstyle.tgtX);\n          ex2 = Math.max(rstyle.srcX, rstyle.midX, rstyle.tgtX);\n          ey1 = Math.min(rstyle.srcY, rstyle.midY, rstyle.tgtY);\n          ey2 = Math.max(rstyle.srcY, rstyle.midY, rstyle.tgtY); // take into account edge width\n\n          ex1 -= wHalf;\n          ex2 += wHalf;\n          ey1 -= wHalf;\n          ey2 += wHalf;\n          updateBounds(bounds, ex1, ey1, ex2, ey2); // precise edges\n          ////////////////\n\n          if (curveStyle === 'haystack') {\n            var hpts = rstyle.haystackPts;\n\n            if (hpts && hpts.length === 2) {\n              ex1 = hpts[0].x;\n              ey1 = hpts[0].y;\n              ex2 = hpts[1].x;\n              ey2 = hpts[1].y;\n\n              if (ex1 > ex2) {\n                var temp = ex1;\n                ex1 = ex2;\n                ex2 = temp;\n              }\n\n              if (ey1 > ey2) {\n                var _temp = ey1;\n                ey1 = ey2;\n                ey2 = _temp;\n              }\n\n              updateBounds(bounds, ex1 - wHalf, ey1 - wHalf, ex2 + wHalf, ey2 + wHalf);\n            }\n          } else if (curveStyle === 'bezier' || curveStyle === 'unbundled-bezier' || curveStyle === 'segments' || curveStyle === 'taxi') {\n            var pts;\n\n            switch (curveStyle) {\n              case 'bezier':\n              case 'unbundled-bezier':\n                pts = rstyle.bezierPts;\n                break;\n\n              case 'segments':\n              case 'taxi':\n                pts = rstyle.linePts;\n                break;\n            }\n\n            if (pts != null) {\n              for (var j = 0; j < pts.length; j++) {\n                var pt = pts[j];\n                ex1 = pt.x - wHalf;\n                ex2 = pt.x + wHalf;\n                ey1 = pt.y - wHalf;\n                ey2 = pt.y + wHalf;\n                updateBounds(bounds, ex1, ey1, ex2, ey2);\n              }\n            }\n          } // bezier-like or segment-like edge\n\n        } else {\n          // headless or style disabled\n          // fallback on source and target positions\n          //////////////////////////////////////////\n          var n1 = ele.source();\n          var n1pos = n1.position();\n          var n2 = ele.target();\n          var n2pos = n2.position();\n          ex1 = n1pos.x;\n          ex2 = n2pos.x;\n          ey1 = n1pos.y;\n          ey2 = n2pos.y;\n\n          if (ex1 > ex2) {\n            var _temp2 = ex1;\n            ex1 = ex2;\n            ex2 = _temp2;\n          }\n\n          if (ey1 > ey2) {\n            var _temp3 = ey1;\n            ey1 = ey2;\n            ey2 = _temp3;\n          } // take into account edge width\n\n\n          ex1 -= wHalf;\n          ex2 += wHalf;\n          ey1 -= wHalf;\n          ey2 += wHalf;\n          updateBounds(bounds, ex1, ey1, ex2, ey2);\n        } // headless or style disabled\n\n      } // edges\n      // handle edge arrow size\n      /////////////////////////\n\n\n      if (styleEnabled && options.includeEdges && isEdge) {\n        updateBoundsFromArrow(bounds, ele, 'mid-source');\n        updateBoundsFromArrow(bounds, ele, 'mid-target');\n        updateBoundsFromArrow(bounds, ele, 'source');\n        updateBoundsFromArrow(bounds, ele, 'target');\n      } // ghost\n      ////////\n\n\n      if (styleEnabled) {\n        var ghost = ele.pstyle('ghost').value === 'yes';\n\n        if (ghost) {\n          var gx = ele.pstyle('ghost-offset-x').pfValue;\n          var gy = ele.pstyle('ghost-offset-y').pfValue;\n          updateBounds(bounds, bounds.x1 + gx, bounds.y1 + gy, bounds.x2 + gx, bounds.y2 + gy);\n        }\n      } // always store the body bounds separately from the labels\n\n\n      var bbBody = _p.bodyBounds = _p.bodyBounds || {};\n      assignBoundingBox(bbBody, bounds);\n      expandBoundingBoxSides(bbBody, manualExpansion);\n      expandBoundingBox(bbBody, 1); // expand to work around browser dimension inaccuracies\n      // overlay\n      //////////\n\n      if (styleEnabled) {\n        ex1 = bounds.x1;\n        ex2 = bounds.x2;\n        ey1 = bounds.y1;\n        ey2 = bounds.y2;\n        updateBounds(bounds, ex1 - padding, ey1 - padding, ex2 + padding, ey2 + padding);\n      } // always store the body bounds separately from the labels\n\n\n      var bbOverlay = _p.overlayBounds = _p.overlayBounds || {};\n      assignBoundingBox(bbOverlay, bounds);\n      expandBoundingBoxSides(bbOverlay, manualExpansion);\n      expandBoundingBox(bbOverlay, 1); // expand to work around browser dimension inaccuracies\n      // handle label dimensions\n      //////////////////////////\n\n      var bbLabels = _p.labelBounds = _p.labelBounds || {};\n\n      if (bbLabels.all != null) {\n        clearBoundingBox(bbLabels.all);\n      } else {\n        bbLabels.all = makeBoundingBox();\n      }\n\n      if (styleEnabled && options.includeLabels) {\n        if (options.includeMainLabels) {\n          updateBoundsFromLabel(bounds, ele, null);\n        }\n\n        if (isEdge) {\n          if (options.includeSourceLabels) {\n            updateBoundsFromLabel(bounds, ele, 'source');\n          }\n\n          if (options.includeTargetLabels) {\n            updateBoundsFromLabel(bounds, ele, 'target');\n          }\n        }\n      } // style enabled for labels\n\n    } // if displayed\n\n\n    bounds.x1 = noninf(bounds.x1);\n    bounds.y1 = noninf(bounds.y1);\n    bounds.x2 = noninf(bounds.x2);\n    bounds.y2 = noninf(bounds.y2);\n    bounds.w = noninf(bounds.x2 - bounds.x1);\n    bounds.h = noninf(bounds.y2 - bounds.y1);\n\n    if (bounds.w > 0 && bounds.h > 0 && displayed) {\n      expandBoundingBoxSides(bounds, manualExpansion); // expand bounds by 1 because antialiasing can increase the visual/effective size by 1 on all sides\n\n      expandBoundingBox(bounds, 1);\n    }\n\n    return bounds;\n  };\n\n  var getKey = function getKey(opts) {\n    var i = 0;\n\n    var tf = function tf(val) {\n      return (val ? 1 : 0) << i++;\n    };\n\n    var key = 0;\n    key += tf(opts.incudeNodes);\n    key += tf(opts.includeEdges);\n    key += tf(opts.includeLabels);\n    key += tf(opts.includeMainLabels);\n    key += tf(opts.includeSourceLabels);\n    key += tf(opts.includeTargetLabels);\n    key += tf(opts.includeOverlays);\n    return key;\n  };\n\n  var getBoundingBoxPosKey = function getBoundingBoxPosKey(ele) {\n    if (ele.isEdge()) {\n      var p1 = ele.source().position();\n      var p2 = ele.target().position();\n\n      var r = function r(x) {\n        return Math.round(x);\n      };\n\n      return hashIntsArray([r(p1.x), r(p1.y), r(p2.x), r(p2.y)]);\n    } else {\n      return 0;\n    }\n  };\n\n  var cachedBoundingBoxImpl = function cachedBoundingBoxImpl(ele, opts) {\n    var _p = ele._private;\n    var bb;\n    var isEdge = ele.isEdge();\n    var key = opts == null ? defBbOptsKey : getKey(opts);\n    var usingDefOpts = key === defBbOptsKey;\n    var currPosKey = getBoundingBoxPosKey(ele);\n    var isPosKeySame = _p.bbCachePosKey === currPosKey;\n    var useCache = opts.useCache && isPosKeySame;\n\n    var isDirty = function isDirty(ele) {\n      return ele._private.bbCache == null || ele._private.styleDirty;\n    };\n\n    var needRecalc = !useCache || isDirty(ele) || isEdge && isDirty(ele.source()) || isDirty(ele.target());\n\n    if (needRecalc) {\n      if (!isPosKeySame) {\n        ele.recalculateRenderedStyle(useCache);\n      }\n\n      bb = boundingBoxImpl(ele, defBbOpts);\n      _p.bbCache = bb;\n      _p.bbCachePosKey = currPosKey;\n    } else {\n      bb = _p.bbCache;\n    } // not using def opts => need to build up bb from combination of sub bbs\n\n\n    if (!usingDefOpts) {\n      var isNode = ele.isNode();\n      bb = makeBoundingBox();\n\n      if (opts.includeNodes && isNode || opts.includeEdges && !isNode) {\n        if (opts.includeOverlays) {\n          updateBoundsFromBox(bb, _p.overlayBounds);\n        } else {\n          updateBoundsFromBox(bb, _p.bodyBounds);\n        }\n      }\n\n      if (opts.includeLabels) {\n        if (opts.includeMainLabels && (!isEdge || opts.includeSourceLabels && opts.includeTargetLabels)) {\n          updateBoundsFromBox(bb, _p.labelBounds.all);\n        } else {\n          if (opts.includeMainLabels) {\n            updateBoundsFromBox(bb, _p.labelBounds.mainRot);\n          }\n\n          if (opts.includeSourceLabels) {\n            updateBoundsFromBox(bb, _p.labelBounds.sourceRot);\n          }\n\n          if (opts.includeTargetLabels) {\n            updateBoundsFromBox(bb, _p.labelBounds.targetRot);\n          }\n        }\n      }\n\n      bb.w = bb.x2 - bb.x1;\n      bb.h = bb.y2 - bb.y1;\n    }\n\n    return bb;\n  };\n\n  var defBbOpts = {\n    includeNodes: true,\n    includeEdges: true,\n    includeLabels: true,\n    includeMainLabels: true,\n    includeSourceLabels: true,\n    includeTargetLabels: true,\n    includeOverlays: true,\n    includeUnderlays: true,\n    useCache: true\n  };\n  var defBbOptsKey = getKey(defBbOpts);\n  var filledBbOpts = defaults$g(defBbOpts);\n\n  elesfn$b.boundingBox = function (options) {\n    var bounds; // the main usecase is ele.boundingBox() for a single element with no/def options\n    // specified s.t. the cache is used, so check for this case to make it faster by\n    // avoiding the overhead of the rest of the function\n\n    if (this.length === 1 && this[0]._private.bbCache != null && !this[0]._private.styleDirty && (options === undefined || options.useCache === undefined || options.useCache === true)) {\n      if (options === undefined) {\n        options = defBbOpts;\n      } else {\n        options = filledBbOpts(options);\n      }\n\n      bounds = cachedBoundingBoxImpl(this[0], options);\n    } else {\n      bounds = makeBoundingBox();\n      options = options || defBbOpts;\n      var opts = filledBbOpts(options);\n      var eles = this;\n      var cy = eles.cy();\n      var styleEnabled = cy.styleEnabled();\n\n      if (styleEnabled) {\n        for (var i = 0; i < eles.length; i++) {\n          var ele = eles[i];\n          var _p = ele._private;\n          var currPosKey = getBoundingBoxPosKey(ele);\n          var isPosKeySame = _p.bbCachePosKey === currPosKey;\n          var useCache = opts.useCache && isPosKeySame && !_p.styleDirty;\n          ele.recalculateRenderedStyle(useCache);\n        }\n      }\n\n      this.updateCompoundBounds(!options.useCache);\n\n      for (var _i = 0; _i < eles.length; _i++) {\n        var _ele = eles[_i];\n        updateBoundsFromBox(bounds, cachedBoundingBoxImpl(_ele, opts));\n      }\n    }\n\n    bounds.x1 = noninf(bounds.x1);\n    bounds.y1 = noninf(bounds.y1);\n    bounds.x2 = noninf(bounds.x2);\n    bounds.y2 = noninf(bounds.y2);\n    bounds.w = noninf(bounds.x2 - bounds.x1);\n    bounds.h = noninf(bounds.y2 - bounds.y1);\n    return bounds;\n  };\n\n  elesfn$b.dirtyBoundingBoxCache = function () {\n    for (var i = 0; i < this.length; i++) {\n      var _p = this[i]._private;\n      _p.bbCache = null;\n      _p.bbCachePosKey = null;\n      _p.bodyBounds = null;\n      _p.overlayBounds = null;\n      _p.labelBounds.all = null;\n      _p.labelBounds.source = null;\n      _p.labelBounds.target = null;\n      _p.labelBounds.main = null;\n      _p.labelBounds.sourceRot = null;\n      _p.labelBounds.targetRot = null;\n      _p.labelBounds.mainRot = null;\n      _p.arrowBounds.source = null;\n      _p.arrowBounds.target = null;\n      _p.arrowBounds['mid-source'] = null;\n      _p.arrowBounds['mid-target'] = null;\n    }\n\n    this.emitAndNotify('bounds');\n    return this;\n  }; // private helper to get bounding box for custom node positions\n  // - good for perf in certain cases but currently requires dirtying the rendered style\n  // - would be better to not modify the nodes but the nodes are read directly everywhere in the renderer...\n  // - try to use for only things like discrete layouts where the node position would change anyway\n\n\n  elesfn$b.boundingBoxAt = function (fn) {\n    var nodes = this.nodes();\n    var cy = this.cy();\n    var hasCompoundNodes = cy.hasCompoundNodes();\n    var parents = cy.collection();\n\n    if (hasCompoundNodes) {\n      parents = nodes.filter(function (node) {\n        return node.isParent();\n      });\n      nodes = nodes.not(parents);\n    }\n\n    if (plainObject(fn)) {\n      var obj = fn;\n\n      fn = function fn() {\n        return obj;\n      };\n    }\n\n    var storeOldPos = function storeOldPos(node, i) {\n      return node._private.bbAtOldPos = fn(node, i);\n    };\n\n    var getOldPos = function getOldPos(node) {\n      return node._private.bbAtOldPos;\n    };\n\n    cy.startBatch();\n    nodes.forEach(storeOldPos).silentPositions(fn);\n\n    if (hasCompoundNodes) {\n      parents.dirtyCompoundBoundsCache();\n      parents.dirtyBoundingBoxCache();\n      parents.updateCompoundBounds(true); // force update b/c we're inside a batch cycle\n    }\n\n    var bb = copyBoundingBox(this.boundingBox({\n      useCache: false\n    }));\n    nodes.silentPositions(getOldPos);\n\n    if (hasCompoundNodes) {\n      parents.dirtyCompoundBoundsCache();\n      parents.dirtyBoundingBoxCache();\n      parents.updateCompoundBounds(true); // force update b/c we're inside a batch cycle\n    }\n\n    cy.endBatch();\n    return bb;\n  };\n\n  fn$3.boundingbox = fn$3.bb = fn$3.boundingBox;\n  fn$3.renderedBoundingbox = fn$3.renderedBoundingBox;\n  var bounds = elesfn$b;\n\n  var fn$2, elesfn$a;\n  fn$2 = elesfn$a = {};\n\n  var defineDimFns = function defineDimFns(opts) {\n    opts.uppercaseName = capitalize(opts.name);\n    opts.autoName = 'auto' + opts.uppercaseName;\n    opts.labelName = 'label' + opts.uppercaseName;\n    opts.outerName = 'outer' + opts.uppercaseName;\n    opts.uppercaseOuterName = capitalize(opts.outerName);\n\n    fn$2[opts.name] = function dimImpl() {\n      var ele = this[0];\n      var _p = ele._private;\n      var cy = _p.cy;\n      var styleEnabled = cy._private.styleEnabled;\n\n      if (ele) {\n        if (styleEnabled) {\n          if (ele.isParent()) {\n            ele.updateCompoundBounds();\n            return _p[opts.autoName] || 0;\n          }\n\n          var d = ele.pstyle(opts.name);\n\n          switch (d.strValue) {\n            case 'label':\n              ele.recalculateRenderedStyle();\n              return _p.rstyle[opts.labelName] || 0;\n\n            default:\n              return d.pfValue;\n          }\n        } else {\n          return 1;\n        }\n      }\n    };\n\n    fn$2['outer' + opts.uppercaseName] = function outerDimImpl() {\n      var ele = this[0];\n      var _p = ele._private;\n      var cy = _p.cy;\n      var styleEnabled = cy._private.styleEnabled;\n\n      if (ele) {\n        if (styleEnabled) {\n          var dim = ele[opts.name]();\n          var border = ele.pstyle('border-width').pfValue; // n.b. 1/2 each side\n\n          var padding = 2 * ele.padding();\n          return dim + border + padding;\n        } else {\n          return 1;\n        }\n      }\n    };\n\n    fn$2['rendered' + opts.uppercaseName] = function renderedDimImpl() {\n      var ele = this[0];\n\n      if (ele) {\n        var d = ele[opts.name]();\n        return d * this.cy().zoom();\n      }\n    };\n\n    fn$2['rendered' + opts.uppercaseOuterName] = function renderedOuterDimImpl() {\n      var ele = this[0];\n\n      if (ele) {\n        var od = ele[opts.outerName]();\n        return od * this.cy().zoom();\n      }\n    };\n  };\n\n  defineDimFns({\n    name: 'width'\n  });\n  defineDimFns({\n    name: 'height'\n  });\n\n  elesfn$a.padding = function () {\n    var ele = this[0];\n    var _p = ele._private;\n\n    if (ele.isParent()) {\n      ele.updateCompoundBounds();\n\n      if (_p.autoPadding !== undefined) {\n        return _p.autoPadding;\n      } else {\n        return ele.pstyle('padding').pfValue;\n      }\n    } else {\n      return ele.pstyle('padding').pfValue;\n    }\n  };\n\n  elesfn$a.paddedHeight = function () {\n    var ele = this[0];\n    return ele.height() + 2 * ele.padding();\n  };\n\n  elesfn$a.paddedWidth = function () {\n    var ele = this[0];\n    return ele.width() + 2 * ele.padding();\n  };\n\n  var widthHeight = elesfn$a;\n\n  var ifEdge = function ifEdge(ele, getValue) {\n    if (ele.isEdge()) {\n      return getValue(ele);\n    }\n  };\n\n  var ifEdgeRenderedPosition = function ifEdgeRenderedPosition(ele, getPoint) {\n    if (ele.isEdge()) {\n      var cy = ele.cy();\n      return modelToRenderedPosition(getPoint(ele), cy.zoom(), cy.pan());\n    }\n  };\n\n  var ifEdgeRenderedPositions = function ifEdgeRenderedPositions(ele, getPoints) {\n    if (ele.isEdge()) {\n      var cy = ele.cy();\n      var pan = cy.pan();\n      var zoom = cy.zoom();\n      return getPoints(ele).map(function (p) {\n        return modelToRenderedPosition(p, zoom, pan);\n      });\n    }\n  };\n\n  var controlPoints = function controlPoints(ele) {\n    return ele.renderer().getControlPoints(ele);\n  };\n\n  var segmentPoints = function segmentPoints(ele) {\n    return ele.renderer().getSegmentPoints(ele);\n  };\n\n  var sourceEndpoint = function sourceEndpoint(ele) {\n    return ele.renderer().getSourceEndpoint(ele);\n  };\n\n  var targetEndpoint = function targetEndpoint(ele) {\n    return ele.renderer().getTargetEndpoint(ele);\n  };\n\n  var midpoint = function midpoint(ele) {\n    return ele.renderer().getEdgeMidpoint(ele);\n  };\n\n  var pts = {\n    controlPoints: {\n      get: controlPoints,\n      mult: true\n    },\n    segmentPoints: {\n      get: segmentPoints,\n      mult: true\n    },\n    sourceEndpoint: {\n      get: sourceEndpoint\n    },\n    targetEndpoint: {\n      get: targetEndpoint\n    },\n    midpoint: {\n      get: midpoint\n    }\n  };\n\n  var renderedName = function renderedName(name) {\n    return 'rendered' + name[0].toUpperCase() + name.substr(1);\n  };\n\n  var edgePoints = Object.keys(pts).reduce(function (obj, name) {\n    var spec = pts[name];\n    var rName = renderedName(name);\n\n    obj[name] = function () {\n      return ifEdge(this, spec.get);\n    };\n\n    if (spec.mult) {\n      obj[rName] = function () {\n        return ifEdgeRenderedPositions(this, spec.get);\n      };\n    } else {\n      obj[rName] = function () {\n        return ifEdgeRenderedPosition(this, spec.get);\n      };\n    }\n\n    return obj;\n  }, {});\n\n  var dimensions = extend({}, position, bounds, widthHeight, edgePoints);\n\n  /*!\n  Event object based on jQuery events, MIT license\n\n  https://jquery.org/license/\n  https://tldrlegal.com/license/mit-license\n  https://github.com/jquery/jquery/blob/master/src/event.js\n  */\n  var Event = function Event(src, props) {\n    this.recycle(src, props);\n  };\n\n  function returnFalse() {\n    return false;\n  }\n\n  function returnTrue() {\n    return true;\n  } // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\n\n\n  Event.prototype = {\n    instanceString: function instanceString() {\n      return 'event';\n    },\n    recycle: function recycle(src, props) {\n      this.isImmediatePropagationStopped = this.isPropagationStopped = this.isDefaultPrevented = returnFalse;\n\n      if (src != null && src.preventDefault) {\n        // Browser Event object\n        this.type = src.type; // Events bubbling up the document may have been marked as prevented\n        // by a handler lower down the tree; reflect the correct value.\n\n        this.isDefaultPrevented = src.defaultPrevented ? returnTrue : returnFalse;\n      } else if (src != null && src.type) {\n        // Plain object containing all event details\n        props = src;\n      } else {\n        // Event string\n        this.type = src;\n      } // Put explicitly provided properties onto the event object\n\n\n      if (props != null) {\n        // more efficient to manually copy fields we use\n        this.originalEvent = props.originalEvent;\n        this.type = props.type != null ? props.type : this.type;\n        this.cy = props.cy;\n        this.target = props.target;\n        this.position = props.position;\n        this.renderedPosition = props.renderedPosition;\n        this.namespace = props.namespace;\n        this.layout = props.layout;\n      }\n\n      if (this.cy != null && this.position != null && this.renderedPosition == null) {\n        // create a rendered position based on the passed position\n        var pos = this.position;\n        var zoom = this.cy.zoom();\n        var pan = this.cy.pan();\n        this.renderedPosition = {\n          x: pos.x * zoom + pan.x,\n          y: pos.y * zoom + pan.y\n        };\n      } // Create a timestamp if incoming event doesn't have one\n\n\n      this.timeStamp = src && src.timeStamp || Date.now();\n    },\n    preventDefault: function preventDefault() {\n      this.isDefaultPrevented = returnTrue;\n      var e = this.originalEvent;\n\n      if (!e) {\n        return;\n      } // if preventDefault exists run it on the original event\n\n\n      if (e.preventDefault) {\n        e.preventDefault();\n      }\n    },\n    stopPropagation: function stopPropagation() {\n      this.isPropagationStopped = returnTrue;\n      var e = this.originalEvent;\n\n      if (!e) {\n        return;\n      } // if stopPropagation exists run it on the original event\n\n\n      if (e.stopPropagation) {\n        e.stopPropagation();\n      }\n    },\n    stopImmediatePropagation: function stopImmediatePropagation() {\n      this.isImmediatePropagationStopped = returnTrue;\n      this.stopPropagation();\n    },\n    isDefaultPrevented: returnFalse,\n    isPropagationStopped: returnFalse,\n    isImmediatePropagationStopped: returnFalse\n  };\n\n  var eventRegex = /^([^.]+)(\\.(?:[^.]+))?$/; // regex for matching event strings (e.g. \"click.namespace\")\n\n  var universalNamespace = '.*'; // matches as if no namespace specified and prevents users from unbinding accidentally\n\n  var defaults$8 = {\n    qualifierCompare: function qualifierCompare(q1, q2) {\n      return q1 === q2;\n    },\n    eventMatches: function\n      /*context, listener, eventObj*/\n    eventMatches() {\n      return true;\n    },\n    addEventFields: function\n      /*context, evt*/\n    addEventFields() {},\n    callbackContext: function callbackContext(context\n    /*, listener, eventObj*/\n    ) {\n      return context;\n    },\n    beforeEmit: function\n      /* context, listener, eventObj */\n    beforeEmit() {},\n    afterEmit: function\n      /* context, listener, eventObj */\n    afterEmit() {},\n    bubble: function\n      /*context*/\n    bubble() {\n      return false;\n    },\n    parent: function\n      /*context*/\n    parent() {\n      return null;\n    },\n    context: null\n  };\n  var defaultsKeys = Object.keys(defaults$8);\n  var emptyOpts = {};\n\n  function Emitter() {\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : emptyOpts;\n    var context = arguments.length > 1 ? arguments[1] : undefined;\n\n    // micro-optimisation vs Object.assign() -- reduces Element instantiation time\n    for (var i = 0; i < defaultsKeys.length; i++) {\n      var key = defaultsKeys[i];\n      this[key] = opts[key] || defaults$8[key];\n    }\n\n    this.context = context || this.context;\n    this.listeners = [];\n    this.emitting = 0;\n  }\n\n  var p = Emitter.prototype;\n\n  var forEachEvent = function forEachEvent(self, handler, events, qualifier, callback, conf, confOverrides) {\n    if (fn$6(qualifier)) {\n      callback = qualifier;\n      qualifier = null;\n    }\n\n    if (confOverrides) {\n      if (conf == null) {\n        conf = confOverrides;\n      } else {\n        conf = extend({}, conf, confOverrides);\n      }\n    }\n\n    var eventList = array(events) ? events : events.split(/\\s+/);\n\n    for (var i = 0; i < eventList.length; i++) {\n      var evt = eventList[i];\n\n      if (emptyString(evt)) {\n        continue;\n      }\n\n      var match = evt.match(eventRegex); // type[.namespace]\n\n      if (match) {\n        var type = match[1];\n        var namespace = match[2] ? match[2] : null;\n        var ret = handler(self, evt, type, namespace, qualifier, callback, conf);\n\n        if (ret === false) {\n          break;\n        } // allow exiting early\n\n      }\n    }\n  };\n\n  var makeEventObj = function makeEventObj(self, obj) {\n    self.addEventFields(self.context, obj);\n    return new Event(obj.type, obj);\n  };\n\n  var forEachEventObj = function forEachEventObj(self, handler, events) {\n    if (event(events)) {\n      handler(self, events);\n      return;\n    } else if (plainObject(events)) {\n      handler(self, makeEventObj(self, events));\n      return;\n    }\n\n    var eventList = array(events) ? events : events.split(/\\s+/);\n\n    for (var i = 0; i < eventList.length; i++) {\n      var evt = eventList[i];\n\n      if (emptyString(evt)) {\n        continue;\n      }\n\n      var match = evt.match(eventRegex); // type[.namespace]\n\n      if (match) {\n        var type = match[1];\n        var namespace = match[2] ? match[2] : null;\n        var eventObj = makeEventObj(self, {\n          type: type,\n          namespace: namespace,\n          target: self.context\n        });\n        handler(self, eventObj);\n      }\n    }\n  };\n\n  p.on = p.addListener = function (events, qualifier, callback, conf, confOverrides) {\n    forEachEvent(this, function (self, event, type, namespace, qualifier, callback, conf) {\n      if (fn$6(callback)) {\n        self.listeners.push({\n          event: event,\n          // full event string\n          callback: callback,\n          // callback to run\n          type: type,\n          // the event type (e.g. 'click')\n          namespace: namespace,\n          // the event namespace (e.g. \".foo\")\n          qualifier: qualifier,\n          // a restriction on whether to match this emitter\n          conf: conf // additional configuration\n\n        });\n      }\n    }, events, qualifier, callback, conf, confOverrides);\n    return this;\n  };\n\n  p.one = function (events, qualifier, callback, conf) {\n    return this.on(events, qualifier, callback, conf, {\n      one: true\n    });\n  };\n\n  p.removeListener = p.off = function (events, qualifier, callback, conf) {\n    var _this = this;\n\n    if (this.emitting !== 0) {\n      this.listeners = copyArray$1(this.listeners);\n    }\n\n    var listeners = this.listeners;\n\n    var _loop = function _loop(i) {\n      var listener = listeners[i];\n      forEachEvent(_this, function (self, event, type, namespace, qualifier, callback\n      /*, conf*/\n      ) {\n        if ((listener.type === type || events === '*') && (!namespace && listener.namespace !== '.*' || listener.namespace === namespace) && (!qualifier || self.qualifierCompare(listener.qualifier, qualifier)) && (!callback || listener.callback === callback)) {\n          listeners.splice(i, 1);\n          return false;\n        }\n      }, events, qualifier, callback, conf);\n    };\n\n    for (var i = listeners.length - 1; i >= 0; i--) {\n      _loop(i);\n    }\n\n    return this;\n  };\n\n  p.removeAllListeners = function () {\n    return this.removeListener('*');\n  };\n\n  p.emit = p.trigger = function (events, extraParams, manualCallback) {\n    var listeners = this.listeners;\n    var numListenersBeforeEmit = listeners.length;\n    this.emitting++;\n\n    if (!array(extraParams)) {\n      extraParams = [extraParams];\n    }\n\n    forEachEventObj(this, function (self, eventObj) {\n      if (manualCallback != null) {\n        listeners = [{\n          event: eventObj.event,\n          type: eventObj.type,\n          namespace: eventObj.namespace,\n          callback: manualCallback\n        }];\n        numListenersBeforeEmit = listeners.length;\n      }\n\n      var _loop2 = function _loop2(i) {\n        var listener = listeners[i];\n\n        if (listener.type === eventObj.type && (!listener.namespace || listener.namespace === eventObj.namespace || listener.namespace === universalNamespace) && self.eventMatches(self.context, listener, eventObj)) {\n          var args = [eventObj];\n\n          if (extraParams != null) {\n            push(args, extraParams);\n          }\n\n          self.beforeEmit(self.context, listener, eventObj);\n\n          if (listener.conf && listener.conf.one) {\n            self.listeners = self.listeners.filter(function (l) {\n              return l !== listener;\n            });\n          }\n\n          var context = self.callbackContext(self.context, listener, eventObj);\n          var ret = listener.callback.apply(context, args);\n          self.afterEmit(self.context, listener, eventObj);\n\n          if (ret === false) {\n            eventObj.stopPropagation();\n            eventObj.preventDefault();\n          }\n        } // if listener matches\n\n      };\n\n      for (var i = 0; i < numListenersBeforeEmit; i++) {\n        _loop2(i);\n      } // for listener\n\n\n      if (self.bubble(self.context) && !eventObj.isPropagationStopped()) {\n        self.parent(self.context).emit(eventObj, extraParams);\n      }\n    }, events);\n    this.emitting--;\n    return this;\n  };\n\n  var emitterOptions$1 = {\n    qualifierCompare: function qualifierCompare(selector1, selector2) {\n      if (selector1 == null || selector2 == null) {\n        return selector1 == null && selector2 == null;\n      } else {\n        return selector1.sameText(selector2);\n      }\n    },\n    eventMatches: function eventMatches(ele, listener, eventObj) {\n      var selector = listener.qualifier;\n\n      if (selector != null) {\n        return ele !== eventObj.target && element(eventObj.target) && selector.matches(eventObj.target);\n      }\n\n      return true;\n    },\n    addEventFields: function addEventFields(ele, evt) {\n      evt.cy = ele.cy();\n      evt.target = ele;\n    },\n    callbackContext: function callbackContext(ele, listener, eventObj) {\n      return listener.qualifier != null ? eventObj.target : ele;\n    },\n    beforeEmit: function beforeEmit(context, listener\n    /*, eventObj*/\n    ) {\n      if (listener.conf && listener.conf.once) {\n        listener.conf.onceCollection.removeListener(listener.event, listener.qualifier, listener.callback);\n      }\n    },\n    bubble: function bubble() {\n      return true;\n    },\n    parent: function parent(ele) {\n      return ele.isChild() ? ele.parent() : ele.cy();\n    }\n  };\n\n  var argSelector$1 = function argSelector(arg) {\n    if (string(arg)) {\n      return new Selector(arg);\n    } else {\n      return arg;\n    }\n  };\n\n  var elesfn$9 = {\n    createEmitter: function createEmitter() {\n      for (var i = 0; i < this.length; i++) {\n        var ele = this[i];\n        var _p = ele._private;\n\n        if (!_p.emitter) {\n          _p.emitter = new Emitter(emitterOptions$1, ele);\n        }\n      }\n\n      return this;\n    },\n    emitter: function emitter() {\n      return this._private.emitter;\n    },\n    on: function on(events, selector, callback) {\n      var argSel = argSelector$1(selector);\n\n      for (var i = 0; i < this.length; i++) {\n        var ele = this[i];\n        ele.emitter().on(events, argSel, callback);\n      }\n\n      return this;\n    },\n    removeListener: function removeListener(events, selector, callback) {\n      var argSel = argSelector$1(selector);\n\n      for (var i = 0; i < this.length; i++) {\n        var ele = this[i];\n        ele.emitter().removeListener(events, argSel, callback);\n      }\n\n      return this;\n    },\n    removeAllListeners: function removeAllListeners() {\n      for (var i = 0; i < this.length; i++) {\n        var ele = this[i];\n        ele.emitter().removeAllListeners();\n      }\n\n      return this;\n    },\n    one: function one(events, selector, callback) {\n      var argSel = argSelector$1(selector);\n\n      for (var i = 0; i < this.length; i++) {\n        var ele = this[i];\n        ele.emitter().one(events, argSel, callback);\n      }\n\n      return this;\n    },\n    once: function once(events, selector, callback) {\n      var argSel = argSelector$1(selector);\n\n      for (var i = 0; i < this.length; i++) {\n        var ele = this[i];\n        ele.emitter().on(events, argSel, callback, {\n          once: true,\n          onceCollection: this\n        });\n      }\n    },\n    emit: function emit(events, extraParams) {\n      for (var i = 0; i < this.length; i++) {\n        var ele = this[i];\n        ele.emitter().emit(events, extraParams);\n      }\n\n      return this;\n    },\n    emitAndNotify: function emitAndNotify(event, extraParams) {\n      // for internal use only\n      if (this.length === 0) {\n        return;\n      } // empty collections don't need to notify anything\n      // notify renderer\n\n\n      this.cy().notify(event, this);\n      this.emit(event, extraParams);\n      return this;\n    }\n  };\n  define.eventAliasesOn(elesfn$9);\n\n  var elesfn$8 = {\n    nodes: function nodes(selector) {\n      return this.filter(function (ele) {\n        return ele.isNode();\n      }).filter(selector);\n    },\n    edges: function edges(selector) {\n      return this.filter(function (ele) {\n        return ele.isEdge();\n      }).filter(selector);\n    },\n    // internal helper to get nodes and edges as separate collections with single iteration over elements\n    byGroup: function byGroup() {\n      var nodes = this.spawn();\n      var edges = this.spawn();\n\n      for (var i = 0; i < this.length; i++) {\n        var ele = this[i];\n\n        if (ele.isNode()) {\n          nodes.push(ele);\n        } else {\n          edges.push(ele);\n        }\n      }\n\n      return {\n        nodes: nodes,\n        edges: edges\n      };\n    },\n    filter: function filter(_filter, thisArg) {\n      if (_filter === undefined) {\n        // check this first b/c it's the most common/performant case\n        return this;\n      } else if (string(_filter) || elementOrCollection(_filter)) {\n        return new Selector(_filter).filter(this);\n      } else if (fn$6(_filter)) {\n        var filterEles = this.spawn();\n        var eles = this;\n\n        for (var i = 0; i < eles.length; i++) {\n          var ele = eles[i];\n          var include = thisArg ? _filter.apply(thisArg, [ele, i, eles]) : _filter(ele, i, eles);\n\n          if (include) {\n            filterEles.push(ele);\n          }\n        }\n\n        return filterEles;\n      }\n\n      return this.spawn(); // if not handled by above, give 'em an empty collection\n    },\n    not: function not(toRemove) {\n      if (!toRemove) {\n        return this;\n      } else {\n        if (string(toRemove)) {\n          toRemove = this.filter(toRemove);\n        }\n\n        var elements = this.spawn();\n\n        for (var i = 0; i < this.length; i++) {\n          var element = this[i];\n          var remove = toRemove.has(element);\n\n          if (!remove) {\n            elements.push(element);\n          }\n        }\n\n        return elements;\n      }\n    },\n    absoluteComplement: function absoluteComplement() {\n      var cy = this.cy();\n      return cy.mutableElements().not(this);\n    },\n    intersect: function intersect(other) {\n      // if a selector is specified, then filter by it instead\n      if (string(other)) {\n        var selector = other;\n        return this.filter(selector);\n      }\n\n      var elements = this.spawn();\n      var col1 = this;\n      var col2 = other;\n      var col1Smaller = this.length < other.length;\n      var colS = col1Smaller ? col1 : col2;\n      var colL = col1Smaller ? col2 : col1;\n\n      for (var i = 0; i < colS.length; i++) {\n        var ele = colS[i];\n\n        if (colL.has(ele)) {\n          elements.push(ele);\n        }\n      }\n\n      return elements;\n    },\n    xor: function xor(other) {\n      var cy = this._private.cy;\n\n      if (string(other)) {\n        other = cy.$(other);\n      }\n\n      var elements = this.spawn();\n      var col1 = this;\n      var col2 = other;\n\n      var add = function add(col, other) {\n        for (var i = 0; i < col.length; i++) {\n          var ele = col[i];\n          var id = ele._private.data.id;\n          var inOther = other.hasElementWithId(id);\n\n          if (!inOther) {\n            elements.push(ele);\n          }\n        }\n      };\n\n      add(col1, col2);\n      add(col2, col1);\n      return elements;\n    },\n    diff: function diff(other) {\n      var cy = this._private.cy;\n\n      if (string(other)) {\n        other = cy.$(other);\n      }\n\n      var left = this.spawn();\n      var right = this.spawn();\n      var both = this.spawn();\n      var col1 = this;\n      var col2 = other;\n\n      var add = function add(col, other, retEles) {\n        for (var i = 0; i < col.length; i++) {\n          var ele = col[i];\n          var id = ele._private.data.id;\n          var inOther = other.hasElementWithId(id);\n\n          if (inOther) {\n            both.merge(ele);\n          } else {\n            retEles.push(ele);\n          }\n        }\n      };\n\n      add(col1, col2, left);\n      add(col2, col1, right);\n      return {\n        left: left,\n        right: right,\n        both: both\n      };\n    },\n    add: function add(toAdd) {\n      var cy = this._private.cy;\n\n      if (!toAdd) {\n        return this;\n      }\n\n      if (string(toAdd)) {\n        var selector = toAdd;\n        toAdd = cy.mutableElements().filter(selector);\n      }\n\n      var elements = this.spawnSelf();\n\n      for (var i = 0; i < toAdd.length; i++) {\n        var ele = toAdd[i];\n        var add = !this.has(ele);\n\n        if (add) {\n          elements.push(ele);\n        }\n      }\n\n      return elements;\n    },\n    // in place merge on calling collection\n    merge: function merge(toAdd) {\n      var _p = this._private;\n      var cy = _p.cy;\n\n      if (!toAdd) {\n        return this;\n      }\n\n      if (toAdd && string(toAdd)) {\n        var selector = toAdd;\n        toAdd = cy.mutableElements().filter(selector);\n      }\n\n      var map = _p.map;\n\n      for (var i = 0; i < toAdd.length; i++) {\n        var toAddEle = toAdd[i];\n        var id = toAddEle._private.data.id;\n        var add = !map.has(id);\n\n        if (add) {\n          var index = this.length++;\n          this[index] = toAddEle;\n          map.set(id, {\n            ele: toAddEle,\n            index: index\n          });\n        }\n      }\n\n      return this; // chaining\n    },\n    unmergeAt: function unmergeAt(i) {\n      var ele = this[i];\n      var id = ele.id();\n      var _p = this._private;\n      var map = _p.map; // remove ele\n\n      this[i] = undefined;\n      map[\"delete\"](id);\n      var unmergedLastEle = i === this.length - 1; // replace empty spot with last ele in collection\n\n      if (this.length > 1 && !unmergedLastEle) {\n        var lastEleI = this.length - 1;\n        var lastEle = this[lastEleI];\n        var lastEleId = lastEle._private.data.id;\n        this[lastEleI] = undefined;\n        this[i] = lastEle;\n        map.set(lastEleId, {\n          ele: lastEle,\n          index: i\n        });\n      } // the collection is now 1 ele smaller\n\n\n      this.length--;\n      return this;\n    },\n    // remove single ele in place in calling collection\n    unmergeOne: function unmergeOne(ele) {\n      ele = ele[0];\n      var _p = this._private;\n      var id = ele._private.data.id;\n      var map = _p.map;\n      var entry = map.get(id);\n\n      if (!entry) {\n        return this; // no need to remove\n      }\n\n      var i = entry.index;\n      this.unmergeAt(i);\n      return this;\n    },\n    // remove eles in place on calling collection\n    unmerge: function unmerge(toRemove) {\n      var cy = this._private.cy;\n\n      if (!toRemove) {\n        return this;\n      }\n\n      if (toRemove && string(toRemove)) {\n        var selector = toRemove;\n        toRemove = cy.mutableElements().filter(selector);\n      }\n\n      for (var i = 0; i < toRemove.length; i++) {\n        this.unmergeOne(toRemove[i]);\n      }\n\n      return this; // chaining\n    },\n    unmergeBy: function unmergeBy(toRmFn) {\n      for (var i = this.length - 1; i >= 0; i--) {\n        var ele = this[i];\n\n        if (toRmFn(ele)) {\n          this.unmergeAt(i);\n        }\n      }\n\n      return this;\n    },\n    map: function map(mapFn, thisArg) {\n      var arr = [];\n      var eles = this;\n\n      for (var i = 0; i < eles.length; i++) {\n        var ele = eles[i];\n        var ret = thisArg ? mapFn.apply(thisArg, [ele, i, eles]) : mapFn(ele, i, eles);\n        arr.push(ret);\n      }\n\n      return arr;\n    },\n    reduce: function reduce(fn, initialValue) {\n      var val = initialValue;\n      var eles = this;\n\n      for (var i = 0; i < eles.length; i++) {\n        val = fn(val, eles[i], i, eles);\n      }\n\n      return val;\n    },\n    max: function max(valFn, thisArg) {\n      var max = -Infinity;\n      var maxEle;\n      var eles = this;\n\n      for (var i = 0; i < eles.length; i++) {\n        var ele = eles[i];\n        var val = thisArg ? valFn.apply(thisArg, [ele, i, eles]) : valFn(ele, i, eles);\n\n        if (val > max) {\n          max = val;\n          maxEle = ele;\n        }\n      }\n\n      return {\n        value: max,\n        ele: maxEle\n      };\n    },\n    min: function min(valFn, thisArg) {\n      var min = Infinity;\n      var minEle;\n      var eles = this;\n\n      for (var i = 0; i < eles.length; i++) {\n        var ele = eles[i];\n        var val = thisArg ? valFn.apply(thisArg, [ele, i, eles]) : valFn(ele, i, eles);\n\n        if (val < min) {\n          min = val;\n          minEle = ele;\n        }\n      }\n\n      return {\n        value: min,\n        ele: minEle\n      };\n    }\n  }; // aliases\n\n  var fn$1 = elesfn$8;\n  fn$1['u'] = fn$1['|'] = fn$1['+'] = fn$1.union = fn$1.or = fn$1.add;\n  fn$1['\\\\'] = fn$1['!'] = fn$1['-'] = fn$1.difference = fn$1.relativeComplement = fn$1.subtract = fn$1.not;\n  fn$1['n'] = fn$1['&'] = fn$1['.'] = fn$1.and = fn$1.intersection = fn$1.intersect;\n  fn$1['^'] = fn$1['(+)'] = fn$1['(-)'] = fn$1.symmetricDifference = fn$1.symdiff = fn$1.xor;\n  fn$1.fnFilter = fn$1.filterFn = fn$1.stdFilter = fn$1.filter;\n  fn$1.complement = fn$1.abscomp = fn$1.absoluteComplement;\n\n  var elesfn$7 = {\n    isNode: function isNode() {\n      return this.group() === 'nodes';\n    },\n    isEdge: function isEdge() {\n      return this.group() === 'edges';\n    },\n    isLoop: function isLoop() {\n      return this.isEdge() && this.source()[0] === this.target()[0];\n    },\n    isSimple: function isSimple() {\n      return this.isEdge() && this.source()[0] !== this.target()[0];\n    },\n    group: function group() {\n      var ele = this[0];\n\n      if (ele) {\n        return ele._private.group;\n      }\n    }\n  };\n\n  /**\n   *  Elements are drawn in a specific order based on compound depth (low to high), the element type (nodes above edges),\n   *  and z-index (low to high).  These styles affect how this applies:\n   *\n   *  z-compound-depth: May be `bottom | orphan | auto | top`.  The first drawn is `bottom`, then `orphan` which is the\n   *      same depth as the root of the compound graph, followed by the default value `auto` which draws in order from\n   *      root to leaves of the compound graph.  The last drawn is `top`.\n   *  z-index-compare: May be `auto | manual`.  The default value is `auto` which always draws edges under nodes.\n   *      `manual` ignores this convention and draws based on the `z-index` value setting.\n   *  z-index: An integer value that affects the relative draw order of elements.  In general, an element with a higher\n   *      `z-index` will be drawn on top of an element with a lower `z-index`.\n   */\n\n  var zIndexSort = function zIndexSort(a, b) {\n    var cy = a.cy();\n    var hasCompoundNodes = cy.hasCompoundNodes();\n\n    function getDepth(ele) {\n      var style = ele.pstyle('z-compound-depth');\n\n      if (style.value === 'auto') {\n        return hasCompoundNodes ? ele.zDepth() : 0;\n      } else if (style.value === 'bottom') {\n        return -1;\n      } else if (style.value === 'top') {\n        return MAX_INT$1;\n      } // 'orphan'\n\n\n      return 0;\n    }\n\n    var depthDiff = getDepth(a) - getDepth(b);\n\n    if (depthDiff !== 0) {\n      return depthDiff;\n    }\n\n    function getEleDepth(ele) {\n      var style = ele.pstyle('z-index-compare');\n\n      if (style.value === 'auto') {\n        return ele.isNode() ? 1 : 0;\n      } // 'manual'\n\n\n      return 0;\n    }\n\n    var eleDiff = getEleDepth(a) - getEleDepth(b);\n\n    if (eleDiff !== 0) {\n      return eleDiff;\n    }\n\n    var zDiff = a.pstyle('z-index').value - b.pstyle('z-index').value;\n\n    if (zDiff !== 0) {\n      return zDiff;\n    } // compare indices in the core (order added to graph w/ last on top)\n\n\n    return a.poolIndex() - b.poolIndex();\n  };\n\n  var elesfn$6 = {\n    forEach: function forEach(fn, thisArg) {\n      if (fn$6(fn)) {\n        var N = this.length;\n\n        for (var i = 0; i < N; i++) {\n          var ele = this[i];\n          var ret = thisArg ? fn.apply(thisArg, [ele, i, this]) : fn(ele, i, this);\n\n          if (ret === false) {\n            break;\n          } // exit each early on return false\n\n        }\n      }\n\n      return this;\n    },\n    toArray: function toArray() {\n      var array = [];\n\n      for (var i = 0; i < this.length; i++) {\n        array.push(this[i]);\n      }\n\n      return array;\n    },\n    slice: function slice(start, end) {\n      var array = [];\n      var thisSize = this.length;\n\n      if (end == null) {\n        end = thisSize;\n      }\n\n      if (start == null) {\n        start = 0;\n      }\n\n      if (start < 0) {\n        start = thisSize + start;\n      }\n\n      if (end < 0) {\n        end = thisSize + end;\n      }\n\n      for (var i = start; i >= 0 && i < end && i < thisSize; i++) {\n        array.push(this[i]);\n      }\n\n      return this.spawn(array);\n    },\n    size: function size() {\n      return this.length;\n    },\n    eq: function eq(i) {\n      return this[i] || this.spawn();\n    },\n    first: function first() {\n      return this[0] || this.spawn();\n    },\n    last: function last() {\n      return this[this.length - 1] || this.spawn();\n    },\n    empty: function empty() {\n      return this.length === 0;\n    },\n    nonempty: function nonempty() {\n      return !this.empty();\n    },\n    sort: function sort(sortFn) {\n      if (!fn$6(sortFn)) {\n        return this;\n      }\n\n      var sorted = this.toArray().sort(sortFn);\n      return this.spawn(sorted);\n    },\n    sortByZIndex: function sortByZIndex() {\n      return this.sort(zIndexSort);\n    },\n    zDepth: function zDepth() {\n      var ele = this[0];\n\n      if (!ele) {\n        return undefined;\n      } // let cy = ele.cy();\n\n\n      var _p = ele._private;\n      var group = _p.group;\n\n      if (group === 'nodes') {\n        var depth = _p.data.parent ? ele.parents().size() : 0;\n\n        if (!ele.isParent()) {\n          return MAX_INT$1 - 1; // childless nodes always on top\n        }\n\n        return depth;\n      } else {\n        var src = _p.source;\n        var tgt = _p.target;\n        var srcDepth = src.zDepth();\n        var tgtDepth = tgt.zDepth();\n        return Math.max(srcDepth, tgtDepth, 0); // depth of deepest parent\n      }\n    }\n  };\n  elesfn$6.each = elesfn$6.forEach;\n\n  var defineSymbolIterator = function defineSymbolIterator() {\n    var typeofUndef = \"undefined\" ;\n    var isIteratorSupported = (typeof Symbol === \"undefined\" ? \"undefined\" : _typeof(Symbol)) != typeofUndef && _typeof(Symbol.iterator) != typeofUndef; // eslint-disable-line no-undef\n\n    if (isIteratorSupported) {\n      elesfn$6[Symbol.iterator] = function () {\n        var _this = this;\n\n        // eslint-disable-line no-undef\n        var entry = {\n          value: undefined,\n          done: false\n        };\n        var i = 0;\n        var length = this.length;\n        return _defineProperty$1({\n          next: function next() {\n            if (i < length) {\n              entry.value = _this[i++];\n            } else {\n              entry.value = undefined;\n              entry.done = true;\n            }\n\n            return entry;\n          }\n        }, Symbol.iterator, function () {\n          // eslint-disable-line no-undef\n          return this;\n        });\n      };\n    }\n  };\n\n  defineSymbolIterator();\n\n  var getLayoutDimensionOptions = defaults$g({\n    nodeDimensionsIncludeLabels: false\n  });\n  var elesfn$5 = {\n    // Calculates and returns node dimensions { x, y } based on options given\n    layoutDimensions: function layoutDimensions(options) {\n      options = getLayoutDimensionOptions(options);\n      var dims;\n\n      if (!this.takesUpSpace()) {\n        dims = {\n          w: 0,\n          h: 0\n        };\n      } else if (options.nodeDimensionsIncludeLabels) {\n        var bbDim = this.boundingBox();\n        dims = {\n          w: bbDim.w,\n          h: bbDim.h\n        };\n      } else {\n        dims = {\n          w: this.outerWidth(),\n          h: this.outerHeight()\n        };\n      } // sanitise the dimensions for external layouts (avoid division by zero)\n\n\n      if (dims.w === 0 || dims.h === 0) {\n        dims.w = dims.h = 1;\n      }\n\n      return dims;\n    },\n    // using standard layout options, apply position function (w/ or w/o animation)\n    layoutPositions: function layoutPositions(layout, options, fn) {\n      var nodes = this.nodes().filter(function (n) {\n        return !n.isParent();\n      });\n      var cy = this.cy();\n      var layoutEles = options.eles; // nodes & edges\n\n      var getMemoizeKey = function getMemoizeKey(node) {\n        return node.id();\n      };\n\n      var fnMem = memoize$1(fn, getMemoizeKey); // memoized version of position function\n\n      layout.emit({\n        type: 'layoutstart',\n        layout: layout\n      });\n      layout.animations = [];\n\n      var calculateSpacing = function calculateSpacing(spacing, nodesBb, pos) {\n        var center = {\n          x: nodesBb.x1 + nodesBb.w / 2,\n          y: nodesBb.y1 + nodesBb.h / 2\n        };\n        var spacingVector = {\n          // scale from center of bounding box (not necessarily 0,0)\n          x: (pos.x - center.x) * spacing,\n          y: (pos.y - center.y) * spacing\n        };\n        return {\n          x: center.x + spacingVector.x,\n          y: center.y + spacingVector.y\n        };\n      };\n\n      var useSpacingFactor = options.spacingFactor && options.spacingFactor !== 1;\n\n      var spacingBb = function spacingBb() {\n        if (!useSpacingFactor) {\n          return null;\n        }\n\n        var bb = makeBoundingBox();\n\n        for (var i = 0; i < nodes.length; i++) {\n          var node = nodes[i];\n          var pos = fnMem(node, i);\n          expandBoundingBoxByPoint(bb, pos.x, pos.y);\n        }\n\n        return bb;\n      };\n\n      var bb = spacingBb();\n      var getFinalPos = memoize$1(function (node, i) {\n        var newPos = fnMem(node, i);\n\n        if (useSpacingFactor) {\n          var spacing = Math.abs(options.spacingFactor);\n          newPos = calculateSpacing(spacing, bb, newPos);\n        }\n\n        if (options.transform != null) {\n          newPos = options.transform(node, newPos);\n        }\n\n        return newPos;\n      }, getMemoizeKey);\n\n      if (options.animate) {\n        for (var i = 0; i < nodes.length; i++) {\n          var node = nodes[i];\n          var newPos = getFinalPos(node, i);\n          var animateNode = options.animateFilter == null || options.animateFilter(node, i);\n\n          if (animateNode) {\n            var ani = node.animation({\n              position: newPos,\n              duration: options.animationDuration,\n              easing: options.animationEasing\n            });\n            layout.animations.push(ani);\n          } else {\n            node.position(newPos);\n          }\n        }\n\n        if (options.fit) {\n          var fitAni = cy.animation({\n            fit: {\n              boundingBox: layoutEles.boundingBoxAt(getFinalPos),\n              padding: options.padding\n            },\n            duration: options.animationDuration,\n            easing: options.animationEasing\n          });\n          layout.animations.push(fitAni);\n        } else if (options.zoom !== undefined && options.pan !== undefined) {\n          var zoomPanAni = cy.animation({\n            zoom: options.zoom,\n            pan: options.pan,\n            duration: options.animationDuration,\n            easing: options.animationEasing\n          });\n          layout.animations.push(zoomPanAni);\n        }\n\n        layout.animations.forEach(function (ani) {\n          return ani.play();\n        });\n        layout.one('layoutready', options.ready);\n        layout.emit({\n          type: 'layoutready',\n          layout: layout\n        });\n        Promise$1.all(layout.animations.map(function (ani) {\n          return ani.promise();\n        })).then(function () {\n          layout.one('layoutstop', options.stop);\n          layout.emit({\n            type: 'layoutstop',\n            layout: layout\n          });\n        });\n      } else {\n        nodes.positions(getFinalPos);\n\n        if (options.fit) {\n          cy.fit(options.eles, options.padding);\n        }\n\n        if (options.zoom != null) {\n          cy.zoom(options.zoom);\n        }\n\n        if (options.pan) {\n          cy.pan(options.pan);\n        }\n\n        layout.one('layoutready', options.ready);\n        layout.emit({\n          type: 'layoutready',\n          layout: layout\n        });\n        layout.one('layoutstop', options.stop);\n        layout.emit({\n          type: 'layoutstop',\n          layout: layout\n        });\n      }\n\n      return this; // chaining\n    },\n    layout: function layout(options) {\n      var cy = this.cy();\n      return cy.makeLayout(extend({}, options, {\n        eles: this\n      }));\n    }\n  }; // aliases:\n\n  elesfn$5.createLayout = elesfn$5.makeLayout = elesfn$5.layout;\n\n  function styleCache(key, fn, ele) {\n    var _p = ele._private;\n    var cache = _p.styleCache = _p.styleCache || [];\n    var val;\n\n    if ((val = cache[key]) != null) {\n      return val;\n    } else {\n      val = cache[key] = fn(ele);\n      return val;\n    }\n  }\n\n  function cacheStyleFunction(key, fn) {\n    key = hashString(key);\n    return function cachedStyleFunction(ele) {\n      return styleCache(key, fn, ele);\n    };\n  }\n\n  function cachePrototypeStyleFunction(key, fn) {\n    key = hashString(key);\n\n    var selfFn = function selfFn(ele) {\n      return fn.call(ele);\n    };\n\n    return function cachedPrototypeStyleFunction() {\n      var ele = this[0];\n\n      if (ele) {\n        return styleCache(key, selfFn, ele);\n      }\n    };\n  }\n\n  var elesfn$4 = {\n    recalculateRenderedStyle: function recalculateRenderedStyle(useCache) {\n      var cy = this.cy();\n      var renderer = cy.renderer();\n      var styleEnabled = cy.styleEnabled();\n\n      if (renderer && styleEnabled) {\n        renderer.recalculateRenderedStyle(this, useCache);\n      }\n\n      return this;\n    },\n    dirtyStyleCache: function dirtyStyleCache() {\n      var cy = this.cy();\n\n      var dirty = function dirty(ele) {\n        return ele._private.styleCache = null;\n      };\n\n      if (cy.hasCompoundNodes()) {\n        var eles;\n        eles = this.spawnSelf().merge(this.descendants()).merge(this.parents());\n        eles.merge(eles.connectedEdges());\n        eles.forEach(dirty);\n      } else {\n        this.forEach(function (ele) {\n          dirty(ele);\n          ele.connectedEdges().forEach(dirty);\n        });\n      }\n\n      return this;\n    },\n    // fully updates (recalculates) the style for the elements\n    updateStyle: function updateStyle(notifyRenderer) {\n      var cy = this._private.cy;\n\n      if (!cy.styleEnabled()) {\n        return this;\n      }\n\n      if (cy.batching()) {\n        var bEles = cy._private.batchStyleEles;\n        bEles.merge(this);\n        return this; // chaining and exit early when batching\n      }\n\n      var hasCompounds = cy.hasCompoundNodes();\n      var updatedEles = this;\n      notifyRenderer = notifyRenderer || notifyRenderer === undefined ? true : false;\n\n      if (hasCompounds) {\n        // then add everything up and down for compound selector checks\n        updatedEles = this.spawnSelf().merge(this.descendants()).merge(this.parents());\n      } // let changedEles = style.apply( updatedEles );\n\n\n      var changedEles = updatedEles;\n\n      if (notifyRenderer) {\n        changedEles.emitAndNotify('style'); // let renderer know we changed style\n      } else {\n        changedEles.emit('style'); // just fire the event\n      }\n\n      updatedEles.forEach(function (ele) {\n        return ele._private.styleDirty = true;\n      });\n      return this; // chaining\n    },\n    // private: clears dirty flag and recalculates style\n    cleanStyle: function cleanStyle() {\n      var cy = this.cy();\n\n      if (!cy.styleEnabled()) {\n        return;\n      }\n\n      for (var i = 0; i < this.length; i++) {\n        var ele = this[i];\n\n        if (ele._private.styleDirty) {\n          // n.b. this flag should be set before apply() to avoid potential infinite recursion\n          ele._private.styleDirty = false;\n          cy.style().apply(ele);\n        }\n      }\n    },\n    // get the internal parsed style object for the specified property\n    parsedStyle: function parsedStyle(property) {\n      var includeNonDefault = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var ele = this[0];\n      var cy = ele.cy();\n\n      if (!cy.styleEnabled()) {\n        return;\n      }\n\n      if (ele) {\n        this.cleanStyle();\n        var overriddenStyle = ele._private.style[property];\n\n        if (overriddenStyle != null) {\n          return overriddenStyle;\n        } else if (includeNonDefault) {\n          return cy.style().getDefaultProperty(property);\n        } else {\n          return null;\n        }\n      }\n    },\n    numericStyle: function numericStyle(property) {\n      var ele = this[0];\n\n      if (!ele.cy().styleEnabled()) {\n        return;\n      }\n\n      if (ele) {\n        var pstyle = ele.pstyle(property);\n        return pstyle.pfValue !== undefined ? pstyle.pfValue : pstyle.value;\n      }\n    },\n    numericStyleUnits: function numericStyleUnits(property) {\n      var ele = this[0];\n\n      if (!ele.cy().styleEnabled()) {\n        return;\n      }\n\n      if (ele) {\n        return ele.pstyle(property).units;\n      }\n    },\n    // get the specified css property as a rendered value (i.e. on-screen value)\n    // or get the whole rendered style if no property specified (NB doesn't allow setting)\n    renderedStyle: function renderedStyle(property) {\n      var cy = this.cy();\n\n      if (!cy.styleEnabled()) {\n        return this;\n      }\n\n      var ele = this[0];\n\n      if (ele) {\n        return cy.style().getRenderedStyle(ele, property);\n      }\n    },\n    // read the calculated css style of the element or override the style (via a bypass)\n    style: function style(name, value) {\n      var cy = this.cy();\n\n      if (!cy.styleEnabled()) {\n        return this;\n      }\n\n      var updateTransitions = false;\n      var style = cy.style();\n\n      if (plainObject(name)) {\n        // then extend the bypass\n        var props = name;\n        style.applyBypass(this, props, updateTransitions);\n        this.emitAndNotify('style'); // let the renderer know we've updated style\n      } else if (string(name)) {\n        if (value === undefined) {\n          // then get the property from the style\n          var ele = this[0];\n\n          if (ele) {\n            return style.getStylePropertyValue(ele, name);\n          } else {\n            // empty collection => can't get any value\n            return;\n          }\n        } else {\n          // then set the bypass with the property value\n          style.applyBypass(this, name, value, updateTransitions);\n          this.emitAndNotify('style'); // let the renderer know we've updated style\n        }\n      } else if (name === undefined) {\n        var _ele = this[0];\n\n        if (_ele) {\n          return style.getRawStyle(_ele);\n        } else {\n          // empty collection => can't get any value\n          return;\n        }\n      }\n\n      return this; // chaining\n    },\n    removeStyle: function removeStyle(names) {\n      var cy = this.cy();\n\n      if (!cy.styleEnabled()) {\n        return this;\n      }\n\n      var updateTransitions = false;\n      var style = cy.style();\n      var eles = this;\n\n      if (names === undefined) {\n        for (var i = 0; i < eles.length; i++) {\n          var ele = eles[i];\n          style.removeAllBypasses(ele, updateTransitions);\n        }\n      } else {\n        names = names.split(/\\s+/);\n\n        for (var _i = 0; _i < eles.length; _i++) {\n          var _ele2 = eles[_i];\n          style.removeBypasses(_ele2, names, updateTransitions);\n        }\n      }\n\n      this.emitAndNotify('style'); // let the renderer know we've updated style\n\n      return this; // chaining\n    },\n    show: function show() {\n      this.css('display', 'element');\n      return this; // chaining\n    },\n    hide: function hide() {\n      this.css('display', 'none');\n      return this; // chaining\n    },\n    effectiveOpacity: function effectiveOpacity() {\n      var cy = this.cy();\n\n      if (!cy.styleEnabled()) {\n        return 1;\n      }\n\n      var hasCompoundNodes = cy.hasCompoundNodes();\n      var ele = this[0];\n\n      if (ele) {\n        var _p = ele._private;\n        var parentOpacity = ele.pstyle('opacity').value;\n\n        if (!hasCompoundNodes) {\n          return parentOpacity;\n        }\n\n        var parents = !_p.data.parent ? null : ele.parents();\n\n        if (parents) {\n          for (var i = 0; i < parents.length; i++) {\n            var parent = parents[i];\n            var opacity = parent.pstyle('opacity').value;\n            parentOpacity = opacity * parentOpacity;\n          }\n        }\n\n        return parentOpacity;\n      }\n    },\n    transparent: function transparent() {\n      var cy = this.cy();\n\n      if (!cy.styleEnabled()) {\n        return false;\n      }\n\n      var ele = this[0];\n      var hasCompoundNodes = ele.cy().hasCompoundNodes();\n\n      if (ele) {\n        if (!hasCompoundNodes) {\n          return ele.pstyle('opacity').value === 0;\n        } else {\n          return ele.effectiveOpacity() === 0;\n        }\n      }\n    },\n    backgrounding: function backgrounding() {\n      var cy = this.cy();\n\n      if (!cy.styleEnabled()) {\n        return false;\n      }\n\n      var ele = this[0];\n      return ele._private.backgrounding ? true : false;\n    }\n  };\n\n  function checkCompound(ele, parentOk) {\n    var _p = ele._private;\n    var parents = _p.data.parent ? ele.parents() : null;\n\n    if (parents) {\n      for (var i = 0; i < parents.length; i++) {\n        var parent = parents[i];\n\n        if (!parentOk(parent)) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  function defineDerivedStateFunction(specs) {\n    var ok = specs.ok;\n    var edgeOkViaNode = specs.edgeOkViaNode || specs.ok;\n    var parentOk = specs.parentOk || specs.ok;\n    return function () {\n      var cy = this.cy();\n\n      if (!cy.styleEnabled()) {\n        return true;\n      }\n\n      var ele = this[0];\n      var hasCompoundNodes = cy.hasCompoundNodes();\n\n      if (ele) {\n        var _p = ele._private;\n\n        if (!ok(ele)) {\n          return false;\n        }\n\n        if (ele.isNode()) {\n          return !hasCompoundNodes || checkCompound(ele, parentOk);\n        } else {\n          var src = _p.source;\n          var tgt = _p.target;\n          return edgeOkViaNode(src) && (!hasCompoundNodes || checkCompound(src, edgeOkViaNode)) && (src === tgt || edgeOkViaNode(tgt) && (!hasCompoundNodes || checkCompound(tgt, edgeOkViaNode)));\n        }\n      }\n    };\n  }\n\n  var eleTakesUpSpace = cacheStyleFunction('eleTakesUpSpace', function (ele) {\n    return ele.pstyle('display').value === 'element' && ele.width() !== 0 && (ele.isNode() ? ele.height() !== 0 : true);\n  });\n  elesfn$4.takesUpSpace = cachePrototypeStyleFunction('takesUpSpace', defineDerivedStateFunction({\n    ok: eleTakesUpSpace\n  }));\n  var eleInteractive = cacheStyleFunction('eleInteractive', function (ele) {\n    return ele.pstyle('events').value === 'yes' && ele.pstyle('visibility').value === 'visible' && eleTakesUpSpace(ele);\n  });\n  var parentInteractive = cacheStyleFunction('parentInteractive', function (parent) {\n    return parent.pstyle('visibility').value === 'visible' && eleTakesUpSpace(parent);\n  });\n  elesfn$4.interactive = cachePrototypeStyleFunction('interactive', defineDerivedStateFunction({\n    ok: eleInteractive,\n    parentOk: parentInteractive,\n    edgeOkViaNode: eleTakesUpSpace\n  }));\n\n  elesfn$4.noninteractive = function () {\n    var ele = this[0];\n\n    if (ele) {\n      return !ele.interactive();\n    }\n  };\n\n  var eleVisible = cacheStyleFunction('eleVisible', function (ele) {\n    return ele.pstyle('visibility').value === 'visible' && ele.pstyle('opacity').pfValue !== 0 && eleTakesUpSpace(ele);\n  });\n  var edgeVisibleViaNode = eleTakesUpSpace;\n  elesfn$4.visible = cachePrototypeStyleFunction('visible', defineDerivedStateFunction({\n    ok: eleVisible,\n    edgeOkViaNode: edgeVisibleViaNode\n  }));\n\n  elesfn$4.hidden = function () {\n    var ele = this[0];\n\n    if (ele) {\n      return !ele.visible();\n    }\n  };\n\n  elesfn$4.isBundledBezier = cachePrototypeStyleFunction('isBundledBezier', function () {\n    if (!this.cy().styleEnabled()) {\n      return false;\n    }\n\n    return !this.removed() && this.pstyle('curve-style').value === 'bezier' && this.takesUpSpace();\n  });\n  elesfn$4.bypass = elesfn$4.css = elesfn$4.style;\n  elesfn$4.renderedCss = elesfn$4.renderedStyle;\n  elesfn$4.removeBypass = elesfn$4.removeCss = elesfn$4.removeStyle;\n  elesfn$4.pstyle = elesfn$4.parsedStyle;\n\n  var elesfn$3 = {};\n\n  function defineSwitchFunction(params) {\n    return function () {\n      var args = arguments;\n      var changedEles = []; // e.g. cy.nodes().select( data, handler )\n\n      if (args.length === 2) {\n        var data = args[0];\n        var handler = args[1];\n        this.on(params.event, data, handler);\n      } // e.g. cy.nodes().select( handler )\n      else if (args.length === 1 && fn$6(args[0])) {\n        var _handler = args[0];\n        this.on(params.event, _handler);\n      } // e.g. cy.nodes().select()\n      // e.g. (private) cy.nodes().select(['tapselect'])\n      else if (args.length === 0 || args.length === 1 && array(args[0])) {\n        var addlEvents = args.length === 1 ? args[0] : null;\n\n        for (var i = 0; i < this.length; i++) {\n          var ele = this[i];\n          var able = !params.ableField || ele._private[params.ableField];\n          var changed = ele._private[params.field] != params.value;\n\n          if (params.overrideAble) {\n            var overrideAble = params.overrideAble(ele);\n\n            if (overrideAble !== undefined) {\n              able = overrideAble;\n\n              if (!overrideAble) {\n                return this;\n              } // to save cycles assume not able for all on override\n\n            }\n          }\n\n          if (able) {\n            ele._private[params.field] = params.value;\n\n            if (changed) {\n              changedEles.push(ele);\n            }\n          }\n        }\n\n        var changedColl = this.spawn(changedEles);\n        changedColl.updateStyle(); // change of state => possible change of style\n\n        changedColl.emit(params.event);\n\n        if (addlEvents) {\n          changedColl.emit(addlEvents);\n        }\n      }\n\n      return this;\n    };\n  }\n\n  function defineSwitchSet(params) {\n    elesfn$3[params.field] = function () {\n      var ele = this[0];\n\n      if (ele) {\n        if (params.overrideField) {\n          var val = params.overrideField(ele);\n\n          if (val !== undefined) {\n            return val;\n          }\n        }\n\n        return ele._private[params.field];\n      }\n    };\n\n    elesfn$3[params.on] = defineSwitchFunction({\n      event: params.on,\n      field: params.field,\n      ableField: params.ableField,\n      overrideAble: params.overrideAble,\n      value: true\n    });\n    elesfn$3[params.off] = defineSwitchFunction({\n      event: params.off,\n      field: params.field,\n      ableField: params.ableField,\n      overrideAble: params.overrideAble,\n      value: false\n    });\n  }\n\n  defineSwitchSet({\n    field: 'locked',\n    overrideField: function overrideField(ele) {\n      return ele.cy().autolock() ? true : undefined;\n    },\n    on: 'lock',\n    off: 'unlock'\n  });\n  defineSwitchSet({\n    field: 'grabbable',\n    overrideField: function overrideField(ele) {\n      return ele.cy().autoungrabify() || ele.pannable() ? false : undefined;\n    },\n    on: 'grabify',\n    off: 'ungrabify'\n  });\n  defineSwitchSet({\n    field: 'selected',\n    ableField: 'selectable',\n    overrideAble: function overrideAble(ele) {\n      return ele.cy().autounselectify() ? false : undefined;\n    },\n    on: 'select',\n    off: 'unselect'\n  });\n  defineSwitchSet({\n    field: 'selectable',\n    overrideField: function overrideField(ele) {\n      return ele.cy().autounselectify() ? false : undefined;\n    },\n    on: 'selectify',\n    off: 'unselectify'\n  });\n  elesfn$3.deselect = elesfn$3.unselect;\n\n  elesfn$3.grabbed = function () {\n    var ele = this[0];\n\n    if (ele) {\n      return ele._private.grabbed;\n    }\n  };\n\n  defineSwitchSet({\n    field: 'active',\n    on: 'activate',\n    off: 'unactivate'\n  });\n  defineSwitchSet({\n    field: 'pannable',\n    on: 'panify',\n    off: 'unpanify'\n  });\n\n  elesfn$3.inactive = function () {\n    var ele = this[0];\n\n    if (ele) {\n      return !ele._private.active;\n    }\n  };\n\n  var elesfn$2 = {}; // DAG functions\n  ////////////////\n\n  var defineDagExtremity = function defineDagExtremity(params) {\n    return function dagExtremityImpl(selector) {\n      var eles = this;\n      var ret = [];\n\n      for (var i = 0; i < eles.length; i++) {\n        var ele = eles[i];\n\n        if (!ele.isNode()) {\n          continue;\n        }\n\n        var disqualified = false;\n        var edges = ele.connectedEdges();\n\n        for (var j = 0; j < edges.length; j++) {\n          var edge = edges[j];\n          var src = edge.source();\n          var tgt = edge.target();\n\n          if (params.noIncomingEdges && tgt === ele && src !== ele || params.noOutgoingEdges && src === ele && tgt !== ele) {\n            disqualified = true;\n            break;\n          }\n        }\n\n        if (!disqualified) {\n          ret.push(ele);\n        }\n      }\n\n      return this.spawn(ret, true).filter(selector);\n    };\n  };\n\n  var defineDagOneHop = function defineDagOneHop(params) {\n    return function (selector) {\n      var eles = this;\n      var oEles = [];\n\n      for (var i = 0; i < eles.length; i++) {\n        var ele = eles[i];\n\n        if (!ele.isNode()) {\n          continue;\n        }\n\n        var edges = ele.connectedEdges();\n\n        for (var j = 0; j < edges.length; j++) {\n          var edge = edges[j];\n          var src = edge.source();\n          var tgt = edge.target();\n\n          if (params.outgoing && src === ele) {\n            oEles.push(edge);\n            oEles.push(tgt);\n          } else if (params.incoming && tgt === ele) {\n            oEles.push(edge);\n            oEles.push(src);\n          }\n        }\n      }\n\n      return this.spawn(oEles, true).filter(selector);\n    };\n  };\n\n  var defineDagAllHops = function defineDagAllHops(params) {\n    return function (selector) {\n      var eles = this;\n      var sEles = [];\n      var sElesIds = {};\n\n      for (;;) {\n        var next = params.outgoing ? eles.outgoers() : eles.incomers();\n\n        if (next.length === 0) {\n          break;\n        } // done if none left\n\n\n        var newNext = false;\n\n        for (var i = 0; i < next.length; i++) {\n          var n = next[i];\n          var nid = n.id();\n\n          if (!sElesIds[nid]) {\n            sElesIds[nid] = true;\n            sEles.push(n);\n            newNext = true;\n          }\n        }\n\n        if (!newNext) {\n          break;\n        } // done if touched all outgoers already\n\n\n        eles = next;\n      }\n\n      return this.spawn(sEles, true).filter(selector);\n    };\n  };\n\n  elesfn$2.clearTraversalCache = function () {\n    for (var i = 0; i < this.length; i++) {\n      this[i]._private.traversalCache = null;\n    }\n  };\n\n  extend(elesfn$2, {\n    // get the root nodes in the DAG\n    roots: defineDagExtremity({\n      noIncomingEdges: true\n    }),\n    // get the leaf nodes in the DAG\n    leaves: defineDagExtremity({\n      noOutgoingEdges: true\n    }),\n    // normally called children in graph theory\n    // these nodes =edges=> outgoing nodes\n    outgoers: cache(defineDagOneHop({\n      outgoing: true\n    }), 'outgoers'),\n    // aka DAG descendants\n    successors: defineDagAllHops({\n      outgoing: true\n    }),\n    // normally called parents in graph theory\n    // these nodes <=edges= incoming nodes\n    incomers: cache(defineDagOneHop({\n      incoming: true\n    }), 'incomers'),\n    // aka DAG ancestors\n    predecessors: defineDagAllHops({\n      incoming: true\n    })\n  }); // Neighbourhood functions\n  //////////////////////////\n\n  extend(elesfn$2, {\n    neighborhood: cache(function (selector) {\n      var elements = [];\n      var nodes = this.nodes();\n\n      for (var i = 0; i < nodes.length; i++) {\n        // for all nodes\n        var node = nodes[i];\n        var connectedEdges = node.connectedEdges(); // for each connected edge, add the edge and the other node\n\n        for (var j = 0; j < connectedEdges.length; j++) {\n          var edge = connectedEdges[j];\n          var src = edge.source();\n          var tgt = edge.target();\n          var otherNode = node === src ? tgt : src; // need check in case of loop\n\n          if (otherNode.length > 0) {\n            elements.push(otherNode[0]); // add node 1 hop away\n          } // add connected edge\n\n\n          elements.push(edge[0]);\n        }\n      }\n\n      return this.spawn(elements, true).filter(selector);\n    }, 'neighborhood'),\n    closedNeighborhood: function closedNeighborhood(selector) {\n      return this.neighborhood().add(this).filter(selector);\n    },\n    openNeighborhood: function openNeighborhood(selector) {\n      return this.neighborhood(selector);\n    }\n  }); // aliases\n\n  elesfn$2.neighbourhood = elesfn$2.neighborhood;\n  elesfn$2.closedNeighbourhood = elesfn$2.closedNeighborhood;\n  elesfn$2.openNeighbourhood = elesfn$2.openNeighborhood; // Edge functions\n  /////////////////\n\n  extend(elesfn$2, {\n    source: cache(function sourceImpl(selector) {\n      var ele = this[0];\n      var src;\n\n      if (ele) {\n        src = ele._private.source || ele.cy().collection();\n      }\n\n      return src && selector ? src.filter(selector) : src;\n    }, 'source'),\n    target: cache(function targetImpl(selector) {\n      var ele = this[0];\n      var tgt;\n\n      if (ele) {\n        tgt = ele._private.target || ele.cy().collection();\n      }\n\n      return tgt && selector ? tgt.filter(selector) : tgt;\n    }, 'target'),\n    sources: defineSourceFunction({\n      attr: 'source'\n    }),\n    targets: defineSourceFunction({\n      attr: 'target'\n    })\n  });\n\n  function defineSourceFunction(params) {\n    return function sourceImpl(selector) {\n      var sources = [];\n\n      for (var i = 0; i < this.length; i++) {\n        var ele = this[i];\n        var src = ele._private[params.attr];\n\n        if (src) {\n          sources.push(src);\n        }\n      }\n\n      return this.spawn(sources, true).filter(selector);\n    };\n  }\n\n  extend(elesfn$2, {\n    edgesWith: cache(defineEdgesWithFunction(), 'edgesWith'),\n    edgesTo: cache(defineEdgesWithFunction({\n      thisIsSrc: true\n    }), 'edgesTo')\n  });\n\n  function defineEdgesWithFunction(params) {\n    return function edgesWithImpl(otherNodes) {\n      var elements = [];\n      var cy = this._private.cy;\n      var p = params || {}; // get elements if a selector is specified\n\n      if (string(otherNodes)) {\n        otherNodes = cy.$(otherNodes);\n      }\n\n      for (var h = 0; h < otherNodes.length; h++) {\n        var edges = otherNodes[h]._private.edges;\n\n        for (var i = 0; i < edges.length; i++) {\n          var edge = edges[i];\n          var edgeData = edge._private.data;\n          var thisToOther = this.hasElementWithId(edgeData.source) && otherNodes.hasElementWithId(edgeData.target);\n          var otherToThis = otherNodes.hasElementWithId(edgeData.source) && this.hasElementWithId(edgeData.target);\n          var edgeConnectsThisAndOther = thisToOther || otherToThis;\n\n          if (!edgeConnectsThisAndOther) {\n            continue;\n          }\n\n          if (p.thisIsSrc || p.thisIsTgt) {\n            if (p.thisIsSrc && !thisToOther) {\n              continue;\n            }\n\n            if (p.thisIsTgt && !otherToThis) {\n              continue;\n            }\n          }\n\n          elements.push(edge);\n        }\n      }\n\n      return this.spawn(elements, true);\n    };\n  }\n\n  extend(elesfn$2, {\n    connectedEdges: cache(function (selector) {\n      var retEles = [];\n      var eles = this;\n\n      for (var i = 0; i < eles.length; i++) {\n        var node = eles[i];\n\n        if (!node.isNode()) {\n          continue;\n        }\n\n        var edges = node._private.edges;\n\n        for (var j = 0; j < edges.length; j++) {\n          var edge = edges[j];\n          retEles.push(edge);\n        }\n      }\n\n      return this.spawn(retEles, true).filter(selector);\n    }, 'connectedEdges'),\n    connectedNodes: cache(function (selector) {\n      var retEles = [];\n      var eles = this;\n\n      for (var i = 0; i < eles.length; i++) {\n        var edge = eles[i];\n\n        if (!edge.isEdge()) {\n          continue;\n        }\n\n        retEles.push(edge.source()[0]);\n        retEles.push(edge.target()[0]);\n      }\n\n      return this.spawn(retEles, true).filter(selector);\n    }, 'connectedNodes'),\n    parallelEdges: cache(defineParallelEdgesFunction(), 'parallelEdges'),\n    codirectedEdges: cache(defineParallelEdgesFunction({\n      codirected: true\n    }), 'codirectedEdges')\n  });\n\n  function defineParallelEdgesFunction(params) {\n    var defaults = {\n      codirected: false\n    };\n    params = extend({}, defaults, params);\n    return function parallelEdgesImpl(selector) {\n      // micro-optimised for renderer\n      var elements = [];\n      var edges = this.edges();\n      var p = params; // look at all the edges in the collection\n\n      for (var i = 0; i < edges.length; i++) {\n        var edge1 = edges[i];\n        var edge1_p = edge1._private;\n        var src1 = edge1_p.source;\n        var srcid1 = src1._private.data.id;\n        var tgtid1 = edge1_p.data.target;\n        var srcEdges1 = src1._private.edges; // look at edges connected to the src node of this edge\n\n        for (var j = 0; j < srcEdges1.length; j++) {\n          var edge2 = srcEdges1[j];\n          var edge2data = edge2._private.data;\n          var tgtid2 = edge2data.target;\n          var srcid2 = edge2data.source;\n          var codirected = tgtid2 === tgtid1 && srcid2 === srcid1;\n          var oppdirected = srcid1 === tgtid2 && tgtid1 === srcid2;\n\n          if (p.codirected && codirected || !p.codirected && (codirected || oppdirected)) {\n            elements.push(edge2);\n          }\n        }\n      }\n\n      return this.spawn(elements, true).filter(selector);\n    };\n  } // Misc functions\n  /////////////////\n\n\n  extend(elesfn$2, {\n    components: function components(root) {\n      var self = this;\n      var cy = self.cy();\n      var visited = cy.collection();\n      var unvisited = root == null ? self.nodes() : root.nodes();\n      var components = [];\n\n      if (root != null && unvisited.empty()) {\n        // root may contain only edges\n        unvisited = root.sources(); // doesn't matter which node to use (undirected), so just use the source sides\n      }\n\n      var visitInComponent = function visitInComponent(node, component) {\n        visited.merge(node);\n        unvisited.unmerge(node);\n        component.merge(node);\n      };\n\n      if (unvisited.empty()) {\n        return self.spawn();\n      }\n\n      var _loop = function _loop() {\n        // each iteration yields a component\n        var cmpt = cy.collection();\n        components.push(cmpt);\n        var root = unvisited[0];\n        visitInComponent(root, cmpt);\n        self.bfs({\n          directed: false,\n          roots: root,\n          visit: function visit(v) {\n            return visitInComponent(v, cmpt);\n          }\n        });\n        cmpt.forEach(function (node) {\n          node.connectedEdges().forEach(function (e) {\n            // connectedEdges() usually cached\n            if (self.has(e) && cmpt.has(e.source()) && cmpt.has(e.target())) {\n              // has() is cheap\n              cmpt.merge(e); // forEach() only considers nodes -- sets N at call time\n            }\n          });\n        });\n      };\n\n      do {\n        _loop();\n      } while (unvisited.length > 0);\n\n      return components;\n    },\n    component: function component() {\n      var ele = this[0];\n      return ele.cy().mutableElements().components(ele)[0];\n    }\n  });\n  elesfn$2.componentsOf = elesfn$2.components;\n\n  var Collection = function Collection(cy, elements) {\n    var unique = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var removed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n    if (cy === undefined) {\n      error('A collection must have a reference to the core');\n      return;\n    }\n\n    var map = new Map$2();\n    var createdElements = false;\n\n    if (!elements) {\n      elements = [];\n    } else if (elements.length > 0 && plainObject(elements[0]) && !element(elements[0])) {\n      createdElements = true; // make elements from json and restore all at once later\n\n      var eles = [];\n      var elesIds = new Set$1();\n\n      for (var i = 0, l = elements.length; i < l; i++) {\n        var json = elements[i];\n\n        if (json.data == null) {\n          json.data = {};\n        }\n\n        var _data = json.data; // make sure newly created elements have valid ids\n\n        if (_data.id == null) {\n          _data.id = uuid();\n        } else if (cy.hasElementWithId(_data.id) || elesIds.has(_data.id)) {\n          continue; // can't create element if prior id already exists\n        }\n\n        var ele = new Element(cy, json, false);\n        eles.push(ele);\n        elesIds.add(_data.id);\n      }\n\n      elements = eles;\n    }\n\n    this.length = 0;\n\n    for (var _i = 0, _l = elements.length; _i < _l; _i++) {\n      var element$1 = elements[_i][0]; // [0] in case elements is an array of collections, rather than array of elements\n\n      if (element$1 == null) {\n        continue;\n      }\n\n      var id = element$1._private.data.id;\n\n      if (!unique || !map.has(id)) {\n        if (unique) {\n          map.set(id, {\n            index: this.length,\n            ele: element$1\n          });\n        }\n\n        this[this.length] = element$1;\n        this.length++;\n      }\n    }\n\n    this._private = {\n      eles: this,\n      cy: cy,\n\n      get map() {\n        if (this.lazyMap == null) {\n          this.rebuildMap();\n        }\n\n        return this.lazyMap;\n      },\n\n      set map(m) {\n        this.lazyMap = m;\n      },\n\n      rebuildMap: function rebuildMap() {\n        var m = this.lazyMap = new Map$2();\n        var eles = this.eles;\n\n        for (var _i2 = 0; _i2 < eles.length; _i2++) {\n          var _ele = eles[_i2];\n          m.set(_ele.id(), {\n            index: _i2,\n            ele: _ele\n          });\n        }\n      }\n    };\n\n    if (unique) {\n      this._private.map = map;\n    } // restore the elements if we created them from json\n\n\n    if (createdElements && !removed) {\n      this.restore();\n    }\n  }; // Functions\n  ////////////////////////////////////////////////////////////////////////////////////////////////////\n  // keep the prototypes in sync (an element has the same functions as a collection)\n  // and use elefn and elesfn as shorthands to the prototypes\n\n\n  var elesfn$1 = Element.prototype = Collection.prototype = Object.create(Array.prototype);\n\n  elesfn$1.instanceString = function () {\n    return 'collection';\n  };\n\n  elesfn$1.spawn = function (eles, unique) {\n    return new Collection(this.cy(), eles, unique);\n  };\n\n  elesfn$1.spawnSelf = function () {\n    return this.spawn(this);\n  };\n\n  elesfn$1.cy = function () {\n    return this._private.cy;\n  };\n\n  elesfn$1.renderer = function () {\n    return this._private.cy.renderer();\n  };\n\n  elesfn$1.element = function () {\n    return this[0];\n  };\n\n  elesfn$1.collection = function () {\n    if (collection(this)) {\n      return this;\n    } else {\n      // an element\n      return new Collection(this._private.cy, [this]);\n    }\n  };\n\n  elesfn$1.unique = function () {\n    return new Collection(this._private.cy, this, true);\n  };\n\n  elesfn$1.hasElementWithId = function (id) {\n    id = '' + id; // id must be string\n\n    return this._private.map.has(id);\n  };\n\n  elesfn$1.getElementById = function (id) {\n    id = '' + id; // id must be string\n\n    var cy = this._private.cy;\n\n    var entry = this._private.map.get(id);\n\n    return entry ? entry.ele : new Collection(cy); // get ele or empty collection\n  };\n\n  elesfn$1.$id = elesfn$1.getElementById;\n\n  elesfn$1.poolIndex = function () {\n    var cy = this._private.cy;\n    var eles = cy._private.elements;\n    var id = this[0]._private.data.id;\n    return eles._private.map.get(id).index;\n  };\n\n  elesfn$1.indexOf = function (ele) {\n    var id = ele[0]._private.data.id;\n    return this._private.map.get(id).index;\n  };\n\n  elesfn$1.indexOfId = function (id) {\n    id = '' + id; // id must be string\n\n    return this._private.map.get(id).index;\n  };\n\n  elesfn$1.json = function (obj) {\n    var ele = this.element();\n    var cy = this.cy();\n\n    if (ele == null && obj) {\n      return this;\n    } // can't set to no eles\n\n\n    if (ele == null) {\n      return undefined;\n    } // can't get from no eles\n\n\n    var p = ele._private;\n\n    if (plainObject(obj)) {\n      // set\n      cy.startBatch();\n\n      if (obj.data) {\n        ele.data(obj.data);\n        var _data2 = p.data;\n\n        if (ele.isEdge()) {\n          // source and target are immutable via data()\n          var move = false;\n          var spec = {};\n          var src = obj.data.source;\n          var tgt = obj.data.target;\n\n          if (src != null && src != _data2.source) {\n            spec.source = '' + src; // id must be string\n\n            move = true;\n          }\n\n          if (tgt != null && tgt != _data2.target) {\n            spec.target = '' + tgt; // id must be string\n\n            move = true;\n          }\n\n          if (move) {\n            ele = ele.move(spec);\n          }\n        } else {\n          // parent is immutable via data()\n          var newParentValSpecd = ('parent' in obj.data);\n          var parent = obj.data.parent;\n\n          if (newParentValSpecd && (parent != null || _data2.parent != null) && parent != _data2.parent) {\n            if (parent === undefined) {\n              // can't set undefined imperatively, so use null\n              parent = null;\n            }\n\n            if (parent != null) {\n              parent = '' + parent; // id must be string\n            }\n\n            ele = ele.move({\n              parent: parent\n            });\n          }\n        }\n      }\n\n      if (obj.position) {\n        ele.position(obj.position);\n      } // ignore group -- immutable\n\n\n      var checkSwitch = function checkSwitch(k, trueFnName, falseFnName) {\n        var obj_k = obj[k];\n\n        if (obj_k != null && obj_k !== p[k]) {\n          if (obj_k) {\n            ele[trueFnName]();\n          } else {\n            ele[falseFnName]();\n          }\n        }\n      };\n\n      checkSwitch('removed', 'remove', 'restore');\n      checkSwitch('selected', 'select', 'unselect');\n      checkSwitch('selectable', 'selectify', 'unselectify');\n      checkSwitch('locked', 'lock', 'unlock');\n      checkSwitch('grabbable', 'grabify', 'ungrabify');\n      checkSwitch('pannable', 'panify', 'unpanify');\n\n      if (obj.classes != null) {\n        ele.classes(obj.classes);\n      }\n\n      cy.endBatch();\n      return this;\n    } else if (obj === undefined) {\n      // get\n      var json = {\n        data: copy(p.data),\n        position: copy(p.position),\n        group: p.group,\n        removed: p.removed,\n        selected: p.selected,\n        selectable: p.selectable,\n        locked: p.locked,\n        grabbable: p.grabbable,\n        pannable: p.pannable,\n        classes: null\n      };\n      json.classes = '';\n      var i = 0;\n      p.classes.forEach(function (cls) {\n        return json.classes += i++ === 0 ? cls : ' ' + cls;\n      });\n      return json;\n    }\n  };\n\n  elesfn$1.jsons = function () {\n    var jsons = [];\n\n    for (var i = 0; i < this.length; i++) {\n      var ele = this[i];\n      var json = ele.json();\n      jsons.push(json);\n    }\n\n    return jsons;\n  };\n\n  elesfn$1.clone = function () {\n    var cy = this.cy();\n    var elesArr = [];\n\n    for (var i = 0; i < this.length; i++) {\n      var ele = this[i];\n      var json = ele.json();\n      var clone = new Element(cy, json, false); // NB no restore\n\n      elesArr.push(clone);\n    }\n\n    return new Collection(cy, elesArr);\n  };\n\n  elesfn$1.copy = elesfn$1.clone;\n\n  elesfn$1.restore = function () {\n    var notifyRenderer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    var addToPool = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var self = this;\n    var cy = self.cy();\n    var cy_p = cy._private; // create arrays of nodes and edges, since we need to\n    // restore the nodes first\n\n    var nodes = [];\n    var edges = [];\n    var elements;\n\n    for (var _i3 = 0, l = self.length; _i3 < l; _i3++) {\n      var ele = self[_i3];\n\n      if (addToPool && !ele.removed()) {\n        // don't need to handle this ele\n        continue;\n      } // keep nodes first in the array and edges after\n\n\n      if (ele.isNode()) {\n        // put to front of array if node\n        nodes.push(ele);\n      } else {\n        // put to end of array if edge\n        edges.push(ele);\n      }\n    }\n\n    elements = nodes.concat(edges);\n    var i;\n\n    var removeFromElements = function removeFromElements() {\n      elements.splice(i, 1);\n      i--;\n    }; // now, restore each element\n\n\n    for (i = 0; i < elements.length; i++) {\n      var _ele2 = elements[i];\n      var _private = _ele2._private;\n      var _data3 = _private.data; // the traversal cache should start fresh when ele is added\n\n      _ele2.clearTraversalCache(); // set id and validate\n\n\n      if (!addToPool && !_private.removed) ; else if (_data3.id === undefined) {\n        _data3.id = uuid();\n      } else if (number$1(_data3.id)) {\n        _data3.id = '' + _data3.id; // now it's a string\n      } else if (emptyString(_data3.id) || !string(_data3.id)) {\n        error('Can not create element with invalid string ID `' + _data3.id + '`'); // can't create element if it has empty string as id or non-string id\n\n        removeFromElements();\n        continue;\n      } else if (cy.hasElementWithId(_data3.id)) {\n        error('Can not create second element with ID `' + _data3.id + '`'); // can't create element if one already has that id\n\n        removeFromElements();\n        continue;\n      }\n\n      var id = _data3.id; // id is finalised, now let's keep a ref\n\n      if (_ele2.isNode()) {\n        // extra checks for nodes\n        var pos = _private.position; // make sure the nodes have a defined position\n\n        if (pos.x == null) {\n          pos.x = 0;\n        }\n\n        if (pos.y == null) {\n          pos.y = 0;\n        }\n      }\n\n      if (_ele2.isEdge()) {\n        // extra checks for edges\n        var edge = _ele2;\n        var fields = ['source', 'target'];\n        var fieldsLength = fields.length;\n        var badSourceOrTarget = false;\n\n        for (var j = 0; j < fieldsLength; j++) {\n          var field = fields[j];\n          var val = _data3[field];\n\n          if (number$1(val)) {\n            val = _data3[field] = '' + _data3[field]; // now string\n          }\n\n          if (val == null || val === '') {\n            // can't create if source or target is not defined properly\n            error('Can not create edge `' + id + '` with unspecified ' + field);\n            badSourceOrTarget = true;\n          } else if (!cy.hasElementWithId(val)) {\n            // can't create edge if one of its nodes doesn't exist\n            error('Can not create edge `' + id + '` with nonexistant ' + field + ' `' + val + '`');\n            badSourceOrTarget = true;\n          }\n        }\n\n        if (badSourceOrTarget) {\n          removeFromElements();\n          continue;\n        } // can't create this\n\n\n        var src = cy.getElementById(_data3.source);\n        var tgt = cy.getElementById(_data3.target); // only one edge in node if loop\n\n        if (src.same(tgt)) {\n          src._private.edges.push(edge);\n        } else {\n          src._private.edges.push(edge);\n\n          tgt._private.edges.push(edge);\n        }\n\n        edge._private.source = src;\n        edge._private.target = tgt;\n      } // if is edge\n      // create mock ids / indexes maps for element so it can be used like collections\n\n\n      _private.map = new Map$2();\n\n      _private.map.set(id, {\n        ele: _ele2,\n        index: 0\n      });\n\n      _private.removed = false;\n\n      if (addToPool) {\n        cy.addToPool(_ele2);\n      }\n    } // for each element\n    // do compound node sanity checks\n\n\n    for (var _i4 = 0; _i4 < nodes.length; _i4++) {\n      // each node\n      var node = nodes[_i4];\n      var _data4 = node._private.data;\n\n      if (number$1(_data4.parent)) {\n        // then automake string\n        _data4.parent = '' + _data4.parent;\n      }\n\n      var parentId = _data4.parent;\n      var specifiedParent = parentId != null;\n\n      if (specifiedParent || node._private.parent) {\n        var parent = node._private.parent ? cy.collection().merge(node._private.parent) : cy.getElementById(parentId);\n\n        if (parent.empty()) {\n          // non-existant parent; just remove it\n          _data4.parent = undefined;\n        } else if (parent[0].removed()) {\n          warn('Node added with missing parent, reference to parent removed');\n          _data4.parent = undefined;\n          node._private.parent = null;\n        } else {\n          var selfAsParent = false;\n          var ancestor = parent;\n\n          while (!ancestor.empty()) {\n            if (node.same(ancestor)) {\n              // mark self as parent and remove from data\n              selfAsParent = true;\n              _data4.parent = undefined; // remove parent reference\n              // exit or we loop forever\n\n              break;\n            }\n\n            ancestor = ancestor.parent();\n          }\n\n          if (!selfAsParent) {\n            // connect with children\n            parent[0]._private.children.push(node);\n\n            node._private.parent = parent[0]; // let the core know we have a compound graph\n\n            cy_p.hasCompoundNodes = true;\n          }\n        } // else\n\n      } // if specified parent\n\n    } // for each node\n\n\n    if (elements.length > 0) {\n      var restored = elements.length === self.length ? self : new Collection(cy, elements);\n\n      for (var _i5 = 0; _i5 < restored.length; _i5++) {\n        var _ele3 = restored[_i5];\n\n        if (_ele3.isNode()) {\n          continue;\n        } // adding an edge invalidates the traversal caches for the parallel edges\n\n\n        _ele3.parallelEdges().clearTraversalCache(); // adding an edge invalidates the traversal cache for the connected nodes\n\n\n        _ele3.source().clearTraversalCache();\n\n        _ele3.target().clearTraversalCache();\n      }\n\n      var toUpdateStyle;\n\n      if (cy_p.hasCompoundNodes) {\n        toUpdateStyle = cy.collection().merge(restored).merge(restored.connectedNodes()).merge(restored.parent());\n      } else {\n        toUpdateStyle = restored;\n      }\n\n      toUpdateStyle.dirtyCompoundBoundsCache().dirtyBoundingBoxCache().updateStyle(notifyRenderer);\n\n      if (notifyRenderer) {\n        restored.emitAndNotify('add');\n      } else if (addToPool) {\n        restored.emit('add');\n      }\n    }\n\n    return self; // chainability\n  };\n\n  elesfn$1.removed = function () {\n    var ele = this[0];\n    return ele && ele._private.removed;\n  };\n\n  elesfn$1.inside = function () {\n    var ele = this[0];\n    return ele && !ele._private.removed;\n  };\n\n  elesfn$1.remove = function () {\n    var notifyRenderer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    var removeFromPool = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var self = this;\n    var elesToRemove = [];\n    var elesToRemoveIds = {};\n    var cy = self._private.cy; // add connected edges\n\n    function addConnectedEdges(node) {\n      var edges = node._private.edges;\n\n      for (var i = 0; i < edges.length; i++) {\n        add(edges[i]);\n      }\n    } // add descendant nodes\n\n\n    function addChildren(node) {\n      var children = node._private.children;\n\n      for (var i = 0; i < children.length; i++) {\n        add(children[i]);\n      }\n    }\n\n    function add(ele) {\n      var alreadyAdded = elesToRemoveIds[ele.id()];\n\n      if (removeFromPool && ele.removed() || alreadyAdded) {\n        return;\n      } else {\n        elesToRemoveIds[ele.id()] = true;\n      }\n\n      if (ele.isNode()) {\n        elesToRemove.push(ele); // nodes are removed last\n\n        addConnectedEdges(ele);\n        addChildren(ele);\n      } else {\n        elesToRemove.unshift(ele); // edges are removed first\n      }\n    } // make the list of elements to remove\n    // (may be removing more than specified due to connected edges etc)\n\n\n    for (var i = 0, l = self.length; i < l; i++) {\n      var ele = self[i];\n      add(ele);\n    }\n\n    function removeEdgeRef(node, edge) {\n      var connectedEdges = node._private.edges;\n      removeFromArray(connectedEdges, edge); // removing an edges invalidates the traversal cache for its nodes\n\n      node.clearTraversalCache();\n    }\n\n    function removeParallelRef(pllEdge) {\n      // removing an edge invalidates the traversal caches for the parallel edges\n      pllEdge.clearTraversalCache();\n    }\n\n    var alteredParents = [];\n    alteredParents.ids = {};\n\n    function removeChildRef(parent, ele) {\n      ele = ele[0];\n      parent = parent[0];\n      var children = parent._private.children;\n      var pid = parent.id();\n      removeFromArray(children, ele); // remove parent => child ref\n\n      ele._private.parent = null; // remove child => parent ref\n\n      if (!alteredParents.ids[pid]) {\n        alteredParents.ids[pid] = true;\n        alteredParents.push(parent);\n      }\n    }\n\n    self.dirtyCompoundBoundsCache();\n\n    if (removeFromPool) {\n      cy.removeFromPool(elesToRemove); // remove from core pool\n    }\n\n    for (var _i6 = 0; _i6 < elesToRemove.length; _i6++) {\n      var _ele4 = elesToRemove[_i6];\n\n      if (_ele4.isEdge()) {\n        // remove references to this edge in its connected nodes\n        var src = _ele4.source()[0];\n\n        var tgt = _ele4.target()[0];\n\n        removeEdgeRef(src, _ele4);\n        removeEdgeRef(tgt, _ele4);\n\n        var pllEdges = _ele4.parallelEdges();\n\n        for (var j = 0; j < pllEdges.length; j++) {\n          var pllEdge = pllEdges[j];\n          removeParallelRef(pllEdge);\n\n          if (pllEdge.isBundledBezier()) {\n            pllEdge.dirtyBoundingBoxCache();\n          }\n        }\n      } else {\n        // remove reference to parent\n        var parent = _ele4.parent();\n\n        if (parent.length !== 0) {\n          removeChildRef(parent, _ele4);\n        }\n      }\n\n      if (removeFromPool) {\n        // mark as removed\n        _ele4._private.removed = true;\n      }\n    } // check to see if we have a compound graph or not\n\n\n    var elesStillInside = cy._private.elements;\n    cy._private.hasCompoundNodes = false;\n\n    for (var _i7 = 0; _i7 < elesStillInside.length; _i7++) {\n      var _ele5 = elesStillInside[_i7];\n\n      if (_ele5.isParent()) {\n        cy._private.hasCompoundNodes = true;\n        break;\n      }\n    }\n\n    var removedElements = new Collection(this.cy(), elesToRemove);\n\n    if (removedElements.size() > 0) {\n      // must manually notify since trigger won't do this automatically once removed\n      if (notifyRenderer) {\n        removedElements.emitAndNotify('remove');\n      } else if (removeFromPool) {\n        removedElements.emit('remove');\n      }\n    } // the parents who were modified by the removal need their style updated\n\n\n    for (var _i8 = 0; _i8 < alteredParents.length; _i8++) {\n      var _ele6 = alteredParents[_i8];\n\n      if (!removeFromPool || !_ele6.removed()) {\n        _ele6.updateStyle();\n      }\n    }\n\n    return removedElements;\n  };\n\n  elesfn$1.move = function (struct) {\n    var cy = this._private.cy;\n    var eles = this; // just clean up refs, caches, etc. in the same way as when removing and then restoring\n    // (our calls to remove/restore do not remove from the graph or make events)\n\n    var notifyRenderer = false;\n    var modifyPool = false;\n\n    var toString = function toString(id) {\n      return id == null ? id : '' + id;\n    }; // id must be string\n\n\n    if (struct.source !== undefined || struct.target !== undefined) {\n      var srcId = toString(struct.source);\n      var tgtId = toString(struct.target);\n      var srcExists = srcId != null && cy.hasElementWithId(srcId);\n      var tgtExists = tgtId != null && cy.hasElementWithId(tgtId);\n\n      if (srcExists || tgtExists) {\n        cy.batch(function () {\n          // avoid duplicate style updates\n          eles.remove(notifyRenderer, modifyPool); // clean up refs etc.\n\n          eles.emitAndNotify('moveout');\n\n          for (var i = 0; i < eles.length; i++) {\n            var ele = eles[i];\n            var _data5 = ele._private.data;\n\n            if (ele.isEdge()) {\n              if (srcExists) {\n                _data5.source = srcId;\n              }\n\n              if (tgtExists) {\n                _data5.target = tgtId;\n              }\n            }\n          }\n\n          eles.restore(notifyRenderer, modifyPool); // make new refs, style, etc.\n        });\n        eles.emitAndNotify('move');\n      }\n    } else if (struct.parent !== undefined) {\n      // move node to new parent\n      var parentId = toString(struct.parent);\n      var parentExists = parentId === null || cy.hasElementWithId(parentId);\n\n      if (parentExists) {\n        var pidToAssign = parentId === null ? undefined : parentId;\n        cy.batch(function () {\n          // avoid duplicate style updates\n          var updated = eles.remove(notifyRenderer, modifyPool); // clean up refs etc.\n\n          updated.emitAndNotify('moveout');\n\n          for (var i = 0; i < eles.length; i++) {\n            var ele = eles[i];\n            var _data6 = ele._private.data;\n\n            if (ele.isNode()) {\n              _data6.parent = pidToAssign;\n            }\n          }\n\n          updated.restore(notifyRenderer, modifyPool); // make new refs, style, etc.\n        });\n        eles.emitAndNotify('move');\n      }\n    }\n\n    return this;\n  };\n\n  [elesfn$j, elesfn$i, elesfn$h, elesfn$g, elesfn$f, data, elesfn$d, dimensions, elesfn$9, elesfn$8, elesfn$7, elesfn$6, elesfn$5, elesfn$4, elesfn$3, elesfn$2].forEach(function (props) {\n    extend(elesfn$1, props);\n  });\n\n  var corefn$9 = {\n    add: function add(opts) {\n      var elements;\n      var cy = this; // add the elements\n\n      if (elementOrCollection(opts)) {\n        var eles = opts;\n\n        if (eles._private.cy === cy) {\n          // same instance => just restore\n          elements = eles.restore();\n        } else {\n          // otherwise, copy from json\n          var jsons = [];\n\n          for (var i = 0; i < eles.length; i++) {\n            var ele = eles[i];\n            jsons.push(ele.json());\n          }\n\n          elements = new Collection(cy, jsons);\n        }\n      } // specify an array of options\n      else if (array(opts)) {\n        var _jsons = opts;\n        elements = new Collection(cy, _jsons);\n      } // specify via opts.nodes and opts.edges\n      else if (plainObject(opts) && (array(opts.nodes) || array(opts.edges))) {\n        var elesByGroup = opts;\n        var _jsons2 = [];\n        var grs = ['nodes', 'edges'];\n\n        for (var _i = 0, il = grs.length; _i < il; _i++) {\n          var group = grs[_i];\n          var elesArray = elesByGroup[group];\n\n          if (array(elesArray)) {\n            for (var j = 0, jl = elesArray.length; j < jl; j++) {\n              var json = extend({\n                group: group\n              }, elesArray[j]);\n\n              _jsons2.push(json);\n            }\n          }\n        }\n\n        elements = new Collection(cy, _jsons2);\n      } // specify options for one element\n      else {\n        var _json = opts;\n        elements = new Element(cy, _json).collection();\n      }\n\n      return elements;\n    },\n    remove: function remove(collection) {\n      if (elementOrCollection(collection)) ; else if (string(collection)) {\n        var selector = collection;\n        collection = this.$(selector);\n      }\n\n      return collection.remove();\n    }\n  };\n\n  /* global Float32Array */\n\n  /*! Bezier curve function generator. Copyright Gaetan Renaudeau. MIT License: http://en.wikipedia.org/wiki/MIT_License */\n  function generateCubicBezier(mX1, mY1, mX2, mY2) {\n    var NEWTON_ITERATIONS = 4,\n        NEWTON_MIN_SLOPE = 0.001,\n        SUBDIVISION_PRECISION = 0.0000001,\n        SUBDIVISION_MAX_ITERATIONS = 10,\n        kSplineTableSize = 11,\n        kSampleStepSize = 1.0 / (kSplineTableSize - 1.0),\n        float32ArraySupported = typeof Float32Array !== 'undefined';\n    /* Must contain four arguments. */\n\n    if (arguments.length !== 4) {\n      return false;\n    }\n    /* Arguments must be numbers. */\n\n\n    for (var i = 0; i < 4; ++i) {\n      if (typeof arguments[i] !== \"number\" || isNaN(arguments[i]) || !isFinite(arguments[i])) {\n        return false;\n      }\n    }\n    /* X values must be in the [0, 1] range. */\n\n\n    mX1 = Math.min(mX1, 1);\n    mX2 = Math.min(mX2, 1);\n    mX1 = Math.max(mX1, 0);\n    mX2 = Math.max(mX2, 0);\n    var mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\n\n    function A(aA1, aA2) {\n      return 1.0 - 3.0 * aA2 + 3.0 * aA1;\n    }\n\n    function B(aA1, aA2) {\n      return 3.0 * aA2 - 6.0 * aA1;\n    }\n\n    function C(aA1) {\n      return 3.0 * aA1;\n    }\n\n    function calcBezier(aT, aA1, aA2) {\n      return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;\n    }\n\n    function getSlope(aT, aA1, aA2) {\n      return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\n    }\n\n    function newtonRaphsonIterate(aX, aGuessT) {\n      for (var _i = 0; _i < NEWTON_ITERATIONS; ++_i) {\n        var currentSlope = getSlope(aGuessT, mX1, mX2);\n\n        if (currentSlope === 0.0) {\n          return aGuessT;\n        }\n\n        var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n        aGuessT -= currentX / currentSlope;\n      }\n\n      return aGuessT;\n    }\n\n    function calcSampleValues() {\n      for (var _i2 = 0; _i2 < kSplineTableSize; ++_i2) {\n        mSampleValues[_i2] = calcBezier(_i2 * kSampleStepSize, mX1, mX2);\n      }\n    }\n\n    function binarySubdivide(aX, aA, aB) {\n      var currentX,\n          currentT,\n          i = 0;\n\n      do {\n        currentT = aA + (aB - aA) / 2.0;\n        currentX = calcBezier(currentT, mX1, mX2) - aX;\n\n        if (currentX > 0.0) {\n          aB = currentT;\n        } else {\n          aA = currentT;\n        }\n      } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n\n      return currentT;\n    }\n\n    function getTForX(aX) {\n      var intervalStart = 0.0,\n          currentSample = 1,\n          lastSample = kSplineTableSize - 1;\n\n      for (; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {\n        intervalStart += kSampleStepSize;\n      }\n\n      --currentSample;\n      var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample + 1] - mSampleValues[currentSample]),\n          guessForT = intervalStart + dist * kSampleStepSize,\n          initialSlope = getSlope(guessForT, mX1, mX2);\n\n      if (initialSlope >= NEWTON_MIN_SLOPE) {\n        return newtonRaphsonIterate(aX, guessForT);\n      } else if (initialSlope === 0.0) {\n        return guessForT;\n      } else {\n        return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize);\n      }\n    }\n\n    var _precomputed = false;\n\n    function precompute() {\n      _precomputed = true;\n\n      if (mX1 !== mY1 || mX2 !== mY2) {\n        calcSampleValues();\n      }\n    }\n\n    var f = function f(aX) {\n      if (!_precomputed) {\n        precompute();\n      }\n\n      if (mX1 === mY1 && mX2 === mY2) {\n        return aX;\n      }\n\n      if (aX === 0) {\n        return 0;\n      }\n\n      if (aX === 1) {\n        return 1;\n      }\n\n      return calcBezier(getTForX(aX), mY1, mY2);\n    };\n\n    f.getControlPoints = function () {\n      return [{\n        x: mX1,\n        y: mY1\n      }, {\n        x: mX2,\n        y: mY2\n      }];\n    };\n\n    var str = \"generateBezier(\" + [mX1, mY1, mX2, mY2] + \")\";\n\n    f.toString = function () {\n      return str;\n    };\n\n    return f;\n  }\n\n  /*! Runge-Kutta spring physics function generator. Adapted from Framer.js, copyright Koen Bok. MIT License: http://en.wikipedia.org/wiki/MIT_License */\n\n  /* Given a tension, friction, and duration, a simulation at 60FPS will first run without a defined duration in order to calculate the full path. A second pass\n     then adjusts the time delta -- using the relation between actual time and duration -- to calculate the path for the duration-constrained animation. */\n  var generateSpringRK4 = function () {\n    function springAccelerationForState(state) {\n      return -state.tension * state.x - state.friction * state.v;\n    }\n\n    function springEvaluateStateWithDerivative(initialState, dt, derivative) {\n      var state = {\n        x: initialState.x + derivative.dx * dt,\n        v: initialState.v + derivative.dv * dt,\n        tension: initialState.tension,\n        friction: initialState.friction\n      };\n      return {\n        dx: state.v,\n        dv: springAccelerationForState(state)\n      };\n    }\n\n    function springIntegrateState(state, dt) {\n      var a = {\n        dx: state.v,\n        dv: springAccelerationForState(state)\n      },\n          b = springEvaluateStateWithDerivative(state, dt * 0.5, a),\n          c = springEvaluateStateWithDerivative(state, dt * 0.5, b),\n          d = springEvaluateStateWithDerivative(state, dt, c),\n          dxdt = 1.0 / 6.0 * (a.dx + 2.0 * (b.dx + c.dx) + d.dx),\n          dvdt = 1.0 / 6.0 * (a.dv + 2.0 * (b.dv + c.dv) + d.dv);\n      state.x = state.x + dxdt * dt;\n      state.v = state.v + dvdt * dt;\n      return state;\n    }\n\n    return function springRK4Factory(tension, friction, duration) {\n      var initState = {\n        x: -1,\n        v: 0,\n        tension: null,\n        friction: null\n      },\n          path = [0],\n          time_lapsed = 0,\n          tolerance = 1 / 10000,\n          DT = 16 / 1000,\n          have_duration,\n          dt,\n          last_state;\n      tension = parseFloat(tension) || 500;\n      friction = parseFloat(friction) || 20;\n      duration = duration || null;\n      initState.tension = tension;\n      initState.friction = friction;\n      have_duration = duration !== null;\n      /* Calculate the actual time it takes for this animation to complete with the provided conditions. */\n\n      if (have_duration) {\n        /* Run the simulation without a duration. */\n        time_lapsed = springRK4Factory(tension, friction);\n        /* Compute the adjusted time delta. */\n\n        dt = time_lapsed / duration * DT;\n      } else {\n        dt = DT;\n      }\n\n      for (;;) {\n        /* Next/step function .*/\n        last_state = springIntegrateState(last_state || initState, dt);\n        /* Store the position. */\n\n        path.push(1 + last_state.x);\n        time_lapsed += 16;\n        /* If the change threshold is reached, break. */\n\n        if (!(Math.abs(last_state.x) > tolerance && Math.abs(last_state.v) > tolerance)) {\n          break;\n        }\n      }\n      /* If duration is not defined, return the actual time required for completing this animation. Otherwise, return a closure that holds the\n         computed path and returns a snapshot of the position according to a given percentComplete. */\n\n\n      return !have_duration ? time_lapsed : function (percentComplete) {\n        return path[percentComplete * (path.length - 1) | 0];\n      };\n    };\n  }();\n\n  var cubicBezier = function cubicBezier(t1, p1, t2, p2) {\n    var bezier = generateCubicBezier(t1, p1, t2, p2);\n    return function (start, end, percent) {\n      return start + (end - start) * bezier(percent);\n    };\n  };\n\n  var easings = {\n    'linear': function linear(start, end, percent) {\n      return start + (end - start) * percent;\n    },\n    // default easings\n    'ease': cubicBezier(0.25, 0.1, 0.25, 1),\n    'ease-in': cubicBezier(0.42, 0, 1, 1),\n    'ease-out': cubicBezier(0, 0, 0.58, 1),\n    'ease-in-out': cubicBezier(0.42, 0, 0.58, 1),\n    // sine\n    'ease-in-sine': cubicBezier(0.47, 0, 0.745, 0.715),\n    'ease-out-sine': cubicBezier(0.39, 0.575, 0.565, 1),\n    'ease-in-out-sine': cubicBezier(0.445, 0.05, 0.55, 0.95),\n    // quad\n    'ease-in-quad': cubicBezier(0.55, 0.085, 0.68, 0.53),\n    'ease-out-quad': cubicBezier(0.25, 0.46, 0.45, 0.94),\n    'ease-in-out-quad': cubicBezier(0.455, 0.03, 0.515, 0.955),\n    // cubic\n    'ease-in-cubic': cubicBezier(0.55, 0.055, 0.675, 0.19),\n    'ease-out-cubic': cubicBezier(0.215, 0.61, 0.355, 1),\n    'ease-in-out-cubic': cubicBezier(0.645, 0.045, 0.355, 1),\n    // quart\n    'ease-in-quart': cubicBezier(0.895, 0.03, 0.685, 0.22),\n    'ease-out-quart': cubicBezier(0.165, 0.84, 0.44, 1),\n    'ease-in-out-quart': cubicBezier(0.77, 0, 0.175, 1),\n    // quint\n    'ease-in-quint': cubicBezier(0.755, 0.05, 0.855, 0.06),\n    'ease-out-quint': cubicBezier(0.23, 1, 0.32, 1),\n    'ease-in-out-quint': cubicBezier(0.86, 0, 0.07, 1),\n    // expo\n    'ease-in-expo': cubicBezier(0.95, 0.05, 0.795, 0.035),\n    'ease-out-expo': cubicBezier(0.19, 1, 0.22, 1),\n    'ease-in-out-expo': cubicBezier(1, 0, 0, 1),\n    // circ\n    'ease-in-circ': cubicBezier(0.6, 0.04, 0.98, 0.335),\n    'ease-out-circ': cubicBezier(0.075, 0.82, 0.165, 1),\n    'ease-in-out-circ': cubicBezier(0.785, 0.135, 0.15, 0.86),\n    // user param easings...\n    'spring': function spring(tension, friction, duration) {\n      if (duration === 0) {\n        // can't get a spring w/ duration 0\n        return easings.linear; // duration 0 => jump to end so impl doesn't matter\n      }\n\n      var spring = generateSpringRK4(tension, friction, duration);\n      return function (start, end, percent) {\n        return start + (end - start) * spring(percent);\n      };\n    },\n    'cubic-bezier': cubicBezier\n  };\n\n  function getEasedValue(type, start, end, percent, easingFn) {\n    if (percent === 1) {\n      return end;\n    }\n\n    if (start === end) {\n      return end;\n    }\n\n    var val = easingFn(start, end, percent);\n\n    if (type == null) {\n      return val;\n    }\n\n    if (type.roundValue || type.color) {\n      val = Math.round(val);\n    }\n\n    if (type.min !== undefined) {\n      val = Math.max(val, type.min);\n    }\n\n    if (type.max !== undefined) {\n      val = Math.min(val, type.max);\n    }\n\n    return val;\n  }\n\n  function getValue(prop, spec) {\n    if (prop.pfValue != null || prop.value != null) {\n      if (prop.pfValue != null && (spec == null || spec.type.units !== '%')) {\n        return prop.pfValue;\n      } else {\n        return prop.value;\n      }\n    } else {\n      return prop;\n    }\n  }\n\n  function ease(startProp, endProp, percent, easingFn, propSpec) {\n    var type = propSpec != null ? propSpec.type : null;\n\n    if (percent < 0) {\n      percent = 0;\n    } else if (percent > 1) {\n      percent = 1;\n    }\n\n    var start = getValue(startProp, propSpec);\n    var end = getValue(endProp, propSpec);\n\n    if (number$1(start) && number$1(end)) {\n      return getEasedValue(type, start, end, percent, easingFn);\n    } else if (array(start) && array(end)) {\n      var easedArr = [];\n\n      for (var i = 0; i < end.length; i++) {\n        var si = start[i];\n        var ei = end[i];\n\n        if (si != null && ei != null) {\n          var val = getEasedValue(type, si, ei, percent, easingFn);\n          easedArr.push(val);\n        } else {\n          easedArr.push(ei);\n        }\n      }\n\n      return easedArr;\n    }\n\n    return undefined;\n  }\n\n  function step$1(self, ani, now, isCore) {\n    var isEles = !isCore;\n    var _p = self._private;\n    var ani_p = ani._private;\n    var pEasing = ani_p.easing;\n    var startTime = ani_p.startTime;\n    var cy = isCore ? self : self.cy();\n    var style = cy.style();\n\n    if (!ani_p.easingImpl) {\n      if (pEasing == null) {\n        // use default\n        ani_p.easingImpl = easings['linear'];\n      } else {\n        // then define w/ name\n        var easingVals;\n\n        if (string(pEasing)) {\n          var easingProp = style.parse('transition-timing-function', pEasing);\n          easingVals = easingProp.value;\n        } else {\n          // then assume preparsed array\n          easingVals = pEasing;\n        }\n\n        var name, args;\n\n        if (string(easingVals)) {\n          name = easingVals;\n          args = [];\n        } else {\n          name = easingVals[1];\n          args = easingVals.slice(2).map(function (n) {\n            return +n;\n          });\n        }\n\n        if (args.length > 0) {\n          // create with args\n          if (name === 'spring') {\n            args.push(ani_p.duration); // need duration to generate spring\n          }\n\n          ani_p.easingImpl = easings[name].apply(null, args);\n        } else {\n          // static impl by name\n          ani_p.easingImpl = easings[name];\n        }\n      }\n    }\n\n    var easing = ani_p.easingImpl;\n    var percent;\n\n    if (ani_p.duration === 0) {\n      percent = 1;\n    } else {\n      percent = (now - startTime) / ani_p.duration;\n    }\n\n    if (ani_p.applying) {\n      percent = ani_p.progress;\n    }\n\n    if (percent < 0) {\n      percent = 0;\n    } else if (percent > 1) {\n      percent = 1;\n    }\n\n    if (ani_p.delay == null) {\n      // then update\n      var startPos = ani_p.startPosition;\n      var endPos = ani_p.position;\n\n      if (endPos && isEles && !self.locked()) {\n        var newPos = {};\n\n        if (valid(startPos.x, endPos.x)) {\n          newPos.x = ease(startPos.x, endPos.x, percent, easing);\n        }\n\n        if (valid(startPos.y, endPos.y)) {\n          newPos.y = ease(startPos.y, endPos.y, percent, easing);\n        }\n\n        self.position(newPos);\n      }\n\n      var startPan = ani_p.startPan;\n      var endPan = ani_p.pan;\n      var pan = _p.pan;\n      var animatingPan = endPan != null && isCore;\n\n      if (animatingPan) {\n        if (valid(startPan.x, endPan.x)) {\n          pan.x = ease(startPan.x, endPan.x, percent, easing);\n        }\n\n        if (valid(startPan.y, endPan.y)) {\n          pan.y = ease(startPan.y, endPan.y, percent, easing);\n        }\n\n        self.emit('pan');\n      }\n\n      var startZoom = ani_p.startZoom;\n      var endZoom = ani_p.zoom;\n      var animatingZoom = endZoom != null && isCore;\n\n      if (animatingZoom) {\n        if (valid(startZoom, endZoom)) {\n          _p.zoom = bound(_p.minZoom, ease(startZoom, endZoom, percent, easing), _p.maxZoom);\n        }\n\n        self.emit('zoom');\n      }\n\n      if (animatingPan || animatingZoom) {\n        self.emit('viewport');\n      }\n\n      var props = ani_p.style;\n\n      if (props && props.length > 0 && isEles) {\n        for (var i = 0; i < props.length; i++) {\n          var prop = props[i];\n          var _name = prop.name;\n          var end = prop;\n          var start = ani_p.startStyle[_name];\n          var propSpec = style.properties[start.name];\n          var easedVal = ease(start, end, percent, easing, propSpec);\n          style.overrideBypass(self, _name, easedVal);\n        } // for props\n\n\n        self.emit('style');\n      } // if\n\n    }\n\n    ani_p.progress = percent;\n    return percent;\n  }\n\n  function valid(start, end) {\n    if (start == null || end == null) {\n      return false;\n    }\n\n    if (number$1(start) && number$1(end)) {\n      return true;\n    } else if (start && end) {\n      return true;\n    }\n\n    return false;\n  }\n\n  function startAnimation(self, ani, now, isCore) {\n    var ani_p = ani._private;\n    ani_p.started = true;\n    ani_p.startTime = now - ani_p.progress * ani_p.duration;\n  }\n\n  function stepAll(now, cy) {\n    var eles = cy._private.aniEles;\n    var doneEles = [];\n\n    function stepOne(ele, isCore) {\n      var _p = ele._private;\n      var current = _p.animation.current;\n      var queue = _p.animation.queue;\n      var ranAnis = false; // if nothing currently animating, get something from the queue\n\n      if (current.length === 0) {\n        var next = queue.shift();\n\n        if (next) {\n          current.push(next);\n        }\n      }\n\n      var callbacks = function callbacks(_callbacks) {\n        for (var j = _callbacks.length - 1; j >= 0; j--) {\n          var cb = _callbacks[j];\n          cb();\n        }\n\n        _callbacks.splice(0, _callbacks.length);\n      }; // step and remove if done\n\n\n      for (var i = current.length - 1; i >= 0; i--) {\n        var ani = current[i];\n        var ani_p = ani._private;\n\n        if (ani_p.stopped) {\n          current.splice(i, 1);\n          ani_p.hooked = false;\n          ani_p.playing = false;\n          ani_p.started = false;\n          callbacks(ani_p.frames);\n          continue;\n        }\n\n        if (!ani_p.playing && !ani_p.applying) {\n          continue;\n        } // an apply() while playing shouldn't do anything\n\n\n        if (ani_p.playing && ani_p.applying) {\n          ani_p.applying = false;\n        }\n\n        if (!ani_p.started) {\n          startAnimation(ele, ani, now);\n        }\n\n        step$1(ele, ani, now, isCore);\n\n        if (ani_p.applying) {\n          ani_p.applying = false;\n        }\n\n        callbacks(ani_p.frames);\n\n        if (ani_p.step != null) {\n          ani_p.step(now);\n        }\n\n        if (ani.completed()) {\n          current.splice(i, 1);\n          ani_p.hooked = false;\n          ani_p.playing = false;\n          ani_p.started = false;\n          callbacks(ani_p.completes);\n        }\n\n        ranAnis = true;\n      }\n\n      if (!isCore && current.length === 0 && queue.length === 0) {\n        doneEles.push(ele);\n      }\n\n      return ranAnis;\n    } // stepElement\n    // handle all eles\n\n\n    var ranEleAni = false;\n\n    for (var e = 0; e < eles.length; e++) {\n      var ele = eles[e];\n      var handledThisEle = stepOne(ele);\n      ranEleAni = ranEleAni || handledThisEle;\n    } // each element\n\n\n    var ranCoreAni = stepOne(cy, true); // notify renderer\n\n    if (ranEleAni || ranCoreAni) {\n      if (eles.length > 0) {\n        cy.notify('draw', eles);\n      } else {\n        cy.notify('draw');\n      }\n    } // remove elements from list of currently animating if its queues are empty\n\n\n    eles.unmerge(doneEles);\n    cy.emit('step');\n  } // stepAll\n\n  var corefn$8 = {\n    // pull in animation functions\n    animate: define.animate(),\n    animation: define.animation(),\n    animated: define.animated(),\n    clearQueue: define.clearQueue(),\n    delay: define.delay(),\n    delayAnimation: define.delayAnimation(),\n    stop: define.stop(),\n    addToAnimationPool: function addToAnimationPool(eles) {\n      var cy = this;\n\n      if (!cy.styleEnabled()) {\n        return;\n      } // save cycles when no style used\n\n\n      cy._private.aniEles.merge(eles);\n    },\n    stopAnimationLoop: function stopAnimationLoop() {\n      this._private.animationsRunning = false;\n    },\n    startAnimationLoop: function startAnimationLoop() {\n      var cy = this;\n      cy._private.animationsRunning = true;\n\n      if (!cy.styleEnabled()) {\n        return;\n      } // save cycles when no style used\n      // NB the animation loop will exec in headless environments if style enabled\n      // and explicit cy.destroy() is necessary to stop the loop\n\n\n      function headlessStep() {\n        if (!cy._private.animationsRunning) {\n          return;\n        }\n\n        requestAnimationFrame(function animationStep(now) {\n          stepAll(now, cy);\n          headlessStep();\n        });\n      }\n\n      var renderer = cy.renderer();\n\n      if (renderer && renderer.beforeRender) {\n        // let the renderer schedule animations\n        renderer.beforeRender(function rendererAnimationStep(willDraw, now) {\n          stepAll(now, cy);\n        }, renderer.beforeRenderPriorities.animations);\n      } else {\n        // manage the animation loop ourselves\n        headlessStep(); // first call\n      }\n    }\n  };\n\n  var emitterOptions = {\n    qualifierCompare: function qualifierCompare(selector1, selector2) {\n      if (selector1 == null || selector2 == null) {\n        return selector1 == null && selector2 == null;\n      } else {\n        return selector1.sameText(selector2);\n      }\n    },\n    eventMatches: function eventMatches(cy, listener, eventObj) {\n      var selector = listener.qualifier;\n\n      if (selector != null) {\n        return cy !== eventObj.target && element(eventObj.target) && selector.matches(eventObj.target);\n      }\n\n      return true;\n    },\n    addEventFields: function addEventFields(cy, evt) {\n      evt.cy = cy;\n      evt.target = cy;\n    },\n    callbackContext: function callbackContext(cy, listener, eventObj) {\n      return listener.qualifier != null ? eventObj.target : cy;\n    }\n  };\n\n  var argSelector = function argSelector(arg) {\n    if (string(arg)) {\n      return new Selector(arg);\n    } else {\n      return arg;\n    }\n  };\n\n  var elesfn = {\n    createEmitter: function createEmitter() {\n      var _p = this._private;\n\n      if (!_p.emitter) {\n        _p.emitter = new Emitter(emitterOptions, this);\n      }\n\n      return this;\n    },\n    emitter: function emitter() {\n      return this._private.emitter;\n    },\n    on: function on(events, selector, callback) {\n      this.emitter().on(events, argSelector(selector), callback);\n      return this;\n    },\n    removeListener: function removeListener(events, selector, callback) {\n      this.emitter().removeListener(events, argSelector(selector), callback);\n      return this;\n    },\n    removeAllListeners: function removeAllListeners() {\n      this.emitter().removeAllListeners();\n      return this;\n    },\n    one: function one(events, selector, callback) {\n      this.emitter().one(events, argSelector(selector), callback);\n      return this;\n    },\n    once: function once(events, selector, callback) {\n      this.emitter().one(events, argSelector(selector), callback);\n      return this;\n    },\n    emit: function emit(events, extraParams) {\n      this.emitter().emit(events, extraParams);\n      return this;\n    },\n    emitAndNotify: function emitAndNotify(event, eles) {\n      this.emit(event);\n      this.notify(event, eles);\n      return this;\n    }\n  };\n  define.eventAliasesOn(elesfn);\n\n  var corefn$7 = {\n    png: function png(options) {\n      var renderer = this._private.renderer;\n      options = options || {};\n      return renderer.png(options);\n    },\n    jpg: function jpg(options) {\n      var renderer = this._private.renderer;\n      options = options || {};\n      options.bg = options.bg || '#fff';\n      return renderer.jpg(options);\n    }\n  };\n  corefn$7.jpeg = corefn$7.jpg;\n\n  var corefn$6 = {\n    layout: function layout(options) {\n      var cy = this;\n\n      if (options == null) {\n        error('Layout options must be specified to make a layout');\n        return;\n      }\n\n      if (options.name == null) {\n        error('A `name` must be specified to make a layout');\n        return;\n      }\n\n      var name = options.name;\n      var Layout = cy.extension('layout', name);\n\n      if (Layout == null) {\n        error('No such layout `' + name + '` found.  Did you forget to import it and `cytoscape.use()` it?');\n        return;\n      }\n\n      var eles;\n\n      if (string(options.eles)) {\n        eles = cy.$(options.eles);\n      } else {\n        eles = options.eles != null ? options.eles : cy.$();\n      }\n\n      var layout = new Layout(extend({}, options, {\n        cy: cy,\n        eles: eles\n      }));\n      return layout;\n    }\n  };\n  corefn$6.createLayout = corefn$6.makeLayout = corefn$6.layout;\n\n  var corefn$5 = {\n    notify: function notify(eventName, eventEles) {\n      var _p = this._private;\n\n      if (this.batching()) {\n        _p.batchNotifications = _p.batchNotifications || {};\n        var eles = _p.batchNotifications[eventName] = _p.batchNotifications[eventName] || this.collection();\n\n        if (eventEles != null) {\n          eles.merge(eventEles);\n        }\n\n        return; // notifications are disabled during batching\n      }\n\n      if (!_p.notificationsEnabled) {\n        return;\n      } // exit on disabled\n\n\n      var renderer = this.renderer(); // exit if destroy() called on core or renderer in between frames #1499 #1528\n\n      if (this.destroyed() || !renderer) {\n        return;\n      }\n\n      renderer.notify(eventName, eventEles);\n    },\n    notifications: function notifications(bool) {\n      var p = this._private;\n\n      if (bool === undefined) {\n        return p.notificationsEnabled;\n      } else {\n        p.notificationsEnabled = bool ? true : false;\n      }\n\n      return this;\n    },\n    noNotifications: function noNotifications(callback) {\n      this.notifications(false);\n      callback();\n      this.notifications(true);\n    },\n    batching: function batching() {\n      return this._private.batchCount > 0;\n    },\n    startBatch: function startBatch() {\n      var _p = this._private;\n\n      if (_p.batchCount == null) {\n        _p.batchCount = 0;\n      }\n\n      if (_p.batchCount === 0) {\n        _p.batchStyleEles = this.collection();\n        _p.batchNotifications = {};\n      }\n\n      _p.batchCount++;\n      return this;\n    },\n    endBatch: function endBatch() {\n      var _p = this._private;\n\n      if (_p.batchCount === 0) {\n        return this;\n      }\n\n      _p.batchCount--;\n\n      if (_p.batchCount === 0) {\n        // update style for dirty eles\n        _p.batchStyleEles.updateStyle();\n\n        var renderer = this.renderer(); // notify the renderer of queued eles and event types\n\n        Object.keys(_p.batchNotifications).forEach(function (eventName) {\n          var eles = _p.batchNotifications[eventName];\n\n          if (eles.empty()) {\n            renderer.notify(eventName);\n          } else {\n            renderer.notify(eventName, eles);\n          }\n        });\n      }\n\n      return this;\n    },\n    batch: function batch(callback) {\n      this.startBatch();\n      callback();\n      this.endBatch();\n      return this;\n    },\n    // for backwards compatibility\n    batchData: function batchData(map) {\n      var cy = this;\n      return this.batch(function () {\n        var ids = Object.keys(map);\n\n        for (var i = 0; i < ids.length; i++) {\n          var id = ids[i];\n          var data = map[id];\n          var ele = cy.getElementById(id);\n          ele.data(data);\n        }\n      });\n    }\n  };\n\n  var rendererDefaults = defaults$g({\n    hideEdgesOnViewport: false,\n    textureOnViewport: false,\n    motionBlur: false,\n    motionBlurOpacity: 0.05,\n    pixelRatio: undefined,\n    desktopTapThreshold: 4,\n    touchTapThreshold: 8,\n    wheelSensitivity: 1,\n    debug: false,\n    showFps: false\n  });\n  var corefn$4 = {\n    renderTo: function renderTo(context, zoom, pan, pxRatio) {\n      var r = this._private.renderer;\n      r.renderTo(context, zoom, pan, pxRatio);\n      return this;\n    },\n    renderer: function renderer() {\n      return this._private.renderer;\n    },\n    forceRender: function forceRender() {\n      this.notify('draw');\n      return this;\n    },\n    resize: function resize() {\n      this.invalidateSize();\n      this.emitAndNotify('resize');\n      return this;\n    },\n    initRenderer: function initRenderer(options) {\n      var cy = this;\n      var RendererProto = cy.extension('renderer', options.name);\n\n      if (RendererProto == null) {\n        error(\"Can not initialise: No such renderer `\".concat(options.name, \"` found. Did you forget to import it and `cytoscape.use()` it?\"));\n        return;\n      }\n\n      if (options.wheelSensitivity !== undefined) {\n        warn(\"You have set a custom wheel sensitivity.  This will make your app zoom unnaturally when using mainstream mice.  You should change this value from the default only if you can guarantee that all your users will use the same hardware and OS configuration as your current machine.\");\n      }\n\n      var rOpts = rendererDefaults(options);\n      rOpts.cy = cy;\n      cy._private.renderer = new RendererProto(rOpts);\n      this.notify('init');\n    },\n    destroyRenderer: function destroyRenderer() {\n      var cy = this;\n      cy.notify('destroy'); // destroy the renderer\n\n      var domEle = cy.container();\n\n      if (domEle) {\n        domEle._cyreg = null;\n\n        while (domEle.childNodes.length > 0) {\n          domEle.removeChild(domEle.childNodes[0]);\n        }\n      }\n\n      cy._private.renderer = null; // to be extra safe, remove the ref\n\n      cy.mutableElements().forEach(function (ele) {\n        var _p = ele._private;\n        _p.rscratch = {};\n        _p.rstyle = {};\n        _p.animation.current = [];\n        _p.animation.queue = [];\n      });\n    },\n    onRender: function onRender(fn) {\n      return this.on('render', fn);\n    },\n    offRender: function offRender(fn) {\n      return this.off('render', fn);\n    }\n  };\n  corefn$4.invalidateDimensions = corefn$4.resize;\n\n  var corefn$3 = {\n    // get a collection\n    // - empty collection on no args\n    // - collection of elements in the graph on selector arg\n    // - guarantee a returned collection when elements or collection specified\n    collection: function collection(eles, opts) {\n      if (string(eles)) {\n        return this.$(eles);\n      } else if (elementOrCollection(eles)) {\n        return eles.collection();\n      } else if (array(eles)) {\n        if (!opts) {\n          opts = {};\n        }\n\n        return new Collection(this, eles, opts.unique, opts.removed);\n      }\n\n      return new Collection(this);\n    },\n    nodes: function nodes(selector) {\n      var nodes = this.$(function (ele) {\n        return ele.isNode();\n      });\n\n      if (selector) {\n        return nodes.filter(selector);\n      }\n\n      return nodes;\n    },\n    edges: function edges(selector) {\n      var edges = this.$(function (ele) {\n        return ele.isEdge();\n      });\n\n      if (selector) {\n        return edges.filter(selector);\n      }\n\n      return edges;\n    },\n    // search the graph like jQuery\n    $: function $(selector) {\n      var eles = this._private.elements;\n\n      if (selector) {\n        return eles.filter(selector);\n      } else {\n        return eles.spawnSelf();\n      }\n    },\n    mutableElements: function mutableElements() {\n      return this._private.elements;\n    }\n  }; // aliases\n\n  corefn$3.elements = corefn$3.filter = corefn$3.$;\n\n  var styfn$8 = {}; // keys for style blocks, e.g. ttfftt\n\n  var TRUE = 't';\n  var FALSE = 'f'; // (potentially expensive calculation)\n  // apply the style to the element based on\n  // - its bypass\n  // - what selectors match it\n\n  styfn$8.apply = function (eles) {\n    var self = this;\n    var _p = self._private;\n    var cy = _p.cy;\n    var updatedEles = cy.collection();\n\n    for (var ie = 0; ie < eles.length; ie++) {\n      var ele = eles[ie];\n      var cxtMeta = self.getContextMeta(ele);\n\n      if (cxtMeta.empty) {\n        continue;\n      }\n\n      var cxtStyle = self.getContextStyle(cxtMeta);\n      var app = self.applyContextStyle(cxtMeta, cxtStyle, ele);\n\n      if (ele._private.appliedInitStyle) {\n        self.updateTransitions(ele, app.diffProps);\n      } else {\n        ele._private.appliedInitStyle = true;\n      }\n\n      var hintsDiff = self.updateStyleHints(ele);\n\n      if (hintsDiff) {\n        updatedEles.push(ele);\n      }\n    } // for elements\n\n\n    return updatedEles;\n  };\n\n  styfn$8.getPropertiesDiff = function (oldCxtKey, newCxtKey) {\n    var self = this;\n    var cache = self._private.propDiffs = self._private.propDiffs || {};\n    var dualCxtKey = oldCxtKey + '-' + newCxtKey;\n    var cachedVal = cache[dualCxtKey];\n\n    if (cachedVal) {\n      return cachedVal;\n    }\n\n    var diffProps = [];\n    var addedProp = {};\n\n    for (var i = 0; i < self.length; i++) {\n      var cxt = self[i];\n      var oldHasCxt = oldCxtKey[i] === TRUE;\n      var newHasCxt = newCxtKey[i] === TRUE;\n      var cxtHasDiffed = oldHasCxt !== newHasCxt;\n      var cxtHasMappedProps = cxt.mappedProperties.length > 0;\n\n      if (cxtHasDiffed || newHasCxt && cxtHasMappedProps) {\n        var props = void 0;\n\n        if (cxtHasDiffed && cxtHasMappedProps) {\n          props = cxt.properties; // suffices b/c mappedProperties is a subset of properties\n        } else if (cxtHasDiffed) {\n          props = cxt.properties; // need to check them all\n        } else if (cxtHasMappedProps) {\n          props = cxt.mappedProperties; // only need to check mapped\n        }\n\n        for (var j = 0; j < props.length; j++) {\n          var prop = props[j];\n          var name = prop.name; // if a later context overrides this property, then the fact that this context has switched/diffed doesn't matter\n          // (semi expensive check since it makes this function O(n^2) on context length, but worth it since overall result\n          // is cached)\n\n          var laterCxtOverrides = false;\n\n          for (var k = i + 1; k < self.length; k++) {\n            var laterCxt = self[k];\n            var hasLaterCxt = newCxtKey[k] === TRUE;\n\n            if (!hasLaterCxt) {\n              continue;\n            } // can't override unless the context is active\n\n\n            laterCxtOverrides = laterCxt.properties[prop.name] != null;\n\n            if (laterCxtOverrides) {\n              break;\n            } // exit early as long as one later context overrides\n\n          }\n\n          if (!addedProp[name] && !laterCxtOverrides) {\n            addedProp[name] = true;\n            diffProps.push(name);\n          }\n        } // for props\n\n      } // if\n\n    } // for contexts\n\n\n    cache[dualCxtKey] = diffProps;\n    return diffProps;\n  };\n\n  styfn$8.getContextMeta = function (ele) {\n    var self = this;\n    var cxtKey = '';\n    var diffProps;\n    var prevKey = ele._private.styleCxtKey || ''; // get the cxt key\n\n    for (var i = 0; i < self.length; i++) {\n      var context = self[i];\n      var contextSelectorMatches = context.selector && context.selector.matches(ele); // NB: context.selector may be null for 'core'\n\n      if (contextSelectorMatches) {\n        cxtKey += TRUE;\n      } else {\n        cxtKey += FALSE;\n      }\n    } // for context\n\n\n    diffProps = self.getPropertiesDiff(prevKey, cxtKey);\n    ele._private.styleCxtKey = cxtKey;\n    return {\n      key: cxtKey,\n      diffPropNames: diffProps,\n      empty: diffProps.length === 0\n    };\n  }; // gets a computed ele style object based on matched contexts\n\n\n  styfn$8.getContextStyle = function (cxtMeta) {\n    var cxtKey = cxtMeta.key;\n    var self = this;\n    var cxtStyles = this._private.contextStyles = this._private.contextStyles || {}; // if already computed style, returned cached copy\n\n    if (cxtStyles[cxtKey]) {\n      return cxtStyles[cxtKey];\n    }\n\n    var style = {\n      _private: {\n        key: cxtKey\n      }\n    };\n\n    for (var i = 0; i < self.length; i++) {\n      var cxt = self[i];\n      var hasCxt = cxtKey[i] === TRUE;\n\n      if (!hasCxt) {\n        continue;\n      }\n\n      for (var j = 0; j < cxt.properties.length; j++) {\n        var prop = cxt.properties[j];\n        style[prop.name] = prop;\n      }\n    }\n\n    cxtStyles[cxtKey] = style;\n    return style;\n  };\n\n  styfn$8.applyContextStyle = function (cxtMeta, cxtStyle, ele) {\n    var self = this;\n    var diffProps = cxtMeta.diffPropNames;\n    var retDiffProps = {};\n    var types = self.types;\n\n    for (var i = 0; i < diffProps.length; i++) {\n      var diffPropName = diffProps[i];\n      var cxtProp = cxtStyle[diffPropName];\n      var eleProp = ele.pstyle(diffPropName);\n\n      if (!cxtProp) {\n        // no context prop means delete\n        if (!eleProp) {\n          continue; // no existing prop means nothing needs to be removed\n          // nb affects initial application on mapped values like control-point-distances\n        } else if (eleProp.bypass) {\n          cxtProp = {\n            name: diffPropName,\n            deleteBypassed: true\n          };\n        } else {\n          cxtProp = {\n            name: diffPropName,\n            \"delete\": true\n          };\n        }\n      } // save cycles when the context prop doesn't need to be applied\n\n\n      if (eleProp === cxtProp) {\n        continue;\n      } // save cycles when a mapped context prop doesn't need to be applied\n\n\n      if (cxtProp.mapped === types.fn // context prop is function mapper\n      && eleProp != null // some props can be null even by default (e.g. a prop that overrides another one)\n      && eleProp.mapping != null // ele prop is a concrete value from from a mapper\n      && eleProp.mapping.value === cxtProp.value // the current prop on the ele is a flat prop value for the function mapper\n      ) {\n        // NB don't write to cxtProp, as it's shared among eles (stored in stylesheet)\n        var mapping = eleProp.mapping; // can write to mapping, as it's a per-ele copy\n\n        var fnValue = mapping.fnValue = cxtProp.value(ele); // temporarily cache the value in case of a miss\n\n        if (fnValue === mapping.prevFnValue) {\n          continue;\n        }\n      }\n\n      var retDiffProp = retDiffProps[diffPropName] = {\n        prev: eleProp\n      };\n      self.applyParsedProperty(ele, cxtProp);\n      retDiffProp.next = ele.pstyle(diffPropName);\n\n      if (retDiffProp.next && retDiffProp.next.bypass) {\n        retDiffProp.next = retDiffProp.next.bypassed;\n      }\n    }\n\n    return {\n      diffProps: retDiffProps\n    };\n  };\n\n  styfn$8.updateStyleHints = function (ele) {\n    var _p = ele._private;\n    var self = this;\n    var propNames = self.propertyGroupNames;\n    var propGrKeys = self.propertyGroupKeys;\n\n    var propHash = function propHash(ele, propNames, seedKey) {\n      return self.getPropertiesHash(ele, propNames, seedKey);\n    };\n\n    var oldStyleKey = _p.styleKey;\n\n    if (ele.removed()) {\n      return false;\n    }\n\n    var isNode = _p.group === 'nodes'; // get the style key hashes per prop group\n    // but lazily -- only use non-default prop values to reduce the number of hashes\n    //\n\n    var overriddenStyles = ele._private.style;\n    propNames = Object.keys(overriddenStyles);\n\n    for (var i = 0; i < propGrKeys.length; i++) {\n      var grKey = propGrKeys[i];\n      _p.styleKeys[grKey] = [DEFAULT_HASH_SEED, DEFAULT_HASH_SEED_ALT];\n    }\n\n    var updateGrKey1 = function updateGrKey1(val, grKey) {\n      return _p.styleKeys[grKey][0] = hashInt(val, _p.styleKeys[grKey][0]);\n    };\n\n    var updateGrKey2 = function updateGrKey2(val, grKey) {\n      return _p.styleKeys[grKey][1] = hashIntAlt(val, _p.styleKeys[grKey][1]);\n    };\n\n    var updateGrKey = function updateGrKey(val, grKey) {\n      updateGrKey1(val, grKey);\n      updateGrKey2(val, grKey);\n    };\n\n    var updateGrKeyWStr = function updateGrKeyWStr(strVal, grKey) {\n      for (var j = 0; j < strVal.length; j++) {\n        var ch = strVal.charCodeAt(j);\n        updateGrKey1(ch, grKey);\n        updateGrKey2(ch, grKey);\n      }\n    }; // - hashing works on 32 bit ints b/c we use bitwise ops\n    // - small numbers get cut off (e.g. 0.123 is seen as 0 by the hashing function)\n    // - raise up small numbers so more significant digits are seen by hashing\n    // - make small numbers larger than a normal value to avoid collisions\n    // - works in practice and it's relatively cheap\n\n\n    var N = 2000000000;\n\n    var cleanNum = function cleanNum(val) {\n      return -128 < val && val < 128 && Math.floor(val) !== val ? N - (val * 1024 | 0) : val;\n    };\n\n    for (var _i = 0; _i < propNames.length; _i++) {\n      var name = propNames[_i];\n      var parsedProp = overriddenStyles[name];\n\n      if (parsedProp == null) {\n        continue;\n      }\n\n      var propInfo = this.properties[name];\n      var type = propInfo.type;\n      var _grKey = propInfo.groupKey;\n      var normalizedNumberVal = void 0;\n\n      if (propInfo.hashOverride != null) {\n        normalizedNumberVal = propInfo.hashOverride(ele, parsedProp);\n      } else if (parsedProp.pfValue != null) {\n        normalizedNumberVal = parsedProp.pfValue;\n      } // might not be a number if it allows enums\n\n\n      var numberVal = propInfo.enums == null ? parsedProp.value : null;\n      var haveNormNum = normalizedNumberVal != null;\n      var haveUnitedNum = numberVal != null;\n      var haveNum = haveNormNum || haveUnitedNum;\n      var units = parsedProp.units; // numbers are cheaper to hash than strings\n      // 1 hash op vs n hash ops (for length n string)\n\n      if (type.number && haveNum && !type.multiple) {\n        var v = haveNormNum ? normalizedNumberVal : numberVal;\n        updateGrKey(cleanNum(v), _grKey);\n\n        if (!haveNormNum && units != null) {\n          updateGrKeyWStr(units, _grKey);\n        }\n      } else {\n        updateGrKeyWStr(parsedProp.strValue, _grKey);\n      }\n    } // overall style key\n    //\n\n\n    var hash = [DEFAULT_HASH_SEED, DEFAULT_HASH_SEED_ALT];\n\n    for (var _i2 = 0; _i2 < propGrKeys.length; _i2++) {\n      var _grKey2 = propGrKeys[_i2];\n      var grHash = _p.styleKeys[_grKey2];\n      hash[0] = hashInt(grHash[0], hash[0]);\n      hash[1] = hashIntAlt(grHash[1], hash[1]);\n    }\n\n    _p.styleKey = combineHashes(hash[0], hash[1]); // label dims\n    //\n\n    var sk = _p.styleKeys;\n    _p.labelDimsKey = combineHashesArray(sk.labelDimensions);\n    var labelKeys = propHash(ele, ['label'], sk.labelDimensions);\n    _p.labelKey = combineHashesArray(labelKeys);\n    _p.labelStyleKey = combineHashesArray(hashArrays(sk.commonLabel, labelKeys));\n\n    if (!isNode) {\n      var sourceLabelKeys = propHash(ele, ['source-label'], sk.labelDimensions);\n      _p.sourceLabelKey = combineHashesArray(sourceLabelKeys);\n      _p.sourceLabelStyleKey = combineHashesArray(hashArrays(sk.commonLabel, sourceLabelKeys));\n      var targetLabelKeys = propHash(ele, ['target-label'], sk.labelDimensions);\n      _p.targetLabelKey = combineHashesArray(targetLabelKeys);\n      _p.targetLabelStyleKey = combineHashesArray(hashArrays(sk.commonLabel, targetLabelKeys));\n    } // node\n    //\n\n\n    if (isNode) {\n      var _p$styleKeys = _p.styleKeys,\n          nodeBody = _p$styleKeys.nodeBody,\n          nodeBorder = _p$styleKeys.nodeBorder,\n          backgroundImage = _p$styleKeys.backgroundImage,\n          compound = _p$styleKeys.compound,\n          pie = _p$styleKeys.pie;\n      var nodeKeys = [nodeBody, nodeBorder, backgroundImage, compound, pie].filter(function (k) {\n        return k != null;\n      }).reduce(hashArrays, [DEFAULT_HASH_SEED, DEFAULT_HASH_SEED_ALT]);\n      _p.nodeKey = combineHashesArray(nodeKeys);\n      _p.hasPie = pie != null && pie[0] !== DEFAULT_HASH_SEED && pie[1] !== DEFAULT_HASH_SEED_ALT;\n    }\n\n    return oldStyleKey !== _p.styleKey;\n  };\n\n  styfn$8.clearStyleHints = function (ele) {\n    var _p = ele._private;\n    _p.styleCxtKey = '';\n    _p.styleKeys = {};\n    _p.styleKey = null;\n    _p.labelKey = null;\n    _p.labelStyleKey = null;\n    _p.sourceLabelKey = null;\n    _p.sourceLabelStyleKey = null;\n    _p.targetLabelKey = null;\n    _p.targetLabelStyleKey = null;\n    _p.nodeKey = null;\n    _p.hasPie = null;\n  }; // apply a property to the style (for internal use)\n  // returns whether application was successful\n  //\n  // now, this function flattens the property, and here's how:\n  //\n  // for parsedProp:{ bypass: true, deleteBypass: true }\n  // no property is generated, instead the bypass property in the\n  // element's style is replaced by what's pointed to by the `bypassed`\n  // field in the bypass property (i.e. restoring the property the\n  // bypass was overriding)\n  //\n  // for parsedProp:{ mapped: truthy }\n  // the generated flattenedProp:{ mapping: prop }\n  //\n  // for parsedProp:{ bypass: true }\n  // the generated flattenedProp:{ bypassed: parsedProp }\n\n\n  styfn$8.applyParsedProperty = function (ele, parsedProp) {\n    var self = this;\n    var prop = parsedProp;\n    var style = ele._private.style;\n    var flatProp;\n    var types = self.types;\n    var type = self.properties[prop.name].type;\n    var propIsBypass = prop.bypass;\n    var origProp = style[prop.name];\n    var origPropIsBypass = origProp && origProp.bypass;\n    var _p = ele._private;\n    var flatPropMapping = 'mapping';\n\n    var getVal = function getVal(p) {\n      if (p == null) {\n        return null;\n      } else if (p.pfValue != null) {\n        return p.pfValue;\n      } else {\n        return p.value;\n      }\n    };\n\n    var checkTriggers = function checkTriggers() {\n      var fromVal = getVal(origProp);\n      var toVal = getVal(prop);\n      self.checkTriggers(ele, prop.name, fromVal, toVal);\n    };\n\n    if (prop && prop.name.substr(0, 3) === 'pie') {\n      warn('The pie style properties are deprecated.  Create charts using background images instead.');\n    } // edge sanity checks to prevent the client from making serious mistakes\n\n\n    if (parsedProp.name === 'curve-style' && ele.isEdge() && ( // loops must be bundled beziers\n    parsedProp.value !== 'bezier' && ele.isLoop() || // edges connected to compound nodes can not be haystacks\n    parsedProp.value === 'haystack' && (ele.source().isParent() || ele.target().isParent()))) {\n      prop = parsedProp = this.parse(parsedProp.name, 'bezier', propIsBypass);\n    }\n\n    if (prop[\"delete\"]) {\n      // delete the property and use the default value on falsey value\n      style[prop.name] = undefined;\n      checkTriggers();\n      return true;\n    }\n\n    if (prop.deleteBypassed) {\n      // delete the property that the\n      if (!origProp) {\n        checkTriggers();\n        return true; // can't delete if no prop\n      } else if (origProp.bypass) {\n        // delete bypassed\n        origProp.bypassed = undefined;\n        checkTriggers();\n        return true;\n      } else {\n        return false; // we're unsuccessful deleting the bypassed\n      }\n    } // check if we need to delete the current bypass\n\n\n    if (prop.deleteBypass) {\n      // then this property is just here to indicate we need to delete\n      if (!origProp) {\n        checkTriggers();\n        return true; // property is already not defined\n      } else if (origProp.bypass) {\n        // then replace the bypass property with the original\n        // because the bypassed property was already applied (and therefore parsed), we can just replace it (no reapplying necessary)\n        style[prop.name] = origProp.bypassed;\n        checkTriggers();\n        return true;\n      } else {\n        return false; // we're unsuccessful deleting the bypass\n      }\n    }\n\n    var printMappingErr = function printMappingErr() {\n      warn('Do not assign mappings to elements without corresponding data (i.e. ele `' + ele.id() + '` has no mapping for property `' + prop.name + '` with data field `' + prop.field + '`); try a `[' + prop.field + ']` selector to limit scope to elements with `' + prop.field + '` defined');\n    }; // put the property in the style objects\n\n\n    switch (prop.mapped) {\n      // flatten the property if mapped\n      case types.mapData:\n        {\n          // flatten the field (e.g. data.foo.bar)\n          var fields = prop.field.split('.');\n          var fieldVal = _p.data;\n\n          for (var i = 0; i < fields.length && fieldVal; i++) {\n            var field = fields[i];\n            fieldVal = fieldVal[field];\n          }\n\n          if (fieldVal == null) {\n            printMappingErr();\n            return false;\n          }\n\n          var percent;\n\n          if (!number$1(fieldVal)) {\n            // then don't apply and fall back on the existing style\n            warn('Do not use continuous mappers without specifying numeric data (i.e. `' + prop.field + ': ' + fieldVal + '` for `' + ele.id() + '` is non-numeric)');\n            return false;\n          } else {\n            var fieldWidth = prop.fieldMax - prop.fieldMin;\n\n            if (fieldWidth === 0) {\n              // safety check -- not strictly necessary as no props of zero range should be passed here\n              percent = 0;\n            } else {\n              percent = (fieldVal - prop.fieldMin) / fieldWidth;\n            }\n          } // make sure to bound percent value\n\n\n          if (percent < 0) {\n            percent = 0;\n          } else if (percent > 1) {\n            percent = 1;\n          }\n\n          if (type.color) {\n            var r1 = prop.valueMin[0];\n            var r2 = prop.valueMax[0];\n            var g1 = prop.valueMin[1];\n            var g2 = prop.valueMax[1];\n            var b1 = prop.valueMin[2];\n            var b2 = prop.valueMax[2];\n            var a1 = prop.valueMin[3] == null ? 1 : prop.valueMin[3];\n            var a2 = prop.valueMax[3] == null ? 1 : prop.valueMax[3];\n            var clr = [Math.round(r1 + (r2 - r1) * percent), Math.round(g1 + (g2 - g1) * percent), Math.round(b1 + (b2 - b1) * percent), Math.round(a1 + (a2 - a1) * percent)];\n            flatProp = {\n              // colours are simple, so just create the flat property instead of expensive string parsing\n              bypass: prop.bypass,\n              // we're a bypass if the mapping property is a bypass\n              name: prop.name,\n              value: clr,\n              strValue: 'rgb(' + clr[0] + ', ' + clr[1] + ', ' + clr[2] + ')'\n            };\n          } else if (type.number) {\n            var calcValue = prop.valueMin + (prop.valueMax - prop.valueMin) * percent;\n            flatProp = this.parse(prop.name, calcValue, prop.bypass, flatPropMapping);\n          } else {\n            return false; // can only map to colours and numbers\n          }\n\n          if (!flatProp) {\n            // if we can't flatten the property, then don't apply the property and fall back on the existing style\n            printMappingErr();\n            return false;\n          }\n\n          flatProp.mapping = prop; // keep a reference to the mapping\n\n          prop = flatProp; // the flattened (mapped) property is the one we want\n\n          break;\n        }\n      // direct mapping\n\n      case types.data:\n        {\n          // flatten the field (e.g. data.foo.bar)\n          var _fields = prop.field.split('.');\n\n          var _fieldVal = _p.data;\n\n          for (var _i3 = 0; _i3 < _fields.length && _fieldVal; _i3++) {\n            var _field = _fields[_i3];\n            _fieldVal = _fieldVal[_field];\n          }\n\n          if (_fieldVal != null) {\n            flatProp = this.parse(prop.name, _fieldVal, prop.bypass, flatPropMapping);\n          }\n\n          if (!flatProp) {\n            // if we can't flatten the property, then don't apply and fall back on the existing style\n            printMappingErr();\n            return false;\n          }\n\n          flatProp.mapping = prop; // keep a reference to the mapping\n\n          prop = flatProp; // the flattened (mapped) property is the one we want\n\n          break;\n        }\n\n      case types.fn:\n        {\n          var fn = prop.value;\n          var fnRetVal = prop.fnValue != null ? prop.fnValue : fn(ele); // check for cached value before calling function\n\n          prop.prevFnValue = fnRetVal;\n\n          if (fnRetVal == null) {\n            warn('Custom function mappers may not return null (i.e. `' + prop.name + '` for ele `' + ele.id() + '` is null)');\n            return false;\n          }\n\n          flatProp = this.parse(prop.name, fnRetVal, prop.bypass, flatPropMapping);\n\n          if (!flatProp) {\n            warn('Custom function mappers may not return invalid values for the property type (i.e. `' + prop.name + '` for ele `' + ele.id() + '` is invalid)');\n            return false;\n          }\n\n          flatProp.mapping = copy(prop); // keep a reference to the mapping\n\n          prop = flatProp; // the flattened (mapped) property is the one we want\n\n          break;\n        }\n\n      case undefined:\n        break;\n      // just set the property\n\n      default:\n        return false;\n      // not a valid mapping\n    } // if the property is a bypass property, then link the resultant property to the original one\n\n\n    if (propIsBypass) {\n      if (origPropIsBypass) {\n        // then this bypass overrides the existing one\n        prop.bypassed = origProp.bypassed; // steal bypassed prop from old bypass\n      } else {\n        // then link the orig prop to the new bypass\n        prop.bypassed = origProp;\n      }\n\n      style[prop.name] = prop; // and set\n    } else {\n      // prop is not bypass\n      if (origPropIsBypass) {\n        // then keep the orig prop (since it's a bypass) and link to the new prop\n        origProp.bypassed = prop;\n      } else {\n        // then just replace the old prop with the new one\n        style[prop.name] = prop;\n      }\n    }\n\n    checkTriggers();\n    return true;\n  };\n\n  styfn$8.cleanElements = function (eles, keepBypasses) {\n    for (var i = 0; i < eles.length; i++) {\n      var ele = eles[i];\n      this.clearStyleHints(ele);\n      ele.dirtyCompoundBoundsCache();\n      ele.dirtyBoundingBoxCache();\n\n      if (!keepBypasses) {\n        ele._private.style = {};\n      } else {\n        var style = ele._private.style;\n        var propNames = Object.keys(style);\n\n        for (var j = 0; j < propNames.length; j++) {\n          var propName = propNames[j];\n          var eleProp = style[propName];\n\n          if (eleProp != null) {\n            if (eleProp.bypass) {\n              eleProp.bypassed = null;\n            } else {\n              style[propName] = null;\n            }\n          }\n        }\n      }\n    }\n  }; // updates the visual style for all elements (useful for manual style modification after init)\n\n\n  styfn$8.update = function () {\n    var cy = this._private.cy;\n    var eles = cy.mutableElements();\n    eles.updateStyle();\n  }; // diffProps : { name => { prev, next } }\n\n\n  styfn$8.updateTransitions = function (ele, diffProps) {\n    var self = this;\n    var _p = ele._private;\n    var props = ele.pstyle('transition-property').value;\n    var duration = ele.pstyle('transition-duration').pfValue;\n    var delay = ele.pstyle('transition-delay').pfValue;\n\n    if (props.length > 0 && duration > 0) {\n      var style = {}; // build up the style to animate towards\n\n      var anyPrev = false;\n\n      for (var i = 0; i < props.length; i++) {\n        var prop = props[i];\n        var styProp = ele.pstyle(prop);\n        var diffProp = diffProps[prop];\n\n        if (!diffProp) {\n          continue;\n        }\n\n        var prevProp = diffProp.prev;\n        var fromProp = prevProp;\n        var toProp = diffProp.next != null ? diffProp.next : styProp;\n        var diff = false;\n        var initVal = void 0;\n        var initDt = 0.000001; // delta time % value for initVal (allows animating out of init zero opacity)\n\n        if (!fromProp) {\n          continue;\n        } // consider px values\n\n\n        if (number$1(fromProp.pfValue) && number$1(toProp.pfValue)) {\n          diff = toProp.pfValue - fromProp.pfValue; // nonzero is truthy\n\n          initVal = fromProp.pfValue + initDt * diff; // consider numerical values\n        } else if (number$1(fromProp.value) && number$1(toProp.value)) {\n          diff = toProp.value - fromProp.value; // nonzero is truthy\n\n          initVal = fromProp.value + initDt * diff; // consider colour values\n        } else if (array(fromProp.value) && array(toProp.value)) {\n          diff = fromProp.value[0] !== toProp.value[0] || fromProp.value[1] !== toProp.value[1] || fromProp.value[2] !== toProp.value[2];\n          initVal = fromProp.strValue;\n        } // the previous value is good for an animation only if it's different\n\n\n        if (diff) {\n          style[prop] = toProp.strValue; // to val\n\n          this.applyBypass(ele, prop, initVal); // from val\n\n          anyPrev = true;\n        }\n      } // end if props allow ani\n      // can't transition if there's nothing previous to transition from\n\n\n      if (!anyPrev) {\n        return;\n      }\n\n      _p.transitioning = true;\n      new Promise$1(function (resolve) {\n        if (delay > 0) {\n          ele.delayAnimation(delay).play().promise().then(resolve);\n        } else {\n          resolve();\n        }\n      }).then(function () {\n        return ele.animation({\n          style: style,\n          duration: duration,\n          easing: ele.pstyle('transition-timing-function').value,\n          queue: false\n        }).play().promise();\n      }).then(function () {\n        // if( !isBypass ){\n        self.removeBypasses(ele, props);\n        ele.emitAndNotify('style'); // }\n\n        _p.transitioning = false;\n      });\n    } else if (_p.transitioning) {\n      this.removeBypasses(ele, props);\n      ele.emitAndNotify('style');\n      _p.transitioning = false;\n    }\n  };\n\n  styfn$8.checkTrigger = function (ele, name, fromValue, toValue, getTrigger, onTrigger) {\n    var prop = this.properties[name];\n    var triggerCheck = getTrigger(prop);\n\n    if (triggerCheck != null && triggerCheck(fromValue, toValue)) {\n      onTrigger(prop);\n    }\n  };\n\n  styfn$8.checkZOrderTrigger = function (ele, name, fromValue, toValue) {\n    var _this = this;\n\n    this.checkTrigger(ele, name, fromValue, toValue, function (prop) {\n      return prop.triggersZOrder;\n    }, function () {\n      _this._private.cy.notify('zorder', ele);\n    });\n  };\n\n  styfn$8.checkBoundsTrigger = function (ele, name, fromValue, toValue) {\n    this.checkTrigger(ele, name, fromValue, toValue, function (prop) {\n      return prop.triggersBounds;\n    }, function (prop) {\n      ele.dirtyCompoundBoundsCache();\n      ele.dirtyBoundingBoxCache(); // if the prop change makes the bb of pll bezier edges invalid,\n      // then dirty the pll edge bb cache as well\n\n      if ( // only for beziers -- so performance of other edges isn't affected\n      prop.triggersBoundsOfParallelBeziers && (name === 'curve-style' && (fromValue === 'bezier' || toValue === 'bezier') || name === 'display' && (fromValue === 'none' || toValue === 'none'))) {\n        ele.parallelEdges().forEach(function (pllEdge) {\n          if (pllEdge.isBundledBezier()) {\n            pllEdge.dirtyBoundingBoxCache();\n          }\n        });\n      }\n    });\n  };\n\n  styfn$8.checkTriggers = function (ele, name, fromValue, toValue) {\n    ele.dirtyStyleCache();\n    this.checkZOrderTrigger(ele, name, fromValue, toValue);\n    this.checkBoundsTrigger(ele, name, fromValue, toValue);\n  };\n\n  var styfn$7 = {}; // bypasses are applied to an existing style on an element, and just tacked on temporarily\n  // returns true iff application was successful for at least 1 specified property\n\n  styfn$7.applyBypass = function (eles, name, value, updateTransitions) {\n    var self = this;\n    var props = [];\n    var isBypass = true; // put all the properties (can specify one or many) in an array after parsing them\n\n    if (name === '*' || name === '**') {\n      // apply to all property names\n      if (value !== undefined) {\n        for (var i = 0; i < self.properties.length; i++) {\n          var prop = self.properties[i];\n          var _name = prop.name;\n          var parsedProp = this.parse(_name, value, true);\n\n          if (parsedProp) {\n            props.push(parsedProp);\n          }\n        }\n      }\n    } else if (string(name)) {\n      // then parse the single property\n      var _parsedProp = this.parse(name, value, true);\n\n      if (_parsedProp) {\n        props.push(_parsedProp);\n      }\n    } else if (plainObject(name)) {\n      // then parse each property\n      var specifiedProps = name;\n      updateTransitions = value;\n      var names = Object.keys(specifiedProps);\n\n      for (var _i = 0; _i < names.length; _i++) {\n        var _name2 = names[_i];\n        var _value = specifiedProps[_name2];\n\n        if (_value === undefined) {\n          // try camel case name too\n          _value = specifiedProps[dash2camel(_name2)];\n        }\n\n        if (_value !== undefined) {\n          var _parsedProp2 = this.parse(_name2, _value, true);\n\n          if (_parsedProp2) {\n            props.push(_parsedProp2);\n          }\n        }\n      }\n    } else {\n      // can't do anything without well defined properties\n      return false;\n    } // we've failed if there are no valid properties\n\n\n    if (props.length === 0) {\n      return false;\n    } // now, apply the bypass properties on the elements\n\n\n    var ret = false; // return true if at least one succesful bypass applied\n\n    for (var _i2 = 0; _i2 < eles.length; _i2++) {\n      // for each ele\n      var ele = eles[_i2];\n      var diffProps = {};\n      var diffProp = void 0;\n\n      for (var j = 0; j < props.length; j++) {\n        // for each prop\n        var _prop = props[j];\n\n        if (updateTransitions) {\n          var prevProp = ele.pstyle(_prop.name);\n          diffProp = diffProps[_prop.name] = {\n            prev: prevProp\n          };\n        }\n\n        ret = this.applyParsedProperty(ele, copy(_prop)) || ret;\n\n        if (updateTransitions) {\n          diffProp.next = ele.pstyle(_prop.name);\n        }\n      } // for props\n\n\n      if (ret) {\n        this.updateStyleHints(ele);\n      }\n\n      if (updateTransitions) {\n        this.updateTransitions(ele, diffProps, isBypass);\n      }\n    } // for eles\n\n\n    return ret;\n  }; // only useful in specific cases like animation\n\n\n  styfn$7.overrideBypass = function (eles, name, value) {\n    name = camel2dash(name);\n\n    for (var i = 0; i < eles.length; i++) {\n      var ele = eles[i];\n      var prop = ele._private.style[name];\n      var type = this.properties[name].type;\n      var isColor = type.color;\n      var isMulti = type.mutiple;\n      var oldValue = !prop ? null : prop.pfValue != null ? prop.pfValue : prop.value;\n\n      if (!prop || !prop.bypass) {\n        // need a bypass if one doesn't exist\n        this.applyBypass(ele, name, value);\n      } else {\n        prop.value = value;\n\n        if (prop.pfValue != null) {\n          prop.pfValue = value;\n        }\n\n        if (isColor) {\n          prop.strValue = 'rgb(' + value.join(',') + ')';\n        } else if (isMulti) {\n          prop.strValue = value.join(' ');\n        } else {\n          prop.strValue = '' + value;\n        }\n\n        this.updateStyleHints(ele);\n      }\n\n      this.checkTriggers(ele, name, oldValue, value);\n    }\n  };\n\n  styfn$7.removeAllBypasses = function (eles, updateTransitions) {\n    return this.removeBypasses(eles, this.propertyNames, updateTransitions);\n  };\n\n  styfn$7.removeBypasses = function (eles, props, updateTransitions) {\n    var isBypass = true;\n\n    for (var j = 0; j < eles.length; j++) {\n      var ele = eles[j];\n      var diffProps = {};\n\n      for (var i = 0; i < props.length; i++) {\n        var name = props[i];\n        var prop = this.properties[name];\n        var prevProp = ele.pstyle(prop.name);\n\n        if (!prevProp || !prevProp.bypass) {\n          // if a bypass doesn't exist for the prop, nothing needs to be removed\n          continue;\n        }\n\n        var value = ''; // empty => remove bypass\n\n        var parsedProp = this.parse(name, value, true);\n        var diffProp = diffProps[prop.name] = {\n          prev: prevProp\n        };\n        this.applyParsedProperty(ele, parsedProp);\n        diffProp.next = ele.pstyle(prop.name);\n      } // for props\n\n\n      this.updateStyleHints(ele);\n\n      if (updateTransitions) {\n        this.updateTransitions(ele, diffProps, isBypass);\n      }\n    } // for eles\n\n  };\n\n  var styfn$6 = {}; // gets what an em size corresponds to in pixels relative to a dom element\n\n  styfn$6.getEmSizeInPixels = function () {\n    var px = this.containerCss('font-size');\n\n    if (px != null) {\n      return parseFloat(px);\n    } else {\n      return 1; // for headless\n    }\n  }; // gets css property from the core container\n\n\n  styfn$6.containerCss = function (propName) {\n    var cy = this._private.cy;\n    var domElement = cy.container();\n\n    if (window$1 && domElement && window$1.getComputedStyle) {\n      return window$1.getComputedStyle(domElement).getPropertyValue(propName);\n    }\n  };\n\n  var styfn$5 = {}; // gets the rendered style for an element\n\n  styfn$5.getRenderedStyle = function (ele, prop) {\n    if (prop) {\n      return this.getStylePropertyValue(ele, prop, true);\n    } else {\n      return this.getRawStyle(ele, true);\n    }\n  }; // gets the raw style for an element\n\n\n  styfn$5.getRawStyle = function (ele, isRenderedVal) {\n    var self = this;\n    ele = ele[0]; // insure it's an element\n\n    if (ele) {\n      var rstyle = {};\n\n      for (var i = 0; i < self.properties.length; i++) {\n        var prop = self.properties[i];\n        var val = self.getStylePropertyValue(ele, prop.name, isRenderedVal);\n\n        if (val != null) {\n          rstyle[prop.name] = val;\n          rstyle[dash2camel(prop.name)] = val;\n        }\n      }\n\n      return rstyle;\n    }\n  };\n\n  styfn$5.getIndexedStyle = function (ele, property, subproperty, index) {\n    var pstyle = ele.pstyle(property)[subproperty][index];\n    return pstyle != null ? pstyle : ele.cy().style().getDefaultProperty(property)[subproperty][0];\n  };\n\n  styfn$5.getStylePropertyValue = function (ele, propName, isRenderedVal) {\n    var self = this;\n    ele = ele[0]; // insure it's an element\n\n    if (ele) {\n      var prop = self.properties[propName];\n\n      if (prop.alias) {\n        prop = prop.pointsTo;\n      }\n\n      var type = prop.type;\n      var styleProp = ele.pstyle(prop.name);\n\n      if (styleProp) {\n        var value = styleProp.value,\n            units = styleProp.units,\n            strValue = styleProp.strValue;\n\n        if (isRenderedVal && type.number && value != null && number$1(value)) {\n          var zoom = ele.cy().zoom();\n\n          var getRenderedValue = function getRenderedValue(val) {\n            return val * zoom;\n          };\n\n          var getValueStringWithUnits = function getValueStringWithUnits(val, units) {\n            return getRenderedValue(val) + units;\n          };\n\n          var isArrayValue = array(value);\n          var haveUnits = isArrayValue ? units.every(function (u) {\n            return u != null;\n          }) : units != null;\n\n          if (haveUnits) {\n            if (isArrayValue) {\n              return value.map(function (v, i) {\n                return getValueStringWithUnits(v, units[i]);\n              }).join(' ');\n            } else {\n              return getValueStringWithUnits(value, units);\n            }\n          } else {\n            if (isArrayValue) {\n              return value.map(function (v) {\n                return string(v) ? v : '' + getRenderedValue(v);\n              }).join(' ');\n            } else {\n              return '' + getRenderedValue(value);\n            }\n          }\n        } else if (strValue != null) {\n          return strValue;\n        }\n      }\n\n      return null;\n    }\n  };\n\n  styfn$5.getAnimationStartStyle = function (ele, aniProps) {\n    var rstyle = {};\n\n    for (var i = 0; i < aniProps.length; i++) {\n      var aniProp = aniProps[i];\n      var name = aniProp.name;\n      var styleProp = ele.pstyle(name);\n\n      if (styleProp !== undefined) {\n        // then make a prop of it\n        if (plainObject(styleProp)) {\n          styleProp = this.parse(name, styleProp.strValue);\n        } else {\n          styleProp = this.parse(name, styleProp);\n        }\n      }\n\n      if (styleProp) {\n        rstyle[name] = styleProp;\n      }\n    }\n\n    return rstyle;\n  };\n\n  styfn$5.getPropsList = function (propsObj) {\n    var self = this;\n    var rstyle = [];\n    var style = propsObj;\n    var props = self.properties;\n\n    if (style) {\n      var names = Object.keys(style);\n\n      for (var i = 0; i < names.length; i++) {\n        var name = names[i];\n        var val = style[name];\n        var prop = props[name] || props[camel2dash(name)];\n        var styleProp = this.parse(prop.name, val);\n\n        if (styleProp) {\n          rstyle.push(styleProp);\n        }\n      }\n    }\n\n    return rstyle;\n  };\n\n  styfn$5.getNonDefaultPropertiesHash = function (ele, propNames, seed) {\n    var hash = seed.slice();\n    var name, val, strVal, chVal;\n    var i, j;\n\n    for (i = 0; i < propNames.length; i++) {\n      name = propNames[i];\n      val = ele.pstyle(name, false);\n\n      if (val == null) {\n        continue;\n      } else if (val.pfValue != null) {\n        hash[0] = hashInt(chVal, hash[0]);\n        hash[1] = hashIntAlt(chVal, hash[1]);\n      } else {\n        strVal = val.strValue;\n\n        for (j = 0; j < strVal.length; j++) {\n          chVal = strVal.charCodeAt(j);\n          hash[0] = hashInt(chVal, hash[0]);\n          hash[1] = hashIntAlt(chVal, hash[1]);\n        }\n      }\n    }\n\n    return hash;\n  };\n\n  styfn$5.getPropertiesHash = styfn$5.getNonDefaultPropertiesHash;\n\n  var styfn$4 = {};\n\n  styfn$4.appendFromJson = function (json) {\n    var style = this;\n\n    for (var i = 0; i < json.length; i++) {\n      var context = json[i];\n      var selector = context.selector;\n      var props = context.style || context.css;\n      var names = Object.keys(props);\n      style.selector(selector); // apply selector\n\n      for (var j = 0; j < names.length; j++) {\n        var name = names[j];\n        var value = props[name];\n        style.css(name, value); // apply property\n      }\n    }\n\n    return style;\n  }; // accessible cy.style() function\n\n\n  styfn$4.fromJson = function (json) {\n    var style = this;\n    style.resetToDefault();\n    style.appendFromJson(json);\n    return style;\n  }; // get json from cy.style() api\n\n\n  styfn$4.json = function () {\n    var json = [];\n\n    for (var i = this.defaultLength; i < this.length; i++) {\n      var cxt = this[i];\n      var selector = cxt.selector;\n      var props = cxt.properties;\n      var css = {};\n\n      for (var j = 0; j < props.length; j++) {\n        var prop = props[j];\n        css[prop.name] = prop.strValue;\n      }\n\n      json.push({\n        selector: !selector ? 'core' : selector.toString(),\n        style: css\n      });\n    }\n\n    return json;\n  };\n\n  var styfn$3 = {};\n\n  styfn$3.appendFromString = function (string) {\n    var self = this;\n    var style = this;\n    var remaining = '' + string;\n    var selAndBlockStr;\n    var blockRem;\n    var propAndValStr; // remove comments from the style string\n\n    remaining = remaining.replace(/[/][*](\\s|.)+?[*][/]/g, '');\n\n    function removeSelAndBlockFromRemaining() {\n      // remove the parsed selector and block from the remaining text to parse\n      if (remaining.length > selAndBlockStr.length) {\n        remaining = remaining.substr(selAndBlockStr.length);\n      } else {\n        remaining = '';\n      }\n    }\n\n    function removePropAndValFromRem() {\n      // remove the parsed property and value from the remaining block text to parse\n      if (blockRem.length > propAndValStr.length) {\n        blockRem = blockRem.substr(propAndValStr.length);\n      } else {\n        blockRem = '';\n      }\n    }\n\n    for (;;) {\n      var nothingLeftToParse = remaining.match(/^\\s*$/);\n\n      if (nothingLeftToParse) {\n        break;\n      }\n\n      var selAndBlock = remaining.match(/^\\s*((?:.|\\s)+?)\\s*\\{((?:.|\\s)+?)\\}/);\n\n      if (!selAndBlock) {\n        warn('Halting stylesheet parsing: String stylesheet contains more to parse but no selector and block found in: ' + remaining);\n        break;\n      }\n\n      selAndBlockStr = selAndBlock[0]; // parse the selector\n\n      var selectorStr = selAndBlock[1];\n\n      if (selectorStr !== 'core') {\n        var selector = new Selector(selectorStr);\n\n        if (selector.invalid) {\n          warn('Skipping parsing of block: Invalid selector found in string stylesheet: ' + selectorStr); // skip this selector and block\n\n          removeSelAndBlockFromRemaining();\n          continue;\n        }\n      } // parse the block of properties and values\n\n\n      var blockStr = selAndBlock[2];\n      var invalidBlock = false;\n      blockRem = blockStr;\n      var props = [];\n\n      for (;;) {\n        var _nothingLeftToParse = blockRem.match(/^\\s*$/);\n\n        if (_nothingLeftToParse) {\n          break;\n        }\n\n        var propAndVal = blockRem.match(/^\\s*(.+?)\\s*:\\s*(.+?)(?:\\s*;|\\s*$)/);\n\n        if (!propAndVal) {\n          warn('Skipping parsing of block: Invalid formatting of style property and value definitions found in:' + blockStr);\n          invalidBlock = true;\n          break;\n        }\n\n        propAndValStr = propAndVal[0];\n        var propStr = propAndVal[1];\n        var valStr = propAndVal[2];\n        var prop = self.properties[propStr];\n\n        if (!prop) {\n          warn('Skipping property: Invalid property name in: ' + propAndValStr); // skip this property in the block\n\n          removePropAndValFromRem();\n          continue;\n        }\n\n        var parsedProp = style.parse(propStr, valStr);\n\n        if (!parsedProp) {\n          warn('Skipping property: Invalid property definition in: ' + propAndValStr); // skip this property in the block\n\n          removePropAndValFromRem();\n          continue;\n        }\n\n        props.push({\n          name: propStr,\n          val: valStr\n        });\n        removePropAndValFromRem();\n      }\n\n      if (invalidBlock) {\n        removeSelAndBlockFromRemaining();\n        break;\n      } // put the parsed block in the style\n\n\n      style.selector(selectorStr);\n\n      for (var i = 0; i < props.length; i++) {\n        var _prop = props[i];\n        style.css(_prop.name, _prop.val);\n      }\n\n      removeSelAndBlockFromRemaining();\n    }\n\n    return style;\n  };\n\n  styfn$3.fromString = function (string) {\n    var style = this;\n    style.resetToDefault();\n    style.appendFromString(string);\n    return style;\n  };\n\n  var styfn$2 = {};\n\n  (function () {\n    var number$1 = number;\n    var rgba = rgbaNoBackRefs;\n    var hsla = hslaNoBackRefs;\n    var hex3$1 = hex3;\n    var hex6$1 = hex6;\n\n    var data = function data(prefix) {\n      return '^' + prefix + '\\\\s*\\\\(\\\\s*([\\\\w\\\\.]+)\\\\s*\\\\)$';\n    };\n\n    var mapData = function mapData(prefix) {\n      var mapArg = number$1 + '|\\\\w+|' + rgba + '|' + hsla + '|' + hex3$1 + '|' + hex6$1;\n      return '^' + prefix + '\\\\s*\\\\(([\\\\w\\\\.]+)\\\\s*\\\\,\\\\s*(' + number$1 + ')\\\\s*\\\\,\\\\s*(' + number$1 + ')\\\\s*,\\\\s*(' + mapArg + ')\\\\s*\\\\,\\\\s*(' + mapArg + ')\\\\)$';\n    };\n\n    var urlRegexes = ['^url\\\\s*\\\\(\\\\s*[\\'\"]?(.+?)[\\'\"]?\\\\s*\\\\)$', '^(none)$', '^(.+)$']; // each visual style property has a type and needs to be validated according to it\n\n    styfn$2.types = {\n      time: {\n        number: true,\n        min: 0,\n        units: 's|ms',\n        implicitUnits: 'ms'\n      },\n      percent: {\n        number: true,\n        min: 0,\n        max: 100,\n        units: '%',\n        implicitUnits: '%'\n      },\n      percentages: {\n        number: true,\n        min: 0,\n        max: 100,\n        units: '%',\n        implicitUnits: '%',\n        multiple: true\n      },\n      zeroOneNumber: {\n        number: true,\n        min: 0,\n        max: 1,\n        unitless: true\n      },\n      zeroOneNumbers: {\n        number: true,\n        min: 0,\n        max: 1,\n        unitless: true,\n        multiple: true\n      },\n      nOneOneNumber: {\n        number: true,\n        min: -1,\n        max: 1,\n        unitless: true\n      },\n      nonNegativeInt: {\n        number: true,\n        min: 0,\n        integer: true,\n        unitless: true\n      },\n      position: {\n        enums: ['parent', 'origin']\n      },\n      nodeSize: {\n        number: true,\n        min: 0,\n        enums: ['label']\n      },\n      number: {\n        number: true,\n        unitless: true\n      },\n      numbers: {\n        number: true,\n        unitless: true,\n        multiple: true\n      },\n      positiveNumber: {\n        number: true,\n        unitless: true,\n        min: 0,\n        strictMin: true\n      },\n      size: {\n        number: true,\n        min: 0\n      },\n      bidirectionalSize: {\n        number: true\n      },\n      // allows negative\n      bidirectionalSizeMaybePercent: {\n        number: true,\n        allowPercent: true\n      },\n      // allows negative\n      bidirectionalSizes: {\n        number: true,\n        multiple: true\n      },\n      // allows negative\n      sizeMaybePercent: {\n        number: true,\n        min: 0,\n        allowPercent: true\n      },\n      axisDirection: {\n        enums: ['horizontal', 'leftward', 'rightward', 'vertical', 'upward', 'downward', 'auto']\n      },\n      paddingRelativeTo: {\n        enums: ['width', 'height', 'average', 'min', 'max']\n      },\n      bgWH: {\n        number: true,\n        min: 0,\n        allowPercent: true,\n        enums: ['auto'],\n        multiple: true\n      },\n      bgPos: {\n        number: true,\n        allowPercent: true,\n        multiple: true\n      },\n      bgRelativeTo: {\n        enums: ['inner', 'include-padding'],\n        multiple: true\n      },\n      bgRepeat: {\n        enums: ['repeat', 'repeat-x', 'repeat-y', 'no-repeat'],\n        multiple: true\n      },\n      bgFit: {\n        enums: ['none', 'contain', 'cover'],\n        multiple: true\n      },\n      bgCrossOrigin: {\n        enums: ['anonymous', 'use-credentials', 'null'],\n        multiple: true\n      },\n      bgClip: {\n        enums: ['none', 'node'],\n        multiple: true\n      },\n      bgContainment: {\n        enums: ['inside', 'over'],\n        multiple: true\n      },\n      color: {\n        color: true\n      },\n      colors: {\n        color: true,\n        multiple: true\n      },\n      fill: {\n        enums: ['solid', 'linear-gradient', 'radial-gradient']\n      },\n      bool: {\n        enums: ['yes', 'no']\n      },\n      bools: {\n        enums: ['yes', 'no'],\n        multiple: true\n      },\n      lineStyle: {\n        enums: ['solid', 'dotted', 'dashed']\n      },\n      lineCap: {\n        enums: ['butt', 'round', 'square']\n      },\n      borderStyle: {\n        enums: ['solid', 'dotted', 'dashed', 'double']\n      },\n      curveStyle: {\n        enums: ['bezier', 'unbundled-bezier', 'haystack', 'segments', 'straight', 'straight-triangle', 'taxi']\n      },\n      fontFamily: {\n        regex: '^([\\\\w- \\\\\"]+(?:\\\\s*,\\\\s*[\\\\w- \\\\\"]+)*)$'\n      },\n      fontStyle: {\n        enums: ['italic', 'normal', 'oblique']\n      },\n      fontWeight: {\n        enums: ['normal', 'bold', 'bolder', 'lighter', '100', '200', '300', '400', '500', '600', '800', '900', 100, 200, 300, 400, 500, 600, 700, 800, 900]\n      },\n      textDecoration: {\n        enums: ['none', 'underline', 'overline', 'line-through']\n      },\n      textTransform: {\n        enums: ['none', 'uppercase', 'lowercase']\n      },\n      textWrap: {\n        enums: ['none', 'wrap', 'ellipsis']\n      },\n      textOverflowWrap: {\n        enums: ['whitespace', 'anywhere']\n      },\n      textBackgroundShape: {\n        enums: ['rectangle', 'roundrectangle', 'round-rectangle']\n      },\n      nodeShape: {\n        enums: ['rectangle', 'roundrectangle', 'round-rectangle', 'cutrectangle', 'cut-rectangle', 'bottomroundrectangle', 'bottom-round-rectangle', 'barrel', 'ellipse', 'triangle', 'round-triangle', 'square', 'pentagon', 'round-pentagon', 'hexagon', 'round-hexagon', 'concavehexagon', 'concave-hexagon', 'heptagon', 'round-heptagon', 'octagon', 'round-octagon', 'tag', 'round-tag', 'star', 'diamond', 'round-diamond', 'vee', 'rhomboid', 'polygon']\n      },\n      overlayShape: {\n        enums: ['roundrectangle', 'round-rectangle', 'ellipse']\n      },\n      compoundIncludeLabels: {\n        enums: ['include', 'exclude']\n      },\n      arrowShape: {\n        enums: ['tee', 'triangle', 'triangle-tee', 'circle-triangle', 'triangle-cross', 'triangle-backcurve', 'vee', 'square', 'circle', 'diamond', 'chevron', 'none']\n      },\n      arrowFill: {\n        enums: ['filled', 'hollow']\n      },\n      display: {\n        enums: ['element', 'none']\n      },\n      visibility: {\n        enums: ['hidden', 'visible']\n      },\n      zCompoundDepth: {\n        enums: ['bottom', 'orphan', 'auto', 'top']\n      },\n      zIndexCompare: {\n        enums: ['auto', 'manual']\n      },\n      valign: {\n        enums: ['top', 'center', 'bottom']\n      },\n      halign: {\n        enums: ['left', 'center', 'right']\n      },\n      justification: {\n        enums: ['left', 'center', 'right', 'auto']\n      },\n      text: {\n        string: true\n      },\n      data: {\n        mapping: true,\n        regex: data('data')\n      },\n      layoutData: {\n        mapping: true,\n        regex: data('layoutData')\n      },\n      scratch: {\n        mapping: true,\n        regex: data('scratch')\n      },\n      mapData: {\n        mapping: true,\n        regex: mapData('mapData')\n      },\n      mapLayoutData: {\n        mapping: true,\n        regex: mapData('mapLayoutData')\n      },\n      mapScratch: {\n        mapping: true,\n        regex: mapData('mapScratch')\n      },\n      fn: {\n        mapping: true,\n        fn: true\n      },\n      url: {\n        regexes: urlRegexes,\n        singleRegexMatchValue: true\n      },\n      urls: {\n        regexes: urlRegexes,\n        singleRegexMatchValue: true,\n        multiple: true\n      },\n      propList: {\n        propList: true\n      },\n      angle: {\n        number: true,\n        units: 'deg|rad',\n        implicitUnits: 'rad'\n      },\n      textRotation: {\n        number: true,\n        units: 'deg|rad',\n        implicitUnits: 'rad',\n        enums: ['none', 'autorotate']\n      },\n      polygonPointList: {\n        number: true,\n        multiple: true,\n        evenMultiple: true,\n        min: -1,\n        max: 1,\n        unitless: true\n      },\n      edgeDistances: {\n        enums: ['intersection', 'node-position']\n      },\n      edgeEndpoint: {\n        number: true,\n        multiple: true,\n        units: '%|px|em|deg|rad',\n        implicitUnits: 'px',\n        enums: ['inside-to-node', 'outside-to-node', 'outside-to-node-or-label', 'outside-to-line', 'outside-to-line-or-label'],\n        singleEnum: true,\n        validate: function validate(valArr, unitsArr) {\n          switch (valArr.length) {\n            case 2:\n              // can be % or px only\n              return unitsArr[0] !== 'deg' && unitsArr[0] !== 'rad' && unitsArr[1] !== 'deg' && unitsArr[1] !== 'rad';\n\n            case 1:\n              // can be enum, deg, or rad only\n              return string(valArr[0]) || unitsArr[0] === 'deg' || unitsArr[0] === 'rad';\n\n            default:\n              return false;\n          }\n        }\n      },\n      easing: {\n        regexes: ['^(spring)\\\\s*\\\\(\\\\s*(' + number$1 + ')\\\\s*,\\\\s*(' + number$1 + ')\\\\s*\\\\)$', '^(cubic-bezier)\\\\s*\\\\(\\\\s*(' + number$1 + ')\\\\s*,\\\\s*(' + number$1 + ')\\\\s*,\\\\s*(' + number$1 + ')\\\\s*,\\\\s*(' + number$1 + ')\\\\s*\\\\)$'],\n        enums: ['linear', 'ease', 'ease-in', 'ease-out', 'ease-in-out', 'ease-in-sine', 'ease-out-sine', 'ease-in-out-sine', 'ease-in-quad', 'ease-out-quad', 'ease-in-out-quad', 'ease-in-cubic', 'ease-out-cubic', 'ease-in-out-cubic', 'ease-in-quart', 'ease-out-quart', 'ease-in-out-quart', 'ease-in-quint', 'ease-out-quint', 'ease-in-out-quint', 'ease-in-expo', 'ease-out-expo', 'ease-in-out-expo', 'ease-in-circ', 'ease-out-circ', 'ease-in-out-circ']\n      },\n      gradientDirection: {\n        enums: ['to-bottom', 'to-top', 'to-left', 'to-right', 'to-bottom-right', 'to-bottom-left', 'to-top-right', 'to-top-left', 'to-right-bottom', 'to-left-bottom', 'to-right-top', 'to-left-top' // different order\n        ]\n      },\n      boundsExpansion: {\n        number: true,\n        multiple: true,\n        min: 0,\n        validate: function validate(valArr) {\n          var length = valArr.length;\n          return length === 1 || length === 2 || length === 4;\n        }\n      }\n    };\n    var diff = {\n      zeroNonZero: function zeroNonZero(val1, val2) {\n        if ((val1 == null || val2 == null) && val1 !== val2) {\n          return true; // null cases could represent any value\n        }\n\n        if (val1 == 0 && val2 != 0) {\n          return true;\n        } else if (val1 != 0 && val2 == 0) {\n          return true;\n        } else {\n          return false;\n        }\n      },\n      any: function any(val1, val2) {\n        return val1 != val2;\n      },\n      emptyNonEmpty: function emptyNonEmpty(str1, str2) {\n        var empty1 = emptyString(str1);\n        var empty2 = emptyString(str2);\n        return empty1 && !empty2 || !empty1 && empty2;\n      }\n    }; // define visual style properties\n    //\n    // - n.b. adding a new group of props may require updates to updateStyleHints()\n    // - adding new props to an existing group gets handled automatically\n\n    var t = styfn$2.types;\n    var mainLabel = [{\n      name: 'label',\n      type: t.text,\n      triggersBounds: diff.any,\n      triggersZOrder: diff.emptyNonEmpty\n    }, {\n      name: 'text-rotation',\n      type: t.textRotation,\n      triggersBounds: diff.any\n    }, {\n      name: 'text-margin-x',\n      type: t.bidirectionalSize,\n      triggersBounds: diff.any\n    }, {\n      name: 'text-margin-y',\n      type: t.bidirectionalSize,\n      triggersBounds: diff.any\n    }];\n    var sourceLabel = [{\n      name: 'source-label',\n      type: t.text,\n      triggersBounds: diff.any\n    }, {\n      name: 'source-text-rotation',\n      type: t.textRotation,\n      triggersBounds: diff.any\n    }, {\n      name: 'source-text-margin-x',\n      type: t.bidirectionalSize,\n      triggersBounds: diff.any\n    }, {\n      name: 'source-text-margin-y',\n      type: t.bidirectionalSize,\n      triggersBounds: diff.any\n    }, {\n      name: 'source-text-offset',\n      type: t.size,\n      triggersBounds: diff.any\n    }];\n    var targetLabel = [{\n      name: 'target-label',\n      type: t.text,\n      triggersBounds: diff.any\n    }, {\n      name: 'target-text-rotation',\n      type: t.textRotation,\n      triggersBounds: diff.any\n    }, {\n      name: 'target-text-margin-x',\n      type: t.bidirectionalSize,\n      triggersBounds: diff.any\n    }, {\n      name: 'target-text-margin-y',\n      type: t.bidirectionalSize,\n      triggersBounds: diff.any\n    }, {\n      name: 'target-text-offset',\n      type: t.size,\n      triggersBounds: diff.any\n    }];\n    var labelDimensions = [{\n      name: 'font-family',\n      type: t.fontFamily,\n      triggersBounds: diff.any\n    }, {\n      name: 'font-style',\n      type: t.fontStyle,\n      triggersBounds: diff.any\n    }, {\n      name: 'font-weight',\n      type: t.fontWeight,\n      triggersBounds: diff.any\n    }, {\n      name: 'font-size',\n      type: t.size,\n      triggersBounds: diff.any\n    }, {\n      name: 'text-transform',\n      type: t.textTransform,\n      triggersBounds: diff.any\n    }, {\n      name: 'text-wrap',\n      type: t.textWrap,\n      triggersBounds: diff.any\n    }, {\n      name: 'text-overflow-wrap',\n      type: t.textOverflowWrap,\n      triggersBounds: diff.any\n    }, {\n      name: 'text-max-width',\n      type: t.size,\n      triggersBounds: diff.any\n    }, {\n      name: 'text-outline-width',\n      type: t.size,\n      triggersBounds: diff.any\n    }, {\n      name: 'line-height',\n      type: t.positiveNumber,\n      triggersBounds: diff.any\n    }];\n    var commonLabel = [{\n      name: 'text-valign',\n      type: t.valign,\n      triggersBounds: diff.any\n    }, {\n      name: 'text-halign',\n      type: t.halign,\n      triggersBounds: diff.any\n    }, {\n      name: 'color',\n      type: t.color\n    }, {\n      name: 'text-outline-color',\n      type: t.color\n    }, {\n      name: 'text-outline-opacity',\n      type: t.zeroOneNumber\n    }, {\n      name: 'text-background-color',\n      type: t.color\n    }, {\n      name: 'text-background-opacity',\n      type: t.zeroOneNumber\n    }, {\n      name: 'text-background-padding',\n      type: t.size,\n      triggersBounds: diff.any\n    }, {\n      name: 'text-border-opacity',\n      type: t.zeroOneNumber\n    }, {\n      name: 'text-border-color',\n      type: t.color\n    }, {\n      name: 'text-border-width',\n      type: t.size,\n      triggersBounds: diff.any\n    }, {\n      name: 'text-border-style',\n      type: t.borderStyle,\n      triggersBounds: diff.any\n    }, {\n      name: 'text-background-shape',\n      type: t.textBackgroundShape,\n      triggersBounds: diff.any\n    }, {\n      name: 'text-justification',\n      type: t.justification\n    }];\n    var behavior = [{\n      name: 'events',\n      type: t.bool\n    }, {\n      name: 'text-events',\n      type: t.bool\n    }];\n    var visibility = [{\n      name: 'display',\n      type: t.display,\n      triggersZOrder: diff.any,\n      triggersBounds: diff.any,\n      triggersBoundsOfParallelBeziers: true\n    }, {\n      name: 'visibility',\n      type: t.visibility,\n      triggersZOrder: diff.any\n    }, {\n      name: 'opacity',\n      type: t.zeroOneNumber,\n      triggersZOrder: diff.zeroNonZero\n    }, {\n      name: 'text-opacity',\n      type: t.zeroOneNumber\n    }, {\n      name: 'min-zoomed-font-size',\n      type: t.size\n    }, {\n      name: 'z-compound-depth',\n      type: t.zCompoundDepth,\n      triggersZOrder: diff.any\n    }, {\n      name: 'z-index-compare',\n      type: t.zIndexCompare,\n      triggersZOrder: diff.any\n    }, {\n      name: 'z-index',\n      type: t.nonNegativeInt,\n      triggersZOrder: diff.any\n    }];\n    var overlay = [{\n      name: 'overlay-padding',\n      type: t.size,\n      triggersBounds: diff.any\n    }, {\n      name: 'overlay-color',\n      type: t.color\n    }, {\n      name: 'overlay-opacity',\n      type: t.zeroOneNumber,\n      triggersBounds: diff.zeroNonZero\n    }, {\n      name: 'overlay-shape',\n      type: t.overlayShape,\n      triggersBounds: diff.any\n    }];\n    var underlay = [{\n      name: 'underlay-padding',\n      type: t.size,\n      triggersBounds: diff.any\n    }, {\n      name: 'underlay-color',\n      type: t.color\n    }, {\n      name: 'underlay-opacity',\n      type: t.zeroOneNumber,\n      triggersBounds: diff.zeroNonZero\n    }, {\n      name: 'underlay-shape',\n      type: t.overlayShape,\n      triggersBounds: diff.any\n    }];\n    var transition = [{\n      name: 'transition-property',\n      type: t.propList\n    }, {\n      name: 'transition-duration',\n      type: t.time\n    }, {\n      name: 'transition-delay',\n      type: t.time\n    }, {\n      name: 'transition-timing-function',\n      type: t.easing\n    }];\n\n    var nodeSizeHashOverride = function nodeSizeHashOverride(ele, parsedProp) {\n      if (parsedProp.value === 'label') {\n        return -ele.poolIndex(); // no hash key hits is using label size (hitrate for perf probably low anyway)\n      } else {\n        return parsedProp.pfValue;\n      }\n    };\n\n    var nodeBody = [{\n      name: 'height',\n      type: t.nodeSize,\n      triggersBounds: diff.any,\n      hashOverride: nodeSizeHashOverride\n    }, {\n      name: 'width',\n      type: t.nodeSize,\n      triggersBounds: diff.any,\n      hashOverride: nodeSizeHashOverride\n    }, {\n      name: 'shape',\n      type: t.nodeShape,\n      triggersBounds: diff.any\n    }, {\n      name: 'shape-polygon-points',\n      type: t.polygonPointList,\n      triggersBounds: diff.any\n    }, {\n      name: 'background-color',\n      type: t.color\n    }, {\n      name: 'background-fill',\n      type: t.fill\n    }, {\n      name: 'background-opacity',\n      type: t.zeroOneNumber\n    }, {\n      name: 'background-blacken',\n      type: t.nOneOneNumber\n    }, {\n      name: 'background-gradient-stop-colors',\n      type: t.colors\n    }, {\n      name: 'background-gradient-stop-positions',\n      type: t.percentages\n    }, {\n      name: 'background-gradient-direction',\n      type: t.gradientDirection\n    }, {\n      name: 'padding',\n      type: t.sizeMaybePercent,\n      triggersBounds: diff.any\n    }, {\n      name: 'padding-relative-to',\n      type: t.paddingRelativeTo,\n      triggersBounds: diff.any\n    }, {\n      name: 'bounds-expansion',\n      type: t.boundsExpansion,\n      triggersBounds: diff.any\n    }];\n    var nodeBorder = [{\n      name: 'border-color',\n      type: t.color\n    }, {\n      name: 'border-opacity',\n      type: t.zeroOneNumber\n    }, {\n      name: 'border-width',\n      type: t.size,\n      triggersBounds: diff.any\n    }, {\n      name: 'border-style',\n      type: t.borderStyle\n    }];\n    var backgroundImage = [{\n      name: 'background-image',\n      type: t.urls\n    }, {\n      name: 'background-image-crossorigin',\n      type: t.bgCrossOrigin\n    }, {\n      name: 'background-image-opacity',\n      type: t.zeroOneNumbers\n    }, {\n      name: 'background-image-containment',\n      type: t.bgContainment\n    }, {\n      name: 'background-image-smoothing',\n      type: t.bools\n    }, {\n      name: 'background-position-x',\n      type: t.bgPos\n    }, {\n      name: 'background-position-y',\n      type: t.bgPos\n    }, {\n      name: 'background-width-relative-to',\n      type: t.bgRelativeTo\n    }, {\n      name: 'background-height-relative-to',\n      type: t.bgRelativeTo\n    }, {\n      name: 'background-repeat',\n      type: t.bgRepeat\n    }, {\n      name: 'background-fit',\n      type: t.bgFit\n    }, {\n      name: 'background-clip',\n      type: t.bgClip\n    }, {\n      name: 'background-width',\n      type: t.bgWH\n    }, {\n      name: 'background-height',\n      type: t.bgWH\n    }, {\n      name: 'background-offset-x',\n      type: t.bgPos\n    }, {\n      name: 'background-offset-y',\n      type: t.bgPos\n    }];\n    var compound = [{\n      name: 'position',\n      type: t.position,\n      triggersBounds: diff.any\n    }, {\n      name: 'compound-sizing-wrt-labels',\n      type: t.compoundIncludeLabels,\n      triggersBounds: diff.any\n    }, {\n      name: 'min-width',\n      type: t.size,\n      triggersBounds: diff.any\n    }, {\n      name: 'min-width-bias-left',\n      type: t.sizeMaybePercent,\n      triggersBounds: diff.any\n    }, {\n      name: 'min-width-bias-right',\n      type: t.sizeMaybePercent,\n      triggersBounds: diff.any\n    }, {\n      name: 'min-height',\n      type: t.size,\n      triggersBounds: diff.any\n    }, {\n      name: 'min-height-bias-top',\n      type: t.sizeMaybePercent,\n      triggersBounds: diff.any\n    }, {\n      name: 'min-height-bias-bottom',\n      type: t.sizeMaybePercent,\n      triggersBounds: diff.any\n    }];\n    var edgeLine = [{\n      name: 'line-style',\n      type: t.lineStyle\n    }, {\n      name: 'line-color',\n      type: t.color\n    }, {\n      name: 'line-fill',\n      type: t.fill\n    }, {\n      name: 'line-cap',\n      type: t.lineCap\n    }, {\n      name: 'line-opacity',\n      type: t.zeroOneNumber\n    }, {\n      name: 'line-dash-pattern',\n      type: t.numbers\n    }, {\n      name: 'line-dash-offset',\n      type: t.number\n    }, {\n      name: 'line-gradient-stop-colors',\n      type: t.colors\n    }, {\n      name: 'line-gradient-stop-positions',\n      type: t.percentages\n    }, {\n      name: 'curve-style',\n      type: t.curveStyle,\n      triggersBounds: diff.any,\n      triggersBoundsOfParallelBeziers: true\n    }, {\n      name: 'haystack-radius',\n      type: t.zeroOneNumber,\n      triggersBounds: diff.any\n    }, {\n      name: 'source-endpoint',\n      type: t.edgeEndpoint,\n      triggersBounds: diff.any\n    }, {\n      name: 'target-endpoint',\n      type: t.edgeEndpoint,\n      triggersBounds: diff.any\n    }, {\n      name: 'control-point-step-size',\n      type: t.size,\n      triggersBounds: diff.any\n    }, {\n      name: 'control-point-distances',\n      type: t.bidirectionalSizes,\n      triggersBounds: diff.any\n    }, {\n      name: 'control-point-weights',\n      type: t.numbers,\n      triggersBounds: diff.any\n    }, {\n      name: 'segment-distances',\n      type: t.bidirectionalSizes,\n      triggersBounds: diff.any\n    }, {\n      name: 'segment-weights',\n      type: t.numbers,\n      triggersBounds: diff.any\n    }, {\n      name: 'taxi-turn',\n      type: t.bidirectionalSizeMaybePercent,\n      triggersBounds: diff.any\n    }, {\n      name: 'taxi-turn-min-distance',\n      type: t.size,\n      triggersBounds: diff.any\n    }, {\n      name: 'taxi-direction',\n      type: t.axisDirection,\n      triggersBounds: diff.any\n    }, {\n      name: 'edge-distances',\n      type: t.edgeDistances,\n      triggersBounds: diff.any\n    }, {\n      name: 'arrow-scale',\n      type: t.positiveNumber,\n      triggersBounds: diff.any\n    }, {\n      name: 'loop-direction',\n      type: t.angle,\n      triggersBounds: diff.any\n    }, {\n      name: 'loop-sweep',\n      type: t.angle,\n      triggersBounds: diff.any\n    }, {\n      name: 'source-distance-from-node',\n      type: t.size,\n      triggersBounds: diff.any\n    }, {\n      name: 'target-distance-from-node',\n      type: t.size,\n      triggersBounds: diff.any\n    }];\n    var ghost = [{\n      name: 'ghost',\n      type: t.bool,\n      triggersBounds: diff.any\n    }, {\n      name: 'ghost-offset-x',\n      type: t.bidirectionalSize,\n      triggersBounds: diff.any\n    }, {\n      name: 'ghost-offset-y',\n      type: t.bidirectionalSize,\n      triggersBounds: diff.any\n    }, {\n      name: 'ghost-opacity',\n      type: t.zeroOneNumber\n    }];\n    var core = [{\n      name: 'selection-box-color',\n      type: t.color\n    }, {\n      name: 'selection-box-opacity',\n      type: t.zeroOneNumber\n    }, {\n      name: 'selection-box-border-color',\n      type: t.color\n    }, {\n      name: 'selection-box-border-width',\n      type: t.size\n    }, {\n      name: 'active-bg-color',\n      type: t.color\n    }, {\n      name: 'active-bg-opacity',\n      type: t.zeroOneNumber\n    }, {\n      name: 'active-bg-size',\n      type: t.size\n    }, {\n      name: 'outside-texture-bg-color',\n      type: t.color\n    }, {\n      name: 'outside-texture-bg-opacity',\n      type: t.zeroOneNumber\n    }]; // pie backgrounds for nodes\n\n    var pie = [];\n    styfn$2.pieBackgroundN = 16; // because the pie properties are numbered, give access to a constant N (for renderer use)\n\n    pie.push({\n      name: 'pie-size',\n      type: t.sizeMaybePercent\n    });\n\n    for (var i = 1; i <= styfn$2.pieBackgroundN; i++) {\n      pie.push({\n        name: 'pie-' + i + '-background-color',\n        type: t.color\n      });\n      pie.push({\n        name: 'pie-' + i + '-background-size',\n        type: t.percent\n      });\n      pie.push({\n        name: 'pie-' + i + '-background-opacity',\n        type: t.zeroOneNumber\n      });\n    } // edge arrows\n\n\n    var edgeArrow = [];\n    var arrowPrefixes = styfn$2.arrowPrefixes = ['source', 'mid-source', 'target', 'mid-target'];\n    [{\n      name: 'arrow-shape',\n      type: t.arrowShape,\n      triggersBounds: diff.any\n    }, {\n      name: 'arrow-color',\n      type: t.color\n    }, {\n      name: 'arrow-fill',\n      type: t.arrowFill\n    }].forEach(function (prop) {\n      arrowPrefixes.forEach(function (prefix) {\n        var name = prefix + '-' + prop.name;\n        var type = prop.type,\n            triggersBounds = prop.triggersBounds;\n        edgeArrow.push({\n          name: name,\n          type: type,\n          triggersBounds: triggersBounds\n        });\n      });\n    }, {});\n    var props = styfn$2.properties = [].concat(behavior, transition, visibility, overlay, underlay, ghost, commonLabel, labelDimensions, mainLabel, sourceLabel, targetLabel, nodeBody, nodeBorder, backgroundImage, pie, compound, edgeLine, edgeArrow, core);\n    var propGroups = styfn$2.propertyGroups = {\n      // common to all eles\n      behavior: behavior,\n      transition: transition,\n      visibility: visibility,\n      overlay: overlay,\n      underlay: underlay,\n      ghost: ghost,\n      // labels\n      commonLabel: commonLabel,\n      labelDimensions: labelDimensions,\n      mainLabel: mainLabel,\n      sourceLabel: sourceLabel,\n      targetLabel: targetLabel,\n      // node props\n      nodeBody: nodeBody,\n      nodeBorder: nodeBorder,\n      backgroundImage: backgroundImage,\n      pie: pie,\n      compound: compound,\n      // edge props\n      edgeLine: edgeLine,\n      edgeArrow: edgeArrow,\n      core: core\n    };\n    var propGroupNames = styfn$2.propertyGroupNames = {};\n    var propGroupKeys = styfn$2.propertyGroupKeys = Object.keys(propGroups);\n    propGroupKeys.forEach(function (key) {\n      propGroupNames[key] = propGroups[key].map(function (prop) {\n        return prop.name;\n      });\n      propGroups[key].forEach(function (prop) {\n        return prop.groupKey = key;\n      });\n    }); // define aliases\n\n    var aliases = styfn$2.aliases = [{\n      name: 'content',\n      pointsTo: 'label'\n    }, {\n      name: 'control-point-distance',\n      pointsTo: 'control-point-distances'\n    }, {\n      name: 'control-point-weight',\n      pointsTo: 'control-point-weights'\n    }, {\n      name: 'edge-text-rotation',\n      pointsTo: 'text-rotation'\n    }, {\n      name: 'padding-left',\n      pointsTo: 'padding'\n    }, {\n      name: 'padding-right',\n      pointsTo: 'padding'\n    }, {\n      name: 'padding-top',\n      pointsTo: 'padding'\n    }, {\n      name: 'padding-bottom',\n      pointsTo: 'padding'\n    }]; // list of property names\n\n    styfn$2.propertyNames = props.map(function (p) {\n      return p.name;\n    }); // allow access of properties by name ( e.g. style.properties.height )\n\n    for (var _i = 0; _i < props.length; _i++) {\n      var prop = props[_i];\n      props[prop.name] = prop; // allow lookup by name\n    } // map aliases\n\n\n    for (var _i2 = 0; _i2 < aliases.length; _i2++) {\n      var alias = aliases[_i2];\n      var pointsToProp = props[alias.pointsTo];\n      var aliasProp = {\n        name: alias.name,\n        alias: true,\n        pointsTo: pointsToProp\n      }; // add alias prop for parsing\n\n      props.push(aliasProp);\n      props[alias.name] = aliasProp; // allow lookup by name\n    }\n  })();\n\n  styfn$2.getDefaultProperty = function (name) {\n    return this.getDefaultProperties()[name];\n  };\n\n  styfn$2.getDefaultProperties = function () {\n    var _p = this._private;\n\n    if (_p.defaultProperties != null) {\n      return _p.defaultProperties;\n    }\n\n    var rawProps = extend({\n      // core props\n      'selection-box-color': '#ddd',\n      'selection-box-opacity': 0.65,\n      'selection-box-border-color': '#aaa',\n      'selection-box-border-width': 1,\n      'active-bg-color': 'black',\n      'active-bg-opacity': 0.15,\n      'active-bg-size': 30,\n      'outside-texture-bg-color': '#000',\n      'outside-texture-bg-opacity': 0.125,\n      // common node/edge props\n      'events': 'yes',\n      'text-events': 'no',\n      'text-valign': 'top',\n      'text-halign': 'center',\n      'text-justification': 'auto',\n      'line-height': 1,\n      'color': '#000',\n      'text-outline-color': '#000',\n      'text-outline-width': 0,\n      'text-outline-opacity': 1,\n      'text-opacity': 1,\n      'text-decoration': 'none',\n      'text-transform': 'none',\n      'text-wrap': 'none',\n      'text-overflow-wrap': 'whitespace',\n      'text-max-width': 9999,\n      'text-background-color': '#000',\n      'text-background-opacity': 0,\n      'text-background-shape': 'rectangle',\n      'text-background-padding': 0,\n      'text-border-opacity': 0,\n      'text-border-width': 0,\n      'text-border-style': 'solid',\n      'text-border-color': '#000',\n      'font-family': 'Helvetica Neue, Helvetica, sans-serif',\n      'font-style': 'normal',\n      'font-weight': 'normal',\n      'font-size': 16,\n      'min-zoomed-font-size': 0,\n      'text-rotation': 'none',\n      'source-text-rotation': 'none',\n      'target-text-rotation': 'none',\n      'visibility': 'visible',\n      'display': 'element',\n      'opacity': 1,\n      'z-compound-depth': 'auto',\n      'z-index-compare': 'auto',\n      'z-index': 0,\n      'label': '',\n      'text-margin-x': 0,\n      'text-margin-y': 0,\n      'source-label': '',\n      'source-text-offset': 0,\n      'source-text-margin-x': 0,\n      'source-text-margin-y': 0,\n      'target-label': '',\n      'target-text-offset': 0,\n      'target-text-margin-x': 0,\n      'target-text-margin-y': 0,\n      'overlay-opacity': 0,\n      'overlay-color': '#000',\n      'overlay-padding': 10,\n      'overlay-shape': 'round-rectangle',\n      'underlay-opacity': 0,\n      'underlay-color': '#000',\n      'underlay-padding': 10,\n      'underlay-shape': 'round-rectangle',\n      'transition-property': 'none',\n      'transition-duration': 0,\n      'transition-delay': 0,\n      'transition-timing-function': 'linear',\n      // node props\n      'background-blacken': 0,\n      'background-color': '#999',\n      'background-fill': 'solid',\n      'background-opacity': 1,\n      'background-image': 'none',\n      'background-image-crossorigin': 'anonymous',\n      'background-image-opacity': 1,\n      'background-image-containment': 'inside',\n      'background-image-smoothing': 'yes',\n      'background-position-x': '50%',\n      'background-position-y': '50%',\n      'background-offset-x': 0,\n      'background-offset-y': 0,\n      'background-width-relative-to': 'include-padding',\n      'background-height-relative-to': 'include-padding',\n      'background-repeat': 'no-repeat',\n      'background-fit': 'none',\n      'background-clip': 'node',\n      'background-width': 'auto',\n      'background-height': 'auto',\n      'border-color': '#000',\n      'border-opacity': 1,\n      'border-width': 0,\n      'border-style': 'solid',\n      'height': 30,\n      'width': 30,\n      'shape': 'ellipse',\n      'shape-polygon-points': '-1, -1,   1, -1,   1, 1,   -1, 1',\n      'bounds-expansion': 0,\n      // node gradient\n      'background-gradient-direction': 'to-bottom',\n      'background-gradient-stop-colors': '#999',\n      'background-gradient-stop-positions': '0%',\n      // ghost props\n      'ghost': 'no',\n      'ghost-offset-y': 0,\n      'ghost-offset-x': 0,\n      'ghost-opacity': 0,\n      // compound props\n      'padding': 0,\n      'padding-relative-to': 'width',\n      'position': 'origin',\n      'compound-sizing-wrt-labels': 'include',\n      'min-width': 0,\n      'min-width-bias-left': 0,\n      'min-width-bias-right': 0,\n      'min-height': 0,\n      'min-height-bias-top': 0,\n      'min-height-bias-bottom': 0\n    }, {\n      // node pie bg\n      'pie-size': '100%'\n    }, [{\n      name: 'pie-{{i}}-background-color',\n      value: 'black'\n    }, {\n      name: 'pie-{{i}}-background-size',\n      value: '0%'\n    }, {\n      name: 'pie-{{i}}-background-opacity',\n      value: 1\n    }].reduce(function (css, prop) {\n      for (var i = 1; i <= styfn$2.pieBackgroundN; i++) {\n        var name = prop.name.replace('{{i}}', i);\n        var val = prop.value;\n        css[name] = val;\n      }\n\n      return css;\n    }, {}), {\n      // edge props\n      'line-style': 'solid',\n      'line-color': '#999',\n      'line-fill': 'solid',\n      'line-cap': 'butt',\n      'line-opacity': 1,\n      'line-gradient-stop-colors': '#999',\n      'line-gradient-stop-positions': '0%',\n      'control-point-step-size': 40,\n      'control-point-weights': 0.5,\n      'segment-weights': 0.5,\n      'segment-distances': 20,\n      'taxi-turn': '50%',\n      'taxi-turn-min-distance': 10,\n      'taxi-direction': 'auto',\n      'edge-distances': 'intersection',\n      'curve-style': 'haystack',\n      'haystack-radius': 0,\n      'arrow-scale': 1,\n      'loop-direction': '-45deg',\n      'loop-sweep': '-90deg',\n      'source-distance-from-node': 0,\n      'target-distance-from-node': 0,\n      'source-endpoint': 'outside-to-node',\n      'target-endpoint': 'outside-to-node',\n      'line-dash-pattern': [6, 3],\n      'line-dash-offset': 0\n    }, [{\n      name: 'arrow-shape',\n      value: 'none'\n    }, {\n      name: 'arrow-color',\n      value: '#999'\n    }, {\n      name: 'arrow-fill',\n      value: 'filled'\n    }].reduce(function (css, prop) {\n      styfn$2.arrowPrefixes.forEach(function (prefix) {\n        var name = prefix + '-' + prop.name;\n        var val = prop.value;\n        css[name] = val;\n      });\n      return css;\n    }, {}));\n    var parsedProps = {};\n\n    for (var i = 0; i < this.properties.length; i++) {\n      var prop = this.properties[i];\n\n      if (prop.pointsTo) {\n        continue;\n      }\n\n      var name = prop.name;\n      var val = rawProps[name];\n      var parsedProp = this.parse(name, val);\n      parsedProps[name] = parsedProp;\n    }\n\n    _p.defaultProperties = parsedProps;\n    return _p.defaultProperties;\n  };\n\n  styfn$2.addDefaultStylesheet = function () {\n    this.selector(':parent').css({\n      'shape': 'rectangle',\n      'padding': 10,\n      'background-color': '#eee',\n      'border-color': '#ccc',\n      'border-width': 1\n    }).selector('edge').css({\n      'width': 3\n    }).selector(':loop').css({\n      'curve-style': 'bezier'\n    }).selector('edge:compound').css({\n      'curve-style': 'bezier',\n      'source-endpoint': 'outside-to-line',\n      'target-endpoint': 'outside-to-line'\n    }).selector(':selected').css({\n      'background-color': '#0169D9',\n      'line-color': '#0169D9',\n      'source-arrow-color': '#0169D9',\n      'target-arrow-color': '#0169D9',\n      'mid-source-arrow-color': '#0169D9',\n      'mid-target-arrow-color': '#0169D9'\n    }).selector(':parent:selected').css({\n      'background-color': '#CCE1F9',\n      'border-color': '#aec8e5'\n    }).selector(':active').css({\n      'overlay-color': 'black',\n      'overlay-padding': 10,\n      'overlay-opacity': 0.25\n    });\n    this.defaultLength = this.length;\n  };\n\n  var styfn$1 = {}; // a caching layer for property parsing\n\n  styfn$1.parse = function (name, value, propIsBypass, propIsFlat) {\n    var self = this; // function values can't be cached in all cases, and there isn't much benefit of caching them anyway\n\n    if (fn$6(value)) {\n      return self.parseImplWarn(name, value, propIsBypass, propIsFlat);\n    }\n\n    var flatKey = propIsFlat === 'mapping' || propIsFlat === true || propIsFlat === false || propIsFlat == null ? 'dontcare' : propIsFlat;\n    var bypassKey = propIsBypass ? 't' : 'f';\n    var valueKey = '' + value;\n    var argHash = hashStrings(name, valueKey, bypassKey, flatKey);\n    var propCache = self.propCache = self.propCache || [];\n    var ret;\n\n    if (!(ret = propCache[argHash])) {\n      ret = propCache[argHash] = self.parseImplWarn(name, value, propIsBypass, propIsFlat);\n    } // - bypasses can't be shared b/c the value can be changed by animations or otherwise overridden\n    // - mappings can't be shared b/c mappings are per-element\n\n\n    if (propIsBypass || propIsFlat === 'mapping') {\n      // need a copy since props are mutated later in their lifecycles\n      ret = copy(ret);\n\n      if (ret) {\n        ret.value = copy(ret.value); // because it could be an array, e.g. colour\n      }\n    }\n\n    return ret;\n  };\n\n  styfn$1.parseImplWarn = function (name, value, propIsBypass, propIsFlat) {\n    var prop = this.parseImpl(name, value, propIsBypass, propIsFlat);\n\n    if (!prop && value != null) {\n      warn(\"The style property `\".concat(name, \": \").concat(value, \"` is invalid\"));\n    }\n\n    if (prop && (prop.name === 'width' || prop.name === 'height') && value === 'label') {\n      warn('The style value of `label` is deprecated for `' + prop.name + '`');\n    }\n\n    return prop;\n  }; // parse a property; return null on invalid; return parsed property otherwise\n  // fields :\n  // - name : the name of the property\n  // - value : the parsed, native-typed value of the property\n  // - strValue : a string value that represents the property value in valid css\n  // - bypass : true iff the property is a bypass property\n\n\n  styfn$1.parseImpl = function (name, value, propIsBypass, propIsFlat) {\n    var self = this;\n    name = camel2dash(name); // make sure the property name is in dash form (e.g. 'property-name' not 'propertyName')\n\n    var property = self.properties[name];\n    var passedValue = value;\n    var types = self.types;\n\n    if (!property) {\n      return null;\n    } // return null on property of unknown name\n\n\n    if (value === undefined) {\n      return null;\n    } // can't assign undefined\n    // the property may be an alias\n\n\n    if (property.alias) {\n      property = property.pointsTo;\n      name = property.name;\n    }\n\n    var valueIsString = string(value);\n\n    if (valueIsString) {\n      // trim the value to make parsing easier\n      value = value.trim();\n    }\n\n    var type = property.type;\n\n    if (!type) {\n      return null;\n    } // no type, no luck\n    // check if bypass is null or empty string (i.e. indication to delete bypass property)\n\n\n    if (propIsBypass && (value === '' || value === null)) {\n      return {\n        name: name,\n        value: value,\n        bypass: true,\n        deleteBypass: true\n      };\n    } // check if value is a function used as a mapper\n\n\n    if (fn$6(value)) {\n      return {\n        name: name,\n        value: value,\n        strValue: 'fn',\n        mapped: types.fn,\n        bypass: propIsBypass\n      };\n    } // check if value is mapped\n\n\n    var data, mapData;\n\n    if (!valueIsString || propIsFlat || value.length < 7 || value[1] !== 'a') ; else if (value.length >= 7 && value[0] === 'd' && (data = new RegExp(types.data.regex).exec(value))) {\n      if (propIsBypass) {\n        return false;\n      } // mappers not allowed in bypass\n\n\n      var mapped = types.data;\n      return {\n        name: name,\n        value: data,\n        strValue: '' + value,\n        mapped: mapped,\n        field: data[1],\n        bypass: propIsBypass\n      };\n    } else if (value.length >= 10 && value[0] === 'm' && (mapData = new RegExp(types.mapData.regex).exec(value))) {\n      if (propIsBypass) {\n        return false;\n      } // mappers not allowed in bypass\n\n\n      if (type.multiple) {\n        return false;\n      } // impossible to map to num\n\n\n      var _mapped = types.mapData; // we can map only if the type is a colour or a number\n\n      if (!(type.color || type.number)) {\n        return false;\n      }\n\n      var valueMin = this.parse(name, mapData[4]); // parse to validate\n\n      if (!valueMin || valueMin.mapped) {\n        return false;\n      } // can't be invalid or mapped\n\n\n      var valueMax = this.parse(name, mapData[5]); // parse to validate\n\n      if (!valueMax || valueMax.mapped) {\n        return false;\n      } // can't be invalid or mapped\n      // check if valueMin and valueMax are the same\n\n\n      if (valueMin.pfValue === valueMax.pfValue || valueMin.strValue === valueMax.strValue) {\n        warn('`' + name + ': ' + value + '` is not a valid mapper because the output range is zero; converting to `' + name + ': ' + valueMin.strValue + '`');\n        return this.parse(name, valueMin.strValue); // can't make much of a mapper without a range\n      } else if (type.color) {\n        var c1 = valueMin.value;\n        var c2 = valueMax.value;\n        var same = c1[0] === c2[0] // red\n        && c1[1] === c2[1] // green\n        && c1[2] === c2[2] // blue\n        && ( // optional alpha\n        c1[3] === c2[3] // same alpha outright\n        || (c1[3] == null || c1[3] === 1 // full opacity for colour 1?\n        ) && (c2[3] == null || c2[3] === 1) // full opacity for colour 2?\n        );\n\n        if (same) {\n          return false;\n        } // can't make a mapper without a range\n\n      }\n\n      return {\n        name: name,\n        value: mapData,\n        strValue: '' + value,\n        mapped: _mapped,\n        field: mapData[1],\n        fieldMin: parseFloat(mapData[2]),\n        // min & max are numeric\n        fieldMax: parseFloat(mapData[3]),\n        valueMin: valueMin.value,\n        valueMax: valueMax.value,\n        bypass: propIsBypass\n      };\n    }\n\n    if (type.multiple && propIsFlat !== 'multiple') {\n      var vals;\n\n      if (valueIsString) {\n        vals = value.split(/\\s+/);\n      } else if (array(value)) {\n        vals = value;\n      } else {\n        vals = [value];\n      }\n\n      if (type.evenMultiple && vals.length % 2 !== 0) {\n        return null;\n      }\n\n      var valArr = [];\n      var unitsArr = [];\n      var pfValArr = [];\n      var strVal = '';\n      var hasEnum = false;\n\n      for (var i = 0; i < vals.length; i++) {\n        var p = self.parse(name, vals[i], propIsBypass, 'multiple');\n        hasEnum = hasEnum || string(p.value);\n        valArr.push(p.value);\n        pfValArr.push(p.pfValue != null ? p.pfValue : p.value);\n        unitsArr.push(p.units);\n        strVal += (i > 0 ? ' ' : '') + p.strValue;\n      }\n\n      if (type.validate && !type.validate(valArr, unitsArr)) {\n        return null;\n      }\n\n      if (type.singleEnum && hasEnum) {\n        if (valArr.length === 1 && string(valArr[0])) {\n          return {\n            name: name,\n            value: valArr[0],\n            strValue: valArr[0],\n            bypass: propIsBypass\n          };\n        } else {\n          return null;\n        }\n      }\n\n      return {\n        name: name,\n        value: valArr,\n        pfValue: pfValArr,\n        strValue: strVal,\n        bypass: propIsBypass,\n        units: unitsArr\n      };\n    } // several types also allow enums\n\n\n    var checkEnums = function checkEnums() {\n      for (var _i = 0; _i < type.enums.length; _i++) {\n        var en = type.enums[_i];\n\n        if (en === value) {\n          return {\n            name: name,\n            value: value,\n            strValue: '' + value,\n            bypass: propIsBypass\n          };\n        }\n      }\n\n      return null;\n    }; // check the type and return the appropriate object\n\n\n    if (type.number) {\n      var units;\n      var implicitUnits = 'px'; // not set => px\n\n      if (type.units) {\n        // use specified units if set\n        units = type.units;\n      }\n\n      if (type.implicitUnits) {\n        implicitUnits = type.implicitUnits;\n      }\n\n      if (!type.unitless) {\n        if (valueIsString) {\n          var unitsRegex = 'px|em' + (type.allowPercent ? '|\\\\%' : '');\n\n          if (units) {\n            unitsRegex = units;\n          } // only allow explicit units if so set\n\n\n          var match = value.match('^(' + number + ')(' + unitsRegex + ')?' + '$');\n\n          if (match) {\n            value = match[1];\n            units = match[2] || implicitUnits;\n          }\n        } else if (!units || type.implicitUnits) {\n          units = implicitUnits; // implicitly px if unspecified\n        }\n      }\n\n      value = parseFloat(value); // if not a number and enums not allowed, then the value is invalid\n\n      if (isNaN(value) && type.enums === undefined) {\n        return null;\n      } // check if this number type also accepts special keywords in place of numbers\n      // (i.e. `left`, `auto`, etc)\n\n\n      if (isNaN(value) && type.enums !== undefined) {\n        value = passedValue;\n        return checkEnums();\n      } // check if value must be an integer\n\n\n      if (type.integer && !integer(value)) {\n        return null;\n      } // check value is within range\n\n\n      if (type.min !== undefined && (value < type.min || type.strictMin && value === type.min) || type.max !== undefined && (value > type.max || type.strictMax && value === type.max)) {\n        return null;\n      }\n\n      var ret = {\n        name: name,\n        value: value,\n        strValue: '' + value + (units ? units : ''),\n        units: units,\n        bypass: propIsBypass\n      }; // normalise value in pixels\n\n      if (type.unitless || units !== 'px' && units !== 'em') {\n        ret.pfValue = value;\n      } else {\n        ret.pfValue = units === 'px' || !units ? value : this.getEmSizeInPixels() * value;\n      } // normalise value in ms\n\n\n      if (units === 'ms' || units === 's') {\n        ret.pfValue = units === 'ms' ? value : 1000 * value;\n      } // normalise value in rad\n\n\n      if (units === 'deg' || units === 'rad') {\n        ret.pfValue = units === 'rad' ? value : deg2rad(value);\n      } // normalize value in %\n\n\n      if (units === '%') {\n        ret.pfValue = value / 100;\n      }\n\n      return ret;\n    } else if (type.propList) {\n      var props = [];\n      var propsStr = '' + value;\n\n      if (propsStr === 'none') ; else {\n        // go over each prop\n        var propsSplit = propsStr.split(/\\s*,\\s*|\\s+/);\n\n        for (var _i2 = 0; _i2 < propsSplit.length; _i2++) {\n          var propName = propsSplit[_i2].trim();\n\n          if (self.properties[propName]) {\n            props.push(propName);\n          } else {\n            warn('`' + propName + '` is not a valid property name');\n          }\n        }\n\n        if (props.length === 0) {\n          return null;\n        }\n      }\n\n      return {\n        name: name,\n        value: props,\n        strValue: props.length === 0 ? 'none' : props.join(' '),\n        bypass: propIsBypass\n      };\n    } else if (type.color) {\n      var tuple = color2tuple(value);\n\n      if (!tuple) {\n        return null;\n      }\n\n      return {\n        name: name,\n        value: tuple,\n        pfValue: tuple,\n        strValue: 'rgb(' + tuple[0] + ',' + tuple[1] + ',' + tuple[2] + ')',\n        // n.b. no spaces b/c of multiple support\n        bypass: propIsBypass\n      };\n    } else if (type.regex || type.regexes) {\n      // first check enums\n      if (type.enums) {\n        var enumProp = checkEnums();\n\n        if (enumProp) {\n          return enumProp;\n        }\n      }\n\n      var regexes = type.regexes ? type.regexes : [type.regex];\n\n      for (var _i3 = 0; _i3 < regexes.length; _i3++) {\n        var regex = new RegExp(regexes[_i3]); // make a regex from the type string\n\n        var m = regex.exec(value);\n\n        if (m) {\n          // regex matches\n          return {\n            name: name,\n            value: type.singleRegexMatchValue ? m[1] : m,\n            strValue: '' + value,\n            bypass: propIsBypass\n          };\n        }\n      }\n\n      return null; // didn't match any\n    } else if (type.string) {\n      // just return\n      return {\n        name: name,\n        value: '' + value,\n        strValue: '' + value,\n        bypass: propIsBypass\n      };\n    } else if (type.enums) {\n      // check enums last because it's a combo type in others\n      return checkEnums();\n    } else {\n      return null; // not a type we can handle\n    }\n  };\n\n  var Style = function Style(cy) {\n    if (!(this instanceof Style)) {\n      return new Style(cy);\n    }\n\n    if (!core(cy)) {\n      error('A style must have a core reference');\n      return;\n    }\n\n    this._private = {\n      cy: cy,\n      coreStyle: {}\n    };\n    this.length = 0;\n    this.resetToDefault();\n  };\n\n  var styfn = Style.prototype;\n\n  styfn.instanceString = function () {\n    return 'style';\n  }; // remove all contexts\n\n\n  styfn.clear = function () {\n    var _p = this._private;\n    var cy = _p.cy;\n    var eles = cy.elements();\n\n    for (var i = 0; i < this.length; i++) {\n      this[i] = undefined;\n    }\n\n    this.length = 0;\n    _p.contextStyles = {};\n    _p.propDiffs = {};\n    this.cleanElements(eles, true);\n    eles.forEach(function (ele) {\n      var ele_p = ele[0]._private;\n      ele_p.styleDirty = true;\n      ele_p.appliedInitStyle = false;\n    });\n    return this; // chaining\n  };\n\n  styfn.resetToDefault = function () {\n    this.clear();\n    this.addDefaultStylesheet();\n    return this;\n  }; // builds a style object for the 'core' selector\n\n\n  styfn.core = function (propName) {\n    return this._private.coreStyle[propName] || this.getDefaultProperty(propName);\n  }; // create a new context from the specified selector string and switch to that context\n\n\n  styfn.selector = function (selectorStr) {\n    // 'core' is a special case and does not need a selector\n    var selector = selectorStr === 'core' ? null : new Selector(selectorStr);\n    var i = this.length++; // new context means new index\n\n    this[i] = {\n      selector: selector,\n      properties: [],\n      mappedProperties: [],\n      index: i\n    };\n    return this; // chaining\n  }; // add one or many css rules to the current context\n\n\n  styfn.css = function () {\n    var self = this;\n    var args = arguments;\n\n    if (args.length === 1) {\n      var map = args[0];\n\n      for (var i = 0; i < self.properties.length; i++) {\n        var prop = self.properties[i];\n        var mapVal = map[prop.name];\n\n        if (mapVal === undefined) {\n          mapVal = map[dash2camel(prop.name)];\n        }\n\n        if (mapVal !== undefined) {\n          this.cssRule(prop.name, mapVal);\n        }\n      }\n    } else if (args.length === 2) {\n      this.cssRule(args[0], args[1]);\n    } // do nothing if args are invalid\n\n\n    return this; // chaining\n  };\n\n  styfn.style = styfn.css; // add a single css rule to the current context\n\n  styfn.cssRule = function (name, value) {\n    // name-value pair\n    var property = this.parse(name, value); // add property to current context if valid\n\n    if (property) {\n      var i = this.length - 1;\n      this[i].properties.push(property);\n      this[i].properties[property.name] = property; // allow access by name as well\n\n      if (property.name.match(/pie-(\\d+)-background-size/) && property.value) {\n        this._private.hasPie = true;\n      }\n\n      if (property.mapped) {\n        this[i].mappedProperties.push(property);\n      } // add to core style if necessary\n\n\n      var currentSelectorIsCore = !this[i].selector;\n\n      if (currentSelectorIsCore) {\n        this._private.coreStyle[property.name] = property;\n      }\n    }\n\n    return this; // chaining\n  };\n\n  styfn.append = function (style) {\n    if (stylesheet(style)) {\n      style.appendToStyle(this);\n    } else if (array(style)) {\n      this.appendFromJson(style);\n    } else if (string(style)) {\n      this.appendFromString(style);\n    } // you probably wouldn't want to append a Style, since you'd duplicate the default parts\n\n\n    return this;\n  }; // static function\n\n\n  Style.fromJson = function (cy, json) {\n    var style = new Style(cy);\n    style.fromJson(json);\n    return style;\n  };\n\n  Style.fromString = function (cy, string) {\n    return new Style(cy).fromString(string);\n  };\n\n  [styfn$8, styfn$7, styfn$6, styfn$5, styfn$4, styfn$3, styfn$2, styfn$1].forEach(function (props) {\n    extend(styfn, props);\n  });\n  Style.types = styfn.types;\n  Style.properties = styfn.properties;\n  Style.propertyGroups = styfn.propertyGroups;\n  Style.propertyGroupNames = styfn.propertyGroupNames;\n  Style.propertyGroupKeys = styfn.propertyGroupKeys;\n\n  var corefn$2 = {\n    style: function style(newStyle) {\n      if (newStyle) {\n        var s = this.setStyle(newStyle);\n        s.update();\n      }\n\n      return this._private.style;\n    },\n    setStyle: function setStyle(style) {\n      var _p = this._private;\n\n      if (stylesheet(style)) {\n        _p.style = style.generateStyle(this);\n      } else if (array(style)) {\n        _p.style = Style.fromJson(this, style);\n      } else if (string(style)) {\n        _p.style = Style.fromString(this, style);\n      } else {\n        _p.style = Style(this);\n      }\n\n      return _p.style;\n    },\n    // e.g. cy.data() changed => recalc ele mappers\n    updateStyle: function updateStyle() {\n      this.mutableElements().updateStyle(); // just send to all eles\n    }\n  };\n\n  var defaultSelectionType = 'single';\n  var corefn$1 = {\n    autolock: function autolock(bool) {\n      if (bool !== undefined) {\n        this._private.autolock = bool ? true : false;\n      } else {\n        return this._private.autolock;\n      }\n\n      return this; // chaining\n    },\n    autoungrabify: function autoungrabify(bool) {\n      if (bool !== undefined) {\n        this._private.autoungrabify = bool ? true : false;\n      } else {\n        return this._private.autoungrabify;\n      }\n\n      return this; // chaining\n    },\n    autounselectify: function autounselectify(bool) {\n      if (bool !== undefined) {\n        this._private.autounselectify = bool ? true : false;\n      } else {\n        return this._private.autounselectify;\n      }\n\n      return this; // chaining\n    },\n    selectionType: function selectionType(selType) {\n      var _p = this._private;\n\n      if (_p.selectionType == null) {\n        _p.selectionType = defaultSelectionType;\n      }\n\n      if (selType !== undefined) {\n        if (selType === 'additive' || selType === 'single') {\n          _p.selectionType = selType;\n        }\n      } else {\n        return _p.selectionType;\n      }\n\n      return this;\n    },\n    panningEnabled: function panningEnabled(bool) {\n      if (bool !== undefined) {\n        this._private.panningEnabled = bool ? true : false;\n      } else {\n        return this._private.panningEnabled;\n      }\n\n      return this; // chaining\n    },\n    userPanningEnabled: function userPanningEnabled(bool) {\n      if (bool !== undefined) {\n        this._private.userPanningEnabled = bool ? true : false;\n      } else {\n        return this._private.userPanningEnabled;\n      }\n\n      return this; // chaining\n    },\n    zoomingEnabled: function zoomingEnabled(bool) {\n      if (bool !== undefined) {\n        this._private.zoomingEnabled = bool ? true : false;\n      } else {\n        return this._private.zoomingEnabled;\n      }\n\n      return this; // chaining\n    },\n    userZoomingEnabled: function userZoomingEnabled(bool) {\n      if (bool !== undefined) {\n        this._private.userZoomingEnabled = bool ? true : false;\n      } else {\n        return this._private.userZoomingEnabled;\n      }\n\n      return this; // chaining\n    },\n    boxSelectionEnabled: function boxSelectionEnabled(bool) {\n      if (bool !== undefined) {\n        this._private.boxSelectionEnabled = bool ? true : false;\n      } else {\n        return this._private.boxSelectionEnabled;\n      }\n\n      return this; // chaining\n    },\n    pan: function pan() {\n      var args = arguments;\n      var pan = this._private.pan;\n      var dim, val, dims, x, y;\n\n      switch (args.length) {\n        case 0:\n          // .pan()\n          return pan;\n\n        case 1:\n          if (string(args[0])) {\n            // .pan('x')\n            dim = args[0];\n            return pan[dim];\n          } else if (plainObject(args[0])) {\n            // .pan({ x: 0, y: 100 })\n            if (!this._private.panningEnabled) {\n              return this;\n            }\n\n            dims = args[0];\n            x = dims.x;\n            y = dims.y;\n\n            if (number$1(x)) {\n              pan.x = x;\n            }\n\n            if (number$1(y)) {\n              pan.y = y;\n            }\n\n            this.emit('pan viewport');\n          }\n\n          break;\n\n        case 2:\n          // .pan('x', 100)\n          if (!this._private.panningEnabled) {\n            return this;\n          }\n\n          dim = args[0];\n          val = args[1];\n\n          if ((dim === 'x' || dim === 'y') && number$1(val)) {\n            pan[dim] = val;\n          }\n\n          this.emit('pan viewport');\n          break;\n        // invalid\n      }\n\n      this.notify('viewport');\n      return this; // chaining\n    },\n    panBy: function panBy(arg0, arg1) {\n      var args = arguments;\n      var pan = this._private.pan;\n      var dim, val, dims, x, y;\n\n      if (!this._private.panningEnabled) {\n        return this;\n      }\n\n      switch (args.length) {\n        case 1:\n          if (plainObject(arg0)) {\n            // .panBy({ x: 0, y: 100 })\n            dims = args[0];\n            x = dims.x;\n            y = dims.y;\n\n            if (number$1(x)) {\n              pan.x += x;\n            }\n\n            if (number$1(y)) {\n              pan.y += y;\n            }\n\n            this.emit('pan viewport');\n          }\n\n          break;\n\n        case 2:\n          // .panBy('x', 100)\n          dim = arg0;\n          val = arg1;\n\n          if ((dim === 'x' || dim === 'y') && number$1(val)) {\n            pan[dim] += val;\n          }\n\n          this.emit('pan viewport');\n          break;\n        // invalid\n      }\n\n      this.notify('viewport');\n      return this; // chaining\n    },\n    fit: function fit(elements, padding) {\n      var viewportState = this.getFitViewport(elements, padding);\n\n      if (viewportState) {\n        var _p = this._private;\n        _p.zoom = viewportState.zoom;\n        _p.pan = viewportState.pan;\n        this.emit('pan zoom viewport');\n        this.notify('viewport');\n      }\n\n      return this; // chaining\n    },\n    getFitViewport: function getFitViewport(elements, padding) {\n      if (number$1(elements) && padding === undefined) {\n        // elements is optional\n        padding = elements;\n        elements = undefined;\n      }\n\n      if (!this._private.panningEnabled || !this._private.zoomingEnabled) {\n        return;\n      }\n\n      var bb;\n\n      if (string(elements)) {\n        var sel = elements;\n        elements = this.$(sel);\n      } else if (boundingBox(elements)) {\n        // assume bb\n        var bbe = elements;\n        bb = {\n          x1: bbe.x1,\n          y1: bbe.y1,\n          x2: bbe.x2,\n          y2: bbe.y2\n        };\n        bb.w = bb.x2 - bb.x1;\n        bb.h = bb.y2 - bb.y1;\n      } else if (!elementOrCollection(elements)) {\n        elements = this.mutableElements();\n      }\n\n      if (elementOrCollection(elements) && elements.empty()) {\n        return;\n      } // can't fit to nothing\n\n\n      bb = bb || elements.boundingBox();\n      var w = this.width();\n      var h = this.height();\n      var zoom;\n      padding = number$1(padding) ? padding : 0;\n\n      if (!isNaN(w) && !isNaN(h) && w > 0 && h > 0 && !isNaN(bb.w) && !isNaN(bb.h) && bb.w > 0 && bb.h > 0) {\n        zoom = Math.min((w - 2 * padding) / bb.w, (h - 2 * padding) / bb.h); // crop zoom\n\n        zoom = zoom > this._private.maxZoom ? this._private.maxZoom : zoom;\n        zoom = zoom < this._private.minZoom ? this._private.minZoom : zoom;\n        var pan = {\n          // now pan to middle\n          x: (w - zoom * (bb.x1 + bb.x2)) / 2,\n          y: (h - zoom * (bb.y1 + bb.y2)) / 2\n        };\n        return {\n          zoom: zoom,\n          pan: pan\n        };\n      }\n\n      return;\n    },\n    zoomRange: function zoomRange(min, max) {\n      var _p = this._private;\n\n      if (max == null) {\n        var opts = min;\n        min = opts.min;\n        max = opts.max;\n      }\n\n      if (number$1(min) && number$1(max) && min <= max) {\n        _p.minZoom = min;\n        _p.maxZoom = max;\n      } else if (number$1(min) && max === undefined && min <= _p.maxZoom) {\n        _p.minZoom = min;\n      } else if (number$1(max) && min === undefined && max >= _p.minZoom) {\n        _p.maxZoom = max;\n      }\n\n      return this;\n    },\n    minZoom: function minZoom(zoom) {\n      if (zoom === undefined) {\n        return this._private.minZoom;\n      } else {\n        return this.zoomRange({\n          min: zoom\n        });\n      }\n    },\n    maxZoom: function maxZoom(zoom) {\n      if (zoom === undefined) {\n        return this._private.maxZoom;\n      } else {\n        return this.zoomRange({\n          max: zoom\n        });\n      }\n    },\n    getZoomedViewport: function getZoomedViewport(params) {\n      var _p = this._private;\n      var currentPan = _p.pan;\n      var currentZoom = _p.zoom;\n      var pos; // in rendered px\n\n      var zoom;\n      var bail = false;\n\n      if (!_p.zoomingEnabled) {\n        // zooming disabled\n        bail = true;\n      }\n\n      if (number$1(params)) {\n        // then set the zoom\n        zoom = params;\n      } else if (plainObject(params)) {\n        // then zoom about a point\n        zoom = params.level;\n\n        if (params.position != null) {\n          pos = modelToRenderedPosition(params.position, currentZoom, currentPan);\n        } else if (params.renderedPosition != null) {\n          pos = params.renderedPosition;\n        }\n\n        if (pos != null && !_p.panningEnabled) {\n          // panning disabled\n          bail = true;\n        }\n      } // crop zoom\n\n\n      zoom = zoom > _p.maxZoom ? _p.maxZoom : zoom;\n      zoom = zoom < _p.minZoom ? _p.minZoom : zoom; // can't zoom with invalid params\n\n      if (bail || !number$1(zoom) || zoom === currentZoom || pos != null && (!number$1(pos.x) || !number$1(pos.y))) {\n        return null;\n      }\n\n      if (pos != null) {\n        // set zoom about position\n        var pan1 = currentPan;\n        var zoom1 = currentZoom;\n        var zoom2 = zoom;\n        var pan2 = {\n          x: -zoom2 / zoom1 * (pos.x - pan1.x) + pos.x,\n          y: -zoom2 / zoom1 * (pos.y - pan1.y) + pos.y\n        };\n        return {\n          zoomed: true,\n          panned: true,\n          zoom: zoom2,\n          pan: pan2\n        };\n      } else {\n        // just set the zoom\n        return {\n          zoomed: true,\n          panned: false,\n          zoom: zoom,\n          pan: currentPan\n        };\n      }\n    },\n    zoom: function zoom(params) {\n      if (params === undefined) {\n        // get\n        return this._private.zoom;\n      } else {\n        // set\n        var vp = this.getZoomedViewport(params);\n        var _p = this._private;\n\n        if (vp == null || !vp.zoomed) {\n          return this;\n        }\n\n        _p.zoom = vp.zoom;\n\n        if (vp.panned) {\n          _p.pan.x = vp.pan.x;\n          _p.pan.y = vp.pan.y;\n        }\n\n        this.emit('zoom' + (vp.panned ? ' pan' : '') + ' viewport');\n        this.notify('viewport');\n        return this; // chaining\n      }\n    },\n    viewport: function viewport(opts) {\n      var _p = this._private;\n      var zoomDefd = true;\n      var panDefd = true;\n      var events = []; // to trigger\n\n      var zoomFailed = false;\n      var panFailed = false;\n\n      if (!opts) {\n        return this;\n      }\n\n      if (!number$1(opts.zoom)) {\n        zoomDefd = false;\n      }\n\n      if (!plainObject(opts.pan)) {\n        panDefd = false;\n      }\n\n      if (!zoomDefd && !panDefd) {\n        return this;\n      }\n\n      if (zoomDefd) {\n        var z = opts.zoom;\n\n        if (z < _p.minZoom || z > _p.maxZoom || !_p.zoomingEnabled) {\n          zoomFailed = true;\n        } else {\n          _p.zoom = z;\n          events.push('zoom');\n        }\n      }\n\n      if (panDefd && (!zoomFailed || !opts.cancelOnFailedZoom) && _p.panningEnabled) {\n        var p = opts.pan;\n\n        if (number$1(p.x)) {\n          _p.pan.x = p.x;\n          panFailed = false;\n        }\n\n        if (number$1(p.y)) {\n          _p.pan.y = p.y;\n          panFailed = false;\n        }\n\n        if (!panFailed) {\n          events.push('pan');\n        }\n      }\n\n      if (events.length > 0) {\n        events.push('viewport');\n        this.emit(events.join(' '));\n        this.notify('viewport');\n      }\n\n      return this; // chaining\n    },\n    center: function center(elements) {\n      var pan = this.getCenterPan(elements);\n\n      if (pan) {\n        this._private.pan = pan;\n        this.emit('pan viewport');\n        this.notify('viewport');\n      }\n\n      return this; // chaining\n    },\n    getCenterPan: function getCenterPan(elements, zoom) {\n      if (!this._private.panningEnabled) {\n        return;\n      }\n\n      if (string(elements)) {\n        var selector = elements;\n        elements = this.mutableElements().filter(selector);\n      } else if (!elementOrCollection(elements)) {\n        elements = this.mutableElements();\n      }\n\n      if (elements.length === 0) {\n        return;\n      } // can't centre pan to nothing\n\n\n      var bb = elements.boundingBox();\n      var w = this.width();\n      var h = this.height();\n      zoom = zoom === undefined ? this._private.zoom : zoom;\n      var pan = {\n        // middle\n        x: (w - zoom * (bb.x1 + bb.x2)) / 2,\n        y: (h - zoom * (bb.y1 + bb.y2)) / 2\n      };\n      return pan;\n    },\n    reset: function reset() {\n      if (!this._private.panningEnabled || !this._private.zoomingEnabled) {\n        return this;\n      }\n\n      this.viewport({\n        pan: {\n          x: 0,\n          y: 0\n        },\n        zoom: 1\n      });\n      return this; // chaining\n    },\n    invalidateSize: function invalidateSize() {\n      this._private.sizeCache = null;\n    },\n    size: function size() {\n      var _p = this._private;\n      var container = _p.container;\n      return _p.sizeCache = _p.sizeCache || (container ? function () {\n        var style = window$1.getComputedStyle(container);\n\n        var val = function val(name) {\n          return parseFloat(style.getPropertyValue(name));\n        };\n\n        return {\n          width: container.clientWidth - val('padding-left') - val('padding-right'),\n          height: container.clientHeight - val('padding-top') - val('padding-bottom')\n        };\n      }() : {\n        // fallback if no container (not 0 b/c can be used for dividing etc)\n        width: 1,\n        height: 1\n      });\n    },\n    width: function width() {\n      return this.size().width;\n    },\n    height: function height() {\n      return this.size().height;\n    },\n    extent: function extent() {\n      var pan = this._private.pan;\n      var zoom = this._private.zoom;\n      var rb = this.renderedExtent();\n      var b = {\n        x1: (rb.x1 - pan.x) / zoom,\n        x2: (rb.x2 - pan.x) / zoom,\n        y1: (rb.y1 - pan.y) / zoom,\n        y2: (rb.y2 - pan.y) / zoom\n      };\n      b.w = b.x2 - b.x1;\n      b.h = b.y2 - b.y1;\n      return b;\n    },\n    renderedExtent: function renderedExtent() {\n      var width = this.width();\n      var height = this.height();\n      return {\n        x1: 0,\n        y1: 0,\n        x2: width,\n        y2: height,\n        w: width,\n        h: height\n      };\n    },\n    multiClickDebounceTime: function multiClickDebounceTime(_int) {\n      if (_int) this._private.multiClickDebounceTime = _int;else return this._private.multiClickDebounceTime;\n      return this; // chaining\n    }\n  }; // aliases\n\n  corefn$1.centre = corefn$1.center; // backwards compatibility\n\n  corefn$1.autolockNodes = corefn$1.autolock;\n  corefn$1.autoungrabifyNodes = corefn$1.autoungrabify;\n\n  var fn = {\n    data: define.data({\n      field: 'data',\n      bindingEvent: 'data',\n      allowBinding: true,\n      allowSetting: true,\n      settingEvent: 'data',\n      settingTriggersEvent: true,\n      triggerFnName: 'trigger',\n      allowGetting: true,\n      updateStyle: true\n    }),\n    removeData: define.removeData({\n      field: 'data',\n      event: 'data',\n      triggerFnName: 'trigger',\n      triggerEvent: true,\n      updateStyle: true\n    }),\n    scratch: define.data({\n      field: 'scratch',\n      bindingEvent: 'scratch',\n      allowBinding: true,\n      allowSetting: true,\n      settingEvent: 'scratch',\n      settingTriggersEvent: true,\n      triggerFnName: 'trigger',\n      allowGetting: true,\n      updateStyle: true\n    }),\n    removeScratch: define.removeData({\n      field: 'scratch',\n      event: 'scratch',\n      triggerFnName: 'trigger',\n      triggerEvent: true,\n      updateStyle: true\n    })\n  }; // aliases\n\n  fn.attr = fn.data;\n  fn.removeAttr = fn.removeData;\n\n  var Core = function Core(opts) {\n    var cy = this;\n    opts = extend({}, opts);\n    var container = opts.container; // allow for passing a wrapped jquery object\n    // e.g. cytoscape({ container: $('#cy') })\n\n    if (container && !htmlElement(container) && htmlElement(container[0])) {\n      container = container[0];\n    }\n\n    var reg = container ? container._cyreg : null; // e.g. already registered some info (e.g. readies) via jquery\n\n    reg = reg || {};\n\n    if (reg && reg.cy) {\n      reg.cy.destroy();\n      reg = {}; // old instance => replace reg completely\n    }\n\n    var readies = reg.readies = reg.readies || [];\n\n    if (container) {\n      container._cyreg = reg;\n    } // make sure container assoc'd reg points to this cy\n\n\n    reg.cy = cy;\n    var head = window$1 !== undefined && container !== undefined && !opts.headless;\n    var options = opts;\n    options.layout = extend({\n      name: head ? 'grid' : 'null'\n    }, options.layout);\n    options.renderer = extend({\n      name: head ? 'canvas' : 'null'\n    }, options.renderer);\n\n    var defVal = function defVal(def, val, altVal) {\n      if (val !== undefined) {\n        return val;\n      } else if (altVal !== undefined) {\n        return altVal;\n      } else {\n        return def;\n      }\n    };\n\n    var _p = this._private = {\n      container: container,\n      // html dom ele container\n      ready: false,\n      // whether ready has been triggered\n      options: options,\n      // cached options\n      elements: new Collection(this),\n      // elements in the graph\n      listeners: [],\n      // list of listeners\n      aniEles: new Collection(this),\n      // elements being animated\n      data: options.data || {},\n      // data for the core\n      scratch: {},\n      // scratch object for core\n      layout: null,\n      renderer: null,\n      destroyed: false,\n      // whether destroy was called\n      notificationsEnabled: true,\n      // whether notifications are sent to the renderer\n      minZoom: 1e-50,\n      maxZoom: 1e50,\n      zoomingEnabled: defVal(true, options.zoomingEnabled),\n      userZoomingEnabled: defVal(true, options.userZoomingEnabled),\n      panningEnabled: defVal(true, options.panningEnabled),\n      userPanningEnabled: defVal(true, options.userPanningEnabled),\n      boxSelectionEnabled: defVal(true, options.boxSelectionEnabled),\n      autolock: defVal(false, options.autolock, options.autolockNodes),\n      autoungrabify: defVal(false, options.autoungrabify, options.autoungrabifyNodes),\n      autounselectify: defVal(false, options.autounselectify),\n      styleEnabled: options.styleEnabled === undefined ? head : options.styleEnabled,\n      zoom: number$1(options.zoom) ? options.zoom : 1,\n      pan: {\n        x: plainObject(options.pan) && number$1(options.pan.x) ? options.pan.x : 0,\n        y: plainObject(options.pan) && number$1(options.pan.y) ? options.pan.y : 0\n      },\n      animation: {\n        // object for currently-running animations\n        current: [],\n        queue: []\n      },\n      hasCompoundNodes: false,\n      multiClickDebounceTime: defVal(250, options.multiClickDebounceTime)\n    };\n\n    this.createEmitter(); // set selection type\n\n    this.selectionType(options.selectionType); // init zoom bounds\n\n    this.zoomRange({\n      min: options.minZoom,\n      max: options.maxZoom\n    });\n\n    var loadExtData = function loadExtData(extData, next) {\n      var anyIsPromise = extData.some(promise);\n\n      if (anyIsPromise) {\n        return Promise$1.all(extData).then(next); // load all data asynchronously, then exec rest of init\n      } else {\n        next(extData); // exec synchronously for convenience\n      }\n    }; // start with the default stylesheet so we have something before loading an external stylesheet\n\n\n    if (_p.styleEnabled) {\n      cy.setStyle([]);\n    } // create the renderer\n\n\n    var rendererOptions = extend({}, options, options.renderer); // allow rendering hints in top level options\n\n    cy.initRenderer(rendererOptions);\n\n    var setElesAndLayout = function setElesAndLayout(elements, onload, ondone) {\n      cy.notifications(false); // remove old elements\n\n      var oldEles = cy.mutableElements();\n\n      if (oldEles.length > 0) {\n        oldEles.remove();\n      }\n\n      if (elements != null) {\n        if (plainObject(elements) || array(elements)) {\n          cy.add(elements);\n        }\n      }\n\n      cy.one('layoutready', function (e) {\n        cy.notifications(true);\n        cy.emit(e); // we missed this event by turning notifications off, so pass it on\n\n        cy.one('load', onload);\n        cy.emitAndNotify('load');\n      }).one('layoutstop', function () {\n        cy.one('done', ondone);\n        cy.emit('done');\n      });\n      var layoutOpts = extend({}, cy._private.options.layout);\n      layoutOpts.eles = cy.elements();\n      cy.layout(layoutOpts).run();\n    };\n\n    loadExtData([options.style, options.elements], function (thens) {\n      var initStyle = thens[0];\n      var initEles = thens[1]; // init style\n\n      if (_p.styleEnabled) {\n        cy.style().append(initStyle);\n      } // initial load\n\n\n      setElesAndLayout(initEles, function () {\n        // onready\n        cy.startAnimationLoop();\n        _p.ready = true; // if a ready callback is specified as an option, the bind it\n\n        if (fn$6(options.ready)) {\n          cy.on('ready', options.ready);\n        } // bind all the ready handlers registered before creating this instance\n\n\n        for (var i = 0; i < readies.length; i++) {\n          var fn = readies[i];\n          cy.on('ready', fn);\n        }\n\n        if (reg) {\n          reg.readies = [];\n        } // clear b/c we've bound them all and don't want to keep it around in case a new core uses the same div etc\n\n\n        cy.emit('ready');\n      }, options.done);\n    });\n  };\n\n  var corefn = Core.prototype; // short alias\n\n  extend(corefn, {\n    instanceString: function instanceString() {\n      return 'core';\n    },\n    isReady: function isReady() {\n      return this._private.ready;\n    },\n    destroyed: function destroyed() {\n      return this._private.destroyed;\n    },\n    ready: function ready(fn) {\n      if (this.isReady()) {\n        this.emitter().emit('ready', [], fn); // just calls fn as though triggered via ready event\n      } else {\n        this.on('ready', fn);\n      }\n\n      return this;\n    },\n    destroy: function destroy() {\n      var cy = this;\n      if (cy.destroyed()) return;\n      cy.stopAnimationLoop();\n      cy.destroyRenderer();\n      this.emit('destroy');\n      cy._private.destroyed = true;\n      return cy;\n    },\n    hasElementWithId: function hasElementWithId(id) {\n      return this._private.elements.hasElementWithId(id);\n    },\n    getElementById: function getElementById(id) {\n      return this._private.elements.getElementById(id);\n    },\n    hasCompoundNodes: function hasCompoundNodes() {\n      return this._private.hasCompoundNodes;\n    },\n    headless: function headless() {\n      return this._private.renderer.isHeadless();\n    },\n    styleEnabled: function styleEnabled() {\n      return this._private.styleEnabled;\n    },\n    addToPool: function addToPool(eles) {\n      this._private.elements.merge(eles);\n\n      return this; // chaining\n    },\n    removeFromPool: function removeFromPool(eles) {\n      this._private.elements.unmerge(eles);\n\n      return this;\n    },\n    container: function container() {\n      return this._private.container || null;\n    },\n    mount: function mount(container) {\n      if (container == null) {\n        return;\n      }\n\n      var cy = this;\n      var _p = cy._private;\n      var options = _p.options;\n\n      if (!htmlElement(container) && htmlElement(container[0])) {\n        container = container[0];\n      }\n\n      cy.stopAnimationLoop();\n      cy.destroyRenderer();\n      _p.container = container;\n      _p.styleEnabled = true;\n      cy.invalidateSize();\n      cy.initRenderer(extend({}, options, options.renderer, {\n        // allow custom renderer name to be re-used, otherwise use canvas\n        name: options.renderer.name === 'null' ? 'canvas' : options.renderer.name\n      }));\n      cy.startAnimationLoop();\n      cy.style(options.style);\n      cy.emit('mount');\n      return cy;\n    },\n    unmount: function unmount() {\n      var cy = this;\n      cy.stopAnimationLoop();\n      cy.destroyRenderer();\n      cy.initRenderer({\n        name: 'null'\n      });\n      cy.emit('unmount');\n      return cy;\n    },\n    options: function options() {\n      return copy(this._private.options);\n    },\n    json: function json(obj) {\n      var cy = this;\n      var _p = cy._private;\n      var eles = cy.mutableElements();\n\n      var getFreshRef = function getFreshRef(ele) {\n        return cy.getElementById(ele.id());\n      };\n\n      if (plainObject(obj)) {\n        // set\n        cy.startBatch();\n\n        if (obj.elements) {\n          var idInJson = {};\n\n          var updateEles = function updateEles(jsons, gr) {\n            var toAdd = [];\n            var toMod = [];\n\n            for (var i = 0; i < jsons.length; i++) {\n              var json = jsons[i];\n\n              if (!json.data.id) {\n                warn('cy.json() cannot handle elements without an ID attribute');\n                continue;\n              }\n\n              var id = '' + json.data.id; // id must be string\n\n              var ele = cy.getElementById(id);\n              idInJson[id] = true;\n\n              if (ele.length !== 0) {\n                // existing element should be updated\n                toMod.push({\n                  ele: ele,\n                  json: json\n                });\n              } else {\n                // otherwise should be added\n                if (gr) {\n                  json.group = gr;\n                  toAdd.push(json);\n                } else {\n                  toAdd.push(json);\n                }\n              }\n            }\n\n            cy.add(toAdd);\n\n            for (var _i = 0; _i < toMod.length; _i++) {\n              var _toMod$_i = toMod[_i],\n                  _ele = _toMod$_i.ele,\n                  _json = _toMod$_i.json;\n\n              _ele.json(_json);\n            }\n          };\n\n          if (array(obj.elements)) {\n            // elements: []\n            updateEles(obj.elements);\n          } else {\n            // elements: { nodes: [], edges: [] }\n            var grs = ['nodes', 'edges'];\n\n            for (var i = 0; i < grs.length; i++) {\n              var gr = grs[i];\n              var elements = obj.elements[gr];\n\n              if (array(elements)) {\n                updateEles(elements, gr);\n              }\n            }\n          }\n\n          var parentsToRemove = cy.collection();\n          eles.filter(function (ele) {\n            return !idInJson[ele.id()];\n          }).forEach(function (ele) {\n            if (ele.isParent()) {\n              parentsToRemove.merge(ele);\n            } else {\n              ele.remove();\n            }\n          }); // so that children are not removed w/parent\n\n          parentsToRemove.forEach(function (ele) {\n            return ele.children().move({\n              parent: null\n            });\n          }); // intermediate parents may be moved by prior line, so make sure we remove by fresh refs\n\n          parentsToRemove.forEach(function (ele) {\n            return getFreshRef(ele).remove();\n          });\n        }\n\n        if (obj.style) {\n          cy.style(obj.style);\n        }\n\n        if (obj.zoom != null && obj.zoom !== _p.zoom) {\n          cy.zoom(obj.zoom);\n        }\n\n        if (obj.pan) {\n          if (obj.pan.x !== _p.pan.x || obj.pan.y !== _p.pan.y) {\n            cy.pan(obj.pan);\n          }\n        }\n\n        if (obj.data) {\n          cy.data(obj.data);\n        }\n\n        var fields = ['minZoom', 'maxZoom', 'zoomingEnabled', 'userZoomingEnabled', 'panningEnabled', 'userPanningEnabled', 'boxSelectionEnabled', 'autolock', 'autoungrabify', 'autounselectify', 'multiClickDebounceTime'];\n\n        for (var _i2 = 0; _i2 < fields.length; _i2++) {\n          var f = fields[_i2];\n\n          if (obj[f] != null) {\n            cy[f](obj[f]);\n          }\n        }\n\n        cy.endBatch();\n        return this; // chaining\n      } else {\n        // get\n        var flat = !!obj;\n        var json = {};\n\n        if (flat) {\n          json.elements = this.elements().map(function (ele) {\n            return ele.json();\n          });\n        } else {\n          json.elements = {};\n          eles.forEach(function (ele) {\n            var group = ele.group();\n\n            if (!json.elements[group]) {\n              json.elements[group] = [];\n            }\n\n            json.elements[group].push(ele.json());\n          });\n        }\n\n        if (this._private.styleEnabled) {\n          json.style = cy.style().json();\n        }\n\n        json.data = copy(cy.data());\n        var options = _p.options;\n        json.zoomingEnabled = _p.zoomingEnabled;\n        json.userZoomingEnabled = _p.userZoomingEnabled;\n        json.zoom = _p.zoom;\n        json.minZoom = _p.minZoom;\n        json.maxZoom = _p.maxZoom;\n        json.panningEnabled = _p.panningEnabled;\n        json.userPanningEnabled = _p.userPanningEnabled;\n        json.pan = copy(_p.pan);\n        json.boxSelectionEnabled = _p.boxSelectionEnabled;\n        json.renderer = copy(options.renderer);\n        json.hideEdgesOnViewport = options.hideEdgesOnViewport;\n        json.textureOnViewport = options.textureOnViewport;\n        json.wheelSensitivity = options.wheelSensitivity;\n        json.motionBlur = options.motionBlur;\n        json.multiClickDebounceTime = options.multiClickDebounceTime;\n        return json;\n      }\n    }\n  });\n  corefn.$id = corefn.getElementById;\n  [corefn$9, corefn$8, elesfn, corefn$7, corefn$6, corefn$5, corefn$4, corefn$3, corefn$2, corefn$1, fn].forEach(function (props) {\n    extend(corefn, props);\n  });\n\n  /* eslint-disable no-unused-vars */\n\n  var defaults$7 = {\n    fit: true,\n    // whether to fit the viewport to the graph\n    directed: false,\n    // whether the tree is directed downwards (or edges can point in any direction if false)\n    padding: 30,\n    // padding on fit\n    circle: false,\n    // put depths in concentric circles if true, put depths top down if false\n    grid: false,\n    // whether to create an even grid into which the DAG is placed (circle:false only)\n    spacingFactor: 1.75,\n    // positive spacing factor, larger => more space between nodes (N.B. n/a if causes overlap)\n    boundingBox: undefined,\n    // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n    avoidOverlap: true,\n    // prevents node overlap, may overflow boundingBox if not enough space\n    nodeDimensionsIncludeLabels: false,\n    // Excludes the label when calculating node bounding boxes for the layout algorithm\n    roots: undefined,\n    // the roots of the trees\n    depthSort: undefined,\n    // a sorting function to order nodes at equal depth. e.g. function(a, b){ return a.data('weight') - b.data('weight') }\n    animate: false,\n    // whether to transition the node positions\n    animationDuration: 500,\n    // duration of animation in ms if enabled\n    animationEasing: undefined,\n    // easing of animation if enabled,\n    animateFilter: function animateFilter(node, i) {\n      return true;\n    },\n    // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts\n    ready: undefined,\n    // callback on layoutready\n    stop: undefined,\n    // callback on layoutstop\n    transform: function transform(node, position) {\n      return position;\n    } // transform a given node position. Useful for changing flow direction in discrete layouts\n\n  };\n  var deprecatedOptionDefaults = {\n    maximal: false,\n    // whether to shift nodes down their natural BFS depths in order to avoid upwards edges (DAGS only); setting acyclic to true sets maximal to true also\n    acyclic: false // whether the tree is acyclic and thus a node could be shifted (due to the maximal option) multiple times without causing an infinite loop; setting to true sets maximal to true also; if you are uncertain whether a tree is acyclic, set to false to avoid potential infinite loops\n\n  };\n  /* eslint-enable */\n\n  var getInfo = function getInfo(ele) {\n    return ele.scratch('breadthfirst');\n  };\n\n  var setInfo = function setInfo(ele, obj) {\n    return ele.scratch('breadthfirst', obj);\n  };\n\n  function BreadthFirstLayout(options) {\n    this.options = extend({}, defaults$7, deprecatedOptionDefaults, options);\n  }\n\n  BreadthFirstLayout.prototype.run = function () {\n    var params = this.options;\n    var options = params;\n    var cy = params.cy;\n    var eles = options.eles;\n    var nodes = eles.nodes().filter(function (n) {\n      return !n.isParent();\n    });\n    var graph = eles;\n    var directed = options.directed;\n    var maximal = options.acyclic || options.maximal || options.maximalAdjustments > 0; // maximalAdjustments for compat. w/ old code; also, setting acyclic to true sets maximal to true\n\n    var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {\n      x1: 0,\n      y1: 0,\n      w: cy.width(),\n      h: cy.height()\n    });\n    var roots;\n\n    if (elementOrCollection(options.roots)) {\n      roots = options.roots;\n    } else if (array(options.roots)) {\n      var rootsArray = [];\n\n      for (var i = 0; i < options.roots.length; i++) {\n        var id = options.roots[i];\n        var ele = cy.getElementById(id);\n        rootsArray.push(ele);\n      }\n\n      roots = cy.collection(rootsArray);\n    } else if (string(options.roots)) {\n      roots = cy.$(options.roots);\n    } else {\n      if (directed) {\n        roots = nodes.roots();\n      } else {\n        var components = eles.components();\n        roots = cy.collection();\n\n        var _loop = function _loop(_i) {\n          var comp = components[_i];\n          var maxDegree = comp.maxDegree(false);\n          var compRoots = comp.filter(function (ele) {\n            return ele.degree(false) === maxDegree;\n          });\n          roots = roots.add(compRoots);\n        };\n\n        for (var _i = 0; _i < components.length; _i++) {\n          _loop(_i);\n        }\n      }\n    }\n\n    var depths = [];\n    var foundByBfs = {};\n\n    var addToDepth = function addToDepth(ele, d) {\n      if (depths[d] == null) {\n        depths[d] = [];\n      }\n\n      var i = depths[d].length;\n      depths[d].push(ele);\n      setInfo(ele, {\n        index: i,\n        depth: d\n      });\n    };\n\n    var changeDepth = function changeDepth(ele, newDepth) {\n      var _getInfo = getInfo(ele),\n          depth = _getInfo.depth,\n          index = _getInfo.index;\n\n      depths[depth][index] = null;\n      addToDepth(ele, newDepth);\n    }; // find the depths of the nodes\n\n\n    graph.bfs({\n      roots: roots,\n      directed: options.directed,\n      visit: function visit(node, edge, pNode, i, depth) {\n        var ele = node[0];\n        var id = ele.id();\n        addToDepth(ele, depth);\n        foundByBfs[id] = true;\n      }\n    }); // check for nodes not found by bfs\n\n    var orphanNodes = [];\n\n    for (var _i2 = 0; _i2 < nodes.length; _i2++) {\n      var _ele = nodes[_i2];\n\n      if (foundByBfs[_ele.id()]) {\n        continue;\n      } else {\n        orphanNodes.push(_ele);\n      }\n    } // assign the nodes a depth and index\n\n\n    var assignDepthsAt = function assignDepthsAt(i) {\n      var eles = depths[i];\n\n      for (var j = 0; j < eles.length; j++) {\n        var _ele2 = eles[j];\n\n        if (_ele2 == null) {\n          eles.splice(j, 1);\n          j--;\n          continue;\n        }\n\n        setInfo(_ele2, {\n          depth: i,\n          index: j\n        });\n      }\n    };\n\n    var assignDepths = function assignDepths() {\n      for (var _i3 = 0; _i3 < depths.length; _i3++) {\n        assignDepthsAt(_i3);\n      }\n    };\n\n    var adjustMaximally = function adjustMaximally(ele, shifted) {\n      var eInfo = getInfo(ele);\n      var incomers = ele.incomers().filter(function (el) {\n        return el.isNode() && eles.has(el);\n      });\n      var maxDepth = -1;\n      var id = ele.id();\n\n      for (var k = 0; k < incomers.length; k++) {\n        var incmr = incomers[k];\n        var iInfo = getInfo(incmr);\n        maxDepth = Math.max(maxDepth, iInfo.depth);\n      }\n\n      if (eInfo.depth <= maxDepth) {\n        if (!options.acyclic && shifted[id]) {\n          return null;\n        }\n\n        var newDepth = maxDepth + 1;\n        changeDepth(ele, newDepth);\n        shifted[id] = newDepth;\n        return true;\n      }\n\n      return false;\n    }; // for the directed case, try to make the edges all go down (i.e. depth i => depth i + 1)\n\n\n    if (directed && maximal) {\n      var Q = [];\n      var shifted = {};\n\n      var enqueue = function enqueue(n) {\n        return Q.push(n);\n      };\n\n      var dequeue = function dequeue() {\n        return Q.shift();\n      };\n\n      nodes.forEach(function (n) {\n        return Q.push(n);\n      });\n\n      while (Q.length > 0) {\n        var _ele3 = dequeue();\n\n        var didShift = adjustMaximally(_ele3, shifted);\n\n        if (didShift) {\n          _ele3.outgoers().filter(function (el) {\n            return el.isNode() && eles.has(el);\n          }).forEach(enqueue);\n        } else if (didShift === null) {\n          warn('Detected double maximal shift for node `' + _ele3.id() + '`.  Bailing maximal adjustment due to cycle.  Use `options.maximal: true` only on DAGs.');\n          break; // exit on failure\n        }\n      }\n    }\n\n    assignDepths(); // clear holes\n    // find min distance we need to leave between nodes\n\n    var minDistance = 0;\n\n    if (options.avoidOverlap) {\n      for (var _i4 = 0; _i4 < nodes.length; _i4++) {\n        var n = nodes[_i4];\n        var nbb = n.layoutDimensions(options);\n        var w = nbb.w;\n        var h = nbb.h;\n        minDistance = Math.max(minDistance, w, h);\n      }\n    } // get the weighted percent for an element based on its connectivity to other levels\n\n\n    var cachedWeightedPercent = {};\n\n    var getWeightedPercent = function getWeightedPercent(ele) {\n      if (cachedWeightedPercent[ele.id()]) {\n        return cachedWeightedPercent[ele.id()];\n      }\n\n      var eleDepth = getInfo(ele).depth;\n      var neighbors = ele.neighborhood();\n      var percent = 0;\n      var samples = 0;\n\n      for (var _i5 = 0; _i5 < neighbors.length; _i5++) {\n        var neighbor = neighbors[_i5];\n\n        if (neighbor.isEdge() || neighbor.isParent() || !nodes.has(neighbor)) {\n          continue;\n        }\n\n        var bf = getInfo(neighbor);\n\n        if (bf == null) {\n          continue;\n        }\n\n        var index = bf.index;\n        var depth = bf.depth; // unassigned neighbours shouldn't affect the ordering\n\n        if (index == null || depth == null) {\n          continue;\n        }\n\n        var nDepth = depths[depth].length;\n\n        if (depth < eleDepth) {\n          // only get influenced by elements above\n          percent += index / nDepth;\n          samples++;\n        }\n      }\n\n      samples = Math.max(1, samples);\n      percent = percent / samples;\n\n      if (samples === 0) {\n        // put lone nodes at the start\n        percent = 0;\n      }\n\n      cachedWeightedPercent[ele.id()] = percent;\n      return percent;\n    }; // rearrange the indices in each depth level based on connectivity\n\n\n    var sortFn = function sortFn(a, b) {\n      var apct = getWeightedPercent(a);\n      var bpct = getWeightedPercent(b);\n      var diff = apct - bpct;\n\n      if (diff === 0) {\n        return ascending(a.id(), b.id()); // make sure sort doesn't have don't-care comparisons\n      } else {\n        return diff;\n      }\n    };\n\n    if (options.depthSort !== undefined) {\n      sortFn = options.depthSort;\n    } // sort each level to make connected nodes closer\n\n\n    for (var _i6 = 0; _i6 < depths.length; _i6++) {\n      depths[_i6].sort(sortFn);\n\n      assignDepthsAt(_i6);\n    } // assign orphan nodes to a new top-level depth\n\n\n    var orphanDepth = [];\n\n    for (var _i7 = 0; _i7 < orphanNodes.length; _i7++) {\n      orphanDepth.push(orphanNodes[_i7]);\n    }\n\n    depths.unshift(orphanDepth);\n    assignDepths();\n    var biggestDepthSize = 0;\n\n    for (var _i8 = 0; _i8 < depths.length; _i8++) {\n      biggestDepthSize = Math.max(depths[_i8].length, biggestDepthSize);\n    }\n\n    var center = {\n      x: bb.x1 + bb.w / 2,\n      y: bb.x1 + bb.h / 2\n    };\n    var maxDepthSize = depths.reduce(function (max, eles) {\n      return Math.max(max, eles.length);\n    }, 0);\n\n    var getPosition = function getPosition(ele) {\n      var _getInfo2 = getInfo(ele),\n          depth = _getInfo2.depth,\n          index = _getInfo2.index;\n\n      var depthSize = depths[depth].length;\n      var distanceX = Math.max(bb.w / ((options.grid ? maxDepthSize : depthSize) + 1), minDistance);\n      var distanceY = Math.max(bb.h / (depths.length + 1), minDistance);\n      var radiusStepSize = Math.min(bb.w / 2 / depths.length, bb.h / 2 / depths.length);\n      radiusStepSize = Math.max(radiusStepSize, minDistance);\n\n      if (!options.circle) {\n        var epos = {\n          x: center.x + (index + 1 - (depthSize + 1) / 2) * distanceX,\n          y: (depth + 1) * distanceY\n        };\n        return epos;\n      } else {\n        var radius = radiusStepSize * depth + radiusStepSize - (depths.length > 0 && depths[0].length <= 3 ? radiusStepSize / 2 : 0);\n        var theta = 2 * Math.PI / depths[depth].length * index;\n\n        if (depth === 0 && depths[0].length === 1) {\n          radius = 1;\n        }\n\n        return {\n          x: center.x + radius * Math.cos(theta),\n          y: center.y + radius * Math.sin(theta)\n        };\n      }\n    };\n\n    eles.nodes().layoutPositions(this, options, getPosition);\n    return this; // chaining\n  };\n\n  var defaults$6 = {\n    fit: true,\n    // whether to fit the viewport to the graph\n    padding: 30,\n    // the padding on fit\n    boundingBox: undefined,\n    // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n    avoidOverlap: true,\n    // prevents node overlap, may overflow boundingBox and radius if not enough space\n    nodeDimensionsIncludeLabels: false,\n    // Excludes the label when calculating node bounding boxes for the layout algorithm\n    spacingFactor: undefined,\n    // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up\n    radius: undefined,\n    // the radius of the circle\n    startAngle: 3 / 2 * Math.PI,\n    // where nodes start in radians\n    sweep: undefined,\n    // how many radians should be between the first and last node (defaults to full circle)\n    clockwise: true,\n    // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)\n    sort: undefined,\n    // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }\n    animate: false,\n    // whether to transition the node positions\n    animationDuration: 500,\n    // duration of animation in ms if enabled\n    animationEasing: undefined,\n    // easing of animation if enabled\n    animateFilter: function animateFilter(node, i) {\n      return true;\n    },\n    // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts\n    ready: undefined,\n    // callback on layoutready\n    stop: undefined,\n    // callback on layoutstop\n    transform: function transform(node, position) {\n      return position;\n    } // transform a given node position. Useful for changing flow direction in discrete layouts \n\n  };\n\n  function CircleLayout(options) {\n    this.options = extend({}, defaults$6, options);\n  }\n\n  CircleLayout.prototype.run = function () {\n    var params = this.options;\n    var options = params;\n    var cy = params.cy;\n    var eles = options.eles;\n    var clockwise = options.counterclockwise !== undefined ? !options.counterclockwise : options.clockwise;\n    var nodes = eles.nodes().not(':parent');\n\n    if (options.sort) {\n      nodes = nodes.sort(options.sort);\n    }\n\n    var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {\n      x1: 0,\n      y1: 0,\n      w: cy.width(),\n      h: cy.height()\n    });\n    var center = {\n      x: bb.x1 + bb.w / 2,\n      y: bb.y1 + bb.h / 2\n    };\n    var sweep = options.sweep === undefined ? 2 * Math.PI - 2 * Math.PI / nodes.length : options.sweep;\n    var dTheta = sweep / Math.max(1, nodes.length - 1);\n    var r;\n    var minDistance = 0;\n\n    for (var i = 0; i < nodes.length; i++) {\n      var n = nodes[i];\n      var nbb = n.layoutDimensions(options);\n      var w = nbb.w;\n      var h = nbb.h;\n      minDistance = Math.max(minDistance, w, h);\n    }\n\n    if (number$1(options.radius)) {\n      r = options.radius;\n    } else if (nodes.length <= 1) {\n      r = 0;\n    } else {\n      r = Math.min(bb.h, bb.w) / 2 - minDistance;\n    } // calculate the radius\n\n\n    if (nodes.length > 1 && options.avoidOverlap) {\n      // but only if more than one node (can't overlap)\n      minDistance *= 1.75; // just to have some nice spacing\n\n      var dcos = Math.cos(dTheta) - Math.cos(0);\n      var dsin = Math.sin(dTheta) - Math.sin(0);\n      var rMin = Math.sqrt(minDistance * minDistance / (dcos * dcos + dsin * dsin)); // s.t. no nodes overlapping\n\n      r = Math.max(rMin, r);\n    }\n\n    var getPos = function getPos(ele, i) {\n      var theta = options.startAngle + i * dTheta * (clockwise ? 1 : -1);\n      var rx = r * Math.cos(theta);\n      var ry = r * Math.sin(theta);\n      var pos = {\n        x: center.x + rx,\n        y: center.y + ry\n      };\n      return pos;\n    };\n\n    eles.nodes().layoutPositions(this, options, getPos);\n    return this; // chaining\n  };\n\n  var defaults$5 = {\n    fit: true,\n    // whether to fit the viewport to the graph\n    padding: 30,\n    // the padding on fit\n    startAngle: 3 / 2 * Math.PI,\n    // where nodes start in radians\n    sweep: undefined,\n    // how many radians should be between the first and last node (defaults to full circle)\n    clockwise: true,\n    // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)\n    equidistant: false,\n    // whether levels have an equal radial distance betwen them, may cause bounding box overflow\n    minNodeSpacing: 10,\n    // min spacing between outside of nodes (used for radius adjustment)\n    boundingBox: undefined,\n    // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n    avoidOverlap: true,\n    // prevents node overlap, may overflow boundingBox if not enough space\n    nodeDimensionsIncludeLabels: false,\n    // Excludes the label when calculating node bounding boxes for the layout algorithm\n    height: undefined,\n    // height of layout area (overrides container height)\n    width: undefined,\n    // width of layout area (overrides container width)\n    spacingFactor: undefined,\n    // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up\n    concentric: function concentric(node) {\n      // returns numeric value for each node, placing higher nodes in levels towards the centre\n      return node.degree();\n    },\n    levelWidth: function levelWidth(nodes) {\n      // the variation of concentric values in each level\n      return nodes.maxDegree() / 4;\n    },\n    animate: false,\n    // whether to transition the node positions\n    animationDuration: 500,\n    // duration of animation in ms if enabled\n    animationEasing: undefined,\n    // easing of animation if enabled\n    animateFilter: function animateFilter(node, i) {\n      return true;\n    },\n    // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts\n    ready: undefined,\n    // callback on layoutready\n    stop: undefined,\n    // callback on layoutstop\n    transform: function transform(node, position) {\n      return position;\n    } // transform a given node position. Useful for changing flow direction in discrete layouts\n\n  };\n\n  function ConcentricLayout(options) {\n    this.options = extend({}, defaults$5, options);\n  }\n\n  ConcentricLayout.prototype.run = function () {\n    var params = this.options;\n    var options = params;\n    var clockwise = options.counterclockwise !== undefined ? !options.counterclockwise : options.clockwise;\n    var cy = params.cy;\n    var eles = options.eles;\n    var nodes = eles.nodes().not(':parent');\n    var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {\n      x1: 0,\n      y1: 0,\n      w: cy.width(),\n      h: cy.height()\n    });\n    var center = {\n      x: bb.x1 + bb.w / 2,\n      y: bb.y1 + bb.h / 2\n    };\n    var nodeValues = []; // { node, value }\n\n    var maxNodeSize = 0;\n\n    for (var i = 0; i < nodes.length; i++) {\n      var node = nodes[i];\n      var value = void 0; // calculate the node value\n\n      value = options.concentric(node);\n      nodeValues.push({\n        value: value,\n        node: node\n      }); // for style mapping\n\n      node._private.scratch.concentric = value;\n    } // in case we used the `concentric` in style\n\n\n    nodes.updateStyle(); // calculate max size now based on potentially updated mappers\n\n    for (var _i = 0; _i < nodes.length; _i++) {\n      var _node = nodes[_i];\n\n      var nbb = _node.layoutDimensions(options);\n\n      maxNodeSize = Math.max(maxNodeSize, nbb.w, nbb.h);\n    } // sort node values in descreasing order\n\n\n    nodeValues.sort(function (a, b) {\n      return b.value - a.value;\n    });\n    var levelWidth = options.levelWidth(nodes); // put the values into levels\n\n    var levels = [[]];\n    var currentLevel = levels[0];\n\n    for (var _i2 = 0; _i2 < nodeValues.length; _i2++) {\n      var val = nodeValues[_i2];\n\n      if (currentLevel.length > 0) {\n        var diff = Math.abs(currentLevel[0].value - val.value);\n\n        if (diff >= levelWidth) {\n          currentLevel = [];\n          levels.push(currentLevel);\n        }\n      }\n\n      currentLevel.push(val);\n    } // create positions from levels\n\n\n    var minDist = maxNodeSize + options.minNodeSpacing; // min dist between nodes\n\n    if (!options.avoidOverlap) {\n      // then strictly constrain to bb\n      var firstLvlHasMulti = levels.length > 0 && levels[0].length > 1;\n      var maxR = Math.min(bb.w, bb.h) / 2 - minDist;\n      var rStep = maxR / (levels.length + firstLvlHasMulti ? 1 : 0);\n      minDist = Math.min(minDist, rStep);\n    } // find the metrics for each level\n\n\n    var r = 0;\n\n    for (var _i3 = 0; _i3 < levels.length; _i3++) {\n      var level = levels[_i3];\n      var sweep = options.sweep === undefined ? 2 * Math.PI - 2 * Math.PI / level.length : options.sweep;\n      var dTheta = level.dTheta = sweep / Math.max(1, level.length - 1); // calculate the radius\n\n      if (level.length > 1 && options.avoidOverlap) {\n        // but only if more than one node (can't overlap)\n        var dcos = Math.cos(dTheta) - Math.cos(0);\n        var dsin = Math.sin(dTheta) - Math.sin(0);\n        var rMin = Math.sqrt(minDist * minDist / (dcos * dcos + dsin * dsin)); // s.t. no nodes overlapping\n\n        r = Math.max(rMin, r);\n      }\n\n      level.r = r;\n      r += minDist;\n    }\n\n    if (options.equidistant) {\n      var rDeltaMax = 0;\n      var _r = 0;\n\n      for (var _i4 = 0; _i4 < levels.length; _i4++) {\n        var _level = levels[_i4];\n        var rDelta = _level.r - _r;\n        rDeltaMax = Math.max(rDeltaMax, rDelta);\n      }\n\n      _r = 0;\n\n      for (var _i5 = 0; _i5 < levels.length; _i5++) {\n        var _level2 = levels[_i5];\n\n        if (_i5 === 0) {\n          _r = _level2.r;\n        }\n\n        _level2.r = _r;\n        _r += rDeltaMax;\n      }\n    } // calculate the node positions\n\n\n    var pos = {}; // id => position\n\n    for (var _i6 = 0; _i6 < levels.length; _i6++) {\n      var _level3 = levels[_i6];\n      var _dTheta = _level3.dTheta;\n      var _r2 = _level3.r;\n\n      for (var j = 0; j < _level3.length; j++) {\n        var _val = _level3[j];\n        var theta = options.startAngle + (clockwise ? 1 : -1) * _dTheta * j;\n        var p = {\n          x: center.x + _r2 * Math.cos(theta),\n          y: center.y + _r2 * Math.sin(theta)\n        };\n        pos[_val.node.id()] = p;\n      }\n    } // position the nodes\n\n\n    eles.nodes().layoutPositions(this, options, function (ele) {\n      var id = ele.id();\n      return pos[id];\n    });\n    return this; // chaining\n  };\n\n  /*\n  The CoSE layout was written by Gerardo Huck.\n  https://www.linkedin.com/in/gerardohuck/\n\n  Based on the following article:\n  http://dl.acm.org/citation.cfm?id=1498047\n\n  Modifications tracked on Github.\n  */\n  var DEBUG;\n  /**\n   * @brief :  default layout options\n   */\n\n  var defaults$4 = {\n    // Called on `layoutready`\n    ready: function ready() {},\n    // Called on `layoutstop`\n    stop: function stop() {},\n    // Whether to animate while running the layout\n    // true : Animate continuously as the layout is running\n    // false : Just show the end result\n    // 'end' : Animate with the end result, from the initial positions to the end positions\n    animate: true,\n    // Easing of the animation for animate:'end'\n    animationEasing: undefined,\n    // The duration of the animation for animate:'end'\n    animationDuration: undefined,\n    // A function that determines whether the node should be animated\n    // All nodes animated by default on animate enabled\n    // Non-animated nodes are positioned immediately when the layout starts\n    animateFilter: function animateFilter(node, i) {\n      return true;\n    },\n    // The layout animates only after this many milliseconds for animate:true\n    // (prevents flashing on fast runs)\n    animationThreshold: 250,\n    // Number of iterations between consecutive screen positions update\n    refresh: 20,\n    // Whether to fit the network view after when done\n    fit: true,\n    // Padding on fit\n    padding: 30,\n    // Constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n    boundingBox: undefined,\n    // Excludes the label when calculating node bounding boxes for the layout algorithm\n    nodeDimensionsIncludeLabels: false,\n    // Randomize the initial positions of the nodes (true) or use existing positions (false)\n    randomize: false,\n    // Extra spacing between components in non-compound graphs\n    componentSpacing: 40,\n    // Node repulsion (non overlapping) multiplier\n    nodeRepulsion: function nodeRepulsion(node) {\n      return 2048;\n    },\n    // Node repulsion (overlapping) multiplier\n    nodeOverlap: 4,\n    // Ideal edge (non nested) length\n    idealEdgeLength: function idealEdgeLength(edge) {\n      return 32;\n    },\n    // Divisor to compute edge forces\n    edgeElasticity: function edgeElasticity(edge) {\n      return 32;\n    },\n    // Nesting factor (multiplier) to compute ideal edge length for nested edges\n    nestingFactor: 1.2,\n    // Gravity force (constant)\n    gravity: 1,\n    // Maximum number of iterations to perform\n    numIter: 1000,\n    // Initial temperature (maximum node displacement)\n    initialTemp: 1000,\n    // Cooling factor (how the temperature is reduced between consecutive iterations\n    coolingFactor: 0.99,\n    // Lower temperature threshold (below this point the layout will end)\n    minTemp: 1.0\n  };\n  /**\n   * @brief       : constructor\n   * @arg options : object containing layout options\n   */\n\n  function CoseLayout(options) {\n    this.options = extend({}, defaults$4, options);\n    this.options.layout = this;\n  }\n  /**\n   * @brief : runs the layout\n   */\n\n\n  CoseLayout.prototype.run = function () {\n    var options = this.options;\n    var cy = options.cy;\n    var layout = this;\n    layout.stopped = false;\n\n    if (options.animate === true || options.animate === false) {\n      layout.emit({\n        type: 'layoutstart',\n        layout: layout\n      });\n    } // Set DEBUG - Global variable\n\n\n    if (true === options.debug) {\n      DEBUG = true;\n    } else {\n      DEBUG = false;\n    } // Initialize layout info\n\n\n    var layoutInfo = createLayoutInfo(cy, layout, options); // Show LayoutInfo contents if debugging\n\n    if (DEBUG) {\n      printLayoutInfo(layoutInfo);\n    } // If required, randomize node positions\n\n\n    if (options.randomize) {\n      randomizePositions(layoutInfo);\n    }\n\n    var startTime = performanceNow();\n\n    var refresh = function refresh() {\n      refreshPositions(layoutInfo, cy, options); // Fit the graph if necessary\n\n      if (true === options.fit) {\n        cy.fit(options.padding);\n      }\n    };\n\n    var mainLoop = function mainLoop(i) {\n      if (layout.stopped || i >= options.numIter) {\n        // logDebug(\"Layout manually stopped. Stopping computation in step \" + i);\n        return false;\n      } // Do one step in the phisical simulation\n\n\n      step(layoutInfo, options); // Update temperature\n\n      layoutInfo.temperature = layoutInfo.temperature * options.coolingFactor; // logDebug(\"New temperature: \" + layoutInfo.temperature);\n\n      if (layoutInfo.temperature < options.minTemp) {\n        // logDebug(\"Temperature drop below minimum threshold. Stopping computation in step \" + i);\n        return false;\n      }\n\n      return true;\n    };\n\n    var done = function done() {\n      if (options.animate === true || options.animate === false) {\n        refresh(); // Layout has finished\n\n        layout.one('layoutstop', options.stop);\n        layout.emit({\n          type: 'layoutstop',\n          layout: layout\n        });\n      } else {\n        var nodes = options.eles.nodes();\n        var getScaledPos = getScaleInBoundsFn(layoutInfo, options, nodes);\n        nodes.layoutPositions(layout, options, getScaledPos);\n      }\n    };\n\n    var i = 0;\n    var loopRet = true;\n\n    if (options.animate === true) {\n      var frame = function frame() {\n        var f = 0;\n\n        while (loopRet && f < options.refresh) {\n          loopRet = mainLoop(i);\n          i++;\n          f++;\n        }\n\n        if (!loopRet) {\n          // it's done\n          separateComponents(layoutInfo, options);\n          done();\n        } else {\n          var now = performanceNow();\n\n          if (now - startTime >= options.animationThreshold) {\n            refresh();\n          }\n\n          requestAnimationFrame(frame);\n        }\n      };\n\n      frame();\n    } else {\n      while (loopRet) {\n        loopRet = mainLoop(i);\n        i++;\n      }\n\n      separateComponents(layoutInfo, options);\n      done();\n    }\n\n    return this; // chaining\n  };\n  /**\n   * @brief : called on continuous layouts to stop them before they finish\n   */\n\n\n  CoseLayout.prototype.stop = function () {\n    this.stopped = true;\n\n    if (this.thread) {\n      this.thread.stop();\n    }\n\n    this.emit('layoutstop');\n    return this; // chaining\n  };\n\n  CoseLayout.prototype.destroy = function () {\n    if (this.thread) {\n      this.thread.stop();\n    }\n\n    return this; // chaining\n  };\n  /**\n   * @brief     : Creates an object which is contains all the data\n   *              used in the layout process\n   * @arg cy    : cytoscape.js object\n   * @return    : layoutInfo object initialized\n   */\n\n\n  var createLayoutInfo = function createLayoutInfo(cy, layout, options) {\n    // Shortcut\n    var edges = options.eles.edges();\n    var nodes = options.eles.nodes();\n    var layoutInfo = {\n      isCompound: cy.hasCompoundNodes(),\n      layoutNodes: [],\n      idToIndex: {},\n      nodeSize: nodes.size(),\n      graphSet: [],\n      indexToGraph: [],\n      layoutEdges: [],\n      edgeSize: edges.size(),\n      temperature: options.initialTemp,\n      clientWidth: cy.width(),\n      clientHeight: cy.width(),\n      boundingBox: makeBoundingBox(options.boundingBox ? options.boundingBox : {\n        x1: 0,\n        y1: 0,\n        w: cy.width(),\n        h: cy.height()\n      })\n    };\n    var components = options.eles.components();\n    var id2cmptId = {};\n\n    for (var i = 0; i < components.length; i++) {\n      var component = components[i];\n\n      for (var j = 0; j < component.length; j++) {\n        var node = component[j];\n        id2cmptId[node.id()] = i;\n      }\n    } // Iterate over all nodes, creating layout nodes\n\n\n    for (var i = 0; i < layoutInfo.nodeSize; i++) {\n      var n = nodes[i];\n      var nbb = n.layoutDimensions(options);\n      var tempNode = {};\n      tempNode.isLocked = n.locked();\n      tempNode.id = n.data('id');\n      tempNode.parentId = n.data('parent');\n      tempNode.cmptId = id2cmptId[n.id()];\n      tempNode.children = [];\n      tempNode.positionX = n.position('x');\n      tempNode.positionY = n.position('y');\n      tempNode.offsetX = 0;\n      tempNode.offsetY = 0;\n      tempNode.height = nbb.w;\n      tempNode.width = nbb.h;\n      tempNode.maxX = tempNode.positionX + tempNode.width / 2;\n      tempNode.minX = tempNode.positionX - tempNode.width / 2;\n      tempNode.maxY = tempNode.positionY + tempNode.height / 2;\n      tempNode.minY = tempNode.positionY - tempNode.height / 2;\n      tempNode.padLeft = parseFloat(n.style('padding'));\n      tempNode.padRight = parseFloat(n.style('padding'));\n      tempNode.padTop = parseFloat(n.style('padding'));\n      tempNode.padBottom = parseFloat(n.style('padding')); // forces\n\n      tempNode.nodeRepulsion = fn$6(options.nodeRepulsion) ? options.nodeRepulsion(n) : options.nodeRepulsion; // Add new node\n\n      layoutInfo.layoutNodes.push(tempNode); // Add entry to id-index map\n\n      layoutInfo.idToIndex[tempNode.id] = i;\n    } // Inline implementation of a queue, used for traversing the graph in BFS order\n\n\n    var queue = [];\n    var start = 0; // Points to the start the queue\n\n    var end = -1; // Points to the end of the queue\n\n    var tempGraph = []; // Second pass to add child information and\n    // initialize queue for hierarchical traversal\n\n    for (var i = 0; i < layoutInfo.nodeSize; i++) {\n      var n = layoutInfo.layoutNodes[i];\n      var p_id = n.parentId; // Check if node n has a parent node\n\n      if (null != p_id) {\n        // Add node Id to parent's list of children\n        layoutInfo.layoutNodes[layoutInfo.idToIndex[p_id]].children.push(n.id);\n      } else {\n        // If a node doesn't have a parent, then it's in the root graph\n        queue[++end] = n.id;\n        tempGraph.push(n.id);\n      }\n    } // Add root graph to graphSet\n\n\n    layoutInfo.graphSet.push(tempGraph); // Traverse the graph, level by level,\n\n    while (start <= end) {\n      // Get the node to visit and remove it from queue\n      var node_id = queue[start++];\n      var node_ix = layoutInfo.idToIndex[node_id];\n      var node = layoutInfo.layoutNodes[node_ix];\n      var children = node.children;\n\n      if (children.length > 0) {\n        // Add children nodes as a new graph to graph set\n        layoutInfo.graphSet.push(children); // Add children to que queue to be visited\n\n        for (var i = 0; i < children.length; i++) {\n          queue[++end] = children[i];\n        }\n      }\n    } // Create indexToGraph map\n\n\n    for (var i = 0; i < layoutInfo.graphSet.length; i++) {\n      var graph = layoutInfo.graphSet[i];\n\n      for (var j = 0; j < graph.length; j++) {\n        var index = layoutInfo.idToIndex[graph[j]];\n        layoutInfo.indexToGraph[index] = i;\n      }\n    } // Iterate over all edges, creating Layout Edges\n\n\n    for (var i = 0; i < layoutInfo.edgeSize; i++) {\n      var e = edges[i];\n      var tempEdge = {};\n      tempEdge.id = e.data('id');\n      tempEdge.sourceId = e.data('source');\n      tempEdge.targetId = e.data('target'); // Compute ideal length\n\n      var idealLength = fn$6(options.idealEdgeLength) ? options.idealEdgeLength(e) : options.idealEdgeLength;\n      var elasticity = fn$6(options.edgeElasticity) ? options.edgeElasticity(e) : options.edgeElasticity; // Check if it's an inter graph edge\n\n      var sourceIx = layoutInfo.idToIndex[tempEdge.sourceId];\n      var targetIx = layoutInfo.idToIndex[tempEdge.targetId];\n      var sourceGraph = layoutInfo.indexToGraph[sourceIx];\n      var targetGraph = layoutInfo.indexToGraph[targetIx];\n\n      if (sourceGraph != targetGraph) {\n        // Find lowest common graph ancestor\n        var lca = findLCA(tempEdge.sourceId, tempEdge.targetId, layoutInfo); // Compute sum of node depths, relative to lca graph\n\n        var lcaGraph = layoutInfo.graphSet[lca];\n        var depth = 0; // Source depth\n\n        var tempNode = layoutInfo.layoutNodes[sourceIx];\n\n        while (-1 === lcaGraph.indexOf(tempNode.id)) {\n          tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];\n          depth++;\n        } // Target depth\n\n\n        tempNode = layoutInfo.layoutNodes[targetIx];\n\n        while (-1 === lcaGraph.indexOf(tempNode.id)) {\n          tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];\n          depth++;\n        } // logDebug('LCA of nodes ' + tempEdge.sourceId + ' and ' + tempEdge.targetId +\n        //  \". Index: \" + lca + \" Contents: \" + lcaGraph.toString() +\n        //  \". Depth: \" + depth);\n        // Update idealLength\n\n\n        idealLength *= depth * options.nestingFactor;\n      }\n\n      tempEdge.idealLength = idealLength;\n      tempEdge.elasticity = elasticity;\n      layoutInfo.layoutEdges.push(tempEdge);\n    } // Finally, return layoutInfo object\n\n\n    return layoutInfo;\n  };\n  /**\n   * @brief : This function finds the index of the lowest common\n   *          graph ancestor between 2 nodes in the subtree\n   *          (from the graph hierarchy induced tree) whose\n   *          root is graphIx\n   *\n   * @arg node1: node1's ID\n   * @arg node2: node2's ID\n   * @arg layoutInfo: layoutInfo object\n   *\n   */\n\n\n  var findLCA = function findLCA(node1, node2, layoutInfo) {\n    // Find their common ancester, starting from the root graph\n    var res = findLCA_aux(node1, node2, 0, layoutInfo);\n\n    if (2 > res.count) {\n      // If aux function couldn't find the common ancester,\n      // then it is the root graph\n      return 0;\n    } else {\n      return res.graph;\n    }\n  };\n  /**\n   * @brief          : Auxiliary function used for LCA computation\n   *\n   * @arg node1      : node1's ID\n   * @arg node2      : node2's ID\n   * @arg graphIx    : subgraph index\n   * @arg layoutInfo : layoutInfo object\n   *\n   * @return         : object of the form {count: X, graph: Y}, where:\n   *                   X is the number of ancestors (max: 2) found in\n   *                   graphIx (and it's subgraphs),\n   *                   Y is the graph index of the lowest graph containing\n   *                   all X nodes\n   */\n\n\n  var findLCA_aux = function findLCA_aux(node1, node2, graphIx, layoutInfo) {\n    var graph = layoutInfo.graphSet[graphIx]; // If both nodes belongs to graphIx\n\n    if (-1 < graph.indexOf(node1) && -1 < graph.indexOf(node2)) {\n      return {\n        count: 2,\n        graph: graphIx\n      };\n    } // Make recursive calls for all subgraphs\n\n\n    var c = 0;\n\n    for (var i = 0; i < graph.length; i++) {\n      var nodeId = graph[i];\n      var nodeIx = layoutInfo.idToIndex[nodeId];\n      var children = layoutInfo.layoutNodes[nodeIx].children; // If the node has no child, skip it\n\n      if (0 === children.length) {\n        continue;\n      }\n\n      var childGraphIx = layoutInfo.indexToGraph[layoutInfo.idToIndex[children[0]]];\n      var result = findLCA_aux(node1, node2, childGraphIx, layoutInfo);\n\n      if (0 === result.count) {\n        // Neither node1 nor node2 are present in this subgraph\n        continue;\n      } else if (1 === result.count) {\n        // One of (node1, node2) is present in this subgraph\n        c++;\n\n        if (2 === c) {\n          // We've already found both nodes, no need to keep searching\n          break;\n        }\n      } else {\n        // Both nodes are present in this subgraph\n        return result;\n      }\n    }\n\n    return {\n      count: c,\n      graph: graphIx\n    };\n  };\n  /**\n   * @brief: printsLayoutInfo into js console\n   *         Only used for debbuging\n   */\n\n\nvar printLayoutInfo; \n  /**\n   * @brief : Randomizes the position of all nodes\n   */\n\n\n  var randomizePositions = function randomizePositions(layoutInfo, cy) {\n    var width = layoutInfo.clientWidth;\n    var height = layoutInfo.clientHeight;\n\n    for (var i = 0; i < layoutInfo.nodeSize; i++) {\n      var n = layoutInfo.layoutNodes[i]; // No need to randomize compound nodes or locked nodes\n\n      if (0 === n.children.length && !n.isLocked) {\n        n.positionX = Math.random() * width;\n        n.positionY = Math.random() * height;\n      }\n    }\n  };\n\n  var getScaleInBoundsFn = function getScaleInBoundsFn(layoutInfo, options, nodes) {\n    var bb = layoutInfo.boundingBox;\n    var coseBB = {\n      x1: Infinity,\n      x2: -Infinity,\n      y1: Infinity,\n      y2: -Infinity\n    };\n\n    if (options.boundingBox) {\n      nodes.forEach(function (node) {\n        var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[node.data('id')]];\n        coseBB.x1 = Math.min(coseBB.x1, lnode.positionX);\n        coseBB.x2 = Math.max(coseBB.x2, lnode.positionX);\n        coseBB.y1 = Math.min(coseBB.y1, lnode.positionY);\n        coseBB.y2 = Math.max(coseBB.y2, lnode.positionY);\n      });\n      coseBB.w = coseBB.x2 - coseBB.x1;\n      coseBB.h = coseBB.y2 - coseBB.y1;\n    }\n\n    return function (ele, i) {\n      var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[ele.data('id')]];\n\n      if (options.boundingBox) {\n        // then add extra bounding box constraint\n        var pctX = (lnode.positionX - coseBB.x1) / coseBB.w;\n        var pctY = (lnode.positionY - coseBB.y1) / coseBB.h;\n        return {\n          x: bb.x1 + pctX * bb.w,\n          y: bb.y1 + pctY * bb.h\n        };\n      } else {\n        return {\n          x: lnode.positionX,\n          y: lnode.positionY\n        };\n      }\n    };\n  };\n  /**\n   * @brief          : Updates the positions of nodes in the network\n   * @arg layoutInfo : LayoutInfo object\n   * @arg cy         : Cytoscape object\n   * @arg options    : Layout options\n   */\n\n\n  var refreshPositions = function refreshPositions(layoutInfo, cy, options) {\n    // var s = 'Refreshing positions';\n    // logDebug(s);\n    var layout = options.layout;\n    var nodes = options.eles.nodes();\n    var getScaledPos = getScaleInBoundsFn(layoutInfo, options, nodes);\n    nodes.positions(getScaledPos); // Trigger layoutReady only on first call\n\n    if (true !== layoutInfo.ready) {\n      // s = 'Triggering layoutready';\n      // logDebug(s);\n      layoutInfo.ready = true;\n      layout.one('layoutready', options.ready);\n      layout.emit({\n        type: 'layoutready',\n        layout: this\n      });\n    }\n  };\n  /**\n   * @brief : Logs a debug message in JS console, if DEBUG is ON\n   */\n  // var logDebug = function(text) {\n  //   if (DEBUG) {\n  //     console.debug(text);\n  //   }\n  // };\n\n  /**\n   * @brief          : Performs one iteration of the physical simulation\n   * @arg layoutInfo : LayoutInfo object already initialized\n   * @arg cy         : Cytoscape object\n   * @arg options    : Layout options\n   */\n\n\n  var step = function step(layoutInfo, options, _step) {\n    // var s = \"\\n\\n###############################\";\n    // s += \"\\nSTEP: \" + step;\n    // s += \"\\n###############################\\n\";\n    // logDebug(s);\n    // Calculate node repulsions\n    calculateNodeForces(layoutInfo, options); // Calculate edge forces\n\n    calculateEdgeForces(layoutInfo); // Calculate gravity forces\n\n    calculateGravityForces(layoutInfo, options); // Propagate forces from parent to child\n\n    propagateForces(layoutInfo); // Update positions based on calculated forces\n\n    updatePositions(layoutInfo);\n  };\n  /**\n   * @brief : Computes the node repulsion forces\n   */\n\n\n  var calculateNodeForces = function calculateNodeForces(layoutInfo, options) {\n    // Go through each of the graphs in graphSet\n    // Nodes only repel each other if they belong to the same graph\n    // var s = 'calculateNodeForces';\n    // logDebug(s);\n    for (var i = 0; i < layoutInfo.graphSet.length; i++) {\n      var graph = layoutInfo.graphSet[i];\n      var numNodes = graph.length; // s = \"Set: \" + graph.toString();\n      // logDebug(s);\n      // Now get all the pairs of nodes\n      // Only get each pair once, (A, B) = (B, A)\n\n      for (var j = 0; j < numNodes; j++) {\n        var node1 = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[j]]];\n\n        for (var k = j + 1; k < numNodes; k++) {\n          var node2 = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[k]]];\n          nodeRepulsion(node1, node2, layoutInfo, options);\n        }\n      }\n    }\n  };\n\n  var randomDistance = function randomDistance(max) {\n    return -max + 2 * max * Math.random();\n  };\n  /**\n   * @brief : Compute the node repulsion forces between a pair of nodes\n   */\n\n\n  var nodeRepulsion = function nodeRepulsion(node1, node2, layoutInfo, options) {\n    // var s = \"Node repulsion. Node1: \" + node1.id + \" Node2: \" + node2.id;\n    var cmptId1 = node1.cmptId;\n    var cmptId2 = node2.cmptId;\n\n    if (cmptId1 !== cmptId2 && !layoutInfo.isCompound) {\n      return;\n    } // Get direction of line connecting both node centers\n\n\n    var directionX = node2.positionX - node1.positionX;\n    var directionY = node2.positionY - node1.positionY;\n    var maxRandDist = 1; // s += \"\\ndirectionX: \" + directionX + \", directionY: \" + directionY;\n    // If both centers are the same, apply a random force\n\n    if (0 === directionX && 0 === directionY) {\n      directionX = randomDistance(maxRandDist);\n      directionY = randomDistance(maxRandDist);\n    }\n\n    var overlap = nodesOverlap(node1, node2, directionX, directionY);\n\n    if (overlap > 0) {\n      // s += \"\\nNodes DO overlap.\";\n      // s += \"\\nOverlap: \" + overlap;\n      // If nodes overlap, repulsion force is proportional\n      // to the overlap\n      var force = options.nodeOverlap * overlap; // Compute the module and components of the force vector\n\n      var distance = Math.sqrt(directionX * directionX + directionY * directionY); // s += \"\\nDistance: \" + distance;\n\n      var forceX = force * directionX / distance;\n      var forceY = force * directionY / distance;\n    } else {\n      // s += \"\\nNodes do NOT overlap.\";\n      // If there's no overlap, force is inversely proportional\n      // to squared distance\n      // Get clipping points for both nodes\n      var point1 = findClippingPoint(node1, directionX, directionY);\n      var point2 = findClippingPoint(node2, -1 * directionX, -1 * directionY); // Use clipping points to compute distance\n\n      var distanceX = point2.x - point1.x;\n      var distanceY = point2.y - point1.y;\n      var distanceSqr = distanceX * distanceX + distanceY * distanceY;\n      var distance = Math.sqrt(distanceSqr); // s += \"\\nDistance: \" + distance;\n      // Compute the module and components of the force vector\n\n      var force = (node1.nodeRepulsion + node2.nodeRepulsion) / distanceSqr;\n      var forceX = force * distanceX / distance;\n      var forceY = force * distanceY / distance;\n    } // Apply force\n\n\n    if (!node1.isLocked) {\n      node1.offsetX -= forceX;\n      node1.offsetY -= forceY;\n    }\n\n    if (!node2.isLocked) {\n      node2.offsetX += forceX;\n      node2.offsetY += forceY;\n    } // s += \"\\nForceX: \" + forceX + \" ForceY: \" + forceY;\n    // logDebug(s);\n\n\n    return;\n  };\n  /**\n   * @brief  : Determines whether two nodes overlap or not\n   * @return : Amount of overlapping (0 => no overlap)\n   */\n\n\n  var nodesOverlap = function nodesOverlap(node1, node2, dX, dY) {\n    if (dX > 0) {\n      var overlapX = node1.maxX - node2.minX;\n    } else {\n      var overlapX = node2.maxX - node1.minX;\n    }\n\n    if (dY > 0) {\n      var overlapY = node1.maxY - node2.minY;\n    } else {\n      var overlapY = node2.maxY - node1.minY;\n    }\n\n    if (overlapX >= 0 && overlapY >= 0) {\n      return Math.sqrt(overlapX * overlapX + overlapY * overlapY);\n    } else {\n      return 0;\n    }\n  };\n  /**\n   * @brief : Finds the point in which an edge (direction dX, dY) intersects\n   *          the rectangular bounding box of it's source/target node\n   */\n\n\n  var findClippingPoint = function findClippingPoint(node, dX, dY) {\n    // Shorcuts\n    var X = node.positionX;\n    var Y = node.positionY;\n    var H = node.height || 1;\n    var W = node.width || 1;\n    var dirSlope = dY / dX;\n    var nodeSlope = H / W; // var s = 'Computing clipping point of node ' + node.id +\n    //   \" . Height:  \" + H + \", Width: \" + W +\n    //   \"\\nDirection \" + dX + \", \" + dY;\n    //\n    // Compute intersection\n\n    var res = {}; // Case: Vertical direction (up)\n\n    if (0 === dX && 0 < dY) {\n      res.x = X; // s += \"\\nUp direction\";\n\n      res.y = Y + H / 2;\n      return res;\n    } // Case: Vertical direction (down)\n\n\n    if (0 === dX && 0 > dY) {\n      res.x = X;\n      res.y = Y + H / 2; // s += \"\\nDown direction\";\n\n      return res;\n    } // Case: Intersects the right border\n\n\n    if (0 < dX && -1 * nodeSlope <= dirSlope && dirSlope <= nodeSlope) {\n      res.x = X + W / 2;\n      res.y = Y + W * dY / 2 / dX; // s += \"\\nRightborder\";\n\n      return res;\n    } // Case: Intersects the left border\n\n\n    if (0 > dX && -1 * nodeSlope <= dirSlope && dirSlope <= nodeSlope) {\n      res.x = X - W / 2;\n      res.y = Y - W * dY / 2 / dX; // s += \"\\nLeftborder\";\n\n      return res;\n    } // Case: Intersects the top border\n\n\n    if (0 < dY && (dirSlope <= -1 * nodeSlope || dirSlope >= nodeSlope)) {\n      res.x = X + H * dX / 2 / dY;\n      res.y = Y + H / 2; // s += \"\\nTop border\";\n\n      return res;\n    } // Case: Intersects the bottom border\n\n\n    if (0 > dY && (dirSlope <= -1 * nodeSlope || dirSlope >= nodeSlope)) {\n      res.x = X - H * dX / 2 / dY;\n      res.y = Y - H / 2; // s += \"\\nBottom border\";\n\n      return res;\n    } // s += \"\\nClipping point found at \" + res.x + \", \" + res.y;\n    // logDebug(s);\n\n\n    return res;\n  };\n  /**\n   * @brief : Calculates all edge forces\n   */\n\n\n  var calculateEdgeForces = function calculateEdgeForces(layoutInfo, options) {\n    // Iterate over all edges\n    for (var i = 0; i < layoutInfo.edgeSize; i++) {\n      // Get edge, source & target nodes\n      var edge = layoutInfo.layoutEdges[i];\n      var sourceIx = layoutInfo.idToIndex[edge.sourceId];\n      var source = layoutInfo.layoutNodes[sourceIx];\n      var targetIx = layoutInfo.idToIndex[edge.targetId];\n      var target = layoutInfo.layoutNodes[targetIx]; // Get direction of line connecting both node centers\n\n      var directionX = target.positionX - source.positionX;\n      var directionY = target.positionY - source.positionY; // If both centers are the same, do nothing.\n      // A random force has already been applied as node repulsion\n\n      if (0 === directionX && 0 === directionY) {\n        continue;\n      } // Get clipping points for both nodes\n\n\n      var point1 = findClippingPoint(source, directionX, directionY);\n      var point2 = findClippingPoint(target, -1 * directionX, -1 * directionY);\n      var lx = point2.x - point1.x;\n      var ly = point2.y - point1.y;\n      var l = Math.sqrt(lx * lx + ly * ly);\n      var force = Math.pow(edge.idealLength - l, 2) / edge.elasticity;\n\n      if (0 !== l) {\n        var forceX = force * lx / l;\n        var forceY = force * ly / l;\n      } else {\n        var forceX = 0;\n        var forceY = 0;\n      } // Add this force to target and source nodes\n\n\n      if (!source.isLocked) {\n        source.offsetX += forceX;\n        source.offsetY += forceY;\n      }\n\n      if (!target.isLocked) {\n        target.offsetX -= forceX;\n        target.offsetY -= forceY;\n      } // var s = 'Edge force between nodes ' + source.id + ' and ' + target.id;\n      // s += \"\\nDistance: \" + l + \" Force: (\" + forceX + \", \" + forceY + \")\";\n      // logDebug(s);\n\n    }\n  };\n  /**\n   * @brief : Computes gravity forces for all nodes\n   */\n\n\n  var calculateGravityForces = function calculateGravityForces(layoutInfo, options) {\n    if (options.gravity === 0) {\n      return;\n    }\n\n    var distThreshold = 1; // var s = 'calculateGravityForces';\n    // logDebug(s);\n\n    for (var i = 0; i < layoutInfo.graphSet.length; i++) {\n      var graph = layoutInfo.graphSet[i];\n      var numNodes = graph.length; // s = \"Set: \" + graph.toString();\n      // logDebug(s);\n      // Compute graph center\n\n      if (0 === i) {\n        var centerX = layoutInfo.clientHeight / 2;\n        var centerY = layoutInfo.clientWidth / 2;\n      } else {\n        // Get Parent node for this graph, and use its position as center\n        var temp = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[0]]];\n        var parent = layoutInfo.layoutNodes[layoutInfo.idToIndex[temp.parentId]];\n        var centerX = parent.positionX;\n        var centerY = parent.positionY;\n      } // s = \"Center found at: \" + centerX + \", \" + centerY;\n      // logDebug(s);\n      // Apply force to all nodes in graph\n\n\n      for (var j = 0; j < numNodes; j++) {\n        var node = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[j]]]; // s = \"Node: \" + node.id;\n\n        if (node.isLocked) {\n          continue;\n        }\n\n        var dx = centerX - node.positionX;\n        var dy = centerY - node.positionY;\n        var d = Math.sqrt(dx * dx + dy * dy);\n\n        if (d > distThreshold) {\n          var fx = options.gravity * dx / d;\n          var fy = options.gravity * dy / d;\n          node.offsetX += fx;\n          node.offsetY += fy; // s += \": Applied force: \" + fx + \", \" + fy;\n        } // logDebug(s);\n\n      }\n    }\n  };\n  /**\n   * @brief          : This function propagates the existing offsets from\n   *                   parent nodes to its descendents.\n   * @arg layoutInfo : layoutInfo Object\n   * @arg cy         : cytoscape Object\n   * @arg options    : Layout options\n   */\n\n\n  var propagateForces = function propagateForces(layoutInfo, options) {\n    // Inline implementation of a queue, used for traversing the graph in BFS order\n    var queue = [];\n    var start = 0; // Points to the start the queue\n\n    var end = -1; // Points to the end of the queue\n    // logDebug('propagateForces');\n    // Start by visiting the nodes in the root graph\n\n    queue.push.apply(queue, layoutInfo.graphSet[0]);\n    end += layoutInfo.graphSet[0].length; // Traverse the graph, level by level,\n\n    while (start <= end) {\n      // Get the node to visit and remove it from queue\n      var nodeId = queue[start++];\n      var nodeIndex = layoutInfo.idToIndex[nodeId];\n      var node = layoutInfo.layoutNodes[nodeIndex];\n      var children = node.children; // We only need to process the node if it's compound\n\n      if (0 < children.length && !node.isLocked) {\n        var offX = node.offsetX;\n        var offY = node.offsetY; // var s = \"Propagating offset from parent node : \" + node.id +\n        //   \". OffsetX: \" + offX + \". OffsetY: \" + offY;\n        // s += \"\\n Children: \" + children.toString();\n        // logDebug(s);\n\n        for (var i = 0; i < children.length; i++) {\n          var childNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[children[i]]]; // Propagate offset\n\n          childNode.offsetX += offX;\n          childNode.offsetY += offY; // Add children to queue to be visited\n\n          queue[++end] = children[i];\n        } // Reset parent offsets\n\n\n        node.offsetX = 0;\n        node.offsetY = 0;\n      }\n    }\n  };\n  /**\n   * @brief : Updates the layout model positions, based on\n   *          the accumulated forces\n   */\n\n\n  var updatePositions = function updatePositions(layoutInfo, options) {\n    // var s = 'Updating positions';\n    // logDebug(s);\n    // Reset boundaries for compound nodes\n    for (var i = 0; i < layoutInfo.nodeSize; i++) {\n      var n = layoutInfo.layoutNodes[i];\n\n      if (0 < n.children.length) {\n        // logDebug(\"Resetting boundaries of compound node: \" + n.id);\n        n.maxX = undefined;\n        n.minX = undefined;\n        n.maxY = undefined;\n        n.minY = undefined;\n      }\n    }\n\n    for (var i = 0; i < layoutInfo.nodeSize; i++) {\n      var n = layoutInfo.layoutNodes[i];\n\n      if (0 < n.children.length || n.isLocked) {\n        // No need to set compound or locked node position\n        // logDebug(\"Skipping position update of node: \" + n.id);\n        continue;\n      } // s = \"Node: \" + n.id + \" Previous position: (\" +\n      // n.positionX + \", \" + n.positionY + \").\";\n      // Limit displacement in order to improve stability\n\n\n      var tempForce = limitForce(n.offsetX, n.offsetY, layoutInfo.temperature);\n      n.positionX += tempForce.x;\n      n.positionY += tempForce.y;\n      n.offsetX = 0;\n      n.offsetY = 0;\n      n.minX = n.positionX - n.width;\n      n.maxX = n.positionX + n.width;\n      n.minY = n.positionY - n.height;\n      n.maxY = n.positionY + n.height; // s += \" New Position: (\" + n.positionX + \", \" + n.positionY + \").\";\n      // logDebug(s);\n      // Update ancestry boudaries\n\n      updateAncestryBoundaries(n, layoutInfo);\n    } // Update size, position of compund nodes\n\n\n    for (var i = 0; i < layoutInfo.nodeSize; i++) {\n      var n = layoutInfo.layoutNodes[i];\n\n      if (0 < n.children.length && !n.isLocked) {\n        n.positionX = (n.maxX + n.minX) / 2;\n        n.positionY = (n.maxY + n.minY) / 2;\n        n.width = n.maxX - n.minX;\n        n.height = n.maxY - n.minY; // s = \"Updating position, size of compound node \" + n.id;\n        // s += \"\\nPositionX: \" + n.positionX + \", PositionY: \" + n.positionY;\n        // s += \"\\nWidth: \" + n.width + \", Height: \" + n.height;\n        // logDebug(s);\n      }\n    }\n  };\n  /**\n   * @brief : Limits a force (forceX, forceY) to be not\n   *          greater (in modulo) than max.\n   8          Preserves force direction.\n    */\n\n\n  var limitForce = function limitForce(forceX, forceY, max) {\n    // var s = \"Limiting force: (\" + forceX + \", \" + forceY + \"). Max: \" + max;\n    var force = Math.sqrt(forceX * forceX + forceY * forceY);\n\n    if (force > max) {\n      var res = {\n        x: max * forceX / force,\n        y: max * forceY / force\n      };\n    } else {\n      var res = {\n        x: forceX,\n        y: forceY\n      };\n    } // s += \".\\nResult: (\" + res.x + \", \" + res.y + \")\";\n    // logDebug(s);\n\n\n    return res;\n  };\n  /**\n   * @brief : Function used for keeping track of compound node\n   *          sizes, since they should bound all their subnodes.\n   */\n\n\n  var updateAncestryBoundaries = function updateAncestryBoundaries(node, layoutInfo) {\n    // var s = \"Propagating new position/size of node \" + node.id;\n    var parentId = node.parentId;\n\n    if (null == parentId) {\n      // If there's no parent, we are done\n      // s += \". No parent node.\";\n      // logDebug(s);\n      return;\n    } // Get Parent Node\n\n\n    var p = layoutInfo.layoutNodes[layoutInfo.idToIndex[parentId]];\n    var flag = false; // MaxX\n\n    if (null == p.maxX || node.maxX + p.padRight > p.maxX) {\n      p.maxX = node.maxX + p.padRight;\n      flag = true; // s += \"\\nNew maxX for parent node \" + p.id + \": \" + p.maxX;\n    } // MinX\n\n\n    if (null == p.minX || node.minX - p.padLeft < p.minX) {\n      p.minX = node.minX - p.padLeft;\n      flag = true; // s += \"\\nNew minX for parent node \" + p.id + \": \" + p.minX;\n    } // MaxY\n\n\n    if (null == p.maxY || node.maxY + p.padBottom > p.maxY) {\n      p.maxY = node.maxY + p.padBottom;\n      flag = true; // s += \"\\nNew maxY for parent node \" + p.id + \": \" + p.maxY;\n    } // MinY\n\n\n    if (null == p.minY || node.minY - p.padTop < p.minY) {\n      p.minY = node.minY - p.padTop;\n      flag = true; // s += \"\\nNew minY for parent node \" + p.id + \": \" + p.minY;\n    } // If updated boundaries, propagate changes upward\n\n\n    if (flag) {\n      // logDebug(s);\n      return updateAncestryBoundaries(p, layoutInfo);\n    } // s += \". No changes in boundaries/position of parent node \" + p.id;\n    // logDebug(s);\n\n\n    return;\n  };\n\n  var separateComponents = function separateComponents(layoutInfo, options) {\n    var nodes = layoutInfo.layoutNodes;\n    var components = [];\n\n    for (var i = 0; i < nodes.length; i++) {\n      var node = nodes[i];\n      var cid = node.cmptId;\n      var component = components[cid] = components[cid] || [];\n      component.push(node);\n    }\n\n    var totalA = 0;\n\n    for (var i = 0; i < components.length; i++) {\n      var c = components[i];\n\n      if (!c) {\n        continue;\n      }\n\n      c.x1 = Infinity;\n      c.x2 = -Infinity;\n      c.y1 = Infinity;\n      c.y2 = -Infinity;\n\n      for (var j = 0; j < c.length; j++) {\n        var n = c[j];\n        c.x1 = Math.min(c.x1, n.positionX - n.width / 2);\n        c.x2 = Math.max(c.x2, n.positionX + n.width / 2);\n        c.y1 = Math.min(c.y1, n.positionY - n.height / 2);\n        c.y2 = Math.max(c.y2, n.positionY + n.height / 2);\n      }\n\n      c.w = c.x2 - c.x1;\n      c.h = c.y2 - c.y1;\n      totalA += c.w * c.h;\n    }\n\n    components.sort(function (c1, c2) {\n      return c2.w * c2.h - c1.w * c1.h;\n    });\n    var x = 0;\n    var y = 0;\n    var usedW = 0;\n    var rowH = 0;\n    var maxRowW = Math.sqrt(totalA) * layoutInfo.clientWidth / layoutInfo.clientHeight;\n\n    for (var i = 0; i < components.length; i++) {\n      var c = components[i];\n\n      if (!c) {\n        continue;\n      }\n\n      for (var j = 0; j < c.length; j++) {\n        var n = c[j];\n\n        if (!n.isLocked) {\n          n.positionX += x - c.x1;\n          n.positionY += y - c.y1;\n        }\n      }\n\n      x += c.w + options.componentSpacing;\n      usedW += c.w + options.componentSpacing;\n      rowH = Math.max(rowH, c.h);\n\n      if (usedW > maxRowW) {\n        y += rowH + options.componentSpacing;\n        x = 0;\n        usedW = 0;\n        rowH = 0;\n      }\n    }\n  };\n\n  var defaults$3 = {\n    fit: true,\n    // whether to fit the viewport to the graph\n    padding: 30,\n    // padding used on fit\n    boundingBox: undefined,\n    // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n    avoidOverlap: true,\n    // prevents node overlap, may overflow boundingBox if not enough space\n    avoidOverlapPadding: 10,\n    // extra spacing around nodes when avoidOverlap: true\n    nodeDimensionsIncludeLabels: false,\n    // Excludes the label when calculating node bounding boxes for the layout algorithm\n    spacingFactor: undefined,\n    // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up\n    condense: false,\n    // uses all available space on false, uses minimal space on true\n    rows: undefined,\n    // force num of rows in the grid\n    cols: undefined,\n    // force num of columns in the grid\n    position: function position(node) {},\n    // returns { row, col } for element\n    sort: undefined,\n    // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }\n    animate: false,\n    // whether to transition the node positions\n    animationDuration: 500,\n    // duration of animation in ms if enabled\n    animationEasing: undefined,\n    // easing of animation if enabled\n    animateFilter: function animateFilter(node, i) {\n      return true;\n    },\n    // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts\n    ready: undefined,\n    // callback on layoutready\n    stop: undefined,\n    // callback on layoutstop\n    transform: function transform(node, position) {\n      return position;\n    } // transform a given node position. Useful for changing flow direction in discrete layouts \n\n  };\n\n  function GridLayout(options) {\n    this.options = extend({}, defaults$3, options);\n  }\n\n  GridLayout.prototype.run = function () {\n    var params = this.options;\n    var options = params;\n    var cy = params.cy;\n    var eles = options.eles;\n    var nodes = eles.nodes().not(':parent');\n\n    if (options.sort) {\n      nodes = nodes.sort(options.sort);\n    }\n\n    var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {\n      x1: 0,\n      y1: 0,\n      w: cy.width(),\n      h: cy.height()\n    });\n\n    if (bb.h === 0 || bb.w === 0) {\n      eles.nodes().layoutPositions(this, options, function (ele) {\n        return {\n          x: bb.x1,\n          y: bb.y1\n        };\n      });\n    } else {\n      // width/height * splits^2 = cells where splits is number of times to split width\n      var cells = nodes.size();\n      var splits = Math.sqrt(cells * bb.h / bb.w);\n      var rows = Math.round(splits);\n      var cols = Math.round(bb.w / bb.h * splits);\n\n      var small = function small(val) {\n        if (val == null) {\n          return Math.min(rows, cols);\n        } else {\n          var min = Math.min(rows, cols);\n\n          if (min == rows) {\n            rows = val;\n          } else {\n            cols = val;\n          }\n        }\n      };\n\n      var large = function large(val) {\n        if (val == null) {\n          return Math.max(rows, cols);\n        } else {\n          var max = Math.max(rows, cols);\n\n          if (max == rows) {\n            rows = val;\n          } else {\n            cols = val;\n          }\n        }\n      };\n\n      var oRows = options.rows;\n      var oCols = options.cols != null ? options.cols : options.columns; // if rows or columns were set in options, use those values\n\n      if (oRows != null && oCols != null) {\n        rows = oRows;\n        cols = oCols;\n      } else if (oRows != null && oCols == null) {\n        rows = oRows;\n        cols = Math.ceil(cells / rows);\n      } else if (oRows == null && oCols != null) {\n        cols = oCols;\n        rows = Math.ceil(cells / cols);\n      } // otherwise use the automatic values and adjust accordingly\n      // if rounding was up, see if we can reduce rows or columns\n      else if (cols * rows > cells) {\n        var sm = small();\n        var lg = large(); // reducing the small side takes away the most cells, so try it first\n\n        if ((sm - 1) * lg >= cells) {\n          small(sm - 1);\n        } else if ((lg - 1) * sm >= cells) {\n          large(lg - 1);\n        }\n      } else {\n        // if rounding was too low, add rows or columns\n        while (cols * rows < cells) {\n          var _sm = small();\n\n          var _lg = large(); // try to add to larger side first (adds less in multiplication)\n\n\n          if ((_lg + 1) * _sm >= cells) {\n            large(_lg + 1);\n          } else {\n            small(_sm + 1);\n          }\n        }\n      }\n\n      var cellWidth = bb.w / cols;\n      var cellHeight = bb.h / rows;\n\n      if (options.condense) {\n        cellWidth = 0;\n        cellHeight = 0;\n      }\n\n      if (options.avoidOverlap) {\n        for (var i = 0; i < nodes.length; i++) {\n          var node = nodes[i];\n          var pos = node._private.position;\n\n          if (pos.x == null || pos.y == null) {\n            // for bb\n            pos.x = 0;\n            pos.y = 0;\n          }\n\n          var nbb = node.layoutDimensions(options);\n          var p = options.avoidOverlapPadding;\n          var w = nbb.w + p;\n          var h = nbb.h + p;\n          cellWidth = Math.max(cellWidth, w);\n          cellHeight = Math.max(cellHeight, h);\n        }\n      }\n\n      var cellUsed = {}; // e.g. 'c-0-2' => true\n\n      var used = function used(row, col) {\n        return cellUsed['c-' + row + '-' + col] ? true : false;\n      };\n\n      var use = function use(row, col) {\n        cellUsed['c-' + row + '-' + col] = true;\n      }; // to keep track of current cell position\n\n\n      var row = 0;\n      var col = 0;\n\n      var moveToNextCell = function moveToNextCell() {\n        col++;\n\n        if (col >= cols) {\n          col = 0;\n          row++;\n        }\n      }; // get a cache of all the manual positions\n\n\n      var id2manPos = {};\n\n      for (var _i = 0; _i < nodes.length; _i++) {\n        var _node = nodes[_i];\n        var rcPos = options.position(_node);\n\n        if (rcPos && (rcPos.row !== undefined || rcPos.col !== undefined)) {\n          // must have at least row or col def'd\n          var _pos = {\n            row: rcPos.row,\n            col: rcPos.col\n          };\n\n          if (_pos.col === undefined) {\n            // find unused col\n            _pos.col = 0;\n\n            while (used(_pos.row, _pos.col)) {\n              _pos.col++;\n            }\n          } else if (_pos.row === undefined) {\n            // find unused row\n            _pos.row = 0;\n\n            while (used(_pos.row, _pos.col)) {\n              _pos.row++;\n            }\n          }\n\n          id2manPos[_node.id()] = _pos;\n          use(_pos.row, _pos.col);\n        }\n      }\n\n      var getPos = function getPos(element, i) {\n        var x, y;\n\n        if (element.locked() || element.isParent()) {\n          return false;\n        } // see if we have a manual position set\n\n\n        var rcPos = id2manPos[element.id()];\n\n        if (rcPos) {\n          x = rcPos.col * cellWidth + cellWidth / 2 + bb.x1;\n          y = rcPos.row * cellHeight + cellHeight / 2 + bb.y1;\n        } else {\n          // otherwise set automatically\n          while (used(row, col)) {\n            moveToNextCell();\n          }\n\n          x = col * cellWidth + cellWidth / 2 + bb.x1;\n          y = row * cellHeight + cellHeight / 2 + bb.y1;\n          use(row, col);\n          moveToNextCell();\n        }\n\n        return {\n          x: x,\n          y: y\n        };\n      };\n\n      nodes.layoutPositions(this, options, getPos);\n    }\n\n    return this; // chaining\n  };\n\n  var defaults$2 = {\n    ready: function ready() {},\n    // on layoutready\n    stop: function stop() {} // on layoutstop\n\n  }; // constructor\n  // options : object containing layout options\n\n  function NullLayout(options) {\n    this.options = extend({}, defaults$2, options);\n  } // runs the layout\n\n\n  NullLayout.prototype.run = function () {\n    var options = this.options;\n    var eles = options.eles; // elements to consider in the layout\n\n    var layout = this; // cy is automatically populated for us in the constructor\n    // (disable eslint for next line as this serves as example layout code to external developers)\n    // eslint-disable-next-line no-unused-vars\n\n    options.cy;\n    layout.emit('layoutstart'); // puts all nodes at (0, 0)\n    // n.b. most layouts would use layoutPositions(), instead of positions() and manual events\n\n    eles.nodes().positions(function () {\n      return {\n        x: 0,\n        y: 0\n      };\n    }); // trigger layoutready when each node has had its position set at least once\n\n    layout.one('layoutready', options.ready);\n    layout.emit('layoutready'); // trigger layoutstop when the layout stops (e.g. finishes)\n\n    layout.one('layoutstop', options.stop);\n    layout.emit('layoutstop');\n    return this; // chaining\n  }; // called on continuous layouts to stop them before they finish\n\n\n  NullLayout.prototype.stop = function () {\n    return this; // chaining\n  };\n\n  var defaults$1 = {\n    positions: undefined,\n    // map of (node id) => (position obj); or function(node){ return somPos; }\n    zoom: undefined,\n    // the zoom level to set (prob want fit = false if set)\n    pan: undefined,\n    // the pan level to set (prob want fit = false if set)\n    fit: true,\n    // whether to fit to viewport\n    padding: 30,\n    // padding on fit\n    animate: false,\n    // whether to transition the node positions\n    animationDuration: 500,\n    // duration of animation in ms if enabled\n    animationEasing: undefined,\n    // easing of animation if enabled\n    animateFilter: function animateFilter(node, i) {\n      return true;\n    },\n    // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts\n    ready: undefined,\n    // callback on layoutready\n    stop: undefined,\n    // callback on layoutstop\n    transform: function transform(node, position) {\n      return position;\n    } // transform a given node position. Useful for changing flow direction in discrete layouts\n\n  };\n\n  function PresetLayout(options) {\n    this.options = extend({}, defaults$1, options);\n  }\n\n  PresetLayout.prototype.run = function () {\n    var options = this.options;\n    var eles = options.eles;\n    var nodes = eles.nodes();\n    var posIsFn = fn$6(options.positions);\n\n    function getPosition(node) {\n      if (options.positions == null) {\n        return copyPosition(node.position());\n      }\n\n      if (posIsFn) {\n        return options.positions(node);\n      }\n\n      var pos = options.positions[node._private.data.id];\n\n      if (pos == null) {\n        return null;\n      }\n\n      return pos;\n    }\n\n    nodes.layoutPositions(this, options, function (node, i) {\n      var position = getPosition(node);\n\n      if (node.locked() || position == null) {\n        return false;\n      }\n\n      return position;\n    });\n    return this; // chaining\n  };\n\n  var defaults = {\n    fit: true,\n    // whether to fit to viewport\n    padding: 30,\n    // fit padding\n    boundingBox: undefined,\n    // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n    animate: false,\n    // whether to transition the node positions\n    animationDuration: 500,\n    // duration of animation in ms if enabled\n    animationEasing: undefined,\n    // easing of animation if enabled\n    animateFilter: function animateFilter(node, i) {\n      return true;\n    },\n    // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts\n    ready: undefined,\n    // callback on layoutready\n    stop: undefined,\n    // callback on layoutstop\n    transform: function transform(node, position) {\n      return position;\n    } // transform a given node position. Useful for changing flow direction in discrete layouts \n\n  };\n\n  function RandomLayout(options) {\n    this.options = extend({}, defaults, options);\n  }\n\n  RandomLayout.prototype.run = function () {\n    var options = this.options;\n    var cy = options.cy;\n    var eles = options.eles;\n    var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {\n      x1: 0,\n      y1: 0,\n      w: cy.width(),\n      h: cy.height()\n    });\n\n    var getPos = function getPos(node, i) {\n      return {\n        x: bb.x1 + Math.round(Math.random() * bb.w),\n        y: bb.y1 + Math.round(Math.random() * bb.h)\n      };\n    };\n\n    eles.nodes().layoutPositions(this, options, getPos);\n    return this; // chaining\n  };\n\n  var layout = [{\n    name: 'breadthfirst',\n    impl: BreadthFirstLayout\n  }, {\n    name: 'circle',\n    impl: CircleLayout\n  }, {\n    name: 'concentric',\n    impl: ConcentricLayout\n  }, {\n    name: 'cose',\n    impl: CoseLayout\n  }, {\n    name: 'grid',\n    impl: GridLayout\n  }, {\n    name: 'null',\n    impl: NullLayout\n  }, {\n    name: 'preset',\n    impl: PresetLayout\n  }, {\n    name: 'random',\n    impl: RandomLayout\n  }];\n\n  function NullRenderer(options) {\n    this.options = options;\n    this.notifications = 0; // for testing\n  }\n\n  var noop = function noop() {};\n\n  var throwImgErr = function throwImgErr() {\n    throw new Error('A headless instance can not render images');\n  };\n\n  NullRenderer.prototype = {\n    recalculateRenderedStyle: noop,\n    notify: function notify() {\n      this.notifications++;\n    },\n    init: noop,\n    isHeadless: function isHeadless() {\n      return true;\n    },\n    png: throwImgErr,\n    jpg: throwImgErr\n  };\n\n  var BRp$f = {};\n  BRp$f.arrowShapeWidth = 0.3;\n\n  BRp$f.registerArrowShapes = function () {\n    var arrowShapes = this.arrowShapes = {};\n    var renderer = this; // Contract for arrow shapes:\n    // 0, 0 is arrow tip\n    // (0, 1) is direction towards node\n    // (1, 0) is right\n    //\n    // functional api:\n    // collide: check x, y in shape\n    // roughCollide: called before collide, no false negatives\n    // draw: draw\n    // spacing: dist(arrowTip, nodeBoundary)\n    // gap: dist(edgeTip, nodeBoundary), edgeTip may != arrowTip\n\n    var bbCollide = function bbCollide(x, y, size, angle, translation, edgeWidth, padding) {\n      var x1 = translation.x - size / 2 - padding;\n      var x2 = translation.x + size / 2 + padding;\n      var y1 = translation.y - size / 2 - padding;\n      var y2 = translation.y + size / 2 + padding;\n      var inside = x1 <= x && x <= x2 && y1 <= y && y <= y2;\n      return inside;\n    };\n\n    var transform = function transform(x, y, size, angle, translation) {\n      var xRotated = x * Math.cos(angle) - y * Math.sin(angle);\n      var yRotated = x * Math.sin(angle) + y * Math.cos(angle);\n      var xScaled = xRotated * size;\n      var yScaled = yRotated * size;\n      var xTranslated = xScaled + translation.x;\n      var yTranslated = yScaled + translation.y;\n      return {\n        x: xTranslated,\n        y: yTranslated\n      };\n    };\n\n    var transformPoints = function transformPoints(pts, size, angle, translation) {\n      var retPts = [];\n\n      for (var i = 0; i < pts.length; i += 2) {\n        var x = pts[i];\n        var y = pts[i + 1];\n        retPts.push(transform(x, y, size, angle, translation));\n      }\n\n      return retPts;\n    };\n\n    var pointsToArr = function pointsToArr(pts) {\n      var ret = [];\n\n      for (var i = 0; i < pts.length; i++) {\n        var p = pts[i];\n        ret.push(p.x, p.y);\n      }\n\n      return ret;\n    };\n\n    var standardGap = function standardGap(edge) {\n      return edge.pstyle('width').pfValue * edge.pstyle('arrow-scale').pfValue * 2;\n    };\n\n    var defineArrowShape = function defineArrowShape(name, defn) {\n      if (string(defn)) {\n        defn = arrowShapes[defn];\n      }\n\n      arrowShapes[name] = extend({\n        name: name,\n        points: [-0.15, -0.3, 0.15, -0.3, 0.15, 0.3, -0.15, 0.3],\n        collide: function collide(x, y, size, angle, translation, padding) {\n          var points = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));\n          var inside = pointInsidePolygonPoints(x, y, points);\n          return inside;\n        },\n        roughCollide: bbCollide,\n        draw: function draw(context, size, angle, translation) {\n          var points = transformPoints(this.points, size, angle, translation);\n          renderer.arrowShapeImpl('polygon')(context, points);\n        },\n        spacing: function spacing(edge) {\n          return 0;\n        },\n        gap: standardGap\n      }, defn);\n    };\n\n    defineArrowShape('none', {\n      collide: falsify,\n      roughCollide: falsify,\n      draw: noop$1,\n      spacing: zeroify,\n      gap: zeroify\n    });\n    defineArrowShape('triangle', {\n      points: [-0.15, -0.3, 0, 0, 0.15, -0.3]\n    });\n    defineArrowShape('arrow', 'triangle');\n    defineArrowShape('triangle-backcurve', {\n      points: arrowShapes['triangle'].points,\n      controlPoint: [0, -0.15],\n      roughCollide: bbCollide,\n      draw: function draw(context, size, angle, translation, edgeWidth) {\n        var ptsTrans = transformPoints(this.points, size, angle, translation);\n        var ctrlPt = this.controlPoint;\n        var ctrlPtTrans = transform(ctrlPt[0], ctrlPt[1], size, angle, translation);\n        renderer.arrowShapeImpl(this.name)(context, ptsTrans, ctrlPtTrans);\n      },\n      gap: function gap(edge) {\n        return standardGap(edge) * 0.8;\n      }\n    });\n    defineArrowShape('triangle-tee', {\n      points: [0, 0, 0.15, -0.3, -0.15, -0.3, 0, 0],\n      pointsTee: [-0.15, -0.4, -0.15, -0.5, 0.15, -0.5, 0.15, -0.4],\n      collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {\n        var triPts = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));\n        var teePts = pointsToArr(transformPoints(this.pointsTee, size + 2 * padding, angle, translation));\n        var inside = pointInsidePolygonPoints(x, y, triPts) || pointInsidePolygonPoints(x, y, teePts);\n        return inside;\n      },\n      draw: function draw(context, size, angle, translation, edgeWidth) {\n        var triPts = transformPoints(this.points, size, angle, translation);\n        var teePts = transformPoints(this.pointsTee, size, angle, translation);\n        renderer.arrowShapeImpl(this.name)(context, triPts, teePts);\n      }\n    });\n    defineArrowShape('circle-triangle', {\n      radius: 0.15,\n      pointsTr: [0, -0.15, 0.15, -0.45, -0.15, -0.45, 0, -0.15],\n      collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {\n        var t = translation;\n        var circleInside = Math.pow(t.x - x, 2) + Math.pow(t.y - y, 2) <= Math.pow((size + 2 * padding) * this.radius, 2);\n        var triPts = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));\n        return pointInsidePolygonPoints(x, y, triPts) || circleInside;\n      },\n      draw: function draw(context, size, angle, translation, edgeWidth) {\n        var triPts = transformPoints(this.pointsTr, size, angle, translation);\n        renderer.arrowShapeImpl(this.name)(context, triPts, translation.x, translation.y, this.radius * size);\n      },\n      spacing: function spacing(edge) {\n        return renderer.getArrowWidth(edge.pstyle('width').pfValue, edge.pstyle('arrow-scale').value) * this.radius;\n      }\n    });\n    defineArrowShape('triangle-cross', {\n      points: [0, 0, 0.15, -0.3, -0.15, -0.3, 0, 0],\n      baseCrossLinePts: [-0.15, -0.4, // first half of the rectangle\n      -0.15, -0.4, 0.15, -0.4, // second half of the rectangle\n      0.15, -0.4],\n      crossLinePts: function crossLinePts(size, edgeWidth) {\n        // shift points so that the distance between the cross points matches edge width\n        var p = this.baseCrossLinePts.slice();\n        var shiftFactor = edgeWidth / size;\n        var y0 = 3;\n        var y1 = 5;\n        p[y0] = p[y0] - shiftFactor;\n        p[y1] = p[y1] - shiftFactor;\n        return p;\n      },\n      collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {\n        var triPts = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));\n        var teePts = pointsToArr(transformPoints(this.crossLinePts(size, edgeWidth), size + 2 * padding, angle, translation));\n        var inside = pointInsidePolygonPoints(x, y, triPts) || pointInsidePolygonPoints(x, y, teePts);\n        return inside;\n      },\n      draw: function draw(context, size, angle, translation, edgeWidth) {\n        var triPts = transformPoints(this.points, size, angle, translation);\n        var crossLinePts = transformPoints(this.crossLinePts(size, edgeWidth), size, angle, translation);\n        renderer.arrowShapeImpl(this.name)(context, triPts, crossLinePts);\n      }\n    });\n    defineArrowShape('vee', {\n      points: [-0.15, -0.3, 0, 0, 0.15, -0.3, 0, -0.15],\n      gap: function gap(edge) {\n        return standardGap(edge) * 0.525;\n      }\n    });\n    defineArrowShape('circle', {\n      radius: 0.15,\n      collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {\n        var t = translation;\n        var inside = Math.pow(t.x - x, 2) + Math.pow(t.y - y, 2) <= Math.pow((size + 2 * padding) * this.radius, 2);\n        return inside;\n      },\n      draw: function draw(context, size, angle, translation, edgeWidth) {\n        renderer.arrowShapeImpl(this.name)(context, translation.x, translation.y, this.radius * size);\n      },\n      spacing: function spacing(edge) {\n        return renderer.getArrowWidth(edge.pstyle('width').pfValue, edge.pstyle('arrow-scale').value) * this.radius;\n      }\n    });\n    defineArrowShape('tee', {\n      points: [-0.15, 0, -0.15, -0.1, 0.15, -0.1, 0.15, 0],\n      spacing: function spacing(edge) {\n        return 1;\n      },\n      gap: function gap(edge) {\n        return 1;\n      }\n    });\n    defineArrowShape('square', {\n      points: [-0.15, 0.00, 0.15, 0.00, 0.15, -0.3, -0.15, -0.3]\n    });\n    defineArrowShape('diamond', {\n      points: [-0.15, -0.15, 0, -0.3, 0.15, -0.15, 0, 0],\n      gap: function gap(edge) {\n        return edge.pstyle('width').pfValue * edge.pstyle('arrow-scale').value;\n      }\n    });\n    defineArrowShape('chevron', {\n      points: [0, 0, -0.15, -0.15, -0.1, -0.2, 0, -0.1, 0.1, -0.2, 0.15, -0.15],\n      gap: function gap(edge) {\n        return 0.95 * edge.pstyle('width').pfValue * edge.pstyle('arrow-scale').value;\n      }\n    });\n  };\n\n  var BRp$e = {}; // Project mouse\n\n  BRp$e.projectIntoViewport = function (clientX, clientY) {\n    var cy = this.cy;\n    var offsets = this.findContainerClientCoords();\n    var offsetLeft = offsets[0];\n    var offsetTop = offsets[1];\n    var scale = offsets[4];\n    var pan = cy.pan();\n    var zoom = cy.zoom();\n    var x = ((clientX - offsetLeft) / scale - pan.x) / zoom;\n    var y = ((clientY - offsetTop) / scale - pan.y) / zoom;\n    return [x, y];\n  };\n\n  BRp$e.findContainerClientCoords = function () {\n    if (this.containerBB) {\n      return this.containerBB;\n    }\n\n    var container = this.container;\n    var rect = container.getBoundingClientRect();\n    var style = window$1.getComputedStyle(container);\n\n    var styleValue = function styleValue(name) {\n      return parseFloat(style.getPropertyValue(name));\n    };\n\n    var padding = {\n      left: styleValue('padding-left'),\n      right: styleValue('padding-right'),\n      top: styleValue('padding-top'),\n      bottom: styleValue('padding-bottom')\n    };\n    var border = {\n      left: styleValue('border-left-width'),\n      right: styleValue('border-right-width'),\n      top: styleValue('border-top-width'),\n      bottom: styleValue('border-bottom-width')\n    };\n    var clientWidth = container.clientWidth;\n    var clientHeight = container.clientHeight;\n    var paddingHor = padding.left + padding.right;\n    var paddingVer = padding.top + padding.bottom;\n    var borderHor = border.left + border.right;\n    var scale = rect.width / (clientWidth + borderHor);\n    var unscaledW = clientWidth - paddingHor;\n    var unscaledH = clientHeight - paddingVer;\n    var left = rect.left + padding.left + border.left;\n    var top = rect.top + padding.top + border.top;\n    return this.containerBB = [left, top, unscaledW, unscaledH, scale];\n  };\n\n  BRp$e.invalidateContainerClientCoordsCache = function () {\n    this.containerBB = null;\n  };\n\n  BRp$e.findNearestElement = function (x, y, interactiveElementsOnly, isTouch) {\n    return this.findNearestElements(x, y, interactiveElementsOnly, isTouch)[0];\n  };\n\n  BRp$e.findNearestElements = function (x, y, interactiveElementsOnly, isTouch) {\n    var self = this;\n    var r = this;\n    var eles = r.getCachedZSortedEles();\n    var near = []; // 1 node max, 1 edge max\n\n    var zoom = r.cy.zoom();\n    var hasCompounds = r.cy.hasCompoundNodes();\n    var edgeThreshold = (isTouch ? 24 : 8) / zoom;\n    var nodeThreshold = (isTouch ? 8 : 2) / zoom;\n    var labelThreshold = (isTouch ? 8 : 2) / zoom;\n    var minSqDist = Infinity;\n    var nearEdge;\n    var nearNode;\n\n    if (interactiveElementsOnly) {\n      eles = eles.interactive;\n    }\n\n    function addEle(ele, sqDist) {\n      if (ele.isNode()) {\n        if (nearNode) {\n          return; // can't replace node\n        } else {\n          nearNode = ele;\n          near.push(ele);\n        }\n      }\n\n      if (ele.isEdge() && (sqDist == null || sqDist < minSqDist)) {\n        if (nearEdge) {\n          // then replace existing edge\n          // can replace only if same z-index\n          if (nearEdge.pstyle('z-compound-depth').value === ele.pstyle('z-compound-depth').value && nearEdge.pstyle('z-compound-depth').value === ele.pstyle('z-compound-depth').value) {\n            for (var i = 0; i < near.length; i++) {\n              if (near[i].isEdge()) {\n                near[i] = ele;\n                nearEdge = ele;\n                minSqDist = sqDist != null ? sqDist : minSqDist;\n                break;\n              }\n            }\n          }\n        } else {\n          near.push(ele);\n          nearEdge = ele;\n          minSqDist = sqDist != null ? sqDist : minSqDist;\n        }\n      }\n    }\n\n    function checkNode(node) {\n      var width = node.outerWidth() + 2 * nodeThreshold;\n      var height = node.outerHeight() + 2 * nodeThreshold;\n      var hw = width / 2;\n      var hh = height / 2;\n      var pos = node.position();\n\n      if (pos.x - hw <= x && x <= pos.x + hw // bb check x\n      && pos.y - hh <= y && y <= pos.y + hh // bb check y\n      ) {\n        var shape = r.nodeShapes[self.getNodeShape(node)];\n\n        if (shape.checkPoint(x, y, 0, width, height, pos.x, pos.y)) {\n          addEle(node, 0);\n          return true;\n        }\n      }\n    }\n\n    function checkEdge(edge) {\n      var _p = edge._private;\n      var rs = _p.rscratch;\n      var styleWidth = edge.pstyle('width').pfValue;\n      var scale = edge.pstyle('arrow-scale').value;\n      var width = styleWidth / 2 + edgeThreshold; // more like a distance radius from centre\n\n      var widthSq = width * width;\n      var width2 = width * 2;\n      var src = _p.source;\n      var tgt = _p.target;\n      var sqDist;\n\n      if (rs.edgeType === 'segments' || rs.edgeType === 'straight' || rs.edgeType === 'haystack') {\n        var pts = rs.allpts;\n\n        for (var i = 0; i + 3 < pts.length; i += 2) {\n          if (inLineVicinity(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3], width2) && widthSq > (sqDist = sqdistToFiniteLine(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3]))) {\n            addEle(edge, sqDist);\n            return true;\n          }\n        }\n      } else if (rs.edgeType === 'bezier' || rs.edgeType === 'multibezier' || rs.edgeType === 'self' || rs.edgeType === 'compound') {\n        var pts = rs.allpts;\n\n        for (var i = 0; i + 5 < rs.allpts.length; i += 4) {\n          if (inBezierVicinity(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3], pts[i + 4], pts[i + 5], width2) && widthSq > (sqDist = sqdistToQuadraticBezier(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3], pts[i + 4], pts[i + 5]))) {\n            addEle(edge, sqDist);\n            return true;\n          }\n        }\n      } // if we're close to the edge but didn't hit it, maybe we hit its arrows\n\n\n      var src = src || _p.source;\n      var tgt = tgt || _p.target;\n      var arSize = self.getArrowWidth(styleWidth, scale);\n      var arrows = [{\n        name: 'source',\n        x: rs.arrowStartX,\n        y: rs.arrowStartY,\n        angle: rs.srcArrowAngle\n      }, {\n        name: 'target',\n        x: rs.arrowEndX,\n        y: rs.arrowEndY,\n        angle: rs.tgtArrowAngle\n      }, {\n        name: 'mid-source',\n        x: rs.midX,\n        y: rs.midY,\n        angle: rs.midsrcArrowAngle\n      }, {\n        name: 'mid-target',\n        x: rs.midX,\n        y: rs.midY,\n        angle: rs.midtgtArrowAngle\n      }];\n\n      for (var i = 0; i < arrows.length; i++) {\n        var ar = arrows[i];\n        var shape = r.arrowShapes[edge.pstyle(ar.name + '-arrow-shape').value];\n        var edgeWidth = edge.pstyle('width').pfValue;\n\n        if (shape.roughCollide(x, y, arSize, ar.angle, {\n          x: ar.x,\n          y: ar.y\n        }, edgeWidth, edgeThreshold) && shape.collide(x, y, arSize, ar.angle, {\n          x: ar.x,\n          y: ar.y\n        }, edgeWidth, edgeThreshold)) {\n          addEle(edge);\n          return true;\n        }\n      } // for compound graphs, hitting edge may actually want a connected node instead (b/c edge may have greater z-index precedence)\n\n\n      if (hasCompounds && near.length > 0) {\n        checkNode(src);\n        checkNode(tgt);\n      }\n    }\n\n    function preprop(obj, name, pre) {\n      return getPrefixedProperty(obj, name, pre);\n    }\n\n    function checkLabel(ele, prefix) {\n      var _p = ele._private;\n      var th = labelThreshold;\n      var prefixDash;\n\n      if (prefix) {\n        prefixDash = prefix + '-';\n      } else {\n        prefixDash = '';\n      }\n\n      ele.boundingBox();\n      var bb = _p.labelBounds[prefix || 'main'];\n      var text = ele.pstyle(prefixDash + 'label').value;\n      var eventsEnabled = ele.pstyle('text-events').strValue === 'yes';\n\n      if (!eventsEnabled || !text) {\n        return;\n      }\n\n      var lx = preprop(_p.rscratch, 'labelX', prefix);\n      var ly = preprop(_p.rscratch, 'labelY', prefix);\n      var theta = preprop(_p.rscratch, 'labelAngle', prefix);\n      var ox = ele.pstyle(prefixDash + 'text-margin-x').pfValue;\n      var oy = ele.pstyle(prefixDash + 'text-margin-y').pfValue;\n      var lx1 = bb.x1 - th - ox; // (-ox, -oy) as bb already includes margin\n\n      var lx2 = bb.x2 + th - ox; // and rotation is about (lx, ly)\n\n      var ly1 = bb.y1 - th - oy;\n      var ly2 = bb.y2 + th - oy;\n\n      if (theta) {\n        var cos = Math.cos(theta);\n        var sin = Math.sin(theta);\n\n        var rotate = function rotate(x, y) {\n          x = x - lx;\n          y = y - ly;\n          return {\n            x: x * cos - y * sin + lx,\n            y: x * sin + y * cos + ly\n          };\n        };\n\n        var px1y1 = rotate(lx1, ly1);\n        var px1y2 = rotate(lx1, ly2);\n        var px2y1 = rotate(lx2, ly1);\n        var px2y2 = rotate(lx2, ly2);\n        var points = [// with the margin added after the rotation is applied\n        px1y1.x + ox, px1y1.y + oy, px2y1.x + ox, px2y1.y + oy, px2y2.x + ox, px2y2.y + oy, px1y2.x + ox, px1y2.y + oy];\n\n        if (pointInsidePolygonPoints(x, y, points)) {\n          addEle(ele);\n          return true;\n        }\n      } else {\n        // do a cheaper bb check\n        if (inBoundingBox(bb, x, y)) {\n          addEle(ele);\n          return true;\n        }\n      }\n    }\n\n    for (var i = eles.length - 1; i >= 0; i--) {\n      // reverse order for precedence\n      var ele = eles[i];\n\n      if (ele.isNode()) {\n        checkNode(ele) || checkLabel(ele);\n      } else {\n        // then edge\n        checkEdge(ele) || checkLabel(ele) || checkLabel(ele, 'source') || checkLabel(ele, 'target');\n      }\n    }\n\n    return near;\n  }; // 'Give me everything from this box'\n\n\n  BRp$e.getAllInBox = function (x1, y1, x2, y2) {\n    var eles = this.getCachedZSortedEles().interactive;\n    var box = [];\n    var x1c = Math.min(x1, x2);\n    var x2c = Math.max(x1, x2);\n    var y1c = Math.min(y1, y2);\n    var y2c = Math.max(y1, y2);\n    x1 = x1c;\n    x2 = x2c;\n    y1 = y1c;\n    y2 = y2c;\n    var boxBb = makeBoundingBox({\n      x1: x1,\n      y1: y1,\n      x2: x2,\n      y2: y2\n    });\n\n    for (var e = 0; e < eles.length; e++) {\n      var ele = eles[e];\n\n      if (ele.isNode()) {\n        var node = ele;\n        var nodeBb = node.boundingBox({\n          includeNodes: true,\n          includeEdges: false,\n          includeLabels: false\n        });\n\n        if (boundingBoxesIntersect(boxBb, nodeBb) && !boundingBoxInBoundingBox(nodeBb, boxBb)) {\n          box.push(node);\n        }\n      } else {\n        var edge = ele;\n        var _p = edge._private;\n        var rs = _p.rscratch;\n\n        if (rs.startX != null && rs.startY != null && !inBoundingBox(boxBb, rs.startX, rs.startY)) {\n          continue;\n        }\n\n        if (rs.endX != null && rs.endY != null && !inBoundingBox(boxBb, rs.endX, rs.endY)) {\n          continue;\n        }\n\n        if (rs.edgeType === 'bezier' || rs.edgeType === 'multibezier' || rs.edgeType === 'self' || rs.edgeType === 'compound' || rs.edgeType === 'segments' || rs.edgeType === 'haystack') {\n          var pts = _p.rstyle.bezierPts || _p.rstyle.linePts || _p.rstyle.haystackPts;\n          var allInside = true;\n\n          for (var i = 0; i < pts.length; i++) {\n            if (!pointInBoundingBox(boxBb, pts[i])) {\n              allInside = false;\n              break;\n            }\n          }\n\n          if (allInside) {\n            box.push(edge);\n          }\n        } else if (rs.edgeType === 'haystack' || rs.edgeType === 'straight') {\n          box.push(edge);\n        }\n      }\n    }\n\n    return box;\n  };\n\n  var BRp$d = {};\n\n  BRp$d.calculateArrowAngles = function (edge) {\n    var rs = edge._private.rscratch;\n    var isHaystack = rs.edgeType === 'haystack';\n    var isBezier = rs.edgeType === 'bezier';\n    var isMultibezier = rs.edgeType === 'multibezier';\n    var isSegments = rs.edgeType === 'segments';\n    var isCompound = rs.edgeType === 'compound';\n    var isSelf = rs.edgeType === 'self'; // Displacement gives direction for arrowhead orientation\n\n    var dispX, dispY;\n    var startX, startY, endX, endY, midX, midY;\n\n    if (isHaystack) {\n      startX = rs.haystackPts[0];\n      startY = rs.haystackPts[1];\n      endX = rs.haystackPts[2];\n      endY = rs.haystackPts[3];\n    } else {\n      startX = rs.arrowStartX;\n      startY = rs.arrowStartY;\n      endX = rs.arrowEndX;\n      endY = rs.arrowEndY;\n    }\n\n    midX = rs.midX;\n    midY = rs.midY; // source\n    //\n\n    if (isSegments) {\n      dispX = startX - rs.segpts[0];\n      dispY = startY - rs.segpts[1];\n    } else if (isMultibezier || isCompound || isSelf || isBezier) {\n      var pts = rs.allpts;\n      var bX = qbezierAt(pts[0], pts[2], pts[4], 0.1);\n      var bY = qbezierAt(pts[1], pts[3], pts[5], 0.1);\n      dispX = startX - bX;\n      dispY = startY - bY;\n    } else {\n      dispX = startX - midX;\n      dispY = startY - midY;\n    }\n\n    rs.srcArrowAngle = getAngleFromDisp(dispX, dispY); // mid target\n    //\n\n    var midX = rs.midX;\n    var midY = rs.midY;\n\n    if (isHaystack) {\n      midX = (startX + endX) / 2;\n      midY = (startY + endY) / 2;\n    }\n\n    dispX = endX - startX;\n    dispY = endY - startY;\n\n    if (isSegments) {\n      var pts = rs.allpts;\n\n      if (pts.length / 2 % 2 === 0) {\n        var i2 = pts.length / 2;\n        var i1 = i2 - 2;\n        dispX = pts[i2] - pts[i1];\n        dispY = pts[i2 + 1] - pts[i1 + 1];\n      } else {\n        var i2 = pts.length / 2 - 1;\n        var i1 = i2 - 2;\n        var i3 = i2 + 2;\n        dispX = pts[i2] - pts[i1];\n        dispY = pts[i2 + 1] - pts[i1 + 1];\n      }\n    } else if (isMultibezier || isCompound || isSelf) {\n      var pts = rs.allpts;\n      var cpts = rs.ctrlpts;\n      var bp0x, bp0y;\n      var bp1x, bp1y;\n\n      if (cpts.length / 2 % 2 === 0) {\n        var p0 = pts.length / 2 - 1; // startpt\n\n        var ic = p0 + 2;\n        var p1 = ic + 2;\n        bp0x = qbezierAt(pts[p0], pts[ic], pts[p1], 0.0);\n        bp0y = qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.0);\n        bp1x = qbezierAt(pts[p0], pts[ic], pts[p1], 0.0001);\n        bp1y = qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.0001);\n      } else {\n        var ic = pts.length / 2 - 1; // ctrpt\n\n        var p0 = ic - 2; // startpt\n\n        var p1 = ic + 2; // endpt\n\n        bp0x = qbezierAt(pts[p0], pts[ic], pts[p1], 0.4999);\n        bp0y = qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.4999);\n        bp1x = qbezierAt(pts[p0], pts[ic], pts[p1], 0.5);\n        bp1y = qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.5);\n      }\n\n      dispX = bp1x - bp0x;\n      dispY = bp1y - bp0y;\n    }\n\n    rs.midtgtArrowAngle = getAngleFromDisp(dispX, dispY);\n    rs.midDispX = dispX;\n    rs.midDispY = dispY; // mid source\n    //\n\n    dispX *= -1;\n    dispY *= -1;\n\n    if (isSegments) {\n      var pts = rs.allpts;\n\n      if (pts.length / 2 % 2 === 0) ; else {\n        var i2 = pts.length / 2 - 1;\n        var i3 = i2 + 2;\n        dispX = -(pts[i3] - pts[i2]);\n        dispY = -(pts[i3 + 1] - pts[i2 + 1]);\n      }\n    }\n\n    rs.midsrcArrowAngle = getAngleFromDisp(dispX, dispY); // target\n    //\n\n    if (isSegments) {\n      dispX = endX - rs.segpts[rs.segpts.length - 2];\n      dispY = endY - rs.segpts[rs.segpts.length - 1];\n    } else if (isMultibezier || isCompound || isSelf || isBezier) {\n      var pts = rs.allpts;\n      var l = pts.length;\n      var bX = qbezierAt(pts[l - 6], pts[l - 4], pts[l - 2], 0.9);\n      var bY = qbezierAt(pts[l - 5], pts[l - 3], pts[l - 1], 0.9);\n      dispX = endX - bX;\n      dispY = endY - bY;\n    } else {\n      dispX = endX - midX;\n      dispY = endY - midY;\n    }\n\n    rs.tgtArrowAngle = getAngleFromDisp(dispX, dispY);\n  };\n\n  BRp$d.getArrowWidth = BRp$d.getArrowHeight = function (edgeWidth, scale) {\n    var cache = this.arrowWidthCache = this.arrowWidthCache || {};\n    var cachedVal = cache[edgeWidth + ', ' + scale];\n\n    if (cachedVal) {\n      return cachedVal;\n    }\n\n    cachedVal = Math.max(Math.pow(edgeWidth * 13.37, 0.9), 29) * scale;\n    cache[edgeWidth + ', ' + scale] = cachedVal;\n    return cachedVal;\n  };\n\n  var BRp$c = {};\n\n  BRp$c.findHaystackPoints = function (edges) {\n    for (var i = 0; i < edges.length; i++) {\n      var edge = edges[i];\n      var _p = edge._private;\n      var rs = _p.rscratch;\n\n      if (!rs.haystack) {\n        var angle = Math.random() * 2 * Math.PI;\n        rs.source = {\n          x: Math.cos(angle),\n          y: Math.sin(angle)\n        };\n        angle = Math.random() * 2 * Math.PI;\n        rs.target = {\n          x: Math.cos(angle),\n          y: Math.sin(angle)\n        };\n      }\n\n      var src = _p.source;\n      var tgt = _p.target;\n      var srcPos = src.position();\n      var tgtPos = tgt.position();\n      var srcW = src.width();\n      var tgtW = tgt.width();\n      var srcH = src.height();\n      var tgtH = tgt.height();\n      var radius = edge.pstyle('haystack-radius').value;\n      var halfRadius = radius / 2; // b/c have to half width/height\n\n      rs.haystackPts = rs.allpts = [rs.source.x * srcW * halfRadius + srcPos.x, rs.source.y * srcH * halfRadius + srcPos.y, rs.target.x * tgtW * halfRadius + tgtPos.x, rs.target.y * tgtH * halfRadius + tgtPos.y];\n      rs.midX = (rs.allpts[0] + rs.allpts[2]) / 2;\n      rs.midY = (rs.allpts[1] + rs.allpts[3]) / 2; // always override as haystack in case set to different type previously\n\n      rs.edgeType = 'haystack';\n      rs.haystack = true;\n      this.storeEdgeProjections(edge);\n      this.calculateArrowAngles(edge);\n      this.recalculateEdgeLabelProjections(edge);\n      this.calculateLabelAngles(edge);\n    }\n  };\n\n  BRp$c.findSegmentsPoints = function (edge, pairInfo) {\n    // Segments (multiple straight lines)\n    var rs = edge._private.rscratch;\n    var posPts = pairInfo.posPts,\n        intersectionPts = pairInfo.intersectionPts,\n        vectorNormInverse = pairInfo.vectorNormInverse;\n    var edgeDistances = edge.pstyle('edge-distances').value;\n    var segmentWs = edge.pstyle('segment-weights');\n    var segmentDs = edge.pstyle('segment-distances');\n    var segmentsN = Math.min(segmentWs.pfValue.length, segmentDs.pfValue.length);\n    rs.edgeType = 'segments';\n    rs.segpts = [];\n\n    for (var s = 0; s < segmentsN; s++) {\n      var w = segmentWs.pfValue[s];\n      var d = segmentDs.pfValue[s];\n      var w1 = 1 - w;\n      var w2 = w;\n      var midptPts = edgeDistances === 'node-position' ? posPts : intersectionPts;\n      var adjustedMidpt = {\n        x: midptPts.x1 * w1 + midptPts.x2 * w2,\n        y: midptPts.y1 * w1 + midptPts.y2 * w2\n      };\n      rs.segpts.push(adjustedMidpt.x + vectorNormInverse.x * d, adjustedMidpt.y + vectorNormInverse.y * d);\n    }\n  };\n\n  BRp$c.findLoopPoints = function (edge, pairInfo, i, edgeIsUnbundled) {\n    // Self-edge\n    var rs = edge._private.rscratch;\n    var dirCounts = pairInfo.dirCounts,\n        srcPos = pairInfo.srcPos;\n    var ctrlptDists = edge.pstyle('control-point-distances');\n    var ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[0] : undefined;\n    var loopDir = edge.pstyle('loop-direction').pfValue;\n    var loopSwp = edge.pstyle('loop-sweep').pfValue;\n    var stepSize = edge.pstyle('control-point-step-size').pfValue;\n    rs.edgeType = 'self';\n    var j = i;\n    var loopDist = stepSize;\n\n    if (edgeIsUnbundled) {\n      j = 0;\n      loopDist = ctrlptDist;\n    }\n\n    var loopAngle = loopDir - Math.PI / 2;\n    var outAngle = loopAngle - loopSwp / 2;\n    var inAngle = loopAngle + loopSwp / 2; // increase by step size for overlapping loops, keyed on direction and sweep values\n\n    var dc = String(loopDir + '_' + loopSwp);\n    j = dirCounts[dc] === undefined ? dirCounts[dc] = 0 : ++dirCounts[dc];\n    rs.ctrlpts = [srcPos.x + Math.cos(outAngle) * 1.4 * loopDist * (j / 3 + 1), srcPos.y + Math.sin(outAngle) * 1.4 * loopDist * (j / 3 + 1), srcPos.x + Math.cos(inAngle) * 1.4 * loopDist * (j / 3 + 1), srcPos.y + Math.sin(inAngle) * 1.4 * loopDist * (j / 3 + 1)];\n  };\n\n  BRp$c.findCompoundLoopPoints = function (edge, pairInfo, i, edgeIsUnbundled) {\n    // Compound edge\n    var rs = edge._private.rscratch;\n    rs.edgeType = 'compound';\n    var srcPos = pairInfo.srcPos,\n        tgtPos = pairInfo.tgtPos,\n        srcW = pairInfo.srcW,\n        srcH = pairInfo.srcH,\n        tgtW = pairInfo.tgtW,\n        tgtH = pairInfo.tgtH;\n    var stepSize = edge.pstyle('control-point-step-size').pfValue;\n    var ctrlptDists = edge.pstyle('control-point-distances');\n    var ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[0] : undefined;\n    var j = i;\n    var loopDist = stepSize;\n\n    if (edgeIsUnbundled) {\n      j = 0;\n      loopDist = ctrlptDist;\n    }\n\n    var loopW = 50;\n    var loopaPos = {\n      x: srcPos.x - srcW / 2,\n      y: srcPos.y - srcH / 2\n    };\n    var loopbPos = {\n      x: tgtPos.x - tgtW / 2,\n      y: tgtPos.y - tgtH / 2\n    };\n    var loopPos = {\n      x: Math.min(loopaPos.x, loopbPos.x),\n      y: Math.min(loopaPos.y, loopbPos.y)\n    }; // avoids cases with impossible beziers\n\n    var minCompoundStretch = 0.5;\n    var compoundStretchA = Math.max(minCompoundStretch, Math.log(srcW * 0.01));\n    var compoundStretchB = Math.max(minCompoundStretch, Math.log(tgtW * 0.01));\n    rs.ctrlpts = [loopPos.x, loopPos.y - (1 + Math.pow(loopW, 1.12) / 100) * loopDist * (j / 3 + 1) * compoundStretchA, loopPos.x - (1 + Math.pow(loopW, 1.12) / 100) * loopDist * (j / 3 + 1) * compoundStretchB, loopPos.y];\n  };\n\n  BRp$c.findStraightEdgePoints = function (edge) {\n    // Straight edge within bundle\n    edge._private.rscratch.edgeType = 'straight';\n  };\n\n  BRp$c.findBezierPoints = function (edge, pairInfo, i, edgeIsUnbundled, edgeIsSwapped) {\n    var rs = edge._private.rscratch;\n    var vectorNormInverse = pairInfo.vectorNormInverse,\n        posPts = pairInfo.posPts,\n        intersectionPts = pairInfo.intersectionPts;\n    var edgeDistances = edge.pstyle('edge-distances').value;\n    var stepSize = edge.pstyle('control-point-step-size').pfValue;\n    var ctrlptDists = edge.pstyle('control-point-distances');\n    var ctrlptWs = edge.pstyle('control-point-weights');\n    var bezierN = ctrlptDists && ctrlptWs ? Math.min(ctrlptDists.value.length, ctrlptWs.value.length) : 1;\n    var ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[0] : undefined;\n    var ctrlptWeight = ctrlptWs.value[0]; // (Multi)bezier\n\n    var multi = edgeIsUnbundled;\n    rs.edgeType = multi ? 'multibezier' : 'bezier';\n    rs.ctrlpts = [];\n\n    for (var b = 0; b < bezierN; b++) {\n      var normctrlptDist = (0.5 - pairInfo.eles.length / 2 + i) * stepSize * (edgeIsSwapped ? -1 : 1);\n      var manctrlptDist = void 0;\n      var sign = signum(normctrlptDist);\n\n      if (multi) {\n        ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[b] : stepSize; // fall back on step size\n\n        ctrlptWeight = ctrlptWs.value[b];\n      }\n\n      if (edgeIsUnbundled) {\n        // multi or single unbundled\n        manctrlptDist = ctrlptDist;\n      } else {\n        manctrlptDist = ctrlptDist !== undefined ? sign * ctrlptDist : undefined;\n      }\n\n      var distanceFromMidpoint = manctrlptDist !== undefined ? manctrlptDist : normctrlptDist;\n      var w1 = 1 - ctrlptWeight;\n      var w2 = ctrlptWeight;\n      var midptPts = edgeDistances === 'node-position' ? posPts : intersectionPts;\n      var adjustedMidpt = {\n        x: midptPts.x1 * w1 + midptPts.x2 * w2,\n        y: midptPts.y1 * w1 + midptPts.y2 * w2\n      };\n      rs.ctrlpts.push(adjustedMidpt.x + vectorNormInverse.x * distanceFromMidpoint, adjustedMidpt.y + vectorNormInverse.y * distanceFromMidpoint);\n    }\n  };\n\n  BRp$c.findTaxiPoints = function (edge, pairInfo) {\n    // Taxicab geometry with two turns maximum\n    var rs = edge._private.rscratch;\n    rs.edgeType = 'segments';\n    var VERTICAL = 'vertical';\n    var HORIZONTAL = 'horizontal';\n    var LEFTWARD = 'leftward';\n    var RIGHTWARD = 'rightward';\n    var DOWNWARD = 'downward';\n    var UPWARD = 'upward';\n    var AUTO = 'auto';\n    var posPts = pairInfo.posPts,\n        srcW = pairInfo.srcW,\n        srcH = pairInfo.srcH,\n        tgtW = pairInfo.tgtW,\n        tgtH = pairInfo.tgtH;\n    var edgeDistances = edge.pstyle('edge-distances').value;\n    var dIncludesNodeBody = edgeDistances !== 'node-position';\n    var taxiDir = edge.pstyle('taxi-direction').value;\n    var rawTaxiDir = taxiDir; // unprocessed value\n\n    var taxiTurn = edge.pstyle('taxi-turn');\n    var turnIsPercent = taxiTurn.units === '%';\n    var taxiTurnPfVal = taxiTurn.pfValue;\n    var turnIsNegative = taxiTurnPfVal < 0; // i.e. from target side\n\n    var minD = edge.pstyle('taxi-turn-min-distance').pfValue;\n    var dw = dIncludesNodeBody ? (srcW + tgtW) / 2 : 0;\n    var dh = dIncludesNodeBody ? (srcH + tgtH) / 2 : 0;\n    var pdx = posPts.x2 - posPts.x1;\n    var pdy = posPts.y2 - posPts.y1; // take away the effective w/h from the magnitude of the delta value\n\n    var subDWH = function subDWH(dxy, dwh) {\n      if (dxy > 0) {\n        return Math.max(dxy - dwh, 0);\n      } else {\n        return Math.min(dxy + dwh, 0);\n      }\n    };\n\n    var dx = subDWH(pdx, dw);\n    var dy = subDWH(pdy, dh);\n    var isExplicitDir = false;\n\n    if (rawTaxiDir === AUTO) {\n      taxiDir = Math.abs(dx) > Math.abs(dy) ? HORIZONTAL : VERTICAL;\n    } else if (rawTaxiDir === UPWARD || rawTaxiDir === DOWNWARD) {\n      taxiDir = VERTICAL;\n      isExplicitDir = true;\n    } else if (rawTaxiDir === LEFTWARD || rawTaxiDir === RIGHTWARD) {\n      taxiDir = HORIZONTAL;\n      isExplicitDir = true;\n    }\n\n    var isVert = taxiDir === VERTICAL;\n    var l = isVert ? dy : dx;\n    var pl = isVert ? pdy : pdx;\n    var sgnL = signum(pl);\n    var forcedDir = false;\n\n    if (!(isExplicitDir && (turnIsPercent || turnIsNegative)) // forcing in this case would cause weird growing in the opposite direction\n    && (rawTaxiDir === DOWNWARD && pl < 0 || rawTaxiDir === UPWARD && pl > 0 || rawTaxiDir === LEFTWARD && pl > 0 || rawTaxiDir === RIGHTWARD && pl < 0)) {\n      sgnL *= -1;\n      l = sgnL * Math.abs(l);\n      forcedDir = true;\n    }\n\n    var d;\n\n    if (turnIsPercent) {\n      var p = taxiTurnPfVal < 0 ? 1 + taxiTurnPfVal : taxiTurnPfVal;\n      d = p * l;\n    } else {\n      var k = taxiTurnPfVal < 0 ? l : 0;\n      d = k + taxiTurnPfVal * sgnL;\n    }\n\n    var getIsTooClose = function getIsTooClose(d) {\n      return Math.abs(d) < minD || Math.abs(d) >= Math.abs(l);\n    };\n\n    var isTooCloseSrc = getIsTooClose(d);\n    var isTooCloseTgt = getIsTooClose(Math.abs(l) - Math.abs(d));\n    var isTooClose = isTooCloseSrc || isTooCloseTgt;\n\n    if (isTooClose && !forcedDir) {\n      // non-ideal routing\n      if (isVert) {\n        // vertical fallbacks\n        var lShapeInsideSrc = Math.abs(pl) <= srcH / 2;\n        var lShapeInsideTgt = Math.abs(pdx) <= tgtW / 2;\n\n        if (lShapeInsideSrc) {\n          // horizontal Z-shape (direction not respected)\n          var x = (posPts.x1 + posPts.x2) / 2;\n          var y1 = posPts.y1,\n              y2 = posPts.y2;\n          rs.segpts = [x, y1, x, y2];\n        } else if (lShapeInsideTgt) {\n          // vertical Z-shape (distance not respected)\n          var y = (posPts.y1 + posPts.y2) / 2;\n          var x1 = posPts.x1,\n              x2 = posPts.x2;\n          rs.segpts = [x1, y, x2, y];\n        } else {\n          // L-shape fallback (turn distance not respected, but works well with tree siblings)\n          rs.segpts = [posPts.x1, posPts.y2];\n        }\n      } else {\n        // horizontal fallbacks\n        var _lShapeInsideSrc = Math.abs(pl) <= srcW / 2;\n\n        var _lShapeInsideTgt = Math.abs(pdy) <= tgtH / 2;\n\n        if (_lShapeInsideSrc) {\n          // vertical Z-shape (direction not respected)\n          var _y = (posPts.y1 + posPts.y2) / 2;\n\n          var _x = posPts.x1,\n              _x2 = posPts.x2;\n          rs.segpts = [_x, _y, _x2, _y];\n        } else if (_lShapeInsideTgt) {\n          // horizontal Z-shape (turn distance not respected)\n          var _x3 = (posPts.x1 + posPts.x2) / 2;\n\n          var _y2 = posPts.y1,\n              _y3 = posPts.y2;\n          rs.segpts = [_x3, _y2, _x3, _y3];\n        } else {\n          // L-shape (turn distance not respected, but works well for tree siblings)\n          rs.segpts = [posPts.x2, posPts.y1];\n        }\n      }\n    } else {\n      // ideal routing\n      if (isVert) {\n        var _y4 = posPts.y1 + d + (dIncludesNodeBody ? srcH / 2 * sgnL : 0);\n\n        var _x4 = posPts.x1,\n            _x5 = posPts.x2;\n        rs.segpts = [_x4, _y4, _x5, _y4];\n      } else {\n        // horizontal\n        var _x6 = posPts.x1 + d + (dIncludesNodeBody ? srcW / 2 * sgnL : 0);\n\n        var _y5 = posPts.y1,\n            _y6 = posPts.y2;\n        rs.segpts = [_x6, _y5, _x6, _y6];\n      }\n    }\n  };\n\n  BRp$c.tryToCorrectInvalidPoints = function (edge, pairInfo) {\n    var rs = edge._private.rscratch; // can only correct beziers for now...\n\n    if (rs.edgeType === 'bezier') {\n      var srcPos = pairInfo.srcPos,\n          tgtPos = pairInfo.tgtPos,\n          srcW = pairInfo.srcW,\n          srcH = pairInfo.srcH,\n          tgtW = pairInfo.tgtW,\n          tgtH = pairInfo.tgtH,\n          srcShape = pairInfo.srcShape,\n          tgtShape = pairInfo.tgtShape;\n      var badStart = !number$1(rs.startX) || !number$1(rs.startY);\n      var badAStart = !number$1(rs.arrowStartX) || !number$1(rs.arrowStartY);\n      var badEnd = !number$1(rs.endX) || !number$1(rs.endY);\n      var badAEnd = !number$1(rs.arrowEndX) || !number$1(rs.arrowEndY);\n      var minCpADistFactor = 3;\n      var arrowW = this.getArrowWidth(edge.pstyle('width').pfValue, edge.pstyle('arrow-scale').value) * this.arrowShapeWidth;\n      var minCpADist = minCpADistFactor * arrowW;\n      var startACpDist = dist({\n        x: rs.ctrlpts[0],\n        y: rs.ctrlpts[1]\n      }, {\n        x: rs.startX,\n        y: rs.startY\n      });\n      var closeStartACp = startACpDist < minCpADist;\n      var endACpDist = dist({\n        x: rs.ctrlpts[0],\n        y: rs.ctrlpts[1]\n      }, {\n        x: rs.endX,\n        y: rs.endY\n      });\n      var closeEndACp = endACpDist < minCpADist;\n      var overlapping = false;\n\n      if (badStart || badAStart || closeStartACp) {\n        overlapping = true; // project control point along line from src centre to outside the src shape\n        // (otherwise intersection will yield nothing)\n\n        var cpD = {\n          // delta\n          x: rs.ctrlpts[0] - srcPos.x,\n          y: rs.ctrlpts[1] - srcPos.y\n        };\n        var cpL = Math.sqrt(cpD.x * cpD.x + cpD.y * cpD.y); // length of line\n\n        var cpM = {\n          // normalised delta\n          x: cpD.x / cpL,\n          y: cpD.y / cpL\n        };\n        var radius = Math.max(srcW, srcH);\n        var cpProj = {\n          // *2 radius guarantees outside shape\n          x: rs.ctrlpts[0] + cpM.x * 2 * radius,\n          y: rs.ctrlpts[1] + cpM.y * 2 * radius\n        };\n        var srcCtrlPtIntn = srcShape.intersectLine(srcPos.x, srcPos.y, srcW, srcH, cpProj.x, cpProj.y, 0);\n\n        if (closeStartACp) {\n          rs.ctrlpts[0] = rs.ctrlpts[0] + cpM.x * (minCpADist - startACpDist);\n          rs.ctrlpts[1] = rs.ctrlpts[1] + cpM.y * (minCpADist - startACpDist);\n        } else {\n          rs.ctrlpts[0] = srcCtrlPtIntn[0] + cpM.x * minCpADist;\n          rs.ctrlpts[1] = srcCtrlPtIntn[1] + cpM.y * minCpADist;\n        }\n      }\n\n      if (badEnd || badAEnd || closeEndACp) {\n        overlapping = true; // project control point along line from tgt centre to outside the tgt shape\n        // (otherwise intersection will yield nothing)\n\n        var _cpD = {\n          // delta\n          x: rs.ctrlpts[0] - tgtPos.x,\n          y: rs.ctrlpts[1] - tgtPos.y\n        };\n\n        var _cpL = Math.sqrt(_cpD.x * _cpD.x + _cpD.y * _cpD.y); // length of line\n\n\n        var _cpM = {\n          // normalised delta\n          x: _cpD.x / _cpL,\n          y: _cpD.y / _cpL\n        };\n\n        var _radius = Math.max(srcW, srcH);\n\n        var _cpProj = {\n          // *2 radius guarantees outside shape\n          x: rs.ctrlpts[0] + _cpM.x * 2 * _radius,\n          y: rs.ctrlpts[1] + _cpM.y * 2 * _radius\n        };\n        var tgtCtrlPtIntn = tgtShape.intersectLine(tgtPos.x, tgtPos.y, tgtW, tgtH, _cpProj.x, _cpProj.y, 0);\n\n        if (closeEndACp) {\n          rs.ctrlpts[0] = rs.ctrlpts[0] + _cpM.x * (minCpADist - endACpDist);\n          rs.ctrlpts[1] = rs.ctrlpts[1] + _cpM.y * (minCpADist - endACpDist);\n        } else {\n          rs.ctrlpts[0] = tgtCtrlPtIntn[0] + _cpM.x * minCpADist;\n          rs.ctrlpts[1] = tgtCtrlPtIntn[1] + _cpM.y * minCpADist;\n        }\n      }\n\n      if (overlapping) {\n        // recalc endpts\n        this.findEndpoints(edge);\n      }\n    }\n  };\n\n  BRp$c.storeAllpts = function (edge) {\n    var rs = edge._private.rscratch;\n\n    if (rs.edgeType === 'multibezier' || rs.edgeType === 'bezier' || rs.edgeType === 'self' || rs.edgeType === 'compound') {\n      rs.allpts = [];\n      rs.allpts.push(rs.startX, rs.startY);\n\n      for (var b = 0; b + 1 < rs.ctrlpts.length; b += 2) {\n        // ctrl pt itself\n        rs.allpts.push(rs.ctrlpts[b], rs.ctrlpts[b + 1]); // the midpt between ctrlpts as intermediate destination pts\n\n        if (b + 3 < rs.ctrlpts.length) {\n          rs.allpts.push((rs.ctrlpts[b] + rs.ctrlpts[b + 2]) / 2, (rs.ctrlpts[b + 1] + rs.ctrlpts[b + 3]) / 2);\n        }\n      }\n\n      rs.allpts.push(rs.endX, rs.endY);\n      var m, mt;\n\n      if (rs.ctrlpts.length / 2 % 2 === 0) {\n        m = rs.allpts.length / 2 - 1;\n        rs.midX = rs.allpts[m];\n        rs.midY = rs.allpts[m + 1];\n      } else {\n        m = rs.allpts.length / 2 - 3;\n        mt = 0.5;\n        rs.midX = qbezierAt(rs.allpts[m], rs.allpts[m + 2], rs.allpts[m + 4], mt);\n        rs.midY = qbezierAt(rs.allpts[m + 1], rs.allpts[m + 3], rs.allpts[m + 5], mt);\n      }\n    } else if (rs.edgeType === 'straight') {\n      // need to calc these after endpts\n      rs.allpts = [rs.startX, rs.startY, rs.endX, rs.endY]; // default midpt for labels etc\n\n      rs.midX = (rs.startX + rs.endX + rs.arrowStartX + rs.arrowEndX) / 4;\n      rs.midY = (rs.startY + rs.endY + rs.arrowStartY + rs.arrowEndY) / 4;\n    } else if (rs.edgeType === 'segments') {\n      rs.allpts = [];\n      rs.allpts.push(rs.startX, rs.startY);\n      rs.allpts.push.apply(rs.allpts, rs.segpts);\n      rs.allpts.push(rs.endX, rs.endY);\n\n      if (rs.segpts.length % 4 === 0) {\n        var i2 = rs.segpts.length / 2;\n        var i1 = i2 - 2;\n        rs.midX = (rs.segpts[i1] + rs.segpts[i2]) / 2;\n        rs.midY = (rs.segpts[i1 + 1] + rs.segpts[i2 + 1]) / 2;\n      } else {\n        var _i = rs.segpts.length / 2 - 1;\n\n        rs.midX = rs.segpts[_i];\n        rs.midY = rs.segpts[_i + 1];\n      }\n    }\n  };\n\n  BRp$c.checkForInvalidEdgeWarning = function (edge) {\n    var rs = edge[0]._private.rscratch;\n\n    if (rs.nodesOverlap || number$1(rs.startX) && number$1(rs.startY) && number$1(rs.endX) && number$1(rs.endY)) {\n      rs.loggedErr = false;\n    } else {\n      if (!rs.loggedErr) {\n        rs.loggedErr = true;\n        warn('Edge `' + edge.id() + '` has invalid endpoints and so it is impossible to draw.  Adjust your edge style (e.g. control points) accordingly or use an alternative edge type.  This is expected behaviour when the source node and the target node overlap.');\n      }\n    }\n  };\n\n  BRp$c.findEdgeControlPoints = function (edges) {\n    var _this = this;\n\n    if (!edges || edges.length === 0) {\n      return;\n    }\n\n    var r = this;\n    var cy = r.cy;\n    var hasCompounds = cy.hasCompoundNodes();\n    var hashTable = {\n      map: new Map$2(),\n      get: function get(pairId) {\n        var map2 = this.map.get(pairId[0]);\n\n        if (map2 != null) {\n          return map2.get(pairId[1]);\n        } else {\n          return null;\n        }\n      },\n      set: function set(pairId, val) {\n        var map2 = this.map.get(pairId[0]);\n\n        if (map2 == null) {\n          map2 = new Map$2();\n          this.map.set(pairId[0], map2);\n        }\n\n        map2.set(pairId[1], val);\n      }\n    };\n    var pairIds = [];\n    var haystackEdges = []; // create a table of edge (src, tgt) => list of edges between them\n\n    for (var i = 0; i < edges.length; i++) {\n      var edge = edges[i];\n      var _p = edge._private;\n      var curveStyle = edge.pstyle('curve-style').value; // ignore edges who are not to be displayed\n      // they shouldn't take up space\n\n      if (edge.removed() || !edge.takesUpSpace()) {\n        continue;\n      }\n\n      if (curveStyle === 'haystack') {\n        haystackEdges.push(edge);\n        continue;\n      }\n\n      var edgeIsUnbundled = curveStyle === 'unbundled-bezier' || curveStyle === 'segments' || curveStyle === 'straight' || curveStyle === 'straight-triangle' || curveStyle === 'taxi';\n      var edgeIsBezier = curveStyle === 'unbundled-bezier' || curveStyle === 'bezier';\n      var src = _p.source;\n      var tgt = _p.target;\n      var srcIndex = src.poolIndex();\n      var tgtIndex = tgt.poolIndex();\n      var pairId = [srcIndex, tgtIndex].sort();\n      var tableEntry = hashTable.get(pairId);\n\n      if (tableEntry == null) {\n        tableEntry = {\n          eles: []\n        };\n        hashTable.set(pairId, tableEntry);\n        pairIds.push(pairId);\n      }\n\n      tableEntry.eles.push(edge);\n\n      if (edgeIsUnbundled) {\n        tableEntry.hasUnbundled = true;\n      }\n\n      if (edgeIsBezier) {\n        tableEntry.hasBezier = true;\n      }\n    } // for each pair (src, tgt), create the ctrl pts\n    // Nested for loop is OK; total number of iterations for both loops = edgeCount\n\n\n    var _loop = function _loop(p) {\n      var pairId = pairIds[p];\n      var pairInfo = hashTable.get(pairId);\n      var swappedpairInfo = void 0;\n\n      if (!pairInfo.hasUnbundled) {\n        var pllEdges = pairInfo.eles[0].parallelEdges().filter(function (e) {\n          return e.isBundledBezier();\n        });\n        clearArray(pairInfo.eles);\n        pllEdges.forEach(function (edge) {\n          return pairInfo.eles.push(edge);\n        }); // for each pair id, the edges should be sorted by index\n\n        pairInfo.eles.sort(function (edge1, edge2) {\n          return edge1.poolIndex() - edge2.poolIndex();\n        });\n      }\n\n      var firstEdge = pairInfo.eles[0];\n      var src = firstEdge.source();\n      var tgt = firstEdge.target(); // make sure src/tgt distinction is consistent w.r.t. pairId\n\n      if (src.poolIndex() > tgt.poolIndex()) {\n        var temp = src;\n        src = tgt;\n        tgt = temp;\n      }\n\n      var srcPos = pairInfo.srcPos = src.position();\n      var tgtPos = pairInfo.tgtPos = tgt.position();\n      var srcW = pairInfo.srcW = src.outerWidth();\n      var srcH = pairInfo.srcH = src.outerHeight();\n      var tgtW = pairInfo.tgtW = tgt.outerWidth();\n      var tgtH = pairInfo.tgtH = tgt.outerHeight();\n\n      var srcShape = pairInfo.srcShape = r.nodeShapes[_this.getNodeShape(src)];\n\n      var tgtShape = pairInfo.tgtShape = r.nodeShapes[_this.getNodeShape(tgt)];\n\n      pairInfo.dirCounts = {\n        'north': 0,\n        'west': 0,\n        'south': 0,\n        'east': 0,\n        'northwest': 0,\n        'southwest': 0,\n        'northeast': 0,\n        'southeast': 0\n      };\n\n      for (var _i2 = 0; _i2 < pairInfo.eles.length; _i2++) {\n        var _edge = pairInfo.eles[_i2];\n        var rs = _edge[0]._private.rscratch;\n\n        var _curveStyle = _edge.pstyle('curve-style').value;\n\n        var _edgeIsUnbundled = _curveStyle === 'unbundled-bezier' || _curveStyle === 'segments' || _curveStyle === 'taxi'; // whether the normalised pair order is the reverse of the edge's src-tgt order\n\n\n        var edgeIsSwapped = !src.same(_edge.source());\n\n        if (!pairInfo.calculatedIntersection && src !== tgt && (pairInfo.hasBezier || pairInfo.hasUnbundled)) {\n          pairInfo.calculatedIntersection = true; // pt outside src shape to calc distance/displacement from src to tgt\n\n          var srcOutside = srcShape.intersectLine(srcPos.x, srcPos.y, srcW, srcH, tgtPos.x, tgtPos.y, 0);\n          var srcIntn = pairInfo.srcIntn = srcOutside; // pt outside tgt shape to calc distance/displacement from src to tgt\n\n          var tgtOutside = tgtShape.intersectLine(tgtPos.x, tgtPos.y, tgtW, tgtH, srcPos.x, srcPos.y, 0);\n          var tgtIntn = pairInfo.tgtIntn = tgtOutside;\n          var intersectionPts = pairInfo.intersectionPts = {\n            x1: srcOutside[0],\n            x2: tgtOutside[0],\n            y1: srcOutside[1],\n            y2: tgtOutside[1]\n          };\n          var posPts = pairInfo.posPts = {\n            x1: srcPos.x,\n            x2: tgtPos.x,\n            y1: srcPos.y,\n            y2: tgtPos.y\n          };\n          var dy = tgtOutside[1] - srcOutside[1];\n          var dx = tgtOutside[0] - srcOutside[0];\n          var l = Math.sqrt(dx * dx + dy * dy);\n          var vector = pairInfo.vector = {\n            x: dx,\n            y: dy\n          };\n          var vectorNorm = pairInfo.vectorNorm = {\n            x: vector.x / l,\n            y: vector.y / l\n          };\n          var vectorNormInverse = {\n            x: -vectorNorm.y,\n            y: vectorNorm.x\n          }; // if node shapes overlap, then no ctrl pts to draw\n\n          pairInfo.nodesOverlap = !number$1(l) || tgtShape.checkPoint(srcOutside[0], srcOutside[1], 0, tgtW, tgtH, tgtPos.x, tgtPos.y) || srcShape.checkPoint(tgtOutside[0], tgtOutside[1], 0, srcW, srcH, srcPos.x, srcPos.y);\n          pairInfo.vectorNormInverse = vectorNormInverse;\n          swappedpairInfo = {\n            nodesOverlap: pairInfo.nodesOverlap,\n            dirCounts: pairInfo.dirCounts,\n            calculatedIntersection: true,\n            hasBezier: pairInfo.hasBezier,\n            hasUnbundled: pairInfo.hasUnbundled,\n            eles: pairInfo.eles,\n            srcPos: tgtPos,\n            tgtPos: srcPos,\n            srcW: tgtW,\n            srcH: tgtH,\n            tgtW: srcW,\n            tgtH: srcH,\n            srcIntn: tgtIntn,\n            tgtIntn: srcIntn,\n            srcShape: tgtShape,\n            tgtShape: srcShape,\n            posPts: {\n              x1: posPts.x2,\n              y1: posPts.y2,\n              x2: posPts.x1,\n              y2: posPts.y1\n            },\n            intersectionPts: {\n              x1: intersectionPts.x2,\n              y1: intersectionPts.y2,\n              x2: intersectionPts.x1,\n              y2: intersectionPts.y1\n            },\n            vector: {\n              x: -vector.x,\n              y: -vector.y\n            },\n            vectorNorm: {\n              x: -vectorNorm.x,\n              y: -vectorNorm.y\n            },\n            vectorNormInverse: {\n              x: -vectorNormInverse.x,\n              y: -vectorNormInverse.y\n            }\n          };\n        }\n\n        var passedPairInfo = edgeIsSwapped ? swappedpairInfo : pairInfo;\n        rs.nodesOverlap = passedPairInfo.nodesOverlap;\n        rs.srcIntn = passedPairInfo.srcIntn;\n        rs.tgtIntn = passedPairInfo.tgtIntn;\n\n        if (hasCompounds && (src.isParent() || src.isChild() || tgt.isParent() || tgt.isChild()) && (src.parents().anySame(tgt) || tgt.parents().anySame(src) || src.same(tgt) && src.isParent())) {\n          _this.findCompoundLoopPoints(_edge, passedPairInfo, _i2, _edgeIsUnbundled);\n        } else if (src === tgt) {\n          _this.findLoopPoints(_edge, passedPairInfo, _i2, _edgeIsUnbundled);\n        } else if (_curveStyle === 'segments') {\n          _this.findSegmentsPoints(_edge, passedPairInfo);\n        } else if (_curveStyle === 'taxi') {\n          _this.findTaxiPoints(_edge, passedPairInfo);\n        } else if (_curveStyle === 'straight' || !_edgeIsUnbundled && pairInfo.eles.length % 2 === 1 && _i2 === Math.floor(pairInfo.eles.length / 2)) {\n          _this.findStraightEdgePoints(_edge);\n        } else {\n          _this.findBezierPoints(_edge, passedPairInfo, _i2, _edgeIsUnbundled, edgeIsSwapped);\n        }\n\n        _this.findEndpoints(_edge);\n\n        _this.tryToCorrectInvalidPoints(_edge, passedPairInfo);\n\n        _this.checkForInvalidEdgeWarning(_edge);\n\n        _this.storeAllpts(_edge);\n\n        _this.storeEdgeProjections(_edge);\n\n        _this.calculateArrowAngles(_edge);\n\n        _this.recalculateEdgeLabelProjections(_edge);\n\n        _this.calculateLabelAngles(_edge);\n      } // for pair edges\n\n    };\n\n    for (var p = 0; p < pairIds.length; p++) {\n      _loop(p);\n    } // for pair ids\n    // haystacks avoid the expense of pairInfo stuff (intersections etc.)\n\n\n    this.findHaystackPoints(haystackEdges);\n  };\n\n  function getPts(pts) {\n    var retPts = [];\n\n    if (pts == null) {\n      return;\n    }\n\n    for (var i = 0; i < pts.length; i += 2) {\n      var x = pts[i];\n      var y = pts[i + 1];\n      retPts.push({\n        x: x,\n        y: y\n      });\n    }\n\n    return retPts;\n  }\n\n  BRp$c.getSegmentPoints = function (edge) {\n    var rs = edge[0]._private.rscratch;\n    var type = rs.edgeType;\n\n    if (type === 'segments') {\n      this.recalculateRenderedStyle(edge);\n      return getPts(rs.segpts);\n    }\n  };\n\n  BRp$c.getControlPoints = function (edge) {\n    var rs = edge[0]._private.rscratch;\n    var type = rs.edgeType;\n\n    if (type === 'bezier' || type === 'multibezier' || type === 'self' || type === 'compound') {\n      this.recalculateRenderedStyle(edge);\n      return getPts(rs.ctrlpts);\n    }\n  };\n\n  BRp$c.getEdgeMidpoint = function (edge) {\n    var rs = edge[0]._private.rscratch;\n    this.recalculateRenderedStyle(edge);\n    return {\n      x: rs.midX,\n      y: rs.midY\n    };\n  };\n\n  var BRp$b = {};\n\n  BRp$b.manualEndptToPx = function (node, prop) {\n    var r = this;\n    var npos = node.position();\n    var w = node.outerWidth();\n    var h = node.outerHeight();\n\n    if (prop.value.length === 2) {\n      var p = [prop.pfValue[0], prop.pfValue[1]];\n\n      if (prop.units[0] === '%') {\n        p[0] = p[0] * w;\n      }\n\n      if (prop.units[1] === '%') {\n        p[1] = p[1] * h;\n      }\n\n      p[0] += npos.x;\n      p[1] += npos.y;\n      return p;\n    } else {\n      var angle = prop.pfValue[0];\n      angle = -Math.PI / 2 + angle; // start at 12 o'clock\n\n      var l = 2 * Math.max(w, h);\n      var _p = [npos.x + Math.cos(angle) * l, npos.y + Math.sin(angle) * l];\n      return r.nodeShapes[this.getNodeShape(node)].intersectLine(npos.x, npos.y, w, h, _p[0], _p[1], 0);\n    }\n  };\n\n  BRp$b.findEndpoints = function (edge) {\n    var r = this;\n    var intersect;\n    var source = edge.source()[0];\n    var target = edge.target()[0];\n    var srcPos = source.position();\n    var tgtPos = target.position();\n    var tgtArShape = edge.pstyle('target-arrow-shape').value;\n    var srcArShape = edge.pstyle('source-arrow-shape').value;\n    var tgtDist = edge.pstyle('target-distance-from-node').pfValue;\n    var srcDist = edge.pstyle('source-distance-from-node').pfValue;\n    var curveStyle = edge.pstyle('curve-style').value;\n    var rs = edge._private.rscratch;\n    var et = rs.edgeType;\n    var taxi = curveStyle === 'taxi';\n    var self = et === 'self' || et === 'compound';\n    var bezier = et === 'bezier' || et === 'multibezier' || self;\n    var multi = et !== 'bezier';\n    var lines = et === 'straight' || et === 'segments';\n    var segments = et === 'segments';\n    var hasEndpts = bezier || multi || lines;\n    var overrideEndpts = self || taxi;\n    var srcManEndpt = edge.pstyle('source-endpoint');\n    var srcManEndptVal = overrideEndpts ? 'outside-to-node' : srcManEndpt.value;\n    var tgtManEndpt = edge.pstyle('target-endpoint');\n    var tgtManEndptVal = overrideEndpts ? 'outside-to-node' : tgtManEndpt.value;\n    rs.srcManEndpt = srcManEndpt;\n    rs.tgtManEndpt = tgtManEndpt;\n    var p1; // last known point of edge on target side\n\n    var p2; // last known point of edge on source side\n\n    var p1_i; // point to intersect with target shape\n\n    var p2_i; // point to intersect with source shape\n\n    if (bezier) {\n      var cpStart = [rs.ctrlpts[0], rs.ctrlpts[1]];\n      var cpEnd = multi ? [rs.ctrlpts[rs.ctrlpts.length - 2], rs.ctrlpts[rs.ctrlpts.length - 1]] : cpStart;\n      p1 = cpEnd;\n      p2 = cpStart;\n    } else if (lines) {\n      var srcArrowFromPt = !segments ? [tgtPos.x, tgtPos.y] : rs.segpts.slice(0, 2);\n      var tgtArrowFromPt = !segments ? [srcPos.x, srcPos.y] : rs.segpts.slice(rs.segpts.length - 2);\n      p1 = tgtArrowFromPt;\n      p2 = srcArrowFromPt;\n    }\n\n    if (tgtManEndptVal === 'inside-to-node') {\n      intersect = [tgtPos.x, tgtPos.y];\n    } else if (tgtManEndpt.units) {\n      intersect = this.manualEndptToPx(target, tgtManEndpt);\n    } else if (tgtManEndptVal === 'outside-to-line') {\n      intersect = rs.tgtIntn; // use cached value from ctrlpt calc\n    } else {\n      if (tgtManEndptVal === 'outside-to-node' || tgtManEndptVal === 'outside-to-node-or-label') {\n        p1_i = p1;\n      } else if (tgtManEndptVal === 'outside-to-line' || tgtManEndptVal === 'outside-to-line-or-label') {\n        p1_i = [srcPos.x, srcPos.y];\n      }\n\n      intersect = r.nodeShapes[this.getNodeShape(target)].intersectLine(tgtPos.x, tgtPos.y, target.outerWidth(), target.outerHeight(), p1_i[0], p1_i[1], 0);\n\n      if (tgtManEndptVal === 'outside-to-node-or-label' || tgtManEndptVal === 'outside-to-line-or-label') {\n        var trs = target._private.rscratch;\n        var lw = trs.labelWidth;\n        var lh = trs.labelHeight;\n        var lx = trs.labelX;\n        var ly = trs.labelY;\n        var lw2 = lw / 2;\n        var lh2 = lh / 2;\n        var va = target.pstyle('text-valign').value;\n\n        if (va === 'top') {\n          ly -= lh2;\n        } else if (va === 'bottom') {\n          ly += lh2;\n        }\n\n        var ha = target.pstyle('text-halign').value;\n\n        if (ha === 'left') {\n          lx -= lw2;\n        } else if (ha === 'right') {\n          lx += lw2;\n        }\n\n        var labelIntersect = polygonIntersectLine(p1_i[0], p1_i[1], [lx - lw2, ly - lh2, lx + lw2, ly - lh2, lx + lw2, ly + lh2, lx - lw2, ly + lh2], tgtPos.x, tgtPos.y);\n\n        if (labelIntersect.length > 0) {\n          var refPt = srcPos;\n          var intSqdist = sqdist(refPt, array2point(intersect));\n          var labIntSqdist = sqdist(refPt, array2point(labelIntersect));\n          var minSqDist = intSqdist;\n\n          if (labIntSqdist < intSqdist) {\n            intersect = labelIntersect;\n            minSqDist = labIntSqdist;\n          }\n\n          if (labelIntersect.length > 2) {\n            var labInt2SqDist = sqdist(refPt, {\n              x: labelIntersect[2],\n              y: labelIntersect[3]\n            });\n\n            if (labInt2SqDist < minSqDist) {\n              intersect = [labelIntersect[2], labelIntersect[3]];\n            }\n          }\n        }\n      }\n    }\n\n    var arrowEnd = shortenIntersection(intersect, p1, r.arrowShapes[tgtArShape].spacing(edge) + tgtDist);\n    var edgeEnd = shortenIntersection(intersect, p1, r.arrowShapes[tgtArShape].gap(edge) + tgtDist);\n    rs.endX = edgeEnd[0];\n    rs.endY = edgeEnd[1];\n    rs.arrowEndX = arrowEnd[0];\n    rs.arrowEndY = arrowEnd[1];\n\n    if (srcManEndptVal === 'inside-to-node') {\n      intersect = [srcPos.x, srcPos.y];\n    } else if (srcManEndpt.units) {\n      intersect = this.manualEndptToPx(source, srcManEndpt);\n    } else if (srcManEndptVal === 'outside-to-line') {\n      intersect = rs.srcIntn; // use cached value from ctrlpt calc\n    } else {\n      if (srcManEndptVal === 'outside-to-node' || srcManEndptVal === 'outside-to-node-or-label') {\n        p2_i = p2;\n      } else if (srcManEndptVal === 'outside-to-line' || srcManEndptVal === 'outside-to-line-or-label') {\n        p2_i = [tgtPos.x, tgtPos.y];\n      }\n\n      intersect = r.nodeShapes[this.getNodeShape(source)].intersectLine(srcPos.x, srcPos.y, source.outerWidth(), source.outerHeight(), p2_i[0], p2_i[1], 0);\n\n      if (srcManEndptVal === 'outside-to-node-or-label' || srcManEndptVal === 'outside-to-line-or-label') {\n        var srs = source._private.rscratch;\n        var _lw = srs.labelWidth;\n        var _lh = srs.labelHeight;\n        var _lx = srs.labelX;\n        var _ly = srs.labelY;\n\n        var _lw2 = _lw / 2;\n\n        var _lh2 = _lh / 2;\n\n        var _va = source.pstyle('text-valign').value;\n\n        if (_va === 'top') {\n          _ly -= _lh2;\n        } else if (_va === 'bottom') {\n          _ly += _lh2;\n        }\n\n        var _ha = source.pstyle('text-halign').value;\n\n        if (_ha === 'left') {\n          _lx -= _lw2;\n        } else if (_ha === 'right') {\n          _lx += _lw2;\n        }\n\n        var _labelIntersect = polygonIntersectLine(p2_i[0], p2_i[1], [_lx - _lw2, _ly - _lh2, _lx + _lw2, _ly - _lh2, _lx + _lw2, _ly + _lh2, _lx - _lw2, _ly + _lh2], srcPos.x, srcPos.y);\n\n        if (_labelIntersect.length > 0) {\n          var _refPt = tgtPos;\n\n          var _intSqdist = sqdist(_refPt, array2point(intersect));\n\n          var _labIntSqdist = sqdist(_refPt, array2point(_labelIntersect));\n\n          var _minSqDist = _intSqdist;\n\n          if (_labIntSqdist < _intSqdist) {\n            intersect = [_labelIntersect[0], _labelIntersect[1]];\n            _minSqDist = _labIntSqdist;\n          }\n\n          if (_labelIntersect.length > 2) {\n            var _labInt2SqDist = sqdist(_refPt, {\n              x: _labelIntersect[2],\n              y: _labelIntersect[3]\n            });\n\n            if (_labInt2SqDist < _minSqDist) {\n              intersect = [_labelIntersect[2], _labelIntersect[3]];\n            }\n          }\n        }\n      }\n    }\n\n    var arrowStart = shortenIntersection(intersect, p2, r.arrowShapes[srcArShape].spacing(edge) + srcDist);\n    var edgeStart = shortenIntersection(intersect, p2, r.arrowShapes[srcArShape].gap(edge) + srcDist);\n    rs.startX = edgeStart[0];\n    rs.startY = edgeStart[1];\n    rs.arrowStartX = arrowStart[0];\n    rs.arrowStartY = arrowStart[1];\n\n    if (hasEndpts) {\n      if (!number$1(rs.startX) || !number$1(rs.startY) || !number$1(rs.endX) || !number$1(rs.endY)) {\n        rs.badLine = true;\n      } else {\n        rs.badLine = false;\n      }\n    }\n  };\n\n  BRp$b.getSourceEndpoint = function (edge) {\n    var rs = edge[0]._private.rscratch;\n    this.recalculateRenderedStyle(edge);\n\n    switch (rs.edgeType) {\n      case 'haystack':\n        return {\n          x: rs.haystackPts[0],\n          y: rs.haystackPts[1]\n        };\n\n      default:\n        return {\n          x: rs.arrowStartX,\n          y: rs.arrowStartY\n        };\n    }\n  };\n\n  BRp$b.getTargetEndpoint = function (edge) {\n    var rs = edge[0]._private.rscratch;\n    this.recalculateRenderedStyle(edge);\n\n    switch (rs.edgeType) {\n      case 'haystack':\n        return {\n          x: rs.haystackPts[2],\n          y: rs.haystackPts[3]\n        };\n\n      default:\n        return {\n          x: rs.arrowEndX,\n          y: rs.arrowEndY\n        };\n    }\n  };\n\n  var BRp$a = {};\n\n  function pushBezierPts(r, edge, pts) {\n    var qbezierAt$1 = function qbezierAt$1(p1, p2, p3, t) {\n      return qbezierAt(p1, p2, p3, t);\n    };\n\n    var _p = edge._private;\n    var bpts = _p.rstyle.bezierPts;\n\n    for (var i = 0; i < r.bezierProjPcts.length; i++) {\n      var p = r.bezierProjPcts[i];\n      bpts.push({\n        x: qbezierAt$1(pts[0], pts[2], pts[4], p),\n        y: qbezierAt$1(pts[1], pts[3], pts[5], p)\n      });\n    }\n  }\n\n  BRp$a.storeEdgeProjections = function (edge) {\n    var _p = edge._private;\n    var rs = _p.rscratch;\n    var et = rs.edgeType; // clear the cached points state\n\n    _p.rstyle.bezierPts = null;\n    _p.rstyle.linePts = null;\n    _p.rstyle.haystackPts = null;\n\n    if (et === 'multibezier' || et === 'bezier' || et === 'self' || et === 'compound') {\n      _p.rstyle.bezierPts = [];\n\n      for (var i = 0; i + 5 < rs.allpts.length; i += 4) {\n        pushBezierPts(this, edge, rs.allpts.slice(i, i + 6));\n      }\n    } else if (et === 'segments') {\n      var lpts = _p.rstyle.linePts = [];\n\n      for (var i = 0; i + 1 < rs.allpts.length; i += 2) {\n        lpts.push({\n          x: rs.allpts[i],\n          y: rs.allpts[i + 1]\n        });\n      }\n    } else if (et === 'haystack') {\n      var hpts = rs.haystackPts;\n      _p.rstyle.haystackPts = [{\n        x: hpts[0],\n        y: hpts[1]\n      }, {\n        x: hpts[2],\n        y: hpts[3]\n      }];\n    }\n\n    _p.rstyle.arrowWidth = this.getArrowWidth(edge.pstyle('width').pfValue, edge.pstyle('arrow-scale').value) * this.arrowShapeWidth;\n  };\n\n  BRp$a.recalculateEdgeProjections = function (edges) {\n    this.findEdgeControlPoints(edges);\n  };\n\n  /* global document */\n\n  var BRp$9 = {};\n\n  BRp$9.recalculateNodeLabelProjection = function (node) {\n    var content = node.pstyle('label').strValue;\n\n    if (emptyString(content)) {\n      return;\n    }\n\n    var textX, textY;\n    var _p = node._private;\n    var nodeWidth = node.width();\n    var nodeHeight = node.height();\n    var padding = node.padding();\n    var nodePos = node.position();\n    var textHalign = node.pstyle('text-halign').strValue;\n    var textValign = node.pstyle('text-valign').strValue;\n    var rs = _p.rscratch;\n    var rstyle = _p.rstyle;\n\n    switch (textHalign) {\n      case 'left':\n        textX = nodePos.x - nodeWidth / 2 - padding;\n        break;\n\n      case 'right':\n        textX = nodePos.x + nodeWidth / 2 + padding;\n        break;\n\n      default:\n        // e.g. center\n        textX = nodePos.x;\n    }\n\n    switch (textValign) {\n      case 'top':\n        textY = nodePos.y - nodeHeight / 2 - padding;\n        break;\n\n      case 'bottom':\n        textY = nodePos.y + nodeHeight / 2 + padding;\n        break;\n\n      default:\n        // e.g. middle\n        textY = nodePos.y;\n    }\n\n    rs.labelX = textX;\n    rs.labelY = textY;\n    rstyle.labelX = textX;\n    rstyle.labelY = textY;\n    this.calculateLabelAngles(node);\n    this.applyLabelDimensions(node);\n  };\n\n  var lineAngleFromDelta = function lineAngleFromDelta(dx, dy) {\n    var angle = Math.atan(dy / dx);\n\n    if (dx === 0 && angle < 0) {\n      angle = angle * -1;\n    }\n\n    return angle;\n  };\n\n  var lineAngle = function lineAngle(p0, p1) {\n    var dx = p1.x - p0.x;\n    var dy = p1.y - p0.y;\n    return lineAngleFromDelta(dx, dy);\n  };\n\n  var bezierAngle = function bezierAngle(p0, p1, p2, t) {\n    var t0 = bound(0, t - 0.001, 1);\n    var t1 = bound(0, t + 0.001, 1);\n    var lp0 = qbezierPtAt(p0, p1, p2, t0);\n    var lp1 = qbezierPtAt(p0, p1, p2, t1);\n    return lineAngle(lp0, lp1);\n  };\n\n  BRp$9.recalculateEdgeLabelProjections = function (edge) {\n    var p;\n    var _p = edge._private;\n    var rs = _p.rscratch;\n    var r = this;\n    var content = {\n      mid: edge.pstyle('label').strValue,\n      source: edge.pstyle('source-label').strValue,\n      target: edge.pstyle('target-label').strValue\n    };\n\n    if (content.mid || content.source || content.target) ; else {\n      return; // no labels => no calcs\n    } // add center point to style so bounding box calculations can use it\n    //\n\n\n    p = {\n      x: rs.midX,\n      y: rs.midY\n    };\n\n    var setRs = function setRs(propName, prefix, value) {\n      setPrefixedProperty(_p.rscratch, propName, prefix, value);\n      setPrefixedProperty(_p.rstyle, propName, prefix, value);\n    };\n\n    setRs('labelX', null, p.x);\n    setRs('labelY', null, p.y);\n    var midAngle = lineAngleFromDelta(rs.midDispX, rs.midDispY);\n    setRs('labelAutoAngle', null, midAngle);\n\n    var createControlPointInfo = function createControlPointInfo() {\n      if (createControlPointInfo.cache) {\n        return createControlPointInfo.cache;\n      } // use cache so only 1x per edge\n\n\n      var ctrlpts = []; // store each ctrlpt info init\n\n      for (var i = 0; i + 5 < rs.allpts.length; i += 4) {\n        var p0 = {\n          x: rs.allpts[i],\n          y: rs.allpts[i + 1]\n        };\n        var p1 = {\n          x: rs.allpts[i + 2],\n          y: rs.allpts[i + 3]\n        }; // ctrlpt\n\n        var p2 = {\n          x: rs.allpts[i + 4],\n          y: rs.allpts[i + 5]\n        };\n        ctrlpts.push({\n          p0: p0,\n          p1: p1,\n          p2: p2,\n          startDist: 0,\n          length: 0,\n          segments: []\n        });\n      }\n\n      var bpts = _p.rstyle.bezierPts;\n      var nProjs = r.bezierProjPcts.length;\n\n      function addSegment(cp, p0, p1, t0, t1) {\n        var length = dist(p0, p1);\n        var prevSegment = cp.segments[cp.segments.length - 1];\n        var segment = {\n          p0: p0,\n          p1: p1,\n          t0: t0,\n          t1: t1,\n          startDist: prevSegment ? prevSegment.startDist + prevSegment.length : 0,\n          length: length\n        };\n        cp.segments.push(segment);\n        cp.length += length;\n      } // update each ctrlpt with segment info\n\n\n      for (var _i = 0; _i < ctrlpts.length; _i++) {\n        var cp = ctrlpts[_i];\n        var prevCp = ctrlpts[_i - 1];\n\n        if (prevCp) {\n          cp.startDist = prevCp.startDist + prevCp.length;\n        }\n\n        addSegment(cp, cp.p0, bpts[_i * nProjs], 0, r.bezierProjPcts[0]); // first\n\n        for (var j = 0; j < nProjs - 1; j++) {\n          addSegment(cp, bpts[_i * nProjs + j], bpts[_i * nProjs + j + 1], r.bezierProjPcts[j], r.bezierProjPcts[j + 1]);\n        }\n\n        addSegment(cp, bpts[_i * nProjs + nProjs - 1], cp.p2, r.bezierProjPcts[nProjs - 1], 1); // last\n      }\n\n      return createControlPointInfo.cache = ctrlpts;\n    };\n\n    var calculateEndProjection = function calculateEndProjection(prefix) {\n      var angle;\n      var isSrc = prefix === 'source';\n\n      if (!content[prefix]) {\n        return;\n      }\n\n      var offset = edge.pstyle(prefix + '-text-offset').pfValue;\n\n      switch (rs.edgeType) {\n        case 'self':\n        case 'compound':\n        case 'bezier':\n        case 'multibezier':\n          {\n            var cps = createControlPointInfo();\n            var selected;\n            var startDist = 0;\n            var totalDist = 0; // find the segment we're on\n\n            for (var i = 0; i < cps.length; i++) {\n              var _cp = cps[isSrc ? i : cps.length - 1 - i];\n\n              for (var j = 0; j < _cp.segments.length; j++) {\n                var _seg = _cp.segments[isSrc ? j : _cp.segments.length - 1 - j];\n                var lastSeg = i === cps.length - 1 && j === _cp.segments.length - 1;\n                startDist = totalDist;\n                totalDist += _seg.length;\n\n                if (totalDist >= offset || lastSeg) {\n                  selected = {\n                    cp: _cp,\n                    segment: _seg\n                  };\n                  break;\n                }\n              }\n\n              if (selected) {\n                break;\n              }\n            }\n\n            var cp = selected.cp;\n            var seg = selected.segment;\n            var tSegment = (offset - startDist) / seg.length;\n            var segDt = seg.t1 - seg.t0;\n            var t = isSrc ? seg.t0 + segDt * tSegment : seg.t1 - segDt * tSegment;\n            t = bound(0, t, 1);\n            p = qbezierPtAt(cp.p0, cp.p1, cp.p2, t);\n            angle = bezierAngle(cp.p0, cp.p1, cp.p2, t);\n            break;\n          }\n\n        case 'straight':\n        case 'segments':\n        case 'haystack':\n          {\n            var d = 0,\n                di,\n                d0;\n            var p0, p1;\n            var l = rs.allpts.length;\n\n            for (var _i2 = 0; _i2 + 3 < l; _i2 += 2) {\n              if (isSrc) {\n                p0 = {\n                  x: rs.allpts[_i2],\n                  y: rs.allpts[_i2 + 1]\n                };\n                p1 = {\n                  x: rs.allpts[_i2 + 2],\n                  y: rs.allpts[_i2 + 3]\n                };\n              } else {\n                p0 = {\n                  x: rs.allpts[l - 2 - _i2],\n                  y: rs.allpts[l - 1 - _i2]\n                };\n                p1 = {\n                  x: rs.allpts[l - 4 - _i2],\n                  y: rs.allpts[l - 3 - _i2]\n                };\n              }\n\n              di = dist(p0, p1);\n              d0 = d;\n              d += di;\n\n              if (d >= offset) {\n                break;\n              }\n            }\n\n            var pD = offset - d0;\n\n            var _t = pD / di;\n\n            _t = bound(0, _t, 1);\n            p = lineAt(p0, p1, _t);\n            angle = lineAngle(p0, p1);\n            break;\n          }\n      }\n\n      setRs('labelX', prefix, p.x);\n      setRs('labelY', prefix, p.y);\n      setRs('labelAutoAngle', prefix, angle);\n    };\n\n    calculateEndProjection('source');\n    calculateEndProjection('target');\n    this.applyLabelDimensions(edge);\n  };\n\n  BRp$9.applyLabelDimensions = function (ele) {\n    this.applyPrefixedLabelDimensions(ele);\n\n    if (ele.isEdge()) {\n      this.applyPrefixedLabelDimensions(ele, 'source');\n      this.applyPrefixedLabelDimensions(ele, 'target');\n    }\n  };\n\n  BRp$9.applyPrefixedLabelDimensions = function (ele, prefix) {\n    var _p = ele._private;\n    var text = this.getLabelText(ele, prefix);\n    var labelDims = this.calculateLabelDimensions(ele, text);\n    var lineHeight = ele.pstyle('line-height').pfValue;\n    var textWrap = ele.pstyle('text-wrap').strValue;\n    var lines = getPrefixedProperty(_p.rscratch, 'labelWrapCachedLines', prefix) || [];\n    var numLines = textWrap !== 'wrap' ? 1 : Math.max(lines.length, 1);\n    var normPerLineHeight = labelDims.height / numLines;\n    var labelLineHeight = normPerLineHeight * lineHeight;\n    var width = labelDims.width;\n    var height = labelDims.height + (numLines - 1) * (lineHeight - 1) * normPerLineHeight;\n    setPrefixedProperty(_p.rstyle, 'labelWidth', prefix, width);\n    setPrefixedProperty(_p.rscratch, 'labelWidth', prefix, width);\n    setPrefixedProperty(_p.rstyle, 'labelHeight', prefix, height);\n    setPrefixedProperty(_p.rscratch, 'labelHeight', prefix, height);\n    setPrefixedProperty(_p.rscratch, 'labelLineHeight', prefix, labelLineHeight);\n  };\n\n  BRp$9.getLabelText = function (ele, prefix) {\n    var _p = ele._private;\n    var pfd = prefix ? prefix + '-' : '';\n    var text = ele.pstyle(pfd + 'label').strValue;\n    var textTransform = ele.pstyle('text-transform').value;\n\n    var rscratch = function rscratch(propName, value) {\n      if (value) {\n        setPrefixedProperty(_p.rscratch, propName, prefix, value);\n        return value;\n      } else {\n        return getPrefixedProperty(_p.rscratch, propName, prefix);\n      }\n    }; // for empty text, skip all processing\n\n\n    if (!text) {\n      return '';\n    }\n\n    if (textTransform == 'none') ; else if (textTransform == 'uppercase') {\n      text = text.toUpperCase();\n    } else if (textTransform == 'lowercase') {\n      text = text.toLowerCase();\n    }\n\n    var wrapStyle = ele.pstyle('text-wrap').value;\n\n    if (wrapStyle === 'wrap') {\n      var labelKey = rscratch('labelKey'); // save recalc if the label is the same as before\n\n      if (labelKey != null && rscratch('labelWrapKey') === labelKey) {\n        return rscratch('labelWrapCachedText');\n      }\n\n      var zwsp = \"\\u200B\";\n      var lines = text.split('\\n');\n      var maxW = ele.pstyle('text-max-width').pfValue;\n      var overflow = ele.pstyle('text-overflow-wrap').value;\n      var overflowAny = overflow === 'anywhere';\n      var wrappedLines = [];\n      var wordsRegex = /[\\s\\u200b]+/;\n      var wordSeparator = overflowAny ? '' : ' ';\n\n      for (var l = 0; l < lines.length; l++) {\n        var line = lines[l];\n        var lineDims = this.calculateLabelDimensions(ele, line);\n        var lineW = lineDims.width;\n\n        if (overflowAny) {\n          var processedLine = line.split('').join(zwsp);\n          line = processedLine;\n        }\n\n        if (lineW > maxW) {\n          // line is too long\n          var words = line.split(wordsRegex);\n          var subline = '';\n\n          for (var w = 0; w < words.length; w++) {\n            var word = words[w];\n            var testLine = subline.length === 0 ? word : subline + wordSeparator + word;\n            var testDims = this.calculateLabelDimensions(ele, testLine);\n            var testW = testDims.width;\n\n            if (testW <= maxW) {\n              // word fits on current line\n              subline += word + wordSeparator;\n            } else {\n              // word starts new line\n              if (subline) {\n                wrappedLines.push(subline);\n              }\n\n              subline = word + wordSeparator;\n            }\n          } // if there's remaining text, put it in a wrapped line\n\n\n          if (!subline.match(/^[\\s\\u200b]+$/)) {\n            wrappedLines.push(subline);\n          }\n        } else {\n          // line is already short enough\n          wrappedLines.push(line);\n        }\n      } // for\n\n\n      rscratch('labelWrapCachedLines', wrappedLines);\n      text = rscratch('labelWrapCachedText', wrappedLines.join('\\n'));\n      rscratch('labelWrapKey', labelKey);\n    } else if (wrapStyle === 'ellipsis') {\n      var _maxW = ele.pstyle('text-max-width').pfValue;\n      var ellipsized = '';\n      var ellipsis = \"\\u2026\";\n      var incLastCh = false;\n\n      if (this.calculateLabelDimensions(ele, text).width < _maxW) {\n        // the label already fits\n        return text;\n      }\n\n      for (var i = 0; i < text.length; i++) {\n        var widthWithNextCh = this.calculateLabelDimensions(ele, ellipsized + text[i] + ellipsis).width;\n\n        if (widthWithNextCh > _maxW) {\n          break;\n        }\n\n        ellipsized += text[i];\n\n        if (i === text.length - 1) {\n          incLastCh = true;\n        }\n      }\n\n      if (!incLastCh) {\n        ellipsized += ellipsis;\n      }\n\n      return ellipsized;\n    } // if ellipsize\n\n\n    return text;\n  };\n\n  BRp$9.getLabelJustification = function (ele) {\n    var justification = ele.pstyle('text-justification').strValue;\n    var textHalign = ele.pstyle('text-halign').strValue;\n\n    if (justification === 'auto') {\n      if (ele.isNode()) {\n        switch (textHalign) {\n          case 'left':\n            return 'right';\n\n          case 'right':\n            return 'left';\n\n          default:\n            return 'center';\n        }\n      } else {\n        return 'center';\n      }\n    } else {\n      return justification;\n    }\n  };\n\n  BRp$9.calculateLabelDimensions = function (ele, text) {\n    var r = this;\n    var cacheKey = hashString(text, ele._private.labelDimsKey);\n    var cache = r.labelDimCache || (r.labelDimCache = []);\n    var existingVal = cache[cacheKey];\n\n    if (existingVal != null) {\n      return existingVal;\n    }\n\n    var padding = 0; // add padding around text dims, as the measurement isn't that accurate\n\n    var fStyle = ele.pstyle('font-style').strValue;\n    var size = ele.pstyle('font-size').pfValue;\n    var family = ele.pstyle('font-family').strValue;\n    var weight = ele.pstyle('font-weight').strValue;\n    var canvas = this.labelCalcCanvas;\n    var c2d = this.labelCalcCanvasContext;\n\n    if (!canvas) {\n      canvas = this.labelCalcCanvas = document.createElement('canvas');\n      c2d = this.labelCalcCanvasContext = canvas.getContext('2d');\n      var ds = canvas.style;\n      ds.position = 'absolute';\n      ds.left = '-9999px';\n      ds.top = '-9999px';\n      ds.zIndex = '-1';\n      ds.visibility = 'hidden';\n      ds.pointerEvents = 'none';\n    }\n\n    c2d.font = \"\".concat(fStyle, \" \").concat(weight, \" \").concat(size, \"px \").concat(family);\n    var width = 0;\n    var height = 0;\n    var lines = text.split('\\n');\n\n    for (var i = 0; i < lines.length; i++) {\n      var line = lines[i];\n      var metrics = c2d.measureText(line);\n      var w = Math.ceil(metrics.width);\n      var h = size;\n      width = Math.max(w, width);\n      height += h;\n    }\n\n    width += padding;\n    height += padding;\n    return cache[cacheKey] = {\n      width: width,\n      height: height\n    };\n  };\n\n  BRp$9.calculateLabelAngle = function (ele, prefix) {\n    var _p = ele._private;\n    var rs = _p.rscratch;\n    var isEdge = ele.isEdge();\n    var prefixDash = prefix ? prefix + '-' : '';\n    var rot = ele.pstyle(prefixDash + 'text-rotation');\n    var rotStr = rot.strValue;\n\n    if (rotStr === 'none') {\n      return 0;\n    } else if (isEdge && rotStr === 'autorotate') {\n      return rs.labelAutoAngle;\n    } else if (rotStr === 'autorotate') {\n      return 0;\n    } else {\n      return rot.pfValue;\n    }\n  };\n\n  BRp$9.calculateLabelAngles = function (ele) {\n    var r = this;\n    var isEdge = ele.isEdge();\n    var _p = ele._private;\n    var rs = _p.rscratch;\n    rs.labelAngle = r.calculateLabelAngle(ele);\n\n    if (isEdge) {\n      rs.sourceLabelAngle = r.calculateLabelAngle(ele, 'source');\n      rs.targetLabelAngle = r.calculateLabelAngle(ele, 'target');\n    }\n  };\n\n  var BRp$8 = {};\n  var TOO_SMALL_CUT_RECT = 28;\n  var warnedCutRect = false;\n\n  BRp$8.getNodeShape = function (node) {\n    var r = this;\n    var shape = node.pstyle('shape').value;\n\n    if (shape === 'cutrectangle' && (node.width() < TOO_SMALL_CUT_RECT || node.height() < TOO_SMALL_CUT_RECT)) {\n      if (!warnedCutRect) {\n        warn('The `cutrectangle` node shape can not be used at small sizes so `rectangle` is used instead');\n        warnedCutRect = true;\n      }\n\n      return 'rectangle';\n    }\n\n    if (node.isParent()) {\n      if (shape === 'rectangle' || shape === 'roundrectangle' || shape === 'round-rectangle' || shape === 'cutrectangle' || shape === 'cut-rectangle' || shape === 'barrel') {\n        return shape;\n      } else {\n        return 'rectangle';\n      }\n    }\n\n    if (shape === 'polygon') {\n      var points = node.pstyle('shape-polygon-points').value;\n      return r.nodeShapes.makePolygon(points).name;\n    }\n\n    return shape;\n  };\n\n  var BRp$7 = {};\n\n  BRp$7.registerCalculationListeners = function () {\n    var cy = this.cy;\n    var elesToUpdate = cy.collection();\n    var r = this;\n\n    var enqueue = function enqueue(eles) {\n      var dirtyStyleCaches = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      elesToUpdate.merge(eles);\n\n      if (dirtyStyleCaches) {\n        for (var i = 0; i < eles.length; i++) {\n          var ele = eles[i];\n          var _p = ele._private;\n          var rstyle = _p.rstyle;\n          rstyle.clean = false;\n          rstyle.cleanConnected = false;\n        }\n      }\n    };\n\n    r.binder(cy).on('bounds.* dirty.*', function onDirtyBounds(e) {\n      var ele = e.target;\n      enqueue(ele);\n    }).on('style.* background.*', function onDirtyStyle(e) {\n      var ele = e.target;\n      enqueue(ele, false);\n    });\n\n    var updateEleCalcs = function updateEleCalcs(willDraw) {\n      if (willDraw) {\n        var fns = r.onUpdateEleCalcsFns; // because we need to have up-to-date style (e.g. stylesheet mappers)\n        // before calculating rendered style (and pstyle might not be called yet)\n\n        elesToUpdate.cleanStyle();\n\n        for (var i = 0; i < elesToUpdate.length; i++) {\n          var ele = elesToUpdate[i];\n          var rstyle = ele._private.rstyle;\n\n          if (ele.isNode() && !rstyle.cleanConnected) {\n            enqueue(ele.connectedEdges());\n            rstyle.cleanConnected = true;\n          }\n        }\n\n        if (fns) {\n          for (var _i = 0; _i < fns.length; _i++) {\n            var fn = fns[_i];\n            fn(willDraw, elesToUpdate);\n          }\n        }\n\n        r.recalculateRenderedStyle(elesToUpdate);\n        elesToUpdate = cy.collection();\n      }\n    };\n\n    r.flushRenderedStyleQueue = function () {\n      updateEleCalcs(true);\n    };\n\n    r.beforeRender(updateEleCalcs, r.beforeRenderPriorities.eleCalcs);\n  };\n\n  BRp$7.onUpdateEleCalcs = function (fn) {\n    var fns = this.onUpdateEleCalcsFns = this.onUpdateEleCalcsFns || [];\n    fns.push(fn);\n  };\n\n  BRp$7.recalculateRenderedStyle = function (eles, useCache) {\n    var isCleanConnected = function isCleanConnected(ele) {\n      return ele._private.rstyle.cleanConnected;\n    };\n\n    var edges = [];\n    var nodes = []; // the renderer can't be used for calcs when destroyed, e.g. ele.boundingBox()\n\n    if (this.destroyed) {\n      return;\n    } // use cache by default for perf\n\n\n    if (useCache === undefined) {\n      useCache = true;\n    }\n\n    for (var i = 0; i < eles.length; i++) {\n      var ele = eles[i];\n      var _p = ele._private;\n      var rstyle = _p.rstyle; // an edge may be implicitly dirty b/c of one of its connected nodes\n      // (and a request for recalc may come in between frames)\n\n      if (ele.isEdge() && (!isCleanConnected(ele.source()) || !isCleanConnected(ele.target()))) {\n        rstyle.clean = false;\n      } // only update if dirty and in graph\n\n\n      if (useCache && rstyle.clean || ele.removed()) {\n        continue;\n      } // only update if not display: none\n\n\n      if (ele.pstyle('display').value === 'none') {\n        continue;\n      }\n\n      if (_p.group === 'nodes') {\n        nodes.push(ele);\n      } else {\n        // edges\n        edges.push(ele);\n      }\n\n      rstyle.clean = true;\n    } // update node data from projections\n\n\n    for (var _i2 = 0; _i2 < nodes.length; _i2++) {\n      var _ele = nodes[_i2];\n      var _p2 = _ele._private;\n      var _rstyle = _p2.rstyle;\n\n      var pos = _ele.position();\n\n      this.recalculateNodeLabelProjection(_ele);\n      _rstyle.nodeX = pos.x;\n      _rstyle.nodeY = pos.y;\n      _rstyle.nodeW = _ele.pstyle('width').pfValue;\n      _rstyle.nodeH = _ele.pstyle('height').pfValue;\n    }\n\n    this.recalculateEdgeProjections(edges); // update edge data from projections\n\n    for (var _i3 = 0; _i3 < edges.length; _i3++) {\n      var _ele2 = edges[_i3];\n      var _p3 = _ele2._private;\n      var _rstyle2 = _p3.rstyle;\n      var rs = _p3.rscratch; // update rstyle positions\n\n      _rstyle2.srcX = rs.arrowStartX;\n      _rstyle2.srcY = rs.arrowStartY;\n      _rstyle2.tgtX = rs.arrowEndX;\n      _rstyle2.tgtY = rs.arrowEndY;\n      _rstyle2.midX = rs.midX;\n      _rstyle2.midY = rs.midY;\n      _rstyle2.labelAngle = rs.labelAngle;\n      _rstyle2.sourceLabelAngle = rs.sourceLabelAngle;\n      _rstyle2.targetLabelAngle = rs.targetLabelAngle;\n    }\n  };\n\n  var BRp$6 = {};\n\n  BRp$6.updateCachedGrabbedEles = function () {\n    var eles = this.cachedZSortedEles;\n\n    if (!eles) {\n      // just let this be recalculated on the next z sort tick\n      return;\n    }\n\n    eles.drag = [];\n    eles.nondrag = [];\n    var grabTargets = [];\n\n    for (var i = 0; i < eles.length; i++) {\n      var ele = eles[i];\n      var rs = ele._private.rscratch;\n\n      if (ele.grabbed() && !ele.isParent()) {\n        grabTargets.push(ele);\n      } else if (rs.inDragLayer) {\n        eles.drag.push(ele);\n      } else {\n        eles.nondrag.push(ele);\n      }\n    } // put the grab target nodes last so it's on top of its neighbourhood\n\n\n    for (var i = 0; i < grabTargets.length; i++) {\n      var ele = grabTargets[i];\n      eles.drag.push(ele);\n    }\n  };\n\n  BRp$6.invalidateCachedZSortedEles = function () {\n    this.cachedZSortedEles = null;\n  };\n\n  BRp$6.getCachedZSortedEles = function (forceRecalc) {\n    if (forceRecalc || !this.cachedZSortedEles) {\n      var eles = this.cy.mutableElements().toArray();\n      eles.sort(zIndexSort);\n      eles.interactive = eles.filter(function (ele) {\n        return ele.interactive();\n      });\n      this.cachedZSortedEles = eles;\n      this.updateCachedGrabbedEles();\n    } else {\n      eles = this.cachedZSortedEles;\n    }\n\n    return eles;\n  };\n\n  var BRp$5 = {};\n  [BRp$e, BRp$d, BRp$c, BRp$b, BRp$a, BRp$9, BRp$8, BRp$7, BRp$6].forEach(function (props) {\n    extend(BRp$5, props);\n  });\n\n  var BRp$4 = {};\n\n  BRp$4.getCachedImage = function (url, crossOrigin, onLoad) {\n    var r = this;\n    var imageCache = r.imageCache = r.imageCache || {};\n    var cache = imageCache[url];\n\n    if (cache) {\n      if (!cache.image.complete) {\n        cache.image.addEventListener('load', onLoad);\n      }\n\n      return cache.image;\n    } else {\n      cache = imageCache[url] = imageCache[url] || {};\n      var image = cache.image = new Image(); // eslint-disable-line no-undef\n\n      image.addEventListener('load', onLoad);\n      image.addEventListener('error', function () {\n        image.error = true;\n      }); // #1582 safari doesn't load data uris with crossOrigin properly\n      // https://bugs.webkit.org/show_bug.cgi?id=123978\n\n      var dataUriPrefix = 'data:';\n      var isDataUri = url.substring(0, dataUriPrefix.length).toLowerCase() === dataUriPrefix;\n\n      if (!isDataUri) {\n        // if crossorigin is 'null'(stringified), then manually set it to null \n        crossOrigin = crossOrigin === 'null' ? null : crossOrigin;\n        image.crossOrigin = crossOrigin; // prevent tainted canvas\n      }\n\n      image.src = url;\n      return image;\n    }\n  };\n\n  var BRp$3 = {};\n  /* global document, window, ResizeObserver, MutationObserver */\n\n  BRp$3.registerBinding = function (target, event, handler, useCapture) {\n    // eslint-disable-line no-unused-vars\n    var args = Array.prototype.slice.apply(arguments, [1]); // copy\n\n    var b = this.binder(target);\n    return b.on.apply(b, args);\n  };\n\n  BRp$3.binder = function (tgt) {\n    var r = this;\n    var tgtIsDom = tgt === window || tgt === document || tgt === document.body || domElement(tgt);\n\n    if (r.supportsPassiveEvents == null) {\n      // from https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md#feature-detection\n      var supportsPassive = false;\n\n      try {\n        var opts = Object.defineProperty({}, 'passive', {\n          get: function get() {\n            supportsPassive = true;\n            return true;\n          }\n        });\n        window.addEventListener('test', null, opts);\n      } catch (err) {// not supported\n      }\n\n      r.supportsPassiveEvents = supportsPassive;\n    }\n\n    var on = function on(event, handler, useCapture) {\n      var args = Array.prototype.slice.call(arguments);\n\n      if (tgtIsDom && r.supportsPassiveEvents) {\n        // replace useCapture w/ opts obj\n        args[2] = {\n          capture: useCapture != null ? useCapture : false,\n          passive: false,\n          once: false\n        };\n      }\n\n      r.bindings.push({\n        target: tgt,\n        args: args\n      });\n      (tgt.addEventListener || tgt.on).apply(tgt, args);\n      return this;\n    };\n\n    return {\n      on: on,\n      addEventListener: on,\n      addListener: on,\n      bind: on\n    };\n  };\n\n  BRp$3.nodeIsDraggable = function (node) {\n    return node && node.isNode() && !node.locked() && node.grabbable();\n  };\n\n  BRp$3.nodeIsGrabbable = function (node) {\n    return this.nodeIsDraggable(node) && node.interactive();\n  };\n\n  BRp$3.load = function () {\n    var r = this;\n\n    var isSelected = function isSelected(ele) {\n      return ele.selected();\n    };\n\n    var triggerEvents = function triggerEvents(target, names, e, position) {\n      if (target == null) {\n        target = r.cy;\n      }\n\n      for (var i = 0; i < names.length; i++) {\n        var name = names[i];\n        target.emit({\n          originalEvent: e,\n          type: name,\n          position: position\n        });\n      }\n    };\n\n    var isMultSelKeyDown = function isMultSelKeyDown(e) {\n      return e.shiftKey || e.metaKey || e.ctrlKey; // maybe e.altKey\n    };\n\n    var allowPanningPassthrough = function allowPanningPassthrough(down, downs) {\n      var allowPassthrough = true;\n\n      if (r.cy.hasCompoundNodes() && down && down.pannable()) {\n        // a grabbable compound node below the ele => no passthrough panning\n        for (var i = 0; downs && i < downs.length; i++) {\n          var down = downs[i]; //if any parent node in event hierarchy isn't pannable, reject passthrough\n\n          if (down.isNode() && down.isParent() && !down.pannable()) {\n            allowPassthrough = false;\n            break;\n          }\n        }\n      } else {\n        allowPassthrough = true;\n      }\n\n      return allowPassthrough;\n    };\n\n    var setGrabbed = function setGrabbed(ele) {\n      ele[0]._private.grabbed = true;\n    };\n\n    var setFreed = function setFreed(ele) {\n      ele[0]._private.grabbed = false;\n    };\n\n    var setInDragLayer = function setInDragLayer(ele) {\n      ele[0]._private.rscratch.inDragLayer = true;\n    };\n\n    var setOutDragLayer = function setOutDragLayer(ele) {\n      ele[0]._private.rscratch.inDragLayer = false;\n    };\n\n    var setGrabTarget = function setGrabTarget(ele) {\n      ele[0]._private.rscratch.isGrabTarget = true;\n    };\n\n    var removeGrabTarget = function removeGrabTarget(ele) {\n      ele[0]._private.rscratch.isGrabTarget = false;\n    };\n\n    var addToDragList = function addToDragList(ele, opts) {\n      var list = opts.addToList;\n      var listHasEle = list.has(ele);\n\n      if (!listHasEle && ele.grabbable() && !ele.locked()) {\n        list.merge(ele);\n        setGrabbed(ele);\n      }\n    }; // helper function to determine which child nodes and inner edges\n    // of a compound node to be dragged as well as the grabbed and selected nodes\n\n\n    var addDescendantsToDrag = function addDescendantsToDrag(node, opts) {\n      if (!node.cy().hasCompoundNodes()) {\n        return;\n      }\n\n      if (opts.inDragLayer == null && opts.addToList == null) {\n        return;\n      } // nothing to do\n\n\n      var innerNodes = node.descendants();\n\n      if (opts.inDragLayer) {\n        innerNodes.forEach(setInDragLayer);\n        innerNodes.connectedEdges().forEach(setInDragLayer);\n      }\n\n      if (opts.addToList) {\n        addToDragList(innerNodes, opts);\n      }\n    }; // adds the given nodes and its neighbourhood to the drag layer\n\n\n    var addNodesToDrag = function addNodesToDrag(nodes, opts) {\n      opts = opts || {};\n      var hasCompoundNodes = nodes.cy().hasCompoundNodes();\n\n      if (opts.inDragLayer) {\n        nodes.forEach(setInDragLayer);\n        nodes.neighborhood().stdFilter(function (ele) {\n          return !hasCompoundNodes || ele.isEdge();\n        }).forEach(setInDragLayer);\n      }\n\n      if (opts.addToList) {\n        nodes.forEach(function (ele) {\n          addToDragList(ele, opts);\n        });\n      }\n\n      addDescendantsToDrag(nodes, opts); // always add to drag\n      // also add nodes and edges related to the topmost ancestor\n\n      updateAncestorsInDragLayer(nodes, {\n        inDragLayer: opts.inDragLayer\n      });\n      r.updateCachedGrabbedEles();\n    };\n\n    var addNodeToDrag = addNodesToDrag;\n\n    var freeDraggedElements = function freeDraggedElements(grabbedEles) {\n      if (!grabbedEles) {\n        return;\n      } // just go over all elements rather than doing a bunch of (possibly expensive) traversals\n\n\n      r.getCachedZSortedEles().forEach(function (ele) {\n        setFreed(ele);\n        setOutDragLayer(ele);\n        removeGrabTarget(ele);\n      });\n      r.updateCachedGrabbedEles();\n    }; // helper function to determine which ancestor nodes and edges should go\n    // to the drag layer (or should be removed from drag layer).\n\n\n    var updateAncestorsInDragLayer = function updateAncestorsInDragLayer(node, opts) {\n      if (opts.inDragLayer == null && opts.addToList == null) {\n        return;\n      } // nothing to do\n\n\n      if (!node.cy().hasCompoundNodes()) {\n        return;\n      } // find top-level parent\n\n\n      var parent = node.ancestors().orphans(); // no parent node: no nodes to add to the drag layer\n\n      if (parent.same(node)) {\n        return;\n      }\n\n      var nodes = parent.descendants().spawnSelf().merge(parent).unmerge(node).unmerge(node.descendants());\n      var edges = nodes.connectedEdges();\n\n      if (opts.inDragLayer) {\n        edges.forEach(setInDragLayer);\n        nodes.forEach(setInDragLayer);\n      }\n\n      if (opts.addToList) {\n        nodes.forEach(function (ele) {\n          addToDragList(ele, opts);\n        });\n      }\n    };\n\n    var blurActiveDomElement = function blurActiveDomElement() {\n      if (document.activeElement != null && document.activeElement.blur != null) {\n        document.activeElement.blur();\n      }\n    };\n\n    var haveMutationsApi = typeof MutationObserver !== 'undefined';\n    var haveResizeObserverApi = typeof ResizeObserver !== 'undefined'; // watch for when the cy container is removed from the dom\n\n    if (haveMutationsApi) {\n      r.removeObserver = new MutationObserver(function (mutns) {\n        // eslint-disable-line no-undef\n        for (var i = 0; i < mutns.length; i++) {\n          var mutn = mutns[i];\n          var rNodes = mutn.removedNodes;\n\n          if (rNodes) {\n            for (var j = 0; j < rNodes.length; j++) {\n              var rNode = rNodes[j];\n\n              if (rNode === r.container) {\n                r.destroy();\n                break;\n              }\n            }\n          }\n        }\n      });\n\n      if (r.container.parentNode) {\n        r.removeObserver.observe(r.container.parentNode, {\n          childList: true\n        });\n      }\n    } else {\n      r.registerBinding(r.container, 'DOMNodeRemoved', function (e) {\n        // eslint-disable-line no-unused-vars\n        r.destroy();\n      });\n    }\n\n    var onResize = debounce_1(function () {\n      r.cy.resize();\n    }, 100);\n\n    if (haveMutationsApi) {\n      r.styleObserver = new MutationObserver(onResize); // eslint-disable-line no-undef\n\n      r.styleObserver.observe(r.container, {\n        attributes: true\n      });\n    } // auto resize\n\n\n    r.registerBinding(window, 'resize', onResize); // eslint-disable-line no-undef\n\n    if (haveResizeObserverApi) {\n      r.resizeObserver = new ResizeObserver(onResize); // eslint-disable-line no-undef\n\n      r.resizeObserver.observe(r.container);\n    }\n\n    var forEachUp = function forEachUp(domEle, fn) {\n      while (domEle != null) {\n        fn(domEle);\n        domEle = domEle.parentNode;\n      }\n    };\n\n    var invalidateCoords = function invalidateCoords() {\n      r.invalidateContainerClientCoordsCache();\n    };\n\n    forEachUp(r.container, function (domEle) {\n      r.registerBinding(domEle, 'transitionend', invalidateCoords);\n      r.registerBinding(domEle, 'animationend', invalidateCoords);\n      r.registerBinding(domEle, 'scroll', invalidateCoords);\n    }); // stop right click menu from appearing on cy\n\n    r.registerBinding(r.container, 'contextmenu', function (e) {\n      e.preventDefault();\n    });\n\n    var inBoxSelection = function inBoxSelection() {\n      return r.selection[4] !== 0;\n    };\n\n    var eventInContainer = function eventInContainer(e) {\n      // save cycles if mouse events aren't to be captured\n      var containerPageCoords = r.findContainerClientCoords();\n      var x = containerPageCoords[0];\n      var y = containerPageCoords[1];\n      var width = containerPageCoords[2];\n      var height = containerPageCoords[3];\n      var positions = e.touches ? e.touches : [e];\n      var atLeastOnePosInside = false;\n\n      for (var i = 0; i < positions.length; i++) {\n        var p = positions[i];\n\n        if (x <= p.clientX && p.clientX <= x + width && y <= p.clientY && p.clientY <= y + height) {\n          atLeastOnePosInside = true;\n          break;\n        }\n      }\n\n      if (!atLeastOnePosInside) {\n        return false;\n      }\n\n      var container = r.container;\n      var target = e.target;\n      var tParent = target.parentNode;\n      var containerIsTarget = false;\n\n      while (tParent) {\n        if (tParent === container) {\n          containerIsTarget = true;\n          break;\n        }\n\n        tParent = tParent.parentNode;\n      }\n\n      if (!containerIsTarget) {\n        return false;\n      } // if target is outisde cy container, then this event is not for us\n\n\n      return true;\n    }; // Primary key\n\n\n    r.registerBinding(r.container, 'mousedown', function mousedownHandler(e) {\n      if (!eventInContainer(e)) {\n        return;\n      }\n\n      e.preventDefault();\n      blurActiveDomElement();\n      r.hoverData.capture = true;\n      r.hoverData.which = e.which;\n      var cy = r.cy;\n      var gpos = [e.clientX, e.clientY];\n      var pos = r.projectIntoViewport(gpos[0], gpos[1]);\n      var select = r.selection;\n      var nears = r.findNearestElements(pos[0], pos[1], true, false);\n      var near = nears[0];\n      var draggedElements = r.dragData.possibleDragElements;\n      r.hoverData.mdownPos = pos;\n      r.hoverData.mdownGPos = gpos;\n\n      var checkForTaphold = function checkForTaphold() {\n        r.hoverData.tapholdCancelled = false;\n        clearTimeout(r.hoverData.tapholdTimeout);\n        r.hoverData.tapholdTimeout = setTimeout(function () {\n          if (r.hoverData.tapholdCancelled) {\n            return;\n          } else {\n            var ele = r.hoverData.down;\n\n            if (ele) {\n              ele.emit({\n                originalEvent: e,\n                type: 'taphold',\n                position: {\n                  x: pos[0],\n                  y: pos[1]\n                }\n              });\n            } else {\n              cy.emit({\n                originalEvent: e,\n                type: 'taphold',\n                position: {\n                  x: pos[0],\n                  y: pos[1]\n                }\n              });\n            }\n          }\n        }, r.tapholdDuration);\n      }; // Right click button\n\n\n      if (e.which == 3) {\n        r.hoverData.cxtStarted = true;\n        var cxtEvt = {\n          originalEvent: e,\n          type: 'cxttapstart',\n          position: {\n            x: pos[0],\n            y: pos[1]\n          }\n        };\n\n        if (near) {\n          near.activate();\n          near.emit(cxtEvt);\n          r.hoverData.down = near;\n        } else {\n          cy.emit(cxtEvt);\n        }\n\n        r.hoverData.downTime = new Date().getTime();\n        r.hoverData.cxtDragged = false; // Primary button\n      } else if (e.which == 1) {\n        if (near) {\n          near.activate();\n        } // Element dragging\n\n\n        {\n          // If something is under the cursor and it is draggable, prepare to grab it\n          if (near != null) {\n            if (r.nodeIsGrabbable(near)) {\n              var makeEvent = function makeEvent(type) {\n                return {\n                  originalEvent: e,\n                  type: type,\n                  position: {\n                    x: pos[0],\n                    y: pos[1]\n                  }\n                };\n              };\n\n              var triggerGrab = function triggerGrab(ele) {\n                ele.emit(makeEvent('grab'));\n              };\n\n              setGrabTarget(near);\n\n              if (!near.selected()) {\n                draggedElements = r.dragData.possibleDragElements = cy.collection();\n                addNodeToDrag(near, {\n                  addToList: draggedElements\n                });\n                near.emit(makeEvent('grabon')).emit(makeEvent('grab'));\n              } else {\n                draggedElements = r.dragData.possibleDragElements = cy.collection();\n                var selectedNodes = cy.$(function (ele) {\n                  return ele.isNode() && ele.selected() && r.nodeIsGrabbable(ele);\n                });\n                addNodesToDrag(selectedNodes, {\n                  addToList: draggedElements\n                });\n                near.emit(makeEvent('grabon'));\n                selectedNodes.forEach(triggerGrab);\n              }\n\n              r.redrawHint('eles', true);\n              r.redrawHint('drag', true);\n            }\n          }\n\n          r.hoverData.down = near;\n          r.hoverData.downs = nears;\n          r.hoverData.downTime = new Date().getTime();\n        }\n        triggerEvents(near, ['mousedown', 'tapstart', 'vmousedown'], e, {\n          x: pos[0],\n          y: pos[1]\n        });\n\n        if (near == null) {\n          select[4] = 1;\n          r.data.bgActivePosistion = {\n            x: pos[0],\n            y: pos[1]\n          };\n          r.redrawHint('select', true);\n          r.redraw();\n        } else if (near.pannable()) {\n          select[4] = 1; // for future pan\n        }\n\n        checkForTaphold();\n      } // Initialize selection box coordinates\n\n\n      select[0] = select[2] = pos[0];\n      select[1] = select[3] = pos[1];\n    }, false);\n    r.registerBinding(window, 'mousemove', function mousemoveHandler(e) {\n      // eslint-disable-line no-undef\n      var capture = r.hoverData.capture;\n\n      if (!capture && !eventInContainer(e)) {\n        return;\n      }\n\n      var preventDefault = false;\n      var cy = r.cy;\n      var zoom = cy.zoom();\n      var gpos = [e.clientX, e.clientY];\n      var pos = r.projectIntoViewport(gpos[0], gpos[1]);\n      var mdownPos = r.hoverData.mdownPos;\n      var mdownGPos = r.hoverData.mdownGPos;\n      var select = r.selection;\n      var near = null;\n\n      if (!r.hoverData.draggingEles && !r.hoverData.dragging && !r.hoverData.selecting) {\n        near = r.findNearestElement(pos[0], pos[1], true, false);\n      }\n\n      var last = r.hoverData.last;\n      var down = r.hoverData.down;\n      var disp = [pos[0] - select[2], pos[1] - select[3]];\n      var draggedElements = r.dragData.possibleDragElements;\n      var isOverThresholdDrag;\n\n      if (mdownGPos) {\n        var dx = gpos[0] - mdownGPos[0];\n        var dx2 = dx * dx;\n        var dy = gpos[1] - mdownGPos[1];\n        var dy2 = dy * dy;\n        var dist2 = dx2 + dy2;\n        r.hoverData.isOverThresholdDrag = isOverThresholdDrag = dist2 >= r.desktopTapThreshold2;\n      }\n\n      var multSelKeyDown = isMultSelKeyDown(e);\n\n      if (isOverThresholdDrag) {\n        r.hoverData.tapholdCancelled = true;\n      }\n\n      var updateDragDelta = function updateDragDelta() {\n        var dragDelta = r.hoverData.dragDelta = r.hoverData.dragDelta || [];\n\n        if (dragDelta.length === 0) {\n          dragDelta.push(disp[0]);\n          dragDelta.push(disp[1]);\n        } else {\n          dragDelta[0] += disp[0];\n          dragDelta[1] += disp[1];\n        }\n      };\n\n      preventDefault = true;\n      triggerEvents(near, ['mousemove', 'vmousemove', 'tapdrag'], e, {\n        x: pos[0],\n        y: pos[1]\n      });\n\n      var goIntoBoxMode = function goIntoBoxMode() {\n        r.data.bgActivePosistion = undefined;\n\n        if (!r.hoverData.selecting) {\n          cy.emit({\n            originalEvent: e,\n            type: 'boxstart',\n            position: {\n              x: pos[0],\n              y: pos[1]\n            }\n          });\n        }\n\n        select[4] = 1;\n        r.hoverData.selecting = true;\n        r.redrawHint('select', true);\n        r.redraw();\n      }; // trigger context drag if rmouse down\n\n\n      if (r.hoverData.which === 3) {\n        // but only if over threshold\n        if (isOverThresholdDrag) {\n          var cxtEvt = {\n            originalEvent: e,\n            type: 'cxtdrag',\n            position: {\n              x: pos[0],\n              y: pos[1]\n            }\n          };\n\n          if (down) {\n            down.emit(cxtEvt);\n          } else {\n            cy.emit(cxtEvt);\n          }\n\n          r.hoverData.cxtDragged = true;\n\n          if (!r.hoverData.cxtOver || near !== r.hoverData.cxtOver) {\n            if (r.hoverData.cxtOver) {\n              r.hoverData.cxtOver.emit({\n                originalEvent: e,\n                type: 'cxtdragout',\n                position: {\n                  x: pos[0],\n                  y: pos[1]\n                }\n              });\n            }\n\n            r.hoverData.cxtOver = near;\n\n            if (near) {\n              near.emit({\n                originalEvent: e,\n                type: 'cxtdragover',\n                position: {\n                  x: pos[0],\n                  y: pos[1]\n                }\n              });\n            }\n          }\n        } // Check if we are drag panning the entire graph\n\n      } else if (r.hoverData.dragging) {\n        preventDefault = true;\n\n        if (cy.panningEnabled() && cy.userPanningEnabled()) {\n          var deltaP;\n\n          if (r.hoverData.justStartedPan) {\n            var mdPos = r.hoverData.mdownPos;\n            deltaP = {\n              x: (pos[0] - mdPos[0]) * zoom,\n              y: (pos[1] - mdPos[1]) * zoom\n            };\n            r.hoverData.justStartedPan = false;\n          } else {\n            deltaP = {\n              x: disp[0] * zoom,\n              y: disp[1] * zoom\n            };\n          }\n\n          cy.panBy(deltaP);\n          cy.emit('dragpan');\n          r.hoverData.dragged = true;\n        } // Needs reproject due to pan changing viewport\n\n\n        pos = r.projectIntoViewport(e.clientX, e.clientY); // Checks primary button down & out of time & mouse not moved much\n      } else if (select[4] == 1 && (down == null || down.pannable())) {\n        if (isOverThresholdDrag) {\n          if (!r.hoverData.dragging && cy.boxSelectionEnabled() && (multSelKeyDown || !cy.panningEnabled() || !cy.userPanningEnabled())) {\n            goIntoBoxMode();\n          } else if (!r.hoverData.selecting && cy.panningEnabled() && cy.userPanningEnabled()) {\n            var allowPassthrough = allowPanningPassthrough(down, r.hoverData.downs);\n\n            if (allowPassthrough) {\n              r.hoverData.dragging = true;\n              r.hoverData.justStartedPan = true;\n              select[4] = 0;\n              r.data.bgActivePosistion = array2point(mdownPos);\n              r.redrawHint('select', true);\n              r.redraw();\n            }\n          }\n\n          if (down && down.pannable() && down.active()) {\n            down.unactivate();\n          }\n        }\n      } else {\n        if (down && down.pannable() && down.active()) {\n          down.unactivate();\n        }\n\n        if ((!down || !down.grabbed()) && near != last) {\n          if (last) {\n            triggerEvents(last, ['mouseout', 'tapdragout'], e, {\n              x: pos[0],\n              y: pos[1]\n            });\n          }\n\n          if (near) {\n            triggerEvents(near, ['mouseover', 'tapdragover'], e, {\n              x: pos[0],\n              y: pos[1]\n            });\n          }\n\n          r.hoverData.last = near;\n        }\n\n        if (down) {\n          if (isOverThresholdDrag) {\n            // then we can take action\n            if (cy.boxSelectionEnabled() && multSelKeyDown) {\n              // then selection overrides\n              if (down && down.grabbed()) {\n                freeDraggedElements(draggedElements);\n                down.emit('freeon');\n                draggedElements.emit('free');\n\n                if (r.dragData.didDrag) {\n                  down.emit('dragfreeon');\n                  draggedElements.emit('dragfree');\n                }\n              }\n\n              goIntoBoxMode();\n            } else if (down && down.grabbed() && r.nodeIsDraggable(down)) {\n              // drag node\n              var justStartedDrag = !r.dragData.didDrag;\n\n              if (justStartedDrag) {\n                r.redrawHint('eles', true);\n              }\n\n              r.dragData.didDrag = true; // indicate that we actually did drag the node\n              // now, add the elements to the drag layer if not done already\n\n              if (!r.hoverData.draggingEles) {\n                addNodesToDrag(draggedElements, {\n                  inDragLayer: true\n                });\n              }\n\n              var totalShift = {\n                x: 0,\n                y: 0\n              };\n\n              if (number$1(disp[0]) && number$1(disp[1])) {\n                totalShift.x += disp[0];\n                totalShift.y += disp[1];\n\n                if (justStartedDrag) {\n                  var dragDelta = r.hoverData.dragDelta;\n\n                  if (dragDelta && number$1(dragDelta[0]) && number$1(dragDelta[1])) {\n                    totalShift.x += dragDelta[0];\n                    totalShift.y += dragDelta[1];\n                  }\n                }\n              }\n\n              r.hoverData.draggingEles = true;\n              draggedElements.silentShift(totalShift).emit('position drag');\n              r.redrawHint('drag', true);\n              r.redraw();\n            }\n          } else {\n            // otherwise save drag delta for when we actually start dragging so the relative grab pos is constant\n            updateDragDelta();\n          }\n        } // prevent the dragging from triggering text selection on the page\n\n\n        preventDefault = true;\n      }\n\n      select[2] = pos[0];\n      select[3] = pos[1];\n\n      if (preventDefault) {\n        if (e.stopPropagation) e.stopPropagation();\n        if (e.preventDefault) e.preventDefault();\n        return false;\n      }\n    }, false);\n    var clickTimeout, didDoubleClick, prevClickTimeStamp;\n    r.registerBinding(window, 'mouseup', function mouseupHandler(e) {\n      // eslint-disable-line no-undef\n      var capture = r.hoverData.capture;\n\n      if (!capture) {\n        return;\n      }\n\n      r.hoverData.capture = false;\n      var cy = r.cy;\n      var pos = r.projectIntoViewport(e.clientX, e.clientY);\n      var select = r.selection;\n      var near = r.findNearestElement(pos[0], pos[1], true, false);\n      var draggedElements = r.dragData.possibleDragElements;\n      var down = r.hoverData.down;\n      var multSelKeyDown = isMultSelKeyDown(e);\n\n      if (r.data.bgActivePosistion) {\n        r.redrawHint('select', true);\n        r.redraw();\n      }\n\n      r.hoverData.tapholdCancelled = true;\n      r.data.bgActivePosistion = undefined; // not active bg now\n\n      if (down) {\n        down.unactivate();\n      }\n\n      if (r.hoverData.which === 3) {\n        var cxtEvt = {\n          originalEvent: e,\n          type: 'cxttapend',\n          position: {\n            x: pos[0],\n            y: pos[1]\n          }\n        };\n\n        if (down) {\n          down.emit(cxtEvt);\n        } else {\n          cy.emit(cxtEvt);\n        }\n\n        if (!r.hoverData.cxtDragged) {\n          var cxtTap = {\n            originalEvent: e,\n            type: 'cxttap',\n            position: {\n              x: pos[0],\n              y: pos[1]\n            }\n          };\n\n          if (down) {\n            down.emit(cxtTap);\n          } else {\n            cy.emit(cxtTap);\n          }\n        }\n\n        r.hoverData.cxtDragged = false;\n        r.hoverData.which = null;\n      } else if (r.hoverData.which === 1) {\n        triggerEvents(near, ['mouseup', 'tapend', 'vmouseup'], e, {\n          x: pos[0],\n          y: pos[1]\n        });\n\n        if (!r.dragData.didDrag && // didn't move a node around\n        !r.hoverData.dragged && // didn't pan\n        !r.hoverData.selecting && // not box selection\n        !r.hoverData.isOverThresholdDrag // didn't move too much\n        ) {\n          triggerEvents(down, [\"click\", \"tap\", \"vclick\"], e, {\n            x: pos[0],\n            y: pos[1]\n          });\n          didDoubleClick = false;\n\n          if (e.timeStamp - prevClickTimeStamp <= cy.multiClickDebounceTime()) {\n            clickTimeout && clearTimeout(clickTimeout);\n            didDoubleClick = true;\n            prevClickTimeStamp = null;\n            triggerEvents(down, [\"dblclick\", \"dbltap\", \"vdblclick\"], e, {\n              x: pos[0],\n              y: pos[1]\n            });\n          } else {\n            clickTimeout = setTimeout(function () {\n              if (didDoubleClick) return;\n              triggerEvents(down, [\"oneclick\", \"onetap\", \"voneclick\"], e, {\n                x: pos[0],\n                y: pos[1]\n              });\n            }, cy.multiClickDebounceTime());\n            prevClickTimeStamp = e.timeStamp;\n          }\n        } // Deselect all elements if nothing is currently under the mouse cursor and we aren't dragging something\n\n\n        if (down == null // not mousedown on node\n        && !r.dragData.didDrag // didn't move the node around\n        && !r.hoverData.selecting // not box selection\n        && !r.hoverData.dragged // didn't pan\n        && !isMultSelKeyDown(e)) {\n          cy.$(isSelected).unselect(['tapunselect']);\n\n          if (draggedElements.length > 0) {\n            r.redrawHint('eles', true);\n          }\n\n          r.dragData.possibleDragElements = draggedElements = cy.collection();\n        } // Single selection\n\n\n        if (near == down && !r.dragData.didDrag && !r.hoverData.selecting) {\n          if (near != null && near._private.selectable) {\n            if (r.hoverData.dragging) ; else if (cy.selectionType() === 'additive' || multSelKeyDown) {\n              if (near.selected()) {\n                near.unselect(['tapunselect']);\n              } else {\n                near.select(['tapselect']);\n              }\n            } else {\n              if (!multSelKeyDown) {\n                cy.$(isSelected).unmerge(near).unselect(['tapunselect']);\n                near.select(['tapselect']);\n              }\n            }\n\n            r.redrawHint('eles', true);\n          }\n        }\n\n        if (r.hoverData.selecting) {\n          var box = cy.collection(r.getAllInBox(select[0], select[1], select[2], select[3]));\n          r.redrawHint('select', true);\n\n          if (box.length > 0) {\n            r.redrawHint('eles', true);\n          }\n\n          cy.emit({\n            type: 'boxend',\n            originalEvent: e,\n            position: {\n              x: pos[0],\n              y: pos[1]\n            }\n          });\n\n          var eleWouldBeSelected = function eleWouldBeSelected(ele) {\n            return ele.selectable() && !ele.selected();\n          };\n\n          if (cy.selectionType() === 'additive') {\n            box.emit('box').stdFilter(eleWouldBeSelected).select().emit('boxselect');\n          } else {\n            if (!multSelKeyDown) {\n              cy.$(isSelected).unmerge(box).unselect();\n            }\n\n            box.emit('box').stdFilter(eleWouldBeSelected).select().emit('boxselect');\n          } // always need redraw in case eles unselectable\n\n\n          r.redraw();\n        } // Cancel drag pan\n\n\n        if (r.hoverData.dragging) {\n          r.hoverData.dragging = false;\n          r.redrawHint('select', true);\n          r.redrawHint('eles', true);\n          r.redraw();\n        }\n\n        if (!select[4]) {\n          r.redrawHint('drag', true);\n          r.redrawHint('eles', true);\n          var downWasGrabbed = down && down.grabbed();\n          freeDraggedElements(draggedElements);\n\n          if (downWasGrabbed) {\n            down.emit('freeon');\n            draggedElements.emit('free');\n\n            if (r.dragData.didDrag) {\n              down.emit('dragfreeon');\n              draggedElements.emit('dragfree');\n            }\n          }\n        }\n      } // else not right mouse\n\n\n      select[4] = 0;\n      r.hoverData.down = null;\n      r.hoverData.cxtStarted = false;\n      r.hoverData.draggingEles = false;\n      r.hoverData.selecting = false;\n      r.hoverData.isOverThresholdDrag = false;\n      r.dragData.didDrag = false;\n      r.hoverData.dragged = false;\n      r.hoverData.dragDelta = [];\n      r.hoverData.mdownPos = null;\n      r.hoverData.mdownGPos = null;\n    }, false);\n\n    var wheelHandler = function wheelHandler(e) {\n      if (r.scrollingPage) {\n        return;\n      } // while scrolling, ignore wheel-to-zoom\n\n\n      var cy = r.cy;\n      var zoom = cy.zoom();\n      var pan = cy.pan();\n      var pos = r.projectIntoViewport(e.clientX, e.clientY);\n      var rpos = [pos[0] * zoom + pan.x, pos[1] * zoom + pan.y];\n\n      if (r.hoverData.draggingEles || r.hoverData.dragging || r.hoverData.cxtStarted || inBoxSelection()) {\n        // if pan dragging or cxt dragging, wheel movements make no zoom\n        e.preventDefault();\n        return;\n      }\n\n      if (cy.panningEnabled() && cy.userPanningEnabled() && cy.zoomingEnabled() && cy.userZoomingEnabled()) {\n        e.preventDefault();\n        r.data.wheelZooming = true;\n        clearTimeout(r.data.wheelTimeout);\n        r.data.wheelTimeout = setTimeout(function () {\n          r.data.wheelZooming = false;\n          r.redrawHint('eles', true);\n          r.redraw();\n        }, 150);\n        var diff;\n\n        if (e.deltaY != null) {\n          diff = e.deltaY / -250;\n        } else if (e.wheelDeltaY != null) {\n          diff = e.wheelDeltaY / 1000;\n        } else {\n          diff = e.wheelDelta / 1000;\n        }\n\n        diff = diff * r.wheelSensitivity;\n        var needsWheelFix = e.deltaMode === 1;\n\n        if (needsWheelFix) {\n          // fixes slow wheel events on ff/linux and ff/windows\n          diff *= 33;\n        }\n\n        var newZoom = cy.zoom() * Math.pow(10, diff);\n\n        if (e.type === 'gesturechange') {\n          newZoom = r.gestureStartZoom * e.scale;\n        }\n\n        cy.zoom({\n          level: newZoom,\n          renderedPosition: {\n            x: rpos[0],\n            y: rpos[1]\n          }\n        });\n        cy.emit(e.type === 'gesturechange' ? 'pinchzoom' : 'scrollzoom');\n      }\n    }; // Functions to help with whether mouse wheel should trigger zooming\n    // --\n\n\n    r.registerBinding(r.container, 'wheel', wheelHandler, true); // disable nonstandard wheel events\n    // r.registerBinding(r.container, 'mousewheel', wheelHandler, true);\n    // r.registerBinding(r.container, 'DOMMouseScroll', wheelHandler, true);\n    // r.registerBinding(r.container, 'MozMousePixelScroll', wheelHandler, true); // older firefox\n\n    r.registerBinding(window, 'scroll', function scrollHandler(e) {\n      // eslint-disable-line no-unused-vars\n      r.scrollingPage = true;\n      clearTimeout(r.scrollingPageTimeout);\n      r.scrollingPageTimeout = setTimeout(function () {\n        r.scrollingPage = false;\n      }, 250);\n    }, true); // desktop safari pinch to zoom start\n\n    r.registerBinding(r.container, 'gesturestart', function gestureStartHandler(e) {\n      r.gestureStartZoom = r.cy.zoom();\n\n      if (!r.hasTouchStarted) {\n        // don't affect touch devices like iphone\n        e.preventDefault();\n      }\n    }, true);\n    r.registerBinding(r.container, 'gesturechange', function (e) {\n      if (!r.hasTouchStarted) {\n        // don't affect touch devices like iphone\n        wheelHandler(e);\n      }\n    }, true); // Functions to help with handling mouseout/mouseover on the Cytoscape container\n    // Handle mouseout on Cytoscape container\n\n    r.registerBinding(r.container, 'mouseout', function mouseOutHandler(e) {\n      var pos = r.projectIntoViewport(e.clientX, e.clientY);\n      r.cy.emit({\n        originalEvent: e,\n        type: 'mouseout',\n        position: {\n          x: pos[0],\n          y: pos[1]\n        }\n      });\n    }, false);\n    r.registerBinding(r.container, 'mouseover', function mouseOverHandler(e) {\n      var pos = r.projectIntoViewport(e.clientX, e.clientY);\n      r.cy.emit({\n        originalEvent: e,\n        type: 'mouseover',\n        position: {\n          x: pos[0],\n          y: pos[1]\n        }\n      });\n    }, false);\n    var f1x1, f1y1, f2x1, f2y1; // starting points for pinch-to-zoom\n\n    var distance1, distance1Sq; // initial distance between finger 1 and finger 2 for pinch-to-zoom\n\n    var center1, modelCenter1; // center point on start pinch to zoom\n\n    var offsetLeft, offsetTop;\n    var containerWidth, containerHeight;\n    var twoFingersStartInside;\n\n    var distance = function distance(x1, y1, x2, y2) {\n      return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n    };\n\n    var distanceSq = function distanceSq(x1, y1, x2, y2) {\n      return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\n    };\n\n    var touchstartHandler;\n    r.registerBinding(r.container, 'touchstart', touchstartHandler = function touchstartHandler(e) {\n      r.hasTouchStarted = true;\n\n      if (!eventInContainer(e)) {\n        return;\n      }\n\n      blurActiveDomElement();\n      r.touchData.capture = true;\n      r.data.bgActivePosistion = undefined;\n      var cy = r.cy;\n      var now = r.touchData.now;\n      var earlier = r.touchData.earlier;\n\n      if (e.touches[0]) {\n        var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);\n        now[0] = pos[0];\n        now[1] = pos[1];\n      }\n\n      if (e.touches[1]) {\n        var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);\n        now[2] = pos[0];\n        now[3] = pos[1];\n      }\n\n      if (e.touches[2]) {\n        var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);\n        now[4] = pos[0];\n        now[5] = pos[1];\n      } // record starting points for pinch-to-zoom\n\n\n      if (e.touches[1]) {\n        r.touchData.singleTouchMoved = true;\n        freeDraggedElements(r.dragData.touchDragEles);\n        var offsets = r.findContainerClientCoords();\n        offsetLeft = offsets[0];\n        offsetTop = offsets[1];\n        containerWidth = offsets[2];\n        containerHeight = offsets[3];\n        f1x1 = e.touches[0].clientX - offsetLeft;\n        f1y1 = e.touches[0].clientY - offsetTop;\n        f2x1 = e.touches[1].clientX - offsetLeft;\n        f2y1 = e.touches[1].clientY - offsetTop;\n        twoFingersStartInside = 0 <= f1x1 && f1x1 <= containerWidth && 0 <= f2x1 && f2x1 <= containerWidth && 0 <= f1y1 && f1y1 <= containerHeight && 0 <= f2y1 && f2y1 <= containerHeight;\n        var pan = cy.pan();\n        var zoom = cy.zoom();\n        distance1 = distance(f1x1, f1y1, f2x1, f2y1);\n        distance1Sq = distanceSq(f1x1, f1y1, f2x1, f2y1);\n        center1 = [(f1x1 + f2x1) / 2, (f1y1 + f2y1) / 2];\n        modelCenter1 = [(center1[0] - pan.x) / zoom, (center1[1] - pan.y) / zoom]; // consider context tap\n\n        var cxtDistThreshold = 200;\n        var cxtDistThresholdSq = cxtDistThreshold * cxtDistThreshold;\n\n        if (distance1Sq < cxtDistThresholdSq && !e.touches[2]) {\n          var near1 = r.findNearestElement(now[0], now[1], true, true);\n          var near2 = r.findNearestElement(now[2], now[3], true, true);\n\n          if (near1 && near1.isNode()) {\n            near1.activate().emit({\n              originalEvent: e,\n              type: 'cxttapstart',\n              position: {\n                x: now[0],\n                y: now[1]\n              }\n            });\n            r.touchData.start = near1;\n          } else if (near2 && near2.isNode()) {\n            near2.activate().emit({\n              originalEvent: e,\n              type: 'cxttapstart',\n              position: {\n                x: now[0],\n                y: now[1]\n              }\n            });\n            r.touchData.start = near2;\n          } else {\n            cy.emit({\n              originalEvent: e,\n              type: 'cxttapstart',\n              position: {\n                x: now[0],\n                y: now[1]\n              }\n            });\n          }\n\n          if (r.touchData.start) {\n            r.touchData.start._private.grabbed = false;\n          }\n\n          r.touchData.cxt = true;\n          r.touchData.cxtDragged = false;\n          r.data.bgActivePosistion = undefined;\n          r.redraw();\n          return;\n        }\n      }\n\n      if (e.touches[2]) {\n        // ignore\n        // safari on ios pans the page otherwise (normally you should be able to preventdefault on touchmove...)\n        if (cy.boxSelectionEnabled()) {\n          e.preventDefault();\n        }\n      } else if (e.touches[1]) ; else if (e.touches[0]) {\n        var nears = r.findNearestElements(now[0], now[1], true, true);\n        var near = nears[0];\n\n        if (near != null) {\n          near.activate();\n          r.touchData.start = near;\n          r.touchData.starts = nears;\n\n          if (r.nodeIsGrabbable(near)) {\n            var draggedEles = r.dragData.touchDragEles = cy.collection();\n            var selectedNodes = null;\n            r.redrawHint('eles', true);\n            r.redrawHint('drag', true);\n\n            if (near.selected()) {\n              // reset drag elements, since near will be added again\n              selectedNodes = cy.$(function (ele) {\n                return ele.selected() && r.nodeIsGrabbable(ele);\n              });\n              addNodesToDrag(selectedNodes, {\n                addToList: draggedEles\n              });\n            } else {\n              addNodeToDrag(near, {\n                addToList: draggedEles\n              });\n            }\n\n            setGrabTarget(near);\n\n            var makeEvent = function makeEvent(type) {\n              return {\n                originalEvent: e,\n                type: type,\n                position: {\n                  x: now[0],\n                  y: now[1]\n                }\n              };\n            };\n\n            near.emit(makeEvent('grabon'));\n\n            if (selectedNodes) {\n              selectedNodes.forEach(function (n) {\n                n.emit(makeEvent('grab'));\n              });\n            } else {\n              near.emit(makeEvent('grab'));\n            }\n          }\n        }\n\n        triggerEvents(near, ['touchstart', 'tapstart', 'vmousedown'], e, {\n          x: now[0],\n          y: now[1]\n        });\n\n        if (near == null) {\n          r.data.bgActivePosistion = {\n            x: pos[0],\n            y: pos[1]\n          };\n          r.redrawHint('select', true);\n          r.redraw();\n        } // Tap, taphold\n        // -----\n\n\n        r.touchData.singleTouchMoved = false;\n        r.touchData.singleTouchStartTime = +new Date();\n        clearTimeout(r.touchData.tapholdTimeout);\n        r.touchData.tapholdTimeout = setTimeout(function () {\n          if (r.touchData.singleTouchMoved === false && !r.pinching // if pinching, then taphold unselect shouldn't take effect\n          && !r.touchData.selecting // box selection shouldn't allow taphold through\n          ) {\n            triggerEvents(r.touchData.start, ['taphold'], e, {\n              x: now[0],\n              y: now[1]\n            });\n          }\n        }, r.tapholdDuration);\n      }\n\n      if (e.touches.length >= 1) {\n        var sPos = r.touchData.startPosition = [];\n\n        for (var i = 0; i < now.length; i++) {\n          sPos[i] = earlier[i] = now[i];\n        }\n\n        var touch0 = e.touches[0];\n        r.touchData.startGPosition = [touch0.clientX, touch0.clientY];\n      }\n    }, false);\n    var touchmoveHandler;\n    r.registerBinding(window, 'touchmove', touchmoveHandler = function touchmoveHandler(e) {\n      // eslint-disable-line no-undef\n      var capture = r.touchData.capture;\n\n      if (!capture && !eventInContainer(e)) {\n        return;\n      }\n\n      var select = r.selection;\n      var cy = r.cy;\n      var now = r.touchData.now;\n      var earlier = r.touchData.earlier;\n      var zoom = cy.zoom();\n\n      if (e.touches[0]) {\n        var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);\n        now[0] = pos[0];\n        now[1] = pos[1];\n      }\n\n      if (e.touches[1]) {\n        var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);\n        now[2] = pos[0];\n        now[3] = pos[1];\n      }\n\n      if (e.touches[2]) {\n        var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);\n        now[4] = pos[0];\n        now[5] = pos[1];\n      }\n\n      var startGPos = r.touchData.startGPosition;\n      var isOverThresholdDrag;\n\n      if (capture && e.touches[0] && startGPos) {\n        var disp = [];\n\n        for (var j = 0; j < now.length; j++) {\n          disp[j] = now[j] - earlier[j];\n        }\n\n        var dx = e.touches[0].clientX - startGPos[0];\n        var dx2 = dx * dx;\n        var dy = e.touches[0].clientY - startGPos[1];\n        var dy2 = dy * dy;\n        var dist2 = dx2 + dy2;\n        isOverThresholdDrag = dist2 >= r.touchTapThreshold2;\n      } // context swipe cancelling\n\n\n      if (capture && r.touchData.cxt) {\n        e.preventDefault();\n        var f1x2 = e.touches[0].clientX - offsetLeft,\n            f1y2 = e.touches[0].clientY - offsetTop;\n        var f2x2 = e.touches[1].clientX - offsetLeft,\n            f2y2 = e.touches[1].clientY - offsetTop; // var distance2 = distance( f1x2, f1y2, f2x2, f2y2 );\n\n        var distance2Sq = distanceSq(f1x2, f1y2, f2x2, f2y2);\n        var factorSq = distance2Sq / distance1Sq;\n        var distThreshold = 150;\n        var distThresholdSq = distThreshold * distThreshold;\n        var factorThreshold = 1.5;\n        var factorThresholdSq = factorThreshold * factorThreshold; // cancel ctx gestures if the distance b/t the fingers increases\n\n        if (factorSq >= factorThresholdSq || distance2Sq >= distThresholdSq) {\n          r.touchData.cxt = false;\n          r.data.bgActivePosistion = undefined;\n          r.redrawHint('select', true);\n          var cxtEvt = {\n            originalEvent: e,\n            type: 'cxttapend',\n            position: {\n              x: now[0],\n              y: now[1]\n            }\n          };\n\n          if (r.touchData.start) {\n            r.touchData.start.unactivate().emit(cxtEvt);\n            r.touchData.start = null;\n          } else {\n            cy.emit(cxtEvt);\n          }\n        }\n      } // context swipe\n\n\n      if (capture && r.touchData.cxt) {\n        var cxtEvt = {\n          originalEvent: e,\n          type: 'cxtdrag',\n          position: {\n            x: now[0],\n            y: now[1]\n          }\n        };\n        r.data.bgActivePosistion = undefined;\n        r.redrawHint('select', true);\n\n        if (r.touchData.start) {\n          r.touchData.start.emit(cxtEvt);\n        } else {\n          cy.emit(cxtEvt);\n        }\n\n        if (r.touchData.start) {\n          r.touchData.start._private.grabbed = false;\n        }\n\n        r.touchData.cxtDragged = true;\n        var near = r.findNearestElement(now[0], now[1], true, true);\n\n        if (!r.touchData.cxtOver || near !== r.touchData.cxtOver) {\n          if (r.touchData.cxtOver) {\n            r.touchData.cxtOver.emit({\n              originalEvent: e,\n              type: 'cxtdragout',\n              position: {\n                x: now[0],\n                y: now[1]\n              }\n            });\n          }\n\n          r.touchData.cxtOver = near;\n\n          if (near) {\n            near.emit({\n              originalEvent: e,\n              type: 'cxtdragover',\n              position: {\n                x: now[0],\n                y: now[1]\n              }\n            });\n          }\n        } // box selection\n\n      } else if (capture && e.touches[2] && cy.boxSelectionEnabled()) {\n        e.preventDefault();\n        r.data.bgActivePosistion = undefined;\n        this.lastThreeTouch = +new Date();\n\n        if (!r.touchData.selecting) {\n          cy.emit({\n            originalEvent: e,\n            type: 'boxstart',\n            position: {\n              x: now[0],\n              y: now[1]\n            }\n          });\n        }\n\n        r.touchData.selecting = true;\n        r.touchData.didSelect = true;\n        select[4] = 1;\n\n        if (!select || select.length === 0 || select[0] === undefined) {\n          select[0] = (now[0] + now[2] + now[4]) / 3;\n          select[1] = (now[1] + now[3] + now[5]) / 3;\n          select[2] = (now[0] + now[2] + now[4]) / 3 + 1;\n          select[3] = (now[1] + now[3] + now[5]) / 3 + 1;\n        } else {\n          select[2] = (now[0] + now[2] + now[4]) / 3;\n          select[3] = (now[1] + now[3] + now[5]) / 3;\n        }\n\n        r.redrawHint('select', true);\n        r.redraw(); // pinch to zoom\n      } else if (capture && e.touches[1] && !r.touchData.didSelect // don't allow box selection to degrade to pinch-to-zoom\n      && cy.zoomingEnabled() && cy.panningEnabled() && cy.userZoomingEnabled() && cy.userPanningEnabled()) {\n        // two fingers => pinch to zoom\n        e.preventDefault();\n        r.data.bgActivePosistion = undefined;\n        r.redrawHint('select', true);\n        var draggedEles = r.dragData.touchDragEles;\n\n        if (draggedEles) {\n          r.redrawHint('drag', true);\n\n          for (var i = 0; i < draggedEles.length; i++) {\n            var de_p = draggedEles[i]._private;\n            de_p.grabbed = false;\n            de_p.rscratch.inDragLayer = false;\n          }\n        }\n\n        var _start = r.touchData.start; // (x2, y2) for fingers 1 and 2\n\n        var f1x2 = e.touches[0].clientX - offsetLeft,\n            f1y2 = e.touches[0].clientY - offsetTop;\n        var f2x2 = e.touches[1].clientX - offsetLeft,\n            f2y2 = e.touches[1].clientY - offsetTop;\n        var distance2 = distance(f1x2, f1y2, f2x2, f2y2); // var distance2Sq = distanceSq( f1x2, f1y2, f2x2, f2y2 );\n        // var factor = Math.sqrt( distance2Sq ) / Math.sqrt( distance1Sq );\n\n        var factor = distance2 / distance1;\n\n        if (twoFingersStartInside) {\n          // delta finger1\n          var df1x = f1x2 - f1x1;\n          var df1y = f1y2 - f1y1; // delta finger 2\n\n          var df2x = f2x2 - f2x1;\n          var df2y = f2y2 - f2y1; // translation is the normalised vector of the two fingers movement\n          // i.e. so pinching cancels out and moving together pans\n\n          var tx = (df1x + df2x) / 2;\n          var ty = (df1y + df2y) / 2; // now calculate the zoom\n\n          var zoom1 = cy.zoom();\n          var zoom2 = zoom1 * factor;\n          var pan1 = cy.pan(); // the model center point converted to the current rendered pos\n\n          var ctrx = modelCenter1[0] * zoom1 + pan1.x;\n          var ctry = modelCenter1[1] * zoom1 + pan1.y;\n          var pan2 = {\n            x: -zoom2 / zoom1 * (ctrx - pan1.x - tx) + ctrx,\n            y: -zoom2 / zoom1 * (ctry - pan1.y - ty) + ctry\n          }; // remove dragged eles\n\n          if (_start && _start.active()) {\n            var draggedEles = r.dragData.touchDragEles;\n            freeDraggedElements(draggedEles);\n            r.redrawHint('drag', true);\n            r.redrawHint('eles', true);\n\n            _start.unactivate().emit('freeon');\n\n            draggedEles.emit('free');\n\n            if (r.dragData.didDrag) {\n              _start.emit('dragfreeon');\n\n              draggedEles.emit('dragfree');\n            }\n          }\n\n          cy.viewport({\n            zoom: zoom2,\n            pan: pan2,\n            cancelOnFailedZoom: true\n          });\n          cy.emit('pinchzoom');\n          distance1 = distance2;\n          f1x1 = f1x2;\n          f1y1 = f1y2;\n          f2x1 = f2x2;\n          f2y1 = f2y2;\n          r.pinching = true;\n        } // Re-project\n\n\n        if (e.touches[0]) {\n          var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);\n          now[0] = pos[0];\n          now[1] = pos[1];\n        }\n\n        if (e.touches[1]) {\n          var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);\n          now[2] = pos[0];\n          now[3] = pos[1];\n        }\n\n        if (e.touches[2]) {\n          var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);\n          now[4] = pos[0];\n          now[5] = pos[1];\n        }\n      } else if (e.touches[0] && !r.touchData.didSelect // don't allow box selection to degrade to single finger events like panning\n      ) {\n        var start = r.touchData.start;\n        var last = r.touchData.last;\n        var near;\n\n        if (!r.hoverData.draggingEles && !r.swipePanning) {\n          near = r.findNearestElement(now[0], now[1], true, true);\n        }\n\n        if (capture && start != null) {\n          e.preventDefault();\n        } // dragging nodes\n\n\n        if (capture && start != null && r.nodeIsDraggable(start)) {\n          if (isOverThresholdDrag) {\n            // then dragging can happen\n            var draggedEles = r.dragData.touchDragEles;\n            var justStartedDrag = !r.dragData.didDrag;\n\n            if (justStartedDrag) {\n              addNodesToDrag(draggedEles, {\n                inDragLayer: true\n              });\n            }\n\n            r.dragData.didDrag = true;\n            var totalShift = {\n              x: 0,\n              y: 0\n            };\n\n            if (number$1(disp[0]) && number$1(disp[1])) {\n              totalShift.x += disp[0];\n              totalShift.y += disp[1];\n\n              if (justStartedDrag) {\n                r.redrawHint('eles', true);\n                var dragDelta = r.touchData.dragDelta;\n\n                if (dragDelta && number$1(dragDelta[0]) && number$1(dragDelta[1])) {\n                  totalShift.x += dragDelta[0];\n                  totalShift.y += dragDelta[1];\n                }\n              }\n            }\n\n            r.hoverData.draggingEles = true;\n            draggedEles.silentShift(totalShift).emit('position drag');\n            r.redrawHint('drag', true);\n\n            if (r.touchData.startPosition[0] == earlier[0] && r.touchData.startPosition[1] == earlier[1]) {\n              r.redrawHint('eles', true);\n            }\n\n            r.redraw();\n          } else {\n            // otherwise keep track of drag delta for later\n            var dragDelta = r.touchData.dragDelta = r.touchData.dragDelta || [];\n\n            if (dragDelta.length === 0) {\n              dragDelta.push(disp[0]);\n              dragDelta.push(disp[1]);\n            } else {\n              dragDelta[0] += disp[0];\n              dragDelta[1] += disp[1];\n            }\n          }\n        } // touchmove\n\n\n        {\n          triggerEvents(start || near, ['touchmove', 'tapdrag', 'vmousemove'], e, {\n            x: now[0],\n            y: now[1]\n          });\n\n          if ((!start || !start.grabbed()) && near != last) {\n            if (last) {\n              last.emit({\n                originalEvent: e,\n                type: 'tapdragout',\n                position: {\n                  x: now[0],\n                  y: now[1]\n                }\n              });\n            }\n\n            if (near) {\n              near.emit({\n                originalEvent: e,\n                type: 'tapdragover',\n                position: {\n                  x: now[0],\n                  y: now[1]\n                }\n              });\n            }\n          }\n\n          r.touchData.last = near;\n        } // check to cancel taphold\n\n        if (capture) {\n          for (var i = 0; i < now.length; i++) {\n            if (now[i] && r.touchData.startPosition[i] && isOverThresholdDrag) {\n              r.touchData.singleTouchMoved = true;\n            }\n          }\n        } // panning\n\n\n        if (capture && (start == null || start.pannable()) && cy.panningEnabled() && cy.userPanningEnabled()) {\n          var allowPassthrough = allowPanningPassthrough(start, r.touchData.starts);\n\n          if (allowPassthrough) {\n            e.preventDefault();\n\n            if (!r.data.bgActivePosistion) {\n              r.data.bgActivePosistion = array2point(r.touchData.startPosition);\n            }\n\n            if (r.swipePanning) {\n              cy.panBy({\n                x: disp[0] * zoom,\n                y: disp[1] * zoom\n              });\n              cy.emit('dragpan');\n            } else if (isOverThresholdDrag) {\n              r.swipePanning = true;\n              cy.panBy({\n                x: dx * zoom,\n                y: dy * zoom\n              });\n              cy.emit('dragpan');\n\n              if (start) {\n                start.unactivate();\n                r.redrawHint('select', true);\n                r.touchData.start = null;\n              }\n            }\n          } // Re-project\n\n\n          var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);\n          now[0] = pos[0];\n          now[1] = pos[1];\n        }\n      }\n\n      for (var j = 0; j < now.length; j++) {\n        earlier[j] = now[j];\n      } // the active bg indicator should be removed when making a swipe that is neither for dragging nodes or panning\n\n\n      if (capture && e.touches.length > 0 && !r.hoverData.draggingEles && !r.swipePanning && r.data.bgActivePosistion != null) {\n        r.data.bgActivePosistion = undefined;\n        r.redrawHint('select', true);\n        r.redraw();\n      }\n    }, false);\n    var touchcancelHandler;\n    r.registerBinding(window, 'touchcancel', touchcancelHandler = function touchcancelHandler(e) {\n      // eslint-disable-line no-unused-vars\n      var start = r.touchData.start;\n      r.touchData.capture = false;\n\n      if (start) {\n        start.unactivate();\n      }\n    });\n    var touchendHandler, didDoubleTouch, touchTimeout, prevTouchTimeStamp;\n    r.registerBinding(window, 'touchend', touchendHandler = function touchendHandler(e) {\n      // eslint-disable-line no-unused-vars\n      var start = r.touchData.start;\n      var capture = r.touchData.capture;\n\n      if (capture) {\n        if (e.touches.length === 0) {\n          r.touchData.capture = false;\n        }\n\n        e.preventDefault();\n      } else {\n        return;\n      }\n\n      var select = r.selection;\n      r.swipePanning = false;\n      r.hoverData.draggingEles = false;\n      var cy = r.cy;\n      var zoom = cy.zoom();\n      var now = r.touchData.now;\n      var earlier = r.touchData.earlier;\n\n      if (e.touches[0]) {\n        var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);\n        now[0] = pos[0];\n        now[1] = pos[1];\n      }\n\n      if (e.touches[1]) {\n        var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);\n        now[2] = pos[0];\n        now[3] = pos[1];\n      }\n\n      if (e.touches[2]) {\n        var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);\n        now[4] = pos[0];\n        now[5] = pos[1];\n      }\n\n      if (start) {\n        start.unactivate();\n      }\n\n      var ctxTapend;\n\n      if (r.touchData.cxt) {\n        ctxTapend = {\n          originalEvent: e,\n          type: 'cxttapend',\n          position: {\n            x: now[0],\n            y: now[1]\n          }\n        };\n\n        if (start) {\n          start.emit(ctxTapend);\n        } else {\n          cy.emit(ctxTapend);\n        }\n\n        if (!r.touchData.cxtDragged) {\n          var ctxTap = {\n            originalEvent: e,\n            type: 'cxttap',\n            position: {\n              x: now[0],\n              y: now[1]\n            }\n          };\n\n          if (start) {\n            start.emit(ctxTap);\n          } else {\n            cy.emit(ctxTap);\n          }\n        }\n\n        if (r.touchData.start) {\n          r.touchData.start._private.grabbed = false;\n        }\n\n        r.touchData.cxt = false;\n        r.touchData.start = null;\n        r.redraw();\n        return;\n      } // no more box selection if we don't have three fingers\n\n\n      if (!e.touches[2] && cy.boxSelectionEnabled() && r.touchData.selecting) {\n        r.touchData.selecting = false;\n        var box = cy.collection(r.getAllInBox(select[0], select[1], select[2], select[3]));\n        select[0] = undefined;\n        select[1] = undefined;\n        select[2] = undefined;\n        select[3] = undefined;\n        select[4] = 0;\n        r.redrawHint('select', true);\n        cy.emit({\n          type: 'boxend',\n          originalEvent: e,\n          position: {\n            x: now[0],\n            y: now[1]\n          }\n        });\n\n        var eleWouldBeSelected = function eleWouldBeSelected(ele) {\n          return ele.selectable() && !ele.selected();\n        };\n\n        box.emit('box').stdFilter(eleWouldBeSelected).select().emit('boxselect');\n\n        if (box.nonempty()) {\n          r.redrawHint('eles', true);\n        }\n\n        r.redraw();\n      }\n\n      if (start != null) {\n        start.unactivate();\n      }\n\n      if (e.touches[2]) {\n        r.data.bgActivePosistion = undefined;\n        r.redrawHint('select', true);\n      } else if (e.touches[1]) ; else if (e.touches[0]) ; else if (!e.touches[0]) {\n        r.data.bgActivePosistion = undefined;\n        r.redrawHint('select', true);\n        var draggedEles = r.dragData.touchDragEles;\n\n        if (start != null) {\n          var startWasGrabbed = start._private.grabbed;\n          freeDraggedElements(draggedEles);\n          r.redrawHint('drag', true);\n          r.redrawHint('eles', true);\n\n          if (startWasGrabbed) {\n            start.emit('freeon');\n            draggedEles.emit('free');\n\n            if (r.dragData.didDrag) {\n              start.emit('dragfreeon');\n              draggedEles.emit('dragfree');\n            }\n          }\n\n          triggerEvents(start, ['touchend', 'tapend', 'vmouseup', 'tapdragout'], e, {\n            x: now[0],\n            y: now[1]\n          });\n          start.unactivate();\n          r.touchData.start = null;\n        } else {\n          var near = r.findNearestElement(now[0], now[1], true, true);\n          triggerEvents(near, ['touchend', 'tapend', 'vmouseup', 'tapdragout'], e, {\n            x: now[0],\n            y: now[1]\n          });\n        }\n\n        var dx = r.touchData.startPosition[0] - now[0];\n        var dx2 = dx * dx;\n        var dy = r.touchData.startPosition[1] - now[1];\n        var dy2 = dy * dy;\n        var dist2 = dx2 + dy2;\n        var rdist2 = dist2 * zoom * zoom; // Tap event, roughly same as mouse click event for touch\n\n        if (!r.touchData.singleTouchMoved) {\n          if (!start) {\n            cy.$(':selected').unselect(['tapunselect']);\n          }\n\n          triggerEvents(start, ['tap', 'vclick'], e, {\n            x: now[0],\n            y: now[1]\n          });\n          didDoubleTouch = false;\n\n          if (e.timeStamp - prevTouchTimeStamp <= cy.multiClickDebounceTime()) {\n            touchTimeout && clearTimeout(touchTimeout);\n            didDoubleTouch = true;\n            prevTouchTimeStamp = null;\n            triggerEvents(start, ['dbltap', 'vdblclick'], e, {\n              x: now[0],\n              y: now[1]\n            });\n          } else {\n            touchTimeout = setTimeout(function () {\n              if (didDoubleTouch) return;\n              triggerEvents(start, ['onetap', 'voneclick'], e, {\n                x: now[0],\n                y: now[1]\n              });\n            }, cy.multiClickDebounceTime());\n            prevTouchTimeStamp = e.timeStamp;\n          }\n        } // Prepare to select the currently touched node, only if it hasn't been dragged past a certain distance\n\n\n        if (start != null && !r.dragData.didDrag // didn't drag nodes around\n        && start._private.selectable && rdist2 < r.touchTapThreshold2 && !r.pinching // pinch to zoom should not affect selection\n        ) {\n          if (cy.selectionType() === 'single') {\n            cy.$(isSelected).unmerge(start).unselect(['tapunselect']);\n            start.select(['tapselect']);\n          } else {\n            if (start.selected()) {\n              start.unselect(['tapunselect']);\n            } else {\n              start.select(['tapselect']);\n            }\n          }\n\n          r.redrawHint('eles', true);\n        }\n\n        r.touchData.singleTouchMoved = true;\n      }\n\n      for (var j = 0; j < now.length; j++) {\n        earlier[j] = now[j];\n      }\n\n      r.dragData.didDrag = false; // reset for next touchstart\n\n      if (e.touches.length === 0) {\n        r.touchData.dragDelta = [];\n        r.touchData.startPosition = null;\n        r.touchData.startGPosition = null;\n        r.touchData.didSelect = false;\n      }\n\n      if (e.touches.length < 2) {\n        if (e.touches.length === 1) {\n          // the old start global pos'n may not be the same finger that remains\n          r.touchData.startGPosition = [e.touches[0].clientX, e.touches[0].clientY];\n        }\n\n        r.pinching = false;\n        r.redrawHint('eles', true);\n        r.redraw();\n      } //r.redraw();\n\n    }, false); // fallback compatibility layer for ms pointer events\n\n    if (typeof TouchEvent === 'undefined') {\n      var pointers = [];\n\n      var makeTouch = function makeTouch(e) {\n        return {\n          clientX: e.clientX,\n          clientY: e.clientY,\n          force: 1,\n          identifier: e.pointerId,\n          pageX: e.pageX,\n          pageY: e.pageY,\n          radiusX: e.width / 2,\n          radiusY: e.height / 2,\n          screenX: e.screenX,\n          screenY: e.screenY,\n          target: e.target\n        };\n      };\n\n      var makePointer = function makePointer(e) {\n        return {\n          event: e,\n          touch: makeTouch(e)\n        };\n      };\n\n      var addPointer = function addPointer(e) {\n        pointers.push(makePointer(e));\n      };\n\n      var removePointer = function removePointer(e) {\n        for (var i = 0; i < pointers.length; i++) {\n          var p = pointers[i];\n\n          if (p.event.pointerId === e.pointerId) {\n            pointers.splice(i, 1);\n            return;\n          }\n        }\n      };\n\n      var updatePointer = function updatePointer(e) {\n        var p = pointers.filter(function (p) {\n          return p.event.pointerId === e.pointerId;\n        })[0];\n        p.event = e;\n        p.touch = makeTouch(e);\n      };\n\n      var addTouchesToEvent = function addTouchesToEvent(e) {\n        e.touches = pointers.map(function (p) {\n          return p.touch;\n        });\n      };\n\n      var pointerIsMouse = function pointerIsMouse(e) {\n        return e.pointerType === 'mouse' || e.pointerType === 4;\n      };\n\n      r.registerBinding(r.container, 'pointerdown', function (e) {\n        if (pointerIsMouse(e)) {\n          return;\n        } // mouse already handled\n\n\n        e.preventDefault();\n        addPointer(e);\n        addTouchesToEvent(e);\n        touchstartHandler(e);\n      });\n      r.registerBinding(r.container, 'pointerup', function (e) {\n        if (pointerIsMouse(e)) {\n          return;\n        } // mouse already handled\n\n\n        removePointer(e);\n        addTouchesToEvent(e);\n        touchendHandler(e);\n      });\n      r.registerBinding(r.container, 'pointercancel', function (e) {\n        if (pointerIsMouse(e)) {\n          return;\n        } // mouse already handled\n\n\n        removePointer(e);\n        addTouchesToEvent(e);\n        touchcancelHandler(e);\n      });\n      r.registerBinding(r.container, 'pointermove', function (e) {\n        if (pointerIsMouse(e)) {\n          return;\n        } // mouse already handled\n\n\n        e.preventDefault();\n        updatePointer(e);\n        addTouchesToEvent(e);\n        touchmoveHandler(e);\n      });\n    }\n  };\n\n  var BRp$2 = {};\n\n  BRp$2.generatePolygon = function (name, points) {\n    return this.nodeShapes[name] = {\n      renderer: this,\n      name: name,\n      points: points,\n      draw: function draw(context, centerX, centerY, width, height) {\n        this.renderer.nodeShapeImpl('polygon', context, centerX, centerY, width, height, this.points);\n      },\n      intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {\n        return polygonIntersectLine(x, y, this.points, nodeX, nodeY, width / 2, height / 2, padding);\n      },\n      checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {\n        return pointInsidePolygon(x, y, this.points, centerX, centerY, width, height, [0, -1], padding);\n      }\n    };\n  };\n\n  BRp$2.generateEllipse = function () {\n    return this.nodeShapes['ellipse'] = {\n      renderer: this,\n      name: 'ellipse',\n      draw: function draw(context, centerX, centerY, width, height) {\n        this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);\n      },\n      intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {\n        return intersectLineEllipse(x, y, nodeX, nodeY, width / 2 + padding, height / 2 + padding);\n      },\n      checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {\n        return checkInEllipse(x, y, width, height, centerX, centerY, padding);\n      }\n    };\n  };\n\n  BRp$2.generateRoundPolygon = function (name, points) {\n    // Pre-compute control points\n    // Since these points depend on the radius length (which in turns depend on the width/height of the node) we will only pre-compute\n    // the unit vectors.\n    // For simplicity the layout will be:\n    // [ p0, UnitVectorP0P1, p1, UniVectorP1P2, ..., pn, UnitVectorPnP0 ]\n    var allPoints = new Array(points.length * 2);\n\n    for (var i = 0; i < points.length / 2; i++) {\n      var sourceIndex = i * 2;\n      var destIndex = void 0;\n\n      if (i < points.length / 2 - 1) {\n        destIndex = (i + 1) * 2;\n      } else {\n        destIndex = 0;\n      }\n\n      allPoints[i * 4] = points[sourceIndex];\n      allPoints[i * 4 + 1] = points[sourceIndex + 1];\n      var xDest = points[destIndex] - points[sourceIndex];\n      var yDest = points[destIndex + 1] - points[sourceIndex + 1];\n      var norm = Math.sqrt(xDest * xDest + yDest * yDest);\n      allPoints[i * 4 + 2] = xDest / norm;\n      allPoints[i * 4 + 3] = yDest / norm;\n    }\n\n    return this.nodeShapes[name] = {\n      renderer: this,\n      name: name,\n      points: allPoints,\n      draw: function draw(context, centerX, centerY, width, height) {\n        this.renderer.nodeShapeImpl('round-polygon', context, centerX, centerY, width, height, this.points);\n      },\n      intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {\n        return roundPolygonIntersectLine(x, y, this.points, nodeX, nodeY, width, height);\n      },\n      checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {\n        return pointInsideRoundPolygon(x, y, this.points, centerX, centerY, width, height);\n      }\n    };\n  };\n\n  BRp$2.generateRoundRectangle = function () {\n    return this.nodeShapes['round-rectangle'] = this.nodeShapes['roundrectangle'] = {\n      renderer: this,\n      name: 'round-rectangle',\n      points: generateUnitNgonPointsFitToSquare(4, 0),\n      draw: function draw(context, centerX, centerY, width, height) {\n        this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);\n      },\n      intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {\n        return roundRectangleIntersectLine(x, y, nodeX, nodeY, width, height, padding);\n      },\n      checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {\n        var cornerRadius = getRoundRectangleRadius(width, height);\n        var diam = cornerRadius * 2; // Check hBox\n\n        if (pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - diam, [0, -1], padding)) {\n          return true;\n        } // Check vBox\n\n\n        if (pointInsidePolygon(x, y, this.points, centerX, centerY, width - diam, height, [0, -1], padding)) {\n          return true;\n        } // Check top left quarter circle\n\n\n        if (checkInEllipse(x, y, diam, diam, centerX - width / 2 + cornerRadius, centerY - height / 2 + cornerRadius, padding)) {\n          return true;\n        } // Check top right quarter circle\n\n\n        if (checkInEllipse(x, y, diam, diam, centerX + width / 2 - cornerRadius, centerY - height / 2 + cornerRadius, padding)) {\n          return true;\n        } // Check bottom right quarter circle\n\n\n        if (checkInEllipse(x, y, diam, diam, centerX + width / 2 - cornerRadius, centerY + height / 2 - cornerRadius, padding)) {\n          return true;\n        } // Check bottom left quarter circle\n\n\n        if (checkInEllipse(x, y, diam, diam, centerX - width / 2 + cornerRadius, centerY + height / 2 - cornerRadius, padding)) {\n          return true;\n        }\n\n        return false;\n      }\n    };\n  };\n\n  BRp$2.generateCutRectangle = function () {\n    return this.nodeShapes['cut-rectangle'] = this.nodeShapes['cutrectangle'] = {\n      renderer: this,\n      name: 'cut-rectangle',\n      cornerLength: getCutRectangleCornerLength(),\n      points: generateUnitNgonPointsFitToSquare(4, 0),\n      draw: function draw(context, centerX, centerY, width, height) {\n        this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);\n      },\n      generateCutTrianglePts: function generateCutTrianglePts(width, height, centerX, centerY) {\n        var cl = this.cornerLength;\n        var hh = height / 2;\n        var hw = width / 2;\n        var xBegin = centerX - hw;\n        var xEnd = centerX + hw;\n        var yBegin = centerY - hh;\n        var yEnd = centerY + hh; // points are in clockwise order, inner (imaginary) triangle pt on [4, 5]\n\n        return {\n          topLeft: [xBegin, yBegin + cl, xBegin + cl, yBegin, xBegin + cl, yBegin + cl],\n          topRight: [xEnd - cl, yBegin, xEnd, yBegin + cl, xEnd - cl, yBegin + cl],\n          bottomRight: [xEnd, yEnd - cl, xEnd - cl, yEnd, xEnd - cl, yEnd - cl],\n          bottomLeft: [xBegin + cl, yEnd, xBegin, yEnd - cl, xBegin + cl, yEnd - cl]\n        };\n      },\n      intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {\n        var cPts = this.generateCutTrianglePts(width + 2 * padding, height + 2 * padding, nodeX, nodeY);\n        var pts = [].concat.apply([], [cPts.topLeft.splice(0, 4), cPts.topRight.splice(0, 4), cPts.bottomRight.splice(0, 4), cPts.bottomLeft.splice(0, 4)]);\n        return polygonIntersectLine(x, y, pts, nodeX, nodeY);\n      },\n      checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {\n        // Check hBox\n        if (pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - 2 * this.cornerLength, [0, -1], padding)) {\n          return true;\n        } // Check vBox\n\n\n        if (pointInsidePolygon(x, y, this.points, centerX, centerY, width - 2 * this.cornerLength, height, [0, -1], padding)) {\n          return true;\n        }\n\n        var cutTrianglePts = this.generateCutTrianglePts(width, height, centerX, centerY);\n        return pointInsidePolygonPoints(x, y, cutTrianglePts.topLeft) || pointInsidePolygonPoints(x, y, cutTrianglePts.topRight) || pointInsidePolygonPoints(x, y, cutTrianglePts.bottomRight) || pointInsidePolygonPoints(x, y, cutTrianglePts.bottomLeft);\n      }\n    };\n  };\n\n  BRp$2.generateBarrel = function () {\n    return this.nodeShapes['barrel'] = {\n      renderer: this,\n      name: 'barrel',\n      points: generateUnitNgonPointsFitToSquare(4, 0),\n      draw: function draw(context, centerX, centerY, width, height) {\n        this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);\n      },\n      intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {\n        // use two fixed t values for the bezier curve approximation\n        var t0 = 0.15;\n        var t1 = 0.5;\n        var t2 = 0.85;\n        var bPts = this.generateBarrelBezierPts(width + 2 * padding, height + 2 * padding, nodeX, nodeY);\n\n        var approximateBarrelCurvePts = function approximateBarrelCurvePts(pts) {\n          // approximate curve pts based on the two t values\n          var m0 = qbezierPtAt({\n            x: pts[0],\n            y: pts[1]\n          }, {\n            x: pts[2],\n            y: pts[3]\n          }, {\n            x: pts[4],\n            y: pts[5]\n          }, t0);\n          var m1 = qbezierPtAt({\n            x: pts[0],\n            y: pts[1]\n          }, {\n            x: pts[2],\n            y: pts[3]\n          }, {\n            x: pts[4],\n            y: pts[5]\n          }, t1);\n          var m2 = qbezierPtAt({\n            x: pts[0],\n            y: pts[1]\n          }, {\n            x: pts[2],\n            y: pts[3]\n          }, {\n            x: pts[4],\n            y: pts[5]\n          }, t2);\n          return [pts[0], pts[1], m0.x, m0.y, m1.x, m1.y, m2.x, m2.y, pts[4], pts[5]];\n        };\n\n        var pts = [].concat(approximateBarrelCurvePts(bPts.topLeft), approximateBarrelCurvePts(bPts.topRight), approximateBarrelCurvePts(bPts.bottomRight), approximateBarrelCurvePts(bPts.bottomLeft));\n        return polygonIntersectLine(x, y, pts, nodeX, nodeY);\n      },\n      generateBarrelBezierPts: function generateBarrelBezierPts(width, height, centerX, centerY) {\n        var hh = height / 2;\n        var hw = width / 2;\n        var xBegin = centerX - hw;\n        var xEnd = centerX + hw;\n        var yBegin = centerY - hh;\n        var yEnd = centerY + hh;\n        var curveConstants = getBarrelCurveConstants(width, height);\n        var hOffset = curveConstants.heightOffset;\n        var wOffset = curveConstants.widthOffset;\n        var ctrlPtXOffset = curveConstants.ctrlPtOffsetPct * width; // points are in clockwise order, inner (imaginary) control pt on [4, 5]\n\n        var pts = {\n          topLeft: [xBegin, yBegin + hOffset, xBegin + ctrlPtXOffset, yBegin, xBegin + wOffset, yBegin],\n          topRight: [xEnd - wOffset, yBegin, xEnd - ctrlPtXOffset, yBegin, xEnd, yBegin + hOffset],\n          bottomRight: [xEnd, yEnd - hOffset, xEnd - ctrlPtXOffset, yEnd, xEnd - wOffset, yEnd],\n          bottomLeft: [xBegin + wOffset, yEnd, xBegin + ctrlPtXOffset, yEnd, xBegin, yEnd - hOffset]\n        };\n        pts.topLeft.isTop = true;\n        pts.topRight.isTop = true;\n        pts.bottomLeft.isBottom = true;\n        pts.bottomRight.isBottom = true;\n        return pts;\n      },\n      checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {\n        var curveConstants = getBarrelCurveConstants(width, height);\n        var hOffset = curveConstants.heightOffset;\n        var wOffset = curveConstants.widthOffset; // Check hBox\n\n        if (pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - 2 * hOffset, [0, -1], padding)) {\n          return true;\n        } // Check vBox\n\n\n        if (pointInsidePolygon(x, y, this.points, centerX, centerY, width - 2 * wOffset, height, [0, -1], padding)) {\n          return true;\n        }\n\n        var barrelCurvePts = this.generateBarrelBezierPts(width, height, centerX, centerY);\n\n        var getCurveT = function getCurveT(x, y, curvePts) {\n          var x0 = curvePts[4];\n          var x1 = curvePts[2];\n          var x2 = curvePts[0];\n          var y0 = curvePts[5]; // var y1 = curvePts[ 3 ];\n\n          var y2 = curvePts[1];\n          var xMin = Math.min(x0, x2);\n          var xMax = Math.max(x0, x2);\n          var yMin = Math.min(y0, y2);\n          var yMax = Math.max(y0, y2);\n\n          if (xMin <= x && x <= xMax && yMin <= y && y <= yMax) {\n            var coeff = bezierPtsToQuadCoeff(x0, x1, x2);\n            var roots = solveQuadratic(coeff[0], coeff[1], coeff[2], x);\n            var validRoots = roots.filter(function (r) {\n              return 0 <= r && r <= 1;\n            });\n\n            if (validRoots.length > 0) {\n              return validRoots[0];\n            }\n          }\n\n          return null;\n        };\n\n        var curveRegions = Object.keys(barrelCurvePts);\n\n        for (var i = 0; i < curveRegions.length; i++) {\n          var corner = curveRegions[i];\n          var cornerPts = barrelCurvePts[corner];\n          var t = getCurveT(x, y, cornerPts);\n\n          if (t == null) {\n            continue;\n          }\n\n          var y0 = cornerPts[5];\n          var y1 = cornerPts[3];\n          var y2 = cornerPts[1];\n          var bezY = qbezierAt(y0, y1, y2, t);\n\n          if (cornerPts.isTop && bezY <= y) {\n            return true;\n          }\n\n          if (cornerPts.isBottom && y <= bezY) {\n            return true;\n          }\n        }\n\n        return false;\n      }\n    };\n  };\n\n  BRp$2.generateBottomRoundrectangle = function () {\n    return this.nodeShapes['bottom-round-rectangle'] = this.nodeShapes['bottomroundrectangle'] = {\n      renderer: this,\n      name: 'bottom-round-rectangle',\n      points: generateUnitNgonPointsFitToSquare(4, 0),\n      draw: function draw(context, centerX, centerY, width, height) {\n        this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);\n      },\n      intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {\n        var topStartX = nodeX - (width / 2 + padding);\n        var topStartY = nodeY - (height / 2 + padding);\n        var topEndY = topStartY;\n        var topEndX = nodeX + (width / 2 + padding);\n        var topIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, topStartX, topStartY, topEndX, topEndY, false);\n\n        if (topIntersections.length > 0) {\n          return topIntersections;\n        }\n\n        return roundRectangleIntersectLine(x, y, nodeX, nodeY, width, height, padding);\n      },\n      checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {\n        var cornerRadius = getRoundRectangleRadius(width, height);\n        var diam = 2 * cornerRadius; // Check hBox\n\n        if (pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - diam, [0, -1], padding)) {\n          return true;\n        } // Check vBox\n\n\n        if (pointInsidePolygon(x, y, this.points, centerX, centerY, width - diam, height, [0, -1], padding)) {\n          return true;\n        } // check non-rounded top side\n\n\n        var outerWidth = width / 2 + 2 * padding;\n        var outerHeight = height / 2 + 2 * padding;\n        var points = [centerX - outerWidth, centerY - outerHeight, centerX - outerWidth, centerY, centerX + outerWidth, centerY, centerX + outerWidth, centerY - outerHeight];\n\n        if (pointInsidePolygonPoints(x, y, points)) {\n          return true;\n        } // Check bottom right quarter circle\n\n\n        if (checkInEllipse(x, y, diam, diam, centerX + width / 2 - cornerRadius, centerY + height / 2 - cornerRadius, padding)) {\n          return true;\n        } // Check bottom left quarter circle\n\n\n        if (checkInEllipse(x, y, diam, diam, centerX - width / 2 + cornerRadius, centerY + height / 2 - cornerRadius, padding)) {\n          return true;\n        }\n\n        return false;\n      }\n    };\n  };\n\n  BRp$2.registerNodeShapes = function () {\n    var nodeShapes = this.nodeShapes = {};\n    var renderer = this;\n    this.generateEllipse();\n    this.generatePolygon('triangle', generateUnitNgonPointsFitToSquare(3, 0));\n    this.generateRoundPolygon('round-triangle', generateUnitNgonPointsFitToSquare(3, 0));\n    this.generatePolygon('rectangle', generateUnitNgonPointsFitToSquare(4, 0));\n    nodeShapes['square'] = nodeShapes['rectangle'];\n    this.generateRoundRectangle();\n    this.generateCutRectangle();\n    this.generateBarrel();\n    this.generateBottomRoundrectangle();\n    {\n      var diamondPoints = [0, 1, 1, 0, 0, -1, -1, 0];\n      this.generatePolygon('diamond', diamondPoints);\n      this.generateRoundPolygon('round-diamond', diamondPoints);\n    }\n    this.generatePolygon('pentagon', generateUnitNgonPointsFitToSquare(5, 0));\n    this.generateRoundPolygon('round-pentagon', generateUnitNgonPointsFitToSquare(5, 0));\n    this.generatePolygon('hexagon', generateUnitNgonPointsFitToSquare(6, 0));\n    this.generateRoundPolygon('round-hexagon', generateUnitNgonPointsFitToSquare(6, 0));\n    this.generatePolygon('heptagon', generateUnitNgonPointsFitToSquare(7, 0));\n    this.generateRoundPolygon('round-heptagon', generateUnitNgonPointsFitToSquare(7, 0));\n    this.generatePolygon('octagon', generateUnitNgonPointsFitToSquare(8, 0));\n    this.generateRoundPolygon('round-octagon', generateUnitNgonPointsFitToSquare(8, 0));\n    var star5Points = new Array(20);\n    {\n      var outerPoints = generateUnitNgonPoints(5, 0);\n      var innerPoints = generateUnitNgonPoints(5, Math.PI / 5); // Outer radius is 1; inner radius of star is smaller\n\n      var innerRadius = 0.5 * (3 - Math.sqrt(5));\n      innerRadius *= 1.57;\n\n      for (var i = 0; i < innerPoints.length / 2; i++) {\n        innerPoints[i * 2] *= innerRadius;\n        innerPoints[i * 2 + 1] *= innerRadius;\n      }\n\n      for (var i = 0; i < 20 / 4; i++) {\n        star5Points[i * 4] = outerPoints[i * 2];\n        star5Points[i * 4 + 1] = outerPoints[i * 2 + 1];\n        star5Points[i * 4 + 2] = innerPoints[i * 2];\n        star5Points[i * 4 + 3] = innerPoints[i * 2 + 1];\n      }\n    }\n    star5Points = fitPolygonToSquare(star5Points);\n    this.generatePolygon('star', star5Points);\n    this.generatePolygon('vee', [-1, -1, 0, -0.333, 1, -1, 0, 1]);\n    this.generatePolygon('rhomboid', [-1, -1, 0.333, -1, 1, 1, -0.333, 1]);\n    this.nodeShapes['concavehexagon'] = this.generatePolygon('concave-hexagon', [-1, -0.95, -0.75, 0, -1, 0.95, 1, 0.95, 0.75, 0, 1, -0.95]);\n    {\n      var tagPoints = [-1, -1, 0.25, -1, 1, 0, 0.25, 1, -1, 1];\n      this.generatePolygon('tag', tagPoints);\n      this.generateRoundPolygon('round-tag', tagPoints);\n    }\n\n    nodeShapes.makePolygon = function (points) {\n      // use caching on user-specified polygons so they are as fast as native shapes\n      var key = points.join('$');\n      var name = 'polygon-' + key;\n      var shape;\n\n      if (shape = this[name]) {\n        // got cached shape\n        return shape;\n      } // create and cache new shape\n\n\n      return renderer.generatePolygon(name, points);\n    };\n  };\n\n  var BRp$1 = {};\n\n  BRp$1.timeToRender = function () {\n    return this.redrawTotalTime / this.redrawCount;\n  };\n\n  BRp$1.redraw = function (options) {\n    options = options || staticEmptyObject();\n    var r = this;\n\n    if (r.averageRedrawTime === undefined) {\n      r.averageRedrawTime = 0;\n    }\n\n    if (r.lastRedrawTime === undefined) {\n      r.lastRedrawTime = 0;\n    }\n\n    if (r.lastDrawTime === undefined) {\n      r.lastDrawTime = 0;\n    }\n\n    r.requestedFrame = true;\n    r.renderOptions = options;\n  };\n\n  BRp$1.beforeRender = function (fn, priority) {\n    // the renderer can't add tick callbacks when destroyed\n    if (this.destroyed) {\n      return;\n    }\n\n    if (priority == null) {\n      error('Priority is not optional for beforeRender');\n    }\n\n    var cbs = this.beforeRenderCallbacks;\n    cbs.push({\n      fn: fn,\n      priority: priority\n    }); // higher priority callbacks executed first\n\n    cbs.sort(function (a, b) {\n      return b.priority - a.priority;\n    });\n  };\n\n  var beforeRenderCallbacks = function beforeRenderCallbacks(r, willDraw, startTime) {\n    var cbs = r.beforeRenderCallbacks;\n\n    for (var i = 0; i < cbs.length; i++) {\n      cbs[i].fn(willDraw, startTime);\n    }\n  };\n\n  BRp$1.startRenderLoop = function () {\n    var r = this;\n    var cy = r.cy;\n\n    if (r.renderLoopStarted) {\n      return;\n    } else {\n      r.renderLoopStarted = true;\n    }\n\n    var renderFn = function renderFn(requestTime) {\n      if (r.destroyed) {\n        return;\n      }\n\n      if (cy.batching()) ; else if (r.requestedFrame && !r.skipFrame) {\n        beforeRenderCallbacks(r, true, requestTime);\n        var startTime = performanceNow();\n        r.render(r.renderOptions);\n        var endTime = r.lastDrawTime = performanceNow();\n\n        if (r.averageRedrawTime === undefined) {\n          r.averageRedrawTime = endTime - startTime;\n        }\n\n        if (r.redrawCount === undefined) {\n          r.redrawCount = 0;\n        }\n\n        r.redrawCount++;\n\n        if (r.redrawTotalTime === undefined) {\n          r.redrawTotalTime = 0;\n        }\n\n        var duration = endTime - startTime;\n        r.redrawTotalTime += duration;\n        r.lastRedrawTime = duration; // use a weighted average with a bias from the previous average so we don't spike so easily\n\n        r.averageRedrawTime = r.averageRedrawTime / 2 + duration / 2;\n        r.requestedFrame = false;\n      } else {\n        beforeRenderCallbacks(r, false, requestTime);\n      }\n\n      r.skipFrame = false;\n      requestAnimationFrame(renderFn);\n    };\n\n    requestAnimationFrame(renderFn);\n  };\n\n  var BaseRenderer = function BaseRenderer(options) {\n    this.init(options);\n  };\n\n  var BR = BaseRenderer;\n  var BRp = BR.prototype;\n  BRp.clientFunctions = ['redrawHint', 'render', 'renderTo', 'matchCanvasSize', 'nodeShapeImpl', 'arrowShapeImpl'];\n\n  BRp.init = function (options) {\n    var r = this;\n    r.options = options;\n    r.cy = options.cy;\n    var ctr = r.container = options.cy.container(); // prepend a stylesheet in the head such that\n\n    if (window$1) {\n      var document = window$1.document;\n      var head = document.head;\n      var stylesheetId = '__________cytoscape_stylesheet';\n      var className = '__________cytoscape_container';\n      var stylesheetAlreadyExists = document.getElementById(stylesheetId) != null;\n\n      if (ctr.className.indexOf(className) < 0) {\n        ctr.className = (ctr.className || '') + ' ' + className;\n      }\n\n      if (!stylesheetAlreadyExists) {\n        var stylesheet = document.createElement('style');\n        stylesheet.id = stylesheetId;\n        stylesheet.innerHTML = '.' + className + ' { position: relative; }';\n        head.insertBefore(stylesheet, head.children[0]); // first so lowest priority\n      }\n\n      var computedStyle = window$1.getComputedStyle(ctr);\n      var position = computedStyle.getPropertyValue('position');\n\n      if (position === 'static') {\n        warn('A Cytoscape container has style position:static and so can not use UI extensions properly');\n      }\n    }\n\n    r.selection = [undefined, undefined, undefined, undefined, 0]; // Coordinates for selection box, plus enabled flag\n\n    r.bezierProjPcts = [0.05, 0.225, 0.4, 0.5, 0.6, 0.775, 0.95]; //--Pointer-related data\n\n    r.hoverData = {\n      down: null,\n      last: null,\n      downTime: null,\n      triggerMode: null,\n      dragging: false,\n      initialPan: [null, null],\n      capture: false\n    };\n    r.dragData = {\n      possibleDragElements: []\n    };\n    r.touchData = {\n      start: null,\n      capture: false,\n      // These 3 fields related to tap, taphold events\n      startPosition: [null, null, null, null, null, null],\n      singleTouchStartTime: null,\n      singleTouchMoved: true,\n      now: [null, null, null, null, null, null],\n      earlier: [null, null, null, null, null, null]\n    };\n    r.redraws = 0;\n    r.showFps = options.showFps;\n    r.debug = options.debug;\n    r.hideEdgesOnViewport = options.hideEdgesOnViewport;\n    r.textureOnViewport = options.textureOnViewport;\n    r.wheelSensitivity = options.wheelSensitivity;\n    r.motionBlurEnabled = options.motionBlur; // on by default\n\n    r.forcedPixelRatio = number$1(options.pixelRatio) ? options.pixelRatio : null;\n    r.motionBlur = options.motionBlur; // for initial kick off\n\n    r.motionBlurOpacity = options.motionBlurOpacity;\n    r.motionBlurTransparency = 1 - r.motionBlurOpacity;\n    r.motionBlurPxRatio = 1;\n    r.mbPxRBlurry = 1; //0.8;\n\n    r.minMbLowQualFrames = 4;\n    r.fullQualityMb = false;\n    r.clearedForMotionBlur = [];\n    r.desktopTapThreshold = options.desktopTapThreshold;\n    r.desktopTapThreshold2 = options.desktopTapThreshold * options.desktopTapThreshold;\n    r.touchTapThreshold = options.touchTapThreshold;\n    r.touchTapThreshold2 = options.touchTapThreshold * options.touchTapThreshold;\n    r.tapholdDuration = 500;\n    r.bindings = [];\n    r.beforeRenderCallbacks = [];\n    r.beforeRenderPriorities = {\n      // higher priority execs before lower one\n      animations: 400,\n      eleCalcs: 300,\n      eleTxrDeq: 200,\n      lyrTxrDeq: 150,\n      lyrTxrSkip: 100\n    };\n    r.registerNodeShapes();\n    r.registerArrowShapes();\n    r.registerCalculationListeners();\n  };\n\n  BRp.notify = function (eventName, eles) {\n    var r = this;\n    var cy = r.cy; // the renderer can't be notified after it's destroyed\n\n    if (this.destroyed) {\n      return;\n    }\n\n    if (eventName === 'init') {\n      r.load();\n      return;\n    }\n\n    if (eventName === 'destroy') {\n      r.destroy();\n      return;\n    }\n\n    if (eventName === 'add' || eventName === 'remove' || eventName === 'move' && cy.hasCompoundNodes() || eventName === 'load' || eventName === 'zorder' || eventName === 'mount') {\n      r.invalidateCachedZSortedEles();\n    }\n\n    if (eventName === 'viewport') {\n      r.redrawHint('select', true);\n    }\n\n    if (eventName === 'load' || eventName === 'resize' || eventName === 'mount') {\n      r.invalidateContainerClientCoordsCache();\n      r.matchCanvasSize(r.container);\n    }\n\n    r.redrawHint('eles', true);\n    r.redrawHint('drag', true);\n    this.startRenderLoop();\n    this.redraw();\n  };\n\n  BRp.destroy = function () {\n    var r = this;\n    r.destroyed = true;\n    r.cy.stopAnimationLoop();\n\n    for (var i = 0; i < r.bindings.length; i++) {\n      var binding = r.bindings[i];\n      var b = binding;\n      var tgt = b.target;\n      (tgt.off || tgt.removeEventListener).apply(tgt, b.args);\n    }\n\n    r.bindings = [];\n    r.beforeRenderCallbacks = [];\n    r.onUpdateEleCalcsFns = [];\n\n    if (r.removeObserver) {\n      r.removeObserver.disconnect();\n    }\n\n    if (r.styleObserver) {\n      r.styleObserver.disconnect();\n    }\n\n    if (r.resizeObserver) {\n      r.resizeObserver.disconnect();\n    }\n\n    if (r.labelCalcDiv) {\n      try {\n        document.body.removeChild(r.labelCalcDiv); // eslint-disable-line no-undef\n      } catch (e) {// ie10 issue #1014\n      }\n    }\n  };\n\n  BRp.isHeadless = function () {\n    return false;\n  };\n\n  [BRp$f, BRp$5, BRp$4, BRp$3, BRp$2, BRp$1].forEach(function (props) {\n    extend(BRp, props);\n  });\n\n  var fullFpsTime = 1000 / 60; // assume 60 frames per second\n\n  var defs = {\n    setupDequeueing: function setupDequeueing(opts) {\n      return function setupDequeueingImpl() {\n        var self = this;\n        var r = this.renderer;\n\n        if (self.dequeueingSetup) {\n          return;\n        } else {\n          self.dequeueingSetup = true;\n        }\n\n        var queueRedraw = debounce_1(function () {\n          r.redrawHint('eles', true);\n          r.redrawHint('drag', true);\n          r.redraw();\n        }, opts.deqRedrawThreshold);\n\n        var dequeue = function dequeue(willDraw, frameStartTime) {\n          var startTime = performanceNow();\n          var avgRenderTime = r.averageRedrawTime;\n          var renderTime = r.lastRedrawTime;\n          var deqd = [];\n          var extent = r.cy.extent();\n          var pixelRatio = r.getPixelRatio(); // if we aren't in a tick that causes a draw, then the rendered style\n          // queue won't automatically be flushed before dequeueing starts\n\n          if (!willDraw) {\n            r.flushRenderedStyleQueue();\n          }\n\n          while (true) {\n            // eslint-disable-line no-constant-condition\n            var now = performanceNow();\n            var duration = now - startTime;\n            var frameDuration = now - frameStartTime;\n\n            if (renderTime < fullFpsTime) {\n              // if we're rendering faster than the ideal fps, then do dequeueing\n              // during all of the remaining frame time\n              var timeAvailable = fullFpsTime - (willDraw ? avgRenderTime : 0);\n\n              if (frameDuration >= opts.deqFastCost * timeAvailable) {\n                break;\n              }\n            } else {\n              if (willDraw) {\n                if (duration >= opts.deqCost * renderTime || duration >= opts.deqAvgCost * avgRenderTime) {\n                  break;\n                }\n              } else if (frameDuration >= opts.deqNoDrawCost * fullFpsTime) {\n                break;\n              }\n            }\n\n            var thisDeqd = opts.deq(self, pixelRatio, extent);\n\n            if (thisDeqd.length > 0) {\n              for (var i = 0; i < thisDeqd.length; i++) {\n                deqd.push(thisDeqd[i]);\n              }\n            } else {\n              break;\n            }\n          } // callbacks on dequeue\n\n\n          if (deqd.length > 0) {\n            opts.onDeqd(self, deqd);\n\n            if (!willDraw && opts.shouldRedraw(self, deqd, pixelRatio, extent)) {\n              queueRedraw();\n            }\n          }\n        };\n\n        var priority = opts.priority || noop$1;\n        r.beforeRender(dequeue, priority(self));\n      };\n    }\n  };\n\n  // Uses keys so elements may share the same cache.\n\n  var ElementTextureCacheLookup = /*#__PURE__*/function () {\n    function ElementTextureCacheLookup(getKey) {\n      var doesEleInvalidateKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : falsify;\n\n      _classCallCheck(this, ElementTextureCacheLookup);\n\n      this.idsByKey = new Map$2();\n      this.keyForId = new Map$2();\n      this.cachesByLvl = new Map$2();\n      this.lvls = [];\n      this.getKey = getKey;\n      this.doesEleInvalidateKey = doesEleInvalidateKey;\n    }\n\n    _createClass(ElementTextureCacheLookup, [{\n      key: \"getIdsFor\",\n      value: function getIdsFor(key) {\n        if (key == null) {\n          error(\"Can not get id list for null key\");\n        }\n\n        var idsByKey = this.idsByKey;\n        var ids = this.idsByKey.get(key);\n\n        if (!ids) {\n          ids = new Set$1();\n          idsByKey.set(key, ids);\n        }\n\n        return ids;\n      }\n    }, {\n      key: \"addIdForKey\",\n      value: function addIdForKey(key, id) {\n        if (key != null) {\n          this.getIdsFor(key).add(id);\n        }\n      }\n    }, {\n      key: \"deleteIdForKey\",\n      value: function deleteIdForKey(key, id) {\n        if (key != null) {\n          this.getIdsFor(key)[\"delete\"](id);\n        }\n      }\n    }, {\n      key: \"getNumberOfIdsForKey\",\n      value: function getNumberOfIdsForKey(key) {\n        if (key == null) {\n          return 0;\n        } else {\n          return this.getIdsFor(key).size;\n        }\n      }\n    }, {\n      key: \"updateKeyMappingFor\",\n      value: function updateKeyMappingFor(ele) {\n        var id = ele.id();\n        var prevKey = this.keyForId.get(id);\n        var currKey = this.getKey(ele);\n        this.deleteIdForKey(prevKey, id);\n        this.addIdForKey(currKey, id);\n        this.keyForId.set(id, currKey);\n      }\n    }, {\n      key: \"deleteKeyMappingFor\",\n      value: function deleteKeyMappingFor(ele) {\n        var id = ele.id();\n        var prevKey = this.keyForId.get(id);\n        this.deleteIdForKey(prevKey, id);\n        this.keyForId[\"delete\"](id);\n      }\n    }, {\n      key: \"keyHasChangedFor\",\n      value: function keyHasChangedFor(ele) {\n        var id = ele.id();\n        var prevKey = this.keyForId.get(id);\n        var newKey = this.getKey(ele);\n        return prevKey !== newKey;\n      }\n    }, {\n      key: \"isInvalid\",\n      value: function isInvalid(ele) {\n        return this.keyHasChangedFor(ele) || this.doesEleInvalidateKey(ele);\n      }\n    }, {\n      key: \"getCachesAt\",\n      value: function getCachesAt(lvl) {\n        var cachesByLvl = this.cachesByLvl,\n            lvls = this.lvls;\n        var caches = cachesByLvl.get(lvl);\n\n        if (!caches) {\n          caches = new Map$2();\n          cachesByLvl.set(lvl, caches);\n          lvls.push(lvl);\n        }\n\n        return caches;\n      }\n    }, {\n      key: \"getCache\",\n      value: function getCache(key, lvl) {\n        return this.getCachesAt(lvl).get(key);\n      }\n    }, {\n      key: \"get\",\n      value: function get(ele, lvl) {\n        var key = this.getKey(ele);\n        var cache = this.getCache(key, lvl); // getting for an element may need to add to the id list b/c eles can share keys\n\n        if (cache != null) {\n          this.updateKeyMappingFor(ele);\n        }\n\n        return cache;\n      }\n    }, {\n      key: \"getForCachedKey\",\n      value: function getForCachedKey(ele, lvl) {\n        var key = this.keyForId.get(ele.id()); // n.b. use cached key, not newly computed key\n\n        var cache = this.getCache(key, lvl);\n        return cache;\n      }\n    }, {\n      key: \"hasCache\",\n      value: function hasCache(key, lvl) {\n        return this.getCachesAt(lvl).has(key);\n      }\n    }, {\n      key: \"has\",\n      value: function has(ele, lvl) {\n        var key = this.getKey(ele);\n        return this.hasCache(key, lvl);\n      }\n    }, {\n      key: \"setCache\",\n      value: function setCache(key, lvl, cache) {\n        cache.key = key;\n        this.getCachesAt(lvl).set(key, cache);\n      }\n    }, {\n      key: \"set\",\n      value: function set(ele, lvl, cache) {\n        var key = this.getKey(ele);\n        this.setCache(key, lvl, cache);\n        this.updateKeyMappingFor(ele);\n      }\n    }, {\n      key: \"deleteCache\",\n      value: function deleteCache(key, lvl) {\n        this.getCachesAt(lvl)[\"delete\"](key);\n      }\n    }, {\n      key: \"delete\",\n      value: function _delete(ele, lvl) {\n        var key = this.getKey(ele);\n        this.deleteCache(key, lvl);\n      }\n    }, {\n      key: \"invalidateKey\",\n      value: function invalidateKey(key) {\n        var _this = this;\n\n        this.lvls.forEach(function (lvl) {\n          return _this.deleteCache(key, lvl);\n        });\n      } // returns true if no other eles reference the invalidated cache (n.b. other eles may need the cache with the same key)\n\n    }, {\n      key: \"invalidate\",\n      value: function invalidate(ele) {\n        var id = ele.id();\n        var key = this.keyForId.get(id); // n.b. use stored key rather than current (potential key)\n\n        this.deleteKeyMappingFor(ele);\n        var entireKeyInvalidated = this.doesEleInvalidateKey(ele);\n\n        if (entireKeyInvalidated) {\n          // clear mapping for current key\n          this.invalidateKey(key);\n        }\n\n        return entireKeyInvalidated || this.getNumberOfIdsForKey(key) === 0;\n      }\n    }]);\n\n    return ElementTextureCacheLookup;\n  }();\n\n  var minTxrH = 25; // the size of the texture cache for small height eles (special case)\n\n  var txrStepH = 50; // the min size of the regular cache, and the size it increases with each step up\n\n  var minLvl$1 = -4; // when scaling smaller than that we don't need to re-render\n\n  var maxLvl$1 = 3; // when larger than this scale just render directly (caching is not helpful)\n\n  var maxZoom$1 = 7.99; // beyond this zoom level, layered textures are not used\n\n  var eleTxrSpacing = 8; // spacing between elements on textures to avoid blitting overlaps\n\n  var defTxrWidth = 1024; // default/minimum texture width\n\n  var maxTxrW = 1024; // the maximum width of a texture\n\n  var maxTxrH = 1024; // the maximum height of a texture\n\n  var minUtility = 0.2; // if usage of texture is less than this, it is retired\n\n  var maxFullness = 0.8; // fullness of texture after which queue removal is checked\n\n  var maxFullnessChecks = 10; // dequeued after this many checks\n\n  var deqCost$1 = 0.15; // % of add'l rendering cost allowed for dequeuing ele caches each frame\n\n  var deqAvgCost$1 = 0.1; // % of add'l rendering cost compared to average overall redraw time\n\n  var deqNoDrawCost$1 = 0.9; // % of avg frame time that can be used for dequeueing when not drawing\n\n  var deqFastCost$1 = 0.9; // % of frame time to be used when >60fps\n\n  var deqRedrawThreshold$1 = 100; // time to batch redraws together from dequeueing to allow more dequeueing calcs to happen in the meanwhile\n\n  var maxDeqSize$1 = 1; // number of eles to dequeue and render at higher texture in each batch\n\n  var getTxrReasons = {\n    dequeue: 'dequeue',\n    downscale: 'downscale',\n    highQuality: 'highQuality'\n  };\n  var initDefaults = defaults$g({\n    getKey: null,\n    doesEleInvalidateKey: falsify,\n    drawElement: null,\n    getBoundingBox: null,\n    getRotationPoint: null,\n    getRotationOffset: null,\n    isVisible: trueify,\n    allowEdgeTxrCaching: true,\n    allowParentTxrCaching: true\n  });\n\n  var ElementTextureCache = function ElementTextureCache(renderer, initOptions) {\n    var self = this;\n    self.renderer = renderer;\n    self.onDequeues = [];\n    var opts = initDefaults(initOptions);\n    extend(self, opts);\n    self.lookup = new ElementTextureCacheLookup(opts.getKey, opts.doesEleInvalidateKey);\n    self.setupDequeueing();\n  };\n\n  var ETCp = ElementTextureCache.prototype;\n  ETCp.reasons = getTxrReasons; // the list of textures in which new subtextures for elements can be placed\n\n  ETCp.getTextureQueue = function (txrH) {\n    var self = this;\n    self.eleImgCaches = self.eleImgCaches || {};\n    return self.eleImgCaches[txrH] = self.eleImgCaches[txrH] || [];\n  }; // the list of usused textures which can be recycled (in use in texture queue)\n\n\n  ETCp.getRetiredTextureQueue = function (txrH) {\n    var self = this;\n    var rtxtrQs = self.eleImgCaches.retired = self.eleImgCaches.retired || {};\n    var rtxtrQ = rtxtrQs[txrH] = rtxtrQs[txrH] || [];\n    return rtxtrQ;\n  }; // queue of element draw requests at different scale levels\n\n\n  ETCp.getElementQueue = function () {\n    var self = this;\n    var q = self.eleCacheQueue = self.eleCacheQueue || new heap(function (a, b) {\n      return b.reqs - a.reqs;\n    });\n    return q;\n  }; // queue of element draw requests at different scale levels (element id lookup)\n\n\n  ETCp.getElementKeyToQueue = function () {\n    var self = this;\n    var k2q = self.eleKeyToCacheQueue = self.eleKeyToCacheQueue || {};\n    return k2q;\n  };\n\n  ETCp.getElement = function (ele, bb, pxRatio, lvl, reason) {\n    var self = this;\n    var r = this.renderer;\n    var zoom = r.cy.zoom();\n    var lookup = this.lookup;\n\n    if (!bb || bb.w === 0 || bb.h === 0 || isNaN(bb.w) || isNaN(bb.h) || !ele.visible() || ele.removed()) {\n      return null;\n    }\n\n    if (!self.allowEdgeTxrCaching && ele.isEdge() || !self.allowParentTxrCaching && ele.isParent()) {\n      return null;\n    }\n\n    if (lvl == null) {\n      lvl = Math.ceil(log2(zoom * pxRatio));\n    }\n\n    if (lvl < minLvl$1) {\n      lvl = minLvl$1;\n    } else if (zoom >= maxZoom$1 || lvl > maxLvl$1) {\n      return null;\n    }\n\n    var scale = Math.pow(2, lvl);\n    var eleScaledH = bb.h * scale;\n    var eleScaledW = bb.w * scale;\n    var scaledLabelShown = r.eleTextBiggerThanMin(ele, scale);\n\n    if (!this.isVisible(ele, scaledLabelShown)) {\n      return null;\n    }\n\n    var eleCache = lookup.get(ele, lvl); // if this get was on an unused/invalidated cache, then restore the texture usage metric\n\n    if (eleCache && eleCache.invalidated) {\n      eleCache.invalidated = false;\n      eleCache.texture.invalidatedWidth -= eleCache.width;\n    }\n\n    if (eleCache) {\n      return eleCache;\n    }\n\n    var txrH; // which texture height this ele belongs to\n\n    if (eleScaledH <= minTxrH) {\n      txrH = minTxrH;\n    } else if (eleScaledH <= txrStepH) {\n      txrH = txrStepH;\n    } else {\n      txrH = Math.ceil(eleScaledH / txrStepH) * txrStepH;\n    }\n\n    if (eleScaledH > maxTxrH || eleScaledW > maxTxrW) {\n      return null; // caching large elements is not efficient\n    }\n\n    var txrQ = self.getTextureQueue(txrH); // first try the second last one in case it has space at the end\n\n    var txr = txrQ[txrQ.length - 2];\n\n    var addNewTxr = function addNewTxr() {\n      return self.recycleTexture(txrH, eleScaledW) || self.addTexture(txrH, eleScaledW);\n    }; // try the last one if there is no second last one\n\n\n    if (!txr) {\n      txr = txrQ[txrQ.length - 1];\n    } // if the last one doesn't exist, we need a first one\n\n\n    if (!txr) {\n      txr = addNewTxr();\n    } // if there's no room in the current texture, we need a new one\n\n\n    if (txr.width - txr.usedWidth < eleScaledW) {\n      txr = addNewTxr();\n    }\n\n    var scalableFrom = function scalableFrom(otherCache) {\n      return otherCache && otherCache.scaledLabelShown === scaledLabelShown;\n    };\n\n    var deqing = reason && reason === getTxrReasons.dequeue;\n    var highQualityReq = reason && reason === getTxrReasons.highQuality;\n    var downscaleReq = reason && reason === getTxrReasons.downscale;\n    var higherCache; // the nearest cache with a higher level\n\n    for (var l = lvl + 1; l <= maxLvl$1; l++) {\n      var c = lookup.get(ele, l);\n\n      if (c) {\n        higherCache = c;\n        break;\n      }\n    }\n\n    var oneUpCache = higherCache && higherCache.level === lvl + 1 ? higherCache : null;\n\n    var downscale = function downscale() {\n      txr.context.drawImage(oneUpCache.texture.canvas, oneUpCache.x, 0, oneUpCache.width, oneUpCache.height, txr.usedWidth, 0, eleScaledW, eleScaledH);\n    }; // reset ele area in texture\n\n\n    txr.context.setTransform(1, 0, 0, 1, 0, 0);\n    txr.context.clearRect(txr.usedWidth, 0, eleScaledW, txrH);\n\n    if (scalableFrom(oneUpCache)) {\n      // then we can relatively cheaply rescale the existing image w/o rerendering\n      downscale();\n    } else if (scalableFrom(higherCache)) {\n      // then use the higher cache for now and queue the next level down\n      // to cheaply scale towards the smaller level\n      if (highQualityReq) {\n        for (var _l = higherCache.level; _l > lvl; _l--) {\n          oneUpCache = self.getElement(ele, bb, pxRatio, _l, getTxrReasons.downscale);\n        }\n\n        downscale();\n      } else {\n        self.queueElement(ele, higherCache.level - 1);\n        return higherCache;\n      }\n    } else {\n      var lowerCache; // the nearest cache with a lower level\n\n      if (!deqing && !highQualityReq && !downscaleReq) {\n        for (var _l2 = lvl - 1; _l2 >= minLvl$1; _l2--) {\n          var _c = lookup.get(ele, _l2);\n\n          if (_c) {\n            lowerCache = _c;\n            break;\n          }\n        }\n      }\n\n      if (scalableFrom(lowerCache)) {\n        // then use the lower quality cache for now and queue the better one for later\n        self.queueElement(ele, lvl);\n        return lowerCache;\n      }\n\n      txr.context.translate(txr.usedWidth, 0);\n      txr.context.scale(scale, scale);\n      this.drawElement(txr.context, ele, bb, scaledLabelShown, false);\n      txr.context.scale(1 / scale, 1 / scale);\n      txr.context.translate(-txr.usedWidth, 0);\n    }\n\n    eleCache = {\n      x: txr.usedWidth,\n      texture: txr,\n      level: lvl,\n      scale: scale,\n      width: eleScaledW,\n      height: eleScaledH,\n      scaledLabelShown: scaledLabelShown\n    };\n    txr.usedWidth += Math.ceil(eleScaledW + eleTxrSpacing);\n    txr.eleCaches.push(eleCache);\n    lookup.set(ele, lvl, eleCache);\n    self.checkTextureFullness(txr);\n    return eleCache;\n  };\n\n  ETCp.invalidateElements = function (eles) {\n    for (var i = 0; i < eles.length; i++) {\n      this.invalidateElement(eles[i]);\n    }\n  };\n\n  ETCp.invalidateElement = function (ele) {\n    var self = this;\n    var lookup = self.lookup;\n    var caches = [];\n    var invalid = lookup.isInvalid(ele);\n\n    if (!invalid) {\n      return; // override the invalidation request if the element key has not changed\n    }\n\n    for (var lvl = minLvl$1; lvl <= maxLvl$1; lvl++) {\n      var cache = lookup.getForCachedKey(ele, lvl);\n\n      if (cache) {\n        caches.push(cache);\n      }\n    }\n\n    var noOtherElesUseCache = lookup.invalidate(ele);\n\n    if (noOtherElesUseCache) {\n      for (var i = 0; i < caches.length; i++) {\n        var _cache = caches[i];\n        var txr = _cache.texture; // remove space from the texture it belongs to\n\n        txr.invalidatedWidth += _cache.width; // mark the cache as invalidated\n\n        _cache.invalidated = true; // retire the texture if its utility is low\n\n        self.checkTextureUtility(txr);\n      }\n    } // remove from queue since the old req was for the old state\n\n\n    self.removeFromQueue(ele);\n  };\n\n  ETCp.checkTextureUtility = function (txr) {\n    // invalidate all entries in the cache if the cache size is small\n    if (txr.invalidatedWidth >= minUtility * txr.width) {\n      this.retireTexture(txr);\n    }\n  };\n\n  ETCp.checkTextureFullness = function (txr) {\n    // if texture has been mostly filled and passed over several times, remove\n    // it from the queue so we don't need to waste time looking at it to put new things\n    var self = this;\n    var txrQ = self.getTextureQueue(txr.height);\n\n    if (txr.usedWidth / txr.width > maxFullness && txr.fullnessChecks >= maxFullnessChecks) {\n      removeFromArray(txrQ, txr);\n    } else {\n      txr.fullnessChecks++;\n    }\n  };\n\n  ETCp.retireTexture = function (txr) {\n    var self = this;\n    var txrH = txr.height;\n    var txrQ = self.getTextureQueue(txrH);\n    var lookup = this.lookup; // retire the texture from the active / searchable queue:\n\n    removeFromArray(txrQ, txr);\n    txr.retired = true; // remove the refs from the eles to the caches:\n\n    var eleCaches = txr.eleCaches;\n\n    for (var i = 0; i < eleCaches.length; i++) {\n      var eleCache = eleCaches[i];\n      lookup.deleteCache(eleCache.key, eleCache.level);\n    }\n\n    clearArray(eleCaches); // add the texture to a retired queue so it can be recycled in future:\n\n    var rtxtrQ = self.getRetiredTextureQueue(txrH);\n    rtxtrQ.push(txr);\n  };\n\n  ETCp.addTexture = function (txrH, minW) {\n    var self = this;\n    var txrQ = self.getTextureQueue(txrH);\n    var txr = {};\n    txrQ.push(txr);\n    txr.eleCaches = [];\n    txr.height = txrH;\n    txr.width = Math.max(defTxrWidth, minW);\n    txr.usedWidth = 0;\n    txr.invalidatedWidth = 0;\n    txr.fullnessChecks = 0;\n    txr.canvas = self.renderer.makeOffscreenCanvas(txr.width, txr.height);\n    txr.context = txr.canvas.getContext('2d');\n    return txr;\n  };\n\n  ETCp.recycleTexture = function (txrH, minW) {\n    var self = this;\n    var txrQ = self.getTextureQueue(txrH);\n    var rtxtrQ = self.getRetiredTextureQueue(txrH);\n\n    for (var i = 0; i < rtxtrQ.length; i++) {\n      var txr = rtxtrQ[i];\n\n      if (txr.width >= minW) {\n        txr.retired = false;\n        txr.usedWidth = 0;\n        txr.invalidatedWidth = 0;\n        txr.fullnessChecks = 0;\n        clearArray(txr.eleCaches);\n        txr.context.setTransform(1, 0, 0, 1, 0, 0);\n        txr.context.clearRect(0, 0, txr.width, txr.height);\n        removeFromArray(rtxtrQ, txr);\n        txrQ.push(txr);\n        return txr;\n      }\n    }\n  };\n\n  ETCp.queueElement = function (ele, lvl) {\n    var self = this;\n    var q = self.getElementQueue();\n    var k2q = self.getElementKeyToQueue();\n    var key = this.getKey(ele);\n    var existingReq = k2q[key];\n\n    if (existingReq) {\n      // use the max lvl b/c in between lvls are cheap to make\n      existingReq.level = Math.max(existingReq.level, lvl);\n      existingReq.eles.merge(ele);\n      existingReq.reqs++;\n      q.updateItem(existingReq);\n    } else {\n      var req = {\n        eles: ele.spawn().merge(ele),\n        level: lvl,\n        reqs: 1,\n        key: key\n      };\n      q.push(req);\n      k2q[key] = req;\n    }\n  };\n\n  ETCp.dequeue = function (pxRatio\n  /*, extent*/\n  ) {\n    var self = this;\n    var q = self.getElementQueue();\n    var k2q = self.getElementKeyToQueue();\n    var dequeued = [];\n    var lookup = self.lookup;\n\n    for (var i = 0; i < maxDeqSize$1; i++) {\n      if (q.size() > 0) {\n        var req = q.pop();\n        var key = req.key;\n        var ele = req.eles[0]; // all eles have the same key\n\n        var cacheExists = lookup.hasCache(ele, req.level); // clear out the key to req lookup\n\n        k2q[key] = null; // dequeueing isn't necessary with an existing cache\n\n        if (cacheExists) {\n          continue;\n        }\n\n        dequeued.push(req);\n        var bb = self.getBoundingBox(ele);\n        self.getElement(ele, bb, pxRatio, req.level, getTxrReasons.dequeue);\n      } else {\n        break;\n      }\n    }\n\n    return dequeued;\n  };\n\n  ETCp.removeFromQueue = function (ele) {\n    var self = this;\n    var q = self.getElementQueue();\n    var k2q = self.getElementKeyToQueue();\n    var key = this.getKey(ele);\n    var req = k2q[key];\n\n    if (req != null) {\n      if (req.eles.length === 1) {\n        // remove if last ele in the req\n        // bring to front of queue\n        req.reqs = MAX_INT$1;\n        q.updateItem(req);\n        q.pop(); // remove from queue\n\n        k2q[key] = null; // remove from lookup map\n      } else {\n        // otherwise just remove ele from req\n        req.eles.unmerge(ele);\n      }\n    }\n  };\n\n  ETCp.onDequeue = function (fn) {\n    this.onDequeues.push(fn);\n  };\n\n  ETCp.offDequeue = function (fn) {\n    removeFromArray(this.onDequeues, fn);\n  };\n\n  ETCp.setupDequeueing = defs.setupDequeueing({\n    deqRedrawThreshold: deqRedrawThreshold$1,\n    deqCost: deqCost$1,\n    deqAvgCost: deqAvgCost$1,\n    deqNoDrawCost: deqNoDrawCost$1,\n    deqFastCost: deqFastCost$1,\n    deq: function deq(self, pxRatio, extent) {\n      return self.dequeue(pxRatio, extent);\n    },\n    onDeqd: function onDeqd(self, deqd) {\n      for (var i = 0; i < self.onDequeues.length; i++) {\n        var fn = self.onDequeues[i];\n        fn(deqd);\n      }\n    },\n    shouldRedraw: function shouldRedraw(self, deqd, pxRatio, extent) {\n      for (var i = 0; i < deqd.length; i++) {\n        var eles = deqd[i].eles;\n\n        for (var j = 0; j < eles.length; j++) {\n          var bb = eles[j].boundingBox();\n\n          if (boundingBoxesIntersect(bb, extent)) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    },\n    priority: function priority(self) {\n      return self.renderer.beforeRenderPriorities.eleTxrDeq;\n    }\n  });\n\n  var defNumLayers = 1; // default number of layers to use\n\n  var minLvl = -4; // when scaling smaller than that we don't need to re-render\n\n  var maxLvl = 2; // when larger than this scale just render directly (caching is not helpful)\n\n  var maxZoom = 3.99; // beyond this zoom level, layered textures are not used\n\n  var deqRedrawThreshold = 50; // time to batch redraws together from dequeueing to allow more dequeueing calcs to happen in the meanwhile\n\n  var refineEleDebounceTime = 50; // time to debounce sharper ele texture updates\n\n  var deqCost = 0.15; // % of add'l rendering cost allowed for dequeuing ele caches each frame\n\n  var deqAvgCost = 0.1; // % of add'l rendering cost compared to average overall redraw time\n\n  var deqNoDrawCost = 0.9; // % of avg frame time that can be used for dequeueing when not drawing\n\n  var deqFastCost = 0.9; // % of frame time to be used when >60fps\n\n  var maxDeqSize = 1; // number of eles to dequeue and render at higher texture in each batch\n\n  var invalidThreshold = 250; // time threshold for disabling b/c of invalidations\n\n  var maxLayerArea = 4000 * 4000; // layers can't be bigger than this\n\n  var useHighQualityEleTxrReqs = true; // whether to use high quality ele txr requests (generally faster and cheaper in the longterm)\n  // var log = function(){ console.log.apply( console, arguments ); };\n\n  var LayeredTextureCache = function LayeredTextureCache(renderer) {\n    var self = this;\n    var r = self.renderer = renderer;\n    var cy = r.cy;\n    self.layersByLevel = {}; // e.g. 2 => [ layer1, layer2, ..., layerN ]\n\n    self.firstGet = true;\n    self.lastInvalidationTime = performanceNow() - 2 * invalidThreshold;\n    self.skipping = false;\n    self.eleTxrDeqs = cy.collection();\n    self.scheduleElementRefinement = debounce_1(function () {\n      self.refineElementTextures(self.eleTxrDeqs);\n      self.eleTxrDeqs.unmerge(self.eleTxrDeqs);\n    }, refineEleDebounceTime);\n    r.beforeRender(function (willDraw, now) {\n      if (now - self.lastInvalidationTime <= invalidThreshold) {\n        self.skipping = true;\n      } else {\n        self.skipping = false;\n      }\n    }, r.beforeRenderPriorities.lyrTxrSkip);\n\n    var qSort = function qSort(a, b) {\n      return b.reqs - a.reqs;\n    };\n\n    self.layersQueue = new heap(qSort);\n    self.setupDequeueing();\n  };\n\n  var LTCp = LayeredTextureCache.prototype;\n  var layerIdPool = 0;\n  var MAX_INT = Math.pow(2, 53) - 1;\n\n  LTCp.makeLayer = function (bb, lvl) {\n    var scale = Math.pow(2, lvl);\n    var w = Math.ceil(bb.w * scale);\n    var h = Math.ceil(bb.h * scale);\n    var canvas = this.renderer.makeOffscreenCanvas(w, h);\n    var layer = {\n      id: layerIdPool = ++layerIdPool % MAX_INT,\n      bb: bb,\n      level: lvl,\n      width: w,\n      height: h,\n      canvas: canvas,\n      context: canvas.getContext('2d'),\n      eles: [],\n      elesQueue: [],\n      reqs: 0\n    }; // log('make layer %s with w %s and h %s and lvl %s', layer.id, layer.width, layer.height, layer.level);\n\n    var cxt = layer.context;\n    var dx = -layer.bb.x1;\n    var dy = -layer.bb.y1; // do the transform on creation to save cycles (it's the same for all eles)\n\n    cxt.scale(scale, scale);\n    cxt.translate(dx, dy);\n    return layer;\n  };\n\n  LTCp.getLayers = function (eles, pxRatio, lvl) {\n    var self = this;\n    var r = self.renderer;\n    var cy = r.cy;\n    var zoom = cy.zoom();\n    var firstGet = self.firstGet;\n    self.firstGet = false; // log('--\\nget layers with %s eles', eles.length);\n    //log eles.map(function(ele){ return ele.id() }) );\n\n    if (lvl == null) {\n      lvl = Math.ceil(log2(zoom * pxRatio));\n\n      if (lvl < minLvl) {\n        lvl = minLvl;\n      } else if (zoom >= maxZoom || lvl > maxLvl) {\n        return null;\n      }\n    }\n\n    self.validateLayersElesOrdering(lvl, eles);\n    var layersByLvl = self.layersByLevel;\n    var scale = Math.pow(2, lvl);\n    var layers = layersByLvl[lvl] = layersByLvl[lvl] || [];\n    var bb;\n    var lvlComplete = self.levelIsComplete(lvl, eles);\n    var tmpLayers;\n\n    var checkTempLevels = function checkTempLevels() {\n      var canUseAsTmpLvl = function canUseAsTmpLvl(l) {\n        self.validateLayersElesOrdering(l, eles);\n\n        if (self.levelIsComplete(l, eles)) {\n          tmpLayers = layersByLvl[l];\n          return true;\n        }\n      };\n\n      var checkLvls = function checkLvls(dir) {\n        if (tmpLayers) {\n          return;\n        }\n\n        for (var l = lvl + dir; minLvl <= l && l <= maxLvl; l += dir) {\n          if (canUseAsTmpLvl(l)) {\n            break;\n          }\n        }\n      };\n\n      checkLvls(+1);\n      checkLvls(-1); // remove the invalid layers; they will be replaced as needed later in this function\n\n      for (var i = layers.length - 1; i >= 0; i--) {\n        var layer = layers[i];\n\n        if (layer.invalid) {\n          removeFromArray(layers, layer);\n        }\n      }\n    };\n\n    if (!lvlComplete) {\n      // if the current level is incomplete, then use the closest, best quality layerset temporarily\n      // and later queue the current layerset so we can get the proper quality level soon\n      checkTempLevels();\n    } else {\n      // log('level complete, using existing layers\\n--');\n      return layers;\n    }\n\n    var getBb = function getBb() {\n      if (!bb) {\n        bb = makeBoundingBox();\n\n        for (var i = 0; i < eles.length; i++) {\n          updateBoundingBox(bb, eles[i].boundingBox());\n        }\n      }\n\n      return bb;\n    };\n\n    var makeLayer = function makeLayer(opts) {\n      opts = opts || {};\n      var after = opts.after;\n      getBb();\n      var area = bb.w * scale * (bb.h * scale);\n\n      if (area > maxLayerArea) {\n        return null;\n      }\n\n      var layer = self.makeLayer(bb, lvl);\n\n      if (after != null) {\n        var index = layers.indexOf(after) + 1;\n        layers.splice(index, 0, layer);\n      } else if (opts.insert === undefined || opts.insert) {\n        // no after specified => first layer made so put at start\n        layers.unshift(layer);\n      } // if( tmpLayers ){\n      //self.queueLayer( layer );\n      // }\n\n\n      return layer;\n    };\n\n    if (self.skipping && !firstGet) {\n      // log('skip layers');\n      return null;\n    } // log('do layers');\n\n\n    var layer = null;\n    var maxElesPerLayer = eles.length / defNumLayers;\n    var allowLazyQueueing = !firstGet;\n\n    for (var i = 0; i < eles.length; i++) {\n      var ele = eles[i];\n      var rs = ele._private.rscratch;\n      var caches = rs.imgLayerCaches = rs.imgLayerCaches || {}; // log('look at ele', ele.id());\n\n      var existingLayer = caches[lvl];\n\n      if (existingLayer) {\n        // reuse layer for later eles\n        // log('reuse layer for', ele.id());\n        layer = existingLayer;\n        continue;\n      }\n\n      if (!layer || layer.eles.length >= maxElesPerLayer || !boundingBoxInBoundingBox(layer.bb, ele.boundingBox())) {\n        // log('make new layer for ele %s', ele.id());\n        layer = makeLayer({\n          insert: true,\n          after: layer\n        }); // if now layer can be built then we can't use layers at this level\n\n        if (!layer) {\n          return null;\n        } // log('new layer with id %s', layer.id);\n\n      }\n\n      if (tmpLayers || allowLazyQueueing) {\n        // log('queue ele %s in layer %s', ele.id(), layer.id);\n        self.queueLayer(layer, ele);\n      } else {\n        // log('draw ele %s in layer %s', ele.id(), layer.id);\n        self.drawEleInLayer(layer, ele, lvl, pxRatio);\n      }\n\n      layer.eles.push(ele);\n      caches[lvl] = layer;\n    } // log('--');\n\n\n    if (tmpLayers) {\n      // then we only queued the current layerset and can't draw it yet\n      return tmpLayers;\n    }\n\n    if (allowLazyQueueing) {\n      // log('lazy queue level', lvl);\n      return null;\n    }\n\n    return layers;\n  }; // a layer may want to use an ele cache of a higher level to avoid blurriness\n  // so the layer level might not equal the ele level\n\n\n  LTCp.getEleLevelForLayerLevel = function (lvl, pxRatio) {\n    return lvl;\n  };\n\n  LTCp.drawEleInLayer = function (layer, ele, lvl, pxRatio) {\n    var self = this;\n    var r = this.renderer;\n    var context = layer.context;\n    var bb = ele.boundingBox();\n\n    if (bb.w === 0 || bb.h === 0 || !ele.visible()) {\n      return;\n    }\n\n    lvl = self.getEleLevelForLayerLevel(lvl, pxRatio);\n\n    {\n      r.setImgSmoothing(context, false);\n    }\n\n    {\n      r.drawCachedElement(context, ele, null, null, lvl, useHighQualityEleTxrReqs);\n    }\n\n    {\n      r.setImgSmoothing(context, true);\n    }\n  };\n\n  LTCp.levelIsComplete = function (lvl, eles) {\n    var self = this;\n    var layers = self.layersByLevel[lvl];\n\n    if (!layers || layers.length === 0) {\n      return false;\n    }\n\n    var numElesInLayers = 0;\n\n    for (var i = 0; i < layers.length; i++) {\n      var layer = layers[i]; // if there are any eles needed to be drawn yet, the level is not complete\n\n      if (layer.reqs > 0) {\n        return false;\n      } // if the layer is invalid, the level is not complete\n\n\n      if (layer.invalid) {\n        return false;\n      }\n\n      numElesInLayers += layer.eles.length;\n    } // we should have exactly the number of eles passed in to be complete\n\n\n    if (numElesInLayers !== eles.length) {\n      return false;\n    }\n\n    return true;\n  };\n\n  LTCp.validateLayersElesOrdering = function (lvl, eles) {\n    var layers = this.layersByLevel[lvl];\n\n    if (!layers) {\n      return;\n    } // if in a layer the eles are not in the same order, then the layer is invalid\n    // (i.e. there is an ele in between the eles in the layer)\n\n\n    for (var i = 0; i < layers.length; i++) {\n      var layer = layers[i];\n      var offset = -1; // find the offset\n\n      for (var j = 0; j < eles.length; j++) {\n        if (layer.eles[0] === eles[j]) {\n          offset = j;\n          break;\n        }\n      }\n\n      if (offset < 0) {\n        // then the layer has nonexistent elements and is invalid\n        this.invalidateLayer(layer);\n        continue;\n      } // the eles in the layer must be in the same continuous order, else the layer is invalid\n\n\n      var o = offset;\n\n      for (var j = 0; j < layer.eles.length; j++) {\n        if (layer.eles[j] !== eles[o + j]) {\n          // log('invalidate based on ordering', layer.id);\n          this.invalidateLayer(layer);\n          break;\n        }\n      }\n    }\n  };\n\n  LTCp.updateElementsInLayers = function (eles, update) {\n    var self = this;\n    var isEles = element(eles[0]); // collect udpated elements (cascaded from the layers) and update each\n    // layer itself along the way\n\n    for (var i = 0; i < eles.length; i++) {\n      var req = isEles ? null : eles[i];\n      var ele = isEles ? eles[i] : eles[i].ele;\n      var rs = ele._private.rscratch;\n      var caches = rs.imgLayerCaches = rs.imgLayerCaches || {};\n\n      for (var l = minLvl; l <= maxLvl; l++) {\n        var layer = caches[l];\n\n        if (!layer) {\n          continue;\n        } // if update is a request from the ele cache, then it affects only\n        // the matching level\n\n\n        if (req && self.getEleLevelForLayerLevel(layer.level) !== req.level) {\n          continue;\n        }\n\n        update(layer, ele, req);\n      }\n    }\n  };\n\n  LTCp.haveLayers = function () {\n    var self = this;\n    var haveLayers = false;\n\n    for (var l = minLvl; l <= maxLvl; l++) {\n      var layers = self.layersByLevel[l];\n\n      if (layers && layers.length > 0) {\n        haveLayers = true;\n        break;\n      }\n    }\n\n    return haveLayers;\n  };\n\n  LTCp.invalidateElements = function (eles) {\n    var self = this;\n\n    if (eles.length === 0) {\n      return;\n    }\n\n    self.lastInvalidationTime = performanceNow(); // log('update invalidate layer time from eles');\n\n    if (eles.length === 0 || !self.haveLayers()) {\n      return;\n    }\n\n    self.updateElementsInLayers(eles, function invalAssocLayers(layer, ele, req) {\n      self.invalidateLayer(layer);\n    });\n  };\n\n  LTCp.invalidateLayer = function (layer) {\n    // log('update invalidate layer time');\n    this.lastInvalidationTime = performanceNow();\n\n    if (layer.invalid) {\n      return;\n    } // save cycles\n\n\n    var lvl = layer.level;\n    var eles = layer.eles;\n    var layers = this.layersByLevel[lvl]; // log('invalidate layer', layer.id );\n\n    removeFromArray(layers, layer); // layer.eles = [];\n\n    layer.elesQueue = [];\n    layer.invalid = true;\n\n    if (layer.replacement) {\n      layer.replacement.invalid = true;\n    }\n\n    for (var i = 0; i < eles.length; i++) {\n      var caches = eles[i]._private.rscratch.imgLayerCaches;\n\n      if (caches) {\n        caches[lvl] = null;\n      }\n    }\n  };\n\n  LTCp.refineElementTextures = function (eles) {\n    var self = this; // log('refine', eles.length);\n\n    self.updateElementsInLayers(eles, function refineEachEle(layer, ele, req) {\n      var rLyr = layer.replacement;\n\n      if (!rLyr) {\n        rLyr = layer.replacement = self.makeLayer(layer.bb, layer.level);\n        rLyr.replaces = layer;\n        rLyr.eles = layer.eles; // log('make replacement layer %s for %s with level %s', rLyr.id, layer.id, rLyr.level);\n      }\n\n      if (!rLyr.reqs) {\n        for (var i = 0; i < rLyr.eles.length; i++) {\n          self.queueLayer(rLyr, rLyr.eles[i]);\n        } // log('queue replacement layer refinement', rLyr.id);\n\n      }\n    });\n  };\n\n  LTCp.enqueueElementRefinement = function (ele) {\n\n    this.eleTxrDeqs.merge(ele);\n    this.scheduleElementRefinement();\n  };\n\n  LTCp.queueLayer = function (layer, ele) {\n    var self = this;\n    var q = self.layersQueue;\n    var elesQ = layer.elesQueue;\n    var hasId = elesQ.hasId = elesQ.hasId || {}; // if a layer is going to be replaced, queuing is a waste of time\n\n    if (layer.replacement) {\n      return;\n    }\n\n    if (ele) {\n      if (hasId[ele.id()]) {\n        return;\n      }\n\n      elesQ.push(ele);\n      hasId[ele.id()] = true;\n    }\n\n    if (layer.reqs) {\n      layer.reqs++;\n      q.updateItem(layer);\n    } else {\n      layer.reqs = 1;\n      q.push(layer);\n    }\n  };\n\n  LTCp.dequeue = function (pxRatio) {\n    var self = this;\n    var q = self.layersQueue;\n    var deqd = [];\n    var eleDeqs = 0;\n\n    while (eleDeqs < maxDeqSize) {\n      if (q.size() === 0) {\n        break;\n      }\n\n      var layer = q.peek(); // if a layer has been or will be replaced, then don't waste time with it\n\n      if (layer.replacement) {\n        // log('layer %s in queue skipped b/c it already has a replacement', layer.id);\n        q.pop();\n        continue;\n      } // if this is a replacement layer that has been superceded, then forget it\n\n\n      if (layer.replaces && layer !== layer.replaces.replacement) {\n        // log('layer is no longer the most uptodate replacement; dequeued', layer.id)\n        q.pop();\n        continue;\n      }\n\n      if (layer.invalid) {\n        // log('replacement layer %s is invalid; dequeued', layer.id);\n        q.pop();\n        continue;\n      }\n\n      var ele = layer.elesQueue.shift();\n\n      if (ele) {\n        // log('dequeue layer %s', layer.id);\n        self.drawEleInLayer(layer, ele, layer.level, pxRatio);\n        eleDeqs++;\n      }\n\n      if (deqd.length === 0) {\n        // we need only one entry in deqd to queue redrawing etc\n        deqd.push(true);\n      } // if the layer has all its eles done, then remove from the queue\n\n\n      if (layer.elesQueue.length === 0) {\n        q.pop();\n        layer.reqs = 0; // log('dequeue of layer %s complete', layer.id);\n        // when a replacement layer is dequeued, it replaces the old layer in the level\n\n        if (layer.replaces) {\n          self.applyLayerReplacement(layer);\n        }\n\n        self.requestRedraw();\n      }\n    }\n\n    return deqd;\n  };\n\n  LTCp.applyLayerReplacement = function (layer) {\n    var self = this;\n    var layersInLevel = self.layersByLevel[layer.level];\n    var replaced = layer.replaces;\n    var index = layersInLevel.indexOf(replaced); // if the replaced layer is not in the active list for the level, then replacing\n    // refs would be a mistake (i.e. overwriting the true active layer)\n\n    if (index < 0 || replaced.invalid) {\n      // log('replacement layer would have no effect', layer.id);\n      return;\n    }\n\n    layersInLevel[index] = layer; // replace level ref\n    // replace refs in eles\n\n    for (var i = 0; i < layer.eles.length; i++) {\n      var _p = layer.eles[i]._private;\n      var cache = _p.imgLayerCaches = _p.imgLayerCaches || {};\n\n      if (cache) {\n        cache[layer.level] = layer;\n      }\n    } // log('apply replacement layer %s over %s', layer.id, replaced.id);\n\n\n    self.requestRedraw();\n  };\n\n  LTCp.requestRedraw = debounce_1(function () {\n    var r = this.renderer;\n    r.redrawHint('eles', true);\n    r.redrawHint('drag', true);\n    r.redraw();\n  }, 100);\n  LTCp.setupDequeueing = defs.setupDequeueing({\n    deqRedrawThreshold: deqRedrawThreshold,\n    deqCost: deqCost,\n    deqAvgCost: deqAvgCost,\n    deqNoDrawCost: deqNoDrawCost,\n    deqFastCost: deqFastCost,\n    deq: function deq(self, pxRatio) {\n      return self.dequeue(pxRatio);\n    },\n    onDeqd: noop$1,\n    shouldRedraw: trueify,\n    priority: function priority(self) {\n      return self.renderer.beforeRenderPriorities.lyrTxrDeq;\n    }\n  });\n\n  var CRp$a = {};\n  var impl;\n\n  function polygon(context, points) {\n    for (var i = 0; i < points.length; i++) {\n      var pt = points[i];\n      context.lineTo(pt.x, pt.y);\n    }\n  }\n\n  function triangleBackcurve(context, points, controlPoint) {\n    var firstPt;\n\n    for (var i = 0; i < points.length; i++) {\n      var pt = points[i];\n\n      if (i === 0) {\n        firstPt = pt;\n      }\n\n      context.lineTo(pt.x, pt.y);\n    }\n\n    context.quadraticCurveTo(controlPoint.x, controlPoint.y, firstPt.x, firstPt.y);\n  }\n\n  function triangleTee(context, trianglePoints, teePoints) {\n    if (context.beginPath) {\n      context.beginPath();\n    }\n\n    var triPts = trianglePoints;\n\n    for (var i = 0; i < triPts.length; i++) {\n      var pt = triPts[i];\n      context.lineTo(pt.x, pt.y);\n    }\n\n    var teePts = teePoints;\n    var firstTeePt = teePoints[0];\n    context.moveTo(firstTeePt.x, firstTeePt.y);\n\n    for (var i = 1; i < teePts.length; i++) {\n      var pt = teePts[i];\n      context.lineTo(pt.x, pt.y);\n    }\n\n    if (context.closePath) {\n      context.closePath();\n    }\n  }\n\n  function circleTriangle(context, trianglePoints, rx, ry, r) {\n    if (context.beginPath) {\n      context.beginPath();\n    }\n\n    context.arc(rx, ry, r, 0, Math.PI * 2, false);\n    var triPts = trianglePoints;\n    var firstTrPt = triPts[0];\n    context.moveTo(firstTrPt.x, firstTrPt.y);\n\n    for (var i = 0; i < triPts.length; i++) {\n      var pt = triPts[i];\n      context.lineTo(pt.x, pt.y);\n    }\n\n    if (context.closePath) {\n      context.closePath();\n    }\n  }\n\n  function circle(context, rx, ry, r) {\n    context.arc(rx, ry, r, 0, Math.PI * 2, false);\n  }\n\n  CRp$a.arrowShapeImpl = function (name) {\n    return (impl || (impl = {\n      'polygon': polygon,\n      'triangle-backcurve': triangleBackcurve,\n      'triangle-tee': triangleTee,\n      'circle-triangle': circleTriangle,\n      'triangle-cross': triangleTee,\n      'circle': circle\n    }))[name];\n  };\n\n  var CRp$9 = {};\n\n  CRp$9.drawElement = function (context, ele, shiftToOriginWithBb, showLabel, showOverlay, showOpacity) {\n    var r = this;\n\n    if (ele.isNode()) {\n      r.drawNode(context, ele, shiftToOriginWithBb, showLabel, showOverlay, showOpacity);\n    } else {\n      r.drawEdge(context, ele, shiftToOriginWithBb, showLabel, showOverlay, showOpacity);\n    }\n  };\n\n  CRp$9.drawElementOverlay = function (context, ele) {\n    var r = this;\n\n    if (ele.isNode()) {\n      r.drawNodeOverlay(context, ele);\n    } else {\n      r.drawEdgeOverlay(context, ele);\n    }\n  };\n\n  CRp$9.drawElementUnderlay = function (context, ele) {\n    var r = this;\n\n    if (ele.isNode()) {\n      r.drawNodeUnderlay(context, ele);\n    } else {\n      r.drawEdgeUnderlay(context, ele);\n    }\n  };\n\n  CRp$9.drawCachedElementPortion = function (context, ele, eleTxrCache, pxRatio, lvl, reason, getRotation, getOpacity) {\n    var r = this;\n    var bb = eleTxrCache.getBoundingBox(ele);\n\n    if (bb.w === 0 || bb.h === 0) {\n      return;\n    } // ignore zero size case\n\n\n    var eleCache = eleTxrCache.getElement(ele, bb, pxRatio, lvl, reason);\n\n    if (eleCache != null) {\n      var opacity = getOpacity(r, ele);\n\n      if (opacity === 0) {\n        return;\n      }\n\n      var theta = getRotation(r, ele);\n      var x1 = bb.x1,\n          y1 = bb.y1,\n          w = bb.w,\n          h = bb.h;\n      var x, y, sx, sy, smooth;\n\n      if (theta !== 0) {\n        var rotPt = eleTxrCache.getRotationPoint(ele);\n        sx = rotPt.x;\n        sy = rotPt.y;\n        context.translate(sx, sy);\n        context.rotate(theta);\n        smooth = r.getImgSmoothing(context);\n\n        if (!smooth) {\n          r.setImgSmoothing(context, true);\n        }\n\n        var off = eleTxrCache.getRotationOffset(ele);\n        x = off.x;\n        y = off.y;\n      } else {\n        x = x1;\n        y = y1;\n      }\n\n      var oldGlobalAlpha;\n\n      if (opacity !== 1) {\n        oldGlobalAlpha = context.globalAlpha;\n        context.globalAlpha = oldGlobalAlpha * opacity;\n      }\n\n      context.drawImage(eleCache.texture.canvas, eleCache.x, 0, eleCache.width, eleCache.height, x, y, w, h);\n\n      if (opacity !== 1) {\n        context.globalAlpha = oldGlobalAlpha;\n      }\n\n      if (theta !== 0) {\n        context.rotate(-theta);\n        context.translate(-sx, -sy);\n\n        if (!smooth) {\n          r.setImgSmoothing(context, false);\n        }\n      }\n    } else {\n      eleTxrCache.drawElement(context, ele); // direct draw fallback\n    }\n  };\n\n  var getZeroRotation = function getZeroRotation() {\n    return 0;\n  };\n\n  var getLabelRotation = function getLabelRotation(r, ele) {\n    return r.getTextAngle(ele, null);\n  };\n\n  var getSourceLabelRotation = function getSourceLabelRotation(r, ele) {\n    return r.getTextAngle(ele, 'source');\n  };\n\n  var getTargetLabelRotation = function getTargetLabelRotation(r, ele) {\n    return r.getTextAngle(ele, 'target');\n  };\n\n  var getOpacity = function getOpacity(r, ele) {\n    return ele.effectiveOpacity();\n  };\n\n  var getTextOpacity = function getTextOpacity(e, ele) {\n    return ele.pstyle('text-opacity').pfValue * ele.effectiveOpacity();\n  };\n\n  CRp$9.drawCachedElement = function (context, ele, pxRatio, extent, lvl, requestHighQuality) {\n    var r = this;\n    var _r$data = r.data,\n        eleTxrCache = _r$data.eleTxrCache,\n        lblTxrCache = _r$data.lblTxrCache,\n        slbTxrCache = _r$data.slbTxrCache,\n        tlbTxrCache = _r$data.tlbTxrCache;\n    var bb = ele.boundingBox();\n    var reason = requestHighQuality === true ? eleTxrCache.reasons.highQuality : null;\n\n    if (bb.w === 0 || bb.h === 0 || !ele.visible()) {\n      return;\n    }\n\n    if (!extent || boundingBoxesIntersect(bb, extent)) {\n      var isEdge = ele.isEdge();\n\n      var badLine = ele.element()._private.rscratch.badLine;\n\n      r.drawElementUnderlay(context, ele);\n      r.drawCachedElementPortion(context, ele, eleTxrCache, pxRatio, lvl, reason, getZeroRotation, getOpacity);\n\n      if (!isEdge || !badLine) {\n        r.drawCachedElementPortion(context, ele, lblTxrCache, pxRatio, lvl, reason, getLabelRotation, getTextOpacity);\n      }\n\n      if (isEdge && !badLine) {\n        r.drawCachedElementPortion(context, ele, slbTxrCache, pxRatio, lvl, reason, getSourceLabelRotation, getTextOpacity);\n        r.drawCachedElementPortion(context, ele, tlbTxrCache, pxRatio, lvl, reason, getTargetLabelRotation, getTextOpacity);\n      }\n\n      r.drawElementOverlay(context, ele);\n    }\n  };\n\n  CRp$9.drawElements = function (context, eles) {\n    var r = this;\n\n    for (var i = 0; i < eles.length; i++) {\n      var ele = eles[i];\n      r.drawElement(context, ele);\n    }\n  };\n\n  CRp$9.drawCachedElements = function (context, eles, pxRatio, extent) {\n    var r = this;\n\n    for (var i = 0; i < eles.length; i++) {\n      var ele = eles[i];\n      r.drawCachedElement(context, ele, pxRatio, extent);\n    }\n  };\n\n  CRp$9.drawCachedNodes = function (context, eles, pxRatio, extent) {\n    var r = this;\n\n    for (var i = 0; i < eles.length; i++) {\n      var ele = eles[i];\n\n      if (!ele.isNode()) {\n        continue;\n      }\n\n      r.drawCachedElement(context, ele, pxRatio, extent);\n    }\n  };\n\n  CRp$9.drawLayeredElements = function (context, eles, pxRatio, extent) {\n    var r = this;\n    var layers = r.data.lyrTxrCache.getLayers(eles, pxRatio);\n\n    if (layers) {\n      for (var i = 0; i < layers.length; i++) {\n        var layer = layers[i];\n        var bb = layer.bb;\n\n        if (bb.w === 0 || bb.h === 0) {\n          continue;\n        }\n\n        context.drawImage(layer.canvas, bb.x1, bb.y1, bb.w, bb.h);\n      }\n    } else {\n      // fall back on plain caching if no layers\n      r.drawCachedElements(context, eles, pxRatio, extent);\n    }\n  };\n\n  /* global Path2D */\n  var CRp$8 = {};\n\n  CRp$8.drawEdge = function (context, edge, shiftToOriginWithBb) {\n    var drawLabel = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    var shouldDrawOverlay = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    var shouldDrawOpacity = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n    var r = this;\n    var rs = edge._private.rscratch;\n\n    if (shouldDrawOpacity && !edge.visible()) {\n      return;\n    } // if bezier ctrl pts can not be calculated, then die\n\n\n    if (rs.badLine || rs.allpts == null || isNaN(rs.allpts[0])) {\n      // isNaN in case edge is impossible and browser bugs (e.g. safari)\n      return;\n    }\n\n    var bb;\n\n    if (shiftToOriginWithBb) {\n      bb = shiftToOriginWithBb;\n      context.translate(-bb.x1, -bb.y1);\n    }\n\n    var opacity = shouldDrawOpacity ? edge.pstyle('opacity').value : 1;\n    var lineOpacity = shouldDrawOpacity ? edge.pstyle('line-opacity').value : 1;\n    var curveStyle = edge.pstyle('curve-style').value;\n    var lineStyle = edge.pstyle('line-style').value;\n    var edgeWidth = edge.pstyle('width').pfValue;\n    var lineCap = edge.pstyle('line-cap').value;\n    var effectiveLineOpacity = opacity * lineOpacity; // separate arrow opacity would require arrow-opacity property\n\n    var effectiveArrowOpacity = opacity * lineOpacity;\n\n    var drawLine = function drawLine() {\n      var strokeOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : effectiveLineOpacity;\n\n      if (curveStyle === 'straight-triangle') {\n        r.eleStrokeStyle(context, edge, strokeOpacity);\n        r.drawEdgeTrianglePath(edge, context, rs.allpts);\n      } else {\n        context.lineWidth = edgeWidth;\n        context.lineCap = lineCap;\n        r.eleStrokeStyle(context, edge, strokeOpacity);\n        r.drawEdgePath(edge, context, rs.allpts, lineStyle);\n        context.lineCap = 'butt'; // reset for other drawing functions\n      }\n    };\n\n    var drawOverlay = function drawOverlay() {\n      if (!shouldDrawOverlay) {\n        return;\n      }\n\n      r.drawEdgeOverlay(context, edge);\n    };\n\n    var drawUnderlay = function drawUnderlay() {\n      if (!shouldDrawOverlay) {\n        return;\n      }\n\n      r.drawEdgeUnderlay(context, edge);\n    };\n\n    var drawArrows = function drawArrows() {\n      var arrowOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : effectiveArrowOpacity;\n      r.drawArrowheads(context, edge, arrowOpacity);\n    };\n\n    var drawText = function drawText() {\n      r.drawElementText(context, edge, null, drawLabel);\n    };\n\n    context.lineJoin = 'round';\n    var ghost = edge.pstyle('ghost').value === 'yes';\n\n    if (ghost) {\n      var gx = edge.pstyle('ghost-offset-x').pfValue;\n      var gy = edge.pstyle('ghost-offset-y').pfValue;\n      var ghostOpacity = edge.pstyle('ghost-opacity').value;\n      var effectiveGhostOpacity = effectiveLineOpacity * ghostOpacity;\n      context.translate(gx, gy);\n      drawLine(effectiveGhostOpacity);\n      drawArrows(effectiveGhostOpacity);\n      context.translate(-gx, -gy);\n    }\n\n    drawUnderlay();\n    drawLine();\n    drawArrows();\n    drawOverlay();\n    drawText();\n\n    if (shiftToOriginWithBb) {\n      context.translate(bb.x1, bb.y1);\n    }\n  };\n\n  var drawEdgeOverlayUnderlay = function drawEdgeOverlayUnderlay(overlayOrUnderlay) {\n    if (!['overlay', 'underlay'].includes(overlayOrUnderlay)) {\n      throw new Error('Invalid state');\n    }\n\n    return function (context, edge) {\n      if (!edge.visible()) {\n        return;\n      }\n\n      var opacity = edge.pstyle(\"\".concat(overlayOrUnderlay, \"-opacity\")).value;\n\n      if (opacity === 0) {\n        return;\n      }\n\n      var r = this;\n      var usePaths = r.usePaths();\n      var rs = edge._private.rscratch;\n      var padding = edge.pstyle(\"\".concat(overlayOrUnderlay, \"-padding\")).pfValue;\n      var width = 2 * padding;\n      var color = edge.pstyle(\"\".concat(overlayOrUnderlay, \"-color\")).value;\n      context.lineWidth = width;\n\n      if (rs.edgeType === 'self' && !usePaths) {\n        context.lineCap = 'butt';\n      } else {\n        context.lineCap = 'round';\n      }\n\n      r.colorStrokeStyle(context, color[0], color[1], color[2], opacity);\n      r.drawEdgePath(edge, context, rs.allpts, 'solid');\n    };\n  };\n\n  CRp$8.drawEdgeOverlay = drawEdgeOverlayUnderlay('overlay');\n  CRp$8.drawEdgeUnderlay = drawEdgeOverlayUnderlay('underlay');\n\n  CRp$8.drawEdgePath = function (edge, context, pts, type) {\n    var rs = edge._private.rscratch;\n    var canvasCxt = context;\n    var path;\n    var pathCacheHit = false;\n    var usePaths = this.usePaths();\n    var lineDashPattern = edge.pstyle('line-dash-pattern').pfValue;\n    var lineDashOffset = edge.pstyle('line-dash-offset').pfValue;\n\n    if (usePaths) {\n      var pathCacheKey = pts.join('$');\n      var keyMatches = rs.pathCacheKey && rs.pathCacheKey === pathCacheKey;\n\n      if (keyMatches) {\n        path = context = rs.pathCache;\n        pathCacheHit = true;\n      } else {\n        path = context = new Path2D();\n        rs.pathCacheKey = pathCacheKey;\n        rs.pathCache = path;\n      }\n    }\n\n    if (canvasCxt.setLineDash) {\n      // for very outofdate browsers\n      switch (type) {\n        case 'dotted':\n          canvasCxt.setLineDash([1, 1]);\n          break;\n\n        case 'dashed':\n          canvasCxt.setLineDash(lineDashPattern);\n          canvasCxt.lineDashOffset = lineDashOffset;\n          break;\n\n        case 'solid':\n          canvasCxt.setLineDash([]);\n          break;\n      }\n    }\n\n    if (!pathCacheHit && !rs.badLine) {\n      if (context.beginPath) {\n        context.beginPath();\n      }\n\n      context.moveTo(pts[0], pts[1]);\n\n      switch (rs.edgeType) {\n        case 'bezier':\n        case 'self':\n        case 'compound':\n        case 'multibezier':\n          for (var i = 2; i + 3 < pts.length; i += 4) {\n            context.quadraticCurveTo(pts[i], pts[i + 1], pts[i + 2], pts[i + 3]);\n          }\n\n          break;\n\n        case 'straight':\n        case 'segments':\n        case 'haystack':\n          for (var _i = 2; _i + 1 < pts.length; _i += 2) {\n            context.lineTo(pts[_i], pts[_i + 1]);\n          }\n\n          break;\n      }\n    }\n\n    context = canvasCxt;\n\n    if (usePaths) {\n      context.stroke(path);\n    } else {\n      context.stroke();\n    } // reset any line dashes\n\n\n    if (context.setLineDash) {\n      // for very outofdate browsers\n      context.setLineDash([]);\n    }\n  };\n\n  CRp$8.drawEdgeTrianglePath = function (edge, context, pts) {\n    // use line stroke style for triangle fill style\n    context.fillStyle = context.strokeStyle;\n    var edgeWidth = edge.pstyle('width').pfValue;\n\n    for (var i = 0; i + 1 < pts.length; i += 2) {\n      var vector = [pts[i + 2] - pts[i], pts[i + 3] - pts[i + 1]];\n      var length = Math.sqrt(vector[0] * vector[0] + vector[1] * vector[1]);\n      var normal = [vector[1] / length, -vector[0] / length];\n      var triangleHead = [normal[0] * edgeWidth / 2, normal[1] * edgeWidth / 2];\n      context.beginPath();\n      context.moveTo(pts[i] - triangleHead[0], pts[i + 1] - triangleHead[1]);\n      context.lineTo(pts[i] + triangleHead[0], pts[i + 1] + triangleHead[1]);\n      context.lineTo(pts[i + 2], pts[i + 3]);\n      context.closePath();\n      context.fill();\n    }\n  };\n\n  CRp$8.drawArrowheads = function (context, edge, opacity) {\n    var rs = edge._private.rscratch;\n    var isHaystack = rs.edgeType === 'haystack';\n\n    if (!isHaystack) {\n      this.drawArrowhead(context, edge, 'source', rs.arrowStartX, rs.arrowStartY, rs.srcArrowAngle, opacity);\n    }\n\n    this.drawArrowhead(context, edge, 'mid-target', rs.midX, rs.midY, rs.midtgtArrowAngle, opacity);\n    this.drawArrowhead(context, edge, 'mid-source', rs.midX, rs.midY, rs.midsrcArrowAngle, opacity);\n\n    if (!isHaystack) {\n      this.drawArrowhead(context, edge, 'target', rs.arrowEndX, rs.arrowEndY, rs.tgtArrowAngle, opacity);\n    }\n  };\n\n  CRp$8.drawArrowhead = function (context, edge, prefix, x, y, angle, opacity) {\n    if (isNaN(x) || x == null || isNaN(y) || y == null || isNaN(angle) || angle == null) {\n      return;\n    }\n\n    var self = this;\n    var arrowShape = edge.pstyle(prefix + '-arrow-shape').value;\n\n    if (arrowShape === 'none') {\n      return;\n    }\n\n    var arrowClearFill = edge.pstyle(prefix + '-arrow-fill').value === 'hollow' ? 'both' : 'filled';\n    var arrowFill = edge.pstyle(prefix + '-arrow-fill').value;\n    var edgeWidth = edge.pstyle('width').pfValue;\n    var edgeOpacity = edge.pstyle('opacity').value;\n\n    if (opacity === undefined) {\n      opacity = edgeOpacity;\n    }\n\n    var gco = context.globalCompositeOperation;\n\n    if (opacity !== 1 || arrowFill === 'hollow') {\n      // then extra clear is needed\n      context.globalCompositeOperation = 'destination-out';\n      self.colorFillStyle(context, 255, 255, 255, 1);\n      self.colorStrokeStyle(context, 255, 255, 255, 1);\n      self.drawArrowShape(edge, context, arrowClearFill, edgeWidth, arrowShape, x, y, angle);\n      context.globalCompositeOperation = gco;\n    } // otherwise, the opaque arrow clears it for free :)\n\n\n    var color = edge.pstyle(prefix + '-arrow-color').value;\n    self.colorFillStyle(context, color[0], color[1], color[2], opacity);\n    self.colorStrokeStyle(context, color[0], color[1], color[2], opacity);\n    self.drawArrowShape(edge, context, arrowFill, edgeWidth, arrowShape, x, y, angle);\n  };\n\n  CRp$8.drawArrowShape = function (edge, context, fill, edgeWidth, shape, x, y, angle) {\n    var r = this;\n    var usePaths = this.usePaths() && shape !== 'triangle-cross';\n    var pathCacheHit = false;\n    var path;\n    var canvasContext = context;\n    var translation = {\n      x: x,\n      y: y\n    };\n    var scale = edge.pstyle('arrow-scale').value;\n    var size = this.getArrowWidth(edgeWidth, scale);\n    var shapeImpl = r.arrowShapes[shape];\n\n    if (usePaths) {\n      var cache = r.arrowPathCache = r.arrowPathCache || [];\n      var key = hashString(shape);\n      var cachedPath = cache[key];\n\n      if (cachedPath != null) {\n        path = context = cachedPath;\n        pathCacheHit = true;\n      } else {\n        path = context = new Path2D();\n        cache[key] = path;\n      }\n    }\n\n    if (!pathCacheHit) {\n      if (context.beginPath) {\n        context.beginPath();\n      }\n\n      if (usePaths) {\n        // store in the path cache with values easily manipulated later\n        shapeImpl.draw(context, 1, 0, {\n          x: 0,\n          y: 0\n        }, 1);\n      } else {\n        shapeImpl.draw(context, size, angle, translation, edgeWidth);\n      }\n\n      if (context.closePath) {\n        context.closePath();\n      }\n    }\n\n    context = canvasContext;\n\n    if (usePaths) {\n      // set transform to arrow position/orientation\n      context.translate(x, y);\n      context.rotate(angle);\n      context.scale(size, size);\n    }\n\n    if (fill === 'filled' || fill === 'both') {\n      if (usePaths) {\n        context.fill(path);\n      } else {\n        context.fill();\n      }\n    }\n\n    if (fill === 'hollow' || fill === 'both') {\n      context.lineWidth = (shapeImpl.matchEdgeWidth ? edgeWidth : 1) / (usePaths ? size : 1);\n      context.lineJoin = 'miter';\n\n      if (usePaths) {\n        context.stroke(path);\n      } else {\n        context.stroke();\n      }\n    }\n\n    if (usePaths) {\n      // reset transform by applying inverse\n      context.scale(1 / size, 1 / size);\n      context.rotate(-angle);\n      context.translate(-x, -y);\n    }\n  };\n\n  var CRp$7 = {};\n\n  CRp$7.safeDrawImage = function (context, img, ix, iy, iw, ih, x, y, w, h) {\n    // detect problematic cases for old browsers with bad images (cheaper than try-catch)\n    if (iw <= 0 || ih <= 0 || w <= 0 || h <= 0) {\n      return;\n    }\n\n    try {\n      context.drawImage(img, ix, iy, iw, ih, x, y, w, h);\n    } catch (e) {\n      warn(e);\n    }\n  };\n\n  CRp$7.drawInscribedImage = function (context, img, node, index, nodeOpacity) {\n    var r = this;\n    var pos = node.position();\n    var nodeX = pos.x;\n    var nodeY = pos.y;\n    var styleObj = node.cy().style();\n    var getIndexedStyle = styleObj.getIndexedStyle.bind(styleObj);\n    var fit = getIndexedStyle(node, 'background-fit', 'value', index);\n    var repeat = getIndexedStyle(node, 'background-repeat', 'value', index);\n    var nodeW = node.width();\n    var nodeH = node.height();\n    var paddingX2 = node.padding() * 2;\n    var nodeTW = nodeW + (getIndexedStyle(node, 'background-width-relative-to', 'value', index) === 'inner' ? 0 : paddingX2);\n    var nodeTH = nodeH + (getIndexedStyle(node, 'background-height-relative-to', 'value', index) === 'inner' ? 0 : paddingX2);\n    var rs = node._private.rscratch;\n    var clip = getIndexedStyle(node, 'background-clip', 'value', index);\n    var shouldClip = clip === 'node';\n    var imgOpacity = getIndexedStyle(node, 'background-image-opacity', 'value', index) * nodeOpacity;\n    var smooth = getIndexedStyle(node, 'background-image-smoothing', 'value', index);\n    var imgW = img.width || img.cachedW;\n    var imgH = img.height || img.cachedH; // workaround for broken browsers like ie\n\n    if (null == imgW || null == imgH) {\n      document.body.appendChild(img); // eslint-disable-line no-undef\n\n      imgW = img.cachedW = img.width || img.offsetWidth;\n      imgH = img.cachedH = img.height || img.offsetHeight;\n      document.body.removeChild(img); // eslint-disable-line no-undef\n    }\n\n    var w = imgW;\n    var h = imgH;\n\n    if (getIndexedStyle(node, 'background-width', 'value', index) !== 'auto') {\n      if (getIndexedStyle(node, 'background-width', 'units', index) === '%') {\n        w = getIndexedStyle(node, 'background-width', 'pfValue', index) * nodeTW;\n      } else {\n        w = getIndexedStyle(node, 'background-width', 'pfValue', index);\n      }\n    }\n\n    if (getIndexedStyle(node, 'background-height', 'value', index) !== 'auto') {\n      if (getIndexedStyle(node, 'background-height', 'units', index) === '%') {\n        h = getIndexedStyle(node, 'background-height', 'pfValue', index) * nodeTH;\n      } else {\n        h = getIndexedStyle(node, 'background-height', 'pfValue', index);\n      }\n    }\n\n    if (w === 0 || h === 0) {\n      return; // no point in drawing empty image (and chrome is broken in this case)\n    }\n\n    if (fit === 'contain') {\n      var scale = Math.min(nodeTW / w, nodeTH / h);\n      w *= scale;\n      h *= scale;\n    } else if (fit === 'cover') {\n      var scale = Math.max(nodeTW / w, nodeTH / h);\n      w *= scale;\n      h *= scale;\n    }\n\n    var x = nodeX - nodeTW / 2; // left\n\n    var posXUnits = getIndexedStyle(node, 'background-position-x', 'units', index);\n    var posXPfVal = getIndexedStyle(node, 'background-position-x', 'pfValue', index);\n\n    if (posXUnits === '%') {\n      x += (nodeTW - w) * posXPfVal;\n    } else {\n      x += posXPfVal;\n    }\n\n    var offXUnits = getIndexedStyle(node, 'background-offset-x', 'units', index);\n    var offXPfVal = getIndexedStyle(node, 'background-offset-x', 'pfValue', index);\n\n    if (offXUnits === '%') {\n      x += (nodeTW - w) * offXPfVal;\n    } else {\n      x += offXPfVal;\n    }\n\n    var y = nodeY - nodeTH / 2; // top\n\n    var posYUnits = getIndexedStyle(node, 'background-position-y', 'units', index);\n    var posYPfVal = getIndexedStyle(node, 'background-position-y', 'pfValue', index);\n\n    if (posYUnits === '%') {\n      y += (nodeTH - h) * posYPfVal;\n    } else {\n      y += posYPfVal;\n    }\n\n    var offYUnits = getIndexedStyle(node, 'background-offset-y', 'units', index);\n    var offYPfVal = getIndexedStyle(node, 'background-offset-y', 'pfValue', index);\n\n    if (offYUnits === '%') {\n      y += (nodeTH - h) * offYPfVal;\n    } else {\n      y += offYPfVal;\n    }\n\n    if (rs.pathCache) {\n      x -= nodeX;\n      y -= nodeY;\n      nodeX = 0;\n      nodeY = 0;\n    }\n\n    var gAlpha = context.globalAlpha;\n    context.globalAlpha = imgOpacity;\n    var smoothingEnabled = r.getImgSmoothing(context);\n    var isSmoothingSwitched = false;\n\n    if (smooth === 'no' && smoothingEnabled) {\n      r.setImgSmoothing(context, false);\n      isSmoothingSwitched = true;\n    } else if (smooth === 'yes' && !smoothingEnabled) {\n      r.setImgSmoothing(context, true);\n      isSmoothingSwitched = true;\n    }\n\n    if (repeat === 'no-repeat') {\n      if (shouldClip) {\n        context.save();\n\n        if (rs.pathCache) {\n          context.clip(rs.pathCache);\n        } else {\n          r.nodeShapes[r.getNodeShape(node)].draw(context, nodeX, nodeY, nodeTW, nodeTH);\n          context.clip();\n        }\n      }\n\n      r.safeDrawImage(context, img, 0, 0, imgW, imgH, x, y, w, h);\n\n      if (shouldClip) {\n        context.restore();\n      }\n    } else {\n      var pattern = context.createPattern(img, repeat);\n      context.fillStyle = pattern;\n      r.nodeShapes[r.getNodeShape(node)].draw(context, nodeX, nodeY, nodeTW, nodeTH);\n      context.translate(x, y);\n      context.fill();\n      context.translate(-x, -y);\n    }\n\n    context.globalAlpha = gAlpha;\n\n    if (isSmoothingSwitched) {\n      r.setImgSmoothing(context, smoothingEnabled);\n    }\n  };\n\n  var CRp$6 = {};\n\n  CRp$6.eleTextBiggerThanMin = function (ele, scale) {\n    if (!scale) {\n      var zoom = ele.cy().zoom();\n      var pxRatio = this.getPixelRatio();\n      var lvl = Math.ceil(log2(zoom * pxRatio)); // the effective texture level\n\n      scale = Math.pow(2, lvl);\n    }\n\n    var computedSize = ele.pstyle('font-size').pfValue * scale;\n    var minSize = ele.pstyle('min-zoomed-font-size').pfValue;\n\n    if (computedSize < minSize) {\n      return false;\n    }\n\n    return true;\n  };\n\n  CRp$6.drawElementText = function (context, ele, shiftToOriginWithBb, force, prefix) {\n    var useEleOpacity = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n    var r = this;\n\n    if (force == null) {\n      if (useEleOpacity && !r.eleTextBiggerThanMin(ele)) {\n        return;\n      }\n    } else if (force === false) {\n      return;\n    }\n\n    if (ele.isNode()) {\n      var label = ele.pstyle('label');\n\n      if (!label || !label.value) {\n        return;\n      }\n\n      var justification = r.getLabelJustification(ele);\n      context.textAlign = justification;\n      context.textBaseline = 'bottom';\n    } else {\n      var badLine = ele.element()._private.rscratch.badLine;\n\n      var _label = ele.pstyle('label');\n\n      var srcLabel = ele.pstyle('source-label');\n      var tgtLabel = ele.pstyle('target-label');\n\n      if (badLine || (!_label || !_label.value) && (!srcLabel || !srcLabel.value) && (!tgtLabel || !tgtLabel.value)) {\n        return;\n      }\n\n      context.textAlign = 'center';\n      context.textBaseline = 'bottom';\n    }\n\n    var applyRotation = !shiftToOriginWithBb;\n    var bb;\n\n    if (shiftToOriginWithBb) {\n      bb = shiftToOriginWithBb;\n      context.translate(-bb.x1, -bb.y1);\n    }\n\n    if (prefix == null) {\n      r.drawText(context, ele, null, applyRotation, useEleOpacity);\n\n      if (ele.isEdge()) {\n        r.drawText(context, ele, 'source', applyRotation, useEleOpacity);\n        r.drawText(context, ele, 'target', applyRotation, useEleOpacity);\n      }\n    } else {\n      r.drawText(context, ele, prefix, applyRotation, useEleOpacity);\n    }\n\n    if (shiftToOriginWithBb) {\n      context.translate(bb.x1, bb.y1);\n    }\n  };\n\n  CRp$6.getFontCache = function (context) {\n    var cache;\n    this.fontCaches = this.fontCaches || [];\n\n    for (var i = 0; i < this.fontCaches.length; i++) {\n      cache = this.fontCaches[i];\n\n      if (cache.context === context) {\n        return cache;\n      }\n    }\n\n    cache = {\n      context: context\n    };\n    this.fontCaches.push(cache);\n    return cache;\n  }; // set up canvas context with font\n  // returns transformed text string\n\n\n  CRp$6.setupTextStyle = function (context, ele) {\n    var useEleOpacity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    // Font style\n    var labelStyle = ele.pstyle('font-style').strValue;\n    var labelSize = ele.pstyle('font-size').pfValue + 'px';\n    var labelFamily = ele.pstyle('font-family').strValue;\n    var labelWeight = ele.pstyle('font-weight').strValue;\n    var opacity = useEleOpacity ? ele.effectiveOpacity() * ele.pstyle('text-opacity').value : 1;\n    var outlineOpacity = ele.pstyle('text-outline-opacity').value * opacity;\n    var color = ele.pstyle('color').value;\n    var outlineColor = ele.pstyle('text-outline-color').value;\n    context.font = labelStyle + ' ' + labelWeight + ' ' + labelSize + ' ' + labelFamily;\n    context.lineJoin = 'round'; // so text outlines aren't jagged\n\n    this.colorFillStyle(context, color[0], color[1], color[2], opacity);\n    this.colorStrokeStyle(context, outlineColor[0], outlineColor[1], outlineColor[2], outlineOpacity);\n  }; // TODO ensure re-used\n\n\n  function roundRect(ctx, x, y, width, height) {\n    var radius = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 5;\n    ctx.beginPath();\n    ctx.moveTo(x + radius, y);\n    ctx.lineTo(x + width - radius, y);\n    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);\n    ctx.lineTo(x + width, y + height - radius);\n    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n    ctx.lineTo(x + radius, y + height);\n    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);\n    ctx.lineTo(x, y + radius);\n    ctx.quadraticCurveTo(x, y, x + radius, y);\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  CRp$6.getTextAngle = function (ele, prefix) {\n    var theta;\n    var _p = ele._private;\n    var rscratch = _p.rscratch;\n    var pdash = prefix ? prefix + '-' : '';\n    var rotation = ele.pstyle(pdash + 'text-rotation');\n    var textAngle = getPrefixedProperty(rscratch, 'labelAngle', prefix);\n\n    if (rotation.strValue === 'autorotate') {\n      theta = ele.isEdge() ? textAngle : 0;\n    } else if (rotation.strValue === 'none') {\n      theta = 0;\n    } else {\n      theta = rotation.pfValue;\n    }\n\n    return theta;\n  };\n\n  CRp$6.drawText = function (context, ele, prefix) {\n    var applyRotation = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    var useEleOpacity = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    var _p = ele._private;\n    var rscratch = _p.rscratch;\n    var parentOpacity = useEleOpacity ? ele.effectiveOpacity() : 1;\n\n    if (useEleOpacity && (parentOpacity === 0 || ele.pstyle('text-opacity').value === 0)) {\n      return;\n    } // use 'main' as an alias for the main label (i.e. null prefix)\n\n\n    if (prefix === 'main') {\n      prefix = null;\n    }\n\n    var textX = getPrefixedProperty(rscratch, 'labelX', prefix);\n    var textY = getPrefixedProperty(rscratch, 'labelY', prefix);\n    var orgTextX, orgTextY; // used for rotation\n\n    var text = this.getLabelText(ele, prefix);\n\n    if (text != null && text !== '' && !isNaN(textX) && !isNaN(textY)) {\n      this.setupTextStyle(context, ele, useEleOpacity);\n      var pdash = prefix ? prefix + '-' : '';\n      var textW = getPrefixedProperty(rscratch, 'labelWidth', prefix);\n      var textH = getPrefixedProperty(rscratch, 'labelHeight', prefix);\n      var marginX = ele.pstyle(pdash + 'text-margin-x').pfValue;\n      var marginY = ele.pstyle(pdash + 'text-margin-y').pfValue;\n      var isEdge = ele.isEdge();\n      var halign = ele.pstyle('text-halign').value;\n      var valign = ele.pstyle('text-valign').value;\n\n      if (isEdge) {\n        halign = 'center';\n        valign = 'center';\n      }\n\n      textX += marginX;\n      textY += marginY;\n      var theta;\n\n      if (!applyRotation) {\n        theta = 0;\n      } else {\n        theta = this.getTextAngle(ele, prefix);\n      }\n\n      if (theta !== 0) {\n        orgTextX = textX;\n        orgTextY = textY;\n        context.translate(orgTextX, orgTextY);\n        context.rotate(theta);\n        textX = 0;\n        textY = 0;\n      }\n\n      switch (valign) {\n        case 'top':\n          break;\n\n        case 'center':\n          textY += textH / 2;\n          break;\n\n        case 'bottom':\n          textY += textH;\n          break;\n      }\n\n      var backgroundOpacity = ele.pstyle('text-background-opacity').value;\n      var borderOpacity = ele.pstyle('text-border-opacity').value;\n      var textBorderWidth = ele.pstyle('text-border-width').pfValue;\n      var backgroundPadding = ele.pstyle('text-background-padding').pfValue;\n\n      if (backgroundOpacity > 0 || textBorderWidth > 0 && borderOpacity > 0) {\n        var bgX = textX - backgroundPadding;\n\n        switch (halign) {\n          case 'left':\n            bgX -= textW;\n            break;\n\n          case 'center':\n            bgX -= textW / 2;\n            break;\n        }\n\n        var bgY = textY - textH - backgroundPadding;\n        var bgW = textW + 2 * backgroundPadding;\n        var bgH = textH + 2 * backgroundPadding;\n\n        if (backgroundOpacity > 0) {\n          var textFill = context.fillStyle;\n          var textBackgroundColor = ele.pstyle('text-background-color').value;\n          context.fillStyle = 'rgba(' + textBackgroundColor[0] + ',' + textBackgroundColor[1] + ',' + textBackgroundColor[2] + ',' + backgroundOpacity * parentOpacity + ')';\n          var styleShape = ele.pstyle('text-background-shape').strValue;\n\n          if (styleShape.indexOf('round') === 0) {\n            roundRect(context, bgX, bgY, bgW, bgH, 2);\n          } else {\n            context.fillRect(bgX, bgY, bgW, bgH);\n          }\n\n          context.fillStyle = textFill;\n        }\n\n        if (textBorderWidth > 0 && borderOpacity > 0) {\n          var textStroke = context.strokeStyle;\n          var textLineWidth = context.lineWidth;\n          var textBorderColor = ele.pstyle('text-border-color').value;\n          var textBorderStyle = ele.pstyle('text-border-style').value;\n          context.strokeStyle = 'rgba(' + textBorderColor[0] + ',' + textBorderColor[1] + ',' + textBorderColor[2] + ',' + borderOpacity * parentOpacity + ')';\n          context.lineWidth = textBorderWidth;\n\n          if (context.setLineDash) {\n            // for very outofdate browsers\n            switch (textBorderStyle) {\n              case 'dotted':\n                context.setLineDash([1, 1]);\n                break;\n\n              case 'dashed':\n                context.setLineDash([4, 2]);\n                break;\n\n              case 'double':\n                context.lineWidth = textBorderWidth / 4; // 50% reserved for white between the two borders\n\n                context.setLineDash([]);\n                break;\n\n              case 'solid':\n                context.setLineDash([]);\n                break;\n            }\n          }\n\n          context.strokeRect(bgX, bgY, bgW, bgH);\n\n          if (textBorderStyle === 'double') {\n            var whiteWidth = textBorderWidth / 2;\n            context.strokeRect(bgX + whiteWidth, bgY + whiteWidth, bgW - whiteWidth * 2, bgH - whiteWidth * 2);\n          }\n\n          if (context.setLineDash) {\n            // for very outofdate browsers\n            context.setLineDash([]);\n          }\n\n          context.lineWidth = textLineWidth;\n          context.strokeStyle = textStroke;\n        }\n      }\n\n      var lineWidth = 2 * ele.pstyle('text-outline-width').pfValue; // *2 b/c the stroke is drawn centred on the middle\n\n      if (lineWidth > 0) {\n        context.lineWidth = lineWidth;\n      }\n\n      if (ele.pstyle('text-wrap').value === 'wrap') {\n        var lines = getPrefixedProperty(rscratch, 'labelWrapCachedLines', prefix);\n        var lineHeight = getPrefixedProperty(rscratch, 'labelLineHeight', prefix);\n        var halfTextW = textW / 2;\n        var justification = this.getLabelJustification(ele);\n\n        if (justification === 'auto') ; else if (halign === 'left') {\n          // auto justification : right\n          if (justification === 'left') {\n            textX += -textW;\n          } else if (justification === 'center') {\n            textX += -halfTextW;\n          } // else same as auto\n\n        } else if (halign === 'center') {\n          // auto justfication : center\n          if (justification === 'left') {\n            textX += -halfTextW;\n          } else if (justification === 'right') {\n            textX += halfTextW;\n          } // else same as auto\n\n        } else if (halign === 'right') {\n          // auto justification : left\n          if (justification === 'center') {\n            textX += halfTextW;\n          } else if (justification === 'right') {\n            textX += textW;\n          } // else same as auto\n\n        }\n\n        switch (valign) {\n          case 'top':\n            textY -= (lines.length - 1) * lineHeight;\n            break;\n\n          case 'center':\n          case 'bottom':\n            textY -= (lines.length - 1) * lineHeight;\n            break;\n        }\n\n        for (var l = 0; l < lines.length; l++) {\n          if (lineWidth > 0) {\n            context.strokeText(lines[l], textX, textY);\n          }\n\n          context.fillText(lines[l], textX, textY);\n          textY += lineHeight;\n        }\n      } else {\n        if (lineWidth > 0) {\n          context.strokeText(text, textX, textY);\n        }\n\n        context.fillText(text, textX, textY);\n      }\n\n      if (theta !== 0) {\n        context.rotate(-theta);\n        context.translate(-orgTextX, -orgTextY);\n      }\n    }\n  };\n\n  /* global Path2D */\n  var CRp$5 = {};\n\n  CRp$5.drawNode = function (context, node, shiftToOriginWithBb) {\n    var drawLabel = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    var shouldDrawOverlay = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    var shouldDrawOpacity = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n    var r = this;\n    var nodeWidth, nodeHeight;\n    var _p = node._private;\n    var rs = _p.rscratch;\n    var pos = node.position();\n\n    if (!number$1(pos.x) || !number$1(pos.y)) {\n      return; // can't draw node with undefined position\n    }\n\n    if (shouldDrawOpacity && !node.visible()) {\n      return;\n    }\n\n    var eleOpacity = shouldDrawOpacity ? node.effectiveOpacity() : 1;\n    var usePaths = r.usePaths();\n    var path;\n    var pathCacheHit = false;\n    var padding = node.padding();\n    nodeWidth = node.width() + 2 * padding;\n    nodeHeight = node.height() + 2 * padding; //\n    // setup shift\n\n    var bb;\n\n    if (shiftToOriginWithBb) {\n      bb = shiftToOriginWithBb;\n      context.translate(-bb.x1, -bb.y1);\n    } //\n    // load bg image\n\n\n    var bgImgProp = node.pstyle('background-image');\n    var urls = bgImgProp.value;\n    var urlDefined = new Array(urls.length);\n    var image = new Array(urls.length);\n    var numImages = 0;\n\n    for (var i = 0; i < urls.length; i++) {\n      var url = urls[i];\n      var defd = urlDefined[i] = url != null && url !== 'none';\n\n      if (defd) {\n        var bgImgCrossOrigin = node.cy().style().getIndexedStyle(node, 'background-image-crossorigin', 'value', i);\n        numImages++; // get image, and if not loaded then ask to redraw when later loaded\n\n        image[i] = r.getCachedImage(url, bgImgCrossOrigin, function () {\n          _p.backgroundTimestamp = Date.now();\n          node.emitAndNotify('background');\n        });\n      }\n    } //\n    // setup styles\n\n\n    var darkness = node.pstyle('background-blacken').value;\n    var borderWidth = node.pstyle('border-width').pfValue;\n    var bgOpacity = node.pstyle('background-opacity').value * eleOpacity;\n    var borderColor = node.pstyle('border-color').value;\n    var borderStyle = node.pstyle('border-style').value;\n    var borderOpacity = node.pstyle('border-opacity').value * eleOpacity;\n    context.lineJoin = 'miter'; // so borders are square with the node shape\n\n    var setupShapeColor = function setupShapeColor() {\n      var bgOpy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : bgOpacity;\n      r.eleFillStyle(context, node, bgOpy);\n    };\n\n    var setupBorderColor = function setupBorderColor() {\n      var bdrOpy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : borderOpacity;\n      r.colorStrokeStyle(context, borderColor[0], borderColor[1], borderColor[2], bdrOpy);\n    }; //\n    // setup shape\n\n\n    var styleShape = node.pstyle('shape').strValue;\n    var shapePts = node.pstyle('shape-polygon-points').pfValue;\n\n    if (usePaths) {\n      context.translate(pos.x, pos.y);\n      var pathCache = r.nodePathCache = r.nodePathCache || [];\n      var key = hashStrings(styleShape === 'polygon' ? styleShape + ',' + shapePts.join(',') : styleShape, '' + nodeHeight, '' + nodeWidth);\n      var cachedPath = pathCache[key];\n\n      if (cachedPath != null) {\n        path = cachedPath;\n        pathCacheHit = true;\n        rs.pathCache = path;\n      } else {\n        path = new Path2D();\n        pathCache[key] = rs.pathCache = path;\n      }\n    }\n\n    var drawShape = function drawShape() {\n      if (!pathCacheHit) {\n        var npos = pos;\n\n        if (usePaths) {\n          npos = {\n            x: 0,\n            y: 0\n          };\n        }\n\n        r.nodeShapes[r.getNodeShape(node)].draw(path || context, npos.x, npos.y, nodeWidth, nodeHeight);\n      }\n\n      if (usePaths) {\n        context.fill(path);\n      } else {\n        context.fill();\n      }\n    };\n\n    var drawImages = function drawImages() {\n      var nodeOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : eleOpacity;\n      var inside = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var prevBging = _p.backgrounding;\n      var totalCompleted = 0;\n\n      for (var _i = 0; _i < image.length; _i++) {\n        var bgContainment = node.cy().style().getIndexedStyle(node, 'background-image-containment', 'value', _i);\n\n        if (inside && bgContainment === 'over' || !inside && bgContainment === 'inside') {\n          totalCompleted++;\n          continue;\n        }\n\n        if (urlDefined[_i] && image[_i].complete && !image[_i].error) {\n          totalCompleted++;\n          r.drawInscribedImage(context, image[_i], node, _i, nodeOpacity);\n        }\n      }\n\n      _p.backgrounding = !(totalCompleted === numImages);\n\n      if (prevBging !== _p.backgrounding) {\n        // update style b/c :backgrounding state changed\n        node.updateStyle(false);\n      }\n    };\n\n    var drawPie = function drawPie() {\n      var redrawShape = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var pieOpacity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : eleOpacity;\n\n      if (r.hasPie(node)) {\n        r.drawPie(context, node, pieOpacity); // redraw/restore path if steps after pie need it\n\n        if (redrawShape) {\n          if (!usePaths) {\n            r.nodeShapes[r.getNodeShape(node)].draw(context, pos.x, pos.y, nodeWidth, nodeHeight);\n          }\n        }\n      }\n    };\n\n    var darken = function darken() {\n      var darkenOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : eleOpacity;\n      var opacity = (darkness > 0 ? darkness : -darkness) * darkenOpacity;\n      var c = darkness > 0 ? 0 : 255;\n\n      if (darkness !== 0) {\n        r.colorFillStyle(context, c, c, c, opacity);\n\n        if (usePaths) {\n          context.fill(path);\n        } else {\n          context.fill();\n        }\n      }\n    };\n\n    var drawBorder = function drawBorder() {\n      if (borderWidth > 0) {\n        context.lineWidth = borderWidth;\n        context.lineCap = 'butt';\n\n        if (context.setLineDash) {\n          // for very outofdate browsers\n          switch (borderStyle) {\n            case 'dotted':\n              context.setLineDash([1, 1]);\n              break;\n\n            case 'dashed':\n              context.setLineDash([4, 2]);\n              break;\n\n            case 'solid':\n            case 'double':\n              context.setLineDash([]);\n              break;\n          }\n        }\n\n        if (usePaths) {\n          context.stroke(path);\n        } else {\n          context.stroke();\n        }\n\n        if (borderStyle === 'double') {\n          context.lineWidth = borderWidth / 3;\n          var gco = context.globalCompositeOperation;\n          context.globalCompositeOperation = 'destination-out';\n\n          if (usePaths) {\n            context.stroke(path);\n          } else {\n            context.stroke();\n          }\n\n          context.globalCompositeOperation = gco;\n        } // reset in case we changed the border style\n\n\n        if (context.setLineDash) {\n          // for very outofdate browsers\n          context.setLineDash([]);\n        }\n      }\n    };\n\n    var drawOverlay = function drawOverlay() {\n      if (shouldDrawOverlay) {\n        r.drawNodeOverlay(context, node, pos, nodeWidth, nodeHeight);\n      }\n    };\n\n    var drawUnderlay = function drawUnderlay() {\n      if (shouldDrawOverlay) {\n        r.drawNodeUnderlay(context, node, pos, nodeWidth, nodeHeight);\n      }\n    };\n\n    var drawText = function drawText() {\n      r.drawElementText(context, node, null, drawLabel);\n    };\n\n    var ghost = node.pstyle('ghost').value === 'yes';\n\n    if (ghost) {\n      var gx = node.pstyle('ghost-offset-x').pfValue;\n      var gy = node.pstyle('ghost-offset-y').pfValue;\n      var ghostOpacity = node.pstyle('ghost-opacity').value;\n      var effGhostOpacity = ghostOpacity * eleOpacity;\n      context.translate(gx, gy);\n      setupShapeColor(ghostOpacity * bgOpacity);\n      drawShape();\n      drawImages(effGhostOpacity, true);\n      setupBorderColor(ghostOpacity * borderOpacity);\n      drawBorder();\n      drawPie(darkness !== 0 || borderWidth !== 0);\n      drawImages(effGhostOpacity, false);\n      darken(effGhostOpacity);\n      context.translate(-gx, -gy);\n    }\n\n    if (usePaths) {\n      context.translate(-pos.x, -pos.y);\n    }\n\n    drawUnderlay();\n\n    if (usePaths) {\n      context.translate(pos.x, pos.y);\n    }\n\n    setupShapeColor();\n    drawShape();\n    drawImages(eleOpacity, true);\n    setupBorderColor();\n    drawBorder();\n    drawPie(darkness !== 0 || borderWidth !== 0);\n    drawImages(eleOpacity, false);\n    darken();\n\n    if (usePaths) {\n      context.translate(-pos.x, -pos.y);\n    }\n\n    drawText();\n    drawOverlay(); //\n    // clean up shift\n\n    if (shiftToOriginWithBb) {\n      context.translate(bb.x1, bb.y1);\n    }\n  };\n\n  var drawNodeOverlayUnderlay = function drawNodeOverlayUnderlay(overlayOrUnderlay) {\n    if (!['overlay', 'underlay'].includes(overlayOrUnderlay)) {\n      throw new Error('Invalid state');\n    }\n\n    return function (context, node, pos, nodeWidth, nodeHeight) {\n      var r = this;\n\n      if (!node.visible()) {\n        return;\n      }\n\n      var padding = node.pstyle(\"\".concat(overlayOrUnderlay, \"-padding\")).pfValue;\n      var opacity = node.pstyle(\"\".concat(overlayOrUnderlay, \"-opacity\")).value;\n      var color = node.pstyle(\"\".concat(overlayOrUnderlay, \"-color\")).value;\n      var shape = node.pstyle(\"\".concat(overlayOrUnderlay, \"-shape\")).value;\n\n      if (opacity > 0) {\n        pos = pos || node.position();\n\n        if (nodeWidth == null || nodeHeight == null) {\n          var _padding = node.padding();\n\n          nodeWidth = node.width() + 2 * _padding;\n          nodeHeight = node.height() + 2 * _padding;\n        }\n\n        r.colorFillStyle(context, color[0], color[1], color[2], opacity);\n        r.nodeShapes[shape].draw(context, pos.x, pos.y, nodeWidth + padding * 2, nodeHeight + padding * 2);\n        context.fill();\n      }\n    };\n  };\n\n  CRp$5.drawNodeOverlay = drawNodeOverlayUnderlay('overlay');\n  CRp$5.drawNodeUnderlay = drawNodeOverlayUnderlay('underlay'); // does the node have at least one pie piece?\n\n  CRp$5.hasPie = function (node) {\n    node = node[0]; // ensure ele ref\n\n    return node._private.hasPie;\n  };\n\n  CRp$5.drawPie = function (context, node, nodeOpacity, pos) {\n    node = node[0]; // ensure ele ref\n\n    pos = pos || node.position();\n    var cyStyle = node.cy().style();\n    var pieSize = node.pstyle('pie-size');\n    var x = pos.x;\n    var y = pos.y;\n    var nodeW = node.width();\n    var nodeH = node.height();\n    var radius = Math.min(nodeW, nodeH) / 2; // must fit in node\n\n    var lastPercent = 0; // what % to continue drawing pie slices from on [0, 1]\n\n    var usePaths = this.usePaths();\n\n    if (usePaths) {\n      x = 0;\n      y = 0;\n    }\n\n    if (pieSize.units === '%') {\n      radius = radius * pieSize.pfValue;\n    } else if (pieSize.pfValue !== undefined) {\n      radius = pieSize.pfValue / 2;\n    }\n\n    for (var i = 1; i <= cyStyle.pieBackgroundN; i++) {\n      // 1..N\n      var size = node.pstyle('pie-' + i + '-background-size').value;\n      var color = node.pstyle('pie-' + i + '-background-color').value;\n      var opacity = node.pstyle('pie-' + i + '-background-opacity').value * nodeOpacity;\n      var percent = size / 100; // map integer range [0, 100] to [0, 1]\n      // percent can't push beyond 1\n\n      if (percent + lastPercent > 1) {\n        percent = 1 - lastPercent;\n      }\n\n      var angleStart = 1.5 * Math.PI + 2 * Math.PI * lastPercent; // start at 12 o'clock and go clockwise\n\n      var angleDelta = 2 * Math.PI * percent;\n      var angleEnd = angleStart + angleDelta; // ignore if\n      // - zero size\n      // - we're already beyond the full circle\n      // - adding the current slice would go beyond the full circle\n\n      if (size === 0 || lastPercent >= 1 || lastPercent + percent > 1) {\n        continue;\n      }\n\n      context.beginPath();\n      context.moveTo(x, y);\n      context.arc(x, y, radius, angleStart, angleEnd);\n      context.closePath();\n      this.colorFillStyle(context, color[0], color[1], color[2], opacity);\n      context.fill();\n      lastPercent += percent;\n    }\n  };\n\n  var CRp$4 = {};\n  var motionBlurDelay = 100; // var isFirefox = typeof InstallTrigger !== 'undefined';\n\n  CRp$4.getPixelRatio = function () {\n    var context = this.data.contexts[0];\n\n    if (this.forcedPixelRatio != null) {\n      return this.forcedPixelRatio;\n    }\n\n    var backingStore = context.backingStorePixelRatio || context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;\n    return (window.devicePixelRatio || 1) / backingStore; // eslint-disable-line no-undef\n  };\n\n  CRp$4.paintCache = function (context) {\n    var caches = this.paintCaches = this.paintCaches || [];\n    var needToCreateCache = true;\n    var cache;\n\n    for (var i = 0; i < caches.length; i++) {\n      cache = caches[i];\n\n      if (cache.context === context) {\n        needToCreateCache = false;\n        break;\n      }\n    }\n\n    if (needToCreateCache) {\n      cache = {\n        context: context\n      };\n      caches.push(cache);\n    }\n\n    return cache;\n  };\n\n  CRp$4.createGradientStyleFor = function (context, shapeStyleName, ele, fill, opacity) {\n    var gradientStyle;\n    var usePaths = this.usePaths();\n    var colors = ele.pstyle(shapeStyleName + '-gradient-stop-colors').value,\n        positions = ele.pstyle(shapeStyleName + '-gradient-stop-positions').pfValue;\n\n    if (fill === 'radial-gradient') {\n      if (ele.isEdge()) {\n        var start = ele.sourceEndpoint(),\n            end = ele.targetEndpoint(),\n            mid = ele.midpoint();\n        var d1 = dist(start, mid);\n        var d2 = dist(end, mid);\n        gradientStyle = context.createRadialGradient(mid.x, mid.y, 0, mid.x, mid.y, Math.max(d1, d2));\n      } else {\n        var pos = usePaths ? {\n          x: 0,\n          y: 0\n        } : ele.position(),\n            width = ele.paddedWidth(),\n            height = ele.paddedHeight();\n        gradientStyle = context.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, Math.max(width, height));\n      }\n    } else {\n      if (ele.isEdge()) {\n        var _start = ele.sourceEndpoint(),\n            _end = ele.targetEndpoint();\n\n        gradientStyle = context.createLinearGradient(_start.x, _start.y, _end.x, _end.y);\n      } else {\n        var _pos = usePaths ? {\n          x: 0,\n          y: 0\n        } : ele.position(),\n            _width = ele.paddedWidth(),\n            _height = ele.paddedHeight(),\n            halfWidth = _width / 2,\n            halfHeight = _height / 2;\n\n        var direction = ele.pstyle('background-gradient-direction').value;\n\n        switch (direction) {\n          case 'to-bottom':\n            gradientStyle = context.createLinearGradient(_pos.x, _pos.y - halfHeight, _pos.x, _pos.y + halfHeight);\n            break;\n\n          case 'to-top':\n            gradientStyle = context.createLinearGradient(_pos.x, _pos.y + halfHeight, _pos.x, _pos.y - halfHeight);\n            break;\n\n          case 'to-left':\n            gradientStyle = context.createLinearGradient(_pos.x + halfWidth, _pos.y, _pos.x - halfWidth, _pos.y);\n            break;\n\n          case 'to-right':\n            gradientStyle = context.createLinearGradient(_pos.x - halfWidth, _pos.y, _pos.x + halfWidth, _pos.y);\n            break;\n\n          case 'to-bottom-right':\n          case 'to-right-bottom':\n            gradientStyle = context.createLinearGradient(_pos.x - halfWidth, _pos.y - halfHeight, _pos.x + halfWidth, _pos.y + halfHeight);\n            break;\n\n          case 'to-top-right':\n          case 'to-right-top':\n            gradientStyle = context.createLinearGradient(_pos.x - halfWidth, _pos.y + halfHeight, _pos.x + halfWidth, _pos.y - halfHeight);\n            break;\n\n          case 'to-bottom-left':\n          case 'to-left-bottom':\n            gradientStyle = context.createLinearGradient(_pos.x + halfWidth, _pos.y - halfHeight, _pos.x - halfWidth, _pos.y + halfHeight);\n            break;\n\n          case 'to-top-left':\n          case 'to-left-top':\n            gradientStyle = context.createLinearGradient(_pos.x + halfWidth, _pos.y + halfHeight, _pos.x - halfWidth, _pos.y - halfHeight);\n            break;\n        }\n      }\n    }\n\n    if (!gradientStyle) return null; // invalid gradient style\n\n    var hasPositions = positions.length === colors.length;\n    var length = colors.length;\n\n    for (var i = 0; i < length; i++) {\n      gradientStyle.addColorStop(hasPositions ? positions[i] : i / (length - 1), 'rgba(' + colors[i][0] + ',' + colors[i][1] + ',' + colors[i][2] + ',' + opacity + ')');\n    }\n\n    return gradientStyle;\n  };\n\n  CRp$4.gradientFillStyle = function (context, ele, fill, opacity) {\n    var gradientStyle = this.createGradientStyleFor(context, 'background', ele, fill, opacity);\n    if (!gradientStyle) return null; // error\n\n    context.fillStyle = gradientStyle;\n  };\n\n  CRp$4.colorFillStyle = function (context, r, g, b, a) {\n    context.fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')'; // turn off for now, seems context does its own caching\n    // var cache = this.paintCache(context);\n    // var fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n    // if( cache.fillStyle !== fillStyle ){\n    //   context.fillStyle = cache.fillStyle = fillStyle;\n    // }\n  };\n\n  CRp$4.eleFillStyle = function (context, ele, opacity) {\n    var backgroundFill = ele.pstyle('background-fill').value;\n\n    if (backgroundFill === 'linear-gradient' || backgroundFill === 'radial-gradient') {\n      this.gradientFillStyle(context, ele, backgroundFill, opacity);\n    } else {\n      var backgroundColor = ele.pstyle('background-color').value;\n      this.colorFillStyle(context, backgroundColor[0], backgroundColor[1], backgroundColor[2], opacity);\n    }\n  };\n\n  CRp$4.gradientStrokeStyle = function (context, ele, fill, opacity) {\n    var gradientStyle = this.createGradientStyleFor(context, 'line', ele, fill, opacity);\n    if (!gradientStyle) return null; // error\n\n    context.strokeStyle = gradientStyle;\n  };\n\n  CRp$4.colorStrokeStyle = function (context, r, g, b, a) {\n    context.strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')'; // turn off for now, seems context does its own caching\n    // var cache = this.paintCache(context);\n    // var strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n    // if( cache.strokeStyle !== strokeStyle ){\n    //   context.strokeStyle = cache.strokeStyle = strokeStyle;\n    // }\n  };\n\n  CRp$4.eleStrokeStyle = function (context, ele, opacity) {\n    var lineFill = ele.pstyle('line-fill').value;\n\n    if (lineFill === 'linear-gradient' || lineFill === 'radial-gradient') {\n      this.gradientStrokeStyle(context, ele, lineFill, opacity);\n    } else {\n      var lineColor = ele.pstyle('line-color').value;\n      this.colorStrokeStyle(context, lineColor[0], lineColor[1], lineColor[2], opacity);\n    }\n  }; // Resize canvas\n\n\n  CRp$4.matchCanvasSize = function (container) {\n    var r = this;\n    var data = r.data;\n    var bb = r.findContainerClientCoords();\n    var width = bb[2];\n    var height = bb[3];\n    var pixelRatio = r.getPixelRatio();\n    var mbPxRatio = r.motionBlurPxRatio;\n\n    if (container === r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_NODE] || container === r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_DRAG]) {\n      pixelRatio = mbPxRatio;\n    }\n\n    var canvasWidth = width * pixelRatio;\n    var canvasHeight = height * pixelRatio;\n    var canvas;\n\n    if (canvasWidth === r.canvasWidth && canvasHeight === r.canvasHeight) {\n      return; // save cycles if same\n    }\n\n    r.fontCaches = null; // resizing resets the style\n\n    var canvasContainer = data.canvasContainer;\n    canvasContainer.style.width = width + 'px';\n    canvasContainer.style.height = height + 'px';\n\n    for (var i = 0; i < r.CANVAS_LAYERS; i++) {\n      canvas = data.canvases[i];\n      canvas.width = canvasWidth;\n      canvas.height = canvasHeight;\n      canvas.style.width = width + 'px';\n      canvas.style.height = height + 'px';\n    }\n\n    for (var i = 0; i < r.BUFFER_COUNT; i++) {\n      canvas = data.bufferCanvases[i];\n      canvas.width = canvasWidth;\n      canvas.height = canvasHeight;\n      canvas.style.width = width + 'px';\n      canvas.style.height = height + 'px';\n    }\n\n    r.textureMult = 1;\n\n    if (pixelRatio <= 1) {\n      canvas = data.bufferCanvases[r.TEXTURE_BUFFER];\n      r.textureMult = 2;\n      canvas.width = canvasWidth * r.textureMult;\n      canvas.height = canvasHeight * r.textureMult;\n    }\n\n    r.canvasWidth = canvasWidth;\n    r.canvasHeight = canvasHeight;\n  };\n\n  CRp$4.renderTo = function (cxt, zoom, pan, pxRatio) {\n    this.render({\n      forcedContext: cxt,\n      forcedZoom: zoom,\n      forcedPan: pan,\n      drawAllLayers: true,\n      forcedPxRatio: pxRatio\n    });\n  };\n\n  CRp$4.render = function (options) {\n    options = options || staticEmptyObject();\n    var forcedContext = options.forcedContext;\n    var drawAllLayers = options.drawAllLayers;\n    var drawOnlyNodeLayer = options.drawOnlyNodeLayer;\n    var forcedZoom = options.forcedZoom;\n    var forcedPan = options.forcedPan;\n    var r = this;\n    var pixelRatio = options.forcedPxRatio === undefined ? this.getPixelRatio() : options.forcedPxRatio;\n    var cy = r.cy;\n    var data = r.data;\n    var needDraw = data.canvasNeedsRedraw;\n    var textureDraw = r.textureOnViewport && !forcedContext && (r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming);\n    var motionBlur = options.motionBlur !== undefined ? options.motionBlur : r.motionBlur;\n    var mbPxRatio = r.motionBlurPxRatio;\n    var hasCompoundNodes = cy.hasCompoundNodes();\n    var inNodeDragGesture = r.hoverData.draggingEles;\n    var inBoxSelection = r.hoverData.selecting || r.touchData.selecting ? true : false;\n    motionBlur = motionBlur && !forcedContext && r.motionBlurEnabled && !inBoxSelection;\n    var motionBlurFadeEffect = motionBlur;\n\n    if (!forcedContext) {\n      if (r.prevPxRatio !== pixelRatio) {\n        r.invalidateContainerClientCoordsCache();\n        r.matchCanvasSize(r.container);\n        r.redrawHint('eles', true);\n        r.redrawHint('drag', true);\n      }\n\n      r.prevPxRatio = pixelRatio;\n    }\n\n    if (!forcedContext && r.motionBlurTimeout) {\n      clearTimeout(r.motionBlurTimeout);\n    }\n\n    if (motionBlur) {\n      if (r.mbFrames == null) {\n        r.mbFrames = 0;\n      }\n\n      r.mbFrames++;\n\n      if (r.mbFrames < 3) {\n        // need several frames before even high quality motionblur\n        motionBlurFadeEffect = false;\n      } // go to lower quality blurry frames when several m/b frames have been rendered (avoids flashing)\n\n\n      if (r.mbFrames > r.minMbLowQualFrames) {\n        //r.fullQualityMb = false;\n        r.motionBlurPxRatio = r.mbPxRBlurry;\n      }\n    }\n\n    if (r.clearingMotionBlur) {\n      r.motionBlurPxRatio = 1;\n    } // b/c drawToContext() may be async w.r.t. redraw(), keep track of last texture frame\n    // because a rogue async texture frame would clear needDraw\n\n\n    if (r.textureDrawLastFrame && !textureDraw) {\n      needDraw[r.NODE] = true;\n      needDraw[r.SELECT_BOX] = true;\n    }\n\n    var style = cy.style();\n    var zoom = cy.zoom();\n    var effectiveZoom = forcedZoom !== undefined ? forcedZoom : zoom;\n    var pan = cy.pan();\n    var effectivePan = {\n      x: pan.x,\n      y: pan.y\n    };\n    var vp = {\n      zoom: zoom,\n      pan: {\n        x: pan.x,\n        y: pan.y\n      }\n    };\n    var prevVp = r.prevViewport;\n    var viewportIsDiff = prevVp === undefined || vp.zoom !== prevVp.zoom || vp.pan.x !== prevVp.pan.x || vp.pan.y !== prevVp.pan.y; // we want the low quality motionblur only when the viewport is being manipulated etc (where it's not noticed)\n\n    if (!viewportIsDiff && !(inNodeDragGesture && !hasCompoundNodes)) {\n      r.motionBlurPxRatio = 1;\n    }\n\n    if (forcedPan) {\n      effectivePan = forcedPan;\n    } // apply pixel ratio\n\n\n    effectiveZoom *= pixelRatio;\n    effectivePan.x *= pixelRatio;\n    effectivePan.y *= pixelRatio;\n    var eles = r.getCachedZSortedEles();\n\n    function mbclear(context, x, y, w, h) {\n      var gco = context.globalCompositeOperation;\n      context.globalCompositeOperation = 'destination-out';\n      r.colorFillStyle(context, 255, 255, 255, r.motionBlurTransparency);\n      context.fillRect(x, y, w, h);\n      context.globalCompositeOperation = gco;\n    }\n\n    function setContextTransform(context, clear) {\n      var ePan, eZoom, w, h;\n\n      if (!r.clearingMotionBlur && (context === data.bufferContexts[r.MOTIONBLUR_BUFFER_NODE] || context === data.bufferContexts[r.MOTIONBLUR_BUFFER_DRAG])) {\n        ePan = {\n          x: pan.x * mbPxRatio,\n          y: pan.y * mbPxRatio\n        };\n        eZoom = zoom * mbPxRatio;\n        w = r.canvasWidth * mbPxRatio;\n        h = r.canvasHeight * mbPxRatio;\n      } else {\n        ePan = effectivePan;\n        eZoom = effectiveZoom;\n        w = r.canvasWidth;\n        h = r.canvasHeight;\n      }\n\n      context.setTransform(1, 0, 0, 1, 0, 0);\n\n      if (clear === 'motionBlur') {\n        mbclear(context, 0, 0, w, h);\n      } else if (!forcedContext && (clear === undefined || clear)) {\n        context.clearRect(0, 0, w, h);\n      }\n\n      if (!drawAllLayers) {\n        context.translate(ePan.x, ePan.y);\n        context.scale(eZoom, eZoom);\n      }\n\n      if (forcedPan) {\n        context.translate(forcedPan.x, forcedPan.y);\n      }\n\n      if (forcedZoom) {\n        context.scale(forcedZoom, forcedZoom);\n      }\n    }\n\n    if (!textureDraw) {\n      r.textureDrawLastFrame = false;\n    }\n\n    if (textureDraw) {\n      r.textureDrawLastFrame = true;\n\n      if (!r.textureCache) {\n        r.textureCache = {};\n        r.textureCache.bb = cy.mutableElements().boundingBox();\n        r.textureCache.texture = r.data.bufferCanvases[r.TEXTURE_BUFFER];\n        var cxt = r.data.bufferContexts[r.TEXTURE_BUFFER];\n        cxt.setTransform(1, 0, 0, 1, 0, 0);\n        cxt.clearRect(0, 0, r.canvasWidth * r.textureMult, r.canvasHeight * r.textureMult);\n        r.render({\n          forcedContext: cxt,\n          drawOnlyNodeLayer: true,\n          forcedPxRatio: pixelRatio * r.textureMult\n        });\n        var vp = r.textureCache.viewport = {\n          zoom: cy.zoom(),\n          pan: cy.pan(),\n          width: r.canvasWidth,\n          height: r.canvasHeight\n        };\n        vp.mpan = {\n          x: (0 - vp.pan.x) / vp.zoom,\n          y: (0 - vp.pan.y) / vp.zoom\n        };\n      }\n\n      needDraw[r.DRAG] = false;\n      needDraw[r.NODE] = false;\n      var context = data.contexts[r.NODE];\n      var texture = r.textureCache.texture;\n      var vp = r.textureCache.viewport;\n      context.setTransform(1, 0, 0, 1, 0, 0);\n\n      if (motionBlur) {\n        mbclear(context, 0, 0, vp.width, vp.height);\n      } else {\n        context.clearRect(0, 0, vp.width, vp.height);\n      }\n\n      var outsideBgColor = style.core('outside-texture-bg-color').value;\n      var outsideBgOpacity = style.core('outside-texture-bg-opacity').value;\n      r.colorFillStyle(context, outsideBgColor[0], outsideBgColor[1], outsideBgColor[2], outsideBgOpacity);\n      context.fillRect(0, 0, vp.width, vp.height);\n      var zoom = cy.zoom();\n      setContextTransform(context, false);\n      context.clearRect(vp.mpan.x, vp.mpan.y, vp.width / vp.zoom / pixelRatio, vp.height / vp.zoom / pixelRatio);\n      context.drawImage(texture, vp.mpan.x, vp.mpan.y, vp.width / vp.zoom / pixelRatio, vp.height / vp.zoom / pixelRatio);\n    } else if (r.textureOnViewport && !forcedContext) {\n      // clear the cache since we don't need it\n      r.textureCache = null;\n    }\n\n    var extent = cy.extent();\n    var vpManip = r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming || r.hoverData.draggingEles || r.cy.animated();\n    var hideEdges = r.hideEdgesOnViewport && vpManip;\n    var needMbClear = [];\n    needMbClear[r.NODE] = !needDraw[r.NODE] && motionBlur && !r.clearedForMotionBlur[r.NODE] || r.clearingMotionBlur;\n\n    if (needMbClear[r.NODE]) {\n      r.clearedForMotionBlur[r.NODE] = true;\n    }\n\n    needMbClear[r.DRAG] = !needDraw[r.DRAG] && motionBlur && !r.clearedForMotionBlur[r.DRAG] || r.clearingMotionBlur;\n\n    if (needMbClear[r.DRAG]) {\n      r.clearedForMotionBlur[r.DRAG] = true;\n    }\n\n    if (needDraw[r.NODE] || drawAllLayers || drawOnlyNodeLayer || needMbClear[r.NODE]) {\n      var useBuffer = motionBlur && !needMbClear[r.NODE] && mbPxRatio !== 1;\n      var context = forcedContext || (useBuffer ? r.data.bufferContexts[r.MOTIONBLUR_BUFFER_NODE] : data.contexts[r.NODE]);\n      var clear = motionBlur && !useBuffer ? 'motionBlur' : undefined;\n      setContextTransform(context, clear);\n\n      if (hideEdges) {\n        r.drawCachedNodes(context, eles.nondrag, pixelRatio, extent);\n      } else {\n        r.drawLayeredElements(context, eles.nondrag, pixelRatio, extent);\n      }\n\n      if (r.debug) {\n        r.drawDebugPoints(context, eles.nondrag);\n      }\n\n      if (!drawAllLayers && !motionBlur) {\n        needDraw[r.NODE] = false;\n      }\n    }\n\n    if (!drawOnlyNodeLayer && (needDraw[r.DRAG] || drawAllLayers || needMbClear[r.DRAG])) {\n      var useBuffer = motionBlur && !needMbClear[r.DRAG] && mbPxRatio !== 1;\n      var context = forcedContext || (useBuffer ? r.data.bufferContexts[r.MOTIONBLUR_BUFFER_DRAG] : data.contexts[r.DRAG]);\n      setContextTransform(context, motionBlur && !useBuffer ? 'motionBlur' : undefined);\n\n      if (hideEdges) {\n        r.drawCachedNodes(context, eles.drag, pixelRatio, extent);\n      } else {\n        r.drawCachedElements(context, eles.drag, pixelRatio, extent);\n      }\n\n      if (r.debug) {\n        r.drawDebugPoints(context, eles.drag);\n      }\n\n      if (!drawAllLayers && !motionBlur) {\n        needDraw[r.DRAG] = false;\n      }\n    }\n\n    if (r.showFps || !drawOnlyNodeLayer && needDraw[r.SELECT_BOX] && !drawAllLayers) {\n      var context = forcedContext || data.contexts[r.SELECT_BOX];\n      setContextTransform(context);\n\n      if (r.selection[4] == 1 && (r.hoverData.selecting || r.touchData.selecting)) {\n        var zoom = r.cy.zoom();\n        var borderWidth = style.core('selection-box-border-width').value / zoom;\n        context.lineWidth = borderWidth;\n        context.fillStyle = 'rgba(' + style.core('selection-box-color').value[0] + ',' + style.core('selection-box-color').value[1] + ',' + style.core('selection-box-color').value[2] + ',' + style.core('selection-box-opacity').value + ')';\n        context.fillRect(r.selection[0], r.selection[1], r.selection[2] - r.selection[0], r.selection[3] - r.selection[1]);\n\n        if (borderWidth > 0) {\n          context.strokeStyle = 'rgba(' + style.core('selection-box-border-color').value[0] + ',' + style.core('selection-box-border-color').value[1] + ',' + style.core('selection-box-border-color').value[2] + ',' + style.core('selection-box-opacity').value + ')';\n          context.strokeRect(r.selection[0], r.selection[1], r.selection[2] - r.selection[0], r.selection[3] - r.selection[1]);\n        }\n      }\n\n      if (data.bgActivePosistion && !r.hoverData.selecting) {\n        var zoom = r.cy.zoom();\n        var pos = data.bgActivePosistion;\n        context.fillStyle = 'rgba(' + style.core('active-bg-color').value[0] + ',' + style.core('active-bg-color').value[1] + ',' + style.core('active-bg-color').value[2] + ',' + style.core('active-bg-opacity').value + ')';\n        context.beginPath();\n        context.arc(pos.x, pos.y, style.core('active-bg-size').pfValue / zoom, 0, 2 * Math.PI);\n        context.fill();\n      }\n\n      var timeToRender = r.lastRedrawTime;\n\n      if (r.showFps && timeToRender) {\n        timeToRender = Math.round(timeToRender);\n        var fps = Math.round(1000 / timeToRender);\n        context.setTransform(1, 0, 0, 1, 0, 0);\n        context.fillStyle = 'rgba(255, 0, 0, 0.75)';\n        context.strokeStyle = 'rgba(255, 0, 0, 0.75)';\n        context.lineWidth = 1;\n        context.fillText('1 frame = ' + timeToRender + ' ms = ' + fps + ' fps', 0, 20);\n        var maxFps = 60;\n        context.strokeRect(0, 30, 250, 20);\n        context.fillRect(0, 30, 250 * Math.min(fps / maxFps, 1), 20);\n      }\n\n      if (!drawAllLayers) {\n        needDraw[r.SELECT_BOX] = false;\n      }\n    } // motionblur: blit rendered blurry frames\n\n\n    if (motionBlur && mbPxRatio !== 1) {\n      var cxtNode = data.contexts[r.NODE];\n      var txtNode = r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_NODE];\n      var cxtDrag = data.contexts[r.DRAG];\n      var txtDrag = r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_DRAG];\n\n      var drawMotionBlur = function drawMotionBlur(cxt, txt, needClear) {\n        cxt.setTransform(1, 0, 0, 1, 0, 0);\n\n        if (needClear || !motionBlurFadeEffect) {\n          cxt.clearRect(0, 0, r.canvasWidth, r.canvasHeight);\n        } else {\n          mbclear(cxt, 0, 0, r.canvasWidth, r.canvasHeight);\n        }\n\n        var pxr = mbPxRatio;\n        cxt.drawImage(txt, // img\n        0, 0, // sx, sy\n        r.canvasWidth * pxr, r.canvasHeight * pxr, // sw, sh\n        0, 0, // x, y\n        r.canvasWidth, r.canvasHeight // w, h\n        );\n      };\n\n      if (needDraw[r.NODE] || needMbClear[r.NODE]) {\n        drawMotionBlur(cxtNode, txtNode, needMbClear[r.NODE]);\n        needDraw[r.NODE] = false;\n      }\n\n      if (needDraw[r.DRAG] || needMbClear[r.DRAG]) {\n        drawMotionBlur(cxtDrag, txtDrag, needMbClear[r.DRAG]);\n        needDraw[r.DRAG] = false;\n      }\n    }\n\n    r.prevViewport = vp;\n\n    if (r.clearingMotionBlur) {\n      r.clearingMotionBlur = false;\n      r.motionBlurCleared = true;\n      r.motionBlur = true;\n    }\n\n    if (motionBlur) {\n      r.motionBlurTimeout = setTimeout(function () {\n        r.motionBlurTimeout = null;\n        r.clearedForMotionBlur[r.NODE] = false;\n        r.clearedForMotionBlur[r.DRAG] = false;\n        r.motionBlur = false;\n        r.clearingMotionBlur = !textureDraw;\n        r.mbFrames = 0;\n        needDraw[r.NODE] = true;\n        needDraw[r.DRAG] = true;\n        r.redraw();\n      }, motionBlurDelay);\n    }\n\n    if (!forcedContext) {\n      cy.emit('render');\n    }\n  };\n\n  var CRp$3 = {}; // @O Polygon drawing\n\n  CRp$3.drawPolygonPath = function (context, x, y, width, height, points) {\n    var halfW = width / 2;\n    var halfH = height / 2;\n\n    if (context.beginPath) {\n      context.beginPath();\n    }\n\n    context.moveTo(x + halfW * points[0], y + halfH * points[1]);\n\n    for (var i = 1; i < points.length / 2; i++) {\n      context.lineTo(x + halfW * points[i * 2], y + halfH * points[i * 2 + 1]);\n    }\n\n    context.closePath();\n  };\n\n  CRp$3.drawRoundPolygonPath = function (context, x, y, width, height, points) {\n    var halfW = width / 2;\n    var halfH = height / 2;\n    var cornerRadius = getRoundPolygonRadius(width, height);\n\n    if (context.beginPath) {\n      context.beginPath();\n    }\n\n    for (var _i = 0; _i < points.length / 4; _i++) {\n      var sourceUv = void 0,\n          destUv = void 0;\n\n      if (_i === 0) {\n        sourceUv = points.length - 2;\n      } else {\n        sourceUv = _i * 4 - 2;\n      }\n\n      destUv = _i * 4 + 2;\n      var px = x + halfW * points[_i * 4];\n      var py = y + halfH * points[_i * 4 + 1];\n      var cosTheta = -points[sourceUv] * points[destUv] - points[sourceUv + 1] * points[destUv + 1];\n      var offset = cornerRadius / Math.tan(Math.acos(cosTheta) / 2);\n      var cp0x = px - offset * points[sourceUv];\n      var cp0y = py - offset * points[sourceUv + 1];\n      var cp1x = px + offset * points[destUv];\n      var cp1y = py + offset * points[destUv + 1];\n\n      if (_i === 0) {\n        context.moveTo(cp0x, cp0y);\n      } else {\n        context.lineTo(cp0x, cp0y);\n      }\n\n      context.arcTo(px, py, cp1x, cp1y, cornerRadius);\n    }\n\n    context.closePath();\n  }; // Round rectangle drawing\n\n\n  CRp$3.drawRoundRectanglePath = function (context, x, y, width, height) {\n    var halfWidth = width / 2;\n    var halfHeight = height / 2;\n    var cornerRadius = getRoundRectangleRadius(width, height);\n\n    if (context.beginPath) {\n      context.beginPath();\n    } // Start at top middle\n\n\n    context.moveTo(x, y - halfHeight); // Arc from middle top to right side\n\n    context.arcTo(x + halfWidth, y - halfHeight, x + halfWidth, y, cornerRadius); // Arc from right side to bottom\n\n    context.arcTo(x + halfWidth, y + halfHeight, x, y + halfHeight, cornerRadius); // Arc from bottom to left side\n\n    context.arcTo(x - halfWidth, y + halfHeight, x - halfWidth, y, cornerRadius); // Arc from left side to topBorder\n\n    context.arcTo(x - halfWidth, y - halfHeight, x, y - halfHeight, cornerRadius); // Join line\n\n    context.lineTo(x, y - halfHeight);\n    context.closePath();\n  };\n\n  CRp$3.drawBottomRoundRectanglePath = function (context, x, y, width, height) {\n    var halfWidth = width / 2;\n    var halfHeight = height / 2;\n    var cornerRadius = getRoundRectangleRadius(width, height);\n\n    if (context.beginPath) {\n      context.beginPath();\n    } // Start at top middle\n\n\n    context.moveTo(x, y - halfHeight);\n    context.lineTo(x + halfWidth, y - halfHeight);\n    context.lineTo(x + halfWidth, y);\n    context.arcTo(x + halfWidth, y + halfHeight, x, y + halfHeight, cornerRadius);\n    context.arcTo(x - halfWidth, y + halfHeight, x - halfWidth, y, cornerRadius);\n    context.lineTo(x - halfWidth, y - halfHeight);\n    context.lineTo(x, y - halfHeight);\n    context.closePath();\n  };\n\n  CRp$3.drawCutRectanglePath = function (context, x, y, width, height) {\n    var halfWidth = width / 2;\n    var halfHeight = height / 2;\n    var cornerLength = getCutRectangleCornerLength();\n\n    if (context.beginPath) {\n      context.beginPath();\n    }\n\n    context.moveTo(x - halfWidth + cornerLength, y - halfHeight);\n    context.lineTo(x + halfWidth - cornerLength, y - halfHeight);\n    context.lineTo(x + halfWidth, y - halfHeight + cornerLength);\n    context.lineTo(x + halfWidth, y + halfHeight - cornerLength);\n    context.lineTo(x + halfWidth - cornerLength, y + halfHeight);\n    context.lineTo(x - halfWidth + cornerLength, y + halfHeight);\n    context.lineTo(x - halfWidth, y + halfHeight - cornerLength);\n    context.lineTo(x - halfWidth, y - halfHeight + cornerLength);\n    context.closePath();\n  };\n\n  CRp$3.drawBarrelPath = function (context, x, y, width, height) {\n    var halfWidth = width / 2;\n    var halfHeight = height / 2;\n    var xBegin = x - halfWidth;\n    var xEnd = x + halfWidth;\n    var yBegin = y - halfHeight;\n    var yEnd = y + halfHeight;\n    var barrelCurveConstants = getBarrelCurveConstants(width, height);\n    var wOffset = barrelCurveConstants.widthOffset;\n    var hOffset = barrelCurveConstants.heightOffset;\n    var ctrlPtXOffset = barrelCurveConstants.ctrlPtOffsetPct * wOffset;\n\n    if (context.beginPath) {\n      context.beginPath();\n    }\n\n    context.moveTo(xBegin, yBegin + hOffset);\n    context.lineTo(xBegin, yEnd - hOffset);\n    context.quadraticCurveTo(xBegin + ctrlPtXOffset, yEnd, xBegin + wOffset, yEnd);\n    context.lineTo(xEnd - wOffset, yEnd);\n    context.quadraticCurveTo(xEnd - ctrlPtXOffset, yEnd, xEnd, yEnd - hOffset);\n    context.lineTo(xEnd, yBegin + hOffset);\n    context.quadraticCurveTo(xEnd - ctrlPtXOffset, yBegin, xEnd - wOffset, yBegin);\n    context.lineTo(xBegin + wOffset, yBegin);\n    context.quadraticCurveTo(xBegin + ctrlPtXOffset, yBegin, xBegin, yBegin + hOffset);\n    context.closePath();\n  };\n\n  var sin0 = Math.sin(0);\n  var cos0 = Math.cos(0);\n  var sin = {};\n  var cos = {};\n  var ellipseStepSize = Math.PI / 40;\n\n  for (var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize) {\n    sin[i] = Math.sin(i);\n    cos[i] = Math.cos(i);\n  }\n\n  CRp$3.drawEllipsePath = function (context, centerX, centerY, width, height) {\n    if (context.beginPath) {\n      context.beginPath();\n    }\n\n    if (context.ellipse) {\n      context.ellipse(centerX, centerY, width / 2, height / 2, 0, 0, 2 * Math.PI);\n    } else {\n      var xPos, yPos;\n      var rw = width / 2;\n      var rh = height / 2;\n\n      for (var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize) {\n        xPos = centerX - rw * sin[i] * sin0 + rw * cos[i] * cos0;\n        yPos = centerY + rh * cos[i] * sin0 + rh * sin[i] * cos0;\n\n        if (i === 0) {\n          context.moveTo(xPos, yPos);\n        } else {\n          context.lineTo(xPos, yPos);\n        }\n      }\n    }\n\n    context.closePath();\n  };\n\n  /* global atob, ArrayBuffer, Uint8Array, Blob */\n  var CRp$2 = {};\n\n  CRp$2.createBuffer = function (w, h) {\n    var buffer = document.createElement('canvas'); // eslint-disable-line no-undef\n\n    buffer.width = w;\n    buffer.height = h;\n    return [buffer, buffer.getContext('2d')];\n  };\n\n  CRp$2.bufferCanvasImage = function (options) {\n    var cy = this.cy;\n    var eles = cy.mutableElements();\n    var bb = eles.boundingBox();\n    var ctrRect = this.findContainerClientCoords();\n    var width = options.full ? Math.ceil(bb.w) : ctrRect[2];\n    var height = options.full ? Math.ceil(bb.h) : ctrRect[3];\n    var specdMaxDims = number$1(options.maxWidth) || number$1(options.maxHeight);\n    var pxRatio = this.getPixelRatio();\n    var scale = 1;\n\n    if (options.scale !== undefined) {\n      width *= options.scale;\n      height *= options.scale;\n      scale = options.scale;\n    } else if (specdMaxDims) {\n      var maxScaleW = Infinity;\n      var maxScaleH = Infinity;\n\n      if (number$1(options.maxWidth)) {\n        maxScaleW = scale * options.maxWidth / width;\n      }\n\n      if (number$1(options.maxHeight)) {\n        maxScaleH = scale * options.maxHeight / height;\n      }\n\n      scale = Math.min(maxScaleW, maxScaleH);\n      width *= scale;\n      height *= scale;\n    }\n\n    if (!specdMaxDims) {\n      width *= pxRatio;\n      height *= pxRatio;\n      scale *= pxRatio;\n    }\n\n    var buffCanvas = document.createElement('canvas'); // eslint-disable-line no-undef\n\n    buffCanvas.width = width;\n    buffCanvas.height = height;\n    buffCanvas.style.width = width + 'px';\n    buffCanvas.style.height = height + 'px';\n    var buffCxt = buffCanvas.getContext('2d'); // Rasterize the layers, but only if container has nonzero size\n\n    if (width > 0 && height > 0) {\n      buffCxt.clearRect(0, 0, width, height);\n      buffCxt.globalCompositeOperation = 'source-over';\n      var zsortedEles = this.getCachedZSortedEles();\n\n      if (options.full) {\n        // draw the full bounds of the graph\n        buffCxt.translate(-bb.x1 * scale, -bb.y1 * scale);\n        buffCxt.scale(scale, scale);\n        this.drawElements(buffCxt, zsortedEles);\n        buffCxt.scale(1 / scale, 1 / scale);\n        buffCxt.translate(bb.x1 * scale, bb.y1 * scale);\n      } else {\n        // draw the current view\n        var pan = cy.pan();\n        var translation = {\n          x: pan.x * scale,\n          y: pan.y * scale\n        };\n        scale *= cy.zoom();\n        buffCxt.translate(translation.x, translation.y);\n        buffCxt.scale(scale, scale);\n        this.drawElements(buffCxt, zsortedEles);\n        buffCxt.scale(1 / scale, 1 / scale);\n        buffCxt.translate(-translation.x, -translation.y);\n      } // need to fill bg at end like this in order to fill cleared transparent pixels in jpgs\n\n\n      if (options.bg) {\n        buffCxt.globalCompositeOperation = 'destination-over';\n        buffCxt.fillStyle = options.bg;\n        buffCxt.rect(0, 0, width, height);\n        buffCxt.fill();\n      }\n    }\n\n    return buffCanvas;\n  };\n\n  function b64ToBlob(b64, mimeType) {\n    var bytes = atob(b64);\n    var buff = new ArrayBuffer(bytes.length);\n    var buffUint8 = new Uint8Array(buff);\n\n    for (var i = 0; i < bytes.length; i++) {\n      buffUint8[i] = bytes.charCodeAt(i);\n    }\n\n    return new Blob([buff], {\n      type: mimeType\n    });\n  }\n\n  function b64UriToB64(b64uri) {\n    var i = b64uri.indexOf(',');\n    return b64uri.substr(i + 1);\n  }\n\n  function output(options, canvas, mimeType) {\n    var getB64Uri = function getB64Uri() {\n      return canvas.toDataURL(mimeType, options.quality);\n    };\n\n    switch (options.output) {\n      case 'blob-promise':\n        return new Promise$1(function (resolve, reject) {\n          try {\n            canvas.toBlob(function (blob) {\n              if (blob != null) {\n                resolve(blob);\n              } else {\n                reject(new Error('`canvas.toBlob()` sent a null value in its callback'));\n              }\n            }, mimeType, options.quality);\n          } catch (err) {\n            reject(err);\n          }\n        });\n\n      case 'blob':\n        return b64ToBlob(b64UriToB64(getB64Uri()), mimeType);\n\n      case 'base64':\n        return b64UriToB64(getB64Uri());\n\n      case 'base64uri':\n      default:\n        return getB64Uri();\n    }\n  }\n\n  CRp$2.png = function (options) {\n    return output(options, this.bufferCanvasImage(options), 'image/png');\n  };\n\n  CRp$2.jpg = function (options) {\n    return output(options, this.bufferCanvasImage(options), 'image/jpeg');\n  };\n\n  var CRp$1 = {};\n\n  CRp$1.nodeShapeImpl = function (name, context, centerX, centerY, width, height, points) {\n    switch (name) {\n      case 'ellipse':\n        return this.drawEllipsePath(context, centerX, centerY, width, height);\n\n      case 'polygon':\n        return this.drawPolygonPath(context, centerX, centerY, width, height, points);\n\n      case 'round-polygon':\n        return this.drawRoundPolygonPath(context, centerX, centerY, width, height, points);\n\n      case 'roundrectangle':\n      case 'round-rectangle':\n        return this.drawRoundRectanglePath(context, centerX, centerY, width, height);\n\n      case 'cutrectangle':\n      case 'cut-rectangle':\n        return this.drawCutRectanglePath(context, centerX, centerY, width, height);\n\n      case 'bottomroundrectangle':\n      case 'bottom-round-rectangle':\n        return this.drawBottomRoundRectanglePath(context, centerX, centerY, width, height);\n\n      case 'barrel':\n        return this.drawBarrelPath(context, centerX, centerY, width, height);\n    }\n  };\n\n  var CR = CanvasRenderer;\n  var CRp = CanvasRenderer.prototype;\n  CRp.CANVAS_LAYERS = 3; //\n\n  CRp.SELECT_BOX = 0;\n  CRp.DRAG = 1;\n  CRp.NODE = 2;\n  CRp.BUFFER_COUNT = 3; //\n\n  CRp.TEXTURE_BUFFER = 0;\n  CRp.MOTIONBLUR_BUFFER_NODE = 1;\n  CRp.MOTIONBLUR_BUFFER_DRAG = 2;\n\n  function CanvasRenderer(options) {\n    var r = this;\n    r.data = {\n      canvases: new Array(CRp.CANVAS_LAYERS),\n      contexts: new Array(CRp.CANVAS_LAYERS),\n      canvasNeedsRedraw: new Array(CRp.CANVAS_LAYERS),\n      bufferCanvases: new Array(CRp.BUFFER_COUNT),\n      bufferContexts: new Array(CRp.CANVAS_LAYERS)\n    };\n    var tapHlOffAttr = '-webkit-tap-highlight-color';\n    var tapHlOffStyle = 'rgba(0,0,0,0)';\n    r.data.canvasContainer = document.createElement('div'); // eslint-disable-line no-undef\n\n    var containerStyle = r.data.canvasContainer.style;\n    r.data.canvasContainer.style[tapHlOffAttr] = tapHlOffStyle;\n    containerStyle.position = 'relative';\n    containerStyle.zIndex = '0';\n    containerStyle.overflow = 'hidden';\n    var container = options.cy.container();\n    container.appendChild(r.data.canvasContainer);\n    container.style[tapHlOffAttr] = tapHlOffStyle;\n    var styleMap = {\n      '-webkit-user-select': 'none',\n      '-moz-user-select': '-moz-none',\n      'user-select': 'none',\n      '-webkit-tap-highlight-color': 'rgba(0,0,0,0)',\n      'outline-style': 'none'\n    };\n\n    if (ms()) {\n      styleMap['-ms-touch-action'] = 'none';\n      styleMap['touch-action'] = 'none';\n    }\n\n    for (var i = 0; i < CRp.CANVAS_LAYERS; i++) {\n      var canvas = r.data.canvases[i] = document.createElement('canvas'); // eslint-disable-line no-undef\n\n      r.data.contexts[i] = canvas.getContext('2d');\n      Object.keys(styleMap).forEach(function (k) {\n        canvas.style[k] = styleMap[k];\n      });\n      canvas.style.position = 'absolute';\n      canvas.setAttribute('data-id', 'layer' + i);\n      canvas.style.zIndex = String(CRp.CANVAS_LAYERS - i);\n      r.data.canvasContainer.appendChild(canvas);\n      r.data.canvasNeedsRedraw[i] = false;\n    }\n\n    r.data.topCanvas = r.data.canvases[0];\n    r.data.canvases[CRp.NODE].setAttribute('data-id', 'layer' + CRp.NODE + '-node');\n    r.data.canvases[CRp.SELECT_BOX].setAttribute('data-id', 'layer' + CRp.SELECT_BOX + '-selectbox');\n    r.data.canvases[CRp.DRAG].setAttribute('data-id', 'layer' + CRp.DRAG + '-drag');\n\n    for (var i = 0; i < CRp.BUFFER_COUNT; i++) {\n      r.data.bufferCanvases[i] = document.createElement('canvas'); // eslint-disable-line no-undef\n\n      r.data.bufferContexts[i] = r.data.bufferCanvases[i].getContext('2d');\n      r.data.bufferCanvases[i].style.position = 'absolute';\n      r.data.bufferCanvases[i].setAttribute('data-id', 'buffer' + i);\n      r.data.bufferCanvases[i].style.zIndex = String(-i - 1);\n      r.data.bufferCanvases[i].style.visibility = 'hidden'; //r.data.canvasContainer.appendChild(r.data.bufferCanvases[i]);\n    }\n\n    r.pathsEnabled = true;\n    var emptyBb = makeBoundingBox();\n\n    var getBoxCenter = function getBoxCenter(bb) {\n      return {\n        x: (bb.x1 + bb.x2) / 2,\n        y: (bb.y1 + bb.y2) / 2\n      };\n    };\n\n    var getCenterOffset = function getCenterOffset(bb) {\n      return {\n        x: -bb.w / 2,\n        y: -bb.h / 2\n      };\n    };\n\n    var backgroundTimestampHasChanged = function backgroundTimestampHasChanged(ele) {\n      var _p = ele[0]._private;\n      var same = _p.oldBackgroundTimestamp === _p.backgroundTimestamp;\n      return !same;\n    };\n\n    var getStyleKey = function getStyleKey(ele) {\n      return ele[0]._private.nodeKey;\n    };\n\n    var getLabelKey = function getLabelKey(ele) {\n      return ele[0]._private.labelStyleKey;\n    };\n\n    var getSourceLabelKey = function getSourceLabelKey(ele) {\n      return ele[0]._private.sourceLabelStyleKey;\n    };\n\n    var getTargetLabelKey = function getTargetLabelKey(ele) {\n      return ele[0]._private.targetLabelStyleKey;\n    };\n\n    var drawElement = function drawElement(context, ele, bb, scaledLabelShown, useEleOpacity) {\n      return r.drawElement(context, ele, bb, false, false, useEleOpacity);\n    };\n\n    var drawLabel = function drawLabel(context, ele, bb, scaledLabelShown, useEleOpacity) {\n      return r.drawElementText(context, ele, bb, scaledLabelShown, 'main', useEleOpacity);\n    };\n\n    var drawSourceLabel = function drawSourceLabel(context, ele, bb, scaledLabelShown, useEleOpacity) {\n      return r.drawElementText(context, ele, bb, scaledLabelShown, 'source', useEleOpacity);\n    };\n\n    var drawTargetLabel = function drawTargetLabel(context, ele, bb, scaledLabelShown, useEleOpacity) {\n      return r.drawElementText(context, ele, bb, scaledLabelShown, 'target', useEleOpacity);\n    };\n\n    var getElementBox = function getElementBox(ele) {\n      ele.boundingBox();\n      return ele[0]._private.bodyBounds;\n    };\n\n    var getLabelBox = function getLabelBox(ele) {\n      ele.boundingBox();\n      return ele[0]._private.labelBounds.main || emptyBb;\n    };\n\n    var getSourceLabelBox = function getSourceLabelBox(ele) {\n      ele.boundingBox();\n      return ele[0]._private.labelBounds.source || emptyBb;\n    };\n\n    var getTargetLabelBox = function getTargetLabelBox(ele) {\n      ele.boundingBox();\n      return ele[0]._private.labelBounds.target || emptyBb;\n    };\n\n    var isLabelVisibleAtScale = function isLabelVisibleAtScale(ele, scaledLabelShown) {\n      return scaledLabelShown;\n    };\n\n    var getElementRotationPoint = function getElementRotationPoint(ele) {\n      return getBoxCenter(getElementBox(ele));\n    };\n\n    var addTextMargin = function addTextMargin(prefix, pt, ele) {\n      var pre = prefix ? prefix + '-' : '';\n      return {\n        x: pt.x + ele.pstyle(pre + 'text-margin-x').pfValue,\n        y: pt.y + ele.pstyle(pre + 'text-margin-y').pfValue\n      };\n    };\n\n    var getRsPt = function getRsPt(ele, x, y) {\n      var rs = ele[0]._private.rscratch;\n      return {\n        x: rs[x],\n        y: rs[y]\n      };\n    };\n\n    var getLabelRotationPoint = function getLabelRotationPoint(ele) {\n      return addTextMargin('', getRsPt(ele, 'labelX', 'labelY'), ele);\n    };\n\n    var getSourceLabelRotationPoint = function getSourceLabelRotationPoint(ele) {\n      return addTextMargin('source', getRsPt(ele, 'sourceLabelX', 'sourceLabelY'), ele);\n    };\n\n    var getTargetLabelRotationPoint = function getTargetLabelRotationPoint(ele) {\n      return addTextMargin('target', getRsPt(ele, 'targetLabelX', 'targetLabelY'), ele);\n    };\n\n    var getElementRotationOffset = function getElementRotationOffset(ele) {\n      return getCenterOffset(getElementBox(ele));\n    };\n\n    var getSourceLabelRotationOffset = function getSourceLabelRotationOffset(ele) {\n      return getCenterOffset(getSourceLabelBox(ele));\n    };\n\n    var getTargetLabelRotationOffset = function getTargetLabelRotationOffset(ele) {\n      return getCenterOffset(getTargetLabelBox(ele));\n    };\n\n    var getLabelRotationOffset = function getLabelRotationOffset(ele) {\n      var bb = getLabelBox(ele);\n      var p = getCenterOffset(getLabelBox(ele));\n\n      if (ele.isNode()) {\n        switch (ele.pstyle('text-halign').value) {\n          case 'left':\n            p.x = -bb.w;\n            break;\n\n          case 'right':\n            p.x = 0;\n            break;\n        }\n\n        switch (ele.pstyle('text-valign').value) {\n          case 'top':\n            p.y = -bb.h;\n            break;\n\n          case 'bottom':\n            p.y = 0;\n            break;\n        }\n      }\n\n      return p;\n    };\n\n    var eleTxrCache = r.data.eleTxrCache = new ElementTextureCache(r, {\n      getKey: getStyleKey,\n      doesEleInvalidateKey: backgroundTimestampHasChanged,\n      drawElement: drawElement,\n      getBoundingBox: getElementBox,\n      getRotationPoint: getElementRotationPoint,\n      getRotationOffset: getElementRotationOffset,\n      allowEdgeTxrCaching: false,\n      allowParentTxrCaching: false\n    });\n    var lblTxrCache = r.data.lblTxrCache = new ElementTextureCache(r, {\n      getKey: getLabelKey,\n      drawElement: drawLabel,\n      getBoundingBox: getLabelBox,\n      getRotationPoint: getLabelRotationPoint,\n      getRotationOffset: getLabelRotationOffset,\n      isVisible: isLabelVisibleAtScale\n    });\n    var slbTxrCache = r.data.slbTxrCache = new ElementTextureCache(r, {\n      getKey: getSourceLabelKey,\n      drawElement: drawSourceLabel,\n      getBoundingBox: getSourceLabelBox,\n      getRotationPoint: getSourceLabelRotationPoint,\n      getRotationOffset: getSourceLabelRotationOffset,\n      isVisible: isLabelVisibleAtScale\n    });\n    var tlbTxrCache = r.data.tlbTxrCache = new ElementTextureCache(r, {\n      getKey: getTargetLabelKey,\n      drawElement: drawTargetLabel,\n      getBoundingBox: getTargetLabelBox,\n      getRotationPoint: getTargetLabelRotationPoint,\n      getRotationOffset: getTargetLabelRotationOffset,\n      isVisible: isLabelVisibleAtScale\n    });\n    var lyrTxrCache = r.data.lyrTxrCache = new LayeredTextureCache(r);\n    r.onUpdateEleCalcs(function invalidateTextureCaches(willDraw, eles) {\n      // each cache should check for sub-key diff to see that the update affects that cache particularly\n      eleTxrCache.invalidateElements(eles);\n      lblTxrCache.invalidateElements(eles);\n      slbTxrCache.invalidateElements(eles);\n      tlbTxrCache.invalidateElements(eles); // any change invalidates the layers\n\n      lyrTxrCache.invalidateElements(eles); // update the old bg timestamp so diffs can be done in the ele txr caches\n\n      for (var _i = 0; _i < eles.length; _i++) {\n        var _p = eles[_i]._private;\n        _p.oldBackgroundTimestamp = _p.backgroundTimestamp;\n      }\n    });\n\n    var refineInLayers = function refineInLayers(reqs) {\n      for (var i = 0; i < reqs.length; i++) {\n        lyrTxrCache.enqueueElementRefinement(reqs[i].ele);\n      }\n    };\n\n    eleTxrCache.onDequeue(refineInLayers);\n    lblTxrCache.onDequeue(refineInLayers);\n    slbTxrCache.onDequeue(refineInLayers);\n    tlbTxrCache.onDequeue(refineInLayers);\n  }\n\n  CRp.redrawHint = function (group, bool) {\n    var r = this;\n\n    switch (group) {\n      case 'eles':\n        r.data.canvasNeedsRedraw[CRp.NODE] = bool;\n        break;\n\n      case 'drag':\n        r.data.canvasNeedsRedraw[CRp.DRAG] = bool;\n        break;\n\n      case 'select':\n        r.data.canvasNeedsRedraw[CRp.SELECT_BOX] = bool;\n        break;\n    }\n  }; // whether to use Path2D caching for drawing\n\n\n  var pathsImpld = typeof Path2D !== 'undefined';\n\n  CRp.path2dEnabled = function (on) {\n    if (on === undefined) {\n      return this.pathsEnabled;\n    }\n\n    this.pathsEnabled = on ? true : false;\n  };\n\n  CRp.usePaths = function () {\n    return pathsImpld && this.pathsEnabled;\n  };\n\n  CRp.setImgSmoothing = function (context, bool) {\n    if (context.imageSmoothingEnabled != null) {\n      context.imageSmoothingEnabled = bool;\n    } else {\n      context.webkitImageSmoothingEnabled = bool;\n      context.mozImageSmoothingEnabled = bool;\n      context.msImageSmoothingEnabled = bool;\n    }\n  };\n\n  CRp.getImgSmoothing = function (context) {\n    if (context.imageSmoothingEnabled != null) {\n      return context.imageSmoothingEnabled;\n    } else {\n      return context.webkitImageSmoothingEnabled || context.mozImageSmoothingEnabled || context.msImageSmoothingEnabled;\n    }\n  };\n\n  CRp.makeOffscreenCanvas = function (width, height) {\n    var canvas;\n\n    if ((typeof OffscreenCanvas === \"undefined\" ? \"undefined\" : _typeof(OffscreenCanvas)) !== (\"undefined\" )) {\n      canvas = new OffscreenCanvas(width, height);\n    } else {\n      canvas = document.createElement('canvas'); // eslint-disable-line no-undef\n\n      canvas.width = width;\n      canvas.height = height;\n    }\n\n    return canvas;\n  };\n\n  [CRp$a, CRp$9, CRp$8, CRp$7, CRp$6, CRp$5, CRp$4, CRp$3, CRp$2, CRp$1].forEach(function (props) {\n    extend(CRp, props);\n  });\n\n  var renderer = [{\n    name: 'null',\n    impl: NullRenderer\n  }, {\n    name: 'base',\n    impl: BR\n  }, {\n    name: 'canvas',\n    impl: CR\n  }];\n\n  var incExts = [{\n    type: 'layout',\n    extensions: layout\n  }, {\n    type: 'renderer',\n    extensions: renderer\n  }];\n\n  var extensions = {}; // registered modules for extensions, indexed by name\n\n  var modules = {};\n\n  function setExtension(type, name, registrant) {\n    var ext = registrant;\n\n    var overrideErr = function overrideErr(field) {\n      warn('Can not register `' + name + '` for `' + type + '` since `' + field + '` already exists in the prototype and can not be overridden');\n    };\n\n    if (type === 'core') {\n      if (Core.prototype[name]) {\n        return overrideErr(name);\n      } else {\n        Core.prototype[name] = registrant;\n      }\n    } else if (type === 'collection') {\n      if (Collection.prototype[name]) {\n        return overrideErr(name);\n      } else {\n        Collection.prototype[name] = registrant;\n      }\n    } else if (type === 'layout') {\n      // fill in missing layout functions in the prototype\n      var Layout = function Layout(options) {\n        this.options = options;\n        registrant.call(this, options); // make sure layout has _private for use w/ std apis like .on()\n\n        if (!plainObject(this._private)) {\n          this._private = {};\n        }\n\n        this._private.cy = options.cy;\n        this._private.listeners = [];\n        this.createEmitter();\n      };\n\n      var layoutProto = Layout.prototype = Object.create(registrant.prototype);\n      var optLayoutFns = [];\n\n      for (var i = 0; i < optLayoutFns.length; i++) {\n        var fnName = optLayoutFns[i];\n\n        layoutProto[fnName] = layoutProto[fnName] || function () {\n          return this;\n        };\n      } // either .start() or .run() is defined, so autogen the other\n\n\n      if (layoutProto.start && !layoutProto.run) {\n        layoutProto.run = function () {\n          this.start();\n          return this;\n        };\n      } else if (!layoutProto.start && layoutProto.run) {\n        layoutProto.start = function () {\n          this.run();\n          return this;\n        };\n      }\n\n      var regStop = registrant.prototype.stop;\n\n      layoutProto.stop = function () {\n        var opts = this.options;\n\n        if (opts && opts.animate) {\n          var anis = this.animations;\n\n          if (anis) {\n            for (var _i = 0; _i < anis.length; _i++) {\n              anis[_i].stop();\n            }\n          }\n        }\n\n        if (regStop) {\n          regStop.call(this);\n        } else {\n          this.emit('layoutstop');\n        }\n\n        return this;\n      };\n\n      if (!layoutProto.destroy) {\n        layoutProto.destroy = function () {\n          return this;\n        };\n      }\n\n      layoutProto.cy = function () {\n        return this._private.cy;\n      };\n\n      var getCy = function getCy(layout) {\n        return layout._private.cy;\n      };\n\n      var emitterOpts = {\n        addEventFields: function addEventFields(layout, evt) {\n          evt.layout = layout;\n          evt.cy = getCy(layout);\n          evt.target = layout;\n        },\n        bubble: function bubble() {\n          return true;\n        },\n        parent: function parent(layout) {\n          return getCy(layout);\n        }\n      };\n      extend(layoutProto, {\n        createEmitter: function createEmitter() {\n          this._private.emitter = new Emitter(emitterOpts, this);\n          return this;\n        },\n        emitter: function emitter() {\n          return this._private.emitter;\n        },\n        on: function on(evt, cb) {\n          this.emitter().on(evt, cb);\n          return this;\n        },\n        one: function one(evt, cb) {\n          this.emitter().one(evt, cb);\n          return this;\n        },\n        once: function once(evt, cb) {\n          this.emitter().one(evt, cb);\n          return this;\n        },\n        removeListener: function removeListener(evt, cb) {\n          this.emitter().removeListener(evt, cb);\n          return this;\n        },\n        removeAllListeners: function removeAllListeners() {\n          this.emitter().removeAllListeners();\n          return this;\n        },\n        emit: function emit(evt, params) {\n          this.emitter().emit(evt, params);\n          return this;\n        }\n      });\n      define.eventAliasesOn(layoutProto);\n      ext = Layout; // replace with our wrapped layout\n    } else if (type === 'renderer' && name !== 'null' && name !== 'base') {\n      // user registered renderers inherit from base\n      var BaseRenderer = getExtension('renderer', 'base');\n      var bProto = BaseRenderer.prototype;\n      var RegistrantRenderer = registrant;\n      var rProto = registrant.prototype;\n\n      var Renderer = function Renderer() {\n        BaseRenderer.apply(this, arguments);\n        RegistrantRenderer.apply(this, arguments);\n      };\n\n      var proto = Renderer.prototype;\n\n      for (var pName in bProto) {\n        var pVal = bProto[pName];\n        var existsInR = rProto[pName] != null;\n\n        if (existsInR) {\n          return overrideErr(pName);\n        }\n\n        proto[pName] = pVal; // take impl from base\n      }\n\n      for (var _pName in rProto) {\n        proto[_pName] = rProto[_pName]; // take impl from registrant\n      }\n\n      bProto.clientFunctions.forEach(function (name) {\n        proto[name] = proto[name] || function () {\n          error('Renderer does not implement `renderer.' + name + '()` on its prototype');\n        };\n      });\n      ext = Renderer;\n    } else if (type === '__proto__' || type === 'constructor' || type === 'prototype') {\n      // to avoid potential prototype pollution\n      return error(type + ' is an illegal type to be registered, possibly lead to prototype pollutions');\n    }\n\n    return setMap({\n      map: extensions,\n      keys: [type, name],\n      value: ext\n    });\n  }\n\n  function getExtension(type, name) {\n    return getMap({\n      map: extensions,\n      keys: [type, name]\n    });\n  }\n\n  function setModule(type, name, moduleType, moduleName, registrant) {\n    return setMap({\n      map: modules,\n      keys: [type, name, moduleType, moduleName],\n      value: registrant\n    });\n  }\n\n  function getModule(type, name, moduleType, moduleName) {\n    return getMap({\n      map: modules,\n      keys: [type, name, moduleType, moduleName]\n    });\n  }\n\n  var extension = function extension() {\n    // e.g. extension('renderer', 'svg')\n    if (arguments.length === 2) {\n      return getExtension.apply(null, arguments);\n    } // e.g. extension('renderer', 'svg', { ... })\n    else if (arguments.length === 3) {\n      return setExtension.apply(null, arguments);\n    } // e.g. extension('renderer', 'svg', 'nodeShape', 'ellipse')\n    else if (arguments.length === 4) {\n      return getModule.apply(null, arguments);\n    } // e.g. extension('renderer', 'svg', 'nodeShape', 'ellipse', { ... })\n    else if (arguments.length === 5) {\n      return setModule.apply(null, arguments);\n    } else {\n      error('Invalid extension access syntax');\n    }\n  }; // allows a core instance to access extensions internally\n\n\n  Core.prototype.extension = extension; // included extensions\n\n  incExts.forEach(function (group) {\n    group.extensions.forEach(function (ext) {\n      setExtension(group.type, ext.name, ext.impl);\n    });\n  });\n\n  // (useful for init)\n\n  var Stylesheet = function Stylesheet() {\n    if (!(this instanceof Stylesheet)) {\n      return new Stylesheet();\n    }\n\n    this.length = 0;\n  };\n\n  var sheetfn = Stylesheet.prototype;\n\n  sheetfn.instanceString = function () {\n    return 'stylesheet';\n  }; // just store the selector to be parsed later\n\n\n  sheetfn.selector = function (selector) {\n    var i = this.length++;\n    this[i] = {\n      selector: selector,\n      properties: []\n    };\n    return this; // chaining\n  }; // just store the property to be parsed later\n\n\n  sheetfn.css = function (name, value) {\n    var i = this.length - 1;\n\n    if (string(name)) {\n      this[i].properties.push({\n        name: name,\n        value: value\n      });\n    } else if (plainObject(name)) {\n      var map = name;\n      var propNames = Object.keys(map);\n\n      for (var j = 0; j < propNames.length; j++) {\n        var key = propNames[j];\n        var mapVal = map[key];\n\n        if (mapVal == null) {\n          continue;\n        }\n\n        var prop = Style.properties[key] || Style.properties[dash2camel(key)];\n\n        if (prop == null) {\n          continue;\n        }\n\n        var _name = prop.name;\n        var _value = mapVal;\n        this[i].properties.push({\n          name: _name,\n          value: _value\n        });\n      }\n    }\n\n    return this; // chaining\n  };\n\n  sheetfn.style = sheetfn.css; // generate a real style object from the dummy stylesheet\n\n  sheetfn.generateStyle = function (cy) {\n    var style = new Style(cy);\n    return this.appendToStyle(style);\n  }; // append a dummy stylesheet object on a real style object\n\n\n  sheetfn.appendToStyle = function (style) {\n    for (var i = 0; i < this.length; i++) {\n      var context = this[i];\n      var selector = context.selector;\n      var props = context.properties;\n      style.selector(selector); // apply selector\n\n      for (var j = 0; j < props.length; j++) {\n        var prop = props[j];\n        style.css(prop.name, prop.value); // apply property\n      }\n    }\n\n    return style;\n  };\n\n  var version = \"3.24.0\";\n\n  var cytoscape = function cytoscape(options) {\n    // if no options specified, use default\n    if (options === undefined) {\n      options = {};\n    } // create instance\n\n\n    if (plainObject(options)) {\n      return new Core(options);\n    } // allow for registration of extensions\n    else if (string(options)) {\n      return extension.apply(extension, arguments);\n    }\n  }; // e.g. cytoscape.use( require('cytoscape-foo'), bar )\n\n\n  cytoscape.use = function (ext) {\n    var args = Array.prototype.slice.call(arguments, 1); // args to pass to ext\n\n    args.unshift(cytoscape); // cytoscape is first arg to ext\n\n    ext.apply(null, args);\n    return this;\n  };\n\n  cytoscape.warnings = function (bool) {\n    return warnings(bool);\n  }; // replaced by build system\n\n\n  cytoscape.version = version; // expose public apis (mostly for extensions)\n\n  cytoscape.stylesheet = cytoscape.Stylesheet = Stylesheet;\n\n  return cytoscape;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvY3l0b3NjYXBlL2Rpc3QvY3l0b3NjYXBlLnVtZC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFLEtBQTREO0FBQzlELEVBQUUsQ0FDd0c7QUFDMUcsQ0FBQyx1QkFBdUI7O0FBRXhCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw4QkFBOEIsK0JBQStCO0FBQzdEOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwyQ0FBMkMsU0FBUzs7QUFFcEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0VBQWdFOztBQUVoRTtBQUNBOztBQUVBOztBQUVBLDRCQUE0Qjs7QUFFNUIsdUNBQXVDOztBQUV2Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixPQUFPO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsT0FBTztBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsR0FBRztBQUNoQixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxxQkFBcUIsYUFBYTtBQUNsQzs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsR0FBRztBQUNoQixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxHQUFHO0FBQ2hCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsR0FBRztBQUNoQixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEdBQUc7QUFDaEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxHQUFHO0FBQ2hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxHQUFHO0FBQ2hCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRLFdBQVc7QUFDaEMsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsaURBQWlELGlCQUFpQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUEsd0NBQXdDLE9BQU87QUFDL0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUNBQXVDOzs7QUFHdkMsc0JBQXNCLGNBQWM7QUFDcEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVCwwQkFBMEIsc0JBQXNCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx1QkFBdUIsNEJBQTRCO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELG1DQUFtQywwQkFBMEI7QUFDdEg7QUFDQSxPQUFPO0FBQ1A7QUFDQSx3Q0FBd0MsV0FBVztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFdBQVc7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxXQUFXO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsc0NBQXNDO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7O0FBRUwsR0FBRztBQUNILEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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Q3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLHdCQUF3QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7OztBQUdBO0FBQ0EsbURBQW1EOztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLGlHQUFpRztBQUNqRztBQUNBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IscUJBQXFCO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQSwrREFBK0Q7QUFDL0Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FB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QUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7O0FBRXRDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxHQUFHO0FBQ2hCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsR0FBRztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsZUFBZSxHQUFHO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSxHQUFHO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVB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QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDUDs7QUFFQTs7QUFFQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixrQkFBa0I7QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FB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LE9BQU87QUFDUCw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGOztBQUUxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQzs7QUFFbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCLGNBQWM7O0FBRWQ7QUFDQSxpR0FBaUc7QUFDakc7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FB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OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEOztBQUUzRDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHLElBQUk7O0FBRVAsNEJBQTRCOztBQUU1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QjtBQUM5Qiw2Q0FBNkM7O0FBRTdDO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFROzs7QUFH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O0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkIsS0FBSztBQUNMO0FBQ0Esb0NBQW9DLFFBQVE7QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0Es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O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBLFFBQVE7O0FBRVI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7O0FBR1QsdUNBQXVDLFFBQVE7QUFDL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047OztBQUdBOztBQUVBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR04sd0NBQXdDOztBQUV4QztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBLFFBQVE7OztBQUdSLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDOztBQUV4QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFD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Q1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUssR0FBRzs7QUFFUjtBQUNBLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCxvQkFBb0IsNkJBQTZCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FB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UTtBQUNSO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25CLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25CLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25CLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUI7QUFDbkIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsY0FBYztBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQjtBQUNuQixLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2RUFBNkU7O0FBRTdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlOztBQUVmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQSxvREFBb0Q7O0FBRXBEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7O0FBRXZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25CLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25CLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1AsbUJBQW1CO0FBQ25CLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNM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RUEsc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGlCQUFpQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUEsd0JBQXdCLDBCQUEwQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0EsbURBQW1EOztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJDQUEyQzs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDOztBQUUxQztBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0VBQXNFOztBQUV0RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7O0FBRTVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEI7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBaUU7OztBQUdqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQiwyQkFBMkI7QUFDakQ7QUFDQSwwREFBMEQ7O0FBRTFEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLDREQUE0RDs7QUFFNUQ7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZOztBQUVaLFlBQVk7O0FBRVosY0FBYzs7QUFFZCxjQUFjOztBQUVkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOLDhCQUE4QjtBQUM5QixNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOLDhCQUE4QjtBQUM5QixNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7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REFBMkQ7QUFDM0QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBeUM7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNENBQTRDOztBQUU1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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OztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBLDBCQUEwQixnQkFBZ0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7OztBQUdaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHlCQUF5Qix5QkFBeUI7QUFDMUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FB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QTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEOztBQUV0RDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG9CQUFvQjtBQUM5QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixxQkFBcUI7QUFDaEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQzs7QUFFMUM7QUFDQSxzQ0FBc0M7O0FBRXRDO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDOztBQUVoQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDs7QUFFakQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9CQUFvQiw0QkFBNEI7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtB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QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FB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QUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDLDRDQUE0Qzs7QUFFNUMsdUJBQXVCLGtCQUFrQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztB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QUNOO0FBQ0E7O0FBRUEsc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBLGlCQUFpQjtBQUNqQjs7QUFFQSwrQkFBK0I7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7O0FBRWhDLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBLHlEQUF5RDs7QUFFekQsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7OztBQUdMLCtCQUErQjs7QUFFL0I7O0FBRUE7O0FBRUEsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NoYXRncHQtbmV4dC13ZWIvLi9ub2RlX21vZHVsZXMvY3l0b3NjYXBlL2Rpc3QvY3l0b3NjYXBlLnVtZC5qcz9iMWExIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMjMsIFRoZSBDeXRvc2NhcGUgQ29uc29ydGl1bS5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mXG4gKiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSDigJxTb2Z0d2FyZeKAnSksIHRvIGRlYWwgaW5cbiAqIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG9cbiAqIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzXG4gKiBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG9cbiAqIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIOKAnEFTIElT4oCdLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiBTT0ZUV0FSRS5cbiAqL1xuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gIChnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGdsb2JhbC5jeXRvc2NhcGUgPSBmYWN0b3J5KCkpO1xufSkodGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gICAgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9IDogZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9LCBfdHlwZW9mKG9iaik7XG4gIH1cblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7XG4gICAgICB3cml0YWJsZTogZmFsc2VcbiAgICB9KTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH1cblxuICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkkMShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkge1xuICAgIHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7XG4gIH1cblxuICBmdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHtcbiAgICB2YXIgX2kgPSBhcnIgPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGFycltTeW1ib2wuaXRlcmF0b3JdIHx8IGFycltcIkBAaXRlcmF0b3JcIl07XG5cbiAgICBpZiAoX2kgPT0gbnVsbCkgcmV0dXJuO1xuICAgIHZhciBfYXJyID0gW107XG4gICAgdmFyIF9uID0gdHJ1ZTtcbiAgICB2YXIgX2QgPSBmYWxzZTtcblxuICAgIHZhciBfcywgX2U7XG5cbiAgICB0cnkge1xuICAgICAgZm9yIChfaSA9IF9pLmNhbGwoYXJyKTsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuXG4gICAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9kID0gdHJ1ZTtcbiAgICAgIF9lID0gZXJyO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBfYXJyO1xuICB9XG5cbiAgZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICAgIGlmICghbykgcmV0dXJuO1xuICAgIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gICAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICAgIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gICAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB9XG5cbiAgZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTtcblxuICAgIHJldHVybiBhcnIyO1xuICB9XG5cbiAgZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xuICB9XG5cbiAgdmFyIHdpbmRvdyQxID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogd2luZG93OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cbiAgdmFyIG5hdmlnYXRvciA9IHdpbmRvdyQxID8gd2luZG93JDEubmF2aWdhdG9yIDogbnVsbDtcbiAgd2luZG93JDEgPyB3aW5kb3ckMS5kb2N1bWVudCA6IG51bGw7XG5cbiAgdmFyIHR5cGVvZnN0ciA9IF90eXBlb2YoJycpO1xuXG4gIHZhciB0eXBlb2ZvYmogPSBfdHlwZW9mKHt9KTtcblxuICB2YXIgdHlwZW9mZm4gPSBfdHlwZW9mKGZ1bmN0aW9uICgpIHt9KTtcblxuICB2YXIgdHlwZW9maHRtbGVsZSA9IHR5cGVvZiBIVE1MRWxlbWVudCA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKEhUTUxFbGVtZW50KTtcblxuICB2YXIgaW5zdGFuY2VTdHIgPSBmdW5jdGlvbiBpbnN0YW5jZVN0cihvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5pbnN0YW5jZVN0cmluZyAmJiBmbiQ2KG9iai5pbnN0YW5jZVN0cmluZykgPyBvYmouaW5zdGFuY2VTdHJpbmcoKSA6IG51bGw7XG4gIH07XG5cbiAgdmFyIHN0cmluZyA9IGZ1bmN0aW9uIHN0cmluZyhvYmopIHtcbiAgICByZXR1cm4gb2JqICE9IG51bGwgJiYgX3R5cGVvZihvYmopID09IHR5cGVvZnN0cjtcbiAgfTtcbiAgdmFyIGZuJDYgPSBmdW5jdGlvbiBmbihvYmopIHtcbiAgICByZXR1cm4gb2JqICE9IG51bGwgJiYgX3R5cGVvZihvYmopID09PSB0eXBlb2ZmbjtcbiAgfTtcbiAgdmFyIGFycmF5ID0gZnVuY3Rpb24gYXJyYXkob2JqKSB7XG4gICAgcmV0dXJuICFlbGVtZW50T3JDb2xsZWN0aW9uKG9iaikgJiYgKEFycmF5LmlzQXJyYXkgPyBBcnJheS5pc0FycmF5KG9iaikgOiBvYmogIT0gbnVsbCAmJiBvYmogaW5zdGFuY2VvZiBBcnJheSk7XG4gIH07XG4gIHZhciBwbGFpbk9iamVjdCA9IGZ1bmN0aW9uIHBsYWluT2JqZWN0KG9iaikge1xuICAgIHJldHVybiBvYmogIT0gbnVsbCAmJiBfdHlwZW9mKG9iaikgPT09IHR5cGVvZm9iaiAmJiAhYXJyYXkob2JqKSAmJiBvYmouY29uc3RydWN0b3IgPT09IE9iamVjdDtcbiAgfTtcbiAgdmFyIG9iamVjdCA9IGZ1bmN0aW9uIG9iamVjdChvYmopIHtcbiAgICByZXR1cm4gb2JqICE9IG51bGwgJiYgX3R5cGVvZihvYmopID09PSB0eXBlb2ZvYmo7XG4gIH07XG4gIHZhciBudW1iZXIkMSA9IGZ1bmN0aW9uIG51bWJlcihvYmopIHtcbiAgICByZXR1cm4gb2JqICE9IG51bGwgJiYgX3R5cGVvZihvYmopID09PSBfdHlwZW9mKDEpICYmICFpc05hTihvYmopO1xuICB9O1xuICB2YXIgaW50ZWdlciA9IGZ1bmN0aW9uIGludGVnZXIob2JqKSB7XG4gICAgcmV0dXJuIG51bWJlciQxKG9iaikgJiYgTWF0aC5mbG9vcihvYmopID09PSBvYmo7XG4gIH07XG4gIHZhciBodG1sRWxlbWVudCA9IGZ1bmN0aW9uIGh0bWxFbGVtZW50KG9iaikge1xuICAgIGlmICgndW5kZWZpbmVkJyA9PT0gdHlwZW9maHRtbGVsZSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGwgIT0gb2JqICYmIG9iaiBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xuICAgIH1cbiAgfTtcbiAgdmFyIGVsZW1lbnRPckNvbGxlY3Rpb24gPSBmdW5jdGlvbiBlbGVtZW50T3JDb2xsZWN0aW9uKG9iaikge1xuICAgIHJldHVybiBlbGVtZW50KG9iaikgfHwgY29sbGVjdGlvbihvYmopO1xuICB9O1xuICB2YXIgZWxlbWVudCA9IGZ1bmN0aW9uIGVsZW1lbnQob2JqKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlU3RyKG9iaikgPT09ICdjb2xsZWN0aW9uJyAmJiBvYmouX3ByaXZhdGUuc2luZ2xlO1xuICB9O1xuICB2YXIgY29sbGVjdGlvbiA9IGZ1bmN0aW9uIGNvbGxlY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlU3RyKG9iaikgPT09ICdjb2xsZWN0aW9uJyAmJiAhb2JqLl9wcml2YXRlLnNpbmdsZTtcbiAgfTtcbiAgdmFyIGNvcmUgPSBmdW5jdGlvbiBjb3JlKG9iaikge1xuICAgIHJldHVybiBpbnN0YW5jZVN0cihvYmopID09PSAnY29yZSc7XG4gIH07XG4gIHZhciBzdHlsZXNoZWV0ID0gZnVuY3Rpb24gc3R5bGVzaGVldChvYmopIHtcbiAgICByZXR1cm4gaW5zdGFuY2VTdHIob2JqKSA9PT0gJ3N0eWxlc2hlZXQnO1xuICB9O1xuICB2YXIgZXZlbnQgPSBmdW5jdGlvbiBldmVudChvYmopIHtcbiAgICByZXR1cm4gaW5zdGFuY2VTdHIob2JqKSA9PT0gJ2V2ZW50JztcbiAgfTtcbiAgdmFyIGVtcHR5U3RyaW5nID0gZnVuY3Rpb24gZW1wdHlTdHJpbmcob2JqKSB7XG4gICAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkIHx8IG9iaiA9PT0gbnVsbCkge1xuICAgICAgLy8gbnVsbCBpcyBlbXB0eVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChvYmogPT09ICcnIHx8IG9iai5tYXRjaCgvXlxccyskLykpIHtcbiAgICAgIHJldHVybiB0cnVlOyAvLyBlbXB0eSBzdHJpbmcgaXMgZW1wdHlcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7IC8vIG90aGVyd2lzZSwgd2UgZG9uJ3Qga25vdyB3aGF0IHdlJ3ZlIGdvdFxuICB9O1xuICB2YXIgZG9tRWxlbWVudCA9IGZ1bmN0aW9uIGRvbUVsZW1lbnQob2JqKSB7XG4gICAgaWYgKHR5cGVvZiBIVE1MRWxlbWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBmYWxzZTsgLy8gd2UncmUgbm90IGluIGEgYnJvd3NlciBzbyBpdCBkb2Vzbid0IG1hdHRlclxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG4gICAgfVxuICB9O1xuICB2YXIgYm91bmRpbmdCb3ggPSBmdW5jdGlvbiBib3VuZGluZ0JveChvYmopIHtcbiAgICByZXR1cm4gcGxhaW5PYmplY3Qob2JqKSAmJiBudW1iZXIkMShvYmoueDEpICYmIG51bWJlciQxKG9iai54MikgJiYgbnVtYmVyJDEob2JqLnkxKSAmJiBudW1iZXIkMShvYmoueTIpO1xuICB9O1xuICB2YXIgcHJvbWlzZSA9IGZ1bmN0aW9uIHByb21pc2Uob2JqKSB7XG4gICAgcmV0dXJuIG9iamVjdChvYmopICYmIGZuJDYob2JqLnRoZW4pO1xuICB9O1xuICB2YXIgbXMgPSBmdW5jdGlvbiBtcygpIHtcbiAgICByZXR1cm4gbmF2aWdhdG9yICYmIG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL21zaWV8dHJpZGVudHxlZGdlL2kpO1xuICB9OyAvLyBwcm9iYWJseSBhIGJldHRlciB3YXkgdG8gZGV0ZWN0IHRoaXMuLi5cblxuICB2YXIgbWVtb2l6ZSQxID0gZnVuY3Rpb24gbWVtb2l6ZShmbiwga2V5Rm4pIHtcbiAgICBpZiAoIWtleUZuKSB7XG4gICAgICBrZXlGbiA9IGZ1bmN0aW9uIGtleUZuKCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHJldHVybiBhcmd1bWVudHNbMF07XG4gICAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiAndW5kZWZpbmVkJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhcmdzID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhcmdzLmpvaW4oJyQnKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIG1lbW9pemVkRm4gPSBmdW5jdGlvbiBtZW1vaXplZEZuKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICB2YXIgcmV0O1xuICAgICAgdmFyIGsgPSBrZXlGbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgIHZhciBjYWNoZSA9IG1lbW9pemVkRm4uY2FjaGU7XG5cbiAgICAgIGlmICghKHJldCA9IGNhY2hlW2tdKSkge1xuICAgICAgICByZXQgPSBjYWNoZVtrXSA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH07XG5cbiAgICBtZW1vaXplZEZuLmNhY2hlID0ge307XG4gICAgcmV0dXJuIG1lbW9pemVkRm47XG4gIH07XG5cbiAgdmFyIGNhbWVsMmRhc2ggPSBtZW1vaXplJDEoZnVuY3Rpb24gKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvKFtBLVpdKS9nLCBmdW5jdGlvbiAodikge1xuICAgICAgcmV0dXJuICctJyArIHYudG9Mb3dlckNhc2UoKTtcbiAgICB9KTtcbiAgfSk7XG4gIHZhciBkYXNoMmNhbWVsID0gbWVtb2l6ZSQxKGZ1bmN0aW9uIChzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLygtXFx3KS9nLCBmdW5jdGlvbiAodikge1xuICAgICAgcmV0dXJuIHZbMV0udG9VcHBlckNhc2UoKTtcbiAgICB9KTtcbiAgfSk7XG4gIHZhciBwcmVwZW5kQ2FtZWwgPSBtZW1vaXplJDEoZnVuY3Rpb24gKHByZWZpeCwgc3RyKSB7XG4gICAgcmV0dXJuIHByZWZpeCArIHN0clswXS50b1VwcGVyQ2FzZSgpICsgc3RyLnN1YnN0cmluZygxKTtcbiAgfSwgZnVuY3Rpb24gKHByZWZpeCwgc3RyKSB7XG4gICAgcmV0dXJuIHByZWZpeCArICckJyArIHN0cjtcbiAgfSk7XG4gIHZhciBjYXBpdGFsaXplID0gZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHIpIHtcbiAgICBpZiAoZW1wdHlTdHJpbmcoc3RyKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnN1YnN0cmluZygxKTtcbiAgfTtcblxuICB2YXIgbnVtYmVyID0gJyg/OlstK10/KD86KD86XFxcXGQrfFxcXFxkKlxcXFwuXFxcXGQrKSg/OltFZV1bKy1dP1xcXFxkKyk/KSknO1xuICB2YXIgcmdiYSA9ICdyZ2JbYV0/XFxcXCgoJyArIG51bWJlciArICdbJV0/KVxcXFxzKixcXFxccyooJyArIG51bWJlciArICdbJV0/KVxcXFxzKixcXFxccyooJyArIG51bWJlciArICdbJV0/KSg/OlxcXFxzKixcXFxccyooJyArIG51bWJlciArICcpKT9cXFxcKSc7XG4gIHZhciByZ2JhTm9CYWNrUmVmcyA9ICdyZ2JbYV0/XFxcXCgoPzonICsgbnVtYmVyICsgJ1slXT8pXFxcXHMqLFxcXFxzKig/OicgKyBudW1iZXIgKyAnWyVdPylcXFxccyosXFxcXHMqKD86JyArIG51bWJlciArICdbJV0/KSg/OlxcXFxzKixcXFxccyooPzonICsgbnVtYmVyICsgJykpP1xcXFwpJztcbiAgdmFyIGhzbGEgPSAnaHNsW2FdP1xcXFwoKCcgKyBudW1iZXIgKyAnKVxcXFxzKixcXFxccyooJyArIG51bWJlciArICdbJV0pXFxcXHMqLFxcXFxzKignICsgbnVtYmVyICsgJ1slXSkoPzpcXFxccyosXFxcXHMqKCcgKyBudW1iZXIgKyAnKSk/XFxcXCknO1xuICB2YXIgaHNsYU5vQmFja1JlZnMgPSAnaHNsW2FdP1xcXFwoKD86JyArIG51bWJlciArICcpXFxcXHMqLFxcXFxzKig/OicgKyBudW1iZXIgKyAnWyVdKVxcXFxzKixcXFxccyooPzonICsgbnVtYmVyICsgJ1slXSkoPzpcXFxccyosXFxcXHMqKD86JyArIG51bWJlciArICcpKT9cXFxcKSc7XG4gIHZhciBoZXgzID0gJ1xcXFwjWzAtOWEtZkEtRl17M30nO1xuICB2YXIgaGV4NiA9ICdcXFxcI1swLTlhLWZBLUZdezZ9JztcblxuICB2YXIgYXNjZW5kaW5nID0gZnVuY3Rpb24gYXNjZW5kaW5nKGEsIGIpIHtcbiAgICBpZiAoYSA8IGIpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9IGVsc2UgaWYgKGEgPiBiKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9O1xuICB2YXIgZGVzY2VuZGluZyA9IGZ1bmN0aW9uIGRlc2NlbmRpbmcoYSwgYikge1xuICAgIHJldHVybiAtMSAqIGFzY2VuZGluZyhhLCBiKTtcbiAgfTtcblxuICB2YXIgZXh0ZW5kID0gT2JqZWN0LmFzc2lnbiAhPSBudWxsID8gT2JqZWN0LmFzc2lnbi5iaW5kKE9iamVjdCkgOiBmdW5jdGlvbiAodGd0KSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG5cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBvYmogPSBhcmdzW2ldO1xuXG4gICAgICBpZiAob2JqID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBrZXlzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBrID0ga2V5c1tqXTtcbiAgICAgICAgdGd0W2tdID0gb2JqW2tdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0Z3Q7XG4gIH07XG5cbiAgdmFyIGhleDJ0dXBsZSA9IGZ1bmN0aW9uIGhleDJ0dXBsZShoZXgpIHtcbiAgICBpZiAoIShoZXgubGVuZ3RoID09PSA0IHx8IGhleC5sZW5ndGggPT09IDcpIHx8IGhleFswXSAhPT0gJyMnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHNob3J0SGV4ID0gaGV4Lmxlbmd0aCA9PT0gNDtcbiAgICB2YXIgciwgZywgYjtcbiAgICB2YXIgYmFzZSA9IDE2O1xuXG4gICAgaWYgKHNob3J0SGV4KSB7XG4gICAgICByID0gcGFyc2VJbnQoaGV4WzFdICsgaGV4WzFdLCBiYXNlKTtcbiAgICAgIGcgPSBwYXJzZUludChoZXhbMl0gKyBoZXhbMl0sIGJhc2UpO1xuICAgICAgYiA9IHBhcnNlSW50KGhleFszXSArIGhleFszXSwgYmFzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHIgPSBwYXJzZUludChoZXhbMV0gKyBoZXhbMl0sIGJhc2UpO1xuICAgICAgZyA9IHBhcnNlSW50KGhleFszXSArIGhleFs0XSwgYmFzZSk7XG4gICAgICBiID0gcGFyc2VJbnQoaGV4WzVdICsgaGV4WzZdLCBiYXNlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gW3IsIGcsIGJdO1xuICB9OyAvLyBnZXQgW3IsIGcsIGIsIGFdIGZyb20gaHNsKDAsIDAsIDApIG9yIGhzbGEoMCwgMCwgMCwgMClcblxuICB2YXIgaHNsMnR1cGxlID0gZnVuY3Rpb24gaHNsMnR1cGxlKGhzbCkge1xuICAgIHZhciByZXQ7XG4gICAgdmFyIGgsIHMsIGwsIGEsIHIsIGcsIGI7XG5cbiAgICBmdW5jdGlvbiBodWUycmdiKHAsIHEsIHQpIHtcbiAgICAgIGlmICh0IDwgMCkgdCArPSAxO1xuICAgICAgaWYgKHQgPiAxKSB0IC09IDE7XG4gICAgICBpZiAodCA8IDEgLyA2KSByZXR1cm4gcCArIChxIC0gcCkgKiA2ICogdDtcbiAgICAgIGlmICh0IDwgMSAvIDIpIHJldHVybiBxO1xuICAgICAgaWYgKHQgPCAyIC8gMykgcmV0dXJuIHAgKyAocSAtIHApICogKDIgLyAzIC0gdCkgKiA2O1xuICAgICAgcmV0dXJuIHA7XG4gICAgfVxuXG4gICAgdmFyIG0gPSBuZXcgUmVnRXhwKCdeJyArIGhzbGEgKyAnJCcpLmV4ZWMoaHNsKTtcblxuICAgIGlmIChtKSB7XG4gICAgICAvLyBnZXQgaHVlXG4gICAgICBoID0gcGFyc2VJbnQobVsxXSk7XG5cbiAgICAgIGlmIChoIDwgMCkge1xuICAgICAgICBoID0gKDM2MCAtIC0xICogaCAlIDM2MCkgJSAzNjA7XG4gICAgICB9IGVsc2UgaWYgKGggPiAzNjApIHtcbiAgICAgICAgaCA9IGggJSAzNjA7XG4gICAgICB9XG5cbiAgICAgIGggLz0gMzYwOyAvLyBub3JtYWxpc2Ugb24gWzAsIDFdXG5cbiAgICAgIHMgPSBwYXJzZUZsb2F0KG1bMl0pO1xuXG4gICAgICBpZiAocyA8IDAgfHwgcyA+IDEwMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIHNhdHVyYXRpb24gaXMgWzAsIDEwMF1cblxuXG4gICAgICBzID0gcyAvIDEwMDsgLy8gbm9ybWFsaXNlIG9uIFswLCAxXVxuXG4gICAgICBsID0gcGFyc2VGbG9hdChtWzNdKTtcblxuICAgICAgaWYgKGwgPCAwIHx8IGwgPiAxMDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBsaWdodG5lc3MgaXMgWzAsIDEwMF1cblxuXG4gICAgICBsID0gbCAvIDEwMDsgLy8gbm9ybWFsaXNlIG9uIFswLCAxXVxuXG4gICAgICBhID0gbVs0XTtcblxuICAgICAgaWYgKGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhID0gcGFyc2VGbG9hdChhKTtcblxuICAgICAgICBpZiAoYSA8IDAgfHwgYSA+IDEpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gYWxwaGEgaXMgWzAsIDFdXG5cbiAgICAgIH0gLy8gbm93LCBjb252ZXJ0IHRvIHJnYlxuICAgICAgLy8gY29kZSBmcm9tIGh0dHA6Ly9tamlqYWNrc29uLmNvbS8yMDA4LzAyL3JnYi10by1oc2wtYW5kLXJnYi10by1oc3YtY29sb3ItbW9kZWwtY29udmVyc2lvbi1hbGdvcml0aG1zLWluLWphdmFzY3JpcHRcblxuXG4gICAgICBpZiAocyA9PT0gMCkge1xuICAgICAgICByID0gZyA9IGIgPSBNYXRoLnJvdW5kKGwgKiAyNTUpOyAvLyBhY2hyb21hdGljXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcSA9IGwgPCAwLjUgPyBsICogKDEgKyBzKSA6IGwgKyBzIC0gbCAqIHM7XG4gICAgICAgIHZhciBwID0gMiAqIGwgLSBxO1xuICAgICAgICByID0gTWF0aC5yb3VuZCgyNTUgKiBodWUycmdiKHAsIHEsIGggKyAxIC8gMykpO1xuICAgICAgICBnID0gTWF0aC5yb3VuZCgyNTUgKiBodWUycmdiKHAsIHEsIGgpKTtcbiAgICAgICAgYiA9IE1hdGgucm91bmQoMjU1ICogaHVlMnJnYihwLCBxLCBoIC0gMSAvIDMpKTtcbiAgICAgIH1cblxuICAgICAgcmV0ID0gW3IsIGcsIGIsIGFdO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH07IC8vIGdldCBbciwgZywgYiwgYV0gZnJvbSByZ2IoMCwgMCwgMCkgb3IgcmdiYSgwLCAwLCAwLCAwKVxuXG4gIHZhciByZ2IydHVwbGUgPSBmdW5jdGlvbiByZ2IydHVwbGUocmdiKSB7XG4gICAgdmFyIHJldDtcbiAgICB2YXIgbSA9IG5ldyBSZWdFeHAoJ14nICsgcmdiYSArICckJykuZXhlYyhyZ2IpO1xuXG4gICAgaWYgKG0pIHtcbiAgICAgIHJldCA9IFtdO1xuICAgICAgdmFyIGlzUGN0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IDM7IGkrKykge1xuICAgICAgICB2YXIgY2hhbm5lbCA9IG1baV07XG5cbiAgICAgICAgaWYgKGNoYW5uZWxbY2hhbm5lbC5sZW5ndGggLSAxXSA9PT0gJyUnKSB7XG4gICAgICAgICAgaXNQY3RbaV0gPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hhbm5lbCA9IHBhcnNlRmxvYXQoY2hhbm5lbCk7XG5cbiAgICAgICAgaWYgKGlzUGN0W2ldKSB7XG4gICAgICAgICAgY2hhbm5lbCA9IGNoYW5uZWwgLyAxMDAgKiAyNTU7IC8vIG5vcm1hbGlzZSB0byBbMCwgMjU1XVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoYW5uZWwgPCAwIHx8IGNoYW5uZWwgPiAyNTUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gaW52YWxpZCBjaGFubmVsIHZhbHVlXG5cblxuICAgICAgICByZXQucHVzaChNYXRoLmZsb29yKGNoYW5uZWwpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGF0TGVhc3RPbmVJc1BjdCA9IGlzUGN0WzFdIHx8IGlzUGN0WzJdIHx8IGlzUGN0WzNdO1xuICAgICAgdmFyIGFsbEFyZVBjdCA9IGlzUGN0WzFdICYmIGlzUGN0WzJdICYmIGlzUGN0WzNdO1xuXG4gICAgICBpZiAoYXRMZWFzdE9uZUlzUGN0ICYmICFhbGxBcmVQY3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBtdXN0IGFsbCBiZSBwZXJjZW50IHZhbHVlcyBpZiBvbmUgaXNcblxuXG4gICAgICB2YXIgYWxwaGEgPSBtWzRdO1xuXG4gICAgICBpZiAoYWxwaGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhbHBoYSA9IHBhcnNlRmxvYXQoYWxwaGEpO1xuXG4gICAgICAgIGlmIChhbHBoYSA8IDAgfHwgYWxwaGEgPiAxKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIGludmFsaWQgYWxwaGEgdmFsdWVcblxuXG4gICAgICAgIHJldC5wdXNoKGFscGhhKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9O1xuICB2YXIgY29sb3JuYW1lMnR1cGxlID0gZnVuY3Rpb24gY29sb3JuYW1lMnR1cGxlKGNvbG9yKSB7XG4gICAgcmV0dXJuIGNvbG9yc1tjb2xvci50b0xvd2VyQ2FzZSgpXTtcbiAgfTtcbiAgdmFyIGNvbG9yMnR1cGxlID0gZnVuY3Rpb24gY29sb3IydHVwbGUoY29sb3IpIHtcbiAgICByZXR1cm4gKGFycmF5KGNvbG9yKSA/IGNvbG9yIDogbnVsbCkgfHwgY29sb3JuYW1lMnR1cGxlKGNvbG9yKSB8fCBoZXgydHVwbGUoY29sb3IpIHx8IHJnYjJ0dXBsZShjb2xvcikgfHwgaHNsMnR1cGxlKGNvbG9yKTtcbiAgfTtcbiAgdmFyIGNvbG9ycyA9IHtcbiAgICAvLyBzcGVjaWFsIGNvbG91ciBuYW1lc1xuICAgIHRyYW5zcGFyZW50OiBbMCwgMCwgMCwgMF0sXG4gICAgLy8gTkIgYWxwaGEgPT09IDBcbiAgICAvLyByZWd1bGFyIGNvbG91cnNcbiAgICBhbGljZWJsdWU6IFsyNDAsIDI0OCwgMjU1XSxcbiAgICBhbnRpcXVld2hpdGU6IFsyNTAsIDIzNSwgMjE1XSxcbiAgICBhcXVhOiBbMCwgMjU1LCAyNTVdLFxuICAgIGFxdWFtYXJpbmU6IFsxMjcsIDI1NSwgMjEyXSxcbiAgICBhenVyZTogWzI0MCwgMjU1LCAyNTVdLFxuICAgIGJlaWdlOiBbMjQ1LCAyNDUsIDIyMF0sXG4gICAgYmlzcXVlOiBbMjU1LCAyMjgsIDE5Nl0sXG4gICAgYmxhY2s6IFswLCAwLCAwXSxcbiAgICBibGFuY2hlZGFsbW9uZDogWzI1NSwgMjM1LCAyMDVdLFxuICAgIGJsdWU6IFswLCAwLCAyNTVdLFxuICAgIGJsdWV2aW9sZXQ6IFsxMzgsIDQzLCAyMjZdLFxuICAgIGJyb3duOiBbMTY1LCA0MiwgNDJdLFxuICAgIGJ1cmx5d29vZDogWzIyMiwgMTg0LCAxMzVdLFxuICAgIGNhZGV0Ymx1ZTogWzk1LCAxNTgsIDE2MF0sXG4gICAgY2hhcnRyZXVzZTogWzEyNywgMjU1LCAwXSxcbiAgICBjaG9jb2xhdGU6IFsyMTAsIDEwNSwgMzBdLFxuICAgIGNvcmFsOiBbMjU1LCAxMjcsIDgwXSxcbiAgICBjb3JuZmxvd2VyYmx1ZTogWzEwMCwgMTQ5LCAyMzddLFxuICAgIGNvcm5zaWxrOiBbMjU1LCAyNDgsIDIyMF0sXG4gICAgY3JpbXNvbjogWzIyMCwgMjAsIDYwXSxcbiAgICBjeWFuOiBbMCwgMjU1LCAyNTVdLFxuICAgIGRhcmtibHVlOiBbMCwgMCwgMTM5XSxcbiAgICBkYXJrY3lhbjogWzAsIDEzOSwgMTM5XSxcbiAgICBkYXJrZ29sZGVucm9kOiBbMTg0LCAxMzQsIDExXSxcbiAgICBkYXJrZ3JheTogWzE2OSwgMTY5LCAxNjldLFxuICAgIGRhcmtncmVlbjogWzAsIDEwMCwgMF0sXG4gICAgZGFya2dyZXk6IFsxNjksIDE2OSwgMTY5XSxcbiAgICBkYXJra2hha2k6IFsxODksIDE4MywgMTA3XSxcbiAgICBkYXJrbWFnZW50YTogWzEzOSwgMCwgMTM5XSxcbiAgICBkYXJrb2xpdmVncmVlbjogWzg1LCAxMDcsIDQ3XSxcbiAgICBkYXJrb3JhbmdlOiBbMjU1LCAxNDAsIDBdLFxuICAgIGRhcmtvcmNoaWQ6IFsxNTMsIDUwLCAyMDRdLFxuICAgIGRhcmtyZWQ6IFsxMzksIDAsIDBdLFxuICAgIGRhcmtzYWxtb246IFsyMzMsIDE1MCwgMTIyXSxcbiAgICBkYXJrc2VhZ3JlZW46IFsxNDMsIDE4OCwgMTQzXSxcbiAgICBkYXJrc2xhdGVibHVlOiBbNzIsIDYxLCAxMzldLFxuICAgIGRhcmtzbGF0ZWdyYXk6IFs0NywgNzksIDc5XSxcbiAgICBkYXJrc2xhdGVncmV5OiBbNDcsIDc5LCA3OV0sXG4gICAgZGFya3R1cnF1b2lzZTogWzAsIDIwNiwgMjA5XSxcbiAgICBkYXJrdmlvbGV0OiBbMTQ4LCAwLCAyMTFdLFxuICAgIGRlZXBwaW5rOiBbMjU1LCAyMCwgMTQ3XSxcbiAgICBkZWVwc2t5Ymx1ZTogWzAsIDE5MSwgMjU1XSxcbiAgICBkaW1ncmF5OiBbMTA1LCAxMDUsIDEwNV0sXG4gICAgZGltZ3JleTogWzEwNSwgMTA1LCAxMDVdLFxuICAgIGRvZGdlcmJsdWU6IFszMCwgMTQ0LCAyNTVdLFxuICAgIGZpcmVicmljazogWzE3OCwgMzQsIDM0XSxcbiAgICBmbG9yYWx3aGl0ZTogWzI1NSwgMjUwLCAyNDBdLFxuICAgIGZvcmVzdGdyZWVuOiBbMzQsIDEzOSwgMzRdLFxuICAgIGZ1Y2hzaWE6IFsyNTUsIDAsIDI1NV0sXG4gICAgZ2FpbnNib3JvOiBbMjIwLCAyMjAsIDIyMF0sXG4gICAgZ2hvc3R3aGl0ZTogWzI0OCwgMjQ4LCAyNTVdLFxuICAgIGdvbGQ6IFsyNTUsIDIxNSwgMF0sXG4gICAgZ29sZGVucm9kOiBbMjE4LCAxNjUsIDMyXSxcbiAgICBncmF5OiBbMTI4LCAxMjgsIDEyOF0sXG4gICAgZ3JleTogWzEyOCwgMTI4LCAxMjhdLFxuICAgIGdyZWVuOiBbMCwgMTI4LCAwXSxcbiAgICBncmVlbnllbGxvdzogWzE3MywgMjU1LCA0N10sXG4gICAgaG9uZXlkZXc6IFsyNDAsIDI1NSwgMjQwXSxcbiAgICBob3RwaW5rOiBbMjU1LCAxMDUsIDE4MF0sXG4gICAgaW5kaWFucmVkOiBbMjA1LCA5MiwgOTJdLFxuICAgIGluZGlnbzogWzc1LCAwLCAxMzBdLFxuICAgIGl2b3J5OiBbMjU1LCAyNTUsIDI0MF0sXG4gICAga2hha2k6IFsyNDAsIDIzMCwgMTQwXSxcbiAgICBsYXZlbmRlcjogWzIzMCwgMjMwLCAyNTBdLFxuICAgIGxhdmVuZGVyYmx1c2g6IFsyNTUsIDI0MCwgMjQ1XSxcbiAgICBsYXduZ3JlZW46IFsxMjQsIDI1MiwgMF0sXG4gICAgbGVtb25jaGlmZm9uOiBbMjU1LCAyNTAsIDIwNV0sXG4gICAgbGlnaHRibHVlOiBbMTczLCAyMTYsIDIzMF0sXG4gICAgbGlnaHRjb3JhbDogWzI0MCwgMTI4LCAxMjhdLFxuICAgIGxpZ2h0Y3lhbjogWzIyNCwgMjU1LCAyNTVdLFxuICAgIGxpZ2h0Z29sZGVucm9keWVsbG93OiBbMjUwLCAyNTAsIDIxMF0sXG4gICAgbGlnaHRncmF5OiBbMjExLCAyMTEsIDIxMV0sXG4gICAgbGlnaHRncmVlbjogWzE0NCwgMjM4LCAxNDRdLFxuICAgIGxpZ2h0Z3JleTogWzIxMSwgMjExLCAyMTFdLFxuICAgIGxpZ2h0cGluazogWzI1NSwgMTgyLCAxOTNdLFxuICAgIGxpZ2h0c2FsbW9uOiBbMjU1LCAxNjAsIDEyMl0sXG4gICAgbGlnaHRzZWFncmVlbjogWzMyLCAxNzgsIDE3MF0sXG4gICAgbGlnaHRza3libHVlOiBbMTM1LCAyMDYsIDI1MF0sXG4gICAgbGlnaHRzbGF0ZWdyYXk6IFsxMTksIDEzNiwgMTUzXSxcbiAgICBsaWdodHNsYXRlZ3JleTogWzExOSwgMTM2LCAxNTNdLFxuICAgIGxpZ2h0c3RlZWxibHVlOiBbMTc2LCAxOTYsIDIyMl0sXG4gICAgbGlnaHR5ZWxsb3c6IFsyNTUsIDI1NSwgMjI0XSxcbiAgICBsaW1lOiBbMCwgMjU1LCAwXSxcbiAgICBsaW1lZ3JlZW46IFs1MCwgMjA1LCA1MF0sXG4gICAgbGluZW46IFsyNTAsIDI0MCwgMjMwXSxcbiAgICBtYWdlbnRhOiBbMjU1LCAwLCAyNTVdLFxuICAgIG1hcm9vbjogWzEyOCwgMCwgMF0sXG4gICAgbWVkaXVtYXF1YW1hcmluZTogWzEwMiwgMjA1LCAxNzBdLFxuICAgIG1lZGl1bWJsdWU6IFswLCAwLCAyMDVdLFxuICAgIG1lZGl1bW9yY2hpZDogWzE4NiwgODUsIDIxMV0sXG4gICAgbWVkaXVtcHVycGxlOiBbMTQ3LCAxMTIsIDIxOV0sXG4gICAgbWVkaXVtc2VhZ3JlZW46IFs2MCwgMTc5LCAxMTNdLFxuICAgIG1lZGl1bXNsYXRlYmx1ZTogWzEyMywgMTA0LCAyMzhdLFxuICAgIG1lZGl1bXNwcmluZ2dyZWVuOiBbMCwgMjUwLCAxNTRdLFxuICAgIG1lZGl1bXR1cnF1b2lzZTogWzcyLCAyMDksIDIwNF0sXG4gICAgbWVkaXVtdmlvbGV0cmVkOiBbMTk5LCAyMSwgMTMzXSxcbiAgICBtaWRuaWdodGJsdWU6IFsyNSwgMjUsIDExMl0sXG4gICAgbWludGNyZWFtOiBbMjQ1LCAyNTUsIDI1MF0sXG4gICAgbWlzdHlyb3NlOiBbMjU1LCAyMjgsIDIyNV0sXG4gICAgbW9jY2FzaW46IFsyNTUsIDIyOCwgMTgxXSxcbiAgICBuYXZham93aGl0ZTogWzI1NSwgMjIyLCAxNzNdLFxuICAgIG5hdnk6IFswLCAwLCAxMjhdLFxuICAgIG9sZGxhY2U6IFsyNTMsIDI0NSwgMjMwXSxcbiAgICBvbGl2ZTogWzEyOCwgMTI4LCAwXSxcbiAgICBvbGl2ZWRyYWI6IFsxMDcsIDE0MiwgMzVdLFxuICAgIG9yYW5nZTogWzI1NSwgMTY1LCAwXSxcbiAgICBvcmFuZ2VyZWQ6IFsyNTUsIDY5LCAwXSxcbiAgICBvcmNoaWQ6IFsyMTgsIDExMiwgMjE0XSxcbiAgICBwYWxlZ29sZGVucm9kOiBbMjM4LCAyMzIsIDE3MF0sXG4gICAgcGFsZWdyZWVuOiBbMTUyLCAyNTEsIDE1Ml0sXG4gICAgcGFsZXR1cnF1b2lzZTogWzE3NSwgMjM4LCAyMzhdLFxuICAgIHBhbGV2aW9sZXRyZWQ6IFsyMTksIDExMiwgMTQ3XSxcbiAgICBwYXBheWF3aGlwOiBbMjU1LCAyMzksIDIxM10sXG4gICAgcGVhY2hwdWZmOiBbMjU1LCAyMTgsIDE4NV0sXG4gICAgcGVydTogWzIwNSwgMTMzLCA2M10sXG4gICAgcGluazogWzI1NSwgMTkyLCAyMDNdLFxuICAgIHBsdW06IFsyMjEsIDE2MCwgMjIxXSxcbiAgICBwb3dkZXJibHVlOiBbMTc2LCAyMjQsIDIzMF0sXG4gICAgcHVycGxlOiBbMTI4LCAwLCAxMjhdLFxuICAgIHJlZDogWzI1NSwgMCwgMF0sXG4gICAgcm9zeWJyb3duOiBbMTg4LCAxNDMsIDE0M10sXG4gICAgcm95YWxibHVlOiBbNjUsIDEwNSwgMjI1XSxcbiAgICBzYWRkbGVicm93bjogWzEzOSwgNjksIDE5XSxcbiAgICBzYWxtb246IFsyNTAsIDEyOCwgMTE0XSxcbiAgICBzYW5keWJyb3duOiBbMjQ0LCAxNjQsIDk2XSxcbiAgICBzZWFncmVlbjogWzQ2LCAxMzksIDg3XSxcbiAgICBzZWFzaGVsbDogWzI1NSwgMjQ1LCAyMzhdLFxuICAgIHNpZW5uYTogWzE2MCwgODIsIDQ1XSxcbiAgICBzaWx2ZXI6IFsxOTIsIDE5MiwgMTkyXSxcbiAgICBza3libHVlOiBbMTM1LCAyMDYsIDIzNV0sXG4gICAgc2xhdGVibHVlOiBbMTA2LCA5MCwgMjA1XSxcbiAgICBzbGF0ZWdyYXk6IFsxMTIsIDEyOCwgMTQ0XSxcbiAgICBzbGF0ZWdyZXk6IFsxMTIsIDEyOCwgMTQ0XSxcbiAgICBzbm93OiBbMjU1LCAyNTAsIDI1MF0sXG4gICAgc3ByaW5nZ3JlZW46IFswLCAyNTUsIDEyN10sXG4gICAgc3RlZWxibHVlOiBbNzAsIDEzMCwgMTgwXSxcbiAgICB0YW46IFsyMTAsIDE4MCwgMTQwXSxcbiAgICB0ZWFsOiBbMCwgMTI4LCAxMjhdLFxuICAgIHRoaXN0bGU6IFsyMTYsIDE5MSwgMjE2XSxcbiAgICB0b21hdG86IFsyNTUsIDk5LCA3MV0sXG4gICAgdHVycXVvaXNlOiBbNjQsIDIyNCwgMjA4XSxcbiAgICB2aW9sZXQ6IFsyMzgsIDEzMCwgMjM4XSxcbiAgICB3aGVhdDogWzI0NSwgMjIyLCAxNzldLFxuICAgIHdoaXRlOiBbMjU1LCAyNTUsIDI1NV0sXG4gICAgd2hpdGVzbW9rZTogWzI0NSwgMjQ1LCAyNDVdLFxuICAgIHllbGxvdzogWzI1NSwgMjU1LCAwXSxcbiAgICB5ZWxsb3dncmVlbjogWzE1NCwgMjA1LCA1MF1cbiAgfTtcblxuICB2YXIgc2V0TWFwID0gZnVuY3Rpb24gc2V0TWFwKG9wdGlvbnMpIHtcbiAgICB2YXIgb2JqID0gb3B0aW9ucy5tYXA7XG4gICAgdmFyIGtleXMgPSBvcHRpb25zLmtleXM7XG4gICAgdmFyIGwgPSBrZXlzLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKHBsYWluT2JqZWN0KGtleSkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ1RyaWVkIHRvIHNldCBtYXAgd2l0aCBvYmplY3Qga2V5Jyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpIDwga2V5cy5sZW5ndGggLSAxKSB7XG4gICAgICAgIC8vIGV4dGVuZCB0aGUgbWFwIGlmIG5lY2Vzc2FyeVxuICAgICAgICBpZiAob2JqW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgIG9ialtrZXldID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBvYmogPSBvYmpba2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHNldCB0aGUgdmFsdWVcbiAgICAgICAgb2JqW2tleV0gPSBvcHRpb25zLnZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfTsgLy8gZ2V0cyB0aGUgdmFsdWUgaW4gYSBtYXAgZXZlbiBpZiBpdCdzIG5vdCBidWlsdCBpbiBwbGFjZXNcblxuICB2YXIgZ2V0TWFwID0gZnVuY3Rpb24gZ2V0TWFwKG9wdGlvbnMpIHtcbiAgICB2YXIgb2JqID0gb3B0aW9ucy5tYXA7XG4gICAgdmFyIGtleXMgPSBvcHRpb25zLmtleXM7XG4gICAgdmFyIGwgPSBrZXlzLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKHBsYWluT2JqZWN0KGtleSkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ1RyaWVkIHRvIGdldCBtYXAgd2l0aCBvYmplY3Qga2V5Jyk7XG4gICAgICB9XG5cbiAgICAgIG9iaiA9IG9ialtrZXldO1xuXG4gICAgICBpZiAob2JqID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xuICB9OyAvLyBkZWxldGVzIHRoZSBlbnRyeSBpbiB0aGUgbWFwXG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICAgKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gICAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgMC4xLjBcbiAgICogQGNhdGVnb3J5IExhbmdcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLmlzT2JqZWN0KHt9KTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogXy5pc09iamVjdChfLm5vb3ApO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIF8uaXNPYmplY3QobnVsbCk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqL1xuICBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG4gIH1cblxuICB2YXIgaXNPYmplY3RfMSA9IGlzT2JqZWN0O1xuXG4gIHZhciBjb21tb25qc0dsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9O1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZuLCBtb2R1bGUpIHtcbiAgXHRyZXR1cm4gbW9kdWxlID0geyBleHBvcnRzOiB7fSB9LCBmbihtb2R1bGUsIG1vZHVsZS5leHBvcnRzKSwgbW9kdWxlLmV4cG9ydHM7XG4gIH1cblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xuICB2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBjb21tb25qc0dsb2JhbCA9PSAnb2JqZWN0JyAmJiBjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBjb21tb25qc0dsb2JhbDtcblxuICB2YXIgX2ZyZWVHbG9iYWwgPSBmcmVlR2xvYmFsO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG4gIHZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4gIC8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xuICB2YXIgcm9vdCA9IF9mcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbiAgdmFyIF9yb290ID0gcm9vdDtcblxuICAvKipcbiAgICogR2V0cyB0aGUgdGltZXN0YW1wIG9mIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlXG4gICAqIHRoZSBVbml4IGVwb2NoICgxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSAyLjQuMFxuICAgKiBAY2F0ZWdvcnkgRGF0ZVxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lc3RhbXAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uZGVmZXIoZnVuY3Rpb24oc3RhbXApIHtcbiAgICogICBjb25zb2xlLmxvZyhfLm5vdygpIC0gc3RhbXApO1xuICAgKiB9LCBfLm5vdygpKTtcbiAgICogLy8gPT4gTG9ncyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBpdCB0b29rIGZvciB0aGUgZGVmZXJyZWQgaW52b2NhdGlvbi5cbiAgICovXG4gIHZhciBub3cgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gX3Jvb3QuRGF0ZS5ub3coKTtcbiAgfTtcblxuICB2YXIgbm93XzEgPSBub3c7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggYSBzaW5nbGUgd2hpdGVzcGFjZSBjaGFyYWN0ZXIuICovXG4gIHZhciByZVdoaXRlc3BhY2UgPSAvXFxzLztcblxuICAvKipcbiAgICogVXNlZCBieSBgXy50cmltYCBhbmQgYF8udHJpbUVuZGAgdG8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgbGFzdCBub24td2hpdGVzcGFjZVxuICAgKiBjaGFyYWN0ZXIgb2YgYHN0cmluZ2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbGFzdCBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXIuXG4gICAqL1xuICBmdW5jdGlvbiB0cmltbWVkRW5kSW5kZXgoc3RyaW5nKSB7XG4gICAgdmFyIGluZGV4ID0gc3RyaW5nLmxlbmd0aDtcblxuICAgIHdoaWxlIChpbmRleC0tICYmIHJlV2hpdGVzcGFjZS50ZXN0KHN0cmluZy5jaGFyQXQoaW5kZXgpKSkge31cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICB2YXIgX3RyaW1tZWRFbmRJbmRleCA9IHRyaW1tZWRFbmRJbmRleDtcblxuICAvKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIHdoaXRlc3BhY2UuICovXG4gIHZhciByZVRyaW1TdGFydCA9IC9eXFxzKy87XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRyaW1gLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gdHJpbS5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdHJpbW1lZCBzdHJpbmcuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlVHJpbShzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nXG4gICAgICA/IHN0cmluZy5zbGljZSgwLCBfdHJpbW1lZEVuZEluZGV4KHN0cmluZykgKyAxKS5yZXBsYWNlKHJlVHJpbVN0YXJ0LCAnJylcbiAgICAgIDogc3RyaW5nO1xuICB9XG5cbiAgdmFyIF9iYXNlVHJpbSA9IGJhc2VUcmltO1xuXG4gIC8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xuICB2YXIgU3ltYm9sJDEgPSBfcm9vdC5TeW1ib2w7XG5cbiAgdmFyIF9TeW1ib2wgPSBTeW1ib2wkMTtcblxuICAvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG4gIHZhciBvYmplY3RQcm90byQ1ID0gT2JqZWN0LnByb3RvdHlwZTtcblxuICAvKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbiAgdmFyIGhhc093blByb3BlcnR5JDQgPSBvYmplY3RQcm90byQ1Lmhhc093blByb3BlcnR5O1xuXG4gIC8qKlxuICAgKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gICAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICAgKiBvZiB2YWx1ZXMuXG4gICAqL1xuICB2YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmckMSA9IG9iamVjdFByb3RvJDUudG9TdHJpbmc7XG5cbiAgLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG4gIHZhciBzeW1Ub1N0cmluZ1RhZyQxID0gX1N5bWJvbCA/IF9TeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAgICovXG4gIGZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICAgIHZhciBpc093biA9IGhhc093blByb3BlcnR5JDQuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWckMSksXG4gICAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnJDFdO1xuXG4gICAgdHJ5IHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnJDFdID0gdW5kZWZpbmVkO1xuICAgICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7fVxuXG4gICAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nJDEuY2FsbCh2YWx1ZSk7XG4gICAgaWYgKHVubWFza2VkKSB7XG4gICAgICBpZiAoaXNPd24pIHtcbiAgICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWckMV0gPSB0YWc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWckMV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgX2dldFJhd1RhZyA9IGdldFJhd1RhZztcblxuICAvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG4gIHZhciBvYmplY3RQcm90byQ0ID0gT2JqZWN0LnByb3RvdHlwZTtcblxuICAvKipcbiAgICogVXNlZCB0byByZXNvbHZlIHRoZVxuICAgKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAgICogb2YgdmFsdWVzLlxuICAgKi9cbiAgdmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8kNC50b1N0cmluZztcblxuICAvKipcbiAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gICAqL1xuICBmdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIHZhciBfb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RUb1N0cmluZztcblxuICAvKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG4gIHZhciBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxuICAgICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXSc7XG5cbiAgLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG4gIHZhciBzeW1Ub1N0cmluZ1RhZyA9IF9TeW1ib2wgPyBfU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICAgIH1cbiAgICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgICA/IF9nZXRSYXdUYWcodmFsdWUpXG4gICAgICA6IF9vYmplY3RUb1N0cmluZyh2YWx1ZSk7XG4gIH1cblxuICB2YXIgX2Jhc2VHZXRUYWcgPSBiYXNlR2V0VGFnO1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAgICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSA0LjAuMFxuICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5pc09iamVjdExpa2Uoe30pO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICpcbiAgICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqL1xuICBmdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG4gIH1cblxuICB2YXIgaXNPYmplY3RMaWtlXzEgPSBpc09iamVjdExpa2U7XG5cbiAgLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xuICB2YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSA0LjAuMFxuICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKi9cbiAgZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgICAoaXNPYmplY3RMaWtlXzEodmFsdWUpICYmIF9iYXNlR2V0VGFnKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xuICB9XG5cbiAgdmFyIGlzU3ltYm9sXzEgPSBpc1N5bWJvbDtcblxuICAvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbiAgdmFyIE5BTiA9IDAgLyAwO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBiYWQgc2lnbmVkIGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXG4gIHZhciByZUlzQmFkSGV4ID0gL15bLStdMHhbMC05YS1mXSskL2k7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGJpbmFyeSBzdHJpbmcgdmFsdWVzLiAqL1xuICB2YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTtcblxuICAvKiogVXNlZCB0byBkZXRlY3Qgb2N0YWwgc3RyaW5nIHZhbHVlcy4gKi9cbiAgdmFyIHJlSXNPY3RhbCA9IC9eMG9bMC03XSskL2k7XG5cbiAgLyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cbiAgdmFyIGZyZWVQYXJzZUludCA9IHBhcnNlSW50O1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgbnVtYmVyLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSA0LjAuMFxuICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8udG9OdW1iZXIoMy4yKTtcbiAgICogLy8gPT4gMy4yXG4gICAqXG4gICAqIF8udG9OdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAqIC8vID0+IDVlLTMyNFxuICAgKlxuICAgKiBfLnRvTnVtYmVyKEluZmluaXR5KTtcbiAgICogLy8gPT4gSW5maW5pdHlcbiAgICpcbiAgICogXy50b051bWJlcignMy4yJyk7XG4gICAqIC8vID0+IDMuMlxuICAgKi9cbiAgZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmIChpc1N5bWJvbF8xKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIE5BTjtcbiAgICB9XG4gICAgaWYgKGlzT2JqZWN0XzEodmFsdWUpKSB7XG4gICAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG4gICAgICB2YWx1ZSA9IGlzT2JqZWN0XzEob3RoZXIpID8gKG90aGVyICsgJycpIDogb3RoZXI7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuICAgIH1cbiAgICB2YWx1ZSA9IF9iYXNlVHJpbSh2YWx1ZSk7XG4gICAgdmFyIGlzQmluYXJ5ID0gcmVJc0JpbmFyeS50ZXN0KHZhbHVlKTtcbiAgICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcbiAgICAgID8gZnJlZVBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCBpc0JpbmFyeSA/IDIgOiA4KVxuICAgICAgOiAocmVJc0JhZEhleC50ZXN0KHZhbHVlKSA/IE5BTiA6ICt2YWx1ZSk7XG4gIH1cblxuICB2YXIgdG9OdW1iZXJfMSA9IHRvTnVtYmVyO1xuXG4gIC8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbiAgdmFyIEZVTkNfRVJST1JfVEVYVCQxID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4gIC8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbiAgdmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4LFxuICAgICAgbmF0aXZlTWluID0gTWF0aC5taW47XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBkZWJvdW5jZWQgZnVuY3Rpb24gdGhhdCBkZWxheXMgaW52b2tpbmcgYGZ1bmNgIHVudGlsIGFmdGVyIGB3YWl0YFxuICAgKiBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgdGhlIGRlYm91bmNlZCBmdW5jdGlvbiB3YXNcbiAgICogaW52b2tlZC4gVGhlIGRlYm91bmNlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGAgbWV0aG9kIHRvIGNhbmNlbFxuICAgKiBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0byBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS5cbiAgICogUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2Agc2hvdWxkIGJlIGludm9rZWQgb24gdGhlXG4gICAqIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YCB0aW1lb3V0LiBUaGUgYGZ1bmNgIGlzIGludm9rZWRcbiAgICogd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbi4gU3Vic2VxdWVudFxuICAgKiBjYWxscyB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYFxuICAgKiBpbnZvY2F0aW9uLlxuICAgKlxuICAgKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG4gICAqIGludm9rZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uXG4gICAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAgICpcbiAgICogSWYgYHdhaXRgIGlzIGAwYCBhbmQgYGxlYWRpbmdgIGlzIGBmYWxzZWAsIGBmdW5jYCBpbnZvY2F0aW9uIGlzIGRlZmVycmVkXG4gICAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cbiAgICpcbiAgICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vZGVib3VuY2luZy10aHJvdHRsaW5nLWV4cGxhaW5lZC1leGFtcGxlcy8pXG4gICAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8uZGVib3VuY2VgIGFuZCBgXy50aHJvdHRsZWAuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDAuMS4wXG4gICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWJvdW5jZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5LlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPWZhbHNlXVxuICAgKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4V2FpdF1cbiAgICogIFRoZSBtYXhpbXVtIHRpbWUgYGZ1bmNgIGlzIGFsbG93ZWQgdG8gYmUgZGVsYXllZCBiZWZvcmUgaXQncyBpbnZva2VkLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXG4gICAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBkZWJvdW5jZWQgZnVuY3Rpb24uXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIC8vIEF2b2lkIGNvc3RseSBjYWxjdWxhdGlvbnMgd2hpbGUgdGhlIHdpbmRvdyBzaXplIGlzIGluIGZsdXguXG4gICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdyZXNpemUnLCBfLmRlYm91bmNlKGNhbGN1bGF0ZUxheW91dCwgMTUwKSk7XG4gICAqXG4gICAqIC8vIEludm9rZSBgc2VuZE1haWxgIHdoZW4gY2xpY2tlZCwgZGVib3VuY2luZyBzdWJzZXF1ZW50IGNhbGxzLlxuICAgKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgXy5kZWJvdW5jZShzZW5kTWFpbCwgMzAwLCB7XG4gICAqICAgJ2xlYWRpbmcnOiB0cnVlLFxuICAgKiAgICd0cmFpbGluZyc6IGZhbHNlXG4gICAqIH0pKTtcbiAgICpcbiAgICogLy8gRW5zdXJlIGBiYXRjaExvZ2AgaXMgaW52b2tlZCBvbmNlIGFmdGVyIDEgc2Vjb25kIG9mIGRlYm91bmNlZCBjYWxscy5cbiAgICogdmFyIGRlYm91bmNlZCA9IF8uZGVib3VuY2UoYmF0Y2hMb2csIDI1MCwgeyAnbWF4V2FpdCc6IDEwMDAgfSk7XG4gICAqIHZhciBzb3VyY2UgPSBuZXcgRXZlbnRTb3VyY2UoJy9zdHJlYW0nKTtcbiAgICogalF1ZXJ5KHNvdXJjZSkub24oJ21lc3NhZ2UnLCBkZWJvdW5jZWQpO1xuICAgKlxuICAgKiAvLyBDYW5jZWwgdGhlIHRyYWlsaW5nIGRlYm91bmNlZCBpbnZvY2F0aW9uLlxuICAgKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCBkZWJvdW5jZWQuY2FuY2VsKTtcbiAgICovXG4gIGZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICB2YXIgbGFzdEFyZ3MsXG4gICAgICAgIGxhc3RUaGlzLFxuICAgICAgICBtYXhXYWl0LFxuICAgICAgICByZXN1bHQsXG4gICAgICAgIHRpbWVySWQsXG4gICAgICAgIGxhc3RDYWxsVGltZSxcbiAgICAgICAgbGFzdEludm9rZVRpbWUgPSAwLFxuICAgICAgICBsZWFkaW5nID0gZmFsc2UsXG4gICAgICAgIG1heGluZyA9IGZhbHNlLFxuICAgICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQkMSk7XG4gICAgfVxuICAgIHdhaXQgPSB0b051bWJlcl8xKHdhaXQpIHx8IDA7XG4gICAgaWYgKGlzT2JqZWN0XzEob3B0aW9ucykpIHtcbiAgICAgIGxlYWRpbmcgPSAhIW9wdGlvbnMubGVhZGluZztcbiAgICAgIG1heGluZyA9ICdtYXhXYWl0JyBpbiBvcHRpb25zO1xuICAgICAgbWF4V2FpdCA9IG1heGluZyA/IG5hdGl2ZU1heCh0b051bWJlcl8xKG9wdGlvbnMubWF4V2FpdCkgfHwgMCwgd2FpdCkgOiBtYXhXYWl0O1xuICAgICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnZva2VGdW5jKHRpbWUpIHtcbiAgICAgIHZhciBhcmdzID0gbGFzdEFyZ3MsXG4gICAgICAgICAgdGhpc0FyZyA9IGxhc3RUaGlzO1xuXG4gICAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGVhZGluZ0VkZ2UodGltZSkge1xuICAgICAgLy8gUmVzZXQgYW55IGBtYXhXYWl0YCB0aW1lci5cbiAgICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICAgIC8vIFN0YXJ0IHRoZSB0aW1lciBmb3IgdGhlIHRyYWlsaW5nIGVkZ2UuXG4gICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgICAgLy8gSW52b2tlIHRoZSBsZWFkaW5nIGVkZ2UuXG4gICAgICByZXR1cm4gbGVhZGluZyA/IGludm9rZUZ1bmModGltZSkgOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtYWluaW5nV2FpdCh0aW1lKSB7XG4gICAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuICAgICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWUsXG4gICAgICAgICAgdGltZVdhaXRpbmcgPSB3YWl0IC0gdGltZVNpbmNlTGFzdENhbGw7XG5cbiAgICAgIHJldHVybiBtYXhpbmdcbiAgICAgICAgPyBuYXRpdmVNaW4odGltZVdhaXRpbmcsIG1heFdhaXQgLSB0aW1lU2luY2VMYXN0SW52b2tlKVxuICAgICAgICA6IHRpbWVXYWl0aW5nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNob3VsZEludm9rZSh0aW1lKSB7XG4gICAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuICAgICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWU7XG5cbiAgICAgIC8vIEVpdGhlciB0aGlzIGlzIHRoZSBmaXJzdCBjYWxsLCBhY3Rpdml0eSBoYXMgc3RvcHBlZCBhbmQgd2UncmUgYXQgdGhlXG4gICAgICAvLyB0cmFpbGluZyBlZGdlLCB0aGUgc3lzdGVtIHRpbWUgaGFzIGdvbmUgYmFja3dhcmRzIGFuZCB3ZSdyZSB0cmVhdGluZ1xuICAgICAgLy8gaXQgYXMgdGhlIHRyYWlsaW5nIGVkZ2UsIG9yIHdlJ3ZlIGhpdCB0aGUgYG1heFdhaXRgIGxpbWl0LlxuICAgICAgcmV0dXJuIChsYXN0Q2FsbFRpbWUgPT09IHVuZGVmaW5lZCB8fCAodGltZVNpbmNlTGFzdENhbGwgPj0gd2FpdCkgfHxcbiAgICAgICAgKHRpbWVTaW5jZUxhc3RDYWxsIDwgMCkgfHwgKG1heGluZyAmJiB0aW1lU2luY2VMYXN0SW52b2tlID49IG1heFdhaXQpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0aW1lckV4cGlyZWQoKSB7XG4gICAgICB2YXIgdGltZSA9IG5vd18xKCk7XG4gICAgICBpZiAoc2hvdWxkSW52b2tlKHRpbWUpKSB7XG4gICAgICAgIHJldHVybiB0cmFpbGluZ0VkZ2UodGltZSk7XG4gICAgICB9XG4gICAgICAvLyBSZXN0YXJ0IHRoZSB0aW1lci5cbiAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgcmVtYWluaW5nV2FpdCh0aW1lKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJhaWxpbmdFZGdlKHRpbWUpIHtcbiAgICAgIHRpbWVySWQgPSB1bmRlZmluZWQ7XG5cbiAgICAgIC8vIE9ubHkgaW52b2tlIGlmIHdlIGhhdmUgYGxhc3RBcmdzYCB3aGljaCBtZWFucyBgZnVuY2AgaGFzIGJlZW5cbiAgICAgIC8vIGRlYm91bmNlZCBhdCBsZWFzdCBvbmNlLlxuICAgICAgaWYgKHRyYWlsaW5nICYmIGxhc3RBcmdzKSB7XG4gICAgICAgIHJldHVybiBpbnZva2VGdW5jKHRpbWUpO1xuICAgICAgfVxuICAgICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgICAgaWYgKHRpbWVySWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgICB9XG4gICAgICBsYXN0SW52b2tlVGltZSA9IDA7XG4gICAgICBsYXN0QXJncyA9IGxhc3RDYWxsVGltZSA9IGxhc3RUaGlzID0gdGltZXJJZCA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICAgIHJldHVybiB0aW1lcklkID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiB0cmFpbGluZ0VkZ2Uobm93XzEoKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVib3VuY2VkKCkge1xuICAgICAgdmFyIHRpbWUgPSBub3dfMSgpLFxuICAgICAgICAgIGlzSW52b2tpbmcgPSBzaG91bGRJbnZva2UodGltZSk7XG5cbiAgICAgIGxhc3RBcmdzID0gYXJndW1lbnRzO1xuICAgICAgbGFzdFRoaXMgPSB0aGlzO1xuICAgICAgbGFzdENhbGxUaW1lID0gdGltZTtcblxuICAgICAgaWYgKGlzSW52b2tpbmcpIHtcbiAgICAgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBsZWFkaW5nRWRnZShsYXN0Q2FsbFRpbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXhpbmcpIHtcbiAgICAgICAgICAvLyBIYW5kbGUgaW52b2NhdGlvbnMgaW4gYSB0aWdodCBsb29wLlxuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcklkKTtcbiAgICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgICAgICAgIHJldHVybiBpbnZva2VGdW5jKGxhc3RDYWxsVGltZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGRlYm91bmNlZC5jYW5jZWwgPSBjYW5jZWw7XG4gICAgZGVib3VuY2VkLmZsdXNoID0gZmx1c2g7XG4gICAgcmV0dXJuIGRlYm91bmNlZDtcbiAgfVxuXG4gIHZhciBkZWJvdW5jZV8xID0gZGVib3VuY2U7XG5cbiAgdmFyIHBlcmZvcm1hbmNlID0gd2luZG93JDEgPyB3aW5kb3ckMS5wZXJmb3JtYW5jZSA6IG51bGw7XG4gIHZhciBwbm93ID0gcGVyZm9ybWFuY2UgJiYgcGVyZm9ybWFuY2Uubm93ID8gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtcbiAgfSA6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gRGF0ZS5ub3coKTtcbiAgfTtcblxuICB2YXIgcmFmID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh3aW5kb3ckMSkge1xuICAgICAgaWYgKHdpbmRvdyQxLnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgd2luZG93JDEucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZuKTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAod2luZG93JDEubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICB3aW5kb3ckMS5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZm4pO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmICh3aW5kb3ckMS53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgIHdpbmRvdyQxLndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZShmbik7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKHdpbmRvdyQxLm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICB3aW5kb3ckMS5tc1JlcXVlc3RBbmltYXRpb25GcmFtZShmbik7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChmbikge1xuICAgICAgaWYgKGZuKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGZuKHBub3coKSk7XG4gICAgICAgIH0sIDEwMDAgLyA2MCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSgpO1xuXG4gIHZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZm4pIHtcbiAgICByZXR1cm4gcmFmKGZuKTtcbiAgfTtcbiAgdmFyIHBlcmZvcm1hbmNlTm93ID0gcG5vdztcblxuICB2YXIgREVGQVVMVF9IQVNIX1NFRUQgPSA5MjYxO1xuICB2YXIgSyA9IDY1NTk5OyAvLyAzNyBhbHNvIHdvcmtzIHByZXR0eSB3ZWxsXG5cbiAgdmFyIERFRkFVTFRfSEFTSF9TRUVEX0FMVCA9IDUzODE7XG4gIHZhciBoYXNoSXRlcmFibGVJbnRzID0gZnVuY3Rpb24gaGFzaEl0ZXJhYmxlSW50cyhpdGVyYXRvcikge1xuICAgIHZhciBzZWVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBERUZBVUxUX0hBU0hfU0VFRDtcbiAgICAvLyBzZGJtL3N0cmluZy1oYXNoXG4gICAgdmFyIGhhc2ggPSBzZWVkO1xuICAgIHZhciBlbnRyeTtcblxuICAgIGZvciAoOzspIHtcbiAgICAgIGVudHJ5ID0gaXRlcmF0b3IubmV4dCgpO1xuXG4gICAgICBpZiAoZW50cnkuZG9uZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaGFzaCA9IGhhc2ggKiBLICsgZW50cnkudmFsdWUgfCAwO1xuICAgIH1cblxuICAgIHJldHVybiBoYXNoO1xuICB9O1xuICB2YXIgaGFzaEludCA9IGZ1bmN0aW9uIGhhc2hJbnQobnVtKSB7XG4gICAgdmFyIHNlZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IERFRkFVTFRfSEFTSF9TRUVEO1xuICAgIC8vIHNkYm0vc3RyaW5nLWhhc2hcbiAgICByZXR1cm4gc2VlZCAqIEsgKyBudW0gfCAwO1xuICB9O1xuICB2YXIgaGFzaEludEFsdCA9IGZ1bmN0aW9uIGhhc2hJbnRBbHQobnVtKSB7XG4gICAgdmFyIHNlZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IERFRkFVTFRfSEFTSF9TRUVEX0FMVDtcbiAgICAvLyBkamIyL3N0cmluZy1oYXNoXG4gICAgcmV0dXJuIChzZWVkIDw8IDUpICsgc2VlZCArIG51bSB8IDA7XG4gIH07XG4gIHZhciBjb21iaW5lSGFzaGVzID0gZnVuY3Rpb24gY29tYmluZUhhc2hlcyhoYXNoMSwgaGFzaDIpIHtcbiAgICByZXR1cm4gaGFzaDEgKiAweDIwMDAwMCArIGhhc2gyO1xuICB9O1xuICB2YXIgY29tYmluZUhhc2hlc0FycmF5ID0gZnVuY3Rpb24gY29tYmluZUhhc2hlc0FycmF5KGhhc2hlcykge1xuICAgIHJldHVybiBoYXNoZXNbMF0gKiAweDIwMDAwMCArIGhhc2hlc1sxXTtcbiAgfTtcbiAgdmFyIGhhc2hBcnJheXMgPSBmdW5jdGlvbiBoYXNoQXJyYXlzKGhhc2hlczEsIGhhc2hlczIpIHtcbiAgICByZXR1cm4gW2hhc2hJbnQoaGFzaGVzMVswXSwgaGFzaGVzMlswXSksIGhhc2hJbnRBbHQoaGFzaGVzMVsxXSwgaGFzaGVzMlsxXSldO1xuICB9O1xuICB2YXIgaGFzaEludHNBcnJheSA9IGZ1bmN0aW9uIGhhc2hJbnRzQXJyYXkoaW50cywgc2VlZCkge1xuICAgIHZhciBlbnRyeSA9IHtcbiAgICAgIHZhbHVlOiAwLFxuICAgICAgZG9uZTogZmFsc2VcbiAgICB9O1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuZ3RoID0gaW50cy5sZW5ndGg7XG4gICAgdmFyIGl0ZXJhdG9yID0ge1xuICAgICAgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgaWYgKGkgPCBsZW5ndGgpIHtcbiAgICAgICAgICBlbnRyeS52YWx1ZSA9IGludHNbaSsrXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbnRyeS5kb25lID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlbnRyeTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBoYXNoSXRlcmFibGVJbnRzKGl0ZXJhdG9yLCBzZWVkKTtcbiAgfTtcbiAgdmFyIGhhc2hTdHJpbmcgPSBmdW5jdGlvbiBoYXNoU3RyaW5nKHN0ciwgc2VlZCkge1xuICAgIHZhciBlbnRyeSA9IHtcbiAgICAgIHZhbHVlOiAwLFxuICAgICAgZG9uZTogZmFsc2VcbiAgICB9O1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgICB2YXIgaXRlcmF0b3IgPSB7XG4gICAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICBpZiAoaSA8IGxlbmd0aCkge1xuICAgICAgICAgIGVudHJ5LnZhbHVlID0gc3RyLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbnRyeS5kb25lID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlbnRyeTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBoYXNoSXRlcmFibGVJbnRzKGl0ZXJhdG9yLCBzZWVkKTtcbiAgfTtcbiAgdmFyIGhhc2hTdHJpbmdzID0gZnVuY3Rpb24gaGFzaFN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIGhhc2hTdHJpbmdzQXJyYXkoYXJndW1lbnRzKTtcbiAgfTtcbiAgdmFyIGhhc2hTdHJpbmdzQXJyYXkgPSBmdW5jdGlvbiBoYXNoU3RyaW5nc0FycmF5KHN0cnMpIHtcbiAgICB2YXIgaGFzaDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3Rycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHN0ciA9IHN0cnNbaV07XG5cbiAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgIGhhc2ggPSBoYXNoU3RyaW5nKHN0cik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoYXNoID0gaGFzaFN0cmluZyhzdHIsIGhhc2gpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBoYXNoO1xuICB9O1xuXG4gIC8qZ2xvYmFsIGNvbnNvbGUgKi9cbiAgdmFyIHdhcm5pbmdzRW5hYmxlZCA9IHRydWU7XG4gIHZhciB3YXJuU3VwcG9ydGVkID0gY29uc29sZS53YXJuICE9IG51bGw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuXG4gIHZhciB0cmFjZVN1cHBvcnRlZCA9IGNvbnNvbGUudHJhY2UgIT0gbnVsbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG5cbiAgdmFyIE1BWF9JTlQkMSA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIHx8IDkwMDcxOTkyNTQ3NDA5OTE7XG4gIHZhciB0cnVlaWZ5ID0gZnVuY3Rpb24gdHJ1ZWlmeSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgdmFyIGZhbHNpZnkgPSBmdW5jdGlvbiBmYWxzaWZ5KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgdmFyIHplcm9pZnkgPSBmdW5jdGlvbiB6ZXJvaWZ5KCkge1xuICAgIHJldHVybiAwO1xuICB9O1xuICB2YXIgbm9vcCQxID0gZnVuY3Rpb24gbm9vcCgpIHt9O1xuICB2YXIgZXJyb3IgPSBmdW5jdGlvbiBlcnJvcihtc2cpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgfTtcbiAgdmFyIHdhcm5pbmdzID0gZnVuY3Rpb24gd2FybmluZ3MoZW5hYmxlZCkge1xuICAgIGlmIChlbmFibGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHdhcm5pbmdzRW5hYmxlZCA9ICEhZW5hYmxlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHdhcm5pbmdzRW5hYmxlZDtcbiAgICB9XG4gIH07XG4gIHZhciB3YXJuID0gZnVuY3Rpb24gd2Fybihtc2cpIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gICAgaWYgKCF3YXJuaW5ncygpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHdhcm5TdXBwb3J0ZWQpIHtcbiAgICAgIGNvbnNvbGUud2Fybihtc2cpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZyhtc2cpO1xuXG4gICAgICBpZiAodHJhY2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLyogZXNsaW50LWVuYWJsZSAqL1xuXG4gIHZhciBjbG9uZSA9IGZ1bmN0aW9uIGNsb25lKG9iaikge1xuICAgIHJldHVybiBleHRlbmQoe30sIG9iaik7XG4gIH07IC8vIGdldHMgYSBzaGFsbG93IGNvcHkgb2YgdGhlIGFyZ3VtZW50XG5cbiAgdmFyIGNvcHkgPSBmdW5jdGlvbiBjb3B5KG9iaikge1xuICAgIGlmIChvYmogPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBpZiAoYXJyYXkob2JqKSkge1xuICAgICAgcmV0dXJuIG9iai5zbGljZSgpO1xuICAgIH0gZWxzZSBpZiAocGxhaW5PYmplY3Qob2JqKSkge1xuICAgICAgcmV0dXJuIGNsb25lKG9iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICB9O1xuICB2YXIgY29weUFycmF5JDEgPSBmdW5jdGlvbiBjb3B5QXJyYXkoYXJyKSB7XG4gICAgcmV0dXJuIGFyci5zbGljZSgpO1xuICB9O1xuICB2YXIgdXVpZCA9IGZ1bmN0aW9uIHV1aWQoYSwgYlxuICAvKiBwbGFjZWhvbGRlcnMgKi9cbiAgKSB7XG4gICAgZm9yICggLy8gbG9vcCA6KVxuICAgIGIgPSBhID0gJyc7IC8vIGIgLSByZXN1bHQgLCBhIC0gbnVtZXJpYyBsZXRpYWJsZVxuICAgIGErKyA8IDM2OyAvL1xuICAgIGIgKz0gYSAqIDUxICYgNTIgLy8gaWYgXCJhXCIgaXMgbm90IDkgb3IgMTQgb3IgMTkgb3IgMjRcbiAgICA/IC8vICByZXR1cm4gYSByYW5kb20gbnVtYmVyIG9yIDRcbiAgICAoYSBeIDE1IC8vIGlmIFwiYVwiIGlzIG5vdCAxNVxuICAgID8gLy8gZ2VuZXJhdGUgYSByYW5kb20gbnVtYmVyIGZyb20gMCB0byAxNVxuICAgIDggXiBNYXRoLnJhbmRvbSgpICogKGEgXiAyMCA/IDE2IDogNCkgLy8gdW5sZXNzIFwiYVwiIGlzIDIwLCBpbiB3aGljaCBjYXNlIGEgcmFuZG9tIG51bWJlciBmcm9tIDggdG8gMTFcbiAgICA6IDQgLy8gIG90aGVyd2lzZSA0XG4gICAgKS50b1N0cmluZygxNikgOiAnLScgLy8gIGluIG90aGVyIGNhc2VzIChpZiBcImFcIiBpcyA5LDE0LDE5LDI0KSBpbnNlcnQgXCItXCJcbiAgICApIHtcbiAgICB9XG5cbiAgICByZXR1cm4gYjtcbiAgfTtcbiAgdmFyIF9zdGF0aWNFbXB0eU9iamVjdCA9IHt9O1xuICB2YXIgc3RhdGljRW1wdHlPYmplY3QgPSBmdW5jdGlvbiBzdGF0aWNFbXB0eU9iamVjdCgpIHtcbiAgICByZXR1cm4gX3N0YXRpY0VtcHR5T2JqZWN0O1xuICB9O1xuICB2YXIgZGVmYXVsdHMkZyA9IGZ1bmN0aW9uIGRlZmF1bHRzKF9kZWZhdWx0cykge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoX2RlZmF1bHRzKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG9wdHMpIHtcbiAgICAgIHZhciBmaWxsZWRPcHRzID0ge307XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgdmFyIG9wdFZhbCA9IG9wdHMgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9wdHNba2V5XTtcbiAgICAgICAgZmlsbGVkT3B0c1trZXldID0gb3B0VmFsID09PSB1bmRlZmluZWQgPyBfZGVmYXVsdHNba2V5XSA6IG9wdFZhbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZpbGxlZE9wdHM7XG4gICAgfTtcbiAgfTtcbiAgdmFyIHJlbW92ZUZyb21BcnJheSA9IGZ1bmN0aW9uIHJlbW92ZUZyb21BcnJheShhcnIsIGVsZSwgb25lQ29weSkge1xuICAgIGZvciAodmFyIGkgPSBhcnIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGlmIChhcnJbaV0gPT09IGVsZSkge1xuICAgICAgICBhcnIuc3BsaWNlKGksIDEpO1xuXG4gICAgICAgIGlmIChvbmVDb3B5KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHZhciBjbGVhckFycmF5ID0gZnVuY3Rpb24gY2xlYXJBcnJheShhcnIpIHtcbiAgICBhcnIuc3BsaWNlKDAsIGFyci5sZW5ndGgpO1xuICB9O1xuICB2YXIgcHVzaCA9IGZ1bmN0aW9uIHB1c2goYXJyLCBvdGhlckFycikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3RoZXJBcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbCA9IG90aGVyQXJyW2ldO1xuICAgICAgYXJyLnB1c2goZWwpO1xuICAgIH1cbiAgfTtcbiAgdmFyIGdldFByZWZpeGVkUHJvcGVydHkgPSBmdW5jdGlvbiBnZXRQcmVmaXhlZFByb3BlcnR5KG9iaiwgcHJvcE5hbWUsIHByZWZpeCkge1xuICAgIGlmIChwcmVmaXgpIHtcbiAgICAgIHByb3BOYW1lID0gcHJlcGVuZENhbWVsKHByZWZpeCwgcHJvcE5hbWUpOyAvLyBlLmcuIChsYWJlbFdpZHRoLCBzb3VyY2UpID0+IHNvdXJjZUxhYmVsV2lkdGhcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqW3Byb3BOYW1lXTtcbiAgfTtcbiAgdmFyIHNldFByZWZpeGVkUHJvcGVydHkgPSBmdW5jdGlvbiBzZXRQcmVmaXhlZFByb3BlcnR5KG9iaiwgcHJvcE5hbWUsIHByZWZpeCwgdmFsdWUpIHtcbiAgICBpZiAocHJlZml4KSB7XG4gICAgICBwcm9wTmFtZSA9IHByZXBlbmRDYW1lbChwcmVmaXgsIHByb3BOYW1lKTsgLy8gZS5nLiAobGFiZWxXaWR0aCwgc291cmNlKSA9PiBzb3VyY2VMYWJlbFdpZHRoXG4gICAgfVxuXG4gICAgb2JqW3Byb3BOYW1lXSA9IHZhbHVlO1xuICB9O1xuXG4gIC8qIGdsb2JhbCBNYXAgKi9cbiAgdmFyIE9iamVjdE1hcCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT2JqZWN0TWFwKCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE9iamVjdE1hcCk7XG5cbiAgICAgIHRoaXMuX29iaiA9IHt9O1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhPYmplY3RNYXAsIFt7XG4gICAgICBrZXk6IFwic2V0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0KGtleSwgdmFsKSB7XG4gICAgICAgIHRoaXMuX29ialtrZXldID0gdmFsO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZGVsZXRlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2RlbGV0ZShrZXkpIHtcbiAgICAgICAgdGhpcy5fb2JqW2tleV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJjbGVhclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgICB0aGlzLl9vYmogPSB7fTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiaGFzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaGFzKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb2JqW2tleV0gIT09IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb2JqW2tleV07XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIE9iamVjdE1hcDtcbiAgfSgpO1xuXG4gIHZhciBNYXAkMiA9IHR5cGVvZiBNYXAgIT09ICd1bmRlZmluZWQnID8gTWFwIDogT2JqZWN0TWFwO1xuXG4gIC8qIGdsb2JhbCBTZXQgKi9cbiAgdmFyIHVuZGVmID0gXCJ1bmRlZmluZWRcIiA7XG5cbiAgdmFyIE9iamVjdFNldCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT2JqZWN0U2V0KGFycmF5T3JPYmplY3RTZXQpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBPYmplY3RTZXQpO1xuXG4gICAgICB0aGlzLl9vYmogPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgdGhpcy5zaXplID0gMDtcblxuICAgICAgaWYgKGFycmF5T3JPYmplY3RTZXQgIT0gbnVsbCkge1xuICAgICAgICB2YXIgYXJyO1xuXG4gICAgICAgIGlmIChhcnJheU9yT2JqZWN0U2V0Lmluc3RhbmNlU3RyaW5nICE9IG51bGwgJiYgYXJyYXlPck9iamVjdFNldC5pbnN0YW5jZVN0cmluZygpID09PSB0aGlzLmluc3RhbmNlU3RyaW5nKCkpIHtcbiAgICAgICAgICBhcnIgPSBhcnJheU9yT2JqZWN0U2V0LnRvQXJyYXkoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhcnIgPSBhcnJheU9yT2JqZWN0U2V0O1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLmFkZChhcnJbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKE9iamVjdFNldCwgW3tcbiAgICAgIGtleTogXCJpbnN0YW5jZVN0cmluZ1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGluc3RhbmNlU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gJ3NldCc7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImFkZFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZCh2YWwpIHtcbiAgICAgICAgdmFyIG8gPSB0aGlzLl9vYmo7XG5cbiAgICAgICAgaWYgKG9bdmFsXSAhPT0gMSkge1xuICAgICAgICAgIG9bdmFsXSA9IDE7XG4gICAgICAgICAgdGhpcy5zaXplKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZGVsZXRlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2RlbGV0ZSh2YWwpIHtcbiAgICAgICAgdmFyIG8gPSB0aGlzLl9vYmo7XG5cbiAgICAgICAgaWYgKG9bdmFsXSA9PT0gMSkge1xuICAgICAgICAgIG9bdmFsXSA9IDA7XG4gICAgICAgICAgdGhpcy5zaXplLS07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY2xlYXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5fb2JqID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiaGFzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaGFzKHZhbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb2JqW3ZhbF0gPT09IDE7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInRvQXJyYXlcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b0FycmF5KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9vYmopLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLmhhcyhrZXkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZm9yRWFjaFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9BcnJheSgpLmZvckVhY2goY2FsbGJhY2ssIHRoaXNBcmcpO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBPYmplY3RTZXQ7XG4gIH0oKTtcblxuICB2YXIgU2V0JDEgPSAodHlwZW9mIFNldCA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKFNldCkpICE9PSB1bmRlZiA/IFNldCA6IE9iamVjdFNldDtcblxuICB2YXIgRWxlbWVudCA9IGZ1bmN0aW9uIEVsZW1lbnQoY3ksIHBhcmFtcykge1xuICAgIHZhciByZXN0b3JlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0cnVlO1xuXG4gICAgaWYgKGN5ID09PSB1bmRlZmluZWQgfHwgcGFyYW1zID09PSB1bmRlZmluZWQgfHwgIWNvcmUoY3kpKSB7XG4gICAgICBlcnJvcignQW4gZWxlbWVudCBtdXN0IGhhdmUgYSBjb3JlIHJlZmVyZW5jZSBhbmQgcGFyYW1ldGVycyBzZXQnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZ3JvdXAgPSBwYXJhbXMuZ3JvdXA7IC8vIHRyeSB0byBhdXRvbWF0aWNhbGx5IGluZmVyIHRoZSBncm91cCBpZiB1bnNwZWNpZmllZFxuXG4gICAgaWYgKGdyb3VwID09IG51bGwpIHtcbiAgICAgIGlmIChwYXJhbXMuZGF0YSAmJiBwYXJhbXMuZGF0YS5zb3VyY2UgIT0gbnVsbCAmJiBwYXJhbXMuZGF0YS50YXJnZXQgIT0gbnVsbCkge1xuICAgICAgICBncm91cCA9ICdlZGdlcyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBncm91cCA9ICdub2Rlcyc7XG4gICAgICB9XG4gICAgfSAvLyB2YWxpZGF0ZSBncm91cFxuXG5cbiAgICBpZiAoZ3JvdXAgIT09ICdub2RlcycgJiYgZ3JvdXAgIT09ICdlZGdlcycpIHtcbiAgICAgIGVycm9yKCdBbiBlbGVtZW50IG11c3QgYmUgb2YgdHlwZSBgbm9kZXNgIG9yIGBlZGdlc2A7IHlvdSBzcGVjaWZpZWQgYCcgKyBncm91cCArICdgJyk7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBtYWtlIHRoZSBlbGVtZW50IGFycmF5LWxpa2UsIGp1c3QgbGlrZSBhIGNvbGxlY3Rpb25cblxuXG4gICAgdGhpcy5sZW5ndGggPSAxO1xuICAgIHRoaXNbMF0gPSB0aGlzOyAvLyBOT1RFOiB3aGVuIHNvbWV0aGluZyBpcyBhZGRlZCBoZXJlLCBhZGQgYWxzbyB0byBlbGUuanNvbigpXG5cbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlID0ge1xuICAgICAgY3k6IGN5LFxuICAgICAgc2luZ2xlOiB0cnVlLFxuICAgICAgLy8gaW5kaWNhdGVzIHRoaXMgaXMgYW4gZWxlbWVudFxuICAgICAgZGF0YTogcGFyYW1zLmRhdGEgfHwge30sXG4gICAgICAvLyBkYXRhIG9iamVjdFxuICAgICAgcG9zaXRpb246IHBhcmFtcy5wb3NpdGlvbiB8fCB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH0sXG4gICAgICAvLyAoeCwgeSkgcG9zaXRpb24gcGFpclxuICAgICAgYXV0b1dpZHRoOiB1bmRlZmluZWQsXG4gICAgICAvLyB3aWR0aCBhbmQgaGVpZ2h0IG9mIG5vZGVzIGNhbGN1bGF0ZWQgYnkgdGhlIHJlbmRlcmVyIHdoZW4gc2V0IHRvIHNwZWNpYWwgJ2F1dG8nIHZhbHVlXG4gICAgICBhdXRvSGVpZ2h0OiB1bmRlZmluZWQsXG4gICAgICBhdXRvUGFkZGluZzogdW5kZWZpbmVkLFxuICAgICAgY29tcG91bmRCb3VuZHNDbGVhbjogZmFsc2UsXG4gICAgICAvLyB3aGV0aGVyIHRoZSBjb21wb3VuZCBkaW1lbnNpb25zIG5lZWQgdG8gYmUgcmVjYWxjdWxhdGVkIHRoZSBuZXh0IHRpbWUgZGltZW5zaW9ucyBhcmUgcmVhZFxuICAgICAgbGlzdGVuZXJzOiBbXSxcbiAgICAgIC8vIGFycmF5IG9mIGJvdW5kIGxpc3RlbmVyc1xuICAgICAgZ3JvdXA6IGdyb3VwLFxuICAgICAgLy8gc3RyaW5nOyAnbm9kZXMnIG9yICdlZGdlcydcbiAgICAgIHN0eWxlOiB7fSxcbiAgICAgIC8vIHByb3BlcnRpZXMgYXMgc2V0IGJ5IHRoZSBzdHlsZVxuICAgICAgcnN0eWxlOiB7fSxcbiAgICAgIC8vIHByb3BlcnRpZXMgZm9yIHN0eWxlIHNlbnQgZnJvbSB0aGUgcmVuZGVyZXIgdG8gdGhlIGNvcmVcbiAgICAgIHN0eWxlQ3h0czogW10sXG4gICAgICAvLyBhcHBsaWVkIHN0eWxlIGNvbnRleHRzIGZyb20gdGhlIHN0eWxlclxuICAgICAgc3R5bGVLZXlzOiB7fSxcbiAgICAgIC8vIHBlci1ncm91cCBrZXlzIG9mIHN0eWxlIHByb3BlcnR5IHZhbHVlc1xuICAgICAgcmVtb3ZlZDogdHJ1ZSxcbiAgICAgIC8vIHdoZXRoZXIgaXQncyBpbnNpZGUgdGhlIHZpczsgdHJ1ZSBpZiByZW1vdmVkIChzZXQgdHJ1ZSBoZXJlIHNpbmNlIHdlIGNhbGwgcmVzdG9yZSlcbiAgICAgIHNlbGVjdGVkOiBwYXJhbXMuc2VsZWN0ZWQgPyB0cnVlIDogZmFsc2UsXG4gICAgICAvLyB3aGV0aGVyIGl0J3Mgc2VsZWN0ZWRcbiAgICAgIHNlbGVjdGFibGU6IHBhcmFtcy5zZWxlY3RhYmxlID09PSB1bmRlZmluZWQgPyB0cnVlIDogcGFyYW1zLnNlbGVjdGFibGUgPyB0cnVlIDogZmFsc2UsXG4gICAgICAvLyB3aGV0aGVyIGl0J3Mgc2VsZWN0YWJsZVxuICAgICAgbG9ja2VkOiBwYXJhbXMubG9ja2VkID8gdHJ1ZSA6IGZhbHNlLFxuICAgICAgLy8gd2hldGhlciB0aGUgZWxlbWVudCBpcyBsb2NrZWQgKGNhbm5vdCBiZSBtb3ZlZClcbiAgICAgIGdyYWJiZWQ6IGZhbHNlLFxuICAgICAgLy8gd2hldGhlciB0aGUgZWxlbWVudCBpcyBncmFiYmVkIGJ5IHRoZSBtb3VzZTsgcmVuZGVyZXIgc2V0cyB0aGlzIHByaXZhdGVseVxuICAgICAgZ3JhYmJhYmxlOiBwYXJhbXMuZ3JhYmJhYmxlID09PSB1bmRlZmluZWQgPyB0cnVlIDogcGFyYW1zLmdyYWJiYWJsZSA/IHRydWUgOiBmYWxzZSxcbiAgICAgIC8vIHdoZXRoZXIgdGhlIGVsZW1lbnQgY2FuIGJlIGdyYWJiZWRcbiAgICAgIHBhbm5hYmxlOiBwYXJhbXMucGFubmFibGUgPT09IHVuZGVmaW5lZCA/IGdyb3VwID09PSAnZWRnZXMnID8gdHJ1ZSA6IGZhbHNlIDogcGFyYW1zLnBhbm5hYmxlID8gdHJ1ZSA6IGZhbHNlLFxuICAgICAgLy8gd2hldGhlciB0aGUgZWxlbWVudCBoYXMgcGFzc3Rocm91Z2ggcGFubmluZyBlbmFibGVkXG4gICAgICBhY3RpdmU6IGZhbHNlLFxuICAgICAgLy8gd2hldGhlciB0aGUgZWxlbWVudCBpcyBhY3RpdmUgZnJvbSB1c2VyIGludGVyYWN0aW9uXG4gICAgICBjbGFzc2VzOiBuZXcgU2V0JDEoKSxcbiAgICAgIC8vIG1hcCAoIGNsYXNzTmFtZSA9PiB0cnVlIClcbiAgICAgIGFuaW1hdGlvbjoge1xuICAgICAgICAvLyBvYmplY3QgZm9yIGN1cnJlbnRseS1ydW5uaW5nIGFuaW1hdGlvbnNcbiAgICAgICAgY3VycmVudDogW10sXG4gICAgICAgIHF1ZXVlOiBbXVxuICAgICAgfSxcbiAgICAgIHJzY3JhdGNoOiB7fSxcbiAgICAgIC8vIG9iamVjdCBpbiB3aGljaCB0aGUgcmVuZGVyZXIgY2FuIHN0b3JlIGluZm9ybWF0aW9uXG4gICAgICBzY3JhdGNoOiBwYXJhbXMuc2NyYXRjaCB8fCB7fSxcbiAgICAgIC8vIHNjcmF0Y2ggb2JqZWN0c1xuICAgICAgZWRnZXM6IFtdLFxuICAgICAgLy8gYXJyYXkgb2YgY29ubmVjdGVkIGVkZ2VzXG4gICAgICBjaGlsZHJlbjogW10sXG4gICAgICAvLyBhcnJheSBvZiBjaGlsZHJlblxuICAgICAgcGFyZW50OiBwYXJhbXMucGFyZW50ICYmIHBhcmFtcy5wYXJlbnQuaXNOb2RlKCkgPyBwYXJhbXMucGFyZW50IDogbnVsbCxcbiAgICAgIC8vIHBhcmVudCByZWZcbiAgICAgIHRyYXZlcnNhbENhY2hlOiB7fSxcbiAgICAgIC8vIGNhY2hlIG9mIG91dHB1dCBvZiB0cmF2ZXJzYWwgZnVuY3Rpb25zXG4gICAgICBiYWNrZ3JvdW5kaW5nOiBmYWxzZSxcbiAgICAgIC8vIHdoZXRoZXIgYmFja2dyb3VuZCBpbWFnZXMgYXJlIGxvYWRpbmdcbiAgICAgIGJiQ2FjaGU6IG51bGwsXG4gICAgICAvLyBjYWNoZSBvZiB0aGUgY3VycmVudCBib3VuZGluZyBib3hcbiAgICAgIGJiQ2FjaGVTaGlmdDoge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9LFxuICAgICAgLy8gc2hpZnQgYXBwbGllZCB0byBjYWNoZWQgYmIgdG8gYmUgYXBwbGllZCBvbiBuZXh0IGdldFxuICAgICAgYm9keUJvdW5kczogbnVsbCxcbiAgICAgIC8vIGJvdW5kcyBjYWNoZSBvZiBlbGVtZW50IGJvZHksIHcvbyBvdmVybGF5XG4gICAgICBvdmVybGF5Qm91bmRzOiBudWxsLFxuICAgICAgLy8gYm91bmRzIGNhY2hlIG9mIGVsZW1lbnQgYm9keSwgaW5jbHVkaW5nIG92ZXJsYXlcbiAgICAgIGxhYmVsQm91bmRzOiB7XG4gICAgICAgIC8vIGJvdW5kcyBjYWNoZSBvZiBsYWJlbHNcbiAgICAgICAgYWxsOiBudWxsLFxuICAgICAgICBzb3VyY2U6IG51bGwsXG4gICAgICAgIHRhcmdldDogbnVsbCxcbiAgICAgICAgbWFpbjogbnVsbFxuICAgICAgfSxcbiAgICAgIGFycm93Qm91bmRzOiB7XG4gICAgICAgIC8vIGJvdW5kcyBjYWNoZSBvZiBlZGdlIGFycm93c1xuICAgICAgICBzb3VyY2U6IG51bGwsXG4gICAgICAgIHRhcmdldDogbnVsbCxcbiAgICAgICAgJ21pZC1zb3VyY2UnOiBudWxsLFxuICAgICAgICAnbWlkLXRhcmdldCc6IG51bGxcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKF9wLnBvc2l0aW9uLnggPT0gbnVsbCkge1xuICAgICAgX3AucG9zaXRpb24ueCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKF9wLnBvc2l0aW9uLnkgPT0gbnVsbCkge1xuICAgICAgX3AucG9zaXRpb24ueSA9IDA7XG4gICAgfSAvLyByZW5kZXJlZFBvc2l0aW9uIG92ZXJyaWRlcyBpZiBzcGVjaWZpZWRcblxuXG4gICAgaWYgKHBhcmFtcy5yZW5kZXJlZFBvc2l0aW9uKSB7XG4gICAgICB2YXIgcnBvcyA9IHBhcmFtcy5yZW5kZXJlZFBvc2l0aW9uO1xuICAgICAgdmFyIHBhbiA9IGN5LnBhbigpO1xuICAgICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgICBfcC5wb3NpdGlvbiA9IHtcbiAgICAgICAgeDogKHJwb3MueCAtIHBhbi54KSAvIHpvb20sXG4gICAgICAgIHk6IChycG9zLnkgLSBwYW4ueSkgLyB6b29tXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBjbGFzc2VzID0gW107XG5cbiAgICBpZiAoYXJyYXkocGFyYW1zLmNsYXNzZXMpKSB7XG4gICAgICBjbGFzc2VzID0gcGFyYW1zLmNsYXNzZXM7XG4gICAgfSBlbHNlIGlmIChzdHJpbmcocGFyYW1zLmNsYXNzZXMpKSB7XG4gICAgICBjbGFzc2VzID0gcGFyYW1zLmNsYXNzZXMuc3BsaXQoL1xccysvKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNsYXNzZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgY2xzID0gY2xhc3Nlc1tpXTtcblxuICAgICAgaWYgKCFjbHMgfHwgY2xzID09PSAnJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgX3AuY2xhc3Nlcy5hZGQoY2xzKTtcbiAgICB9XG5cbiAgICB0aGlzLmNyZWF0ZUVtaXR0ZXIoKTtcbiAgICB2YXIgYnlwYXNzID0gcGFyYW1zLnN0eWxlIHx8IHBhcmFtcy5jc3M7XG5cbiAgICBpZiAoYnlwYXNzKSB7XG4gICAgICB3YXJuKCdTZXR0aW5nIGEgYHN0eWxlYCBieXBhc3MgYXQgZWxlbWVudCBjcmVhdGlvbiBzaG91bGQgYmUgZG9uZSBvbmx5IHdoZW4gYWJzb2x1dGVseSBuZWNlc3NhcnkuICBUcnkgdG8gdXNlIHRoZSBzdHlsZXNoZWV0IGluc3RlYWQuJyk7XG4gICAgICB0aGlzLnN0eWxlKGJ5cGFzcyk7XG4gICAgfVxuXG4gICAgaWYgKHJlc3RvcmUgPT09IHVuZGVmaW5lZCB8fCByZXN0b3JlKSB7XG4gICAgICB0aGlzLnJlc3RvcmUoKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGRlZmluZVNlYXJjaCA9IGZ1bmN0aW9uIGRlZmluZVNlYXJjaChwYXJhbXMpIHtcbiAgICBwYXJhbXMgPSB7XG4gICAgICBiZnM6IHBhcmFtcy5iZnMgfHwgIXBhcmFtcy5kZnMsXG4gICAgICBkZnM6IHBhcmFtcy5kZnMgfHwgIXBhcmFtcy5iZnNcbiAgICB9OyAvLyBmcm9tIHBzZXVkb2NvZGUgb24gd2lraXBlZGlhXG5cbiAgICByZXR1cm4gZnVuY3Rpb24gc2VhcmNoRm4ocm9vdHMsIGZuLCBkaXJlY3RlZCkge1xuICAgICAgdmFyIG9wdGlvbnM7XG5cbiAgICAgIGlmIChwbGFpbk9iamVjdChyb290cykgJiYgIWVsZW1lbnRPckNvbGxlY3Rpb24ocm9vdHMpKSB7XG4gICAgICAgIG9wdGlvbnMgPSByb290cztcbiAgICAgICAgcm9vdHMgPSBvcHRpb25zLnJvb3RzIHx8IG9wdGlvbnMucm9vdDtcbiAgICAgICAgZm4gPSBvcHRpb25zLnZpc2l0O1xuICAgICAgICBkaXJlY3RlZCA9IG9wdGlvbnMuZGlyZWN0ZWQ7XG4gICAgICB9XG5cbiAgICAgIGRpcmVjdGVkID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiAhZm4kNihmbikgPyBmbiA6IGRpcmVjdGVkO1xuICAgICAgZm4gPSBmbiQ2KGZuKSA/IGZuIDogZnVuY3Rpb24gKCkge307XG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgICAgdmFyIHYgPSByb290cyA9IHN0cmluZyhyb290cykgPyB0aGlzLmZpbHRlcihyb290cykgOiByb290cztcbiAgICAgIHZhciBRID0gW107XG4gICAgICB2YXIgY29ubmVjdGVkTm9kZXMgPSBbXTtcbiAgICAgIHZhciBjb25uZWN0ZWRCeSA9IHt9O1xuICAgICAgdmFyIGlkMmRlcHRoID0ge307XG4gICAgICB2YXIgViA9IHt9O1xuICAgICAgdmFyIGogPSAwO1xuICAgICAgdmFyIGZvdW5kO1xuXG4gICAgICB2YXIgX3RoaXMkYnlHcm91cCA9IHRoaXMuYnlHcm91cCgpLFxuICAgICAgICAgIG5vZGVzID0gX3RoaXMkYnlHcm91cC5ub2RlcyxcbiAgICAgICAgICBlZGdlcyA9IF90aGlzJGJ5R3JvdXAuZWRnZXM7IC8vIGVucXVldWUgdlxuXG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdmkgPSB2W2ldO1xuICAgICAgICB2YXIgdmlJZCA9IHZpLmlkKCk7XG5cbiAgICAgICAgaWYgKHZpLmlzTm9kZSgpKSB7XG4gICAgICAgICAgUS51bnNoaWZ0KHZpKTtcblxuICAgICAgICAgIGlmIChwYXJhbXMuYmZzKSB7XG4gICAgICAgICAgICBWW3ZpSWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbm5lY3RlZE5vZGVzLnB1c2godmkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlkMmRlcHRoW3ZpSWRdID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICAgICAgdmFyIHYgPSBwYXJhbXMuYmZzID8gUS5zaGlmdCgpIDogUS5wb3AoKTtcbiAgICAgICAgdmFyIHZJZCA9IHYuaWQoKTtcblxuICAgICAgICBpZiAocGFyYW1zLmRmcykge1xuICAgICAgICAgIGlmIChWW3ZJZF0pIHtcbiAgICAgICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgVlt2SWRdID0gdHJ1ZTtcbiAgICAgICAgICBjb25uZWN0ZWROb2Rlcy5wdXNoKHYpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRlcHRoID0gaWQyZGVwdGhbdklkXTtcbiAgICAgICAgdmFyIHByZXZFZGdlID0gY29ubmVjdGVkQnlbdklkXTtcbiAgICAgICAgdmFyIHNyYyA9IHByZXZFZGdlICE9IG51bGwgPyBwcmV2RWRnZS5zb3VyY2UoKSA6IG51bGw7XG4gICAgICAgIHZhciB0Z3QgPSBwcmV2RWRnZSAhPSBudWxsID8gcHJldkVkZ2UudGFyZ2V0KCkgOiBudWxsO1xuICAgICAgICB2YXIgcHJldk5vZGUgPSBwcmV2RWRnZSA9PSBudWxsID8gdW5kZWZpbmVkIDogdi5zYW1lKHNyYykgPyB0Z3RbMF0gOiBzcmNbMF07XG4gICAgICAgIHZhciByZXQgPSB2b2lkIDA7XG4gICAgICAgIHJldCA9IGZuKHYsIHByZXZFZGdlLCBwcmV2Tm9kZSwgaisrLCBkZXB0aCk7XG5cbiAgICAgICAgaWYgKHJldCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGZvdW5kID0gdjtcbiAgICAgICAgICByZXR1cm4gXCJicmVha1wiO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gXCJicmVha1wiO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZ3RWRnZXMgPSB2LmNvbm5lY3RlZEVkZ2VzKCkuZmlsdGVyKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgcmV0dXJuICghZGlyZWN0ZWQgfHwgZS5zb3VyY2UoKS5zYW1lKHYpKSAmJiBlZGdlcy5oYXMoZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IHZ3RWRnZXMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICAgIHZhciBlID0gdndFZGdlc1tfaTJdO1xuICAgICAgICAgIHZhciB3ID0gZS5jb25uZWN0ZWROb2RlcygpLmZpbHRlcihmdW5jdGlvbiAobikge1xuICAgICAgICAgICAgcmV0dXJuICFuLnNhbWUodikgJiYgbm9kZXMuaGFzKG4pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciB3SWQgPSB3LmlkKCk7XG5cbiAgICAgICAgICBpZiAody5sZW5ndGggIT09IDAgJiYgIVZbd0lkXSkge1xuICAgICAgICAgICAgdyA9IHdbMF07XG4gICAgICAgICAgICBRLnB1c2godyk7XG5cbiAgICAgICAgICAgIGlmIChwYXJhbXMuYmZzKSB7XG4gICAgICAgICAgICAgIFZbd0lkXSA9IHRydWU7XG4gICAgICAgICAgICAgIGNvbm5lY3RlZE5vZGVzLnB1c2godyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbm5lY3RlZEJ5W3dJZF0gPSBlO1xuICAgICAgICAgICAgaWQyZGVwdGhbd0lkXSA9IGlkMmRlcHRoW3ZJZF0gKyAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgd2hpbGUgKFEubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIHZhciBfcmV0ID0gX2xvb3AoKTtcblxuICAgICAgICBpZiAoX3JldCA9PT0gXCJjb250aW51ZVwiKSBjb250aW51ZTtcbiAgICAgICAgaWYgKF9yZXQgPT09IFwiYnJlYWtcIikgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHZhciBjb25uZWN0ZWRFbGVzID0gY3kuY29sbGVjdGlvbigpO1xuXG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgY29ubmVjdGVkTm9kZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gY29ubmVjdGVkTm9kZXNbX2ldO1xuICAgICAgICB2YXIgZWRnZSA9IGNvbm5lY3RlZEJ5W25vZGUuaWQoKV07XG5cbiAgICAgICAgaWYgKGVkZ2UgIT0gbnVsbCkge1xuICAgICAgICAgIGNvbm5lY3RlZEVsZXMucHVzaChlZGdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbm5lY3RlZEVsZXMucHVzaChub2RlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aDogY3kuY29sbGVjdGlvbihjb25uZWN0ZWRFbGVzKSxcbiAgICAgICAgZm91bmQ6IGN5LmNvbGxlY3Rpb24oZm91bmQpXG4gICAgICB9O1xuICAgIH07XG4gIH07IC8vIHNlYXJjaCwgc3Bhbm5pbmcgdHJlZXMsIGV0Y1xuXG5cbiAgdmFyIGVsZXNmbiR2ID0ge1xuICAgIGJyZWFkdGhGaXJzdFNlYXJjaDogZGVmaW5lU2VhcmNoKHtcbiAgICAgIGJmczogdHJ1ZVxuICAgIH0pLFxuICAgIGRlcHRoRmlyc3RTZWFyY2g6IGRlZmluZVNlYXJjaCh7XG4gICAgICBkZnM6IHRydWVcbiAgICB9KVxuICB9OyAvLyBuaWNlLCBzaG9ydCBtYXRoZW1hdGljYWwgYWxpYXNcblxuICBlbGVzZm4kdi5iZnMgPSBlbGVzZm4kdi5icmVhZHRoRmlyc3RTZWFyY2g7XG4gIGVsZXNmbiR2LmRmcyA9IGVsZXNmbiR2LmRlcHRoRmlyc3RTZWFyY2g7XG5cbiAgdmFyIGhlYXAkMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbiAgLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjguMFxuICAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIEhlYXAsIGRlZmF1bHRDbXAsIGZsb29yLCBoZWFwaWZ5LCBoZWFwcG9wLCBoZWFwcHVzaCwgaGVhcHB1c2hwb3AsIGhlYXByZXBsYWNlLCBpbnNvcnQsIG1pbiwgbmxhcmdlc3QsIG5zbWFsbGVzdCwgdXBkYXRlSXRlbSwgX3NpZnRkb3duLCBfc2lmdHVwO1xuXG4gICAgZmxvb3IgPSBNYXRoLmZsb29yLCBtaW4gPSBNYXRoLm1pbjtcblxuXG4gICAgLypcbiAgICBEZWZhdWx0IGNvbXBhcmlzb24gZnVuY3Rpb24gdG8gYmUgdXNlZFxuICAgICAqL1xuXG4gICAgZGVmYXVsdENtcCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIGlmICh4IDwgeSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICBpZiAoeCA+IHkpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9O1xuXG5cbiAgICAvKlxuICAgIEluc2VydCBpdGVtIHggaW4gbGlzdCBhLCBhbmQga2VlcCBpdCBzb3J0ZWQgYXNzdW1pbmcgYSBpcyBzb3J0ZWQuXG4gICAgXG4gICAgSWYgeCBpcyBhbHJlYWR5IGluIGEsIGluc2VydCBpdCB0byB0aGUgcmlnaHQgb2YgdGhlIHJpZ2h0bW9zdCB4LlxuICAgIFxuICAgIE9wdGlvbmFsIGFyZ3MgbG8gKGRlZmF1bHQgMCkgYW5kIGhpIChkZWZhdWx0IGEubGVuZ3RoKSBib3VuZCB0aGUgc2xpY2VcbiAgICBvZiBhIHRvIGJlIHNlYXJjaGVkLlxuICAgICAqL1xuXG4gICAgaW5zb3J0ID0gZnVuY3Rpb24oYSwgeCwgbG8sIGhpLCBjbXApIHtcbiAgICAgIHZhciBtaWQ7XG4gICAgICBpZiAobG8gPT0gbnVsbCkge1xuICAgICAgICBsbyA9IDA7XG4gICAgICB9XG4gICAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICAgIH1cbiAgICAgIGlmIChsbyA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsbyBtdXN0IGJlIG5vbi1uZWdhdGl2ZScpO1xuICAgICAgfVxuICAgICAgaWYgKGhpID09IG51bGwpIHtcbiAgICAgICAgaGkgPSBhLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgICAgIG1pZCA9IGZsb29yKChsbyArIGhpKSAvIDIpO1xuICAgICAgICBpZiAoY21wKHgsIGFbbWlkXSkgPCAwKSB7XG4gICAgICAgICAgaGkgPSBtaWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG8gPSBtaWQgKyAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gKFtdLnNwbGljZS5hcHBseShhLCBbbG8sIGxvIC0gbG9dLmNvbmNhdCh4KSksIHgpO1xuICAgIH07XG5cblxuICAgIC8qXG4gICAgUHVzaCBpdGVtIG9udG8gaGVhcCwgbWFpbnRhaW5pbmcgdGhlIGhlYXAgaW52YXJpYW50LlxuICAgICAqL1xuXG4gICAgaGVhcHB1c2ggPSBmdW5jdGlvbihhcnJheSwgaXRlbSwgY21wKSB7XG4gICAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICAgIH1cbiAgICAgIGFycmF5LnB1c2goaXRlbSk7XG4gICAgICByZXR1cm4gX3NpZnRkb3duKGFycmF5LCAwLCBhcnJheS5sZW5ndGggLSAxLCBjbXApO1xuICAgIH07XG5cblxuICAgIC8qXG4gICAgUG9wIHRoZSBzbWFsbGVzdCBpdGVtIG9mZiB0aGUgaGVhcCwgbWFpbnRhaW5pbmcgdGhlIGhlYXAgaW52YXJpYW50LlxuICAgICAqL1xuXG4gICAgaGVhcHBvcCA9IGZ1bmN0aW9uKGFycmF5LCBjbXApIHtcbiAgICAgIHZhciBsYXN0ZWx0LCByZXR1cm5pdGVtO1xuICAgICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgICB9XG4gICAgICBsYXN0ZWx0ID0gYXJyYXkucG9wKCk7XG4gICAgICBpZiAoYXJyYXkubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybml0ZW0gPSBhcnJheVswXTtcbiAgICAgICAgYXJyYXlbMF0gPSBsYXN0ZWx0O1xuICAgICAgICBfc2lmdHVwKGFycmF5LCAwLCBjbXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuaXRlbSA9IGxhc3RlbHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0dXJuaXRlbTtcbiAgICB9O1xuXG5cbiAgICAvKlxuICAgIFBvcCBhbmQgcmV0dXJuIHRoZSBjdXJyZW50IHNtYWxsZXN0IHZhbHVlLCBhbmQgYWRkIHRoZSBuZXcgaXRlbS5cbiAgICBcbiAgICBUaGlzIGlzIG1vcmUgZWZmaWNpZW50IHRoYW4gaGVhcHBvcCgpIGZvbGxvd2VkIGJ5IGhlYXBwdXNoKCksIGFuZCBjYW4gYmVcbiAgICBtb3JlIGFwcHJvcHJpYXRlIHdoZW4gdXNpbmcgYSBmaXhlZCBzaXplIGhlYXAuIE5vdGUgdGhhdCB0aGUgdmFsdWVcbiAgICByZXR1cm5lZCBtYXkgYmUgbGFyZ2VyIHRoYW4gaXRlbSEgVGhhdCBjb25zdHJhaW5zIHJlYXNvbmFibGUgdXNlIG9mXG4gICAgdGhpcyByb3V0aW5lIHVubGVzcyB3cml0dGVuIGFzIHBhcnQgb2YgYSBjb25kaXRpb25hbCByZXBsYWNlbWVudDpcbiAgICAgICAgaWYgaXRlbSA+IGFycmF5WzBdXG4gICAgICAgICAgaXRlbSA9IGhlYXByZXBsYWNlKGFycmF5LCBpdGVtKVxuICAgICAqL1xuXG4gICAgaGVhcHJlcGxhY2UgPSBmdW5jdGlvbihhcnJheSwgaXRlbSwgY21wKSB7XG4gICAgICB2YXIgcmV0dXJuaXRlbTtcbiAgICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgICAgfVxuICAgICAgcmV0dXJuaXRlbSA9IGFycmF5WzBdO1xuICAgICAgYXJyYXlbMF0gPSBpdGVtO1xuICAgICAgX3NpZnR1cChhcnJheSwgMCwgY21wKTtcbiAgICAgIHJldHVybiByZXR1cm5pdGVtO1xuICAgIH07XG5cblxuICAgIC8qXG4gICAgRmFzdCB2ZXJzaW9uIG9mIGEgaGVhcHB1c2ggZm9sbG93ZWQgYnkgYSBoZWFwcG9wLlxuICAgICAqL1xuXG4gICAgaGVhcHB1c2hwb3AgPSBmdW5jdGlvbihhcnJheSwgaXRlbSwgY21wKSB7XG4gICAgICB2YXIgX3JlZjtcbiAgICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgICAgfVxuICAgICAgaWYgKGFycmF5Lmxlbmd0aCAmJiBjbXAoYXJyYXlbMF0sIGl0ZW0pIDwgMCkge1xuICAgICAgICBfcmVmID0gW2FycmF5WzBdLCBpdGVtXSwgaXRlbSA9IF9yZWZbMF0sIGFycmF5WzBdID0gX3JlZlsxXTtcbiAgICAgICAgX3NpZnR1cChhcnJheSwgMCwgY21wKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpdGVtO1xuICAgIH07XG5cblxuICAgIC8qXG4gICAgVHJhbnNmb3JtIGxpc3QgaW50byBhIGhlYXAsIGluLXBsYWNlLCBpbiBPKGFycmF5Lmxlbmd0aCkgdGltZS5cbiAgICAgKi9cblxuICAgIGhlYXBpZnkgPSBmdW5jdGlvbihhcnJheSwgY21wKSB7XG4gICAgICB2YXIgaSwgX2ksIF9sZW4sIF9yZWYxLCBfcmVzdWx0cywgX3Jlc3VsdHMxO1xuICAgICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgICB9XG4gICAgICBfcmVmMSA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgX3Jlc3VsdHMxID0gW107XG4gICAgICAgIGZvciAodmFyIF9qID0gMCwgX3JlZiA9IGZsb29yKGFycmF5Lmxlbmd0aCAvIDIpOyAwIDw9IF9yZWYgPyBfaiA8IF9yZWYgOiBfaiA+IF9yZWY7IDAgPD0gX3JlZiA/IF9qKysgOiBfai0tKXsgX3Jlc3VsdHMxLnB1c2goX2opOyB9XG4gICAgICAgIHJldHVybiBfcmVzdWx0czE7XG4gICAgICB9KS5hcHBseSh0aGlzKS5yZXZlcnNlKCk7XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMS5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBpID0gX3JlZjFbX2ldO1xuICAgICAgICBfcmVzdWx0cy5wdXNoKF9zaWZ0dXAoYXJyYXksIGksIGNtcCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH07XG5cblxuICAgIC8qXG4gICAgVXBkYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgZ2l2ZW4gaXRlbSBpbiB0aGUgaGVhcC5cbiAgICBUaGlzIGZ1bmN0aW9uIHNob3VsZCBiZSBjYWxsZWQgZXZlcnkgdGltZSB0aGUgaXRlbSBpcyBiZWluZyBtb2RpZmllZC5cbiAgICAgKi9cblxuICAgIHVwZGF0ZUl0ZW0gPSBmdW5jdGlvbihhcnJheSwgaXRlbSwgY21wKSB7XG4gICAgICB2YXIgcG9zO1xuICAgICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgICB9XG4gICAgICBwb3MgPSBhcnJheS5pbmRleE9mKGl0ZW0pO1xuICAgICAgaWYgKHBvcyA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgX3NpZnRkb3duKGFycmF5LCAwLCBwb3MsIGNtcCk7XG4gICAgICByZXR1cm4gX3NpZnR1cChhcnJheSwgcG9zLCBjbXApO1xuICAgIH07XG5cblxuICAgIC8qXG4gICAgRmluZCB0aGUgbiBsYXJnZXN0IGVsZW1lbnRzIGluIGEgZGF0YXNldC5cbiAgICAgKi9cblxuICAgIG5sYXJnZXN0ID0gZnVuY3Rpb24oYXJyYXksIG4sIGNtcCkge1xuICAgICAgdmFyIGVsZW0sIHJlc3VsdCwgX2ksIF9sZW4sIF9yZWY7XG4gICAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGFycmF5LnNsaWNlKDAsIG4pO1xuICAgICAgaWYgKCFyZXN1bHQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBoZWFwaWZ5KHJlc3VsdCwgY21wKTtcbiAgICAgIF9yZWYgPSBhcnJheS5zbGljZShuKTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBlbGVtID0gX3JlZltfaV07XG4gICAgICAgIGhlYXBwdXNocG9wKHJlc3VsdCwgZWxlbSwgY21wKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQuc29ydChjbXApLnJldmVyc2UoKTtcbiAgICB9O1xuXG5cbiAgICAvKlxuICAgIEZpbmQgdGhlIG4gc21hbGxlc3QgZWxlbWVudHMgaW4gYSBkYXRhc2V0LlxuICAgICAqL1xuXG4gICAgbnNtYWxsZXN0ID0gZnVuY3Rpb24oYXJyYXksIG4sIGNtcCkge1xuICAgICAgdmFyIGVsZW0sIGxvcywgcmVzdWx0LCBfaSwgX2osIF9sZW4sIF9yZWYsIF9yZWYxLCBfcmVzdWx0cztcbiAgICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgICAgfVxuICAgICAgaWYgKG4gKiAxMCA8PSBhcnJheS5sZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0ID0gYXJyYXkuc2xpY2UoMCwgbikuc29ydChjbXApO1xuICAgICAgICBpZiAoIXJlc3VsdC5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGxvcyA9IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV07XG4gICAgICAgIF9yZWYgPSBhcnJheS5zbGljZShuKTtcbiAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgZWxlbSA9IF9yZWZbX2ldO1xuICAgICAgICAgIGlmIChjbXAoZWxlbSwgbG9zKSA8IDApIHtcbiAgICAgICAgICAgIGluc29ydChyZXN1bHQsIGVsZW0sIDAsIG51bGwsIGNtcCk7XG4gICAgICAgICAgICByZXN1bHQucG9wKCk7XG4gICAgICAgICAgICBsb3MgPSByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgaGVhcGlmeShhcnJheSwgY21wKTtcbiAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICBmb3IgKF9qID0gMCwgX3JlZjEgPSBtaW4obiwgYXJyYXkubGVuZ3RoKTsgMCA8PSBfcmVmMSA/IF9qIDwgX3JlZjEgOiBfaiA+IF9yZWYxOyAwIDw9IF9yZWYxID8gKytfaiA6IC0tX2opIHtcbiAgICAgICAgX3Jlc3VsdHMucHVzaChoZWFwcG9wKGFycmF5LCBjbXApKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9O1xuXG4gICAgX3NpZnRkb3duID0gZnVuY3Rpb24oYXJyYXksIHN0YXJ0cG9zLCBwb3MsIGNtcCkge1xuICAgICAgdmFyIG5ld2l0ZW0sIHBhcmVudCwgcGFyZW50cG9zO1xuICAgICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgICB9XG4gICAgICBuZXdpdGVtID0gYXJyYXlbcG9zXTtcbiAgICAgIHdoaWxlIChwb3MgPiBzdGFydHBvcykge1xuICAgICAgICBwYXJlbnRwb3MgPSAocG9zIC0gMSkgPj4gMTtcbiAgICAgICAgcGFyZW50ID0gYXJyYXlbcGFyZW50cG9zXTtcbiAgICAgICAgaWYgKGNtcChuZXdpdGVtLCBwYXJlbnQpIDwgMCkge1xuICAgICAgICAgIGFycmF5W3Bvc10gPSBwYXJlbnQ7XG4gICAgICAgICAgcG9zID0gcGFyZW50cG9zO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5W3Bvc10gPSBuZXdpdGVtO1xuICAgIH07XG5cbiAgICBfc2lmdHVwID0gZnVuY3Rpb24oYXJyYXksIHBvcywgY21wKSB7XG4gICAgICB2YXIgY2hpbGRwb3MsIGVuZHBvcywgbmV3aXRlbSwgcmlnaHRwb3MsIHN0YXJ0cG9zO1xuICAgICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgICB9XG4gICAgICBlbmRwb3MgPSBhcnJheS5sZW5ndGg7XG4gICAgICBzdGFydHBvcyA9IHBvcztcbiAgICAgIG5ld2l0ZW0gPSBhcnJheVtwb3NdO1xuICAgICAgY2hpbGRwb3MgPSAyICogcG9zICsgMTtcbiAgICAgIHdoaWxlIChjaGlsZHBvcyA8IGVuZHBvcykge1xuICAgICAgICByaWdodHBvcyA9IGNoaWxkcG9zICsgMTtcbiAgICAgICAgaWYgKHJpZ2h0cG9zIDwgZW5kcG9zICYmICEoY21wKGFycmF5W2NoaWxkcG9zXSwgYXJyYXlbcmlnaHRwb3NdKSA8IDApKSB7XG4gICAgICAgICAgY2hpbGRwb3MgPSByaWdodHBvcztcbiAgICAgICAgfVxuICAgICAgICBhcnJheVtwb3NdID0gYXJyYXlbY2hpbGRwb3NdO1xuICAgICAgICBwb3MgPSBjaGlsZHBvcztcbiAgICAgICAgY2hpbGRwb3MgPSAyICogcG9zICsgMTtcbiAgICAgIH1cbiAgICAgIGFycmF5W3Bvc10gPSBuZXdpdGVtO1xuICAgICAgcmV0dXJuIF9zaWZ0ZG93bihhcnJheSwgc3RhcnRwb3MsIHBvcywgY21wKTtcbiAgICB9O1xuXG4gICAgSGVhcCA9IChmdW5jdGlvbigpIHtcbiAgICAgIEhlYXAucHVzaCA9IGhlYXBwdXNoO1xuXG4gICAgICBIZWFwLnBvcCA9IGhlYXBwb3A7XG5cbiAgICAgIEhlYXAucmVwbGFjZSA9IGhlYXByZXBsYWNlO1xuXG4gICAgICBIZWFwLnB1c2hwb3AgPSBoZWFwcHVzaHBvcDtcblxuICAgICAgSGVhcC5oZWFwaWZ5ID0gaGVhcGlmeTtcblxuICAgICAgSGVhcC51cGRhdGVJdGVtID0gdXBkYXRlSXRlbTtcblxuICAgICAgSGVhcC5ubGFyZ2VzdCA9IG5sYXJnZXN0O1xuXG4gICAgICBIZWFwLm5zbWFsbGVzdCA9IG5zbWFsbGVzdDtcblxuICAgICAgZnVuY3Rpb24gSGVhcChjbXApIHtcbiAgICAgICAgdGhpcy5jbXAgPSBjbXAgIT0gbnVsbCA/IGNtcCA6IGRlZmF1bHRDbXA7XG4gICAgICAgIHRoaXMubm9kZXMgPSBbXTtcbiAgICAgIH1cblxuICAgICAgSGVhcC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIGhlYXBwdXNoKHRoaXMubm9kZXMsIHgsIHRoaXMuY21wKTtcbiAgICAgIH07XG5cbiAgICAgIEhlYXAucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaGVhcHBvcCh0aGlzLm5vZGVzLCB0aGlzLmNtcCk7XG4gICAgICB9O1xuXG4gICAgICBIZWFwLnByb3RvdHlwZS5wZWVrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzWzBdO1xuICAgICAgfTtcblxuICAgICAgSGVhcC5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzLmluZGV4T2YoeCkgIT09IC0xO1xuICAgICAgfTtcblxuICAgICAgSGVhcC5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIGhlYXByZXBsYWNlKHRoaXMubm9kZXMsIHgsIHRoaXMuY21wKTtcbiAgICAgIH07XG5cbiAgICAgIEhlYXAucHJvdG90eXBlLnB1c2hwb3AgPSBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiBoZWFwcHVzaHBvcCh0aGlzLm5vZGVzLCB4LCB0aGlzLmNtcCk7XG4gICAgICB9O1xuXG4gICAgICBIZWFwLnByb3RvdHlwZS5oZWFwaWZ5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBoZWFwaWZ5KHRoaXMubm9kZXMsIHRoaXMuY21wKTtcbiAgICAgIH07XG5cbiAgICAgIEhlYXAucHJvdG90eXBlLnVwZGF0ZUl0ZW0gPSBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiB1cGRhdGVJdGVtKHRoaXMubm9kZXMsIHgsIHRoaXMuY21wKTtcbiAgICAgIH07XG5cbiAgICAgIEhlYXAucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzID0gW107XG4gICAgICB9O1xuXG4gICAgICBIZWFwLnByb3RvdHlwZS5lbXB0eSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2Rlcy5sZW5ndGggPT09IDA7XG4gICAgICB9O1xuXG4gICAgICBIZWFwLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzLmxlbmd0aDtcbiAgICAgIH07XG5cbiAgICAgIEhlYXAucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBoZWFwO1xuICAgICAgICBoZWFwID0gbmV3IEhlYXAoKTtcbiAgICAgICAgaGVhcC5ub2RlcyA9IHRoaXMubm9kZXMuc2xpY2UoMCk7XG4gICAgICAgIHJldHVybiBoZWFwO1xuICAgICAgfTtcblxuICAgICAgSGVhcC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2Rlcy5zbGljZSgwKTtcbiAgICAgIH07XG5cbiAgICAgIEhlYXAucHJvdG90eXBlLmluc2VydCA9IEhlYXAucHJvdG90eXBlLnB1c2g7XG5cbiAgICAgIEhlYXAucHJvdG90eXBlLnRvcCA9IEhlYXAucHJvdG90eXBlLnBlZWs7XG5cbiAgICAgIEhlYXAucHJvdG90eXBlLmZyb250ID0gSGVhcC5wcm90b3R5cGUucGVlaztcblxuICAgICAgSGVhcC5wcm90b3R5cGUuaGFzID0gSGVhcC5wcm90b3R5cGUuY29udGFpbnM7XG5cbiAgICAgIEhlYXAucHJvdG90eXBlLmNvcHkgPSBIZWFwLnByb3RvdHlwZS5jbG9uZTtcblxuICAgICAgcmV0dXJuIEhlYXA7XG5cbiAgICB9KSgpO1xuXG4gICAgKGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICAgICAgfVxuICAgIH0pKHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIEhlYXA7XG4gICAgfSk7XG5cbiAgfSkuY2FsbChjb21tb25qc0dsb2JhbCk7XG4gIH0pO1xuXG4gIHZhciBoZWFwID0gaGVhcCQxO1xuXG4gIHZhciBkaWprc3RyYURlZmF1bHRzID0gZGVmYXVsdHMkZyh7XG4gICAgcm9vdDogbnVsbCxcbiAgICB3ZWlnaHQ6IGZ1bmN0aW9uIHdlaWdodChlZGdlKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9LFxuICAgIGRpcmVjdGVkOiBmYWxzZVxuICB9KTtcbiAgdmFyIGVsZXNmbiR1ID0ge1xuICAgIGRpamtzdHJhOiBmdW5jdGlvbiBkaWprc3RyYShvcHRpb25zKSB7XG4gICAgICBpZiAoIXBsYWluT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgIHJvb3Q6IGFyZ3NbMF0sXG4gICAgICAgICAgd2VpZ2h0OiBhcmdzWzFdLFxuICAgICAgICAgIGRpcmVjdGVkOiBhcmdzWzJdXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHZhciBfZGlqa3N0cmFEZWZhdWx0cyA9IGRpamtzdHJhRGVmYXVsdHMob3B0aW9ucyksXG4gICAgICAgICAgcm9vdCA9IF9kaWprc3RyYURlZmF1bHRzLnJvb3QsXG4gICAgICAgICAgd2VpZ2h0ID0gX2RpamtzdHJhRGVmYXVsdHMud2VpZ2h0LFxuICAgICAgICAgIGRpcmVjdGVkID0gX2RpamtzdHJhRGVmYXVsdHMuZGlyZWN0ZWQ7XG5cbiAgICAgIHZhciBlbGVzID0gdGhpcztcbiAgICAgIHZhciB3ZWlnaHRGbiA9IHdlaWdodDtcbiAgICAgIHZhciBzb3VyY2UgPSBzdHJpbmcocm9vdCkgPyB0aGlzLmZpbHRlcihyb290KVswXSA6IHJvb3RbMF07XG4gICAgICB2YXIgZGlzdCA9IHt9O1xuICAgICAgdmFyIHByZXYgPSB7fTtcbiAgICAgIHZhciBrbm93bkRpc3QgPSB7fTtcblxuICAgICAgdmFyIF90aGlzJGJ5R3JvdXAgPSB0aGlzLmJ5R3JvdXAoKSxcbiAgICAgICAgICBub2RlcyA9IF90aGlzJGJ5R3JvdXAubm9kZXMsXG4gICAgICAgICAgZWRnZXMgPSBfdGhpcyRieUdyb3VwLmVkZ2VzO1xuXG4gICAgICBlZGdlcy51bm1lcmdlQnkoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICByZXR1cm4gZWxlLmlzTG9vcCgpO1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBnZXREaXN0ID0gZnVuY3Rpb24gZ2V0RGlzdChub2RlKSB7XG4gICAgICAgIHJldHVybiBkaXN0W25vZGUuaWQoKV07XG4gICAgICB9O1xuXG4gICAgICB2YXIgc2V0RGlzdCA9IGZ1bmN0aW9uIHNldERpc3Qobm9kZSwgZCkge1xuICAgICAgICBkaXN0W25vZGUuaWQoKV0gPSBkO1xuICAgICAgICBRLnVwZGF0ZUl0ZW0obm9kZSk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgUSA9IG5ldyBoZWFwKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBnZXREaXN0KGEpIC0gZ2V0RGlzdChiKTtcbiAgICAgIH0pO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIGRpc3Rbbm9kZS5pZCgpXSA9IG5vZGUuc2FtZShzb3VyY2UpID8gMCA6IEluZmluaXR5O1xuICAgICAgICBRLnB1c2gobm9kZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBkaXN0QmV0d2VlbiA9IGZ1bmN0aW9uIGRpc3RCZXR3ZWVuKHUsIHYpIHtcbiAgICAgICAgdmFyIHV2cyA9IChkaXJlY3RlZCA/IHUuZWRnZXNUbyh2KSA6IHUuZWRnZXNXaXRoKHYpKS5pbnRlcnNlY3QoZWRnZXMpO1xuICAgICAgICB2YXIgc21hbGxlc3REaXN0YW5jZSA9IEluZmluaXR5O1xuICAgICAgICB2YXIgc21hbGxlc3RFZGdlO1xuXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB1dnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgdmFyIGVkZ2UgPSB1dnNbX2ldO1xuXG4gICAgICAgICAgdmFyIF93ZWlnaHQgPSB3ZWlnaHRGbihlZGdlKTtcblxuICAgICAgICAgIGlmIChfd2VpZ2h0IDwgc21hbGxlc3REaXN0YW5jZSB8fCAhc21hbGxlc3RFZGdlKSB7XG4gICAgICAgICAgICBzbWFsbGVzdERpc3RhbmNlID0gX3dlaWdodDtcbiAgICAgICAgICAgIHNtYWxsZXN0RWRnZSA9IGVkZ2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBlZGdlOiBzbWFsbGVzdEVkZ2UsXG4gICAgICAgICAgZGlzdDogc21hbGxlc3REaXN0YW5jZVxuICAgICAgICB9O1xuICAgICAgfTtcblxuICAgICAgd2hpbGUgKFEuc2l6ZSgpID4gMCkge1xuICAgICAgICB2YXIgdSA9IFEucG9wKCk7XG4gICAgICAgIHZhciBzbWFsbGV0c0Rpc3QgPSBnZXREaXN0KHUpO1xuICAgICAgICB2YXIgdWlkID0gdS5pZCgpO1xuICAgICAgICBrbm93bkRpc3RbdWlkXSA9IHNtYWxsZXRzRGlzdDtcblxuICAgICAgICBpZiAoc21hbGxldHNEaXN0ID09PSBJbmZpbml0eSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5laWdoYm9ycyA9IHUubmVpZ2hib3Job29kKCkuaW50ZXJzZWN0KG5vZGVzKTtcblxuICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBuZWlnaGJvcnMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICAgIHZhciB2ID0gbmVpZ2hib3JzW19pMl07XG4gICAgICAgICAgdmFyIHZpZCA9IHYuaWQoKTtcbiAgICAgICAgICB2YXIgdkRpc3QgPSBkaXN0QmV0d2Vlbih1LCB2KTtcbiAgICAgICAgICB2YXIgYWx0ID0gc21hbGxldHNEaXN0ICsgdkRpc3QuZGlzdDtcblxuICAgICAgICAgIGlmIChhbHQgPCBnZXREaXN0KHYpKSB7XG4gICAgICAgICAgICBzZXREaXN0KHYsIGFsdCk7XG4gICAgICAgICAgICBwcmV2W3ZpZF0gPSB7XG4gICAgICAgICAgICAgIG5vZGU6IHUsXG4gICAgICAgICAgICAgIGVkZ2U6IHZEaXN0LmVkZ2VcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIGZvclxuXG4gICAgICB9IC8vIHdoaWxlXG5cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGlzdGFuY2VUbzogZnVuY3Rpb24gZGlzdGFuY2VUbyhub2RlKSB7XG4gICAgICAgICAgdmFyIHRhcmdldCA9IHN0cmluZyhub2RlKSA/IG5vZGVzLmZpbHRlcihub2RlKVswXSA6IG5vZGVbMF07XG4gICAgICAgICAgcmV0dXJuIGtub3duRGlzdFt0YXJnZXQuaWQoKV07XG4gICAgICAgIH0sXG4gICAgICAgIHBhdGhUbzogZnVuY3Rpb24gcGF0aFRvKG5vZGUpIHtcbiAgICAgICAgICB2YXIgdGFyZ2V0ID0gc3RyaW5nKG5vZGUpID8gbm9kZXMuZmlsdGVyKG5vZGUpWzBdIDogbm9kZVswXTtcbiAgICAgICAgICB2YXIgUyA9IFtdO1xuICAgICAgICAgIHZhciB1ID0gdGFyZ2V0O1xuICAgICAgICAgIHZhciB1aWQgPSB1LmlkKCk7XG5cbiAgICAgICAgICBpZiAodGFyZ2V0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIFMudW5zaGlmdCh0YXJnZXQpO1xuXG4gICAgICAgICAgICB3aGlsZSAocHJldlt1aWRdKSB7XG4gICAgICAgICAgICAgIHZhciBwID0gcHJldlt1aWRdO1xuICAgICAgICAgICAgICBTLnVuc2hpZnQocC5lZGdlKTtcbiAgICAgICAgICAgICAgUy51bnNoaWZ0KHAubm9kZSk7XG4gICAgICAgICAgICAgIHUgPSBwLm5vZGU7XG4gICAgICAgICAgICAgIHVpZCA9IHUuaWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZWxlcy5zcGF3bihTKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGVsZXNmbiR0ID0ge1xuICAgIC8vIGtydXNrYWwncyBhbGdvcml0aG0gKGZpbmRzIG1pbiBzcGFubmluZyB0cmVlLCBhc3N1bWluZyB1bmRpcmVjdGVkIGdyYXBoKVxuICAgIC8vIGltcGxlbWVudGVkIGZyb20gcHNldWRvY29kZSBmcm9tIHdpa2lwZWRpYVxuICAgIGtydXNrYWw6IGZ1bmN0aW9uIGtydXNrYWwod2VpZ2h0Rm4pIHtcbiAgICAgIHdlaWdodEZuID0gd2VpZ2h0Rm4gfHwgZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9O1xuXG4gICAgICB2YXIgX3RoaXMkYnlHcm91cCA9IHRoaXMuYnlHcm91cCgpLFxuICAgICAgICAgIG5vZGVzID0gX3RoaXMkYnlHcm91cC5ub2RlcyxcbiAgICAgICAgICBlZGdlcyA9IF90aGlzJGJ5R3JvdXAuZWRnZXM7XG5cbiAgICAgIHZhciBudW1Ob2RlcyA9IG5vZGVzLmxlbmd0aDtcbiAgICAgIHZhciBmb3Jlc3QgPSBuZXcgQXJyYXkobnVtTm9kZXMpO1xuICAgICAgdmFyIEEgPSBub2RlczsgLy8gYXNzdW1lcyBieUdyb3VwKCkgY3JlYXRlcyBuZXcgY29sbGVjdGlvbnMgdGhhdCBjYW4gYmUgc2FmZWx5IG11dGF0ZWRcblxuICAgICAgdmFyIGZpbmRTZXRJbmRleCA9IGZ1bmN0aW9uIGZpbmRTZXRJbmRleChlbGUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb3Jlc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZWxlcyA9IGZvcmVzdFtpXTtcblxuICAgICAgICAgIGlmIChlbGVzLmhhcyhlbGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07IC8vIHN0YXJ0IHdpdGggb25lIGZvcmVzdCBwZXIgbm9kZVxuXG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgICBmb3Jlc3RbaV0gPSB0aGlzLnNwYXduKG5vZGVzW2ldKTtcbiAgICAgIH1cblxuICAgICAgdmFyIFMgPSBlZGdlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiB3ZWlnaHRGbihhKSAtIHdlaWdodEZuKGIpO1xuICAgICAgfSk7XG5cbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBTLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgZWRnZSA9IFNbX2ldO1xuICAgICAgICB2YXIgdSA9IGVkZ2Uuc291cmNlKClbMF07XG4gICAgICAgIHZhciB2ID0gZWRnZS50YXJnZXQoKVswXTtcbiAgICAgICAgdmFyIHNldFVJbmRleCA9IGZpbmRTZXRJbmRleCh1KTtcbiAgICAgICAgdmFyIHNldFZJbmRleCA9IGZpbmRTZXRJbmRleCh2KTtcbiAgICAgICAgdmFyIHNldFUgPSBmb3Jlc3Rbc2V0VUluZGV4XTtcbiAgICAgICAgdmFyIHNldFYgPSBmb3Jlc3Rbc2V0VkluZGV4XTtcblxuICAgICAgICBpZiAoc2V0VUluZGV4ICE9PSBzZXRWSW5kZXgpIHtcbiAgICAgICAgICBBLm1lcmdlKGVkZ2UpOyAvLyBjb21iaW5lIGZvcmVzdHMgZm9yIHUgYW5kIHZcblxuICAgICAgICAgIHNldFUubWVyZ2Uoc2V0Vik7XG4gICAgICAgICAgZm9yZXN0LnNwbGljZShzZXRWSW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBBO1xuICAgIH1cbiAgfTtcblxuICB2YXIgYVN0YXJEZWZhdWx0cyA9IGRlZmF1bHRzJGcoe1xuICAgIHJvb3Q6IG51bGwsXG4gICAgZ29hbDogbnVsbCxcbiAgICB3ZWlnaHQ6IGZ1bmN0aW9uIHdlaWdodChlZGdlKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9LFxuICAgIGhldXJpc3RpYzogZnVuY3Rpb24gaGV1cmlzdGljKGVkZ2UpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH0sXG4gICAgZGlyZWN0ZWQ6IGZhbHNlXG4gIH0pO1xuICB2YXIgZWxlc2ZuJHMgPSB7XG4gICAgLy8gSW1wbGVtZW50ZWQgZnJvbSBwc2V1ZG9jb2RlIGZyb20gd2lraXBlZGlhXG4gICAgYVN0YXI6IGZ1bmN0aW9uIGFTdGFyKG9wdGlvbnMpIHtcbiAgICAgIHZhciBjeSA9IHRoaXMuY3koKTtcblxuICAgICAgdmFyIF9hU3RhckRlZmF1bHRzID0gYVN0YXJEZWZhdWx0cyhvcHRpb25zKSxcbiAgICAgICAgICByb290ID0gX2FTdGFyRGVmYXVsdHMucm9vdCxcbiAgICAgICAgICBnb2FsID0gX2FTdGFyRGVmYXVsdHMuZ29hbCxcbiAgICAgICAgICBoZXVyaXN0aWMgPSBfYVN0YXJEZWZhdWx0cy5oZXVyaXN0aWMsXG4gICAgICAgICAgZGlyZWN0ZWQgPSBfYVN0YXJEZWZhdWx0cy5kaXJlY3RlZCxcbiAgICAgICAgICB3ZWlnaHQgPSBfYVN0YXJEZWZhdWx0cy53ZWlnaHQ7XG5cbiAgICAgIHJvb3QgPSBjeS5jb2xsZWN0aW9uKHJvb3QpWzBdO1xuICAgICAgZ29hbCA9IGN5LmNvbGxlY3Rpb24oZ29hbClbMF07XG4gICAgICB2YXIgc2lkID0gcm9vdC5pZCgpO1xuICAgICAgdmFyIHRpZCA9IGdvYWwuaWQoKTtcbiAgICAgIHZhciBnU2NvcmUgPSB7fTtcbiAgICAgIHZhciBmU2NvcmUgPSB7fTtcbiAgICAgIHZhciBjbG9zZWRTZXRJZHMgPSB7fTtcbiAgICAgIHZhciBvcGVuU2V0ID0gbmV3IGhlYXAoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGZTY29yZVthLmlkKCldIC0gZlNjb3JlW2IuaWQoKV07XG4gICAgICB9KTtcbiAgICAgIHZhciBvcGVuU2V0SWRzID0gbmV3IFNldCQxKCk7XG4gICAgICB2YXIgY2FtZUZyb20gPSB7fTtcbiAgICAgIHZhciBjYW1lRnJvbUVkZ2UgPSB7fTtcblxuICAgICAgdmFyIGFkZFRvT3BlblNldCA9IGZ1bmN0aW9uIGFkZFRvT3BlblNldChlbGUsIGlkKSB7XG4gICAgICAgIG9wZW5TZXQucHVzaChlbGUpO1xuICAgICAgICBvcGVuU2V0SWRzLmFkZChpZCk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgY01pbiwgY01pbklkO1xuXG4gICAgICB2YXIgcG9wRnJvbU9wZW5TZXQgPSBmdW5jdGlvbiBwb3BGcm9tT3BlblNldCgpIHtcbiAgICAgICAgY01pbiA9IG9wZW5TZXQucG9wKCk7XG4gICAgICAgIGNNaW5JZCA9IGNNaW4uaWQoKTtcbiAgICAgICAgb3BlblNldElkc1tcImRlbGV0ZVwiXShjTWluSWQpO1xuICAgICAgfTtcblxuICAgICAgdmFyIGlzSW5PcGVuU2V0ID0gZnVuY3Rpb24gaXNJbk9wZW5TZXQoaWQpIHtcbiAgICAgICAgcmV0dXJuIG9wZW5TZXRJZHMuaGFzKGlkKTtcbiAgICAgIH07XG5cbiAgICAgIGFkZFRvT3BlblNldChyb290LCBzaWQpO1xuICAgICAgZ1Njb3JlW3NpZF0gPSAwO1xuICAgICAgZlNjb3JlW3NpZF0gPSBoZXVyaXN0aWMocm9vdCk7IC8vIENvdW50ZXJcblxuICAgICAgdmFyIHN0ZXBzID0gMDsgLy8gTWFpbiBsb29wXG5cbiAgICAgIHdoaWxlIChvcGVuU2V0LnNpemUoKSA+IDApIHtcbiAgICAgICAgcG9wRnJvbU9wZW5TZXQoKTtcbiAgICAgICAgc3RlcHMrKzsgLy8gSWYgd2UndmUgZm91bmQgb3VyIGdvYWwsIHRoZW4gd2UgYXJlIGRvbmVcblxuICAgICAgICBpZiAoY01pbklkID09PSB0aWQpIHtcbiAgICAgICAgICB2YXIgcGF0aCA9IFtdO1xuICAgICAgICAgIHZhciBwYXRoTm9kZSA9IGdvYWw7XG4gICAgICAgICAgdmFyIHBhdGhOb2RlSWQgPSB0aWQ7XG4gICAgICAgICAgdmFyIHBhdGhFZGdlID0gY2FtZUZyb21FZGdlW3BhdGhOb2RlSWRdO1xuXG4gICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgcGF0aC51bnNoaWZ0KHBhdGhOb2RlKTtcblxuICAgICAgICAgICAgaWYgKHBhdGhFZGdlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgcGF0aC51bnNoaWZ0KHBhdGhFZGdlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGF0aE5vZGUgPSBjYW1lRnJvbVtwYXRoTm9kZUlkXTtcblxuICAgICAgICAgICAgaWYgKHBhdGhOb2RlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBhdGhOb2RlSWQgPSBwYXRoTm9kZS5pZCgpO1xuICAgICAgICAgICAgcGF0aEVkZ2UgPSBjYW1lRnJvbUVkZ2VbcGF0aE5vZGVJZF07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZvdW5kOiB0cnVlLFxuICAgICAgICAgICAgZGlzdGFuY2U6IGdTY29yZVtjTWluSWRdLFxuICAgICAgICAgICAgcGF0aDogdGhpcy5zcGF3bihwYXRoKSxcbiAgICAgICAgICAgIHN0ZXBzOiBzdGVwc1xuICAgICAgICAgIH07XG4gICAgICAgIH0gLy8gQWRkIGNNaW4gdG8gcHJvY2Vzc2VkIG5vZGVzXG5cblxuICAgICAgICBjbG9zZWRTZXRJZHNbY01pbklkXSA9IHRydWU7IC8vIFVwZGF0ZSBzY29yZXMgZm9yIG5laWdoYm9ycyBvZiBjTWluXG4gICAgICAgIC8vIFRha2UgaW50byBhY2NvdW50IGlmIGdyYXBoIGlzIGRpcmVjdGVkIG9yIG5vdFxuXG4gICAgICAgIHZhciB2d0VkZ2VzID0gY01pbi5fcHJpdmF0ZS5lZGdlcztcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZ3RWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZSA9IHZ3RWRnZXNbaV07IC8vIGVkZ2UgbXVzdCBiZSBpbiBzZXQgb2YgY2FsbGluZyBlbGVzXG5cbiAgICAgICAgICBpZiAoIXRoaXMuaGFzRWxlbWVudFdpdGhJZChlLmlkKCkpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IC8vIGNNaW4gbXVzdCBiZSB0aGUgc291cmNlIG9mIGVkZ2UgaWYgZGlyZWN0ZWRcblxuXG4gICAgICAgICAgaWYgKGRpcmVjdGVkICYmIGUuZGF0YSgnc291cmNlJykgIT09IGNNaW5JZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHdTcmMgPSBlLnNvdXJjZSgpO1xuICAgICAgICAgIHZhciB3VGd0ID0gZS50YXJnZXQoKTtcbiAgICAgICAgICB2YXIgdyA9IHdTcmMuaWQoKSAhPT0gY01pbklkID8gd1NyYyA6IHdUZ3Q7XG4gICAgICAgICAgdmFyIHdpZCA9IHcuaWQoKTsgLy8gbm9kZSBtdXN0IGJlIGluIHNldCBvZiBjYWxsaW5nIGVsZXNcblxuICAgICAgICAgIGlmICghdGhpcy5oYXNFbGVtZW50V2l0aElkKHdpZCkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gLy8gaWYgbm9kZSBpcyBpbiBjbG9zZWRTZXQsIGlnbm9yZSBpdFxuXG5cbiAgICAgICAgICBpZiAoY2xvc2VkU2V0SWRzW3dpZF0pIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gLy8gTmV3IHRlbnRhdGl2ZSBzY29yZSBmb3Igbm9kZSB3XG5cblxuICAgICAgICAgIHZhciB0ZW1wU2NvcmUgPSBnU2NvcmVbY01pbklkXSArIHdlaWdodChlKTsgLy8gVXBkYXRlIGdTY29yZSBmb3Igbm9kZSB3IGlmOlxuICAgICAgICAgIC8vICAgdyBub3QgcHJlc2VudCBpbiBvcGVuU2V0XG4gICAgICAgICAgLy8gT1JcbiAgICAgICAgICAvLyAgIHRlbnRhdGl2ZSBnU2NvcmUgaXMgbGVzcyB0aGFuIHByZXZpb3VzIHZhbHVlXG4gICAgICAgICAgLy8gdyBub3QgaW4gb3BlblNldFxuXG4gICAgICAgICAgaWYgKCFpc0luT3BlblNldCh3aWQpKSB7XG4gICAgICAgICAgICBnU2NvcmVbd2lkXSA9IHRlbXBTY29yZTtcbiAgICAgICAgICAgIGZTY29yZVt3aWRdID0gdGVtcFNjb3JlICsgaGV1cmlzdGljKHcpO1xuICAgICAgICAgICAgYWRkVG9PcGVuU2V0KHcsIHdpZCk7XG4gICAgICAgICAgICBjYW1lRnJvbVt3aWRdID0gY01pbjtcbiAgICAgICAgICAgIGNhbWVGcm9tRWRnZVt3aWRdID0gZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gLy8gdyBhbHJlYWR5IGluIG9wZW5TZXQsIGJ1dCB3aXRoIGdyZWF0ZXIgZ1Njb3JlXG5cblxuICAgICAgICAgIGlmICh0ZW1wU2NvcmUgPCBnU2NvcmVbd2lkXSkge1xuICAgICAgICAgICAgZ1Njb3JlW3dpZF0gPSB0ZW1wU2NvcmU7XG4gICAgICAgICAgICBmU2NvcmVbd2lkXSA9IHRlbXBTY29yZSArIGhldXJpc3RpYyh3KTtcbiAgICAgICAgICAgIGNhbWVGcm9tW3dpZF0gPSBjTWluO1xuICAgICAgICAgICAgY2FtZUZyb21FZGdlW3dpZF0gPSBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBFbmQgb2YgbmVpZ2hib3JzIHVwZGF0ZVxuXG4gICAgICB9IC8vIEVuZCBvZiBtYWluIGxvb3BcbiAgICAgIC8vIElmIHdlJ3ZlIHJlYWNoZWQgaGVyZSwgdGhlbiB3ZSd2ZSBub3QgcmVhY2hlZCBvdXIgZ29hbFxuXG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGZvdW5kOiBmYWxzZSxcbiAgICAgICAgZGlzdGFuY2U6IHVuZGVmaW5lZCxcbiAgICAgICAgcGF0aDogdW5kZWZpbmVkLFxuICAgICAgICBzdGVwczogc3RlcHNcbiAgICAgIH07XG4gICAgfVxuICB9OyAvLyBlbGVzZm5cblxuICB2YXIgZmxveWRXYXJzaGFsbERlZmF1bHRzID0gZGVmYXVsdHMkZyh7XG4gICAgd2VpZ2h0OiBmdW5jdGlvbiB3ZWlnaHQoZWRnZSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSxcbiAgICBkaXJlY3RlZDogZmFsc2VcbiAgfSk7XG4gIHZhciBlbGVzZm4kciA9IHtcbiAgICAvLyBJbXBsZW1lbnRlZCBmcm9tIHBzZXVkb2NvZGUgZnJvbSB3aWtpcGVkaWFcbiAgICBmbG95ZFdhcnNoYWxsOiBmdW5jdGlvbiBmbG95ZFdhcnNoYWxsKG9wdGlvbnMpIHtcbiAgICAgIHZhciBjeSA9IHRoaXMuY3koKTtcblxuICAgICAgdmFyIF9mbG95ZFdhcnNoYWxsRGVmYXVsdCA9IGZsb3lkV2Fyc2hhbGxEZWZhdWx0cyhvcHRpb25zKSxcbiAgICAgICAgICB3ZWlnaHQgPSBfZmxveWRXYXJzaGFsbERlZmF1bHQud2VpZ2h0LFxuICAgICAgICAgIGRpcmVjdGVkID0gX2Zsb3lkV2Fyc2hhbGxEZWZhdWx0LmRpcmVjdGVkO1xuXG4gICAgICB2YXIgd2VpZ2h0Rm4gPSB3ZWlnaHQ7XG5cbiAgICAgIHZhciBfdGhpcyRieUdyb3VwID0gdGhpcy5ieUdyb3VwKCksXG4gICAgICAgICAgbm9kZXMgPSBfdGhpcyRieUdyb3VwLm5vZGVzLFxuICAgICAgICAgIGVkZ2VzID0gX3RoaXMkYnlHcm91cC5lZGdlcztcblxuICAgICAgdmFyIE4gPSBub2Rlcy5sZW5ndGg7XG4gICAgICB2YXIgTnNxID0gTiAqIE47XG5cbiAgICAgIHZhciBpbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZihub2RlKSB7XG4gICAgICAgIHJldHVybiBub2Rlcy5pbmRleE9mKG5vZGUpO1xuICAgICAgfTtcblxuICAgICAgdmFyIGF0SW5kZXggPSBmdW5jdGlvbiBhdEluZGV4KGkpIHtcbiAgICAgICAgcmV0dXJuIG5vZGVzW2ldO1xuICAgICAgfTsgLy8gSW5pdGlhbGl6ZSBkaXN0YW5jZSBtYXRyaXhcblxuXG4gICAgICB2YXIgZGlzdCA9IG5ldyBBcnJheShOc3EpO1xuXG4gICAgICBmb3IgKHZhciBuID0gMDsgbiA8IE5zcTsgbisrKSB7XG4gICAgICAgIHZhciBqID0gbiAlIE47XG4gICAgICAgIHZhciBpID0gKG4gLSBqKSAvIE47XG5cbiAgICAgICAgaWYgKGkgPT09IGopIHtcbiAgICAgICAgICBkaXN0W25dID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkaXN0W25dID0gSW5maW5pdHk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gSW5pdGlhbGl6ZSBtYXRyaXggdXNlZCBmb3IgcGF0aCByZWNvbnN0cnVjdGlvblxuICAgICAgLy8gSW5pdGlhbGl6ZSBkaXN0YW5jZSBtYXRyaXhcblxuXG4gICAgICB2YXIgbmV4dCA9IG5ldyBBcnJheShOc3EpO1xuICAgICAgdmFyIGVkZ2VOZXh0ID0gbmV3IEFycmF5KE5zcSk7IC8vIFByb2Nlc3MgZWRnZXNcblxuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGVkZ2VzLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW19pXTtcbiAgICAgICAgdmFyIHNyYyA9IGVkZ2Uuc291cmNlKClbMF07XG4gICAgICAgIHZhciB0Z3QgPSBlZGdlLnRhcmdldCgpWzBdO1xuXG4gICAgICAgIGlmIChzcmMgPT09IHRndCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIGV4Y2x1ZGUgbG9vcHNcblxuXG4gICAgICAgIHZhciBzID0gaW5kZXhPZihzcmMpO1xuICAgICAgICB2YXIgdCA9IGluZGV4T2YodGd0KTtcbiAgICAgICAgdmFyIHN0ID0gcyAqIE4gKyB0OyAvLyBzb3VyY2UgdG8gdGFyZ2V0IGluZGV4XG5cbiAgICAgICAgdmFyIF93ZWlnaHQgPSB3ZWlnaHRGbihlZGdlKTsgLy8gQ2hlY2sgaWYgYWxyZWFkeSBwcm9jZXNzIGFub3RoZXIgZWRnZSBiZXR3ZWVuIHNhbWUgMiBub2Rlc1xuXG5cbiAgICAgICAgaWYgKGRpc3Rbc3RdID4gX3dlaWdodCkge1xuICAgICAgICAgIGRpc3Rbc3RdID0gX3dlaWdodDtcbiAgICAgICAgICBuZXh0W3N0XSA9IHQ7XG4gICAgICAgICAgZWRnZU5leHRbc3RdID0gZWRnZTtcbiAgICAgICAgfSAvLyBJZiB1bmRpcmVjdGVkIGdyYXBoLCBwcm9jZXNzICdyZXZlcnNlZCcgZWRnZVxuXG5cbiAgICAgICAgaWYgKCFkaXJlY3RlZCkge1xuICAgICAgICAgIHZhciB0cyA9IHQgKiBOICsgczsgLy8gdGFyZ2V0IHRvIHNvdXJjZSBpbmRleFxuXG4gICAgICAgICAgaWYgKCFkaXJlY3RlZCAmJiBkaXN0W3RzXSA+IF93ZWlnaHQpIHtcbiAgICAgICAgICAgIGRpc3RbdHNdID0gX3dlaWdodDtcbiAgICAgICAgICAgIG5leHRbdHNdID0gcztcbiAgICAgICAgICAgIGVkZ2VOZXh0W3RzXSA9IGVkZ2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIE1haW4gbG9vcFxuXG5cbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgTjsgaysrKSB7XG4gICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IE47IF9pMisrKSB7XG4gICAgICAgICAgdmFyIGlrID0gX2kyICogTiArIGs7XG5cbiAgICAgICAgICBmb3IgKHZhciBfaiA9IDA7IF9qIDwgTjsgX2orKykge1xuICAgICAgICAgICAgdmFyIGlqID0gX2kyICogTiArIF9qO1xuICAgICAgICAgICAgdmFyIGtqID0gayAqIE4gKyBfajtcblxuICAgICAgICAgICAgaWYgKGRpc3RbaWtdICsgZGlzdFtral0gPCBkaXN0W2lqXSkge1xuICAgICAgICAgICAgICBkaXN0W2lqXSA9IGRpc3RbaWtdICsgZGlzdFtral07XG4gICAgICAgICAgICAgIG5leHRbaWpdID0gbmV4dFtpa107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBnZXRBcmdFbGUgPSBmdW5jdGlvbiBnZXRBcmdFbGUoZWxlKSB7XG4gICAgICAgIHJldHVybiAoc3RyaW5nKGVsZSkgPyBjeS5maWx0ZXIoZWxlKSA6IGVsZSlbMF07XG4gICAgICB9O1xuXG4gICAgICB2YXIgaW5kZXhPZkFyZ0VsZSA9IGZ1bmN0aW9uIGluZGV4T2ZBcmdFbGUoZWxlKSB7XG4gICAgICAgIHJldHVybiBpbmRleE9mKGdldEFyZ0VsZShlbGUpKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciByZXMgPSB7XG4gICAgICAgIGRpc3RhbmNlOiBmdW5jdGlvbiBkaXN0YW5jZShmcm9tLCB0bykge1xuICAgICAgICAgIHZhciBpID0gaW5kZXhPZkFyZ0VsZShmcm9tKTtcbiAgICAgICAgICB2YXIgaiA9IGluZGV4T2ZBcmdFbGUodG8pO1xuICAgICAgICAgIHJldHVybiBkaXN0W2kgKiBOICsgal07XG4gICAgICAgIH0sXG4gICAgICAgIHBhdGg6IGZ1bmN0aW9uIHBhdGgoZnJvbSwgdG8pIHtcbiAgICAgICAgICB2YXIgaSA9IGluZGV4T2ZBcmdFbGUoZnJvbSk7XG4gICAgICAgICAgdmFyIGogPSBpbmRleE9mQXJnRWxlKHRvKTtcbiAgICAgICAgICB2YXIgZnJvbU5vZGUgPSBhdEluZGV4KGkpO1xuXG4gICAgICAgICAgaWYgKGkgPT09IGopIHtcbiAgICAgICAgICAgIHJldHVybiBmcm9tTm9kZS5jb2xsZWN0aW9uKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG5leHRbaSAqIE4gKyBqXSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gY3kuY29sbGVjdGlvbigpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBwYXRoID0gY3kuY29sbGVjdGlvbigpO1xuICAgICAgICAgIHZhciBwcmV2ID0gaTtcbiAgICAgICAgICB2YXIgZWRnZTtcbiAgICAgICAgICBwYXRoLm1lcmdlKGZyb21Ob2RlKTtcblxuICAgICAgICAgIHdoaWxlIChpICE9PSBqKSB7XG4gICAgICAgICAgICBwcmV2ID0gaTtcbiAgICAgICAgICAgIGkgPSBuZXh0W2kgKiBOICsgal07XG4gICAgICAgICAgICBlZGdlID0gZWRnZU5leHRbcHJldiAqIE4gKyBpXTtcbiAgICAgICAgICAgIHBhdGgubWVyZ2UoZWRnZSk7XG4gICAgICAgICAgICBwYXRoLm1lcmdlKGF0SW5kZXgoaSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9IC8vIGZsb3lkV2Fyc2hhbGxcblxuICB9OyAvLyBlbGVzZm5cblxuICB2YXIgYmVsbG1hbkZvcmREZWZhdWx0cyA9IGRlZmF1bHRzJGcoe1xuICAgIHdlaWdodDogZnVuY3Rpb24gd2VpZ2h0KGVkZ2UpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0sXG4gICAgZGlyZWN0ZWQ6IGZhbHNlLFxuICAgIHJvb3Q6IG51bGxcbiAgfSk7XG4gIHZhciBlbGVzZm4kcSA9IHtcbiAgICAvLyBJbXBsZW1lbnRlZCBmcm9tIHBzZXVkb2NvZGUgZnJvbSB3aWtpcGVkaWFcbiAgICBiZWxsbWFuRm9yZDogZnVuY3Rpb24gYmVsbG1hbkZvcmQob3B0aW9ucykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIF9iZWxsbWFuRm9yZERlZmF1bHRzID0gYmVsbG1hbkZvcmREZWZhdWx0cyhvcHRpb25zKSxcbiAgICAgICAgICB3ZWlnaHQgPSBfYmVsbG1hbkZvcmREZWZhdWx0cy53ZWlnaHQsXG4gICAgICAgICAgZGlyZWN0ZWQgPSBfYmVsbG1hbkZvcmREZWZhdWx0cy5kaXJlY3RlZCxcbiAgICAgICAgICByb290ID0gX2JlbGxtYW5Gb3JkRGVmYXVsdHMucm9vdDtcblxuICAgICAgdmFyIHdlaWdodEZuID0gd2VpZ2h0O1xuICAgICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuXG4gICAgICB2YXIgX3RoaXMkYnlHcm91cCA9IHRoaXMuYnlHcm91cCgpLFxuICAgICAgICAgIGVkZ2VzID0gX3RoaXMkYnlHcm91cC5lZGdlcyxcbiAgICAgICAgICBub2RlcyA9IF90aGlzJGJ5R3JvdXAubm9kZXM7XG5cbiAgICAgIHZhciBudW1Ob2RlcyA9IG5vZGVzLmxlbmd0aDtcbiAgICAgIHZhciBpbmZvTWFwID0gbmV3IE1hcCQyKCk7XG4gICAgICB2YXIgaGFzTmVnYXRpdmVXZWlnaHRDeWNsZSA9IGZhbHNlO1xuICAgICAgdmFyIG5lZ2F0aXZlV2VpZ2h0Q3ljbGVzID0gW107XG4gICAgICByb290ID0gY3kuY29sbGVjdGlvbihyb290KVswXTsgLy8gaW4gY2FzZSBzZWxlY3RvciBwYXNzZWRcblxuICAgICAgZWRnZXMudW5tZXJnZUJ5KGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgIHJldHVybiBlZGdlLmlzTG9vcCgpO1xuICAgICAgfSk7XG4gICAgICB2YXIgbnVtRWRnZXMgPSBlZGdlcy5sZW5ndGg7XG5cbiAgICAgIHZhciBnZXRJbmZvID0gZnVuY3Rpb24gZ2V0SW5mbyhub2RlKSB7XG4gICAgICAgIHZhciBvYmogPSBpbmZvTWFwLmdldChub2RlLmlkKCkpO1xuXG4gICAgICAgIGlmICghb2JqKSB7XG4gICAgICAgICAgb2JqID0ge307XG4gICAgICAgICAgaW5mb01hcC5zZXQobm9kZS5pZCgpLCBvYmopO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgIH07XG5cbiAgICAgIHZhciBnZXROb2RlRnJvbVRvID0gZnVuY3Rpb24gZ2V0Tm9kZUZyb21Ubyh0bykge1xuICAgICAgICByZXR1cm4gKHN0cmluZyh0bykgPyBjeS4kKHRvKSA6IHRvKVswXTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBkaXN0YW5jZVRvID0gZnVuY3Rpb24gZGlzdGFuY2VUbyh0bykge1xuICAgICAgICByZXR1cm4gZ2V0SW5mbyhnZXROb2RlRnJvbVRvKHRvKSkuZGlzdDtcbiAgICAgIH07XG5cbiAgICAgIHZhciBwYXRoVG8gPSBmdW5jdGlvbiBwYXRoVG8odG8pIHtcbiAgICAgICAgdmFyIHRoaXNTdGFydCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogcm9vdDtcbiAgICAgICAgdmFyIGVuZCA9IGdldE5vZGVGcm9tVG8odG8pO1xuICAgICAgICB2YXIgcGF0aCA9IFtdO1xuICAgICAgICB2YXIgbm9kZSA9IGVuZDtcblxuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnNwYXduKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9nZXRJbmZvID0gZ2V0SW5mbyhub2RlKSxcbiAgICAgICAgICAgICAgZWRnZSA9IF9nZXRJbmZvLmVkZ2UsXG4gICAgICAgICAgICAgIHByZWQgPSBfZ2V0SW5mby5wcmVkO1xuXG4gICAgICAgICAgcGF0aC51bnNoaWZ0KG5vZGVbMF0pO1xuXG4gICAgICAgICAgaWYgKG5vZGUuc2FtZSh0aGlzU3RhcnQpICYmIHBhdGgubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGVkZ2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgcGF0aC51bnNoaWZ0KGVkZ2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG5vZGUgPSBwcmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVsZXMuc3Bhd24ocGF0aCk7XG4gICAgICB9OyAvLyBJbml0aWFsaXphdGlvbnMgeyBkaXN0LCBwcmVkLCBlZGdlIH1cblxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgdmFyIGluZm8gPSBnZXRJbmZvKG5vZGUpO1xuXG4gICAgICAgIGlmIChub2RlLnNhbWUocm9vdCkpIHtcbiAgICAgICAgICBpbmZvLmRpc3QgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluZm8uZGlzdCA9IEluZmluaXR5O1xuICAgICAgICB9XG5cbiAgICAgICAgaW5mby5wcmVkID0gbnVsbDtcbiAgICAgICAgaW5mby5lZGdlID0gbnVsbDtcbiAgICAgIH0gLy8gRWRnZXMgcmVsYXhhdGlvblxuXG5cbiAgICAgIHZhciByZXBsYWNlZEVkZ2UgPSBmYWxzZTtcblxuICAgICAgdmFyIGNoZWNrRm9yRWRnZVJlcGxhY2VtZW50ID0gZnVuY3Rpb24gY2hlY2tGb3JFZGdlUmVwbGFjZW1lbnQobm9kZTEsIG5vZGUyLCBlZGdlLCBpbmZvMSwgaW5mbzIsIHdlaWdodCkge1xuICAgICAgICB2YXIgZGlzdCA9IGluZm8xLmRpc3QgKyB3ZWlnaHQ7XG5cbiAgICAgICAgaWYgKGRpc3QgPCBpbmZvMi5kaXN0ICYmICFlZGdlLnNhbWUoaW5mbzEuZWRnZSkpIHtcbiAgICAgICAgICBpbmZvMi5kaXN0ID0gZGlzdDtcbiAgICAgICAgICBpbmZvMi5wcmVkID0gbm9kZTE7XG4gICAgICAgICAgaW5mbzIuZWRnZSA9IGVkZ2U7XG4gICAgICAgICAgcmVwbGFjZWRFZGdlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IG51bU5vZGVzOyBfaSsrKSB7XG4gICAgICAgIHJlcGxhY2VkRWRnZSA9IGZhbHNlO1xuXG4gICAgICAgIGZvciAodmFyIGUgPSAwOyBlIDwgbnVtRWRnZXM7IGUrKykge1xuICAgICAgICAgIHZhciBlZGdlID0gZWRnZXNbZV07XG4gICAgICAgICAgdmFyIHNyYyA9IGVkZ2Uuc291cmNlKCk7XG4gICAgICAgICAgdmFyIHRndCA9IGVkZ2UudGFyZ2V0KCk7XG5cbiAgICAgICAgICB2YXIgX3dlaWdodCA9IHdlaWdodEZuKGVkZ2UpO1xuXG4gICAgICAgICAgdmFyIHNyY0luZm8gPSBnZXRJbmZvKHNyYyk7XG4gICAgICAgICAgdmFyIHRndEluZm8gPSBnZXRJbmZvKHRndCk7XG4gICAgICAgICAgY2hlY2tGb3JFZGdlUmVwbGFjZW1lbnQoc3JjLCB0Z3QsIGVkZ2UsIHNyY0luZm8sIHRndEluZm8sIF93ZWlnaHQpOyAvLyBJZiB1bmRpcmVjdGVkIGdyYXBoLCB3ZSBuZWVkIHRvIHRha2UgaW50byBhY2NvdW50IHRoZSAncmV2ZXJzZScgZWRnZVxuXG4gICAgICAgICAgaWYgKCFkaXJlY3RlZCkge1xuICAgICAgICAgICAgY2hlY2tGb3JFZGdlUmVwbGFjZW1lbnQodGd0LCBzcmMsIGVkZ2UsIHRndEluZm8sIHNyY0luZm8sIF93ZWlnaHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcmVwbGFjZWRFZGdlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHJlcGxhY2VkRWRnZSkge1xuICAgICAgICAvLyBDaGVjayBmb3IgbmVnYXRpdmUgd2VpZ2h0IGN5Y2xlc1xuICAgICAgICB2YXIgbmVnYXRpdmVXZWlnaHRDeWNsZUlkcyA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIF9lID0gMDsgX2UgPCBudW1FZGdlczsgX2UrKykge1xuICAgICAgICAgIHZhciBfZWRnZSA9IGVkZ2VzW19lXTtcblxuICAgICAgICAgIHZhciBfc3JjID0gX2VkZ2Uuc291cmNlKCk7XG5cbiAgICAgICAgICB2YXIgX3RndCA9IF9lZGdlLnRhcmdldCgpO1xuXG4gICAgICAgICAgdmFyIF93ZWlnaHQyID0gd2VpZ2h0Rm4oX2VkZ2UpO1xuXG4gICAgICAgICAgdmFyIHNyY0Rpc3QgPSBnZXRJbmZvKF9zcmMpLmRpc3Q7XG4gICAgICAgICAgdmFyIHRndERpc3QgPSBnZXRJbmZvKF90Z3QpLmRpc3Q7XG5cbiAgICAgICAgICBpZiAoc3JjRGlzdCArIF93ZWlnaHQyIDwgdGd0RGlzdCB8fCAhZGlyZWN0ZWQgJiYgdGd0RGlzdCArIF93ZWlnaHQyIDwgc3JjRGlzdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNOZWdhdGl2ZVdlaWdodEN5Y2xlKSB7XG4gICAgICAgICAgICAgIHdhcm4oJ0dyYXBoIGNvbnRhaW5zIGEgbmVnYXRpdmUgd2VpZ2h0IGN5Y2xlIGZvciBCZWxsbWFuLUZvcmQnKTtcbiAgICAgICAgICAgICAgaGFzTmVnYXRpdmVXZWlnaHRDeWNsZSA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmZpbmROZWdhdGl2ZVdlaWdodEN5Y2xlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgdmFyIG5lZ2F0aXZlTm9kZXMgPSBbXTtcblxuICAgICAgICAgICAgICBpZiAoc3JjRGlzdCArIF93ZWlnaHQyIDwgdGd0RGlzdCkge1xuICAgICAgICAgICAgICAgIG5lZ2F0aXZlTm9kZXMucHVzaChfc3JjKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghZGlyZWN0ZWQgJiYgdGd0RGlzdCArIF93ZWlnaHQyIDwgc3JjRGlzdCkge1xuICAgICAgICAgICAgICAgIG5lZ2F0aXZlTm9kZXMucHVzaChfdGd0KTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBudW1OZWdhdGl2ZU5vZGVzID0gbmVnYXRpdmVOb2Rlcy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBudW1OZWdhdGl2ZU5vZGVzOyBuKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBuZWdhdGl2ZU5vZGVzW25dO1xuICAgICAgICAgICAgICAgIHZhciBjeWNsZSA9IFtzdGFydF07XG4gICAgICAgICAgICAgICAgY3ljbGUucHVzaChnZXRJbmZvKHN0YXJ0KS5lZGdlKTtcbiAgICAgICAgICAgICAgICB2YXIgX25vZGUgPSBnZXRJbmZvKHN0YXJ0KS5wcmVkO1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKGN5Y2xlLmluZGV4T2YoX25vZGUpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgY3ljbGUucHVzaChfbm9kZSk7XG4gICAgICAgICAgICAgICAgICBjeWNsZS5wdXNoKGdldEluZm8oX25vZGUpLmVkZ2UpO1xuICAgICAgICAgICAgICAgICAgX25vZGUgPSBnZXRJbmZvKF9ub2RlKS5wcmVkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGN5Y2xlID0gY3ljbGUuc2xpY2UoY3ljbGUuaW5kZXhPZihfbm9kZSkpO1xuICAgICAgICAgICAgICAgIHZhciBzbWFsbGVzdElkID0gY3ljbGVbMF0uaWQoKTtcbiAgICAgICAgICAgICAgICB2YXIgc21hbGxlc3RJbmRleCA9IDA7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjID0gMjsgYyA8IGN5Y2xlLmxlbmd0aDsgYyArPSAyKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoY3ljbGVbY10uaWQoKSA8IHNtYWxsZXN0SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc21hbGxlc3RJZCA9IGN5Y2xlW2NdLmlkKCk7XG4gICAgICAgICAgICAgICAgICAgIHNtYWxsZXN0SW5kZXggPSBjO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGN5Y2xlID0gY3ljbGUuc2xpY2Uoc21hbGxlc3RJbmRleCkuY29uY2F0KGN5Y2xlLnNsaWNlKDAsIHNtYWxsZXN0SW5kZXgpKTtcbiAgICAgICAgICAgICAgICBjeWNsZS5wdXNoKGN5Y2xlWzBdKTtcbiAgICAgICAgICAgICAgICB2YXIgY3ljbGVJZCA9IGN5Y2xlLm1hcChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBlbC5pZCgpO1xuICAgICAgICAgICAgICAgIH0pLmpvaW4oXCIsXCIpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG5lZ2F0aXZlV2VpZ2h0Q3ljbGVJZHMuaW5kZXhPZihjeWNsZUlkKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgIG5lZ2F0aXZlV2VpZ2h0Q3ljbGVzLnB1c2goZWxlcy5zcGF3bihjeWNsZSkpO1xuICAgICAgICAgICAgICAgICAgbmVnYXRpdmVXZWlnaHRDeWNsZUlkcy5wdXNoKGN5Y2xlSWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpc3RhbmNlVG86IGRpc3RhbmNlVG8sXG4gICAgICAgIHBhdGhUbzogcGF0aFRvLFxuICAgICAgICBoYXNOZWdhdGl2ZVdlaWdodEN5Y2xlOiBoYXNOZWdhdGl2ZVdlaWdodEN5Y2xlLFxuICAgICAgICBuZWdhdGl2ZVdlaWdodEN5Y2xlczogbmVnYXRpdmVXZWlnaHRDeWNsZXNcbiAgICAgIH07XG4gICAgfSAvLyBiZWxsbWFuRm9yZFxuXG4gIH07IC8vIGVsZXNmblxuXG4gIHZhciBzcXJ0MiA9IE1hdGguc3FydCgyKTsgLy8gRnVuY3Rpb24gd2hpY2ggY29sYXBzZXMgMiAobWV0YSkgbm9kZXMgaW50byBvbmVcbiAgLy8gVXBkYXRlcyB0aGUgcmVtYWluaW5nIGVkZ2UgbGlzdHNcbiAgLy8gUmVjZWl2ZXMgYXMgYSBwYXJhbWF0ZXIgdGhlIGVkZ2Ugd2hpY2ggY2F1c2VzIHRoZSBjb2xsYXBzZVxuXG4gIHZhciBjb2xsYXBzZSA9IGZ1bmN0aW9uIGNvbGxhcHNlKGVkZ2VJbmRleCwgbm9kZU1hcCwgcmVtYWluaW5nRWRnZXMpIHtcbiAgICBpZiAocmVtYWluaW5nRWRnZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICBlcnJvcihcIkthcmdlci1TdGVpbiBtdXN0IGJlIHJ1biBvbiBhIGNvbm5lY3RlZCAoc3ViKWdyYXBoXCIpO1xuICAgIH1cblxuICAgIHZhciBlZGdlSW5mbyA9IHJlbWFpbmluZ0VkZ2VzW2VkZ2VJbmRleF07XG4gICAgdmFyIHNvdXJjZUluID0gZWRnZUluZm9bMV07XG4gICAgdmFyIHRhcmdldEluID0gZWRnZUluZm9bMl07XG4gICAgdmFyIHBhcnRpdGlvbjEgPSBub2RlTWFwW3NvdXJjZUluXTtcbiAgICB2YXIgcGFydGl0aW9uMiA9IG5vZGVNYXBbdGFyZ2V0SW5dO1xuICAgIHZhciBuZXdFZGdlcyA9IHJlbWFpbmluZ0VkZ2VzOyAvLyByZS11c2UgYXJyYXlcbiAgICAvLyBEZWxldGUgYWxsIGVkZ2VzIGJldHdlZW4gcGFydGl0aW9uMSBhbmQgcGFydGl0aW9uMlxuXG4gICAgZm9yICh2YXIgaSA9IG5ld0VkZ2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZWRnZSA9IG5ld0VkZ2VzW2ldO1xuICAgICAgdmFyIHNyYyA9IGVkZ2VbMV07XG4gICAgICB2YXIgdGd0ID0gZWRnZVsyXTtcblxuICAgICAgaWYgKG5vZGVNYXBbc3JjXSA9PT0gcGFydGl0aW9uMSAmJiBub2RlTWFwW3RndF0gPT09IHBhcnRpdGlvbjIgfHwgbm9kZU1hcFtzcmNdID09PSBwYXJ0aXRpb24yICYmIG5vZGVNYXBbdGd0XSA9PT0gcGFydGl0aW9uMSkge1xuICAgICAgICBuZXdFZGdlcy5zcGxpY2UoaSwgMSk7XG4gICAgICB9XG4gICAgfSAvLyBBbGwgZWRnZXMgcG9pbnRpbmcgdG8gcGFydGl0aW9uMiBzaG91bGQgbm93IHBvaW50IHRvIHBhcnRpdGlvbjFcblxuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG5ld0VkZ2VzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF9lZGdlID0gbmV3RWRnZXNbX2ldO1xuXG4gICAgICBpZiAoX2VkZ2VbMV0gPT09IHBhcnRpdGlvbjIpIHtcbiAgICAgICAgLy8gQ2hlY2sgc291cmNlXG4gICAgICAgIG5ld0VkZ2VzW19pXSA9IF9lZGdlLnNsaWNlKCk7IC8vIGNvcHlcblxuICAgICAgICBuZXdFZGdlc1tfaV1bMV0gPSBwYXJ0aXRpb24xO1xuICAgICAgfSBlbHNlIGlmIChfZWRnZVsyXSA9PT0gcGFydGl0aW9uMikge1xuICAgICAgICAvLyBDaGVjayB0YXJnZXRcbiAgICAgICAgbmV3RWRnZXNbX2ldID0gX2VkZ2Uuc2xpY2UoKTsgLy8gY29weVxuXG4gICAgICAgIG5ld0VkZ2VzW19pXVsyXSA9IHBhcnRpdGlvbjE7XG4gICAgICB9XG4gICAgfSAvLyBNb3ZlIGFsbCBub2RlcyBmcm9tIHBhcnRpdGlvbjIgdG8gcGFydGl0aW9uMVxuXG5cbiAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBub2RlTWFwLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgIGlmIChub2RlTWFwW19pMl0gPT09IHBhcnRpdGlvbjIpIHtcbiAgICAgICAgbm9kZU1hcFtfaTJdID0gcGFydGl0aW9uMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3RWRnZXM7XG4gIH07IC8vIENvbnRyYWN0cyBhIGdyYXBoIHVudGlsIHdlIHJlYWNoIGEgY2VydGFpbiBudW1iZXIgb2YgbWV0YSBub2Rlc1xuXG5cbiAgdmFyIGNvbnRyYWN0VW50aWwgPSBmdW5jdGlvbiBjb250cmFjdFVudGlsKG1ldGFOb2RlTWFwLCByZW1haW5pbmdFZGdlcywgc2l6ZSwgc2l6ZUxpbWl0KSB7XG4gICAgd2hpbGUgKHNpemUgPiBzaXplTGltaXQpIHtcbiAgICAgIC8vIENob29zZSBhbiBlZGdlIHJhbmRvbWx5XG4gICAgICB2YXIgZWRnZUluZGV4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogcmVtYWluaW5nRWRnZXMubGVuZ3RoKTsgLy8gQ29sbGFwc2UgZ3JhcGggYmFzZWQgb24gZWRnZVxuXG4gICAgICByZW1haW5pbmdFZGdlcyA9IGNvbGxhcHNlKGVkZ2VJbmRleCwgbWV0YU5vZGVNYXAsIHJlbWFpbmluZ0VkZ2VzKTtcbiAgICAgIHNpemUtLTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVtYWluaW5nRWRnZXM7XG4gIH07XG5cbiAgdmFyIGVsZXNmbiRwID0ge1xuICAgIC8vIENvbXB1dGVzIHRoZSBtaW5pbXVtIGN1dCBvZiBhbiB1bmRpcmVjdGVkIGdyYXBoXG4gICAgLy8gUmV0dXJucyB0aGUgY29ycmVjdCBhbnN3ZXIgd2l0aCBoaWdoIHByb2JhYmlsaXR5XG4gICAga2FyZ2VyU3RlaW46IGZ1bmN0aW9uIGthcmdlclN0ZWluKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIF90aGlzJGJ5R3JvdXAgPSB0aGlzLmJ5R3JvdXAoKSxcbiAgICAgICAgICBub2RlcyA9IF90aGlzJGJ5R3JvdXAubm9kZXMsXG4gICAgICAgICAgZWRnZXMgPSBfdGhpcyRieUdyb3VwLmVkZ2VzO1xuXG4gICAgICBlZGdlcy51bm1lcmdlQnkoZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgICAgcmV0dXJuIGVkZ2UuaXNMb29wKCk7XG4gICAgICB9KTtcbiAgICAgIHZhciBudW1Ob2RlcyA9IG5vZGVzLmxlbmd0aDtcbiAgICAgIHZhciBudW1FZGdlcyA9IGVkZ2VzLmxlbmd0aDtcbiAgICAgIHZhciBudW1JdGVyID0gTWF0aC5jZWlsKE1hdGgucG93KE1hdGgubG9nKG51bU5vZGVzKSAvIE1hdGguTE4yLCAyKSk7XG4gICAgICB2YXIgc3RvcFNpemUgPSBNYXRoLmZsb29yKG51bU5vZGVzIC8gc3FydDIpO1xuXG4gICAgICBpZiAobnVtTm9kZXMgPCAyKSB7XG4gICAgICAgIGVycm9yKCdBdCBsZWFzdCAyIG5vZGVzIGFyZSByZXF1aXJlZCBmb3IgS2FyZ2VyLVN0ZWluIGFsZ29yaXRobScpO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfSAvLyBOb3cgc3RvcmUgZWRnZSBkZXN0aW5hdGlvbiBhcyBpbmRleGVzXG4gICAgICAvLyBGb3JtYXQgZm9yIGVhY2ggZWRnZSAoZWRnZSBpbmRleCwgc291cmNlIG5vZGUgaW5kZXgsIHRhcmdldCBub2RlIGluZGV4KVxuXG5cbiAgICAgIHZhciBlZGdlSW5kZXhlcyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUVkZ2VzOyBpKyspIHtcbiAgICAgICAgdmFyIGUgPSBlZGdlc1tpXTtcbiAgICAgICAgZWRnZUluZGV4ZXMucHVzaChbaSwgbm9kZXMuaW5kZXhPZihlLnNvdXJjZSgpKSwgbm9kZXMuaW5kZXhPZihlLnRhcmdldCgpKV0pO1xuICAgICAgfSAvLyBXZSB3aWxsIHN0b3JlIHRoZSBiZXN0IGN1dCBmb3VuZCBoZXJlXG5cblxuICAgICAgdmFyIG1pbkN1dFNpemUgPSBJbmZpbml0eTtcbiAgICAgIHZhciBtaW5DdXRFZGdlSW5kZXhlcyA9IFtdO1xuICAgICAgdmFyIG1pbkN1dE5vZGVNYXAgPSBuZXcgQXJyYXkobnVtTm9kZXMpOyAvLyBJbml0aWFsIG1ldGEgbm9kZSBwYXJ0aXRpb25cblxuICAgICAgdmFyIG1ldGFOb2RlTWFwID0gbmV3IEFycmF5KG51bU5vZGVzKTtcbiAgICAgIHZhciBtZXRhTm9kZU1hcDIgPSBuZXcgQXJyYXkobnVtTm9kZXMpO1xuXG4gICAgICB2YXIgY29weU5vZGVzTWFwID0gZnVuY3Rpb24gY29weU5vZGVzTWFwKGZyb20sIHRvKSB7XG4gICAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IG51bU5vZGVzOyBfaTMrKykge1xuICAgICAgICAgIHRvW19pM10gPSBmcm9tW19pM107XG4gICAgICAgIH1cbiAgICAgIH07IC8vIE1haW4gbG9vcFxuXG5cbiAgICAgIGZvciAodmFyIGl0ZXIgPSAwOyBpdGVyIDw9IG51bUl0ZXI7IGl0ZXIrKykge1xuICAgICAgICAvLyBSZXNldCBtZXRhIG5vZGUgcGFydGl0aW9uXG4gICAgICAgIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IG51bU5vZGVzOyBfaTQrKykge1xuICAgICAgICAgIG1ldGFOb2RlTWFwW19pNF0gPSBfaTQ7XG4gICAgICAgIH0gLy8gQ29udHJhY3QgdW50aWwgc3RvcCBwb2ludCAoc3RvcFNpemUgbm9kZXMpXG5cblxuICAgICAgICB2YXIgZWRnZXNTdGF0ZSA9IGNvbnRyYWN0VW50aWwobWV0YU5vZGVNYXAsIGVkZ2VJbmRleGVzLnNsaWNlKCksIG51bU5vZGVzLCBzdG9wU2l6ZSk7XG4gICAgICAgIHZhciBlZGdlc1N0YXRlMiA9IGVkZ2VzU3RhdGUuc2xpY2UoKTsgLy8gY29weVxuICAgICAgICAvLyBDcmVhdGUgYSBjb3B5IG9mIHRoZSBjb2xhcHNlZCBub2RlcyBzdGF0ZVxuXG4gICAgICAgIGNvcHlOb2Rlc01hcChtZXRhTm9kZU1hcCwgbWV0YU5vZGVNYXAyKTsgLy8gUnVuIDIgaXRlcmF0aW9ucyBzdGFydGluZyBpbiB0aGUgc3RvcCBzdGF0ZVxuXG4gICAgICAgIHZhciByZXMxID0gY29udHJhY3RVbnRpbChtZXRhTm9kZU1hcCwgZWRnZXNTdGF0ZSwgc3RvcFNpemUsIDIpO1xuICAgICAgICB2YXIgcmVzMiA9IGNvbnRyYWN0VW50aWwobWV0YU5vZGVNYXAyLCBlZGdlc1N0YXRlMiwgc3RvcFNpemUsIDIpOyAvLyBJcyBhbnkgb2YgdGhlIDIgcmVzdWx0cyB0aGUgYmVzdCBjdXQgc28gZmFyP1xuXG4gICAgICAgIGlmIChyZXMxLmxlbmd0aCA8PSByZXMyLmxlbmd0aCAmJiByZXMxLmxlbmd0aCA8IG1pbkN1dFNpemUpIHtcbiAgICAgICAgICBtaW5DdXRTaXplID0gcmVzMS5sZW5ndGg7XG4gICAgICAgICAgbWluQ3V0RWRnZUluZGV4ZXMgPSByZXMxO1xuICAgICAgICAgIGNvcHlOb2Rlc01hcChtZXRhTm9kZU1hcCwgbWluQ3V0Tm9kZU1hcCk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzMi5sZW5ndGggPD0gcmVzMS5sZW5ndGggJiYgcmVzMi5sZW5ndGggPCBtaW5DdXRTaXplKSB7XG4gICAgICAgICAgbWluQ3V0U2l6ZSA9IHJlczIubGVuZ3RoO1xuICAgICAgICAgIG1pbkN1dEVkZ2VJbmRleGVzID0gcmVzMjtcbiAgICAgICAgICBjb3B5Tm9kZXNNYXAobWV0YU5vZGVNYXAyLCBtaW5DdXROb2RlTWFwKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBlbmQgb2YgbWFpbiBsb29wXG4gICAgICAvLyBDb25zdHJ1Y3QgcmVzdWx0XG5cblxuICAgICAgdmFyIGN1dCA9IHRoaXMuc3Bhd24obWluQ3V0RWRnZUluZGV4ZXMubWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBlZGdlc1tlWzBdXTtcbiAgICAgIH0pKTtcbiAgICAgIHZhciBwYXJ0aXRpb24xID0gdGhpcy5zcGF3bigpO1xuICAgICAgdmFyIHBhcnRpdGlvbjIgPSB0aGlzLnNwYXduKCk7IC8vIHRyYXZlcnNlIG1ldGFOb2RlTWFwIGZvciBiZXN0IGN1dFxuXG4gICAgICB2YXIgd2l0bmVzc05vZGVQYXJ0aXRpb24gPSBtaW5DdXROb2RlTWFwWzBdO1xuXG4gICAgICBmb3IgKHZhciBfaTUgPSAwOyBfaTUgPCBtaW5DdXROb2RlTWFwLmxlbmd0aDsgX2k1KyspIHtcbiAgICAgICAgdmFyIHBhcnRpdGlvbklkID0gbWluQ3V0Tm9kZU1hcFtfaTVdO1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW19pNV07XG5cbiAgICAgICAgaWYgKHBhcnRpdGlvbklkID09PSB3aXRuZXNzTm9kZVBhcnRpdGlvbikge1xuICAgICAgICAgIHBhcnRpdGlvbjEubWVyZ2Uobm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFydGl0aW9uMi5tZXJnZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBjb25zdHJ1Y3QgY29tcG9uZW50cyBjb3JyZXNwb25kaW5nIHRvIGVhY2ggZGlzam9pbnQgc3Vic2V0IG9mIG5vZGVzXG5cblxuICAgICAgdmFyIGNvbnN0cnVjdENvbXBvbmVudCA9IGZ1bmN0aW9uIGNvbnN0cnVjdENvbXBvbmVudChzdWJzZXQpIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IF90aGlzLnNwYXduKCk7XG5cbiAgICAgICAgc3Vic2V0LmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICBjb21wb25lbnQubWVyZ2Uobm9kZSk7XG4gICAgICAgICAgbm9kZS5jb25uZWN0ZWRFZGdlcygpLmZvckVhY2goZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgICAgICAgIC8vIGVuc3VyZSBlZGdlIGlzIHdpdGhpbiBjYWxsaW5nIGNvbGxlY3Rpb24gYW5kIGVkZ2UgaXMgbm90IGluIGN1dFxuICAgICAgICAgICAgaWYgKF90aGlzLmNvbnRhaW5zKGVkZ2UpICYmICFjdXQuY29udGFpbnMoZWRnZSkpIHtcbiAgICAgICAgICAgICAgY29tcG9uZW50Lm1lcmdlKGVkZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudDtcbiAgICAgIH07XG5cbiAgICAgIHZhciBjb21wb25lbnRzID0gW2NvbnN0cnVjdENvbXBvbmVudChwYXJ0aXRpb24xKSwgY29uc3RydWN0Q29tcG9uZW50KHBhcnRpdGlvbjIpXTtcbiAgICAgIHZhciByZXQgPSB7XG4gICAgICAgIGN1dDogY3V0LFxuICAgICAgICBjb21wb25lbnRzOiBjb21wb25lbnRzLFxuICAgICAgICAvLyBuLmIuIHBhcnRpdGlvbnMgYXJlIGluY2x1ZGVkIHRvIGJlIGNvbXBhdGlibGUgd2l0aCB0aGUgb2xkIGFwaSBzcGVjXG4gICAgICAgIC8vIChjb3VsZCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHZlcnNpb24pXG4gICAgICAgIHBhcnRpdGlvbjE6IHBhcnRpdGlvbjEsXG4gICAgICAgIHBhcnRpdGlvbjI6IHBhcnRpdGlvbjJcbiAgICAgIH07XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgfTsgLy8gZWxlc2ZuXG5cbiAgdmFyIGNvcHlQb3NpdGlvbiA9IGZ1bmN0aW9uIGNvcHlQb3NpdGlvbihwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHAueCxcbiAgICAgIHk6IHAueVxuICAgIH07XG4gIH07XG4gIHZhciBtb2RlbFRvUmVuZGVyZWRQb3NpdGlvbiA9IGZ1bmN0aW9uIG1vZGVsVG9SZW5kZXJlZFBvc2l0aW9uKHAsIHpvb20sIHBhbikge1xuICAgIHJldHVybiB7XG4gICAgICB4OiBwLnggKiB6b29tICsgcGFuLngsXG4gICAgICB5OiBwLnkgKiB6b29tICsgcGFuLnlcbiAgICB9O1xuICB9O1xuICB2YXIgcmVuZGVyZWRUb01vZGVsUG9zaXRpb24gPSBmdW5jdGlvbiByZW5kZXJlZFRvTW9kZWxQb3NpdGlvbihwLCB6b29tLCBwYW4pIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogKHAueCAtIHBhbi54KSAvIHpvb20sXG4gICAgICB5OiAocC55IC0gcGFuLnkpIC8gem9vbVxuICAgIH07XG4gIH07XG4gIHZhciBhcnJheTJwb2ludCA9IGZ1bmN0aW9uIGFycmF5MnBvaW50KGFycikge1xuICAgIHJldHVybiB7XG4gICAgICB4OiBhcnJbMF0sXG4gICAgICB5OiBhcnJbMV1cbiAgICB9O1xuICB9O1xuICB2YXIgbWluID0gZnVuY3Rpb24gbWluKGFycikge1xuICAgIHZhciBiZWdpbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgICB2YXIgZW5kID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBhcnIubGVuZ3RoO1xuICAgIHZhciBtaW4gPSBJbmZpbml0eTtcblxuICAgIGZvciAodmFyIGkgPSBiZWdpbjsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB2YXIgdmFsID0gYXJyW2ldO1xuXG4gICAgICBpZiAoaXNGaW5pdGUodmFsKSkge1xuICAgICAgICBtaW4gPSBNYXRoLm1pbih2YWwsIG1pbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1pbjtcbiAgfTtcbiAgdmFyIG1heCA9IGZ1bmN0aW9uIG1heChhcnIpIHtcbiAgICB2YXIgYmVnaW4gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gICAgdmFyIGVuZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogYXJyLmxlbmd0aDtcbiAgICB2YXIgbWF4ID0gLUluZmluaXR5O1xuXG4gICAgZm9yICh2YXIgaSA9IGJlZ2luOyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHZhciB2YWwgPSBhcnJbaV07XG5cbiAgICAgIGlmIChpc0Zpbml0ZSh2YWwpKSB7XG4gICAgICAgIG1heCA9IE1hdGgubWF4KHZhbCwgbWF4KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWF4O1xuICB9O1xuICB2YXIgbWVhbiA9IGZ1bmN0aW9uIG1lYW4oYXJyKSB7XG4gICAgdmFyIGJlZ2luID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgIHZhciBlbmQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGFyci5sZW5ndGg7XG4gICAgdmFyIHRvdGFsID0gMDtcbiAgICB2YXIgbiA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gYmVnaW47IGkgPCBlbmQ7IGkrKykge1xuICAgICAgdmFyIHZhbCA9IGFycltpXTtcblxuICAgICAgaWYgKGlzRmluaXRlKHZhbCkpIHtcbiAgICAgICAgdG90YWwgKz0gdmFsO1xuICAgICAgICBuKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRvdGFsIC8gbjtcbiAgfTtcbiAgdmFyIG1lZGlhbiA9IGZ1bmN0aW9uIG1lZGlhbihhcnIpIHtcbiAgICB2YXIgYmVnaW4gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gICAgdmFyIGVuZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogYXJyLmxlbmd0aDtcbiAgICB2YXIgY29weSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogdHJ1ZTtcbiAgICB2YXIgc29ydCA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogdHJ1ZTtcbiAgICB2YXIgaW5jbHVkZUhvbGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiB0cnVlO1xuXG4gICAgaWYgKGNvcHkpIHtcbiAgICAgIGFyciA9IGFyci5zbGljZShiZWdpbiwgZW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGVuZCA8IGFyci5sZW5ndGgpIHtcbiAgICAgICAgYXJyLnNwbGljZShlbmQsIGFyci5sZW5ndGggLSBlbmQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYmVnaW4gPiAwKSB7XG4gICAgICAgIGFyci5zcGxpY2UoMCwgYmVnaW4pO1xuICAgICAgfVxuICAgIH0gLy8gYWxsIG5vbiBmaW5pdGUgKGUuZy4gSW5maW5pdHksIE5hTikgZWxlbWVudHMgbXVzdCBiZSAtSW5maW5pdHkgc28gdGhleSBnbyB0byB0aGUgc3RhcnRcblxuXG4gICAgdmFyIG9mZiA9IDA7IC8vIG9mZnNldCBmcm9tIG5vbi1maW5pdGUgdmFsdWVzXG5cbiAgICBmb3IgKHZhciBpID0gYXJyLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgdiA9IGFycltpXTtcblxuICAgICAgaWYgKGluY2x1ZGVIb2xlcykge1xuICAgICAgICBpZiAoIWlzRmluaXRlKHYpKSB7XG4gICAgICAgICAgYXJyW2ldID0gLUluZmluaXR5O1xuICAgICAgICAgIG9mZisrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBqdXN0IHJlbW92ZSBpdCBpZiB3ZSBkb24ndCB3YW50IHRvIGNvbnNpZGVyIGhvbGVzXG4gICAgICAgIGFyci5zcGxpY2UoaSwgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNvcnQpIHtcbiAgICAgIGFyci5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhIC0gYjtcbiAgICAgIH0pOyAvLyByZXF1aXJlcyBjb3B5ID0gdHJ1ZSBpZiB5b3UgZG9uJ3Qgd2FudCB0byBjaGFuZ2UgdGhlIG9yaWdcbiAgICB9XG5cbiAgICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcbiAgICB2YXIgbWlkID0gTWF0aC5mbG9vcihsZW4gLyAyKTtcblxuICAgIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgICByZXR1cm4gYXJyW21pZCArIDEgKyBvZmZdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKGFyclttaWQgLSAxICsgb2ZmXSArIGFyclttaWQgKyBvZmZdKSAvIDI7XG4gICAgfVxuICB9O1xuICB2YXIgZGVnMnJhZCA9IGZ1bmN0aW9uIGRlZzJyYWQoZGVnKSB7XG4gICAgcmV0dXJuIE1hdGguUEkgKiBkZWcgLyAxODA7XG4gIH07XG4gIHZhciBnZXRBbmdsZUZyb21EaXNwID0gZnVuY3Rpb24gZ2V0QW5nbGVGcm9tRGlzcChkaXNwWCwgZGlzcFkpIHtcbiAgICByZXR1cm4gTWF0aC5hdGFuMihkaXNwWSwgZGlzcFgpIC0gTWF0aC5QSSAvIDI7XG4gIH07XG4gIHZhciBsb2cyID0gTWF0aC5sb2cyIHx8IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIE1hdGgubG9nKG4pIC8gTWF0aC5sb2coMik7XG4gIH07XG4gIHZhciBzaWdudW0gPSBmdW5jdGlvbiBzaWdudW0oeCkge1xuICAgIGlmICh4ID4gMCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmICh4IDwgMCkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH07XG4gIHZhciBkaXN0ID0gZnVuY3Rpb24gZGlzdChwMSwgcDIpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHNxZGlzdChwMSwgcDIpKTtcbiAgfTtcbiAgdmFyIHNxZGlzdCA9IGZ1bmN0aW9uIHNxZGlzdChwMSwgcDIpIHtcbiAgICB2YXIgZHggPSBwMi54IC0gcDEueDtcbiAgICB2YXIgZHkgPSBwMi55IC0gcDEueTtcbiAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG4gIH07XG4gIHZhciBpblBsYWNlU3VtTm9ybWFsaXplID0gZnVuY3Rpb24gaW5QbGFjZVN1bU5vcm1hbGl6ZSh2KSB7XG4gICAgdmFyIGxlbmd0aCA9IHYubGVuZ3RoOyAvLyBGaXJzdCwgZ2V0IHN1bSBvZiBhbGwgZWxlbWVudHNcblxuICAgIHZhciB0b3RhbCA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB0b3RhbCArPSB2W2ldO1xuICAgIH0gLy8gTm93LCBkaXZpZGUgZWFjaCBieSB0aGUgc3VtIG9mIGFsbCBlbGVtZW50c1xuXG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2W19pXSA9IHZbX2ldIC8gdG90YWw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHY7XG4gIH07XG5cbiAgdmFyIHFiZXppZXJBdCA9IGZ1bmN0aW9uIHFiZXppZXJBdChwMCwgcDEsIHAyLCB0KSB7XG4gICAgcmV0dXJuICgxIC0gdCkgKiAoMSAtIHQpICogcDAgKyAyICogKDEgLSB0KSAqIHQgKiBwMSArIHQgKiB0ICogcDI7XG4gIH07XG4gIHZhciBxYmV6aWVyUHRBdCA9IGZ1bmN0aW9uIHFiZXppZXJQdEF0KHAwLCBwMSwgcDIsIHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogcWJlemllckF0KHAwLngsIHAxLngsIHAyLngsIHQpLFxuICAgICAgeTogcWJlemllckF0KHAwLnksIHAxLnksIHAyLnksIHQpXG4gICAgfTtcbiAgfTtcbiAgdmFyIGxpbmVBdCA9IGZ1bmN0aW9uIGxpbmVBdChwMCwgcDEsIHQsIGQpIHtcbiAgICB2YXIgdmVjID0ge1xuICAgICAgeDogcDEueCAtIHAwLngsXG4gICAgICB5OiBwMS55IC0gcDAueVxuICAgIH07XG4gICAgdmFyIHZlY0Rpc3QgPSBkaXN0KHAwLCBwMSk7XG4gICAgdmFyIG5vcm1WZWMgPSB7XG4gICAgICB4OiB2ZWMueCAvIHZlY0Rpc3QsXG4gICAgICB5OiB2ZWMueSAvIHZlY0Rpc3RcbiAgICB9O1xuICAgIHQgPSB0ID09IG51bGwgPyAwIDogdDtcbiAgICBkID0gZCAhPSBudWxsID8gZCA6IHQgKiB2ZWNEaXN0O1xuICAgIHJldHVybiB7XG4gICAgICB4OiBwMC54ICsgbm9ybVZlYy54ICogZCxcbiAgICAgIHk6IHAwLnkgKyBub3JtVmVjLnkgKiBkXG4gICAgfTtcbiAgfTtcbiAgdmFyIGJvdW5kID0gZnVuY3Rpb24gYm91bmQobWluLCB2YWwsIG1heCkge1xuICAgIHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgdmFsKSk7XG4gIH07IC8vIG1ha2VzIGEgZnVsbCBiYiAoeDEsIHkxLCB4MiwgeTIsIHcsIGgpIGZyb20gaW1wbGljaXQgcGFyYW1zXG5cbiAgdmFyIG1ha2VCb3VuZGluZ0JveCA9IGZ1bmN0aW9uIG1ha2VCb3VuZGluZ0JveChiYikge1xuICAgIGlmIChiYiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4MTogSW5maW5pdHksXG4gICAgICAgIHkxOiBJbmZpbml0eSxcbiAgICAgICAgeDI6IC1JbmZpbml0eSxcbiAgICAgICAgeTI6IC1JbmZpbml0eSxcbiAgICAgICAgdzogMCxcbiAgICAgICAgaDogMFxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGJiLngxICE9IG51bGwgJiYgYmIueTEgIT0gbnVsbCkge1xuICAgICAgaWYgKGJiLngyICE9IG51bGwgJiYgYmIueTIgIT0gbnVsbCAmJiBiYi54MiA+PSBiYi54MSAmJiBiYi55MiA+PSBiYi55MSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHgxOiBiYi54MSxcbiAgICAgICAgICB5MTogYmIueTEsXG4gICAgICAgICAgeDI6IGJiLngyLFxuICAgICAgICAgIHkyOiBiYi55MixcbiAgICAgICAgICB3OiBiYi54MiAtIGJiLngxLFxuICAgICAgICAgIGg6IGJiLnkyIC0gYmIueTFcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoYmIudyAhPSBudWxsICYmIGJiLmggIT0gbnVsbCAmJiBiYi53ID49IDAgJiYgYmIuaCA+PSAwKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDE6IGJiLngxLFxuICAgICAgICAgIHkxOiBiYi55MSxcbiAgICAgICAgICB4MjogYmIueDEgKyBiYi53LFxuICAgICAgICAgIHkyOiBiYi55MSArIGJiLmgsXG4gICAgICAgICAgdzogYmIudyxcbiAgICAgICAgICBoOiBiYi5oXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9O1xuICB2YXIgY29weUJvdW5kaW5nQm94ID0gZnVuY3Rpb24gY29weUJvdW5kaW5nQm94KGJiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHgxOiBiYi54MSxcbiAgICAgIHgyOiBiYi54MixcbiAgICAgIHc6IGJiLncsXG4gICAgICB5MTogYmIueTEsXG4gICAgICB5MjogYmIueTIsXG4gICAgICBoOiBiYi5oXG4gICAgfTtcbiAgfTtcbiAgdmFyIGNsZWFyQm91bmRpbmdCb3ggPSBmdW5jdGlvbiBjbGVhckJvdW5kaW5nQm94KGJiKSB7XG4gICAgYmIueDEgPSBJbmZpbml0eTtcbiAgICBiYi55MSA9IEluZmluaXR5O1xuICAgIGJiLngyID0gLUluZmluaXR5O1xuICAgIGJiLnkyID0gLUluZmluaXR5O1xuICAgIGJiLncgPSAwO1xuICAgIGJiLmggPSAwO1xuICB9O1xuICB2YXIgdXBkYXRlQm91bmRpbmdCb3ggPSBmdW5jdGlvbiB1cGRhdGVCb3VuZGluZ0JveChiYjEsIGJiMikge1xuICAgIC8vIHVwZGF0ZSBiYjEgd2l0aCBiYjIgYm91bmRzXG4gICAgYmIxLngxID0gTWF0aC5taW4oYmIxLngxLCBiYjIueDEpO1xuICAgIGJiMS54MiA9IE1hdGgubWF4KGJiMS54MiwgYmIyLngyKTtcbiAgICBiYjEudyA9IGJiMS54MiAtIGJiMS54MTtcbiAgICBiYjEueTEgPSBNYXRoLm1pbihiYjEueTEsIGJiMi55MSk7XG4gICAgYmIxLnkyID0gTWF0aC5tYXgoYmIxLnkyLCBiYjIueTIpO1xuICAgIGJiMS5oID0gYmIxLnkyIC0gYmIxLnkxO1xuICB9O1xuICB2YXIgZXhwYW5kQm91bmRpbmdCb3hCeVBvaW50ID0gZnVuY3Rpb24gZXhwYW5kQm91bmRpbmdCb3hCeVBvaW50KGJiLCB4LCB5KSB7XG4gICAgYmIueDEgPSBNYXRoLm1pbihiYi54MSwgeCk7XG4gICAgYmIueDIgPSBNYXRoLm1heChiYi54MiwgeCk7XG4gICAgYmIudyA9IGJiLngyIC0gYmIueDE7XG4gICAgYmIueTEgPSBNYXRoLm1pbihiYi55MSwgeSk7XG4gICAgYmIueTIgPSBNYXRoLm1heChiYi55MiwgeSk7XG4gICAgYmIuaCA9IGJiLnkyIC0gYmIueTE7XG4gIH07XG4gIHZhciBleHBhbmRCb3VuZGluZ0JveCA9IGZ1bmN0aW9uIGV4cGFuZEJvdW5kaW5nQm94KGJiKSB7XG4gICAgdmFyIHBhZGRpbmcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gICAgYmIueDEgLT0gcGFkZGluZztcbiAgICBiYi54MiArPSBwYWRkaW5nO1xuICAgIGJiLnkxIC09IHBhZGRpbmc7XG4gICAgYmIueTIgKz0gcGFkZGluZztcbiAgICBiYi53ID0gYmIueDIgLSBiYi54MTtcbiAgICBiYi5oID0gYmIueTIgLSBiYi55MTtcbiAgICByZXR1cm4gYmI7XG4gIH07XG4gIHZhciBleHBhbmRCb3VuZGluZ0JveFNpZGVzID0gZnVuY3Rpb24gZXhwYW5kQm91bmRpbmdCb3hTaWRlcyhiYikge1xuICAgIHZhciBwYWRkaW5nID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbMF07XG4gICAgdmFyIHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdDtcblxuICAgIGlmIChwYWRkaW5nLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdG9wID0gcmlnaHQgPSBib3R0b20gPSBsZWZ0ID0gcGFkZGluZ1swXTtcbiAgICB9IGVsc2UgaWYgKHBhZGRpbmcubGVuZ3RoID09PSAyKSB7XG4gICAgICB0b3AgPSBib3R0b20gPSBwYWRkaW5nWzBdO1xuICAgICAgbGVmdCA9IHJpZ2h0ID0gcGFkZGluZ1sxXTtcbiAgICB9IGVsc2UgaWYgKHBhZGRpbmcubGVuZ3RoID09PSA0KSB7XG4gICAgICB2YXIgX3BhZGRpbmcgPSBfc2xpY2VkVG9BcnJheShwYWRkaW5nLCA0KTtcblxuICAgICAgdG9wID0gX3BhZGRpbmdbMF07XG4gICAgICByaWdodCA9IF9wYWRkaW5nWzFdO1xuICAgICAgYm90dG9tID0gX3BhZGRpbmdbMl07XG4gICAgICBsZWZ0ID0gX3BhZGRpbmdbM107XG4gICAgfVxuXG4gICAgYmIueDEgLT0gbGVmdDtcbiAgICBiYi54MiArPSByaWdodDtcbiAgICBiYi55MSAtPSB0b3A7XG4gICAgYmIueTIgKz0gYm90dG9tO1xuICAgIGJiLncgPSBiYi54MiAtIGJiLngxO1xuICAgIGJiLmggPSBiYi55MiAtIGJiLnkxO1xuICAgIHJldHVybiBiYjtcbiAgfTtcblxuICB2YXIgYXNzaWduQm91bmRpbmdCb3ggPSBmdW5jdGlvbiBhc3NpZ25Cb3VuZGluZ0JveChiYjEsIGJiMikge1xuICAgIGJiMS54MSA9IGJiMi54MTtcbiAgICBiYjEueTEgPSBiYjIueTE7XG4gICAgYmIxLngyID0gYmIyLngyO1xuICAgIGJiMS55MiA9IGJiMi55MjtcbiAgICBiYjEudyA9IGJiMS54MiAtIGJiMS54MTtcbiAgICBiYjEuaCA9IGJiMS55MiAtIGJiMS55MTtcbiAgfTtcbiAgdmFyIGJvdW5kaW5nQm94ZXNJbnRlcnNlY3QgPSBmdW5jdGlvbiBib3VuZGluZ0JveGVzSW50ZXJzZWN0KGJiMSwgYmIyKSB7XG4gICAgLy8gY2FzZTogb25lIGJiIHRvIHJpZ2h0IG9mIG90aGVyXG4gICAgaWYgKGJiMS54MSA+IGJiMi54Mikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChiYjIueDEgPiBiYjEueDIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIGNhc2U6IG9uZSBiYiB0byBsZWZ0IG9mIG90aGVyXG5cblxuICAgIGlmIChiYjEueDIgPCBiYjIueDEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoYmIyLngyIDwgYmIxLngxKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBjYXNlOiBvbmUgYmIgYWJvdmUgb3RoZXJcblxuXG4gICAgaWYgKGJiMS55MiA8IGJiMi55MSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChiYjIueTIgPCBiYjEueTEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIGNhc2U6IG9uZSBiYiBiZWxvdyBvdGhlclxuXG5cbiAgICBpZiAoYmIxLnkxID4gYmIyLnkyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGJiMi55MSA+IGJiMS55Mikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gb3RoZXJ3aXNlLCBtdXN0IGhhdmUgc29tZSBvdmVybGFwXG5cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuICB2YXIgaW5Cb3VuZGluZ0JveCA9IGZ1bmN0aW9uIGluQm91bmRpbmdCb3goYmIsIHgsIHkpIHtcbiAgICByZXR1cm4gYmIueDEgPD0geCAmJiB4IDw9IGJiLngyICYmIGJiLnkxIDw9IHkgJiYgeSA8PSBiYi55MjtcbiAgfTtcbiAgdmFyIHBvaW50SW5Cb3VuZGluZ0JveCA9IGZ1bmN0aW9uIHBvaW50SW5Cb3VuZGluZ0JveChiYiwgcHQpIHtcbiAgICByZXR1cm4gaW5Cb3VuZGluZ0JveChiYiwgcHQueCwgcHQueSk7XG4gIH07XG4gIHZhciBib3VuZGluZ0JveEluQm91bmRpbmdCb3ggPSBmdW5jdGlvbiBib3VuZGluZ0JveEluQm91bmRpbmdCb3goYmIxLCBiYjIpIHtcbiAgICByZXR1cm4gaW5Cb3VuZGluZ0JveChiYjEsIGJiMi54MSwgYmIyLnkxKSAmJiBpbkJvdW5kaW5nQm94KGJiMSwgYmIyLngyLCBiYjIueTIpO1xuICB9O1xuICB2YXIgcm91bmRSZWN0YW5nbGVJbnRlcnNlY3RMaW5lID0gZnVuY3Rpb24gcm91bmRSZWN0YW5nbGVJbnRlcnNlY3RMaW5lKHgsIHksIG5vZGVYLCBub2RlWSwgd2lkdGgsIGhlaWdodCwgcGFkZGluZykge1xuICAgIHZhciBjb3JuZXJSYWRpdXMgPSBnZXRSb3VuZFJlY3RhbmdsZVJhZGl1cyh3aWR0aCwgaGVpZ2h0KTtcbiAgICB2YXIgaGFsZldpZHRoID0gd2lkdGggLyAyO1xuICAgIHZhciBoYWxmSGVpZ2h0ID0gaGVpZ2h0IC8gMjsgLy8gQ2hlY2sgaW50ZXJzZWN0aW9ucyB3aXRoIHN0cmFpZ2h0IGxpbmUgc2VnbWVudHNcblxuICAgIHZhciBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zOyAvLyBUb3Agc2VnbWVudCwgbGVmdCB0byByaWdodFxuXG4gICAge1xuICAgICAgdmFyIHRvcFN0YXJ0WCA9IG5vZGVYIC0gaGFsZldpZHRoICsgY29ybmVyUmFkaXVzIC0gcGFkZGluZztcbiAgICAgIHZhciB0b3BTdGFydFkgPSBub2RlWSAtIGhhbGZIZWlnaHQgLSBwYWRkaW5nO1xuICAgICAgdmFyIHRvcEVuZFggPSBub2RlWCArIGhhbGZXaWR0aCAtIGNvcm5lclJhZGl1cyArIHBhZGRpbmc7XG4gICAgICB2YXIgdG9wRW5kWSA9IHRvcFN0YXJ0WTtcbiAgICAgIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnMgPSBmaW5pdGVMaW5lc0ludGVyc2VjdCh4LCB5LCBub2RlWCwgbm9kZVksIHRvcFN0YXJ0WCwgdG9wU3RhcnRZLCB0b3BFbmRYLCB0b3BFbmRZLCBmYWxzZSk7XG5cbiAgICAgIGlmIChzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnM7XG4gICAgICB9XG4gICAgfSAvLyBSaWdodCBzZWdtZW50LCB0b3AgdG8gYm90dG9tXG5cbiAgICB7XG4gICAgICB2YXIgcmlnaHRTdGFydFggPSBub2RlWCArIGhhbGZXaWR0aCArIHBhZGRpbmc7XG4gICAgICB2YXIgcmlnaHRTdGFydFkgPSBub2RlWSAtIGhhbGZIZWlnaHQgKyBjb3JuZXJSYWRpdXMgLSBwYWRkaW5nO1xuICAgICAgdmFyIHJpZ2h0RW5kWCA9IHJpZ2h0U3RhcnRYO1xuICAgICAgdmFyIHJpZ2h0RW5kWSA9IG5vZGVZICsgaGFsZkhlaWdodCAtIGNvcm5lclJhZGl1cyArIHBhZGRpbmc7XG4gICAgICBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zID0gZmluaXRlTGluZXNJbnRlcnNlY3QoeCwgeSwgbm9kZVgsIG5vZGVZLCByaWdodFN0YXJ0WCwgcmlnaHRTdGFydFksIHJpZ2h0RW5kWCwgcmlnaHRFbmRZLCBmYWxzZSk7XG5cbiAgICAgIGlmIChzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnM7XG4gICAgICB9XG4gICAgfSAvLyBCb3R0b20gc2VnbWVudCwgbGVmdCB0byByaWdodFxuXG4gICAge1xuICAgICAgdmFyIGJvdHRvbVN0YXJ0WCA9IG5vZGVYIC0gaGFsZldpZHRoICsgY29ybmVyUmFkaXVzIC0gcGFkZGluZztcbiAgICAgIHZhciBib3R0b21TdGFydFkgPSBub2RlWSArIGhhbGZIZWlnaHQgKyBwYWRkaW5nO1xuICAgICAgdmFyIGJvdHRvbUVuZFggPSBub2RlWCArIGhhbGZXaWR0aCAtIGNvcm5lclJhZGl1cyArIHBhZGRpbmc7XG4gICAgICB2YXIgYm90dG9tRW5kWSA9IGJvdHRvbVN0YXJ0WTtcbiAgICAgIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnMgPSBmaW5pdGVMaW5lc0ludGVyc2VjdCh4LCB5LCBub2RlWCwgbm9kZVksIGJvdHRvbVN0YXJ0WCwgYm90dG9tU3RhcnRZLCBib3R0b21FbmRYLCBib3R0b21FbmRZLCBmYWxzZSk7XG5cbiAgICAgIGlmIChzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnM7XG4gICAgICB9XG4gICAgfSAvLyBMZWZ0IHNlZ21lbnQsIHRvcCB0byBib3R0b21cblxuICAgIHtcbiAgICAgIHZhciBsZWZ0U3RhcnRYID0gbm9kZVggLSBoYWxmV2lkdGggLSBwYWRkaW5nO1xuICAgICAgdmFyIGxlZnRTdGFydFkgPSBub2RlWSAtIGhhbGZIZWlnaHQgKyBjb3JuZXJSYWRpdXMgLSBwYWRkaW5nO1xuICAgICAgdmFyIGxlZnRFbmRYID0gbGVmdFN0YXJ0WDtcbiAgICAgIHZhciBsZWZ0RW5kWSA9IG5vZGVZICsgaGFsZkhlaWdodCAtIGNvcm5lclJhZGl1cyArIHBhZGRpbmc7XG4gICAgICBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zID0gZmluaXRlTGluZXNJbnRlcnNlY3QoeCwgeSwgbm9kZVgsIG5vZGVZLCBsZWZ0U3RhcnRYLCBsZWZ0U3RhcnRZLCBsZWZ0RW5kWCwgbGVmdEVuZFksIGZhbHNlKTtcblxuICAgICAgaWYgKHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucztcbiAgICAgIH1cbiAgICB9IC8vIENoZWNrIGludGVyc2VjdGlvbnMgd2l0aCBhcmMgc2VnbWVudHNcblxuICAgIHZhciBhcmNJbnRlcnNlY3Rpb25zOyAvLyBUb3AgTGVmdFxuXG4gICAge1xuICAgICAgdmFyIHRvcExlZnRDZW50ZXJYID0gbm9kZVggLSBoYWxmV2lkdGggKyBjb3JuZXJSYWRpdXM7XG4gICAgICB2YXIgdG9wTGVmdENlbnRlclkgPSBub2RlWSAtIGhhbGZIZWlnaHQgKyBjb3JuZXJSYWRpdXM7XG4gICAgICBhcmNJbnRlcnNlY3Rpb25zID0gaW50ZXJzZWN0TGluZUNpcmNsZSh4LCB5LCBub2RlWCwgbm9kZVksIHRvcExlZnRDZW50ZXJYLCB0b3BMZWZ0Q2VudGVyWSwgY29ybmVyUmFkaXVzICsgcGFkZGluZyk7IC8vIEVuc3VyZSB0aGUgaW50ZXJzZWN0aW9uIGlzIG9uIHRoZSBkZXNpcmVkIHF1YXJ0ZXIgb2YgdGhlIGNpcmNsZVxuXG4gICAgICBpZiAoYXJjSW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwICYmIGFyY0ludGVyc2VjdGlvbnNbMF0gPD0gdG9wTGVmdENlbnRlclggJiYgYXJjSW50ZXJzZWN0aW9uc1sxXSA8PSB0b3BMZWZ0Q2VudGVyWSkge1xuICAgICAgICByZXR1cm4gW2FyY0ludGVyc2VjdGlvbnNbMF0sIGFyY0ludGVyc2VjdGlvbnNbMV1dO1xuICAgICAgfVxuICAgIH0gLy8gVG9wIFJpZ2h0XG5cbiAgICB7XG4gICAgICB2YXIgdG9wUmlnaHRDZW50ZXJYID0gbm9kZVggKyBoYWxmV2lkdGggLSBjb3JuZXJSYWRpdXM7XG4gICAgICB2YXIgdG9wUmlnaHRDZW50ZXJZID0gbm9kZVkgLSBoYWxmSGVpZ2h0ICsgY29ybmVyUmFkaXVzO1xuICAgICAgYXJjSW50ZXJzZWN0aW9ucyA9IGludGVyc2VjdExpbmVDaXJjbGUoeCwgeSwgbm9kZVgsIG5vZGVZLCB0b3BSaWdodENlbnRlclgsIHRvcFJpZ2h0Q2VudGVyWSwgY29ybmVyUmFkaXVzICsgcGFkZGluZyk7IC8vIEVuc3VyZSB0aGUgaW50ZXJzZWN0aW9uIGlzIG9uIHRoZSBkZXNpcmVkIHF1YXJ0ZXIgb2YgdGhlIGNpcmNsZVxuXG4gICAgICBpZiAoYXJjSW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwICYmIGFyY0ludGVyc2VjdGlvbnNbMF0gPj0gdG9wUmlnaHRDZW50ZXJYICYmIGFyY0ludGVyc2VjdGlvbnNbMV0gPD0gdG9wUmlnaHRDZW50ZXJZKSB7XG4gICAgICAgIHJldHVybiBbYXJjSW50ZXJzZWN0aW9uc1swXSwgYXJjSW50ZXJzZWN0aW9uc1sxXV07XG4gICAgICB9XG4gICAgfSAvLyBCb3R0b20gUmlnaHRcblxuICAgIHtcbiAgICAgIHZhciBib3R0b21SaWdodENlbnRlclggPSBub2RlWCArIGhhbGZXaWR0aCAtIGNvcm5lclJhZGl1cztcbiAgICAgIHZhciBib3R0b21SaWdodENlbnRlclkgPSBub2RlWSArIGhhbGZIZWlnaHQgLSBjb3JuZXJSYWRpdXM7XG4gICAgICBhcmNJbnRlcnNlY3Rpb25zID0gaW50ZXJzZWN0TGluZUNpcmNsZSh4LCB5LCBub2RlWCwgbm9kZVksIGJvdHRvbVJpZ2h0Q2VudGVyWCwgYm90dG9tUmlnaHRDZW50ZXJZLCBjb3JuZXJSYWRpdXMgKyBwYWRkaW5nKTsgLy8gRW5zdXJlIHRoZSBpbnRlcnNlY3Rpb24gaXMgb24gdGhlIGRlc2lyZWQgcXVhcnRlciBvZiB0aGUgY2lyY2xlXG5cbiAgICAgIGlmIChhcmNJbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDAgJiYgYXJjSW50ZXJzZWN0aW9uc1swXSA+PSBib3R0b21SaWdodENlbnRlclggJiYgYXJjSW50ZXJzZWN0aW9uc1sxXSA+PSBib3R0b21SaWdodENlbnRlclkpIHtcbiAgICAgICAgcmV0dXJuIFthcmNJbnRlcnNlY3Rpb25zWzBdLCBhcmNJbnRlcnNlY3Rpb25zWzFdXTtcbiAgICAgIH1cbiAgICB9IC8vIEJvdHRvbSBMZWZ0XG5cbiAgICB7XG4gICAgICB2YXIgYm90dG9tTGVmdENlbnRlclggPSBub2RlWCAtIGhhbGZXaWR0aCArIGNvcm5lclJhZGl1cztcbiAgICAgIHZhciBib3R0b21MZWZ0Q2VudGVyWSA9IG5vZGVZICsgaGFsZkhlaWdodCAtIGNvcm5lclJhZGl1cztcbiAgICAgIGFyY0ludGVyc2VjdGlvbnMgPSBpbnRlcnNlY3RMaW5lQ2lyY2xlKHgsIHksIG5vZGVYLCBub2RlWSwgYm90dG9tTGVmdENlbnRlclgsIGJvdHRvbUxlZnRDZW50ZXJZLCBjb3JuZXJSYWRpdXMgKyBwYWRkaW5nKTsgLy8gRW5zdXJlIHRoZSBpbnRlcnNlY3Rpb24gaXMgb24gdGhlIGRlc2lyZWQgcXVhcnRlciBvZiB0aGUgY2lyY2xlXG5cbiAgICAgIGlmIChhcmNJbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDAgJiYgYXJjSW50ZXJzZWN0aW9uc1swXSA8PSBib3R0b21MZWZ0Q2VudGVyWCAmJiBhcmNJbnRlcnNlY3Rpb25zWzFdID49IGJvdHRvbUxlZnRDZW50ZXJZKSB7XG4gICAgICAgIHJldHVybiBbYXJjSW50ZXJzZWN0aW9uc1swXSwgYXJjSW50ZXJzZWN0aW9uc1sxXV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbXTsgLy8gaWYgbm90aGluZ1xuICB9O1xuICB2YXIgaW5MaW5lVmljaW5pdHkgPSBmdW5jdGlvbiBpbkxpbmVWaWNpbml0eSh4LCB5LCBseDEsIGx5MSwgbHgyLCBseTIsIHRvbGVyYW5jZSkge1xuICAgIHZhciB0ID0gdG9sZXJhbmNlO1xuICAgIHZhciB4MSA9IE1hdGgubWluKGx4MSwgbHgyKTtcbiAgICB2YXIgeDIgPSBNYXRoLm1heChseDEsIGx4Mik7XG4gICAgdmFyIHkxID0gTWF0aC5taW4obHkxLCBseTIpO1xuICAgIHZhciB5MiA9IE1hdGgubWF4KGx5MSwgbHkyKTtcbiAgICByZXR1cm4geDEgLSB0IDw9IHggJiYgeCA8PSB4MiArIHQgJiYgeTEgLSB0IDw9IHkgJiYgeSA8PSB5MiArIHQ7XG4gIH07XG4gIHZhciBpbkJlemllclZpY2luaXR5ID0gZnVuY3Rpb24gaW5CZXppZXJWaWNpbml0eSh4LCB5LCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB0b2xlcmFuY2UpIHtcbiAgICB2YXIgYmIgPSB7XG4gICAgICB4MTogTWF0aC5taW4oeDEsIHgzLCB4MikgLSB0b2xlcmFuY2UsXG4gICAgICB4MjogTWF0aC5tYXgoeDEsIHgzLCB4MikgKyB0b2xlcmFuY2UsXG4gICAgICB5MTogTWF0aC5taW4oeTEsIHkzLCB5MikgLSB0b2xlcmFuY2UsXG4gICAgICB5MjogTWF0aC5tYXgoeTEsIHkzLCB5MikgKyB0b2xlcmFuY2VcbiAgICB9OyAvLyBpZiBvdXRzaWRlIHRoZSByb3VnaCBib3VuZGluZyBib3ggZm9yIHRoZSBiZXppZXIsIHRoZW4gaXQgY2FuJ3QgYmUgYSBoaXRcblxuICAgIGlmICh4IDwgYmIueDEgfHwgeCA+IGJiLngyIHx8IHkgPCBiYi55MSB8fCB5ID4gYmIueTIpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdiZXppZXIgb3V0IG9mIHJvdWdoIGJiJylcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY29uc29sZS5sb2coJ2RvIG1vcmUgZXhwZW5zaXZlIGNoZWNrJyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH07XG4gIHZhciBzb2x2ZVF1YWRyYXRpYyA9IGZ1bmN0aW9uIHNvbHZlUXVhZHJhdGljKGEsIGIsIGMsIHZhbCkge1xuICAgIGMgLT0gdmFsO1xuICAgIHZhciByID0gYiAqIGIgLSA0ICogYSAqIGM7XG5cbiAgICBpZiAociA8IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICB2YXIgc3FydFIgPSBNYXRoLnNxcnQocik7XG4gICAgdmFyIGRlbm9tID0gMiAqIGE7XG4gICAgdmFyIHJvb3QxID0gKC1iICsgc3FydFIpIC8gZGVub207XG4gICAgdmFyIHJvb3QyID0gKC1iIC0gc3FydFIpIC8gZGVub207XG4gICAgcmV0dXJuIFtyb290MSwgcm9vdDJdO1xuICB9O1xuICB2YXIgc29sdmVDdWJpYyA9IGZ1bmN0aW9uIHNvbHZlQ3ViaWMoYSwgYiwgYywgZCwgcmVzdWx0KSB7XG4gICAgLy8gU29sdmVzIGEgY3ViaWMgZnVuY3Rpb24sIHJldHVybnMgcm9vdCBpbiBmb3JtIFtyMSwgaTEsIHIyLCBpMiwgcjMsIGkzXSwgd2hlcmVcbiAgICAvLyByIGlzIHRoZSByZWFsIGNvbXBvbmVudCwgaSBpcyB0aGUgaW1hZ2luYXJ5IGNvbXBvbmVudFxuICAgIC8vIEFuIGltcGxlbWVudGF0aW9uIG9mIHRoZSBDYXJkYW5vIG1ldGhvZCBmcm9tIHRoZSB5ZWFyIDE1NDVcbiAgICAvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0N1YmljX2Z1bmN0aW9uI1RoZV9uYXR1cmVfb2ZfdGhlX3Jvb3RzXG4gICAgdmFyIGVwc2lsb24gPSAwLjAwMDAxOyAvLyBhdm9pZCBkaXZpc2lvbiBieSB6ZXJvIHdoaWxlIGtlZXBpbmcgdGhlIG92ZXJhbGwgZXhwcmVzc2lvbiBjbG9zZSBpbiB2YWx1ZVxuXG4gICAgaWYgKGEgPT09IDApIHtcbiAgICAgIGEgPSBlcHNpbG9uO1xuICAgIH1cblxuICAgIGIgLz0gYTtcbiAgICBjIC89IGE7XG4gICAgZCAvPSBhO1xuICAgIHZhciBkaXNjcmltaW5hbnQsIHEsIHIsIGR1bTEsIHMsIHQsIHRlcm0xLCByMTM7XG4gICAgcSA9ICgzLjAgKiBjIC0gYiAqIGIpIC8gOS4wO1xuICAgIHIgPSAtKDI3LjAgKiBkKSArIGIgKiAoOS4wICogYyAtIDIuMCAqIChiICogYikpO1xuICAgIHIgLz0gNTQuMDtcbiAgICBkaXNjcmltaW5hbnQgPSBxICogcSAqIHEgKyByICogcjtcbiAgICByZXN1bHRbMV0gPSAwO1xuICAgIHRlcm0xID0gYiAvIDMuMDtcblxuICAgIGlmIChkaXNjcmltaW5hbnQgPiAwKSB7XG4gICAgICBzID0gciArIE1hdGguc3FydChkaXNjcmltaW5hbnQpO1xuICAgICAgcyA9IHMgPCAwID8gLU1hdGgucG93KC1zLCAxLjAgLyAzLjApIDogTWF0aC5wb3cocywgMS4wIC8gMy4wKTtcbiAgICAgIHQgPSByIC0gTWF0aC5zcXJ0KGRpc2NyaW1pbmFudCk7XG4gICAgICB0ID0gdCA8IDAgPyAtTWF0aC5wb3coLXQsIDEuMCAvIDMuMCkgOiBNYXRoLnBvdyh0LCAxLjAgLyAzLjApO1xuICAgICAgcmVzdWx0WzBdID0gLXRlcm0xICsgcyArIHQ7XG4gICAgICB0ZXJtMSArPSAocyArIHQpIC8gMi4wO1xuICAgICAgcmVzdWx0WzRdID0gcmVzdWx0WzJdID0gLXRlcm0xO1xuICAgICAgdGVybTEgPSBNYXRoLnNxcnQoMy4wKSAqICgtdCArIHMpIC8gMjtcbiAgICAgIHJlc3VsdFszXSA9IHRlcm0xO1xuICAgICAgcmVzdWx0WzVdID0gLXRlcm0xO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJlc3VsdFs1XSA9IHJlc3VsdFszXSA9IDA7XG5cbiAgICBpZiAoZGlzY3JpbWluYW50ID09PSAwKSB7XG4gICAgICByMTMgPSByIDwgMCA/IC1NYXRoLnBvdygtciwgMS4wIC8gMy4wKSA6IE1hdGgucG93KHIsIDEuMCAvIDMuMCk7XG4gICAgICByZXN1bHRbMF0gPSAtdGVybTEgKyAyLjAgKiByMTM7XG4gICAgICByZXN1bHRbNF0gPSByZXN1bHRbMl0gPSAtKHIxMyArIHRlcm0xKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBxID0gLXE7XG4gICAgZHVtMSA9IHEgKiBxICogcTtcbiAgICBkdW0xID0gTWF0aC5hY29zKHIgLyBNYXRoLnNxcnQoZHVtMSkpO1xuICAgIHIxMyA9IDIuMCAqIE1hdGguc3FydChxKTtcbiAgICByZXN1bHRbMF0gPSAtdGVybTEgKyByMTMgKiBNYXRoLmNvcyhkdW0xIC8gMy4wKTtcbiAgICByZXN1bHRbMl0gPSAtdGVybTEgKyByMTMgKiBNYXRoLmNvcygoZHVtMSArIDIuMCAqIE1hdGguUEkpIC8gMy4wKTtcbiAgICByZXN1bHRbNF0gPSAtdGVybTEgKyByMTMgKiBNYXRoLmNvcygoZHVtMSArIDQuMCAqIE1hdGguUEkpIC8gMy4wKTtcbiAgICByZXR1cm47XG4gIH07XG4gIHZhciBzcWRpc3RUb1F1YWRyYXRpY0JlemllciA9IGZ1bmN0aW9uIHNxZGlzdFRvUXVhZHJhdGljQmV6aWVyKHgsIHksIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcbiAgICAvLyBGaW5kIG1pbmltdW0gZGlzdGFuY2UgYnkgdXNpbmcgdGhlIG1pbmltdW0gb2YgdGhlIGRpc3RhbmNlXG4gICAgLy8gZnVuY3Rpb24gYmV0d2VlbiB0aGUgZ2l2ZW4gcG9pbnQgYW5kIHRoZSBjdXJ2ZVxuICAgIC8vIFRoaXMgZ2l2ZXMgdGhlIGNvZWZmaWNpZW50cyBvZiB0aGUgcmVzdWx0aW5nIGN1YmljIGVxdWF0aW9uXG4gICAgLy8gd2hvc2Ugcm9vdHMgdGVsbCB1cyB3aGVyZSBhIHBvc3NpYmxlIG1pbmltdW0gaXNcbiAgICAvLyAoQ29lZmZpY2llbnRzIGFyZSBkaXZpZGVkIGJ5IDQpXG4gICAgdmFyIGEgPSAxLjAgKiB4MSAqIHgxIC0gNCAqIHgxICogeDIgKyAyICogeDEgKiB4MyArIDQgKiB4MiAqIHgyIC0gNCAqIHgyICogeDMgKyB4MyAqIHgzICsgeTEgKiB5MSAtIDQgKiB5MSAqIHkyICsgMiAqIHkxICogeTMgKyA0ICogeTIgKiB5MiAtIDQgKiB5MiAqIHkzICsgeTMgKiB5MztcbiAgICB2YXIgYiA9IDEuMCAqIDkgKiB4MSAqIHgyIC0gMyAqIHgxICogeDEgLSAzICogeDEgKiB4MyAtIDYgKiB4MiAqIHgyICsgMyAqIHgyICogeDMgKyA5ICogeTEgKiB5MiAtIDMgKiB5MSAqIHkxIC0gMyAqIHkxICogeTMgLSA2ICogeTIgKiB5MiArIDMgKiB5MiAqIHkzO1xuICAgIHZhciBjID0gMS4wICogMyAqIHgxICogeDEgLSA2ICogeDEgKiB4MiArIHgxICogeDMgLSB4MSAqIHggKyAyICogeDIgKiB4MiArIDIgKiB4MiAqIHggLSB4MyAqIHggKyAzICogeTEgKiB5MSAtIDYgKiB5MSAqIHkyICsgeTEgKiB5MyAtIHkxICogeSArIDIgKiB5MiAqIHkyICsgMiAqIHkyICogeSAtIHkzICogeTtcbiAgICB2YXIgZCA9IDEuMCAqIHgxICogeDIgLSB4MSAqIHgxICsgeDEgKiB4IC0geDIgKiB4ICsgeTEgKiB5MiAtIHkxICogeTEgKyB5MSAqIHkgLSB5MiAqIHk7IC8vIGRlYnVnKFwiY29lZmZpY2llbnRzOiBcIiArIGEgLyBhICsgXCIsIFwiICsgYiAvIGEgKyBcIiwgXCIgKyBjIC8gYSArIFwiLCBcIiArIGQgLyBhKTtcblxuICAgIHZhciByb290cyA9IFtdOyAvLyBVc2UgdGhlIGN1YmljIHNvbHZpbmcgYWxnb3JpdGhtXG5cbiAgICBzb2x2ZUN1YmljKGEsIGIsIGMsIGQsIHJvb3RzKTtcbiAgICB2YXIgemVyb1RocmVzaG9sZCA9IDAuMDAwMDAwMTtcbiAgICB2YXIgcGFyYW1zID0gW107XG5cbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgNjsgaW5kZXggKz0gMikge1xuICAgICAgaWYgKE1hdGguYWJzKHJvb3RzW2luZGV4ICsgMV0pIDwgemVyb1RocmVzaG9sZCAmJiByb290c1tpbmRleF0gPj0gMCAmJiByb290c1tpbmRleF0gPD0gMS4wKSB7XG4gICAgICAgIHBhcmFtcy5wdXNoKHJvb3RzW2luZGV4XSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcGFyYW1zLnB1c2goMS4wKTtcbiAgICBwYXJhbXMucHVzaCgwLjApO1xuICAgIHZhciBtaW5EaXN0YW5jZVNxdWFyZWQgPSAtMTtcbiAgICB2YXIgY3VyWCwgY3VyWSwgZGlzdFNxdWFyZWQ7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGg7IGkrKykge1xuICAgICAgY3VyWCA9IE1hdGgucG93KDEuMCAtIHBhcmFtc1tpXSwgMi4wKSAqIHgxICsgMi4wICogKDEgLSBwYXJhbXNbaV0pICogcGFyYW1zW2ldICogeDIgKyBwYXJhbXNbaV0gKiBwYXJhbXNbaV0gKiB4MztcbiAgICAgIGN1clkgPSBNYXRoLnBvdygxIC0gcGFyYW1zW2ldLCAyLjApICogeTEgKyAyICogKDEuMCAtIHBhcmFtc1tpXSkgKiBwYXJhbXNbaV0gKiB5MiArIHBhcmFtc1tpXSAqIHBhcmFtc1tpXSAqIHkzO1xuICAgICAgZGlzdFNxdWFyZWQgPSBNYXRoLnBvdyhjdXJYIC0geCwgMikgKyBNYXRoLnBvdyhjdXJZIC0geSwgMik7IC8vIGRlYnVnKCdkaXN0YW5jZSBmb3IgcGFyYW0gJyArIHBhcmFtc1tpXSArIFwiOiBcIiArIE1hdGguc3FydChkaXN0U3F1YXJlZCkpO1xuXG4gICAgICBpZiAobWluRGlzdGFuY2VTcXVhcmVkID49IDApIHtcbiAgICAgICAgaWYgKGRpc3RTcXVhcmVkIDwgbWluRGlzdGFuY2VTcXVhcmVkKSB7XG4gICAgICAgICAgbWluRGlzdGFuY2VTcXVhcmVkID0gZGlzdFNxdWFyZWQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1pbkRpc3RhbmNlU3F1YXJlZCA9IGRpc3RTcXVhcmVkO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtaW5EaXN0YW5jZVNxdWFyZWQ7XG4gIH07XG4gIHZhciBzcWRpc3RUb0Zpbml0ZUxpbmUgPSBmdW5jdGlvbiBzcWRpc3RUb0Zpbml0ZUxpbmUoeCwgeSwgeDEsIHkxLCB4MiwgeTIpIHtcbiAgICB2YXIgb2Zmc2V0ID0gW3ggLSB4MSwgeSAtIHkxXTtcbiAgICB2YXIgbGluZSA9IFt4MiAtIHgxLCB5MiAtIHkxXTtcbiAgICB2YXIgbGluZVNxID0gbGluZVswXSAqIGxpbmVbMF0gKyBsaW5lWzFdICogbGluZVsxXTtcbiAgICB2YXIgaHlwU3EgPSBvZmZzZXRbMF0gKiBvZmZzZXRbMF0gKyBvZmZzZXRbMV0gKiBvZmZzZXRbMV07XG4gICAgdmFyIGRvdFByb2R1Y3QgPSBvZmZzZXRbMF0gKiBsaW5lWzBdICsgb2Zmc2V0WzFdICogbGluZVsxXTtcbiAgICB2YXIgYWRqU3EgPSBkb3RQcm9kdWN0ICogZG90UHJvZHVjdCAvIGxpbmVTcTtcblxuICAgIGlmIChkb3RQcm9kdWN0IDwgMCkge1xuICAgICAgcmV0dXJuIGh5cFNxO1xuICAgIH1cblxuICAgIGlmIChhZGpTcSA+IGxpbmVTcSkge1xuICAgICAgcmV0dXJuICh4IC0geDIpICogKHggLSB4MikgKyAoeSAtIHkyKSAqICh5IC0geTIpO1xuICAgIH1cblxuICAgIHJldHVybiBoeXBTcSAtIGFkalNxO1xuICB9O1xuICB2YXIgcG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzID0gZnVuY3Rpb24gcG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKHgsIHksIHBvaW50cykge1xuICAgIHZhciB4MSwgeTEsIHgyLCB5MjtcbiAgICB2YXIgeTM7IC8vIEludGVyc2VjdCB3aXRoIHZlcnRpY2FsIGxpbmUgdGhyb3VnaCAoeCwgeSlcblxuICAgIHZhciB1cCA9IDA7IC8vIGxldCBkb3duID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgeDEgPSBwb2ludHNbaSAqIDJdO1xuICAgICAgeTEgPSBwb2ludHNbaSAqIDIgKyAxXTtcblxuICAgICAgaWYgKGkgKyAxIDwgcG9pbnRzLmxlbmd0aCAvIDIpIHtcbiAgICAgICAgeDIgPSBwb2ludHNbKGkgKyAxKSAqIDJdO1xuICAgICAgICB5MiA9IHBvaW50c1soaSArIDEpICogMiArIDFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeDIgPSBwb2ludHNbKGkgKyAxIC0gcG9pbnRzLmxlbmd0aCAvIDIpICogMl07XG4gICAgICAgIHkyID0gcG9pbnRzWyhpICsgMSAtIHBvaW50cy5sZW5ndGggLyAyKSAqIDIgKyAxXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHgxID09IHggJiYgeDIgPT0geCkgOyBlbHNlIGlmICh4MSA+PSB4ICYmIHggPj0geDIgfHwgeDEgPD0geCAmJiB4IDw9IHgyKSB7XG4gICAgICAgIHkzID0gKHggLSB4MSkgLyAoeDIgLSB4MSkgKiAoeTIgLSB5MSkgKyB5MTtcblxuICAgICAgICBpZiAoeTMgPiB5KSB7XG4gICAgICAgICAgdXArKztcbiAgICAgICAgfSAvLyBpZiggeTMgPCB5ICl7XG4gICAgICAgIC8vIGRvd24rKztcbiAgICAgICAgLy8gfVxuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodXAgJSAyID09PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfTtcbiAgdmFyIHBvaW50SW5zaWRlUG9seWdvbiA9IGZ1bmN0aW9uIHBvaW50SW5zaWRlUG9seWdvbih4LCB5LCBiYXNlUG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBkaXJlY3Rpb24sIHBhZGRpbmcpIHtcbiAgICB2YXIgdHJhbnNmb3JtZWRQb2ludHMgPSBuZXcgQXJyYXkoYmFzZVBvaW50cy5sZW5ndGgpOyAvLyBHaXZlcyBuZWdhdGl2ZSBhbmdsZVxuXG4gICAgdmFyIGFuZ2xlO1xuXG4gICAgaWYgKGRpcmVjdGlvblswXSAhPSBudWxsKSB7XG4gICAgICBhbmdsZSA9IE1hdGguYXRhbihkaXJlY3Rpb25bMV0gLyBkaXJlY3Rpb25bMF0pO1xuXG4gICAgICBpZiAoZGlyZWN0aW9uWzBdIDwgMCkge1xuICAgICAgICBhbmdsZSA9IGFuZ2xlICsgTWF0aC5QSSAvIDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbmdsZSA9IC1hbmdsZSAtIE1hdGguUEkgLyAyO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBhbmdsZSA9IGRpcmVjdGlvbjtcbiAgICB9XG5cbiAgICB2YXIgY29zID0gTWF0aC5jb3MoLWFuZ2xlKTtcbiAgICB2YXIgc2luID0gTWF0aC5zaW4oLWFuZ2xlKTsgLy8gICAgY29uc29sZS5sb2coXCJiYXNlOiBcIiArIGJhc2VQb2ludHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFuc2Zvcm1lZFBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgIHRyYW5zZm9ybWVkUG9pbnRzW2kgKiAyXSA9IHdpZHRoIC8gMiAqIChiYXNlUG9pbnRzW2kgKiAyXSAqIGNvcyAtIGJhc2VQb2ludHNbaSAqIDIgKyAxXSAqIHNpbik7XG4gICAgICB0cmFuc2Zvcm1lZFBvaW50c1tpICogMiArIDFdID0gaGVpZ2h0IC8gMiAqIChiYXNlUG9pbnRzW2kgKiAyICsgMV0gKiBjb3MgKyBiYXNlUG9pbnRzW2kgKiAyXSAqIHNpbik7XG4gICAgICB0cmFuc2Zvcm1lZFBvaW50c1tpICogMl0gKz0gY2VudGVyWDtcbiAgICAgIHRyYW5zZm9ybWVkUG9pbnRzW2kgKiAyICsgMV0gKz0gY2VudGVyWTtcbiAgICB9XG5cbiAgICB2YXIgcG9pbnRzO1xuXG4gICAgaWYgKHBhZGRpbmcgPiAwKSB7XG4gICAgICB2YXIgZXhwYW5kZWRMaW5lU2V0ID0gZXhwYW5kUG9seWdvbih0cmFuc2Zvcm1lZFBvaW50cywgLXBhZGRpbmcpO1xuICAgICAgcG9pbnRzID0gam9pbkxpbmVzKGV4cGFuZGVkTGluZVNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvaW50cyA9IHRyYW5zZm9ybWVkUG9pbnRzO1xuICAgIH1cblxuICAgIHJldHVybiBwb2ludEluc2lkZVBvbHlnb25Qb2ludHMoeCwgeSwgcG9pbnRzKTtcbiAgfTtcbiAgdmFyIHBvaW50SW5zaWRlUm91bmRQb2x5Z29uID0gZnVuY3Rpb24gcG9pbnRJbnNpZGVSb3VuZFBvbHlnb24oeCwgeSwgYmFzZVBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCkge1xuICAgIHZhciBjdXRQb2x5Z29uUG9pbnRzID0gbmV3IEFycmF5KGJhc2VQb2ludHMubGVuZ3RoKTtcbiAgICB2YXIgaGFsZlcgPSB3aWR0aCAvIDI7XG4gICAgdmFyIGhhbGZIID0gaGVpZ2h0IC8gMjtcbiAgICB2YXIgY29ybmVyUmFkaXVzID0gZ2V0Um91bmRQb2x5Z29uUmFkaXVzKHdpZHRoLCBoZWlnaHQpO1xuICAgIHZhciBzcXVhcmVkQ29ybmVyUmFkaXVzID0gY29ybmVyUmFkaXVzICogY29ybmVyUmFkaXVzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYXNlUG9pbnRzLmxlbmd0aCAvIDQ7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZVV2ID0gdm9pZCAwLFxuICAgICAgICAgIGRlc3RVdiA9IHZvaWQgMDtcblxuICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgc291cmNlVXYgPSBiYXNlUG9pbnRzLmxlbmd0aCAtIDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzb3VyY2VVdiA9IGkgKiA0IC0gMjtcbiAgICAgIH1cblxuICAgICAgZGVzdFV2ID0gaSAqIDQgKyAyO1xuICAgICAgdmFyIHB4ID0gY2VudGVyWCArIGhhbGZXICogYmFzZVBvaW50c1tpICogNF07XG4gICAgICB2YXIgcHkgPSBjZW50ZXJZICsgaGFsZkggKiBiYXNlUG9pbnRzW2kgKiA0ICsgMV07XG4gICAgICB2YXIgY29zVGhldGEgPSAtYmFzZVBvaW50c1tzb3VyY2VVdl0gKiBiYXNlUG9pbnRzW2Rlc3RVdl0gLSBiYXNlUG9pbnRzW3NvdXJjZVV2ICsgMV0gKiBiYXNlUG9pbnRzW2Rlc3RVdiArIDFdO1xuICAgICAgdmFyIG9mZnNldCA9IGNvcm5lclJhZGl1cyAvIE1hdGgudGFuKE1hdGguYWNvcyhjb3NUaGV0YSkgLyAyKTtcbiAgICAgIHZhciBjcDB4ID0gcHggLSBvZmZzZXQgKiBiYXNlUG9pbnRzW3NvdXJjZVV2XTtcbiAgICAgIHZhciBjcDB5ID0gcHkgLSBvZmZzZXQgKiBiYXNlUG9pbnRzW3NvdXJjZVV2ICsgMV07XG4gICAgICB2YXIgY3AxeCA9IHB4ICsgb2Zmc2V0ICogYmFzZVBvaW50c1tkZXN0VXZdO1xuICAgICAgdmFyIGNwMXkgPSBweSArIG9mZnNldCAqIGJhc2VQb2ludHNbZGVzdFV2ICsgMV07XG4gICAgICBjdXRQb2x5Z29uUG9pbnRzW2kgKiA0XSA9IGNwMHg7XG4gICAgICBjdXRQb2x5Z29uUG9pbnRzW2kgKiA0ICsgMV0gPSBjcDB5O1xuICAgICAgY3V0UG9seWdvblBvaW50c1tpICogNCArIDJdID0gY3AxeDtcbiAgICAgIGN1dFBvbHlnb25Qb2ludHNbaSAqIDQgKyAzXSA9IGNwMXk7XG4gICAgICB2YXIgb3J0aHggPSBiYXNlUG9pbnRzW3NvdXJjZVV2ICsgMV07XG4gICAgICB2YXIgb3J0aHkgPSAtYmFzZVBvaW50c1tzb3VyY2VVdl07XG4gICAgICB2YXIgY29zQWxwaGEgPSBvcnRoeCAqIGJhc2VQb2ludHNbZGVzdFV2XSArIG9ydGh5ICogYmFzZVBvaW50c1tkZXN0VXYgKyAxXTtcblxuICAgICAgaWYgKGNvc0FscGhhIDwgMCkge1xuICAgICAgICBvcnRoeCAqPSAtMTtcbiAgICAgICAgb3J0aHkgKj0gLTE7XG4gICAgICB9XG5cbiAgICAgIHZhciBjeCA9IGNwMHggKyBvcnRoeCAqIGNvcm5lclJhZGl1cztcbiAgICAgIHZhciBjeSA9IGNwMHkgKyBvcnRoeSAqIGNvcm5lclJhZGl1cztcbiAgICAgIHZhciBzcXVhcmVkRGlzdGFuY2UgPSBNYXRoLnBvdyhjeCAtIHgsIDIpICsgTWF0aC5wb3coY3kgLSB5LCAyKTtcblxuICAgICAgaWYgKHNxdWFyZWREaXN0YW5jZSA8PSBzcXVhcmVkQ29ybmVyUmFkaXVzKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwb2ludEluc2lkZVBvbHlnb25Qb2ludHMoeCwgeSwgY3V0UG9seWdvblBvaW50cyk7XG4gIH07XG4gIHZhciBqb2luTGluZXMgPSBmdW5jdGlvbiBqb2luTGluZXMobGluZVNldCkge1xuICAgIHZhciB2ZXJ0aWNlcyA9IG5ldyBBcnJheShsaW5lU2V0Lmxlbmd0aCAvIDIpO1xuICAgIHZhciBjdXJyZW50TGluZVN0YXJ0WCwgY3VycmVudExpbmVTdGFydFksIGN1cnJlbnRMaW5lRW5kWCwgY3VycmVudExpbmVFbmRZO1xuICAgIHZhciBuZXh0TGluZVN0YXJ0WCwgbmV4dExpbmVTdGFydFksIG5leHRMaW5lRW5kWCwgbmV4dExpbmVFbmRZO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lU2V0Lmxlbmd0aCAvIDQ7IGkrKykge1xuICAgICAgY3VycmVudExpbmVTdGFydFggPSBsaW5lU2V0W2kgKiA0XTtcbiAgICAgIGN1cnJlbnRMaW5lU3RhcnRZID0gbGluZVNldFtpICogNCArIDFdO1xuICAgICAgY3VycmVudExpbmVFbmRYID0gbGluZVNldFtpICogNCArIDJdO1xuICAgICAgY3VycmVudExpbmVFbmRZID0gbGluZVNldFtpICogNCArIDNdO1xuXG4gICAgICBpZiAoaSA8IGxpbmVTZXQubGVuZ3RoIC8gNCAtIDEpIHtcbiAgICAgICAgbmV4dExpbmVTdGFydFggPSBsaW5lU2V0WyhpICsgMSkgKiA0XTtcbiAgICAgICAgbmV4dExpbmVTdGFydFkgPSBsaW5lU2V0WyhpICsgMSkgKiA0ICsgMV07XG4gICAgICAgIG5leHRMaW5lRW5kWCA9IGxpbmVTZXRbKGkgKyAxKSAqIDQgKyAyXTtcbiAgICAgICAgbmV4dExpbmVFbmRZID0gbGluZVNldFsoaSArIDEpICogNCArIDNdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dExpbmVTdGFydFggPSBsaW5lU2V0WzBdO1xuICAgICAgICBuZXh0TGluZVN0YXJ0WSA9IGxpbmVTZXRbMV07XG4gICAgICAgIG5leHRMaW5lRW5kWCA9IGxpbmVTZXRbMl07XG4gICAgICAgIG5leHRMaW5lRW5kWSA9IGxpbmVTZXRbM107XG4gICAgICB9XG5cbiAgICAgIHZhciBpbnRlcnNlY3Rpb24gPSBmaW5pdGVMaW5lc0ludGVyc2VjdChjdXJyZW50TGluZVN0YXJ0WCwgY3VycmVudExpbmVTdGFydFksIGN1cnJlbnRMaW5lRW5kWCwgY3VycmVudExpbmVFbmRZLCBuZXh0TGluZVN0YXJ0WCwgbmV4dExpbmVTdGFydFksIG5leHRMaW5lRW5kWCwgbmV4dExpbmVFbmRZLCB0cnVlKTtcbiAgICAgIHZlcnRpY2VzW2kgKiAyXSA9IGludGVyc2VjdGlvblswXTtcbiAgICAgIHZlcnRpY2VzW2kgKiAyICsgMV0gPSBpbnRlcnNlY3Rpb25bMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHZlcnRpY2VzO1xuICB9O1xuICB2YXIgZXhwYW5kUG9seWdvbiA9IGZ1bmN0aW9uIGV4cGFuZFBvbHlnb24ocG9pbnRzLCBwYWQpIHtcbiAgICB2YXIgZXhwYW5kZWRMaW5lU2V0ID0gbmV3IEFycmF5KHBvaW50cy5sZW5ndGggKiAyKTtcbiAgICB2YXIgY3VycmVudFBvaW50WCwgY3VycmVudFBvaW50WSwgbmV4dFBvaW50WCwgbmV4dFBvaW50WTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgY3VycmVudFBvaW50WCA9IHBvaW50c1tpICogMl07XG4gICAgICBjdXJyZW50UG9pbnRZID0gcG9pbnRzW2kgKiAyICsgMV07XG5cbiAgICAgIGlmIChpIDwgcG9pbnRzLmxlbmd0aCAvIDIgLSAxKSB7XG4gICAgICAgIG5leHRQb2ludFggPSBwb2ludHNbKGkgKyAxKSAqIDJdO1xuICAgICAgICBuZXh0UG9pbnRZID0gcG9pbnRzWyhpICsgMSkgKiAyICsgMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0UG9pbnRYID0gcG9pbnRzWzBdO1xuICAgICAgICBuZXh0UG9pbnRZID0gcG9pbnRzWzFdO1xuICAgICAgfSAvLyBDdXJyZW50IGxpbmU6IFtjdXJyZW50UG9pbnRYLCBjdXJyZW50UG9pbnRZXSB0byBbbmV4dFBvaW50WCwgbmV4dFBvaW50WV1cbiAgICAgIC8vIEFzc3VtZSBDQ1cgcG9seWdvbiB3aW5kaW5nXG5cblxuICAgICAgdmFyIG9mZnNldFggPSBuZXh0UG9pbnRZIC0gY3VycmVudFBvaW50WTtcbiAgICAgIHZhciBvZmZzZXRZID0gLShuZXh0UG9pbnRYIC0gY3VycmVudFBvaW50WCk7IC8vIE5vcm1hbGl6ZVxuXG4gICAgICB2YXIgb2Zmc2V0TGVuZ3RoID0gTWF0aC5zcXJ0KG9mZnNldFggKiBvZmZzZXRYICsgb2Zmc2V0WSAqIG9mZnNldFkpO1xuICAgICAgdmFyIG5vcm1hbGl6ZWRPZmZzZXRYID0gb2Zmc2V0WCAvIG9mZnNldExlbmd0aDtcbiAgICAgIHZhciBub3JtYWxpemVkT2Zmc2V0WSA9IG9mZnNldFkgLyBvZmZzZXRMZW5ndGg7XG4gICAgICBleHBhbmRlZExpbmVTZXRbaSAqIDRdID0gY3VycmVudFBvaW50WCArIG5vcm1hbGl6ZWRPZmZzZXRYICogcGFkO1xuICAgICAgZXhwYW5kZWRMaW5lU2V0W2kgKiA0ICsgMV0gPSBjdXJyZW50UG9pbnRZICsgbm9ybWFsaXplZE9mZnNldFkgKiBwYWQ7XG4gICAgICBleHBhbmRlZExpbmVTZXRbaSAqIDQgKyAyXSA9IG5leHRQb2ludFggKyBub3JtYWxpemVkT2Zmc2V0WCAqIHBhZDtcbiAgICAgIGV4cGFuZGVkTGluZVNldFtpICogNCArIDNdID0gbmV4dFBvaW50WSArIG5vcm1hbGl6ZWRPZmZzZXRZICogcGFkO1xuICAgIH1cblxuICAgIHJldHVybiBleHBhbmRlZExpbmVTZXQ7XG4gIH07XG4gIHZhciBpbnRlcnNlY3RMaW5lRWxsaXBzZSA9IGZ1bmN0aW9uIGludGVyc2VjdExpbmVFbGxpcHNlKHgsIHksIGNlbnRlclgsIGNlbnRlclksIGVsbGlwc2VXcmFkaXVzLCBlbGxpcHNlSHJhZGl1cykge1xuICAgIHZhciBkaXNwWCA9IGNlbnRlclggLSB4O1xuICAgIHZhciBkaXNwWSA9IGNlbnRlclkgLSB5O1xuICAgIGRpc3BYIC89IGVsbGlwc2VXcmFkaXVzO1xuICAgIGRpc3BZIC89IGVsbGlwc2VIcmFkaXVzO1xuICAgIHZhciBsZW4gPSBNYXRoLnNxcnQoZGlzcFggKiBkaXNwWCArIGRpc3BZICogZGlzcFkpO1xuICAgIHZhciBuZXdMZW5ndGggPSBsZW4gLSAxO1xuXG4gICAgaWYgKG5ld0xlbmd0aCA8IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICB2YXIgbGVuUHJvcG9ydGlvbiA9IG5ld0xlbmd0aCAvIGxlbjtcbiAgICByZXR1cm4gWyhjZW50ZXJYIC0geCkgKiBsZW5Qcm9wb3J0aW9uICsgeCwgKGNlbnRlclkgLSB5KSAqIGxlblByb3BvcnRpb24gKyB5XTtcbiAgfTtcbiAgdmFyIGNoZWNrSW5FbGxpcHNlID0gZnVuY3Rpb24gY2hlY2tJbkVsbGlwc2UoeCwgeSwgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSwgcGFkZGluZykge1xuICAgIHggLT0gY2VudGVyWDtcbiAgICB5IC09IGNlbnRlclk7XG4gICAgeCAvPSB3aWR0aCAvIDIgKyBwYWRkaW5nO1xuICAgIHkgLz0gaGVpZ2h0IC8gMiArIHBhZGRpbmc7XG4gICAgcmV0dXJuIHggKiB4ICsgeSAqIHkgPD0gMTtcbiAgfTsgLy8gUmV0dXJucyBpbnRlcnNlY3Rpb25zIG9mIGluY3JlYXNpbmcgZGlzdGFuY2UgZnJvbSBsaW5lJ3Mgc3RhcnQgcG9pbnRcblxuICB2YXIgaW50ZXJzZWN0TGluZUNpcmNsZSA9IGZ1bmN0aW9uIGludGVyc2VjdExpbmVDaXJjbGUoeDEsIHkxLCB4MiwgeTIsIGNlbnRlclgsIGNlbnRlclksIHJhZGl1cykge1xuICAgIC8vIENhbGN1bGF0ZSBkLCBkaXJlY3Rpb24gdmVjdG9yIG9mIGxpbmVcbiAgICB2YXIgZCA9IFt4MiAtIHgxLCB5MiAtIHkxXTsgLy8gRGlyZWN0aW9uIHZlY3RvciBvZiBsaW5lXG5cbiAgICB2YXIgZiA9IFt4MSAtIGNlbnRlclgsIHkxIC0gY2VudGVyWV07XG4gICAgdmFyIGEgPSBkWzBdICogZFswXSArIGRbMV0gKiBkWzFdO1xuICAgIHZhciBiID0gMiAqIChmWzBdICogZFswXSArIGZbMV0gKiBkWzFdKTtcbiAgICB2YXIgYyA9IGZbMF0gKiBmWzBdICsgZlsxXSAqIGZbMV0gLSByYWRpdXMgKiByYWRpdXM7XG4gICAgdmFyIGRpc2NyaW1pbmFudCA9IGIgKiBiIC0gNCAqIGEgKiBjO1xuXG4gICAgaWYgKGRpc2NyaW1pbmFudCA8IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICB2YXIgdDEgPSAoLWIgKyBNYXRoLnNxcnQoZGlzY3JpbWluYW50KSkgLyAoMiAqIGEpO1xuICAgIHZhciB0MiA9ICgtYiAtIE1hdGguc3FydChkaXNjcmltaW5hbnQpKSAvICgyICogYSk7XG4gICAgdmFyIHRNaW4gPSBNYXRoLm1pbih0MSwgdDIpO1xuICAgIHZhciB0TWF4ID0gTWF0aC5tYXgodDEsIHQyKTtcbiAgICB2YXIgaW5SYW5nZVBhcmFtcyA9IFtdO1xuXG4gICAgaWYgKHRNaW4gPj0gMCAmJiB0TWluIDw9IDEpIHtcbiAgICAgIGluUmFuZ2VQYXJhbXMucHVzaCh0TWluKTtcbiAgICB9XG5cbiAgICBpZiAodE1heCA+PSAwICYmIHRNYXggPD0gMSkge1xuICAgICAgaW5SYW5nZVBhcmFtcy5wdXNoKHRNYXgpO1xuICAgIH1cblxuICAgIGlmIChpblJhbmdlUGFyYW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHZhciBuZWFySW50ZXJzZWN0aW9uWCA9IGluUmFuZ2VQYXJhbXNbMF0gKiBkWzBdICsgeDE7XG4gICAgdmFyIG5lYXJJbnRlcnNlY3Rpb25ZID0gaW5SYW5nZVBhcmFtc1swXSAqIGRbMV0gKyB5MTtcblxuICAgIGlmIChpblJhbmdlUGFyYW1zLmxlbmd0aCA+IDEpIHtcbiAgICAgIGlmIChpblJhbmdlUGFyYW1zWzBdID09IGluUmFuZ2VQYXJhbXNbMV0pIHtcbiAgICAgICAgcmV0dXJuIFtuZWFySW50ZXJzZWN0aW9uWCwgbmVhckludGVyc2VjdGlvblldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGZhckludGVyc2VjdGlvblggPSBpblJhbmdlUGFyYW1zWzFdICogZFswXSArIHgxO1xuICAgICAgICB2YXIgZmFySW50ZXJzZWN0aW9uWSA9IGluUmFuZ2VQYXJhbXNbMV0gKiBkWzFdICsgeTE7XG4gICAgICAgIHJldHVybiBbbmVhckludGVyc2VjdGlvblgsIG5lYXJJbnRlcnNlY3Rpb25ZLCBmYXJJbnRlcnNlY3Rpb25YLCBmYXJJbnRlcnNlY3Rpb25ZXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFtuZWFySW50ZXJzZWN0aW9uWCwgbmVhckludGVyc2VjdGlvblldO1xuICAgIH1cbiAgfTtcbiAgdmFyIG1pZE9mVGhyZWUgPSBmdW5jdGlvbiBtaWRPZlRocmVlKGEsIGIsIGMpIHtcbiAgICBpZiAoYiA8PSBhICYmIGEgPD0gYyB8fCBjIDw9IGEgJiYgYSA8PSBiKSB7XG4gICAgICByZXR1cm4gYTtcbiAgICB9IGVsc2UgaWYgKGEgPD0gYiAmJiBiIDw9IGMgfHwgYyA8PSBiICYmIGIgPD0gYSkge1xuICAgICAgcmV0dXJuIGI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjO1xuICAgIH1cbiAgfTsgLy8gKHgxLHkxKT0+KHgyLHkyKSBpbnRlcnNlY3Qgd2l0aCAoeDMseTMpPT4oeDQseTQpXG5cbiAgdmFyIGZpbml0ZUxpbmVzSW50ZXJzZWN0ID0gZnVuY3Rpb24gZmluaXRlTGluZXNJbnRlcnNlY3QoeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeDQsIHk0LCBpbmZpbml0ZUxpbmVzKSB7XG4gICAgdmFyIGR4MTMgPSB4MSAtIHgzO1xuICAgIHZhciBkeDIxID0geDIgLSB4MTtcbiAgICB2YXIgZHg0MyA9IHg0IC0geDM7XG4gICAgdmFyIGR5MTMgPSB5MSAtIHkzO1xuICAgIHZhciBkeTIxID0geTIgLSB5MTtcbiAgICB2YXIgZHk0MyA9IHk0IC0geTM7XG4gICAgdmFyIHVhX3QgPSBkeDQzICogZHkxMyAtIGR5NDMgKiBkeDEzO1xuICAgIHZhciB1Yl90ID0gZHgyMSAqIGR5MTMgLSBkeTIxICogZHgxMztcbiAgICB2YXIgdV9iID0gZHk0MyAqIGR4MjEgLSBkeDQzICogZHkyMTtcblxuICAgIGlmICh1X2IgIT09IDApIHtcbiAgICAgIHZhciB1YSA9IHVhX3QgLyB1X2I7XG4gICAgICB2YXIgdWIgPSB1Yl90IC8gdV9iO1xuICAgICAgdmFyIGZscHRUaHJlc2hvbGQgPSAwLjAwMTtcblxuICAgICAgdmFyIF9taW4gPSAwIC0gZmxwdFRocmVzaG9sZDtcblxuICAgICAgdmFyIF9tYXggPSAxICsgZmxwdFRocmVzaG9sZDtcblxuICAgICAgaWYgKF9taW4gPD0gdWEgJiYgdWEgPD0gX21heCAmJiBfbWluIDw9IHViICYmIHViIDw9IF9tYXgpIHtcbiAgICAgICAgcmV0dXJuIFt4MSArIHVhICogZHgyMSwgeTEgKyB1YSAqIGR5MjFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFpbmZpbml0ZUxpbmVzKSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBbeDEgKyB1YSAqIGR4MjEsIHkxICsgdWEgKiBkeTIxXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodWFfdCA9PT0gMCB8fCB1Yl90ID09PSAwKSB7XG4gICAgICAgIC8vIFBhcmFsbGVsLCBjb2luY2lkZW50IGxpbmVzLiBDaGVjayBpZiBvdmVybGFwXG4gICAgICAgIC8vIENoZWNrIGVuZHBvaW50IG9mIHNlY29uZCBsaW5lXG4gICAgICAgIGlmIChtaWRPZlRocmVlKHgxLCB4MiwgeDQpID09PSB4NCkge1xuICAgICAgICAgIHJldHVybiBbeDQsIHk0XTtcbiAgICAgICAgfSAvLyBDaGVjayBzdGFydCBwb2ludCBvZiBzZWNvbmQgbGluZVxuXG5cbiAgICAgICAgaWYgKG1pZE9mVGhyZWUoeDEsIHgyLCB4MykgPT09IHgzKSB7XG4gICAgICAgICAgcmV0dXJuIFt4MywgeTNdO1xuICAgICAgICB9IC8vIEVuZHBvaW50IG9mIGZpcnN0IGxpbmVcblxuXG4gICAgICAgIGlmIChtaWRPZlRocmVlKHgzLCB4NCwgeDIpID09PSB4Mikge1xuICAgICAgICAgIHJldHVybiBbeDIsIHkyXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFBhcmFsbGVsLCBub24tY29pbmNpZGVudFxuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgfVxuICB9OyAvLyBtYXRoLnBvbHlnb25JbnRlcnNlY3RMaW5lKCB4LCB5LCBiYXNlUG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBwYWRkaW5nIClcbiAgLy8gaW50ZXJzZWN0IGEgbm9kZSBwb2x5Z29uIChwdHMgdHJhbnNmb3JtZWQpXG4gIC8vXG4gIC8vIG1hdGgucG9seWdvbkludGVyc2VjdExpbmUoIHgsIHksIGJhc2VQb2ludHMsIGNlbnRlclgsIGNlbnRlclkgKVxuICAvLyBpbnRlcnNlY3QgdGhlIHBvaW50cyAobm8gdHJhbnNmb3JtKVxuXG4gIHZhciBwb2x5Z29uSW50ZXJzZWN0TGluZSA9IGZ1bmN0aW9uIHBvbHlnb25JbnRlcnNlY3RMaW5lKHgsIHksIGJhc2VQb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIHBhZGRpbmcpIHtcbiAgICB2YXIgaW50ZXJzZWN0aW9ucyA9IFtdO1xuICAgIHZhciBpbnRlcnNlY3Rpb247XG4gICAgdmFyIHRyYW5zZm9ybWVkUG9pbnRzID0gbmV3IEFycmF5KGJhc2VQb2ludHMubGVuZ3RoKTtcbiAgICB2YXIgZG9UcmFuc2Zvcm0gPSB0cnVlO1xuXG4gICAgaWYgKHdpZHRoID09IG51bGwpIHtcbiAgICAgIGRvVHJhbnNmb3JtID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHBvaW50cztcblxuICAgIGlmIChkb1RyYW5zZm9ybSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFuc2Zvcm1lZFBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgICAgdHJhbnNmb3JtZWRQb2ludHNbaSAqIDJdID0gYmFzZVBvaW50c1tpICogMl0gKiB3aWR0aCArIGNlbnRlclg7XG4gICAgICAgIHRyYW5zZm9ybWVkUG9pbnRzW2kgKiAyICsgMV0gPSBiYXNlUG9pbnRzW2kgKiAyICsgMV0gKiBoZWlnaHQgKyBjZW50ZXJZO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFkZGluZyA+IDApIHtcbiAgICAgICAgdmFyIGV4cGFuZGVkTGluZVNldCA9IGV4cGFuZFBvbHlnb24odHJhbnNmb3JtZWRQb2ludHMsIC1wYWRkaW5nKTtcbiAgICAgICAgcG9pbnRzID0gam9pbkxpbmVzKGV4cGFuZGVkTGluZVNldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb2ludHMgPSB0cmFuc2Zvcm1lZFBvaW50cztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcG9pbnRzID0gYmFzZVBvaW50cztcbiAgICB9XG5cbiAgICB2YXIgY3VycmVudFgsIGN1cnJlbnRZLCBuZXh0WCwgbmV4dFk7XG5cbiAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBwb2ludHMubGVuZ3RoIC8gMjsgX2kyKyspIHtcbiAgICAgIGN1cnJlbnRYID0gcG9pbnRzW19pMiAqIDJdO1xuICAgICAgY3VycmVudFkgPSBwb2ludHNbX2kyICogMiArIDFdO1xuXG4gICAgICBpZiAoX2kyIDwgcG9pbnRzLmxlbmd0aCAvIDIgLSAxKSB7XG4gICAgICAgIG5leHRYID0gcG9pbnRzWyhfaTIgKyAxKSAqIDJdO1xuICAgICAgICBuZXh0WSA9IHBvaW50c1soX2kyICsgMSkgKiAyICsgMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0WCA9IHBvaW50c1swXTtcbiAgICAgICAgbmV4dFkgPSBwb2ludHNbMV07XG4gICAgICB9XG5cbiAgICAgIGludGVyc2VjdGlvbiA9IGZpbml0ZUxpbmVzSW50ZXJzZWN0KHgsIHksIGNlbnRlclgsIGNlbnRlclksIGN1cnJlbnRYLCBjdXJyZW50WSwgbmV4dFgsIG5leHRZKTtcblxuICAgICAgaWYgKGludGVyc2VjdGlvbi5sZW5ndGggIT09IDApIHtcbiAgICAgICAgaW50ZXJzZWN0aW9ucy5wdXNoKGludGVyc2VjdGlvblswXSwgaW50ZXJzZWN0aW9uWzFdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW50ZXJzZWN0aW9ucztcbiAgfTtcbiAgdmFyIHJvdW5kUG9seWdvbkludGVyc2VjdExpbmUgPSBmdW5jdGlvbiByb3VuZFBvbHlnb25JbnRlcnNlY3RMaW5lKHgsIHksIGJhc2VQb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIHBhZGRpbmcpIHtcbiAgICB2YXIgaW50ZXJzZWN0aW9ucyA9IFtdO1xuICAgIHZhciBpbnRlcnNlY3Rpb247XG4gICAgdmFyIGxpbmVzID0gbmV3IEFycmF5KGJhc2VQb2ludHMubGVuZ3RoKTtcbiAgICB2YXIgaGFsZlcgPSB3aWR0aCAvIDI7XG4gICAgdmFyIGhhbGZIID0gaGVpZ2h0IC8gMjtcbiAgICB2YXIgY29ybmVyUmFkaXVzID0gZ2V0Um91bmRQb2x5Z29uUmFkaXVzKHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYXNlUG9pbnRzLmxlbmd0aCAvIDQ7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZVV2ID0gdm9pZCAwLFxuICAgICAgICAgIGRlc3RVdiA9IHZvaWQgMDtcblxuICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgc291cmNlVXYgPSBiYXNlUG9pbnRzLmxlbmd0aCAtIDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzb3VyY2VVdiA9IGkgKiA0IC0gMjtcbiAgICAgIH1cblxuICAgICAgZGVzdFV2ID0gaSAqIDQgKyAyO1xuICAgICAgdmFyIHB4ID0gY2VudGVyWCArIGhhbGZXICogYmFzZVBvaW50c1tpICogNF07XG4gICAgICB2YXIgcHkgPSBjZW50ZXJZICsgaGFsZkggKiBiYXNlUG9pbnRzW2kgKiA0ICsgMV07XG4gICAgICB2YXIgY29zVGhldGEgPSAtYmFzZVBvaW50c1tzb3VyY2VVdl0gKiBiYXNlUG9pbnRzW2Rlc3RVdl0gLSBiYXNlUG9pbnRzW3NvdXJjZVV2ICsgMV0gKiBiYXNlUG9pbnRzW2Rlc3RVdiArIDFdO1xuICAgICAgdmFyIG9mZnNldCA9IGNvcm5lclJhZGl1cyAvIE1hdGgudGFuKE1hdGguYWNvcyhjb3NUaGV0YSkgLyAyKTtcbiAgICAgIHZhciBjcDB4ID0gcHggLSBvZmZzZXQgKiBiYXNlUG9pbnRzW3NvdXJjZVV2XTtcbiAgICAgIHZhciBjcDB5ID0gcHkgLSBvZmZzZXQgKiBiYXNlUG9pbnRzW3NvdXJjZVV2ICsgMV07XG4gICAgICB2YXIgY3AxeCA9IHB4ICsgb2Zmc2V0ICogYmFzZVBvaW50c1tkZXN0VXZdO1xuICAgICAgdmFyIGNwMXkgPSBweSArIG9mZnNldCAqIGJhc2VQb2ludHNbZGVzdFV2ICsgMV07XG5cbiAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgIGxpbmVzW2Jhc2VQb2ludHMubGVuZ3RoIC0gMl0gPSBjcDB4O1xuICAgICAgICBsaW5lc1tiYXNlUG9pbnRzLmxlbmd0aCAtIDFdID0gY3AweTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpbmVzW2kgKiA0IC0gMl0gPSBjcDB4O1xuICAgICAgICBsaW5lc1tpICogNCAtIDFdID0gY3AweTtcbiAgICAgIH1cblxuICAgICAgbGluZXNbaSAqIDRdID0gY3AxeDtcbiAgICAgIGxpbmVzW2kgKiA0ICsgMV0gPSBjcDF5O1xuICAgICAgdmFyIG9ydGh4ID0gYmFzZVBvaW50c1tzb3VyY2VVdiArIDFdO1xuICAgICAgdmFyIG9ydGh5ID0gLWJhc2VQb2ludHNbc291cmNlVXZdO1xuICAgICAgdmFyIGNvc0FscGhhID0gb3J0aHggKiBiYXNlUG9pbnRzW2Rlc3RVdl0gKyBvcnRoeSAqIGJhc2VQb2ludHNbZGVzdFV2ICsgMV07XG5cbiAgICAgIGlmIChjb3NBbHBoYSA8IDApIHtcbiAgICAgICAgb3J0aHggKj0gLTE7XG4gICAgICAgIG9ydGh5ICo9IC0xO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3ggPSBjcDB4ICsgb3J0aHggKiBjb3JuZXJSYWRpdXM7XG4gICAgICB2YXIgY3kgPSBjcDB5ICsgb3J0aHkgKiBjb3JuZXJSYWRpdXM7XG4gICAgICBpbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3RMaW5lQ2lyY2xlKHgsIHksIGNlbnRlclgsIGNlbnRlclksIGN4LCBjeSwgY29ybmVyUmFkaXVzKTtcblxuICAgICAgaWYgKGludGVyc2VjdGlvbi5sZW5ndGggIT09IDApIHtcbiAgICAgICAgaW50ZXJzZWN0aW9ucy5wdXNoKGludGVyc2VjdGlvblswXSwgaW50ZXJzZWN0aW9uWzFdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBsaW5lcy5sZW5ndGggLyA0OyBfaTMrKykge1xuICAgICAgaW50ZXJzZWN0aW9uID0gZmluaXRlTGluZXNJbnRlcnNlY3QoeCwgeSwgY2VudGVyWCwgY2VudGVyWSwgbGluZXNbX2kzICogNF0sIGxpbmVzW19pMyAqIDQgKyAxXSwgbGluZXNbX2kzICogNCArIDJdLCBsaW5lc1tfaTMgKiA0ICsgM10sIGZhbHNlKTtcblxuICAgICAgaWYgKGludGVyc2VjdGlvbi5sZW5ndGggIT09IDApIHtcbiAgICAgICAgaW50ZXJzZWN0aW9ucy5wdXNoKGludGVyc2VjdGlvblswXSwgaW50ZXJzZWN0aW9uWzFdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaW50ZXJzZWN0aW9ucy5sZW5ndGggPiAyKSB7XG4gICAgICB2YXIgbG93ZXN0SW50ZXJzZWN0aW9uID0gW2ludGVyc2VjdGlvbnNbMF0sIGludGVyc2VjdGlvbnNbMV1dO1xuICAgICAgdmFyIGxvd2VzdFNxdWFyZWREaXN0YW5jZSA9IE1hdGgucG93KGxvd2VzdEludGVyc2VjdGlvblswXSAtIHgsIDIpICsgTWF0aC5wb3cobG93ZXN0SW50ZXJzZWN0aW9uWzFdIC0geSwgMik7XG5cbiAgICAgIGZvciAodmFyIF9pNCA9IDE7IF9pNCA8IGludGVyc2VjdGlvbnMubGVuZ3RoIC8gMjsgX2k0KyspIHtcbiAgICAgICAgdmFyIHNxdWFyZWREaXN0YW5jZSA9IE1hdGgucG93KGludGVyc2VjdGlvbnNbX2k0ICogMl0gLSB4LCAyKSArIE1hdGgucG93KGludGVyc2VjdGlvbnNbX2k0ICogMiArIDFdIC0geSwgMik7XG5cbiAgICAgICAgaWYgKHNxdWFyZWREaXN0YW5jZSA8PSBsb3dlc3RTcXVhcmVkRGlzdGFuY2UpIHtcbiAgICAgICAgICBsb3dlc3RJbnRlcnNlY3Rpb25bMF0gPSBpbnRlcnNlY3Rpb25zW19pNCAqIDJdO1xuICAgICAgICAgIGxvd2VzdEludGVyc2VjdGlvblsxXSA9IGludGVyc2VjdGlvbnNbX2k0ICogMiArIDFdO1xuICAgICAgICAgIGxvd2VzdFNxdWFyZWREaXN0YW5jZSA9IHNxdWFyZWREaXN0YW5jZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbG93ZXN0SW50ZXJzZWN0aW9uO1xuICAgIH1cblxuICAgIHJldHVybiBpbnRlcnNlY3Rpb25zO1xuICB9O1xuICB2YXIgc2hvcnRlbkludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIHNob3J0ZW5JbnRlcnNlY3Rpb24oaW50ZXJzZWN0aW9uLCBvZmZzZXQsIGFtb3VudCkge1xuICAgIHZhciBkaXNwID0gW2ludGVyc2VjdGlvblswXSAtIG9mZnNldFswXSwgaW50ZXJzZWN0aW9uWzFdIC0gb2Zmc2V0WzFdXTtcbiAgICB2YXIgbGVuZ3RoID0gTWF0aC5zcXJ0KGRpc3BbMF0gKiBkaXNwWzBdICsgZGlzcFsxXSAqIGRpc3BbMV0pO1xuICAgIHZhciBsZW5SYXRpbyA9IChsZW5ndGggLSBhbW91bnQpIC8gbGVuZ3RoO1xuXG4gICAgaWYgKGxlblJhdGlvIDwgMCkge1xuICAgICAgbGVuUmF0aW8gPSAwLjAwMDAxO1xuICAgIH1cblxuICAgIHJldHVybiBbb2Zmc2V0WzBdICsgbGVuUmF0aW8gKiBkaXNwWzBdLCBvZmZzZXRbMV0gKyBsZW5SYXRpbyAqIGRpc3BbMV1dO1xuICB9O1xuICB2YXIgZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlID0gZnVuY3Rpb24gZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKHNpZGVzLCByb3RhdGlvblJhZGlhbnMpIHtcbiAgICB2YXIgcG9pbnRzID0gZ2VuZXJhdGVVbml0TmdvblBvaW50cyhzaWRlcywgcm90YXRpb25SYWRpYW5zKTtcbiAgICBwb2ludHMgPSBmaXRQb2x5Z29uVG9TcXVhcmUocG9pbnRzKTtcbiAgICByZXR1cm4gcG9pbnRzO1xuICB9O1xuICB2YXIgZml0UG9seWdvblRvU3F1YXJlID0gZnVuY3Rpb24gZml0UG9seWdvblRvU3F1YXJlKHBvaW50cykge1xuICAgIHZhciB4LCB5O1xuICAgIHZhciBzaWRlcyA9IHBvaW50cy5sZW5ndGggLyAyO1xuICAgIHZhciBtaW5YID0gSW5maW5pdHksXG4gICAgICAgIG1pblkgPSBJbmZpbml0eSxcbiAgICAgICAgbWF4WCA9IC1JbmZpbml0eSxcbiAgICAgICAgbWF4WSA9IC1JbmZpbml0eTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lkZXM7IGkrKykge1xuICAgICAgeCA9IHBvaW50c1syICogaV07XG4gICAgICB5ID0gcG9pbnRzWzIgKiBpICsgMV07XG4gICAgICBtaW5YID0gTWF0aC5taW4obWluWCwgeCk7XG4gICAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgeCk7XG4gICAgICBtaW5ZID0gTWF0aC5taW4obWluWSwgeSk7XG4gICAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgeSk7XG4gICAgfSAvLyBzdHJldGNoIGZhY3RvcnNcblxuXG4gICAgdmFyIHN4ID0gMiAvIChtYXhYIC0gbWluWCk7XG4gICAgdmFyIHN5ID0gMiAvIChtYXhZIC0gbWluWSk7XG5cbiAgICBmb3IgKHZhciBfaTUgPSAwOyBfaTUgPCBzaWRlczsgX2k1KyspIHtcbiAgICAgIHggPSBwb2ludHNbMiAqIF9pNV0gPSBwb2ludHNbMiAqIF9pNV0gKiBzeDtcbiAgICAgIHkgPSBwb2ludHNbMiAqIF9pNSArIDFdID0gcG9pbnRzWzIgKiBfaTUgKyAxXSAqIHN5O1xuICAgICAgbWluWCA9IE1hdGgubWluKG1pblgsIHgpO1xuICAgICAgbWF4WCA9IE1hdGgubWF4KG1heFgsIHgpO1xuICAgICAgbWluWSA9IE1hdGgubWluKG1pblksIHkpO1xuICAgICAgbWF4WSA9IE1hdGgubWF4KG1heFksIHkpO1xuICAgIH1cblxuICAgIGlmIChtaW5ZIDwgLTEpIHtcbiAgICAgIGZvciAodmFyIF9pNiA9IDA7IF9pNiA8IHNpZGVzOyBfaTYrKykge1xuICAgICAgICB5ID0gcG9pbnRzWzIgKiBfaTYgKyAxXSA9IHBvaW50c1syICogX2k2ICsgMV0gKyAoLTEgLSBtaW5ZKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcG9pbnRzO1xuICB9O1xuICB2YXIgZ2VuZXJhdGVVbml0TmdvblBvaW50cyA9IGZ1bmN0aW9uIGdlbmVyYXRlVW5pdE5nb25Qb2ludHMoc2lkZXMsIHJvdGF0aW9uUmFkaWFucykge1xuICAgIHZhciBpbmNyZW1lbnQgPSAxLjAgLyBzaWRlcyAqIDIgKiBNYXRoLlBJO1xuICAgIHZhciBzdGFydEFuZ2xlID0gc2lkZXMgJSAyID09PSAwID8gTWF0aC5QSSAvIDIuMCArIGluY3JlbWVudCAvIDIuMCA6IE1hdGguUEkgLyAyLjA7XG4gICAgc3RhcnRBbmdsZSArPSByb3RhdGlvblJhZGlhbnM7XG4gICAgdmFyIHBvaW50cyA9IG5ldyBBcnJheShzaWRlcyAqIDIpO1xuICAgIHZhciBjdXJyZW50QW5nbGU7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZGVzOyBpKyspIHtcbiAgICAgIGN1cnJlbnRBbmdsZSA9IGkgKiBpbmNyZW1lbnQgKyBzdGFydEFuZ2xlO1xuICAgICAgcG9pbnRzWzIgKiBpXSA9IE1hdGguY29zKGN1cnJlbnRBbmdsZSk7IC8vIHhcblxuICAgICAgcG9pbnRzWzIgKiBpICsgMV0gPSBNYXRoLnNpbigtY3VycmVudEFuZ2xlKTsgLy8geVxuICAgIH1cblxuICAgIHJldHVybiBwb2ludHM7XG4gIH07IC8vIFNldCB0aGUgZGVmYXVsdCByYWRpdXMsIHVubGVzcyBoYWxmIG9mIHdpZHRoIG9yIGhlaWdodCBpcyBzbWFsbGVyIHRoYW4gZGVmYXVsdFxuXG4gIHZhciBnZXRSb3VuZFJlY3RhbmdsZVJhZGl1cyA9IGZ1bmN0aW9uIGdldFJvdW5kUmVjdGFuZ2xlUmFkaXVzKHdpZHRoLCBoZWlnaHQpIHtcbiAgICByZXR1cm4gTWF0aC5taW4od2lkdGggLyA0LCBoZWlnaHQgLyA0LCA4KTtcbiAgfTsgLy8gU2V0IHRoZSBkZWZhdWx0IHJhZGl1c1xuXG4gIHZhciBnZXRSb3VuZFBvbHlnb25SYWRpdXMgPSBmdW5jdGlvbiBnZXRSb3VuZFBvbHlnb25SYWRpdXMod2lkdGgsIGhlaWdodCkge1xuICAgIHJldHVybiBNYXRoLm1pbih3aWR0aCAvIDEwLCBoZWlnaHQgLyAxMCwgOCk7XG4gIH07XG4gIHZhciBnZXRDdXRSZWN0YW5nbGVDb3JuZXJMZW5ndGggPSBmdW5jdGlvbiBnZXRDdXRSZWN0YW5nbGVDb3JuZXJMZW5ndGgoKSB7XG4gICAgcmV0dXJuIDg7XG4gIH07XG4gIHZhciBiZXppZXJQdHNUb1F1YWRDb2VmZiA9IGZ1bmN0aW9uIGJlemllclB0c1RvUXVhZENvZWZmKHAwLCBwMSwgcDIpIHtcbiAgICByZXR1cm4gW3AwIC0gMiAqIHAxICsgcDIsIDIgKiAocDEgLSBwMCksIHAwXTtcbiAgfTsgLy8gZ2V0IGN1cnZlIHdpZHRoLCBoZWlnaHQsIGFuZCBjb250cm9sIHBvaW50IHBvc2l0aW9uIG9mZnNldHMgYXMgYSBwZXJjZW50YWdlIG9mIG5vZGUgaGVpZ2h0IC8gd2lkdGhcblxuICB2YXIgZ2V0QmFycmVsQ3VydmVDb25zdGFudHMgPSBmdW5jdGlvbiBnZXRCYXJyZWxDdXJ2ZUNvbnN0YW50cyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhlaWdodE9mZnNldDogTWF0aC5taW4oMTUsIDAuMDUgKiBoZWlnaHQpLFxuICAgICAgd2lkdGhPZmZzZXQ6IE1hdGgubWluKDEwMCwgMC4yNSAqIHdpZHRoKSxcbiAgICAgIGN0cmxQdE9mZnNldFBjdDogMC4wNVxuICAgIH07XG4gIH07XG5cbiAgdmFyIHBhZ2VSYW5rRGVmYXVsdHMgPSBkZWZhdWx0cyRnKHtcbiAgICBkYW1waW5nRmFjdG9yOiAwLjgsXG4gICAgcHJlY2lzaW9uOiAwLjAwMDAwMSxcbiAgICBpdGVyYXRpb25zOiAyMDAsXG4gICAgd2VpZ2h0OiBmdW5jdGlvbiB3ZWlnaHQoZWRnZSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9KTtcbiAgdmFyIGVsZXNmbiRvID0ge1xuICAgIHBhZ2VSYW5rOiBmdW5jdGlvbiBwYWdlUmFuayhvcHRpb25zKSB7XG4gICAgICB2YXIgX3BhZ2VSYW5rRGVmYXVsdHMgPSBwYWdlUmFua0RlZmF1bHRzKG9wdGlvbnMpLFxuICAgICAgICAgIGRhbXBpbmdGYWN0b3IgPSBfcGFnZVJhbmtEZWZhdWx0cy5kYW1waW5nRmFjdG9yLFxuICAgICAgICAgIHByZWNpc2lvbiA9IF9wYWdlUmFua0RlZmF1bHRzLnByZWNpc2lvbixcbiAgICAgICAgICBpdGVyYXRpb25zID0gX3BhZ2VSYW5rRGVmYXVsdHMuaXRlcmF0aW9ucyxcbiAgICAgICAgICB3ZWlnaHQgPSBfcGFnZVJhbmtEZWZhdWx0cy53ZWlnaHQ7XG5cbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG5cbiAgICAgIHZhciBfdGhpcyRieUdyb3VwID0gdGhpcy5ieUdyb3VwKCksXG4gICAgICAgICAgbm9kZXMgPSBfdGhpcyRieUdyb3VwLm5vZGVzLFxuICAgICAgICAgIGVkZ2VzID0gX3RoaXMkYnlHcm91cC5lZGdlcztcblxuICAgICAgdmFyIG51bU5vZGVzID0gbm9kZXMubGVuZ3RoO1xuICAgICAgdmFyIG51bU5vZGVzU3FkID0gbnVtTm9kZXMgKiBudW1Ob2RlcztcbiAgICAgIHZhciBudW1FZGdlcyA9IGVkZ2VzLmxlbmd0aDsgLy8gQ29uc3RydWN0IHRyYW5zcG9zZWQgYWRqYWNlbmN5IG1hdHJpeFxuICAgICAgLy8gRmlyc3QgbGV0cyBoYXZlIGEgemVyb2VkIG1hdHJpeCBvZiB0aGUgcmlnaHQgc2l6ZVxuICAgICAgLy8gV2UnbGwgYWxzbyBrZWVwIHRyYWNrIG9mIHRoZSBzdW0gb2YgZWFjaCBjb2x1bW5cblxuICAgICAgdmFyIG1hdHJpeCA9IG5ldyBBcnJheShudW1Ob2Rlc1NxZCk7XG4gICAgICB2YXIgY29sdW1uU3VtID0gbmV3IEFycmF5KG51bU5vZGVzKTtcbiAgICAgIHZhciBhZGRpdGlvbmFsUHJvYiA9ICgxIC0gZGFtcGluZ0ZhY3RvcikgLyBudW1Ob2RlczsgLy8gQ3JlYXRlIG51bGwgbWF0cml4XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG51bU5vZGVzOyBqKyspIHtcbiAgICAgICAgICB2YXIgbiA9IGkgKiBudW1Ob2RlcyArIGo7XG4gICAgICAgICAgbWF0cml4W25dID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbHVtblN1bVtpXSA9IDA7XG4gICAgICB9IC8vIE5vdywgcHJvY2VzcyBlZGdlc1xuXG5cbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBudW1FZGdlczsgX2krKykge1xuICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW19pXTtcbiAgICAgICAgdmFyIHNyY0lkID0gZWRnZS5kYXRhKCdzb3VyY2UnKTtcbiAgICAgICAgdmFyIHRndElkID0gZWRnZS5kYXRhKCd0YXJnZXQnKTsgLy8gRG9uJ3QgaW5jbHVkZSBsb29wcyBpbiB0aGUgbWF0cml4XG5cbiAgICAgICAgaWYgKHNyY0lkID09PSB0Z3RJZCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHMgPSBub2Rlcy5pbmRleE9mSWQoc3JjSWQpO1xuICAgICAgICB2YXIgdCA9IG5vZGVzLmluZGV4T2ZJZCh0Z3RJZCk7XG4gICAgICAgIHZhciB3ID0gd2VpZ2h0KGVkZ2UpO1xuXG4gICAgICAgIHZhciBfbiA9IHQgKiBudW1Ob2RlcyArIHM7IC8vIFVwZGF0ZSBtYXRyaXhcblxuXG4gICAgICAgIG1hdHJpeFtfbl0gKz0gdzsgLy8gVXBkYXRlIGNvbHVtbiBzdW1cblxuICAgICAgICBjb2x1bW5TdW1bc10gKz0gdztcbiAgICAgIH0gLy8gQWRkIGFkZGl0aW9uYWwgcHJvYmFiaWxpdHkgYmFzZWQgb24gZGFtcGluZyBmYWN0b3JcbiAgICAgIC8vIEFsc28sIHRha2UgaW50byBhY2NvdW50IGNvbHVtbnMgdGhhdCBoYXZlIHN1bSA9IDBcblxuXG4gICAgICB2YXIgcCA9IDEuMCAvIG51bU5vZGVzICsgYWRkaXRpb25hbFByb2I7IC8vIFNob3J0aGFuZFxuICAgICAgLy8gVHJhdmVyc2UgbWF0cml4LCBjb2x1bW4gYnkgY29sdW1uXG5cbiAgICAgIGZvciAodmFyIF9qID0gMDsgX2ogPCBudW1Ob2RlczsgX2orKykge1xuICAgICAgICBpZiAoY29sdW1uU3VtW19qXSA9PT0gMCkge1xuICAgICAgICAgIC8vIE5vICdsaW5rcycgb3V0IGZyb20gbm9kZSBqdGgsIGFzc3VtZSBlcXVhbCBwcm9iYWJpbGl0eSBmb3IgZWFjaCBwb3NzaWJsZSBub2RlXG4gICAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbnVtTm9kZXM7IF9pMisrKSB7XG4gICAgICAgICAgICB2YXIgX24yID0gX2kyICogbnVtTm9kZXMgKyBfajtcblxuICAgICAgICAgICAgbWF0cml4W19uMl0gPSBwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBOb2RlIGp0aCBoYXMgb3V0Z29pbmcgbGluaywgY29tcHV0ZSBub3JtYWxpemVkIHByb2JhYmlsaXRpZXNcbiAgICAgICAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBudW1Ob2RlczsgX2kzKyspIHtcbiAgICAgICAgICAgIHZhciBfbjMgPSBfaTMgKiBudW1Ob2RlcyArIF9qO1xuXG4gICAgICAgICAgICBtYXRyaXhbX24zXSA9IG1hdHJpeFtfbjNdIC8gY29sdW1uU3VtW19qXSArIGFkZGl0aW9uYWxQcm9iO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBDb21wdXRlIGRvbWluYW50IGVpZ2VudmVjdG9yIHVzaW5nIHBvd2VyIG1ldGhvZFxuXG5cbiAgICAgIHZhciBlaWdlbnZlY3RvciA9IG5ldyBBcnJheShudW1Ob2Rlcyk7XG4gICAgICB2YXIgdGVtcCA9IG5ldyBBcnJheShudW1Ob2Rlcyk7XG4gICAgICB2YXIgcHJldmlvdXM7IC8vIFN0YXJ0IHdpdGggYSB2ZWN0b3Igb2YgYWxsIDEnc1xuICAgICAgLy8gQWxzbywgaW5pdGlhbGl6ZSBhIG51bGwgdmVjdG9yIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBzaG9ydGhhbmRcblxuICAgICAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgbnVtTm9kZXM7IF9pNCsrKSB7XG4gICAgICAgIGVpZ2VudmVjdG9yW19pNF0gPSAxO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpdGVyID0gMDsgaXRlciA8IGl0ZXJhdGlvbnM7IGl0ZXIrKykge1xuICAgICAgICAvLyBUZW1wIGFycmF5IHdpdGggYWxsIDAnc1xuICAgICAgICBmb3IgKHZhciBfaTUgPSAwOyBfaTUgPCBudW1Ob2RlczsgX2k1KyspIHtcbiAgICAgICAgICB0ZW1wW19pNV0gPSAwO1xuICAgICAgICB9IC8vIE11bHRpcGx5IG1hdHJpeCB3aXRoIHByZXZpb3VzIHJlc3VsdFxuXG5cbiAgICAgICAgZm9yICh2YXIgX2k2ID0gMDsgX2k2IDwgbnVtTm9kZXM7IF9pNisrKSB7XG4gICAgICAgICAgZm9yICh2YXIgX2oyID0gMDsgX2oyIDwgbnVtTm9kZXM7IF9qMisrKSB7XG4gICAgICAgICAgICB2YXIgX240ID0gX2k2ICogbnVtTm9kZXMgKyBfajI7XG5cbiAgICAgICAgICAgIHRlbXBbX2k2XSArPSBtYXRyaXhbX240XSAqIGVpZ2VudmVjdG9yW19qMl07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaW5QbGFjZVN1bU5vcm1hbGl6ZSh0ZW1wKTtcbiAgICAgICAgcHJldmlvdXMgPSBlaWdlbnZlY3RvcjtcbiAgICAgICAgZWlnZW52ZWN0b3IgPSB0ZW1wO1xuICAgICAgICB0ZW1wID0gcHJldmlvdXM7XG4gICAgICAgIHZhciBkaWZmID0gMDsgLy8gQ29tcHV0ZSBkaWZmZXJlbmNlIChzcXVhcmVkIG1vZHVsZSkgb2YgYm90aCB2ZWN0b3JzXG5cbiAgICAgICAgZm9yICh2YXIgX2k3ID0gMDsgX2k3IDwgbnVtTm9kZXM7IF9pNysrKSB7XG4gICAgICAgICAgdmFyIGRlbHRhID0gcHJldmlvdXNbX2k3XSAtIGVpZ2VudmVjdG9yW19pN107XG4gICAgICAgICAgZGlmZiArPSBkZWx0YSAqIGRlbHRhO1xuICAgICAgICB9IC8vIElmIGRpZmZlcmVuY2UgaXMgbGVzcyB0aGFuIHRoZSBkZXNpcmVkIHRocmVzaG9sZCwgc3RvcCBpdGVyYXRpbmdcblxuXG4gICAgICAgIGlmIChkaWZmIDwgcHJlY2lzaW9uKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gQ29uc3RydWN0IHJlc3VsdFxuXG5cbiAgICAgIHZhciByZXMgPSB7XG4gICAgICAgIHJhbms6IGZ1bmN0aW9uIHJhbmsobm9kZSkge1xuICAgICAgICAgIG5vZGUgPSBjeS5jb2xsZWN0aW9uKG5vZGUpWzBdO1xuICAgICAgICAgIHJldHVybiBlaWdlbnZlY3Rvcltub2Rlcy5pbmRleE9mKG5vZGUpXTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfSAvLyBwYWdlUmFua1xuXG4gIH07IC8vIGVsZXNmblxuXG4gIHZhciBkZWZhdWx0cyRmID0gZGVmYXVsdHMkZyh7XG4gICAgcm9vdDogbnVsbCxcbiAgICB3ZWlnaHQ6IGZ1bmN0aW9uIHdlaWdodChlZGdlKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9LFxuICAgIGRpcmVjdGVkOiBmYWxzZSxcbiAgICBhbHBoYTogMFxuICB9KTtcbiAgdmFyIGVsZXNmbiRuID0ge1xuICAgIGRlZ3JlZUNlbnRyYWxpdHlOb3JtYWxpemVkOiBmdW5jdGlvbiBkZWdyZWVDZW50cmFsaXR5Tm9ybWFsaXplZChvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gZGVmYXVsdHMkZihvcHRpb25zKTtcbiAgICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgICAgIHZhciBudW1Ob2RlcyA9IG5vZGVzLmxlbmd0aDtcblxuICAgICAgaWYgKCFvcHRpb25zLmRpcmVjdGVkKSB7XG4gICAgICAgIHZhciBkZWdyZWVzID0ge307XG4gICAgICAgIHZhciBtYXhEZWdyZWUgPSAwO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07IC8vIGFkZCBjdXJyZW50IG5vZGUgdG8gdGhlIGN1cnJlbnQgb3B0aW9ucyBvYmplY3QgYW5kIGNhbGwgZGVncmVlQ2VudHJhbGl0eVxuXG4gICAgICAgICAgb3B0aW9ucy5yb290ID0gbm9kZTtcbiAgICAgICAgICB2YXIgY3VyckRlZ3JlZSA9IHRoaXMuZGVncmVlQ2VudHJhbGl0eShvcHRpb25zKTtcblxuICAgICAgICAgIGlmIChtYXhEZWdyZWUgPCBjdXJyRGVncmVlLmRlZ3JlZSkge1xuICAgICAgICAgICAgbWF4RGVncmVlID0gY3VyckRlZ3JlZS5kZWdyZWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGVncmVlc1tub2RlLmlkKCldID0gY3VyckRlZ3JlZS5kZWdyZWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRlZ3JlZTogZnVuY3Rpb24gZGVncmVlKG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChtYXhEZWdyZWUgPT09IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzdHJpbmcobm9kZSkpIHtcbiAgICAgICAgICAgICAgLy8gZnJvbSBpcyBhIHNlbGVjdG9yIHN0cmluZ1xuICAgICAgICAgICAgICBub2RlID0gY3kuZmlsdGVyKG5vZGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZGVncmVlc1tub2RlLmlkKCldIC8gbWF4RGVncmVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpbmRlZ3JlZXMgPSB7fTtcbiAgICAgICAgdmFyIG91dGRlZ3JlZXMgPSB7fTtcbiAgICAgICAgdmFyIG1heEluZGVncmVlID0gMDtcbiAgICAgICAgdmFyIG1heE91dGRlZ3JlZSA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG51bU5vZGVzOyBfaSsrKSB7XG4gICAgICAgICAgdmFyIF9ub2RlID0gbm9kZXNbX2ldO1xuXG4gICAgICAgICAgdmFyIGlkID0gX25vZGUuaWQoKTsgLy8gYWRkIGN1cnJlbnQgbm9kZSB0byB0aGUgY3VycmVudCBvcHRpb25zIG9iamVjdCBhbmQgY2FsbCBkZWdyZWVDZW50cmFsaXR5XG5cblxuICAgICAgICAgIG9wdGlvbnMucm9vdCA9IF9ub2RlO1xuXG4gICAgICAgICAgdmFyIF9jdXJyRGVncmVlID0gdGhpcy5kZWdyZWVDZW50cmFsaXR5KG9wdGlvbnMpO1xuXG4gICAgICAgICAgaWYgKG1heEluZGVncmVlIDwgX2N1cnJEZWdyZWUuaW5kZWdyZWUpIG1heEluZGVncmVlID0gX2N1cnJEZWdyZWUuaW5kZWdyZWU7XG4gICAgICAgICAgaWYgKG1heE91dGRlZ3JlZSA8IF9jdXJyRGVncmVlLm91dGRlZ3JlZSkgbWF4T3V0ZGVncmVlID0gX2N1cnJEZWdyZWUub3V0ZGVncmVlO1xuICAgICAgICAgIGluZGVncmVlc1tpZF0gPSBfY3VyckRlZ3JlZS5pbmRlZ3JlZTtcbiAgICAgICAgICBvdXRkZWdyZWVzW2lkXSA9IF9jdXJyRGVncmVlLm91dGRlZ3JlZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaW5kZWdyZWU6IGZ1bmN0aW9uIGluZGVncmVlKG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChtYXhJbmRlZ3JlZSA9PSAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc3RyaW5nKG5vZGUpKSB7XG4gICAgICAgICAgICAgIC8vIGZyb20gaXMgYSBzZWxlY3RvciBzdHJpbmdcbiAgICAgICAgICAgICAgbm9kZSA9IGN5LmZpbHRlcihub2RlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGluZGVncmVlc1tub2RlLmlkKCldIC8gbWF4SW5kZWdyZWU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvdXRkZWdyZWU6IGZ1bmN0aW9uIG91dGRlZ3JlZShub2RlKSB7XG4gICAgICAgICAgICBpZiAobWF4T3V0ZGVncmVlID09PSAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc3RyaW5nKG5vZGUpKSB7XG4gICAgICAgICAgICAgIC8vIGZyb20gaXMgYSBzZWxlY3RvciBzdHJpbmdcbiAgICAgICAgICAgICAgbm9kZSA9IGN5LmZpbHRlcihub2RlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG91dGRlZ3JlZXNbbm9kZS5pZCgpXSAvIG1heE91dGRlZ3JlZTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBkZWdyZWVDZW50cmFsaXR5Tm9ybWFsaXplZFxuICAgIC8vIEltcGxlbWVudGVkIGZyb20gdGhlIGFsZ29yaXRobSBpbiBPcHNhaGwncyBwYXBlclxuICAgIC8vIFwiTm9kZSBjZW50cmFsaXR5IGluIHdlaWdodGVkIG5ldHdvcmtzOiBHZW5lcmFsaXppbmcgZGVncmVlIGFuZCBzaG9ydGVzdCBwYXRoc1wiXG4gICAgLy8gY2hlY2sgdGhlIGhlYWRpbmcgMiBcIkRlZ3JlZVwiXG4gICAgZGVncmVlQ2VudHJhbGl0eTogZnVuY3Rpb24gZGVncmVlQ2VudHJhbGl0eShvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gZGVmYXVsdHMkZihvcHRpb25zKTtcbiAgICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICAgIHZhciBjYWxsaW5nRWxlcyA9IHRoaXM7XG4gICAgICB2YXIgX29wdGlvbnMgPSBvcHRpb25zLFxuICAgICAgICAgIHJvb3QgPSBfb3B0aW9ucy5yb290LFxuICAgICAgICAgIHdlaWdodCA9IF9vcHRpb25zLndlaWdodCxcbiAgICAgICAgICBkaXJlY3RlZCA9IF9vcHRpb25zLmRpcmVjdGVkLFxuICAgICAgICAgIGFscGhhID0gX29wdGlvbnMuYWxwaGE7XG4gICAgICByb290ID0gY3kuY29sbGVjdGlvbihyb290KVswXTtcblxuICAgICAgaWYgKCFkaXJlY3RlZCkge1xuICAgICAgICB2YXIgY29ubkVkZ2VzID0gcm9vdC5jb25uZWN0ZWRFZGdlcygpLmludGVyc2VjdGlvbihjYWxsaW5nRWxlcyk7XG4gICAgICAgIHZhciBrID0gY29ubkVkZ2VzLmxlbmd0aDtcbiAgICAgICAgdmFyIHMgPSAwOyAvLyBOb3csIHN1bSBlZGdlIHdlaWdodHNcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbm5FZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHMgKz0gd2VpZ2h0KGNvbm5FZGdlc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRlZ3JlZTogTWF0aC5wb3coaywgMSAtIGFscGhhKSAqIE1hdGgucG93KHMsIGFscGhhKVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGVkZ2VzID0gcm9vdC5jb25uZWN0ZWRFZGdlcygpO1xuICAgICAgICB2YXIgaW5jb21pbmcgPSBlZGdlcy5maWx0ZXIoZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgICAgICByZXR1cm4gZWRnZS50YXJnZXQoKS5zYW1lKHJvb3QpICYmIGNhbGxpbmdFbGVzLmhhcyhlZGdlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBvdXRnb2luZyA9IGVkZ2VzLmZpbHRlcihmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICAgIHJldHVybiBlZGdlLnNvdXJjZSgpLnNhbWUocm9vdCkgJiYgY2FsbGluZ0VsZXMuaGFzKGVkZ2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGtfaW4gPSBpbmNvbWluZy5sZW5ndGg7XG4gICAgICAgIHZhciBrX291dCA9IG91dGdvaW5nLmxlbmd0aDtcbiAgICAgICAgdmFyIHNfaW4gPSAwO1xuICAgICAgICB2YXIgc19vdXQgPSAwOyAvLyBOb3csIHN1bSBpbmNvbWluZyBlZGdlIHdlaWdodHNcblxuICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBpbmNvbWluZy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgICAgc19pbiArPSB3ZWlnaHQoaW5jb21pbmdbX2kyXSk7XG4gICAgICAgIH0gLy8gTm93LCBzdW0gb3V0Z29pbmcgZWRnZSB3ZWlnaHRzXG5cblxuICAgICAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBvdXRnb2luZy5sZW5ndGg7IF9pMysrKSB7XG4gICAgICAgICAgc19vdXQgKz0gd2VpZ2h0KG91dGdvaW5nW19pM10pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpbmRlZ3JlZTogTWF0aC5wb3coa19pbiwgMSAtIGFscGhhKSAqIE1hdGgucG93KHNfaW4sIGFscGhhKSxcbiAgICAgICAgICBvdXRkZWdyZWU6IE1hdGgucG93KGtfb3V0LCAxIC0gYWxwaGEpICogTWF0aC5wb3coc19vdXQsIGFscGhhKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gLy8gZGVncmVlQ2VudHJhbGl0eVxuXG4gIH07IC8vIGVsZXNmblxuICAvLyBuaWNlLCBzaG9ydCBtYXRoZW1hdGljYWwgYWxpYXNcblxuICBlbGVzZm4kbi5kYyA9IGVsZXNmbiRuLmRlZ3JlZUNlbnRyYWxpdHk7XG4gIGVsZXNmbiRuLmRjbiA9IGVsZXNmbiRuLmRlZ3JlZUNlbnRyYWxpdHlOb3JtYWxpc2VkID0gZWxlc2ZuJG4uZGVncmVlQ2VudHJhbGl0eU5vcm1hbGl6ZWQ7XG5cbiAgdmFyIGRlZmF1bHRzJGUgPSBkZWZhdWx0cyRnKHtcbiAgICBoYXJtb25pYzogdHJ1ZSxcbiAgICB3ZWlnaHQ6IGZ1bmN0aW9uIHdlaWdodCgpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0sXG4gICAgZGlyZWN0ZWQ6IGZhbHNlLFxuICAgIHJvb3Q6IG51bGxcbiAgfSk7XG4gIHZhciBlbGVzZm4kbSA9IHtcbiAgICBjbG9zZW5lc3NDZW50cmFsaXR5Tm9ybWFsaXplZDogZnVuY3Rpb24gY2xvc2VuZXNzQ2VudHJhbGl0eU5vcm1hbGl6ZWQob3B0aW9ucykge1xuICAgICAgdmFyIF9kZWZhdWx0cyA9IGRlZmF1bHRzJGUob3B0aW9ucyksXG4gICAgICAgICAgaGFybW9uaWMgPSBfZGVmYXVsdHMuaGFybW9uaWMsXG4gICAgICAgICAgd2VpZ2h0ID0gX2RlZmF1bHRzLndlaWdodCxcbiAgICAgICAgICBkaXJlY3RlZCA9IF9kZWZhdWx0cy5kaXJlY3RlZDtcblxuICAgICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgICAgdmFyIGNsb3NlbmVzc2VzID0ge307XG4gICAgICB2YXIgbWF4Q2xvc2VuZXNzID0gMDtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgICAgIHZhciBmdyA9IHRoaXMuZmxveWRXYXJzaGFsbCh7XG4gICAgICAgIHdlaWdodDogd2VpZ2h0LFxuICAgICAgICBkaXJlY3RlZDogZGlyZWN0ZWRcbiAgICAgIH0pOyAvLyBDb21wdXRlIGNsb3NlbmVzcyBmb3IgZXZlcnkgbm9kZSBhbmQgZmluZCB0aGUgbWF4aW11bSBjbG9zZW5lc3NcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY3VyckNsb3NlbmVzcyA9IDA7XG4gICAgICAgIHZhciBub2RlX2kgPSBub2Rlc1tpXTtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5vZGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgaWYgKGkgIT09IGopIHtcbiAgICAgICAgICAgIHZhciBkID0gZncuZGlzdGFuY2Uobm9kZV9pLCBub2Rlc1tqXSk7XG5cbiAgICAgICAgICAgIGlmIChoYXJtb25pYykge1xuICAgICAgICAgICAgICBjdXJyQ2xvc2VuZXNzICs9IDEgLyBkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY3VyckNsb3NlbmVzcyArPSBkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaGFybW9uaWMpIHtcbiAgICAgICAgICBjdXJyQ2xvc2VuZXNzID0gMSAvIGN1cnJDbG9zZW5lc3M7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF4Q2xvc2VuZXNzIDwgY3VyckNsb3NlbmVzcykge1xuICAgICAgICAgIG1heENsb3NlbmVzcyA9IGN1cnJDbG9zZW5lc3M7XG4gICAgICAgIH1cblxuICAgICAgICBjbG9zZW5lc3Nlc1tub2RlX2kuaWQoKV0gPSBjdXJyQ2xvc2VuZXNzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBjbG9zZW5lc3M6IGZ1bmN0aW9uIGNsb3NlbmVzcyhub2RlKSB7XG4gICAgICAgICAgaWYgKG1heENsb3NlbmVzcyA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc3RyaW5nKG5vZGUpKSB7XG4gICAgICAgICAgICAvLyBmcm9tIGlzIGEgc2VsZWN0b3Igc3RyaW5nXG4gICAgICAgICAgICBub2RlID0gY3kuZmlsdGVyKG5vZGUpWzBdLmlkKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGZyb20gaXMgYSBub2RlXG4gICAgICAgICAgICBub2RlID0gbm9kZS5pZCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjbG9zZW5lc3Nlc1tub2RlXSAvIG1heENsb3NlbmVzcztcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIC8vIEltcGxlbWVudGVkIGZyb20gcHNldWRvY29kZSBmcm9tIHdpa2lwZWRpYVxuICAgIGNsb3NlbmVzc0NlbnRyYWxpdHk6IGZ1bmN0aW9uIGNsb3NlbmVzc0NlbnRyYWxpdHkob3B0aW9ucykge1xuICAgICAgdmFyIF9kZWZhdWx0czIgPSBkZWZhdWx0cyRlKG9wdGlvbnMpLFxuICAgICAgICAgIHJvb3QgPSBfZGVmYXVsdHMyLnJvb3QsXG4gICAgICAgICAgd2VpZ2h0ID0gX2RlZmF1bHRzMi53ZWlnaHQsXG4gICAgICAgICAgZGlyZWN0ZWQgPSBfZGVmYXVsdHMyLmRpcmVjdGVkLFxuICAgICAgICAgIGhhcm1vbmljID0gX2RlZmF1bHRzMi5oYXJtb25pYztcblxuICAgICAgcm9vdCA9IHRoaXMuZmlsdGVyKHJvb3QpWzBdOyAvLyB3ZSBuZWVkIGRpc3RhbmNlIGZyb20gdGhpcyBub2RlIHRvIGV2ZXJ5IG90aGVyIG5vZGVcblxuICAgICAgdmFyIGRpamtzdHJhID0gdGhpcy5kaWprc3RyYSh7XG4gICAgICAgIHJvb3Q6IHJvb3QsXG4gICAgICAgIHdlaWdodDogd2VpZ2h0LFxuICAgICAgICBkaXJlY3RlZDogZGlyZWN0ZWRcbiAgICAgIH0pO1xuICAgICAgdmFyIHRvdGFsRGlzdGFuY2UgPSAwO1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBuID0gbm9kZXNbaV07XG5cbiAgICAgICAgaWYgKCFuLnNhbWUocm9vdCkpIHtcbiAgICAgICAgICB2YXIgZCA9IGRpamtzdHJhLmRpc3RhbmNlVG8obik7XG5cbiAgICAgICAgICBpZiAoaGFybW9uaWMpIHtcbiAgICAgICAgICAgIHRvdGFsRGlzdGFuY2UgKz0gMSAvIGQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRvdGFsRGlzdGFuY2UgKz0gZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhhcm1vbmljID8gdG90YWxEaXN0YW5jZSA6IDEgLyB0b3RhbERpc3RhbmNlO1xuICAgIH0gLy8gY2xvc2VuZXNzQ2VudHJhbGl0eVxuXG4gIH07IC8vIGVsZXNmblxuICAvLyBuaWNlLCBzaG9ydCBtYXRoZW1hdGljYWwgYWxpYXNcblxuICBlbGVzZm4kbS5jYyA9IGVsZXNmbiRtLmNsb3NlbmVzc0NlbnRyYWxpdHk7XG4gIGVsZXNmbiRtLmNjbiA9IGVsZXNmbiRtLmNsb3NlbmVzc0NlbnRyYWxpdHlOb3JtYWxpc2VkID0gZWxlc2ZuJG0uY2xvc2VuZXNzQ2VudHJhbGl0eU5vcm1hbGl6ZWQ7XG5cbiAgdmFyIGRlZmF1bHRzJGQgPSBkZWZhdWx0cyRnKHtcbiAgICB3ZWlnaHQ6IG51bGwsXG4gICAgZGlyZWN0ZWQ6IGZhbHNlXG4gIH0pO1xuICB2YXIgZWxlc2ZuJGwgPSB7XG4gICAgLy8gSW1wbGVtZW50ZWQgZnJvbSB0aGUgYWxnb3JpdGhtIGluIHRoZSBwYXBlciBcIk9uIFZhcmlhbnRzIG9mIFNob3J0ZXN0LVBhdGggQmV0d2Vlbm5lc3MgQ2VudHJhbGl0eSBhbmQgdGhlaXIgR2VuZXJpYyBDb21wdXRhdGlvblwiIGJ5IFVscmlrIEJyYW5kZXNcbiAgICBiZXR3ZWVubmVzc0NlbnRyYWxpdHk6IGZ1bmN0aW9uIGJldHdlZW5uZXNzQ2VudHJhbGl0eShvcHRpb25zKSB7XG4gICAgICB2YXIgX2RlZmF1bHRzID0gZGVmYXVsdHMkZChvcHRpb25zKSxcbiAgICAgICAgICBkaXJlY3RlZCA9IF9kZWZhdWx0cy5kaXJlY3RlZCxcbiAgICAgICAgICB3ZWlnaHQgPSBfZGVmYXVsdHMud2VpZ2h0O1xuXG4gICAgICB2YXIgd2VpZ2h0ZWQgPSB3ZWlnaHQgIT0gbnVsbDtcbiAgICAgIHZhciBjeSA9IHRoaXMuY3koKTsgLy8gc3RhcnRpbmdcblxuICAgICAgdmFyIFYgPSB0aGlzLm5vZGVzKCk7XG4gICAgICB2YXIgQSA9IHt9O1xuICAgICAgdmFyIF9DID0ge307XG4gICAgICB2YXIgbWF4ID0gMDtcbiAgICAgIHZhciBDID0ge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChrZXksIHZhbCkge1xuICAgICAgICAgIF9DW2tleV0gPSB2YWw7XG5cbiAgICAgICAgICBpZiAodmFsID4gbWF4KSB7XG4gICAgICAgICAgICBtYXggPSB2YWw7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICAgICAgICByZXR1cm4gX0Nba2V5XTtcbiAgICAgICAgfVxuICAgICAgfTsgLy8gQSBjb250YWlucyB0aGUgbmVpZ2hib3Job29kcyBvZiBldmVyeSBub2RlXG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgVi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdiA9IFZbaV07XG4gICAgICAgIHZhciB2aWQgPSB2LmlkKCk7XG5cbiAgICAgICAgaWYgKGRpcmVjdGVkKSB7XG4gICAgICAgICAgQVt2aWRdID0gdi5vdXRnb2VycygpLm5vZGVzKCk7IC8vIGdldCBvdXRnb2VycyBvZiBldmVyeSBub2RlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgQVt2aWRdID0gdi5vcGVuTmVpZ2hib3Job29kKCkubm9kZXMoKTsgLy8gZ2V0IG5laWdoYm9ycyBvZiBldmVyeSBub2RlXG4gICAgICAgIH1cblxuICAgICAgICBDLnNldCh2aWQsIDApO1xuICAgICAgfVxuXG4gICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChzKSB7XG4gICAgICAgIHZhciBzaWQgPSBWW3NdLmlkKCk7XG4gICAgICAgIHZhciBTID0gW107IC8vIHN0YWNrXG5cbiAgICAgICAgdmFyIFAgPSB7fTtcbiAgICAgICAgdmFyIGcgPSB7fTtcbiAgICAgICAgdmFyIGQgPSB7fTtcbiAgICAgICAgdmFyIFEgPSBuZXcgaGVhcChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgIHJldHVybiBkW2FdIC0gZFtiXTtcbiAgICAgICAgfSk7IC8vIHF1ZXVlXG4gICAgICAgIC8vIGluaXQgZGljdGlvbmFyaWVzXG5cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IFYubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgdmFyIF92aWQgPSBWW19pXS5pZCgpO1xuXG4gICAgICAgICAgUFtfdmlkXSA9IFtdO1xuICAgICAgICAgIGdbX3ZpZF0gPSAwO1xuICAgICAgICAgIGRbX3ZpZF0gPSBJbmZpbml0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdbc2lkXSA9IDE7IC8vIHNpZ21hXG5cbiAgICAgICAgZFtzaWRdID0gMDsgLy8gZGlzdGFuY2UgdG8gc1xuXG4gICAgICAgIFEucHVzaChzaWQpO1xuXG4gICAgICAgIHdoaWxlICghUS5lbXB0eSgpKSB7XG4gICAgICAgICAgdmFyIF92ID0gUS5wb3AoKTtcblxuICAgICAgICAgIFMucHVzaChfdik7XG5cbiAgICAgICAgICBpZiAod2VpZ2h0ZWQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgQVtfdl0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgdmFyIHcgPSBBW192XVtqXTtcbiAgICAgICAgICAgICAgdmFyIHZFbGUgPSBjeS5nZXRFbGVtZW50QnlJZChfdik7XG4gICAgICAgICAgICAgIHZhciBlZGdlID0gdm9pZCAwO1xuXG4gICAgICAgICAgICAgIGlmICh2RWxlLmVkZ2VzVG8odykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGVkZ2UgPSB2RWxlLmVkZ2VzVG8odylbMF07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZWRnZSA9IHcuZWRnZXNUbyh2RWxlKVswXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBlZGdlV2VpZ2h0ID0gd2VpZ2h0KGVkZ2UpO1xuICAgICAgICAgICAgICB3ID0gdy5pZCgpO1xuXG4gICAgICAgICAgICAgIGlmIChkW3ddID4gZFtfdl0gKyBlZGdlV2VpZ2h0KSB7XG4gICAgICAgICAgICAgICAgZFt3XSA9IGRbX3ZdICsgZWRnZVdlaWdodDtcblxuICAgICAgICAgICAgICAgIGlmIChRLm5vZGVzLmluZGV4T2YodykgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAvL2lmIHcgaXMgbm90IGluIFFcbiAgICAgICAgICAgICAgICAgIFEucHVzaCh3KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIHBvc2l0aW9uIGlmIHcgaXMgaW4gUVxuICAgICAgICAgICAgICAgICAgUS51cGRhdGVJdGVtKHcpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGdbd10gPSAwO1xuICAgICAgICAgICAgICAgIFBbd10gPSBbXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChkW3ddID09IGRbX3ZdICsgZWRnZVdlaWdodCkge1xuICAgICAgICAgICAgICAgIGdbd10gPSBnW3ddICsgZ1tfdl07XG4gICAgICAgICAgICAgICAgUFt3XS5wdXNoKF92KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaiA9IDA7IF9qIDwgQVtfdl0ubGVuZ3RoOyBfaisrKSB7XG4gICAgICAgICAgICAgIHZhciBfdyA9IEFbX3ZdW19qXS5pZCgpO1xuXG4gICAgICAgICAgICAgIGlmIChkW193XSA9PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgICAgIFEucHVzaChfdyk7XG4gICAgICAgICAgICAgICAgZFtfd10gPSBkW192XSArIDE7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoZFtfd10gPT0gZFtfdl0gKyAxKSB7XG4gICAgICAgICAgICAgICAgZ1tfd10gPSBnW193XSArIGdbX3ZdO1xuXG4gICAgICAgICAgICAgICAgUFtfd10ucHVzaChfdik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZSA9IHt9O1xuXG4gICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IFYubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICAgIGVbVltfaTJdLmlkKCldID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChTLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgX3cyID0gUy5wb3AoKTtcblxuICAgICAgICAgIGZvciAodmFyIF9qMiA9IDA7IF9qMiA8IFBbX3cyXS5sZW5ndGg7IF9qMisrKSB7XG4gICAgICAgICAgICB2YXIgX3YyID0gUFtfdzJdW19qMl07XG4gICAgICAgICAgICBlW192Ml0gPSBlW192Ml0gKyBnW192Ml0gLyBnW193Ml0gKiAoMSArIGVbX3cyXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKF93MiAhPSBWW3NdLmlkKCkpIHtcbiAgICAgICAgICAgIEMuc2V0KF93MiwgQy5nZXQoX3cyKSArIGVbX3cyXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBzID0gMDsgcyA8IFYubGVuZ3RoOyBzKyspIHtcbiAgICAgICAgX2xvb3Aocyk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXQgPSB7XG4gICAgICAgIGJldHdlZW5uZXNzOiBmdW5jdGlvbiBiZXR3ZWVubmVzcyhub2RlKSB7XG4gICAgICAgICAgdmFyIGlkID0gY3kuY29sbGVjdGlvbihub2RlKS5pZCgpO1xuICAgICAgICAgIHJldHVybiBDLmdldChpZCk7XG4gICAgICAgIH0sXG4gICAgICAgIGJldHdlZW5uZXNzTm9ybWFsaXplZDogZnVuY3Rpb24gYmV0d2Vlbm5lc3NOb3JtYWxpemVkKG5vZGUpIHtcbiAgICAgICAgICBpZiAobWF4ID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBpZCA9IGN5LmNvbGxlY3Rpb24obm9kZSkuaWQoKTtcbiAgICAgICAgICByZXR1cm4gQy5nZXQoaWQpIC8gbWF4O1xuICAgICAgICB9XG4gICAgICB9OyAvLyBhbGlhc1xuXG4gICAgICByZXQuYmV0d2Vlbm5lc3NOb3JtYWxpc2VkID0gcmV0LmJldHdlZW5uZXNzTm9ybWFsaXplZDtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSAvLyBiZXR3ZWVubmVzc0NlbnRyYWxpdHlcblxuICB9OyAvLyBlbGVzZm5cbiAgLy8gbmljZSwgc2hvcnQgbWF0aGVtYXRpY2FsIGFsaWFzXG5cbiAgZWxlc2ZuJGwuYmMgPSBlbGVzZm4kbC5iZXR3ZWVubmVzc0NlbnRyYWxpdHk7XG5cbiAgLy8gSW1wbGVtZW50ZWQgYnkgWm9lIFhpIEB6b2V4aSBmb3IgR1NPQyAyMDE2XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5cbiAgdmFyIGRlZmF1bHRzJGMgPSBkZWZhdWx0cyRnKHtcbiAgICBleHBhbmRGYWN0b3I6IDIsXG4gICAgLy8gYWZmZWN0cyB0aW1lIG9mIGNvbXB1dGF0aW9uIGFuZCBjbHVzdGVyIGdyYW51bGFyaXR5IHRvIHNvbWUgZXh0ZW50OiBNICogTVxuICAgIGluZmxhdGVGYWN0b3I6IDIsXG4gICAgLy8gYWZmZWN0cyBjbHVzdGVyIGdyYW51bGFyaXR5ICh0aGUgZ3JlYXRlciB0aGUgdmFsdWUsIHRoZSBtb3JlIGNsdXN0ZXJzKTogTShpLGopIC8gRShqKVxuICAgIG11bHRGYWN0b3I6IDEsXG4gICAgLy8gb3B0aW9uYWwgc2VsZiBsb29wcyBmb3IgZWFjaCBub2RlLiBVc2UgYSBuZXV0cmFsIHZhbHVlIHRvIGltcHJvdmUgY2x1c3RlciBjb21wdXRhdGlvbnMuXG4gICAgbWF4SXRlcmF0aW9uczogMjAsXG4gICAgLy8gbWF4aW11bSBudW1iZXIgb2YgaXRlcmF0aW9ucyBvZiB0aGUgTUNMIGFsZ29yaXRobSBpbiBhIHNpbmdsZSBydW5cbiAgICBhdHRyaWJ1dGVzOiBbLy8gYXR0cmlidXRlcy9mZWF0dXJlcyB1c2VkIHRvIGdyb3VwIG5vZGVzLCBpZS4gc2ltaWxhcml0eSB2YWx1ZXMgYmV0d2VlbiBub2Rlc1xuICAgIGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XVxuICB9KTtcbiAgLyogZXNsaW50LWVuYWJsZSAqL1xuXG4gIHZhciBzZXRPcHRpb25zJDMgPSBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZGVmYXVsdHMkYyhvcHRpb25zKTtcbiAgfTtcbiAgLyogZXNsaW50LWVuYWJsZSAqL1xuXG5cbiAgdmFyIGdldFNpbWlsYXJpdHkkMSA9IGZ1bmN0aW9uIGdldFNpbWlsYXJpdHkoZWRnZSwgYXR0cmlidXRlcykge1xuICAgIHZhciB0b3RhbCA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRvdGFsICs9IGF0dHJpYnV0ZXNbaV0oZWRnZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRvdGFsO1xuICB9O1xuXG4gIHZhciBhZGRMb29wcyA9IGZ1bmN0aW9uIGFkZExvb3BzKE0sIG4sIHZhbCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICBNW2kgKiBuICsgaV0gPSB2YWw7XG4gICAgfVxuICB9O1xuXG4gIHZhciBub3JtYWxpemUgPSBmdW5jdGlvbiBub3JtYWxpemUoTSwgbikge1xuICAgIHZhciBzdW07XG5cbiAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBuOyBjb2wrKykge1xuICAgICAgc3VtID0gMDtcblxuICAgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgbjsgcm93KyspIHtcbiAgICAgICAgc3VtICs9IE1bcm93ICogbiArIGNvbF07XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIF9yb3cgPSAwOyBfcm93IDwgbjsgX3JvdysrKSB7XG4gICAgICAgIE1bX3JvdyAqIG4gKyBjb2xdID0gTVtfcm93ICogbiArIGNvbF0gLyBzdW07XG4gICAgICB9XG4gICAgfVxuICB9OyAvLyBUT0RPOiBibG9ja2VkIG1hdHJpeCBtdWx0aXBsaWNhdGlvbj9cblxuXG4gIHZhciBtbXVsdCA9IGZ1bmN0aW9uIG1tdWx0KEEsIEIsIG4pIHtcbiAgICB2YXIgQyA9IG5ldyBBcnJheShuICogbik7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBuOyBqKyspIHtcbiAgICAgICAgQ1tpICogbiArIGpdID0gMDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBuOyBrKyspIHtcbiAgICAgICAgZm9yICh2YXIgX2ogPSAwOyBfaiA8IG47IF9qKyspIHtcbiAgICAgICAgICBDW2kgKiBuICsgX2pdICs9IEFbaSAqIG4gKyBrXSAqIEJbayAqIG4gKyBfal07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gQztcbiAgfTtcblxuICB2YXIgZXhwYW5kID0gZnVuY3Rpb24gZXhwYW5kKE0sIG4sIGV4cGFuZEZhY3RvclxuICAvKiogcG93ZXIgKiovXG4gICkge1xuICAgIHZhciBfTSA9IE0uc2xpY2UoMCk7XG5cbiAgICBmb3IgKHZhciBwID0gMTsgcCA8IGV4cGFuZEZhY3RvcjsgcCsrKSB7XG4gICAgICBNID0gbW11bHQoTSwgX00sIG4pO1xuICAgIH1cblxuICAgIHJldHVybiBNO1xuICB9O1xuXG4gIHZhciBpbmZsYXRlID0gZnVuY3Rpb24gaW5mbGF0ZShNLCBuLCBpbmZsYXRlRmFjdG9yXG4gIC8qKiByICoqL1xuICApIHtcbiAgICB2YXIgX00gPSBuZXcgQXJyYXkobiAqIG4pOyAvLyBNKGksaikgXiBpbmZsYXRlUG93ZXJcblxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuICogbjsgaSsrKSB7XG4gICAgICBfTVtpXSA9IE1hdGgucG93KE1baV0sIGluZmxhdGVGYWN0b3IpO1xuICAgIH1cblxuICAgIG5vcm1hbGl6ZShfTSwgbik7XG4gICAgcmV0dXJuIF9NO1xuICB9O1xuXG4gIHZhciBoYXNDb252ZXJnZWQgPSBmdW5jdGlvbiBoYXNDb252ZXJnZWQoTSwgX00sIG4yLCByb3VuZEZhY3Rvcikge1xuICAgIC8vIENoZWNrIHRoYXQgYm90aCBtYXRyaWNlcyBoYXZlIHRoZSBzYW1lIGVsZW1lbnRzIChpLGopXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuMjsgaSsrKSB7XG4gICAgICB2YXIgdjEgPSBNYXRoLnJvdW5kKE1baV0gKiBNYXRoLnBvdygxMCwgcm91bmRGYWN0b3IpKSAvIE1hdGgucG93KDEwLCByb3VuZEZhY3Rvcik7IC8vIHRydW5jYXRlIHRvICdyb3VuZEZhY3RvcicgZGVjaW1hbCBwbGFjZXNcblxuICAgICAgdmFyIHYyID0gTWF0aC5yb3VuZChfTVtpXSAqIE1hdGgucG93KDEwLCByb3VuZEZhY3RvcikpIC8gTWF0aC5wb3coMTAsIHJvdW5kRmFjdG9yKTtcblxuICAgICAgaWYgKHYxICE9PSB2Mikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgdmFyIGFzc2lnbiQyID0gZnVuY3Rpb24gYXNzaWduKE0sIG4sIG5vZGVzLCBjeSkge1xuICAgIHZhciBjbHVzdGVycyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgIHZhciBjbHVzdGVyID0gW107XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbjsgaisrKSB7XG4gICAgICAgIC8vIFJvdy13aXNlIGF0dHJhY3RvcnMgYW5kIGVsZW1lbnRzIHRoYXQgdGhleSBhdHRyYWN0IGJlbG9uZyBpbiBzYW1lIGNsdXN0ZXJcbiAgICAgICAgaWYgKE1hdGgucm91bmQoTVtpICogbiArIGpdICogMTAwMCkgLyAxMDAwID4gMCkge1xuICAgICAgICAgIGNsdXN0ZXIucHVzaChub2Rlc1tqXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNsdXN0ZXIubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIGNsdXN0ZXJzLnB1c2goY3kuY29sbGVjdGlvbihjbHVzdGVyKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsdXN0ZXJzO1xuICB9O1xuXG4gIHZhciBpc0R1cGxpY2F0ZSA9IGZ1bmN0aW9uIGlzRHVwbGljYXRlKGMxLCBjMikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYzEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghYzJbaV0gfHwgYzFbaV0uaWQoKSAhPT0gYzJbaV0uaWQoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgdmFyIHJlbW92ZUR1cGxpY2F0ZXMgPSBmdW5jdGlvbiByZW1vdmVEdXBsaWNhdGVzKGNsdXN0ZXJzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbHVzdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjbHVzdGVycy5sZW5ndGg7IGorKykge1xuICAgICAgICBpZiAoaSAhPSBqICYmIGlzRHVwbGljYXRlKGNsdXN0ZXJzW2ldLCBjbHVzdGVyc1tqXSkpIHtcbiAgICAgICAgICBjbHVzdGVycy5zcGxpY2UoaiwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2x1c3RlcnM7XG4gIH07XG5cbiAgdmFyIG1hcmtvdkNsdXN0ZXJpbmcgPSBmdW5jdGlvbiBtYXJrb3ZDbHVzdGVyaW5nKG9wdGlvbnMpIHtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gICAgdmFyIGVkZ2VzID0gdGhpcy5lZGdlcygpO1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTsgLy8gU2V0IHBhcmFtZXRlcnMgb2YgYWxnb3JpdGhtOlxuXG4gICAgdmFyIG9wdHMgPSBzZXRPcHRpb25zJDMob3B0aW9ucyk7IC8vIE1hcCBlYWNoIG5vZGUgdG8gaXRzIHBvc2l0aW9uIGluIG5vZGUgYXJyYXlcblxuICAgIHZhciBpZDJwb3NpdGlvbiA9IHt9O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWQycG9zaXRpb25bbm9kZXNbaV0uaWQoKV0gPSBpO1xuICAgIH0gLy8gR2VuZXJhdGUgc3RvY2hhc3RpYyBtYXRyaXggTSBmcm9tIGlucHV0IGdyYXBoIEcgKHNob3VsZCBiZSBzeW1tZXRyaWMvdW5kaXJlY3RlZClcblxuXG4gICAgdmFyIG4gPSBub2Rlcy5sZW5ndGgsXG4gICAgICAgIG4yID0gbiAqIG47XG5cbiAgICB2YXIgTSA9IG5ldyBBcnJheShuMiksXG4gICAgICAgIF9NO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG4yOyBfaSsrKSB7XG4gICAgICBNW19pXSA9IDA7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgZSA9IDA7IGUgPCBlZGdlcy5sZW5ndGg7IGUrKykge1xuICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tlXTtcbiAgICAgIHZhciBfaTIgPSBpZDJwb3NpdGlvbltlZGdlLnNvdXJjZSgpLmlkKCldO1xuICAgICAgdmFyIGogPSBpZDJwb3NpdGlvbltlZGdlLnRhcmdldCgpLmlkKCldO1xuICAgICAgdmFyIHNpbSA9IGdldFNpbWlsYXJpdHkkMShlZGdlLCBvcHRzLmF0dHJpYnV0ZXMpO1xuICAgICAgTVtfaTIgKiBuICsgal0gKz0gc2ltOyAvLyBHIHNob3VsZCBiZSBzeW1tZXRyaWMgYW5kIHVuZGlyZWN0ZWRcblxuICAgICAgTVtqICogbiArIF9pMl0gKz0gc2ltO1xuICAgIH0gLy8gQmVnaW4gTWFya292IGNsdXN0ZXIgYWxnb3JpdGhtXG4gICAgLy8gU3RlcCAxOiBBZGQgc2VsZiBsb29wcyB0byBlYWNoIG5vZGUsIGllLiBhZGQgbXVsdEZhY3RvciB0byBtYXRyaXggZGlhZ29uYWxcblxuXG4gICAgYWRkTG9vcHMoTSwgbiwgb3B0cy5tdWx0RmFjdG9yKTsgLy8gU3RlcCAyOiBNID0gbm9ybWFsaXplKCBNICk7XG5cbiAgICBub3JtYWxpemUoTSwgbik7XG4gICAgdmFyIGlzU3RpbGxNb3ZpbmcgPSB0cnVlO1xuICAgIHZhciBpdGVyYXRpb25zID0gMDtcblxuICAgIHdoaWxlIChpc1N0aWxsTW92aW5nICYmIGl0ZXJhdGlvbnMgPCBvcHRzLm1heEl0ZXJhdGlvbnMpIHtcbiAgICAgIGlzU3RpbGxNb3ZpbmcgPSBmYWxzZTsgLy8gU3RlcCAzOlxuXG4gICAgICBfTSA9IGV4cGFuZChNLCBuLCBvcHRzLmV4cGFuZEZhY3Rvcik7IC8vIFN0ZXAgNDpcblxuICAgICAgTSA9IGluZmxhdGUoX00sIG4sIG9wdHMuaW5mbGF0ZUZhY3Rvcik7IC8vIFN0ZXAgNTogY2hlY2sgdG8gc2VlIGlmIH5zdGVhZHkgc3RhdGUgaGFzIGJlZW4gcmVhY2hlZFxuXG4gICAgICBpZiAoIWhhc0NvbnZlcmdlZChNLCBfTSwgbjIsIDQpKSB7XG4gICAgICAgIGlzU3RpbGxNb3ZpbmcgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpdGVyYXRpb25zKys7XG4gICAgfSAvLyBCdWlsZCBjbHVzdGVycyBmcm9tIG1hdHJpeFxuXG5cbiAgICB2YXIgY2x1c3RlcnMgPSBhc3NpZ24kMihNLCBuLCBub2RlcywgY3kpOyAvLyBSZW1vdmUgZHVwbGljYXRlIGNsdXN0ZXJzIGR1ZSB0byBzeW1tZXRyeSBvZiBncmFwaCBhbmQgTSBtYXRyaXhcblxuICAgIGNsdXN0ZXJzID0gcmVtb3ZlRHVwbGljYXRlcyhjbHVzdGVycyk7XG4gICAgcmV0dXJuIGNsdXN0ZXJzO1xuICB9O1xuXG4gIHZhciBtYXJrb3ZDbHVzdGVyaW5nJDEgPSB7XG4gICAgbWFya292Q2x1c3RlcmluZzogbWFya292Q2x1c3RlcmluZyxcbiAgICBtY2w6IG1hcmtvdkNsdXN0ZXJpbmdcbiAgfTtcblxuICAvLyBDb21tb24gZGlzdGFuY2UgbWV0cmljcyBmb3IgY2x1c3RlcmluZyBhbGdvcml0aG1zXG5cbiAgdmFyIGlkZW50aXR5ID0gZnVuY3Rpb24gaWRlbnRpdHkoeCkge1xuICAgIHJldHVybiB4O1xuICB9O1xuXG4gIHZhciBhYnNEaWZmID0gZnVuY3Rpb24gYWJzRGlmZihwLCBxKSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKHEgLSBwKTtcbiAgfTtcblxuICB2YXIgYWRkQWJzRGlmZiA9IGZ1bmN0aW9uIGFkZEFic0RpZmYodG90YWwsIHAsIHEpIHtcbiAgICByZXR1cm4gdG90YWwgKyBhYnNEaWZmKHAsIHEpO1xuICB9O1xuXG4gIHZhciBhZGRTcXVhcmVkRGlmZiA9IGZ1bmN0aW9uIGFkZFNxdWFyZWREaWZmKHRvdGFsLCBwLCBxKSB7XG4gICAgcmV0dXJuIHRvdGFsICsgTWF0aC5wb3cocSAtIHAsIDIpO1xuICB9O1xuXG4gIHZhciBzcXJ0ID0gZnVuY3Rpb24gc3FydCh4KSB7XG4gICAgcmV0dXJuIE1hdGguc3FydCh4KTtcbiAgfTtcblxuICB2YXIgbWF4QWJzRGlmZiA9IGZ1bmN0aW9uIG1heEFic0RpZmYoY3VycmVudE1heCwgcCwgcSkge1xuICAgIHJldHVybiBNYXRoLm1heChjdXJyZW50TWF4LCBhYnNEaWZmKHAsIHEpKTtcbiAgfTtcblxuICB2YXIgZ2V0RGlzdGFuY2UgPSBmdW5jdGlvbiBnZXREaXN0YW5jZShsZW5ndGgsIGdldFAsIGdldFEsIGluaXQsIHZpc2l0KSB7XG4gICAgdmFyIHBvc3QgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IGlkZW50aXR5O1xuICAgIHZhciByZXQgPSBpbml0O1xuICAgIHZhciBwLCBxO1xuXG4gICAgZm9yICh2YXIgZGltID0gMDsgZGltIDwgbGVuZ3RoOyBkaW0rKykge1xuICAgICAgcCA9IGdldFAoZGltKTtcbiAgICAgIHEgPSBnZXRRKGRpbSk7XG4gICAgICByZXQgPSB2aXNpdChyZXQsIHAsIHEpO1xuICAgIH1cblxuICAgIHJldHVybiBwb3N0KHJldCk7XG4gIH07XG5cbiAgdmFyIGRpc3RhbmNlcyA9IHtcbiAgICBldWNsaWRlYW46IGZ1bmN0aW9uIGV1Y2xpZGVhbihsZW5ndGgsIGdldFAsIGdldFEpIHtcbiAgICAgIGlmIChsZW5ndGggPj0gMikge1xuICAgICAgICByZXR1cm4gZ2V0RGlzdGFuY2UobGVuZ3RoLCBnZXRQLCBnZXRRLCAwLCBhZGRTcXVhcmVkRGlmZiwgc3FydCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBmb3Igc2luZ2xlIGF0dHIgY2FzZSwgbW9yZSBlZmZpY2llbnQgdG8gYXZvaWQgc3FydFxuICAgICAgICByZXR1cm4gZ2V0RGlzdGFuY2UobGVuZ3RoLCBnZXRQLCBnZXRRLCAwLCBhZGRBYnNEaWZmKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNxdWFyZWRFdWNsaWRlYW46IGZ1bmN0aW9uIHNxdWFyZWRFdWNsaWRlYW4obGVuZ3RoLCBnZXRQLCBnZXRRKSB7XG4gICAgICByZXR1cm4gZ2V0RGlzdGFuY2UobGVuZ3RoLCBnZXRQLCBnZXRRLCAwLCBhZGRTcXVhcmVkRGlmZik7XG4gICAgfSxcbiAgICBtYW5oYXR0YW46IGZ1bmN0aW9uIG1hbmhhdHRhbihsZW5ndGgsIGdldFAsIGdldFEpIHtcbiAgICAgIHJldHVybiBnZXREaXN0YW5jZShsZW5ndGgsIGdldFAsIGdldFEsIDAsIGFkZEFic0RpZmYpO1xuICAgIH0sXG4gICAgbWF4OiBmdW5jdGlvbiBtYXgobGVuZ3RoLCBnZXRQLCBnZXRRKSB7XG4gICAgICByZXR1cm4gZ2V0RGlzdGFuY2UobGVuZ3RoLCBnZXRQLCBnZXRRLCAtSW5maW5pdHksIG1heEFic0RpZmYpO1xuICAgIH1cbiAgfTsgLy8gaW4gY2FzZSB0aGUgdXNlciBhY2NpZGVudGFsbHkgZG9lc24ndCB1c2UgY2FtZWwgY2FzZVxuXG4gIGRpc3RhbmNlc1snc3F1YXJlZC1ldWNsaWRlYW4nXSA9IGRpc3RhbmNlc1snc3F1YXJlZEV1Y2xpZGVhbiddO1xuICBkaXN0YW5jZXNbJ3NxdWFyZWRldWNsaWRlYW4nXSA9IGRpc3RhbmNlc1snc3F1YXJlZEV1Y2xpZGVhbiddO1xuICBmdW5jdGlvbiBjbHVzdGVyaW5nRGlzdGFuY2UgKG1ldGhvZCwgbGVuZ3RoLCBnZXRQLCBnZXRRLCBub2RlUCwgbm9kZVEpIHtcbiAgICB2YXIgaW1wbDtcblxuICAgIGlmIChmbiQ2KG1ldGhvZCkpIHtcbiAgICAgIGltcGwgPSBtZXRob2Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIGltcGwgPSBkaXN0YW5jZXNbbWV0aG9kXSB8fCBkaXN0YW5jZXMuZXVjbGlkZWFuO1xuICAgIH1cblxuICAgIGlmIChsZW5ndGggPT09IDAgJiYgZm4kNihtZXRob2QpKSB7XG4gICAgICByZXR1cm4gaW1wbChub2RlUCwgbm9kZVEpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gaW1wbChsZW5ndGgsIGdldFAsIGdldFEsIG5vZGVQLCBub2RlUSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGRlZmF1bHRzJGIgPSBkZWZhdWx0cyRnKHtcbiAgICBrOiAyLFxuICAgIG06IDIsXG4gICAgc2Vuc2l0aXZpdHlUaHJlc2hvbGQ6IDAuMDAwMSxcbiAgICBkaXN0YW5jZTogJ2V1Y2xpZGVhbicsXG4gICAgbWF4SXRlcmF0aW9uczogMTAsXG4gICAgYXR0cmlidXRlczogW10sXG4gICAgdGVzdE1vZGU6IGZhbHNlLFxuICAgIHRlc3RDZW50cm9pZHM6IG51bGxcbiAgfSk7XG5cbiAgdmFyIHNldE9wdGlvbnMkMiA9IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgIHJldHVybiBkZWZhdWx0cyRiKG9wdGlvbnMpO1xuICB9O1xuICAvKiBlc2xpbnQtZW5hYmxlICovXG5cblxuICB2YXIgZ2V0RGlzdCA9IGZ1bmN0aW9uIGdldERpc3QodHlwZSwgbm9kZSwgY2VudHJvaWQsIGF0dHJpYnV0ZXMsIG1vZGUpIHtcbiAgICB2YXIgbm9Ob2RlUCA9IG1vZGUgIT09ICdrTWVkb2lkcyc7XG4gICAgdmFyIGdldFAgPSBub05vZGVQID8gZnVuY3Rpb24gKGkpIHtcbiAgICAgIHJldHVybiBjZW50cm9pZFtpXTtcbiAgICB9IDogZnVuY3Rpb24gKGkpIHtcbiAgICAgIHJldHVybiBhdHRyaWJ1dGVzW2ldKGNlbnRyb2lkKTtcbiAgICB9O1xuXG4gICAgdmFyIGdldFEgPSBmdW5jdGlvbiBnZXRRKGkpIHtcbiAgICAgIHJldHVybiBhdHRyaWJ1dGVzW2ldKG5vZGUpO1xuICAgIH07XG5cbiAgICB2YXIgbm9kZVAgPSBjZW50cm9pZDtcbiAgICB2YXIgbm9kZVEgPSBub2RlO1xuICAgIHJldHVybiBjbHVzdGVyaW5nRGlzdGFuY2UodHlwZSwgYXR0cmlidXRlcy5sZW5ndGgsIGdldFAsIGdldFEsIG5vZGVQLCBub2RlUSk7XG4gIH07XG5cbiAgdmFyIHJhbmRvbUNlbnRyb2lkcyA9IGZ1bmN0aW9uIHJhbmRvbUNlbnRyb2lkcyhub2RlcywgaywgYXR0cmlidXRlcykge1xuICAgIHZhciBuZGltID0gYXR0cmlidXRlcy5sZW5ndGg7XG4gICAgdmFyIG1pbiA9IG5ldyBBcnJheShuZGltKTtcbiAgICB2YXIgbWF4ID0gbmV3IEFycmF5KG5kaW0pO1xuICAgIHZhciBjZW50cm9pZHMgPSBuZXcgQXJyYXkoayk7XG4gICAgdmFyIGNlbnRyb2lkID0gbnVsbDsgLy8gRmluZCBtaW4sIG1heCB2YWx1ZXMgZm9yIGVhY2ggYXR0cmlidXRlIGRpbWVuc2lvblxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZGltOyBpKyspIHtcbiAgICAgIG1pbltpXSA9IG5vZGVzLm1pbihhdHRyaWJ1dGVzW2ldKS52YWx1ZTtcbiAgICAgIG1heFtpXSA9IG5vZGVzLm1heChhdHRyaWJ1dGVzW2ldKS52YWx1ZTtcbiAgICB9IC8vIEJ1aWxkIGsgY2VudHJvaWRzLCBlYWNoIHJlcHJlc2VudGVkIGFzIGFuIG4tZGltIGZlYXR1cmUgdmVjdG9yXG5cblxuICAgIGZvciAodmFyIGMgPSAwOyBjIDwgazsgYysrKSB7XG4gICAgICBjZW50cm9pZCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbmRpbTsgX2krKykge1xuICAgICAgICBjZW50cm9pZFtfaV0gPSBNYXRoLnJhbmRvbSgpICogKG1heFtfaV0gLSBtaW5bX2ldKSArIG1pbltfaV07IC8vIHJhbmRvbSBpbml0aWFsIHZhbHVlXG4gICAgICB9XG5cbiAgICAgIGNlbnRyb2lkc1tjXSA9IGNlbnRyb2lkO1xuICAgIH1cblxuICAgIHJldHVybiBjZW50cm9pZHM7XG4gIH07XG5cbiAgdmFyIGNsYXNzaWZ5ID0gZnVuY3Rpb24gY2xhc3NpZnkobm9kZSwgY2VudHJvaWRzLCBkaXN0YW5jZSwgYXR0cmlidXRlcywgdHlwZSkge1xuICAgIHZhciBtaW4gPSBJbmZpbml0eTtcbiAgICB2YXIgaW5kZXggPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjZW50cm9pZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkaXN0ID0gZ2V0RGlzdChkaXN0YW5jZSwgbm9kZSwgY2VudHJvaWRzW2ldLCBhdHRyaWJ1dGVzLCB0eXBlKTtcblxuICAgICAgaWYgKGRpc3QgPCBtaW4pIHtcbiAgICAgICAgbWluID0gZGlzdDtcbiAgICAgICAgaW5kZXggPSBpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpbmRleDtcbiAgfTtcblxuICB2YXIgYnVpbGRDbHVzdGVyID0gZnVuY3Rpb24gYnVpbGRDbHVzdGVyKGNlbnRyb2lkLCBub2RlcywgYXNzaWdubWVudCkge1xuICAgIHZhciBjbHVzdGVyID0gW107XG4gICAgdmFyIG5vZGUgPSBudWxsO1xuXG4gICAgZm9yICh2YXIgbiA9IDA7IG4gPCBub2Rlcy5sZW5ndGg7IG4rKykge1xuICAgICAgbm9kZSA9IG5vZGVzW25dO1xuXG4gICAgICBpZiAoYXNzaWdubWVudFtub2RlLmlkKCldID09PSBjZW50cm9pZCkge1xuICAgICAgICAvL2NvbnNvbGUubG9nKFwiTm9kZSBcIiArIG5vZGUuaWQoKSArIFwiIGlzIGFzc29jaWF0ZWQgd2l0aCBtZWRvaWQgIzogXCIgKyBtKTtcbiAgICAgICAgY2x1c3Rlci5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjbHVzdGVyO1xuICB9O1xuXG4gIHZhciBoYXZlVmFsdWVzQ29udmVyZ2VkID0gZnVuY3Rpb24gaGF2ZVZhbHVlc0NvbnZlcmdlZCh2MSwgdjIsIHNlbnNpdGl2aXR5VGhyZXNob2xkKSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKHYyIC0gdjEpIDw9IHNlbnNpdGl2aXR5VGhyZXNob2xkO1xuICB9O1xuXG4gIHZhciBoYXZlTWF0cmljZXNDb252ZXJnZWQgPSBmdW5jdGlvbiBoYXZlTWF0cmljZXNDb252ZXJnZWQodjEsIHYyLCBzZW5zaXRpdml0eVRocmVzaG9sZCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdjEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdjFbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIGRpZmYgPSBNYXRoLmFicyh2MVtpXVtqXSAtIHYyW2ldW2pdKTtcblxuICAgICAgICBpZiAoZGlmZiA+IHNlbnNpdGl2aXR5VGhyZXNob2xkKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgdmFyIHNlZW5CZWZvcmUgPSBmdW5jdGlvbiBzZWVuQmVmb3JlKG5vZGUsIG1lZG9pZHMsIG4pIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgaWYgKG5vZGUgPT09IG1lZG9pZHNbaV0pIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICB2YXIgcmFuZG9tTWVkb2lkcyA9IGZ1bmN0aW9uIHJhbmRvbU1lZG9pZHMobm9kZXMsIGspIHtcbiAgICB2YXIgbWVkb2lkcyA9IG5ldyBBcnJheShrKTsgLy8gRm9yIHNtYWxsIGRhdGEgc2V0cywgdGhlIHByb2JhYmlsaXR5IG9mIG1lZG9pZCBjb25mbGljdCBpcyBncmVhdGVyLFxuICAgIC8vIHNvIHdlIG5lZWQgdG8gY2hlY2sgdG8gc2VlIGlmIHdlJ3ZlIGFscmVhZHkgc2VlbiBvciBjaG9zZSB0aGlzIG5vZGUgYmVmb3JlLlxuXG4gICAgaWYgKG5vZGVzLmxlbmd0aCA8IDUwKSB7XG4gICAgICAvLyBSYW5kb21seSBzZWxlY3QgayBtZWRvaWRzIGZyb20gdGhlIG4gbm9kZXNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgazsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gbm9kZXNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbm9kZXMubGVuZ3RoKV07IC8vIElmIHdlJ3ZlIGFscmVhZHkgY2hvc2VuIHRoaXMgbm9kZSB0byBiZSBhIG1lZG9pZCwgZG9uJ3QgY2hvb3NlIGl0IGFnYWluIChmb3Igc21hbGwgZGF0YSBzZXRzKS5cbiAgICAgICAgLy8gSW5zdGVhZCBjaG9vc2UgYSBkaWZmZXJlbnQgcmFuZG9tIG5vZGUuXG5cbiAgICAgICAgd2hpbGUgKHNlZW5CZWZvcmUobm9kZSwgbWVkb2lkcywgaSkpIHtcbiAgICAgICAgICBub2RlID0gbm9kZXNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbm9kZXMubGVuZ3RoKV07XG4gICAgICAgIH1cblxuICAgICAgICBtZWRvaWRzW2ldID0gbm9kZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVsYXRpdmVseSBsYXJnZSBkYXRhIHNldCwgc28gcHJldHR5IHNhZmUgdG8gbm90IGNoZWNrIGFuZCBqdXN0IHNlbGVjdCByYW5kb20gbm9kZXNcbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGs7IF9pMisrKSB7XG4gICAgICAgIG1lZG9pZHNbX2kyXSA9IG5vZGVzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG5vZGVzLmxlbmd0aCldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtZWRvaWRzO1xuICB9O1xuXG4gIHZhciBmaW5kQ29zdCA9IGZ1bmN0aW9uIGZpbmRDb3N0KHBvdGVudGlhbE5ld01lZG9pZCwgY2x1c3RlciwgYXR0cmlidXRlcykge1xuICAgIHZhciBjb3N0ID0gMDtcblxuICAgIGZvciAodmFyIG4gPSAwOyBuIDwgY2x1c3Rlci5sZW5ndGg7IG4rKykge1xuICAgICAgY29zdCArPSBnZXREaXN0KCdtYW5oYXR0YW4nLCBjbHVzdGVyW25dLCBwb3RlbnRpYWxOZXdNZWRvaWQsIGF0dHJpYnV0ZXMsICdrTWVkb2lkcycpO1xuICAgIH1cblxuICAgIHJldHVybiBjb3N0O1xuICB9O1xuXG4gIHZhciBrTWVhbnMgPSBmdW5jdGlvbiBrTWVhbnMob3B0aW9ucykge1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gICAgdmFyIG5vZGUgPSBudWxsOyAvLyBTZXQgcGFyYW1ldGVycyBvZiBhbGdvcml0aG06ICMgb2YgY2x1c3RlcnMsIGRpc3RhbmNlIG1ldHJpYywgZXRjLlxuXG4gICAgdmFyIG9wdHMgPSBzZXRPcHRpb25zJDIob3B0aW9ucyk7IC8vIEJlZ2luIGstbWVhbnMgYWxnb3JpdGhtXG5cbiAgICB2YXIgY2x1c3RlcnMgPSBuZXcgQXJyYXkob3B0cy5rKTtcbiAgICB2YXIgYXNzaWdubWVudCA9IHt9O1xuICAgIHZhciBjZW50cm9pZHM7IC8vIFN0ZXAgMTogSW5pdGlhbGl6ZSBjZW50cm9pZCBwb3NpdGlvbnNcblxuICAgIGlmIChvcHRzLnRlc3RNb2RlKSB7XG4gICAgICBpZiAodHlwZW9mIG9wdHMudGVzdENlbnRyb2lkcyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgLy8gVE9ETzogaW1wbGVtZW50IGEgc2VlZGVkIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yLlxuICAgICAgICBvcHRzLnRlc3RDZW50cm9pZHM7XG4gICAgICAgIGNlbnRyb2lkcyA9IHJhbmRvbUNlbnRyb2lkcyhub2Rlcywgb3B0cy5rLCBvcHRzLmF0dHJpYnV0ZXMpO1xuICAgICAgfSBlbHNlIGlmIChfdHlwZW9mKG9wdHMudGVzdENlbnRyb2lkcykgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGNlbnRyb2lkcyA9IG9wdHMudGVzdENlbnRyb2lkcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNlbnRyb2lkcyA9IHJhbmRvbUNlbnRyb2lkcyhub2Rlcywgb3B0cy5rLCBvcHRzLmF0dHJpYnV0ZXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjZW50cm9pZHMgPSByYW5kb21DZW50cm9pZHMobm9kZXMsIG9wdHMuaywgb3B0cy5hdHRyaWJ1dGVzKTtcbiAgICB9XG5cbiAgICB2YXIgaXNTdGlsbE1vdmluZyA9IHRydWU7XG4gICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuXG4gICAgd2hpbGUgKGlzU3RpbGxNb3ZpbmcgJiYgaXRlcmF0aW9ucyA8IG9wdHMubWF4SXRlcmF0aW9ucykge1xuICAgICAgLy8gU3RlcCAyOiBBc3NpZ24gbm9kZXMgdG8gdGhlIG5lYXJlc3QgY2VudHJvaWRcbiAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgbm9kZXMubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgbm9kZSA9IG5vZGVzW25dOyAvLyBEZXRlcm1pbmUgd2hpY2ggY2x1c3RlciB0aGlzIG5vZGUgYmVsb25ncyB0bzogbm9kZSBpZCA9PiBjbHVzdGVyICNcblxuICAgICAgICBhc3NpZ25tZW50W25vZGUuaWQoKV0gPSBjbGFzc2lmeShub2RlLCBjZW50cm9pZHMsIG9wdHMuZGlzdGFuY2UsIG9wdHMuYXR0cmlidXRlcywgJ2tNZWFucycpO1xuICAgICAgfSAvLyBTdGVwIDM6IEZvciBlYWNoIG9mIHRoZSBrIGNsdXN0ZXJzLCB1cGRhdGUgaXRzIGNlbnRyb2lkXG5cblxuICAgICAgaXNTdGlsbE1vdmluZyA9IGZhbHNlO1xuXG4gICAgICBmb3IgKHZhciBjID0gMDsgYyA8IG9wdHMuazsgYysrKSB7XG4gICAgICAgIC8vIEdldCBhbGwgbm9kZXMgdGhhdCBiZWxvbmcgdG8gdGhpcyBjbHVzdGVyXG4gICAgICAgIHZhciBjbHVzdGVyID0gYnVpbGRDbHVzdGVyKGMsIG5vZGVzLCBhc3NpZ25tZW50KTtcblxuICAgICAgICBpZiAoY2x1c3Rlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAvLyBJZiBjbHVzdGVyIGlzIGVtcHR5LCBicmVhayBvdXQgZWFybHkgJiBtb3ZlIHRvIG5leHQgY2x1c3RlclxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIFVwZGF0ZSBjZW50cm9pZHMgYnkgY2FsY3VsYXRpbmcgYXZnIG9mIGFsbCBub2RlcyB3aXRoaW4gdGhlIGNsdXN0ZXIuXG5cblxuICAgICAgICB2YXIgbmRpbSA9IG9wdHMuYXR0cmlidXRlcy5sZW5ndGg7XG4gICAgICAgIHZhciBjZW50cm9pZCA9IGNlbnRyb2lkc1tjXTsgLy8gWyBkaW1fMSwgZGltXzIsIGRpbV8zLCAuLi4gLCBkaW1fbiBdXG5cbiAgICAgICAgdmFyIG5ld0NlbnRyb2lkID0gbmV3IEFycmF5KG5kaW0pO1xuICAgICAgICB2YXIgc3VtID0gbmV3IEFycmF5KG5kaW0pO1xuXG4gICAgICAgIGZvciAodmFyIGQgPSAwOyBkIDwgbmRpbTsgZCsrKSB7XG4gICAgICAgICAgc3VtW2RdID0gMC4wO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbHVzdGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBub2RlID0gY2x1c3RlcltpXTtcbiAgICAgICAgICAgIHN1bVtkXSArPSBvcHRzLmF0dHJpYnV0ZXNbZF0obm9kZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV3Q2VudHJvaWRbZF0gPSBzdW1bZF0gLyBjbHVzdGVyLmxlbmd0aDsgLy8gQ2hlY2sgdG8gc2VlIGlmIGFsZ29yaXRobSBoYXMgY29udmVyZ2VkLCBpLmUuIHdoZW4gY2VudHJvaWRzIG5vIGxvbmdlciBjaGFuZ2VcblxuICAgICAgICAgIGlmICghaGF2ZVZhbHVlc0NvbnZlcmdlZChuZXdDZW50cm9pZFtkXSwgY2VudHJvaWRbZF0sIG9wdHMuc2Vuc2l0aXZpdHlUaHJlc2hvbGQpKSB7XG4gICAgICAgICAgICBpc1N0aWxsTW92aW5nID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjZW50cm9pZHNbY10gPSBuZXdDZW50cm9pZDtcbiAgICAgICAgY2x1c3RlcnNbY10gPSBjeS5jb2xsZWN0aW9uKGNsdXN0ZXIpO1xuICAgICAgfVxuXG4gICAgICBpdGVyYXRpb25zKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsdXN0ZXJzO1xuICB9O1xuXG4gIHZhciBrTWVkb2lkcyA9IGZ1bmN0aW9uIGtNZWRvaWRzKG9wdGlvbnMpIHtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuICAgIHZhciBub2RlID0gbnVsbDtcbiAgICB2YXIgb3B0cyA9IHNldE9wdGlvbnMkMihvcHRpb25zKTsgLy8gQmVnaW4gay1tZWRvaWRzIGFsZ29yaXRobVxuXG4gICAgdmFyIGNsdXN0ZXJzID0gbmV3IEFycmF5KG9wdHMuayk7XG4gICAgdmFyIG1lZG9pZHM7XG4gICAgdmFyIGFzc2lnbm1lbnQgPSB7fTtcbiAgICB2YXIgY3VyQ29zdDtcbiAgICB2YXIgbWluQ29zdHMgPSBuZXcgQXJyYXkob3B0cy5rKTsgLy8gbWluaW11bSBjb3N0IGNvbmZpZ3VyYXRpb24gZm9yIGVhY2ggY2x1c3RlclxuICAgIC8vIFN0ZXAgMTogSW5pdGlhbGl6ZSBrIG1lZG9pZHNcblxuICAgIGlmIChvcHRzLnRlc3RNb2RlKSB7XG4gICAgICBpZiAodHlwZW9mIG9wdHMudGVzdENlbnRyb2lkcyA9PT0gJ251bWJlcicpIDsgZWxzZSBpZiAoX3R5cGVvZihvcHRzLnRlc3RDZW50cm9pZHMpID09PSAnb2JqZWN0Jykge1xuICAgICAgICBtZWRvaWRzID0gb3B0cy50ZXN0Q2VudHJvaWRzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWVkb2lkcyA9IHJhbmRvbU1lZG9pZHMobm9kZXMsIG9wdHMuayk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lZG9pZHMgPSByYW5kb21NZWRvaWRzKG5vZGVzLCBvcHRzLmspO1xuICAgIH1cblxuICAgIHZhciBpc1N0aWxsTW92aW5nID0gdHJ1ZTtcbiAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG5cbiAgICB3aGlsZSAoaXNTdGlsbE1vdmluZyAmJiBpdGVyYXRpb25zIDwgb3B0cy5tYXhJdGVyYXRpb25zKSB7XG4gICAgICAvLyBTdGVwIDI6IEFzc2lnbiBub2RlcyB0byB0aGUgbmVhcmVzdCBtZWRvaWRcbiAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgbm9kZXMubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgbm9kZSA9IG5vZGVzW25dOyAvLyBEZXRlcm1pbmUgd2hpY2ggY2x1c3RlciB0aGlzIG5vZGUgYmVsb25ncyB0bzogbm9kZSBpZCA9PiBjbHVzdGVyICNcblxuICAgICAgICBhc3NpZ25tZW50W25vZGUuaWQoKV0gPSBjbGFzc2lmeShub2RlLCBtZWRvaWRzLCBvcHRzLmRpc3RhbmNlLCBvcHRzLmF0dHJpYnV0ZXMsICdrTWVkb2lkcycpO1xuICAgICAgfVxuXG4gICAgICBpc1N0aWxsTW92aW5nID0gZmFsc2U7IC8vIFN0ZXAgMzogRm9yIGVhY2ggbWVkb2lkIG0sIGFuZCBmb3IgZWFjaCBub2RlIGFzc29jaWF0ZWQgd2l0aCBtZWRpb2QgbSxcbiAgICAgIC8vIHNlbGVjdCB0aGUgbm9kZSB3aXRoIHRoZSBsb3dlc3QgY29uZmlndXJhdGlvbiBjb3N0IGFzIG5ldyBtZWRvaWQuXG5cbiAgICAgIGZvciAodmFyIG0gPSAwOyBtIDwgbWVkb2lkcy5sZW5ndGg7IG0rKykge1xuICAgICAgICAvLyBHZXQgYWxsIG5vZGVzIHRoYXQgYmVsb25nIHRvIHRoaXMgbWVkb2lkXG4gICAgICAgIHZhciBjbHVzdGVyID0gYnVpbGRDbHVzdGVyKG0sIG5vZGVzLCBhc3NpZ25tZW50KTtcblxuICAgICAgICBpZiAoY2x1c3Rlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAvLyBJZiBjbHVzdGVyIGlzIGVtcHR5LCBicmVhayBvdXQgZWFybHkgJiBtb3ZlIHRvIG5leHQgY2x1c3RlclxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbWluQ29zdHNbbV0gPSBmaW5kQ29zdChtZWRvaWRzW21dLCBjbHVzdGVyLCBvcHRzLmF0dHJpYnV0ZXMpOyAvLyBvcmlnaW5hbCBjb3N0XG4gICAgICAgIC8vIFNlbGVjdCBkaWZmZXJlbnQgbWVkb2lkIGlmIGl0cyBjb25maWd1cmF0aW9uIGhhcyB0aGUgbG93ZXN0IGNvc3RcblxuICAgICAgICBmb3IgKHZhciBfbiA9IDA7IF9uIDwgY2x1c3Rlci5sZW5ndGg7IF9uKyspIHtcbiAgICAgICAgICBjdXJDb3N0ID0gZmluZENvc3QoY2x1c3Rlcltfbl0sIGNsdXN0ZXIsIG9wdHMuYXR0cmlidXRlcyk7XG5cbiAgICAgICAgICBpZiAoY3VyQ29zdCA8IG1pbkNvc3RzW21dKSB7XG4gICAgICAgICAgICBtaW5Db3N0c1ttXSA9IGN1ckNvc3Q7XG4gICAgICAgICAgICBtZWRvaWRzW21dID0gY2x1c3Rlcltfbl07XG4gICAgICAgICAgICBpc1N0aWxsTW92aW5nID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjbHVzdGVyc1ttXSA9IGN5LmNvbGxlY3Rpb24oY2x1c3Rlcik7XG4gICAgICB9XG5cbiAgICAgIGl0ZXJhdGlvbnMrKztcbiAgICB9XG5cbiAgICByZXR1cm4gY2x1c3RlcnM7XG4gIH07XG5cbiAgdmFyIHVwZGF0ZUNlbnRyb2lkcyA9IGZ1bmN0aW9uIHVwZGF0ZUNlbnRyb2lkcyhjZW50cm9pZHMsIG5vZGVzLCBVLCB3ZWlnaHQsIG9wdHMpIHtcbiAgICB2YXIgbnVtZXJhdG9yLCBkZW5vbWluYXRvcjtcblxuICAgIGZvciAodmFyIG4gPSAwOyBuIDwgbm9kZXMubGVuZ3RoOyBuKyspIHtcbiAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgY2VudHJvaWRzLmxlbmd0aDsgYysrKSB7XG4gICAgICAgIHdlaWdodFtuXVtjXSA9IE1hdGgucG93KFVbbl1bY10sIG9wdHMubSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2MgPSAwOyBfYyA8IGNlbnRyb2lkcy5sZW5ndGg7IF9jKyspIHtcbiAgICAgIGZvciAodmFyIGRpbSA9IDA7IGRpbSA8IG9wdHMuYXR0cmlidXRlcy5sZW5ndGg7IGRpbSsrKSB7XG4gICAgICAgIG51bWVyYXRvciA9IDA7XG4gICAgICAgIGRlbm9taW5hdG9yID0gMDtcblxuICAgICAgICBmb3IgKHZhciBfbjIgPSAwOyBfbjIgPCBub2Rlcy5sZW5ndGg7IF9uMisrKSB7XG4gICAgICAgICAgbnVtZXJhdG9yICs9IHdlaWdodFtfbjJdW19jXSAqIG9wdHMuYXR0cmlidXRlc1tkaW1dKG5vZGVzW19uMl0pO1xuICAgICAgICAgIGRlbm9taW5hdG9yICs9IHdlaWdodFtfbjJdW19jXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNlbnRyb2lkc1tfY11bZGltXSA9IG51bWVyYXRvciAvIGRlbm9taW5hdG9yO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgdXBkYXRlTWVtYmVyc2hpcCA9IGZ1bmN0aW9uIHVwZGF0ZU1lbWJlcnNoaXAoVSwgX1UsIGNlbnRyb2lkcywgbm9kZXMsIG9wdHMpIHtcbiAgICAvLyBTYXZlIHByZXZpb3VzIHN0ZXBcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IFUubGVuZ3RoOyBpKyspIHtcbiAgICAgIF9VW2ldID0gVVtpXS5zbGljZSgpO1xuICAgIH1cblxuICAgIHZhciBzdW0sIG51bWVyYXRvciwgZGVub21pbmF0b3I7XG4gICAgdmFyIHBvdyA9IDIgLyAob3B0cy5tIC0gMSk7XG5cbiAgICBmb3IgKHZhciBjID0gMDsgYyA8IGNlbnRyb2lkcy5sZW5ndGg7IGMrKykge1xuICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBub2Rlcy5sZW5ndGg7IG4rKykge1xuICAgICAgICBzdW0gPSAwO1xuXG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgY2VudHJvaWRzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgLy8gYWdhaW5zdCBhbGwgb3RoZXIgY2VudHJvaWRzXG4gICAgICAgICAgbnVtZXJhdG9yID0gZ2V0RGlzdChvcHRzLmRpc3RhbmNlLCBub2Rlc1tuXSwgY2VudHJvaWRzW2NdLCBvcHRzLmF0dHJpYnV0ZXMsICdjbWVhbnMnKTtcbiAgICAgICAgICBkZW5vbWluYXRvciA9IGdldERpc3Qob3B0cy5kaXN0YW5jZSwgbm9kZXNbbl0sIGNlbnRyb2lkc1trXSwgb3B0cy5hdHRyaWJ1dGVzLCAnY21lYW5zJyk7XG4gICAgICAgICAgc3VtICs9IE1hdGgucG93KG51bWVyYXRvciAvIGRlbm9taW5hdG9yLCBwb3cpO1xuICAgICAgICB9XG5cbiAgICAgICAgVVtuXVtjXSA9IDEgLyBzdW07XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBhc3NpZ24kMSA9IGZ1bmN0aW9uIGFzc2lnbihub2RlcywgVSwgb3B0cywgY3kpIHtcbiAgICB2YXIgY2x1c3RlcnMgPSBuZXcgQXJyYXkob3B0cy5rKTtcblxuICAgIGZvciAodmFyIGMgPSAwOyBjIDwgY2x1c3RlcnMubGVuZ3RoOyBjKyspIHtcbiAgICAgIGNsdXN0ZXJzW2NdID0gW107XG4gICAgfVxuXG4gICAgdmFyIG1heDtcbiAgICB2YXIgaW5kZXg7XG5cbiAgICBmb3IgKHZhciBuID0gMDsgbiA8IFUubGVuZ3RoOyBuKyspIHtcbiAgICAgIC8vIGZvciBlYWNoIG5vZGUgKFUgaXMgTiB4IEMgbWF0cml4KVxuICAgICAgbWF4ID0gLUluZmluaXR5O1xuICAgICAgaW5kZXggPSAtMTsgLy8gRGV0ZXJtaW5lIHdoaWNoIGNsdXN0ZXIgdGhlIG5vZGUgaXMgbW9zdCBsaWtlbHkgdG8gYmVsb25nIGluXG5cbiAgICAgIGZvciAodmFyIF9jMiA9IDA7IF9jMiA8IFVbMF0ubGVuZ3RoOyBfYzIrKykge1xuICAgICAgICBpZiAoVVtuXVtfYzJdID4gbWF4KSB7XG4gICAgICAgICAgbWF4ID0gVVtuXVtfYzJdO1xuICAgICAgICAgIGluZGV4ID0gX2MyO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNsdXN0ZXJzW2luZGV4XS5wdXNoKG5vZGVzW25dKTtcbiAgICB9IC8vIFR1cm4gZXZlcnkgYXJyYXkgaW50byBhIGNvbGxlY3Rpb24gb2Ygbm9kZXNcblxuXG4gICAgZm9yICh2YXIgX2MzID0gMDsgX2MzIDwgY2x1c3RlcnMubGVuZ3RoOyBfYzMrKykge1xuICAgICAgY2x1c3RlcnNbX2MzXSA9IGN5LmNvbGxlY3Rpb24oY2x1c3RlcnNbX2MzXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsdXN0ZXJzO1xuICB9O1xuXG4gIHZhciBmdXp6eUNNZWFucyA9IGZ1bmN0aW9uIGZ1enp5Q01lYW5zKG9wdGlvbnMpIHtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuICAgIHZhciBvcHRzID0gc2V0T3B0aW9ucyQyKG9wdGlvbnMpOyAvLyBCZWdpbiBmdXp6eSBjLW1lYW5zIGFsZ29yaXRobVxuXG4gICAgdmFyIGNsdXN0ZXJzO1xuICAgIHZhciBjZW50cm9pZHM7XG4gICAgdmFyIFU7XG5cbiAgICB2YXIgX1U7XG5cbiAgICB2YXIgd2VpZ2h0OyAvLyBTdGVwIDE6IEluaXRpYWxpemUgbGV0aWFibGVzLlxuXG4gICAgX1UgPSBuZXcgQXJyYXkobm9kZXMubGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIE4geCBDIG1hdHJpeFxuICAgICAgX1VbaV0gPSBuZXcgQXJyYXkob3B0cy5rKTtcbiAgICB9XG5cbiAgICBVID0gbmV3IEFycmF5KG5vZGVzLmxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBub2Rlcy5sZW5ndGg7IF9pMysrKSB7XG4gICAgICAvLyBOIHggQyBtYXRyaXhcbiAgICAgIFVbX2kzXSA9IG5ldyBBcnJheShvcHRzLmspO1xuICAgIH1cblxuICAgIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IG5vZGVzLmxlbmd0aDsgX2k0KyspIHtcbiAgICAgIHZhciB0b3RhbCA9IDA7XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgb3B0cy5rOyBqKyspIHtcbiAgICAgICAgVVtfaTRdW2pdID0gTWF0aC5yYW5kb20oKTtcbiAgICAgICAgdG90YWwgKz0gVVtfaTRdW2pdO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBfaiA9IDA7IF9qIDwgb3B0cy5rOyBfaisrKSB7XG4gICAgICAgIFVbX2k0XVtfal0gPSBVW19pNF1bX2pdIC8gdG90YWw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2VudHJvaWRzID0gbmV3IEFycmF5KG9wdHMuayk7XG5cbiAgICBmb3IgKHZhciBfaTUgPSAwOyBfaTUgPCBvcHRzLms7IF9pNSsrKSB7XG4gICAgICBjZW50cm9pZHNbX2k1XSA9IG5ldyBBcnJheShvcHRzLmF0dHJpYnV0ZXMubGVuZ3RoKTtcbiAgICB9XG5cbiAgICB3ZWlnaHQgPSBuZXcgQXJyYXkobm9kZXMubGVuZ3RoKTtcblxuICAgIGZvciAodmFyIF9pNiA9IDA7IF9pNiA8IG5vZGVzLmxlbmd0aDsgX2k2KyspIHtcbiAgICAgIC8vIE4geCBDIG1hdHJpeFxuICAgICAgd2VpZ2h0W19pNl0gPSBuZXcgQXJyYXkob3B0cy5rKTtcbiAgICB9IC8vIGVuZCBpbml0IEZDTVxuXG5cbiAgICB2YXIgaXNTdGlsbE1vdmluZyA9IHRydWU7XG4gICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuXG4gICAgd2hpbGUgKGlzU3RpbGxNb3ZpbmcgJiYgaXRlcmF0aW9ucyA8IG9wdHMubWF4SXRlcmF0aW9ucykge1xuICAgICAgaXNTdGlsbE1vdmluZyA9IGZhbHNlOyAvLyBTdGVwIDI6IENhbGN1bGF0ZSB0aGUgY2VudHJvaWRzIGZvciBlYWNoIHN0ZXAuXG5cbiAgICAgIHVwZGF0ZUNlbnRyb2lkcyhjZW50cm9pZHMsIG5vZGVzLCBVLCB3ZWlnaHQsIG9wdHMpOyAvLyBTdGVwIDM6IFVwZGF0ZSB0aGUgcGFydGl0aW9uIG1hdHJpeCBVLlxuXG4gICAgICB1cGRhdGVNZW1iZXJzaGlwKFUsIF9VLCBjZW50cm9pZHMsIG5vZGVzLCBvcHRzKTsgLy8gU3RlcCA0OiBDaGVjayBmb3IgY29udmVyZ2VuY2UuXG5cbiAgICAgIGlmICghaGF2ZU1hdHJpY2VzQ29udmVyZ2VkKFUsIF9VLCBvcHRzLnNlbnNpdGl2aXR5VGhyZXNob2xkKSkge1xuICAgICAgICBpc1N0aWxsTW92aW5nID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaXRlcmF0aW9ucysrO1xuICAgIH0gLy8gQXNzaWduIG5vZGVzIHRvIGNsdXN0ZXJzIHdpdGggaGlnaGVzdCBwcm9iYWJpbGl0eS5cblxuXG4gICAgY2x1c3RlcnMgPSBhc3NpZ24kMShub2RlcywgVSwgb3B0cywgY3kpO1xuICAgIHJldHVybiB7XG4gICAgICBjbHVzdGVyczogY2x1c3RlcnMsXG4gICAgICBkZWdyZWVPZk1lbWJlcnNoaXA6IFVcbiAgICB9O1xuICB9O1xuXG4gIHZhciBrQ2x1c3RlcmluZyA9IHtcbiAgICBrTWVhbnM6IGtNZWFucyxcbiAgICBrTWVkb2lkczoga01lZG9pZHMsXG4gICAgZnV6enlDTWVhbnM6IGZ1enp5Q01lYW5zLFxuICAgIGZjbTogZnV6enlDTWVhbnNcbiAgfTtcblxuICAvLyBJbXBsZW1lbnRlZCBieSBab2UgWGkgQHpvZXhpIGZvciBHU09DIDIwMTZcbiAgdmFyIGRlZmF1bHRzJGEgPSBkZWZhdWx0cyRnKHtcbiAgICBkaXN0YW5jZTogJ2V1Y2xpZGVhbicsXG4gICAgLy8gZGlzdGFuY2UgbWV0cmljIHRvIGNvbXBhcmUgbm9kZXNcbiAgICBsaW5rYWdlOiAnbWluJyxcbiAgICAvLyBsaW5rYWdlIGNyaXRlcmlvbiA6IGhvdyB0byBkZXRlcm1pbmUgdGhlIGRpc3RhbmNlIGJldHdlZW4gY2x1c3RlcnMgb2Ygbm9kZXNcbiAgICBtb2RlOiAndGhyZXNob2xkJyxcbiAgICAvLyBtb2RlOid0aHJlc2hvbGQnID0+IGNsdXN0ZXJzIG11c3QgYmUgdGhyZXNob2xkIGRpc3RhbmNlIGFwYXJ0XG4gICAgdGhyZXNob2xkOiBJbmZpbml0eSxcbiAgICAvLyB0aGUgZGlzdGFuY2UgdGhyZXNob2xkXG4gICAgLy8gbW9kZTonZGVuZHJvZ3JhbScgPT4gdGhlIG5vZGVzIGFyZSBvcmdhbmlzZWQgYXMgbGVhdmVzIGluIGEgdHJlZSAoc2libGluZ3MgYXJlIGNsb3NlKSwgbWVyZ2luZyBtYWtlcyBjbHVzdGVyc1xuICAgIGFkZERlbmRyb2dyYW06IGZhbHNlLFxuICAgIC8vIHdoZXRoZXIgdG8gYWRkIHRoZSBkZW5kcm9ncmFtIHRvIHRoZSBncmFwaCBmb3Igdml6XG4gICAgZGVuZHJvZ3JhbURlcHRoOiAwLFxuICAgIC8vIGRlcHRoIGF0IHdoaWNoIGRlbmRyb2dyYW0gYnJhbmNoZXMgYXJlIG1lcmdlZCBpbnRvIHRoZSByZXR1cm5lZCBjbHVzdGVyc1xuICAgIGF0dHJpYnV0ZXM6IFtdIC8vIGFycmF5IG9mIGF0dHIgZnVuY3Rpb25zXG5cbiAgfSk7XG4gIHZhciBsaW5rYWdlQWxpYXNlcyA9IHtcbiAgICAnc2luZ2xlJzogJ21pbicsXG4gICAgJ2NvbXBsZXRlJzogJ21heCdcbiAgfTtcblxuICB2YXIgc2V0T3B0aW9ucyQxID0gZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgdmFyIG9wdHMgPSBkZWZhdWx0cyRhKG9wdGlvbnMpO1xuICAgIHZhciBwcmVmZXJyZWRBbGlhcyA9IGxpbmthZ2VBbGlhc2VzW29wdHMubGlua2FnZV07XG5cbiAgICBpZiAocHJlZmVycmVkQWxpYXMgIT0gbnVsbCkge1xuICAgICAgb3B0cy5saW5rYWdlID0gcHJlZmVycmVkQWxpYXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9wdHM7XG4gIH07XG5cbiAgdmFyIG1lcmdlQ2xvc2VzdCA9IGZ1bmN0aW9uIG1lcmdlQ2xvc2VzdChjbHVzdGVycywgaW5kZXgsIGRpc3RzLCBtaW5zLCBvcHRzKSB7XG4gICAgLy8gRmluZCB0d28gY2xvc2VzdCBjbHVzdGVycyBmcm9tIGNhY2hlZCBtaW5zXG4gICAgdmFyIG1pbktleSA9IDA7XG4gICAgdmFyIG1pbiA9IEluZmluaXR5O1xuICAgIHZhciBkaXN0O1xuICAgIHZhciBhdHRycyA9IG9wdHMuYXR0cmlidXRlcztcblxuICAgIHZhciBnZXREaXN0ID0gZnVuY3Rpb24gZ2V0RGlzdChuMSwgbjIpIHtcbiAgICAgIHJldHVybiBjbHVzdGVyaW5nRGlzdGFuY2Uob3B0cy5kaXN0YW5jZSwgYXR0cnMubGVuZ3RoLCBmdW5jdGlvbiAoaSkge1xuICAgICAgICByZXR1cm4gYXR0cnNbaV0objEpO1xuICAgICAgfSwgZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgcmV0dXJuIGF0dHJzW2ldKG4yKTtcbiAgICAgIH0sIG4xLCBuMik7XG4gICAgfTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2x1c3RlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBjbHVzdGVyc1tpXS5rZXk7XG4gICAgICB2YXIgX2Rpc3QgPSBkaXN0c1trZXldW21pbnNba2V5XV07XG5cbiAgICAgIGlmIChfZGlzdCA8IG1pbikge1xuICAgICAgICBtaW5LZXkgPSBrZXk7XG4gICAgICAgIG1pbiA9IF9kaXN0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvcHRzLm1vZGUgPT09ICd0aHJlc2hvbGQnICYmIG1pbiA+PSBvcHRzLnRocmVzaG9sZCB8fCBvcHRzLm1vZGUgPT09ICdkZW5kcm9ncmFtJyAmJiBjbHVzdGVycy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgYzEgPSBpbmRleFttaW5LZXldO1xuICAgIHZhciBjMiA9IGluZGV4W21pbnNbbWluS2V5XV07XG4gICAgdmFyIG1lcmdlZDsgLy8gTWVyZ2UgdHdvIGNsb3Nlc3QgY2x1c3RlcnNcblxuICAgIGlmIChvcHRzLm1vZGUgPT09ICdkZW5kcm9ncmFtJykge1xuICAgICAgbWVyZ2VkID0ge1xuICAgICAgICBsZWZ0OiBjMSxcbiAgICAgICAgcmlnaHQ6IGMyLFxuICAgICAgICBrZXk6IGMxLmtleVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWVyZ2VkID0ge1xuICAgICAgICB2YWx1ZTogYzEudmFsdWUuY29uY2F0KGMyLnZhbHVlKSxcbiAgICAgICAga2V5OiBjMS5rZXlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY2x1c3RlcnNbYzEuaW5kZXhdID0gbWVyZ2VkO1xuICAgIGNsdXN0ZXJzLnNwbGljZShjMi5pbmRleCwgMSk7XG4gICAgaW5kZXhbYzEua2V5XSA9IG1lcmdlZDsgLy8gVXBkYXRlIGRpc3RhbmNlcyB3aXRoIG5ldyBtZXJnZWQgY2x1c3RlclxuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGNsdXN0ZXJzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIGN1ciA9IGNsdXN0ZXJzW19pXTtcblxuICAgICAgaWYgKGMxLmtleSA9PT0gY3VyLmtleSkge1xuICAgICAgICBkaXN0ID0gSW5maW5pdHk7XG4gICAgICB9IGVsc2UgaWYgKG9wdHMubGlua2FnZSA9PT0gJ21pbicpIHtcbiAgICAgICAgZGlzdCA9IGRpc3RzW2MxLmtleV1bY3VyLmtleV07XG5cbiAgICAgICAgaWYgKGRpc3RzW2MxLmtleV1bY3VyLmtleV0gPiBkaXN0c1tjMi5rZXldW2N1ci5rZXldKSB7XG4gICAgICAgICAgZGlzdCA9IGRpc3RzW2MyLmtleV1bY3VyLmtleV07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAob3B0cy5saW5rYWdlID09PSAnbWF4Jykge1xuICAgICAgICBkaXN0ID0gZGlzdHNbYzEua2V5XVtjdXIua2V5XTtcblxuICAgICAgICBpZiAoZGlzdHNbYzEua2V5XVtjdXIua2V5XSA8IGRpc3RzW2MyLmtleV1bY3VyLmtleV0pIHtcbiAgICAgICAgICBkaXN0ID0gZGlzdHNbYzIua2V5XVtjdXIua2V5XTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChvcHRzLmxpbmthZ2UgPT09ICdtZWFuJykge1xuICAgICAgICBkaXN0ID0gKGRpc3RzW2MxLmtleV1bY3VyLmtleV0gKiBjMS5zaXplICsgZGlzdHNbYzIua2V5XVtjdXIua2V5XSAqIGMyLnNpemUpIC8gKGMxLnNpemUgKyBjMi5zaXplKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChvcHRzLm1vZGUgPT09ICdkZW5kcm9ncmFtJykgZGlzdCA9IGdldERpc3QoY3VyLnZhbHVlLCBjMS52YWx1ZSk7ZWxzZSBkaXN0ID0gZ2V0RGlzdChjdXIudmFsdWVbMF0sIGMxLnZhbHVlWzBdKTtcbiAgICAgIH1cblxuICAgICAgZGlzdHNbYzEua2V5XVtjdXIua2V5XSA9IGRpc3RzW2N1ci5rZXldW2MxLmtleV0gPSBkaXN0OyAvLyBkaXN0YW5jZSBtYXRyaXggaXMgc3ltbWV0cmljXG4gICAgfSAvLyBVcGRhdGUgY2FjaGVkIG1pbnNcblxuXG4gICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgY2x1c3RlcnMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgdmFyIGtleTEgPSBjbHVzdGVyc1tfaTJdLmtleTtcblxuICAgICAgaWYgKG1pbnNba2V5MV0gPT09IGMxLmtleSB8fCBtaW5zW2tleTFdID09PSBjMi5rZXkpIHtcbiAgICAgICAgdmFyIF9taW4gPSBrZXkxO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2x1c3RlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB2YXIga2V5MiA9IGNsdXN0ZXJzW2pdLmtleTtcblxuICAgICAgICAgIGlmIChkaXN0c1trZXkxXVtrZXkyXSA8IGRpc3RzW2tleTFdW19taW5dKSB7XG4gICAgICAgICAgICBfbWluID0ga2V5MjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBtaW5zW2tleTFdID0gX21pbjtcbiAgICAgIH1cblxuICAgICAgY2x1c3RlcnNbX2kyXS5pbmRleCA9IF9pMjtcbiAgICB9IC8vIENsZWFuIHVwIG1ldGEgZGF0YSB1c2VkIGZvciBjbHVzdGVyaW5nXG5cblxuICAgIGMxLmtleSA9IGMyLmtleSA9IGMxLmluZGV4ID0gYzIuaW5kZXggPSBudWxsO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIHZhciBnZXRBbGxDaGlsZHJlbiA9IGZ1bmN0aW9uIGdldEFsbENoaWxkcmVuKHJvb3QsIGFyciwgY3kpIHtcbiAgICBpZiAoIXJvb3QpIHJldHVybjtcblxuICAgIGlmIChyb290LnZhbHVlKSB7XG4gICAgICBhcnIucHVzaChyb290LnZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHJvb3QubGVmdCkgZ2V0QWxsQ2hpbGRyZW4ocm9vdC5sZWZ0LCBhcnIpO1xuICAgICAgaWYgKHJvb3QucmlnaHQpIGdldEFsbENoaWxkcmVuKHJvb3QucmlnaHQsIGFycik7XG4gICAgfVxuICB9O1xuXG4gIHZhciBidWlsZERlbmRyb2dyYW0gPSBmdW5jdGlvbiBidWlsZERlbmRyb2dyYW0ocm9vdCwgY3kpIHtcbiAgICBpZiAoIXJvb3QpIHJldHVybiAnJztcblxuICAgIGlmIChyb290LmxlZnQgJiYgcm9vdC5yaWdodCkge1xuICAgICAgdmFyIGxlZnRTdHIgPSBidWlsZERlbmRyb2dyYW0ocm9vdC5sZWZ0LCBjeSk7XG4gICAgICB2YXIgcmlnaHRTdHIgPSBidWlsZERlbmRyb2dyYW0ocm9vdC5yaWdodCwgY3kpO1xuICAgICAgdmFyIG5vZGUgPSBjeS5hZGQoe1xuICAgICAgICBncm91cDogJ25vZGVzJyxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGlkOiBsZWZ0U3RyICsgJywnICsgcmlnaHRTdHJcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjeS5hZGQoe1xuICAgICAgICBncm91cDogJ2VkZ2VzJyxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHNvdXJjZTogbGVmdFN0cixcbiAgICAgICAgICB0YXJnZXQ6IG5vZGUuaWQoKVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGN5LmFkZCh7XG4gICAgICAgIGdyb3VwOiAnZWRnZXMnLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgc291cmNlOiByaWdodFN0cixcbiAgICAgICAgICB0YXJnZXQ6IG5vZGUuaWQoKVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBub2RlLmlkKCk7XG4gICAgfSBlbHNlIGlmIChyb290LnZhbHVlKSB7XG4gICAgICByZXR1cm4gcm9vdC52YWx1ZS5pZCgpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgYnVpbGRDbHVzdGVyc0Zyb21UcmVlID0gZnVuY3Rpb24gYnVpbGRDbHVzdGVyc0Zyb21UcmVlKHJvb3QsIGssIGN5KSB7XG4gICAgaWYgKCFyb290KSByZXR1cm4gW107XG4gICAgdmFyIGxlZnQgPSBbXSxcbiAgICAgICAgcmlnaHQgPSBbXSxcbiAgICAgICAgbGVhdmVzID0gW107XG5cbiAgICBpZiAoayA9PT0gMCkge1xuICAgICAgLy8gZG9uJ3QgY3V0IHRyZWUsIHNpbXBseSByZXR1cm4gYWxsIG5vZGVzIGFzIDEgc2luZ2xlIGNsdXN0ZXJcbiAgICAgIGlmIChyb290LmxlZnQpIGdldEFsbENoaWxkcmVuKHJvb3QubGVmdCwgbGVmdCk7XG4gICAgICBpZiAocm9vdC5yaWdodCkgZ2V0QWxsQ2hpbGRyZW4ocm9vdC5yaWdodCwgcmlnaHQpO1xuICAgICAgbGVhdmVzID0gbGVmdC5jb25jYXQocmlnaHQpO1xuICAgICAgcmV0dXJuIFtjeS5jb2xsZWN0aW9uKGxlYXZlcyldO1xuICAgIH0gZWxzZSBpZiAoayA9PT0gMSkge1xuICAgICAgLy8gY3V0IGF0IHJvb3RcbiAgICAgIGlmIChyb290LnZhbHVlKSB7XG4gICAgICAgIC8vIGxlYWYgbm9kZVxuICAgICAgICByZXR1cm4gW2N5LmNvbGxlY3Rpb24ocm9vdC52YWx1ZSldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHJvb3QubGVmdCkgZ2V0QWxsQ2hpbGRyZW4ocm9vdC5sZWZ0LCBsZWZ0KTtcbiAgICAgICAgaWYgKHJvb3QucmlnaHQpIGdldEFsbENoaWxkcmVuKHJvb3QucmlnaHQsIHJpZ2h0KTtcbiAgICAgICAgcmV0dXJuIFtjeS5jb2xsZWN0aW9uKGxlZnQpLCBjeS5jb2xsZWN0aW9uKHJpZ2h0KV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChyb290LnZhbHVlKSB7XG4gICAgICAgIHJldHVybiBbY3kuY29sbGVjdGlvbihyb290LnZhbHVlKV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocm9vdC5sZWZ0KSBsZWZ0ID0gYnVpbGRDbHVzdGVyc0Zyb21UcmVlKHJvb3QubGVmdCwgayAtIDEsIGN5KTtcbiAgICAgICAgaWYgKHJvb3QucmlnaHQpIHJpZ2h0ID0gYnVpbGRDbHVzdGVyc0Zyb21UcmVlKHJvb3QucmlnaHQsIGsgLSAxLCBjeSk7XG4gICAgICAgIHJldHVybiBsZWZ0LmNvbmNhdChyaWdodCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvKiBlc2xpbnQtZW5hYmxlICovXG5cblxuICB2YXIgaGllcmFyY2hpY2FsQ2x1c3RlcmluZyA9IGZ1bmN0aW9uIGhpZXJhcmNoaWNhbENsdXN0ZXJpbmcob3B0aW9ucykge1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7IC8vIFNldCBwYXJhbWV0ZXJzIG9mIGFsZ29yaXRobTogbGlua2FnZSB0eXBlLCBkaXN0YW5jZSBtZXRyaWMsIGV0Yy5cblxuICAgIHZhciBvcHRzID0gc2V0T3B0aW9ucyQxKG9wdGlvbnMpO1xuICAgIHZhciBhdHRycyA9IG9wdHMuYXR0cmlidXRlcztcblxuICAgIHZhciBnZXREaXN0ID0gZnVuY3Rpb24gZ2V0RGlzdChuMSwgbjIpIHtcbiAgICAgIHJldHVybiBjbHVzdGVyaW5nRGlzdGFuY2Uob3B0cy5kaXN0YW5jZSwgYXR0cnMubGVuZ3RoLCBmdW5jdGlvbiAoaSkge1xuICAgICAgICByZXR1cm4gYXR0cnNbaV0objEpO1xuICAgICAgfSwgZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgcmV0dXJuIGF0dHJzW2ldKG4yKTtcbiAgICAgIH0sIG4xLCBuMik7XG4gICAgfTsgLy8gQmVnaW4gaGllcmFyY2hpY2FsIGFsZ29yaXRobVxuXG5cbiAgICB2YXIgY2x1c3RlcnMgPSBbXTtcbiAgICB2YXIgZGlzdHMgPSBbXTsgLy8gZGlzdGFuY2VzIGJldHdlZW4gZWFjaCBwYWlyIG9mIGNsdXN0ZXJzXG5cbiAgICB2YXIgbWlucyA9IFtdOyAvLyBjbG9zZXN0IGNsdXN0ZXIgZm9yIGVhY2ggY2x1c3RlclxuXG4gICAgdmFyIGluZGV4ID0gW107IC8vIGhhc2ggb2YgYWxsIGNsdXN0ZXJzIGJ5IGtleVxuICAgIC8vIEluIGFnZ2xvbWVyYXRpdmUgKGJvdHRvbS11cCkgY2x1c3RlcmluZywgZWFjaCBub2RlIHN0YXJ0cyBhcyBpdHMgb3duIGNsdXN0ZXJcblxuICAgIGZvciAodmFyIG4gPSAwOyBuIDwgbm9kZXMubGVuZ3RoOyBuKyspIHtcbiAgICAgIHZhciBjbHVzdGVyID0ge1xuICAgICAgICB2YWx1ZTogb3B0cy5tb2RlID09PSAnZGVuZHJvZ3JhbScgPyBub2Rlc1tuXSA6IFtub2Rlc1tuXV0sXG4gICAgICAgIGtleTogbixcbiAgICAgICAgaW5kZXg6IG5cbiAgICAgIH07XG4gICAgICBjbHVzdGVyc1tuXSA9IGNsdXN0ZXI7XG4gICAgICBpbmRleFtuXSA9IGNsdXN0ZXI7XG4gICAgICBkaXN0c1tuXSA9IFtdO1xuICAgICAgbWluc1tuXSA9IDA7XG4gICAgfSAvLyBDYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGJldHdlZW4gZWFjaCBwYWlyIG9mIGNsdXN0ZXJzXG5cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2x1c3RlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDw9IGk7IGorKykge1xuICAgICAgICB2YXIgZGlzdCA9IHZvaWQgMDtcblxuICAgICAgICBpZiAob3B0cy5tb2RlID09PSAnZGVuZHJvZ3JhbScpIHtcbiAgICAgICAgICAvLyBtb2RlcyBzdG9yZSBjbHVzdGVyIHZhbHVlcyBkaWZmZXJlbnRseVxuICAgICAgICAgIGRpc3QgPSBpID09PSBqID8gSW5maW5pdHkgOiBnZXREaXN0KGNsdXN0ZXJzW2ldLnZhbHVlLCBjbHVzdGVyc1tqXS52YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGlzdCA9IGkgPT09IGogPyBJbmZpbml0eSA6IGdldERpc3QoY2x1c3RlcnNbaV0udmFsdWVbMF0sIGNsdXN0ZXJzW2pdLnZhbHVlWzBdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRpc3RzW2ldW2pdID0gZGlzdDtcbiAgICAgICAgZGlzdHNbal1baV0gPSBkaXN0O1xuXG4gICAgICAgIGlmIChkaXN0IDwgZGlzdHNbaV1bbWluc1tpXV0pIHtcbiAgICAgICAgICBtaW5zW2ldID0gajsgLy8gQ2FjaGUgbWluczogY2xvc2VzdCBjbHVzdGVyIHRvIGNsdXN0ZXIgaSBpcyBjbHVzdGVyIGpcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gRmluZCB0aGUgY2xvc2VzdCBwYWlyIG9mIGNsdXN0ZXJzIGFuZCBtZXJnZSB0aGVtIGludG8gYSBzaW5nbGUgY2x1c3Rlci5cbiAgICAvLyBVcGRhdGUgZGlzdGFuY2VzIGJldHdlZW4gbmV3IGNsdXN0ZXIgYW5kIGVhY2ggb2YgdGhlIG9sZCBjbHVzdGVycywgYW5kIGxvb3AgdW50aWwgdGhyZXNob2xkIHJlYWNoZWQuXG5cblxuICAgIHZhciBtZXJnZWQgPSBtZXJnZUNsb3Nlc3QoY2x1c3RlcnMsIGluZGV4LCBkaXN0cywgbWlucywgb3B0cyk7XG5cbiAgICB3aGlsZSAobWVyZ2VkKSB7XG4gICAgICBtZXJnZWQgPSBtZXJnZUNsb3Nlc3QoY2x1c3RlcnMsIGluZGV4LCBkaXN0cywgbWlucywgb3B0cyk7XG4gICAgfVxuXG4gICAgdmFyIHJldENsdXN0ZXJzOyAvLyBEZW5kcm9ncmFtIG1vZGUgYnVpbGRzIHRoZSBoaWVyYXJjaHkgYW5kIGFkZHMgaW50ZXJtZWRpYXJ5IG5vZGVzICsgZWRnZXNcbiAgICAvLyBpbiBhZGRpdGlvbiB0byByZXR1cm5pbmcgdGhlIGNsdXN0ZXJzLlxuXG4gICAgaWYgKG9wdHMubW9kZSA9PT0gJ2RlbmRyb2dyYW0nKSB7XG4gICAgICByZXRDbHVzdGVycyA9IGJ1aWxkQ2x1c3RlcnNGcm9tVHJlZShjbHVzdGVyc1swXSwgb3B0cy5kZW5kcm9ncmFtRGVwdGgsIGN5KTtcbiAgICAgIGlmIChvcHRzLmFkZERlbmRyb2dyYW0pIGJ1aWxkRGVuZHJvZ3JhbShjbHVzdGVyc1swXSwgY3kpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZWd1bGFyIG1vZGUgc2ltcGx5IHJldHVybnMgdGhlIGNsdXN0ZXJzXG4gICAgICByZXRDbHVzdGVycyA9IG5ldyBBcnJheShjbHVzdGVycy5sZW5ndGgpO1xuICAgICAgY2x1c3RlcnMuZm9yRWFjaChmdW5jdGlvbiAoY2x1c3RlciwgaSkge1xuICAgICAgICAvLyBDbGVhbiB1cCBtZXRhIGRhdGEgdXNlZCBmb3IgY2x1c3RlcmluZ1xuICAgICAgICBjbHVzdGVyLmtleSA9IGNsdXN0ZXIuaW5kZXggPSBudWxsO1xuICAgICAgICByZXRDbHVzdGVyc1tpXSA9IGN5LmNvbGxlY3Rpb24oY2x1c3Rlci52YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0Q2x1c3RlcnM7XG4gIH07XG5cbiAgdmFyIGhpZXJhcmNoaWNhbENsdXN0ZXJpbmckMSA9IHtcbiAgICBoaWVyYXJjaGljYWxDbHVzdGVyaW5nOiBoaWVyYXJjaGljYWxDbHVzdGVyaW5nLFxuICAgIGhjYTogaGllcmFyY2hpY2FsQ2x1c3RlcmluZ1xuICB9O1xuXG4gIC8vIEltcGxlbWVudGVkIGJ5IFpvZSBYaSBAem9leGkgZm9yIEdTT0MgMjAxNlxuICB2YXIgZGVmYXVsdHMkOSA9IGRlZmF1bHRzJGcoe1xuICAgIGRpc3RhbmNlOiAnZXVjbGlkZWFuJyxcbiAgICAvLyBkaXN0YW5jZSBtZXRyaWMgdG8gY29tcGFyZSBhdHRyaWJ1dGVzIGJldHdlZW4gdHdvIG5vZGVzXG4gICAgcHJlZmVyZW5jZTogJ21lZGlhbicsXG4gICAgLy8gc3VpdGFiaWxpdHkgb2YgYSBkYXRhIHBvaW50IHRvIHNlcnZlIGFzIGFuIGV4ZW1wbGFyXG4gICAgZGFtcGluZzogMC44LFxuICAgIC8vIGRhbXBpbmcgZmFjdG9yIGJldHdlZW4gWzAuNSwgMSlcbiAgICBtYXhJdGVyYXRpb25zOiAxMDAwLFxuICAgIC8vIG1heCBudW1iZXIgb2YgaXRlcmF0aW9ucyB0byBydW5cbiAgICBtaW5JdGVyYXRpb25zOiAxMDAsXG4gICAgLy8gbWluIG51bWJlciBvZiBpdGVyYXRpb25zIHRvIHJ1biBpbiBvcmRlciBmb3IgY2x1c3RlcmluZyB0byBzdG9wXG4gICAgYXR0cmlidXRlczogWy8vIGZ1bmN0aW9ucyB0byBxdWFudGlmeSB0aGUgc2ltaWxhcml0eSBiZXR3ZWVuIGFueSB0d28gcG9pbnRzXG4gICAgICAvLyBlLmcuIG5vZGUgPT4gbm9kZS5kYXRhKCd3ZWlnaHQnKVxuICAgIF1cbiAgfSk7XG5cbiAgdmFyIHNldE9wdGlvbnMgPSBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICB2YXIgZG1wID0gb3B0aW9ucy5kYW1waW5nO1xuICAgIHZhciBwcmVmID0gb3B0aW9ucy5wcmVmZXJlbmNlO1xuXG4gICAgaWYgKCEoMC41IDw9IGRtcCAmJiBkbXAgPCAxKSkge1xuICAgICAgZXJyb3IoXCJEYW1waW5nIG11c3QgcmFuZ2Ugb24gWzAuNSwgMSkuICBHb3Q6IFwiLmNvbmNhdChkbXApKTtcbiAgICB9XG5cbiAgICB2YXIgdmFsaWRQcmVmcyA9IFsnbWVkaWFuJywgJ21lYW4nLCAnbWluJywgJ21heCddO1xuXG4gICAgaWYgKCEodmFsaWRQcmVmcy5zb21lKGZ1bmN0aW9uICh2KSB7XG4gICAgICByZXR1cm4gdiA9PT0gcHJlZjtcbiAgICB9KSB8fCBudW1iZXIkMShwcmVmKSkpIHtcbiAgICAgIGVycm9yKFwiUHJlZmVyZW5jZSBtdXN0IGJlIG9uZSBvZiBbXCIuY29uY2F0KHZhbGlkUHJlZnMubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHJldHVybiBcIidcIi5jb25jYXQocCwgXCInXCIpO1xuICAgICAgfSkuam9pbignLCAnKSwgXCJdIG9yIGEgbnVtYmVyLiAgR290OiBcIikuY29uY2F0KHByZWYpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVmYXVsdHMkOShvcHRpb25zKTtcbiAgfTtcbiAgLyogZXNsaW50LWVuYWJsZSAqL1xuXG5cbiAgdmFyIGdldFNpbWlsYXJpdHkgPSBmdW5jdGlvbiBnZXRTaW1pbGFyaXR5KHR5cGUsIG4xLCBuMiwgYXR0cmlidXRlcykge1xuICAgIHZhciBhdHRyID0gZnVuY3Rpb24gYXR0cihuLCBpKSB7XG4gICAgICByZXR1cm4gYXR0cmlidXRlc1tpXShuKTtcbiAgICB9OyAvLyBuYiBuZWdhdGl2ZSBiZWNhdXNlIHNpbWlsYXJpdHkgc2hvdWxkIGhhdmUgYW4gaW52ZXJzZSByZWxhdGlvbnNoaXAgdG8gZGlzdGFuY2VcblxuXG4gICAgcmV0dXJuIC1jbHVzdGVyaW5nRGlzdGFuY2UodHlwZSwgYXR0cmlidXRlcy5sZW5ndGgsIGZ1bmN0aW9uIChpKSB7XG4gICAgICByZXR1cm4gYXR0cihuMSwgaSk7XG4gICAgfSwgZnVuY3Rpb24gKGkpIHtcbiAgICAgIHJldHVybiBhdHRyKG4yLCBpKTtcbiAgICB9LCBuMSwgbjIpO1xuICB9O1xuXG4gIHZhciBnZXRQcmVmZXJlbmNlID0gZnVuY3Rpb24gZ2V0UHJlZmVyZW5jZShTLCBwcmVmZXJlbmNlKSB7XG4gICAgLy8gbGFyZ2VyIHByZWZlcmVuY2UgPSBncmVhdGVyICMgb2YgY2x1c3RlcnNcbiAgICB2YXIgcCA9IG51bGw7XG5cbiAgICBpZiAocHJlZmVyZW5jZSA9PT0gJ21lZGlhbicpIHtcbiAgICAgIHAgPSBtZWRpYW4oUyk7XG4gICAgfSBlbHNlIGlmIChwcmVmZXJlbmNlID09PSAnbWVhbicpIHtcbiAgICAgIHAgPSBtZWFuKFMpO1xuICAgIH0gZWxzZSBpZiAocHJlZmVyZW5jZSA9PT0gJ21pbicpIHtcbiAgICAgIHAgPSBtaW4oUyk7XG4gICAgfSBlbHNlIGlmIChwcmVmZXJlbmNlID09PSAnbWF4Jykge1xuICAgICAgcCA9IG1heChTKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ3VzdG9tIHByZWZlcmVuY2UgbnVtYmVyLCBhcyBzZXQgYnkgdXNlclxuICAgICAgcCA9IHByZWZlcmVuY2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHA7XG4gIH07XG5cbiAgdmFyIGZpbmRFeGVtcGxhcnMgPSBmdW5jdGlvbiBmaW5kRXhlbXBsYXJzKG4sIFIsIEEpIHtcbiAgICB2YXIgaW5kaWNlcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgIGlmIChSW2kgKiBuICsgaV0gKyBBW2kgKiBuICsgaV0gPiAwKSB7XG4gICAgICAgIGluZGljZXMucHVzaChpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5kaWNlcztcbiAgfTtcblxuICB2YXIgYXNzaWduQ2x1c3RlcnMgPSBmdW5jdGlvbiBhc3NpZ25DbHVzdGVycyhuLCBTLCBleGVtcGxhcnMpIHtcbiAgICB2YXIgY2x1c3RlcnMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgIHZhciBtYXggPSAtSW5maW5pdHk7XG5cbiAgICAgIGZvciAodmFyIGVpID0gMDsgZWkgPCBleGVtcGxhcnMubGVuZ3RoOyBlaSsrKSB7XG4gICAgICAgIHZhciBlID0gZXhlbXBsYXJzW2VpXTtcblxuICAgICAgICBpZiAoU1tpICogbiArIGVdID4gbWF4KSB7XG4gICAgICAgICAgaW5kZXggPSBlO1xuICAgICAgICAgIG1heCA9IFNbaSAqIG4gKyBlXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaW5kZXggPiAwKSB7XG4gICAgICAgIGNsdXN0ZXJzLnB1c2goaW5kZXgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIF9laSA9IDA7IF9laSA8IGV4ZW1wbGFycy5sZW5ndGg7IF9laSsrKSB7XG4gICAgICBjbHVzdGVyc1tleGVtcGxhcnNbX2VpXV0gPSBleGVtcGxhcnNbX2VpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2x1c3RlcnM7XG4gIH07XG5cbiAgdmFyIGFzc2lnbiA9IGZ1bmN0aW9uIGFzc2lnbihuLCBTLCBleGVtcGxhcnMpIHtcbiAgICB2YXIgY2x1c3RlcnMgPSBhc3NpZ25DbHVzdGVycyhuLCBTLCBleGVtcGxhcnMpO1xuXG4gICAgZm9yICh2YXIgZWkgPSAwOyBlaSA8IGV4ZW1wbGFycy5sZW5ndGg7IGVpKyspIHtcbiAgICAgIHZhciBpaSA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBjID0gMDsgYyA8IGNsdXN0ZXJzLmxlbmd0aDsgYysrKSB7XG4gICAgICAgIGlmIChjbHVzdGVyc1tjXSA9PT0gZXhlbXBsYXJzW2VpXSkge1xuICAgICAgICAgIGlpLnB1c2goYyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIG1heEkgPSAtMTtcbiAgICAgIHZhciBtYXhTdW0gPSAtSW5maW5pdHk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHN1bSA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBpaS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHN1bSArPSBTW2lpW2pdICogbiArIGlpW2ldXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdW0gPiBtYXhTdW0pIHtcbiAgICAgICAgICBtYXhJID0gaTtcbiAgICAgICAgICBtYXhTdW0gPSBzdW07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZXhlbXBsYXJzW2VpXSA9IGlpW21heEldO1xuICAgIH1cblxuICAgIGNsdXN0ZXJzID0gYXNzaWduQ2x1c3RlcnMobiwgUywgZXhlbXBsYXJzKTtcbiAgICByZXR1cm4gY2x1c3RlcnM7XG4gIH07XG5cbiAgdmFyIGFmZmluaXR5UHJvcGFnYXRpb24gPSBmdW5jdGlvbiBhZmZpbml0eVByb3BhZ2F0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuICAgIHZhciBvcHRzID0gc2V0T3B0aW9ucyhvcHRpb25zKTsgLy8gTWFwIGVhY2ggbm9kZSB0byBpdHMgcG9zaXRpb24gaW4gbm9kZSBhcnJheVxuXG4gICAgdmFyIGlkMnBvc2l0aW9uID0ge307XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZDJwb3NpdGlvbltub2Rlc1tpXS5pZCgpXSA9IGk7XG4gICAgfSAvLyBCZWdpbiBhZmZpbml0eSBwcm9wYWdhdGlvbiBhbGdvcml0aG1cblxuXG4gICAgdmFyIG47IC8vIG51bWJlciBvZiBkYXRhIHBvaW50c1xuXG4gICAgdmFyIG4yOyAvLyBzaXplIG9mIG1hdHJpY2VzXG5cbiAgICB2YXIgUzsgLy8gc2ltaWxhcml0eSBtYXRyaXggKDFEIGFycmF5KVxuXG4gICAgdmFyIHA7IC8vIHByZWZlcmVuY2Uvc3VpdGFiaWxpdHkgb2YgYSBkYXRhIHBvaW50IHRvIHNlcnZlIGFzIGFuIGV4ZW1wbGFyXG5cbiAgICB2YXIgUjsgLy8gcmVzcG9uc2liaWxpdHkgbWF0cml4ICgxRCBhcnJheSlcblxuICAgIHZhciBBOyAvLyBhdmFpbGFiaWxpdHkgbWF0cml4ICgxRCBhcnJheSlcblxuICAgIG4gPSBub2Rlcy5sZW5ndGg7XG4gICAgbjIgPSBuICogbjsgLy8gSW5pdGlhbGl6ZSBhbmQgYnVpbGQgUyBzaW1pbGFyaXR5IG1hdHJpeFxuXG4gICAgUyA9IG5ldyBBcnJheShuMik7XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbjI7IF9pKyspIHtcbiAgICAgIFNbX2ldID0gLUluZmluaXR5OyAvLyBmb3IgY2FzZXMgd2hlcmUgdHdvIGRhdGEgcG9pbnRzIHNob3VsZG4ndCBiZSBsaW5rZWQgdG9nZXRoZXJcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBuOyBfaTIrKykge1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBuOyBqKyspIHtcbiAgICAgICAgaWYgKF9pMiAhPT0gaikge1xuICAgICAgICAgIFNbX2kyICogbiArIGpdID0gZ2V0U2ltaWxhcml0eShvcHRzLmRpc3RhbmNlLCBub2Rlc1tfaTJdLCBub2Rlc1tqXSwgb3B0cy5hdHRyaWJ1dGVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gUGxhY2UgcHJlZmVyZW5jZXMgb24gdGhlIGRpYWdvbmFsIG9mIFNcblxuXG4gICAgcCA9IGdldFByZWZlcmVuY2UoUywgb3B0cy5wcmVmZXJlbmNlKTtcblxuICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IG47IF9pMysrKSB7XG4gICAgICBTW19pMyAqIG4gKyBfaTNdID0gcDtcbiAgICB9IC8vIEluaXRpYWxpemUgUiByZXNwb25zaWJpbGl0eSBtYXRyaXhcblxuXG4gICAgUiA9IG5ldyBBcnJheShuMik7XG5cbiAgICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBuMjsgX2k0KyspIHtcbiAgICAgIFJbX2k0XSA9IDAuMDtcbiAgICB9IC8vIEluaXRpYWxpemUgQSBhdmFpbGFiaWxpdHkgbWF0cml4XG5cblxuICAgIEEgPSBuZXcgQXJyYXkobjIpO1xuXG4gICAgZm9yICh2YXIgX2k1ID0gMDsgX2k1IDwgbjI7IF9pNSsrKSB7XG4gICAgICBBW19pNV0gPSAwLjA7XG4gICAgfVxuXG4gICAgdmFyIG9sZCA9IG5ldyBBcnJheShuKTtcbiAgICB2YXIgUnAgPSBuZXcgQXJyYXkobik7XG4gICAgdmFyIHNlID0gbmV3IEFycmF5KG4pO1xuXG4gICAgZm9yICh2YXIgX2k2ID0gMDsgX2k2IDwgbjsgX2k2KyspIHtcbiAgICAgIG9sZFtfaTZdID0gMC4wO1xuICAgICAgUnBbX2k2XSA9IDAuMDtcbiAgICAgIHNlW19pNl0gPSAwO1xuICAgIH1cblxuICAgIHZhciBlID0gbmV3IEFycmF5KG4gKiBvcHRzLm1pbkl0ZXJhdGlvbnMpO1xuXG4gICAgZm9yICh2YXIgX2k3ID0gMDsgX2k3IDwgZS5sZW5ndGg7IF9pNysrKSB7XG4gICAgICBlW19pN10gPSAwO1xuICAgIH1cblxuICAgIHZhciBpdGVyO1xuXG4gICAgZm9yIChpdGVyID0gMDsgaXRlciA8IG9wdHMubWF4SXRlcmF0aW9uczsgaXRlcisrKSB7XG4gICAgICAvLyBtYWluIGFsZ29yaXRobWljIGxvb3BcbiAgICAgIC8vIFVwZGF0ZSBSIHJlc3BvbnNpYmlsaXR5IG1hdHJpeFxuICAgICAgZm9yICh2YXIgX2k4ID0gMDsgX2k4IDwgbjsgX2k4KyspIHtcbiAgICAgICAgdmFyIG1heCA9IC1JbmZpbml0eSxcbiAgICAgICAgICAgIG1heDIgPSAtSW5maW5pdHksXG4gICAgICAgICAgICBtYXhJID0gLTEsXG4gICAgICAgICAgICBBUyA9IDAuMDtcblxuICAgICAgICBmb3IgKHZhciBfaiA9IDA7IF9qIDwgbjsgX2orKykge1xuICAgICAgICAgIG9sZFtfal0gPSBSW19pOCAqIG4gKyBfal07XG4gICAgICAgICAgQVMgPSBBW19pOCAqIG4gKyBfal0gKyBTW19pOCAqIG4gKyBfal07XG5cbiAgICAgICAgICBpZiAoQVMgPj0gbWF4KSB7XG4gICAgICAgICAgICBtYXgyID0gbWF4O1xuICAgICAgICAgICAgbWF4ID0gQVM7XG4gICAgICAgICAgICBtYXhJID0gX2o7XG4gICAgICAgICAgfSBlbHNlIGlmIChBUyA+IG1heDIpIHtcbiAgICAgICAgICAgIG1heDIgPSBBUztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBfajIgPSAwOyBfajIgPCBuOyBfajIrKykge1xuICAgICAgICAgIFJbX2k4ICogbiArIF9qMl0gPSAoMSAtIG9wdHMuZGFtcGluZykgKiAoU1tfaTggKiBuICsgX2oyXSAtIG1heCkgKyBvcHRzLmRhbXBpbmcgKiBvbGRbX2oyXTtcbiAgICAgICAgfVxuXG4gICAgICAgIFJbX2k4ICogbiArIG1heEldID0gKDEgLSBvcHRzLmRhbXBpbmcpICogKFNbX2k4ICogbiArIG1heEldIC0gbWF4MikgKyBvcHRzLmRhbXBpbmcgKiBvbGRbbWF4SV07XG4gICAgICB9IC8vIFVwZGF0ZSBBIGF2YWlsYWJpbGl0eSBtYXRyaXhcblxuXG4gICAgICBmb3IgKHZhciBfaTkgPSAwOyBfaTkgPCBuOyBfaTkrKykge1xuICAgICAgICB2YXIgc3VtID0gMDtcblxuICAgICAgICBmb3IgKHZhciBfajMgPSAwOyBfajMgPCBuOyBfajMrKykge1xuICAgICAgICAgIG9sZFtfajNdID0gQVtfajMgKiBuICsgX2k5XTtcbiAgICAgICAgICBScFtfajNdID0gTWF0aC5tYXgoMCwgUltfajMgKiBuICsgX2k5XSk7XG4gICAgICAgICAgc3VtICs9IFJwW19qM107XG4gICAgICAgIH1cblxuICAgICAgICBzdW0gLT0gUnBbX2k5XTtcbiAgICAgICAgUnBbX2k5XSA9IFJbX2k5ICogbiArIF9pOV07XG4gICAgICAgIHN1bSArPSBScFtfaTldO1xuXG4gICAgICAgIGZvciAodmFyIF9qNCA9IDA7IF9qNCA8IG47IF9qNCsrKSB7XG4gICAgICAgICAgQVtfajQgKiBuICsgX2k5XSA9ICgxIC0gb3B0cy5kYW1waW5nKSAqIE1hdGgubWluKDAsIHN1bSAtIFJwW19qNF0pICsgb3B0cy5kYW1waW5nICogb2xkW19qNF07XG4gICAgICAgIH1cblxuICAgICAgICBBW19pOSAqIG4gKyBfaTldID0gKDEgLSBvcHRzLmRhbXBpbmcpICogKHN1bSAtIFJwW19pOV0pICsgb3B0cy5kYW1waW5nICogb2xkW19pOV07XG4gICAgICB9IC8vIENoZWNrIGZvciBjb252ZXJnZW5jZVxuXG5cbiAgICAgIHZhciBLID0gMDtcblxuICAgICAgZm9yICh2YXIgX2kxMCA9IDA7IF9pMTAgPCBuOyBfaTEwKyspIHtcbiAgICAgICAgdmFyIEUgPSBBW19pMTAgKiBuICsgX2kxMF0gKyBSW19pMTAgKiBuICsgX2kxMF0gPiAwID8gMSA6IDA7XG4gICAgICAgIGVbaXRlciAlIG9wdHMubWluSXRlcmF0aW9ucyAqIG4gKyBfaTEwXSA9IEU7XG4gICAgICAgIEsgKz0gRTtcbiAgICAgIH1cblxuICAgICAgaWYgKEsgPiAwICYmIChpdGVyID49IG9wdHMubWluSXRlcmF0aW9ucyAtIDEgfHwgaXRlciA9PSBvcHRzLm1heEl0ZXJhdGlvbnMgLSAxKSkge1xuICAgICAgICB2YXIgX3N1bSA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgX2kxMSA9IDA7IF9pMTEgPCBuOyBfaTExKyspIHtcbiAgICAgICAgICBzZVtfaTExXSA9IDA7XG5cbiAgICAgICAgICBmb3IgKHZhciBfajUgPSAwOyBfajUgPCBvcHRzLm1pbkl0ZXJhdGlvbnM7IF9qNSsrKSB7XG4gICAgICAgICAgICBzZVtfaTExXSArPSBlW19qNSAqIG4gKyBfaTExXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VbX2kxMV0gPT09IDAgfHwgc2VbX2kxMV0gPT09IG9wdHMubWluSXRlcmF0aW9ucykge1xuICAgICAgICAgICAgX3N1bSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfc3VtID09PSBuKSB7XG4gICAgICAgICAgLy8gdGhlbiB3ZSBoYXZlIGNvbnZlcmdlbmNlXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIElkZW50aWZ5IGV4ZW1wbGFycyAoY2x1c3RlciBjZW50ZXJzKVxuXG5cbiAgICB2YXIgZXhlbXBsYXJzSW5kaWNlcyA9IGZpbmRFeGVtcGxhcnMobiwgUiwgQSk7IC8vIEFzc2lnbiBub2RlcyB0byBjbHVzdGVyc1xuXG4gICAgdmFyIGNsdXN0ZXJJbmRpY2VzID0gYXNzaWduKG4sIFMsIGV4ZW1wbGFyc0luZGljZXMpO1xuICAgIHZhciBjbHVzdGVycyA9IHt9O1xuXG4gICAgZm9yICh2YXIgYyA9IDA7IGMgPCBleGVtcGxhcnNJbmRpY2VzLmxlbmd0aDsgYysrKSB7XG4gICAgICBjbHVzdGVyc1tleGVtcGxhcnNJbmRpY2VzW2NdXSA9IFtdO1xuICAgIH1cblxuICAgIGZvciAodmFyIF9pMTIgPSAwOyBfaTEyIDwgbm9kZXMubGVuZ3RoOyBfaTEyKyspIHtcbiAgICAgIHZhciBwb3MgPSBpZDJwb3NpdGlvbltub2Rlc1tfaTEyXS5pZCgpXTtcblxuICAgICAgdmFyIGNsdXN0ZXJJbmRleCA9IGNsdXN0ZXJJbmRpY2VzW3Bvc107XG5cbiAgICAgIGlmIChjbHVzdGVySW5kZXggIT0gbnVsbCkge1xuICAgICAgICAvLyB0aGUgbm9kZSBtYXkgaGF2ZSBub3QgYmVlbiBhc3NpZ25lZCBhIGNsdXN0ZXIgaWYgbm8gdmFsaWQgYXR0cmlidXRlcyB3ZXJlIHNwZWNpZmllZFxuICAgICAgICBjbHVzdGVyc1tjbHVzdGVySW5kZXhdLnB1c2gobm9kZXNbX2kxMl0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZXRDbHVzdGVycyA9IG5ldyBBcnJheShleGVtcGxhcnNJbmRpY2VzLmxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBfYyA9IDA7IF9jIDwgZXhlbXBsYXJzSW5kaWNlcy5sZW5ndGg7IF9jKyspIHtcbiAgICAgIHJldENsdXN0ZXJzW19jXSA9IGN5LmNvbGxlY3Rpb24oY2x1c3RlcnNbZXhlbXBsYXJzSW5kaWNlc1tfY11dKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0Q2x1c3RlcnM7XG4gIH07XG5cbiAgdmFyIGFmZmluaXR5UHJvcGFnYXRpb24kMSA9IHtcbiAgICBhZmZpbml0eVByb3BhZ2F0aW9uOiBhZmZpbml0eVByb3BhZ2F0aW9uLFxuICAgIGFwOiBhZmZpbml0eVByb3BhZ2F0aW9uXG4gIH07XG5cbiAgdmFyIGhpZXJob2x6ZXJEZWZhdWx0cyA9IGRlZmF1bHRzJGcoe1xuICAgIHJvb3Q6IHVuZGVmaW5lZCxcbiAgICBkaXJlY3RlZDogZmFsc2VcbiAgfSk7XG4gIHZhciBlbGVzZm4kayA9IHtcbiAgICBoaWVyaG9semVyOiBmdW5jdGlvbiBoaWVyaG9semVyKG9wdGlvbnMpIHtcbiAgICAgIGlmICghcGxhaW5PYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgcm9vdDogYXJnc1swXSxcbiAgICAgICAgICBkaXJlY3RlZDogYXJnc1sxXVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB2YXIgX2hpZXJob2x6ZXJEZWZhdWx0cyA9IGhpZXJob2x6ZXJEZWZhdWx0cyhvcHRpb25zKSxcbiAgICAgICAgICByb290ID0gX2hpZXJob2x6ZXJEZWZhdWx0cy5yb290LFxuICAgICAgICAgIGRpcmVjdGVkID0gX2hpZXJob2x6ZXJEZWZhdWx0cy5kaXJlY3RlZDtcblxuICAgICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgICAgdmFyIGRmbGFnID0gZmFsc2U7XG4gICAgICB2YXIgb2RkSW47XG4gICAgICB2YXIgb2RkT3V0O1xuICAgICAgdmFyIHN0YXJ0VmVydGV4O1xuICAgICAgaWYgKHJvb3QpIHN0YXJ0VmVydGV4ID0gc3RyaW5nKHJvb3QpID8gdGhpcy5maWx0ZXIocm9vdClbMF0uaWQoKSA6IHJvb3RbMF0uaWQoKTtcbiAgICAgIHZhciBub2RlcyA9IHt9O1xuICAgICAgdmFyIGVkZ2VzID0ge307XG5cbiAgICAgIGlmIChkaXJlY3RlZCkge1xuICAgICAgICBlbGVzLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICAgIHZhciBpZCA9IGVsZS5pZCgpO1xuXG4gICAgICAgICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgICAgICAgdmFyIGluZCA9IGVsZS5pbmRlZ3JlZSh0cnVlKTtcbiAgICAgICAgICAgIHZhciBvdXRkID0gZWxlLm91dGRlZ3JlZSh0cnVlKTtcbiAgICAgICAgICAgIHZhciBkMSA9IGluZCAtIG91dGQ7XG4gICAgICAgICAgICB2YXIgZDIgPSBvdXRkIC0gaW5kO1xuXG4gICAgICAgICAgICBpZiAoZDEgPT0gMSkge1xuICAgICAgICAgICAgICBpZiAob2RkSW4pIGRmbGFnID0gdHJ1ZTtlbHNlIG9kZEluID0gaWQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGQyID09IDEpIHtcbiAgICAgICAgICAgICAgaWYgKG9kZE91dCkgZGZsYWcgPSB0cnVlO2Vsc2Ugb2RkT3V0ID0gaWQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGQyID4gMSB8fCBkMSA+IDEpIHtcbiAgICAgICAgICAgICAgZGZsYWcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBub2Rlc1tpZF0gPSBbXTtcbiAgICAgICAgICAgIGVsZS5vdXRnb2VycygpLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgaWYgKGUuaXNFZGdlKCkpIG5vZGVzW2lkXS5wdXNoKGUuaWQoKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWRnZXNbaWRdID0gW3VuZGVmaW5lZCwgZWxlLnRhcmdldCgpLmlkKCldO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVzLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICAgIHZhciBpZCA9IGVsZS5pZCgpO1xuXG4gICAgICAgICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgICAgICAgdmFyIGQgPSBlbGUuZGVncmVlKHRydWUpO1xuXG4gICAgICAgICAgICBpZiAoZCAlIDIpIHtcbiAgICAgICAgICAgICAgaWYgKCFvZGRJbikgb2RkSW4gPSBpZDtlbHNlIGlmICghb2RkT3V0KSBvZGRPdXQgPSBpZDtlbHNlIGRmbGFnID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbm9kZXNbaWRdID0gW107XG4gICAgICAgICAgICBlbGUuY29ubmVjdGVkRWRnZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBub2Rlc1tpZF0ucHVzaChlLmlkKCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVkZ2VzW2lkXSA9IFtlbGUuc291cmNlKCkuaWQoKSwgZWxlLnRhcmdldCgpLmlkKCldO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgIGZvdW5kOiBmYWxzZSxcbiAgICAgICAgdHJhaWw6IHVuZGVmaW5lZFxuICAgICAgfTtcbiAgICAgIGlmIChkZmxhZykgcmV0dXJuIHJlc3VsdDtlbHNlIGlmIChvZGRPdXQgJiYgb2RkSW4pIHtcbiAgICAgICAgaWYgKGRpcmVjdGVkKSB7XG4gICAgICAgICAgaWYgKHN0YXJ0VmVydGV4ICYmIG9kZE91dCAhPSBzdGFydFZlcnRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzdGFydFZlcnRleCA9IG9kZE91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoc3RhcnRWZXJ0ZXggJiYgb2RkT3V0ICE9IHN0YXJ0VmVydGV4ICYmIG9kZEluICE9IHN0YXJ0VmVydGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH0gZWxzZSBpZiAoIXN0YXJ0VmVydGV4KSB7XG4gICAgICAgICAgICBzdGFydFZlcnRleCA9IG9kZE91dDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghc3RhcnRWZXJ0ZXgpIHN0YXJ0VmVydGV4ID0gZWxlc1swXS5pZCgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgd2FsayA9IGZ1bmN0aW9uIHdhbGsodikge1xuICAgICAgICB2YXIgY3VycmVudE5vZGUgPSB2O1xuICAgICAgICB2YXIgc3VidG91ciA9IFt2XTtcbiAgICAgICAgdmFyIGFkaiwgYWRqVGFpbCwgYWRqSGVhZDtcblxuICAgICAgICB3aGlsZSAobm9kZXNbY3VycmVudE5vZGVdLmxlbmd0aCkge1xuICAgICAgICAgIGFkaiA9IG5vZGVzW2N1cnJlbnROb2RlXS5zaGlmdCgpO1xuICAgICAgICAgIGFkalRhaWwgPSBlZGdlc1thZGpdWzBdO1xuICAgICAgICAgIGFkakhlYWQgPSBlZGdlc1thZGpdWzFdO1xuXG4gICAgICAgICAgaWYgKGN1cnJlbnROb2RlICE9IGFkakhlYWQpIHtcbiAgICAgICAgICAgIG5vZGVzW2FkakhlYWRdID0gbm9kZXNbYWRqSGVhZF0uZmlsdGVyKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBlICE9IGFkajtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY3VycmVudE5vZGUgPSBhZGpIZWFkO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIWRpcmVjdGVkICYmIGN1cnJlbnROb2RlICE9IGFkalRhaWwpIHtcbiAgICAgICAgICAgIG5vZGVzW2FkalRhaWxdID0gbm9kZXNbYWRqVGFpbF0uZmlsdGVyKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBlICE9IGFkajtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY3VycmVudE5vZGUgPSBhZGpUYWlsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN1YnRvdXIudW5zaGlmdChhZGopO1xuICAgICAgICAgIHN1YnRvdXIudW5zaGlmdChjdXJyZW50Tm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3VidG91cjtcbiAgICAgIH07XG5cbiAgICAgIHZhciB0cmFpbCA9IFtdO1xuICAgICAgdmFyIHN1YnRvdXIgPSBbXTtcbiAgICAgIHN1YnRvdXIgPSB3YWxrKHN0YXJ0VmVydGV4KTtcblxuICAgICAgd2hpbGUgKHN1YnRvdXIubGVuZ3RoICE9IDEpIHtcbiAgICAgICAgaWYgKG5vZGVzW3N1YnRvdXJbMF1dLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgdHJhaWwudW5zaGlmdChlbGVzLmdldEVsZW1lbnRCeUlkKHN1YnRvdXIuc2hpZnQoKSkpO1xuICAgICAgICAgIHRyYWlsLnVuc2hpZnQoZWxlcy5nZXRFbGVtZW50QnlJZChzdWJ0b3VyLnNoaWZ0KCkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdWJ0b3VyID0gd2FsayhzdWJ0b3VyLnNoaWZ0KCkpLmNvbmNhdChzdWJ0b3VyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0cmFpbC51bnNoaWZ0KGVsZXMuZ2V0RWxlbWVudEJ5SWQoc3VidG91ci5zaGlmdCgpKSk7IC8vIGZpbmFsIG5vZGVcblxuICAgICAgZm9yICh2YXIgZCBpbiBub2Rlcykge1xuICAgICAgICBpZiAobm9kZXNbZF0ubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXN1bHQuZm91bmQgPSB0cnVlO1xuICAgICAgcmVzdWx0LnRyYWlsID0gdGhpcy5zcGF3bih0cmFpbCwgdHJ1ZSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfTtcblxuICB2YXIgaG9wY3JvZnRUYXJqYW5CaWNvbm5lY3RlZCA9IGZ1bmN0aW9uIGhvcGNyb2Z0VGFyamFuQmljb25uZWN0ZWQoKSB7XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgIHZhciBub2RlcyA9IHt9O1xuICAgIHZhciBpZCA9IDA7XG4gICAgdmFyIGVkZ2VDb3VudCA9IDA7XG4gICAgdmFyIGNvbXBvbmVudHMgPSBbXTtcbiAgICB2YXIgc3RhY2sgPSBbXTtcbiAgICB2YXIgdmlzaXRlZEVkZ2VzID0ge307XG5cbiAgICB2YXIgYnVpbGRDb21wb25lbnQgPSBmdW5jdGlvbiBidWlsZENvbXBvbmVudCh4LCB5KSB7XG4gICAgICB2YXIgaSA9IHN0YWNrLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgY3V0c2V0ID0gW107XG4gICAgICB2YXIgY29tcG9uZW50ID0gZWxlcy5zcGF3bigpO1xuXG4gICAgICB3aGlsZSAoc3RhY2tbaV0ueCAhPSB4IHx8IHN0YWNrW2ldLnkgIT0geSkge1xuICAgICAgICBjdXRzZXQucHVzaChzdGFjay5wb3AoKS5lZGdlKTtcbiAgICAgICAgaS0tO1xuICAgICAgfVxuXG4gICAgICBjdXRzZXQucHVzaChzdGFjay5wb3AoKS5lZGdlKTtcbiAgICAgIGN1dHNldC5mb3JFYWNoKGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgIHZhciBjb25uZWN0ZWROb2RlcyA9IGVkZ2UuY29ubmVjdGVkTm9kZXMoKS5pbnRlcnNlY3Rpb24oZWxlcyk7XG4gICAgICAgIGNvbXBvbmVudC5tZXJnZShlZGdlKTtcbiAgICAgICAgY29ubmVjdGVkTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIHZhciBub2RlSWQgPSBub2RlLmlkKCk7XG4gICAgICAgICAgdmFyIGNvbm5lY3RlZEVkZ2VzID0gbm9kZS5jb25uZWN0ZWRFZGdlcygpLmludGVyc2VjdGlvbihlbGVzKTtcbiAgICAgICAgICBjb21wb25lbnQubWVyZ2Uobm9kZSk7XG5cbiAgICAgICAgICBpZiAoIW5vZGVzW25vZGVJZF0uY3V0VmVydGV4KSB7XG4gICAgICAgICAgICBjb21wb25lbnQubWVyZ2UoY29ubmVjdGVkRWRnZXMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb21wb25lbnQubWVyZ2UoY29ubmVjdGVkRWRnZXMuZmlsdGVyKGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBlZGdlLmlzTG9vcCgpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGNvbXBvbmVudHMucHVzaChjb21wb25lbnQpO1xuICAgIH07XG5cbiAgICB2YXIgYmljb25uZWN0ZWRTZWFyY2ggPSBmdW5jdGlvbiBiaWNvbm5lY3RlZFNlYXJjaChyb290LCBjdXJyZW50Tm9kZSwgcGFyZW50KSB7XG4gICAgICBpZiAocm9vdCA9PT0gcGFyZW50KSBlZGdlQ291bnQgKz0gMTtcbiAgICAgIG5vZGVzW2N1cnJlbnROb2RlXSA9IHtcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICBsb3c6IGlkKyssXG4gICAgICAgIGN1dFZlcnRleDogZmFsc2VcbiAgICAgIH07XG4gICAgICB2YXIgZWRnZXMgPSBlbGVzLmdldEVsZW1lbnRCeUlkKGN1cnJlbnROb2RlKS5jb25uZWN0ZWRFZGdlcygpLmludGVyc2VjdGlvbihlbGVzKTtcblxuICAgICAgaWYgKGVkZ2VzLnNpemUoKSA9PT0gMCkge1xuICAgICAgICBjb21wb25lbnRzLnB1c2goZWxlcy5zcGF3bihlbGVzLmdldEVsZW1lbnRCeUlkKGN1cnJlbnROb2RlKSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHNvdXJjZUlkLCB0YXJnZXRJZCwgb3RoZXJOb2RlSWQsIGVkZ2VJZDtcbiAgICAgICAgZWRnZXMuZm9yRWFjaChmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICAgIHNvdXJjZUlkID0gZWRnZS5zb3VyY2UoKS5pZCgpO1xuICAgICAgICAgIHRhcmdldElkID0gZWRnZS50YXJnZXQoKS5pZCgpO1xuICAgICAgICAgIG90aGVyTm9kZUlkID0gc291cmNlSWQgPT09IGN1cnJlbnROb2RlID8gdGFyZ2V0SWQgOiBzb3VyY2VJZDtcblxuICAgICAgICAgIGlmIChvdGhlck5vZGVJZCAhPT0gcGFyZW50KSB7XG4gICAgICAgICAgICBlZGdlSWQgPSBlZGdlLmlkKCk7XG5cbiAgICAgICAgICAgIGlmICghdmlzaXRlZEVkZ2VzW2VkZ2VJZF0pIHtcbiAgICAgICAgICAgICAgdmlzaXRlZEVkZ2VzW2VkZ2VJZF0gPSB0cnVlO1xuICAgICAgICAgICAgICBzdGFjay5wdXNoKHtcbiAgICAgICAgICAgICAgICB4OiBjdXJyZW50Tm9kZSxcbiAgICAgICAgICAgICAgICB5OiBvdGhlck5vZGVJZCxcbiAgICAgICAgICAgICAgICBlZGdlOiBlZGdlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIShvdGhlck5vZGVJZCBpbiBub2RlcykpIHtcbiAgICAgICAgICAgICAgYmljb25uZWN0ZWRTZWFyY2gocm9vdCwgb3RoZXJOb2RlSWQsIGN1cnJlbnROb2RlKTtcbiAgICAgICAgICAgICAgbm9kZXNbY3VycmVudE5vZGVdLmxvdyA9IE1hdGgubWluKG5vZGVzW2N1cnJlbnROb2RlXS5sb3csIG5vZGVzW290aGVyTm9kZUlkXS5sb3cpO1xuXG4gICAgICAgICAgICAgIGlmIChub2Rlc1tjdXJyZW50Tm9kZV0uaWQgPD0gbm9kZXNbb3RoZXJOb2RlSWRdLmxvdykge1xuICAgICAgICAgICAgICAgIG5vZGVzW2N1cnJlbnROb2RlXS5jdXRWZXJ0ZXggPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJ1aWxkQ29tcG9uZW50KGN1cnJlbnROb2RlLCBvdGhlck5vZGVJZCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5vZGVzW2N1cnJlbnROb2RlXS5sb3cgPSBNYXRoLm1pbihub2Rlc1tjdXJyZW50Tm9kZV0ubG93LCBub2Rlc1tvdGhlck5vZGVJZF0uaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGVsZXMuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgICAgIHZhciBub2RlSWQgPSBlbGUuaWQoKTtcblxuICAgICAgICBpZiAoIShub2RlSWQgaW4gbm9kZXMpKSB7XG4gICAgICAgICAgZWRnZUNvdW50ID0gMDtcbiAgICAgICAgICBiaWNvbm5lY3RlZFNlYXJjaChub2RlSWQsIG5vZGVJZCk7XG4gICAgICAgICAgbm9kZXNbbm9kZUlkXS5jdXRWZXJ0ZXggPSBlZGdlQ291bnQgPiAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdmFyIGN1dFZlcnRpY2VzID0gT2JqZWN0LmtleXMobm9kZXMpLmZpbHRlcihmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHJldHVybiBub2Rlc1tpZF0uY3V0VmVydGV4O1xuICAgIH0pLm1hcChmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHJldHVybiBlbGVzLmdldEVsZW1lbnRCeUlkKGlkKTtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgY3V0OiBlbGVzLnNwYXduKGN1dFZlcnRpY2VzKSxcbiAgICAgIGNvbXBvbmVudHM6IGNvbXBvbmVudHNcbiAgICB9O1xuICB9O1xuXG4gIHZhciBob3Bjcm9mdFRhcmphbkJpY29ubmVjdGVkJDEgPSB7XG4gICAgaG9wY3JvZnRUYXJqYW5CaWNvbm5lY3RlZDogaG9wY3JvZnRUYXJqYW5CaWNvbm5lY3RlZCxcbiAgICBodGJjOiBob3Bjcm9mdFRhcmphbkJpY29ubmVjdGVkLFxuICAgIGh0YjogaG9wY3JvZnRUYXJqYW5CaWNvbm5lY3RlZCxcbiAgICBob3Bjcm9mdFRhcmphbkJpY29ubmVjdGVkQ29tcG9uZW50czogaG9wY3JvZnRUYXJqYW5CaWNvbm5lY3RlZFxuICB9O1xuXG4gIHZhciB0YXJqYW5TdHJvbmdseUNvbm5lY3RlZCA9IGZ1bmN0aW9uIHRhcmphblN0cm9uZ2x5Q29ubmVjdGVkKCkge1xuICAgIHZhciBlbGVzID0gdGhpcztcbiAgICB2YXIgbm9kZXMgPSB7fTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBjb21wb25lbnRzID0gW107XG4gICAgdmFyIHN0YWNrID0gW107XG4gICAgdmFyIGN1dCA9IGVsZXMuc3Bhd24oZWxlcyk7XG5cbiAgICB2YXIgc3Ryb25nbHlDb25uZWN0ZWRTZWFyY2ggPSBmdW5jdGlvbiBzdHJvbmdseUNvbm5lY3RlZFNlYXJjaChzb3VyY2VOb2RlSWQpIHtcbiAgICAgIHN0YWNrLnB1c2goc291cmNlTm9kZUlkKTtcbiAgICAgIG5vZGVzW3NvdXJjZU5vZGVJZF0gPSB7XG4gICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgbG93OiBpbmRleCsrLFxuICAgICAgICBleHBsb3JlZDogZmFsc2VcbiAgICAgIH07XG4gICAgICB2YXIgY29ubmVjdGVkRWRnZXMgPSBlbGVzLmdldEVsZW1lbnRCeUlkKHNvdXJjZU5vZGVJZCkuY29ubmVjdGVkRWRnZXMoKS5pbnRlcnNlY3Rpb24oZWxlcyk7XG4gICAgICBjb25uZWN0ZWRFZGdlcy5mb3JFYWNoKGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgIHZhciB0YXJnZXROb2RlSWQgPSBlZGdlLnRhcmdldCgpLmlkKCk7XG5cbiAgICAgICAgaWYgKHRhcmdldE5vZGVJZCAhPT0gc291cmNlTm9kZUlkKSB7XG4gICAgICAgICAgaWYgKCEodGFyZ2V0Tm9kZUlkIGluIG5vZGVzKSkge1xuICAgICAgICAgICAgc3Ryb25nbHlDb25uZWN0ZWRTZWFyY2godGFyZ2V0Tm9kZUlkKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIW5vZGVzW3RhcmdldE5vZGVJZF0uZXhwbG9yZWQpIHtcbiAgICAgICAgICAgIG5vZGVzW3NvdXJjZU5vZGVJZF0ubG93ID0gTWF0aC5taW4obm9kZXNbc291cmNlTm9kZUlkXS5sb3csIG5vZGVzW3RhcmdldE5vZGVJZF0ubG93KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAobm9kZXNbc291cmNlTm9kZUlkXS5pbmRleCA9PT0gbm9kZXNbc291cmNlTm9kZUlkXS5sb3cpIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudE5vZGVzID0gZWxlcy5zcGF3bigpO1xuXG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICB2YXIgbm9kZUlkID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgY29tcG9uZW50Tm9kZXMubWVyZ2UoZWxlcy5nZXRFbGVtZW50QnlJZChub2RlSWQpKTtcbiAgICAgICAgICBub2Rlc1tub2RlSWRdLmxvdyA9IG5vZGVzW3NvdXJjZU5vZGVJZF0uaW5kZXg7XG4gICAgICAgICAgbm9kZXNbbm9kZUlkXS5leHBsb3JlZCA9IHRydWU7XG5cbiAgICAgICAgICBpZiAobm9kZUlkID09PSBzb3VyY2VOb2RlSWQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb21wb25lbnRFZGdlcyA9IGNvbXBvbmVudE5vZGVzLmVkZ2VzV2l0aChjb21wb25lbnROb2Rlcyk7XG4gICAgICAgIHZhciBjb21wb25lbnQgPSBjb21wb25lbnROb2Rlcy5tZXJnZShjb21wb25lbnRFZGdlcyk7XG4gICAgICAgIGNvbXBvbmVudHMucHVzaChjb21wb25lbnQpO1xuICAgICAgICBjdXQgPSBjdXQuZGlmZmVyZW5jZShjb21wb25lbnQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBlbGVzLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgICB2YXIgbm9kZUlkID0gZWxlLmlkKCk7XG5cbiAgICAgICAgaWYgKCEobm9kZUlkIGluIG5vZGVzKSkge1xuICAgICAgICAgIHN0cm9uZ2x5Q29ubmVjdGVkU2VhcmNoKG5vZGVJZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgY3V0OiBjdXQsXG4gICAgICBjb21wb25lbnRzOiBjb21wb25lbnRzXG4gICAgfTtcbiAgfTtcblxuICB2YXIgdGFyamFuU3Ryb25nbHlDb25uZWN0ZWQkMSA9IHtcbiAgICB0YXJqYW5TdHJvbmdseUNvbm5lY3RlZDogdGFyamFuU3Ryb25nbHlDb25uZWN0ZWQsXG4gICAgdHNjOiB0YXJqYW5TdHJvbmdseUNvbm5lY3RlZCxcbiAgICB0c2NjOiB0YXJqYW5TdHJvbmdseUNvbm5lY3RlZCxcbiAgICB0YXJqYW5TdHJvbmdseUNvbm5lY3RlZENvbXBvbmVudHM6IHRhcmphblN0cm9uZ2x5Q29ubmVjdGVkXG4gIH07XG5cbiAgdmFyIGVsZXNmbiRqID0ge307XG4gIFtlbGVzZm4kdiwgZWxlc2ZuJHUsIGVsZXNmbiR0LCBlbGVzZm4kcywgZWxlc2ZuJHIsIGVsZXNmbiRxLCBlbGVzZm4kcCwgZWxlc2ZuJG8sIGVsZXNmbiRuLCBlbGVzZm4kbSwgZWxlc2ZuJGwsIG1hcmtvdkNsdXN0ZXJpbmckMSwga0NsdXN0ZXJpbmcsIGhpZXJhcmNoaWNhbENsdXN0ZXJpbmckMSwgYWZmaW5pdHlQcm9wYWdhdGlvbiQxLCBlbGVzZm4kaywgaG9wY3JvZnRUYXJqYW5CaWNvbm5lY3RlZCQxLCB0YXJqYW5TdHJvbmdseUNvbm5lY3RlZCQxXS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wcykge1xuICAgIGV4dGVuZChlbGVzZm4kaiwgcHJvcHMpO1xuICB9KTtcblxuICAvKiFcbiAgRW1iZWRkYWJsZSBNaW5pbXVtIFN0cmljdGx5LUNvbXBsaWFudCBQcm9taXNlcy9BKyAxLjEuMSBUaGVuYWJsZVxuICBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNCBSYWxmIFMuIEVuZ2Vsc2NoYWxsIChodHRwOi8vZW5nZWxzY2hhbGwuY29tKVxuICBMaWNlbnNlZCB1bmRlciBUaGUgTUlUIExpY2Vuc2UgKGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQpXG4gICovXG5cbiAgLyogIHByb21pc2Ugc3RhdGVzIFtQcm9taXNlcy9BKyAyLjFdICAqL1xuICB2YXIgU1RBVEVfUEVORElORyA9IDA7XG4gIC8qICBbUHJvbWlzZXMvQSsgMi4xLjFdICAqL1xuXG4gIHZhciBTVEFURV9GVUxGSUxMRUQgPSAxO1xuICAvKiAgW1Byb21pc2VzL0ErIDIuMS4yXSAgKi9cblxuICB2YXIgU1RBVEVfUkVKRUNURUQgPSAyO1xuICAvKiAgW1Byb21pc2VzL0ErIDIuMS4zXSAgKi9cblxuICAvKiAgcHJvbWlzZSBvYmplY3QgY29uc3RydWN0b3IgICovXG5cbiAgdmFyIGFwaSA9IGZ1bmN0aW9uIGFwaShleGVjdXRvcikge1xuICAgIC8qICBvcHRpb25hbGx5IHN1cHBvcnQgbm9uLWNvbnN0cnVjdG9yL3BsYWluLWZ1bmN0aW9uIGNhbGwgICovXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIGFwaSkpIHJldHVybiBuZXcgYXBpKGV4ZWN1dG9yKTtcbiAgICAvKiAgaW5pdGlhbGl6ZSBvYmplY3QgICovXG5cbiAgICB0aGlzLmlkID0gJ1RoZW5hYmxlLzEuMC43JztcbiAgICB0aGlzLnN0YXRlID0gU1RBVEVfUEVORElORztcbiAgICAvKiAgaW5pdGlhbCBzdGF0ZSAgKi9cblxuICAgIHRoaXMuZnVsZmlsbFZhbHVlID0gdW5kZWZpbmVkO1xuICAgIC8qICBpbml0aWFsIHZhbHVlICAqL1xuXG4gICAgLyogIFtQcm9taXNlcy9BKyAxLjMsIDIuMS4yLjJdICAqL1xuXG4gICAgdGhpcy5yZWplY3RSZWFzb24gPSB1bmRlZmluZWQ7XG4gICAgLyogIGluaXRpYWwgcmVhc29uICovXG5cbiAgICAvKiAgW1Byb21pc2VzL0ErIDEuNSwgMi4xLjMuMl0gICovXG5cbiAgICB0aGlzLm9uRnVsZmlsbGVkID0gW107XG4gICAgLyogIGluaXRpYWwgaGFuZGxlcnMgICovXG5cbiAgICB0aGlzLm9uUmVqZWN0ZWQgPSBbXTtcbiAgICAvKiAgaW5pdGlhbCBoYW5kbGVycyAgKi9cblxuICAgIC8qICBwcm92aWRlIG9wdGlvbmFsIGluZm9ybWF0aW9uLWhpZGluZyBwcm94eSAgKi9cblxuICAgIHRoaXMucHJveHkgPSB7XG4gICAgICB0aGVuOiB0aGlzLnRoZW4uYmluZCh0aGlzKVxuICAgIH07XG4gICAgLyogIHN1cHBvcnQgb3B0aW9uYWwgZXhlY3V0b3IgZnVuY3Rpb24gICovXG5cbiAgICBpZiAodHlwZW9mIGV4ZWN1dG9yID09PSAnZnVuY3Rpb24nKSBleGVjdXRvci5jYWxsKHRoaXMsIHRoaXMuZnVsZmlsbC5iaW5kKHRoaXMpLCB0aGlzLnJlamVjdC5iaW5kKHRoaXMpKTtcbiAgfTtcbiAgLyogIHByb21pc2UgQVBJIG1ldGhvZHMgICovXG5cblxuICBhcGkucHJvdG90eXBlID0ge1xuICAgIC8qICBwcm9taXNlIHJlc29sdmluZyBtZXRob2RzICAqL1xuICAgIGZ1bGZpbGw6IGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHtcbiAgICAgIHJldHVybiBkZWxpdmVyKHRoaXMsIFNUQVRFX0ZVTEZJTExFRCwgJ2Z1bGZpbGxWYWx1ZScsIHZhbHVlKTtcbiAgICB9LFxuICAgIHJlamVjdDogZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gZGVsaXZlcih0aGlzLCBTVEFURV9SRUpFQ1RFRCwgJ3JlamVjdFJlYXNvbicsIHZhbHVlKTtcbiAgICB9LFxuXG4gICAgLyogIFwiVGhlIHRoZW4gTWV0aG9kXCIgW1Byb21pc2VzL0ErIDEuMSwgMS4yLCAyLjJdICAqL1xuICAgIHRoZW46IGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAgIHZhciBjdXJyID0gdGhpcztcbiAgICAgIHZhciBuZXh0ID0gbmV3IGFwaSgpO1xuICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjIuN10gICovXG5cbiAgICAgIGN1cnIub25GdWxmaWxsZWQucHVzaChyZXNvbHZlcihvbkZ1bGZpbGxlZCwgbmV4dCwgJ2Z1bGZpbGwnKSk7XG4gICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMi4yLzIuMi42XSAgKi9cblxuICAgICAgY3Vyci5vblJlamVjdGVkLnB1c2gocmVzb2x2ZXIob25SZWplY3RlZCwgbmV4dCwgJ3JlamVjdCcpKTtcbiAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjMvMi4yLjZdICAqL1xuXG4gICAgICBleGVjdXRlKGN1cnIpO1xuICAgICAgcmV0dXJuIG5leHQucHJveHk7XG4gICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMi43LCAzLjNdICAqL1xuICAgIH1cbiAgfTtcbiAgLyogIGRlbGl2ZXIgYW4gYWN0aW9uICAqL1xuXG4gIHZhciBkZWxpdmVyID0gZnVuY3Rpb24gZGVsaXZlcihjdXJyLCBzdGF0ZSwgbmFtZSwgdmFsdWUpIHtcbiAgICBpZiAoY3Vyci5zdGF0ZSA9PT0gU1RBVEVfUEVORElORykge1xuICAgICAgY3Vyci5zdGF0ZSA9IHN0YXRlO1xuICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjEuMi4xLCAyLjEuMy4xXSAgKi9cblxuICAgICAgY3VycltuYW1lXSA9IHZhbHVlO1xuICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjEuMi4yLCAyLjEuMy4yXSAgKi9cblxuICAgICAgZXhlY3V0ZShjdXJyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3VycjtcbiAgfTtcbiAgLyogIGV4ZWN1dGUgYWxsIGhhbmRsZXJzICAqL1xuXG5cbiAgdmFyIGV4ZWN1dGUgPSBmdW5jdGlvbiBleGVjdXRlKGN1cnIpIHtcbiAgICBpZiAoY3Vyci5zdGF0ZSA9PT0gU1RBVEVfRlVMRklMTEVEKSBleGVjdXRlX2hhbmRsZXJzKGN1cnIsICdvbkZ1bGZpbGxlZCcsIGN1cnIuZnVsZmlsbFZhbHVlKTtlbHNlIGlmIChjdXJyLnN0YXRlID09PSBTVEFURV9SRUpFQ1RFRCkgZXhlY3V0ZV9oYW5kbGVycyhjdXJyLCAnb25SZWplY3RlZCcsIGN1cnIucmVqZWN0UmVhc29uKTtcbiAgfTtcbiAgLyogIGV4ZWN1dGUgcGFydGljdWxhciBzZXQgb2YgaGFuZGxlcnMgICovXG5cblxuICB2YXIgZXhlY3V0ZV9oYW5kbGVycyA9IGZ1bmN0aW9uIGV4ZWN1dGVfaGFuZGxlcnMoY3VyciwgbmFtZSwgdmFsdWUpIHtcbiAgICAvKiBnbG9iYWwgc2V0SW1tZWRpYXRlOiB0cnVlICovXG5cbiAgICAvKiBnbG9iYWwgc2V0VGltZW91dDogdHJ1ZSAqL1xuXG4gICAgLyogIHNob3J0LWNpcmN1aXQgcHJvY2Vzc2luZyAgKi9cbiAgICBpZiAoY3VycltuYW1lXS5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICAvKiAgaXRlcmF0ZSBvdmVyIGFsbCBoYW5kbGVycywgZXhhY3RseSBvbmNlICAqL1xuXG4gICAgdmFyIGhhbmRsZXJzID0gY3VycltuYW1lXTtcbiAgICBjdXJyW25hbWVdID0gW107XG4gICAgLyogIFtQcm9taXNlcy9BKyAyLjIuMi4zLCAyLjIuMy4zXSAgKi9cblxuICAgIHZhciBmdW5jID0gZnVuY3Rpb24gZnVuYygpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGFuZGxlcnNbaV0odmFsdWUpO1xuICAgICAgfVxuICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjIuNV0gICovXG5cbiAgICB9O1xuICAgIC8qICBleGVjdXRlIHByb2NlZHVyZSBhc3luY2hyb25vdXNseSAgKi9cblxuICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjQsIDMuMV0gICovXG5cblxuICAgIGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nKSBzZXRJbW1lZGlhdGUoZnVuYyk7ZWxzZSBzZXRUaW1lb3V0KGZ1bmMsIDApO1xuICB9O1xuICAvKiAgZ2VuZXJhdGUgYSByZXNvbHZlciBmdW5jdGlvbiAgKi9cblxuXG4gIHZhciByZXNvbHZlciA9IGZ1bmN0aW9uIHJlc29sdmVyKGNiLCBuZXh0LCBtZXRob2QpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMi4xLCAyLjIuNy4zLCAyLjIuNy40XSAgKi9cbiAgICAgICAgbmV4dFttZXRob2RdLmNhbGwobmV4dCwgdmFsdWUpO1xuICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMi43LjMsIDIuMi43LjRdICAqL1xuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXN1bHQgPSBjYih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjIuMi4xLCAyLjIuMy4xLCAyLjIuNSwgMy4yXSAgKi9cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICBuZXh0LnJlamVjdChlKTtcbiAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMi43LjJdICAqL1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzb2x2ZShuZXh0LCByZXN1bHQpO1xuICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMi43LjFdICAqL1xuICAgICAgfVxuICAgIH07XG4gIH07XG4gIC8qICBcIlByb21pc2UgUmVzb2x1dGlvbiBQcm9jZWR1cmVcIiAgKi9cblxuICAvKiAgW1Byb21pc2VzL0ErIDIuM10gICovXG5cblxuICB2YXIgcmVzb2x2ZSA9IGZ1bmN0aW9uIHJlc29sdmUocHJvbWlzZSwgeCkge1xuICAgIC8qICBzYW5pdHkgY2hlY2sgYXJndW1lbnRzICAqL1xuXG4gICAgLyogIFtQcm9taXNlcy9BKyAyLjMuMV0gICovXG4gICAgaWYgKHByb21pc2UgPT09IHggfHwgcHJvbWlzZS5wcm94eSA9PT0geCkge1xuICAgICAgcHJvbWlzZS5yZWplY3QobmV3IFR5cGVFcnJvcignY2Fubm90IHJlc29sdmUgcHJvbWlzZSB3aXRoIGl0c2VsZicpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLyogIHN1cmdpY2FsbHkgY2hlY2sgZm9yIGEgXCJ0aGVuXCIgbWV0aG9kXG4gICAgICAobWFpbmx5IHRvIGp1c3QgY2FsbCB0aGUgXCJnZXR0ZXJcIiBvZiBcInRoZW5cIiBvbmx5IG9uY2UpICAqL1xuXG5cbiAgICB2YXIgdGhlbjtcblxuICAgIGlmIChfdHlwZW9mKHgpID09PSAnb2JqZWN0JyAmJiB4ICE9PSBudWxsIHx8IHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGVuID0geC50aGVuO1xuICAgICAgfVxuICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjMuMy4xLCAzLjVdICAqL1xuICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcHJvbWlzZS5yZWplY3QoZSk7XG4gICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4zLjMuMl0gICovXG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiAgaGFuZGxlIG93biBUaGVuYWJsZXMgICAgW1Byb21pc2VzL0ErIDIuMy4yXVxuICAgICAgYW5kIHNpbWlsYXIgXCJ0aGVuYWJsZXNcIiBbUHJvbWlzZXMvQSsgMi4zLjNdICAqL1xuXG5cbiAgICBpZiAodHlwZW9mIHRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciByZXNvbHZlZCA9IGZhbHNlO1xuXG4gICAgICB0cnkge1xuICAgICAgICAvKiAgY2FsbCByZXRyaWV2ZWQgXCJ0aGVuXCIgbWV0aG9kICovXG5cbiAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjMuMy4zXSAgKi9cbiAgICAgICAgdGhlbi5jYWxsKHgsXG4gICAgICAgIC8qICByZXNvbHZlUHJvbWlzZSAgKi9cblxuICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjMuMV0gICovXG4gICAgICAgIGZ1bmN0aW9uICh5KSB7XG4gICAgICAgICAgaWYgKHJlc29sdmVkKSByZXR1cm47XG4gICAgICAgICAgcmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4zLjMuMy4zXSAgKi9cblxuICAgICAgICAgIGlmICh5ID09PSB4KVxuICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAzLjZdICAqL1xuICAgICAgICAgICAgcHJvbWlzZS5yZWplY3QobmV3IFR5cGVFcnJvcignY2lyY3VsYXIgdGhlbmFibGUgY2hhaW4nKSk7ZWxzZSByZXNvbHZlKHByb21pc2UsIHkpO1xuICAgICAgICB9LFxuICAgICAgICAvKiAgcmVqZWN0UHJvbWlzZSAgKi9cblxuICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjMuMl0gICovXG4gICAgICAgIGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgaWYgKHJlc29sdmVkKSByZXR1cm47XG4gICAgICAgICAgcmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4zLjMuMy4zXSAgKi9cblxuICAgICAgICAgIHByb21pc2UucmVqZWN0KHIpO1xuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKCFyZXNvbHZlZClcbiAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjMuM10gICovXG4gICAgICAgICAgcHJvbWlzZS5yZWplY3QoZSk7XG4gICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4zLjMuMy40XSAgKi9cbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvKiAgaGFuZGxlIG90aGVyIHZhbHVlcyAgKi9cblxuXG4gICAgcHJvbWlzZS5mdWxmaWxsKHgpO1xuICAgIC8qICBbUHJvbWlzZXMvQSsgMi4zLjQsIDIuMy4zLjRdICAqL1xuICB9OyAvLyBzbyB3ZSBhbHdheXMgaGF2ZSBQcm9taXNlLmFsbCgpXG5cblxuICBhcGkuYWxsID0gZnVuY3Rpb24gKHBzKSB7XG4gICAgcmV0dXJuIG5ldyBhcGkoZnVuY3Rpb24gKHJlc29sdmVBbGwsIHJlamVjdEFsbCkge1xuICAgICAgdmFyIHZhbHMgPSBuZXcgQXJyYXkocHMubGVuZ3RoKTtcbiAgICAgIHZhciBkb25lQ291bnQgPSAwO1xuXG4gICAgICB2YXIgZnVsZmlsbCA9IGZ1bmN0aW9uIGZ1bGZpbGwoaSwgdmFsKSB7XG4gICAgICAgIHZhbHNbaV0gPSB2YWw7XG4gICAgICAgIGRvbmVDb3VudCsrO1xuXG4gICAgICAgIGlmIChkb25lQ291bnQgPT09IHBzLmxlbmd0aCkge1xuICAgICAgICAgIHJlc29sdmVBbGwodmFscyk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgdmFyIHAgPSBwc1tpXTtcbiAgICAgICAgICB2YXIgaXNQcm9taXNlID0gcCAhPSBudWxsICYmIHAudGhlbiAhPSBudWxsO1xuXG4gICAgICAgICAgaWYgKGlzUHJvbWlzZSkge1xuICAgICAgICAgICAgcC50aGVuKGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgZnVsZmlsbChpLCB2YWwpO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICByZWplY3RBbGwoZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdmFsID0gcDtcbiAgICAgICAgICAgIGZ1bGZpbGwoaSwgdmFsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKGkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIGFwaS5yZXNvbHZlID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIHJldHVybiBuZXcgYXBpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHJlc29sdmUodmFsKTtcbiAgICB9KTtcbiAgfTtcblxuICBhcGkucmVqZWN0ID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIHJldHVybiBuZXcgYXBpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHJlamVjdCh2YWwpO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBQcm9taXNlJDEgPSB0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcgPyBQcm9taXNlIDogYXBpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cbiAgdmFyIEFuaW1hdGlvbiA9IGZ1bmN0aW9uIEFuaW1hdGlvbih0YXJnZXQsIG9wdHMsIG9wdHMyKSB7XG4gICAgdmFyIGlzQ29yZSA9IGNvcmUodGFyZ2V0KTtcbiAgICB2YXIgaXNFbGUgPSAhaXNDb3JlO1xuXG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZSA9IGV4dGVuZCh7XG4gICAgICBkdXJhdGlvbjogMTAwMFxuICAgIH0sIG9wdHMsIG9wdHMyKTtcblxuICAgIF9wLnRhcmdldCA9IHRhcmdldDtcbiAgICBfcC5zdHlsZSA9IF9wLnN0eWxlIHx8IF9wLmNzcztcbiAgICBfcC5zdGFydGVkID0gZmFsc2U7XG4gICAgX3AucGxheWluZyA9IGZhbHNlO1xuICAgIF9wLmhvb2tlZCA9IGZhbHNlO1xuICAgIF9wLmFwcGx5aW5nID0gZmFsc2U7XG4gICAgX3AucHJvZ3Jlc3MgPSAwO1xuICAgIF9wLmNvbXBsZXRlcyA9IFtdO1xuICAgIF9wLmZyYW1lcyA9IFtdO1xuXG4gICAgaWYgKF9wLmNvbXBsZXRlICYmIGZuJDYoX3AuY29tcGxldGUpKSB7XG4gICAgICBfcC5jb21wbGV0ZXMucHVzaChfcC5jb21wbGV0ZSk7XG4gICAgfVxuXG4gICAgaWYgKGlzRWxlKSB7XG4gICAgICB2YXIgcG9zID0gdGFyZ2V0LnBvc2l0aW9uKCk7XG4gICAgICBfcC5zdGFydFBvc2l0aW9uID0gX3Auc3RhcnRQb3NpdGlvbiB8fCB7XG4gICAgICAgIHg6IHBvcy54LFxuICAgICAgICB5OiBwb3MueVxuICAgICAgfTtcbiAgICAgIF9wLnN0YXJ0U3R5bGUgPSBfcC5zdGFydFN0eWxlIHx8IHRhcmdldC5jeSgpLnN0eWxlKCkuZ2V0QW5pbWF0aW9uU3RhcnRTdHlsZSh0YXJnZXQsIF9wLnN0eWxlKTtcbiAgICB9XG5cbiAgICBpZiAoaXNDb3JlKSB7XG4gICAgICB2YXIgcGFuID0gdGFyZ2V0LnBhbigpO1xuICAgICAgX3Auc3RhcnRQYW4gPSB7XG4gICAgICAgIHg6IHBhbi54LFxuICAgICAgICB5OiBwYW4ueVxuICAgICAgfTtcbiAgICAgIF9wLnN0YXJ0Wm9vbSA9IHRhcmdldC56b29tKCk7XG4gICAgfSAvLyBmb3IgZnV0dXJlIHRpbWVsaW5lL2FuaW1hdGlvbnMgaW1wbFxuXG5cbiAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgdGhpc1swXSA9IHRoaXM7XG4gIH07XG5cbiAgdmFyIGFuaWZuID0gQW5pbWF0aW9uLnByb3RvdHlwZTtcbiAgZXh0ZW5kKGFuaWZuLCB7XG4gICAgaW5zdGFuY2VTdHJpbmc6IGZ1bmN0aW9uIGluc3RhbmNlU3RyaW5nKCkge1xuICAgICAgcmV0dXJuICdhbmltYXRpb24nO1xuICAgIH0sXG4gICAgaG9vazogZnVuY3Rpb24gaG9vaygpIHtcbiAgICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICAgIGlmICghX3AuaG9va2VkKSB7XG4gICAgICAgIC8vIGFkZCB0byB0YXJnZXQncyBhbmltYXRpb24gcXVldWVcbiAgICAgICAgdmFyIHE7XG4gICAgICAgIHZhciB0QW5pID0gX3AudGFyZ2V0Ll9wcml2YXRlLmFuaW1hdGlvbjtcblxuICAgICAgICBpZiAoX3AucXVldWUpIHtcbiAgICAgICAgICBxID0gdEFuaS5xdWV1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBxID0gdEFuaS5jdXJyZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgcS5wdXNoKHRoaXMpOyAvLyBhZGQgdG8gdGhlIGFuaW1hdGlvbiBsb29wIHBvb2xcblxuICAgICAgICBpZiAoZWxlbWVudE9yQ29sbGVjdGlvbihfcC50YXJnZXQpKSB7XG4gICAgICAgICAgX3AudGFyZ2V0LmN5KCkuYWRkVG9BbmltYXRpb25Qb29sKF9wLnRhcmdldCk7XG4gICAgICAgIH1cblxuICAgICAgICBfcC5ob29rZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHBsYXk6IGZ1bmN0aW9uIHBsYXkoKSB7XG4gICAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlOyAvLyBhdXRvcmV3aW5kXG5cbiAgICAgIGlmIChfcC5wcm9ncmVzcyA9PT0gMSkge1xuICAgICAgICBfcC5wcm9ncmVzcyA9IDA7XG4gICAgICB9XG5cbiAgICAgIF9wLnBsYXlpbmcgPSB0cnVlO1xuICAgICAgX3Auc3RhcnRlZCA9IGZhbHNlOyAvLyBuZWVkcyB0byBiZSBzdGFydGVkIGJ5IGFuaW1hdGlvbiBsb29wXG5cbiAgICAgIF9wLnN0b3BwZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuaG9vaygpOyAvLyB0aGUgYW5pbWF0aW9uIGxvb3Agd2lsbCBzdGFydCB0aGUgYW5pbWF0aW9uLi4uXG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgcGxheWluZzogZnVuY3Rpb24gcGxheWluZygpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnBsYXlpbmc7XG4gICAgfSxcbiAgICBhcHBseTogZnVuY3Rpb24gYXBwbHkoKSB7XG4gICAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgICAgX3AuYXBwbHlpbmcgPSB0cnVlO1xuICAgICAgX3Auc3RhcnRlZCA9IGZhbHNlOyAvLyBuZWVkcyB0byBiZSBzdGFydGVkIGJ5IGFuaW1hdGlvbiBsb29wXG5cbiAgICAgIF9wLnN0b3BwZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuaG9vaygpOyAvLyB0aGUgYW5pbWF0aW9uIGxvb3Agd2lsbCBhcHBseSB0aGUgYW5pbWF0aW9uIGF0IHRoaXMgcHJvZ3Jlc3NcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBhcHBseWluZzogZnVuY3Rpb24gYXBwbHlpbmcoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5hcHBseWluZztcbiAgICB9LFxuICAgIHBhdXNlOiBmdW5jdGlvbiBwYXVzZSgpIHtcbiAgICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgICBfcC5wbGF5aW5nID0gZmFsc2U7XG4gICAgICBfcC5zdGFydGVkID0gZmFsc2U7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHN0b3A6IGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgICAgX3AucGxheWluZyA9IGZhbHNlO1xuICAgICAgX3Auc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgX3Auc3RvcHBlZCA9IHRydWU7IC8vIHRvIGJlIHJlbW92ZWQgZnJvbSBhbmltYXRpb24gcXVldWVzXG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgcmV3aW5kOiBmdW5jdGlvbiByZXdpbmQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9ncmVzcygwKTtcbiAgICB9LFxuICAgIGZhc3Rmb3J3YXJkOiBmdW5jdGlvbiBmYXN0Zm9yd2FyZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb2dyZXNzKDEpO1xuICAgIH0sXG4gICAgdGltZTogZnVuY3Rpb24gdGltZSh0KSB7XG4gICAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuXG4gICAgICBpZiAodCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBfcC5wcm9ncmVzcyAqIF9wLmR1cmF0aW9uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvZ3Jlc3ModCAvIF9wLmR1cmF0aW9uKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHByb2dyZXNzOiBmdW5jdGlvbiBwcm9ncmVzcyhwKSB7XG4gICAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgICAgdmFyIHdhc1BsYXlpbmcgPSBfcC5wbGF5aW5nO1xuXG4gICAgICBpZiAocCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBfcC5wcm9ncmVzcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh3YXNQbGF5aW5nKSB7XG4gICAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3AucHJvZ3Jlc3MgPSBwO1xuICAgICAgICBfcC5zdGFydGVkID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHdhc1BsYXlpbmcpIHtcbiAgICAgICAgICB0aGlzLnBsYXkoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGNvbXBsZXRlZDogZnVuY3Rpb24gY29tcGxldGVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUucHJvZ3Jlc3MgPT09IDE7XG4gICAgfSxcbiAgICByZXZlcnNlOiBmdW5jdGlvbiByZXZlcnNlKCkge1xuICAgICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICAgIHZhciB3YXNQbGF5aW5nID0gX3AucGxheWluZztcblxuICAgICAgaWYgKHdhc1BsYXlpbmcpIHtcbiAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgfVxuXG4gICAgICBfcC5wcm9ncmVzcyA9IDEgLSBfcC5wcm9ncmVzcztcbiAgICAgIF9wLnN0YXJ0ZWQgPSBmYWxzZTtcblxuICAgICAgdmFyIHN3YXAgPSBmdW5jdGlvbiBzd2FwKGEsIGIpIHtcbiAgICAgICAgdmFyIF9wYSA9IF9wW2FdO1xuXG4gICAgICAgIGlmIChfcGEgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIF9wW2FdID0gX3BbYl07XG4gICAgICAgIF9wW2JdID0gX3BhO1xuICAgICAgfTtcblxuICAgICAgc3dhcCgnem9vbScsICdzdGFydFpvb20nKTtcbiAgICAgIHN3YXAoJ3BhbicsICdzdGFydFBhbicpO1xuICAgICAgc3dhcCgncG9zaXRpb24nLCAnc3RhcnRQb3NpdGlvbicpOyAvLyBzd2FwIHN0eWxlc1xuXG4gICAgICBpZiAoX3Auc3R5bGUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfcC5zdHlsZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBwcm9wID0gX3Auc3R5bGVbaV07XG4gICAgICAgICAgdmFyIG5hbWUgPSBwcm9wLm5hbWU7XG4gICAgICAgICAgdmFyIHN0YXJ0U3R5bGVQcm9wID0gX3Auc3RhcnRTdHlsZVtuYW1lXTtcbiAgICAgICAgICBfcC5zdGFydFN0eWxlW25hbWVdID0gcHJvcDtcbiAgICAgICAgICBfcC5zdHlsZVtpXSA9IHN0YXJ0U3R5bGVQcm9wO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh3YXNQbGF5aW5nKSB7XG4gICAgICAgIHRoaXMucGxheSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHByb21pc2U6IGZ1bmN0aW9uIHByb21pc2UodHlwZSkge1xuICAgICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICAgIHZhciBhcnI7XG5cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdmcmFtZSc6XG4gICAgICAgICAgYXJyID0gX3AuZnJhbWVzO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNhc2UgJ2NvbXBsZXRlJzpcbiAgICAgICAgY2FzZSAnY29tcGxldGVkJzpcbiAgICAgICAgICBhcnIgPSBfcC5jb21wbGV0ZXM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgYXJyLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICBhbmlmbi5jb21wbGV0ZSA9IGFuaWZuLmNvbXBsZXRlZDtcbiAgYW5pZm4ucnVuID0gYW5pZm4ucGxheTtcbiAgYW5pZm4ucnVubmluZyA9IGFuaWZuLnBsYXlpbmc7XG5cbiAgdmFyIGRlZmluZSQzID0ge1xuICAgIGFuaW1hdGVkOiBmdW5jdGlvbiBhbmltYXRlZCgpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBhbmltYXRlZEltcGwoKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHNlbGZJc0FycmF5TGlrZSA9IHNlbGYubGVuZ3RoICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogW3NlbGZdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcblxuICAgICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5IHx8IHRoaXM7XG5cbiAgICAgICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbGUgPSBhbGxbMF07XG5cbiAgICAgICAgaWYgKGVsZSkge1xuICAgICAgICAgIHJldHVybiBlbGUuX3ByaXZhdGUuYW5pbWF0aW9uLmN1cnJlbnQubGVuZ3RoID4gMDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIC8vIGFuaW1hdGVkXG4gICAgY2xlYXJRdWV1ZTogZnVuY3Rpb24gY2xlYXJRdWV1ZSgpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBjbGVhclF1ZXVlSW1wbCgpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGFsbCA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGYgOiBbc2VsZl07IC8vIHB1dCBpbiBhcnJheSBpZiBub3QgYXJyYXktbGlrZVxuXG4gICAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3kgfHwgdGhpcztcblxuICAgICAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBlbGUgPSBhbGxbaV07XG4gICAgICAgICAgZWxlLl9wcml2YXRlLmFuaW1hdGlvbi5xdWV1ZSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuICAgIH0sXG4gICAgLy8gY2xlYXJRdWV1ZVxuICAgIGRlbGF5OiBmdW5jdGlvbiBkZWxheSgpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBkZWxheUltcGwodGltZSwgY29tcGxldGUpIHtcbiAgICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeSB8fCB0aGlzO1xuXG4gICAgICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmFuaW1hdGUoe1xuICAgICAgICAgIGRlbGF5OiB0aW1lLFxuICAgICAgICAgIGR1cmF0aW9uOiB0aW1lLFxuICAgICAgICAgIGNvbXBsZXRlOiBjb21wbGV0ZVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfSxcbiAgICAvLyBkZWxheVxuICAgIGRlbGF5QW5pbWF0aW9uOiBmdW5jdGlvbiBkZWxheUFuaW1hdGlvbigpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBkZWxheUFuaW1hdGlvbkltcGwodGltZSwgY29tcGxldGUpIHtcbiAgICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeSB8fCB0aGlzO1xuXG4gICAgICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmFuaW1hdGlvbih7XG4gICAgICAgICAgZGVsYXk6IHRpbWUsXG4gICAgICAgICAgZHVyYXRpb246IHRpbWUsXG4gICAgICAgICAgY29tcGxldGU6IGNvbXBsZXRlXG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9LFxuICAgIC8vIGRlbGF5XG4gICAgYW5pbWF0aW9uOiBmdW5jdGlvbiBhbmltYXRpb24oKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gYW5pbWF0aW9uSW1wbChwcm9wZXJ0aWVzLCBwYXJhbXMpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGFsbCA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGYgOiBbc2VsZl07IC8vIHB1dCBpbiBhcnJheSBpZiBub3QgYXJyYXktbGlrZVxuXG4gICAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3kgfHwgdGhpcztcbiAgICAgICAgdmFyIGlzQ29yZSA9ICFzZWxmSXNBcnJheUxpa2U7XG4gICAgICAgIHZhciBpc0VsZXMgPSAhaXNDb3JlO1xuXG4gICAgICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdHlsZSA9IGN5LnN0eWxlKCk7XG4gICAgICAgIHByb3BlcnRpZXMgPSBleHRlbmQoe30sIHByb3BlcnRpZXMsIHBhcmFtcyk7XG4gICAgICAgIHZhciBwcm9wZXJ0aWVzRW1wdHkgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKS5sZW5ndGggPT09IDA7XG5cbiAgICAgICAgaWYgKHByb3BlcnRpZXNFbXB0eSkge1xuICAgICAgICAgIHJldHVybiBuZXcgQW5pbWF0aW9uKGFsbFswXSwgcHJvcGVydGllcyk7IC8vIG5vdGhpbmcgdG8gYW5pbWF0ZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb3BlcnRpZXMuZHVyYXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHByb3BlcnRpZXMuZHVyYXRpb24gPSA0MDA7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKHByb3BlcnRpZXMuZHVyYXRpb24pIHtcbiAgICAgICAgICBjYXNlICdzbG93JzpcbiAgICAgICAgICAgIHByb3BlcnRpZXMuZHVyYXRpb24gPSA2MDA7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2Zhc3QnOlxuICAgICAgICAgICAgcHJvcGVydGllcy5kdXJhdGlvbiA9IDIwMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRWxlcykge1xuICAgICAgICAgIHByb3BlcnRpZXMuc3R5bGUgPSBzdHlsZS5nZXRQcm9wc0xpc3QocHJvcGVydGllcy5zdHlsZSB8fCBwcm9wZXJ0aWVzLmNzcyk7XG4gICAgICAgICAgcHJvcGVydGllcy5jc3MgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNFbGVzICYmIHByb3BlcnRpZXMucmVuZGVyZWRQb3NpdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgdmFyIHJwb3MgPSBwcm9wZXJ0aWVzLnJlbmRlcmVkUG9zaXRpb247XG4gICAgICAgICAgdmFyIHBhbiA9IGN5LnBhbigpO1xuICAgICAgICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuICAgICAgICAgIHByb3BlcnRpZXMucG9zaXRpb24gPSByZW5kZXJlZFRvTW9kZWxQb3NpdGlvbihycG9zLCB6b29tLCBwYW4pO1xuICAgICAgICB9IC8vIG92ZXJyaWRlIHBhbiB3LyBwYW5CeSBpZiBzZXRcblxuXG4gICAgICAgIGlmIChpc0NvcmUgJiYgcHJvcGVydGllcy5wYW5CeSAhPSBudWxsKSB7XG4gICAgICAgICAgdmFyIHBhbkJ5ID0gcHJvcGVydGllcy5wYW5CeTtcbiAgICAgICAgICB2YXIgY3lQYW4gPSBjeS5wYW4oKTtcbiAgICAgICAgICBwcm9wZXJ0aWVzLnBhbiA9IHtcbiAgICAgICAgICAgIHg6IGN5UGFuLnggKyBwYW5CeS54LFxuICAgICAgICAgICAgeTogY3lQYW4ueSArIHBhbkJ5LnlcbiAgICAgICAgICB9O1xuICAgICAgICB9IC8vIG92ZXJyaWRlIHBhbiB3LyBjZW50ZXIgaWYgc2V0XG5cblxuICAgICAgICB2YXIgY2VudGVyID0gcHJvcGVydGllcy5jZW50ZXIgfHwgcHJvcGVydGllcy5jZW50cmU7XG5cbiAgICAgICAgaWYgKGlzQ29yZSAmJiBjZW50ZXIgIT0gbnVsbCkge1xuICAgICAgICAgIHZhciBjZW50ZXJQYW4gPSBjeS5nZXRDZW50ZXJQYW4oY2VudGVyLmVsZXMsIHByb3BlcnRpZXMuem9vbSk7XG5cbiAgICAgICAgICBpZiAoY2VudGVyUGFuICE9IG51bGwpIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXMucGFuID0gY2VudGVyUGFuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBvdmVycmlkZSBwYW4gJiB6b29tIHcvIGZpdCBpZiBzZXRcblxuXG4gICAgICAgIGlmIChpc0NvcmUgJiYgcHJvcGVydGllcy5maXQgIT0gbnVsbCkge1xuICAgICAgICAgIHZhciBmaXQgPSBwcm9wZXJ0aWVzLmZpdDtcbiAgICAgICAgICB2YXIgZml0VnAgPSBjeS5nZXRGaXRWaWV3cG9ydChmaXQuZWxlcyB8fCBmaXQuYm91bmRpbmdCb3gsIGZpdC5wYWRkaW5nKTtcblxuICAgICAgICAgIGlmIChmaXRWcCAhPSBudWxsKSB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLnBhbiA9IGZpdFZwLnBhbjtcbiAgICAgICAgICAgIHByb3BlcnRpZXMuem9vbSA9IGZpdFZwLnpvb207XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIG92ZXJyaWRlIHpvb20gKCYgcG90ZW50aWFsbHkgcGFuKSB3LyB6b29tIG9iaiBpZiBzZXRcblxuXG4gICAgICAgIGlmIChpc0NvcmUgJiYgcGxhaW5PYmplY3QocHJvcGVydGllcy56b29tKSkge1xuICAgICAgICAgIHZhciB2cCA9IGN5LmdldFpvb21lZFZpZXdwb3J0KHByb3BlcnRpZXMuem9vbSk7XG5cbiAgICAgICAgICBpZiAodnAgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHZwLnpvb21lZCkge1xuICAgICAgICAgICAgICBwcm9wZXJ0aWVzLnpvb20gPSB2cC56b29tO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodnAucGFubmVkKSB7XG4gICAgICAgICAgICAgIHByb3BlcnRpZXMucGFuID0gdnAucGFuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLnpvb20gPSBudWxsOyAvLyBhbiBpbmF2YWxpZCB6b29tIChlLmcuIG5vIGRlbHRhKSBnZXRzIGF1dG9tYXRpY2FsbHkgZGVzdHJveWVkXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBBbmltYXRpb24oYWxsWzBdLCBwcm9wZXJ0aWVzKTtcbiAgICAgIH07XG4gICAgfSxcbiAgICAvLyBhbmltYXRlXG4gICAgYW5pbWF0ZTogZnVuY3Rpb24gYW5pbWF0ZSgpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBhbmltYXRlSW1wbChwcm9wZXJ0aWVzLCBwYXJhbXMpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGFsbCA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGYgOiBbc2VsZl07IC8vIHB1dCBpbiBhcnJheSBpZiBub3QgYXJyYXktbGlrZVxuXG4gICAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3kgfHwgdGhpcztcblxuICAgICAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyYW1zKSB7XG4gICAgICAgICAgcHJvcGVydGllcyA9IGV4dGVuZCh7fSwgcHJvcGVydGllcywgcGFyYW1zKTtcbiAgICAgICAgfSAvLyBtYW51YWxseSBob29rIGFuZCBydW4gdGhlIGFuaW1hdGlvblxuXG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZWxlID0gYWxsW2ldO1xuICAgICAgICAgIHZhciBxdWV1ZSA9IGVsZS5hbmltYXRlZCgpICYmIChwcm9wZXJ0aWVzLnF1ZXVlID09PSB1bmRlZmluZWQgfHwgcHJvcGVydGllcy5xdWV1ZSk7XG4gICAgICAgICAgdmFyIGFuaSA9IGVsZS5hbmltYXRpb24ocHJvcGVydGllcywgcXVldWUgPyB7XG4gICAgICAgICAgICBxdWV1ZTogdHJ1ZVxuICAgICAgICAgIH0gOiB1bmRlZmluZWQpO1xuICAgICAgICAgIGFuaS5wbGF5KCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICAgIH07XG4gICAgfSxcbiAgICAvLyBhbmltYXRlXG4gICAgc3RvcDogZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBzdG9wSW1wbChjbGVhclF1ZXVlLCBqdW1wVG9FbmQpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGFsbCA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGYgOiBbc2VsZl07IC8vIHB1dCBpbiBhcnJheSBpZiBub3QgYXJyYXktbGlrZVxuXG4gICAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3kgfHwgdGhpcztcblxuICAgICAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBlbGUgPSBhbGxbaV07XG4gICAgICAgICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgICAgICAgIHZhciBhbmlzID0gX3AuYW5pbWF0aW9uLmN1cnJlbnQ7XG5cbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGFuaXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBhbmkgPSBhbmlzW2pdO1xuICAgICAgICAgICAgdmFyIGFuaV9wID0gYW5pLl9wcml2YXRlO1xuXG4gICAgICAgICAgICBpZiAoanVtcFRvRW5kKSB7XG4gICAgICAgICAgICAgIC8vIG5leHQgaXRlcmF0aW9uIG9mIHRoZSBhbmltYXRpb24gbG9vcCwgdGhlIGFuaW1hdGlvblxuICAgICAgICAgICAgICAvLyB3aWxsIGdvIHN0cmFpZ2h0IHRvIHRoZSBlbmQgYW5kIGJlIHJlbW92ZWRcbiAgICAgICAgICAgICAgYW5pX3AuZHVyYXRpb24gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gY2xlYXIgdGhlIHF1ZXVlIG9mIGZ1dHVyZSBhbmltYXRpb25zXG5cblxuICAgICAgICAgIGlmIChjbGVhclF1ZXVlKSB7XG4gICAgICAgICAgICBfcC5hbmltYXRpb24ucXVldWUgPSBbXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWp1bXBUb0VuZCkge1xuICAgICAgICAgICAgX3AuYW5pbWF0aW9uLmN1cnJlbnQgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gd2UgaGF2ZSB0byBub3RpZnkgKHRoZSBhbmltYXRpb24gbG9vcCBkb2Vzbid0IGRvIGl0IGZvciB1cyBvbiBgc3RvcGApXG5cblxuICAgICAgICBjeS5ub3RpZnkoJ2RyYXcnKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuICAgIH0gLy8gc3RvcFxuXG4gIH07IC8vIGRlZmluZVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSAwLjEuMFxuICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKlxuICAgKiBfLmlzQXJyYXkoJ2FiYycpO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKlxuICAgKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICovXG4gIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuICB2YXIgaXNBcnJheV8xID0gaXNBcnJheTtcblxuICAvKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG4gIHZhciByZUlzRGVlcFByb3AgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqP1xcMSlcXF0vLFxuICAgICAgcmVJc1BsYWluUHJvcCA9IC9eXFx3KiQvO1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUgYW5kIG5vdCBhIHByb3BlcnR5IHBhdGguXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGlzS2V5KHZhbHVlLCBvYmplY3QpIHtcbiAgICBpZiAoaXNBcnJheV8xKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICBpZiAodHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgIHZhbHVlID09IG51bGwgfHwgaXNTeW1ib2xfMSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVJc1BsYWluUHJvcC50ZXN0KHZhbHVlKSB8fCAhcmVJc0RlZXBQcm9wLnRlc3QodmFsdWUpIHx8XG4gICAgICAob2JqZWN0ICE9IG51bGwgJiYgdmFsdWUgaW4gT2JqZWN0KG9iamVjdCkpO1xuICB9XG5cbiAgdmFyIF9pc0tleSA9IGlzS2V5O1xuXG4gIC8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbiAgdmFyIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuICAgICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nO1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDAuMS4wXG4gICAqIEBjYXRlZ29yeSBMYW5nXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uaXNGdW5jdGlvbihfKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKi9cbiAgZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmICghaXNPYmplY3RfMSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gICAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gICAgdmFyIHRhZyA9IF9iYXNlR2V0VGFnKHZhbHVlKTtcbiAgICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xuICB9XG5cbiAgdmFyIGlzRnVuY3Rpb25fMSA9IGlzRnVuY3Rpb247XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xuICB2YXIgY29yZUpzRGF0YSA9IF9yb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxuICB2YXIgX2NvcmVKc0RhdGEgPSBjb3JlSnNEYXRhO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG4gIHZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciB1aWQgPSAvW14uXSskLy5leGVjKF9jb3JlSnNEYXRhICYmIF9jb3JlSnNEYXRhLmtleXMgJiYgX2NvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gICAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xuICB9KCkpO1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gICAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcbiAgfVxuXG4gIHZhciBfaXNNYXNrZWQgPSBpc01hc2tlZDtcblxuICAvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG4gIHZhciBmdW5jUHJvdG8kMSA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcblxuICAvKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG4gIHZhciBmdW5jVG9TdHJpbmckMSA9IGZ1bmNQcm90byQxLnRvU3RyaW5nO1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAgICovXG4gIGZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZnVuY1RvU3RyaW5nJDEuY2FsbChmdW5jKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH1cbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB2YXIgX3RvU291cmNlID0gdG9Tb3VyY2U7XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAgICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gICAqL1xuICB2YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbiAgdmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbiAgLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuICB2YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgICAgb2JqZWN0UHJvdG8kMyA9IE9iamVjdC5wcm90b3R5cGU7XG5cbiAgLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xuICB2YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4gIC8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xuICB2YXIgaGFzT3duUHJvcGVydHkkMyA9IG9iamVjdFByb3RvJDMuaGFzT3duUHJvcGVydHk7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbiAgdmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSQzKS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gICAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4gICk7XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gICAgaWYgKCFpc09iamVjdF8xKHZhbHVlKSB8fCBfaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBwYXR0ZXJuID0gaXNGdW5jdGlvbl8xKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gICAgcmV0dXJuIHBhdHRlcm4udGVzdChfdG9Tb3VyY2UodmFsdWUpKTtcbiAgfVxuXG4gIHZhciBfYmFzZUlzTmF0aXZlID0gYmFzZUlzTmF0aXZlO1xuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRWYWx1ZSQxKG9iamVjdCwga2V5KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIH1cblxuICB2YXIgX2dldFZhbHVlID0gZ2V0VmFsdWUkMTtcblxuICAvKipcbiAgICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gICAgdmFyIHZhbHVlID0gX2dldFZhbHVlKG9iamVjdCwga2V5KTtcbiAgICByZXR1cm4gX2Jhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHZhciBfZ2V0TmF0aXZlID0gZ2V0TmF0aXZlO1xuXG4gIC8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbiAgdmFyIG5hdGl2ZUNyZWF0ZSA9IF9nZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbiAgdmFyIF9uYXRpdmVDcmVhdGUgPSBuYXRpdmVDcmVhdGU7XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBuYW1lIGNsZWFyXG4gICAqIEBtZW1iZXJPZiBIYXNoXG4gICAqL1xuICBmdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gICAgdGhpcy5fX2RhdGFfXyA9IF9uYXRpdmVDcmVhdGUgPyBfbmF0aXZlQ3JlYXRlKG51bGwpIDoge307XG4gICAgdGhpcy5zaXplID0gMDtcbiAgfVxuXG4gIHZhciBfaGFzaENsZWFyID0gaGFzaENsZWFyO1xuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG5hbWUgZGVsZXRlXG4gICAqIEBtZW1iZXJPZiBIYXNoXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHZhciBfaGFzaERlbGV0ZSA9IGhhc2hEZWxldGU7XG5cbiAgLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xuICB2YXIgSEFTSF9VTkRFRklORUQkMSA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuICAvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG4gIHZhciBvYmplY3RQcm90byQyID0gT2JqZWN0LnByb3RvdHlwZTtcblxuICAvKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbiAgdmFyIGhhc093blByb3BlcnR5JDIgPSBvYmplY3RQcm90byQyLmhhc093blByb3BlcnR5O1xuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG5hbWUgZ2V0XG4gICAqIEBtZW1iZXJPZiBIYXNoXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gICAqL1xuICBmdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgICBpZiAoX25hdGl2ZUNyZWF0ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEJDEgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eSQyLmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHZhciBfaGFzaEdldCA9IGhhc2hHZXQ7XG5cbiAgLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuICB2YXIgb2JqZWN0UHJvdG8kMSA9IE9iamVjdC5wcm90b3R5cGU7XG5cbiAgLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG4gIHZhciBoYXNPd25Qcm9wZXJ0eSQxID0gb2JqZWN0UHJvdG8kMS5oYXNPd25Qcm9wZXJ0eTtcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbmFtZSBoYXNcbiAgICogQG1lbWJlck9mIEhhc2hcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICAgIHJldHVybiBfbmF0aXZlQ3JlYXRlID8gKGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkKSA6IGhhc093blByb3BlcnR5JDEuY2FsbChkYXRhLCBrZXkpO1xuICB9XG5cbiAgdmFyIF9oYXNoSGFzID0gaGFzaEhhcztcblxuICAvKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG4gIHZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuICAvKipcbiAgICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbmFtZSBzZXRcbiAgICogQG1lbWJlck9mIEhhc2hcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaGFzaCBpbnN0YW5jZS5cbiAgICovXG4gIGZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICAgIGRhdGFba2V5XSA9IChfbmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHZhciBfaGFzaFNldCA9IGhhc2hTZXQ7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICAgKi9cbiAgZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICAgIHRoaXMuY2xlYXIoKTtcbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbiAgSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBfaGFzaENsZWFyO1xuICBIYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBfaGFzaERlbGV0ZTtcbiAgSGFzaC5wcm90b3R5cGUuZ2V0ID0gX2hhc2hHZXQ7XG4gIEhhc2gucHJvdG90eXBlLmhhcyA9IF9oYXNoSGFzO1xuICBIYXNoLnByb3RvdHlwZS5zZXQgPSBfaGFzaFNldDtcblxuICB2YXIgX0hhc2ggPSBIYXNoO1xuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbmFtZSBjbGVhclxuICAgKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gICAqL1xuICBmdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgICB0aGlzLl9fZGF0YV9fID0gW107XG4gICAgdGhpcy5zaXplID0gMDtcbiAgfVxuXG4gIHZhciBfbGlzdENhY2hlQ2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcblxuICAvKipcbiAgICogUGVyZm9ybXMgYVxuICAgKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgNC4wLjBcbiAgICogQGNhdGVnb3J5IExhbmdcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gICAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gICAqXG4gICAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqXG4gICAqIF8uZXEoJ2EnLCAnYScpO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqXG4gICAqIF8uZXEoTmFOLCBOYU4pO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqL1xuICBmdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbiAgfVxuXG4gIHZhciBlcV8xID0gZXE7XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIGlmIChlcV8xKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgdmFyIF9hc3NvY0luZGV4T2YgPSBhc3NvY0luZGV4T2Y7XG5cbiAgLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuICB2YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxuICAvKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbiAgdmFyIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlO1xuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG5hbWUgZGVsZXRlXG4gICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICAgIGluZGV4ID0gX2Fzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICAgIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICAgIGRhdGEucG9wKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgICB9XG4gICAgLS10aGlzLnNpemU7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgX2xpc3RDYWNoZURlbGV0ZSA9IGxpc3RDYWNoZURlbGV0ZTtcblxuICAvKipcbiAgICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBuYW1lIGdldFxuICAgKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gICAqL1xuICBmdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgICBpbmRleCA9IF9hc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICAgIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbiAgfVxuXG4gIHZhciBfbGlzdENhY2hlR2V0ID0gbGlzdENhY2hlR2V0O1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBuYW1lIGhhc1xuICAgKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gICAgcmV0dXJuIF9hc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xuICB9XG5cbiAgdmFyIF9saXN0Q2FjaGVIYXMgPSBsaXN0Q2FjaGVIYXM7XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG5hbWUgc2V0XG4gICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAgICovXG4gIGZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgICBpbmRleCA9IF9hc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICsrdGhpcy5zaXplO1xuICAgICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyIF9saXN0Q2FjaGVTZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAgICovXG4gIGZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICAgIHRoaXMuY2xlYXIoKTtcbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuICBMaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gX2xpc3RDYWNoZUNsZWFyO1xuICBMaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IF9saXN0Q2FjaGVEZWxldGU7XG4gIExpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gX2xpc3RDYWNoZUdldDtcbiAgTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBfbGlzdENhY2hlSGFzO1xuICBMaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IF9saXN0Q2FjaGVTZXQ7XG5cbiAgdmFyIF9MaXN0Q2FjaGUgPSBMaXN0Q2FjaGU7XG5cbiAgLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xuICB2YXIgTWFwJDEgPSBfZ2V0TmF0aXZlKF9yb290LCAnTWFwJyk7XG5cbiAgdmFyIF9NYXAgPSBNYXAkMTtcblxuICAvKipcbiAgICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbmFtZSBjbGVhclxuICAgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAgICovXG4gIGZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gICAgdGhpcy5zaXplID0gMDtcbiAgICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICAgJ2hhc2gnOiBuZXcgX0hhc2gsXG4gICAgICAnbWFwJzogbmV3IChfTWFwIHx8IF9MaXN0Q2FjaGUpLFxuICAgICAgJ3N0cmluZyc6IG5ldyBfSGFzaFxuICAgIH07XG4gIH1cblxuICB2YXIgX21hcENhY2hlQ2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XG4gIH1cblxuICB2YXIgX2lzS2V5YWJsZSA9IGlzS2V5YWJsZTtcblxuICAvKipcbiAgICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICAgIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICAgIHJldHVybiBfaXNLZXlhYmxlKGtleSlcbiAgICAgID8gZGF0YVt0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8gJ3N0cmluZycgOiAnaGFzaCddXG4gICAgICA6IGRhdGEubWFwO1xuICB9XG5cbiAgdmFyIF9nZXRNYXBEYXRhID0gZ2V0TWFwRGF0YTtcblxuICAvKipcbiAgICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG5hbWUgZGVsZXRlXG4gICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG4gICAgdmFyIHJlc3VsdCA9IF9nZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gICAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgX21hcENhY2hlRGVsZXRlID0gbWFwQ2FjaGVEZWxldGU7XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBuYW1lIGdldFxuICAgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAgICovXG4gIGZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICAgIHJldHVybiBfZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xuICB9XG5cbiAgdmFyIF9tYXBDYWNoZUdldCA9IG1hcENhY2hlR2V0O1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG5hbWUgaGFzXG4gICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gICAgcmV0dXJuIF9nZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG4gIH1cblxuICB2YXIgX21hcENhY2hlSGFzID0gbWFwQ2FjaGVIYXM7XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbmFtZSBzZXRcbiAgICogQG1lbWJlck9mIE1hcENhY2hlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAgICovXG4gIGZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgICB2YXIgZGF0YSA9IF9nZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cbiAgICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHZhciBfbWFwQ2FjaGVTZXQgPSBtYXBDYWNoZVNldDtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gICAqL1xuICBmdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICAgIHRoaXMuY2xlYXIoKTtcbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG4gIE1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IF9tYXBDYWNoZUNsZWFyO1xuICBNYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gX21hcENhY2hlRGVsZXRlO1xuICBNYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gX21hcENhY2hlR2V0O1xuICBNYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gX21hcENhY2hlSGFzO1xuICBNYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gX21hcENhY2hlU2V0O1xuXG4gIHZhciBfTWFwQ2FjaGUgPSBNYXBDYWNoZTtcblxuICAvKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG4gIHZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gICAqIHByb3ZpZGVkLCBpdCBkZXRlcm1pbmVzIHRoZSBjYWNoZSBrZXkgZm9yIHN0b3JpbmcgdGhlIHJlc3VsdCBiYXNlZCBvbiB0aGVcbiAgICogYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0IGFyZ3VtZW50XG4gICAqIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBtYXAgY2FjaGUga2V5LiBUaGUgYGZ1bmNgXG4gICAqIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICAgKlxuICAgKiAqKk5vdGU6KiogVGhlIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkXG4gICAqIGZ1bmN0aW9uLiBJdHMgY3JlYXRpb24gbWF5IGJlIGN1c3RvbWl6ZWQgYnkgcmVwbGFjaW5nIHRoZSBgXy5tZW1vaXplLkNhY2hlYFxuICAgKiBjb25zdHJ1Y3RvciB3aXRoIG9uZSB3aG9zZSBpbnN0YW5jZXMgaW1wbGVtZW50IHRoZVxuICAgKiBbYE1hcGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLW1hcC1wcm90b3R5cGUtb2JqZWN0KVxuICAgKiBtZXRob2QgaW50ZXJmYWNlIG9mIGBjbGVhcmAsIGBkZWxldGVgLCBgZ2V0YCwgYGhhc2AsIGFuZCBgc2V0YC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgMC4xLjBcbiAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVyXSBUaGUgZnVuY3Rpb24gdG8gcmVzb2x2ZSB0aGUgY2FjaGUga2V5LlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAgICogdmFyIG90aGVyID0geyAnYyc6IDMsICdkJzogNCB9O1xuICAgKlxuICAgKiB2YXIgdmFsdWVzID0gXy5tZW1vaXplKF8udmFsdWVzKTtcbiAgICogdmFsdWVzKG9iamVjdCk7XG4gICAqIC8vID0+IFsxLCAyXVxuICAgKlxuICAgKiB2YWx1ZXMob3RoZXIpO1xuICAgKiAvLyA9PiBbMywgNF1cbiAgICpcbiAgICogb2JqZWN0LmEgPSAyO1xuICAgKiB2YWx1ZXMob2JqZWN0KTtcbiAgICogLy8gPT4gWzEsIDJdXG4gICAqXG4gICAqIC8vIE1vZGlmeSB0aGUgcmVzdWx0IGNhY2hlLlxuICAgKiB2YWx1ZXMuY2FjaGUuc2V0KG9iamVjdCwgWydhJywgJ2InXSk7XG4gICAqIHZhbHVlcyhvYmplY3QpO1xuICAgKiAvLyA9PiBbJ2EnLCAnYiddXG4gICAqXG4gICAqIC8vIFJlcGxhY2UgYF8ubWVtb2l6ZS5DYWNoZWAuXG4gICAqIF8ubWVtb2l6ZS5DYWNoZSA9IFdlYWtNYXA7XG4gICAqL1xuICBmdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG4gICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicgfHwgKHJlc29sdmVyICE9IG51bGwgJiYgdHlwZW9mIHJlc29sdmVyICE9ICdmdW5jdGlvbicpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgfVxuICAgIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAga2V5ID0gcmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmdzKSA6IGFyZ3NbMF0sXG4gICAgICAgICAgY2FjaGUgPSBtZW1vaXplZC5jYWNoZTtcblxuICAgICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgbWVtb2l6ZWQuY2FjaGUgPSBjYWNoZS5zZXQoa2V5LCByZXN1bHQpIHx8IGNhY2hlO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIG1lbW9pemVkLmNhY2hlID0gbmV3IChtZW1vaXplLkNhY2hlIHx8IF9NYXBDYWNoZSk7XG4gICAgcmV0dXJuIG1lbW9pemVkO1xuICB9XG5cbiAgLy8gRXhwb3NlIGBNYXBDYWNoZWAuXG4gIG1lbW9pemUuQ2FjaGUgPSBfTWFwQ2FjaGU7XG5cbiAgdmFyIG1lbW9pemVfMSA9IG1lbW9pemU7XG5cbiAgLyoqIFVzZWQgYXMgdGhlIG1heGltdW0gbWVtb2l6ZSBjYWNoZSBzaXplLiAqL1xuICB2YXIgTUFYX01FTU9JWkVfU0laRSA9IDUwMDtcblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1lbW9pemVgIHdoaWNoIGNsZWFycyB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24nc1xuICAgKiBjYWNoZSB3aGVuIGl0IGV4Y2VlZHMgYE1BWF9NRU1PSVpFX1NJWkVgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gbWVtb2l6ZUNhcHBlZChmdW5jKSB7XG4gICAgdmFyIHJlc3VsdCA9IG1lbW9pemVfMShmdW5jLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgIGlmIChjYWNoZS5zaXplID09PSBNQVhfTUVNT0laRV9TSVpFKSB7XG4gICAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH0pO1xuXG4gICAgdmFyIGNhY2hlID0gcmVzdWx0LmNhY2hlO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgX21lbW9pemVDYXBwZWQgPSBtZW1vaXplQ2FwcGVkO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbiAgdmFyIHJlUHJvcE5hbWUgPSAvW14uW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JCkpL2c7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG4gIHZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZztcblxuICAvKipcbiAgICogQ29udmVydHMgYHN0cmluZ2AgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICAgKi9cbiAgdmFyIHN0cmluZ1RvUGF0aCA9IF9tZW1vaXplQ2FwcGVkKGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBpZiAoc3RyaW5nLmNoYXJDb2RlQXQoMCkgPT09IDQ2IC8qIC4gKi8pIHtcbiAgICAgIHJlc3VsdC5wdXNoKCcnKTtcbiAgICB9XG4gICAgc3RyaW5nLnJlcGxhY2UocmVQcm9wTmFtZSwgZnVuY3Rpb24obWF0Y2gsIG51bWJlciwgcXVvdGUsIHN1YlN0cmluZykge1xuICAgICAgcmVzdWx0LnB1c2gocXVvdGUgPyBzdWJTdHJpbmcucmVwbGFjZShyZUVzY2FwZUNoYXIsICckMScpIDogKG51bWJlciB8fCBtYXRjaCkpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0pO1xuXG4gIHZhciBfc3RyaW5nVG9QYXRoID0gc3RyaW5nVG9QYXRoO1xuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWFwYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAgICogc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHZhciBfYXJyYXlNYXAgPSBhcnJheU1hcDtcblxuICAvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbiAgdmFyIElORklOSVRZJDEgPSAxIC8gMDtcblxuICAvKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbiAgdmFyIHN5bWJvbFByb3RvID0gX1N5bWJvbCA/IF9TeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1N0cmluZ2Agd2hpY2ggZG9lc24ndCBjb252ZXJ0IG51bGxpc2hcbiAgICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAgIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAoaXNBcnJheV8xKHZhbHVlKSkge1xuICAgICAgLy8gUmVjdXJzaXZlbHkgY29udmVydCB2YWx1ZXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgIHJldHVybiBfYXJyYXlNYXAodmFsdWUsIGJhc2VUb1N0cmluZykgKyAnJztcbiAgICB9XG4gICAgaWYgKGlzU3ltYm9sXzEodmFsdWUpKSB7XG4gICAgICByZXR1cm4gc3ltYm9sVG9TdHJpbmcgPyBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICAgIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkkMSkgPyAnLTAnIDogcmVzdWx0O1xuICB9XG5cbiAgdmFyIF9iYXNlVG9TdHJpbmcgPSBiYXNlVG9TdHJpbmc7XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBmb3IgYG51bGxgXG4gICAqIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSA0LjAuMFxuICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLnRvU3RyaW5nKG51bGwpO1xuICAgKiAvLyA9PiAnJ1xuICAgKlxuICAgKiBfLnRvU3RyaW5nKC0wKTtcbiAgICogLy8gPT4gJy0wJ1xuICAgKlxuICAgKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XG4gICAqIC8vID0+ICcxLDIsMydcbiAgICovXG4gIGZ1bmN0aW9uIHRvU3RyaW5nJDEodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogX2Jhc2VUb1N0cmluZyh2YWx1ZSk7XG4gIH1cblxuICB2YXIgdG9TdHJpbmdfMSA9IHRvU3RyaW5nJDE7XG5cbiAgLyoqXG4gICAqIENhc3RzIGB2YWx1ZWAgdG8gYSBwYXRoIGFycmF5IGlmIGl0J3Mgbm90IG9uZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IHByb3BlcnR5IHBhdGggYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiBjYXN0UGF0aCh2YWx1ZSwgb2JqZWN0KSB7XG4gICAgaWYgKGlzQXJyYXlfMSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIF9pc0tleSh2YWx1ZSwgb2JqZWN0KSA/IFt2YWx1ZV0gOiBfc3RyaW5nVG9QYXRoKHRvU3RyaW5nXzEodmFsdWUpKTtcbiAgfVxuXG4gIHZhciBfY2FzdFBhdGggPSBjYXN0UGF0aDtcblxuICAvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbiAgdmFyIElORklOSVRZID0gMSAvIDA7XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcga2V5IGlmIGl0J3Mgbm90IGEgc3RyaW5nIG9yIHN5bWJvbC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAgICovXG4gIGZ1bmN0aW9uIHRvS2V5KHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbF8xKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICAgIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbiAgfVxuXG4gIHZhciBfdG9LZXkgPSB0b0tleTtcblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZ2V0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZmF1bHQgdmFsdWVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VHZXQob2JqZWN0LCBwYXRoKSB7XG4gICAgcGF0aCA9IF9jYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gICAgdmFyIGluZGV4ID0gMCxcbiAgICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cbiAgICB3aGlsZSAob2JqZWN0ICE9IG51bGwgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIG9iamVjdCA9IG9iamVjdFtfdG9LZXkocGF0aFtpbmRleCsrXSldO1xuICAgIH1cbiAgICByZXR1cm4gKGluZGV4ICYmIGluZGV4ID09IGxlbmd0aCkgPyBvYmplY3QgOiB1bmRlZmluZWQ7XG4gIH1cblxuICB2YXIgX2Jhc2VHZXQgPSBiYXNlR2V0O1xuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuIElmIHRoZSByZXNvbHZlZCB2YWx1ZSBpc1xuICAgKiBgdW5kZWZpbmVkYCwgdGhlIGBkZWZhdWx0VmFsdWVgIGlzIHJldHVybmVkIGluIGl0cyBwbGFjZS5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgMy43LjBcbiAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHJldHVybmVkIGZvciBgdW5kZWZpbmVkYCByZXNvbHZlZCB2YWx1ZXMuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAgICpcbiAgICogXy5nZXQob2JqZWN0LCAnYVswXS5iLmMnKTtcbiAgICogLy8gPT4gM1xuICAgKlxuICAgKiBfLmdldChvYmplY3QsIFsnYScsICcwJywgJ2InLCAnYyddKTtcbiAgICogLy8gPT4gM1xuICAgKlxuICAgKiBfLmdldChvYmplY3QsICdhLmIuYycsICdkZWZhdWx0Jyk7XG4gICAqIC8vID0+ICdkZWZhdWx0J1xuICAgKi9cbiAgZnVuY3Rpb24gZ2V0KG9iamVjdCwgcGF0aCwgZGVmYXVsdFZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogX2Jhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0VmFsdWUgOiByZXN1bHQ7XG4gIH1cblxuICB2YXIgZ2V0XzEgPSBnZXQ7XG5cbiAgdmFyIGRlZmluZVByb3BlcnR5ID0gKGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICB2YXIgZnVuYyA9IF9nZXROYXRpdmUoT2JqZWN0LCAnZGVmaW5lUHJvcGVydHknKTtcbiAgICAgIGZ1bmMoe30sICcnLCB7fSk7XG4gICAgICByZXR1cm4gZnVuYztcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9KCkpO1xuXG4gIHZhciBfZGVmaW5lUHJvcGVydHkgPSBkZWZpbmVQcm9wZXJ0eTtcblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGFzc2lnblZhbHVlYCBhbmQgYGFzc2lnbk1lcmdlVmFsdWVgIHdpdGhvdXRcbiAgICogdmFsdWUgY2hlY2tzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICAgIGlmIChrZXkgPT0gJ19fcHJvdG9fXycgJiYgX2RlZmluZVByb3BlcnR5KSB7XG4gICAgICBfZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHtcbiAgICAgICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgICAgICdlbnVtZXJhYmxlJzogdHJ1ZSxcbiAgICAgICAgJ3ZhbHVlJzogdmFsdWUsXG4gICAgICAgICd3cml0YWJsZSc6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBfYmFzZUFzc2lnblZhbHVlID0gYmFzZUFzc2lnblZhbHVlO1xuXG4gIC8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbiAgdmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuICAvKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbiAgdmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbiAgLyoqXG4gICAqIEFzc2lnbnMgYHZhbHVlYCB0byBga2V5YCBvZiBgb2JqZWN0YCBpZiB0aGUgZXhpc3RpbmcgdmFsdWUgaXMgbm90IGVxdWl2YWxlbnRcbiAgICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICAgKi9cbiAgZnVuY3Rpb24gYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV07XG4gICAgaWYgKCEoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYgZXFfMShvYmpWYWx1ZSwgdmFsdWUpKSB8fFxuICAgICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgICAgX2Jhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBfYXNzaWduVmFsdWUgPSBhc3NpZ25WYWx1ZTtcblxuICAvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbiAgdmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbiAgdmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG5cbiAgICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAgICh0eXBlID09ICdudW1iZXInIHx8XG4gICAgICAgICh0eXBlICE9ICdzeW1ib2wnICYmIHJlSXNVaW50LnRlc3QodmFsdWUpKSkgJiZcbiAgICAgICAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG4gIH1cblxuICB2YXIgX2lzSW5kZXggPSBpc0luZGV4O1xuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zZXRgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIHBhdGggY3JlYXRpb24uXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlU2V0KG9iamVjdCwgcGF0aCwgdmFsdWUsIGN1c3RvbWl6ZXIpIHtcbiAgICBpZiAoIWlzT2JqZWN0XzEob2JqZWN0KSkge1xuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG4gICAgcGF0aCA9IF9jYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoLFxuICAgICAgICBsYXN0SW5kZXggPSBsZW5ndGggLSAxLFxuICAgICAgICBuZXN0ZWQgPSBvYmplY3Q7XG5cbiAgICB3aGlsZSAobmVzdGVkICE9IG51bGwgJiYgKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIGtleSA9IF90b0tleShwYXRoW2luZGV4XSksXG4gICAgICAgICAgbmV3VmFsdWUgPSB2YWx1ZTtcblxuICAgICAgaWYgKGtleSA9PT0gJ19fcHJvdG9fXycgfHwga2V5ID09PSAnY29uc3RydWN0b3InIHx8IGtleSA9PT0gJ3Byb3RvdHlwZScpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH1cblxuICAgICAgaWYgKGluZGV4ICE9IGxhc3RJbmRleCkge1xuICAgICAgICB2YXIgb2JqVmFsdWUgPSBuZXN0ZWRba2V5XTtcbiAgICAgICAgbmV3VmFsdWUgPSBjdXN0b21pemVyID8gY3VzdG9taXplcihvYmpWYWx1ZSwga2V5LCBuZXN0ZWQpIDogdW5kZWZpbmVkO1xuICAgICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG5ld1ZhbHVlID0gaXNPYmplY3RfMShvYmpWYWx1ZSlcbiAgICAgICAgICAgID8gb2JqVmFsdWVcbiAgICAgICAgICAgIDogKF9pc0luZGV4KHBhdGhbaW5kZXggKyAxXSkgPyBbXSA6IHt9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgX2Fzc2lnblZhbHVlKG5lc3RlZCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgICBuZXN0ZWQgPSBuZXN0ZWRba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxuXG4gIHZhciBfYmFzZVNldCA9IGJhc2VTZXQ7XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC4gSWYgYSBwb3J0aW9uIG9mIGBwYXRoYCBkb2Vzbid0IGV4aXN0LFxuICAgKiBpdCdzIGNyZWF0ZWQuIEFycmF5cyBhcmUgY3JlYXRlZCBmb3IgbWlzc2luZyBpbmRleCBwcm9wZXJ0aWVzIHdoaWxlIG9iamVjdHNcbiAgICogYXJlIGNyZWF0ZWQgZm9yIGFsbCBvdGhlciBtaXNzaW5nIHByb3BlcnRpZXMuIFVzZSBgXy5zZXRXaXRoYCB0byBjdXN0b21pemVcbiAgICogYHBhdGhgIGNyZWF0aW9uLlxuICAgKlxuICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgMy43LjBcbiAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gICAqXG4gICAqIF8uc2V0KG9iamVjdCwgJ2FbMF0uYi5jJywgNCk7XG4gICAqIGNvbnNvbGUubG9nKG9iamVjdC5hWzBdLmIuYyk7XG4gICAqIC8vID0+IDRcbiAgICpcbiAgICogXy5zZXQob2JqZWN0LCBbJ3gnLCAnMCcsICd5JywgJ3onXSwgNSk7XG4gICAqIGNvbnNvbGUubG9nKG9iamVjdC54WzBdLnkueik7XG4gICAqIC8vID0+IDVcbiAgICovXG4gIGZ1bmN0aW9uIHNldChvYmplY3QsIHBhdGgsIHZhbHVlKSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogX2Jhc2VTZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSk7XG4gIH1cblxuICB2YXIgc2V0XzEgPSBzZXQ7XG5cbiAgLyoqXG4gICAqIENvcGllcyB0aGUgdmFsdWVzIG9mIGBzb3VyY2VgIHRvIGBhcnJheWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgZnJvbS5cbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgdG8uXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgKi9cbiAgZnVuY3Rpb24gY29weUFycmF5KHNvdXJjZSwgYXJyYXkpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcblxuICAgIGFycmF5IHx8IChhcnJheSA9IEFycmF5KGxlbmd0aCkpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBhcnJheVtpbmRleF0gPSBzb3VyY2VbaW5kZXhdO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICB2YXIgX2NvcHlBcnJheSA9IGNvcHlBcnJheTtcblxuICAvKipcbiAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDQuMC4wXG4gICAqIEBjYXRlZ29yeSBVdGlsXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHByb3BlcnR5IHBhdGggYXJyYXkuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8udG9QYXRoKCdhLmIuYycpO1xuICAgKiAvLyA9PiBbJ2EnLCAnYicsICdjJ11cbiAgICpcbiAgICogXy50b1BhdGgoJ2FbMF0uYi5jJyk7XG4gICAqIC8vID0+IFsnYScsICcwJywgJ2InLCAnYyddXG4gICAqL1xuICBmdW5jdGlvbiB0b1BhdGgodmFsdWUpIHtcbiAgICBpZiAoaXNBcnJheV8xKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIF9hcnJheU1hcCh2YWx1ZSwgX3RvS2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIGlzU3ltYm9sXzEodmFsdWUpID8gW3ZhbHVlXSA6IF9jb3B5QXJyYXkoX3N0cmluZ1RvUGF0aCh0b1N0cmluZ18xKHZhbHVlKSkpO1xuICB9XG5cbiAgdmFyIHRvUGF0aF8xID0gdG9QYXRoO1xuXG4gIHZhciBkZWZpbmUkMiA9IHtcbiAgICAvLyBhY2Nlc3MgZGF0YSBmaWVsZFxuICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEocGFyYW1zKSB7XG4gICAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICAgIGZpZWxkOiAnZGF0YScsXG4gICAgICAgIGJpbmRpbmdFdmVudDogJ2RhdGEnLFxuICAgICAgICBhbGxvd0JpbmRpbmc6IGZhbHNlLFxuICAgICAgICBhbGxvd1NldHRpbmc6IGZhbHNlLFxuICAgICAgICBhbGxvd0dldHRpbmc6IGZhbHNlLFxuICAgICAgICBzZXR0aW5nRXZlbnQ6ICdkYXRhJyxcbiAgICAgICAgc2V0dGluZ1RyaWdnZXJzRXZlbnQ6IGZhbHNlLFxuICAgICAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgICAgIGltbXV0YWJsZUtleXM6IHt9LFxuICAgICAgICAvLyBrZXkgPT4gdHJ1ZSBpZiBpbW11dGFibGVcbiAgICAgICAgdXBkYXRlU3R5bGU6IGZhbHNlLFxuICAgICAgICBiZWZvcmVHZXQ6IGZ1bmN0aW9uIGJlZm9yZUdldChzZWxmKSB7fSxcbiAgICAgICAgYmVmb3JlU2V0OiBmdW5jdGlvbiBiZWZvcmVTZXQoc2VsZiwgb2JqKSB7fSxcbiAgICAgICAgb25TZXQ6IGZ1bmN0aW9uIG9uU2V0KHNlbGYpIHt9LFxuICAgICAgICBjYW5TZXQ6IGZ1bmN0aW9uIGNhblNldChzZWxmKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBwYXJhbXMgPSBleHRlbmQoe30sIGRlZmF1bHRzLCBwYXJhbXMpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGRhdGFJbXBsKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHZhciBwID0gcGFyYW1zO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBzZWxmSXNBcnJheUxpa2UgPSBzZWxmLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgYWxsID0gc2VsZklzQXJyYXlMaWtlID8gc2VsZiA6IFtzZWxmXTsgLy8gcHV0IGluIGFycmF5IGlmIG5vdCBhcnJheS1saWtlXG5cbiAgICAgICAgdmFyIHNpbmdsZSA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGZbMF0gOiBzZWxmOyAvLyAuZGF0YSgnZm9vJywgLi4uKVxuXG4gICAgICAgIGlmIChzdHJpbmcobmFtZSkpIHtcbiAgICAgICAgICAvLyBzZXQgb3IgZ2V0IHByb3BlcnR5XG4gICAgICAgICAgdmFyIGlzUGF0aExpa2UgPSBuYW1lLmluZGV4T2YoJy4nKSAhPT0gLTE7IC8vIHRoZXJlIG1pZ2h0IGJlIGEgbm9ybWFsIGZpZWxkIHdpdGggYSBkb3QgXG5cbiAgICAgICAgICB2YXIgcGF0aCA9IGlzUGF0aExpa2UgJiYgdG9QYXRoXzEobmFtZSk7IC8vIC5kYXRhKCdmb28nKVxuXG4gICAgICAgICAgaWYgKHAuYWxsb3dHZXR0aW5nICYmIHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIGdldFxuICAgICAgICAgICAgdmFyIHJldDtcblxuICAgICAgICAgICAgaWYgKHNpbmdsZSkge1xuICAgICAgICAgICAgICBwLmJlZm9yZUdldChzaW5nbGUpOyAvLyBjaGVjayBpZiBpdCdzIHBhdGggYW5kIGEgZmllbGQgd2l0aCB0aGUgc2FtZSBuYW1lIGRvZXNuJ3QgZXhpc3RcblxuICAgICAgICAgICAgICBpZiAocGF0aCAmJiBzaW5nbGUuX3ByaXZhdGVbcC5maWVsZF1bbmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldCA9IGdldF8xKHNpbmdsZS5fcHJpdmF0ZVtwLmZpZWxkXSwgcGF0aCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gc2luZ2xlLl9wcml2YXRlW3AuZmllbGRdW25hbWVdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXQ7IC8vIC5kYXRhKCdmb28nLCAnYmFyJylcbiAgICAgICAgICB9IGVsc2UgaWYgKHAuYWxsb3dTZXR0aW5nICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIHNldFxuICAgICAgICAgICAgdmFyIHZhbGlkID0gIXAuaW1tdXRhYmxlS2V5c1tuYW1lXTtcblxuICAgICAgICAgICAgaWYgKHZhbGlkKSB7XG4gICAgICAgICAgICAgIHZhciBjaGFuZ2UgPSBfZGVmaW5lUHJvcGVydHkkMSh7fSwgbmFtZSwgdmFsdWUpO1xuXG4gICAgICAgICAgICAgIHAuYmVmb3JlU2V0KHNlbGYsIGNoYW5nZSk7XG5cbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhbGwubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZSA9IGFsbFtpXTtcblxuICAgICAgICAgICAgICAgIGlmIChwLmNhblNldChlbGUpKSB7XG4gICAgICAgICAgICAgICAgICBpZiAocGF0aCAmJiBzaW5nbGUuX3ByaXZhdGVbcC5maWVsZF1bbmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBzZXRfMShlbGUuX3ByaXZhdGVbcC5maWVsZF0sIHBhdGgsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZS5fcHJpdmF0ZVtwLmZpZWxkXVtuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSAvLyB1cGRhdGUgbWFwcGVycyBpZiBhc2tlZFxuXG5cbiAgICAgICAgICAgICAgaWYgKHAudXBkYXRlU3R5bGUpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnVwZGF0ZVN0eWxlKCk7XG4gICAgICAgICAgICAgIH0gLy8gY2FsbCBvblNldCBjYWxsYmFja1xuXG5cbiAgICAgICAgICAgICAgcC5vblNldChzZWxmKTtcblxuICAgICAgICAgICAgICBpZiAocC5zZXR0aW5nVHJpZ2dlcnNFdmVudCkge1xuICAgICAgICAgICAgICAgIHNlbGZbcC50cmlnZ2VyRm5OYW1lXShwLnNldHRpbmdFdmVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIC5kYXRhKHsgJ2Zvbyc6ICdiYXInIH0pXG5cbiAgICAgICAgfSBlbHNlIGlmIChwLmFsbG93U2V0dGluZyAmJiBwbGFpbk9iamVjdChuYW1lKSkge1xuICAgICAgICAgIC8vIGV4dGVuZFxuICAgICAgICAgIHZhciBvYmogPSBuYW1lO1xuICAgICAgICAgIHZhciBrLCB2O1xuICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICAgICAgICBwLmJlZm9yZVNldChzZWxmLCBvYmopO1xuXG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGtleXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBrID0ga2V5c1tfaV07XG4gICAgICAgICAgICB2ID0gb2JqW2tdO1xuXG4gICAgICAgICAgICB2YXIgX3ZhbGlkID0gIXAuaW1tdXRhYmxlS2V5c1trXTtcblxuICAgICAgICAgICAgaWYgKF92YWxpZCkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGFsbC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHZhciBfZWxlID0gYWxsW2pdO1xuXG4gICAgICAgICAgICAgICAgaWYgKHAuY2FuU2V0KF9lbGUpKSB7XG4gICAgICAgICAgICAgICAgICBfZWxlLl9wcml2YXRlW3AuZmllbGRdW2tdID0gdjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIHVwZGF0ZSBtYXBwZXJzIGlmIGFza2VkXG5cblxuICAgICAgICAgIGlmIChwLnVwZGF0ZVN0eWxlKSB7XG4gICAgICAgICAgICBzZWxmLnVwZGF0ZVN0eWxlKCk7XG4gICAgICAgICAgfSAvLyBjYWxsIG9uU2V0IGNhbGxiYWNrXG5cblxuICAgICAgICAgIHAub25TZXQoc2VsZik7XG5cbiAgICAgICAgICBpZiAocC5zZXR0aW5nVHJpZ2dlcnNFdmVudCkge1xuICAgICAgICAgICAgc2VsZltwLnRyaWdnZXJGbk5hbWVdKHAuc2V0dGluZ0V2ZW50KTtcbiAgICAgICAgICB9IC8vIC5kYXRhKGZ1bmN0aW9uKCl7IC4uLiB9KVxuXG4gICAgICAgIH0gZWxzZSBpZiAocC5hbGxvd0JpbmRpbmcgJiYgZm4kNihuYW1lKSkge1xuICAgICAgICAgIC8vIGJpbmQgdG8gZXZlbnRcbiAgICAgICAgICB2YXIgZm4gPSBuYW1lO1xuICAgICAgICAgIHNlbGYub24ocC5iaW5kaW5nRXZlbnQsIGZuKTsgLy8gLmRhdGEoKVxuICAgICAgICB9IGVsc2UgaWYgKHAuYWxsb3dHZXR0aW5nICYmIG5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIGdldCB3aG9sZSBvYmplY3RcbiAgICAgICAgICB2YXIgX3JldDtcblxuICAgICAgICAgIGlmIChzaW5nbGUpIHtcbiAgICAgICAgICAgIHAuYmVmb3JlR2V0KHNpbmdsZSk7XG4gICAgICAgICAgICBfcmV0ID0gc2luZ2xlLl9wcml2YXRlW3AuZmllbGRdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBfcmV0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7IC8vIG1haW50YWluIGNoYWluYWJpbGl0eVxuICAgICAgfTsgLy8gZnVuY3Rpb25cbiAgICB9LFxuICAgIC8vIGRhdGFcbiAgICAvLyByZW1vdmUgZGF0YSBmaWVsZFxuICAgIHJlbW92ZURhdGE6IGZ1bmN0aW9uIHJlbW92ZURhdGEocGFyYW1zKSB7XG4gICAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICAgIGZpZWxkOiAnZGF0YScsXG4gICAgICAgIGV2ZW50OiAnZGF0YScsXG4gICAgICAgIHRyaWdnZXJGbk5hbWU6ICd0cmlnZ2VyJyxcbiAgICAgICAgdHJpZ2dlckV2ZW50OiBmYWxzZSxcbiAgICAgICAgaW1tdXRhYmxlS2V5czoge30gLy8ga2V5ID0+IHRydWUgaWYgaW1tdXRhYmxlXG5cbiAgICAgIH07XG4gICAgICBwYXJhbXMgPSBleHRlbmQoe30sIGRlZmF1bHRzLCBwYXJhbXMpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHJlbW92ZURhdGFJbXBsKG5hbWVzKSB7XG4gICAgICAgIHZhciBwID0gcGFyYW1zO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBzZWxmSXNBcnJheUxpa2UgPSBzZWxmLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgYWxsID0gc2VsZklzQXJyYXlMaWtlID8gc2VsZiA6IFtzZWxmXTsgLy8gcHV0IGluIGFycmF5IGlmIG5vdCBhcnJheS1saWtlXG4gICAgICAgIC8vIC5yZW1vdmVEYXRhKCdmb28gYmFyJylcblxuICAgICAgICBpZiAoc3RyaW5nKG5hbWVzKSkge1xuICAgICAgICAgIC8vIHRoZW4gZ2V0IHRoZSBsaXN0IG9mIGtleXMsIGFuZCBkZWxldGUgdGhlbVxuICAgICAgICAgIHZhciBrZXlzID0gbmFtZXMuc3BsaXQoL1xccysvKTtcbiAgICAgICAgICB2YXIgbCA9IGtleXMubGVuZ3RoO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIC8vIGRlbGV0ZSBlYWNoIG5vbi1lbXB0eSBrZXlcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgICAgICBpZiAoZW1wdHlTdHJpbmcoa2V5KSkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHZhbGlkID0gIXAuaW1tdXRhYmxlS2V5c1trZXldOyAvLyBub3QgdmFsaWQgaWYgaW1tdXRhYmxlXG5cbiAgICAgICAgICAgIGlmICh2YWxpZCkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBpX2EgPSAwLCBsX2EgPSBhbGwubGVuZ3RoOyBpX2EgPCBsX2E7IGlfYSsrKSB7XG4gICAgICAgICAgICAgICAgYWxsW2lfYV0uX3ByaXZhdGVbcC5maWVsZF1ba2V5XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwLnRyaWdnZXJFdmVudCkge1xuICAgICAgICAgICAgc2VsZltwLnRyaWdnZXJGbk5hbWVdKHAuZXZlbnQpO1xuICAgICAgICAgIH0gLy8gLnJlbW92ZURhdGEoKVxuXG4gICAgICAgIH0gZWxzZSBpZiAobmFtZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIHRoZW4gZGVsZXRlIGFsbCBrZXlzXG4gICAgICAgICAgZm9yICh2YXIgX2lfYSA9IDAsIF9sX2EgPSBhbGwubGVuZ3RoOyBfaV9hIDwgX2xfYTsgX2lfYSsrKSB7XG4gICAgICAgICAgICB2YXIgX3ByaXZhdGVGaWVsZHMgPSBhbGxbX2lfYV0uX3ByaXZhdGVbcC5maWVsZF07XG5cbiAgICAgICAgICAgIHZhciBfa2V5cyA9IE9iamVjdC5rZXlzKF9wcml2YXRlRmllbGRzKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgX2tleXMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICAgICAgICB2YXIgX2tleSA9IF9rZXlzW19pMl07XG4gICAgICAgICAgICAgIHZhciB2YWxpZEtleVRvRGVsZXRlID0gIXAuaW1tdXRhYmxlS2V5c1tfa2V5XTtcblxuICAgICAgICAgICAgICBpZiAodmFsaWRLZXlUb0RlbGV0ZSkge1xuICAgICAgICAgICAgICAgIF9wcml2YXRlRmllbGRzW19rZXldID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHAudHJpZ2dlckV2ZW50KSB7XG4gICAgICAgICAgICBzZWxmW3AudHJpZ2dlckZuTmFtZV0ocC5ldmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7IC8vIG1haW50YWluIGNoYWluaW5nXG4gICAgICB9OyAvLyBmdW5jdGlvblxuICAgIH0gLy8gcmVtb3ZlRGF0YVxuXG4gIH07IC8vIGRlZmluZVxuXG4gIHZhciBkZWZpbmUkMSA9IHtcbiAgICBldmVudEFsaWFzZXNPbjogZnVuY3Rpb24gZXZlbnRBbGlhc2VzT24ocHJvdG8pIHtcbiAgICAgIHZhciBwID0gcHJvdG87XG4gICAgICBwLmFkZExpc3RlbmVyID0gcC5saXN0ZW4gPSBwLmJpbmQgPSBwLm9uO1xuICAgICAgcC51bmxpc3RlbiA9IHAudW5iaW5kID0gcC5vZmYgPSBwLnJlbW92ZUxpc3RlbmVyO1xuICAgICAgcC50cmlnZ2VyID0gcC5lbWl0OyAvLyB0aGlzIGlzIGp1c3QgYSB3cmFwcGVyIGFsaWFzIG9mIC5vbigpXG5cbiAgICAgIHAucG9uID0gcC5wcm9taXNlT24gPSBmdW5jdGlvbiAoZXZlbnRzLCBzZWxlY3Rvcikge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uIGNhbGxiYWNrKGUpIHtcbiAgICAgICAgICAgIHNlbGYub2ZmLmFwcGx5KHNlbGYsIG9mZkFyZ3MpO1xuICAgICAgICAgICAgcmVzb2x2ZShlKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdmFyIG9uQXJncyA9IGFyZ3MuY29uY2F0KFtjYWxsYmFja10pO1xuICAgICAgICAgIHZhciBvZmZBcmdzID0gb25BcmdzLmNvbmNhdChbXSk7XG4gICAgICAgICAgc2VsZi5vbi5hcHBseShzZWxmLCBvbkFyZ3MpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfVxuICB9OyAvLyBkZWZpbmVcblxuICAvLyB1c2UgdGhpcyBtb2R1bGUgdG8gY2hlcnJ5IHBpY2sgZnVuY3Rpb25zIGludG8geW91ciBwcm90b3R5cGVcbiAgdmFyIGRlZmluZSA9IHt9O1xuICBbZGVmaW5lJDMsIGRlZmluZSQyLCBkZWZpbmUkMV0uZm9yRWFjaChmdW5jdGlvbiAobSkge1xuICAgIGV4dGVuZChkZWZpbmUsIG0pO1xuICB9KTtcblxuICB2YXIgZWxlc2ZuJGkgPSB7XG4gICAgYW5pbWF0ZTogZGVmaW5lLmFuaW1hdGUoKSxcbiAgICBhbmltYXRpb246IGRlZmluZS5hbmltYXRpb24oKSxcbiAgICBhbmltYXRlZDogZGVmaW5lLmFuaW1hdGVkKCksXG4gICAgY2xlYXJRdWV1ZTogZGVmaW5lLmNsZWFyUXVldWUoKSxcbiAgICBkZWxheTogZGVmaW5lLmRlbGF5KCksXG4gICAgZGVsYXlBbmltYXRpb246IGRlZmluZS5kZWxheUFuaW1hdGlvbigpLFxuICAgIHN0b3A6IGRlZmluZS5zdG9wKClcbiAgfTtcblxuICB2YXIgZWxlc2ZuJGggPSB7XG4gICAgY2xhc3NlczogZnVuY3Rpb24gY2xhc3NlcyhfY2xhc3Nlcykge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICBpZiAoX2NsYXNzZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgcmV0ID0gW107XG5cbiAgICAgICAgc2VsZlswXS5fcHJpdmF0ZS5jbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKGNscykge1xuICAgICAgICAgIHJldHVybiByZXQucHVzaChjbHMpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfSBlbHNlIGlmICghYXJyYXkoX2NsYXNzZXMpKSB7XG4gICAgICAgIC8vIGV4dHJhY3QgY2xhc3NlcyBmcm9tIHN0cmluZ1xuICAgICAgICBfY2xhc3NlcyA9IChfY2xhc3NlcyB8fCAnJykubWF0Y2goL1xcUysvZykgfHwgW107XG4gICAgICB9XG5cbiAgICAgIHZhciBjaGFuZ2VkID0gW107XG4gICAgICB2YXIgY2xhc3Nlc1NldCA9IG5ldyBTZXQkMShfY2xhc3Nlcyk7IC8vIGNoZWNrIGFuZCB1cGRhdGUgZWFjaCBlbGVcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzZWxmLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBlbGUgPSBzZWxmW2pdO1xuICAgICAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgICAgIHZhciBlbGVDbGFzc2VzID0gX3AuY2xhc3NlcztcbiAgICAgICAgdmFyIGNoYW5nZWRFbGUgPSBmYWxzZTsgLy8gY2hlY2sgaWYgZWxlIGhhcyBhbGwgb2YgdGhlIHBhc3NlZCBjbGFzc2VzXG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfY2xhc3Nlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBjbHMgPSBfY2xhc3Nlc1tpXTtcbiAgICAgICAgICB2YXIgZWxlSGFzQ2xhc3MgPSBlbGVDbGFzc2VzLmhhcyhjbHMpO1xuXG4gICAgICAgICAgaWYgKCFlbGVIYXNDbGFzcykge1xuICAgICAgICAgICAgY2hhbmdlZEVsZSA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gY2hlY2sgaWYgZWxlIGhhcyBjbGFzc2VzIG91dHNpZGUgb2YgdGhvc2UgcGFzc2VkXG5cblxuICAgICAgICBpZiAoIWNoYW5nZWRFbGUpIHtcbiAgICAgICAgICBjaGFuZ2VkRWxlID0gZWxlQ2xhc3Nlcy5zaXplICE9PSBfY2xhc3Nlcy5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2hhbmdlZEVsZSkge1xuICAgICAgICAgIF9wLmNsYXNzZXMgPSBjbGFzc2VzU2V0O1xuICAgICAgICAgIGNoYW5nZWQucHVzaChlbGUpO1xuICAgICAgICB9XG4gICAgICB9IC8vIHRyaWdnZXIgdXBkYXRlIHN0eWxlIG9uIHRob3NlIGVsZXMgdGhhdCBoYWQgY2xhc3MgY2hhbmdlc1xuXG5cbiAgICAgIGlmIChjaGFuZ2VkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5zcGF3bihjaGFuZ2VkKS51cGRhdGVTdHlsZSgpLmVtaXQoJ2NsYXNzJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG4gICAgYWRkQ2xhc3M6IGZ1bmN0aW9uIGFkZENsYXNzKGNsYXNzZXMpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvZ2dsZUNsYXNzKGNsYXNzZXMsIHRydWUpO1xuICAgIH0sXG4gICAgaGFzQ2xhc3M6IGZ1bmN0aW9uIGhhc0NsYXNzKGNsYXNzTmFtZSkge1xuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgICByZXR1cm4gZWxlICE9IG51bGwgJiYgZWxlLl9wcml2YXRlLmNsYXNzZXMuaGFzKGNsYXNzTmFtZSk7XG4gICAgfSxcbiAgICB0b2dnbGVDbGFzczogZnVuY3Rpb24gdG9nZ2xlQ2xhc3MoY2xhc3NlcywgdG9nZ2xlKSB7XG4gICAgICBpZiAoIWFycmF5KGNsYXNzZXMpKSB7XG4gICAgICAgIC8vIGV4dHJhY3QgY2xhc3NlcyBmcm9tIHN0cmluZ1xuICAgICAgICBjbGFzc2VzID0gY2xhc3Nlcy5tYXRjaCgvXFxTKy9nKSB8fCBbXTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHRvZ2dsZVVuZGVmZCA9IHRvZ2dsZSA9PT0gdW5kZWZpbmVkO1xuICAgICAgdmFyIGNoYW5nZWQgPSBbXTsgLy8gZWxlcyB3aG8gaGFkIGNsYXNzZXMgY2hhbmdlZFxuXG4gICAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBzZWxmLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IHNlbGZbaV07XG4gICAgICAgIHZhciBlbGVDbGFzc2VzID0gZWxlLl9wcml2YXRlLmNsYXNzZXM7XG4gICAgICAgIHZhciBjaGFuZ2VkRWxlID0gZmFsc2U7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjbGFzc2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdmFyIGNscyA9IGNsYXNzZXNbal07XG4gICAgICAgICAgdmFyIGhhc0NsYXNzID0gZWxlQ2xhc3Nlcy5oYXMoY2xzKTtcbiAgICAgICAgICB2YXIgY2hhbmdlZE5vdyA9IGZhbHNlO1xuXG4gICAgICAgICAgaWYgKHRvZ2dsZSB8fCB0b2dnbGVVbmRlZmQgJiYgIWhhc0NsYXNzKSB7XG4gICAgICAgICAgICBlbGVDbGFzc2VzLmFkZChjbHMpO1xuICAgICAgICAgICAgY2hhbmdlZE5vdyA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIGlmICghdG9nZ2xlIHx8IHRvZ2dsZVVuZGVmZCAmJiBoYXNDbGFzcykge1xuICAgICAgICAgICAgZWxlQ2xhc3Nlc1tcImRlbGV0ZVwiXShjbHMpO1xuICAgICAgICAgICAgY2hhbmdlZE5vdyA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFjaGFuZ2VkRWxlICYmIGNoYW5nZWROb3cpIHtcbiAgICAgICAgICAgIGNoYW5nZWQucHVzaChlbGUpO1xuICAgICAgICAgICAgY2hhbmdlZEVsZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIGZvciBqIGNsYXNzZXNcblxuICAgICAgfSAvLyBmb3IgaSBlbGVzXG4gICAgICAvLyB0cmlnZ2VyIHVwZGF0ZSBzdHlsZSBvbiB0aG9zZSBlbGVzIHRoYXQgaGFkIGNsYXNzIGNoYW5nZXNcblxuXG4gICAgICBpZiAoY2hhbmdlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuc3Bhd24oY2hhbmdlZCkudXBkYXRlU3R5bGUoKS5lbWl0KCdjbGFzcycpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuICAgIHJlbW92ZUNsYXNzOiBmdW5jdGlvbiByZW1vdmVDbGFzcyhjbGFzc2VzKSB7XG4gICAgICByZXR1cm4gdGhpcy50b2dnbGVDbGFzcyhjbGFzc2VzLCBmYWxzZSk7XG4gICAgfSxcbiAgICBmbGFzaENsYXNzOiBmdW5jdGlvbiBmbGFzaENsYXNzKGNsYXNzZXMsIGR1cmF0aW9uKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIGlmIChkdXJhdGlvbiA9PSBudWxsKSB7XG4gICAgICAgIGR1cmF0aW9uID0gMjUwO1xuICAgICAgfSBlbHNlIGlmIChkdXJhdGlvbiA9PT0gMCkge1xuICAgICAgICByZXR1cm4gc2VsZjsgLy8gbm90aGluZyB0byBkbyByZWFsbHlcbiAgICAgIH1cblxuICAgICAgc2VsZi5hZGRDbGFzcyhjbGFzc2VzKTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLnJlbW92ZUNsYXNzKGNsYXNzZXMpO1xuICAgICAgfSwgZHVyYXRpb24pO1xuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICB9O1xuICBlbGVzZm4kaC5jbGFzc05hbWUgPSBlbGVzZm4kaC5jbGFzc05hbWVzID0gZWxlc2ZuJGguY2xhc3NlcztcblxuICB2YXIgdG9rZW5zID0ge1xuICAgIG1ldGFDaGFyOiAnW1xcXFwhXFxcXFwiXFxcXCNcXFxcJFxcXFwlXFxcXCZcXFxcXFwnXFxcXChcXFxcKVxcXFwqXFxcXCtcXFxcLFxcXFwuXFxcXC9cXFxcOlxcXFw7XFxcXDxcXFxcPVxcXFw+XFxcXD9cXFxcQFxcXFxbXFxcXF1cXFxcXlxcXFxgXFxcXHtcXFxcfFxcXFx9XFxcXH5dJyxcbiAgICAvLyBjaGFycyB3ZSBuZWVkIHRvIGVzY2FwZSBpbiBsZXQgbmFtZXMsIGV0Y1xuICAgIGNvbXBhcmF0b3JPcDogJz18XFxcXCE9fD58Pj18PHw8PXxcXFxcJD18XFxcXF49fFxcXFwqPScsXG4gICAgLy8gYmluYXJ5IGNvbXBhcmlzb24gb3AgKHVzZWQgaW4gZGF0YSBzZWxlY3RvcnMpXG4gICAgYm9vbE9wOiAnXFxcXD98XFxcXCF8XFxcXF4nLFxuICAgIC8vIGJvb2xlYW4gKHVuYXJ5KSBvcGVyYXRvcnMgKHVzZWQgaW4gZGF0YSBzZWxlY3RvcnMpXG4gICAgc3RyaW5nOiAnXCIoPzpcXFxcXFxcXFwifFteXCJdKSpcIicgKyAnfCcgKyBcIicoPzpcXFxcXFxcXCd8W14nXSkqJ1wiLFxuICAgIC8vIHN0cmluZyBsaXRlcmFscyAodXNlZCBpbiBkYXRhIHNlbGVjdG9ycykgLS0gZG91YmxlcXVvdGVzIHwgc2luZ2xlcXVvdGVzXG4gICAgbnVtYmVyOiBudW1iZXIsXG4gICAgLy8gbnVtYmVyIGxpdGVyYWwgKHVzZWQgaW4gZGF0YSBzZWxlY3RvcnMpIC0tLSBlLmcuIDAuMTIzNCwgMTIzNCwgMTJlMTIzXG4gICAgbWV0YTogJ2RlZ3JlZXxpbmRlZ3JlZXxvdXRkZWdyZWUnLFxuICAgIC8vIGFsbG93ZWQgbWV0YWRhdGEgZmllbGRzIChpLmUuIGFsbG93ZWQgZnVuY3Rpb25zIHRvIHVzZSBmcm9tIENvbGxlY3Rpb24pXG4gICAgc2VwYXJhdG9yOiAnXFxcXHMqLFxcXFxzKicsXG4gICAgLy8gcXVlcmllcyBhcmUgc2VwYXJhdGVkIGJ5IGNvbW1hcywgZS5nLiBlZGdlW2ZvbyA9ICdiYXInXSwgbm9kZS5zb21lQ2xhc3NcbiAgICBkZXNjZW5kYW50OiAnXFxcXHMrJyxcbiAgICBjaGlsZDogJ1xcXFxzKz5cXFxccysnLFxuICAgIHN1YmplY3Q6ICdcXFxcJCcsXG4gICAgZ3JvdXA6ICdub2RlfGVkZ2V8XFxcXConLFxuICAgIGRpcmVjdGVkRWRnZTogJ1xcXFxzKy0+XFxcXHMrJyxcbiAgICB1bmRpcmVjdGVkRWRnZTogJ1xcXFxzKzwtPlxcXFxzKydcbiAgfTtcbiAgdG9rZW5zLnZhcmlhYmxlID0gJyg/OltcXFxcdy0uXXwoPzpcXFxcXFxcXCcgKyB0b2tlbnMubWV0YUNoYXIgKyAnKSkrJzsgLy8gYSB2YXJpYWJsZSBuYW1lIGNhbiBoYXZlIGxldHRlcnMsIG51bWJlcnMsIGRhc2hlcywgYW5kIHBlcmlvZHNcblxuICB0b2tlbnMuY2xhc3NOYW1lID0gJyg/OltcXFxcdy1dfCg/OlxcXFxcXFxcJyArIHRva2Vucy5tZXRhQ2hhciArICcpKSsnOyAvLyBhIGNsYXNzIG5hbWUgaGFzIHRoZSBzYW1lIHJ1bGVzIGFzIGEgdmFyaWFibGUgZXhjZXB0IGl0IGNhbid0IGhhdmUgYSAnLicgaW4gdGhlIG5hbWVcblxuICB0b2tlbnMudmFsdWUgPSB0b2tlbnMuc3RyaW5nICsgJ3wnICsgdG9rZW5zLm51bWJlcjsgLy8gYSB2YWx1ZSBsaXRlcmFsLCBlaXRoZXIgYSBzdHJpbmcgb3IgbnVtYmVyXG5cbiAgdG9rZW5zLmlkID0gdG9rZW5zLnZhcmlhYmxlOyAvLyBhbiBlbGVtZW50IGlkIChmb2xsb3dzIHZhcmlhYmxlIGNvbnZlbnRpb25zKVxuXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9wcywgb3AsIGk7IC8vIGFkZCBAIHZhcmlhbnRzIHRvIGNvbXBhcmF0b3JPcFxuXG4gICAgb3BzID0gdG9rZW5zLmNvbXBhcmF0b3JPcC5zcGxpdCgnfCcpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgb3AgPSBvcHNbaV07XG4gICAgICB0b2tlbnMuY29tcGFyYXRvck9wICs9ICd8QCcgKyBvcDtcbiAgICB9IC8vIGFkZCAhIHZhcmlhbnRzIHRvIGNvbXBhcmF0b3JPcFxuXG5cbiAgICBvcHMgPSB0b2tlbnMuY29tcGFyYXRvck9wLnNwbGl0KCd8Jyk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvcCA9IG9wc1tpXTtcblxuICAgICAgaWYgKG9wLmluZGV4T2YoJyEnKSA+PSAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvLyBza2lwIG9wcyB0aGF0IGV4cGxpY2l0bHkgY29udGFpbiAhXG5cblxuICAgICAgaWYgKG9wID09PSAnPScpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIHNraXAgPSBiL2MgIT0gaXMgZXhwbGljaXRseSBkZWZpbmVkXG5cblxuICAgICAgdG9rZW5zLmNvbXBhcmF0b3JPcCArPSAnfFxcXFwhJyArIG9wO1xuICAgIH1cbiAgfSkoKTtcblxuICAvKipcbiAgICogTWFrZSBhIG5ldyBxdWVyeSBvYmplY3RcbiAgICpcbiAgICogQHByb3AgdHlwZSB7VHlwZX0gVGhlIHR5cGUgZW51bSAoaW50KSBvZiB0aGUgcXVlcnlcbiAgICogQHByb3AgY2hlY2tzIExpc3Qgb2YgY2hlY2tzIHRvIG1ha2UgYWdhaW5zdCBhbiBlbGUgdG8gdGVzdCBmb3IgYSBtYXRjaFxuICAgKi9cbiAgdmFyIG5ld1F1ZXJ5ID0gZnVuY3Rpb24gbmV3UXVlcnkoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNoZWNrczogW11cbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBBIGNoZWNrIHR5cGUgZW51bS1saWtlIG9iamVjdC4gIFVzZXMgaW50ZWdlciB2YWx1ZXMgZm9yIGZhc3QgbWF0Y2goKSBsb29rdXAuXG4gICAqIFRoZSBvcmRlcmluZyBkb2VzIG5vdCBtYXR0ZXIgYXMgbG9uZyBhcyB0aGUgaW50cyBhcmUgdW5pcXVlLlxuICAgKi9cbiAgdmFyIFR5cGUgPSB7XG4gICAgLyoqIEUuZy4gbm9kZSAqL1xuICAgIEdST1VQOiAwLFxuXG4gICAgLyoqIEEgY29sbGVjdGlvbiBvZiBlbGVtZW50cyAqL1xuICAgIENPTExFQ1RJT046IDEsXG5cbiAgICAvKiogQSBmaWx0ZXIoZWxlKSBmdW5jdGlvbiAqL1xuICAgIEZJTFRFUjogMixcblxuICAgIC8qKiBFLmcuIFtmb28gPiAxXSAqL1xuICAgIERBVEFfQ09NUEFSRTogMyxcblxuICAgIC8qKiBFLmcuIFtmb29dICovXG4gICAgREFUQV9FWElTVDogNCxcblxuICAgIC8qKiBFLmcuIFs/Zm9vXSAqL1xuICAgIERBVEFfQk9PTDogNSxcblxuICAgIC8qKiBFLmcuIFtbZGVncmVlID4gMl1dICovXG4gICAgTUVUQV9DT01QQVJFOiA2LFxuXG4gICAgLyoqIEUuZy4gOnNlbGVjdGVkICovXG4gICAgU1RBVEU6IDcsXG5cbiAgICAvKiogRS5nLiAjZm9vICovXG4gICAgSUQ6IDgsXG5cbiAgICAvKiogRS5nLiAuZm9vICovXG4gICAgQ0xBU1M6IDksXG5cbiAgICAvKiogRS5nLiAjZm9vIDwtPiAjYmFyICovXG4gICAgVU5ESVJFQ1RFRF9FREdFOiAxMCxcblxuICAgIC8qKiBFLmcuICNmb28gLT4gI2JhciAqL1xuICAgIERJUkVDVEVEX0VER0U6IDExLFxuXG4gICAgLyoqIEUuZy4gJCNmb28gLT4gI2JhciAqL1xuICAgIE5PREVfU09VUkNFOiAxMixcblxuICAgIC8qKiBFLmcuICNmb28gLT4gJCNiYXIgKi9cbiAgICBOT0RFX1RBUkdFVDogMTMsXG5cbiAgICAvKiogRS5nLiAkI2ZvbyA8LT4gI2JhciAqL1xuICAgIE5PREVfTkVJR0hCT1I6IDE0LFxuXG4gICAgLyoqIEUuZy4gI2ZvbyA+ICNiYXIgKi9cbiAgICBDSElMRDogMTUsXG5cbiAgICAvKiogRS5nLiAjZm9vICNiYXIgKi9cbiAgICBERVNDRU5EQU5UOiAxNixcblxuICAgIC8qKiBFLmcuICQjZm9vID4gI2JhciAqL1xuICAgIFBBUkVOVDogMTcsXG5cbiAgICAvKiogRS5nLiAkI2ZvbyAjYmFyICovXG4gICAgQU5DRVNUT1I6IDE4LFxuXG4gICAgLyoqIEUuZy4gI2ZvbyA+ICRiYXIgPiAjYmF6ICovXG4gICAgQ09NUE9VTkRfU1BMSVQ6IDE5LFxuXG4gICAgLyoqIEFsd2F5cyBtYXRjaGVzLCB1c2VmdWwgcGxhY2Vob2xkZXIgZm9yIHN1YmplY3QgaW4gYENPTVBPVU5EX1NQTElUYCAqL1xuICAgIFRSVUU6IDIwXG4gIH07XG5cbiAgdmFyIHN0YXRlU2VsZWN0b3JzID0gW3tcbiAgICBzZWxlY3RvcjogJzpzZWxlY3RlZCcsXG4gICAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuc2VsZWN0ZWQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBzZWxlY3RvcjogJzp1bnNlbGVjdGVkJyxcbiAgICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgICAgcmV0dXJuICFlbGUuc2VsZWN0ZWQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBzZWxlY3RvcjogJzpzZWxlY3RhYmxlJyxcbiAgICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5zZWxlY3RhYmxlKCk7XG4gICAgfVxuICB9LCB7XG4gICAgc2VsZWN0b3I6ICc6dW5zZWxlY3RhYmxlJyxcbiAgICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgICAgcmV0dXJuICFlbGUuc2VsZWN0YWJsZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIHNlbGVjdG9yOiAnOmxvY2tlZCcsXG4gICAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICAgIHJldHVybiBlbGUubG9ja2VkKCk7XG4gICAgfVxuICB9LCB7XG4gICAgc2VsZWN0b3I6ICc6dW5sb2NrZWQnLFxuICAgIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgICByZXR1cm4gIWVsZS5sb2NrZWQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBzZWxlY3RvcjogJzp2aXNpYmxlJyxcbiAgICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS52aXNpYmxlKCk7XG4gICAgfVxuICB9LCB7XG4gICAgc2VsZWN0b3I6ICc6aGlkZGVuJyxcbiAgICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgICAgcmV0dXJuICFlbGUudmlzaWJsZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIHNlbGVjdG9yOiAnOnRyYW5zcGFyZW50JyxcbiAgICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS50cmFuc3BhcmVudCgpO1xuICAgIH1cbiAgfSwge1xuICAgIHNlbGVjdG9yOiAnOmdyYWJiZWQnLFxuICAgIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLmdyYWJiZWQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBzZWxlY3RvcjogJzpmcmVlJyxcbiAgICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgICAgcmV0dXJuICFlbGUuZ3JhYmJlZCgpO1xuICAgIH1cbiAgfSwge1xuICAgIHNlbGVjdG9yOiAnOnJlbW92ZWQnLFxuICAgIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLnJlbW92ZWQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBzZWxlY3RvcjogJzppbnNpZGUnLFxuICAgIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgICByZXR1cm4gIWVsZS5yZW1vdmVkKCk7XG4gICAgfVxuICB9LCB7XG4gICAgc2VsZWN0b3I6ICc6Z3JhYmJhYmxlJyxcbiAgICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5ncmFiYmFibGUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBzZWxlY3RvcjogJzp1bmdyYWJiYWJsZScsXG4gICAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICAgIHJldHVybiAhZWxlLmdyYWJiYWJsZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIHNlbGVjdG9yOiAnOmFuaW1hdGVkJyxcbiAgICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5hbmltYXRlZCgpO1xuICAgIH1cbiAgfSwge1xuICAgIHNlbGVjdG9yOiAnOnVuYW5pbWF0ZWQnLFxuICAgIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgICByZXR1cm4gIWVsZS5hbmltYXRlZCgpO1xuICAgIH1cbiAgfSwge1xuICAgIHNlbGVjdG9yOiAnOnBhcmVudCcsXG4gICAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuaXNQYXJlbnQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBzZWxlY3RvcjogJzpjaGlsZGxlc3MnLFxuICAgIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLmlzQ2hpbGRsZXNzKCk7XG4gICAgfVxuICB9LCB7XG4gICAgc2VsZWN0b3I6ICc6Y2hpbGQnLFxuICAgIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLmlzQ2hpbGQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBzZWxlY3RvcjogJzpvcnBoYW4nLFxuICAgIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLmlzT3JwaGFuKCk7XG4gICAgfVxuICB9LCB7XG4gICAgc2VsZWN0b3I6ICc6bm9ub3JwaGFuJyxcbiAgICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5pc0NoaWxkKCk7XG4gICAgfVxuICB9LCB7XG4gICAgc2VsZWN0b3I6ICc6Y29tcG91bmQnLFxuICAgIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgICAgIHJldHVybiBlbGUuaXNQYXJlbnQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBlbGUuc291cmNlKCkuaXNQYXJlbnQoKSB8fCBlbGUudGFyZ2V0KCkuaXNQYXJlbnQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBzZWxlY3RvcjogJzpsb29wJyxcbiAgICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5pc0xvb3AoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBzZWxlY3RvcjogJzpzaW1wbGUnLFxuICAgIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLmlzU2ltcGxlKCk7XG4gICAgfVxuICB9LCB7XG4gICAgc2VsZWN0b3I6ICc6YWN0aXZlJyxcbiAgICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5hY3RpdmUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBzZWxlY3RvcjogJzppbmFjdGl2ZScsXG4gICAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICAgIHJldHVybiAhZWxlLmFjdGl2ZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIHNlbGVjdG9yOiAnOmJhY2tncm91bmRpbmcnLFxuICAgIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLmJhY2tncm91bmRpbmcoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBzZWxlY3RvcjogJzpub25iYWNrZ3JvdW5kaW5nJyxcbiAgICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgICAgcmV0dXJuICFlbGUuYmFja2dyb3VuZGluZygpO1xuICAgIH1cbiAgfV0uc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIC8vIG4uYi4gc2VsZWN0b3JzIHRoYXQgYXJlIHN0YXJ0aW5nIHN1YnN0cmluZ3Mgb2Ygb3RoZXJzIG11c3QgaGF2ZSB0aGUgbG9uZ2VyIG9uZXMgZmlyc3RcbiAgICByZXR1cm4gZGVzY2VuZGluZyhhLnNlbGVjdG9yLCBiLnNlbGVjdG9yKTtcbiAgfSk7XG5cbiAgdmFyIGxvb2t1cCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsVG9GbiA9IHt9O1xuICAgIHZhciBzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZVNlbGVjdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgcyA9IHN0YXRlU2VsZWN0b3JzW2ldO1xuICAgICAgc2VsVG9GbltzLnNlbGVjdG9yXSA9IHMubWF0Y2hlcztcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsVG9GbjtcbiAgfSgpO1xuXG4gIHZhciBzdGF0ZVNlbGVjdG9yTWF0Y2hlcyA9IGZ1bmN0aW9uIHN0YXRlU2VsZWN0b3JNYXRjaGVzKHNlbCwgZWxlKSB7XG4gICAgcmV0dXJuIGxvb2t1cFtzZWxdKGVsZSk7XG4gIH07XG4gIHZhciBzdGF0ZVNlbGVjdG9yUmVnZXggPSAnKCcgKyBzdGF0ZVNlbGVjdG9ycy5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICByZXR1cm4gcy5zZWxlY3RvcjtcbiAgfSkuam9pbignfCcpICsgJyknO1xuXG4gIC8vIHNvIHRoYXQgdmFsdWVzIGdldCBjb21wYXJlZCBwcm9wZXJseSBpbiBTZWxlY3Rvci5maWx0ZXIoKVxuXG4gIHZhciBjbGVhbk1ldGFDaGFycyA9IGZ1bmN0aW9uIGNsZWFuTWV0YUNoYXJzKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZShuZXcgUmVnRXhwKCdcXFxcXFxcXCgnICsgdG9rZW5zLm1ldGFDaGFyICsgJyknLCAnZycpLCBmdW5jdGlvbiAobWF0Y2gsICQxKSB7XG4gICAgICByZXR1cm4gJDE7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIHJlcGxhY2VMYXN0UXVlcnkgPSBmdW5jdGlvbiByZXBsYWNlTGFzdFF1ZXJ5KHNlbGVjdG9yLCBleGFtaW5pbmdRdWVyeSwgcmVwbGFjZW1lbnRRdWVyeSkge1xuICAgIHNlbGVjdG9yW3NlbGVjdG9yLmxlbmd0aCAtIDFdID0gcmVwbGFjZW1lbnRRdWVyeTtcbiAgfTsgLy8gTk9URTogYWRkIG5ldyBleHByZXNzaW9uIHN5bnRheCBoZXJlIHRvIGhhdmUgaXQgcmVjb2duaXNlZCBieSB0aGUgcGFyc2VyO1xuICAvLyAtIGEgcXVlcnkgY29udGFpbnMgYWxsIGFkamFjZW50IChpLmUuIG5vIHNlcGFyYXRvciBpbiBiZXR3ZWVuKSBleHByZXNzaW9ucztcbiAgLy8gLSB0aGUgY3VycmVudCBxdWVyeSBpcyBzdG9yZWQgaW4gc2VsZWN0b3JbaV1cbiAgLy8gLSB5b3UgbmVlZCB0byBjaGVjayB0aGUgcXVlcnkgb2JqZWN0cyBpbiBtYXRjaCgpIGZvciBpdCBhY3R1YWxseSBmaWx0ZXIgcHJvcGVybHksIGJ1dCB0aGF0J3MgcHJldHR5IHN0cmFpZ2h0IGZvcndhcmRcblxuXG4gIHZhciBleHBycyA9IFt7XG4gICAgbmFtZTogJ2dyb3VwJyxcbiAgICAvLyBqdXN0IHVzZWQgZm9yIGlkZW50aWZ5aW5nIHdoZW4gZGVidWdnaW5nXG4gICAgcXVlcnk6IHRydWUsXG4gICAgcmVnZXg6ICcoJyArIHRva2Vucy5ncm91cCArICcpJyxcbiAgICBwb3B1bGF0ZTogZnVuY3Rpb24gcG9wdWxhdGUoc2VsZWN0b3IsIHF1ZXJ5LCBfcmVmKSB7XG4gICAgICB2YXIgX3JlZjIgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAxKSxcbiAgICAgICAgICBncm91cCA9IF9yZWYyWzBdO1xuXG4gICAgICBxdWVyeS5jaGVja3MucHVzaCh7XG4gICAgICAgIHR5cGU6IFR5cGUuR1JPVVAsXG4gICAgICAgIHZhbHVlOiBncm91cCA9PT0gJyonID8gZ3JvdXAgOiBncm91cCArICdzJ1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAgbmFtZTogJ3N0YXRlJyxcbiAgICBxdWVyeTogdHJ1ZSxcbiAgICByZWdleDogc3RhdGVTZWxlY3RvclJlZ2V4LFxuICAgIHBvcHVsYXRlOiBmdW5jdGlvbiBwb3B1bGF0ZShzZWxlY3RvciwgcXVlcnksIF9yZWYzKSB7XG4gICAgICB2YXIgX3JlZjQgPSBfc2xpY2VkVG9BcnJheShfcmVmMywgMSksXG4gICAgICAgICAgc3RhdGUgPSBfcmVmNFswXTtcblxuICAgICAgcXVlcnkuY2hlY2tzLnB1c2goe1xuICAgICAgICB0eXBlOiBUeXBlLlNUQVRFLFxuICAgICAgICB2YWx1ZTogc3RhdGVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIG5hbWU6ICdpZCcsXG4gICAgcXVlcnk6IHRydWUsXG4gICAgcmVnZXg6ICdcXFxcIygnICsgdG9rZW5zLmlkICsgJyknLFxuICAgIHBvcHVsYXRlOiBmdW5jdGlvbiBwb3B1bGF0ZShzZWxlY3RvciwgcXVlcnksIF9yZWY1KSB7XG4gICAgICB2YXIgX3JlZjYgPSBfc2xpY2VkVG9BcnJheShfcmVmNSwgMSksXG4gICAgICAgICAgaWQgPSBfcmVmNlswXTtcblxuICAgICAgcXVlcnkuY2hlY2tzLnB1c2goe1xuICAgICAgICB0eXBlOiBUeXBlLklELFxuICAgICAgICB2YWx1ZTogY2xlYW5NZXRhQ2hhcnMoaWQpXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBuYW1lOiAnY2xhc3NOYW1lJyxcbiAgICBxdWVyeTogdHJ1ZSxcbiAgICByZWdleDogJ1xcXFwuKCcgKyB0b2tlbnMuY2xhc3NOYW1lICsgJyknLFxuICAgIHBvcHVsYXRlOiBmdW5jdGlvbiBwb3B1bGF0ZShzZWxlY3RvciwgcXVlcnksIF9yZWY3KSB7XG4gICAgICB2YXIgX3JlZjggPSBfc2xpY2VkVG9BcnJheShfcmVmNywgMSksXG4gICAgICAgICAgY2xhc3NOYW1lID0gX3JlZjhbMF07XG5cbiAgICAgIHF1ZXJ5LmNoZWNrcy5wdXNoKHtcbiAgICAgICAgdHlwZTogVHlwZS5DTEFTUyxcbiAgICAgICAgdmFsdWU6IGNsZWFuTWV0YUNoYXJzKGNsYXNzTmFtZSlcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIG5hbWU6ICdkYXRhRXhpc3RzJyxcbiAgICBxdWVyeTogdHJ1ZSxcbiAgICByZWdleDogJ1xcXFxbXFxcXHMqKCcgKyB0b2tlbnMudmFyaWFibGUgKyAnKVxcXFxzKlxcXFxdJyxcbiAgICBwb3B1bGF0ZTogZnVuY3Rpb24gcG9wdWxhdGUoc2VsZWN0b3IsIHF1ZXJ5LCBfcmVmOSkge1xuICAgICAgdmFyIF9yZWYxMCA9IF9zbGljZWRUb0FycmF5KF9yZWY5LCAxKSxcbiAgICAgICAgICB2YXJpYWJsZSA9IF9yZWYxMFswXTtcblxuICAgICAgcXVlcnkuY2hlY2tzLnB1c2goe1xuICAgICAgICB0eXBlOiBUeXBlLkRBVEFfRVhJU1QsXG4gICAgICAgIGZpZWxkOiBjbGVhbk1ldGFDaGFycyh2YXJpYWJsZSlcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIG5hbWU6ICdkYXRhQ29tcGFyZScsXG4gICAgcXVlcnk6IHRydWUsXG4gICAgcmVnZXg6ICdcXFxcW1xcXFxzKignICsgdG9rZW5zLnZhcmlhYmxlICsgJylcXFxccyooJyArIHRva2Vucy5jb21wYXJhdG9yT3AgKyAnKVxcXFxzKignICsgdG9rZW5zLnZhbHVlICsgJylcXFxccypcXFxcXScsXG4gICAgcG9wdWxhdGU6IGZ1bmN0aW9uIHBvcHVsYXRlKHNlbGVjdG9yLCBxdWVyeSwgX3JlZjExKSB7XG4gICAgICB2YXIgX3JlZjEyID0gX3NsaWNlZFRvQXJyYXkoX3JlZjExLCAzKSxcbiAgICAgICAgICB2YXJpYWJsZSA9IF9yZWYxMlswXSxcbiAgICAgICAgICBjb21wYXJhdG9yT3AgPSBfcmVmMTJbMV0sXG4gICAgICAgICAgdmFsdWUgPSBfcmVmMTJbMl07XG5cbiAgICAgIHZhciB2YWx1ZUlzU3RyaW5nID0gbmV3IFJlZ0V4cCgnXicgKyB0b2tlbnMuc3RyaW5nICsgJyQnKS5leGVjKHZhbHVlKSAhPSBudWxsO1xuXG4gICAgICBpZiAodmFsdWVJc1N0cmluZykge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cmluZygxLCB2YWx1ZS5sZW5ndGggLSAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHF1ZXJ5LmNoZWNrcy5wdXNoKHtcbiAgICAgICAgdHlwZTogVHlwZS5EQVRBX0NPTVBBUkUsXG4gICAgICAgIGZpZWxkOiBjbGVhbk1ldGFDaGFycyh2YXJpYWJsZSksXG4gICAgICAgIG9wZXJhdG9yOiBjb21wYXJhdG9yT3AsXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAgbmFtZTogJ2RhdGFCb29sJyxcbiAgICBxdWVyeTogdHJ1ZSxcbiAgICByZWdleDogJ1xcXFxbXFxcXHMqKCcgKyB0b2tlbnMuYm9vbE9wICsgJylcXFxccyooJyArIHRva2Vucy52YXJpYWJsZSArICcpXFxcXHMqXFxcXF0nLFxuICAgIHBvcHVsYXRlOiBmdW5jdGlvbiBwb3B1bGF0ZShzZWxlY3RvciwgcXVlcnksIF9yZWYxMykge1xuICAgICAgdmFyIF9yZWYxNCA9IF9zbGljZWRUb0FycmF5KF9yZWYxMywgMiksXG4gICAgICAgICAgYm9vbE9wID0gX3JlZjE0WzBdLFxuICAgICAgICAgIHZhcmlhYmxlID0gX3JlZjE0WzFdO1xuXG4gICAgICBxdWVyeS5jaGVja3MucHVzaCh7XG4gICAgICAgIHR5cGU6IFR5cGUuREFUQV9CT09MLFxuICAgICAgICBmaWVsZDogY2xlYW5NZXRhQ2hhcnModmFyaWFibGUpLFxuICAgICAgICBvcGVyYXRvcjogYm9vbE9wXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBuYW1lOiAnbWV0YUNvbXBhcmUnLFxuICAgIHF1ZXJ5OiB0cnVlLFxuICAgIHJlZ2V4OiAnXFxcXFtcXFxcW1xcXFxzKignICsgdG9rZW5zLm1ldGEgKyAnKVxcXFxzKignICsgdG9rZW5zLmNvbXBhcmF0b3JPcCArICcpXFxcXHMqKCcgKyB0b2tlbnMubnVtYmVyICsgJylcXFxccypcXFxcXVxcXFxdJyxcbiAgICBwb3B1bGF0ZTogZnVuY3Rpb24gcG9wdWxhdGUoc2VsZWN0b3IsIHF1ZXJ5LCBfcmVmMTUpIHtcbiAgICAgIHZhciBfcmVmMTYgPSBfc2xpY2VkVG9BcnJheShfcmVmMTUsIDMpLFxuICAgICAgICAgIG1ldGEgPSBfcmVmMTZbMF0sXG4gICAgICAgICAgY29tcGFyYXRvck9wID0gX3JlZjE2WzFdLFxuICAgICAgICAgIG51bWJlciA9IF9yZWYxNlsyXTtcblxuICAgICAgcXVlcnkuY2hlY2tzLnB1c2goe1xuICAgICAgICB0eXBlOiBUeXBlLk1FVEFfQ09NUEFSRSxcbiAgICAgICAgZmllbGQ6IGNsZWFuTWV0YUNoYXJzKG1ldGEpLFxuICAgICAgICBvcGVyYXRvcjogY29tcGFyYXRvck9wLFxuICAgICAgICB2YWx1ZTogcGFyc2VGbG9hdChudW1iZXIpXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBuYW1lOiAnbmV4dFF1ZXJ5JyxcbiAgICBzZXBhcmF0b3I6IHRydWUsXG4gICAgcmVnZXg6IHRva2Vucy5zZXBhcmF0b3IsXG4gICAgcG9wdWxhdGU6IGZ1bmN0aW9uIHBvcHVsYXRlKHNlbGVjdG9yLCBxdWVyeSkge1xuICAgICAgdmFyIGN1cnJlbnRTdWJqZWN0ID0gc2VsZWN0b3IuY3VycmVudFN1YmplY3Q7XG4gICAgICB2YXIgZWRnZUNvdW50ID0gc2VsZWN0b3IuZWRnZUNvdW50O1xuICAgICAgdmFyIGNvbXBvdW5kQ291bnQgPSBzZWxlY3Rvci5jb21wb3VuZENvdW50O1xuICAgICAgdmFyIGxhc3RRID0gc2VsZWN0b3Jbc2VsZWN0b3IubGVuZ3RoIC0gMV07XG5cbiAgICAgIGlmIChjdXJyZW50U3ViamVjdCAhPSBudWxsKSB7XG4gICAgICAgIGxhc3RRLnN1YmplY3QgPSBjdXJyZW50U3ViamVjdDtcbiAgICAgICAgc2VsZWN0b3IuY3VycmVudFN1YmplY3QgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBsYXN0US5lZGdlQ291bnQgPSBlZGdlQ291bnQ7XG4gICAgICBsYXN0US5jb21wb3VuZENvdW50ID0gY29tcG91bmRDb3VudDtcbiAgICAgIHNlbGVjdG9yLmVkZ2VDb3VudCA9IDA7XG4gICAgICBzZWxlY3Rvci5jb21wb3VuZENvdW50ID0gMDsgLy8gZ28gb24gdG8gbmV4dCBxdWVyeVxuXG4gICAgICB2YXIgbmV4dFF1ZXJ5ID0gc2VsZWN0b3Jbc2VsZWN0b3IubGVuZ3RoKytdID0gbmV3UXVlcnkoKTtcbiAgICAgIHJldHVybiBuZXh0UXVlcnk7IC8vIHRoaXMgaXMgdGhlIG5ldyBxdWVyeSB0byBiZSBmaWxsZWQgYnkgdGhlIGZvbGxvd2luZyBleHByc1xuICAgIH1cbiAgfSwge1xuICAgIG5hbWU6ICdkaXJlY3RlZEVkZ2UnLFxuICAgIHNlcGFyYXRvcjogdHJ1ZSxcbiAgICByZWdleDogdG9rZW5zLmRpcmVjdGVkRWRnZSxcbiAgICBwb3B1bGF0ZTogZnVuY3Rpb24gcG9wdWxhdGUoc2VsZWN0b3IsIHF1ZXJ5KSB7XG4gICAgICBpZiAoc2VsZWN0b3IuY3VycmVudFN1YmplY3QgPT0gbnVsbCkge1xuICAgICAgICAvLyB1bmRpcmVjdGVkIGVkZ2VcbiAgICAgICAgdmFyIGVkZ2VRdWVyeSA9IG5ld1F1ZXJ5KCk7XG4gICAgICAgIHZhciBzb3VyY2UgPSBxdWVyeTtcbiAgICAgICAgdmFyIHRhcmdldCA9IG5ld1F1ZXJ5KCk7XG4gICAgICAgIGVkZ2VRdWVyeS5jaGVja3MucHVzaCh7XG4gICAgICAgICAgdHlwZTogVHlwZS5ESVJFQ1RFRF9FREdFLFxuICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgIHRhcmdldDogdGFyZ2V0XG4gICAgICAgIH0pOyAvLyB0aGUgcXVlcnkgaW4gdGhlIHNlbGVjdG9yIHNob3VsZCBiZSB0aGUgZWRnZSByYXRoZXIgdGhhbiB0aGUgc291cmNlXG5cbiAgICAgICAgcmVwbGFjZUxhc3RRdWVyeShzZWxlY3RvciwgcXVlcnksIGVkZ2VRdWVyeSk7XG4gICAgICAgIHNlbGVjdG9yLmVkZ2VDb3VudCsrOyAvLyB3ZSdyZSBub3cgcG9wdWxhdGluZyB0aGUgdGFyZ2V0IHF1ZXJ5IHdpdGggZXhwcmVzc2lvbnMgdGhhdCBmb2xsb3dcblxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc291cmNlL3RhcmdldFxuICAgICAgICB2YXIgc3JjVGd0USA9IG5ld1F1ZXJ5KCk7XG4gICAgICAgIHZhciBfc291cmNlID0gcXVlcnk7XG5cbiAgICAgICAgdmFyIF90YXJnZXQgPSBuZXdRdWVyeSgpO1xuXG4gICAgICAgIHNyY1RndFEuY2hlY2tzLnB1c2goe1xuICAgICAgICAgIHR5cGU6IFR5cGUuTk9ERV9TT1VSQ0UsXG4gICAgICAgICAgc291cmNlOiBfc291cmNlLFxuICAgICAgICAgIHRhcmdldDogX3RhcmdldFxuICAgICAgICB9KTsgLy8gdGhlIHF1ZXJ5IGluIHRoZSBzZWxlY3RvciBzaG91bGQgYmUgdGhlIG5laWdoYm91cmhvb2QgcmF0aGVyIHRoYW4gdGhlIG5vZGVcblxuICAgICAgICByZXBsYWNlTGFzdFF1ZXJ5KHNlbGVjdG9yLCBxdWVyeSwgc3JjVGd0USk7XG4gICAgICAgIHNlbGVjdG9yLmVkZ2VDb3VudCsrO1xuICAgICAgICByZXR1cm4gX3RhcmdldDsgLy8gbm93IHBvcHVsYXRpbmcgdGhlIHRhcmdldCB3aXRoIHRoZSBmb2xsb3dpbmcgZXhwcmVzc2lvbnNcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBuYW1lOiAndW5kaXJlY3RlZEVkZ2UnLFxuICAgIHNlcGFyYXRvcjogdHJ1ZSxcbiAgICByZWdleDogdG9rZW5zLnVuZGlyZWN0ZWRFZGdlLFxuICAgIHBvcHVsYXRlOiBmdW5jdGlvbiBwb3B1bGF0ZShzZWxlY3RvciwgcXVlcnkpIHtcbiAgICAgIGlmIChzZWxlY3Rvci5jdXJyZW50U3ViamVjdCA9PSBudWxsKSB7XG4gICAgICAgIC8vIHVuZGlyZWN0ZWQgZWRnZVxuICAgICAgICB2YXIgZWRnZVF1ZXJ5ID0gbmV3UXVlcnkoKTtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHF1ZXJ5O1xuICAgICAgICB2YXIgdGFyZ2V0ID0gbmV3UXVlcnkoKTtcbiAgICAgICAgZWRnZVF1ZXJ5LmNoZWNrcy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBUeXBlLlVORElSRUNURURfRURHRSxcbiAgICAgICAgICBub2RlczogW3NvdXJjZSwgdGFyZ2V0XVxuICAgICAgICB9KTsgLy8gdGhlIHF1ZXJ5IGluIHRoZSBzZWxlY3RvciBzaG91bGQgYmUgdGhlIGVkZ2UgcmF0aGVyIHRoYW4gdGhlIHNvdXJjZVxuXG4gICAgICAgIHJlcGxhY2VMYXN0UXVlcnkoc2VsZWN0b3IsIHF1ZXJ5LCBlZGdlUXVlcnkpO1xuICAgICAgICBzZWxlY3Rvci5lZGdlQ291bnQrKzsgLy8gd2UncmUgbm93IHBvcHVsYXRpbmcgdGhlIHRhcmdldCBxdWVyeSB3aXRoIGV4cHJlc3Npb25zIHRoYXQgZm9sbG93XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5laWdoYm91cmhvb2RcbiAgICAgICAgdmFyIG5ob29kUSA9IG5ld1F1ZXJ5KCk7XG4gICAgICAgIHZhciBub2RlID0gcXVlcnk7XG4gICAgICAgIHZhciBuZWlnaGJvciA9IG5ld1F1ZXJ5KCk7XG4gICAgICAgIG5ob29kUS5jaGVja3MucHVzaCh7XG4gICAgICAgICAgdHlwZTogVHlwZS5OT0RFX05FSUdIQk9SLFxuICAgICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgICAgbmVpZ2hib3I6IG5laWdoYm9yXG4gICAgICAgIH0pOyAvLyB0aGUgcXVlcnkgaW4gdGhlIHNlbGVjdG9yIHNob3VsZCBiZSB0aGUgbmVpZ2hib3VyaG9vZCByYXRoZXIgdGhhbiB0aGUgbm9kZVxuXG4gICAgICAgIHJlcGxhY2VMYXN0UXVlcnkoc2VsZWN0b3IsIHF1ZXJ5LCBuaG9vZFEpO1xuICAgICAgICByZXR1cm4gbmVpZ2hib3I7IC8vIG5vdyBwb3B1bGF0aW5nIHRoZSBuZWlnaGJvciB3aXRoIGZvbGxvd2luZyBleHByZXNzaW9uc1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIG5hbWU6ICdjaGlsZCcsXG4gICAgc2VwYXJhdG9yOiB0cnVlLFxuICAgIHJlZ2V4OiB0b2tlbnMuY2hpbGQsXG4gICAgcG9wdWxhdGU6IGZ1bmN0aW9uIHBvcHVsYXRlKHNlbGVjdG9yLCBxdWVyeSkge1xuICAgICAgaWYgKHNlbGVjdG9yLmN1cnJlbnRTdWJqZWN0ID09IG51bGwpIHtcbiAgICAgICAgLy8gZGVmYXVsdDogY2hpbGQgcXVlcnlcbiAgICAgICAgdmFyIHBhcmVudENoaWxkUXVlcnkgPSBuZXdRdWVyeSgpO1xuICAgICAgICB2YXIgY2hpbGQgPSBuZXdRdWVyeSgpO1xuICAgICAgICB2YXIgcGFyZW50ID0gc2VsZWN0b3Jbc2VsZWN0b3IubGVuZ3RoIC0gMV07XG4gICAgICAgIHBhcmVudENoaWxkUXVlcnkuY2hlY2tzLnB1c2goe1xuICAgICAgICAgIHR5cGU6IFR5cGUuQ0hJTEQsXG4gICAgICAgICAgcGFyZW50OiBwYXJlbnQsXG4gICAgICAgICAgY2hpbGQ6IGNoaWxkXG4gICAgICAgIH0pOyAvLyB0aGUgcXVlcnkgaW4gdGhlIHNlbGVjdG9yIHNob3VsZCBiZSB0aGUgJz4nIGl0c2VsZlxuXG4gICAgICAgIHJlcGxhY2VMYXN0UXVlcnkoc2VsZWN0b3IsIHF1ZXJ5LCBwYXJlbnRDaGlsZFF1ZXJ5KTtcbiAgICAgICAgc2VsZWN0b3IuY29tcG91bmRDb3VudCsrOyAvLyB3ZSdyZSBub3cgcG9wdWxhdGluZyB0aGUgY2hpbGQgcXVlcnkgd2l0aCBleHByZXNzaW9ucyB0aGF0IGZvbGxvd1xuXG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgIH0gZWxzZSBpZiAoc2VsZWN0b3IuY3VycmVudFN1YmplY3QgPT09IHF1ZXJ5KSB7XG4gICAgICAgIC8vIGNvbXBvdW5kIHNwbGl0IHF1ZXJ5XG4gICAgICAgIHZhciBjb21wb3VuZCA9IG5ld1F1ZXJ5KCk7XG4gICAgICAgIHZhciBsZWZ0ID0gc2VsZWN0b3Jbc2VsZWN0b3IubGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciByaWdodCA9IG5ld1F1ZXJ5KCk7XG4gICAgICAgIHZhciBzdWJqZWN0ID0gbmV3UXVlcnkoKTtcblxuICAgICAgICB2YXIgX2NoaWxkID0gbmV3UXVlcnkoKTtcblxuICAgICAgICB2YXIgX3BhcmVudCA9IG5ld1F1ZXJ5KCk7IC8vIHNldCB1cCB0aGUgcm9vdCBjb21wb3VuZCBxXG5cblxuICAgICAgICBjb21wb3VuZC5jaGVja3MucHVzaCh7XG4gICAgICAgICAgdHlwZTogVHlwZS5DT01QT1VORF9TUExJVCxcbiAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICAgIHJpZ2h0OiByaWdodCxcbiAgICAgICAgICBzdWJqZWN0OiBzdWJqZWN0XG4gICAgICAgIH0pOyAvLyBwb3B1bGF0ZSB0aGUgc3ViamVjdCBhbmQgcmVwbGFjZSB0aGUgcSBhdCB0aGUgb2xkIHNwb3QgKHdpdGhpbiBsZWZ0KSB3aXRoIFRSVUVcblxuICAgICAgICBzdWJqZWN0LmNoZWNrcyA9IHF1ZXJ5LmNoZWNrczsgLy8gdGFrZSB0aGUgY2hlY2tzIGZyb20gdGhlIGxlZnRcblxuICAgICAgICBxdWVyeS5jaGVja3MgPSBbe1xuICAgICAgICAgIHR5cGU6IFR5cGUuVFJVRVxuICAgICAgICB9XTsgLy8gY2hlY2tzIHVuZGVyIGxlZnQgcmVmcyB0aGUgc3ViamVjdCBpbXBsaWNpdGx5XG4gICAgICAgIC8vIHNldCB1cCB0aGUgcmlnaHQgcVxuXG4gICAgICAgIF9wYXJlbnQuY2hlY2tzLnB1c2goe1xuICAgICAgICAgIHR5cGU6IFR5cGUuVFJVRVxuICAgICAgICB9KTsgLy8gcGFyZW50IGltcGxpY2l0bHkgcmVmcyB0aGUgc3ViamVjdFxuXG5cbiAgICAgICAgcmlnaHQuY2hlY2tzLnB1c2goe1xuICAgICAgICAgIHR5cGU6IFR5cGUuUEFSRU5ULFxuICAgICAgICAgIC8vIHR5cGUgaXMgc3dhcHBlZCBvbiByaWdodCBzaWRlIHF1ZXJpZXNcbiAgICAgICAgICBwYXJlbnQ6IF9wYXJlbnQsXG4gICAgICAgICAgY2hpbGQ6IF9jaGlsZCAvLyBlbXB0eSBmb3Igbm93XG5cbiAgICAgICAgfSk7XG4gICAgICAgIHJlcGxhY2VMYXN0UXVlcnkoc2VsZWN0b3IsIGxlZnQsIGNvbXBvdW5kKTsgLy8gdXBkYXRlIHRoZSByZWYgc2luY2Ugd2UgbW92ZWQgdGhpbmdzIGFyb3VuZCBmb3IgYHF1ZXJ5YFxuXG4gICAgICAgIHNlbGVjdG9yLmN1cnJlbnRTdWJqZWN0ID0gc3ViamVjdDtcbiAgICAgICAgc2VsZWN0b3IuY29tcG91bmRDb3VudCsrO1xuICAgICAgICByZXR1cm4gX2NoaWxkOyAvLyBub3cgcG9wdWxhdGluZyB0aGUgcmlnaHQgc2lkZSdzIGNoaWxkXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBwYXJlbnQgcXVlcnlcbiAgICAgICAgLy8gaW5mbyBmb3IgcGFyZW50IHF1ZXJ5XG4gICAgICAgIHZhciBfcGFyZW50MiA9IG5ld1F1ZXJ5KCk7XG5cbiAgICAgICAgdmFyIF9jaGlsZDIgPSBuZXdRdWVyeSgpO1xuXG4gICAgICAgIHZhciBwY1FDaGVja3MgPSBbe1xuICAgICAgICAgIHR5cGU6IFR5cGUuUEFSRU5ULFxuICAgICAgICAgIHBhcmVudDogX3BhcmVudDIsXG4gICAgICAgICAgY2hpbGQ6IF9jaGlsZDJcbiAgICAgICAgfV07IC8vIHRoZSBwYXJlbnQtY2hpbGQgcXVlcnkgdGFrZXMgdGhlIHBsYWNlIG9mIHRoZSBxdWVyeSBwcmV2aW91c2x5IGJlaW5nIHBvcHVsYXRlZFxuXG4gICAgICAgIF9wYXJlbnQyLmNoZWNrcyA9IHF1ZXJ5LmNoZWNrczsgLy8gdGhlIHByZXZpb3VzIHF1ZXJ5IGNvbnRhaW5zIHRoZSBjaGVja3MgZm9yIHRoZSBwYXJlbnRcblxuICAgICAgICBxdWVyeS5jaGVja3MgPSBwY1FDaGVja3M7IC8vIHBjIHF1ZXJ5IHRha2VzIG92ZXJcblxuICAgICAgICBzZWxlY3Rvci5jb21wb3VuZENvdW50Kys7XG4gICAgICAgIHJldHVybiBfY2hpbGQyOyAvLyB3ZSdyZSBub3cgcG9wdWxhdGluZyB0aGUgY2hpbGRcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBuYW1lOiAnZGVzY2VuZGFudCcsXG4gICAgc2VwYXJhdG9yOiB0cnVlLFxuICAgIHJlZ2V4OiB0b2tlbnMuZGVzY2VuZGFudCxcbiAgICBwb3B1bGF0ZTogZnVuY3Rpb24gcG9wdWxhdGUoc2VsZWN0b3IsIHF1ZXJ5KSB7XG4gICAgICBpZiAoc2VsZWN0b3IuY3VycmVudFN1YmplY3QgPT0gbnVsbCkge1xuICAgICAgICAvLyBkZWZhdWx0OiBkZXNjZW5kYW50IHF1ZXJ5XG4gICAgICAgIHZhciBhbmNDaFF1ZXJ5ID0gbmV3UXVlcnkoKTtcbiAgICAgICAgdmFyIGRlc2NlbmRhbnQgPSBuZXdRdWVyeSgpO1xuICAgICAgICB2YXIgYW5jZXN0b3IgPSBzZWxlY3RvcltzZWxlY3Rvci5sZW5ndGggLSAxXTtcbiAgICAgICAgYW5jQ2hRdWVyeS5jaGVja3MucHVzaCh7XG4gICAgICAgICAgdHlwZTogVHlwZS5ERVNDRU5EQU5ULFxuICAgICAgICAgIGFuY2VzdG9yOiBhbmNlc3RvcixcbiAgICAgICAgICBkZXNjZW5kYW50OiBkZXNjZW5kYW50XG4gICAgICAgIH0pOyAvLyB0aGUgcXVlcnkgaW4gdGhlIHNlbGVjdG9yIHNob3VsZCBiZSB0aGUgJz4nIGl0c2VsZlxuXG4gICAgICAgIHJlcGxhY2VMYXN0UXVlcnkoc2VsZWN0b3IsIHF1ZXJ5LCBhbmNDaFF1ZXJ5KTtcbiAgICAgICAgc2VsZWN0b3IuY29tcG91bmRDb3VudCsrOyAvLyB3ZSdyZSBub3cgcG9wdWxhdGluZyB0aGUgZGVzY2VuZGFudCBxdWVyeSB3aXRoIGV4cHJlc3Npb25zIHRoYXQgZm9sbG93XG5cbiAgICAgICAgcmV0dXJuIGRlc2NlbmRhbnQ7XG4gICAgICB9IGVsc2UgaWYgKHNlbGVjdG9yLmN1cnJlbnRTdWJqZWN0ID09PSBxdWVyeSkge1xuICAgICAgICAvLyBjb21wb3VuZCBzcGxpdCBxdWVyeVxuICAgICAgICB2YXIgY29tcG91bmQgPSBuZXdRdWVyeSgpO1xuICAgICAgICB2YXIgbGVmdCA9IHNlbGVjdG9yW3NlbGVjdG9yLmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgcmlnaHQgPSBuZXdRdWVyeSgpO1xuICAgICAgICB2YXIgc3ViamVjdCA9IG5ld1F1ZXJ5KCk7XG5cbiAgICAgICAgdmFyIF9kZXNjZW5kYW50ID0gbmV3UXVlcnkoKTtcblxuICAgICAgICB2YXIgX2FuY2VzdG9yID0gbmV3UXVlcnkoKTsgLy8gc2V0IHVwIHRoZSByb290IGNvbXBvdW5kIHFcblxuXG4gICAgICAgIGNvbXBvdW5kLmNoZWNrcy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBUeXBlLkNPTVBPVU5EX1NQTElULFxuICAgICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgICAgcmlnaHQ6IHJpZ2h0LFxuICAgICAgICAgIHN1YmplY3Q6IHN1YmplY3RcbiAgICAgICAgfSk7IC8vIHBvcHVsYXRlIHRoZSBzdWJqZWN0IGFuZCByZXBsYWNlIHRoZSBxIGF0IHRoZSBvbGQgc3BvdCAod2l0aGluIGxlZnQpIHdpdGggVFJVRVxuXG4gICAgICAgIHN1YmplY3QuY2hlY2tzID0gcXVlcnkuY2hlY2tzOyAvLyB0YWtlIHRoZSBjaGVja3MgZnJvbSB0aGUgbGVmdFxuXG4gICAgICAgIHF1ZXJ5LmNoZWNrcyA9IFt7XG4gICAgICAgICAgdHlwZTogVHlwZS5UUlVFXG4gICAgICAgIH1dOyAvLyBjaGVja3MgdW5kZXIgbGVmdCByZWZzIHRoZSBzdWJqZWN0IGltcGxpY2l0bHlcbiAgICAgICAgLy8gc2V0IHVwIHRoZSByaWdodCBxXG5cbiAgICAgICAgX2FuY2VzdG9yLmNoZWNrcy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBUeXBlLlRSVUVcbiAgICAgICAgfSk7IC8vIGFuY2VzdG9yIGltcGxpY2l0bHkgcmVmcyB0aGUgc3ViamVjdFxuXG5cbiAgICAgICAgcmlnaHQuY2hlY2tzLnB1c2goe1xuICAgICAgICAgIHR5cGU6IFR5cGUuQU5DRVNUT1IsXG4gICAgICAgICAgLy8gdHlwZSBpcyBzd2FwcGVkIG9uIHJpZ2h0IHNpZGUgcXVlcmllc1xuICAgICAgICAgIGFuY2VzdG9yOiBfYW5jZXN0b3IsXG4gICAgICAgICAgZGVzY2VuZGFudDogX2Rlc2NlbmRhbnQgLy8gZW1wdHkgZm9yIG5vd1xuXG4gICAgICAgIH0pO1xuICAgICAgICByZXBsYWNlTGFzdFF1ZXJ5KHNlbGVjdG9yLCBsZWZ0LCBjb21wb3VuZCk7IC8vIHVwZGF0ZSB0aGUgcmVmIHNpbmNlIHdlIG1vdmVkIHRoaW5ncyBhcm91bmQgZm9yIGBxdWVyeWBcblxuICAgICAgICBzZWxlY3Rvci5jdXJyZW50U3ViamVjdCA9IHN1YmplY3Q7XG4gICAgICAgIHNlbGVjdG9yLmNvbXBvdW5kQ291bnQrKztcbiAgICAgICAgcmV0dXJuIF9kZXNjZW5kYW50OyAvLyBub3cgcG9wdWxhdGluZyB0aGUgcmlnaHQgc2lkZSdzIGRlc2NlbmRhbnRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGFuY2VzdG9yIHF1ZXJ5XG4gICAgICAgIC8vIGluZm8gZm9yIHBhcmVudCBxdWVyeVxuICAgICAgICB2YXIgX2FuY2VzdG9yMiA9IG5ld1F1ZXJ5KCk7XG5cbiAgICAgICAgdmFyIF9kZXNjZW5kYW50MiA9IG5ld1F1ZXJ5KCk7XG5cbiAgICAgICAgdmFyIGFkUUNoZWNrcyA9IFt7XG4gICAgICAgICAgdHlwZTogVHlwZS5BTkNFU1RPUixcbiAgICAgICAgICBhbmNlc3RvcjogX2FuY2VzdG9yMixcbiAgICAgICAgICBkZXNjZW5kYW50OiBfZGVzY2VuZGFudDJcbiAgICAgICAgfV07IC8vIHRoZSBwYXJlbnQtY2hpbGQgcXVlcnkgdGFrZXMgdGhlIHBsYWNlIG9mIHRoZSBxdWVyeSBwcmV2aW91c2x5IGJlaW5nIHBvcHVsYXRlZFxuXG4gICAgICAgIF9hbmNlc3RvcjIuY2hlY2tzID0gcXVlcnkuY2hlY2tzOyAvLyB0aGUgcHJldmlvdXMgcXVlcnkgY29udGFpbnMgdGhlIGNoZWNrcyBmb3IgdGhlIHBhcmVudFxuXG4gICAgICAgIHF1ZXJ5LmNoZWNrcyA9IGFkUUNoZWNrczsgLy8gcGMgcXVlcnkgdGFrZXMgb3ZlclxuXG4gICAgICAgIHNlbGVjdG9yLmNvbXBvdW5kQ291bnQrKztcbiAgICAgICAgcmV0dXJuIF9kZXNjZW5kYW50MjsgLy8gd2UncmUgbm93IHBvcHVsYXRpbmcgdGhlIGNoaWxkXG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAgbmFtZTogJ3N1YmplY3QnLFxuICAgIG1vZGlmaWVyOiB0cnVlLFxuICAgIHJlZ2V4OiB0b2tlbnMuc3ViamVjdCxcbiAgICBwb3B1bGF0ZTogZnVuY3Rpb24gcG9wdWxhdGUoc2VsZWN0b3IsIHF1ZXJ5KSB7XG4gICAgICBpZiAoc2VsZWN0b3IuY3VycmVudFN1YmplY3QgIT0gbnVsbCAmJiBzZWxlY3Rvci5jdXJyZW50U3ViamVjdCAhPT0gcXVlcnkpIHtcbiAgICAgICAgd2FybignUmVkZWZpbml0aW9uIG9mIHN1YmplY3QgaW4gc2VsZWN0b3IgYCcgKyBzZWxlY3Rvci50b1N0cmluZygpICsgJ2AnKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBzZWxlY3Rvci5jdXJyZW50U3ViamVjdCA9IHF1ZXJ5O1xuICAgICAgdmFyIHRvcFEgPSBzZWxlY3RvcltzZWxlY3Rvci5sZW5ndGggLSAxXTtcbiAgICAgIHZhciB0b3BDaGsgPSB0b3BRLmNoZWNrc1swXTtcbiAgICAgIHZhciB0b3BUeXBlID0gdG9wQ2hrID09IG51bGwgPyBudWxsIDogdG9wQ2hrLnR5cGU7XG5cbiAgICAgIGlmICh0b3BUeXBlID09PSBUeXBlLkRJUkVDVEVEX0VER0UpIHtcbiAgICAgICAgLy8gZGlyZWN0ZWQgZWRnZSB3aXRoIHN1YmplY3Qgb24gdGhlIHRhcmdldFxuICAgICAgICAvLyBjaGFuZ2UgdG8gdGFyZ2V0IG5vZGUgY2hlY2tcbiAgICAgICAgdG9wQ2hrLnR5cGUgPSBUeXBlLk5PREVfVEFSR0VUO1xuICAgICAgfSBlbHNlIGlmICh0b3BUeXBlID09PSBUeXBlLlVORElSRUNURURfRURHRSkge1xuICAgICAgICAvLyB1bmRpcmVjdGVkIGVkZ2Ugd2l0aCBzdWJqZWN0IG9uIHRoZSBzZWNvbmQgbm9kZVxuICAgICAgICAvLyBjaGFuZ2UgdG8gbmVpZ2hib3IgY2hlY2tcbiAgICAgICAgdG9wQ2hrLnR5cGUgPSBUeXBlLk5PREVfTkVJR0hCT1I7XG4gICAgICAgIHRvcENoay5ub2RlID0gdG9wQ2hrLm5vZGVzWzFdOyAvLyBzZWNvbmQgbm9kZSBpcyBzdWJqZWN0XG5cbiAgICAgICAgdG9wQ2hrLm5laWdoYm9yID0gdG9wQ2hrLm5vZGVzWzBdOyAvLyBjbGVhbiB1cCB1bnVzZWQgZmllbGRzIGZvciBuZXcgdHlwZVxuXG4gICAgICAgIHRvcENoay5ub2RlcyA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XTtcbiAgZXhwcnMuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgIHJldHVybiBlLnJlZ2V4T2JqID0gbmV3IFJlZ0V4cCgnXicgKyBlLnJlZ2V4KTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIE9mIGFsbCB0aGUgZXhwcmVzc2lvbnMsIGZpbmQgdGhlIGZpcnN0IG1hdGNoIGluIHRoZSByZW1haW5pbmcgdGV4dC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlbWFpbmluZyBUaGUgcmVtYWluaW5nIHRleHQgdG8gcGFyc2VcbiAgICogQHJldHVybnMgVGhlIG1hdGNoZWQgZXhwcmVzc2lvbiBhbmQgdGhlIG5ld2x5IHJlbWFpbmluZyB0ZXh0IGB7IGV4cHIsIG1hdGNoLCBuYW1lLCByZW1haW5pbmcgfWBcbiAgICovXG5cbiAgdmFyIGNvbnN1bWVFeHByID0gZnVuY3Rpb24gY29uc3VtZUV4cHIocmVtYWluaW5nKSB7XG4gICAgdmFyIGV4cHI7XG4gICAgdmFyIG1hdGNoO1xuICAgIHZhciBuYW1lO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBleHBycy5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIGUgPSBleHByc1tqXTtcbiAgICAgIHZhciBuID0gZS5uYW1lO1xuICAgICAgdmFyIG0gPSByZW1haW5pbmcubWF0Y2goZS5yZWdleE9iaik7XG5cbiAgICAgIGlmIChtICE9IG51bGwpIHtcbiAgICAgICAgbWF0Y2ggPSBtO1xuICAgICAgICBleHByID0gZTtcbiAgICAgICAgbmFtZSA9IG47XG4gICAgICAgIHZhciBjb25zdW1lZCA9IG1bMF07XG4gICAgICAgIHJlbWFpbmluZyA9IHJlbWFpbmluZy5zdWJzdHJpbmcoY29uc3VtZWQubGVuZ3RoKTtcbiAgICAgICAgYnJlYWs7IC8vIHdlJ3ZlIGNvbnN1bWVkIG9uZSBleHByLCBzbyB3ZSBjYW4gcmV0dXJuIG5vd1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBleHByOiBleHByLFxuICAgICAgbWF0Y2g6IG1hdGNoLFxuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHJlbWFpbmluZzogcmVtYWluaW5nXG4gICAgfTtcbiAgfTtcbiAgLyoqXG4gICAqIENvbnN1bWUgYWxsIHRoZSBsZWFkaW5nIHdoaXRlc3BhY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlbWFpbmluZyBUaGUgdGV4dCB0byBjb25zdW1lXG4gICAqIEByZXR1cm5zIFRoZSB0ZXh0IHdpdGggdGhlIGxlYWRpbmcgd2hpdGVzcGFjZSByZW1vdmVkXG4gICAqL1xuXG5cbiAgdmFyIGNvbnN1bWVXaGl0ZXNwYWNlID0gZnVuY3Rpb24gY29uc3VtZVdoaXRlc3BhY2UocmVtYWluaW5nKSB7XG4gICAgdmFyIG1hdGNoID0gcmVtYWluaW5nLm1hdGNoKC9eXFxzKy8pO1xuXG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICB2YXIgY29uc3VtZWQgPSBtYXRjaFswXTtcbiAgICAgIHJlbWFpbmluZyA9IHJlbWFpbmluZy5zdWJzdHJpbmcoY29uc3VtZWQubGVuZ3RoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVtYWluaW5nO1xuICB9O1xuICAvKipcbiAgICogUGFyc2UgdGhlIHN0cmluZyBhbmQgc3RvcmUgdGhlIHBhcnNlZCByZXByZXNlbnRhdGlvbiBpbiB0aGUgU2VsZWN0b3IuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvciBUaGUgc2VsZWN0b3Igc3RyaW5nXG4gICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgc2VsZWN0b3Igd2FzIHN1Y2Nlc3NmdWxseSBwYXJzZWQsIGBmYWxzZWAgb3RoZXJ3aXNlXG4gICAqL1xuXG5cbiAgdmFyIHBhcnNlID0gZnVuY3Rpb24gcGFyc2Uoc2VsZWN0b3IpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHJlbWFpbmluZyA9IHNlbGYuaW5wdXRUZXh0ID0gc2VsZWN0b3I7XG4gICAgdmFyIGN1cnJlbnRRdWVyeSA9IHNlbGZbMF0gPSBuZXdRdWVyeSgpO1xuICAgIHNlbGYubGVuZ3RoID0gMTtcbiAgICByZW1haW5pbmcgPSBjb25zdW1lV2hpdGVzcGFjZShyZW1haW5pbmcpOyAvLyBnZXQgcmlkIG9mIGxlYWRpbmcgd2hpdGVzcGFjZVxuXG4gICAgZm9yICg7Oykge1xuICAgICAgdmFyIGV4cHJJbmZvID0gY29uc3VtZUV4cHIocmVtYWluaW5nKTtcblxuICAgICAgaWYgKGV4cHJJbmZvLmV4cHIgPT0gbnVsbCkge1xuICAgICAgICB3YXJuKCdUaGUgc2VsZWN0b3IgYCcgKyBzZWxlY3RvciArICdgaXMgaW52YWxpZCcpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgYXJncyA9IGV4cHJJbmZvLm1hdGNoLnNsaWNlKDEpOyAvLyBsZXQgdGhlIHRva2VuIHBvcHVsYXRlIHRoZSBzZWxlY3RvciBvYmplY3QgaW4gY3VycmVudFF1ZXJ5XG5cbiAgICAgICAgdmFyIHJldCA9IGV4cHJJbmZvLmV4cHIucG9wdWxhdGUoc2VsZiwgY3VycmVudFF1ZXJ5LCBhcmdzKTtcblxuICAgICAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gZXhpdCBpZiBwb3B1bGF0aW9uIGZhaWxlZFxuICAgICAgICB9IGVsc2UgaWYgKHJldCAhPSBudWxsKSB7XG4gICAgICAgICAgY3VycmVudFF1ZXJ5ID0gcmV0OyAvLyBjaGFuZ2UgdGhlIGN1cnJlbnQgcXVlcnkgdG8gYmUgZmlsbGVkIGlmIHRoZSBleHByIHNwZWNpZmllc1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJlbWFpbmluZyA9IGV4cHJJbmZvLnJlbWFpbmluZzsgLy8gd2UncmUgZG9uZSB3aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIHBhcnNlXG5cbiAgICAgIGlmIChyZW1haW5pbmcubWF0Y2goL15cXHMqJC8pKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBsYXN0USA9IHNlbGZbc2VsZi5sZW5ndGggLSAxXTtcblxuICAgIGlmIChzZWxmLmN1cnJlbnRTdWJqZWN0ICE9IG51bGwpIHtcbiAgICAgIGxhc3RRLnN1YmplY3QgPSBzZWxmLmN1cnJlbnRTdWJqZWN0O1xuICAgIH1cblxuICAgIGxhc3RRLmVkZ2VDb3VudCA9IHNlbGYuZWRnZUNvdW50O1xuICAgIGxhc3RRLmNvbXBvdW5kQ291bnQgPSBzZWxmLmNvbXBvdW5kQ291bnQ7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBxID0gc2VsZltpXTsgLy8gaW4gZnV0dXJlLCB0aGlzIGNvdWxkIHBvdGVudGlhbGx5IGJlIGFsbG93ZWQgaWYgdGhlcmUgd2VyZSBvcGVyYXRvciBwcmVjZWRlbmNlIGFuZCBkZXRlY3Rpb24gb2YgaW52YWxpZCBjb21iaW5hdGlvbnNcblxuICAgICAgaWYgKHEuY29tcG91bmRDb3VudCA+IDAgJiYgcS5lZGdlQ291bnQgPiAwKSB7XG4gICAgICAgIHdhcm4oJ1RoZSBzZWxlY3RvciBgJyArIHNlbGVjdG9yICsgJ2AgaXMgaW52YWxpZCBiZWNhdXNlIGl0IHVzZXMgYm90aCBhIGNvbXBvdW5kIHNlbGVjdG9yIGFuZCBhbiBlZGdlIHNlbGVjdG9yJyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHEuZWRnZUNvdW50ID4gMSkge1xuICAgICAgICB3YXJuKCdUaGUgc2VsZWN0b3IgYCcgKyBzZWxlY3RvciArICdgIGlzIGludmFsaWQgYmVjYXVzZSBpdCB1c2VzIG11bHRpcGxlIGVkZ2Ugc2VsZWN0b3JzJyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAocS5lZGdlQ291bnQgPT09IDEpIHtcbiAgICAgICAgd2FybignVGhlIHNlbGVjdG9yIGAnICsgc2VsZWN0b3IgKyAnYCBpcyBkZXByZWNhdGVkLiAgRWRnZSBzZWxlY3RvcnMgZG8gbm90IHRha2UgZWZmZWN0IG9uIGNoYW5nZXMgdG8gc291cmNlIGFuZCB0YXJnZXQgbm9kZXMgYWZ0ZXIgYW4gZWRnZSBpcyBhZGRlZCwgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuICBVc2UgYSBjbGFzcyBvciBkYXRhIHNlbGVjdG9yIG9uIGVkZ2VzIGluc3RlYWQsIHVwZGF0aW5nIHRoZSBjbGFzcyBvciBkYXRhIG9mIGFuIGVkZ2Ugd2hlbiB5b3VyIGFwcCBkZXRlY3RzIGEgY2hhbmdlIGluIHNvdXJjZSBvciB0YXJnZXQgbm9kZXMuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7IC8vIHN1Y2Nlc3NcbiAgfTtcbiAgLyoqXG4gICAqIEdldCB0aGUgc2VsZWN0b3IgcmVwcmVzZW50ZWQgYXMgYSBzdHJpbmcuICBUaGlzIHZhbHVlIHVzZXMgZGVmYXVsdCBmb3JtYXR0aW5nLFxuICAgKiBzbyB0aGluZ3MgbGlrZSBzcGFjaW5nIG1heSBkaWZmZXIgZnJvbSB0aGUgaW5wdXQgdGV4dCBwYXNzZWQgdG8gdGhlIGNvbnN0cnVjdG9yLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgc2VsZWN0b3Igc3RyaW5nXG4gICAqL1xuXG5cbiAgdmFyIHRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgaWYgKHRoaXMudG9TdHJpbmdDYWNoZSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcy50b1N0cmluZ0NhY2hlO1xuICAgIH1cblxuICAgIHZhciBjbGVhbiA9IGZ1bmN0aW9uIGNsZWFuKG9iaikge1xuICAgICAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBjbGVhblZhbCA9IGZ1bmN0aW9uIGNsZWFuVmFsKHZhbCkge1xuICAgICAgaWYgKHN0cmluZyh2YWwpKSB7XG4gICAgICAgIHJldHVybiAnXCInICsgdmFsICsgJ1wiJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjbGVhbih2YWwpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgc3BhY2UgPSBmdW5jdGlvbiBzcGFjZSh2YWwpIHtcbiAgICAgIHJldHVybiAnICcgKyB2YWwgKyAnICc7XG4gICAgfTtcblxuICAgIHZhciBjaGVja1RvU3RyaW5nID0gZnVuY3Rpb24gY2hlY2tUb1N0cmluZyhjaGVjaywgc3ViamVjdCkge1xuICAgICAgdmFyIHR5cGUgPSBjaGVjay50eXBlLFxuICAgICAgICAgIHZhbHVlID0gY2hlY2sudmFsdWU7XG5cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFR5cGUuR1JPVVA6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIGdyb3VwID0gY2xlYW4odmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIGdyb3VwLnN1YnN0cmluZygwLCBncm91cC5sZW5ndGggLSAxKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBUeXBlLkRBVEFfQ09NUEFSRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgZmllbGQgPSBjaGVjay5maWVsZCxcbiAgICAgICAgICAgICAgICBvcGVyYXRvciA9IGNoZWNrLm9wZXJhdG9yO1xuICAgICAgICAgICAgcmV0dXJuICdbJyArIGZpZWxkICsgc3BhY2UoY2xlYW4ob3BlcmF0b3IpKSArIGNsZWFuVmFsKHZhbHVlKSArICddJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBUeXBlLkRBVEFfQk9PTDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX29wZXJhdG9yID0gY2hlY2sub3BlcmF0b3IsXG4gICAgICAgICAgICAgICAgX2ZpZWxkID0gY2hlY2suZmllbGQ7XG4gICAgICAgICAgICByZXR1cm4gJ1snICsgY2xlYW4oX29wZXJhdG9yKSArIF9maWVsZCArICddJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBUeXBlLkRBVEFfRVhJU1Q6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9maWVsZDIgPSBjaGVjay5maWVsZDtcbiAgICAgICAgICAgIHJldHVybiAnWycgKyBfZmllbGQyICsgJ10nO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFR5cGUuTUVUQV9DT01QQVJFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfb3BlcmF0b3IyID0gY2hlY2sub3BlcmF0b3IsXG4gICAgICAgICAgICAgICAgX2ZpZWxkMyA9IGNoZWNrLmZpZWxkO1xuICAgICAgICAgICAgcmV0dXJuICdbWycgKyBfZmllbGQzICsgc3BhY2UoY2xlYW4oX29wZXJhdG9yMikpICsgY2xlYW5WYWwodmFsdWUpICsgJ11dJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBUeXBlLlNUQVRFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBUeXBlLklEOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiAnIycgKyB2YWx1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBUeXBlLkNMQVNTOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiAnLicgKyB2YWx1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBUeXBlLlBBUkVOVDpcbiAgICAgICAgY2FzZSBUeXBlLkNISUxEOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBxdWVyeVRvU3RyaW5nKGNoZWNrLnBhcmVudCwgc3ViamVjdCkgKyBzcGFjZSgnPicpICsgcXVlcnlUb1N0cmluZyhjaGVjay5jaGlsZCwgc3ViamVjdCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgVHlwZS5BTkNFU1RPUjpcbiAgICAgICAgY2FzZSBUeXBlLkRFU0NFTkRBTlQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHF1ZXJ5VG9TdHJpbmcoY2hlY2suYW5jZXN0b3IsIHN1YmplY3QpICsgJyAnICsgcXVlcnlUb1N0cmluZyhjaGVjay5kZXNjZW5kYW50LCBzdWJqZWN0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBUeXBlLkNPTVBPVU5EX1NQTElUOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBsaHMgPSBxdWVyeVRvU3RyaW5nKGNoZWNrLmxlZnQsIHN1YmplY3QpO1xuICAgICAgICAgICAgdmFyIHN1YiA9IHF1ZXJ5VG9TdHJpbmcoY2hlY2suc3ViamVjdCwgc3ViamVjdCk7XG4gICAgICAgICAgICB2YXIgcmhzID0gcXVlcnlUb1N0cmluZyhjaGVjay5yaWdodCwgc3ViamVjdCk7XG4gICAgICAgICAgICByZXR1cm4gbGhzICsgKGxocy5sZW5ndGggPiAwID8gJyAnIDogJycpICsgc3ViICsgcmhzO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFR5cGUuVFJVRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgcXVlcnlUb1N0cmluZyA9IGZ1bmN0aW9uIHF1ZXJ5VG9TdHJpbmcocXVlcnksIHN1YmplY3QpIHtcbiAgICAgIHJldHVybiBxdWVyeS5jaGVja3MucmVkdWNlKGZ1bmN0aW9uIChzdHIsIGNoaywgaSkge1xuICAgICAgICByZXR1cm4gc3RyICsgKHN1YmplY3QgPT09IHF1ZXJ5ICYmIGkgPT09IDAgPyAnJCcgOiAnJykgKyBjaGVja1RvU3RyaW5nKGNoaywgc3ViamVjdCk7XG4gICAgICB9LCAnJyk7XG4gICAgfTtcblxuICAgIHZhciBzdHIgPSAnJztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHF1ZXJ5ID0gdGhpc1tpXTtcbiAgICAgIHN0ciArPSBxdWVyeVRvU3RyaW5nKHF1ZXJ5LCBxdWVyeS5zdWJqZWN0KTtcblxuICAgICAgaWYgKHRoaXMubGVuZ3RoID4gMSAmJiBpIDwgdGhpcy5sZW5ndGggLSAxKSB7XG4gICAgICAgIHN0ciArPSAnLCAnO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMudG9TdHJpbmdDYWNoZSA9IHN0cjtcbiAgICByZXR1cm4gc3RyO1xuICB9O1xuICB2YXIgcGFyc2UkMSA9IHtcbiAgICBwYXJzZTogcGFyc2UsXG4gICAgdG9TdHJpbmc6IHRvU3RyaW5nXG4gIH07XG5cbiAgdmFyIHZhbENtcCA9IGZ1bmN0aW9uIHZhbENtcChmaWVsZFZhbCwgb3BlcmF0b3IsIHZhbHVlKSB7XG4gICAgdmFyIG1hdGNoZXM7XG4gICAgdmFyIGlzRmllbGRTdHIgPSBzdHJpbmcoZmllbGRWYWwpO1xuICAgIHZhciBpc0ZpZWxkTnVtID0gbnVtYmVyJDEoZmllbGRWYWwpO1xuICAgIHZhciBpc1ZhbFN0ciA9IHN0cmluZyh2YWx1ZSk7XG4gICAgdmFyIGZpZWxkU3RyLCB2YWxTdHI7XG4gICAgdmFyIGNhc2VJbnNlbnNpdGl2ZSA9IGZhbHNlO1xuICAgIHZhciBub3RFeHByID0gZmFsc2U7XG4gICAgdmFyIGlzSW5lcUNtcCA9IGZhbHNlO1xuXG4gICAgaWYgKG9wZXJhdG9yLmluZGV4T2YoJyEnKSA+PSAwKSB7XG4gICAgICBvcGVyYXRvciA9IG9wZXJhdG9yLnJlcGxhY2UoJyEnLCAnJyk7XG4gICAgICBub3RFeHByID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAob3BlcmF0b3IuaW5kZXhPZignQCcpID49IDApIHtcbiAgICAgIG9wZXJhdG9yID0gb3BlcmF0b3IucmVwbGFjZSgnQCcsICcnKTtcbiAgICAgIGNhc2VJbnNlbnNpdGl2ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGlzRmllbGRTdHIgfHwgaXNWYWxTdHIgfHwgY2FzZUluc2Vuc2l0aXZlKSB7XG4gICAgICBmaWVsZFN0ciA9ICFpc0ZpZWxkU3RyICYmICFpc0ZpZWxkTnVtID8gJycgOiAnJyArIGZpZWxkVmFsO1xuICAgICAgdmFsU3RyID0gJycgKyB2YWx1ZTtcbiAgICB9IC8vIGlmIHdlJ3JlIGRvaW5nIGEgY2FzZSBpbnNlbnNpdGl2ZSBjb21wYXJpc29uLCB0aGVuIHdlJ3JlIHVzaW5nIGEgU1RSSU5HIGNvbXBhcmlzb25cbiAgICAvLyBldmVuIGlmIHdlJ3JlIGNvbXBhcmluZyBudW1iZXJzXG5cblxuICAgIGlmIChjYXNlSW5zZW5zaXRpdmUpIHtcbiAgICAgIGZpZWxkVmFsID0gZmllbGRTdHIgPSBmaWVsZFN0ci50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFsdWUgPSB2YWxTdHIgPSB2YWxTdHIudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgICBjYXNlICcqPSc6XG4gICAgICAgIG1hdGNoZXMgPSBmaWVsZFN0ci5pbmRleE9mKHZhbFN0cikgPj0gMDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJyQ9JzpcbiAgICAgICAgbWF0Y2hlcyA9IGZpZWxkU3RyLmluZGV4T2YodmFsU3RyLCBmaWVsZFN0ci5sZW5ndGggLSB2YWxTdHIubGVuZ3RoKSA+PSAwO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnXj0nOlxuICAgICAgICBtYXRjaGVzID0gZmllbGRTdHIuaW5kZXhPZih2YWxTdHIpID09PSAwO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnPSc6XG4gICAgICAgIG1hdGNoZXMgPSBmaWVsZFZhbCA9PT0gdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICc+JzpcbiAgICAgICAgaXNJbmVxQ21wID0gdHJ1ZTtcbiAgICAgICAgbWF0Y2hlcyA9IGZpZWxkVmFsID4gdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICc+PSc6XG4gICAgICAgIGlzSW5lcUNtcCA9IHRydWU7XG4gICAgICAgIG1hdGNoZXMgPSBmaWVsZFZhbCA+PSB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJzwnOlxuICAgICAgICBpc0luZXFDbXAgPSB0cnVlO1xuICAgICAgICBtYXRjaGVzID0gZmllbGRWYWwgPCB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJzw9JzpcbiAgICAgICAgaXNJbmVxQ21wID0gdHJ1ZTtcbiAgICAgICAgbWF0Y2hlcyA9IGZpZWxkVmFsIDw9IHZhbHVlO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbWF0Y2hlcyA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICB9IC8vIGFwcGx5IHRoZSBub3Qgb3AsIGJ1dCBudWxsIHZhbHMgZm9yIGluZXF1YWxpdGllcyBzaG91bGQgYWx3YXlzIHN0YXkgbm9uLW1hdGNoaW5nXG5cblxuICAgIGlmIChub3RFeHByICYmIChmaWVsZFZhbCAhPSBudWxsIHx8ICFpc0luZXFDbXApKSB7XG4gICAgICBtYXRjaGVzID0gIW1hdGNoZXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hdGNoZXM7XG4gIH07XG4gIHZhciBib29sQ21wID0gZnVuY3Rpb24gYm9vbENtcChmaWVsZFZhbCwgb3BlcmF0b3IpIHtcbiAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgICBjYXNlICc/JzpcbiAgICAgICAgcmV0dXJuIGZpZWxkVmFsID8gdHJ1ZSA6IGZhbHNlO1xuXG4gICAgICBjYXNlICchJzpcbiAgICAgICAgcmV0dXJuIGZpZWxkVmFsID8gZmFsc2UgOiB0cnVlO1xuXG4gICAgICBjYXNlICdeJzpcbiAgICAgICAgcmV0dXJuIGZpZWxkVmFsID09PSB1bmRlZmluZWQ7XG4gICAgfVxuICB9O1xuICB2YXIgZXhpc3RDbXAgPSBmdW5jdGlvbiBleGlzdENtcChmaWVsZFZhbCkge1xuICAgIHJldHVybiBmaWVsZFZhbCAhPT0gdW5kZWZpbmVkO1xuICB9O1xuICB2YXIgZGF0YSQxID0gZnVuY3Rpb24gZGF0YShlbGUsIGZpZWxkKSB7XG4gICAgcmV0dXJuIGVsZS5kYXRhKGZpZWxkKTtcbiAgfTtcbiAgdmFyIG1ldGEgPSBmdW5jdGlvbiBtZXRhKGVsZSwgZmllbGQpIHtcbiAgICByZXR1cm4gZWxlW2ZpZWxkXSgpO1xuICB9O1xuXG4gIC8qKiBBIGxvb2t1cCBvZiBgbWF0Y2goY2hlY2ssIGVsZSlgIGZ1bmN0aW9ucyBieSBgVHlwZWAgaW50ICovXG5cbiAgdmFyIG1hdGNoID0gW107XG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHF1ZXJ5IG1hdGNoZXMgZm9yIHRoZSBlbGVtZW50XG4gICAqIEBwYXJhbSBxdWVyeSBUaGUgYHsgdHlwZSwgdmFsdWUsIC4uLiB9YCBxdWVyeSBvYmplY3RcbiAgICogQHBhcmFtIGVsZSBUaGUgZWxlbWVudCB0byBjb21wYXJlIGFnYWluc3RcbiAgKi9cblxuICB2YXIgbWF0Y2hlcyQxID0gZnVuY3Rpb24gbWF0Y2hlcyhxdWVyeSwgZWxlKSB7XG4gICAgcmV0dXJuIHF1ZXJ5LmNoZWNrcy5ldmVyeShmdW5jdGlvbiAoY2hrKSB7XG4gICAgICByZXR1cm4gbWF0Y2hbY2hrLnR5cGVdKGNoaywgZWxlKTtcbiAgICB9KTtcbiAgfTtcblxuICBtYXRjaFtUeXBlLkdST1VQXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gICAgdmFyIGdyb3VwID0gY2hlY2sudmFsdWU7XG4gICAgcmV0dXJuIGdyb3VwID09PSAnKicgfHwgZ3JvdXAgPT09IGVsZS5ncm91cCgpO1xuICB9O1xuXG4gIG1hdGNoW1R5cGUuU1RBVEVdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgICB2YXIgc3RhdGVTZWxlY3RvciA9IGNoZWNrLnZhbHVlO1xuICAgIHJldHVybiBzdGF0ZVNlbGVjdG9yTWF0Y2hlcyhzdGF0ZVNlbGVjdG9yLCBlbGUpO1xuICB9O1xuXG4gIG1hdGNoW1R5cGUuSURdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgICB2YXIgaWQgPSBjaGVjay52YWx1ZTtcbiAgICByZXR1cm4gZWxlLmlkKCkgPT09IGlkO1xuICB9O1xuXG4gIG1hdGNoW1R5cGUuQ0xBU1NdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgICB2YXIgY2xzID0gY2hlY2sudmFsdWU7XG4gICAgcmV0dXJuIGVsZS5oYXNDbGFzcyhjbHMpO1xuICB9O1xuXG4gIG1hdGNoW1R5cGUuTUVUQV9DT01QQVJFXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gICAgdmFyIGZpZWxkID0gY2hlY2suZmllbGQsXG4gICAgICAgIG9wZXJhdG9yID0gY2hlY2sub3BlcmF0b3IsXG4gICAgICAgIHZhbHVlID0gY2hlY2sudmFsdWU7XG4gICAgcmV0dXJuIHZhbENtcChtZXRhKGVsZSwgZmllbGQpLCBvcGVyYXRvciwgdmFsdWUpO1xuICB9O1xuXG4gIG1hdGNoW1R5cGUuREFUQV9DT01QQVJFXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gICAgdmFyIGZpZWxkID0gY2hlY2suZmllbGQsXG4gICAgICAgIG9wZXJhdG9yID0gY2hlY2sub3BlcmF0b3IsXG4gICAgICAgIHZhbHVlID0gY2hlY2sudmFsdWU7XG4gICAgcmV0dXJuIHZhbENtcChkYXRhJDEoZWxlLCBmaWVsZCksIG9wZXJhdG9yLCB2YWx1ZSk7XG4gIH07XG5cbiAgbWF0Y2hbVHlwZS5EQVRBX0JPT0xdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgICB2YXIgZmllbGQgPSBjaGVjay5maWVsZCxcbiAgICAgICAgb3BlcmF0b3IgPSBjaGVjay5vcGVyYXRvcjtcbiAgICByZXR1cm4gYm9vbENtcChkYXRhJDEoZWxlLCBmaWVsZCksIG9wZXJhdG9yKTtcbiAgfTtcblxuICBtYXRjaFtUeXBlLkRBVEFfRVhJU1RdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgICB2YXIgZmllbGQgPSBjaGVjay5maWVsZDtcbiAgICAgICAgY2hlY2sub3BlcmF0b3I7XG4gICAgcmV0dXJuIGV4aXN0Q21wKGRhdGEkMShlbGUsIGZpZWxkKSk7XG4gIH07XG5cbiAgbWF0Y2hbVHlwZS5VTkRJUkVDVEVEX0VER0VdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgICB2YXIgcUEgPSBjaGVjay5ub2Rlc1swXTtcbiAgICB2YXIgcUIgPSBjaGVjay5ub2Rlc1sxXTtcbiAgICB2YXIgc3JjID0gZWxlLnNvdXJjZSgpO1xuICAgIHZhciB0Z3QgPSBlbGUudGFyZ2V0KCk7XG4gICAgcmV0dXJuIG1hdGNoZXMkMShxQSwgc3JjKSAmJiBtYXRjaGVzJDEocUIsIHRndCkgfHwgbWF0Y2hlcyQxKHFCLCBzcmMpICYmIG1hdGNoZXMkMShxQSwgdGd0KTtcbiAgfTtcblxuICBtYXRjaFtUeXBlLk5PREVfTkVJR0hCT1JdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgICByZXR1cm4gbWF0Y2hlcyQxKGNoZWNrLm5vZGUsIGVsZSkgJiYgZWxlLm5laWdoYm9yaG9vZCgpLnNvbWUoZnVuY3Rpb24gKG4pIHtcbiAgICAgIHJldHVybiBuLmlzTm9kZSgpICYmIG1hdGNoZXMkMShjaGVjay5uZWlnaGJvciwgbik7XG4gICAgfSk7XG4gIH07XG5cbiAgbWF0Y2hbVHlwZS5ESVJFQ1RFRF9FREdFXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gICAgcmV0dXJuIG1hdGNoZXMkMShjaGVjay5zb3VyY2UsIGVsZS5zb3VyY2UoKSkgJiYgbWF0Y2hlcyQxKGNoZWNrLnRhcmdldCwgZWxlLnRhcmdldCgpKTtcbiAgfTtcblxuICBtYXRjaFtUeXBlLk5PREVfU09VUkNFXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gICAgcmV0dXJuIG1hdGNoZXMkMShjaGVjay5zb3VyY2UsIGVsZSkgJiYgZWxlLm91dGdvZXJzKCkuc29tZShmdW5jdGlvbiAobikge1xuICAgICAgcmV0dXJuIG4uaXNOb2RlKCkgJiYgbWF0Y2hlcyQxKGNoZWNrLnRhcmdldCwgbik7XG4gICAgfSk7XG4gIH07XG5cbiAgbWF0Y2hbVHlwZS5OT0RFX1RBUkdFVF0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICAgIHJldHVybiBtYXRjaGVzJDEoY2hlY2sudGFyZ2V0LCBlbGUpICYmIGVsZS5pbmNvbWVycygpLnNvbWUoZnVuY3Rpb24gKG4pIHtcbiAgICAgIHJldHVybiBuLmlzTm9kZSgpICYmIG1hdGNoZXMkMShjaGVjay5zb3VyY2UsIG4pO1xuICAgIH0pO1xuICB9O1xuXG4gIG1hdGNoW1R5cGUuQ0hJTERdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgICByZXR1cm4gbWF0Y2hlcyQxKGNoZWNrLmNoaWxkLCBlbGUpICYmIG1hdGNoZXMkMShjaGVjay5wYXJlbnQsIGVsZS5wYXJlbnQoKSk7XG4gIH07XG5cbiAgbWF0Y2hbVHlwZS5QQVJFTlRdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgICByZXR1cm4gbWF0Y2hlcyQxKGNoZWNrLnBhcmVudCwgZWxlKSAmJiBlbGUuY2hpbGRyZW4oKS5zb21lKGZ1bmN0aW9uIChjKSB7XG4gICAgICByZXR1cm4gbWF0Y2hlcyQxKGNoZWNrLmNoaWxkLCBjKTtcbiAgICB9KTtcbiAgfTtcblxuICBtYXRjaFtUeXBlLkRFU0NFTkRBTlRdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgICByZXR1cm4gbWF0Y2hlcyQxKGNoZWNrLmRlc2NlbmRhbnQsIGVsZSkgJiYgZWxlLmFuY2VzdG9ycygpLnNvbWUoZnVuY3Rpb24gKGEpIHtcbiAgICAgIHJldHVybiBtYXRjaGVzJDEoY2hlY2suYW5jZXN0b3IsIGEpO1xuICAgIH0pO1xuICB9O1xuXG4gIG1hdGNoW1R5cGUuQU5DRVNUT1JdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgICByZXR1cm4gbWF0Y2hlcyQxKGNoZWNrLmFuY2VzdG9yLCBlbGUpICYmIGVsZS5kZXNjZW5kYW50cygpLnNvbWUoZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiBtYXRjaGVzJDEoY2hlY2suZGVzY2VuZGFudCwgZCk7XG4gICAgfSk7XG4gIH07XG5cbiAgbWF0Y2hbVHlwZS5DT01QT1VORF9TUExJVF0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICAgIHJldHVybiBtYXRjaGVzJDEoY2hlY2suc3ViamVjdCwgZWxlKSAmJiBtYXRjaGVzJDEoY2hlY2subGVmdCwgZWxlKSAmJiBtYXRjaGVzJDEoY2hlY2sucmlnaHQsIGVsZSk7XG4gIH07XG5cbiAgbWF0Y2hbVHlwZS5UUlVFXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBtYXRjaFtUeXBlLkNPTExFQ1RJT05dID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgICB2YXIgY29sbGVjdGlvbiA9IGNoZWNrLnZhbHVlO1xuICAgIHJldHVybiBjb2xsZWN0aW9uLmhhcyhlbGUpO1xuICB9O1xuXG4gIG1hdGNoW1R5cGUuRklMVEVSXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gICAgdmFyIGZpbHRlciA9IGNoZWNrLnZhbHVlO1xuICAgIHJldHVybiBmaWx0ZXIoZWxlKTtcbiAgfTtcblxuICB2YXIgZmlsdGVyID0gZnVuY3Rpb24gZmlsdGVyKGNvbGxlY3Rpb24pIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7IC8vIGZvciAxIGlkICNmb28gcXVlcmllcywganVzdCBnZXQgdGhlIGVsZW1lbnRcblxuICAgIGlmIChzZWxmLmxlbmd0aCA9PT0gMSAmJiBzZWxmWzBdLmNoZWNrcy5sZW5ndGggPT09IDEgJiYgc2VsZlswXS5jaGVja3NbMF0udHlwZSA9PT0gVHlwZS5JRCkge1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uZ2V0RWxlbWVudEJ5SWQoc2VsZlswXS5jaGVja3NbMF0udmFsdWUpLmNvbGxlY3Rpb24oKTtcbiAgICB9XG5cbiAgICB2YXIgc2VsZWN0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uIHNlbGVjdG9yRnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzZWxmLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBxdWVyeSA9IHNlbGZbal07XG5cbiAgICAgICAgaWYgKG1hdGNoZXMkMShxdWVyeSwgZWxlbWVudCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIGlmIChzZWxmLnRleHQoKSA9PSBudWxsKSB7XG4gICAgICBzZWxlY3RvckZ1bmN0aW9uID0gZnVuY3Rpb24gc2VsZWN0b3JGdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBjb2xsZWN0aW9uLmZpbHRlcihzZWxlY3RvckZ1bmN0aW9uKTtcbiAgfTsgLy8gZmlsdGVyXG4gIC8vIGRvZXMgc2VsZWN0b3IgbWF0Y2ggYSBzaW5nbGUgZWxlbWVudD9cblxuXG4gIHZhciBtYXRjaGVzID0gZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNlbGYubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBxdWVyeSA9IHNlbGZbal07XG5cbiAgICAgIGlmIChtYXRjaGVzJDEocXVlcnksIGVsZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9OyAvLyBtYXRjaGVzXG5cblxuICB2YXIgbWF0Y2hpbmcgPSB7XG4gICAgbWF0Y2hlczogbWF0Y2hlcyxcbiAgICBmaWx0ZXI6IGZpbHRlclxuICB9O1xuXG4gIHZhciBTZWxlY3RvciA9IGZ1bmN0aW9uIFNlbGVjdG9yKHNlbGVjdG9yKSB7XG4gICAgdGhpcy5pbnB1dFRleHQgPSBzZWxlY3RvcjtcbiAgICB0aGlzLmN1cnJlbnRTdWJqZWN0ID0gbnVsbDtcbiAgICB0aGlzLmNvbXBvdW5kQ291bnQgPSAwO1xuICAgIHRoaXMuZWRnZUNvdW50ID0gMDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgICBpZiAoc2VsZWN0b3IgPT0gbnVsbCB8fCBzdHJpbmcoc2VsZWN0b3IpICYmIHNlbGVjdG9yLm1hdGNoKC9eXFxzKiQvKSkgOyBlbHNlIGlmIChlbGVtZW50T3JDb2xsZWN0aW9uKHNlbGVjdG9yKSkge1xuICAgICAgdGhpcy5hZGRRdWVyeSh7XG4gICAgICAgIGNoZWNrczogW3tcbiAgICAgICAgICB0eXBlOiBUeXBlLkNPTExFQ1RJT04sXG4gICAgICAgICAgdmFsdWU6IHNlbGVjdG9yLmNvbGxlY3Rpb24oKVxuICAgICAgICB9XVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChmbiQ2KHNlbGVjdG9yKSkge1xuICAgICAgdGhpcy5hZGRRdWVyeSh7XG4gICAgICAgIGNoZWNrczogW3tcbiAgICAgICAgICB0eXBlOiBUeXBlLkZJTFRFUixcbiAgICAgICAgICB2YWx1ZTogc2VsZWN0b3JcbiAgICAgICAgfV1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoc3RyaW5nKHNlbGVjdG9yKSkge1xuICAgICAgaWYgKCF0aGlzLnBhcnNlKHNlbGVjdG9yKSkge1xuICAgICAgICB0aGlzLmludmFsaWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlcnJvcignQSBzZWxlY3RvciBtdXN0IGJlIGNyZWF0ZWQgZnJvbSBhIHN0cmluZzsgZm91bmQgJyk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBzZWxmbiA9IFNlbGVjdG9yLnByb3RvdHlwZTtcbiAgW3BhcnNlJDEsIG1hdGNoaW5nXS5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIGV4dGVuZChzZWxmbiwgcCk7XG4gIH0pO1xuXG4gIHNlbGZuLnRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5wdXRUZXh0O1xuICB9O1xuXG4gIHNlbGZuLnNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubGVuZ3RoO1xuICB9O1xuXG4gIHNlbGZuLmVxID0gZnVuY3Rpb24gKGkpIHtcbiAgICByZXR1cm4gdGhpc1tpXTtcbiAgfTtcblxuICBzZWxmbi5zYW1lVGV4dCA9IGZ1bmN0aW9uIChvdGhlclNlbCkge1xuICAgIHJldHVybiAhdGhpcy5pbnZhbGlkICYmICFvdGhlclNlbC5pbnZhbGlkICYmIHRoaXMudGV4dCgpID09PSBvdGhlclNlbC50ZXh0KCk7XG4gIH07XG5cbiAgc2VsZm4uYWRkUXVlcnkgPSBmdW5jdGlvbiAocSkge1xuICAgIHRoaXNbdGhpcy5sZW5ndGgrK10gPSBxO1xuICB9O1xuXG4gIHNlbGZuLnNlbGVjdG9yID0gc2VsZm4udG9TdHJpbmc7XG5cbiAgdmFyIGVsZXNmbiRnID0ge1xuICAgIGFsbEFyZTogZnVuY3Rpb24gYWxsQXJlKHNlbGVjdG9yKSB7XG4gICAgICB2YXIgc2VsT2JqID0gbmV3IFNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAgIHJldHVybiB0aGlzLmV2ZXJ5KGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgcmV0dXJuIHNlbE9iai5tYXRjaGVzKGVsZSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGlzOiBmdW5jdGlvbiBpcyhzZWxlY3Rvcikge1xuICAgICAgdmFyIHNlbE9iaiA9IG5ldyBTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgICByZXR1cm4gdGhpcy5zb21lKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgcmV0dXJuIHNlbE9iai5tYXRjaGVzKGVsZSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHNvbWU6IGZ1bmN0aW9uIHNvbWUoZm4sIHRoaXNBcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcmV0ID0gIXRoaXNBcmcgPyBmbih0aGlzW2ldLCBpLCB0aGlzKSA6IGZuLmFwcGx5KHRoaXNBcmcsIFt0aGlzW2ldLCBpLCB0aGlzXSk7XG5cbiAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGV2ZXJ5OiBmdW5jdGlvbiBldmVyeShmbiwgdGhpc0FyZykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciByZXQgPSAhdGhpc0FyZyA/IGZuKHRoaXNbaV0sIGksIHRoaXMpIDogZm4uYXBwbHkodGhpc0FyZywgW3RoaXNbaV0sIGksIHRoaXNdKTtcblxuICAgICAgICBpZiAoIXJldCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIHNhbWU6IGZ1bmN0aW9uIHNhbWUoY29sbGVjdGlvbikge1xuICAgICAgLy8gY2hlYXAgY29sbGVjdGlvbiByZWYgY2hlY2tcbiAgICAgIGlmICh0aGlzID09PSBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBjb2xsZWN0aW9uID0gdGhpcy5jeSgpLmNvbGxlY3Rpb24oY29sbGVjdGlvbik7XG4gICAgICB2YXIgdGhpc0xlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgICAgdmFyIGNvbGxlY3Rpb25MZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDsgLy8gY2hlYXAgbGVuZ3RoIGNoZWNrXG5cbiAgICAgIGlmICh0aGlzTGVuZ3RoICE9PSBjb2xsZWN0aW9uTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gLy8gY2hlYXAgZWxlbWVudCByZWYgY2hlY2tcblxuXG4gICAgICBpZiAodGhpc0xlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gdGhpc1swXSA9PT0gY29sbGVjdGlvblswXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuZXZlcnkoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICByZXR1cm4gY29sbGVjdGlvbi5oYXNFbGVtZW50V2l0aElkKGVsZS5pZCgpKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgYW55U2FtZTogZnVuY3Rpb24gYW55U2FtZShjb2xsZWN0aW9uKSB7XG4gICAgICBjb2xsZWN0aW9uID0gdGhpcy5jeSgpLmNvbGxlY3Rpb24oY29sbGVjdGlvbik7XG4gICAgICByZXR1cm4gdGhpcy5zb21lKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uaGFzRWxlbWVudFdpdGhJZChlbGUuaWQoKSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGFsbEFyZU5laWdoYm9yczogZnVuY3Rpb24gYWxsQXJlTmVpZ2hib3JzKGNvbGxlY3Rpb24pIHtcbiAgICAgIGNvbGxlY3Rpb24gPSB0aGlzLmN5KCkuY29sbGVjdGlvbihjb2xsZWN0aW9uKTtcbiAgICAgIHZhciBuaG9vZCA9IHRoaXMubmVpZ2hib3Job29kKCk7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbi5ldmVyeShmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgIHJldHVybiBuaG9vZC5oYXNFbGVtZW50V2l0aElkKGVsZS5pZCgpKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgY29udGFpbnM6IGZ1bmN0aW9uIGNvbnRhaW5zKGNvbGxlY3Rpb24pIHtcbiAgICAgIGNvbGxlY3Rpb24gPSB0aGlzLmN5KCkuY29sbGVjdGlvbihjb2xsZWN0aW9uKTtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uLmV2ZXJ5KGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuaGFzRWxlbWVudFdpdGhJZChlbGUuaWQoKSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIGVsZXNmbiRnLmFsbEFyZU5laWdoYm91cnMgPSBlbGVzZm4kZy5hbGxBcmVOZWlnaGJvcnM7XG4gIGVsZXNmbiRnLmhhcyA9IGVsZXNmbiRnLmNvbnRhaW5zO1xuICBlbGVzZm4kZy5lcXVhbCA9IGVsZXNmbiRnLmVxdWFscyA9IGVsZXNmbiRnLnNhbWU7XG5cbiAgdmFyIGNhY2hlID0gZnVuY3Rpb24gY2FjaGUoZm4sIG5hbWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gdHJhdmVyc2FsQ2FjaGUoYXJnMSwgYXJnMiwgYXJnMywgYXJnNCkge1xuICAgICAgdmFyIHNlbGVjdG9yT3JFbGVzID0gYXJnMTtcbiAgICAgIHZhciBlbGVzID0gdGhpcztcbiAgICAgIHZhciBrZXk7XG5cbiAgICAgIGlmIChzZWxlY3Rvck9yRWxlcyA9PSBudWxsKSB7XG4gICAgICAgIGtleSA9ICcnO1xuICAgICAgfSBlbHNlIGlmIChlbGVtZW50T3JDb2xsZWN0aW9uKHNlbGVjdG9yT3JFbGVzKSAmJiBzZWxlY3Rvck9yRWxlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAga2V5ID0gc2VsZWN0b3JPckVsZXMuaWQoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVsZXMubGVuZ3RoID09PSAxICYmIGtleSkge1xuICAgICAgICB2YXIgX3AgPSBlbGVzWzBdLl9wcml2YXRlO1xuICAgICAgICB2YXIgdGNoID0gX3AudHJhdmVyc2FsQ2FjaGUgPSBfcC50cmF2ZXJzYWxDYWNoZSB8fCB7fTtcbiAgICAgICAgdmFyIGNoID0gdGNoW25hbWVdID0gdGNoW25hbWVdIHx8IFtdO1xuICAgICAgICB2YXIgaGFzaCA9IGhhc2hTdHJpbmcoa2V5KTtcbiAgICAgICAgdmFyIGNhY2hlSGl0ID0gY2hbaGFzaF07XG5cbiAgICAgICAgaWYgKGNhY2hlSGl0KSB7XG4gICAgICAgICAgcmV0dXJuIGNhY2hlSGl0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBjaFtoYXNoXSA9IGZuLmNhbGwoZWxlcywgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmbi5jYWxsKGVsZXMsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgdmFyIGVsZXNmbiRmID0ge1xuICAgIHBhcmVudDogZnVuY3Rpb24gcGFyZW50KHNlbGVjdG9yKSB7XG4gICAgICB2YXIgcGFyZW50cyA9IFtdOyAvLyBvcHRpbWlzYXRpb24gZm9yIHNpbmdsZSBlbGUgY2FsbFxuXG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXNbMF0uX3ByaXZhdGUucGFyZW50O1xuXG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICByZXR1cm4gcGFyZW50O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgICAgdmFyIF9wYXJlbnQgPSBlbGUuX3ByaXZhdGUucGFyZW50O1xuXG4gICAgICAgIGlmIChfcGFyZW50KSB7XG4gICAgICAgICAgcGFyZW50cy5wdXNoKF9wYXJlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnNwYXduKHBhcmVudHMsIHRydWUpLmZpbHRlcihzZWxlY3Rvcik7XG4gICAgfSxcbiAgICBwYXJlbnRzOiBmdW5jdGlvbiBwYXJlbnRzKHNlbGVjdG9yKSB7XG4gICAgICB2YXIgcGFyZW50cyA9IFtdO1xuICAgICAgdmFyIGVsZXMgPSB0aGlzLnBhcmVudCgpO1xuXG4gICAgICB3aGlsZSAoZWxlcy5ub25lbXB0eSgpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgICAgIHBhcmVudHMucHVzaChlbGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlcyA9IGVsZXMucGFyZW50KCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnNwYXduKHBhcmVudHMsIHRydWUpLmZpbHRlcihzZWxlY3Rvcik7XG4gICAgfSxcbiAgICBjb21tb25BbmNlc3RvcnM6IGZ1bmN0aW9uIGNvbW1vbkFuY2VzdG9ycyhzZWxlY3Rvcikge1xuICAgICAgdmFyIGFuY2VzdG9ycztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgICB2YXIgcGFyZW50cyA9IGVsZS5wYXJlbnRzKCk7XG4gICAgICAgIGFuY2VzdG9ycyA9IGFuY2VzdG9ycyB8fCBwYXJlbnRzO1xuICAgICAgICBhbmNlc3RvcnMgPSBhbmNlc3RvcnMuaW50ZXJzZWN0KHBhcmVudHMpOyAvLyBjdXJyZW50IGxpc3QgbXVzdCBiZSBjb21tb24gd2l0aCBjdXJyZW50IGVsZSBwYXJlbnRzIHNldFxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYW5jZXN0b3JzLmZpbHRlcihzZWxlY3Rvcik7XG4gICAgfSxcbiAgICBvcnBoYW5zOiBmdW5jdGlvbiBvcnBoYW5zKHNlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdGRGaWx0ZXIoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICByZXR1cm4gZWxlLmlzT3JwaGFuKCk7XG4gICAgICB9KS5maWx0ZXIoc2VsZWN0b3IpO1xuICAgIH0sXG4gICAgbm9ub3JwaGFuczogZnVuY3Rpb24gbm9ub3JwaGFucyhzZWxlY3Rvcikge1xuICAgICAgcmV0dXJuIHRoaXMuc3RkRmlsdGVyKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgcmV0dXJuIGVsZS5pc0NoaWxkKCk7XG4gICAgICB9KS5maWx0ZXIoc2VsZWN0b3IpO1xuICAgIH0sXG4gICAgY2hpbGRyZW46IGNhY2hlKGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgdmFyIGNoaWxkcmVuID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgICAgdmFyIGVsZUNoaWxkcmVuID0gZWxlLl9wcml2YXRlLmNoaWxkcmVuO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZWxlQ2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKGVsZUNoaWxkcmVuW2pdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5zcGF3bihjaGlsZHJlbiwgdHJ1ZSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgICB9LCAnY2hpbGRyZW4nKSxcbiAgICBzaWJsaW5nczogZnVuY3Rpb24gc2libGluZ3Moc2VsZWN0b3IpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudCgpLmNoaWxkcmVuKCkubm90KHRoaXMpLmZpbHRlcihzZWxlY3Rvcik7XG4gICAgfSxcbiAgICBpc1BhcmVudDogZnVuY3Rpb24gaXNQYXJlbnQoKSB7XG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgICAgaWYgKGVsZSkge1xuICAgICAgICByZXR1cm4gZWxlLmlzTm9kZSgpICYmIGVsZS5fcHJpdmF0ZS5jaGlsZHJlbi5sZW5ndGggIT09IDA7XG4gICAgICB9XG4gICAgfSxcbiAgICBpc0NoaWxkbGVzczogZnVuY3Rpb24gaXNDaGlsZGxlc3MoKSB7XG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgICAgaWYgKGVsZSkge1xuICAgICAgICByZXR1cm4gZWxlLmlzTm9kZSgpICYmIGVsZS5fcHJpdmF0ZS5jaGlsZHJlbi5sZW5ndGggPT09IDA7XG4gICAgICB9XG4gICAgfSxcbiAgICBpc0NoaWxkOiBmdW5jdGlvbiBpc0NoaWxkKCkge1xuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICAgIGlmIChlbGUpIHtcbiAgICAgICAgcmV0dXJuIGVsZS5pc05vZGUoKSAmJiBlbGUuX3ByaXZhdGUucGFyZW50ICE9IG51bGw7XG4gICAgICB9XG4gICAgfSxcbiAgICBpc09ycGhhbjogZnVuY3Rpb24gaXNPcnBoYW4oKSB7XG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgICAgaWYgKGVsZSkge1xuICAgICAgICByZXR1cm4gZWxlLmlzTm9kZSgpICYmIGVsZS5fcHJpdmF0ZS5wYXJlbnQgPT0gbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRlc2NlbmRhbnRzOiBmdW5jdGlvbiBkZXNjZW5kYW50cyhzZWxlY3Rvcikge1xuICAgICAgdmFyIGVsZW1lbnRzID0gW107XG5cbiAgICAgIGZ1bmN0aW9uIGFkZChlbGVzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgICAgIGVsZW1lbnRzLnB1c2goZWxlKTtcblxuICAgICAgICAgIGlmIChlbGUuY2hpbGRyZW4oKS5ub25lbXB0eSgpKSB7XG4gICAgICAgICAgICBhZGQoZWxlLmNoaWxkcmVuKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBhZGQodGhpcy5jaGlsZHJlbigpKTtcbiAgICAgIHJldHVybiB0aGlzLnNwYXduKGVsZW1lbnRzLCB0cnVlKS5maWx0ZXIoc2VsZWN0b3IpO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBmb3JFYWNoQ29tcG91bmQoZWxlcywgZm4sIGluY2x1ZGVTZWxmLCByZWN1cnNpdmVTdGVwKSB7XG4gICAgdmFyIHEgPSBbXTtcbiAgICB2YXIgZGlkID0gbmV3IFNldCQxKCk7XG4gICAgdmFyIGN5ID0gZWxlcy5jeSgpO1xuICAgIHZhciBoYXNDb21wb3VuZHMgPSBjeS5oYXNDb21wb3VuZE5vZGVzKCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuXG4gICAgICBpZiAoaW5jbHVkZVNlbGYpIHtcbiAgICAgICAgcS5wdXNoKGVsZSk7XG4gICAgICB9IGVsc2UgaWYgKGhhc0NvbXBvdW5kcykge1xuICAgICAgICByZWN1cnNpdmVTdGVwKHEsIGRpZCwgZWxlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB3aGlsZSAocS5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgX2VsZSA9IHEuc2hpZnQoKTtcblxuICAgICAgZm4oX2VsZSk7XG4gICAgICBkaWQuYWRkKF9lbGUuaWQoKSk7XG5cbiAgICAgIGlmIChoYXNDb21wb3VuZHMpIHtcbiAgICAgICAgcmVjdXJzaXZlU3RlcChxLCBkaWQsIF9lbGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBlbGVzO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkQ2hpbGRyZW4ocSwgZGlkLCBlbGUpIHtcbiAgICBpZiAoZWxlLmlzUGFyZW50KCkpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IGVsZS5fcHJpdmF0ZS5jaGlsZHJlbjtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcblxuICAgICAgICBpZiAoIWRpZC5oYXMoY2hpbGQuaWQoKSkpIHtcbiAgICAgICAgICBxLnB1c2goY2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IC8vIHZlcnkgZWZmaWNpZW50IHZlcnNpb24gb2YgZWxlcy5hZGQoIGVsZXMuZGVzY2VuZGFudHMoKSApLmZvckVhY2goKVxuICAvLyBmb3IgaW50ZXJuYWwgdXNlXG5cblxuICBlbGVzZm4kZi5mb3JFYWNoRG93biA9IGZ1bmN0aW9uIChmbikge1xuICAgIHZhciBpbmNsdWRlU2VsZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICByZXR1cm4gZm9yRWFjaENvbXBvdW5kKHRoaXMsIGZuLCBpbmNsdWRlU2VsZiwgYWRkQ2hpbGRyZW4pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGFkZFBhcmVudChxLCBkaWQsIGVsZSkge1xuICAgIGlmIChlbGUuaXNDaGlsZCgpKSB7XG4gICAgICB2YXIgcGFyZW50ID0gZWxlLl9wcml2YXRlLnBhcmVudDtcblxuICAgICAgaWYgKCFkaWQuaGFzKHBhcmVudC5pZCgpKSkge1xuICAgICAgICBxLnB1c2gocGFyZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBlbGVzZm4kZi5mb3JFYWNoVXAgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICB2YXIgaW5jbHVkZVNlbGYgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgcmV0dXJuIGZvckVhY2hDb21wb3VuZCh0aGlzLCBmbiwgaW5jbHVkZVNlbGYsIGFkZFBhcmVudCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gYWRkUGFyZW50QW5kQ2hpbGRyZW4ocSwgZGlkLCBlbGUpIHtcbiAgICBhZGRQYXJlbnQocSwgZGlkLCBlbGUpO1xuICAgIGFkZENoaWxkcmVuKHEsIGRpZCwgZWxlKTtcbiAgfVxuXG4gIGVsZXNmbiRmLmZvckVhY2hVcEFuZERvd24gPSBmdW5jdGlvbiAoZm4pIHtcbiAgICB2YXIgaW5jbHVkZVNlbGYgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgcmV0dXJuIGZvckVhY2hDb21wb3VuZCh0aGlzLCBmbiwgaW5jbHVkZVNlbGYsIGFkZFBhcmVudEFuZENoaWxkcmVuKTtcbiAgfTsgLy8gYWxpYXNlc1xuXG5cbiAgZWxlc2ZuJGYuYW5jZXN0b3JzID0gZWxlc2ZuJGYucGFyZW50cztcblxuICB2YXIgZm4kNSwgZWxlc2ZuJGU7XG4gIGZuJDUgPSBlbGVzZm4kZSA9IHtcbiAgICBkYXRhOiBkZWZpbmUuZGF0YSh7XG4gICAgICBmaWVsZDogJ2RhdGEnLFxuICAgICAgYmluZGluZ0V2ZW50OiAnZGF0YScsXG4gICAgICBhbGxvd0JpbmRpbmc6IHRydWUsXG4gICAgICBhbGxvd1NldHRpbmc6IHRydWUsXG4gICAgICBzZXR0aW5nRXZlbnQ6ICdkYXRhJyxcbiAgICAgIHNldHRpbmdUcmlnZ2Vyc0V2ZW50OiB0cnVlLFxuICAgICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgICAgYWxsb3dHZXR0aW5nOiB0cnVlLFxuICAgICAgaW1tdXRhYmxlS2V5czoge1xuICAgICAgICAnaWQnOiB0cnVlLFxuICAgICAgICAnc291cmNlJzogdHJ1ZSxcbiAgICAgICAgJ3RhcmdldCc6IHRydWUsXG4gICAgICAgICdwYXJlbnQnOiB0cnVlXG4gICAgICB9LFxuICAgICAgdXBkYXRlU3R5bGU6IHRydWVcbiAgICB9KSxcbiAgICByZW1vdmVEYXRhOiBkZWZpbmUucmVtb3ZlRGF0YSh7XG4gICAgICBmaWVsZDogJ2RhdGEnLFxuICAgICAgZXZlbnQ6ICdkYXRhJyxcbiAgICAgIHRyaWdnZXJGbk5hbWU6ICd0cmlnZ2VyJyxcbiAgICAgIHRyaWdnZXJFdmVudDogdHJ1ZSxcbiAgICAgIGltbXV0YWJsZUtleXM6IHtcbiAgICAgICAgJ2lkJzogdHJ1ZSxcbiAgICAgICAgJ3NvdXJjZSc6IHRydWUsXG4gICAgICAgICd0YXJnZXQnOiB0cnVlLFxuICAgICAgICAncGFyZW50JzogdHJ1ZVxuICAgICAgfSxcbiAgICAgIHVwZGF0ZVN0eWxlOiB0cnVlXG4gICAgfSksXG4gICAgc2NyYXRjaDogZGVmaW5lLmRhdGEoe1xuICAgICAgZmllbGQ6ICdzY3JhdGNoJyxcbiAgICAgIGJpbmRpbmdFdmVudDogJ3NjcmF0Y2gnLFxuICAgICAgYWxsb3dCaW5kaW5nOiB0cnVlLFxuICAgICAgYWxsb3dTZXR0aW5nOiB0cnVlLFxuICAgICAgc2V0dGluZ0V2ZW50OiAnc2NyYXRjaCcsXG4gICAgICBzZXR0aW5nVHJpZ2dlcnNFdmVudDogdHJ1ZSxcbiAgICAgIHRyaWdnZXJGbk5hbWU6ICd0cmlnZ2VyJyxcbiAgICAgIGFsbG93R2V0dGluZzogdHJ1ZSxcbiAgICAgIHVwZGF0ZVN0eWxlOiB0cnVlXG4gICAgfSksXG4gICAgcmVtb3ZlU2NyYXRjaDogZGVmaW5lLnJlbW92ZURhdGEoe1xuICAgICAgZmllbGQ6ICdzY3JhdGNoJyxcbiAgICAgIGV2ZW50OiAnc2NyYXRjaCcsXG4gICAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgICB0cmlnZ2VyRXZlbnQ6IHRydWUsXG4gICAgICB1cGRhdGVTdHlsZTogdHJ1ZVxuICAgIH0pLFxuICAgIHJzY3JhdGNoOiBkZWZpbmUuZGF0YSh7XG4gICAgICBmaWVsZDogJ3JzY3JhdGNoJyxcbiAgICAgIGFsbG93QmluZGluZzogZmFsc2UsXG4gICAgICBhbGxvd1NldHRpbmc6IHRydWUsXG4gICAgICBzZXR0aW5nVHJpZ2dlcnNFdmVudDogZmFsc2UsXG4gICAgICBhbGxvd0dldHRpbmc6IHRydWVcbiAgICB9KSxcbiAgICByZW1vdmVSc2NyYXRjaDogZGVmaW5lLnJlbW92ZURhdGEoe1xuICAgICAgZmllbGQ6ICdyc2NyYXRjaCcsXG4gICAgICB0cmlnZ2VyRXZlbnQ6IGZhbHNlXG4gICAgfSksXG4gICAgaWQ6IGZ1bmN0aW9uIGlkKCkge1xuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICAgIGlmIChlbGUpIHtcbiAgICAgICAgcmV0dXJuIGVsZS5fcHJpdmF0ZS5kYXRhLmlkO1xuICAgICAgfVxuICAgIH1cbiAgfTsgLy8gYWxpYXNlc1xuXG4gIGZuJDUuYXR0ciA9IGZuJDUuZGF0YTtcbiAgZm4kNS5yZW1vdmVBdHRyID0gZm4kNS5yZW1vdmVEYXRhO1xuICB2YXIgZGF0YSA9IGVsZXNmbiRlO1xuXG4gIHZhciBlbGVzZm4kZCA9IHt9O1xuXG4gIGZ1bmN0aW9uIGRlZmluZURlZ3JlZUZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpbmNsdWRlTG9vcHMpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgaWYgKGluY2x1ZGVMb29wcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGluY2x1ZGVMb29wcyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmLmlzTm9kZSgpICYmICFzZWxmLnJlbW92ZWQoKSkge1xuICAgICAgICB2YXIgZGVncmVlID0gMDtcbiAgICAgICAgdmFyIG5vZGUgPSBzZWxmWzBdO1xuICAgICAgICB2YXIgY29ubmVjdGVkRWRnZXMgPSBub2RlLl9wcml2YXRlLmVkZ2VzO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29ubmVjdGVkRWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZWRnZSA9IGNvbm5lY3RlZEVkZ2VzW2ldO1xuXG4gICAgICAgICAgaWYgKCFpbmNsdWRlTG9vcHMgJiYgZWRnZS5pc0xvb3AoKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGVncmVlICs9IGNhbGxiYWNrKG5vZGUsIGVkZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlZ3JlZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgZXh0ZW5kKGVsZXNmbiRkLCB7XG4gICAgZGVncmVlOiBkZWZpbmVEZWdyZWVGdW5jdGlvbihmdW5jdGlvbiAobm9kZSwgZWRnZSkge1xuICAgICAgaWYgKGVkZ2Uuc291cmNlKCkuc2FtZShlZGdlLnRhcmdldCgpKSkge1xuICAgICAgICByZXR1cm4gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgIH0pLFxuICAgIGluZGVncmVlOiBkZWZpbmVEZWdyZWVGdW5jdGlvbihmdW5jdGlvbiAobm9kZSwgZWRnZSkge1xuICAgICAgaWYgKGVkZ2UudGFyZ2V0KCkuc2FtZShub2RlKSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgIH0pLFxuICAgIG91dGRlZ3JlZTogZGVmaW5lRGVncmVlRnVuY3Rpb24oZnVuY3Rpb24gKG5vZGUsIGVkZ2UpIHtcbiAgICAgIGlmIChlZGdlLnNvdXJjZSgpLnNhbWUobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICB9KVxuICB9KTtcblxuICBmdW5jdGlvbiBkZWZpbmVEZWdyZWVCb3VuZHNGdW5jdGlvbihkZWdyZWVGbiwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGluY2x1ZGVMb29wcykge1xuICAgICAgdmFyIHJldDtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gbm9kZXNbaV07XG4gICAgICAgIHZhciBkZWdyZWUgPSBlbGVbZGVncmVlRm5dKGluY2x1ZGVMb29wcyk7XG5cbiAgICAgICAgaWYgKGRlZ3JlZSAhPT0gdW5kZWZpbmVkICYmIChyZXQgPT09IHVuZGVmaW5lZCB8fCBjYWxsYmFjayhkZWdyZWUsIHJldCkpKSB7XG4gICAgICAgICAgcmV0ID0gZGVncmVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgfVxuXG4gIGV4dGVuZChlbGVzZm4kZCwge1xuICAgIG1pbkRlZ3JlZTogZGVmaW5lRGVncmVlQm91bmRzRnVuY3Rpb24oJ2RlZ3JlZScsIGZ1bmN0aW9uIChkZWdyZWUsIG1pbikge1xuICAgICAgcmV0dXJuIGRlZ3JlZSA8IG1pbjtcbiAgICB9KSxcbiAgICBtYXhEZWdyZWU6IGRlZmluZURlZ3JlZUJvdW5kc0Z1bmN0aW9uKCdkZWdyZWUnLCBmdW5jdGlvbiAoZGVncmVlLCBtYXgpIHtcbiAgICAgIHJldHVybiBkZWdyZWUgPiBtYXg7XG4gICAgfSksXG4gICAgbWluSW5kZWdyZWU6IGRlZmluZURlZ3JlZUJvdW5kc0Z1bmN0aW9uKCdpbmRlZ3JlZScsIGZ1bmN0aW9uIChkZWdyZWUsIG1pbikge1xuICAgICAgcmV0dXJuIGRlZ3JlZSA8IG1pbjtcbiAgICB9KSxcbiAgICBtYXhJbmRlZ3JlZTogZGVmaW5lRGVncmVlQm91bmRzRnVuY3Rpb24oJ2luZGVncmVlJywgZnVuY3Rpb24gKGRlZ3JlZSwgbWF4KSB7XG4gICAgICByZXR1cm4gZGVncmVlID4gbWF4O1xuICAgIH0pLFxuICAgIG1pbk91dGRlZ3JlZTogZGVmaW5lRGVncmVlQm91bmRzRnVuY3Rpb24oJ291dGRlZ3JlZScsIGZ1bmN0aW9uIChkZWdyZWUsIG1pbikge1xuICAgICAgcmV0dXJuIGRlZ3JlZSA8IG1pbjtcbiAgICB9KSxcbiAgICBtYXhPdXRkZWdyZWU6IGRlZmluZURlZ3JlZUJvdW5kc0Z1bmN0aW9uKCdvdXRkZWdyZWUnLCBmdW5jdGlvbiAoZGVncmVlLCBtYXgpIHtcbiAgICAgIHJldHVybiBkZWdyZWUgPiBtYXg7XG4gICAgfSlcbiAgfSk7XG4gIGV4dGVuZChlbGVzZm4kZCwge1xuICAgIHRvdGFsRGVncmVlOiBmdW5jdGlvbiB0b3RhbERlZ3JlZShpbmNsdWRlTG9vcHMpIHtcbiAgICAgIHZhciB0b3RhbCA9IDA7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdG90YWwgKz0gbm9kZXNbaV0uZGVncmVlKGluY2x1ZGVMb29wcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0b3RhbDtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBmbiQ0LCBlbGVzZm4kYztcblxuICB2YXIgYmVmb3JlUG9zaXRpb25TZXQgPSBmdW5jdGlvbiBiZWZvcmVQb3NpdGlvblNldChlbGVzLCBuZXdQb3MsIHNpbGVudCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG5cbiAgICAgIGlmICghZWxlLmxvY2tlZCgpKSB7XG4gICAgICAgIHZhciBvbGRQb3MgPSBlbGUuX3ByaXZhdGUucG9zaXRpb247XG4gICAgICAgIHZhciBkZWx0YSA9IHtcbiAgICAgICAgICB4OiBuZXdQb3MueCAhPSBudWxsID8gbmV3UG9zLnggLSBvbGRQb3MueCA6IDAsXG4gICAgICAgICAgeTogbmV3UG9zLnkgIT0gbnVsbCA/IG5ld1Bvcy55IC0gb2xkUG9zLnkgOiAwXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGVsZS5pc1BhcmVudCgpICYmICEoZGVsdGEueCA9PT0gMCAmJiBkZWx0YS55ID09PSAwKSkge1xuICAgICAgICAgIGVsZS5jaGlsZHJlbigpLnNoaWZ0KGRlbHRhLCBzaWxlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlLmRpcnR5Qm91bmRpbmdCb3hDYWNoZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgcG9zaXRpb25EZWYgPSB7XG4gICAgZmllbGQ6ICdwb3NpdGlvbicsXG4gICAgYmluZGluZ0V2ZW50OiAncG9zaXRpb24nLFxuICAgIGFsbG93QmluZGluZzogdHJ1ZSxcbiAgICBhbGxvd1NldHRpbmc6IHRydWUsXG4gICAgc2V0dGluZ0V2ZW50OiAncG9zaXRpb24nLFxuICAgIHNldHRpbmdUcmlnZ2Vyc0V2ZW50OiB0cnVlLFxuICAgIHRyaWdnZXJGbk5hbWU6ICdlbWl0QW5kTm90aWZ5JyxcbiAgICBhbGxvd0dldHRpbmc6IHRydWUsXG4gICAgdmFsaWRLZXlzOiBbJ3gnLCAneSddLFxuICAgIGJlZm9yZUdldDogZnVuY3Rpb24gYmVmb3JlR2V0KGVsZSkge1xuICAgICAgZWxlLnVwZGF0ZUNvbXBvdW5kQm91bmRzKCk7XG4gICAgfSxcbiAgICBiZWZvcmVTZXQ6IGZ1bmN0aW9uIGJlZm9yZVNldChlbGVzLCBuZXdQb3MpIHtcbiAgICAgIGJlZm9yZVBvc2l0aW9uU2V0KGVsZXMsIG5ld1BvcywgZmFsc2UpO1xuICAgIH0sXG4gICAgb25TZXQ6IGZ1bmN0aW9uIG9uU2V0KGVsZXMpIHtcbiAgICAgIGVsZXMuZGlydHlDb21wb3VuZEJvdW5kc0NhY2hlKCk7XG4gICAgfSxcbiAgICBjYW5TZXQ6IGZ1bmN0aW9uIGNhblNldChlbGUpIHtcbiAgICAgIHJldHVybiAhZWxlLmxvY2tlZCgpO1xuICAgIH1cbiAgfTtcbiAgZm4kNCA9IGVsZXNmbiRjID0ge1xuICAgIHBvc2l0aW9uOiBkZWZpbmUuZGF0YShwb3NpdGlvbkRlZiksXG4gICAgLy8gcG9zaXRpb24gYnV0IG5vIG5vdGlmaWNhdGlvbiB0byByZW5kZXJlclxuICAgIHNpbGVudFBvc2l0aW9uOiBkZWZpbmUuZGF0YShleHRlbmQoe30sIHBvc2l0aW9uRGVmLCB7XG4gICAgICBhbGxvd0JpbmRpbmc6IGZhbHNlLFxuICAgICAgYWxsb3dTZXR0aW5nOiB0cnVlLFxuICAgICAgc2V0dGluZ1RyaWdnZXJzRXZlbnQ6IGZhbHNlLFxuICAgICAgYWxsb3dHZXR0aW5nOiBmYWxzZSxcbiAgICAgIGJlZm9yZVNldDogZnVuY3Rpb24gYmVmb3JlU2V0KGVsZXMsIG5ld1Bvcykge1xuICAgICAgICBiZWZvcmVQb3NpdGlvblNldChlbGVzLCBuZXdQb3MsIHRydWUpO1xuICAgICAgfSxcbiAgICAgIG9uU2V0OiBmdW5jdGlvbiBvblNldChlbGVzKSB7XG4gICAgICAgIGVsZXMuZGlydHlDb21wb3VuZEJvdW5kc0NhY2hlKCk7XG4gICAgICB9XG4gICAgfSkpLFxuICAgIHBvc2l0aW9uczogZnVuY3Rpb24gcG9zaXRpb25zKHBvcywgc2lsZW50KSB7XG4gICAgICBpZiAocGxhaW5PYmplY3QocG9zKSkge1xuICAgICAgICBpZiAoc2lsZW50KSB7XG4gICAgICAgICAgdGhpcy5zaWxlbnRQb3NpdGlvbihwb3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucG9zaXRpb24ocG9zKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChmbiQ2KHBvcykpIHtcbiAgICAgICAgdmFyIF9mbiA9IHBvcztcbiAgICAgICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgICAgICBjeS5zdGFydEJhdGNoKCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG5cbiAgICAgICAgICB2YXIgX3BvcyA9IHZvaWQgMDtcblxuICAgICAgICAgIGlmIChfcG9zID0gX2ZuKGVsZSwgaSkpIHtcbiAgICAgICAgICAgIGlmIChzaWxlbnQpIHtcbiAgICAgICAgICAgICAgZWxlLnNpbGVudFBvc2l0aW9uKF9wb3MpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZWxlLnBvc2l0aW9uKF9wb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGN5LmVuZEJhdGNoKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG4gICAgc2lsZW50UG9zaXRpb25zOiBmdW5jdGlvbiBzaWxlbnRQb3NpdGlvbnMocG9zKSB7XG4gICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbnMocG9zLCB0cnVlKTtcbiAgICB9LFxuICAgIHNoaWZ0OiBmdW5jdGlvbiBzaGlmdChkaW0sIHZhbCwgc2lsZW50KSB7XG4gICAgICB2YXIgZGVsdGE7XG5cbiAgICAgIGlmIChwbGFpbk9iamVjdChkaW0pKSB7XG4gICAgICAgIGRlbHRhID0ge1xuICAgICAgICAgIHg6IG51bWJlciQxKGRpbS54KSA/IGRpbS54IDogMCxcbiAgICAgICAgICB5OiBudW1iZXIkMShkaW0ueSkgPyBkaW0ueSA6IDBcbiAgICAgICAgfTtcbiAgICAgICAgc2lsZW50ID0gdmFsO1xuICAgICAgfSBlbHNlIGlmIChzdHJpbmcoZGltKSAmJiBudW1iZXIkMSh2YWwpKSB7XG4gICAgICAgIGRlbHRhID0ge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMFxuICAgICAgICB9O1xuICAgICAgICBkZWx0YVtkaW1dID0gdmFsO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGVsdGEgIT0gbnVsbCkge1xuICAgICAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgICAgIGN5LnN0YXJ0QmF0Y2goKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZWxlID0gdGhpc1tpXTsgLy8gZXhjbHVkZSBhbnkgbm9kZSB0aGF0IGlzIGEgZGVzY2VuZGFudCBvZiB0aGUgY2FsbGluZyBjb2xsZWN0aW9uXG5cbiAgICAgICAgICBpZiAoY3kuaGFzQ29tcG91bmROb2RlcygpICYmIGVsZS5pc0NoaWxkKCkgJiYgZWxlLmFuY2VzdG9ycygpLmFueVNhbWUodGhpcykpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBwb3MgPSBlbGUucG9zaXRpb24oKTtcbiAgICAgICAgICB2YXIgbmV3UG9zID0ge1xuICAgICAgICAgICAgeDogcG9zLnggKyBkZWx0YS54LFxuICAgICAgICAgICAgeTogcG9zLnkgKyBkZWx0YS55XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmIChzaWxlbnQpIHtcbiAgICAgICAgICAgIGVsZS5zaWxlbnRQb3NpdGlvbihuZXdQb3MpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbGUucG9zaXRpb24obmV3UG9zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjeS5lbmRCYXRjaCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHNpbGVudFNoaWZ0OiBmdW5jdGlvbiBzaWxlbnRTaGlmdChkaW0sIHZhbCkge1xuICAgICAgaWYgKHBsYWluT2JqZWN0KGRpbSkpIHtcbiAgICAgICAgdGhpcy5zaGlmdChkaW0sIHRydWUpO1xuICAgICAgfSBlbHNlIGlmIChzdHJpbmcoZGltKSAmJiBudW1iZXIkMSh2YWwpKSB7XG4gICAgICAgIHRoaXMuc2hpZnQoZGltLCB2YWwsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8vIGdldC9zZXQgdGhlIHJlbmRlcmVkIChpLmUuIG9uIHNjcmVlbikgcG9zaXRvbiBvZiB0aGUgZWxlbWVudFxuICAgIHJlbmRlcmVkUG9zaXRpb246IGZ1bmN0aW9uIHJlbmRlcmVkUG9zaXRpb24oZGltLCB2YWwpIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgICB2YXIgcGFuID0gY3kucGFuKCk7XG4gICAgICB2YXIgcnBvcyA9IHBsYWluT2JqZWN0KGRpbSkgPyBkaW0gOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgc2V0dGluZyA9IHJwb3MgIT09IHVuZGVmaW5lZCB8fCB2YWwgIT09IHVuZGVmaW5lZCAmJiBzdHJpbmcoZGltKTtcblxuICAgICAgaWYgKGVsZSAmJiBlbGUuaXNOb2RlKCkpIHtcbiAgICAgICAgLy8gbXVzdCBoYXZlIGFuIGVsZW1lbnQgYW5kIG11c3QgYmUgYSBub2RlIHRvIHJldHVybiBwb3NpdGlvblxuICAgICAgICBpZiAoc2V0dGluZykge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIF9lbGUgPSB0aGlzW2ldO1xuXG4gICAgICAgICAgICBpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgLy8gc2V0IG9uZSBkaW1lbnNpb25cbiAgICAgICAgICAgICAgX2VsZS5wb3NpdGlvbihkaW0sICh2YWwgLSBwYW5bZGltXSkgLyB6b29tKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocnBvcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIC8vIHNldCB3aG9sZSBwb3NpdGlvblxuICAgICAgICAgICAgICBfZWxlLnBvc2l0aW9uKHJlbmRlcmVkVG9Nb2RlbFBvc2l0aW9uKHJwb3MsIHpvb20sIHBhbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBnZXR0aW5nXG4gICAgICAgICAgdmFyIHBvcyA9IGVsZS5wb3NpdGlvbigpO1xuICAgICAgICAgIHJwb3MgPSBtb2RlbFRvUmVuZGVyZWRQb3NpdGlvbihwb3MsIHpvb20sIHBhbik7XG5cbiAgICAgICAgICBpZiAoZGltID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIHRoZW4gcmV0dXJuIHRoZSB3aG9sZSByZW5kZXJlZCBwb3NpdGlvblxuICAgICAgICAgICAgcmV0dXJuIHJwb3M7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRoZW4gcmV0dXJuIHRoZSBzcGVjaWZpZWQgZGltZW5zaW9uXG4gICAgICAgICAgICByZXR1cm4gcnBvc1tkaW1dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghc2V0dGluZykge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkOyAvLyBmb3IgZW1wdHkgY29sbGVjdGlvbiBjYXNlXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG4gICAgLy8gZ2V0L3NldCB0aGUgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIHBhcmVudFxuICAgIHJlbGF0aXZlUG9zaXRpb246IGZ1bmN0aW9uIHJlbGF0aXZlUG9zaXRpb24oZGltLCB2YWwpIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgICAgdmFyIHBwb3MgPSBwbGFpbk9iamVjdChkaW0pID8gZGltIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIHNldHRpbmcgPSBwcG9zICE9PSB1bmRlZmluZWQgfHwgdmFsICE9PSB1bmRlZmluZWQgJiYgc3RyaW5nKGRpbSk7XG4gICAgICB2YXIgaGFzQ29tcG91bmROb2RlcyA9IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcblxuICAgICAgaWYgKGVsZSAmJiBlbGUuaXNOb2RlKCkpIHtcbiAgICAgICAgLy8gbXVzdCBoYXZlIGFuIGVsZW1lbnQgYW5kIG11c3QgYmUgYSBub2RlIHRvIHJldHVybiBwb3NpdGlvblxuICAgICAgICBpZiAoc2V0dGluZykge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIF9lbGUyID0gdGhpc1tpXTtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBoYXNDb21wb3VuZE5vZGVzID8gX2VsZTIucGFyZW50KCkgOiBudWxsO1xuICAgICAgICAgICAgdmFyIGhhc1BhcmVudCA9IHBhcmVudCAmJiBwYXJlbnQubGVuZ3RoID4gMDtcbiAgICAgICAgICAgIHZhciByZWxhdGl2ZVRvUGFyZW50ID0gaGFzUGFyZW50O1xuXG4gICAgICAgICAgICBpZiAoaGFzUGFyZW50KSB7XG4gICAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudFswXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG9yaWdpbiA9IHJlbGF0aXZlVG9QYXJlbnQgPyBwYXJlbnQucG9zaXRpb24oKSA6IHtcbiAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgeTogMFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIC8vIHNldCBvbmUgZGltZW5zaW9uXG4gICAgICAgICAgICAgIF9lbGUyLnBvc2l0aW9uKGRpbSwgdmFsICsgb3JpZ2luW2RpbV0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwcG9zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgLy8gc2V0IHdob2xlIHBvc2l0aW9uXG4gICAgICAgICAgICAgIF9lbGUyLnBvc2l0aW9uKHtcbiAgICAgICAgICAgICAgICB4OiBwcG9zLnggKyBvcmlnaW4ueCxcbiAgICAgICAgICAgICAgICB5OiBwcG9zLnkgKyBvcmlnaW4ueVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZ2V0dGluZ1xuICAgICAgICAgIHZhciBwb3MgPSBlbGUucG9zaXRpb24oKTtcblxuICAgICAgICAgIHZhciBfcGFyZW50ID0gaGFzQ29tcG91bmROb2RlcyA/IGVsZS5wYXJlbnQoKSA6IG51bGw7XG5cbiAgICAgICAgICB2YXIgX2hhc1BhcmVudCA9IF9wYXJlbnQgJiYgX3BhcmVudC5sZW5ndGggPiAwO1xuXG4gICAgICAgICAgdmFyIF9yZWxhdGl2ZVRvUGFyZW50ID0gX2hhc1BhcmVudDtcblxuICAgICAgICAgIGlmIChfaGFzUGFyZW50KSB7XG4gICAgICAgICAgICBfcGFyZW50ID0gX3BhcmVudFswXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX29yaWdpbiA9IF9yZWxhdGl2ZVRvUGFyZW50ID8gX3BhcmVudC5wb3NpdGlvbigpIDoge1xuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDBcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgcHBvcyA9IHtcbiAgICAgICAgICAgIHg6IHBvcy54IC0gX29yaWdpbi54LFxuICAgICAgICAgICAgeTogcG9zLnkgLSBfb3JpZ2luLnlcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKGRpbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyB0aGVuIHJldHVybiB0aGUgd2hvbGUgcmVuZGVyZWQgcG9zaXRpb25cbiAgICAgICAgICAgIHJldHVybiBwcG9zO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB0aGVuIHJldHVybiB0aGUgc3BlY2lmaWVkIGRpbWVuc2lvblxuICAgICAgICAgICAgcmV0dXJuIHBwb3NbZGltXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIXNldHRpbmcpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDsgLy8gZm9yIGVtcHR5IGNvbGxlY3Rpb24gY2FzZVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9XG4gIH07IC8vIGFsaWFzZXNcblxuICBmbiQ0Lm1vZGVsUG9zaXRpb24gPSBmbiQ0LnBvaW50ID0gZm4kNC5wb3NpdGlvbjtcbiAgZm4kNC5tb2RlbFBvc2l0aW9ucyA9IGZuJDQucG9pbnRzID0gZm4kNC5wb3NpdGlvbnM7XG4gIGZuJDQucmVuZGVyZWRQb2ludCA9IGZuJDQucmVuZGVyZWRQb3NpdGlvbjtcbiAgZm4kNC5yZWxhdGl2ZVBvaW50ID0gZm4kNC5yZWxhdGl2ZVBvc2l0aW9uO1xuICB2YXIgcG9zaXRpb24gPSBlbGVzZm4kYztcblxuICB2YXIgZm4kMywgZWxlc2ZuJGI7XG4gIGZuJDMgPSBlbGVzZm4kYiA9IHt9O1xuXG4gIGVsZXNmbiRiLnJlbmRlcmVkQm91bmRpbmdCb3ggPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciBiYiA9IHRoaXMuYm91bmRpbmdCb3gob3B0aW9ucyk7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuICAgIHZhciBwYW4gPSBjeS5wYW4oKTtcbiAgICB2YXIgeDEgPSBiYi54MSAqIHpvb20gKyBwYW4ueDtcbiAgICB2YXIgeDIgPSBiYi54MiAqIHpvb20gKyBwYW4ueDtcbiAgICB2YXIgeTEgPSBiYi55MSAqIHpvb20gKyBwYW4ueTtcbiAgICB2YXIgeTIgPSBiYi55MiAqIHpvb20gKyBwYW4ueTtcbiAgICByZXR1cm4ge1xuICAgICAgeDE6IHgxLFxuICAgICAgeDI6IHgyLFxuICAgICAgeTE6IHkxLFxuICAgICAgeTI6IHkyLFxuICAgICAgdzogeDIgLSB4MSxcbiAgICAgIGg6IHkyIC0geTFcbiAgICB9O1xuICB9O1xuXG4gIGVsZXNmbiRiLmRpcnR5Q29tcG91bmRCb3VuZHNDYWNoZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2lsZW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpIHx8ICFjeS5oYXNDb21wb3VuZE5vZGVzKCkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRoaXMuZm9yRWFjaFVwKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgIGlmIChlbGUuaXNQYXJlbnQoKSkge1xuICAgICAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgICAgIF9wLmNvbXBvdW5kQm91bmRzQ2xlYW4gPSBmYWxzZTtcbiAgICAgICAgX3AuYmJDYWNoZSA9IG51bGw7XG5cbiAgICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgICBlbGUuZW1pdEFuZE5vdGlmeSgnYm91bmRzJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBlbGVzZm4kYi51cGRhdGVDb21wb3VuZEJvdW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZm9yY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTsgLy8gbm90IHBvc3NpYmxlIHRvIGRvIG9uIG5vbi1jb21wb3VuZCBncmFwaHMgb3Igd2l0aCB0aGUgc3R5bGUgZGlzYWJsZWRcblxuICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkgfHwgIWN5Lmhhc0NvbXBvdW5kTm9kZXMoKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSAvLyBzYXZlIGN5Y2xlcyB3aGVuIGJhdGNoaW5nIC0tIGJ1dCBib3VuZHMgd2lsbCBiZSBzdGFsZSAob3Igbm90IGV4aXN0IHlldClcblxuXG4gICAgaWYgKCFmb3JjZSAmJiBjeS5iYXRjaGluZygpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGUocGFyZW50KSB7XG4gICAgICBpZiAoIXBhcmVudC5pc1BhcmVudCgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIF9wID0gcGFyZW50Ll9wcml2YXRlO1xuICAgICAgdmFyIGNoaWxkcmVuID0gcGFyZW50LmNoaWxkcmVuKCk7XG4gICAgICB2YXIgaW5jbHVkZUxhYmVscyA9IHBhcmVudC5wc3R5bGUoJ2NvbXBvdW5kLXNpemluZy13cnQtbGFiZWxzJykudmFsdWUgPT09ICdpbmNsdWRlJztcbiAgICAgIHZhciBtaW4gPSB7XG4gICAgICAgIHdpZHRoOiB7XG4gICAgICAgICAgdmFsOiBwYXJlbnQucHN0eWxlKCdtaW4td2lkdGgnKS5wZlZhbHVlLFxuICAgICAgICAgIGxlZnQ6IHBhcmVudC5wc3R5bGUoJ21pbi13aWR0aC1iaWFzLWxlZnQnKSxcbiAgICAgICAgICByaWdodDogcGFyZW50LnBzdHlsZSgnbWluLXdpZHRoLWJpYXMtcmlnaHQnKVxuICAgICAgICB9LFxuICAgICAgICBoZWlnaHQ6IHtcbiAgICAgICAgICB2YWw6IHBhcmVudC5wc3R5bGUoJ21pbi1oZWlnaHQnKS5wZlZhbHVlLFxuICAgICAgICAgIHRvcDogcGFyZW50LnBzdHlsZSgnbWluLWhlaWdodC1iaWFzLXRvcCcpLFxuICAgICAgICAgIGJvdHRvbTogcGFyZW50LnBzdHlsZSgnbWluLWhlaWdodC1iaWFzLWJvdHRvbScpXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB2YXIgYmIgPSBjaGlsZHJlbi5ib3VuZGluZ0JveCh7XG4gICAgICAgIGluY2x1ZGVMYWJlbHM6IGluY2x1ZGVMYWJlbHMsXG4gICAgICAgIGluY2x1ZGVPdmVybGF5czogZmFsc2UsXG4gICAgICAgIC8vIHVwZGF0aW5nIHRoZSBjb21wb3VuZCBib3VuZHMgaGFwcGVucyBvdXRzaWRlIG9mIHRoZSByZWd1bGFyXG4gICAgICAgIC8vIGNhY2hlIGN5Y2xlIChpLmUuIGJlZm9yZSBmaXJlZCBldmVudHMpXG4gICAgICAgIHVzZUNhY2hlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICB2YXIgcG9zID0gX3AucG9zaXRpb247IC8vIGlmIGNoaWxkcmVuIHRha2UgdXAgemVybyBhcmVhIHRoZW4ga2VlcCBwb3NpdGlvbiBhbmQgZmFsbCBiYWNrIG9uIHN0eWxlc2hlZXQgdy9oXG5cbiAgICAgIGlmIChiYi53ID09PSAwIHx8IGJiLmggPT09IDApIHtcbiAgICAgICAgYmIgPSB7XG4gICAgICAgICAgdzogcGFyZW50LnBzdHlsZSgnd2lkdGgnKS5wZlZhbHVlLFxuICAgICAgICAgIGg6IHBhcmVudC5wc3R5bGUoJ2hlaWdodCcpLnBmVmFsdWVcbiAgICAgICAgfTtcbiAgICAgICAgYmIueDEgPSBwb3MueCAtIGJiLncgLyAyO1xuICAgICAgICBiYi54MiA9IHBvcy54ICsgYmIudyAvIDI7XG4gICAgICAgIGJiLnkxID0gcG9zLnkgLSBiYi5oIC8gMjtcbiAgICAgICAgYmIueTIgPSBwb3MueSArIGJiLmggLyAyO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjb21wdXRlQmlhc1ZhbHVlcyhwcm9wRGlmZiwgcHJvcEJpYXMsIHByb3BCaWFzQ29tcGxlbWVudCkge1xuICAgICAgICB2YXIgYmlhc0RpZmYgPSAwO1xuICAgICAgICB2YXIgYmlhc0NvbXBsZW1lbnREaWZmID0gMDtcbiAgICAgICAgdmFyIGJpYXNUb3RhbCA9IHByb3BCaWFzICsgcHJvcEJpYXNDb21wbGVtZW50O1xuXG4gICAgICAgIGlmIChwcm9wRGlmZiA+IDAgJiYgYmlhc1RvdGFsID4gMCkge1xuICAgICAgICAgIGJpYXNEaWZmID0gcHJvcEJpYXMgLyBiaWFzVG90YWwgKiBwcm9wRGlmZjtcbiAgICAgICAgICBiaWFzQ29tcGxlbWVudERpZmYgPSBwcm9wQmlhc0NvbXBsZW1lbnQgLyBiaWFzVG90YWwgKiBwcm9wRGlmZjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYmlhc0RpZmY6IGJpYXNEaWZmLFxuICAgICAgICAgIGJpYXNDb21wbGVtZW50RGlmZjogYmlhc0NvbXBsZW1lbnREaWZmXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNvbXB1dGVQYWRkaW5nVmFsdWVzKHdpZHRoLCBoZWlnaHQsIHBhZGRpbmdPYmplY3QsIHJlbGF0aXZlVG8pIHtcbiAgICAgICAgLy8gQXNzdW1pbmcgcGVyY2VudGFnZSBpcyBudW1iZXIgZnJvbSAwIHRvIDFcbiAgICAgICAgaWYgKHBhZGRpbmdPYmplY3QudW5pdHMgPT09ICclJykge1xuICAgICAgICAgIHN3aXRjaCAocmVsYXRpdmVUbykge1xuICAgICAgICAgICAgY2FzZSAnd2lkdGgnOlxuICAgICAgICAgICAgICByZXR1cm4gd2lkdGggPiAwID8gcGFkZGluZ09iamVjdC5wZlZhbHVlICogd2lkdGggOiAwO1xuXG4gICAgICAgICAgICBjYXNlICdoZWlnaHQnOlxuICAgICAgICAgICAgICByZXR1cm4gaGVpZ2h0ID4gMCA/IHBhZGRpbmdPYmplY3QucGZWYWx1ZSAqIGhlaWdodCA6IDA7XG5cbiAgICAgICAgICAgIGNhc2UgJ2F2ZXJhZ2UnOlxuICAgICAgICAgICAgICByZXR1cm4gd2lkdGggPiAwICYmIGhlaWdodCA+IDAgPyBwYWRkaW5nT2JqZWN0LnBmVmFsdWUgKiAod2lkdGggKyBoZWlnaHQpIC8gMiA6IDA7XG5cbiAgICAgICAgICAgIGNhc2UgJ21pbic6XG4gICAgICAgICAgICAgIHJldHVybiB3aWR0aCA+IDAgJiYgaGVpZ2h0ID4gMCA/IHdpZHRoID4gaGVpZ2h0ID8gcGFkZGluZ09iamVjdC5wZlZhbHVlICogaGVpZ2h0IDogcGFkZGluZ09iamVjdC5wZlZhbHVlICogd2lkdGggOiAwO1xuXG4gICAgICAgICAgICBjYXNlICdtYXgnOlxuICAgICAgICAgICAgICByZXR1cm4gd2lkdGggPiAwICYmIGhlaWdodCA+IDAgPyB3aWR0aCA+IGhlaWdodCA/IHBhZGRpbmdPYmplY3QucGZWYWx1ZSAqIHdpZHRoIDogcGFkZGluZ09iamVjdC5wZlZhbHVlICogaGVpZ2h0IDogMDtcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHBhZGRpbmdPYmplY3QudW5pdHMgPT09ICdweCcpIHtcbiAgICAgICAgICByZXR1cm4gcGFkZGluZ09iamVjdC5wZlZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBsZWZ0VmFsID0gbWluLndpZHRoLmxlZnQudmFsdWU7XG5cbiAgICAgIGlmIChtaW4ud2lkdGgubGVmdC51bml0cyA9PT0gJ3B4JyAmJiBtaW4ud2lkdGgudmFsID4gMCkge1xuICAgICAgICBsZWZ0VmFsID0gbGVmdFZhbCAqIDEwMCAvIG1pbi53aWR0aC52YWw7XG4gICAgICB9XG5cbiAgICAgIHZhciByaWdodFZhbCA9IG1pbi53aWR0aC5yaWdodC52YWx1ZTtcblxuICAgICAgaWYgKG1pbi53aWR0aC5yaWdodC51bml0cyA9PT0gJ3B4JyAmJiBtaW4ud2lkdGgudmFsID4gMCkge1xuICAgICAgICByaWdodFZhbCA9IHJpZ2h0VmFsICogMTAwIC8gbWluLndpZHRoLnZhbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHRvcFZhbCA9IG1pbi5oZWlnaHQudG9wLnZhbHVlO1xuXG4gICAgICBpZiAobWluLmhlaWdodC50b3AudW5pdHMgPT09ICdweCcgJiYgbWluLmhlaWdodC52YWwgPiAwKSB7XG4gICAgICAgIHRvcFZhbCA9IHRvcFZhbCAqIDEwMCAvIG1pbi5oZWlnaHQudmFsO1xuICAgICAgfVxuXG4gICAgICB2YXIgYm90dG9tVmFsID0gbWluLmhlaWdodC5ib3R0b20udmFsdWU7XG5cbiAgICAgIGlmIChtaW4uaGVpZ2h0LmJvdHRvbS51bml0cyA9PT0gJ3B4JyAmJiBtaW4uaGVpZ2h0LnZhbCA+IDApIHtcbiAgICAgICAgYm90dG9tVmFsID0gYm90dG9tVmFsICogMTAwIC8gbWluLmhlaWdodC52YWw7XG4gICAgICB9XG5cbiAgICAgIHZhciB3aWR0aEJpYXNEaWZmcyA9IGNvbXB1dGVCaWFzVmFsdWVzKG1pbi53aWR0aC52YWwgLSBiYi53LCBsZWZ0VmFsLCByaWdodFZhbCk7XG4gICAgICB2YXIgZGlmZkxlZnQgPSB3aWR0aEJpYXNEaWZmcy5iaWFzRGlmZjtcbiAgICAgIHZhciBkaWZmUmlnaHQgPSB3aWR0aEJpYXNEaWZmcy5iaWFzQ29tcGxlbWVudERpZmY7XG4gICAgICB2YXIgaGVpZ2h0Qmlhc0RpZmZzID0gY29tcHV0ZUJpYXNWYWx1ZXMobWluLmhlaWdodC52YWwgLSBiYi5oLCB0b3BWYWwsIGJvdHRvbVZhbCk7XG4gICAgICB2YXIgZGlmZlRvcCA9IGhlaWdodEJpYXNEaWZmcy5iaWFzRGlmZjtcbiAgICAgIHZhciBkaWZmQm90dG9tID0gaGVpZ2h0Qmlhc0RpZmZzLmJpYXNDb21wbGVtZW50RGlmZjtcbiAgICAgIF9wLmF1dG9QYWRkaW5nID0gY29tcHV0ZVBhZGRpbmdWYWx1ZXMoYmIudywgYmIuaCwgcGFyZW50LnBzdHlsZSgncGFkZGluZycpLCBwYXJlbnQucHN0eWxlKCdwYWRkaW5nLXJlbGF0aXZlLXRvJykudmFsdWUpO1xuICAgICAgX3AuYXV0b1dpZHRoID0gTWF0aC5tYXgoYmIudywgbWluLndpZHRoLnZhbCk7XG4gICAgICBwb3MueCA9ICgtZGlmZkxlZnQgKyBiYi54MSArIGJiLngyICsgZGlmZlJpZ2h0KSAvIDI7XG4gICAgICBfcC5hdXRvSGVpZ2h0ID0gTWF0aC5tYXgoYmIuaCwgbWluLmhlaWdodC52YWwpO1xuICAgICAgcG9zLnkgPSAoLWRpZmZUb3AgKyBiYi55MSArIGJiLnkyICsgZGlmZkJvdHRvbSkgLyAyO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG5cbiAgICAgIGlmICghX3AuY29tcG91bmRCb3VuZHNDbGVhbiB8fCBmb3JjZSkge1xuICAgICAgICB1cGRhdGUoZWxlKTtcblxuICAgICAgICBpZiAoIWN5LmJhdGNoaW5nKCkpIHtcbiAgICAgICAgICBfcC5jb21wb3VuZEJvdW5kc0NsZWFuID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHZhciBub25pbmYgPSBmdW5jdGlvbiBub25pbmYoeCkge1xuICAgIGlmICh4ID09PSBJbmZpbml0eSB8fCB4ID09PSAtSW5maW5pdHkpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHJldHVybiB4O1xuICB9O1xuXG4gIHZhciB1cGRhdGVCb3VuZHMgPSBmdW5jdGlvbiB1cGRhdGVCb3VuZHMoYiwgeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAvLyBkb24ndCB1cGRhdGUgd2l0aCB6ZXJvIGFyZWEgYm94ZXNcbiAgICBpZiAoeDIgLSB4MSA9PT0gMCB8fCB5MiAtIHkxID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBkb24ndCB1cGRhdGUgd2l0aCBudWxsIGRpbVxuXG5cbiAgICBpZiAoeDEgPT0gbnVsbCB8fCB5MSA9PSBudWxsIHx8IHgyID09IG51bGwgfHwgeTIgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGIueDEgPSB4MSA8IGIueDEgPyB4MSA6IGIueDE7XG4gICAgYi54MiA9IHgyID4gYi54MiA/IHgyIDogYi54MjtcbiAgICBiLnkxID0geTEgPCBiLnkxID8geTEgOiBiLnkxO1xuICAgIGIueTIgPSB5MiA+IGIueTIgPyB5MiA6IGIueTI7XG4gICAgYi53ID0gYi54MiAtIGIueDE7XG4gICAgYi5oID0gYi55MiAtIGIueTE7XG4gIH07XG5cbiAgdmFyIHVwZGF0ZUJvdW5kc0Zyb21Cb3ggPSBmdW5jdGlvbiB1cGRhdGVCb3VuZHNGcm9tQm94KGIsIGIyKSB7XG4gICAgaWYgKGIyID09IG51bGwpIHtcbiAgICAgIHJldHVybiBiO1xuICAgIH1cblxuICAgIHJldHVybiB1cGRhdGVCb3VuZHMoYiwgYjIueDEsIGIyLnkxLCBiMi54MiwgYjIueTIpO1xuICB9O1xuXG4gIHZhciBwcmVmaXhlZFByb3BlcnR5ID0gZnVuY3Rpb24gcHJlZml4ZWRQcm9wZXJ0eShvYmosIGZpZWxkLCBwcmVmaXgpIHtcbiAgICByZXR1cm4gZ2V0UHJlZml4ZWRQcm9wZXJ0eShvYmosIGZpZWxkLCBwcmVmaXgpO1xuICB9O1xuXG4gIHZhciB1cGRhdGVCb3VuZHNGcm9tQXJyb3cgPSBmdW5jdGlvbiB1cGRhdGVCb3VuZHNGcm9tQXJyb3coYm91bmRzLCBlbGUsIHByZWZpeCkge1xuICAgIGlmIChlbGUuY3koKS5oZWFkbGVzcygpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgIHZhciByc3R5bGUgPSBfcC5yc3R5bGU7XG4gICAgdmFyIGhhbGZBclcgPSByc3R5bGUuYXJyb3dXaWR0aCAvIDI7XG4gICAgdmFyIGFycm93VHlwZSA9IGVsZS5wc3R5bGUocHJlZml4ICsgJy1hcnJvdy1zaGFwZScpLnZhbHVlO1xuICAgIHZhciB4O1xuICAgIHZhciB5O1xuXG4gICAgaWYgKGFycm93VHlwZSAhPT0gJ25vbmUnKSB7XG4gICAgICBpZiAocHJlZml4ID09PSAnc291cmNlJykge1xuICAgICAgICB4ID0gcnN0eWxlLnNyY1g7XG4gICAgICAgIHkgPSByc3R5bGUuc3JjWTtcbiAgICAgIH0gZWxzZSBpZiAocHJlZml4ID09PSAndGFyZ2V0Jykge1xuICAgICAgICB4ID0gcnN0eWxlLnRndFg7XG4gICAgICAgIHkgPSByc3R5bGUudGd0WTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHggPSByc3R5bGUubWlkWDtcbiAgICAgICAgeSA9IHJzdHlsZS5taWRZO1xuICAgICAgfSAvLyBhbHdheXMgc3RvcmUgdGhlIGluZGl2aWR1YWwgYXJyb3cgYm91bmRzXG5cblxuICAgICAgdmFyIGJicyA9IF9wLmFycm93Qm91bmRzID0gX3AuYXJyb3dCb3VuZHMgfHwge307XG4gICAgICB2YXIgYmIgPSBiYnNbcHJlZml4XSA9IGJic1twcmVmaXhdIHx8IHt9O1xuICAgICAgYmIueDEgPSB4IC0gaGFsZkFyVztcbiAgICAgIGJiLnkxID0geSAtIGhhbGZBclc7XG4gICAgICBiYi54MiA9IHggKyBoYWxmQXJXO1xuICAgICAgYmIueTIgPSB5ICsgaGFsZkFyVztcbiAgICAgIGJiLncgPSBiYi54MiAtIGJiLngxO1xuICAgICAgYmIuaCA9IGJiLnkyIC0gYmIueTE7XG4gICAgICBleHBhbmRCb3VuZGluZ0JveChiYiwgMSk7XG4gICAgICB1cGRhdGVCb3VuZHMoYm91bmRzLCBiYi54MSwgYmIueTEsIGJiLngyLCBiYi55Mik7XG4gICAgfVxuICB9O1xuXG4gIHZhciB1cGRhdGVCb3VuZHNGcm9tTGFiZWwgPSBmdW5jdGlvbiB1cGRhdGVCb3VuZHNGcm9tTGFiZWwoYm91bmRzLCBlbGUsIHByZWZpeCkge1xuICAgIGlmIChlbGUuY3koKS5oZWFkbGVzcygpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByZWZpeERhc2g7XG5cbiAgICBpZiAocHJlZml4KSB7XG4gICAgICBwcmVmaXhEYXNoID0gcHJlZml4ICsgJy0nO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcmVmaXhEYXNoID0gJyc7XG4gICAgfVxuXG4gICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgIHZhciByc3R5bGUgPSBfcC5yc3R5bGU7XG4gICAgdmFyIGxhYmVsID0gZWxlLnBzdHlsZShwcmVmaXhEYXNoICsgJ2xhYmVsJykuc3RyVmFsdWU7XG5cbiAgICBpZiAobGFiZWwpIHtcbiAgICAgIHZhciBoYWxpZ24gPSBlbGUucHN0eWxlKCd0ZXh0LWhhbGlnbicpO1xuICAgICAgdmFyIHZhbGlnbiA9IGVsZS5wc3R5bGUoJ3RleHQtdmFsaWduJyk7XG4gICAgICB2YXIgbGFiZWxXaWR0aCA9IHByZWZpeGVkUHJvcGVydHkocnN0eWxlLCAnbGFiZWxXaWR0aCcsIHByZWZpeCk7XG4gICAgICB2YXIgbGFiZWxIZWlnaHQgPSBwcmVmaXhlZFByb3BlcnR5KHJzdHlsZSwgJ2xhYmVsSGVpZ2h0JywgcHJlZml4KTtcbiAgICAgIHZhciBsYWJlbFggPSBwcmVmaXhlZFByb3BlcnR5KHJzdHlsZSwgJ2xhYmVsWCcsIHByZWZpeCk7XG4gICAgICB2YXIgbGFiZWxZID0gcHJlZml4ZWRQcm9wZXJ0eShyc3R5bGUsICdsYWJlbFknLCBwcmVmaXgpO1xuICAgICAgdmFyIG1hcmdpblggPSBlbGUucHN0eWxlKHByZWZpeERhc2ggKyAndGV4dC1tYXJnaW4teCcpLnBmVmFsdWU7XG4gICAgICB2YXIgbWFyZ2luWSA9IGVsZS5wc3R5bGUocHJlZml4RGFzaCArICd0ZXh0LW1hcmdpbi15JykucGZWYWx1ZTtcbiAgICAgIHZhciBpc0VkZ2UgPSBlbGUuaXNFZGdlKCk7XG4gICAgICB2YXIgcm90YXRpb24gPSBlbGUucHN0eWxlKHByZWZpeERhc2ggKyAndGV4dC1yb3RhdGlvbicpO1xuICAgICAgdmFyIG91dGxpbmVXaWR0aCA9IGVsZS5wc3R5bGUoJ3RleHQtb3V0bGluZS13aWR0aCcpLnBmVmFsdWU7XG4gICAgICB2YXIgYm9yZGVyV2lkdGggPSBlbGUucHN0eWxlKCd0ZXh0LWJvcmRlci13aWR0aCcpLnBmVmFsdWU7XG4gICAgICB2YXIgaGFsZkJvcmRlcldpZHRoID0gYm9yZGVyV2lkdGggLyAyO1xuICAgICAgdmFyIHBhZGRpbmcgPSBlbGUucHN0eWxlKCd0ZXh0LWJhY2tncm91bmQtcGFkZGluZycpLnBmVmFsdWU7XG4gICAgICB2YXIgbWFyZ2luT2ZFcnJvciA9IDI7IC8vIGV4cGFuZCB0byB3b3JrIGFyb3VuZCBicm93c2VyIGRpbWVuc2lvbiBpbmFjY3VyYWNpZXNcblxuICAgICAgdmFyIGxoID0gbGFiZWxIZWlnaHQ7XG4gICAgICB2YXIgbHcgPSBsYWJlbFdpZHRoO1xuICAgICAgdmFyIGx3XzIgPSBsdyAvIDI7XG4gICAgICB2YXIgbGhfMiA9IGxoIC8gMjtcbiAgICAgIHZhciBseDEsIGx4MiwgbHkxLCBseTI7XG5cbiAgICAgIGlmIChpc0VkZ2UpIHtcbiAgICAgICAgbHgxID0gbGFiZWxYIC0gbHdfMjtcbiAgICAgICAgbHgyID0gbGFiZWxYICsgbHdfMjtcbiAgICAgICAgbHkxID0gbGFiZWxZIC0gbGhfMjtcbiAgICAgICAgbHkyID0gbGFiZWxZICsgbGhfMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXRjaCAoaGFsaWduLnZhbHVlKSB7XG4gICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICBseDEgPSBsYWJlbFggLSBsdztcbiAgICAgICAgICAgIGx4MiA9IGxhYmVsWDtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICAgIGx4MSA9IGxhYmVsWCAtIGx3XzI7XG4gICAgICAgICAgICBseDIgPSBsYWJlbFggKyBsd18yO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICBseDEgPSBsYWJlbFg7XG4gICAgICAgICAgICBseDIgPSBsYWJlbFggKyBsdztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoICh2YWxpZ24udmFsdWUpIHtcbiAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgbHkxID0gbGFiZWxZIC0gbGg7XG4gICAgICAgICAgICBseTIgPSBsYWJlbFk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgICBseTEgPSBsYWJlbFkgLSBsaF8yO1xuICAgICAgICAgICAgbHkyID0gbGFiZWxZICsgbGhfMjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgIGx5MSA9IGxhYmVsWTtcbiAgICAgICAgICAgIGx5MiA9IGxhYmVsWSArIGxoO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gc2hpZnQgYnkgbWFyZ2luIGFuZCBleHBhbmQgYnkgb3V0bGluZSBhbmQgYm9yZGVyXG5cblxuICAgICAgbHgxICs9IG1hcmdpblggLSBNYXRoLm1heChvdXRsaW5lV2lkdGgsIGhhbGZCb3JkZXJXaWR0aCkgLSBwYWRkaW5nIC0gbWFyZ2luT2ZFcnJvcjtcbiAgICAgIGx4MiArPSBtYXJnaW5YICsgTWF0aC5tYXgob3V0bGluZVdpZHRoLCBoYWxmQm9yZGVyV2lkdGgpICsgcGFkZGluZyArIG1hcmdpbk9mRXJyb3I7XG4gICAgICBseTEgKz0gbWFyZ2luWSAtIE1hdGgubWF4KG91dGxpbmVXaWR0aCwgaGFsZkJvcmRlcldpZHRoKSAtIHBhZGRpbmcgLSBtYXJnaW5PZkVycm9yO1xuICAgICAgbHkyICs9IG1hcmdpblkgKyBNYXRoLm1heChvdXRsaW5lV2lkdGgsIGhhbGZCb3JkZXJXaWR0aCkgKyBwYWRkaW5nICsgbWFyZ2luT2ZFcnJvcjsgLy8gYWx3YXlzIHN0b3JlIHRoZSB1bnJvdGF0ZWQgbGFiZWwgYm91bmRzIHNlcGFyYXRlbHlcblxuICAgICAgdmFyIGJiUHJlZml4ID0gcHJlZml4IHx8ICdtYWluJztcbiAgICAgIHZhciBiYnMgPSBfcC5sYWJlbEJvdW5kcztcbiAgICAgIHZhciBiYiA9IGJic1tiYlByZWZpeF0gPSBiYnNbYmJQcmVmaXhdIHx8IHt9O1xuICAgICAgYmIueDEgPSBseDE7XG4gICAgICBiYi55MSA9IGx5MTtcbiAgICAgIGJiLngyID0gbHgyO1xuICAgICAgYmIueTIgPSBseTI7XG4gICAgICBiYi53ID0gbHgyIC0gbHgxO1xuICAgICAgYmIuaCA9IGx5MiAtIGx5MTtcbiAgICAgIHZhciBpc0F1dG9yb3RhdGUgPSBpc0VkZ2UgJiYgcm90YXRpb24uc3RyVmFsdWUgPT09ICdhdXRvcm90YXRlJztcbiAgICAgIHZhciBpc1BmVmFsdWUgPSByb3RhdGlvbi5wZlZhbHVlICE9IG51bGwgJiYgcm90YXRpb24ucGZWYWx1ZSAhPT0gMDtcblxuICAgICAgaWYgKGlzQXV0b3JvdGF0ZSB8fCBpc1BmVmFsdWUpIHtcbiAgICAgICAgdmFyIHRoZXRhID0gaXNBdXRvcm90YXRlID8gcHJlZml4ZWRQcm9wZXJ0eShfcC5yc3R5bGUsICdsYWJlbEFuZ2xlJywgcHJlZml4KSA6IHJvdGF0aW9uLnBmVmFsdWU7XG4gICAgICAgIHZhciBjb3MgPSBNYXRoLmNvcyh0aGV0YSk7XG4gICAgICAgIHZhciBzaW4gPSBNYXRoLnNpbih0aGV0YSk7IC8vIHJvdGF0aW9uIHBvaW50IChkZWZhdWx0IHZhbHVlIGZvciBjZW50ZXItY2VudGVyKVxuXG4gICAgICAgIHZhciB4byA9IChseDEgKyBseDIpIC8gMjtcbiAgICAgICAgdmFyIHlvID0gKGx5MSArIGx5MikgLyAyO1xuXG4gICAgICAgIGlmICghaXNFZGdlKSB7XG4gICAgICAgICAgc3dpdGNoIChoYWxpZ24udmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICB4byA9IGx4MjtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgeG8gPSBseDE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN3aXRjaCAodmFsaWduLnZhbHVlKSB7XG4gICAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgICB5byA9IGx5MjtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICAgIHlvID0gbHkxO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcm90YXRlID0gZnVuY3Rpb24gcm90YXRlKHgsIHkpIHtcbiAgICAgICAgICB4ID0geCAtIHhvO1xuICAgICAgICAgIHkgPSB5IC0geW87XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHggKiBjb3MgLSB5ICogc2luICsgeG8sXG4gICAgICAgICAgICB5OiB4ICogc2luICsgeSAqIGNvcyArIHlvXG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcHgxeTEgPSByb3RhdGUobHgxLCBseTEpO1xuICAgICAgICB2YXIgcHgxeTIgPSByb3RhdGUobHgxLCBseTIpO1xuICAgICAgICB2YXIgcHgyeTEgPSByb3RhdGUobHgyLCBseTEpO1xuICAgICAgICB2YXIgcHgyeTIgPSByb3RhdGUobHgyLCBseTIpO1xuICAgICAgICBseDEgPSBNYXRoLm1pbihweDF5MS54LCBweDF5Mi54LCBweDJ5MS54LCBweDJ5Mi54KTtcbiAgICAgICAgbHgyID0gTWF0aC5tYXgocHgxeTEueCwgcHgxeTIueCwgcHgyeTEueCwgcHgyeTIueCk7XG4gICAgICAgIGx5MSA9IE1hdGgubWluKHB4MXkxLnksIHB4MXkyLnksIHB4MnkxLnksIHB4MnkyLnkpO1xuICAgICAgICBseTIgPSBNYXRoLm1heChweDF5MS55LCBweDF5Mi55LCBweDJ5MS55LCBweDJ5Mi55KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGJiUHJlZml4Um90ID0gYmJQcmVmaXggKyAnUm90JztcbiAgICAgIHZhciBiYlJvdCA9IGJic1tiYlByZWZpeFJvdF0gPSBiYnNbYmJQcmVmaXhSb3RdIHx8IHt9O1xuICAgICAgYmJSb3QueDEgPSBseDE7XG4gICAgICBiYlJvdC55MSA9IGx5MTtcbiAgICAgIGJiUm90LngyID0gbHgyO1xuICAgICAgYmJSb3QueTIgPSBseTI7XG4gICAgICBiYlJvdC53ID0gbHgyIC0gbHgxO1xuICAgICAgYmJSb3QuaCA9IGx5MiAtIGx5MTtcbiAgICAgIHVwZGF0ZUJvdW5kcyhib3VuZHMsIGx4MSwgbHkxLCBseDIsIGx5Mik7XG4gICAgICB1cGRhdGVCb3VuZHMoX3AubGFiZWxCb3VuZHMuYWxsLCBseDEsIGx5MSwgbHgyLCBseTIpO1xuICAgIH1cblxuICAgIHJldHVybiBib3VuZHM7XG4gIH07IC8vIGdldCB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSBlbGVtZW50cyAoaW4gcmF3IG1vZGVsIHBvc2l0aW9uKVxuXG5cbiAgdmFyIGJvdW5kaW5nQm94SW1wbCA9IGZ1bmN0aW9uIGJvdW5kaW5nQm94SW1wbChlbGUsIG9wdGlvbnMpIHtcbiAgICB2YXIgY3kgPSBlbGUuX3ByaXZhdGUuY3k7XG4gICAgdmFyIHN0eWxlRW5hYmxlZCA9IGN5LnN0eWxlRW5hYmxlZCgpO1xuICAgIHZhciBoZWFkbGVzcyA9IGN5LmhlYWRsZXNzKCk7XG4gICAgdmFyIGJvdW5kcyA9IG1ha2VCb3VuZGluZ0JveCgpO1xuICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICB2YXIgaXNOb2RlID0gZWxlLmlzTm9kZSgpO1xuICAgIHZhciBpc0VkZ2UgPSBlbGUuaXNFZGdlKCk7XG4gICAgdmFyIGV4MSwgZXgyLCBleTEsIGV5MjsgLy8gZXh0cmVtYSBvZiBib2R5IC8gbGluZXNcblxuICAgIHZhciB4LCB5OyAvLyBub2RlIHBvc1xuXG4gICAgdmFyIHJzdHlsZSA9IF9wLnJzdHlsZTtcbiAgICB2YXIgbWFudWFsRXhwYW5zaW9uID0gaXNOb2RlICYmIHN0eWxlRW5hYmxlZCA/IGVsZS5wc3R5bGUoJ2JvdW5kcy1leHBhbnNpb24nKS5wZlZhbHVlIDogWzBdOyAvLyBtdXN0IHVzZSBgZGlzcGxheWAgcHJvcCBvbmx5LCBhcyByZWFkaW5nIGBjb21wb3VuZC53aWR0aCgpYCBjYXVzZXMgcmVjdXJzaW9uXG4gICAgLy8gKG90aGVyIGZhY3RvcnMgbGlrZSB3aWR0aCB2YWx1ZXMgd2lsbCBiZSBjb25zaWRlcmVkIGxhdGVyIGluIHRoaXMgZnVuY3Rpb24gYW55d2F5KVxuXG4gICAgdmFyIGlzRGlzcGxheWVkID0gZnVuY3Rpb24gaXNEaXNwbGF5ZWQoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLnBzdHlsZSgnZGlzcGxheScpLnZhbHVlICE9PSAnbm9uZSc7XG4gICAgfTtcblxuICAgIHZhciBkaXNwbGF5ZWQgPSAhc3R5bGVFbmFibGVkIHx8IGlzRGlzcGxheWVkKGVsZSkgLy8gbXVzdCB0YWtlIGludG8gYWNjb3VudCBjb25uZWN0ZWQgbm9kZXMgYi9jIG9mIGltcGxpY2l0IGVkZ2UgaGlkaW5nIG9uIGRpc3BsYXk6bm9uZSBub2RlXG4gICAgJiYgKCFpc0VkZ2UgfHwgaXNEaXNwbGF5ZWQoZWxlLnNvdXJjZSgpKSAmJiBpc0Rpc3BsYXllZChlbGUudGFyZ2V0KCkpKTtcblxuICAgIGlmIChkaXNwbGF5ZWQpIHtcbiAgICAgIC8vIGRpc3BsYXllZCBzdWZmaWNlcywgc2luY2Ugd2Ugd2lsbCBmaW5kIHplcm8gYXJlYSBlbGVzIGFueXdheVxuICAgICAgdmFyIG92ZXJsYXlPcGFjaXR5ID0gMDtcbiAgICAgIHZhciBvdmVybGF5UGFkZGluZyA9IDA7XG5cbiAgICAgIGlmIChzdHlsZUVuYWJsZWQgJiYgb3B0aW9ucy5pbmNsdWRlT3ZlcmxheXMpIHtcbiAgICAgICAgb3ZlcmxheU9wYWNpdHkgPSBlbGUucHN0eWxlKCdvdmVybGF5LW9wYWNpdHknKS52YWx1ZTtcblxuICAgICAgICBpZiAob3ZlcmxheU9wYWNpdHkgIT09IDApIHtcbiAgICAgICAgICBvdmVybGF5UGFkZGluZyA9IGVsZS5wc3R5bGUoJ292ZXJsYXktcGFkZGluZycpLnZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB1bmRlcmxheU9wYWNpdHkgPSAwO1xuICAgICAgdmFyIHVuZGVybGF5UGFkZGluZyA9IDA7XG5cbiAgICAgIGlmIChzdHlsZUVuYWJsZWQgJiYgb3B0aW9ucy5pbmNsdWRlVW5kZXJsYXlzKSB7XG4gICAgICAgIHVuZGVybGF5T3BhY2l0eSA9IGVsZS5wc3R5bGUoJ3VuZGVybGF5LW9wYWNpdHknKS52YWx1ZTtcblxuICAgICAgICBpZiAodW5kZXJsYXlPcGFjaXR5ICE9PSAwKSB7XG4gICAgICAgICAgdW5kZXJsYXlQYWRkaW5nID0gZWxlLnBzdHlsZSgndW5kZXJsYXktcGFkZGluZycpLnZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBwYWRkaW5nID0gTWF0aC5tYXgob3ZlcmxheVBhZGRpbmcsIHVuZGVybGF5UGFkZGluZyk7XG4gICAgICB2YXIgdyA9IDA7XG4gICAgICB2YXIgd0hhbGYgPSAwO1xuXG4gICAgICBpZiAoc3R5bGVFbmFibGVkKSB7XG4gICAgICAgIHcgPSBlbGUucHN0eWxlKCd3aWR0aCcpLnBmVmFsdWU7XG4gICAgICAgIHdIYWxmID0gdyAvIDI7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc05vZGUgJiYgb3B0aW9ucy5pbmNsdWRlTm9kZXMpIHtcbiAgICAgICAgdmFyIHBvcyA9IGVsZS5wb3NpdGlvbigpO1xuICAgICAgICB4ID0gcG9zLng7XG4gICAgICAgIHkgPSBwb3MueTtcblxuICAgICAgICB2YXIgX3cgPSBlbGUub3V0ZXJXaWR0aCgpO1xuXG4gICAgICAgIHZhciBoYWxmVyA9IF93IC8gMjtcbiAgICAgICAgdmFyIGggPSBlbGUub3V0ZXJIZWlnaHQoKTtcbiAgICAgICAgdmFyIGhhbGZIID0gaCAvIDI7IC8vIGhhbmRsZSBub2RlIGRpbWVuc2lvbnNcbiAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgICAgIGV4MSA9IHggLSBoYWxmVztcbiAgICAgICAgZXgyID0geCArIGhhbGZXO1xuICAgICAgICBleTEgPSB5IC0gaGFsZkg7XG4gICAgICAgIGV5MiA9IHkgKyBoYWxmSDtcbiAgICAgICAgdXBkYXRlQm91bmRzKGJvdW5kcywgZXgxLCBleTEsIGV4MiwgZXkyKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNFZGdlICYmIG9wdGlvbnMuaW5jbHVkZUVkZ2VzKSB7XG4gICAgICAgIGlmIChzdHlsZUVuYWJsZWQgJiYgIWhlYWRsZXNzKSB7XG4gICAgICAgICAgdmFyIGN1cnZlU3R5bGUgPSBlbGUucHN0eWxlKCdjdXJ2ZS1zdHlsZScpLnN0clZhbHVlOyAvLyBoYW5kbGUgZWRnZSBkaW1lbnNpb25zIChyb3VnaCBib3ggZXN0aW1hdGUpXG4gICAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgICAgICAgZXgxID0gTWF0aC5taW4ocnN0eWxlLnNyY1gsIHJzdHlsZS5taWRYLCByc3R5bGUudGd0WCk7XG4gICAgICAgICAgZXgyID0gTWF0aC5tYXgocnN0eWxlLnNyY1gsIHJzdHlsZS5taWRYLCByc3R5bGUudGd0WCk7XG4gICAgICAgICAgZXkxID0gTWF0aC5taW4ocnN0eWxlLnNyY1ksIHJzdHlsZS5taWRZLCByc3R5bGUudGd0WSk7XG4gICAgICAgICAgZXkyID0gTWF0aC5tYXgocnN0eWxlLnNyY1ksIHJzdHlsZS5taWRZLCByc3R5bGUudGd0WSk7IC8vIHRha2UgaW50byBhY2NvdW50IGVkZ2Ugd2lkdGhcblxuICAgICAgICAgIGV4MSAtPSB3SGFsZjtcbiAgICAgICAgICBleDIgKz0gd0hhbGY7XG4gICAgICAgICAgZXkxIC09IHdIYWxmO1xuICAgICAgICAgIGV5MiArPSB3SGFsZjtcbiAgICAgICAgICB1cGRhdGVCb3VuZHMoYm91bmRzLCBleDEsIGV5MSwgZXgyLCBleTIpOyAvLyBwcmVjaXNlIGVkZ2VzXG4gICAgICAgICAgLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgICAgICAgaWYgKGN1cnZlU3R5bGUgPT09ICdoYXlzdGFjaycpIHtcbiAgICAgICAgICAgIHZhciBocHRzID0gcnN0eWxlLmhheXN0YWNrUHRzO1xuXG4gICAgICAgICAgICBpZiAoaHB0cyAmJiBocHRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICBleDEgPSBocHRzWzBdLng7XG4gICAgICAgICAgICAgIGV5MSA9IGhwdHNbMF0ueTtcbiAgICAgICAgICAgICAgZXgyID0gaHB0c1sxXS54O1xuICAgICAgICAgICAgICBleTIgPSBocHRzWzFdLnk7XG5cbiAgICAgICAgICAgICAgaWYgKGV4MSA+IGV4Mikge1xuICAgICAgICAgICAgICAgIHZhciB0ZW1wID0gZXgxO1xuICAgICAgICAgICAgICAgIGV4MSA9IGV4MjtcbiAgICAgICAgICAgICAgICBleDIgPSB0ZW1wO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGV5MSA+IGV5Mikge1xuICAgICAgICAgICAgICAgIHZhciBfdGVtcCA9IGV5MTtcbiAgICAgICAgICAgICAgICBleTEgPSBleTI7XG4gICAgICAgICAgICAgICAgZXkyID0gX3RlbXA7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB1cGRhdGVCb3VuZHMoYm91bmRzLCBleDEgLSB3SGFsZiwgZXkxIC0gd0hhbGYsIGV4MiArIHdIYWxmLCBleTIgKyB3SGFsZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChjdXJ2ZVN0eWxlID09PSAnYmV6aWVyJyB8fCBjdXJ2ZVN0eWxlID09PSAndW5idW5kbGVkLWJlemllcicgfHwgY3VydmVTdHlsZSA9PT0gJ3NlZ21lbnRzJyB8fCBjdXJ2ZVN0eWxlID09PSAndGF4aScpIHtcbiAgICAgICAgICAgIHZhciBwdHM7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoY3VydmVTdHlsZSkge1xuICAgICAgICAgICAgICBjYXNlICdiZXppZXInOlxuICAgICAgICAgICAgICBjYXNlICd1bmJ1bmRsZWQtYmV6aWVyJzpcbiAgICAgICAgICAgICAgICBwdHMgPSByc3R5bGUuYmV6aWVyUHRzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgJ3NlZ21lbnRzJzpcbiAgICAgICAgICAgICAgY2FzZSAndGF4aSc6XG4gICAgICAgICAgICAgICAgcHRzID0gcnN0eWxlLmxpbmVQdHM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwdHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHB0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHZhciBwdCA9IHB0c1tqXTtcbiAgICAgICAgICAgICAgICBleDEgPSBwdC54IC0gd0hhbGY7XG4gICAgICAgICAgICAgICAgZXgyID0gcHQueCArIHdIYWxmO1xuICAgICAgICAgICAgICAgIGV5MSA9IHB0LnkgLSB3SGFsZjtcbiAgICAgICAgICAgICAgICBleTIgPSBwdC55ICsgd0hhbGY7XG4gICAgICAgICAgICAgICAgdXBkYXRlQm91bmRzKGJvdW5kcywgZXgxLCBleTEsIGV4MiwgZXkyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gYmV6aWVyLWxpa2Ugb3Igc2VnbWVudC1saWtlIGVkZ2VcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGhlYWRsZXNzIG9yIHN0eWxlIGRpc2FibGVkXG4gICAgICAgICAgLy8gZmFsbGJhY2sgb24gc291cmNlIGFuZCB0YXJnZXQgcG9zaXRpb25zXG4gICAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgICAgICAgdmFyIG4xID0gZWxlLnNvdXJjZSgpO1xuICAgICAgICAgIHZhciBuMXBvcyA9IG4xLnBvc2l0aW9uKCk7XG4gICAgICAgICAgdmFyIG4yID0gZWxlLnRhcmdldCgpO1xuICAgICAgICAgIHZhciBuMnBvcyA9IG4yLnBvc2l0aW9uKCk7XG4gICAgICAgICAgZXgxID0gbjFwb3MueDtcbiAgICAgICAgICBleDIgPSBuMnBvcy54O1xuICAgICAgICAgIGV5MSA9IG4xcG9zLnk7XG4gICAgICAgICAgZXkyID0gbjJwb3MueTtcblxuICAgICAgICAgIGlmIChleDEgPiBleDIpIHtcbiAgICAgICAgICAgIHZhciBfdGVtcDIgPSBleDE7XG4gICAgICAgICAgICBleDEgPSBleDI7XG4gICAgICAgICAgICBleDIgPSBfdGVtcDI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGV5MSA+IGV5Mikge1xuICAgICAgICAgICAgdmFyIF90ZW1wMyA9IGV5MTtcbiAgICAgICAgICAgIGV5MSA9IGV5MjtcbiAgICAgICAgICAgIGV5MiA9IF90ZW1wMztcbiAgICAgICAgICB9IC8vIHRha2UgaW50byBhY2NvdW50IGVkZ2Ugd2lkdGhcblxuXG4gICAgICAgICAgZXgxIC09IHdIYWxmO1xuICAgICAgICAgIGV4MiArPSB3SGFsZjtcbiAgICAgICAgICBleTEgLT0gd0hhbGY7XG4gICAgICAgICAgZXkyICs9IHdIYWxmO1xuICAgICAgICAgIHVwZGF0ZUJvdW5kcyhib3VuZHMsIGV4MSwgZXkxLCBleDIsIGV5Mik7XG4gICAgICAgIH0gLy8gaGVhZGxlc3Mgb3Igc3R5bGUgZGlzYWJsZWRcblxuICAgICAgfSAvLyBlZGdlc1xuICAgICAgLy8gaGFuZGxlIGVkZ2UgYXJyb3cgc2l6ZVxuICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cbiAgICAgIGlmIChzdHlsZUVuYWJsZWQgJiYgb3B0aW9ucy5pbmNsdWRlRWRnZXMgJiYgaXNFZGdlKSB7XG4gICAgICAgIHVwZGF0ZUJvdW5kc0Zyb21BcnJvdyhib3VuZHMsIGVsZSwgJ21pZC1zb3VyY2UnKTtcbiAgICAgICAgdXBkYXRlQm91bmRzRnJvbUFycm93KGJvdW5kcywgZWxlLCAnbWlkLXRhcmdldCcpO1xuICAgICAgICB1cGRhdGVCb3VuZHNGcm9tQXJyb3coYm91bmRzLCBlbGUsICdzb3VyY2UnKTtcbiAgICAgICAgdXBkYXRlQm91bmRzRnJvbUFycm93KGJvdW5kcywgZWxlLCAndGFyZ2V0Jyk7XG4gICAgICB9IC8vIGdob3N0XG4gICAgICAvLy8vLy8vL1xuXG5cbiAgICAgIGlmIChzdHlsZUVuYWJsZWQpIHtcbiAgICAgICAgdmFyIGdob3N0ID0gZWxlLnBzdHlsZSgnZ2hvc3QnKS52YWx1ZSA9PT0gJ3llcyc7XG5cbiAgICAgICAgaWYgKGdob3N0KSB7XG4gICAgICAgICAgdmFyIGd4ID0gZWxlLnBzdHlsZSgnZ2hvc3Qtb2Zmc2V0LXgnKS5wZlZhbHVlO1xuICAgICAgICAgIHZhciBneSA9IGVsZS5wc3R5bGUoJ2dob3N0LW9mZnNldC15JykucGZWYWx1ZTtcbiAgICAgICAgICB1cGRhdGVCb3VuZHMoYm91bmRzLCBib3VuZHMueDEgKyBneCwgYm91bmRzLnkxICsgZ3ksIGJvdW5kcy54MiArIGd4LCBib3VuZHMueTIgKyBneSk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gYWx3YXlzIHN0b3JlIHRoZSBib2R5IGJvdW5kcyBzZXBhcmF0ZWx5IGZyb20gdGhlIGxhYmVsc1xuXG5cbiAgICAgIHZhciBiYkJvZHkgPSBfcC5ib2R5Qm91bmRzID0gX3AuYm9keUJvdW5kcyB8fCB7fTtcbiAgICAgIGFzc2lnbkJvdW5kaW5nQm94KGJiQm9keSwgYm91bmRzKTtcbiAgICAgIGV4cGFuZEJvdW5kaW5nQm94U2lkZXMoYmJCb2R5LCBtYW51YWxFeHBhbnNpb24pO1xuICAgICAgZXhwYW5kQm91bmRpbmdCb3goYmJCb2R5LCAxKTsgLy8gZXhwYW5kIHRvIHdvcmsgYXJvdW5kIGJyb3dzZXIgZGltZW5zaW9uIGluYWNjdXJhY2llc1xuICAgICAgLy8gb3ZlcmxheVxuICAgICAgLy8vLy8vLy8vL1xuXG4gICAgICBpZiAoc3R5bGVFbmFibGVkKSB7XG4gICAgICAgIGV4MSA9IGJvdW5kcy54MTtcbiAgICAgICAgZXgyID0gYm91bmRzLngyO1xuICAgICAgICBleTEgPSBib3VuZHMueTE7XG4gICAgICAgIGV5MiA9IGJvdW5kcy55MjtcbiAgICAgICAgdXBkYXRlQm91bmRzKGJvdW5kcywgZXgxIC0gcGFkZGluZywgZXkxIC0gcGFkZGluZywgZXgyICsgcGFkZGluZywgZXkyICsgcGFkZGluZyk7XG4gICAgICB9IC8vIGFsd2F5cyBzdG9yZSB0aGUgYm9keSBib3VuZHMgc2VwYXJhdGVseSBmcm9tIHRoZSBsYWJlbHNcblxuXG4gICAgICB2YXIgYmJPdmVybGF5ID0gX3Aub3ZlcmxheUJvdW5kcyA9IF9wLm92ZXJsYXlCb3VuZHMgfHwge307XG4gICAgICBhc3NpZ25Cb3VuZGluZ0JveChiYk92ZXJsYXksIGJvdW5kcyk7XG4gICAgICBleHBhbmRCb3VuZGluZ0JveFNpZGVzKGJiT3ZlcmxheSwgbWFudWFsRXhwYW5zaW9uKTtcbiAgICAgIGV4cGFuZEJvdW5kaW5nQm94KGJiT3ZlcmxheSwgMSk7IC8vIGV4cGFuZCB0byB3b3JrIGFyb3VuZCBicm93c2VyIGRpbWVuc2lvbiBpbmFjY3VyYWNpZXNcbiAgICAgIC8vIGhhbmRsZSBsYWJlbCBkaW1lbnNpb25zXG4gICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgICB2YXIgYmJMYWJlbHMgPSBfcC5sYWJlbEJvdW5kcyA9IF9wLmxhYmVsQm91bmRzIHx8IHt9O1xuXG4gICAgICBpZiAoYmJMYWJlbHMuYWxsICE9IG51bGwpIHtcbiAgICAgICAgY2xlYXJCb3VuZGluZ0JveChiYkxhYmVscy5hbGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmJMYWJlbHMuYWxsID0gbWFrZUJvdW5kaW5nQm94KCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdHlsZUVuYWJsZWQgJiYgb3B0aW9ucy5pbmNsdWRlTGFiZWxzKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmluY2x1ZGVNYWluTGFiZWxzKSB7XG4gICAgICAgICAgdXBkYXRlQm91bmRzRnJvbUxhYmVsKGJvdW5kcywgZWxlLCBudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0VkZ2UpIHtcbiAgICAgICAgICBpZiAob3B0aW9ucy5pbmNsdWRlU291cmNlTGFiZWxzKSB7XG4gICAgICAgICAgICB1cGRhdGVCb3VuZHNGcm9tTGFiZWwoYm91bmRzLCBlbGUsICdzb3VyY2UnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob3B0aW9ucy5pbmNsdWRlVGFyZ2V0TGFiZWxzKSB7XG4gICAgICAgICAgICB1cGRhdGVCb3VuZHNGcm9tTGFiZWwoYm91bmRzLCBlbGUsICd0YXJnZXQnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gc3R5bGUgZW5hYmxlZCBmb3IgbGFiZWxzXG5cbiAgICB9IC8vIGlmIGRpc3BsYXllZFxuXG5cbiAgICBib3VuZHMueDEgPSBub25pbmYoYm91bmRzLngxKTtcbiAgICBib3VuZHMueTEgPSBub25pbmYoYm91bmRzLnkxKTtcbiAgICBib3VuZHMueDIgPSBub25pbmYoYm91bmRzLngyKTtcbiAgICBib3VuZHMueTIgPSBub25pbmYoYm91bmRzLnkyKTtcbiAgICBib3VuZHMudyA9IG5vbmluZihib3VuZHMueDIgLSBib3VuZHMueDEpO1xuICAgIGJvdW5kcy5oID0gbm9uaW5mKGJvdW5kcy55MiAtIGJvdW5kcy55MSk7XG5cbiAgICBpZiAoYm91bmRzLncgPiAwICYmIGJvdW5kcy5oID4gMCAmJiBkaXNwbGF5ZWQpIHtcbiAgICAgIGV4cGFuZEJvdW5kaW5nQm94U2lkZXMoYm91bmRzLCBtYW51YWxFeHBhbnNpb24pOyAvLyBleHBhbmQgYm91bmRzIGJ5IDEgYmVjYXVzZSBhbnRpYWxpYXNpbmcgY2FuIGluY3JlYXNlIHRoZSB2aXN1YWwvZWZmZWN0aXZlIHNpemUgYnkgMSBvbiBhbGwgc2lkZXNcblxuICAgICAgZXhwYW5kQm91bmRpbmdCb3goYm91bmRzLCAxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYm91bmRzO1xuICB9O1xuXG4gIHZhciBnZXRLZXkgPSBmdW5jdGlvbiBnZXRLZXkob3B0cykge1xuICAgIHZhciBpID0gMDtcblxuICAgIHZhciB0ZiA9IGZ1bmN0aW9uIHRmKHZhbCkge1xuICAgICAgcmV0dXJuICh2YWwgPyAxIDogMCkgPDwgaSsrO1xuICAgIH07XG5cbiAgICB2YXIga2V5ID0gMDtcbiAgICBrZXkgKz0gdGYob3B0cy5pbmN1ZGVOb2Rlcyk7XG4gICAga2V5ICs9IHRmKG9wdHMuaW5jbHVkZUVkZ2VzKTtcbiAgICBrZXkgKz0gdGYob3B0cy5pbmNsdWRlTGFiZWxzKTtcbiAgICBrZXkgKz0gdGYob3B0cy5pbmNsdWRlTWFpbkxhYmVscyk7XG4gICAga2V5ICs9IHRmKG9wdHMuaW5jbHVkZVNvdXJjZUxhYmVscyk7XG4gICAga2V5ICs9IHRmKG9wdHMuaW5jbHVkZVRhcmdldExhYmVscyk7XG4gICAga2V5ICs9IHRmKG9wdHMuaW5jbHVkZU92ZXJsYXlzKTtcbiAgICByZXR1cm4ga2V5O1xuICB9O1xuXG4gIHZhciBnZXRCb3VuZGluZ0JveFBvc0tleSA9IGZ1bmN0aW9uIGdldEJvdW5kaW5nQm94UG9zS2V5KGVsZSkge1xuICAgIGlmIChlbGUuaXNFZGdlKCkpIHtcbiAgICAgIHZhciBwMSA9IGVsZS5zb3VyY2UoKS5wb3NpdGlvbigpO1xuICAgICAgdmFyIHAyID0gZWxlLnRhcmdldCgpLnBvc2l0aW9uKCk7XG5cbiAgICAgIHZhciByID0gZnVuY3Rpb24gcih4KSB7XG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHgpO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIGhhc2hJbnRzQXJyYXkoW3IocDEueCksIHIocDEueSksIHIocDIueCksIHIocDIueSldKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9O1xuXG4gIHZhciBjYWNoZWRCb3VuZGluZ0JveEltcGwgPSBmdW5jdGlvbiBjYWNoZWRCb3VuZGluZ0JveEltcGwoZWxlLCBvcHRzKSB7XG4gICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgIHZhciBiYjtcbiAgICB2YXIgaXNFZGdlID0gZWxlLmlzRWRnZSgpO1xuICAgIHZhciBrZXkgPSBvcHRzID09IG51bGwgPyBkZWZCYk9wdHNLZXkgOiBnZXRLZXkob3B0cyk7XG4gICAgdmFyIHVzaW5nRGVmT3B0cyA9IGtleSA9PT0gZGVmQmJPcHRzS2V5O1xuICAgIHZhciBjdXJyUG9zS2V5ID0gZ2V0Qm91bmRpbmdCb3hQb3NLZXkoZWxlKTtcbiAgICB2YXIgaXNQb3NLZXlTYW1lID0gX3AuYmJDYWNoZVBvc0tleSA9PT0gY3VyclBvc0tleTtcbiAgICB2YXIgdXNlQ2FjaGUgPSBvcHRzLnVzZUNhY2hlICYmIGlzUG9zS2V5U2FtZTtcblxuICAgIHZhciBpc0RpcnR5ID0gZnVuY3Rpb24gaXNEaXJ0eShlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuX3ByaXZhdGUuYmJDYWNoZSA9PSBudWxsIHx8IGVsZS5fcHJpdmF0ZS5zdHlsZURpcnR5O1xuICAgIH07XG5cbiAgICB2YXIgbmVlZFJlY2FsYyA9ICF1c2VDYWNoZSB8fCBpc0RpcnR5KGVsZSkgfHwgaXNFZGdlICYmIGlzRGlydHkoZWxlLnNvdXJjZSgpKSB8fCBpc0RpcnR5KGVsZS50YXJnZXQoKSk7XG5cbiAgICBpZiAobmVlZFJlY2FsYykge1xuICAgICAgaWYgKCFpc1Bvc0tleVNhbWUpIHtcbiAgICAgICAgZWxlLnJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZSh1c2VDYWNoZSk7XG4gICAgICB9XG5cbiAgICAgIGJiID0gYm91bmRpbmdCb3hJbXBsKGVsZSwgZGVmQmJPcHRzKTtcbiAgICAgIF9wLmJiQ2FjaGUgPSBiYjtcbiAgICAgIF9wLmJiQ2FjaGVQb3NLZXkgPSBjdXJyUG9zS2V5O1xuICAgIH0gZWxzZSB7XG4gICAgICBiYiA9IF9wLmJiQ2FjaGU7XG4gICAgfSAvLyBub3QgdXNpbmcgZGVmIG9wdHMgPT4gbmVlZCB0byBidWlsZCB1cCBiYiBmcm9tIGNvbWJpbmF0aW9uIG9mIHN1YiBiYnNcblxuXG4gICAgaWYgKCF1c2luZ0RlZk9wdHMpIHtcbiAgICAgIHZhciBpc05vZGUgPSBlbGUuaXNOb2RlKCk7XG4gICAgICBiYiA9IG1ha2VCb3VuZGluZ0JveCgpO1xuXG4gICAgICBpZiAob3B0cy5pbmNsdWRlTm9kZXMgJiYgaXNOb2RlIHx8IG9wdHMuaW5jbHVkZUVkZ2VzICYmICFpc05vZGUpIHtcbiAgICAgICAgaWYgKG9wdHMuaW5jbHVkZU92ZXJsYXlzKSB7XG4gICAgICAgICAgdXBkYXRlQm91bmRzRnJvbUJveChiYiwgX3Aub3ZlcmxheUJvdW5kcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdXBkYXRlQm91bmRzRnJvbUJveChiYiwgX3AuYm9keUJvdW5kcyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG9wdHMuaW5jbHVkZUxhYmVscykge1xuICAgICAgICBpZiAob3B0cy5pbmNsdWRlTWFpbkxhYmVscyAmJiAoIWlzRWRnZSB8fCBvcHRzLmluY2x1ZGVTb3VyY2VMYWJlbHMgJiYgb3B0cy5pbmNsdWRlVGFyZ2V0TGFiZWxzKSkge1xuICAgICAgICAgIHVwZGF0ZUJvdW5kc0Zyb21Cb3goYmIsIF9wLmxhYmVsQm91bmRzLmFsbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKG9wdHMuaW5jbHVkZU1haW5MYWJlbHMpIHtcbiAgICAgICAgICAgIHVwZGF0ZUJvdW5kc0Zyb21Cb3goYmIsIF9wLmxhYmVsQm91bmRzLm1haW5Sb3QpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvcHRzLmluY2x1ZGVTb3VyY2VMYWJlbHMpIHtcbiAgICAgICAgICAgIHVwZGF0ZUJvdW5kc0Zyb21Cb3goYmIsIF9wLmxhYmVsQm91bmRzLnNvdXJjZVJvdCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG9wdHMuaW5jbHVkZVRhcmdldExhYmVscykge1xuICAgICAgICAgICAgdXBkYXRlQm91bmRzRnJvbUJveChiYiwgX3AubGFiZWxCb3VuZHMudGFyZ2V0Um90KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYmIudyA9IGJiLngyIC0gYmIueDE7XG4gICAgICBiYi5oID0gYmIueTIgLSBiYi55MTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmI7XG4gIH07XG5cbiAgdmFyIGRlZkJiT3B0cyA9IHtcbiAgICBpbmNsdWRlTm9kZXM6IHRydWUsXG4gICAgaW5jbHVkZUVkZ2VzOiB0cnVlLFxuICAgIGluY2x1ZGVMYWJlbHM6IHRydWUsXG4gICAgaW5jbHVkZU1haW5MYWJlbHM6IHRydWUsXG4gICAgaW5jbHVkZVNvdXJjZUxhYmVsczogdHJ1ZSxcbiAgICBpbmNsdWRlVGFyZ2V0TGFiZWxzOiB0cnVlLFxuICAgIGluY2x1ZGVPdmVybGF5czogdHJ1ZSxcbiAgICBpbmNsdWRlVW5kZXJsYXlzOiB0cnVlLFxuICAgIHVzZUNhY2hlOiB0cnVlXG4gIH07XG4gIHZhciBkZWZCYk9wdHNLZXkgPSBnZXRLZXkoZGVmQmJPcHRzKTtcbiAgdmFyIGZpbGxlZEJiT3B0cyA9IGRlZmF1bHRzJGcoZGVmQmJPcHRzKTtcblxuICBlbGVzZm4kYi5ib3VuZGluZ0JveCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIGJvdW5kczsgLy8gdGhlIG1haW4gdXNlY2FzZSBpcyBlbGUuYm91bmRpbmdCb3goKSBmb3IgYSBzaW5nbGUgZWxlbWVudCB3aXRoIG5vL2RlZiBvcHRpb25zXG4gICAgLy8gc3BlY2lmaWVkIHMudC4gdGhlIGNhY2hlIGlzIHVzZWQsIHNvIGNoZWNrIGZvciB0aGlzIGNhc2UgdG8gbWFrZSBpdCBmYXN0ZXIgYnlcbiAgICAvLyBhdm9pZGluZyB0aGUgb3ZlcmhlYWQgb2YgdGhlIHJlc3Qgb2YgdGhlIGZ1bmN0aW9uXG5cbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEgJiYgdGhpc1swXS5fcHJpdmF0ZS5iYkNhY2hlICE9IG51bGwgJiYgIXRoaXNbMF0uX3ByaXZhdGUuc3R5bGVEaXJ0eSAmJiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMudXNlQ2FjaGUgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLnVzZUNhY2hlID09PSB0cnVlKSkge1xuICAgICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvcHRpb25zID0gZGVmQmJPcHRzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9ucyA9IGZpbGxlZEJiT3B0cyhvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgYm91bmRzID0gY2FjaGVkQm91bmRpbmdCb3hJbXBsKHRoaXNbMF0sIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBib3VuZHMgPSBtYWtlQm91bmRpbmdCb3goKTtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IGRlZkJiT3B0cztcbiAgICAgIHZhciBvcHRzID0gZmlsbGVkQmJPcHRzKG9wdGlvbnMpO1xuICAgICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgICAgdmFyIGN5ID0gZWxlcy5jeSgpO1xuICAgICAgdmFyIHN0eWxlRW5hYmxlZCA9IGN5LnN0eWxlRW5hYmxlZCgpO1xuXG4gICAgICBpZiAoc3R5bGVFbmFibGVkKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICAgICAgICB2YXIgY3VyclBvc0tleSA9IGdldEJvdW5kaW5nQm94UG9zS2V5KGVsZSk7XG4gICAgICAgICAgdmFyIGlzUG9zS2V5U2FtZSA9IF9wLmJiQ2FjaGVQb3NLZXkgPT09IGN1cnJQb3NLZXk7XG4gICAgICAgICAgdmFyIHVzZUNhY2hlID0gb3B0cy51c2VDYWNoZSAmJiBpc1Bvc0tleVNhbWUgJiYgIV9wLnN0eWxlRGlydHk7XG4gICAgICAgICAgZWxlLnJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZSh1c2VDYWNoZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy51cGRhdGVDb21wb3VuZEJvdW5kcyghb3B0aW9ucy51c2VDYWNoZSk7XG5cbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBlbGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgX2VsZSA9IGVsZXNbX2ldO1xuICAgICAgICB1cGRhdGVCb3VuZHNGcm9tQm94KGJvdW5kcywgY2FjaGVkQm91bmRpbmdCb3hJbXBsKF9lbGUsIG9wdHMpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBib3VuZHMueDEgPSBub25pbmYoYm91bmRzLngxKTtcbiAgICBib3VuZHMueTEgPSBub25pbmYoYm91bmRzLnkxKTtcbiAgICBib3VuZHMueDIgPSBub25pbmYoYm91bmRzLngyKTtcbiAgICBib3VuZHMueTIgPSBub25pbmYoYm91bmRzLnkyKTtcbiAgICBib3VuZHMudyA9IG5vbmluZihib3VuZHMueDIgLSBib3VuZHMueDEpO1xuICAgIGJvdW5kcy5oID0gbm9uaW5mKGJvdW5kcy55MiAtIGJvdW5kcy55MSk7XG4gICAgcmV0dXJuIGJvdW5kcztcbiAgfTtcblxuICBlbGVzZm4kYi5kaXJ0eUJvdW5kaW5nQm94Q2FjaGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgX3AgPSB0aGlzW2ldLl9wcml2YXRlO1xuICAgICAgX3AuYmJDYWNoZSA9IG51bGw7XG4gICAgICBfcC5iYkNhY2hlUG9zS2V5ID0gbnVsbDtcbiAgICAgIF9wLmJvZHlCb3VuZHMgPSBudWxsO1xuICAgICAgX3Aub3ZlcmxheUJvdW5kcyA9IG51bGw7XG4gICAgICBfcC5sYWJlbEJvdW5kcy5hbGwgPSBudWxsO1xuICAgICAgX3AubGFiZWxCb3VuZHMuc291cmNlID0gbnVsbDtcbiAgICAgIF9wLmxhYmVsQm91bmRzLnRhcmdldCA9IG51bGw7XG4gICAgICBfcC5sYWJlbEJvdW5kcy5tYWluID0gbnVsbDtcbiAgICAgIF9wLmxhYmVsQm91bmRzLnNvdXJjZVJvdCA9IG51bGw7XG4gICAgICBfcC5sYWJlbEJvdW5kcy50YXJnZXRSb3QgPSBudWxsO1xuICAgICAgX3AubGFiZWxCb3VuZHMubWFpblJvdCA9IG51bGw7XG4gICAgICBfcC5hcnJvd0JvdW5kcy5zb3VyY2UgPSBudWxsO1xuICAgICAgX3AuYXJyb3dCb3VuZHMudGFyZ2V0ID0gbnVsbDtcbiAgICAgIF9wLmFycm93Qm91bmRzWydtaWQtc291cmNlJ10gPSBudWxsO1xuICAgICAgX3AuYXJyb3dCb3VuZHNbJ21pZC10YXJnZXQnXSA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5lbWl0QW5kTm90aWZ5KCdib3VuZHMnKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTsgLy8gcHJpdmF0ZSBoZWxwZXIgdG8gZ2V0IGJvdW5kaW5nIGJveCBmb3IgY3VzdG9tIG5vZGUgcG9zaXRpb25zXG4gIC8vIC0gZ29vZCBmb3IgcGVyZiBpbiBjZXJ0YWluIGNhc2VzIGJ1dCBjdXJyZW50bHkgcmVxdWlyZXMgZGlydHlpbmcgdGhlIHJlbmRlcmVkIHN0eWxlXG4gIC8vIC0gd291bGQgYmUgYmV0dGVyIHRvIG5vdCBtb2RpZnkgdGhlIG5vZGVzIGJ1dCB0aGUgbm9kZXMgYXJlIHJlYWQgZGlyZWN0bHkgZXZlcnl3aGVyZSBpbiB0aGUgcmVuZGVyZXIuLi5cbiAgLy8gLSB0cnkgdG8gdXNlIGZvciBvbmx5IHRoaW5ncyBsaWtlIGRpc2NyZXRlIGxheW91dHMgd2hlcmUgdGhlIG5vZGUgcG9zaXRpb24gd291bGQgY2hhbmdlIGFueXdheVxuXG5cbiAgZWxlc2ZuJGIuYm91bmRpbmdCb3hBdCA9IGZ1bmN0aW9uIChmbikge1xuICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgdmFyIGhhc0NvbXBvdW5kTm9kZXMgPSBjeS5oYXNDb21wb3VuZE5vZGVzKCk7XG4gICAgdmFyIHBhcmVudHMgPSBjeS5jb2xsZWN0aW9uKCk7XG5cbiAgICBpZiAoaGFzQ29tcG91bmROb2Rlcykge1xuICAgICAgcGFyZW50cyA9IG5vZGVzLmZpbHRlcihmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZS5pc1BhcmVudCgpO1xuICAgICAgfSk7XG4gICAgICBub2RlcyA9IG5vZGVzLm5vdChwYXJlbnRzKTtcbiAgICB9XG5cbiAgICBpZiAocGxhaW5PYmplY3QoZm4pKSB7XG4gICAgICB2YXIgb2JqID0gZm47XG5cbiAgICAgIGZuID0gZnVuY3Rpb24gZm4oKSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBzdG9yZU9sZFBvcyA9IGZ1bmN0aW9uIHN0b3JlT2xkUG9zKG5vZGUsIGkpIHtcbiAgICAgIHJldHVybiBub2RlLl9wcml2YXRlLmJiQXRPbGRQb3MgPSBmbihub2RlLCBpKTtcbiAgICB9O1xuXG4gICAgdmFyIGdldE9sZFBvcyA9IGZ1bmN0aW9uIGdldE9sZFBvcyhub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZS5fcHJpdmF0ZS5iYkF0T2xkUG9zO1xuICAgIH07XG5cbiAgICBjeS5zdGFydEJhdGNoKCk7XG4gICAgbm9kZXMuZm9yRWFjaChzdG9yZU9sZFBvcykuc2lsZW50UG9zaXRpb25zKGZuKTtcblxuICAgIGlmIChoYXNDb21wb3VuZE5vZGVzKSB7XG4gICAgICBwYXJlbnRzLmRpcnR5Q29tcG91bmRCb3VuZHNDYWNoZSgpO1xuICAgICAgcGFyZW50cy5kaXJ0eUJvdW5kaW5nQm94Q2FjaGUoKTtcbiAgICAgIHBhcmVudHMudXBkYXRlQ29tcG91bmRCb3VuZHModHJ1ZSk7IC8vIGZvcmNlIHVwZGF0ZSBiL2Mgd2UncmUgaW5zaWRlIGEgYmF0Y2ggY3ljbGVcbiAgICB9XG5cbiAgICB2YXIgYmIgPSBjb3B5Qm91bmRpbmdCb3godGhpcy5ib3VuZGluZ0JveCh7XG4gICAgICB1c2VDYWNoZTogZmFsc2VcbiAgICB9KSk7XG4gICAgbm9kZXMuc2lsZW50UG9zaXRpb25zKGdldE9sZFBvcyk7XG5cbiAgICBpZiAoaGFzQ29tcG91bmROb2Rlcykge1xuICAgICAgcGFyZW50cy5kaXJ0eUNvbXBvdW5kQm91bmRzQ2FjaGUoKTtcbiAgICAgIHBhcmVudHMuZGlydHlCb3VuZGluZ0JveENhY2hlKCk7XG4gICAgICBwYXJlbnRzLnVwZGF0ZUNvbXBvdW5kQm91bmRzKHRydWUpOyAvLyBmb3JjZSB1cGRhdGUgYi9jIHdlJ3JlIGluc2lkZSBhIGJhdGNoIGN5Y2xlXG4gICAgfVxuXG4gICAgY3kuZW5kQmF0Y2goKTtcbiAgICByZXR1cm4gYmI7XG4gIH07XG5cbiAgZm4kMy5ib3VuZGluZ2JveCA9IGZuJDMuYmIgPSBmbiQzLmJvdW5kaW5nQm94O1xuICBmbiQzLnJlbmRlcmVkQm91bmRpbmdib3ggPSBmbiQzLnJlbmRlcmVkQm91bmRpbmdCb3g7XG4gIHZhciBib3VuZHMgPSBlbGVzZm4kYjtcblxuICB2YXIgZm4kMiwgZWxlc2ZuJGE7XG4gIGZuJDIgPSBlbGVzZm4kYSA9IHt9O1xuXG4gIHZhciBkZWZpbmVEaW1GbnMgPSBmdW5jdGlvbiBkZWZpbmVEaW1GbnMob3B0cykge1xuICAgIG9wdHMudXBwZXJjYXNlTmFtZSA9IGNhcGl0YWxpemUob3B0cy5uYW1lKTtcbiAgICBvcHRzLmF1dG9OYW1lID0gJ2F1dG8nICsgb3B0cy51cHBlcmNhc2VOYW1lO1xuICAgIG9wdHMubGFiZWxOYW1lID0gJ2xhYmVsJyArIG9wdHMudXBwZXJjYXNlTmFtZTtcbiAgICBvcHRzLm91dGVyTmFtZSA9ICdvdXRlcicgKyBvcHRzLnVwcGVyY2FzZU5hbWU7XG4gICAgb3B0cy51cHBlcmNhc2VPdXRlck5hbWUgPSBjYXBpdGFsaXplKG9wdHMub3V0ZXJOYW1lKTtcblxuICAgIGZuJDJbb3B0cy5uYW1lXSA9IGZ1bmN0aW9uIGRpbUltcGwoKSB7XG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICAgIHZhciBjeSA9IF9wLmN5O1xuICAgICAgdmFyIHN0eWxlRW5hYmxlZCA9IGN5Ll9wcml2YXRlLnN0eWxlRW5hYmxlZDtcblxuICAgICAgaWYgKGVsZSkge1xuICAgICAgICBpZiAoc3R5bGVFbmFibGVkKSB7XG4gICAgICAgICAgaWYgKGVsZS5pc1BhcmVudCgpKSB7XG4gICAgICAgICAgICBlbGUudXBkYXRlQ29tcG91bmRCb3VuZHMoKTtcbiAgICAgICAgICAgIHJldHVybiBfcFtvcHRzLmF1dG9OYW1lXSB8fCAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBkID0gZWxlLnBzdHlsZShvcHRzLm5hbWUpO1xuXG4gICAgICAgICAgc3dpdGNoIChkLnN0clZhbHVlKSB7XG4gICAgICAgICAgICBjYXNlICdsYWJlbCc6XG4gICAgICAgICAgICAgIGVsZS5yZWNhbGN1bGF0ZVJlbmRlcmVkU3R5bGUoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIF9wLnJzdHlsZVtvcHRzLmxhYmVsTmFtZV0gfHwgMDtcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmV0dXJuIGQucGZWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZm4kMlsnb3V0ZXInICsgb3B0cy51cHBlcmNhc2VOYW1lXSA9IGZ1bmN0aW9uIG91dGVyRGltSW1wbCgpIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgICAgdmFyIGN5ID0gX3AuY3k7XG4gICAgICB2YXIgc3R5bGVFbmFibGVkID0gY3kuX3ByaXZhdGUuc3R5bGVFbmFibGVkO1xuXG4gICAgICBpZiAoZWxlKSB7XG4gICAgICAgIGlmIChzdHlsZUVuYWJsZWQpIHtcbiAgICAgICAgICB2YXIgZGltID0gZWxlW29wdHMubmFtZV0oKTtcbiAgICAgICAgICB2YXIgYm9yZGVyID0gZWxlLnBzdHlsZSgnYm9yZGVyLXdpZHRoJykucGZWYWx1ZTsgLy8gbi5iLiAxLzIgZWFjaCBzaWRlXG5cbiAgICAgICAgICB2YXIgcGFkZGluZyA9IDIgKiBlbGUucGFkZGluZygpO1xuICAgICAgICAgIHJldHVybiBkaW0gKyBib3JkZXIgKyBwYWRkaW5nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZuJDJbJ3JlbmRlcmVkJyArIG9wdHMudXBwZXJjYXNlTmFtZV0gPSBmdW5jdGlvbiByZW5kZXJlZERpbUltcGwoKSB7XG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgICAgaWYgKGVsZSkge1xuICAgICAgICB2YXIgZCA9IGVsZVtvcHRzLm5hbWVdKCk7XG4gICAgICAgIHJldHVybiBkICogdGhpcy5jeSgpLnpvb20oKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZm4kMlsncmVuZGVyZWQnICsgb3B0cy51cHBlcmNhc2VPdXRlck5hbWVdID0gZnVuY3Rpb24gcmVuZGVyZWRPdXRlckRpbUltcGwoKSB7XG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgICAgaWYgKGVsZSkge1xuICAgICAgICB2YXIgb2QgPSBlbGVbb3B0cy5vdXRlck5hbWVdKCk7XG4gICAgICAgIHJldHVybiBvZCAqIHRoaXMuY3koKS56b29tKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICBkZWZpbmVEaW1GbnMoe1xuICAgIG5hbWU6ICd3aWR0aCdcbiAgfSk7XG4gIGRlZmluZURpbUZucyh7XG4gICAgbmFtZTogJ2hlaWdodCdcbiAgfSk7XG5cbiAgZWxlc2ZuJGEucGFkZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG5cbiAgICBpZiAoZWxlLmlzUGFyZW50KCkpIHtcbiAgICAgIGVsZS51cGRhdGVDb21wb3VuZEJvdW5kcygpO1xuXG4gICAgICBpZiAoX3AuYXV0b1BhZGRpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gX3AuYXV0b1BhZGRpbmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZWxlLnBzdHlsZSgncGFkZGluZycpLnBmVmFsdWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBlbGUucHN0eWxlKCdwYWRkaW5nJykucGZWYWx1ZTtcbiAgICB9XG4gIH07XG5cbiAgZWxlc2ZuJGEucGFkZGVkSGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIHJldHVybiBlbGUuaGVpZ2h0KCkgKyAyICogZWxlLnBhZGRpbmcoKTtcbiAgfTtcblxuICBlbGVzZm4kYS5wYWRkZWRXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICByZXR1cm4gZWxlLndpZHRoKCkgKyAyICogZWxlLnBhZGRpbmcoKTtcbiAgfTtcblxuICB2YXIgd2lkdGhIZWlnaHQgPSBlbGVzZm4kYTtcblxuICB2YXIgaWZFZGdlID0gZnVuY3Rpb24gaWZFZGdlKGVsZSwgZ2V0VmFsdWUpIHtcbiAgICBpZiAoZWxlLmlzRWRnZSgpKSB7XG4gICAgICByZXR1cm4gZ2V0VmFsdWUoZWxlKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGlmRWRnZVJlbmRlcmVkUG9zaXRpb24gPSBmdW5jdGlvbiBpZkVkZ2VSZW5kZXJlZFBvc2l0aW9uKGVsZSwgZ2V0UG9pbnQpIHtcbiAgICBpZiAoZWxlLmlzRWRnZSgpKSB7XG4gICAgICB2YXIgY3kgPSBlbGUuY3koKTtcbiAgICAgIHJldHVybiBtb2RlbFRvUmVuZGVyZWRQb3NpdGlvbihnZXRQb2ludChlbGUpLCBjeS56b29tKCksIGN5LnBhbigpKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGlmRWRnZVJlbmRlcmVkUG9zaXRpb25zID0gZnVuY3Rpb24gaWZFZGdlUmVuZGVyZWRQb3NpdGlvbnMoZWxlLCBnZXRQb2ludHMpIHtcbiAgICBpZiAoZWxlLmlzRWRnZSgpKSB7XG4gICAgICB2YXIgY3kgPSBlbGUuY3koKTtcbiAgICAgIHZhciBwYW4gPSBjeS5wYW4oKTtcbiAgICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuICAgICAgcmV0dXJuIGdldFBvaW50cyhlbGUpLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgICByZXR1cm4gbW9kZWxUb1JlbmRlcmVkUG9zaXRpb24ocCwgem9vbSwgcGFuKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICB2YXIgY29udHJvbFBvaW50cyA9IGZ1bmN0aW9uIGNvbnRyb2xQb2ludHMoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5yZW5kZXJlcigpLmdldENvbnRyb2xQb2ludHMoZWxlKTtcbiAgfTtcblxuICB2YXIgc2VnbWVudFBvaW50cyA9IGZ1bmN0aW9uIHNlZ21lbnRQb2ludHMoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5yZW5kZXJlcigpLmdldFNlZ21lbnRQb2ludHMoZWxlKTtcbiAgfTtcblxuICB2YXIgc291cmNlRW5kcG9pbnQgPSBmdW5jdGlvbiBzb3VyY2VFbmRwb2ludChlbGUpIHtcbiAgICByZXR1cm4gZWxlLnJlbmRlcmVyKCkuZ2V0U291cmNlRW5kcG9pbnQoZWxlKTtcbiAgfTtcblxuICB2YXIgdGFyZ2V0RW5kcG9pbnQgPSBmdW5jdGlvbiB0YXJnZXRFbmRwb2ludChlbGUpIHtcbiAgICByZXR1cm4gZWxlLnJlbmRlcmVyKCkuZ2V0VGFyZ2V0RW5kcG9pbnQoZWxlKTtcbiAgfTtcblxuICB2YXIgbWlkcG9pbnQgPSBmdW5jdGlvbiBtaWRwb2ludChlbGUpIHtcbiAgICByZXR1cm4gZWxlLnJlbmRlcmVyKCkuZ2V0RWRnZU1pZHBvaW50KGVsZSk7XG4gIH07XG5cbiAgdmFyIHB0cyA9IHtcbiAgICBjb250cm9sUG9pbnRzOiB7XG4gICAgICBnZXQ6IGNvbnRyb2xQb2ludHMsXG4gICAgICBtdWx0OiB0cnVlXG4gICAgfSxcbiAgICBzZWdtZW50UG9pbnRzOiB7XG4gICAgICBnZXQ6IHNlZ21lbnRQb2ludHMsXG4gICAgICBtdWx0OiB0cnVlXG4gICAgfSxcbiAgICBzb3VyY2VFbmRwb2ludDoge1xuICAgICAgZ2V0OiBzb3VyY2VFbmRwb2ludFxuICAgIH0sXG4gICAgdGFyZ2V0RW5kcG9pbnQ6IHtcbiAgICAgIGdldDogdGFyZ2V0RW5kcG9pbnRcbiAgICB9LFxuICAgIG1pZHBvaW50OiB7XG4gICAgICBnZXQ6IG1pZHBvaW50XG4gICAgfVxuICB9O1xuXG4gIHZhciByZW5kZXJlZE5hbWUgPSBmdW5jdGlvbiByZW5kZXJlZE5hbWUobmFtZSkge1xuICAgIHJldHVybiAncmVuZGVyZWQnICsgbmFtZVswXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zdWJzdHIoMSk7XG4gIH07XG5cbiAgdmFyIGVkZ2VQb2ludHMgPSBPYmplY3Qua2V5cyhwdHMpLnJlZHVjZShmdW5jdGlvbiAob2JqLCBuYW1lKSB7XG4gICAgdmFyIHNwZWMgPSBwdHNbbmFtZV07XG4gICAgdmFyIHJOYW1lID0gcmVuZGVyZWROYW1lKG5hbWUpO1xuXG4gICAgb2JqW25hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGlmRWRnZSh0aGlzLCBzcGVjLmdldCk7XG4gICAgfTtcblxuICAgIGlmIChzcGVjLm11bHQpIHtcbiAgICAgIG9ialtyTmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBpZkVkZ2VSZW5kZXJlZFBvc2l0aW9ucyh0aGlzLCBzcGVjLmdldCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpbck5hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gaWZFZGdlUmVuZGVyZWRQb3NpdGlvbih0aGlzLCBzcGVjLmdldCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG4gIH0sIHt9KTtcblxuICB2YXIgZGltZW5zaW9ucyA9IGV4dGVuZCh7fSwgcG9zaXRpb24sIGJvdW5kcywgd2lkdGhIZWlnaHQsIGVkZ2VQb2ludHMpO1xuXG4gIC8qIVxuICBFdmVudCBvYmplY3QgYmFzZWQgb24galF1ZXJ5IGV2ZW50cywgTUlUIGxpY2Vuc2VcblxuICBodHRwczovL2pxdWVyeS5vcmcvbGljZW5zZS9cbiAgaHR0cHM6Ly90bGRybGVnYWwuY29tL2xpY2Vuc2UvbWl0LWxpY2Vuc2VcbiAgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnkvYmxvYi9tYXN0ZXIvc3JjL2V2ZW50LmpzXG4gICovXG4gIHZhciBFdmVudCA9IGZ1bmN0aW9uIEV2ZW50KHNyYywgcHJvcHMpIHtcbiAgICB0aGlzLnJlY3ljbGUoc3JjLCBwcm9wcyk7XG4gIH07XG5cbiAgZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDAzMDMzMS9lY21hLXNjcmlwdC1iaW5kaW5nLmh0bWxcblxuXG4gIEV2ZW50LnByb3RvdHlwZSA9IHtcbiAgICBpbnN0YW5jZVN0cmluZzogZnVuY3Rpb24gaW5zdGFuY2VTdHJpbmcoKSB7XG4gICAgICByZXR1cm4gJ2V2ZW50JztcbiAgICB9LFxuICAgIHJlY3ljbGU6IGZ1bmN0aW9uIHJlY3ljbGUoc3JjLCBwcm9wcykge1xuICAgICAgdGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHJldHVybkZhbHNlO1xuXG4gICAgICBpZiAoc3JjICE9IG51bGwgJiYgc3JjLnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgIC8vIEJyb3dzZXIgRXZlbnQgb2JqZWN0XG4gICAgICAgIHRoaXMudHlwZSA9IHNyYy50eXBlOyAvLyBFdmVudHMgYnViYmxpbmcgdXAgdGhlIGRvY3VtZW50IG1heSBoYXZlIGJlZW4gbWFya2VkIGFzIHByZXZlbnRlZFxuICAgICAgICAvLyBieSBhIGhhbmRsZXIgbG93ZXIgZG93biB0aGUgdHJlZTsgcmVmbGVjdCB0aGUgY29ycmVjdCB2YWx1ZS5cblxuICAgICAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHNyYy5kZWZhdWx0UHJldmVudGVkID8gcmV0dXJuVHJ1ZSA6IHJldHVybkZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChzcmMgIT0gbnVsbCAmJiBzcmMudHlwZSkge1xuICAgICAgICAvLyBQbGFpbiBvYmplY3QgY29udGFpbmluZyBhbGwgZXZlbnQgZGV0YWlsc1xuICAgICAgICBwcm9wcyA9IHNyYztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEV2ZW50IHN0cmluZ1xuICAgICAgICB0aGlzLnR5cGUgPSBzcmM7XG4gICAgICB9IC8vIFB1dCBleHBsaWNpdGx5IHByb3ZpZGVkIHByb3BlcnRpZXMgb250byB0aGUgZXZlbnQgb2JqZWN0XG5cblxuICAgICAgaWYgKHByb3BzICE9IG51bGwpIHtcbiAgICAgICAgLy8gbW9yZSBlZmZpY2llbnQgdG8gbWFudWFsbHkgY29weSBmaWVsZHMgd2UgdXNlXG4gICAgICAgIHRoaXMub3JpZ2luYWxFdmVudCA9IHByb3BzLm9yaWdpbmFsRXZlbnQ7XG4gICAgICAgIHRoaXMudHlwZSA9IHByb3BzLnR5cGUgIT0gbnVsbCA/IHByb3BzLnR5cGUgOiB0aGlzLnR5cGU7XG4gICAgICAgIHRoaXMuY3kgPSBwcm9wcy5jeTtcbiAgICAgICAgdGhpcy50YXJnZXQgPSBwcm9wcy50YXJnZXQ7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBwcm9wcy5wb3NpdGlvbjtcbiAgICAgICAgdGhpcy5yZW5kZXJlZFBvc2l0aW9uID0gcHJvcHMucmVuZGVyZWRQb3NpdGlvbjtcbiAgICAgICAgdGhpcy5uYW1lc3BhY2UgPSBwcm9wcy5uYW1lc3BhY2U7XG4gICAgICAgIHRoaXMubGF5b3V0ID0gcHJvcHMubGF5b3V0O1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5jeSAhPSBudWxsICYmIHRoaXMucG9zaXRpb24gIT0gbnVsbCAmJiB0aGlzLnJlbmRlcmVkUG9zaXRpb24gPT0gbnVsbCkge1xuICAgICAgICAvLyBjcmVhdGUgYSByZW5kZXJlZCBwb3NpdGlvbiBiYXNlZCBvbiB0aGUgcGFzc2VkIHBvc2l0aW9uXG4gICAgICAgIHZhciBwb3MgPSB0aGlzLnBvc2l0aW9uO1xuICAgICAgICB2YXIgem9vbSA9IHRoaXMuY3kuem9vbSgpO1xuICAgICAgICB2YXIgcGFuID0gdGhpcy5jeS5wYW4oKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlZFBvc2l0aW9uID0ge1xuICAgICAgICAgIHg6IHBvcy54ICogem9vbSArIHBhbi54LFxuICAgICAgICAgIHk6IHBvcy55ICogem9vbSArIHBhbi55XG4gICAgICAgIH07XG4gICAgICB9IC8vIENyZWF0ZSBhIHRpbWVzdGFtcCBpZiBpbmNvbWluZyBldmVudCBkb2Vzbid0IGhhdmUgb25lXG5cblxuICAgICAgdGhpcy50aW1lU3RhbXAgPSBzcmMgJiYgc3JjLnRpbWVTdGFtcCB8fCBEYXRlLm5vdygpO1xuICAgIH0sXG4gICAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KCkge1xuICAgICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSByZXR1cm5UcnVlO1xuICAgICAgdmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cbiAgICAgIGlmICghZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIGlmIHByZXZlbnREZWZhdWx0IGV4aXN0cyBydW4gaXQgb24gdGhlIG9yaWdpbmFsIGV2ZW50XG5cblxuICAgICAgaWYgKGUucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbiBzdG9wUHJvcGFnYXRpb24oKSB7XG4gICAgICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcbiAgICAgIHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG4gICAgICBpZiAoIWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBpZiBzdG9wUHJvcGFnYXRpb24gZXhpc3RzIHJ1biBpdCBvbiB0aGUgb3JpZ2luYWwgZXZlbnRcblxuXG4gICAgICBpZiAoZS5zdG9wUHJvcGFnYXRpb24pIHtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjogZnVuY3Rpb24gc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCkge1xuICAgICAgdGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG4gICAgICB0aGlzLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH0sXG4gICAgaXNEZWZhdWx0UHJldmVudGVkOiByZXR1cm5GYWxzZSxcbiAgICBpc1Byb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG4gICAgaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlXG4gIH07XG5cbiAgdmFyIGV2ZW50UmVnZXggPSAvXihbXi5dKykoXFwuKD86W14uXSspKT8kLzsgLy8gcmVnZXggZm9yIG1hdGNoaW5nIGV2ZW50IHN0cmluZ3MgKGUuZy4gXCJjbGljay5uYW1lc3BhY2VcIilcblxuICB2YXIgdW5pdmVyc2FsTmFtZXNwYWNlID0gJy4qJzsgLy8gbWF0Y2hlcyBhcyBpZiBubyBuYW1lc3BhY2Ugc3BlY2lmaWVkIGFuZCBwcmV2ZW50cyB1c2VycyBmcm9tIHVuYmluZGluZyBhY2NpZGVudGFsbHlcblxuICB2YXIgZGVmYXVsdHMkOCA9IHtcbiAgICBxdWFsaWZpZXJDb21wYXJlOiBmdW5jdGlvbiBxdWFsaWZpZXJDb21wYXJlKHExLCBxMikge1xuICAgICAgcmV0dXJuIHExID09PSBxMjtcbiAgICB9LFxuICAgIGV2ZW50TWF0Y2hlczogZnVuY3Rpb25cbiAgICAgIC8qY29udGV4dCwgbGlzdGVuZXIsIGV2ZW50T2JqKi9cbiAgICBldmVudE1hdGNoZXMoKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGFkZEV2ZW50RmllbGRzOiBmdW5jdGlvblxuICAgICAgLypjb250ZXh0LCBldnQqL1xuICAgIGFkZEV2ZW50RmllbGRzKCkge30sXG4gICAgY2FsbGJhY2tDb250ZXh0OiBmdW5jdGlvbiBjYWxsYmFja0NvbnRleHQoY29udGV4dFxuICAgIC8qLCBsaXN0ZW5lciwgZXZlbnRPYmoqL1xuICAgICkge1xuICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgfSxcbiAgICBiZWZvcmVFbWl0OiBmdW5jdGlvblxuICAgICAgLyogY29udGV4dCwgbGlzdGVuZXIsIGV2ZW50T2JqICovXG4gICAgYmVmb3JlRW1pdCgpIHt9LFxuICAgIGFmdGVyRW1pdDogZnVuY3Rpb25cbiAgICAgIC8qIGNvbnRleHQsIGxpc3RlbmVyLCBldmVudE9iaiAqL1xuICAgIGFmdGVyRW1pdCgpIHt9LFxuICAgIGJ1YmJsZTogZnVuY3Rpb25cbiAgICAgIC8qY29udGV4dCovXG4gICAgYnViYmxlKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgcGFyZW50OiBmdW5jdGlvblxuICAgICAgLypjb250ZXh0Ki9cbiAgICBwYXJlbnQoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIGNvbnRleHQ6IG51bGxcbiAgfTtcbiAgdmFyIGRlZmF1bHRzS2V5cyA9IE9iamVjdC5rZXlzKGRlZmF1bHRzJDgpO1xuICB2YXIgZW1wdHlPcHRzID0ge307XG5cbiAgZnVuY3Rpb24gRW1pdHRlcigpIHtcbiAgICB2YXIgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZW1wdHlPcHRzO1xuICAgIHZhciBjb250ZXh0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG5cbiAgICAvLyBtaWNyby1vcHRpbWlzYXRpb24gdnMgT2JqZWN0LmFzc2lnbigpIC0tIHJlZHVjZXMgRWxlbWVudCBpbnN0YW50aWF0aW9uIHRpbWVcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlZmF1bHRzS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGRlZmF1bHRzS2V5c1tpXTtcbiAgICAgIHRoaXNba2V5XSA9IG9wdHNba2V5XSB8fCBkZWZhdWx0cyQ4W2tleV07XG4gICAgfVxuXG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dCB8fCB0aGlzLmNvbnRleHQ7XG4gICAgdGhpcy5saXN0ZW5lcnMgPSBbXTtcbiAgICB0aGlzLmVtaXR0aW5nID0gMDtcbiAgfVxuXG4gIHZhciBwID0gRW1pdHRlci5wcm90b3R5cGU7XG5cbiAgdmFyIGZvckVhY2hFdmVudCA9IGZ1bmN0aW9uIGZvckVhY2hFdmVudChzZWxmLCBoYW5kbGVyLCBldmVudHMsIHF1YWxpZmllciwgY2FsbGJhY2ssIGNvbmYsIGNvbmZPdmVycmlkZXMpIHtcbiAgICBpZiAoZm4kNihxdWFsaWZpZXIpKSB7XG4gICAgICBjYWxsYmFjayA9IHF1YWxpZmllcjtcbiAgICAgIHF1YWxpZmllciA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGNvbmZPdmVycmlkZXMpIHtcbiAgICAgIGlmIChjb25mID09IG51bGwpIHtcbiAgICAgICAgY29uZiA9IGNvbmZPdmVycmlkZXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25mID0gZXh0ZW5kKHt9LCBjb25mLCBjb25mT3ZlcnJpZGVzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZXZlbnRMaXN0ID0gYXJyYXkoZXZlbnRzKSA/IGV2ZW50cyA6IGV2ZW50cy5zcGxpdCgvXFxzKy8pO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBldmVudExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBldnQgPSBldmVudExpc3RbaV07XG5cbiAgICAgIGlmIChlbXB0eVN0cmluZyhldnQpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWF0Y2ggPSBldnQubWF0Y2goZXZlbnRSZWdleCk7IC8vIHR5cGVbLm5hbWVzcGFjZV1cblxuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIHZhciB0eXBlID0gbWF0Y2hbMV07XG4gICAgICAgIHZhciBuYW1lc3BhY2UgPSBtYXRjaFsyXSA/IG1hdGNoWzJdIDogbnVsbDtcbiAgICAgICAgdmFyIHJldCA9IGhhbmRsZXIoc2VsZiwgZXZ0LCB0eXBlLCBuYW1lc3BhY2UsIHF1YWxpZmllciwgY2FsbGJhY2ssIGNvbmYpO1xuXG4gICAgICAgIGlmIChyZXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gLy8gYWxsb3cgZXhpdGluZyBlYXJseVxuXG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBtYWtlRXZlbnRPYmogPSBmdW5jdGlvbiBtYWtlRXZlbnRPYmooc2VsZiwgb2JqKSB7XG4gICAgc2VsZi5hZGRFdmVudEZpZWxkcyhzZWxmLmNvbnRleHQsIG9iaik7XG4gICAgcmV0dXJuIG5ldyBFdmVudChvYmoudHlwZSwgb2JqKTtcbiAgfTtcblxuICB2YXIgZm9yRWFjaEV2ZW50T2JqID0gZnVuY3Rpb24gZm9yRWFjaEV2ZW50T2JqKHNlbGYsIGhhbmRsZXIsIGV2ZW50cykge1xuICAgIGlmIChldmVudChldmVudHMpKSB7XG4gICAgICBoYW5kbGVyKHNlbGYsIGV2ZW50cyk7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChwbGFpbk9iamVjdChldmVudHMpKSB7XG4gICAgICBoYW5kbGVyKHNlbGYsIG1ha2VFdmVudE9iaihzZWxmLCBldmVudHMpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZXZlbnRMaXN0ID0gYXJyYXkoZXZlbnRzKSA/IGV2ZW50cyA6IGV2ZW50cy5zcGxpdCgvXFxzKy8pO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBldmVudExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBldnQgPSBldmVudExpc3RbaV07XG5cbiAgICAgIGlmIChlbXB0eVN0cmluZyhldnQpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWF0Y2ggPSBldnQubWF0Y2goZXZlbnRSZWdleCk7IC8vIHR5cGVbLm5hbWVzcGFjZV1cblxuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIHZhciB0eXBlID0gbWF0Y2hbMV07XG4gICAgICAgIHZhciBuYW1lc3BhY2UgPSBtYXRjaFsyXSA/IG1hdGNoWzJdIDogbnVsbDtcbiAgICAgICAgdmFyIGV2ZW50T2JqID0gbWFrZUV2ZW50T2JqKHNlbGYsIHtcbiAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgIG5hbWVzcGFjZTogbmFtZXNwYWNlLFxuICAgICAgICAgIHRhcmdldDogc2VsZi5jb250ZXh0XG4gICAgICAgIH0pO1xuICAgICAgICBoYW5kbGVyKHNlbGYsIGV2ZW50T2JqKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcC5vbiA9IHAuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnRzLCBxdWFsaWZpZXIsIGNhbGxiYWNrLCBjb25mLCBjb25mT3ZlcnJpZGVzKSB7XG4gICAgZm9yRWFjaEV2ZW50KHRoaXMsIGZ1bmN0aW9uIChzZWxmLCBldmVudCwgdHlwZSwgbmFtZXNwYWNlLCBxdWFsaWZpZXIsIGNhbGxiYWNrLCBjb25mKSB7XG4gICAgICBpZiAoZm4kNihjYWxsYmFjaykpIHtcbiAgICAgICAgc2VsZi5saXN0ZW5lcnMucHVzaCh7XG4gICAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICAgIC8vIGZ1bGwgZXZlbnQgc3RyaW5nXG4gICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICAgIC8vIGNhbGxiYWNrIHRvIHJ1blxuICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgLy8gdGhlIGV2ZW50IHR5cGUgKGUuZy4gJ2NsaWNrJylcbiAgICAgICAgICBuYW1lc3BhY2U6IG5hbWVzcGFjZSxcbiAgICAgICAgICAvLyB0aGUgZXZlbnQgbmFtZXNwYWNlIChlLmcuIFwiLmZvb1wiKVxuICAgICAgICAgIHF1YWxpZmllcjogcXVhbGlmaWVyLFxuICAgICAgICAgIC8vIGEgcmVzdHJpY3Rpb24gb24gd2hldGhlciB0byBtYXRjaCB0aGlzIGVtaXR0ZXJcbiAgICAgICAgICBjb25mOiBjb25mIC8vIGFkZGl0aW9uYWwgY29uZmlndXJhdGlvblxuXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIGV2ZW50cywgcXVhbGlmaWVyLCBjYWxsYmFjaywgY29uZiwgY29uZk92ZXJyaWRlcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgcC5vbmUgPSBmdW5jdGlvbiAoZXZlbnRzLCBxdWFsaWZpZXIsIGNhbGxiYWNrLCBjb25mKSB7XG4gICAgcmV0dXJuIHRoaXMub24oZXZlbnRzLCBxdWFsaWZpZXIsIGNhbGxiYWNrLCBjb25mLCB7XG4gICAgICBvbmU6IHRydWVcbiAgICB9KTtcbiAgfTtcblxuICBwLnJlbW92ZUxpc3RlbmVyID0gcC5vZmYgPSBmdW5jdGlvbiAoZXZlbnRzLCBxdWFsaWZpZXIsIGNhbGxiYWNrLCBjb25mKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGlmICh0aGlzLmVtaXR0aW5nICE9PSAwKSB7XG4gICAgICB0aGlzLmxpc3RlbmVycyA9IGNvcHlBcnJheSQxKHRoaXMubGlzdGVuZXJzKTtcbiAgICB9XG5cbiAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnM7XG5cbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChpKSB7XG4gICAgICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lcnNbaV07XG4gICAgICBmb3JFYWNoRXZlbnQoX3RoaXMsIGZ1bmN0aW9uIChzZWxmLCBldmVudCwgdHlwZSwgbmFtZXNwYWNlLCBxdWFsaWZpZXIsIGNhbGxiYWNrXG4gICAgICAvKiwgY29uZiovXG4gICAgICApIHtcbiAgICAgICAgaWYgKChsaXN0ZW5lci50eXBlID09PSB0eXBlIHx8IGV2ZW50cyA9PT0gJyonKSAmJiAoIW5hbWVzcGFjZSAmJiBsaXN0ZW5lci5uYW1lc3BhY2UgIT09ICcuKicgfHwgbGlzdGVuZXIubmFtZXNwYWNlID09PSBuYW1lc3BhY2UpICYmICghcXVhbGlmaWVyIHx8IHNlbGYucXVhbGlmaWVyQ29tcGFyZShsaXN0ZW5lci5xdWFsaWZpZXIsIHF1YWxpZmllcikpICYmICghY2FsbGJhY2sgfHwgbGlzdGVuZXIuY2FsbGJhY2sgPT09IGNhbGxiYWNrKSkge1xuICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9LCBldmVudHMsIHF1YWxpZmllciwgY2FsbGJhY2ssIGNvbmYpO1xuICAgIH07XG5cbiAgICBmb3IgKHZhciBpID0gbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBfbG9vcChpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBwLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5yZW1vdmVMaXN0ZW5lcignKicpO1xuICB9O1xuXG4gIHAuZW1pdCA9IHAudHJpZ2dlciA9IGZ1bmN0aW9uIChldmVudHMsIGV4dHJhUGFyYW1zLCBtYW51YWxDYWxsYmFjaykge1xuICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVycztcbiAgICB2YXIgbnVtTGlzdGVuZXJzQmVmb3JlRW1pdCA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgdGhpcy5lbWl0dGluZysrO1xuXG4gICAgaWYgKCFhcnJheShleHRyYVBhcmFtcykpIHtcbiAgICAgIGV4dHJhUGFyYW1zID0gW2V4dHJhUGFyYW1zXTtcbiAgICB9XG5cbiAgICBmb3JFYWNoRXZlbnRPYmoodGhpcywgZnVuY3Rpb24gKHNlbGYsIGV2ZW50T2JqKSB7XG4gICAgICBpZiAobWFudWFsQ2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICBsaXN0ZW5lcnMgPSBbe1xuICAgICAgICAgIGV2ZW50OiBldmVudE9iai5ldmVudCxcbiAgICAgICAgICB0eXBlOiBldmVudE9iai50eXBlLFxuICAgICAgICAgIG5hbWVzcGFjZTogZXZlbnRPYmoubmFtZXNwYWNlLFxuICAgICAgICAgIGNhbGxiYWNrOiBtYW51YWxDYWxsYmFja1xuICAgICAgICB9XTtcbiAgICAgICAgbnVtTGlzdGVuZXJzQmVmb3JlRW1pdCA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIHZhciBfbG9vcDIgPSBmdW5jdGlvbiBfbG9vcDIoaSkge1xuICAgICAgICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lcnNbaV07XG5cbiAgICAgICAgaWYgKGxpc3RlbmVyLnR5cGUgPT09IGV2ZW50T2JqLnR5cGUgJiYgKCFsaXN0ZW5lci5uYW1lc3BhY2UgfHwgbGlzdGVuZXIubmFtZXNwYWNlID09PSBldmVudE9iai5uYW1lc3BhY2UgfHwgbGlzdGVuZXIubmFtZXNwYWNlID09PSB1bml2ZXJzYWxOYW1lc3BhY2UpICYmIHNlbGYuZXZlbnRNYXRjaGVzKHNlbGYuY29udGV4dCwgbGlzdGVuZXIsIGV2ZW50T2JqKSkge1xuICAgICAgICAgIHZhciBhcmdzID0gW2V2ZW50T2JqXTtcblxuICAgICAgICAgIGlmIChleHRyYVBhcmFtcyAhPSBudWxsKSB7XG4gICAgICAgICAgICBwdXNoKGFyZ3MsIGV4dHJhUGFyYW1zKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZWxmLmJlZm9yZUVtaXQoc2VsZi5jb250ZXh0LCBsaXN0ZW5lciwgZXZlbnRPYmopO1xuXG4gICAgICAgICAgaWYgKGxpc3RlbmVyLmNvbmYgJiYgbGlzdGVuZXIuY29uZi5vbmUpIHtcbiAgICAgICAgICAgIHNlbGYubGlzdGVuZXJzID0gc2VsZi5saXN0ZW5lcnMuZmlsdGVyKGZ1bmN0aW9uIChsKSB7XG4gICAgICAgICAgICAgIHJldHVybiBsICE9PSBsaXN0ZW5lcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBjb250ZXh0ID0gc2VsZi5jYWxsYmFja0NvbnRleHQoc2VsZi5jb250ZXh0LCBsaXN0ZW5lciwgZXZlbnRPYmopO1xuICAgICAgICAgIHZhciByZXQgPSBsaXN0ZW5lci5jYWxsYmFjay5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgICBzZWxmLmFmdGVyRW1pdChzZWxmLmNvbnRleHQsIGxpc3RlbmVyLCBldmVudE9iaik7XG5cbiAgICAgICAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgZXZlbnRPYmouc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBldmVudE9iai5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBpZiBsaXN0ZW5lciBtYXRjaGVzXG5cbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTGlzdGVuZXJzQmVmb3JlRW1pdDsgaSsrKSB7XG4gICAgICAgIF9sb29wMihpKTtcbiAgICAgIH0gLy8gZm9yIGxpc3RlbmVyXG5cblxuICAgICAgaWYgKHNlbGYuYnViYmxlKHNlbGYuY29udGV4dCkgJiYgIWV2ZW50T2JqLmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcbiAgICAgICAgc2VsZi5wYXJlbnQoc2VsZi5jb250ZXh0KS5lbWl0KGV2ZW50T2JqLCBleHRyYVBhcmFtcyk7XG4gICAgICB9XG4gICAgfSwgZXZlbnRzKTtcbiAgICB0aGlzLmVtaXR0aW5nLS07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdmFyIGVtaXR0ZXJPcHRpb25zJDEgPSB7XG4gICAgcXVhbGlmaWVyQ29tcGFyZTogZnVuY3Rpb24gcXVhbGlmaWVyQ29tcGFyZShzZWxlY3RvcjEsIHNlbGVjdG9yMikge1xuICAgICAgaWYgKHNlbGVjdG9yMSA9PSBudWxsIHx8IHNlbGVjdG9yMiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzZWxlY3RvcjEgPT0gbnVsbCAmJiBzZWxlY3RvcjIgPT0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzZWxlY3RvcjEuc2FtZVRleHQoc2VsZWN0b3IyKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGV2ZW50TWF0Y2hlczogZnVuY3Rpb24gZXZlbnRNYXRjaGVzKGVsZSwgbGlzdGVuZXIsIGV2ZW50T2JqKSB7XG4gICAgICB2YXIgc2VsZWN0b3IgPSBsaXN0ZW5lci5xdWFsaWZpZXI7XG5cbiAgICAgIGlmIChzZWxlY3RvciAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBlbGUgIT09IGV2ZW50T2JqLnRhcmdldCAmJiBlbGVtZW50KGV2ZW50T2JqLnRhcmdldCkgJiYgc2VsZWN0b3IubWF0Y2hlcyhldmVudE9iai50YXJnZXQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGFkZEV2ZW50RmllbGRzOiBmdW5jdGlvbiBhZGRFdmVudEZpZWxkcyhlbGUsIGV2dCkge1xuICAgICAgZXZ0LmN5ID0gZWxlLmN5KCk7XG4gICAgICBldnQudGFyZ2V0ID0gZWxlO1xuICAgIH0sXG4gICAgY2FsbGJhY2tDb250ZXh0OiBmdW5jdGlvbiBjYWxsYmFja0NvbnRleHQoZWxlLCBsaXN0ZW5lciwgZXZlbnRPYmopIHtcbiAgICAgIHJldHVybiBsaXN0ZW5lci5xdWFsaWZpZXIgIT0gbnVsbCA/IGV2ZW50T2JqLnRhcmdldCA6IGVsZTtcbiAgICB9LFxuICAgIGJlZm9yZUVtaXQ6IGZ1bmN0aW9uIGJlZm9yZUVtaXQoY29udGV4dCwgbGlzdGVuZXJcbiAgICAvKiwgZXZlbnRPYmoqL1xuICAgICkge1xuICAgICAgaWYgKGxpc3RlbmVyLmNvbmYgJiYgbGlzdGVuZXIuY29uZi5vbmNlKSB7XG4gICAgICAgIGxpc3RlbmVyLmNvbmYub25jZUNvbGxlY3Rpb24ucmVtb3ZlTGlzdGVuZXIobGlzdGVuZXIuZXZlbnQsIGxpc3RlbmVyLnF1YWxpZmllciwgbGlzdGVuZXIuY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH0sXG4gICAgYnViYmxlOiBmdW5jdGlvbiBidWJibGUoKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIHBhcmVudDogZnVuY3Rpb24gcGFyZW50KGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5pc0NoaWxkKCkgPyBlbGUucGFyZW50KCkgOiBlbGUuY3koKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGFyZ1NlbGVjdG9yJDEgPSBmdW5jdGlvbiBhcmdTZWxlY3RvcihhcmcpIHtcbiAgICBpZiAoc3RyaW5nKGFyZykpIHtcbiAgICAgIHJldHVybiBuZXcgU2VsZWN0b3IoYXJnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFyZztcbiAgICB9XG4gIH07XG5cbiAgdmFyIGVsZXNmbiQ5ID0ge1xuICAgIGNyZWF0ZUVtaXR0ZXI6IGZ1bmN0aW9uIGNyZWF0ZUVtaXR0ZXIoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcblxuICAgICAgICBpZiAoIV9wLmVtaXR0ZXIpIHtcbiAgICAgICAgICBfcC5lbWl0dGVyID0gbmV3IEVtaXR0ZXIoZW1pdHRlck9wdGlvbnMkMSwgZWxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGVtaXR0ZXI6IGZ1bmN0aW9uIGVtaXR0ZXIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5lbWl0dGVyO1xuICAgIH0sXG4gICAgb246IGZ1bmN0aW9uIG9uKGV2ZW50cywgc2VsZWN0b3IsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgYXJnU2VsID0gYXJnU2VsZWN0b3IkMShzZWxlY3Rvcik7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgICAgZWxlLmVtaXR0ZXIoKS5vbihldmVudHMsIGFyZ1NlbCwgY2FsbGJhY2spO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHJlbW92ZUxpc3RlbmVyOiBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihldmVudHMsIHNlbGVjdG9yLCBjYWxsYmFjaykge1xuICAgICAgdmFyIGFyZ1NlbCA9IGFyZ1NlbGVjdG9yJDEoc2VsZWN0b3IpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICAgIGVsZS5lbWl0dGVyKCkucmVtb3ZlTGlzdGVuZXIoZXZlbnRzLCBhcmdTZWwsIGNhbGxiYWNrKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICByZW1vdmVBbGxMaXN0ZW5lcnM6IGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycygpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgICAgZWxlLmVtaXR0ZXIoKS5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBvbmU6IGZ1bmN0aW9uIG9uZShldmVudHMsIHNlbGVjdG9yLCBjYWxsYmFjaykge1xuICAgICAgdmFyIGFyZ1NlbCA9IGFyZ1NlbGVjdG9yJDEoc2VsZWN0b3IpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICAgIGVsZS5lbWl0dGVyKCkub25lKGV2ZW50cywgYXJnU2VsLCBjYWxsYmFjayk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgb25jZTogZnVuY3Rpb24gb25jZShldmVudHMsIHNlbGVjdG9yLCBjYWxsYmFjaykge1xuICAgICAgdmFyIGFyZ1NlbCA9IGFyZ1NlbGVjdG9yJDEoc2VsZWN0b3IpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICAgIGVsZS5lbWl0dGVyKCkub24oZXZlbnRzLCBhcmdTZWwsIGNhbGxiYWNrLCB7XG4gICAgICAgICAgb25jZTogdHJ1ZSxcbiAgICAgICAgICBvbmNlQ29sbGVjdGlvbjogdGhpc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGVtaXQ6IGZ1bmN0aW9uIGVtaXQoZXZlbnRzLCBleHRyYVBhcmFtcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgICBlbGUuZW1pdHRlcigpLmVtaXQoZXZlbnRzLCBleHRyYVBhcmFtcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZW1pdEFuZE5vdGlmeTogZnVuY3Rpb24gZW1pdEFuZE5vdGlmeShldmVudCwgZXh0cmFQYXJhbXMpIHtcbiAgICAgIC8vIGZvciBpbnRlcm5hbCB1c2Ugb25seVxuICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gZW1wdHkgY29sbGVjdGlvbnMgZG9uJ3QgbmVlZCB0byBub3RpZnkgYW55dGhpbmdcbiAgICAgIC8vIG5vdGlmeSByZW5kZXJlclxuXG5cbiAgICAgIHRoaXMuY3koKS5ub3RpZnkoZXZlbnQsIHRoaXMpO1xuICAgICAgdGhpcy5lbWl0KGV2ZW50LCBleHRyYVBhcmFtcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG4gIGRlZmluZS5ldmVudEFsaWFzZXNPbihlbGVzZm4kOSk7XG5cbiAgdmFyIGVsZXNmbiQ4ID0ge1xuICAgIG5vZGVzOiBmdW5jdGlvbiBub2RlcyhzZWxlY3Rvcikge1xuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgcmV0dXJuIGVsZS5pc05vZGUoKTtcbiAgICAgIH0pLmZpbHRlcihzZWxlY3Rvcik7XG4gICAgfSxcbiAgICBlZGdlczogZnVuY3Rpb24gZWRnZXMoc2VsZWN0b3IpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgIHJldHVybiBlbGUuaXNFZGdlKCk7XG4gICAgICB9KS5maWx0ZXIoc2VsZWN0b3IpO1xuICAgIH0sXG4gICAgLy8gaW50ZXJuYWwgaGVscGVyIHRvIGdldCBub2RlcyBhbmQgZWRnZXMgYXMgc2VwYXJhdGUgY29sbGVjdGlvbnMgd2l0aCBzaW5nbGUgaXRlcmF0aW9uIG92ZXIgZWxlbWVudHNcbiAgICBieUdyb3VwOiBmdW5jdGlvbiBieUdyb3VwKCkge1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5zcGF3bigpO1xuICAgICAgdmFyIGVkZ2VzID0gdGhpcy5zcGF3bigpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG5cbiAgICAgICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgICAgIG5vZGVzLnB1c2goZWxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlZGdlcy5wdXNoKGVsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbm9kZXM6IG5vZGVzLFxuICAgICAgICBlZGdlczogZWRnZXNcbiAgICAgIH07XG4gICAgfSxcbiAgICBmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcihfZmlsdGVyLCB0aGlzQXJnKSB7XG4gICAgICBpZiAoX2ZpbHRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIGNoZWNrIHRoaXMgZmlyc3QgYi9jIGl0J3MgdGhlIG1vc3QgY29tbW9uL3BlcmZvcm1hbnQgY2FzZVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gZWxzZSBpZiAoc3RyaW5nKF9maWx0ZXIpIHx8IGVsZW1lbnRPckNvbGxlY3Rpb24oX2ZpbHRlcikpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZWxlY3RvcihfZmlsdGVyKS5maWx0ZXIodGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKGZuJDYoX2ZpbHRlcikpIHtcbiAgICAgICAgdmFyIGZpbHRlckVsZXMgPSB0aGlzLnNwYXduKCk7XG4gICAgICAgIHZhciBlbGVzID0gdGhpcztcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgICAgICB2YXIgaW5jbHVkZSA9IHRoaXNBcmcgPyBfZmlsdGVyLmFwcGx5KHRoaXNBcmcsIFtlbGUsIGksIGVsZXNdKSA6IF9maWx0ZXIoZWxlLCBpLCBlbGVzKTtcblxuICAgICAgICAgIGlmIChpbmNsdWRlKSB7XG4gICAgICAgICAgICBmaWx0ZXJFbGVzLnB1c2goZWxlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmlsdGVyRWxlcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuc3Bhd24oKTsgLy8gaWYgbm90IGhhbmRsZWQgYnkgYWJvdmUsIGdpdmUgJ2VtIGFuIGVtcHR5IGNvbGxlY3Rpb25cbiAgICB9LFxuICAgIG5vdDogZnVuY3Rpb24gbm90KHRvUmVtb3ZlKSB7XG4gICAgICBpZiAoIXRvUmVtb3ZlKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHN0cmluZyh0b1JlbW92ZSkpIHtcbiAgICAgICAgICB0b1JlbW92ZSA9IHRoaXMuZmlsdGVyKHRvUmVtb3ZlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbGVtZW50cyA9IHRoaXMuc3Bhd24oKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXNbaV07XG4gICAgICAgICAgdmFyIHJlbW92ZSA9IHRvUmVtb3ZlLmhhcyhlbGVtZW50KTtcblxuICAgICAgICAgIGlmICghcmVtb3ZlKSB7XG4gICAgICAgICAgICBlbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlbGVtZW50cztcbiAgICAgIH1cbiAgICB9LFxuICAgIGFic29sdXRlQ29tcGxlbWVudDogZnVuY3Rpb24gYWJzb2x1dGVDb21wbGVtZW50KCkge1xuICAgICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgICAgcmV0dXJuIGN5Lm11dGFibGVFbGVtZW50cygpLm5vdCh0aGlzKTtcbiAgICB9LFxuICAgIGludGVyc2VjdDogZnVuY3Rpb24gaW50ZXJzZWN0KG90aGVyKSB7XG4gICAgICAvLyBpZiBhIHNlbGVjdG9yIGlzIHNwZWNpZmllZCwgdGhlbiBmaWx0ZXIgYnkgaXQgaW5zdGVhZFxuICAgICAgaWYgKHN0cmluZyhvdGhlcikpIHtcbiAgICAgICAgdmFyIHNlbGVjdG9yID0gb3RoZXI7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbHRlcihzZWxlY3Rvcik7XG4gICAgICB9XG5cbiAgICAgIHZhciBlbGVtZW50cyA9IHRoaXMuc3Bhd24oKTtcbiAgICAgIHZhciBjb2wxID0gdGhpcztcbiAgICAgIHZhciBjb2wyID0gb3RoZXI7XG4gICAgICB2YXIgY29sMVNtYWxsZXIgPSB0aGlzLmxlbmd0aCA8IG90aGVyLmxlbmd0aDtcbiAgICAgIHZhciBjb2xTID0gY29sMVNtYWxsZXIgPyBjb2wxIDogY29sMjtcbiAgICAgIHZhciBjb2xMID0gY29sMVNtYWxsZXIgPyBjb2wyIDogY29sMTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xTLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSBjb2xTW2ldO1xuXG4gICAgICAgIGlmIChjb2xMLmhhcyhlbGUpKSB7XG4gICAgICAgICAgZWxlbWVudHMucHVzaChlbGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbGVtZW50cztcbiAgICB9LFxuICAgIHhvcjogZnVuY3Rpb24geG9yKG90aGVyKSB7XG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuXG4gICAgICBpZiAoc3RyaW5nKG90aGVyKSkge1xuICAgICAgICBvdGhlciA9IGN5LiQob3RoZXIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLnNwYXduKCk7XG4gICAgICB2YXIgY29sMSA9IHRoaXM7XG4gICAgICB2YXIgY29sMiA9IG90aGVyO1xuXG4gICAgICB2YXIgYWRkID0gZnVuY3Rpb24gYWRkKGNvbCwgb3RoZXIpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2wubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZWxlID0gY29sW2ldO1xuICAgICAgICAgIHZhciBpZCA9IGVsZS5fcHJpdmF0ZS5kYXRhLmlkO1xuICAgICAgICAgIHZhciBpbk90aGVyID0gb3RoZXIuaGFzRWxlbWVudFdpdGhJZChpZCk7XG5cbiAgICAgICAgICBpZiAoIWluT3RoZXIpIHtcbiAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goZWxlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGFkZChjb2wxLCBjb2wyKTtcbiAgICAgIGFkZChjb2wyLCBjb2wxKTtcbiAgICAgIHJldHVybiBlbGVtZW50cztcbiAgICB9LFxuICAgIGRpZmY6IGZ1bmN0aW9uIGRpZmYob3RoZXIpIHtcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG5cbiAgICAgIGlmIChzdHJpbmcob3RoZXIpKSB7XG4gICAgICAgIG90aGVyID0gY3kuJChvdGhlcik7XG4gICAgICB9XG5cbiAgICAgIHZhciBsZWZ0ID0gdGhpcy5zcGF3bigpO1xuICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5zcGF3bigpO1xuICAgICAgdmFyIGJvdGggPSB0aGlzLnNwYXduKCk7XG4gICAgICB2YXIgY29sMSA9IHRoaXM7XG4gICAgICB2YXIgY29sMiA9IG90aGVyO1xuXG4gICAgICB2YXIgYWRkID0gZnVuY3Rpb24gYWRkKGNvbCwgb3RoZXIsIHJldEVsZXMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2wubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZWxlID0gY29sW2ldO1xuICAgICAgICAgIHZhciBpZCA9IGVsZS5fcHJpdmF0ZS5kYXRhLmlkO1xuICAgICAgICAgIHZhciBpbk90aGVyID0gb3RoZXIuaGFzRWxlbWVudFdpdGhJZChpZCk7XG5cbiAgICAgICAgICBpZiAoaW5PdGhlcikge1xuICAgICAgICAgICAgYm90aC5tZXJnZShlbGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXRFbGVzLnB1c2goZWxlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGFkZChjb2wxLCBjb2wyLCBsZWZ0KTtcbiAgICAgIGFkZChjb2wyLCBjb2wxLCByaWdodCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICByaWdodDogcmlnaHQsXG4gICAgICAgIGJvdGg6IGJvdGhcbiAgICAgIH07XG4gICAgfSxcbiAgICBhZGQ6IGZ1bmN0aW9uIGFkZCh0b0FkZCkge1xuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcblxuICAgICAgaWYgKCF0b0FkZCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgaWYgKHN0cmluZyh0b0FkZCkpIHtcbiAgICAgICAgdmFyIHNlbGVjdG9yID0gdG9BZGQ7XG4gICAgICAgIHRvQWRkID0gY3kubXV0YWJsZUVsZW1lbnRzKCkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVsZW1lbnRzID0gdGhpcy5zcGF3blNlbGYoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b0FkZC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gdG9BZGRbaV07XG4gICAgICAgIHZhciBhZGQgPSAhdGhpcy5oYXMoZWxlKTtcblxuICAgICAgICBpZiAoYWRkKSB7XG4gICAgICAgICAgZWxlbWVudHMucHVzaChlbGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbGVtZW50cztcbiAgICB9LFxuICAgIC8vIGluIHBsYWNlIG1lcmdlIG9uIGNhbGxpbmcgY29sbGVjdGlvblxuICAgIG1lcmdlOiBmdW5jdGlvbiBtZXJnZSh0b0FkZCkge1xuICAgICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICAgIHZhciBjeSA9IF9wLmN5O1xuXG4gICAgICBpZiAoIXRvQWRkKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBpZiAodG9BZGQgJiYgc3RyaW5nKHRvQWRkKSkge1xuICAgICAgICB2YXIgc2VsZWN0b3IgPSB0b0FkZDtcbiAgICAgICAgdG9BZGQgPSBjeS5tdXRhYmxlRWxlbWVudHMoKS5maWx0ZXIoc2VsZWN0b3IpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWFwID0gX3AubWFwO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvQWRkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0b0FkZEVsZSA9IHRvQWRkW2ldO1xuICAgICAgICB2YXIgaWQgPSB0b0FkZEVsZS5fcHJpdmF0ZS5kYXRhLmlkO1xuICAgICAgICB2YXIgYWRkID0gIW1hcC5oYXMoaWQpO1xuXG4gICAgICAgIGlmIChhZGQpIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmxlbmd0aCsrO1xuICAgICAgICAgIHRoaXNbaW5kZXhdID0gdG9BZGRFbGU7XG4gICAgICAgICAgbWFwLnNldChpZCwge1xuICAgICAgICAgICAgZWxlOiB0b0FkZEVsZSxcbiAgICAgICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG4gICAgdW5tZXJnZUF0OiBmdW5jdGlvbiB1bm1lcmdlQXQoaSkge1xuICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICB2YXIgaWQgPSBlbGUuaWQoKTtcbiAgICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgICB2YXIgbWFwID0gX3AubWFwOyAvLyByZW1vdmUgZWxlXG5cbiAgICAgIHRoaXNbaV0gPSB1bmRlZmluZWQ7XG4gICAgICBtYXBbXCJkZWxldGVcIl0oaWQpO1xuICAgICAgdmFyIHVubWVyZ2VkTGFzdEVsZSA9IGkgPT09IHRoaXMubGVuZ3RoIC0gMTsgLy8gcmVwbGFjZSBlbXB0eSBzcG90IHdpdGggbGFzdCBlbGUgaW4gY29sbGVjdGlvblxuXG4gICAgICBpZiAodGhpcy5sZW5ndGggPiAxICYmICF1bm1lcmdlZExhc3RFbGUpIHtcbiAgICAgICAgdmFyIGxhc3RFbGVJID0gdGhpcy5sZW5ndGggLSAxO1xuICAgICAgICB2YXIgbGFzdEVsZSA9IHRoaXNbbGFzdEVsZUldO1xuICAgICAgICB2YXIgbGFzdEVsZUlkID0gbGFzdEVsZS5fcHJpdmF0ZS5kYXRhLmlkO1xuICAgICAgICB0aGlzW2xhc3RFbGVJXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpc1tpXSA9IGxhc3RFbGU7XG4gICAgICAgIG1hcC5zZXQobGFzdEVsZUlkLCB7XG4gICAgICAgICAgZWxlOiBsYXN0RWxlLFxuICAgICAgICAgIGluZGV4OiBpXG4gICAgICAgIH0pO1xuICAgICAgfSAvLyB0aGUgY29sbGVjdGlvbiBpcyBub3cgMSBlbGUgc21hbGxlclxuXG5cbiAgICAgIHRoaXMubGVuZ3RoLS07XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8vIHJlbW92ZSBzaW5nbGUgZWxlIGluIHBsYWNlIGluIGNhbGxpbmcgY29sbGVjdGlvblxuICAgIHVubWVyZ2VPbmU6IGZ1bmN0aW9uIHVubWVyZ2VPbmUoZWxlKSB7XG4gICAgICBlbGUgPSBlbGVbMF07XG4gICAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgICAgdmFyIGlkID0gZWxlLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgICB2YXIgbWFwID0gX3AubWFwO1xuICAgICAgdmFyIGVudHJ5ID0gbWFwLmdldChpZCk7XG5cbiAgICAgIGlmICghZW50cnkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7IC8vIG5vIG5lZWQgdG8gcmVtb3ZlXG4gICAgICB9XG5cbiAgICAgIHZhciBpID0gZW50cnkuaW5kZXg7XG4gICAgICB0aGlzLnVubWVyZ2VBdChpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLy8gcmVtb3ZlIGVsZXMgaW4gcGxhY2Ugb24gY2FsbGluZyBjb2xsZWN0aW9uXG4gICAgdW5tZXJnZTogZnVuY3Rpb24gdW5tZXJnZSh0b1JlbW92ZSkge1xuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcblxuICAgICAgaWYgKCF0b1JlbW92ZSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgaWYgKHRvUmVtb3ZlICYmIHN0cmluZyh0b1JlbW92ZSkpIHtcbiAgICAgICAgdmFyIHNlbGVjdG9yID0gdG9SZW1vdmU7XG4gICAgICAgIHRvUmVtb3ZlID0gY3kubXV0YWJsZUVsZW1lbnRzKCkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b1JlbW92ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnVubWVyZ2VPbmUodG9SZW1vdmVbaV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuICAgIHVubWVyZ2VCeTogZnVuY3Rpb24gdW5tZXJnZUJ5KHRvUm1Gbikge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG5cbiAgICAgICAgaWYgKHRvUm1GbihlbGUpKSB7XG4gICAgICAgICAgdGhpcy51bm1lcmdlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBtYXA6IGZ1bmN0aW9uIG1hcChtYXBGbiwgdGhpc0FyZykge1xuICAgICAgdmFyIGFyciA9IFtdO1xuICAgICAgdmFyIGVsZXMgPSB0aGlzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICAgIHZhciByZXQgPSB0aGlzQXJnID8gbWFwRm4uYXBwbHkodGhpc0FyZywgW2VsZSwgaSwgZWxlc10pIDogbWFwRm4oZWxlLCBpLCBlbGVzKTtcbiAgICAgICAgYXJyLnB1c2gocmV0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFycjtcbiAgICB9LFxuICAgIHJlZHVjZTogZnVuY3Rpb24gcmVkdWNlKGZuLCBpbml0aWFsVmFsdWUpIHtcbiAgICAgIHZhciB2YWwgPSBpbml0aWFsVmFsdWU7XG4gICAgICB2YXIgZWxlcyA9IHRoaXM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YWwgPSBmbih2YWwsIGVsZXNbaV0sIGksIGVsZXMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsO1xuICAgIH0sXG4gICAgbWF4OiBmdW5jdGlvbiBtYXgodmFsRm4sIHRoaXNBcmcpIHtcbiAgICAgIHZhciBtYXggPSAtSW5maW5pdHk7XG4gICAgICB2YXIgbWF4RWxlO1xuICAgICAgdmFyIGVsZXMgPSB0aGlzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICAgIHZhciB2YWwgPSB0aGlzQXJnID8gdmFsRm4uYXBwbHkodGhpc0FyZywgW2VsZSwgaSwgZWxlc10pIDogdmFsRm4oZWxlLCBpLCBlbGVzKTtcblxuICAgICAgICBpZiAodmFsID4gbWF4KSB7XG4gICAgICAgICAgbWF4ID0gdmFsO1xuICAgICAgICAgIG1heEVsZSA9IGVsZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogbWF4LFxuICAgICAgICBlbGU6IG1heEVsZVxuICAgICAgfTtcbiAgICB9LFxuICAgIG1pbjogZnVuY3Rpb24gbWluKHZhbEZuLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgbWluID0gSW5maW5pdHk7XG4gICAgICB2YXIgbWluRWxlO1xuICAgICAgdmFyIGVsZXMgPSB0aGlzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICAgIHZhciB2YWwgPSB0aGlzQXJnID8gdmFsRm4uYXBwbHkodGhpc0FyZywgW2VsZSwgaSwgZWxlc10pIDogdmFsRm4oZWxlLCBpLCBlbGVzKTtcblxuICAgICAgICBpZiAodmFsIDwgbWluKSB7XG4gICAgICAgICAgbWluID0gdmFsO1xuICAgICAgICAgIG1pbkVsZSA9IGVsZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogbWluLFxuICAgICAgICBlbGU6IG1pbkVsZVxuICAgICAgfTtcbiAgICB9XG4gIH07IC8vIGFsaWFzZXNcblxuICB2YXIgZm4kMSA9IGVsZXNmbiQ4O1xuICBmbiQxWyd1J10gPSBmbiQxWyd8J10gPSBmbiQxWycrJ10gPSBmbiQxLnVuaW9uID0gZm4kMS5vciA9IGZuJDEuYWRkO1xuICBmbiQxWydcXFxcJ10gPSBmbiQxWychJ10gPSBmbiQxWyctJ10gPSBmbiQxLmRpZmZlcmVuY2UgPSBmbiQxLnJlbGF0aXZlQ29tcGxlbWVudCA9IGZuJDEuc3VidHJhY3QgPSBmbiQxLm5vdDtcbiAgZm4kMVsnbiddID0gZm4kMVsnJiddID0gZm4kMVsnLiddID0gZm4kMS5hbmQgPSBmbiQxLmludGVyc2VjdGlvbiA9IGZuJDEuaW50ZXJzZWN0O1xuICBmbiQxWydeJ10gPSBmbiQxWycoKyknXSA9IGZuJDFbJygtKSddID0gZm4kMS5zeW1tZXRyaWNEaWZmZXJlbmNlID0gZm4kMS5zeW1kaWZmID0gZm4kMS54b3I7XG4gIGZuJDEuZm5GaWx0ZXIgPSBmbiQxLmZpbHRlckZuID0gZm4kMS5zdGRGaWx0ZXIgPSBmbiQxLmZpbHRlcjtcbiAgZm4kMS5jb21wbGVtZW50ID0gZm4kMS5hYnNjb21wID0gZm4kMS5hYnNvbHV0ZUNvbXBsZW1lbnQ7XG5cbiAgdmFyIGVsZXNmbiQ3ID0ge1xuICAgIGlzTm9kZTogZnVuY3Rpb24gaXNOb2RlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ3JvdXAoKSA9PT0gJ25vZGVzJztcbiAgICB9LFxuICAgIGlzRWRnZTogZnVuY3Rpb24gaXNFZGdlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ3JvdXAoKSA9PT0gJ2VkZ2VzJztcbiAgICB9LFxuICAgIGlzTG9vcDogZnVuY3Rpb24gaXNMb29wKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNFZGdlKCkgJiYgdGhpcy5zb3VyY2UoKVswXSA9PT0gdGhpcy50YXJnZXQoKVswXTtcbiAgICB9LFxuICAgIGlzU2ltcGxlOiBmdW5jdGlvbiBpc1NpbXBsZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzRWRnZSgpICYmIHRoaXMuc291cmNlKClbMF0gIT09IHRoaXMudGFyZ2V0KClbMF07XG4gICAgfSxcbiAgICBncm91cDogZnVuY3Rpb24gZ3JvdXAoKSB7XG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgICAgaWYgKGVsZSkge1xuICAgICAgICByZXR1cm4gZWxlLl9wcml2YXRlLmdyb3VwO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogIEVsZW1lbnRzIGFyZSBkcmF3biBpbiBhIHNwZWNpZmljIG9yZGVyIGJhc2VkIG9uIGNvbXBvdW5kIGRlcHRoIChsb3cgdG8gaGlnaCksIHRoZSBlbGVtZW50IHR5cGUgKG5vZGVzIGFib3ZlIGVkZ2VzKSxcbiAgICogIGFuZCB6LWluZGV4IChsb3cgdG8gaGlnaCkuICBUaGVzZSBzdHlsZXMgYWZmZWN0IGhvdyB0aGlzIGFwcGxpZXM6XG4gICAqXG4gICAqICB6LWNvbXBvdW5kLWRlcHRoOiBNYXkgYmUgYGJvdHRvbSB8IG9ycGhhbiB8IGF1dG8gfCB0b3BgLiAgVGhlIGZpcnN0IGRyYXduIGlzIGBib3R0b21gLCB0aGVuIGBvcnBoYW5gIHdoaWNoIGlzIHRoZVxuICAgKiAgICAgIHNhbWUgZGVwdGggYXMgdGhlIHJvb3Qgb2YgdGhlIGNvbXBvdW5kIGdyYXBoLCBmb2xsb3dlZCBieSB0aGUgZGVmYXVsdCB2YWx1ZSBgYXV0b2Agd2hpY2ggZHJhd3MgaW4gb3JkZXIgZnJvbVxuICAgKiAgICAgIHJvb3QgdG8gbGVhdmVzIG9mIHRoZSBjb21wb3VuZCBncmFwaC4gIFRoZSBsYXN0IGRyYXduIGlzIGB0b3BgLlxuICAgKiAgei1pbmRleC1jb21wYXJlOiBNYXkgYmUgYGF1dG8gfCBtYW51YWxgLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgYGF1dG9gIHdoaWNoIGFsd2F5cyBkcmF3cyBlZGdlcyB1bmRlciBub2Rlcy5cbiAgICogICAgICBgbWFudWFsYCBpZ25vcmVzIHRoaXMgY29udmVudGlvbiBhbmQgZHJhd3MgYmFzZWQgb24gdGhlIGB6LWluZGV4YCB2YWx1ZSBzZXR0aW5nLlxuICAgKiAgei1pbmRleDogQW4gaW50ZWdlciB2YWx1ZSB0aGF0IGFmZmVjdHMgdGhlIHJlbGF0aXZlIGRyYXcgb3JkZXIgb2YgZWxlbWVudHMuICBJbiBnZW5lcmFsLCBhbiBlbGVtZW50IHdpdGggYSBoaWdoZXJcbiAgICogICAgICBgei1pbmRleGAgd2lsbCBiZSBkcmF3biBvbiB0b3Agb2YgYW4gZWxlbWVudCB3aXRoIGEgbG93ZXIgYHotaW5kZXhgLlxuICAgKi9cblxuICB2YXIgekluZGV4U29ydCA9IGZ1bmN0aW9uIHpJbmRleFNvcnQoYSwgYikge1xuICAgIHZhciBjeSA9IGEuY3koKTtcbiAgICB2YXIgaGFzQ29tcG91bmROb2RlcyA9IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcblxuICAgIGZ1bmN0aW9uIGdldERlcHRoKGVsZSkge1xuICAgICAgdmFyIHN0eWxlID0gZWxlLnBzdHlsZSgnei1jb21wb3VuZC1kZXB0aCcpO1xuXG4gICAgICBpZiAoc3R5bGUudmFsdWUgPT09ICdhdXRvJykge1xuICAgICAgICByZXR1cm4gaGFzQ29tcG91bmROb2RlcyA/IGVsZS56RGVwdGgoKSA6IDA7XG4gICAgICB9IGVsc2UgaWYgKHN0eWxlLnZhbHVlID09PSAnYm90dG9tJykge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9IGVsc2UgaWYgKHN0eWxlLnZhbHVlID09PSAndG9wJykge1xuICAgICAgICByZXR1cm4gTUFYX0lOVCQxO1xuICAgICAgfSAvLyAnb3JwaGFuJ1xuXG5cbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHZhciBkZXB0aERpZmYgPSBnZXREZXB0aChhKSAtIGdldERlcHRoKGIpO1xuXG4gICAgaWYgKGRlcHRoRGlmZiAhPT0gMCkge1xuICAgICAgcmV0dXJuIGRlcHRoRGlmZjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRFbGVEZXB0aChlbGUpIHtcbiAgICAgIHZhciBzdHlsZSA9IGVsZS5wc3R5bGUoJ3otaW5kZXgtY29tcGFyZScpO1xuXG4gICAgICBpZiAoc3R5bGUudmFsdWUgPT09ICdhdXRvJykge1xuICAgICAgICByZXR1cm4gZWxlLmlzTm9kZSgpID8gMSA6IDA7XG4gICAgICB9IC8vICdtYW51YWwnXG5cblxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgdmFyIGVsZURpZmYgPSBnZXRFbGVEZXB0aChhKSAtIGdldEVsZURlcHRoKGIpO1xuXG4gICAgaWYgKGVsZURpZmYgIT09IDApIHtcbiAgICAgIHJldHVybiBlbGVEaWZmO1xuICAgIH1cblxuICAgIHZhciB6RGlmZiA9IGEucHN0eWxlKCd6LWluZGV4JykudmFsdWUgLSBiLnBzdHlsZSgnei1pbmRleCcpLnZhbHVlO1xuXG4gICAgaWYgKHpEaWZmICE9PSAwKSB7XG4gICAgICByZXR1cm4gekRpZmY7XG4gICAgfSAvLyBjb21wYXJlIGluZGljZXMgaW4gdGhlIGNvcmUgKG9yZGVyIGFkZGVkIHRvIGdyYXBoIHcvIGxhc3Qgb24gdG9wKVxuXG5cbiAgICByZXR1cm4gYS5wb29sSW5kZXgoKSAtIGIucG9vbEluZGV4KCk7XG4gIH07XG5cbiAgdmFyIGVsZXNmbiQ2ID0ge1xuICAgIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goZm4sIHRoaXNBcmcpIHtcbiAgICAgIGlmIChmbiQ2KGZuKSkge1xuICAgICAgICB2YXIgTiA9IHRoaXMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICAgICAgdmFyIHJldCA9IHRoaXNBcmcgPyBmbi5hcHBseSh0aGlzQXJnLCBbZWxlLCBpLCB0aGlzXSkgOiBmbihlbGUsIGksIHRoaXMpO1xuXG4gICAgICAgICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gLy8gZXhpdCBlYWNoIGVhcmx5IG9uIHJldHVybiBmYWxzZVxuXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICB0b0FycmF5OiBmdW5jdGlvbiB0b0FycmF5KCkge1xuICAgICAgdmFyIGFycmF5ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJheS5wdXNoKHRoaXNbaV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfSxcbiAgICBzbGljZTogZnVuY3Rpb24gc2xpY2Uoc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIGFycmF5ID0gW107XG4gICAgICB2YXIgdGhpc1NpemUgPSB0aGlzLmxlbmd0aDtcblxuICAgICAgaWYgKGVuZCA9PSBudWxsKSB7XG4gICAgICAgIGVuZCA9IHRoaXNTaXplO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhcnQgPT0gbnVsbCkge1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgc3RhcnQgPSB0aGlzU2l6ZSArIHN0YXJ0O1xuICAgICAgfVxuXG4gICAgICBpZiAoZW5kIDwgMCkge1xuICAgICAgICBlbmQgPSB0aGlzU2l6ZSArIGVuZDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpID49IDAgJiYgaSA8IGVuZCAmJiBpIDwgdGhpc1NpemU7IGkrKykge1xuICAgICAgICBhcnJheS5wdXNoKHRoaXNbaV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5zcGF3bihhcnJheSk7XG4gICAgfSxcbiAgICBzaXplOiBmdW5jdGlvbiBzaXplKCkge1xuICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoO1xuICAgIH0sXG4gICAgZXE6IGZ1bmN0aW9uIGVxKGkpIHtcbiAgICAgIHJldHVybiB0aGlzW2ldIHx8IHRoaXMuc3Bhd24oKTtcbiAgICB9LFxuICAgIGZpcnN0OiBmdW5jdGlvbiBmaXJzdCgpIHtcbiAgICAgIHJldHVybiB0aGlzWzBdIHx8IHRoaXMuc3Bhd24oKTtcbiAgICB9LFxuICAgIGxhc3Q6IGZ1bmN0aW9uIGxhc3QoKSB7XG4gICAgICByZXR1cm4gdGhpc1t0aGlzLmxlbmd0aCAtIDFdIHx8IHRoaXMuc3Bhd24oKTtcbiAgICB9LFxuICAgIGVtcHR5OiBmdW5jdGlvbiBlbXB0eSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmxlbmd0aCA9PT0gMDtcbiAgICB9LFxuICAgIG5vbmVtcHR5OiBmdW5jdGlvbiBub25lbXB0eSgpIHtcbiAgICAgIHJldHVybiAhdGhpcy5lbXB0eSgpO1xuICAgIH0sXG4gICAgc29ydDogZnVuY3Rpb24gc29ydChzb3J0Rm4pIHtcbiAgICAgIGlmICghZm4kNihzb3J0Rm4pKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB2YXIgc29ydGVkID0gdGhpcy50b0FycmF5KCkuc29ydChzb3J0Rm4pO1xuICAgICAgcmV0dXJuIHRoaXMuc3Bhd24oc29ydGVkKTtcbiAgICB9LFxuICAgIHNvcnRCeVpJbmRleDogZnVuY3Rpb24gc29ydEJ5WkluZGV4KCkge1xuICAgICAgcmV0dXJuIHRoaXMuc29ydCh6SW5kZXhTb3J0KTtcbiAgICB9LFxuICAgIHpEZXB0aDogZnVuY3Rpb24gekRlcHRoKCkge1xuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICAgIGlmICghZWxlKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9IC8vIGxldCBjeSA9IGVsZS5jeSgpO1xuXG5cbiAgICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICAgIHZhciBncm91cCA9IF9wLmdyb3VwO1xuXG4gICAgICBpZiAoZ3JvdXAgPT09ICdub2RlcycpIHtcbiAgICAgICAgdmFyIGRlcHRoID0gX3AuZGF0YS5wYXJlbnQgPyBlbGUucGFyZW50cygpLnNpemUoKSA6IDA7XG5cbiAgICAgICAgaWYgKCFlbGUuaXNQYXJlbnQoKSkge1xuICAgICAgICAgIHJldHVybiBNQVhfSU5UJDEgLSAxOyAvLyBjaGlsZGxlc3Mgbm9kZXMgYWx3YXlzIG9uIHRvcFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlcHRoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHNyYyA9IF9wLnNvdXJjZTtcbiAgICAgICAgdmFyIHRndCA9IF9wLnRhcmdldDtcbiAgICAgICAgdmFyIHNyY0RlcHRoID0gc3JjLnpEZXB0aCgpO1xuICAgICAgICB2YXIgdGd0RGVwdGggPSB0Z3QuekRlcHRoKCk7XG4gICAgICAgIHJldHVybiBNYXRoLm1heChzcmNEZXB0aCwgdGd0RGVwdGgsIDApOyAvLyBkZXB0aCBvZiBkZWVwZXN0IHBhcmVudFxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgZWxlc2ZuJDYuZWFjaCA9IGVsZXNmbiQ2LmZvckVhY2g7XG5cbiAgdmFyIGRlZmluZVN5bWJvbEl0ZXJhdG9yID0gZnVuY3Rpb24gZGVmaW5lU3ltYm9sSXRlcmF0b3IoKSB7XG4gICAgdmFyIHR5cGVvZlVuZGVmID0gXCJ1bmRlZmluZWRcIiA7XG4gICAgdmFyIGlzSXRlcmF0b3JTdXBwb3J0ZWQgPSAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKFN5bWJvbCkpICE9IHR5cGVvZlVuZGVmICYmIF90eXBlb2YoU3ltYm9sLml0ZXJhdG9yKSAhPSB0eXBlb2ZVbmRlZjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4gICAgaWYgKGlzSXRlcmF0b3JTdXBwb3J0ZWQpIHtcbiAgICAgIGVsZXNmbiQ2W1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgICAgICB2YXIgZW50cnkgPSB7XG4gICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIF9kZWZpbmVQcm9wZXJ0eSQxKHtcbiAgICAgICAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgICAgaWYgKGkgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgZW50cnkudmFsdWUgPSBfdGhpc1tpKytdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZW50cnkudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIGVudHJ5LmRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZW50cnk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBTeW1ib2wuaXRlcmF0b3IsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9XG4gIH07XG5cbiAgZGVmaW5lU3ltYm9sSXRlcmF0b3IoKTtcblxuICB2YXIgZ2V0TGF5b3V0RGltZW5zaW9uT3B0aW9ucyA9IGRlZmF1bHRzJGcoe1xuICAgIG5vZGVEaW1lbnNpb25zSW5jbHVkZUxhYmVsczogZmFsc2VcbiAgfSk7XG4gIHZhciBlbGVzZm4kNSA9IHtcbiAgICAvLyBDYWxjdWxhdGVzIGFuZCByZXR1cm5zIG5vZGUgZGltZW5zaW9ucyB7IHgsIHkgfSBiYXNlZCBvbiBvcHRpb25zIGdpdmVuXG4gICAgbGF5b3V0RGltZW5zaW9uczogZnVuY3Rpb24gbGF5b3V0RGltZW5zaW9ucyhvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gZ2V0TGF5b3V0RGltZW5zaW9uT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgIHZhciBkaW1zO1xuXG4gICAgICBpZiAoIXRoaXMudGFrZXNVcFNwYWNlKCkpIHtcbiAgICAgICAgZGltcyA9IHtcbiAgICAgICAgICB3OiAwLFxuICAgICAgICAgIGg6IDBcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5ub2RlRGltZW5zaW9uc0luY2x1ZGVMYWJlbHMpIHtcbiAgICAgICAgdmFyIGJiRGltID0gdGhpcy5ib3VuZGluZ0JveCgpO1xuICAgICAgICBkaW1zID0ge1xuICAgICAgICAgIHc6IGJiRGltLncsXG4gICAgICAgICAgaDogYmJEaW0uaFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGltcyA9IHtcbiAgICAgICAgICB3OiB0aGlzLm91dGVyV2lkdGgoKSxcbiAgICAgICAgICBoOiB0aGlzLm91dGVySGVpZ2h0KClcbiAgICAgICAgfTtcbiAgICAgIH0gLy8gc2FuaXRpc2UgdGhlIGRpbWVuc2lvbnMgZm9yIGV4dGVybmFsIGxheW91dHMgKGF2b2lkIGRpdmlzaW9uIGJ5IHplcm8pXG5cblxuICAgICAgaWYgKGRpbXMudyA9PT0gMCB8fCBkaW1zLmggPT09IDApIHtcbiAgICAgICAgZGltcy53ID0gZGltcy5oID0gMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRpbXM7XG4gICAgfSxcbiAgICAvLyB1c2luZyBzdGFuZGFyZCBsYXlvdXQgb3B0aW9ucywgYXBwbHkgcG9zaXRpb24gZnVuY3Rpb24gKHcvIG9yIHcvbyBhbmltYXRpb24pXG4gICAgbGF5b3V0UG9zaXRpb25zOiBmdW5jdGlvbiBsYXlvdXRQb3NpdGlvbnMobGF5b3V0LCBvcHRpb25zLCBmbikge1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpLmZpbHRlcihmdW5jdGlvbiAobikge1xuICAgICAgICByZXR1cm4gIW4uaXNQYXJlbnQoKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgICAgdmFyIGxheW91dEVsZXMgPSBvcHRpb25zLmVsZXM7IC8vIG5vZGVzICYgZWRnZXNcblxuICAgICAgdmFyIGdldE1lbW9pemVLZXkgPSBmdW5jdGlvbiBnZXRNZW1vaXplS2V5KG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUuaWQoKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBmbk1lbSA9IG1lbW9pemUkMShmbiwgZ2V0TWVtb2l6ZUtleSk7IC8vIG1lbW9pemVkIHZlcnNpb24gb2YgcG9zaXRpb24gZnVuY3Rpb25cblxuICAgICAgbGF5b3V0LmVtaXQoe1xuICAgICAgICB0eXBlOiAnbGF5b3V0c3RhcnQnLFxuICAgICAgICBsYXlvdXQ6IGxheW91dFxuICAgICAgfSk7XG4gICAgICBsYXlvdXQuYW5pbWF0aW9ucyA9IFtdO1xuXG4gICAgICB2YXIgY2FsY3VsYXRlU3BhY2luZyA9IGZ1bmN0aW9uIGNhbGN1bGF0ZVNwYWNpbmcoc3BhY2luZywgbm9kZXNCYiwgcG9zKSB7XG4gICAgICAgIHZhciBjZW50ZXIgPSB7XG4gICAgICAgICAgeDogbm9kZXNCYi54MSArIG5vZGVzQmIudyAvIDIsXG4gICAgICAgICAgeTogbm9kZXNCYi55MSArIG5vZGVzQmIuaCAvIDJcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHNwYWNpbmdWZWN0b3IgPSB7XG4gICAgICAgICAgLy8gc2NhbGUgZnJvbSBjZW50ZXIgb2YgYm91bmRpbmcgYm94IChub3QgbmVjZXNzYXJpbHkgMCwwKVxuICAgICAgICAgIHg6IChwb3MueCAtIGNlbnRlci54KSAqIHNwYWNpbmcsXG4gICAgICAgICAgeTogKHBvcy55IC0gY2VudGVyLnkpICogc3BhY2luZ1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IGNlbnRlci54ICsgc3BhY2luZ1ZlY3Rvci54LFxuICAgICAgICAgIHk6IGNlbnRlci55ICsgc3BhY2luZ1ZlY3Rvci55XG4gICAgICAgIH07XG4gICAgICB9O1xuXG4gICAgICB2YXIgdXNlU3BhY2luZ0ZhY3RvciA9IG9wdGlvbnMuc3BhY2luZ0ZhY3RvciAmJiBvcHRpb25zLnNwYWNpbmdGYWN0b3IgIT09IDE7XG5cbiAgICAgIHZhciBzcGFjaW5nQmIgPSBmdW5jdGlvbiBzcGFjaW5nQmIoKSB7XG4gICAgICAgIGlmICghdXNlU3BhY2luZ0ZhY3Rvcikge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJiID0gbWFrZUJvdW5kaW5nQm94KCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgdmFyIHBvcyA9IGZuTWVtKG5vZGUsIGkpO1xuICAgICAgICAgIGV4cGFuZEJvdW5kaW5nQm94QnlQb2ludChiYiwgcG9zLngsIHBvcy55KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBiYjtcbiAgICAgIH07XG5cbiAgICAgIHZhciBiYiA9IHNwYWNpbmdCYigpO1xuICAgICAgdmFyIGdldEZpbmFsUG9zID0gbWVtb2l6ZSQxKGZ1bmN0aW9uIChub2RlLCBpKSB7XG4gICAgICAgIHZhciBuZXdQb3MgPSBmbk1lbShub2RlLCBpKTtcblxuICAgICAgICBpZiAodXNlU3BhY2luZ0ZhY3Rvcikge1xuICAgICAgICAgIHZhciBzcGFjaW5nID0gTWF0aC5hYnMob3B0aW9ucy5zcGFjaW5nRmFjdG9yKTtcbiAgICAgICAgICBuZXdQb3MgPSBjYWxjdWxhdGVTcGFjaW5nKHNwYWNpbmcsIGJiLCBuZXdQb3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMudHJhbnNmb3JtICE9IG51bGwpIHtcbiAgICAgICAgICBuZXdQb3MgPSBvcHRpb25zLnRyYW5zZm9ybShub2RlLCBuZXdQb3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ld1BvcztcbiAgICAgIH0sIGdldE1lbW9pemVLZXkpO1xuXG4gICAgICBpZiAob3B0aW9ucy5hbmltYXRlKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgIHZhciBuZXdQb3MgPSBnZXRGaW5hbFBvcyhub2RlLCBpKTtcbiAgICAgICAgICB2YXIgYW5pbWF0ZU5vZGUgPSBvcHRpb25zLmFuaW1hdGVGaWx0ZXIgPT0gbnVsbCB8fCBvcHRpb25zLmFuaW1hdGVGaWx0ZXIobm9kZSwgaSk7XG5cbiAgICAgICAgICBpZiAoYW5pbWF0ZU5vZGUpIHtcbiAgICAgICAgICAgIHZhciBhbmkgPSBub2RlLmFuaW1hdGlvbih7XG4gICAgICAgICAgICAgIHBvc2l0aW9uOiBuZXdQb3MsXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiBvcHRpb25zLmFuaW1hdGlvbkR1cmF0aW9uLFxuICAgICAgICAgICAgICBlYXNpbmc6IG9wdGlvbnMuYW5pbWF0aW9uRWFzaW5nXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxheW91dC5hbmltYXRpb25zLnB1c2goYW5pKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9kZS5wb3NpdGlvbihuZXdQb3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmZpdCkge1xuICAgICAgICAgIHZhciBmaXRBbmkgPSBjeS5hbmltYXRpb24oe1xuICAgICAgICAgICAgZml0OiB7XG4gICAgICAgICAgICAgIGJvdW5kaW5nQm94OiBsYXlvdXRFbGVzLmJvdW5kaW5nQm94QXQoZ2V0RmluYWxQb3MpLFxuICAgICAgICAgICAgICBwYWRkaW5nOiBvcHRpb25zLnBhZGRpbmdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkdXJhdGlvbjogb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbixcbiAgICAgICAgICAgIGVhc2luZzogb3B0aW9ucy5hbmltYXRpb25FYXNpbmdcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBsYXlvdXQuYW5pbWF0aW9ucy5wdXNoKGZpdEFuaSk7XG4gICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy56b29tICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5wYW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciB6b29tUGFuQW5pID0gY3kuYW5pbWF0aW9uKHtcbiAgICAgICAgICAgIHpvb206IG9wdGlvbnMuem9vbSxcbiAgICAgICAgICAgIHBhbjogb3B0aW9ucy5wYW4sXG4gICAgICAgICAgICBkdXJhdGlvbjogb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbixcbiAgICAgICAgICAgIGVhc2luZzogb3B0aW9ucy5hbmltYXRpb25FYXNpbmdcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBsYXlvdXQuYW5pbWF0aW9ucy5wdXNoKHpvb21QYW5BbmkpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGF5b3V0LmFuaW1hdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoYW5pKSB7XG4gICAgICAgICAgcmV0dXJuIGFuaS5wbGF5KCk7XG4gICAgICAgIH0pO1xuICAgICAgICBsYXlvdXQub25lKCdsYXlvdXRyZWFkeScsIG9wdGlvbnMucmVhZHkpO1xuICAgICAgICBsYXlvdXQuZW1pdCh7XG4gICAgICAgICAgdHlwZTogJ2xheW91dHJlYWR5JyxcbiAgICAgICAgICBsYXlvdXQ6IGxheW91dFxuICAgICAgICB9KTtcbiAgICAgICAgUHJvbWlzZSQxLmFsbChsYXlvdXQuYW5pbWF0aW9ucy5tYXAoZnVuY3Rpb24gKGFuaSkge1xuICAgICAgICAgIHJldHVybiBhbmkucHJvbWlzZSgpO1xuICAgICAgICB9KSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgbGF5b3V0Lm9uZSgnbGF5b3V0c3RvcCcsIG9wdGlvbnMuc3RvcCk7XG4gICAgICAgICAgbGF5b3V0LmVtaXQoe1xuICAgICAgICAgICAgdHlwZTogJ2xheW91dHN0b3AnLFxuICAgICAgICAgICAgbGF5b3V0OiBsYXlvdXRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2Rlcy5wb3NpdGlvbnMoZ2V0RmluYWxQb3MpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmZpdCkge1xuICAgICAgICAgIGN5LmZpdChvcHRpb25zLmVsZXMsIG9wdGlvbnMucGFkZGluZyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy56b29tICE9IG51bGwpIHtcbiAgICAgICAgICBjeS56b29tKG9wdGlvbnMuem9vbSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5wYW4pIHtcbiAgICAgICAgICBjeS5wYW4ob3B0aW9ucy5wYW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgbGF5b3V0Lm9uZSgnbGF5b3V0cmVhZHknLCBvcHRpb25zLnJlYWR5KTtcbiAgICAgICAgbGF5b3V0LmVtaXQoe1xuICAgICAgICAgIHR5cGU6ICdsYXlvdXRyZWFkeScsXG4gICAgICAgICAgbGF5b3V0OiBsYXlvdXRcbiAgICAgICAgfSk7XG4gICAgICAgIGxheW91dC5vbmUoJ2xheW91dHN0b3AnLCBvcHRpb25zLnN0b3ApO1xuICAgICAgICBsYXlvdXQuZW1pdCh7XG4gICAgICAgICAgdHlwZTogJ2xheW91dHN0b3AnLFxuICAgICAgICAgIGxheW91dDogbGF5b3V0XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuICAgIGxheW91dDogZnVuY3Rpb24gbGF5b3V0KG9wdGlvbnMpIHtcbiAgICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICAgIHJldHVybiBjeS5tYWtlTGF5b3V0KGV4dGVuZCh7fSwgb3B0aW9ucywge1xuICAgICAgICBlbGVzOiB0aGlzXG4gICAgICB9KSk7XG4gICAgfVxuICB9OyAvLyBhbGlhc2VzOlxuXG4gIGVsZXNmbiQ1LmNyZWF0ZUxheW91dCA9IGVsZXNmbiQ1Lm1ha2VMYXlvdXQgPSBlbGVzZm4kNS5sYXlvdXQ7XG5cbiAgZnVuY3Rpb24gc3R5bGVDYWNoZShrZXksIGZuLCBlbGUpIHtcbiAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgdmFyIGNhY2hlID0gX3Auc3R5bGVDYWNoZSA9IF9wLnN0eWxlQ2FjaGUgfHwgW107XG4gICAgdmFyIHZhbDtcblxuICAgIGlmICgodmFsID0gY2FjaGVba2V5XSkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsID0gY2FjaGVba2V5XSA9IGZuKGVsZSk7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNhY2hlU3R5bGVGdW5jdGlvbihrZXksIGZuKSB7XG4gICAga2V5ID0gaGFzaFN0cmluZyhrZXkpO1xuICAgIHJldHVybiBmdW5jdGlvbiBjYWNoZWRTdHlsZUZ1bmN0aW9uKGVsZSkge1xuICAgICAgcmV0dXJuIHN0eWxlQ2FjaGUoa2V5LCBmbiwgZWxlKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gY2FjaGVQcm90b3R5cGVTdHlsZUZ1bmN0aW9uKGtleSwgZm4pIHtcbiAgICBrZXkgPSBoYXNoU3RyaW5nKGtleSk7XG5cbiAgICB2YXIgc2VsZkZuID0gZnVuY3Rpb24gc2VsZkZuKGVsZSkge1xuICAgICAgcmV0dXJuIGZuLmNhbGwoZWxlKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNhY2hlZFByb3RvdHlwZVN0eWxlRnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgICAgaWYgKGVsZSkge1xuICAgICAgICByZXR1cm4gc3R5bGVDYWNoZShrZXksIHNlbGZGbiwgZWxlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgdmFyIGVsZXNmbiQ0ID0ge1xuICAgIHJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZTogZnVuY3Rpb24gcmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlKHVzZUNhY2hlKSB7XG4gICAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgICB2YXIgcmVuZGVyZXIgPSBjeS5yZW5kZXJlcigpO1xuICAgICAgdmFyIHN0eWxlRW5hYmxlZCA9IGN5LnN0eWxlRW5hYmxlZCgpO1xuXG4gICAgICBpZiAocmVuZGVyZXIgJiYgc3R5bGVFbmFibGVkKSB7XG4gICAgICAgIHJlbmRlcmVyLnJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZSh0aGlzLCB1c2VDYWNoZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZGlydHlTdHlsZUNhY2hlOiBmdW5jdGlvbiBkaXJ0eVN0eWxlQ2FjaGUoKSB7XG4gICAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICAgIHZhciBkaXJ0eSA9IGZ1bmN0aW9uIGRpcnR5KGVsZSkge1xuICAgICAgICByZXR1cm4gZWxlLl9wcml2YXRlLnN0eWxlQ2FjaGUgPSBudWxsO1xuICAgICAgfTtcblxuICAgICAgaWYgKGN5Lmhhc0NvbXBvdW5kTm9kZXMoKSkge1xuICAgICAgICB2YXIgZWxlcztcbiAgICAgICAgZWxlcyA9IHRoaXMuc3Bhd25TZWxmKCkubWVyZ2UodGhpcy5kZXNjZW5kYW50cygpKS5tZXJnZSh0aGlzLnBhcmVudHMoKSk7XG4gICAgICAgIGVsZXMubWVyZ2UoZWxlcy5jb25uZWN0ZWRFZGdlcygpKTtcbiAgICAgICAgZWxlcy5mb3JFYWNoKGRpcnR5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgICAgZGlydHkoZWxlKTtcbiAgICAgICAgICBlbGUuY29ubmVjdGVkRWRnZXMoKS5mb3JFYWNoKGRpcnR5KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLy8gZnVsbHkgdXBkYXRlcyAocmVjYWxjdWxhdGVzKSB0aGUgc3R5bGUgZm9yIHRoZSBlbGVtZW50c1xuICAgIHVwZGF0ZVN0eWxlOiBmdW5jdGlvbiB1cGRhdGVTdHlsZShub3RpZnlSZW5kZXJlcikge1xuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcblxuICAgICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgaWYgKGN5LmJhdGNoaW5nKCkpIHtcbiAgICAgICAgdmFyIGJFbGVzID0gY3kuX3ByaXZhdGUuYmF0Y2hTdHlsZUVsZXM7XG4gICAgICAgIGJFbGVzLm1lcmdlKHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmcgYW5kIGV4aXQgZWFybHkgd2hlbiBiYXRjaGluZ1xuICAgICAgfVxuXG4gICAgICB2YXIgaGFzQ29tcG91bmRzID0gY3kuaGFzQ29tcG91bmROb2RlcygpO1xuICAgICAgdmFyIHVwZGF0ZWRFbGVzID0gdGhpcztcbiAgICAgIG5vdGlmeVJlbmRlcmVyID0gbm90aWZ5UmVuZGVyZXIgfHwgbm90aWZ5UmVuZGVyZXIgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBmYWxzZTtcblxuICAgICAgaWYgKGhhc0NvbXBvdW5kcykge1xuICAgICAgICAvLyB0aGVuIGFkZCBldmVyeXRoaW5nIHVwIGFuZCBkb3duIGZvciBjb21wb3VuZCBzZWxlY3RvciBjaGVja3NcbiAgICAgICAgdXBkYXRlZEVsZXMgPSB0aGlzLnNwYXduU2VsZigpLm1lcmdlKHRoaXMuZGVzY2VuZGFudHMoKSkubWVyZ2UodGhpcy5wYXJlbnRzKCkpO1xuICAgICAgfSAvLyBsZXQgY2hhbmdlZEVsZXMgPSBzdHlsZS5hcHBseSggdXBkYXRlZEVsZXMgKTtcblxuXG4gICAgICB2YXIgY2hhbmdlZEVsZXMgPSB1cGRhdGVkRWxlcztcblxuICAgICAgaWYgKG5vdGlmeVJlbmRlcmVyKSB7XG4gICAgICAgIGNoYW5nZWRFbGVzLmVtaXRBbmROb3RpZnkoJ3N0eWxlJyk7IC8vIGxldCByZW5kZXJlciBrbm93IHdlIGNoYW5nZWQgc3R5bGVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoYW5nZWRFbGVzLmVtaXQoJ3N0eWxlJyk7IC8vIGp1c3QgZmlyZSB0aGUgZXZlbnRcbiAgICAgIH1cblxuICAgICAgdXBkYXRlZEVsZXMuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgIHJldHVybiBlbGUuX3ByaXZhdGUuc3R5bGVEaXJ0eSA9IHRydWU7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG4gICAgLy8gcHJpdmF0ZTogY2xlYXJzIGRpcnR5IGZsYWcgYW5kIHJlY2FsY3VsYXRlcyBzdHlsZVxuICAgIGNsZWFuU3R5bGU6IGZ1bmN0aW9uIGNsZWFuU3R5bGUoKSB7XG4gICAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG5cbiAgICAgICAgaWYgKGVsZS5fcHJpdmF0ZS5zdHlsZURpcnR5KSB7XG4gICAgICAgICAgLy8gbi5iLiB0aGlzIGZsYWcgc2hvdWxkIGJlIHNldCBiZWZvcmUgYXBwbHkoKSB0byBhdm9pZCBwb3RlbnRpYWwgaW5maW5pdGUgcmVjdXJzaW9uXG4gICAgICAgICAgZWxlLl9wcml2YXRlLnN0eWxlRGlydHkgPSBmYWxzZTtcbiAgICAgICAgICBjeS5zdHlsZSgpLmFwcGx5KGVsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIGdldCB0aGUgaW50ZXJuYWwgcGFyc2VkIHN0eWxlIG9iamVjdCBmb3IgdGhlIHNwZWNpZmllZCBwcm9wZXJ0eVxuICAgIHBhcnNlZFN0eWxlOiBmdW5jdGlvbiBwYXJzZWRTdHlsZShwcm9wZXJ0eSkge1xuICAgICAgdmFyIGluY2x1ZGVOb25EZWZhdWx0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgICB2YXIgY3kgPSBlbGUuY3koKTtcblxuICAgICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChlbGUpIHtcbiAgICAgICAgdGhpcy5jbGVhblN0eWxlKCk7XG4gICAgICAgIHZhciBvdmVycmlkZGVuU3R5bGUgPSBlbGUuX3ByaXZhdGUuc3R5bGVbcHJvcGVydHldO1xuXG4gICAgICAgIGlmIChvdmVycmlkZGVuU3R5bGUgIT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBvdmVycmlkZGVuU3R5bGU7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5jbHVkZU5vbkRlZmF1bHQpIHtcbiAgICAgICAgICByZXR1cm4gY3kuc3R5bGUoKS5nZXREZWZhdWx0UHJvcGVydHkocHJvcGVydHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBudW1lcmljU3R5bGU6IGZ1bmN0aW9uIG51bWVyaWNTdHlsZShwcm9wZXJ0eSkge1xuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICAgIGlmICghZWxlLmN5KCkuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWxlKSB7XG4gICAgICAgIHZhciBwc3R5bGUgPSBlbGUucHN0eWxlKHByb3BlcnR5KTtcbiAgICAgICAgcmV0dXJuIHBzdHlsZS5wZlZhbHVlICE9PSB1bmRlZmluZWQgPyBwc3R5bGUucGZWYWx1ZSA6IHBzdHlsZS52YWx1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG51bWVyaWNTdHlsZVVuaXRzOiBmdW5jdGlvbiBudW1lcmljU3R5bGVVbml0cyhwcm9wZXJ0eSkge1xuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICAgIGlmICghZWxlLmN5KCkuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWxlKSB7XG4gICAgICAgIHJldHVybiBlbGUucHN0eWxlKHByb3BlcnR5KS51bml0cztcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIGdldCB0aGUgc3BlY2lmaWVkIGNzcyBwcm9wZXJ0eSBhcyBhIHJlbmRlcmVkIHZhbHVlIChpLmUuIG9uLXNjcmVlbiB2YWx1ZSlcbiAgICAvLyBvciBnZXQgdGhlIHdob2xlIHJlbmRlcmVkIHN0eWxlIGlmIG5vIHByb3BlcnR5IHNwZWNpZmllZCAoTkIgZG9lc24ndCBhbGxvdyBzZXR0aW5nKVxuICAgIHJlbmRlcmVkU3R5bGU6IGZ1bmN0aW9uIHJlbmRlcmVkU3R5bGUocHJvcGVydHkpIHtcbiAgICAgIHZhciBjeSA9IHRoaXMuY3koKTtcblxuICAgICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICAgIGlmIChlbGUpIHtcbiAgICAgICAgcmV0dXJuIGN5LnN0eWxlKCkuZ2V0UmVuZGVyZWRTdHlsZShlbGUsIHByb3BlcnR5KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIHJlYWQgdGhlIGNhbGN1bGF0ZWQgY3NzIHN0eWxlIG9mIHRoZSBlbGVtZW50IG9yIG92ZXJyaWRlIHRoZSBzdHlsZSAodmlhIGEgYnlwYXNzKVxuICAgIHN0eWxlOiBmdW5jdGlvbiBzdHlsZShuYW1lLCB2YWx1ZSkge1xuICAgICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuXG4gICAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB2YXIgdXBkYXRlVHJhbnNpdGlvbnMgPSBmYWxzZTtcbiAgICAgIHZhciBzdHlsZSA9IGN5LnN0eWxlKCk7XG5cbiAgICAgIGlmIChwbGFpbk9iamVjdChuYW1lKSkge1xuICAgICAgICAvLyB0aGVuIGV4dGVuZCB0aGUgYnlwYXNzXG4gICAgICAgIHZhciBwcm9wcyA9IG5hbWU7XG4gICAgICAgIHN0eWxlLmFwcGx5QnlwYXNzKHRoaXMsIHByb3BzLCB1cGRhdGVUcmFuc2l0aW9ucyk7XG4gICAgICAgIHRoaXMuZW1pdEFuZE5vdGlmeSgnc3R5bGUnKTsgLy8gbGV0IHRoZSByZW5kZXJlciBrbm93IHdlJ3ZlIHVwZGF0ZWQgc3R5bGVcbiAgICAgIH0gZWxzZSBpZiAoc3RyaW5nKG5hbWUpKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gdGhlbiBnZXQgdGhlIHByb3BlcnR5IGZyb20gdGhlIHN0eWxlXG4gICAgICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICAgICAgICBpZiAoZWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gc3R5bGUuZ2V0U3R5bGVQcm9wZXJ0eVZhbHVlKGVsZSwgbmFtZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGVtcHR5IGNvbGxlY3Rpb24gPT4gY2FuJ3QgZ2V0IGFueSB2YWx1ZVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB0aGVuIHNldCB0aGUgYnlwYXNzIHdpdGggdGhlIHByb3BlcnR5IHZhbHVlXG4gICAgICAgICAgc3R5bGUuYXBwbHlCeXBhc3ModGhpcywgbmFtZSwgdmFsdWUsIHVwZGF0ZVRyYW5zaXRpb25zKTtcbiAgICAgICAgICB0aGlzLmVtaXRBbmROb3RpZnkoJ3N0eWxlJyk7IC8vIGxldCB0aGUgcmVuZGVyZXIga25vdyB3ZSd2ZSB1cGRhdGVkIHN0eWxlXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBfZWxlID0gdGhpc1swXTtcblxuICAgICAgICBpZiAoX2VsZSkge1xuICAgICAgICAgIHJldHVybiBzdHlsZS5nZXRSYXdTdHlsZShfZWxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBlbXB0eSBjb2xsZWN0aW9uID0+IGNhbid0IGdldCBhbnkgdmFsdWVcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcbiAgICByZW1vdmVTdHlsZTogZnVuY3Rpb24gcmVtb3ZlU3R5bGUobmFtZXMpIHtcbiAgICAgIHZhciBjeSA9IHRoaXMuY3koKTtcblxuICAgICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdmFyIHVwZGF0ZVRyYW5zaXRpb25zID0gZmFsc2U7XG4gICAgICB2YXIgc3R5bGUgPSBjeS5zdHlsZSgpO1xuICAgICAgdmFyIGVsZXMgPSB0aGlzO1xuXG4gICAgICBpZiAobmFtZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgICAgICBzdHlsZS5yZW1vdmVBbGxCeXBhc3NlcyhlbGUsIHVwZGF0ZVRyYW5zaXRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmFtZXMgPSBuYW1lcy5zcGxpdCgvXFxzKy8pO1xuXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBlbGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgIHZhciBfZWxlMiA9IGVsZXNbX2ldO1xuICAgICAgICAgIHN0eWxlLnJlbW92ZUJ5cGFzc2VzKF9lbGUyLCBuYW1lcywgdXBkYXRlVHJhbnNpdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZW1pdEFuZE5vdGlmeSgnc3R5bGUnKTsgLy8gbGV0IHRoZSByZW5kZXJlciBrbm93IHdlJ3ZlIHVwZGF0ZWQgc3R5bGVcblxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcbiAgICBzaG93OiBmdW5jdGlvbiBzaG93KCkge1xuICAgICAgdGhpcy5jc3MoJ2Rpc3BsYXknLCAnZWxlbWVudCcpO1xuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcbiAgICBoaWRlOiBmdW5jdGlvbiBoaWRlKCkge1xuICAgICAgdGhpcy5jc3MoJ2Rpc3BsYXknLCAnbm9uZScpO1xuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcbiAgICBlZmZlY3RpdmVPcGFjaXR5OiBmdW5jdGlvbiBlZmZlY3RpdmVPcGFjaXR5KCkge1xuICAgICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuXG4gICAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuXG4gICAgICB2YXIgaGFzQ29tcG91bmROb2RlcyA9IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgICBpZiAoZWxlKSB7XG4gICAgICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICAgICAgdmFyIHBhcmVudE9wYWNpdHkgPSBlbGUucHN0eWxlKCdvcGFjaXR5JykudmFsdWU7XG5cbiAgICAgICAgaWYgKCFoYXNDb21wb3VuZE5vZGVzKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcmVudE9wYWNpdHk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGFyZW50cyA9ICFfcC5kYXRhLnBhcmVudCA/IG51bGwgOiBlbGUucGFyZW50cygpO1xuXG4gICAgICAgIGlmIChwYXJlbnRzKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gcGFyZW50c1tpXTtcbiAgICAgICAgICAgIHZhciBvcGFjaXR5ID0gcGFyZW50LnBzdHlsZSgnb3BhY2l0eScpLnZhbHVlO1xuICAgICAgICAgICAgcGFyZW50T3BhY2l0eSA9IG9wYWNpdHkgKiBwYXJlbnRPcGFjaXR5O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJlbnRPcGFjaXR5O1xuICAgICAgfVxuICAgIH0sXG4gICAgdHJhbnNwYXJlbnQ6IGZ1bmN0aW9uIHRyYW5zcGFyZW50KCkge1xuICAgICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuXG4gICAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgICB2YXIgaGFzQ29tcG91bmROb2RlcyA9IGVsZS5jeSgpLmhhc0NvbXBvdW5kTm9kZXMoKTtcblxuICAgICAgaWYgKGVsZSkge1xuICAgICAgICBpZiAoIWhhc0NvbXBvdW5kTm9kZXMpIHtcbiAgICAgICAgICByZXR1cm4gZWxlLnBzdHlsZSgnb3BhY2l0eScpLnZhbHVlID09PSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBlbGUuZWZmZWN0aXZlT3BhY2l0eSgpID09PSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBiYWNrZ3JvdW5kaW5nOiBmdW5jdGlvbiBiYWNrZ3JvdW5kaW5nKCkge1xuICAgICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuXG4gICAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgICByZXR1cm4gZWxlLl9wcml2YXRlLmJhY2tncm91bmRpbmcgPyB0cnVlIDogZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGNoZWNrQ29tcG91bmQoZWxlLCBwYXJlbnRPaykge1xuICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICB2YXIgcGFyZW50cyA9IF9wLmRhdGEucGFyZW50ID8gZWxlLnBhcmVudHMoKSA6IG51bGw7XG5cbiAgICBpZiAocGFyZW50cykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSBwYXJlbnRzW2ldO1xuXG4gICAgICAgIGlmICghcGFyZW50T2socGFyZW50KSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVmaW5lRGVyaXZlZFN0YXRlRnVuY3Rpb24oc3BlY3MpIHtcbiAgICB2YXIgb2sgPSBzcGVjcy5vaztcbiAgICB2YXIgZWRnZU9rVmlhTm9kZSA9IHNwZWNzLmVkZ2VPa1ZpYU5vZGUgfHwgc3BlY3Mub2s7XG4gICAgdmFyIHBhcmVudE9rID0gc3BlY3MucGFyZW50T2sgfHwgc3BlY3Mub2s7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjeSA9IHRoaXMuY3koKTtcblxuICAgICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgICB2YXIgaGFzQ29tcG91bmROb2RlcyA9IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcblxuICAgICAgaWYgKGVsZSkge1xuICAgICAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG5cbiAgICAgICAgaWYgKCFvayhlbGUpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgICAgIHJldHVybiAhaGFzQ29tcG91bmROb2RlcyB8fCBjaGVja0NvbXBvdW5kKGVsZSwgcGFyZW50T2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBzcmMgPSBfcC5zb3VyY2U7XG4gICAgICAgICAgdmFyIHRndCA9IF9wLnRhcmdldDtcbiAgICAgICAgICByZXR1cm4gZWRnZU9rVmlhTm9kZShzcmMpICYmICghaGFzQ29tcG91bmROb2RlcyB8fCBjaGVja0NvbXBvdW5kKHNyYywgZWRnZU9rVmlhTm9kZSkpICYmIChzcmMgPT09IHRndCB8fCBlZGdlT2tWaWFOb2RlKHRndCkgJiYgKCFoYXNDb21wb3VuZE5vZGVzIHx8IGNoZWNrQ29tcG91bmQodGd0LCBlZGdlT2tWaWFOb2RlKSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHZhciBlbGVUYWtlc1VwU3BhY2UgPSBjYWNoZVN0eWxlRnVuY3Rpb24oJ2VsZVRha2VzVXBTcGFjZScsIGZ1bmN0aW9uIChlbGUpIHtcbiAgICByZXR1cm4gZWxlLnBzdHlsZSgnZGlzcGxheScpLnZhbHVlID09PSAnZWxlbWVudCcgJiYgZWxlLndpZHRoKCkgIT09IDAgJiYgKGVsZS5pc05vZGUoKSA/IGVsZS5oZWlnaHQoKSAhPT0gMCA6IHRydWUpO1xuICB9KTtcbiAgZWxlc2ZuJDQudGFrZXNVcFNwYWNlID0gY2FjaGVQcm90b3R5cGVTdHlsZUZ1bmN0aW9uKCd0YWtlc1VwU3BhY2UnLCBkZWZpbmVEZXJpdmVkU3RhdGVGdW5jdGlvbih7XG4gICAgb2s6IGVsZVRha2VzVXBTcGFjZVxuICB9KSk7XG4gIHZhciBlbGVJbnRlcmFjdGl2ZSA9IGNhY2hlU3R5bGVGdW5jdGlvbignZWxlSW50ZXJhY3RpdmUnLCBmdW5jdGlvbiAoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5wc3R5bGUoJ2V2ZW50cycpLnZhbHVlID09PSAneWVzJyAmJiBlbGUucHN0eWxlKCd2aXNpYmlsaXR5JykudmFsdWUgPT09ICd2aXNpYmxlJyAmJiBlbGVUYWtlc1VwU3BhY2UoZWxlKTtcbiAgfSk7XG4gIHZhciBwYXJlbnRJbnRlcmFjdGl2ZSA9IGNhY2hlU3R5bGVGdW5jdGlvbigncGFyZW50SW50ZXJhY3RpdmUnLCBmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgcmV0dXJuIHBhcmVudC5wc3R5bGUoJ3Zpc2liaWxpdHknKS52YWx1ZSA9PT0gJ3Zpc2libGUnICYmIGVsZVRha2VzVXBTcGFjZShwYXJlbnQpO1xuICB9KTtcbiAgZWxlc2ZuJDQuaW50ZXJhY3RpdmUgPSBjYWNoZVByb3RvdHlwZVN0eWxlRnVuY3Rpb24oJ2ludGVyYWN0aXZlJywgZGVmaW5lRGVyaXZlZFN0YXRlRnVuY3Rpb24oe1xuICAgIG9rOiBlbGVJbnRlcmFjdGl2ZSxcbiAgICBwYXJlbnRPazogcGFyZW50SW50ZXJhY3RpdmUsXG4gICAgZWRnZU9rVmlhTm9kZTogZWxlVGFrZXNVcFNwYWNlXG4gIH0pKTtcblxuICBlbGVzZm4kNC5ub25pbnRlcmFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgIGlmIChlbGUpIHtcbiAgICAgIHJldHVybiAhZWxlLmludGVyYWN0aXZlKCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBlbGVWaXNpYmxlID0gY2FjaGVTdHlsZUZ1bmN0aW9uKCdlbGVWaXNpYmxlJywgZnVuY3Rpb24gKGVsZSkge1xuICAgIHJldHVybiBlbGUucHN0eWxlKCd2aXNpYmlsaXR5JykudmFsdWUgPT09ICd2aXNpYmxlJyAmJiBlbGUucHN0eWxlKCdvcGFjaXR5JykucGZWYWx1ZSAhPT0gMCAmJiBlbGVUYWtlc1VwU3BhY2UoZWxlKTtcbiAgfSk7XG4gIHZhciBlZGdlVmlzaWJsZVZpYU5vZGUgPSBlbGVUYWtlc1VwU3BhY2U7XG4gIGVsZXNmbiQ0LnZpc2libGUgPSBjYWNoZVByb3RvdHlwZVN0eWxlRnVuY3Rpb24oJ3Zpc2libGUnLCBkZWZpbmVEZXJpdmVkU3RhdGVGdW5jdGlvbih7XG4gICAgb2s6IGVsZVZpc2libGUsXG4gICAgZWRnZU9rVmlhTm9kZTogZWRnZVZpc2libGVWaWFOb2RlXG4gIH0pKTtcblxuICBlbGVzZm4kNC5oaWRkZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICBpZiAoZWxlKSB7XG4gICAgICByZXR1cm4gIWVsZS52aXNpYmxlKCk7XG4gICAgfVxuICB9O1xuXG4gIGVsZXNmbiQ0LmlzQnVuZGxlZEJlemllciA9IGNhY2hlUHJvdG90eXBlU3R5bGVGdW5jdGlvbignaXNCdW5kbGVkQmV6aWVyJywgZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5jeSgpLnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuICF0aGlzLnJlbW92ZWQoKSAmJiB0aGlzLnBzdHlsZSgnY3VydmUtc3R5bGUnKS52YWx1ZSA9PT0gJ2JlemllcicgJiYgdGhpcy50YWtlc1VwU3BhY2UoKTtcbiAgfSk7XG4gIGVsZXNmbiQ0LmJ5cGFzcyA9IGVsZXNmbiQ0LmNzcyA9IGVsZXNmbiQ0LnN0eWxlO1xuICBlbGVzZm4kNC5yZW5kZXJlZENzcyA9IGVsZXNmbiQ0LnJlbmRlcmVkU3R5bGU7XG4gIGVsZXNmbiQ0LnJlbW92ZUJ5cGFzcyA9IGVsZXNmbiQ0LnJlbW92ZUNzcyA9IGVsZXNmbiQ0LnJlbW92ZVN0eWxlO1xuICBlbGVzZm4kNC5wc3R5bGUgPSBlbGVzZm4kNC5wYXJzZWRTdHlsZTtcblxuICB2YXIgZWxlc2ZuJDMgPSB7fTtcblxuICBmdW5jdGlvbiBkZWZpbmVTd2l0Y2hGdW5jdGlvbihwYXJhbXMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICB2YXIgY2hhbmdlZEVsZXMgPSBbXTsgLy8gZS5nLiBjeS5ub2RlcygpLnNlbGVjdCggZGF0YSwgaGFuZGxlciApXG5cbiAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICB2YXIgZGF0YSA9IGFyZ3NbMF07XG4gICAgICAgIHZhciBoYW5kbGVyID0gYXJnc1sxXTtcbiAgICAgICAgdGhpcy5vbihwYXJhbXMuZXZlbnQsIGRhdGEsIGhhbmRsZXIpO1xuICAgICAgfSAvLyBlLmcuIGN5Lm5vZGVzKCkuc2VsZWN0KCBoYW5kbGVyIClcbiAgICAgIGVsc2UgaWYgKGFyZ3MubGVuZ3RoID09PSAxICYmIGZuJDYoYXJnc1swXSkpIHtcbiAgICAgICAgdmFyIF9oYW5kbGVyID0gYXJnc1swXTtcbiAgICAgICAgdGhpcy5vbihwYXJhbXMuZXZlbnQsIF9oYW5kbGVyKTtcbiAgICAgIH0gLy8gZS5nLiBjeS5ub2RlcygpLnNlbGVjdCgpXG4gICAgICAvLyBlLmcuIChwcml2YXRlKSBjeS5ub2RlcygpLnNlbGVjdChbJ3RhcHNlbGVjdCddKVxuICAgICAgZWxzZSBpZiAoYXJncy5sZW5ndGggPT09IDAgfHwgYXJncy5sZW5ndGggPT09IDEgJiYgYXJyYXkoYXJnc1swXSkpIHtcbiAgICAgICAgdmFyIGFkZGxFdmVudHMgPSBhcmdzLmxlbmd0aCA9PT0gMSA/IGFyZ3NbMF0gOiBudWxsO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgICAgIHZhciBhYmxlID0gIXBhcmFtcy5hYmxlRmllbGQgfHwgZWxlLl9wcml2YXRlW3BhcmFtcy5hYmxlRmllbGRdO1xuICAgICAgICAgIHZhciBjaGFuZ2VkID0gZWxlLl9wcml2YXRlW3BhcmFtcy5maWVsZF0gIT0gcGFyYW1zLnZhbHVlO1xuXG4gICAgICAgICAgaWYgKHBhcmFtcy5vdmVycmlkZUFibGUpIHtcbiAgICAgICAgICAgIHZhciBvdmVycmlkZUFibGUgPSBwYXJhbXMub3ZlcnJpZGVBYmxlKGVsZSk7XG5cbiAgICAgICAgICAgIGlmIChvdmVycmlkZUFibGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBhYmxlID0gb3ZlcnJpZGVBYmxlO1xuXG4gICAgICAgICAgICAgIGlmICghb3ZlcnJpZGVBYmxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgIH0gLy8gdG8gc2F2ZSBjeWNsZXMgYXNzdW1lIG5vdCBhYmxlIGZvciBhbGwgb24gb3ZlcnJpZGVcblxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChhYmxlKSB7XG4gICAgICAgICAgICBlbGUuX3ByaXZhdGVbcGFyYW1zLmZpZWxkXSA9IHBhcmFtcy52YWx1ZTtcblxuICAgICAgICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgY2hhbmdlZEVsZXMucHVzaChlbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaGFuZ2VkQ29sbCA9IHRoaXMuc3Bhd24oY2hhbmdlZEVsZXMpO1xuICAgICAgICBjaGFuZ2VkQ29sbC51cGRhdGVTdHlsZSgpOyAvLyBjaGFuZ2Ugb2Ygc3RhdGUgPT4gcG9zc2libGUgY2hhbmdlIG9mIHN0eWxlXG5cbiAgICAgICAgY2hhbmdlZENvbGwuZW1pdChwYXJhbXMuZXZlbnQpO1xuXG4gICAgICAgIGlmIChhZGRsRXZlbnRzKSB7XG4gICAgICAgICAgY2hhbmdlZENvbGwuZW1pdChhZGRsRXZlbnRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZGVmaW5lU3dpdGNoU2V0KHBhcmFtcykge1xuICAgIGVsZXNmbiQzW3BhcmFtcy5maWVsZF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgICAgaWYgKGVsZSkge1xuICAgICAgICBpZiAocGFyYW1zLm92ZXJyaWRlRmllbGQpIHtcbiAgICAgICAgICB2YXIgdmFsID0gcGFyYW1zLm92ZXJyaWRlRmllbGQoZWxlKTtcblxuICAgICAgICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZWxlLl9wcml2YXRlW3BhcmFtcy5maWVsZF07XG4gICAgICB9XG4gICAgfTtcblxuICAgIGVsZXNmbiQzW3BhcmFtcy5vbl0gPSBkZWZpbmVTd2l0Y2hGdW5jdGlvbih7XG4gICAgICBldmVudDogcGFyYW1zLm9uLFxuICAgICAgZmllbGQ6IHBhcmFtcy5maWVsZCxcbiAgICAgIGFibGVGaWVsZDogcGFyYW1zLmFibGVGaWVsZCxcbiAgICAgIG92ZXJyaWRlQWJsZTogcGFyYW1zLm92ZXJyaWRlQWJsZSxcbiAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSk7XG4gICAgZWxlc2ZuJDNbcGFyYW1zLm9mZl0gPSBkZWZpbmVTd2l0Y2hGdW5jdGlvbih7XG4gICAgICBldmVudDogcGFyYW1zLm9mZixcbiAgICAgIGZpZWxkOiBwYXJhbXMuZmllbGQsXG4gICAgICBhYmxlRmllbGQ6IHBhcmFtcy5hYmxlRmllbGQsXG4gICAgICBvdmVycmlkZUFibGU6IHBhcmFtcy5vdmVycmlkZUFibGUsXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9KTtcbiAgfVxuXG4gIGRlZmluZVN3aXRjaFNldCh7XG4gICAgZmllbGQ6ICdsb2NrZWQnLFxuICAgIG92ZXJyaWRlRmllbGQ6IGZ1bmN0aW9uIG92ZXJyaWRlRmllbGQoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLmN5KCkuYXV0b2xvY2soKSA/IHRydWUgOiB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBvbjogJ2xvY2snLFxuICAgIG9mZjogJ3VubG9jaydcbiAgfSk7XG4gIGRlZmluZVN3aXRjaFNldCh7XG4gICAgZmllbGQ6ICdncmFiYmFibGUnLFxuICAgIG92ZXJyaWRlRmllbGQ6IGZ1bmN0aW9uIG92ZXJyaWRlRmllbGQoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLmN5KCkuYXV0b3VuZ3JhYmlmeSgpIHx8IGVsZS5wYW5uYWJsZSgpID8gZmFsc2UgOiB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBvbjogJ2dyYWJpZnknLFxuICAgIG9mZjogJ3VuZ3JhYmlmeSdcbiAgfSk7XG4gIGRlZmluZVN3aXRjaFNldCh7XG4gICAgZmllbGQ6ICdzZWxlY3RlZCcsXG4gICAgYWJsZUZpZWxkOiAnc2VsZWN0YWJsZScsXG4gICAgb3ZlcnJpZGVBYmxlOiBmdW5jdGlvbiBvdmVycmlkZUFibGUoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLmN5KCkuYXV0b3Vuc2VsZWN0aWZ5KCkgPyBmYWxzZSA6IHVuZGVmaW5lZDtcbiAgICB9LFxuICAgIG9uOiAnc2VsZWN0JyxcbiAgICBvZmY6ICd1bnNlbGVjdCdcbiAgfSk7XG4gIGRlZmluZVN3aXRjaFNldCh7XG4gICAgZmllbGQ6ICdzZWxlY3RhYmxlJyxcbiAgICBvdmVycmlkZUZpZWxkOiBmdW5jdGlvbiBvdmVycmlkZUZpZWxkKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5jeSgpLmF1dG91bnNlbGVjdGlmeSgpID8gZmFsc2UgOiB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBvbjogJ3NlbGVjdGlmeScsXG4gICAgb2ZmOiAndW5zZWxlY3RpZnknXG4gIH0pO1xuICBlbGVzZm4kMy5kZXNlbGVjdCA9IGVsZXNmbiQzLnVuc2VsZWN0O1xuXG4gIGVsZXNmbiQzLmdyYWJiZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICBpZiAoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLl9wcml2YXRlLmdyYWJiZWQ7XG4gICAgfVxuICB9O1xuXG4gIGRlZmluZVN3aXRjaFNldCh7XG4gICAgZmllbGQ6ICdhY3RpdmUnLFxuICAgIG9uOiAnYWN0aXZhdGUnLFxuICAgIG9mZjogJ3VuYWN0aXZhdGUnXG4gIH0pO1xuICBkZWZpbmVTd2l0Y2hTZXQoe1xuICAgIGZpZWxkOiAncGFubmFibGUnLFxuICAgIG9uOiAncGFuaWZ5JyxcbiAgICBvZmY6ICd1bnBhbmlmeSdcbiAgfSk7XG5cbiAgZWxlc2ZuJDMuaW5hY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICBpZiAoZWxlKSB7XG4gICAgICByZXR1cm4gIWVsZS5fcHJpdmF0ZS5hY3RpdmU7XG4gICAgfVxuICB9O1xuXG4gIHZhciBlbGVzZm4kMiA9IHt9OyAvLyBEQUcgZnVuY3Rpb25zXG4gIC8vLy8vLy8vLy8vLy8vLy9cblxuICB2YXIgZGVmaW5lRGFnRXh0cmVtaXR5ID0gZnVuY3Rpb24gZGVmaW5lRGFnRXh0cmVtaXR5KHBhcmFtcykge1xuICAgIHJldHVybiBmdW5jdGlvbiBkYWdFeHRyZW1pdHlJbXBsKHNlbGVjdG9yKSB7XG4gICAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgICB2YXIgcmV0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcblxuICAgICAgICBpZiAoIWVsZS5pc05vZGUoKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRpc3F1YWxpZmllZCA9IGZhbHNlO1xuICAgICAgICB2YXIgZWRnZXMgPSBlbGUuY29ubmVjdGVkRWRnZXMoKTtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGVkZ2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tqXTtcbiAgICAgICAgICB2YXIgc3JjID0gZWRnZS5zb3VyY2UoKTtcbiAgICAgICAgICB2YXIgdGd0ID0gZWRnZS50YXJnZXQoKTtcblxuICAgICAgICAgIGlmIChwYXJhbXMubm9JbmNvbWluZ0VkZ2VzICYmIHRndCA9PT0gZWxlICYmIHNyYyAhPT0gZWxlIHx8IHBhcmFtcy5ub091dGdvaW5nRWRnZXMgJiYgc3JjID09PSBlbGUgJiYgdGd0ICE9PSBlbGUpIHtcbiAgICAgICAgICAgIGRpc3F1YWxpZmllZCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWRpc3F1YWxpZmllZCkge1xuICAgICAgICAgIHJldC5wdXNoKGVsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuc3Bhd24ocmV0LCB0cnVlKS5maWx0ZXIoc2VsZWN0b3IpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGRlZmluZURhZ09uZUhvcCA9IGZ1bmN0aW9uIGRlZmluZURhZ09uZUhvcChwYXJhbXMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgICB2YXIgb0VsZXMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuXG4gICAgICAgIGlmICghZWxlLmlzTm9kZSgpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZWRnZXMgPSBlbGUuY29ubmVjdGVkRWRnZXMoKTtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGVkZ2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tqXTtcbiAgICAgICAgICB2YXIgc3JjID0gZWRnZS5zb3VyY2UoKTtcbiAgICAgICAgICB2YXIgdGd0ID0gZWRnZS50YXJnZXQoKTtcblxuICAgICAgICAgIGlmIChwYXJhbXMub3V0Z29pbmcgJiYgc3JjID09PSBlbGUpIHtcbiAgICAgICAgICAgIG9FbGVzLnB1c2goZWRnZSk7XG4gICAgICAgICAgICBvRWxlcy5wdXNoKHRndCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChwYXJhbXMuaW5jb21pbmcgJiYgdGd0ID09PSBlbGUpIHtcbiAgICAgICAgICAgIG9FbGVzLnB1c2goZWRnZSk7XG4gICAgICAgICAgICBvRWxlcy5wdXNoKHNyYyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnNwYXduKG9FbGVzLCB0cnVlKS5maWx0ZXIoc2VsZWN0b3IpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGRlZmluZURhZ0FsbEhvcHMgPSBmdW5jdGlvbiBkZWZpbmVEYWdBbGxIb3BzKHBhcmFtcykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgIHZhciBlbGVzID0gdGhpcztcbiAgICAgIHZhciBzRWxlcyA9IFtdO1xuICAgICAgdmFyIHNFbGVzSWRzID0ge307XG5cbiAgICAgIGZvciAoOzspIHtcbiAgICAgICAgdmFyIG5leHQgPSBwYXJhbXMub3V0Z29pbmcgPyBlbGVzLm91dGdvZXJzKCkgOiBlbGVzLmluY29tZXJzKCk7XG5cbiAgICAgICAgaWYgKG5leHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gLy8gZG9uZSBpZiBub25lIGxlZnRcblxuXG4gICAgICAgIHZhciBuZXdOZXh0ID0gZmFsc2U7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIG4gPSBuZXh0W2ldO1xuICAgICAgICAgIHZhciBuaWQgPSBuLmlkKCk7XG5cbiAgICAgICAgICBpZiAoIXNFbGVzSWRzW25pZF0pIHtcbiAgICAgICAgICAgIHNFbGVzSWRzW25pZF0gPSB0cnVlO1xuICAgICAgICAgICAgc0VsZXMucHVzaChuKTtcbiAgICAgICAgICAgIG5ld05leHQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbmV3TmV4dCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IC8vIGRvbmUgaWYgdG91Y2hlZCBhbGwgb3V0Z29lcnMgYWxyZWFkeVxuXG5cbiAgICAgICAgZWxlcyA9IG5leHQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnNwYXduKHNFbGVzLCB0cnVlKS5maWx0ZXIoc2VsZWN0b3IpO1xuICAgIH07XG4gIH07XG5cbiAgZWxlc2ZuJDIuY2xlYXJUcmF2ZXJzYWxDYWNoZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXNbaV0uX3ByaXZhdGUudHJhdmVyc2FsQ2FjaGUgPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICBleHRlbmQoZWxlc2ZuJDIsIHtcbiAgICAvLyBnZXQgdGhlIHJvb3Qgbm9kZXMgaW4gdGhlIERBR1xuICAgIHJvb3RzOiBkZWZpbmVEYWdFeHRyZW1pdHkoe1xuICAgICAgbm9JbmNvbWluZ0VkZ2VzOiB0cnVlXG4gICAgfSksXG4gICAgLy8gZ2V0IHRoZSBsZWFmIG5vZGVzIGluIHRoZSBEQUdcbiAgICBsZWF2ZXM6IGRlZmluZURhZ0V4dHJlbWl0eSh7XG4gICAgICBub091dGdvaW5nRWRnZXM6IHRydWVcbiAgICB9KSxcbiAgICAvLyBub3JtYWxseSBjYWxsZWQgY2hpbGRyZW4gaW4gZ3JhcGggdGhlb3J5XG4gICAgLy8gdGhlc2Ugbm9kZXMgPWVkZ2VzPT4gb3V0Z29pbmcgbm9kZXNcbiAgICBvdXRnb2VyczogY2FjaGUoZGVmaW5lRGFnT25lSG9wKHtcbiAgICAgIG91dGdvaW5nOiB0cnVlXG4gICAgfSksICdvdXRnb2VycycpLFxuICAgIC8vIGFrYSBEQUcgZGVzY2VuZGFudHNcbiAgICBzdWNjZXNzb3JzOiBkZWZpbmVEYWdBbGxIb3BzKHtcbiAgICAgIG91dGdvaW5nOiB0cnVlXG4gICAgfSksXG4gICAgLy8gbm9ybWFsbHkgY2FsbGVkIHBhcmVudHMgaW4gZ3JhcGggdGhlb3J5XG4gICAgLy8gdGhlc2Ugbm9kZXMgPD1lZGdlcz0gaW5jb21pbmcgbm9kZXNcbiAgICBpbmNvbWVyczogY2FjaGUoZGVmaW5lRGFnT25lSG9wKHtcbiAgICAgIGluY29taW5nOiB0cnVlXG4gICAgfSksICdpbmNvbWVycycpLFxuICAgIC8vIGFrYSBEQUcgYW5jZXN0b3JzXG4gICAgcHJlZGVjZXNzb3JzOiBkZWZpbmVEYWdBbGxIb3BzKHtcbiAgICAgIGluY29taW5nOiB0cnVlXG4gICAgfSlcbiAgfSk7IC8vIE5laWdoYm91cmhvb2QgZnVuY3Rpb25zXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgZXh0ZW5kKGVsZXNmbiQyLCB7XG4gICAgbmVpZ2hib3Job29kOiBjYWNoZShmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgIHZhciBlbGVtZW50cyA9IFtdO1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIGZvciBhbGwgbm9kZXNcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgdmFyIGNvbm5lY3RlZEVkZ2VzID0gbm9kZS5jb25uZWN0ZWRFZGdlcygpOyAvLyBmb3IgZWFjaCBjb25uZWN0ZWQgZWRnZSwgYWRkIHRoZSBlZGdlIGFuZCB0aGUgb3RoZXIgbm9kZVxuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29ubmVjdGVkRWRnZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB2YXIgZWRnZSA9IGNvbm5lY3RlZEVkZ2VzW2pdO1xuICAgICAgICAgIHZhciBzcmMgPSBlZGdlLnNvdXJjZSgpO1xuICAgICAgICAgIHZhciB0Z3QgPSBlZGdlLnRhcmdldCgpO1xuICAgICAgICAgIHZhciBvdGhlck5vZGUgPSBub2RlID09PSBzcmMgPyB0Z3QgOiBzcmM7IC8vIG5lZWQgY2hlY2sgaW4gY2FzZSBvZiBsb29wXG5cbiAgICAgICAgICBpZiAob3RoZXJOb2RlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGVsZW1lbnRzLnB1c2gob3RoZXJOb2RlWzBdKTsgLy8gYWRkIG5vZGUgMSBob3AgYXdheVxuICAgICAgICAgIH0gLy8gYWRkIGNvbm5lY3RlZCBlZGdlXG5cblxuICAgICAgICAgIGVsZW1lbnRzLnB1c2goZWRnZVswXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuc3Bhd24oZWxlbWVudHMsIHRydWUpLmZpbHRlcihzZWxlY3Rvcik7XG4gICAgfSwgJ25laWdoYm9yaG9vZCcpLFxuICAgIGNsb3NlZE5laWdoYm9yaG9vZDogZnVuY3Rpb24gY2xvc2VkTmVpZ2hib3Job29kKHNlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gdGhpcy5uZWlnaGJvcmhvb2QoKS5hZGQodGhpcykuZmlsdGVyKHNlbGVjdG9yKTtcbiAgICB9LFxuICAgIG9wZW5OZWlnaGJvcmhvb2Q6IGZ1bmN0aW9uIG9wZW5OZWlnaGJvcmhvb2Qoc2VsZWN0b3IpIHtcbiAgICAgIHJldHVybiB0aGlzLm5laWdoYm9yaG9vZChzZWxlY3Rvcik7XG4gICAgfVxuICB9KTsgLy8gYWxpYXNlc1xuXG4gIGVsZXNmbiQyLm5laWdoYm91cmhvb2QgPSBlbGVzZm4kMi5uZWlnaGJvcmhvb2Q7XG4gIGVsZXNmbiQyLmNsb3NlZE5laWdoYm91cmhvb2QgPSBlbGVzZm4kMi5jbG9zZWROZWlnaGJvcmhvb2Q7XG4gIGVsZXNmbiQyLm9wZW5OZWlnaGJvdXJob29kID0gZWxlc2ZuJDIub3Blbk5laWdoYm9yaG9vZDsgLy8gRWRnZSBmdW5jdGlvbnNcbiAgLy8vLy8vLy8vLy8vLy8vLy9cblxuICBleHRlbmQoZWxlc2ZuJDIsIHtcbiAgICBzb3VyY2U6IGNhY2hlKGZ1bmN0aW9uIHNvdXJjZUltcGwoc2VsZWN0b3IpIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgICAgdmFyIHNyYztcblxuICAgICAgaWYgKGVsZSkge1xuICAgICAgICBzcmMgPSBlbGUuX3ByaXZhdGUuc291cmNlIHx8IGVsZS5jeSgpLmNvbGxlY3Rpb24oKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNyYyAmJiBzZWxlY3RvciA/IHNyYy5maWx0ZXIoc2VsZWN0b3IpIDogc3JjO1xuICAgIH0sICdzb3VyY2UnKSxcbiAgICB0YXJnZXQ6IGNhY2hlKGZ1bmN0aW9uIHRhcmdldEltcGwoc2VsZWN0b3IpIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgICAgdmFyIHRndDtcblxuICAgICAgaWYgKGVsZSkge1xuICAgICAgICB0Z3QgPSBlbGUuX3ByaXZhdGUudGFyZ2V0IHx8IGVsZS5jeSgpLmNvbGxlY3Rpb24oKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRndCAmJiBzZWxlY3RvciA/IHRndC5maWx0ZXIoc2VsZWN0b3IpIDogdGd0O1xuICAgIH0sICd0YXJnZXQnKSxcbiAgICBzb3VyY2VzOiBkZWZpbmVTb3VyY2VGdW5jdGlvbih7XG4gICAgICBhdHRyOiAnc291cmNlJ1xuICAgIH0pLFxuICAgIHRhcmdldHM6IGRlZmluZVNvdXJjZUZ1bmN0aW9uKHtcbiAgICAgIGF0dHI6ICd0YXJnZXQnXG4gICAgfSlcbiAgfSk7XG5cbiAgZnVuY3Rpb24gZGVmaW5lU291cmNlRnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHNvdXJjZUltcGwoc2VsZWN0b3IpIHtcbiAgICAgIHZhciBzb3VyY2VzID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgICAgdmFyIHNyYyA9IGVsZS5fcHJpdmF0ZVtwYXJhbXMuYXR0cl07XG5cbiAgICAgICAgaWYgKHNyYykge1xuICAgICAgICAgIHNvdXJjZXMucHVzaChzcmMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnNwYXduKHNvdXJjZXMsIHRydWUpLmZpbHRlcihzZWxlY3Rvcik7XG4gICAgfTtcbiAgfVxuXG4gIGV4dGVuZChlbGVzZm4kMiwge1xuICAgIGVkZ2VzV2l0aDogY2FjaGUoZGVmaW5lRWRnZXNXaXRoRnVuY3Rpb24oKSwgJ2VkZ2VzV2l0aCcpLFxuICAgIGVkZ2VzVG86IGNhY2hlKGRlZmluZUVkZ2VzV2l0aEZ1bmN0aW9uKHtcbiAgICAgIHRoaXNJc1NyYzogdHJ1ZVxuICAgIH0pLCAnZWRnZXNUbycpXG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGRlZmluZUVkZ2VzV2l0aEZ1bmN0aW9uKHBhcmFtcykge1xuICAgIHJldHVybiBmdW5jdGlvbiBlZGdlc1dpdGhJbXBsKG90aGVyTm9kZXMpIHtcbiAgICAgIHZhciBlbGVtZW50cyA9IFtdO1xuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgICAgIHZhciBwID0gcGFyYW1zIHx8IHt9OyAvLyBnZXQgZWxlbWVudHMgaWYgYSBzZWxlY3RvciBpcyBzcGVjaWZpZWRcblxuICAgICAgaWYgKHN0cmluZyhvdGhlck5vZGVzKSkge1xuICAgICAgICBvdGhlck5vZGVzID0gY3kuJChvdGhlck5vZGVzKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaCA9IDA7IGggPCBvdGhlck5vZGVzLmxlbmd0aDsgaCsrKSB7XG4gICAgICAgIHZhciBlZGdlcyA9IG90aGVyTm9kZXNbaF0uX3ByaXZhdGUuZWRnZXM7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBlZGdlID0gZWRnZXNbaV07XG4gICAgICAgICAgdmFyIGVkZ2VEYXRhID0gZWRnZS5fcHJpdmF0ZS5kYXRhO1xuICAgICAgICAgIHZhciB0aGlzVG9PdGhlciA9IHRoaXMuaGFzRWxlbWVudFdpdGhJZChlZGdlRGF0YS5zb3VyY2UpICYmIG90aGVyTm9kZXMuaGFzRWxlbWVudFdpdGhJZChlZGdlRGF0YS50YXJnZXQpO1xuICAgICAgICAgIHZhciBvdGhlclRvVGhpcyA9IG90aGVyTm9kZXMuaGFzRWxlbWVudFdpdGhJZChlZGdlRGF0YS5zb3VyY2UpICYmIHRoaXMuaGFzRWxlbWVudFdpdGhJZChlZGdlRGF0YS50YXJnZXQpO1xuICAgICAgICAgIHZhciBlZGdlQ29ubmVjdHNUaGlzQW5kT3RoZXIgPSB0aGlzVG9PdGhlciB8fCBvdGhlclRvVGhpcztcblxuICAgICAgICAgIGlmICghZWRnZUNvbm5lY3RzVGhpc0FuZE90aGVyKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocC50aGlzSXNTcmMgfHwgcC50aGlzSXNUZ3QpIHtcbiAgICAgICAgICAgIGlmIChwLnRoaXNJc1NyYyAmJiAhdGhpc1RvT3RoZXIpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwLnRoaXNJc1RndCAmJiAhb3RoZXJUb1RoaXMpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZWxlbWVudHMucHVzaChlZGdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5zcGF3bihlbGVtZW50cywgdHJ1ZSk7XG4gICAgfTtcbiAgfVxuXG4gIGV4dGVuZChlbGVzZm4kMiwge1xuICAgIGNvbm5lY3RlZEVkZ2VzOiBjYWNoZShmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgIHZhciByZXRFbGVzID0gW107XG4gICAgICB2YXIgZWxlcyA9IHRoaXM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm9kZSA9IGVsZXNbaV07XG5cbiAgICAgICAgaWYgKCFub2RlLmlzTm9kZSgpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZWRnZXMgPSBub2RlLl9wcml2YXRlLmVkZ2VzO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZWRnZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2pdO1xuICAgICAgICAgIHJldEVsZXMucHVzaChlZGdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5zcGF3bihyZXRFbGVzLCB0cnVlKS5maWx0ZXIoc2VsZWN0b3IpO1xuICAgIH0sICdjb25uZWN0ZWRFZGdlcycpLFxuICAgIGNvbm5lY3RlZE5vZGVzOiBjYWNoZShmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgIHZhciByZXRFbGVzID0gW107XG4gICAgICB2YXIgZWxlcyA9IHRoaXM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWRnZSA9IGVsZXNbaV07XG5cbiAgICAgICAgaWYgKCFlZGdlLmlzRWRnZSgpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXRFbGVzLnB1c2goZWRnZS5zb3VyY2UoKVswXSk7XG4gICAgICAgIHJldEVsZXMucHVzaChlZGdlLnRhcmdldCgpWzBdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuc3Bhd24ocmV0RWxlcywgdHJ1ZSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgICB9LCAnY29ubmVjdGVkTm9kZXMnKSxcbiAgICBwYXJhbGxlbEVkZ2VzOiBjYWNoZShkZWZpbmVQYXJhbGxlbEVkZ2VzRnVuY3Rpb24oKSwgJ3BhcmFsbGVsRWRnZXMnKSxcbiAgICBjb2RpcmVjdGVkRWRnZXM6IGNhY2hlKGRlZmluZVBhcmFsbGVsRWRnZXNGdW5jdGlvbih7XG4gICAgICBjb2RpcmVjdGVkOiB0cnVlXG4gICAgfSksICdjb2RpcmVjdGVkRWRnZXMnKVxuICB9KTtcblxuICBmdW5jdGlvbiBkZWZpbmVQYXJhbGxlbEVkZ2VzRnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgY29kaXJlY3RlZDogZmFsc2VcbiAgICB9O1xuICAgIHBhcmFtcyA9IGV4dGVuZCh7fSwgZGVmYXVsdHMsIHBhcmFtcyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHBhcmFsbGVsRWRnZXNJbXBsKHNlbGVjdG9yKSB7XG4gICAgICAvLyBtaWNyby1vcHRpbWlzZWQgZm9yIHJlbmRlcmVyXG4gICAgICB2YXIgZWxlbWVudHMgPSBbXTtcbiAgICAgIHZhciBlZGdlcyA9IHRoaXMuZWRnZXMoKTtcbiAgICAgIHZhciBwID0gcGFyYW1zOyAvLyBsb29rIGF0IGFsbCB0aGUgZWRnZXMgaW4gdGhlIGNvbGxlY3Rpb25cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWRnZTEgPSBlZGdlc1tpXTtcbiAgICAgICAgdmFyIGVkZ2UxX3AgPSBlZGdlMS5fcHJpdmF0ZTtcbiAgICAgICAgdmFyIHNyYzEgPSBlZGdlMV9wLnNvdXJjZTtcbiAgICAgICAgdmFyIHNyY2lkMSA9IHNyYzEuX3ByaXZhdGUuZGF0YS5pZDtcbiAgICAgICAgdmFyIHRndGlkMSA9IGVkZ2UxX3AuZGF0YS50YXJnZXQ7XG4gICAgICAgIHZhciBzcmNFZGdlczEgPSBzcmMxLl9wcml2YXRlLmVkZ2VzOyAvLyBsb29rIGF0IGVkZ2VzIGNvbm5lY3RlZCB0byB0aGUgc3JjIG5vZGUgb2YgdGhpcyBlZGdlXG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzcmNFZGdlczEubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB2YXIgZWRnZTIgPSBzcmNFZGdlczFbal07XG4gICAgICAgICAgdmFyIGVkZ2UyZGF0YSA9IGVkZ2UyLl9wcml2YXRlLmRhdGE7XG4gICAgICAgICAgdmFyIHRndGlkMiA9IGVkZ2UyZGF0YS50YXJnZXQ7XG4gICAgICAgICAgdmFyIHNyY2lkMiA9IGVkZ2UyZGF0YS5zb3VyY2U7XG4gICAgICAgICAgdmFyIGNvZGlyZWN0ZWQgPSB0Z3RpZDIgPT09IHRndGlkMSAmJiBzcmNpZDIgPT09IHNyY2lkMTtcbiAgICAgICAgICB2YXIgb3BwZGlyZWN0ZWQgPSBzcmNpZDEgPT09IHRndGlkMiAmJiB0Z3RpZDEgPT09IHNyY2lkMjtcblxuICAgICAgICAgIGlmIChwLmNvZGlyZWN0ZWQgJiYgY29kaXJlY3RlZCB8fCAhcC5jb2RpcmVjdGVkICYmIChjb2RpcmVjdGVkIHx8IG9wcGRpcmVjdGVkKSkge1xuICAgICAgICAgICAgZWxlbWVudHMucHVzaChlZGdlMik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnNwYXduKGVsZW1lbnRzLCB0cnVlKS5maWx0ZXIoc2VsZWN0b3IpO1xuICAgIH07XG4gIH0gLy8gTWlzYyBmdW5jdGlvbnNcbiAgLy8vLy8vLy8vLy8vLy8vLy9cblxuXG4gIGV4dGVuZChlbGVzZm4kMiwge1xuICAgIGNvbXBvbmVudHM6IGZ1bmN0aW9uIGNvbXBvbmVudHMocm9vdCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGN5ID0gc2VsZi5jeSgpO1xuICAgICAgdmFyIHZpc2l0ZWQgPSBjeS5jb2xsZWN0aW9uKCk7XG4gICAgICB2YXIgdW52aXNpdGVkID0gcm9vdCA9PSBudWxsID8gc2VsZi5ub2RlcygpIDogcm9vdC5ub2RlcygpO1xuICAgICAgdmFyIGNvbXBvbmVudHMgPSBbXTtcblxuICAgICAgaWYgKHJvb3QgIT0gbnVsbCAmJiB1bnZpc2l0ZWQuZW1wdHkoKSkge1xuICAgICAgICAvLyByb290IG1heSBjb250YWluIG9ubHkgZWRnZXNcbiAgICAgICAgdW52aXNpdGVkID0gcm9vdC5zb3VyY2VzKCk7IC8vIGRvZXNuJ3QgbWF0dGVyIHdoaWNoIG5vZGUgdG8gdXNlICh1bmRpcmVjdGVkKSwgc28ganVzdCB1c2UgdGhlIHNvdXJjZSBzaWRlc1xuICAgICAgfVxuXG4gICAgICB2YXIgdmlzaXRJbkNvbXBvbmVudCA9IGZ1bmN0aW9uIHZpc2l0SW5Db21wb25lbnQobm9kZSwgY29tcG9uZW50KSB7XG4gICAgICAgIHZpc2l0ZWQubWVyZ2Uobm9kZSk7XG4gICAgICAgIHVudmlzaXRlZC51bm1lcmdlKG5vZGUpO1xuICAgICAgICBjb21wb25lbnQubWVyZ2Uobm9kZSk7XG4gICAgICB9O1xuXG4gICAgICBpZiAodW52aXNpdGVkLmVtcHR5KCkpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuc3Bhd24oKTtcbiAgICAgIH1cblxuICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoKSB7XG4gICAgICAgIC8vIGVhY2ggaXRlcmF0aW9uIHlpZWxkcyBhIGNvbXBvbmVudFxuICAgICAgICB2YXIgY21wdCA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICAgICAgY29tcG9uZW50cy5wdXNoKGNtcHQpO1xuICAgICAgICB2YXIgcm9vdCA9IHVudmlzaXRlZFswXTtcbiAgICAgICAgdmlzaXRJbkNvbXBvbmVudChyb290LCBjbXB0KTtcbiAgICAgICAgc2VsZi5iZnMoe1xuICAgICAgICAgIGRpcmVjdGVkOiBmYWxzZSxcbiAgICAgICAgICByb290czogcm9vdCxcbiAgICAgICAgICB2aXNpdDogZnVuY3Rpb24gdmlzaXQodikge1xuICAgICAgICAgICAgcmV0dXJuIHZpc2l0SW5Db21wb25lbnQodiwgY21wdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY21wdC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgbm9kZS5jb25uZWN0ZWRFZGdlcygpLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIC8vIGNvbm5lY3RlZEVkZ2VzKCkgdXN1YWxseSBjYWNoZWRcbiAgICAgICAgICAgIGlmIChzZWxmLmhhcyhlKSAmJiBjbXB0LmhhcyhlLnNvdXJjZSgpKSAmJiBjbXB0LmhhcyhlLnRhcmdldCgpKSkge1xuICAgICAgICAgICAgICAvLyBoYXMoKSBpcyBjaGVhcFxuICAgICAgICAgICAgICBjbXB0Lm1lcmdlKGUpOyAvLyBmb3JFYWNoKCkgb25seSBjb25zaWRlcnMgbm9kZXMgLS0gc2V0cyBOIGF0IGNhbGwgdGltZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGRvIHtcbiAgICAgICAgX2xvb3AoKTtcbiAgICAgIH0gd2hpbGUgKHVudmlzaXRlZC5sZW5ndGggPiAwKTtcblxuICAgICAgcmV0dXJuIGNvbXBvbmVudHM7XG4gICAgfSxcbiAgICBjb21wb25lbnQ6IGZ1bmN0aW9uIGNvbXBvbmVudCgpIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgICAgcmV0dXJuIGVsZS5jeSgpLm11dGFibGVFbGVtZW50cygpLmNvbXBvbmVudHMoZWxlKVswXTtcbiAgICB9XG4gIH0pO1xuICBlbGVzZm4kMi5jb21wb25lbnRzT2YgPSBlbGVzZm4kMi5jb21wb25lbnRzO1xuXG4gIHZhciBDb2xsZWN0aW9uID0gZnVuY3Rpb24gQ29sbGVjdGlvbihjeSwgZWxlbWVudHMpIHtcbiAgICB2YXIgdW5pcXVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgICB2YXIgcmVtb3ZlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogZmFsc2U7XG5cbiAgICBpZiAoY3kgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZXJyb3IoJ0EgY29sbGVjdGlvbiBtdXN0IGhhdmUgYSByZWZlcmVuY2UgdG8gdGhlIGNvcmUnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbWFwID0gbmV3IE1hcCQyKCk7XG4gICAgdmFyIGNyZWF0ZWRFbGVtZW50cyA9IGZhbHNlO1xuXG4gICAgaWYgKCFlbGVtZW50cykge1xuICAgICAgZWxlbWVudHMgPSBbXTtcbiAgICB9IGVsc2UgaWYgKGVsZW1lbnRzLmxlbmd0aCA+IDAgJiYgcGxhaW5PYmplY3QoZWxlbWVudHNbMF0pICYmICFlbGVtZW50KGVsZW1lbnRzWzBdKSkge1xuICAgICAgY3JlYXRlZEVsZW1lbnRzID0gdHJ1ZTsgLy8gbWFrZSBlbGVtZW50cyBmcm9tIGpzb24gYW5kIHJlc3RvcmUgYWxsIGF0IG9uY2UgbGF0ZXJcblxuICAgICAgdmFyIGVsZXMgPSBbXTtcbiAgICAgIHZhciBlbGVzSWRzID0gbmV3IFNldCQxKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBqc29uID0gZWxlbWVudHNbaV07XG5cbiAgICAgICAgaWYgKGpzb24uZGF0YSA9PSBudWxsKSB7XG4gICAgICAgICAganNvbi5kYXRhID0ge307XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX2RhdGEgPSBqc29uLmRhdGE7IC8vIG1ha2Ugc3VyZSBuZXdseSBjcmVhdGVkIGVsZW1lbnRzIGhhdmUgdmFsaWQgaWRzXG5cbiAgICAgICAgaWYgKF9kYXRhLmlkID09IG51bGwpIHtcbiAgICAgICAgICBfZGF0YS5pZCA9IHV1aWQoKTtcbiAgICAgICAgfSBlbHNlIGlmIChjeS5oYXNFbGVtZW50V2l0aElkKF9kYXRhLmlkKSB8fCBlbGVzSWRzLmhhcyhfZGF0YS5pZCkpIHtcbiAgICAgICAgICBjb250aW51ZTsgLy8gY2FuJ3QgY3JlYXRlIGVsZW1lbnQgaWYgcHJpb3IgaWQgYWxyZWFkeSBleGlzdHNcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbGUgPSBuZXcgRWxlbWVudChjeSwganNvbiwgZmFsc2UpO1xuICAgICAgICBlbGVzLnB1c2goZWxlKTtcbiAgICAgICAgZWxlc0lkcy5hZGQoX2RhdGEuaWQpO1xuICAgICAgfVxuXG4gICAgICBlbGVtZW50cyA9IGVsZXM7XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSAwO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwLCBfbCA9IGVsZW1lbnRzLmxlbmd0aDsgX2kgPCBfbDsgX2krKykge1xuICAgICAgdmFyIGVsZW1lbnQkMSA9IGVsZW1lbnRzW19pXVswXTsgLy8gWzBdIGluIGNhc2UgZWxlbWVudHMgaXMgYW4gYXJyYXkgb2YgY29sbGVjdGlvbnMsIHJhdGhlciB0aGFuIGFycmF5IG9mIGVsZW1lbnRzXG5cbiAgICAgIGlmIChlbGVtZW50JDEgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGlkID0gZWxlbWVudCQxLl9wcml2YXRlLmRhdGEuaWQ7XG5cbiAgICAgIGlmICghdW5pcXVlIHx8ICFtYXAuaGFzKGlkKSkge1xuICAgICAgICBpZiAodW5pcXVlKSB7XG4gICAgICAgICAgbWFwLnNldChpZCwge1xuICAgICAgICAgICAgaW5kZXg6IHRoaXMubGVuZ3RoLFxuICAgICAgICAgICAgZWxlOiBlbGVtZW50JDFcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXNbdGhpcy5sZW5ndGhdID0gZWxlbWVudCQxO1xuICAgICAgICB0aGlzLmxlbmd0aCsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3ByaXZhdGUgPSB7XG4gICAgICBlbGVzOiB0aGlzLFxuICAgICAgY3k6IGN5LFxuXG4gICAgICBnZXQgbWFwKCkge1xuICAgICAgICBpZiAodGhpcy5sYXp5TWFwID09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLnJlYnVpbGRNYXAoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmxhenlNYXA7XG4gICAgICB9LFxuXG4gICAgICBzZXQgbWFwKG0pIHtcbiAgICAgICAgdGhpcy5sYXp5TWFwID0gbTtcbiAgICAgIH0sXG5cbiAgICAgIHJlYnVpbGRNYXA6IGZ1bmN0aW9uIHJlYnVpbGRNYXAoKSB7XG4gICAgICAgIHZhciBtID0gdGhpcy5sYXp5TWFwID0gbmV3IE1hcCQyKCk7XG4gICAgICAgIHZhciBlbGVzID0gdGhpcy5lbGVzO1xuXG4gICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGVsZXMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICAgIHZhciBfZWxlID0gZWxlc1tfaTJdO1xuICAgICAgICAgIG0uc2V0KF9lbGUuaWQoKSwge1xuICAgICAgICAgICAgaW5kZXg6IF9pMixcbiAgICAgICAgICAgIGVsZTogX2VsZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmICh1bmlxdWUpIHtcbiAgICAgIHRoaXMuX3ByaXZhdGUubWFwID0gbWFwO1xuICAgIH0gLy8gcmVzdG9yZSB0aGUgZWxlbWVudHMgaWYgd2UgY3JlYXRlZCB0aGVtIGZyb20ganNvblxuXG5cbiAgICBpZiAoY3JlYXRlZEVsZW1lbnRzICYmICFyZW1vdmVkKSB7XG4gICAgICB0aGlzLnJlc3RvcmUoKTtcbiAgICB9XG4gIH07IC8vIEZ1bmN0aW9uc1xuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vIGtlZXAgdGhlIHByb3RvdHlwZXMgaW4gc3luYyAoYW4gZWxlbWVudCBoYXMgdGhlIHNhbWUgZnVuY3Rpb25zIGFzIGEgY29sbGVjdGlvbilcbiAgLy8gYW5kIHVzZSBlbGVmbiBhbmQgZWxlc2ZuIGFzIHNob3J0aGFuZHMgdG8gdGhlIHByb3RvdHlwZXNcblxuXG4gIHZhciBlbGVzZm4kMSA9IEVsZW1lbnQucHJvdG90eXBlID0gQ29sbGVjdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEFycmF5LnByb3RvdHlwZSk7XG5cbiAgZWxlc2ZuJDEuaW5zdGFuY2VTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICdjb2xsZWN0aW9uJztcbiAgfTtcblxuICBlbGVzZm4kMS5zcGF3biA9IGZ1bmN0aW9uIChlbGVzLCB1bmlxdWUpIHtcbiAgICByZXR1cm4gbmV3IENvbGxlY3Rpb24odGhpcy5jeSgpLCBlbGVzLCB1bmlxdWUpO1xuICB9O1xuXG4gIGVsZXNmbiQxLnNwYXduU2VsZiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5zcGF3bih0aGlzKTtcbiAgfTtcblxuICBlbGVzZm4kMS5jeSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgfTtcblxuICBlbGVzZm4kMS5yZW5kZXJlciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5jeS5yZW5kZXJlcigpO1xuICB9O1xuXG4gIGVsZXNmbiQxLmVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXNbMF07XG4gIH07XG5cbiAgZWxlc2ZuJDEuY29sbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY29sbGVjdGlvbih0aGlzKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGFuIGVsZW1lbnRcbiAgICAgIHJldHVybiBuZXcgQ29sbGVjdGlvbih0aGlzLl9wcml2YXRlLmN5LCBbdGhpc10pO1xuICAgIH1cbiAgfTtcblxuICBlbGVzZm4kMS51bmlxdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uKHRoaXMuX3ByaXZhdGUuY3ksIHRoaXMsIHRydWUpO1xuICB9O1xuXG4gIGVsZXNmbiQxLmhhc0VsZW1lbnRXaXRoSWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICBpZCA9ICcnICsgaWQ7IC8vIGlkIG11c3QgYmUgc3RyaW5nXG5cbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5tYXAuaGFzKGlkKTtcbiAgfTtcblxuICBlbGVzZm4kMS5nZXRFbGVtZW50QnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgIGlkID0gJycgKyBpZDsgLy8gaWQgbXVzdCBiZSBzdHJpbmdcblxuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG5cbiAgICB2YXIgZW50cnkgPSB0aGlzLl9wcml2YXRlLm1hcC5nZXQoaWQpO1xuXG4gICAgcmV0dXJuIGVudHJ5ID8gZW50cnkuZWxlIDogbmV3IENvbGxlY3Rpb24oY3kpOyAvLyBnZXQgZWxlIG9yIGVtcHR5IGNvbGxlY3Rpb25cbiAgfTtcblxuICBlbGVzZm4kMS4kaWQgPSBlbGVzZm4kMS5nZXRFbGVtZW50QnlJZDtcblxuICBlbGVzZm4kMS5wb29sSW5kZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgICB2YXIgZWxlcyA9IGN5Ll9wcml2YXRlLmVsZW1lbnRzO1xuICAgIHZhciBpZCA9IHRoaXNbMF0uX3ByaXZhdGUuZGF0YS5pZDtcbiAgICByZXR1cm4gZWxlcy5fcHJpdmF0ZS5tYXAuZ2V0KGlkKS5pbmRleDtcbiAgfTtcblxuICBlbGVzZm4kMS5pbmRleE9mID0gZnVuY3Rpb24gKGVsZSkge1xuICAgIHZhciBpZCA9IGVsZVswXS5fcHJpdmF0ZS5kYXRhLmlkO1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLm1hcC5nZXQoaWQpLmluZGV4O1xuICB9O1xuXG4gIGVsZXNmbiQxLmluZGV4T2ZJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgIGlkID0gJycgKyBpZDsgLy8gaWQgbXVzdCBiZSBzdHJpbmdcblxuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLm1hcC5nZXQoaWQpLmluZGV4O1xuICB9O1xuXG4gIGVsZXNmbiQxLmpzb24gPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIGVsZSA9IHRoaXMuZWxlbWVudCgpO1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcblxuICAgIGlmIChlbGUgPT0gbnVsbCAmJiBvYmopIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gLy8gY2FuJ3Qgc2V0IHRvIG5vIGVsZXNcblxuXG4gICAgaWYgKGVsZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0gLy8gY2FuJ3QgZ2V0IGZyb20gbm8gZWxlc1xuXG5cbiAgICB2YXIgcCA9IGVsZS5fcHJpdmF0ZTtcblxuICAgIGlmIChwbGFpbk9iamVjdChvYmopKSB7XG4gICAgICAvLyBzZXRcbiAgICAgIGN5LnN0YXJ0QmF0Y2goKTtcblxuICAgICAgaWYgKG9iai5kYXRhKSB7XG4gICAgICAgIGVsZS5kYXRhKG9iai5kYXRhKTtcbiAgICAgICAgdmFyIF9kYXRhMiA9IHAuZGF0YTtcblxuICAgICAgICBpZiAoZWxlLmlzRWRnZSgpKSB7XG4gICAgICAgICAgLy8gc291cmNlIGFuZCB0YXJnZXQgYXJlIGltbXV0YWJsZSB2aWEgZGF0YSgpXG4gICAgICAgICAgdmFyIG1vdmUgPSBmYWxzZTtcbiAgICAgICAgICB2YXIgc3BlYyA9IHt9O1xuICAgICAgICAgIHZhciBzcmMgPSBvYmouZGF0YS5zb3VyY2U7XG4gICAgICAgICAgdmFyIHRndCA9IG9iai5kYXRhLnRhcmdldDtcblxuICAgICAgICAgIGlmIChzcmMgIT0gbnVsbCAmJiBzcmMgIT0gX2RhdGEyLnNvdXJjZSkge1xuICAgICAgICAgICAgc3BlYy5zb3VyY2UgPSAnJyArIHNyYzsgLy8gaWQgbXVzdCBiZSBzdHJpbmdcblxuICAgICAgICAgICAgbW92ZSA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRndCAhPSBudWxsICYmIHRndCAhPSBfZGF0YTIudGFyZ2V0KSB7XG4gICAgICAgICAgICBzcGVjLnRhcmdldCA9ICcnICsgdGd0OyAvLyBpZCBtdXN0IGJlIHN0cmluZ1xuXG4gICAgICAgICAgICBtb3ZlID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobW92ZSkge1xuICAgICAgICAgICAgZWxlID0gZWxlLm1vdmUoc3BlYyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHBhcmVudCBpcyBpbW11dGFibGUgdmlhIGRhdGEoKVxuICAgICAgICAgIHZhciBuZXdQYXJlbnRWYWxTcGVjZCA9ICgncGFyZW50JyBpbiBvYmouZGF0YSk7XG4gICAgICAgICAgdmFyIHBhcmVudCA9IG9iai5kYXRhLnBhcmVudDtcblxuICAgICAgICAgIGlmIChuZXdQYXJlbnRWYWxTcGVjZCAmJiAocGFyZW50ICE9IG51bGwgfHwgX2RhdGEyLnBhcmVudCAhPSBudWxsKSAmJiBwYXJlbnQgIT0gX2RhdGEyLnBhcmVudCkge1xuICAgICAgICAgICAgaWYgKHBhcmVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIC8vIGNhbid0IHNldCB1bmRlZmluZWQgaW1wZXJhdGl2ZWx5LCBzbyB1c2UgbnVsbFxuICAgICAgICAgICAgICBwYXJlbnQgPSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGFyZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgcGFyZW50ID0gJycgKyBwYXJlbnQ7IC8vIGlkIG11c3QgYmUgc3RyaW5nXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVsZSA9IGVsZS5tb3ZlKHtcbiAgICAgICAgICAgICAgcGFyZW50OiBwYXJlbnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob2JqLnBvc2l0aW9uKSB7XG4gICAgICAgIGVsZS5wb3NpdGlvbihvYmoucG9zaXRpb24pO1xuICAgICAgfSAvLyBpZ25vcmUgZ3JvdXAgLS0gaW1tdXRhYmxlXG5cblxuICAgICAgdmFyIGNoZWNrU3dpdGNoID0gZnVuY3Rpb24gY2hlY2tTd2l0Y2goaywgdHJ1ZUZuTmFtZSwgZmFsc2VGbk5hbWUpIHtcbiAgICAgICAgdmFyIG9ial9rID0gb2JqW2tdO1xuXG4gICAgICAgIGlmIChvYmpfayAhPSBudWxsICYmIG9ial9rICE9PSBwW2tdKSB7XG4gICAgICAgICAgaWYgKG9ial9rKSB7XG4gICAgICAgICAgICBlbGVbdHJ1ZUZuTmFtZV0oKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlW2ZhbHNlRm5OYW1lXSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgY2hlY2tTd2l0Y2goJ3JlbW92ZWQnLCAncmVtb3ZlJywgJ3Jlc3RvcmUnKTtcbiAgICAgIGNoZWNrU3dpdGNoKCdzZWxlY3RlZCcsICdzZWxlY3QnLCAndW5zZWxlY3QnKTtcbiAgICAgIGNoZWNrU3dpdGNoKCdzZWxlY3RhYmxlJywgJ3NlbGVjdGlmeScsICd1bnNlbGVjdGlmeScpO1xuICAgICAgY2hlY2tTd2l0Y2goJ2xvY2tlZCcsICdsb2NrJywgJ3VubG9jaycpO1xuICAgICAgY2hlY2tTd2l0Y2goJ2dyYWJiYWJsZScsICdncmFiaWZ5JywgJ3VuZ3JhYmlmeScpO1xuICAgICAgY2hlY2tTd2l0Y2goJ3Bhbm5hYmxlJywgJ3BhbmlmeScsICd1bnBhbmlmeScpO1xuXG4gICAgICBpZiAob2JqLmNsYXNzZXMgIT0gbnVsbCkge1xuICAgICAgICBlbGUuY2xhc3NlcyhvYmouY2xhc3Nlcyk7XG4gICAgICB9XG5cbiAgICAgIGN5LmVuZEJhdGNoKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2UgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBnZXRcbiAgICAgIHZhciBqc29uID0ge1xuICAgICAgICBkYXRhOiBjb3B5KHAuZGF0YSksXG4gICAgICAgIHBvc2l0aW9uOiBjb3B5KHAucG9zaXRpb24pLFxuICAgICAgICBncm91cDogcC5ncm91cCxcbiAgICAgICAgcmVtb3ZlZDogcC5yZW1vdmVkLFxuICAgICAgICBzZWxlY3RlZDogcC5zZWxlY3RlZCxcbiAgICAgICAgc2VsZWN0YWJsZTogcC5zZWxlY3RhYmxlLFxuICAgICAgICBsb2NrZWQ6IHAubG9ja2VkLFxuICAgICAgICBncmFiYmFibGU6IHAuZ3JhYmJhYmxlLFxuICAgICAgICBwYW5uYWJsZTogcC5wYW5uYWJsZSxcbiAgICAgICAgY2xhc3NlczogbnVsbFxuICAgICAgfTtcbiAgICAgIGpzb24uY2xhc3NlcyA9ICcnO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgcC5jbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKGNscykge1xuICAgICAgICByZXR1cm4ganNvbi5jbGFzc2VzICs9IGkrKyA9PT0gMCA/IGNscyA6ICcgJyArIGNscztcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGpzb247XG4gICAgfVxuICB9O1xuXG4gIGVsZXNmbiQxLmpzb25zID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBqc29ucyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgIHZhciBqc29uID0gZWxlLmpzb24oKTtcbiAgICAgIGpzb25zLnB1c2goanNvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGpzb25zO1xuICB9O1xuXG4gIGVsZXNmbiQxLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICB2YXIgZWxlc0FyciA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgIHZhciBqc29uID0gZWxlLmpzb24oKTtcbiAgICAgIHZhciBjbG9uZSA9IG5ldyBFbGVtZW50KGN5LCBqc29uLCBmYWxzZSk7IC8vIE5CIG5vIHJlc3RvcmVcblxuICAgICAgZWxlc0Fyci5wdXNoKGNsb25lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IENvbGxlY3Rpb24oY3ksIGVsZXNBcnIpO1xuICB9O1xuXG4gIGVsZXNmbiQxLmNvcHkgPSBlbGVzZm4kMS5jbG9uZTtcblxuICBlbGVzZm4kMS5yZXN0b3JlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBub3RpZnlSZW5kZXJlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdHJ1ZTtcbiAgICB2YXIgYWRkVG9Qb29sID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY3kgPSBzZWxmLmN5KCk7XG4gICAgdmFyIGN5X3AgPSBjeS5fcHJpdmF0ZTsgLy8gY3JlYXRlIGFycmF5cyBvZiBub2RlcyBhbmQgZWRnZXMsIHNpbmNlIHdlIG5lZWQgdG9cbiAgICAvLyByZXN0b3JlIHRoZSBub2RlcyBmaXJzdFxuXG4gICAgdmFyIG5vZGVzID0gW107XG4gICAgdmFyIGVkZ2VzID0gW107XG4gICAgdmFyIGVsZW1lbnRzO1xuXG4gICAgZm9yICh2YXIgX2kzID0gMCwgbCA9IHNlbGYubGVuZ3RoOyBfaTMgPCBsOyBfaTMrKykge1xuICAgICAgdmFyIGVsZSA9IHNlbGZbX2kzXTtcblxuICAgICAgaWYgKGFkZFRvUG9vbCAmJiAhZWxlLnJlbW92ZWQoKSkge1xuICAgICAgICAvLyBkb24ndCBuZWVkIHRvIGhhbmRsZSB0aGlzIGVsZVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8ga2VlcCBub2RlcyBmaXJzdCBpbiB0aGUgYXJyYXkgYW5kIGVkZ2VzIGFmdGVyXG5cblxuICAgICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgICAvLyBwdXQgdG8gZnJvbnQgb2YgYXJyYXkgaWYgbm9kZVxuICAgICAgICBub2Rlcy5wdXNoKGVsZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBwdXQgdG8gZW5kIG9mIGFycmF5IGlmIGVkZ2VcbiAgICAgICAgZWRnZXMucHVzaChlbGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGVsZW1lbnRzID0gbm9kZXMuY29uY2F0KGVkZ2VzKTtcbiAgICB2YXIgaTtcblxuICAgIHZhciByZW1vdmVGcm9tRWxlbWVudHMgPSBmdW5jdGlvbiByZW1vdmVGcm9tRWxlbWVudHMoKSB7XG4gICAgICBlbGVtZW50cy5zcGxpY2UoaSwgMSk7XG4gICAgICBpLS07XG4gICAgfTsgLy8gbm93LCByZXN0b3JlIGVhY2ggZWxlbWVudFxuXG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBfZWxlMiA9IGVsZW1lbnRzW2ldO1xuICAgICAgdmFyIF9wcml2YXRlID0gX2VsZTIuX3ByaXZhdGU7XG4gICAgICB2YXIgX2RhdGEzID0gX3ByaXZhdGUuZGF0YTsgLy8gdGhlIHRyYXZlcnNhbCBjYWNoZSBzaG91bGQgc3RhcnQgZnJlc2ggd2hlbiBlbGUgaXMgYWRkZWRcblxuICAgICAgX2VsZTIuY2xlYXJUcmF2ZXJzYWxDYWNoZSgpOyAvLyBzZXQgaWQgYW5kIHZhbGlkYXRlXG5cblxuICAgICAgaWYgKCFhZGRUb1Bvb2wgJiYgIV9wcml2YXRlLnJlbW92ZWQpIDsgZWxzZSBpZiAoX2RhdGEzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgX2RhdGEzLmlkID0gdXVpZCgpO1xuICAgICAgfSBlbHNlIGlmIChudW1iZXIkMShfZGF0YTMuaWQpKSB7XG4gICAgICAgIF9kYXRhMy5pZCA9ICcnICsgX2RhdGEzLmlkOyAvLyBub3cgaXQncyBhIHN0cmluZ1xuICAgICAgfSBlbHNlIGlmIChlbXB0eVN0cmluZyhfZGF0YTMuaWQpIHx8ICFzdHJpbmcoX2RhdGEzLmlkKSkge1xuICAgICAgICBlcnJvcignQ2FuIG5vdCBjcmVhdGUgZWxlbWVudCB3aXRoIGludmFsaWQgc3RyaW5nIElEIGAnICsgX2RhdGEzLmlkICsgJ2AnKTsgLy8gY2FuJ3QgY3JlYXRlIGVsZW1lbnQgaWYgaXQgaGFzIGVtcHR5IHN0cmluZyBhcyBpZCBvciBub24tc3RyaW5nIGlkXG5cbiAgICAgICAgcmVtb3ZlRnJvbUVsZW1lbnRzKCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIGlmIChjeS5oYXNFbGVtZW50V2l0aElkKF9kYXRhMy5pZCkpIHtcbiAgICAgICAgZXJyb3IoJ0NhbiBub3QgY3JlYXRlIHNlY29uZCBlbGVtZW50IHdpdGggSUQgYCcgKyBfZGF0YTMuaWQgKyAnYCcpOyAvLyBjYW4ndCBjcmVhdGUgZWxlbWVudCBpZiBvbmUgYWxyZWFkeSBoYXMgdGhhdCBpZFxuXG4gICAgICAgIHJlbW92ZUZyb21FbGVtZW50cygpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGlkID0gX2RhdGEzLmlkOyAvLyBpZCBpcyBmaW5hbGlzZWQsIG5vdyBsZXQncyBrZWVwIGEgcmVmXG5cbiAgICAgIGlmIChfZWxlMi5pc05vZGUoKSkge1xuICAgICAgICAvLyBleHRyYSBjaGVja3MgZm9yIG5vZGVzXG4gICAgICAgIHZhciBwb3MgPSBfcHJpdmF0ZS5wb3NpdGlvbjsgLy8gbWFrZSBzdXJlIHRoZSBub2RlcyBoYXZlIGEgZGVmaW5lZCBwb3NpdGlvblxuXG4gICAgICAgIGlmIChwb3MueCA9PSBudWxsKSB7XG4gICAgICAgICAgcG9zLnggPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvcy55ID09IG51bGwpIHtcbiAgICAgICAgICBwb3MueSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKF9lbGUyLmlzRWRnZSgpKSB7XG4gICAgICAgIC8vIGV4dHJhIGNoZWNrcyBmb3IgZWRnZXNcbiAgICAgICAgdmFyIGVkZ2UgPSBfZWxlMjtcbiAgICAgICAgdmFyIGZpZWxkcyA9IFsnc291cmNlJywgJ3RhcmdldCddO1xuICAgICAgICB2YXIgZmllbGRzTGVuZ3RoID0gZmllbGRzLmxlbmd0aDtcbiAgICAgICAgdmFyIGJhZFNvdXJjZU9yVGFyZ2V0ID0gZmFsc2U7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBmaWVsZHNMZW5ndGg7IGorKykge1xuICAgICAgICAgIHZhciBmaWVsZCA9IGZpZWxkc1tqXTtcbiAgICAgICAgICB2YXIgdmFsID0gX2RhdGEzW2ZpZWxkXTtcblxuICAgICAgICAgIGlmIChudW1iZXIkMSh2YWwpKSB7XG4gICAgICAgICAgICB2YWwgPSBfZGF0YTNbZmllbGRdID0gJycgKyBfZGF0YTNbZmllbGRdOyAvLyBub3cgc3RyaW5nXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHZhbCA9PSBudWxsIHx8IHZhbCA9PT0gJycpIHtcbiAgICAgICAgICAgIC8vIGNhbid0IGNyZWF0ZSBpZiBzb3VyY2Ugb3IgdGFyZ2V0IGlzIG5vdCBkZWZpbmVkIHByb3Blcmx5XG4gICAgICAgICAgICBlcnJvcignQ2FuIG5vdCBjcmVhdGUgZWRnZSBgJyArIGlkICsgJ2Agd2l0aCB1bnNwZWNpZmllZCAnICsgZmllbGQpO1xuICAgICAgICAgICAgYmFkU291cmNlT3JUYXJnZXQgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIWN5Lmhhc0VsZW1lbnRXaXRoSWQodmFsKSkge1xuICAgICAgICAgICAgLy8gY2FuJ3QgY3JlYXRlIGVkZ2UgaWYgb25lIG9mIGl0cyBub2RlcyBkb2Vzbid0IGV4aXN0XG4gICAgICAgICAgICBlcnJvcignQ2FuIG5vdCBjcmVhdGUgZWRnZSBgJyArIGlkICsgJ2Agd2l0aCBub25leGlzdGFudCAnICsgZmllbGQgKyAnIGAnICsgdmFsICsgJ2AnKTtcbiAgICAgICAgICAgIGJhZFNvdXJjZU9yVGFyZ2V0ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYmFkU291cmNlT3JUYXJnZXQpIHtcbiAgICAgICAgICByZW1vdmVGcm9tRWxlbWVudHMoKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBjYW4ndCBjcmVhdGUgdGhpc1xuXG5cbiAgICAgICAgdmFyIHNyYyA9IGN5LmdldEVsZW1lbnRCeUlkKF9kYXRhMy5zb3VyY2UpO1xuICAgICAgICB2YXIgdGd0ID0gY3kuZ2V0RWxlbWVudEJ5SWQoX2RhdGEzLnRhcmdldCk7IC8vIG9ubHkgb25lIGVkZ2UgaW4gbm9kZSBpZiBsb29wXG5cbiAgICAgICAgaWYgKHNyYy5zYW1lKHRndCkpIHtcbiAgICAgICAgICBzcmMuX3ByaXZhdGUuZWRnZXMucHVzaChlZGdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzcmMuX3ByaXZhdGUuZWRnZXMucHVzaChlZGdlKTtcblxuICAgICAgICAgIHRndC5fcHJpdmF0ZS5lZGdlcy5wdXNoKGVkZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgZWRnZS5fcHJpdmF0ZS5zb3VyY2UgPSBzcmM7XG4gICAgICAgIGVkZ2UuX3ByaXZhdGUudGFyZ2V0ID0gdGd0O1xuICAgICAgfSAvLyBpZiBpcyBlZGdlXG4gICAgICAvLyBjcmVhdGUgbW9jayBpZHMgLyBpbmRleGVzIG1hcHMgZm9yIGVsZW1lbnQgc28gaXQgY2FuIGJlIHVzZWQgbGlrZSBjb2xsZWN0aW9uc1xuXG5cbiAgICAgIF9wcml2YXRlLm1hcCA9IG5ldyBNYXAkMigpO1xuXG4gICAgICBfcHJpdmF0ZS5tYXAuc2V0KGlkLCB7XG4gICAgICAgIGVsZTogX2VsZTIsXG4gICAgICAgIGluZGV4OiAwXG4gICAgICB9KTtcblxuICAgICAgX3ByaXZhdGUucmVtb3ZlZCA9IGZhbHNlO1xuXG4gICAgICBpZiAoYWRkVG9Qb29sKSB7XG4gICAgICAgIGN5LmFkZFRvUG9vbChfZWxlMik7XG4gICAgICB9XG4gICAgfSAvLyBmb3IgZWFjaCBlbGVtZW50XG4gICAgLy8gZG8gY29tcG91bmQgbm9kZSBzYW5pdHkgY2hlY2tzXG5cblxuICAgIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IG5vZGVzLmxlbmd0aDsgX2k0KyspIHtcbiAgICAgIC8vIGVhY2ggbm9kZVxuICAgICAgdmFyIG5vZGUgPSBub2Rlc1tfaTRdO1xuICAgICAgdmFyIF9kYXRhNCA9IG5vZGUuX3ByaXZhdGUuZGF0YTtcblxuICAgICAgaWYgKG51bWJlciQxKF9kYXRhNC5wYXJlbnQpKSB7XG4gICAgICAgIC8vIHRoZW4gYXV0b21ha2Ugc3RyaW5nXG4gICAgICAgIF9kYXRhNC5wYXJlbnQgPSAnJyArIF9kYXRhNC5wYXJlbnQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBwYXJlbnRJZCA9IF9kYXRhNC5wYXJlbnQ7XG4gICAgICB2YXIgc3BlY2lmaWVkUGFyZW50ID0gcGFyZW50SWQgIT0gbnVsbDtcblxuICAgICAgaWYgKHNwZWNpZmllZFBhcmVudCB8fCBub2RlLl9wcml2YXRlLnBhcmVudCkge1xuICAgICAgICB2YXIgcGFyZW50ID0gbm9kZS5fcHJpdmF0ZS5wYXJlbnQgPyBjeS5jb2xsZWN0aW9uKCkubWVyZ2Uobm9kZS5fcHJpdmF0ZS5wYXJlbnQpIDogY3kuZ2V0RWxlbWVudEJ5SWQocGFyZW50SWQpO1xuXG4gICAgICAgIGlmIChwYXJlbnQuZW1wdHkoKSkge1xuICAgICAgICAgIC8vIG5vbi1leGlzdGFudCBwYXJlbnQ7IGp1c3QgcmVtb3ZlIGl0XG4gICAgICAgICAgX2RhdGE0LnBhcmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSBlbHNlIGlmIChwYXJlbnRbMF0ucmVtb3ZlZCgpKSB7XG4gICAgICAgICAgd2FybignTm9kZSBhZGRlZCB3aXRoIG1pc3NpbmcgcGFyZW50LCByZWZlcmVuY2UgdG8gcGFyZW50IHJlbW92ZWQnKTtcbiAgICAgICAgICBfZGF0YTQucGFyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5vZGUuX3ByaXZhdGUucGFyZW50ID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgc2VsZkFzUGFyZW50ID0gZmFsc2U7XG4gICAgICAgICAgdmFyIGFuY2VzdG9yID0gcGFyZW50O1xuXG4gICAgICAgICAgd2hpbGUgKCFhbmNlc3Rvci5lbXB0eSgpKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5zYW1lKGFuY2VzdG9yKSkge1xuICAgICAgICAgICAgICAvLyBtYXJrIHNlbGYgYXMgcGFyZW50IGFuZCByZW1vdmUgZnJvbSBkYXRhXG4gICAgICAgICAgICAgIHNlbGZBc1BhcmVudCA9IHRydWU7XG4gICAgICAgICAgICAgIF9kYXRhNC5wYXJlbnQgPSB1bmRlZmluZWQ7IC8vIHJlbW92ZSBwYXJlbnQgcmVmZXJlbmNlXG4gICAgICAgICAgICAgIC8vIGV4aXQgb3Igd2UgbG9vcCBmb3JldmVyXG5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFzZWxmQXNQYXJlbnQpIHtcbiAgICAgICAgICAgIC8vIGNvbm5lY3Qgd2l0aCBjaGlsZHJlblxuICAgICAgICAgICAgcGFyZW50WzBdLl9wcml2YXRlLmNoaWxkcmVuLnB1c2gobm9kZSk7XG5cbiAgICAgICAgICAgIG5vZGUuX3ByaXZhdGUucGFyZW50ID0gcGFyZW50WzBdOyAvLyBsZXQgdGhlIGNvcmUga25vdyB3ZSBoYXZlIGEgY29tcG91bmQgZ3JhcGhcblxuICAgICAgICAgICAgY3lfcC5oYXNDb21wb3VuZE5vZGVzID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gZWxzZVxuXG4gICAgICB9IC8vIGlmIHNwZWNpZmllZCBwYXJlbnRcblxuICAgIH0gLy8gZm9yIGVhY2ggbm9kZVxuXG5cbiAgICBpZiAoZWxlbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIHJlc3RvcmVkID0gZWxlbWVudHMubGVuZ3RoID09PSBzZWxmLmxlbmd0aCA/IHNlbGYgOiBuZXcgQ29sbGVjdGlvbihjeSwgZWxlbWVudHMpO1xuXG4gICAgICBmb3IgKHZhciBfaTUgPSAwOyBfaTUgPCByZXN0b3JlZC5sZW5ndGg7IF9pNSsrKSB7XG4gICAgICAgIHZhciBfZWxlMyA9IHJlc3RvcmVkW19pNV07XG5cbiAgICAgICAgaWYgKF9lbGUzLmlzTm9kZSgpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gYWRkaW5nIGFuIGVkZ2UgaW52YWxpZGF0ZXMgdGhlIHRyYXZlcnNhbCBjYWNoZXMgZm9yIHRoZSBwYXJhbGxlbCBlZGdlc1xuXG5cbiAgICAgICAgX2VsZTMucGFyYWxsZWxFZGdlcygpLmNsZWFyVHJhdmVyc2FsQ2FjaGUoKTsgLy8gYWRkaW5nIGFuIGVkZ2UgaW52YWxpZGF0ZXMgdGhlIHRyYXZlcnNhbCBjYWNoZSBmb3IgdGhlIGNvbm5lY3RlZCBub2Rlc1xuXG5cbiAgICAgICAgX2VsZTMuc291cmNlKCkuY2xlYXJUcmF2ZXJzYWxDYWNoZSgpO1xuXG4gICAgICAgIF9lbGUzLnRhcmdldCgpLmNsZWFyVHJhdmVyc2FsQ2FjaGUoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRvVXBkYXRlU3R5bGU7XG5cbiAgICAgIGlmIChjeV9wLmhhc0NvbXBvdW5kTm9kZXMpIHtcbiAgICAgICAgdG9VcGRhdGVTdHlsZSA9IGN5LmNvbGxlY3Rpb24oKS5tZXJnZShyZXN0b3JlZCkubWVyZ2UocmVzdG9yZWQuY29ubmVjdGVkTm9kZXMoKSkubWVyZ2UocmVzdG9yZWQucGFyZW50KCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9VcGRhdGVTdHlsZSA9IHJlc3RvcmVkO1xuICAgICAgfVxuXG4gICAgICB0b1VwZGF0ZVN0eWxlLmRpcnR5Q29tcG91bmRCb3VuZHNDYWNoZSgpLmRpcnR5Qm91bmRpbmdCb3hDYWNoZSgpLnVwZGF0ZVN0eWxlKG5vdGlmeVJlbmRlcmVyKTtcblxuICAgICAgaWYgKG5vdGlmeVJlbmRlcmVyKSB7XG4gICAgICAgIHJlc3RvcmVkLmVtaXRBbmROb3RpZnkoJ2FkZCcpO1xuICAgICAgfSBlbHNlIGlmIChhZGRUb1Bvb2wpIHtcbiAgICAgICAgcmVzdG9yZWQuZW1pdCgnYWRkJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGY7IC8vIGNoYWluYWJpbGl0eVxuICB9O1xuXG4gIGVsZXNmbiQxLnJlbW92ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgcmV0dXJuIGVsZSAmJiBlbGUuX3ByaXZhdGUucmVtb3ZlZDtcbiAgfTtcblxuICBlbGVzZm4kMS5pbnNpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgcmV0dXJuIGVsZSAmJiAhZWxlLl9wcml2YXRlLnJlbW92ZWQ7XG4gIH07XG5cbiAgZWxlc2ZuJDEucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBub3RpZnlSZW5kZXJlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdHJ1ZTtcbiAgICB2YXIgcmVtb3ZlRnJvbVBvb2wgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBlbGVzVG9SZW1vdmUgPSBbXTtcbiAgICB2YXIgZWxlc1RvUmVtb3ZlSWRzID0ge307XG4gICAgdmFyIGN5ID0gc2VsZi5fcHJpdmF0ZS5jeTsgLy8gYWRkIGNvbm5lY3RlZCBlZGdlc1xuXG4gICAgZnVuY3Rpb24gYWRkQ29ubmVjdGVkRWRnZXMobm9kZSkge1xuICAgICAgdmFyIGVkZ2VzID0gbm9kZS5fcHJpdmF0ZS5lZGdlcztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBhZGQoZWRnZXNbaV0pO1xuICAgICAgfVxuICAgIH0gLy8gYWRkIGRlc2NlbmRhbnQgbm9kZXNcblxuXG4gICAgZnVuY3Rpb24gYWRkQ2hpbGRyZW4obm9kZSkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gbm9kZS5fcHJpdmF0ZS5jaGlsZHJlbjtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBhZGQoY2hpbGRyZW5baV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZChlbGUpIHtcbiAgICAgIHZhciBhbHJlYWR5QWRkZWQgPSBlbGVzVG9SZW1vdmVJZHNbZWxlLmlkKCldO1xuXG4gICAgICBpZiAocmVtb3ZlRnJvbVBvb2wgJiYgZWxlLnJlbW92ZWQoKSB8fCBhbHJlYWR5QWRkZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlc1RvUmVtb3ZlSWRzW2VsZS5pZCgpXSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbGUuaXNOb2RlKCkpIHtcbiAgICAgICAgZWxlc1RvUmVtb3ZlLnB1c2goZWxlKTsgLy8gbm9kZXMgYXJlIHJlbW92ZWQgbGFzdFxuXG4gICAgICAgIGFkZENvbm5lY3RlZEVkZ2VzKGVsZSk7XG4gICAgICAgIGFkZENoaWxkcmVuKGVsZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVzVG9SZW1vdmUudW5zaGlmdChlbGUpOyAvLyBlZGdlcyBhcmUgcmVtb3ZlZCBmaXJzdFxuICAgICAgfVxuICAgIH0gLy8gbWFrZSB0aGUgbGlzdCBvZiBlbGVtZW50cyB0byByZW1vdmVcbiAgICAvLyAobWF5IGJlIHJlbW92aW5nIG1vcmUgdGhhbiBzcGVjaWZpZWQgZHVlIHRvIGNvbm5lY3RlZCBlZGdlcyBldGMpXG5cblxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gc2VsZi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSBzZWxmW2ldO1xuICAgICAgYWRkKGVsZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlRWRnZVJlZihub2RlLCBlZGdlKSB7XG4gICAgICB2YXIgY29ubmVjdGVkRWRnZXMgPSBub2RlLl9wcml2YXRlLmVkZ2VzO1xuICAgICAgcmVtb3ZlRnJvbUFycmF5KGNvbm5lY3RlZEVkZ2VzLCBlZGdlKTsgLy8gcmVtb3ZpbmcgYW4gZWRnZXMgaW52YWxpZGF0ZXMgdGhlIHRyYXZlcnNhbCBjYWNoZSBmb3IgaXRzIG5vZGVzXG5cbiAgICAgIG5vZGUuY2xlYXJUcmF2ZXJzYWxDYWNoZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZVBhcmFsbGVsUmVmKHBsbEVkZ2UpIHtcbiAgICAgIC8vIHJlbW92aW5nIGFuIGVkZ2UgaW52YWxpZGF0ZXMgdGhlIHRyYXZlcnNhbCBjYWNoZXMgZm9yIHRoZSBwYXJhbGxlbCBlZGdlc1xuICAgICAgcGxsRWRnZS5jbGVhclRyYXZlcnNhbENhY2hlKCk7XG4gICAgfVxuXG4gICAgdmFyIGFsdGVyZWRQYXJlbnRzID0gW107XG4gICAgYWx0ZXJlZFBhcmVudHMuaWRzID0ge307XG5cbiAgICBmdW5jdGlvbiByZW1vdmVDaGlsZFJlZihwYXJlbnQsIGVsZSkge1xuICAgICAgZWxlID0gZWxlWzBdO1xuICAgICAgcGFyZW50ID0gcGFyZW50WzBdO1xuICAgICAgdmFyIGNoaWxkcmVuID0gcGFyZW50Ll9wcml2YXRlLmNoaWxkcmVuO1xuICAgICAgdmFyIHBpZCA9IHBhcmVudC5pZCgpO1xuICAgICAgcmVtb3ZlRnJvbUFycmF5KGNoaWxkcmVuLCBlbGUpOyAvLyByZW1vdmUgcGFyZW50ID0+IGNoaWxkIHJlZlxuXG4gICAgICBlbGUuX3ByaXZhdGUucGFyZW50ID0gbnVsbDsgLy8gcmVtb3ZlIGNoaWxkID0+IHBhcmVudCByZWZcblxuICAgICAgaWYgKCFhbHRlcmVkUGFyZW50cy5pZHNbcGlkXSkge1xuICAgICAgICBhbHRlcmVkUGFyZW50cy5pZHNbcGlkXSA9IHRydWU7XG4gICAgICAgIGFsdGVyZWRQYXJlbnRzLnB1c2gocGFyZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmLmRpcnR5Q29tcG91bmRCb3VuZHNDYWNoZSgpO1xuXG4gICAgaWYgKHJlbW92ZUZyb21Qb29sKSB7XG4gICAgICBjeS5yZW1vdmVGcm9tUG9vbChlbGVzVG9SZW1vdmUpOyAvLyByZW1vdmUgZnJvbSBjb3JlIHBvb2xcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaTYgPSAwOyBfaTYgPCBlbGVzVG9SZW1vdmUubGVuZ3RoOyBfaTYrKykge1xuICAgICAgdmFyIF9lbGU0ID0gZWxlc1RvUmVtb3ZlW19pNl07XG5cbiAgICAgIGlmIChfZWxlNC5pc0VkZ2UoKSkge1xuICAgICAgICAvLyByZW1vdmUgcmVmZXJlbmNlcyB0byB0aGlzIGVkZ2UgaW4gaXRzIGNvbm5lY3RlZCBub2Rlc1xuICAgICAgICB2YXIgc3JjID0gX2VsZTQuc291cmNlKClbMF07XG5cbiAgICAgICAgdmFyIHRndCA9IF9lbGU0LnRhcmdldCgpWzBdO1xuXG4gICAgICAgIHJlbW92ZUVkZ2VSZWYoc3JjLCBfZWxlNCk7XG4gICAgICAgIHJlbW92ZUVkZ2VSZWYodGd0LCBfZWxlNCk7XG5cbiAgICAgICAgdmFyIHBsbEVkZ2VzID0gX2VsZTQucGFyYWxsZWxFZGdlcygpO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcGxsRWRnZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB2YXIgcGxsRWRnZSA9IHBsbEVkZ2VzW2pdO1xuICAgICAgICAgIHJlbW92ZVBhcmFsbGVsUmVmKHBsbEVkZ2UpO1xuXG4gICAgICAgICAgaWYgKHBsbEVkZ2UuaXNCdW5kbGVkQmV6aWVyKCkpIHtcbiAgICAgICAgICAgIHBsbEVkZ2UuZGlydHlCb3VuZGluZ0JveENhY2hlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyByZW1vdmUgcmVmZXJlbmNlIHRvIHBhcmVudFxuICAgICAgICB2YXIgcGFyZW50ID0gX2VsZTQucGFyZW50KCk7XG5cbiAgICAgICAgaWYgKHBhcmVudC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICByZW1vdmVDaGlsZFJlZihwYXJlbnQsIF9lbGU0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocmVtb3ZlRnJvbVBvb2wpIHtcbiAgICAgICAgLy8gbWFyayBhcyByZW1vdmVkXG4gICAgICAgIF9lbGU0Ll9wcml2YXRlLnJlbW92ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gLy8gY2hlY2sgdG8gc2VlIGlmIHdlIGhhdmUgYSBjb21wb3VuZCBncmFwaCBvciBub3RcblxuXG4gICAgdmFyIGVsZXNTdGlsbEluc2lkZSA9IGN5Ll9wcml2YXRlLmVsZW1lbnRzO1xuICAgIGN5Ll9wcml2YXRlLmhhc0NvbXBvdW5kTm9kZXMgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIF9pNyA9IDA7IF9pNyA8IGVsZXNTdGlsbEluc2lkZS5sZW5ndGg7IF9pNysrKSB7XG4gICAgICB2YXIgX2VsZTUgPSBlbGVzU3RpbGxJbnNpZGVbX2k3XTtcblxuICAgICAgaWYgKF9lbGU1LmlzUGFyZW50KCkpIHtcbiAgICAgICAgY3kuX3ByaXZhdGUuaGFzQ29tcG91bmROb2RlcyA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZW1vdmVkRWxlbWVudHMgPSBuZXcgQ29sbGVjdGlvbih0aGlzLmN5KCksIGVsZXNUb1JlbW92ZSk7XG5cbiAgICBpZiAocmVtb3ZlZEVsZW1lbnRzLnNpemUoKSA+IDApIHtcbiAgICAgIC8vIG11c3QgbWFudWFsbHkgbm90aWZ5IHNpbmNlIHRyaWdnZXIgd29uJ3QgZG8gdGhpcyBhdXRvbWF0aWNhbGx5IG9uY2UgcmVtb3ZlZFxuICAgICAgaWYgKG5vdGlmeVJlbmRlcmVyKSB7XG4gICAgICAgIHJlbW92ZWRFbGVtZW50cy5lbWl0QW5kTm90aWZ5KCdyZW1vdmUnKTtcbiAgICAgIH0gZWxzZSBpZiAocmVtb3ZlRnJvbVBvb2wpIHtcbiAgICAgICAgcmVtb3ZlZEVsZW1lbnRzLmVtaXQoJ3JlbW92ZScpO1xuICAgICAgfVxuICAgIH0gLy8gdGhlIHBhcmVudHMgd2hvIHdlcmUgbW9kaWZpZWQgYnkgdGhlIHJlbW92YWwgbmVlZCB0aGVpciBzdHlsZSB1cGRhdGVkXG5cblxuICAgIGZvciAodmFyIF9pOCA9IDA7IF9pOCA8IGFsdGVyZWRQYXJlbnRzLmxlbmd0aDsgX2k4KyspIHtcbiAgICAgIHZhciBfZWxlNiA9IGFsdGVyZWRQYXJlbnRzW19pOF07XG5cbiAgICAgIGlmICghcmVtb3ZlRnJvbVBvb2wgfHwgIV9lbGU2LnJlbW92ZWQoKSkge1xuICAgICAgICBfZWxlNi51cGRhdGVTdHlsZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZW1vdmVkRWxlbWVudHM7XG4gIH07XG5cbiAgZWxlc2ZuJDEubW92ZSA9IGZ1bmN0aW9uIChzdHJ1Y3QpIHtcbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgIHZhciBlbGVzID0gdGhpczsgLy8ganVzdCBjbGVhbiB1cCByZWZzLCBjYWNoZXMsIGV0Yy4gaW4gdGhlIHNhbWUgd2F5IGFzIHdoZW4gcmVtb3ZpbmcgYW5kIHRoZW4gcmVzdG9yaW5nXG4gICAgLy8gKG91ciBjYWxscyB0byByZW1vdmUvcmVzdG9yZSBkbyBub3QgcmVtb3ZlIGZyb20gdGhlIGdyYXBoIG9yIG1ha2UgZXZlbnRzKVxuXG4gICAgdmFyIG5vdGlmeVJlbmRlcmVyID0gZmFsc2U7XG4gICAgdmFyIG1vZGlmeVBvb2wgPSBmYWxzZTtcblxuICAgIHZhciB0b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKGlkKSB7XG4gICAgICByZXR1cm4gaWQgPT0gbnVsbCA/IGlkIDogJycgKyBpZDtcbiAgICB9OyAvLyBpZCBtdXN0IGJlIHN0cmluZ1xuXG5cbiAgICBpZiAoc3RydWN0LnNvdXJjZSAhPT0gdW5kZWZpbmVkIHx8IHN0cnVjdC50YXJnZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIHNyY0lkID0gdG9TdHJpbmcoc3RydWN0LnNvdXJjZSk7XG4gICAgICB2YXIgdGd0SWQgPSB0b1N0cmluZyhzdHJ1Y3QudGFyZ2V0KTtcbiAgICAgIHZhciBzcmNFeGlzdHMgPSBzcmNJZCAhPSBudWxsICYmIGN5Lmhhc0VsZW1lbnRXaXRoSWQoc3JjSWQpO1xuICAgICAgdmFyIHRndEV4aXN0cyA9IHRndElkICE9IG51bGwgJiYgY3kuaGFzRWxlbWVudFdpdGhJZCh0Z3RJZCk7XG5cbiAgICAgIGlmIChzcmNFeGlzdHMgfHwgdGd0RXhpc3RzKSB7XG4gICAgICAgIGN5LmJhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBhdm9pZCBkdXBsaWNhdGUgc3R5bGUgdXBkYXRlc1xuICAgICAgICAgIGVsZXMucmVtb3ZlKG5vdGlmeVJlbmRlcmVyLCBtb2RpZnlQb29sKTsgLy8gY2xlYW4gdXAgcmVmcyBldGMuXG5cbiAgICAgICAgICBlbGVzLmVtaXRBbmROb3RpZnkoJ21vdmVvdXQnKTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICAgICAgICB2YXIgX2RhdGE1ID0gZWxlLl9wcml2YXRlLmRhdGE7XG5cbiAgICAgICAgICAgIGlmIChlbGUuaXNFZGdlKCkpIHtcbiAgICAgICAgICAgICAgaWYgKHNyY0V4aXN0cykge1xuICAgICAgICAgICAgICAgIF9kYXRhNS5zb3VyY2UgPSBzcmNJZDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICh0Z3RFeGlzdHMpIHtcbiAgICAgICAgICAgICAgICBfZGF0YTUudGFyZ2V0ID0gdGd0SWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlbGVzLnJlc3RvcmUobm90aWZ5UmVuZGVyZXIsIG1vZGlmeVBvb2wpOyAvLyBtYWtlIG5ldyByZWZzLCBzdHlsZSwgZXRjLlxuICAgICAgICB9KTtcbiAgICAgICAgZWxlcy5lbWl0QW5kTm90aWZ5KCdtb3ZlJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzdHJ1Y3QucGFyZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIG1vdmUgbm9kZSB0byBuZXcgcGFyZW50XG4gICAgICB2YXIgcGFyZW50SWQgPSB0b1N0cmluZyhzdHJ1Y3QucGFyZW50KTtcbiAgICAgIHZhciBwYXJlbnRFeGlzdHMgPSBwYXJlbnRJZCA9PT0gbnVsbCB8fCBjeS5oYXNFbGVtZW50V2l0aElkKHBhcmVudElkKTtcblxuICAgICAgaWYgKHBhcmVudEV4aXN0cykge1xuICAgICAgICB2YXIgcGlkVG9Bc3NpZ24gPSBwYXJlbnRJZCA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IHBhcmVudElkO1xuICAgICAgICBjeS5iYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gYXZvaWQgZHVwbGljYXRlIHN0eWxlIHVwZGF0ZXNcbiAgICAgICAgICB2YXIgdXBkYXRlZCA9IGVsZXMucmVtb3ZlKG5vdGlmeVJlbmRlcmVyLCBtb2RpZnlQb29sKTsgLy8gY2xlYW4gdXAgcmVmcyBldGMuXG5cbiAgICAgICAgICB1cGRhdGVkLmVtaXRBbmROb3RpZnkoJ21vdmVvdXQnKTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICAgICAgICB2YXIgX2RhdGE2ID0gZWxlLl9wcml2YXRlLmRhdGE7XG5cbiAgICAgICAgICAgIGlmIChlbGUuaXNOb2RlKCkpIHtcbiAgICAgICAgICAgICAgX2RhdGE2LnBhcmVudCA9IHBpZFRvQXNzaWduO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHVwZGF0ZWQucmVzdG9yZShub3RpZnlSZW5kZXJlciwgbW9kaWZ5UG9vbCk7IC8vIG1ha2UgbmV3IHJlZnMsIHN0eWxlLCBldGMuXG4gICAgICAgIH0pO1xuICAgICAgICBlbGVzLmVtaXRBbmROb3RpZnkoJ21vdmUnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBbZWxlc2ZuJGosIGVsZXNmbiRpLCBlbGVzZm4kaCwgZWxlc2ZuJGcsIGVsZXNmbiRmLCBkYXRhLCBlbGVzZm4kZCwgZGltZW5zaW9ucywgZWxlc2ZuJDksIGVsZXNmbiQ4LCBlbGVzZm4kNywgZWxlc2ZuJDYsIGVsZXNmbiQ1LCBlbGVzZm4kNCwgZWxlc2ZuJDMsIGVsZXNmbiQyXS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wcykge1xuICAgIGV4dGVuZChlbGVzZm4kMSwgcHJvcHMpO1xuICB9KTtcblxuICB2YXIgY29yZWZuJDkgPSB7XG4gICAgYWRkOiBmdW5jdGlvbiBhZGQob3B0cykge1xuICAgICAgdmFyIGVsZW1lbnRzO1xuICAgICAgdmFyIGN5ID0gdGhpczsgLy8gYWRkIHRoZSBlbGVtZW50c1xuXG4gICAgICBpZiAoZWxlbWVudE9yQ29sbGVjdGlvbihvcHRzKSkge1xuICAgICAgICB2YXIgZWxlcyA9IG9wdHM7XG5cbiAgICAgICAgaWYgKGVsZXMuX3ByaXZhdGUuY3kgPT09IGN5KSB7XG4gICAgICAgICAgLy8gc2FtZSBpbnN0YW5jZSA9PiBqdXN0IHJlc3RvcmVcbiAgICAgICAgICBlbGVtZW50cyA9IGVsZXMucmVzdG9yZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG90aGVyd2lzZSwgY29weSBmcm9tIGpzb25cbiAgICAgICAgICB2YXIganNvbnMgPSBbXTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICAgICAgICBqc29ucy5wdXNoKGVsZS5qc29uKCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVsZW1lbnRzID0gbmV3IENvbGxlY3Rpb24oY3ksIGpzb25zKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBzcGVjaWZ5IGFuIGFycmF5IG9mIG9wdGlvbnNcbiAgICAgIGVsc2UgaWYgKGFycmF5KG9wdHMpKSB7XG4gICAgICAgIHZhciBfanNvbnMgPSBvcHRzO1xuICAgICAgICBlbGVtZW50cyA9IG5ldyBDb2xsZWN0aW9uKGN5LCBfanNvbnMpO1xuICAgICAgfSAvLyBzcGVjaWZ5IHZpYSBvcHRzLm5vZGVzIGFuZCBvcHRzLmVkZ2VzXG4gICAgICBlbHNlIGlmIChwbGFpbk9iamVjdChvcHRzKSAmJiAoYXJyYXkob3B0cy5ub2RlcykgfHwgYXJyYXkob3B0cy5lZGdlcykpKSB7XG4gICAgICAgIHZhciBlbGVzQnlHcm91cCA9IG9wdHM7XG4gICAgICAgIHZhciBfanNvbnMyID0gW107XG4gICAgICAgIHZhciBncnMgPSBbJ25vZGVzJywgJ2VkZ2VzJ107XG5cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBpbCA9IGdycy5sZW5ndGg7IF9pIDwgaWw7IF9pKyspIHtcbiAgICAgICAgICB2YXIgZ3JvdXAgPSBncnNbX2ldO1xuICAgICAgICAgIHZhciBlbGVzQXJyYXkgPSBlbGVzQnlHcm91cFtncm91cF07XG5cbiAgICAgICAgICBpZiAoYXJyYXkoZWxlc0FycmF5KSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGpsID0gZWxlc0FycmF5Lmxlbmd0aDsgaiA8IGpsOyBqKyspIHtcbiAgICAgICAgICAgICAgdmFyIGpzb24gPSBleHRlbmQoe1xuICAgICAgICAgICAgICAgIGdyb3VwOiBncm91cFxuICAgICAgICAgICAgICB9LCBlbGVzQXJyYXlbal0pO1xuXG4gICAgICAgICAgICAgIF9qc29uczIucHVzaChqc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBlbGVtZW50cyA9IG5ldyBDb2xsZWN0aW9uKGN5LCBfanNvbnMyKTtcbiAgICAgIH0gLy8gc3BlY2lmeSBvcHRpb25zIGZvciBvbmUgZWxlbWVudFxuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBfanNvbiA9IG9wdHM7XG4gICAgICAgIGVsZW1lbnRzID0gbmV3IEVsZW1lbnQoY3ksIF9qc29uKS5jb2xsZWN0aW9uKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbGVtZW50cztcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKGNvbGxlY3Rpb24pIHtcbiAgICAgIGlmIChlbGVtZW50T3JDb2xsZWN0aW9uKGNvbGxlY3Rpb24pKSA7IGVsc2UgaWYgKHN0cmluZyhjb2xsZWN0aW9uKSkge1xuICAgICAgICB2YXIgc2VsZWN0b3IgPSBjb2xsZWN0aW9uO1xuICAgICAgICBjb2xsZWN0aW9uID0gdGhpcy4kKHNlbGVjdG9yKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbGxlY3Rpb24ucmVtb3ZlKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qIGdsb2JhbCBGbG9hdDMyQXJyYXkgKi9cblxuICAvKiEgQmV6aWVyIGN1cnZlIGZ1bmN0aW9uIGdlbmVyYXRvci4gQ29weXJpZ2h0IEdhZXRhbiBSZW5hdWRlYXUuIE1JVCBMaWNlbnNlOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01JVF9MaWNlbnNlICovXG4gIGZ1bmN0aW9uIGdlbmVyYXRlQ3ViaWNCZXppZXIobVgxLCBtWTEsIG1YMiwgbVkyKSB7XG4gICAgdmFyIE5FV1RPTl9JVEVSQVRJT05TID0gNCxcbiAgICAgICAgTkVXVE9OX01JTl9TTE9QRSA9IDAuMDAxLFxuICAgICAgICBTVUJESVZJU0lPTl9QUkVDSVNJT04gPSAwLjAwMDAwMDEsXG4gICAgICAgIFNVQkRJVklTSU9OX01BWF9JVEVSQVRJT05TID0gMTAsXG4gICAgICAgIGtTcGxpbmVUYWJsZVNpemUgPSAxMSxcbiAgICAgICAga1NhbXBsZVN0ZXBTaXplID0gMS4wIC8gKGtTcGxpbmVUYWJsZVNpemUgLSAxLjApLFxuICAgICAgICBmbG9hdDMyQXJyYXlTdXBwb3J0ZWQgPSB0eXBlb2YgRmxvYXQzMkFycmF5ICE9PSAndW5kZWZpbmVkJztcbiAgICAvKiBNdXN0IGNvbnRhaW4gZm91ciBhcmd1bWVudHMuICovXG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gNCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKiBBcmd1bWVudHMgbXVzdCBiZSBudW1iZXJzLiAqL1xuXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7ICsraSkge1xuICAgICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbaV0gIT09IFwibnVtYmVyXCIgfHwgaXNOYU4oYXJndW1lbnRzW2ldKSB8fCAhaXNGaW5pdGUoYXJndW1lbnRzW2ldKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIC8qIFggdmFsdWVzIG11c3QgYmUgaW4gdGhlIFswLCAxXSByYW5nZS4gKi9cblxuXG4gICAgbVgxID0gTWF0aC5taW4obVgxLCAxKTtcbiAgICBtWDIgPSBNYXRoLm1pbihtWDIsIDEpO1xuICAgIG1YMSA9IE1hdGgubWF4KG1YMSwgMCk7XG4gICAgbVgyID0gTWF0aC5tYXgobVgyLCAwKTtcbiAgICB2YXIgbVNhbXBsZVZhbHVlcyA9IGZsb2F0MzJBcnJheVN1cHBvcnRlZCA/IG5ldyBGbG9hdDMyQXJyYXkoa1NwbGluZVRhYmxlU2l6ZSkgOiBuZXcgQXJyYXkoa1NwbGluZVRhYmxlU2l6ZSk7XG5cbiAgICBmdW5jdGlvbiBBKGFBMSwgYUEyKSB7XG4gICAgICByZXR1cm4gMS4wIC0gMy4wICogYUEyICsgMy4wICogYUExO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEIoYUExLCBhQTIpIHtcbiAgICAgIHJldHVybiAzLjAgKiBhQTIgLSA2LjAgKiBhQTE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gQyhhQTEpIHtcbiAgICAgIHJldHVybiAzLjAgKiBhQTE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FsY0JlemllcihhVCwgYUExLCBhQTIpIHtcbiAgICAgIHJldHVybiAoKEEoYUExLCBhQTIpICogYVQgKyBCKGFBMSwgYUEyKSkgKiBhVCArIEMoYUExKSkgKiBhVDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTbG9wZShhVCwgYUExLCBhQTIpIHtcbiAgICAgIHJldHVybiAzLjAgKiBBKGFBMSwgYUEyKSAqIGFUICogYVQgKyAyLjAgKiBCKGFBMSwgYUEyKSAqIGFUICsgQyhhQTEpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5ld3RvblJhcGhzb25JdGVyYXRlKGFYLCBhR3Vlc3NUKSB7XG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgTkVXVE9OX0lURVJBVElPTlM7ICsrX2kpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRTbG9wZSA9IGdldFNsb3BlKGFHdWVzc1QsIG1YMSwgbVgyKTtcblxuICAgICAgICBpZiAoY3VycmVudFNsb3BlID09PSAwLjApIHtcbiAgICAgICAgICByZXR1cm4gYUd1ZXNzVDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjdXJyZW50WCA9IGNhbGNCZXppZXIoYUd1ZXNzVCwgbVgxLCBtWDIpIC0gYVg7XG4gICAgICAgIGFHdWVzc1QgLT0gY3VycmVudFggLyBjdXJyZW50U2xvcGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhR3Vlc3NUO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhbGNTYW1wbGVWYWx1ZXMoKSB7XG4gICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBrU3BsaW5lVGFibGVTaXplOyArK19pMikge1xuICAgICAgICBtU2FtcGxlVmFsdWVzW19pMl0gPSBjYWxjQmV6aWVyKF9pMiAqIGtTYW1wbGVTdGVwU2l6ZSwgbVgxLCBtWDIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJpbmFyeVN1YmRpdmlkZShhWCwgYUEsIGFCKSB7XG4gICAgICB2YXIgY3VycmVudFgsXG4gICAgICAgICAgY3VycmVudFQsXG4gICAgICAgICAgaSA9IDA7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgY3VycmVudFQgPSBhQSArIChhQiAtIGFBKSAvIDIuMDtcbiAgICAgICAgY3VycmVudFggPSBjYWxjQmV6aWVyKGN1cnJlbnRULCBtWDEsIG1YMikgLSBhWDtcblxuICAgICAgICBpZiAoY3VycmVudFggPiAwLjApIHtcbiAgICAgICAgICBhQiA9IGN1cnJlbnRUO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFBID0gY3VycmVudFQ7XG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKE1hdGguYWJzKGN1cnJlbnRYKSA+IFNVQkRJVklTSU9OX1BSRUNJU0lPTiAmJiArK2kgPCBTVUJESVZJU0lPTl9NQVhfSVRFUkFUSU9OUyk7XG5cbiAgICAgIHJldHVybiBjdXJyZW50VDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRURm9yWChhWCkge1xuICAgICAgdmFyIGludGVydmFsU3RhcnQgPSAwLjAsXG4gICAgICAgICAgY3VycmVudFNhbXBsZSA9IDEsXG4gICAgICAgICAgbGFzdFNhbXBsZSA9IGtTcGxpbmVUYWJsZVNpemUgLSAxO1xuXG4gICAgICBmb3IgKDsgY3VycmVudFNhbXBsZSAhPT0gbGFzdFNhbXBsZSAmJiBtU2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdIDw9IGFYOyArK2N1cnJlbnRTYW1wbGUpIHtcbiAgICAgICAgaW50ZXJ2YWxTdGFydCArPSBrU2FtcGxlU3RlcFNpemU7XG4gICAgICB9XG5cbiAgICAgIC0tY3VycmVudFNhbXBsZTtcbiAgICAgIHZhciBkaXN0ID0gKGFYIC0gbVNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSkgLyAobVNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlICsgMV0gLSBtU2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdKSxcbiAgICAgICAgICBndWVzc0ZvclQgPSBpbnRlcnZhbFN0YXJ0ICsgZGlzdCAqIGtTYW1wbGVTdGVwU2l6ZSxcbiAgICAgICAgICBpbml0aWFsU2xvcGUgPSBnZXRTbG9wZShndWVzc0ZvclQsIG1YMSwgbVgyKTtcblxuICAgICAgaWYgKGluaXRpYWxTbG9wZSA+PSBORVdUT05fTUlOX1NMT1BFKSB7XG4gICAgICAgIHJldHVybiBuZXd0b25SYXBoc29uSXRlcmF0ZShhWCwgZ3Vlc3NGb3JUKTtcbiAgICAgIH0gZWxzZSBpZiAoaW5pdGlhbFNsb3BlID09PSAwLjApIHtcbiAgICAgICAgcmV0dXJuIGd1ZXNzRm9yVDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBiaW5hcnlTdWJkaXZpZGUoYVgsIGludGVydmFsU3RhcnQsIGludGVydmFsU3RhcnQgKyBrU2FtcGxlU3RlcFNpemUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBfcHJlY29tcHV0ZWQgPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIHByZWNvbXB1dGUoKSB7XG4gICAgICBfcHJlY29tcHV0ZWQgPSB0cnVlO1xuXG4gICAgICBpZiAobVgxICE9PSBtWTEgfHwgbVgyICE9PSBtWTIpIHtcbiAgICAgICAgY2FsY1NhbXBsZVZhbHVlcygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBmID0gZnVuY3Rpb24gZihhWCkge1xuICAgICAgaWYgKCFfcHJlY29tcHV0ZWQpIHtcbiAgICAgICAgcHJlY29tcHV0ZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAobVgxID09PSBtWTEgJiYgbVgyID09PSBtWTIpIHtcbiAgICAgICAgcmV0dXJuIGFYO1xuICAgICAgfVxuXG4gICAgICBpZiAoYVggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChhWCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNhbGNCZXppZXIoZ2V0VEZvclgoYVgpLCBtWTEsIG1ZMik7XG4gICAgfTtcblxuICAgIGYuZ2V0Q29udHJvbFBvaW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBbe1xuICAgICAgICB4OiBtWDEsXG4gICAgICAgIHk6IG1ZMVxuICAgICAgfSwge1xuICAgICAgICB4OiBtWDIsXG4gICAgICAgIHk6IG1ZMlxuICAgICAgfV07XG4gICAgfTtcblxuICAgIHZhciBzdHIgPSBcImdlbmVyYXRlQmV6aWVyKFwiICsgW21YMSwgbVkxLCBtWDIsIG1ZMl0gKyBcIilcIjtcblxuICAgIGYudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH07XG5cbiAgICByZXR1cm4gZjtcbiAgfVxuXG4gIC8qISBSdW5nZS1LdXR0YSBzcHJpbmcgcGh5c2ljcyBmdW5jdGlvbiBnZW5lcmF0b3IuIEFkYXB0ZWQgZnJvbSBGcmFtZXIuanMsIGNvcHlyaWdodCBLb2VuIEJvay4gTUlUIExpY2Vuc2U6IGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTUlUX0xpY2Vuc2UgKi9cblxuICAvKiBHaXZlbiBhIHRlbnNpb24sIGZyaWN0aW9uLCBhbmQgZHVyYXRpb24sIGEgc2ltdWxhdGlvbiBhdCA2MEZQUyB3aWxsIGZpcnN0IHJ1biB3aXRob3V0IGEgZGVmaW5lZCBkdXJhdGlvbiBpbiBvcmRlciB0byBjYWxjdWxhdGUgdGhlIGZ1bGwgcGF0aC4gQSBzZWNvbmQgcGFzc1xuICAgICB0aGVuIGFkanVzdHMgdGhlIHRpbWUgZGVsdGEgLS0gdXNpbmcgdGhlIHJlbGF0aW9uIGJldHdlZW4gYWN0dWFsIHRpbWUgYW5kIGR1cmF0aW9uIC0tIHRvIGNhbGN1bGF0ZSB0aGUgcGF0aCBmb3IgdGhlIGR1cmF0aW9uLWNvbnN0cmFpbmVkIGFuaW1hdGlvbi4gKi9cbiAgdmFyIGdlbmVyYXRlU3ByaW5nUks0ID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIHNwcmluZ0FjY2VsZXJhdGlvbkZvclN0YXRlKHN0YXRlKSB7XG4gICAgICByZXR1cm4gLXN0YXRlLnRlbnNpb24gKiBzdGF0ZS54IC0gc3RhdGUuZnJpY3Rpb24gKiBzdGF0ZS52O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNwcmluZ0V2YWx1YXRlU3RhdGVXaXRoRGVyaXZhdGl2ZShpbml0aWFsU3RhdGUsIGR0LCBkZXJpdmF0aXZlKSB7XG4gICAgICB2YXIgc3RhdGUgPSB7XG4gICAgICAgIHg6IGluaXRpYWxTdGF0ZS54ICsgZGVyaXZhdGl2ZS5keCAqIGR0LFxuICAgICAgICB2OiBpbml0aWFsU3RhdGUudiArIGRlcml2YXRpdmUuZHYgKiBkdCxcbiAgICAgICAgdGVuc2lvbjogaW5pdGlhbFN0YXRlLnRlbnNpb24sXG4gICAgICAgIGZyaWN0aW9uOiBpbml0aWFsU3RhdGUuZnJpY3Rpb25cbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkeDogc3RhdGUudixcbiAgICAgICAgZHY6IHNwcmluZ0FjY2VsZXJhdGlvbkZvclN0YXRlKHN0YXRlKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzcHJpbmdJbnRlZ3JhdGVTdGF0ZShzdGF0ZSwgZHQpIHtcbiAgICAgIHZhciBhID0ge1xuICAgICAgICBkeDogc3RhdGUudixcbiAgICAgICAgZHY6IHNwcmluZ0FjY2VsZXJhdGlvbkZvclN0YXRlKHN0YXRlKVxuICAgICAgfSxcbiAgICAgICAgICBiID0gc3ByaW5nRXZhbHVhdGVTdGF0ZVdpdGhEZXJpdmF0aXZlKHN0YXRlLCBkdCAqIDAuNSwgYSksXG4gICAgICAgICAgYyA9IHNwcmluZ0V2YWx1YXRlU3RhdGVXaXRoRGVyaXZhdGl2ZShzdGF0ZSwgZHQgKiAwLjUsIGIpLFxuICAgICAgICAgIGQgPSBzcHJpbmdFdmFsdWF0ZVN0YXRlV2l0aERlcml2YXRpdmUoc3RhdGUsIGR0LCBjKSxcbiAgICAgICAgICBkeGR0ID0gMS4wIC8gNi4wICogKGEuZHggKyAyLjAgKiAoYi5keCArIGMuZHgpICsgZC5keCksXG4gICAgICAgICAgZHZkdCA9IDEuMCAvIDYuMCAqIChhLmR2ICsgMi4wICogKGIuZHYgKyBjLmR2KSArIGQuZHYpO1xuICAgICAgc3RhdGUueCA9IHN0YXRlLnggKyBkeGR0ICogZHQ7XG4gICAgICBzdGF0ZS52ID0gc3RhdGUudiArIGR2ZHQgKiBkdDtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gc3ByaW5nUks0RmFjdG9yeSh0ZW5zaW9uLCBmcmljdGlvbiwgZHVyYXRpb24pIHtcbiAgICAgIHZhciBpbml0U3RhdGUgPSB7XG4gICAgICAgIHg6IC0xLFxuICAgICAgICB2OiAwLFxuICAgICAgICB0ZW5zaW9uOiBudWxsLFxuICAgICAgICBmcmljdGlvbjogbnVsbFxuICAgICAgfSxcbiAgICAgICAgICBwYXRoID0gWzBdLFxuICAgICAgICAgIHRpbWVfbGFwc2VkID0gMCxcbiAgICAgICAgICB0b2xlcmFuY2UgPSAxIC8gMTAwMDAsXG4gICAgICAgICAgRFQgPSAxNiAvIDEwMDAsXG4gICAgICAgICAgaGF2ZV9kdXJhdGlvbixcbiAgICAgICAgICBkdCxcbiAgICAgICAgICBsYXN0X3N0YXRlO1xuICAgICAgdGVuc2lvbiA9IHBhcnNlRmxvYXQodGVuc2lvbikgfHwgNTAwO1xuICAgICAgZnJpY3Rpb24gPSBwYXJzZUZsb2F0KGZyaWN0aW9uKSB8fCAyMDtcbiAgICAgIGR1cmF0aW9uID0gZHVyYXRpb24gfHwgbnVsbDtcbiAgICAgIGluaXRTdGF0ZS50ZW5zaW9uID0gdGVuc2lvbjtcbiAgICAgIGluaXRTdGF0ZS5mcmljdGlvbiA9IGZyaWN0aW9uO1xuICAgICAgaGF2ZV9kdXJhdGlvbiA9IGR1cmF0aW9uICE9PSBudWxsO1xuICAgICAgLyogQ2FsY3VsYXRlIHRoZSBhY3R1YWwgdGltZSBpdCB0YWtlcyBmb3IgdGhpcyBhbmltYXRpb24gdG8gY29tcGxldGUgd2l0aCB0aGUgcHJvdmlkZWQgY29uZGl0aW9ucy4gKi9cblxuICAgICAgaWYgKGhhdmVfZHVyYXRpb24pIHtcbiAgICAgICAgLyogUnVuIHRoZSBzaW11bGF0aW9uIHdpdGhvdXQgYSBkdXJhdGlvbi4gKi9cbiAgICAgICAgdGltZV9sYXBzZWQgPSBzcHJpbmdSSzRGYWN0b3J5KHRlbnNpb24sIGZyaWN0aW9uKTtcbiAgICAgICAgLyogQ29tcHV0ZSB0aGUgYWRqdXN0ZWQgdGltZSBkZWx0YS4gKi9cblxuICAgICAgICBkdCA9IHRpbWVfbGFwc2VkIC8gZHVyYXRpb24gKiBEVDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGR0ID0gRFQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAoOzspIHtcbiAgICAgICAgLyogTmV4dC9zdGVwIGZ1bmN0aW9uIC4qL1xuICAgICAgICBsYXN0X3N0YXRlID0gc3ByaW5nSW50ZWdyYXRlU3RhdGUobGFzdF9zdGF0ZSB8fCBpbml0U3RhdGUsIGR0KTtcbiAgICAgICAgLyogU3RvcmUgdGhlIHBvc2l0aW9uLiAqL1xuXG4gICAgICAgIHBhdGgucHVzaCgxICsgbGFzdF9zdGF0ZS54KTtcbiAgICAgICAgdGltZV9sYXBzZWQgKz0gMTY7XG4gICAgICAgIC8qIElmIHRoZSBjaGFuZ2UgdGhyZXNob2xkIGlzIHJlYWNoZWQsIGJyZWFrLiAqL1xuXG4gICAgICAgIGlmICghKE1hdGguYWJzKGxhc3Rfc3RhdGUueCkgPiB0b2xlcmFuY2UgJiYgTWF0aC5hYnMobGFzdF9zdGF0ZS52KSA+IHRvbGVyYW5jZSkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLyogSWYgZHVyYXRpb24gaXMgbm90IGRlZmluZWQsIHJldHVybiB0aGUgYWN0dWFsIHRpbWUgcmVxdWlyZWQgZm9yIGNvbXBsZXRpbmcgdGhpcyBhbmltYXRpb24uIE90aGVyd2lzZSwgcmV0dXJuIGEgY2xvc3VyZSB0aGF0IGhvbGRzIHRoZVxuICAgICAgICAgY29tcHV0ZWQgcGF0aCBhbmQgcmV0dXJucyBhIHNuYXBzaG90IG9mIHRoZSBwb3NpdGlvbiBhY2NvcmRpbmcgdG8gYSBnaXZlbiBwZXJjZW50Q29tcGxldGUuICovXG5cblxuICAgICAgcmV0dXJuICFoYXZlX2R1cmF0aW9uID8gdGltZV9sYXBzZWQgOiBmdW5jdGlvbiAocGVyY2VudENvbXBsZXRlKSB7XG4gICAgICAgIHJldHVybiBwYXRoW3BlcmNlbnRDb21wbGV0ZSAqIChwYXRoLmxlbmd0aCAtIDEpIHwgMF07XG4gICAgICB9O1xuICAgIH07XG4gIH0oKTtcblxuICB2YXIgY3ViaWNCZXppZXIgPSBmdW5jdGlvbiBjdWJpY0Jlemllcih0MSwgcDEsIHQyLCBwMikge1xuICAgIHZhciBiZXppZXIgPSBnZW5lcmF0ZUN1YmljQmV6aWVyKHQxLCBwMSwgdDIsIHAyKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIHBlcmNlbnQpIHtcbiAgICAgIHJldHVybiBzdGFydCArIChlbmQgLSBzdGFydCkgKiBiZXppZXIocGVyY2VudCk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgZWFzaW5ncyA9IHtcbiAgICAnbGluZWFyJzogZnVuY3Rpb24gbGluZWFyKHN0YXJ0LCBlbmQsIHBlcmNlbnQpIHtcbiAgICAgIHJldHVybiBzdGFydCArIChlbmQgLSBzdGFydCkgKiBwZXJjZW50O1xuICAgIH0sXG4gICAgLy8gZGVmYXVsdCBlYXNpbmdzXG4gICAgJ2Vhc2UnOiBjdWJpY0JlemllcigwLjI1LCAwLjEsIDAuMjUsIDEpLFxuICAgICdlYXNlLWluJzogY3ViaWNCZXppZXIoMC40MiwgMCwgMSwgMSksXG4gICAgJ2Vhc2Utb3V0JzogY3ViaWNCZXppZXIoMCwgMCwgMC41OCwgMSksXG4gICAgJ2Vhc2UtaW4tb3V0JzogY3ViaWNCZXppZXIoMC40MiwgMCwgMC41OCwgMSksXG4gICAgLy8gc2luZVxuICAgICdlYXNlLWluLXNpbmUnOiBjdWJpY0JlemllcigwLjQ3LCAwLCAwLjc0NSwgMC43MTUpLFxuICAgICdlYXNlLW91dC1zaW5lJzogY3ViaWNCZXppZXIoMC4zOSwgMC41NzUsIDAuNTY1LCAxKSxcbiAgICAnZWFzZS1pbi1vdXQtc2luZSc6IGN1YmljQmV6aWVyKDAuNDQ1LCAwLjA1LCAwLjU1LCAwLjk1KSxcbiAgICAvLyBxdWFkXG4gICAgJ2Vhc2UtaW4tcXVhZCc6IGN1YmljQmV6aWVyKDAuNTUsIDAuMDg1LCAwLjY4LCAwLjUzKSxcbiAgICAnZWFzZS1vdXQtcXVhZCc6IGN1YmljQmV6aWVyKDAuMjUsIDAuNDYsIDAuNDUsIDAuOTQpLFxuICAgICdlYXNlLWluLW91dC1xdWFkJzogY3ViaWNCZXppZXIoMC40NTUsIDAuMDMsIDAuNTE1LCAwLjk1NSksXG4gICAgLy8gY3ViaWNcbiAgICAnZWFzZS1pbi1jdWJpYyc6IGN1YmljQmV6aWVyKDAuNTUsIDAuMDU1LCAwLjY3NSwgMC4xOSksXG4gICAgJ2Vhc2Utb3V0LWN1YmljJzogY3ViaWNCZXppZXIoMC4yMTUsIDAuNjEsIDAuMzU1LCAxKSxcbiAgICAnZWFzZS1pbi1vdXQtY3ViaWMnOiBjdWJpY0JlemllcigwLjY0NSwgMC4wNDUsIDAuMzU1LCAxKSxcbiAgICAvLyBxdWFydFxuICAgICdlYXNlLWluLXF1YXJ0JzogY3ViaWNCZXppZXIoMC44OTUsIDAuMDMsIDAuNjg1LCAwLjIyKSxcbiAgICAnZWFzZS1vdXQtcXVhcnQnOiBjdWJpY0JlemllcigwLjE2NSwgMC44NCwgMC40NCwgMSksXG4gICAgJ2Vhc2UtaW4tb3V0LXF1YXJ0JzogY3ViaWNCZXppZXIoMC43NywgMCwgMC4xNzUsIDEpLFxuICAgIC8vIHF1aW50XG4gICAgJ2Vhc2UtaW4tcXVpbnQnOiBjdWJpY0JlemllcigwLjc1NSwgMC4wNSwgMC44NTUsIDAuMDYpLFxuICAgICdlYXNlLW91dC1xdWludCc6IGN1YmljQmV6aWVyKDAuMjMsIDEsIDAuMzIsIDEpLFxuICAgICdlYXNlLWluLW91dC1xdWludCc6IGN1YmljQmV6aWVyKDAuODYsIDAsIDAuMDcsIDEpLFxuICAgIC8vIGV4cG9cbiAgICAnZWFzZS1pbi1leHBvJzogY3ViaWNCZXppZXIoMC45NSwgMC4wNSwgMC43OTUsIDAuMDM1KSxcbiAgICAnZWFzZS1vdXQtZXhwbyc6IGN1YmljQmV6aWVyKDAuMTksIDEsIDAuMjIsIDEpLFxuICAgICdlYXNlLWluLW91dC1leHBvJzogY3ViaWNCZXppZXIoMSwgMCwgMCwgMSksXG4gICAgLy8gY2lyY1xuICAgICdlYXNlLWluLWNpcmMnOiBjdWJpY0JlemllcigwLjYsIDAuMDQsIDAuOTgsIDAuMzM1KSxcbiAgICAnZWFzZS1vdXQtY2lyYyc6IGN1YmljQmV6aWVyKDAuMDc1LCAwLjgyLCAwLjE2NSwgMSksXG4gICAgJ2Vhc2UtaW4tb3V0LWNpcmMnOiBjdWJpY0JlemllcigwLjc4NSwgMC4xMzUsIDAuMTUsIDAuODYpLFxuICAgIC8vIHVzZXIgcGFyYW0gZWFzaW5ncy4uLlxuICAgICdzcHJpbmcnOiBmdW5jdGlvbiBzcHJpbmcodGVuc2lvbiwgZnJpY3Rpb24sIGR1cmF0aW9uKSB7XG4gICAgICBpZiAoZHVyYXRpb24gPT09IDApIHtcbiAgICAgICAgLy8gY2FuJ3QgZ2V0IGEgc3ByaW5nIHcvIGR1cmF0aW9uIDBcbiAgICAgICAgcmV0dXJuIGVhc2luZ3MubGluZWFyOyAvLyBkdXJhdGlvbiAwID0+IGp1bXAgdG8gZW5kIHNvIGltcGwgZG9lc24ndCBtYXR0ZXJcbiAgICAgIH1cblxuICAgICAgdmFyIHNwcmluZyA9IGdlbmVyYXRlU3ByaW5nUks0KHRlbnNpb24sIGZyaWN0aW9uLCBkdXJhdGlvbik7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIHBlcmNlbnQpIHtcbiAgICAgICAgcmV0dXJuIHN0YXJ0ICsgKGVuZCAtIHN0YXJ0KSAqIHNwcmluZyhwZXJjZW50KTtcbiAgICAgIH07XG4gICAgfSxcbiAgICAnY3ViaWMtYmV6aWVyJzogY3ViaWNCZXppZXJcbiAgfTtcblxuICBmdW5jdGlvbiBnZXRFYXNlZFZhbHVlKHR5cGUsIHN0YXJ0LCBlbmQsIHBlcmNlbnQsIGVhc2luZ0ZuKSB7XG4gICAgaWYgKHBlcmNlbnQgPT09IDEpIHtcbiAgICAgIHJldHVybiBlbmQ7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0ID09PSBlbmQpIHtcbiAgICAgIHJldHVybiBlbmQ7XG4gICAgfVxuXG4gICAgdmFyIHZhbCA9IGVhc2luZ0ZuKHN0YXJ0LCBlbmQsIHBlcmNlbnQpO1xuXG4gICAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG5cbiAgICBpZiAodHlwZS5yb3VuZFZhbHVlIHx8IHR5cGUuY29sb3IpIHtcbiAgICAgIHZhbCA9IE1hdGgucm91bmQodmFsKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZS5taW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFsID0gTWF0aC5tYXgodmFsLCB0eXBlLm1pbik7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUubWF4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhbCA9IE1hdGgubWluKHZhbCwgdHlwZS5tYXgpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRWYWx1ZShwcm9wLCBzcGVjKSB7XG4gICAgaWYgKHByb3AucGZWYWx1ZSAhPSBudWxsIHx8IHByb3AudmFsdWUgIT0gbnVsbCkge1xuICAgICAgaWYgKHByb3AucGZWYWx1ZSAhPSBudWxsICYmIChzcGVjID09IG51bGwgfHwgc3BlYy50eXBlLnVuaXRzICE9PSAnJScpKSB7XG4gICAgICAgIHJldHVybiBwcm9wLnBmVmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcHJvcC52YWx1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHByb3A7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZWFzZShzdGFydFByb3AsIGVuZFByb3AsIHBlcmNlbnQsIGVhc2luZ0ZuLCBwcm9wU3BlYykge1xuICAgIHZhciB0eXBlID0gcHJvcFNwZWMgIT0gbnVsbCA/IHByb3BTcGVjLnR5cGUgOiBudWxsO1xuXG4gICAgaWYgKHBlcmNlbnQgPCAwKSB7XG4gICAgICBwZXJjZW50ID0gMDtcbiAgICB9IGVsc2UgaWYgKHBlcmNlbnQgPiAxKSB7XG4gICAgICBwZXJjZW50ID0gMTtcbiAgICB9XG5cbiAgICB2YXIgc3RhcnQgPSBnZXRWYWx1ZShzdGFydFByb3AsIHByb3BTcGVjKTtcbiAgICB2YXIgZW5kID0gZ2V0VmFsdWUoZW5kUHJvcCwgcHJvcFNwZWMpO1xuXG4gICAgaWYgKG51bWJlciQxKHN0YXJ0KSAmJiBudW1iZXIkMShlbmQpKSB7XG4gICAgICByZXR1cm4gZ2V0RWFzZWRWYWx1ZSh0eXBlLCBzdGFydCwgZW5kLCBwZXJjZW50LCBlYXNpbmdGbik7XG4gICAgfSBlbHNlIGlmIChhcnJheShzdGFydCkgJiYgYXJyYXkoZW5kKSkge1xuICAgICAgdmFyIGVhc2VkQXJyID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5kLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzaSA9IHN0YXJ0W2ldO1xuICAgICAgICB2YXIgZWkgPSBlbmRbaV07XG5cbiAgICAgICAgaWYgKHNpICE9IG51bGwgJiYgZWkgIT0gbnVsbCkge1xuICAgICAgICAgIHZhciB2YWwgPSBnZXRFYXNlZFZhbHVlKHR5cGUsIHNpLCBlaSwgcGVyY2VudCwgZWFzaW5nRm4pO1xuICAgICAgICAgIGVhc2VkQXJyLnB1c2godmFsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlYXNlZEFyci5wdXNoKGVpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZWFzZWRBcnI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0ZXAkMShzZWxmLCBhbmksIG5vdywgaXNDb3JlKSB7XG4gICAgdmFyIGlzRWxlcyA9ICFpc0NvcmU7XG4gICAgdmFyIF9wID0gc2VsZi5fcHJpdmF0ZTtcbiAgICB2YXIgYW5pX3AgPSBhbmkuX3ByaXZhdGU7XG4gICAgdmFyIHBFYXNpbmcgPSBhbmlfcC5lYXNpbmc7XG4gICAgdmFyIHN0YXJ0VGltZSA9IGFuaV9wLnN0YXJ0VGltZTtcbiAgICB2YXIgY3kgPSBpc0NvcmUgPyBzZWxmIDogc2VsZi5jeSgpO1xuICAgIHZhciBzdHlsZSA9IGN5LnN0eWxlKCk7XG5cbiAgICBpZiAoIWFuaV9wLmVhc2luZ0ltcGwpIHtcbiAgICAgIGlmIChwRWFzaW5nID09IG51bGwpIHtcbiAgICAgICAgLy8gdXNlIGRlZmF1bHRcbiAgICAgICAgYW5pX3AuZWFzaW5nSW1wbCA9IGVhc2luZ3NbJ2xpbmVhciddO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdGhlbiBkZWZpbmUgdy8gbmFtZVxuICAgICAgICB2YXIgZWFzaW5nVmFscztcblxuICAgICAgICBpZiAoc3RyaW5nKHBFYXNpbmcpKSB7XG4gICAgICAgICAgdmFyIGVhc2luZ1Byb3AgPSBzdHlsZS5wYXJzZSgndHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb24nLCBwRWFzaW5nKTtcbiAgICAgICAgICBlYXNpbmdWYWxzID0gZWFzaW5nUHJvcC52YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB0aGVuIGFzc3VtZSBwcmVwYXJzZWQgYXJyYXlcbiAgICAgICAgICBlYXNpbmdWYWxzID0gcEVhc2luZztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuYW1lLCBhcmdzO1xuXG4gICAgICAgIGlmIChzdHJpbmcoZWFzaW5nVmFscykpIHtcbiAgICAgICAgICBuYW1lID0gZWFzaW5nVmFscztcbiAgICAgICAgICBhcmdzID0gW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmFtZSA9IGVhc2luZ1ZhbHNbMV07XG4gICAgICAgICAgYXJncyA9IGVhc2luZ1ZhbHMuc2xpY2UoMikubWFwKGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICByZXR1cm4gK247XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXJncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgLy8gY3JlYXRlIHdpdGggYXJnc1xuICAgICAgICAgIGlmIChuYW1lID09PSAnc3ByaW5nJykge1xuICAgICAgICAgICAgYXJncy5wdXNoKGFuaV9wLmR1cmF0aW9uKTsgLy8gbmVlZCBkdXJhdGlvbiB0byBnZW5lcmF0ZSBzcHJpbmdcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhbmlfcC5lYXNpbmdJbXBsID0gZWFzaW5nc1tuYW1lXS5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBzdGF0aWMgaW1wbCBieSBuYW1lXG4gICAgICAgICAgYW5pX3AuZWFzaW5nSW1wbCA9IGVhc2luZ3NbbmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZWFzaW5nID0gYW5pX3AuZWFzaW5nSW1wbDtcbiAgICB2YXIgcGVyY2VudDtcblxuICAgIGlmIChhbmlfcC5kdXJhdGlvbiA9PT0gMCkge1xuICAgICAgcGVyY2VudCA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlcmNlbnQgPSAobm93IC0gc3RhcnRUaW1lKSAvIGFuaV9wLmR1cmF0aW9uO1xuICAgIH1cblxuICAgIGlmIChhbmlfcC5hcHBseWluZykge1xuICAgICAgcGVyY2VudCA9IGFuaV9wLnByb2dyZXNzO1xuICAgIH1cblxuICAgIGlmIChwZXJjZW50IDwgMCkge1xuICAgICAgcGVyY2VudCA9IDA7XG4gICAgfSBlbHNlIGlmIChwZXJjZW50ID4gMSkge1xuICAgICAgcGVyY2VudCA9IDE7XG4gICAgfVxuXG4gICAgaWYgKGFuaV9wLmRlbGF5ID09IG51bGwpIHtcbiAgICAgIC8vIHRoZW4gdXBkYXRlXG4gICAgICB2YXIgc3RhcnRQb3MgPSBhbmlfcC5zdGFydFBvc2l0aW9uO1xuICAgICAgdmFyIGVuZFBvcyA9IGFuaV9wLnBvc2l0aW9uO1xuXG4gICAgICBpZiAoZW5kUG9zICYmIGlzRWxlcyAmJiAhc2VsZi5sb2NrZWQoKSkge1xuICAgICAgICB2YXIgbmV3UG9zID0ge307XG5cbiAgICAgICAgaWYgKHZhbGlkKHN0YXJ0UG9zLngsIGVuZFBvcy54KSkge1xuICAgICAgICAgIG5ld1Bvcy54ID0gZWFzZShzdGFydFBvcy54LCBlbmRQb3MueCwgcGVyY2VudCwgZWFzaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWxpZChzdGFydFBvcy55LCBlbmRQb3MueSkpIHtcbiAgICAgICAgICBuZXdQb3MueSA9IGVhc2Uoc3RhcnRQb3MueSwgZW5kUG9zLnksIHBlcmNlbnQsIGVhc2luZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLnBvc2l0aW9uKG5ld1Bvcyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzdGFydFBhbiA9IGFuaV9wLnN0YXJ0UGFuO1xuICAgICAgdmFyIGVuZFBhbiA9IGFuaV9wLnBhbjtcbiAgICAgIHZhciBwYW4gPSBfcC5wYW47XG4gICAgICB2YXIgYW5pbWF0aW5nUGFuID0gZW5kUGFuICE9IG51bGwgJiYgaXNDb3JlO1xuXG4gICAgICBpZiAoYW5pbWF0aW5nUGFuKSB7XG4gICAgICAgIGlmICh2YWxpZChzdGFydFBhbi54LCBlbmRQYW4ueCkpIHtcbiAgICAgICAgICBwYW4ueCA9IGVhc2Uoc3RhcnRQYW4ueCwgZW5kUGFuLngsIHBlcmNlbnQsIGVhc2luZyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsaWQoc3RhcnRQYW4ueSwgZW5kUGFuLnkpKSB7XG4gICAgICAgICAgcGFuLnkgPSBlYXNlKHN0YXJ0UGFuLnksIGVuZFBhbi55LCBwZXJjZW50LCBlYXNpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5lbWl0KCdwYW4nKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0YXJ0Wm9vbSA9IGFuaV9wLnN0YXJ0Wm9vbTtcbiAgICAgIHZhciBlbmRab29tID0gYW5pX3Auem9vbTtcbiAgICAgIHZhciBhbmltYXRpbmdab29tID0gZW5kWm9vbSAhPSBudWxsICYmIGlzQ29yZTtcblxuICAgICAgaWYgKGFuaW1hdGluZ1pvb20pIHtcbiAgICAgICAgaWYgKHZhbGlkKHN0YXJ0Wm9vbSwgZW5kWm9vbSkpIHtcbiAgICAgICAgICBfcC56b29tID0gYm91bmQoX3AubWluWm9vbSwgZWFzZShzdGFydFpvb20sIGVuZFpvb20sIHBlcmNlbnQsIGVhc2luZyksIF9wLm1heFpvb20pO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5lbWl0KCd6b29tJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhbmltYXRpbmdQYW4gfHwgYW5pbWF0aW5nWm9vbSkge1xuICAgICAgICBzZWxmLmVtaXQoJ3ZpZXdwb3J0Jyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9wcyA9IGFuaV9wLnN0eWxlO1xuXG4gICAgICBpZiAocHJvcHMgJiYgcHJvcHMubGVuZ3RoID4gMCAmJiBpc0VsZXMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBwcm9wID0gcHJvcHNbaV07XG4gICAgICAgICAgdmFyIF9uYW1lID0gcHJvcC5uYW1lO1xuICAgICAgICAgIHZhciBlbmQgPSBwcm9wO1xuICAgICAgICAgIHZhciBzdGFydCA9IGFuaV9wLnN0YXJ0U3R5bGVbX25hbWVdO1xuICAgICAgICAgIHZhciBwcm9wU3BlYyA9IHN0eWxlLnByb3BlcnRpZXNbc3RhcnQubmFtZV07XG4gICAgICAgICAgdmFyIGVhc2VkVmFsID0gZWFzZShzdGFydCwgZW5kLCBwZXJjZW50LCBlYXNpbmcsIHByb3BTcGVjKTtcbiAgICAgICAgICBzdHlsZS5vdmVycmlkZUJ5cGFzcyhzZWxmLCBfbmFtZSwgZWFzZWRWYWwpO1xuICAgICAgICB9IC8vIGZvciBwcm9wc1xuXG5cbiAgICAgICAgc2VsZi5lbWl0KCdzdHlsZScpO1xuICAgICAgfSAvLyBpZlxuXG4gICAgfVxuXG4gICAgYW5pX3AucHJvZ3Jlc3MgPSBwZXJjZW50O1xuICAgIHJldHVybiBwZXJjZW50O1xuICB9XG5cbiAgZnVuY3Rpb24gdmFsaWQoc3RhcnQsIGVuZCkge1xuICAgIGlmIChzdGFydCA9PSBudWxsIHx8IGVuZCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKG51bWJlciQxKHN0YXJ0KSAmJiBudW1iZXIkMShlbmQpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHN0YXJ0ICYmIGVuZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gc3RhcnRBbmltYXRpb24oc2VsZiwgYW5pLCBub3csIGlzQ29yZSkge1xuICAgIHZhciBhbmlfcCA9IGFuaS5fcHJpdmF0ZTtcbiAgICBhbmlfcC5zdGFydGVkID0gdHJ1ZTtcbiAgICBhbmlfcC5zdGFydFRpbWUgPSBub3cgLSBhbmlfcC5wcm9ncmVzcyAqIGFuaV9wLmR1cmF0aW9uO1xuICB9XG5cbiAgZnVuY3Rpb24gc3RlcEFsbChub3csIGN5KSB7XG4gICAgdmFyIGVsZXMgPSBjeS5fcHJpdmF0ZS5hbmlFbGVzO1xuICAgIHZhciBkb25lRWxlcyA9IFtdO1xuXG4gICAgZnVuY3Rpb24gc3RlcE9uZShlbGUsIGlzQ29yZSkge1xuICAgICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgICAgdmFyIGN1cnJlbnQgPSBfcC5hbmltYXRpb24uY3VycmVudDtcbiAgICAgIHZhciBxdWV1ZSA9IF9wLmFuaW1hdGlvbi5xdWV1ZTtcbiAgICAgIHZhciByYW5BbmlzID0gZmFsc2U7IC8vIGlmIG5vdGhpbmcgY3VycmVudGx5IGFuaW1hdGluZywgZ2V0IHNvbWV0aGluZyBmcm9tIHRoZSBxdWV1ZVxuXG4gICAgICBpZiAoY3VycmVudC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFyIG5leHQgPSBxdWV1ZS5zaGlmdCgpO1xuXG4gICAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgICAgY3VycmVudC5wdXNoKG5leHQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBjYWxsYmFja3MgPSBmdW5jdGlvbiBjYWxsYmFja3MoX2NhbGxiYWNrcykge1xuICAgICAgICBmb3IgKHZhciBqID0gX2NhbGxiYWNrcy5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICAgIHZhciBjYiA9IF9jYWxsYmFja3Nbal07XG4gICAgICAgICAgY2IoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9jYWxsYmFja3Muc3BsaWNlKDAsIF9jYWxsYmFja3MubGVuZ3RoKTtcbiAgICAgIH07IC8vIHN0ZXAgYW5kIHJlbW92ZSBpZiBkb25lXG5cblxuICAgICAgZm9yICh2YXIgaSA9IGN1cnJlbnQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIGFuaSA9IGN1cnJlbnRbaV07XG4gICAgICAgIHZhciBhbmlfcCA9IGFuaS5fcHJpdmF0ZTtcblxuICAgICAgICBpZiAoYW5pX3Auc3RvcHBlZCkge1xuICAgICAgICAgIGN1cnJlbnQuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIGFuaV9wLmhvb2tlZCA9IGZhbHNlO1xuICAgICAgICAgIGFuaV9wLnBsYXlpbmcgPSBmYWxzZTtcbiAgICAgICAgICBhbmlfcC5zdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgY2FsbGJhY2tzKGFuaV9wLmZyYW1lcyk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWFuaV9wLnBsYXlpbmcgJiYgIWFuaV9wLmFwcGx5aW5nKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gYW4gYXBwbHkoKSB3aGlsZSBwbGF5aW5nIHNob3VsZG4ndCBkbyBhbnl0aGluZ1xuXG5cbiAgICAgICAgaWYgKGFuaV9wLnBsYXlpbmcgJiYgYW5pX3AuYXBwbHlpbmcpIHtcbiAgICAgICAgICBhbmlfcC5hcHBseWluZyA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFhbmlfcC5zdGFydGVkKSB7XG4gICAgICAgICAgc3RhcnRBbmltYXRpb24oZWxlLCBhbmksIG5vdyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGVwJDEoZWxlLCBhbmksIG5vdywgaXNDb3JlKTtcblxuICAgICAgICBpZiAoYW5pX3AuYXBwbHlpbmcpIHtcbiAgICAgICAgICBhbmlfcC5hcHBseWluZyA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FsbGJhY2tzKGFuaV9wLmZyYW1lcyk7XG5cbiAgICAgICAgaWYgKGFuaV9wLnN0ZXAgIT0gbnVsbCkge1xuICAgICAgICAgIGFuaV9wLnN0ZXAobm93KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhbmkuY29tcGxldGVkKCkpIHtcbiAgICAgICAgICBjdXJyZW50LnNwbGljZShpLCAxKTtcbiAgICAgICAgICBhbmlfcC5ob29rZWQgPSBmYWxzZTtcbiAgICAgICAgICBhbmlfcC5wbGF5aW5nID0gZmFsc2U7XG4gICAgICAgICAgYW5pX3Auc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgIGNhbGxiYWNrcyhhbmlfcC5jb21wbGV0ZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmFuQW5pcyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNDb3JlICYmIGN1cnJlbnQubGVuZ3RoID09PSAwICYmIHF1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBkb25lRWxlcy5wdXNoKGVsZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByYW5BbmlzO1xuICAgIH0gLy8gc3RlcEVsZW1lbnRcbiAgICAvLyBoYW5kbGUgYWxsIGVsZXNcblxuXG4gICAgdmFyIHJhbkVsZUFuaSA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgZSA9IDA7IGUgPCBlbGVzLmxlbmd0aDsgZSsrKSB7XG4gICAgICB2YXIgZWxlID0gZWxlc1tlXTtcbiAgICAgIHZhciBoYW5kbGVkVGhpc0VsZSA9IHN0ZXBPbmUoZWxlKTtcbiAgICAgIHJhbkVsZUFuaSA9IHJhbkVsZUFuaSB8fCBoYW5kbGVkVGhpc0VsZTtcbiAgICB9IC8vIGVhY2ggZWxlbWVudFxuXG5cbiAgICB2YXIgcmFuQ29yZUFuaSA9IHN0ZXBPbmUoY3ksIHRydWUpOyAvLyBub3RpZnkgcmVuZGVyZXJcblxuICAgIGlmIChyYW5FbGVBbmkgfHwgcmFuQ29yZUFuaSkge1xuICAgICAgaWYgKGVsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBjeS5ub3RpZnkoJ2RyYXcnLCBlbGVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN5Lm5vdGlmeSgnZHJhdycpO1xuICAgICAgfVxuICAgIH0gLy8gcmVtb3ZlIGVsZW1lbnRzIGZyb20gbGlzdCBvZiBjdXJyZW50bHkgYW5pbWF0aW5nIGlmIGl0cyBxdWV1ZXMgYXJlIGVtcHR5XG5cblxuICAgIGVsZXMudW5tZXJnZShkb25lRWxlcyk7XG4gICAgY3kuZW1pdCgnc3RlcCcpO1xuICB9IC8vIHN0ZXBBbGxcblxuICB2YXIgY29yZWZuJDggPSB7XG4gICAgLy8gcHVsbCBpbiBhbmltYXRpb24gZnVuY3Rpb25zXG4gICAgYW5pbWF0ZTogZGVmaW5lLmFuaW1hdGUoKSxcbiAgICBhbmltYXRpb246IGRlZmluZS5hbmltYXRpb24oKSxcbiAgICBhbmltYXRlZDogZGVmaW5lLmFuaW1hdGVkKCksXG4gICAgY2xlYXJRdWV1ZTogZGVmaW5lLmNsZWFyUXVldWUoKSxcbiAgICBkZWxheTogZGVmaW5lLmRlbGF5KCksXG4gICAgZGVsYXlBbmltYXRpb246IGRlZmluZS5kZWxheUFuaW1hdGlvbigpLFxuICAgIHN0b3A6IGRlZmluZS5zdG9wKCksXG4gICAgYWRkVG9BbmltYXRpb25Qb29sOiBmdW5jdGlvbiBhZGRUb0FuaW1hdGlvblBvb2woZWxlcykge1xuICAgICAgdmFyIGN5ID0gdGhpcztcblxuICAgICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIHNhdmUgY3ljbGVzIHdoZW4gbm8gc3R5bGUgdXNlZFxuXG5cbiAgICAgIGN5Ll9wcml2YXRlLmFuaUVsZXMubWVyZ2UoZWxlcyk7XG4gICAgfSxcbiAgICBzdG9wQW5pbWF0aW9uTG9vcDogZnVuY3Rpb24gc3RvcEFuaW1hdGlvbkxvb3AoKSB7XG4gICAgICB0aGlzLl9wcml2YXRlLmFuaW1hdGlvbnNSdW5uaW5nID0gZmFsc2U7XG4gICAgfSxcbiAgICBzdGFydEFuaW1hdGlvbkxvb3A6IGZ1bmN0aW9uIHN0YXJ0QW5pbWF0aW9uTG9vcCgpIHtcbiAgICAgIHZhciBjeSA9IHRoaXM7XG4gICAgICBjeS5fcHJpdmF0ZS5hbmltYXRpb25zUnVubmluZyA9IHRydWU7XG5cbiAgICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBzYXZlIGN5Y2xlcyB3aGVuIG5vIHN0eWxlIHVzZWRcbiAgICAgIC8vIE5CIHRoZSBhbmltYXRpb24gbG9vcCB3aWxsIGV4ZWMgaW4gaGVhZGxlc3MgZW52aXJvbm1lbnRzIGlmIHN0eWxlIGVuYWJsZWRcbiAgICAgIC8vIGFuZCBleHBsaWNpdCBjeS5kZXN0cm95KCkgaXMgbmVjZXNzYXJ5IHRvIHN0b3AgdGhlIGxvb3BcblxuXG4gICAgICBmdW5jdGlvbiBoZWFkbGVzc1N0ZXAoKSB7XG4gICAgICAgIGlmICghY3kuX3ByaXZhdGUuYW5pbWF0aW9uc1J1bm5pbmcpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gYW5pbWF0aW9uU3RlcChub3cpIHtcbiAgICAgICAgICBzdGVwQWxsKG5vdywgY3kpO1xuICAgICAgICAgIGhlYWRsZXNzU3RlcCgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlbmRlcmVyID0gY3kucmVuZGVyZXIoKTtcblxuICAgICAgaWYgKHJlbmRlcmVyICYmIHJlbmRlcmVyLmJlZm9yZVJlbmRlcikge1xuICAgICAgICAvLyBsZXQgdGhlIHJlbmRlcmVyIHNjaGVkdWxlIGFuaW1hdGlvbnNcbiAgICAgICAgcmVuZGVyZXIuYmVmb3JlUmVuZGVyKGZ1bmN0aW9uIHJlbmRlcmVyQW5pbWF0aW9uU3RlcCh3aWxsRHJhdywgbm93KSB7XG4gICAgICAgICAgc3RlcEFsbChub3csIGN5KTtcbiAgICAgICAgfSwgcmVuZGVyZXIuYmVmb3JlUmVuZGVyUHJpb3JpdGllcy5hbmltYXRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG1hbmFnZSB0aGUgYW5pbWF0aW9uIGxvb3Agb3Vyc2VsdmVzXG4gICAgICAgIGhlYWRsZXNzU3RlcCgpOyAvLyBmaXJzdCBjYWxsXG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBlbWl0dGVyT3B0aW9ucyA9IHtcbiAgICBxdWFsaWZpZXJDb21wYXJlOiBmdW5jdGlvbiBxdWFsaWZpZXJDb21wYXJlKHNlbGVjdG9yMSwgc2VsZWN0b3IyKSB7XG4gICAgICBpZiAoc2VsZWN0b3IxID09IG51bGwgfHwgc2VsZWN0b3IyID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yMSA9PSBudWxsICYmIHNlbGVjdG9yMiA9PSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yMS5zYW1lVGV4dChzZWxlY3RvcjIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZXZlbnRNYXRjaGVzOiBmdW5jdGlvbiBldmVudE1hdGNoZXMoY3ksIGxpc3RlbmVyLCBldmVudE9iaikge1xuICAgICAgdmFyIHNlbGVjdG9yID0gbGlzdGVuZXIucXVhbGlmaWVyO1xuXG4gICAgICBpZiAoc2VsZWN0b3IgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gY3kgIT09IGV2ZW50T2JqLnRhcmdldCAmJiBlbGVtZW50KGV2ZW50T2JqLnRhcmdldCkgJiYgc2VsZWN0b3IubWF0Y2hlcyhldmVudE9iai50YXJnZXQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGFkZEV2ZW50RmllbGRzOiBmdW5jdGlvbiBhZGRFdmVudEZpZWxkcyhjeSwgZXZ0KSB7XG4gICAgICBldnQuY3kgPSBjeTtcbiAgICAgIGV2dC50YXJnZXQgPSBjeTtcbiAgICB9LFxuICAgIGNhbGxiYWNrQ29udGV4dDogZnVuY3Rpb24gY2FsbGJhY2tDb250ZXh0KGN5LCBsaXN0ZW5lciwgZXZlbnRPYmopIHtcbiAgICAgIHJldHVybiBsaXN0ZW5lci5xdWFsaWZpZXIgIT0gbnVsbCA/IGV2ZW50T2JqLnRhcmdldCA6IGN5O1xuICAgIH1cbiAgfTtcblxuICB2YXIgYXJnU2VsZWN0b3IgPSBmdW5jdGlvbiBhcmdTZWxlY3RvcihhcmcpIHtcbiAgICBpZiAoc3RyaW5nKGFyZykpIHtcbiAgICAgIHJldHVybiBuZXcgU2VsZWN0b3IoYXJnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFyZztcbiAgICB9XG4gIH07XG5cbiAgdmFyIGVsZXNmbiA9IHtcbiAgICBjcmVhdGVFbWl0dGVyOiBmdW5jdGlvbiBjcmVhdGVFbWl0dGVyKCkge1xuICAgICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcblxuICAgICAgaWYgKCFfcC5lbWl0dGVyKSB7XG4gICAgICAgIF9wLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcihlbWl0dGVyT3B0aW9ucywgdGhpcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZW1pdHRlcjogZnVuY3Rpb24gZW1pdHRlcigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmVtaXR0ZXI7XG4gICAgfSxcbiAgICBvbjogZnVuY3Rpb24gb24oZXZlbnRzLCBzZWxlY3RvciwgY2FsbGJhY2spIHtcbiAgICAgIHRoaXMuZW1pdHRlcigpLm9uKGV2ZW50cywgYXJnU2VsZWN0b3Ioc2VsZWN0b3IpLCBjYWxsYmFjayk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHJlbW92ZUxpc3RlbmVyOiBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihldmVudHMsIHNlbGVjdG9yLCBjYWxsYmFjaykge1xuICAgICAgdGhpcy5lbWl0dGVyKCkucmVtb3ZlTGlzdGVuZXIoZXZlbnRzLCBhcmdTZWxlY3RvcihzZWxlY3RvciksIGNhbGxiYWNrKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgcmVtb3ZlQWxsTGlzdGVuZXJzOiBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnMoKSB7XG4gICAgICB0aGlzLmVtaXR0ZXIoKS5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgb25lOiBmdW5jdGlvbiBvbmUoZXZlbnRzLCBzZWxlY3RvciwgY2FsbGJhY2spIHtcbiAgICAgIHRoaXMuZW1pdHRlcigpLm9uZShldmVudHMsIGFyZ1NlbGVjdG9yKHNlbGVjdG9yKSwgY2FsbGJhY2spO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBvbmNlOiBmdW5jdGlvbiBvbmNlKGV2ZW50cywgc2VsZWN0b3IsIGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLmVtaXR0ZXIoKS5vbmUoZXZlbnRzLCBhcmdTZWxlY3RvcihzZWxlY3RvciksIGNhbGxiYWNrKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZW1pdDogZnVuY3Rpb24gZW1pdChldmVudHMsIGV4dHJhUGFyYW1zKSB7XG4gICAgICB0aGlzLmVtaXR0ZXIoKS5lbWl0KGV2ZW50cywgZXh0cmFQYXJhbXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBlbWl0QW5kTm90aWZ5OiBmdW5jdGlvbiBlbWl0QW5kTm90aWZ5KGV2ZW50LCBlbGVzKSB7XG4gICAgICB0aGlzLmVtaXQoZXZlbnQpO1xuICAgICAgdGhpcy5ub3RpZnkoZXZlbnQsIGVsZXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O1xuICBkZWZpbmUuZXZlbnRBbGlhc2VzT24oZWxlc2ZuKTtcblxuICB2YXIgY29yZWZuJDcgPSB7XG4gICAgcG5nOiBmdW5jdGlvbiBwbmcob3B0aW9ucykge1xuICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5fcHJpdmF0ZS5yZW5kZXJlcjtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgcmV0dXJuIHJlbmRlcmVyLnBuZyhvcHRpb25zKTtcbiAgICB9LFxuICAgIGpwZzogZnVuY3Rpb24ganBnKG9wdGlvbnMpIHtcbiAgICAgIHZhciByZW5kZXJlciA9IHRoaXMuX3ByaXZhdGUucmVuZGVyZXI7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIG9wdGlvbnMuYmcgPSBvcHRpb25zLmJnIHx8ICcjZmZmJztcbiAgICAgIHJldHVybiByZW5kZXJlci5qcGcob3B0aW9ucyk7XG4gICAgfVxuICB9O1xuICBjb3JlZm4kNy5qcGVnID0gY29yZWZuJDcuanBnO1xuXG4gIHZhciBjb3JlZm4kNiA9IHtcbiAgICBsYXlvdXQ6IGZ1bmN0aW9uIGxheW91dChvcHRpb25zKSB7XG4gICAgICB2YXIgY3kgPSB0aGlzO1xuXG4gICAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgIGVycm9yKCdMYXlvdXQgb3B0aW9ucyBtdXN0IGJlIHNwZWNpZmllZCB0byBtYWtlIGEgbGF5b3V0Jyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMubmFtZSA9PSBudWxsKSB7XG4gICAgICAgIGVycm9yKCdBIGBuYW1lYCBtdXN0IGJlIHNwZWNpZmllZCB0byBtYWtlIGEgbGF5b3V0Jyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIG5hbWUgPSBvcHRpb25zLm5hbWU7XG4gICAgICB2YXIgTGF5b3V0ID0gY3kuZXh0ZW5zaW9uKCdsYXlvdXQnLCBuYW1lKTtcblxuICAgICAgaWYgKExheW91dCA9PSBudWxsKSB7XG4gICAgICAgIGVycm9yKCdObyBzdWNoIGxheW91dCBgJyArIG5hbWUgKyAnYCBmb3VuZC4gIERpZCB5b3UgZm9yZ2V0IHRvIGltcG9ydCBpdCBhbmQgYGN5dG9zY2FwZS51c2UoKWAgaXQ/Jyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGVsZXM7XG5cbiAgICAgIGlmIChzdHJpbmcob3B0aW9ucy5lbGVzKSkge1xuICAgICAgICBlbGVzID0gY3kuJChvcHRpb25zLmVsZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlcyA9IG9wdGlvbnMuZWxlcyAhPSBudWxsID8gb3B0aW9ucy5lbGVzIDogY3kuJCgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGF5b3V0ID0gbmV3IExheW91dChleHRlbmQoe30sIG9wdGlvbnMsIHtcbiAgICAgICAgY3k6IGN5LFxuICAgICAgICBlbGVzOiBlbGVzXG4gICAgICB9KSk7XG4gICAgICByZXR1cm4gbGF5b3V0O1xuICAgIH1cbiAgfTtcbiAgY29yZWZuJDYuY3JlYXRlTGF5b3V0ID0gY29yZWZuJDYubWFrZUxheW91dCA9IGNvcmVmbiQ2LmxheW91dDtcblxuICB2YXIgY29yZWZuJDUgPSB7XG4gICAgbm90aWZ5OiBmdW5jdGlvbiBub3RpZnkoZXZlbnROYW1lLCBldmVudEVsZXMpIHtcbiAgICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICAgIGlmICh0aGlzLmJhdGNoaW5nKCkpIHtcbiAgICAgICAgX3AuYmF0Y2hOb3RpZmljYXRpb25zID0gX3AuYmF0Y2hOb3RpZmljYXRpb25zIHx8IHt9O1xuICAgICAgICB2YXIgZWxlcyA9IF9wLmJhdGNoTm90aWZpY2F0aW9uc1tldmVudE5hbWVdID0gX3AuYmF0Y2hOb3RpZmljYXRpb25zW2V2ZW50TmFtZV0gfHwgdGhpcy5jb2xsZWN0aW9uKCk7XG5cbiAgICAgICAgaWYgKGV2ZW50RWxlcyAhPSBudWxsKSB7XG4gICAgICAgICAgZWxlcy5tZXJnZShldmVudEVsZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuOyAvLyBub3RpZmljYXRpb25zIGFyZSBkaXNhYmxlZCBkdXJpbmcgYmF0Y2hpbmdcbiAgICAgIH1cblxuICAgICAgaWYgKCFfcC5ub3RpZmljYXRpb25zRW5hYmxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIGV4aXQgb24gZGlzYWJsZWRcblxuXG4gICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyKCk7IC8vIGV4aXQgaWYgZGVzdHJveSgpIGNhbGxlZCBvbiBjb3JlIG9yIHJlbmRlcmVyIGluIGJldHdlZW4gZnJhbWVzICMxNDk5ICMxNTI4XG5cbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCgpIHx8ICFyZW5kZXJlcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJlbmRlcmVyLm5vdGlmeShldmVudE5hbWUsIGV2ZW50RWxlcyk7XG4gICAgfSxcbiAgICBub3RpZmljYXRpb25zOiBmdW5jdGlvbiBub3RpZmljYXRpb25zKGJvb2wpIHtcbiAgICAgIHZhciBwID0gdGhpcy5fcHJpdmF0ZTtcblxuICAgICAgaWYgKGJvb2wgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gcC5ub3RpZmljYXRpb25zRW5hYmxlZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHAubm90aWZpY2F0aW9uc0VuYWJsZWQgPSBib29sID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIG5vTm90aWZpY2F0aW9uczogZnVuY3Rpb24gbm9Ob3RpZmljYXRpb25zKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLm5vdGlmaWNhdGlvbnMoZmFsc2UpO1xuICAgICAgY2FsbGJhY2soKTtcbiAgICAgIHRoaXMubm90aWZpY2F0aW9ucyh0cnVlKTtcbiAgICB9LFxuICAgIGJhdGNoaW5nOiBmdW5jdGlvbiBiYXRjaGluZygpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmJhdGNoQ291bnQgPiAwO1xuICAgIH0sXG4gICAgc3RhcnRCYXRjaDogZnVuY3Rpb24gc3RhcnRCYXRjaCgpIHtcbiAgICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICAgIGlmIChfcC5iYXRjaENvdW50ID09IG51bGwpIHtcbiAgICAgICAgX3AuYmF0Y2hDb3VudCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChfcC5iYXRjaENvdW50ID09PSAwKSB7XG4gICAgICAgIF9wLmJhdGNoU3R5bGVFbGVzID0gdGhpcy5jb2xsZWN0aW9uKCk7XG4gICAgICAgIF9wLmJhdGNoTm90aWZpY2F0aW9ucyA9IHt9O1xuICAgICAgfVxuXG4gICAgICBfcC5iYXRjaENvdW50Kys7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGVuZEJhdGNoOiBmdW5jdGlvbiBlbmRCYXRjaCgpIHtcbiAgICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICAgIGlmIChfcC5iYXRjaENvdW50ID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBfcC5iYXRjaENvdW50LS07XG5cbiAgICAgIGlmIChfcC5iYXRjaENvdW50ID09PSAwKSB7XG4gICAgICAgIC8vIHVwZGF0ZSBzdHlsZSBmb3IgZGlydHkgZWxlc1xuICAgICAgICBfcC5iYXRjaFN0eWxlRWxlcy51cGRhdGVTdHlsZSgpO1xuXG4gICAgICAgIHZhciByZW5kZXJlciA9IHRoaXMucmVuZGVyZXIoKTsgLy8gbm90aWZ5IHRoZSByZW5kZXJlciBvZiBxdWV1ZWQgZWxlcyBhbmQgZXZlbnQgdHlwZXNcblxuICAgICAgICBPYmplY3Qua2V5cyhfcC5iYXRjaE5vdGlmaWNhdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgICAgIHZhciBlbGVzID0gX3AuYmF0Y2hOb3RpZmljYXRpb25zW2V2ZW50TmFtZV07XG5cbiAgICAgICAgICBpZiAoZWxlcy5lbXB0eSgpKSB7XG4gICAgICAgICAgICByZW5kZXJlci5ub3RpZnkoZXZlbnROYW1lKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVuZGVyZXIubm90aWZ5KGV2ZW50TmFtZSwgZWxlcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBiYXRjaDogZnVuY3Rpb24gYmF0Y2goY2FsbGJhY2spIHtcbiAgICAgIHRoaXMuc3RhcnRCYXRjaCgpO1xuICAgICAgY2FsbGJhY2soKTtcbiAgICAgIHRoaXMuZW5kQmF0Y2goKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLy8gZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgYmF0Y2hEYXRhOiBmdW5jdGlvbiBiYXRjaERhdGEobWFwKSB7XG4gICAgICB2YXIgY3kgPSB0aGlzO1xuICAgICAgcmV0dXJuIHRoaXMuYmF0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaWRzID0gT2JqZWN0LmtleXMobWFwKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBpZCA9IGlkc1tpXTtcbiAgICAgICAgICB2YXIgZGF0YSA9IG1hcFtpZF07XG4gICAgICAgICAgdmFyIGVsZSA9IGN5LmdldEVsZW1lbnRCeUlkKGlkKTtcbiAgICAgICAgICBlbGUuZGF0YShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciByZW5kZXJlckRlZmF1bHRzID0gZGVmYXVsdHMkZyh7XG4gICAgaGlkZUVkZ2VzT25WaWV3cG9ydDogZmFsc2UsXG4gICAgdGV4dHVyZU9uVmlld3BvcnQ6IGZhbHNlLFxuICAgIG1vdGlvbkJsdXI6IGZhbHNlLFxuICAgIG1vdGlvbkJsdXJPcGFjaXR5OiAwLjA1LFxuICAgIHBpeGVsUmF0aW86IHVuZGVmaW5lZCxcbiAgICBkZXNrdG9wVGFwVGhyZXNob2xkOiA0LFxuICAgIHRvdWNoVGFwVGhyZXNob2xkOiA4LFxuICAgIHdoZWVsU2Vuc2l0aXZpdHk6IDEsXG4gICAgZGVidWc6IGZhbHNlLFxuICAgIHNob3dGcHM6IGZhbHNlXG4gIH0pO1xuICB2YXIgY29yZWZuJDQgPSB7XG4gICAgcmVuZGVyVG86IGZ1bmN0aW9uIHJlbmRlclRvKGNvbnRleHQsIHpvb20sIHBhbiwgcHhSYXRpbykge1xuICAgICAgdmFyIHIgPSB0aGlzLl9wcml2YXRlLnJlbmRlcmVyO1xuICAgICAgci5yZW5kZXJUbyhjb250ZXh0LCB6b29tLCBwYW4sIHB4UmF0aW8pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICByZW5kZXJlcjogZnVuY3Rpb24gcmVuZGVyZXIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5yZW5kZXJlcjtcbiAgICB9LFxuICAgIGZvcmNlUmVuZGVyOiBmdW5jdGlvbiBmb3JjZVJlbmRlcigpIHtcbiAgICAgIHRoaXMubm90aWZ5KCdkcmF3Jyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHJlc2l6ZTogZnVuY3Rpb24gcmVzaXplKCkge1xuICAgICAgdGhpcy5pbnZhbGlkYXRlU2l6ZSgpO1xuICAgICAgdGhpcy5lbWl0QW5kTm90aWZ5KCdyZXNpemUnKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgaW5pdFJlbmRlcmVyOiBmdW5jdGlvbiBpbml0UmVuZGVyZXIob3B0aW9ucykge1xuICAgICAgdmFyIGN5ID0gdGhpcztcbiAgICAgIHZhciBSZW5kZXJlclByb3RvID0gY3kuZXh0ZW5zaW9uKCdyZW5kZXJlcicsIG9wdGlvbnMubmFtZSk7XG5cbiAgICAgIGlmIChSZW5kZXJlclByb3RvID09IG51bGwpIHtcbiAgICAgICAgZXJyb3IoXCJDYW4gbm90IGluaXRpYWxpc2U6IE5vIHN1Y2ggcmVuZGVyZXIgYFwiLmNvbmNhdChvcHRpb25zLm5hbWUsIFwiYCBmb3VuZC4gRGlkIHlvdSBmb3JnZXQgdG8gaW1wb3J0IGl0IGFuZCBgY3l0b3NjYXBlLnVzZSgpYCBpdD9cIikpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLndoZWVsU2Vuc2l0aXZpdHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB3YXJuKFwiWW91IGhhdmUgc2V0IGEgY3VzdG9tIHdoZWVsIHNlbnNpdGl2aXR5LiAgVGhpcyB3aWxsIG1ha2UgeW91ciBhcHAgem9vbSB1bm5hdHVyYWxseSB3aGVuIHVzaW5nIG1haW5zdHJlYW0gbWljZS4gIFlvdSBzaG91bGQgY2hhbmdlIHRoaXMgdmFsdWUgZnJvbSB0aGUgZGVmYXVsdCBvbmx5IGlmIHlvdSBjYW4gZ3VhcmFudGVlIHRoYXQgYWxsIHlvdXIgdXNlcnMgd2lsbCB1c2UgdGhlIHNhbWUgaGFyZHdhcmUgYW5kIE9TIGNvbmZpZ3VyYXRpb24gYXMgeW91ciBjdXJyZW50IG1hY2hpbmUuXCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgck9wdHMgPSByZW5kZXJlckRlZmF1bHRzKG9wdGlvbnMpO1xuICAgICAgck9wdHMuY3kgPSBjeTtcbiAgICAgIGN5Ll9wcml2YXRlLnJlbmRlcmVyID0gbmV3IFJlbmRlcmVyUHJvdG8ock9wdHMpO1xuICAgICAgdGhpcy5ub3RpZnkoJ2luaXQnKTtcbiAgICB9LFxuICAgIGRlc3Ryb3lSZW5kZXJlcjogZnVuY3Rpb24gZGVzdHJveVJlbmRlcmVyKCkge1xuICAgICAgdmFyIGN5ID0gdGhpcztcbiAgICAgIGN5Lm5vdGlmeSgnZGVzdHJveScpOyAvLyBkZXN0cm95IHRoZSByZW5kZXJlclxuXG4gICAgICB2YXIgZG9tRWxlID0gY3kuY29udGFpbmVyKCk7XG5cbiAgICAgIGlmIChkb21FbGUpIHtcbiAgICAgICAgZG9tRWxlLl9jeXJlZyA9IG51bGw7XG5cbiAgICAgICAgd2hpbGUgKGRvbUVsZS5jaGlsZE5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBkb21FbGUucmVtb3ZlQ2hpbGQoZG9tRWxlLmNoaWxkTm9kZXNbMF0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGN5Ll9wcml2YXRlLnJlbmRlcmVyID0gbnVsbDsgLy8gdG8gYmUgZXh0cmEgc2FmZSwgcmVtb3ZlIHRoZSByZWZcblxuICAgICAgY3kubXV0YWJsZUVsZW1lbnRzKCkuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICAgICAgX3AucnNjcmF0Y2ggPSB7fTtcbiAgICAgICAgX3AucnN0eWxlID0ge307XG4gICAgICAgIF9wLmFuaW1hdGlvbi5jdXJyZW50ID0gW107XG4gICAgICAgIF9wLmFuaW1hdGlvbi5xdWV1ZSA9IFtdO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBvblJlbmRlcjogZnVuY3Rpb24gb25SZW5kZXIoZm4pIHtcbiAgICAgIHJldHVybiB0aGlzLm9uKCdyZW5kZXInLCBmbik7XG4gICAgfSxcbiAgICBvZmZSZW5kZXI6IGZ1bmN0aW9uIG9mZlJlbmRlcihmbikge1xuICAgICAgcmV0dXJuIHRoaXMub2ZmKCdyZW5kZXInLCBmbik7XG4gICAgfVxuICB9O1xuICBjb3JlZm4kNC5pbnZhbGlkYXRlRGltZW5zaW9ucyA9IGNvcmVmbiQ0LnJlc2l6ZTtcblxuICB2YXIgY29yZWZuJDMgPSB7XG4gICAgLy8gZ2V0IGEgY29sbGVjdGlvblxuICAgIC8vIC0gZW1wdHkgY29sbGVjdGlvbiBvbiBubyBhcmdzXG4gICAgLy8gLSBjb2xsZWN0aW9uIG9mIGVsZW1lbnRzIGluIHRoZSBncmFwaCBvbiBzZWxlY3RvciBhcmdcbiAgICAvLyAtIGd1YXJhbnRlZSBhIHJldHVybmVkIGNvbGxlY3Rpb24gd2hlbiBlbGVtZW50cyBvciBjb2xsZWN0aW9uIHNwZWNpZmllZFxuICAgIGNvbGxlY3Rpb246IGZ1bmN0aW9uIGNvbGxlY3Rpb24oZWxlcywgb3B0cykge1xuICAgICAgaWYgKHN0cmluZyhlbGVzKSkge1xuICAgICAgICByZXR1cm4gdGhpcy4kKGVsZXMpO1xuICAgICAgfSBlbHNlIGlmIChlbGVtZW50T3JDb2xsZWN0aW9uKGVsZXMpKSB7XG4gICAgICAgIHJldHVybiBlbGVzLmNvbGxlY3Rpb24oKTtcbiAgICAgIH0gZWxzZSBpZiAoYXJyYXkoZWxlcykpIHtcbiAgICAgICAgaWYgKCFvcHRzKSB7XG4gICAgICAgICAgb3B0cyA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uKHRoaXMsIGVsZXMsIG9wdHMudW5pcXVlLCBvcHRzLnJlbW92ZWQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IENvbGxlY3Rpb24odGhpcyk7XG4gICAgfSxcbiAgICBub2RlczogZnVuY3Rpb24gbm9kZXMoc2VsZWN0b3IpIHtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMuJChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgIHJldHVybiBlbGUuaXNOb2RlKCk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiBub2Rlcy5maWx0ZXIoc2VsZWN0b3IpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbm9kZXM7XG4gICAgfSxcbiAgICBlZGdlczogZnVuY3Rpb24gZWRnZXMoc2VsZWN0b3IpIHtcbiAgICAgIHZhciBlZGdlcyA9IHRoaXMuJChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgIHJldHVybiBlbGUuaXNFZGdlKCk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiBlZGdlcy5maWx0ZXIoc2VsZWN0b3IpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZWRnZXM7XG4gICAgfSxcbiAgICAvLyBzZWFyY2ggdGhlIGdyYXBoIGxpa2UgalF1ZXJ5XG4gICAgJDogZnVuY3Rpb24gJChzZWxlY3Rvcikge1xuICAgICAgdmFyIGVsZXMgPSB0aGlzLl9wcml2YXRlLmVsZW1lbnRzO1xuXG4gICAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIGVsZXMuZmlsdGVyKHNlbGVjdG9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBlbGVzLnNwYXduU2VsZigpO1xuICAgICAgfVxuICAgIH0sXG4gICAgbXV0YWJsZUVsZW1lbnRzOiBmdW5jdGlvbiBtdXRhYmxlRWxlbWVudHMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5lbGVtZW50cztcbiAgICB9XG4gIH07IC8vIGFsaWFzZXNcblxuICBjb3JlZm4kMy5lbGVtZW50cyA9IGNvcmVmbiQzLmZpbHRlciA9IGNvcmVmbiQzLiQ7XG5cbiAgdmFyIHN0eWZuJDggPSB7fTsgLy8ga2V5cyBmb3Igc3R5bGUgYmxvY2tzLCBlLmcuIHR0ZmZ0dFxuXG4gIHZhciBUUlVFID0gJ3QnO1xuICB2YXIgRkFMU0UgPSAnZic7IC8vIChwb3RlbnRpYWxseSBleHBlbnNpdmUgY2FsY3VsYXRpb24pXG4gIC8vIGFwcGx5IHRoZSBzdHlsZSB0byB0aGUgZWxlbWVudCBiYXNlZCBvblxuICAvLyAtIGl0cyBieXBhc3NcbiAgLy8gLSB3aGF0IHNlbGVjdG9ycyBtYXRjaCBpdFxuXG4gIHN0eWZuJDguYXBwbHkgPSBmdW5jdGlvbiAoZWxlcykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgX3AgPSBzZWxmLl9wcml2YXRlO1xuICAgIHZhciBjeSA9IF9wLmN5O1xuICAgIHZhciB1cGRhdGVkRWxlcyA9IGN5LmNvbGxlY3Rpb24oKTtcblxuICAgIGZvciAodmFyIGllID0gMDsgaWUgPCBlbGVzLmxlbmd0aDsgaWUrKykge1xuICAgICAgdmFyIGVsZSA9IGVsZXNbaWVdO1xuICAgICAgdmFyIGN4dE1ldGEgPSBzZWxmLmdldENvbnRleHRNZXRhKGVsZSk7XG5cbiAgICAgIGlmIChjeHRNZXRhLmVtcHR5KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3h0U3R5bGUgPSBzZWxmLmdldENvbnRleHRTdHlsZShjeHRNZXRhKTtcbiAgICAgIHZhciBhcHAgPSBzZWxmLmFwcGx5Q29udGV4dFN0eWxlKGN4dE1ldGEsIGN4dFN0eWxlLCBlbGUpO1xuXG4gICAgICBpZiAoZWxlLl9wcml2YXRlLmFwcGxpZWRJbml0U3R5bGUpIHtcbiAgICAgICAgc2VsZi51cGRhdGVUcmFuc2l0aW9ucyhlbGUsIGFwcC5kaWZmUHJvcHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlLl9wcml2YXRlLmFwcGxpZWRJbml0U3R5bGUgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgaGludHNEaWZmID0gc2VsZi51cGRhdGVTdHlsZUhpbnRzKGVsZSk7XG5cbiAgICAgIGlmIChoaW50c0RpZmYpIHtcbiAgICAgICAgdXBkYXRlZEVsZXMucHVzaChlbGUpO1xuICAgICAgfVxuICAgIH0gLy8gZm9yIGVsZW1lbnRzXG5cblxuICAgIHJldHVybiB1cGRhdGVkRWxlcztcbiAgfTtcblxuICBzdHlmbiQ4LmdldFByb3BlcnRpZXNEaWZmID0gZnVuY3Rpb24gKG9sZEN4dEtleSwgbmV3Q3h0S2V5KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjYWNoZSA9IHNlbGYuX3ByaXZhdGUucHJvcERpZmZzID0gc2VsZi5fcHJpdmF0ZS5wcm9wRGlmZnMgfHwge307XG4gICAgdmFyIGR1YWxDeHRLZXkgPSBvbGRDeHRLZXkgKyAnLScgKyBuZXdDeHRLZXk7XG4gICAgdmFyIGNhY2hlZFZhbCA9IGNhY2hlW2R1YWxDeHRLZXldO1xuXG4gICAgaWYgKGNhY2hlZFZhbCkge1xuICAgICAgcmV0dXJuIGNhY2hlZFZhbDtcbiAgICB9XG5cbiAgICB2YXIgZGlmZlByb3BzID0gW107XG4gICAgdmFyIGFkZGVkUHJvcCA9IHt9O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY3h0ID0gc2VsZltpXTtcbiAgICAgIHZhciBvbGRIYXNDeHQgPSBvbGRDeHRLZXlbaV0gPT09IFRSVUU7XG4gICAgICB2YXIgbmV3SGFzQ3h0ID0gbmV3Q3h0S2V5W2ldID09PSBUUlVFO1xuICAgICAgdmFyIGN4dEhhc0RpZmZlZCA9IG9sZEhhc0N4dCAhPT0gbmV3SGFzQ3h0O1xuICAgICAgdmFyIGN4dEhhc01hcHBlZFByb3BzID0gY3h0Lm1hcHBlZFByb3BlcnRpZXMubGVuZ3RoID4gMDtcblxuICAgICAgaWYgKGN4dEhhc0RpZmZlZCB8fCBuZXdIYXNDeHQgJiYgY3h0SGFzTWFwcGVkUHJvcHMpIHtcbiAgICAgICAgdmFyIHByb3BzID0gdm9pZCAwO1xuXG4gICAgICAgIGlmIChjeHRIYXNEaWZmZWQgJiYgY3h0SGFzTWFwcGVkUHJvcHMpIHtcbiAgICAgICAgICBwcm9wcyA9IGN4dC5wcm9wZXJ0aWVzOyAvLyBzdWZmaWNlcyBiL2MgbWFwcGVkUHJvcGVydGllcyBpcyBhIHN1YnNldCBvZiBwcm9wZXJ0aWVzXG4gICAgICAgIH0gZWxzZSBpZiAoY3h0SGFzRGlmZmVkKSB7XG4gICAgICAgICAgcHJvcHMgPSBjeHQucHJvcGVydGllczsgLy8gbmVlZCB0byBjaGVjayB0aGVtIGFsbFxuICAgICAgICB9IGVsc2UgaWYgKGN4dEhhc01hcHBlZFByb3BzKSB7XG4gICAgICAgICAgcHJvcHMgPSBjeHQubWFwcGVkUHJvcGVydGllczsgLy8gb25seSBuZWVkIHRvIGNoZWNrIG1hcHBlZFxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwcm9wcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHZhciBwcm9wID0gcHJvcHNbal07XG4gICAgICAgICAgdmFyIG5hbWUgPSBwcm9wLm5hbWU7IC8vIGlmIGEgbGF0ZXIgY29udGV4dCBvdmVycmlkZXMgdGhpcyBwcm9wZXJ0eSwgdGhlbiB0aGUgZmFjdCB0aGF0IHRoaXMgY29udGV4dCBoYXMgc3dpdGNoZWQvZGlmZmVkIGRvZXNuJ3QgbWF0dGVyXG4gICAgICAgICAgLy8gKHNlbWkgZXhwZW5zaXZlIGNoZWNrIHNpbmNlIGl0IG1ha2VzIHRoaXMgZnVuY3Rpb24gTyhuXjIpIG9uIGNvbnRleHQgbGVuZ3RoLCBidXQgd29ydGggaXQgc2luY2Ugb3ZlcmFsbCByZXN1bHRcbiAgICAgICAgICAvLyBpcyBjYWNoZWQpXG5cbiAgICAgICAgICB2YXIgbGF0ZXJDeHRPdmVycmlkZXMgPSBmYWxzZTtcblxuICAgICAgICAgIGZvciAodmFyIGsgPSBpICsgMTsgayA8IHNlbGYubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIHZhciBsYXRlckN4dCA9IHNlbGZba107XG4gICAgICAgICAgICB2YXIgaGFzTGF0ZXJDeHQgPSBuZXdDeHRLZXlba10gPT09IFRSVUU7XG5cbiAgICAgICAgICAgIGlmICghaGFzTGF0ZXJDeHQpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IC8vIGNhbid0IG92ZXJyaWRlIHVubGVzcyB0aGUgY29udGV4dCBpcyBhY3RpdmVcblxuXG4gICAgICAgICAgICBsYXRlckN4dE92ZXJyaWRlcyA9IGxhdGVyQ3h0LnByb3BlcnRpZXNbcHJvcC5uYW1lXSAhPSBudWxsO1xuXG4gICAgICAgICAgICBpZiAobGF0ZXJDeHRPdmVycmlkZXMpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IC8vIGV4aXQgZWFybHkgYXMgbG9uZyBhcyBvbmUgbGF0ZXIgY29udGV4dCBvdmVycmlkZXNcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghYWRkZWRQcm9wW25hbWVdICYmICFsYXRlckN4dE92ZXJyaWRlcykge1xuICAgICAgICAgICAgYWRkZWRQcm9wW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgIGRpZmZQcm9wcy5wdXNoKG5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBmb3IgcHJvcHNcblxuICAgICAgfSAvLyBpZlxuXG4gICAgfSAvLyBmb3IgY29udGV4dHNcblxuXG4gICAgY2FjaGVbZHVhbEN4dEtleV0gPSBkaWZmUHJvcHM7XG4gICAgcmV0dXJuIGRpZmZQcm9wcztcbiAgfTtcblxuICBzdHlmbiQ4LmdldENvbnRleHRNZXRhID0gZnVuY3Rpb24gKGVsZSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY3h0S2V5ID0gJyc7XG4gICAgdmFyIGRpZmZQcm9wcztcbiAgICB2YXIgcHJldktleSA9IGVsZS5fcHJpdmF0ZS5zdHlsZUN4dEtleSB8fCAnJzsgLy8gZ2V0IHRoZSBjeHQga2V5XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjb250ZXh0ID0gc2VsZltpXTtcbiAgICAgIHZhciBjb250ZXh0U2VsZWN0b3JNYXRjaGVzID0gY29udGV4dC5zZWxlY3RvciAmJiBjb250ZXh0LnNlbGVjdG9yLm1hdGNoZXMoZWxlKTsgLy8gTkI6IGNvbnRleHQuc2VsZWN0b3IgbWF5IGJlIG51bGwgZm9yICdjb3JlJ1xuXG4gICAgICBpZiAoY29udGV4dFNlbGVjdG9yTWF0Y2hlcykge1xuICAgICAgICBjeHRLZXkgKz0gVFJVRTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN4dEtleSArPSBGQUxTRTtcbiAgICAgIH1cbiAgICB9IC8vIGZvciBjb250ZXh0XG5cblxuICAgIGRpZmZQcm9wcyA9IHNlbGYuZ2V0UHJvcGVydGllc0RpZmYocHJldktleSwgY3h0S2V5KTtcbiAgICBlbGUuX3ByaXZhdGUuc3R5bGVDeHRLZXkgPSBjeHRLZXk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtleTogY3h0S2V5LFxuICAgICAgZGlmZlByb3BOYW1lczogZGlmZlByb3BzLFxuICAgICAgZW1wdHk6IGRpZmZQcm9wcy5sZW5ndGggPT09IDBcbiAgICB9O1xuICB9OyAvLyBnZXRzIGEgY29tcHV0ZWQgZWxlIHN0eWxlIG9iamVjdCBiYXNlZCBvbiBtYXRjaGVkIGNvbnRleHRzXG5cblxuICBzdHlmbiQ4LmdldENvbnRleHRTdHlsZSA9IGZ1bmN0aW9uIChjeHRNZXRhKSB7XG4gICAgdmFyIGN4dEtleSA9IGN4dE1ldGEua2V5O1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY3h0U3R5bGVzID0gdGhpcy5fcHJpdmF0ZS5jb250ZXh0U3R5bGVzID0gdGhpcy5fcHJpdmF0ZS5jb250ZXh0U3R5bGVzIHx8IHt9OyAvLyBpZiBhbHJlYWR5IGNvbXB1dGVkIHN0eWxlLCByZXR1cm5lZCBjYWNoZWQgY29weVxuXG4gICAgaWYgKGN4dFN0eWxlc1tjeHRLZXldKSB7XG4gICAgICByZXR1cm4gY3h0U3R5bGVzW2N4dEtleV07XG4gICAgfVxuXG4gICAgdmFyIHN0eWxlID0ge1xuICAgICAgX3ByaXZhdGU6IHtcbiAgICAgICAga2V5OiBjeHRLZXlcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY3h0ID0gc2VsZltpXTtcbiAgICAgIHZhciBoYXNDeHQgPSBjeHRLZXlbaV0gPT09IFRSVUU7XG5cbiAgICAgIGlmICghaGFzQ3h0KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGN4dC5wcm9wZXJ0aWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBwcm9wID0gY3h0LnByb3BlcnRpZXNbal07XG4gICAgICAgIHN0eWxlW3Byb3AubmFtZV0gPSBwcm9wO1xuICAgICAgfVxuICAgIH1cblxuICAgIGN4dFN0eWxlc1tjeHRLZXldID0gc3R5bGU7XG4gICAgcmV0dXJuIHN0eWxlO1xuICB9O1xuXG4gIHN0eWZuJDguYXBwbHlDb250ZXh0U3R5bGUgPSBmdW5jdGlvbiAoY3h0TWV0YSwgY3h0U3R5bGUsIGVsZSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZGlmZlByb3BzID0gY3h0TWV0YS5kaWZmUHJvcE5hbWVzO1xuICAgIHZhciByZXREaWZmUHJvcHMgPSB7fTtcbiAgICB2YXIgdHlwZXMgPSBzZWxmLnR5cGVzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaWZmUHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkaWZmUHJvcE5hbWUgPSBkaWZmUHJvcHNbaV07XG4gICAgICB2YXIgY3h0UHJvcCA9IGN4dFN0eWxlW2RpZmZQcm9wTmFtZV07XG4gICAgICB2YXIgZWxlUHJvcCA9IGVsZS5wc3R5bGUoZGlmZlByb3BOYW1lKTtcblxuICAgICAgaWYgKCFjeHRQcm9wKSB7XG4gICAgICAgIC8vIG5vIGNvbnRleHQgcHJvcCBtZWFucyBkZWxldGVcbiAgICAgICAgaWYgKCFlbGVQcm9wKSB7XG4gICAgICAgICAgY29udGludWU7IC8vIG5vIGV4aXN0aW5nIHByb3AgbWVhbnMgbm90aGluZyBuZWVkcyB0byBiZSByZW1vdmVkXG4gICAgICAgICAgLy8gbmIgYWZmZWN0cyBpbml0aWFsIGFwcGxpY2F0aW9uIG9uIG1hcHBlZCB2YWx1ZXMgbGlrZSBjb250cm9sLXBvaW50LWRpc3RhbmNlc1xuICAgICAgICB9IGVsc2UgaWYgKGVsZVByb3AuYnlwYXNzKSB7XG4gICAgICAgICAgY3h0UHJvcCA9IHtcbiAgICAgICAgICAgIG5hbWU6IGRpZmZQcm9wTmFtZSxcbiAgICAgICAgICAgIGRlbGV0ZUJ5cGFzc2VkOiB0cnVlXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjeHRQcm9wID0ge1xuICAgICAgICAgICAgbmFtZTogZGlmZlByb3BOYW1lLFxuICAgICAgICAgICAgXCJkZWxldGVcIjogdHJ1ZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0gLy8gc2F2ZSBjeWNsZXMgd2hlbiB0aGUgY29udGV4dCBwcm9wIGRvZXNuJ3QgbmVlZCB0byBiZSBhcHBsaWVkXG5cblxuICAgICAgaWYgKGVsZVByb3AgPT09IGN4dFByb3ApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIHNhdmUgY3ljbGVzIHdoZW4gYSBtYXBwZWQgY29udGV4dCBwcm9wIGRvZXNuJ3QgbmVlZCB0byBiZSBhcHBsaWVkXG5cblxuICAgICAgaWYgKGN4dFByb3AubWFwcGVkID09PSB0eXBlcy5mbiAvLyBjb250ZXh0IHByb3AgaXMgZnVuY3Rpb24gbWFwcGVyXG4gICAgICAmJiBlbGVQcm9wICE9IG51bGwgLy8gc29tZSBwcm9wcyBjYW4gYmUgbnVsbCBldmVuIGJ5IGRlZmF1bHQgKGUuZy4gYSBwcm9wIHRoYXQgb3ZlcnJpZGVzIGFub3RoZXIgb25lKVxuICAgICAgJiYgZWxlUHJvcC5tYXBwaW5nICE9IG51bGwgLy8gZWxlIHByb3AgaXMgYSBjb25jcmV0ZSB2YWx1ZSBmcm9tIGZyb20gYSBtYXBwZXJcbiAgICAgICYmIGVsZVByb3AubWFwcGluZy52YWx1ZSA9PT0gY3h0UHJvcC52YWx1ZSAvLyB0aGUgY3VycmVudCBwcm9wIG9uIHRoZSBlbGUgaXMgYSBmbGF0IHByb3AgdmFsdWUgZm9yIHRoZSBmdW5jdGlvbiBtYXBwZXJcbiAgICAgICkge1xuICAgICAgICAvLyBOQiBkb24ndCB3cml0ZSB0byBjeHRQcm9wLCBhcyBpdCdzIHNoYXJlZCBhbW9uZyBlbGVzIChzdG9yZWQgaW4gc3R5bGVzaGVldClcbiAgICAgICAgdmFyIG1hcHBpbmcgPSBlbGVQcm9wLm1hcHBpbmc7IC8vIGNhbiB3cml0ZSB0byBtYXBwaW5nLCBhcyBpdCdzIGEgcGVyLWVsZSBjb3B5XG5cbiAgICAgICAgdmFyIGZuVmFsdWUgPSBtYXBwaW5nLmZuVmFsdWUgPSBjeHRQcm9wLnZhbHVlKGVsZSk7IC8vIHRlbXBvcmFyaWx5IGNhY2hlIHRoZSB2YWx1ZSBpbiBjYXNlIG9mIGEgbWlzc1xuXG4gICAgICAgIGlmIChmblZhbHVlID09PSBtYXBwaW5nLnByZXZGblZhbHVlKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHJldERpZmZQcm9wID0gcmV0RGlmZlByb3BzW2RpZmZQcm9wTmFtZV0gPSB7XG4gICAgICAgIHByZXY6IGVsZVByb3BcbiAgICAgIH07XG4gICAgICBzZWxmLmFwcGx5UGFyc2VkUHJvcGVydHkoZWxlLCBjeHRQcm9wKTtcbiAgICAgIHJldERpZmZQcm9wLm5leHQgPSBlbGUucHN0eWxlKGRpZmZQcm9wTmFtZSk7XG5cbiAgICAgIGlmIChyZXREaWZmUHJvcC5uZXh0ICYmIHJldERpZmZQcm9wLm5leHQuYnlwYXNzKSB7XG4gICAgICAgIHJldERpZmZQcm9wLm5leHQgPSByZXREaWZmUHJvcC5uZXh0LmJ5cGFzc2VkO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBkaWZmUHJvcHM6IHJldERpZmZQcm9wc1xuICAgIH07XG4gIH07XG5cbiAgc3R5Zm4kOC51cGRhdGVTdHlsZUhpbnRzID0gZnVuY3Rpb24gKGVsZSkge1xuICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHByb3BOYW1lcyA9IHNlbGYucHJvcGVydHlHcm91cE5hbWVzO1xuICAgIHZhciBwcm9wR3JLZXlzID0gc2VsZi5wcm9wZXJ0eUdyb3VwS2V5cztcblxuICAgIHZhciBwcm9wSGFzaCA9IGZ1bmN0aW9uIHByb3BIYXNoKGVsZSwgcHJvcE5hbWVzLCBzZWVkS2V5KSB7XG4gICAgICByZXR1cm4gc2VsZi5nZXRQcm9wZXJ0aWVzSGFzaChlbGUsIHByb3BOYW1lcywgc2VlZEtleSk7XG4gICAgfTtcblxuICAgIHZhciBvbGRTdHlsZUtleSA9IF9wLnN0eWxlS2V5O1xuXG4gICAgaWYgKGVsZS5yZW1vdmVkKCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgaXNOb2RlID0gX3AuZ3JvdXAgPT09ICdub2Rlcyc7IC8vIGdldCB0aGUgc3R5bGUga2V5IGhhc2hlcyBwZXIgcHJvcCBncm91cFxuICAgIC8vIGJ1dCBsYXppbHkgLS0gb25seSB1c2Ugbm9uLWRlZmF1bHQgcHJvcCB2YWx1ZXMgdG8gcmVkdWNlIHRoZSBudW1iZXIgb2YgaGFzaGVzXG4gICAgLy9cblxuICAgIHZhciBvdmVycmlkZGVuU3R5bGVzID0gZWxlLl9wcml2YXRlLnN0eWxlO1xuICAgIHByb3BOYW1lcyA9IE9iamVjdC5rZXlzKG92ZXJyaWRkZW5TdHlsZXMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wR3JLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZ3JLZXkgPSBwcm9wR3JLZXlzW2ldO1xuICAgICAgX3Auc3R5bGVLZXlzW2dyS2V5XSA9IFtERUZBVUxUX0hBU0hfU0VFRCwgREVGQVVMVF9IQVNIX1NFRURfQUxUXTtcbiAgICB9XG5cbiAgICB2YXIgdXBkYXRlR3JLZXkxID0gZnVuY3Rpb24gdXBkYXRlR3JLZXkxKHZhbCwgZ3JLZXkpIHtcbiAgICAgIHJldHVybiBfcC5zdHlsZUtleXNbZ3JLZXldWzBdID0gaGFzaEludCh2YWwsIF9wLnN0eWxlS2V5c1tncktleV1bMF0pO1xuICAgIH07XG5cbiAgICB2YXIgdXBkYXRlR3JLZXkyID0gZnVuY3Rpb24gdXBkYXRlR3JLZXkyKHZhbCwgZ3JLZXkpIHtcbiAgICAgIHJldHVybiBfcC5zdHlsZUtleXNbZ3JLZXldWzFdID0gaGFzaEludEFsdCh2YWwsIF9wLnN0eWxlS2V5c1tncktleV1bMV0pO1xuICAgIH07XG5cbiAgICB2YXIgdXBkYXRlR3JLZXkgPSBmdW5jdGlvbiB1cGRhdGVHcktleSh2YWwsIGdyS2V5KSB7XG4gICAgICB1cGRhdGVHcktleTEodmFsLCBncktleSk7XG4gICAgICB1cGRhdGVHcktleTIodmFsLCBncktleSk7XG4gICAgfTtcblxuICAgIHZhciB1cGRhdGVHcktleVdTdHIgPSBmdW5jdGlvbiB1cGRhdGVHcktleVdTdHIoc3RyVmFsLCBncktleSkge1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzdHJWYWwubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIGNoID0gc3RyVmFsLmNoYXJDb2RlQXQoaik7XG4gICAgICAgIHVwZGF0ZUdyS2V5MShjaCwgZ3JLZXkpO1xuICAgICAgICB1cGRhdGVHcktleTIoY2gsIGdyS2V5KTtcbiAgICAgIH1cbiAgICB9OyAvLyAtIGhhc2hpbmcgd29ya3Mgb24gMzIgYml0IGludHMgYi9jIHdlIHVzZSBiaXR3aXNlIG9wc1xuICAgIC8vIC0gc21hbGwgbnVtYmVycyBnZXQgY3V0IG9mZiAoZS5nLiAwLjEyMyBpcyBzZWVuIGFzIDAgYnkgdGhlIGhhc2hpbmcgZnVuY3Rpb24pXG4gICAgLy8gLSByYWlzZSB1cCBzbWFsbCBudW1iZXJzIHNvIG1vcmUgc2lnbmlmaWNhbnQgZGlnaXRzIGFyZSBzZWVuIGJ5IGhhc2hpbmdcbiAgICAvLyAtIG1ha2Ugc21hbGwgbnVtYmVycyBsYXJnZXIgdGhhbiBhIG5vcm1hbCB2YWx1ZSB0byBhdm9pZCBjb2xsaXNpb25zXG4gICAgLy8gLSB3b3JrcyBpbiBwcmFjdGljZSBhbmQgaXQncyByZWxhdGl2ZWx5IGNoZWFwXG5cblxuICAgIHZhciBOID0gMjAwMDAwMDAwMDtcblxuICAgIHZhciBjbGVhbk51bSA9IGZ1bmN0aW9uIGNsZWFuTnVtKHZhbCkge1xuICAgICAgcmV0dXJuIC0xMjggPCB2YWwgJiYgdmFsIDwgMTI4ICYmIE1hdGguZmxvb3IodmFsKSAhPT0gdmFsID8gTiAtICh2YWwgKiAxMDI0IHwgMCkgOiB2YWw7XG4gICAgfTtcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBwcm9wTmFtZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgbmFtZSA9IHByb3BOYW1lc1tfaV07XG4gICAgICB2YXIgcGFyc2VkUHJvcCA9IG92ZXJyaWRkZW5TdHlsZXNbbmFtZV07XG5cbiAgICAgIGlmIChwYXJzZWRQcm9wID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9wSW5mbyA9IHRoaXMucHJvcGVydGllc1tuYW1lXTtcbiAgICAgIHZhciB0eXBlID0gcHJvcEluZm8udHlwZTtcbiAgICAgIHZhciBfZ3JLZXkgPSBwcm9wSW5mby5ncm91cEtleTtcbiAgICAgIHZhciBub3JtYWxpemVkTnVtYmVyVmFsID0gdm9pZCAwO1xuXG4gICAgICBpZiAocHJvcEluZm8uaGFzaE92ZXJyaWRlICE9IG51bGwpIHtcbiAgICAgICAgbm9ybWFsaXplZE51bWJlclZhbCA9IHByb3BJbmZvLmhhc2hPdmVycmlkZShlbGUsIHBhcnNlZFByb3ApO1xuICAgICAgfSBlbHNlIGlmIChwYXJzZWRQcm9wLnBmVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBub3JtYWxpemVkTnVtYmVyVmFsID0gcGFyc2VkUHJvcC5wZlZhbHVlO1xuICAgICAgfSAvLyBtaWdodCBub3QgYmUgYSBudW1iZXIgaWYgaXQgYWxsb3dzIGVudW1zXG5cblxuICAgICAgdmFyIG51bWJlclZhbCA9IHByb3BJbmZvLmVudW1zID09IG51bGwgPyBwYXJzZWRQcm9wLnZhbHVlIDogbnVsbDtcbiAgICAgIHZhciBoYXZlTm9ybU51bSA9IG5vcm1hbGl6ZWROdW1iZXJWYWwgIT0gbnVsbDtcbiAgICAgIHZhciBoYXZlVW5pdGVkTnVtID0gbnVtYmVyVmFsICE9IG51bGw7XG4gICAgICB2YXIgaGF2ZU51bSA9IGhhdmVOb3JtTnVtIHx8IGhhdmVVbml0ZWROdW07XG4gICAgICB2YXIgdW5pdHMgPSBwYXJzZWRQcm9wLnVuaXRzOyAvLyBudW1iZXJzIGFyZSBjaGVhcGVyIHRvIGhhc2ggdGhhbiBzdHJpbmdzXG4gICAgICAvLyAxIGhhc2ggb3AgdnMgbiBoYXNoIG9wcyAoZm9yIGxlbmd0aCBuIHN0cmluZylcblxuICAgICAgaWYgKHR5cGUubnVtYmVyICYmIGhhdmVOdW0gJiYgIXR5cGUubXVsdGlwbGUpIHtcbiAgICAgICAgdmFyIHYgPSBoYXZlTm9ybU51bSA/IG5vcm1hbGl6ZWROdW1iZXJWYWwgOiBudW1iZXJWYWw7XG4gICAgICAgIHVwZGF0ZUdyS2V5KGNsZWFuTnVtKHYpLCBfZ3JLZXkpO1xuXG4gICAgICAgIGlmICghaGF2ZU5vcm1OdW0gJiYgdW5pdHMgIT0gbnVsbCkge1xuICAgICAgICAgIHVwZGF0ZUdyS2V5V1N0cih1bml0cywgX2dyS2V5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXBkYXRlR3JLZXlXU3RyKHBhcnNlZFByb3Auc3RyVmFsdWUsIF9ncktleSk7XG4gICAgICB9XG4gICAgfSAvLyBvdmVyYWxsIHN0eWxlIGtleVxuICAgIC8vXG5cblxuICAgIHZhciBoYXNoID0gW0RFRkFVTFRfSEFTSF9TRUVELCBERUZBVUxUX0hBU0hfU0VFRF9BTFRdO1xuXG4gICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgcHJvcEdyS2V5cy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICB2YXIgX2dyS2V5MiA9IHByb3BHcktleXNbX2kyXTtcbiAgICAgIHZhciBnckhhc2ggPSBfcC5zdHlsZUtleXNbX2dyS2V5Ml07XG4gICAgICBoYXNoWzBdID0gaGFzaEludChnckhhc2hbMF0sIGhhc2hbMF0pO1xuICAgICAgaGFzaFsxXSA9IGhhc2hJbnRBbHQoZ3JIYXNoWzFdLCBoYXNoWzFdKTtcbiAgICB9XG5cbiAgICBfcC5zdHlsZUtleSA9IGNvbWJpbmVIYXNoZXMoaGFzaFswXSwgaGFzaFsxXSk7IC8vIGxhYmVsIGRpbXNcbiAgICAvL1xuXG4gICAgdmFyIHNrID0gX3Auc3R5bGVLZXlzO1xuICAgIF9wLmxhYmVsRGltc0tleSA9IGNvbWJpbmVIYXNoZXNBcnJheShzay5sYWJlbERpbWVuc2lvbnMpO1xuICAgIHZhciBsYWJlbEtleXMgPSBwcm9wSGFzaChlbGUsIFsnbGFiZWwnXSwgc2subGFiZWxEaW1lbnNpb25zKTtcbiAgICBfcC5sYWJlbEtleSA9IGNvbWJpbmVIYXNoZXNBcnJheShsYWJlbEtleXMpO1xuICAgIF9wLmxhYmVsU3R5bGVLZXkgPSBjb21iaW5lSGFzaGVzQXJyYXkoaGFzaEFycmF5cyhzay5jb21tb25MYWJlbCwgbGFiZWxLZXlzKSk7XG5cbiAgICBpZiAoIWlzTm9kZSkge1xuICAgICAgdmFyIHNvdXJjZUxhYmVsS2V5cyA9IHByb3BIYXNoKGVsZSwgWydzb3VyY2UtbGFiZWwnXSwgc2subGFiZWxEaW1lbnNpb25zKTtcbiAgICAgIF9wLnNvdXJjZUxhYmVsS2V5ID0gY29tYmluZUhhc2hlc0FycmF5KHNvdXJjZUxhYmVsS2V5cyk7XG4gICAgICBfcC5zb3VyY2VMYWJlbFN0eWxlS2V5ID0gY29tYmluZUhhc2hlc0FycmF5KGhhc2hBcnJheXMoc2suY29tbW9uTGFiZWwsIHNvdXJjZUxhYmVsS2V5cykpO1xuICAgICAgdmFyIHRhcmdldExhYmVsS2V5cyA9IHByb3BIYXNoKGVsZSwgWyd0YXJnZXQtbGFiZWwnXSwgc2subGFiZWxEaW1lbnNpb25zKTtcbiAgICAgIF9wLnRhcmdldExhYmVsS2V5ID0gY29tYmluZUhhc2hlc0FycmF5KHRhcmdldExhYmVsS2V5cyk7XG4gICAgICBfcC50YXJnZXRMYWJlbFN0eWxlS2V5ID0gY29tYmluZUhhc2hlc0FycmF5KGhhc2hBcnJheXMoc2suY29tbW9uTGFiZWwsIHRhcmdldExhYmVsS2V5cykpO1xuICAgIH0gLy8gbm9kZVxuICAgIC8vXG5cblxuICAgIGlmIChpc05vZGUpIHtcbiAgICAgIHZhciBfcCRzdHlsZUtleXMgPSBfcC5zdHlsZUtleXMsXG4gICAgICAgICAgbm9kZUJvZHkgPSBfcCRzdHlsZUtleXMubm9kZUJvZHksXG4gICAgICAgICAgbm9kZUJvcmRlciA9IF9wJHN0eWxlS2V5cy5ub2RlQm9yZGVyLFxuICAgICAgICAgIGJhY2tncm91bmRJbWFnZSA9IF9wJHN0eWxlS2V5cy5iYWNrZ3JvdW5kSW1hZ2UsXG4gICAgICAgICAgY29tcG91bmQgPSBfcCRzdHlsZUtleXMuY29tcG91bmQsXG4gICAgICAgICAgcGllID0gX3Akc3R5bGVLZXlzLnBpZTtcbiAgICAgIHZhciBub2RlS2V5cyA9IFtub2RlQm9keSwgbm9kZUJvcmRlciwgYmFja2dyb3VuZEltYWdlLCBjb21wb3VuZCwgcGllXS5maWx0ZXIoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgcmV0dXJuIGsgIT0gbnVsbDtcbiAgICAgIH0pLnJlZHVjZShoYXNoQXJyYXlzLCBbREVGQVVMVF9IQVNIX1NFRUQsIERFRkFVTFRfSEFTSF9TRUVEX0FMVF0pO1xuICAgICAgX3Aubm9kZUtleSA9IGNvbWJpbmVIYXNoZXNBcnJheShub2RlS2V5cyk7XG4gICAgICBfcC5oYXNQaWUgPSBwaWUgIT0gbnVsbCAmJiBwaWVbMF0gIT09IERFRkFVTFRfSEFTSF9TRUVEICYmIHBpZVsxXSAhPT0gREVGQVVMVF9IQVNIX1NFRURfQUxUO1xuICAgIH1cblxuICAgIHJldHVybiBvbGRTdHlsZUtleSAhPT0gX3Auc3R5bGVLZXk7XG4gIH07XG5cbiAgc3R5Zm4kOC5jbGVhclN0eWxlSGludHMgPSBmdW5jdGlvbiAoZWxlKSB7XG4gICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgIF9wLnN0eWxlQ3h0S2V5ID0gJyc7XG4gICAgX3Auc3R5bGVLZXlzID0ge307XG4gICAgX3Auc3R5bGVLZXkgPSBudWxsO1xuICAgIF9wLmxhYmVsS2V5ID0gbnVsbDtcbiAgICBfcC5sYWJlbFN0eWxlS2V5ID0gbnVsbDtcbiAgICBfcC5zb3VyY2VMYWJlbEtleSA9IG51bGw7XG4gICAgX3Auc291cmNlTGFiZWxTdHlsZUtleSA9IG51bGw7XG4gICAgX3AudGFyZ2V0TGFiZWxLZXkgPSBudWxsO1xuICAgIF9wLnRhcmdldExhYmVsU3R5bGVLZXkgPSBudWxsO1xuICAgIF9wLm5vZGVLZXkgPSBudWxsO1xuICAgIF9wLmhhc1BpZSA9IG51bGw7XG4gIH07IC8vIGFwcGx5IGEgcHJvcGVydHkgdG8gdGhlIHN0eWxlIChmb3IgaW50ZXJuYWwgdXNlKVxuICAvLyByZXR1cm5zIHdoZXRoZXIgYXBwbGljYXRpb24gd2FzIHN1Y2Nlc3NmdWxcbiAgLy9cbiAgLy8gbm93LCB0aGlzIGZ1bmN0aW9uIGZsYXR0ZW5zIHRoZSBwcm9wZXJ0eSwgYW5kIGhlcmUncyBob3c6XG4gIC8vXG4gIC8vIGZvciBwYXJzZWRQcm9wOnsgYnlwYXNzOiB0cnVlLCBkZWxldGVCeXBhc3M6IHRydWUgfVxuICAvLyBubyBwcm9wZXJ0eSBpcyBnZW5lcmF0ZWQsIGluc3RlYWQgdGhlIGJ5cGFzcyBwcm9wZXJ0eSBpbiB0aGVcbiAgLy8gZWxlbWVudCdzIHN0eWxlIGlzIHJlcGxhY2VkIGJ5IHdoYXQncyBwb2ludGVkIHRvIGJ5IHRoZSBgYnlwYXNzZWRgXG4gIC8vIGZpZWxkIGluIHRoZSBieXBhc3MgcHJvcGVydHkgKGkuZS4gcmVzdG9yaW5nIHRoZSBwcm9wZXJ0eSB0aGVcbiAgLy8gYnlwYXNzIHdhcyBvdmVycmlkaW5nKVxuICAvL1xuICAvLyBmb3IgcGFyc2VkUHJvcDp7IG1hcHBlZDogdHJ1dGh5IH1cbiAgLy8gdGhlIGdlbmVyYXRlZCBmbGF0dGVuZWRQcm9wOnsgbWFwcGluZzogcHJvcCB9XG4gIC8vXG4gIC8vIGZvciBwYXJzZWRQcm9wOnsgYnlwYXNzOiB0cnVlIH1cbiAgLy8gdGhlIGdlbmVyYXRlZCBmbGF0dGVuZWRQcm9wOnsgYnlwYXNzZWQ6IHBhcnNlZFByb3AgfVxuXG5cbiAgc3R5Zm4kOC5hcHBseVBhcnNlZFByb3BlcnR5ID0gZnVuY3Rpb24gKGVsZSwgcGFyc2VkUHJvcCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgcHJvcCA9IHBhcnNlZFByb3A7XG4gICAgdmFyIHN0eWxlID0gZWxlLl9wcml2YXRlLnN0eWxlO1xuICAgIHZhciBmbGF0UHJvcDtcbiAgICB2YXIgdHlwZXMgPSBzZWxmLnR5cGVzO1xuICAgIHZhciB0eXBlID0gc2VsZi5wcm9wZXJ0aWVzW3Byb3AubmFtZV0udHlwZTtcbiAgICB2YXIgcHJvcElzQnlwYXNzID0gcHJvcC5ieXBhc3M7XG4gICAgdmFyIG9yaWdQcm9wID0gc3R5bGVbcHJvcC5uYW1lXTtcbiAgICB2YXIgb3JpZ1Byb3BJc0J5cGFzcyA9IG9yaWdQcm9wICYmIG9yaWdQcm9wLmJ5cGFzcztcbiAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgdmFyIGZsYXRQcm9wTWFwcGluZyA9ICdtYXBwaW5nJztcblxuICAgIHZhciBnZXRWYWwgPSBmdW5jdGlvbiBnZXRWYWwocCkge1xuICAgICAgaWYgKHAgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAocC5wZlZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHAucGZWYWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwLnZhbHVlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgY2hlY2tUcmlnZ2VycyA9IGZ1bmN0aW9uIGNoZWNrVHJpZ2dlcnMoKSB7XG4gICAgICB2YXIgZnJvbVZhbCA9IGdldFZhbChvcmlnUHJvcCk7XG4gICAgICB2YXIgdG9WYWwgPSBnZXRWYWwocHJvcCk7XG4gICAgICBzZWxmLmNoZWNrVHJpZ2dlcnMoZWxlLCBwcm9wLm5hbWUsIGZyb21WYWwsIHRvVmFsKTtcbiAgICB9O1xuXG4gICAgaWYgKHByb3AgJiYgcHJvcC5uYW1lLnN1YnN0cigwLCAzKSA9PT0gJ3BpZScpIHtcbiAgICAgIHdhcm4oJ1RoZSBwaWUgc3R5bGUgcHJvcGVydGllcyBhcmUgZGVwcmVjYXRlZC4gIENyZWF0ZSBjaGFydHMgdXNpbmcgYmFja2dyb3VuZCBpbWFnZXMgaW5zdGVhZC4nKTtcbiAgICB9IC8vIGVkZ2Ugc2FuaXR5IGNoZWNrcyB0byBwcmV2ZW50IHRoZSBjbGllbnQgZnJvbSBtYWtpbmcgc2VyaW91cyBtaXN0YWtlc1xuXG5cbiAgICBpZiAocGFyc2VkUHJvcC5uYW1lID09PSAnY3VydmUtc3R5bGUnICYmIGVsZS5pc0VkZ2UoKSAmJiAoIC8vIGxvb3BzIG11c3QgYmUgYnVuZGxlZCBiZXppZXJzXG4gICAgcGFyc2VkUHJvcC52YWx1ZSAhPT0gJ2JlemllcicgJiYgZWxlLmlzTG9vcCgpIHx8IC8vIGVkZ2VzIGNvbm5lY3RlZCB0byBjb21wb3VuZCBub2RlcyBjYW4gbm90IGJlIGhheXN0YWNrc1xuICAgIHBhcnNlZFByb3AudmFsdWUgPT09ICdoYXlzdGFjaycgJiYgKGVsZS5zb3VyY2UoKS5pc1BhcmVudCgpIHx8IGVsZS50YXJnZXQoKS5pc1BhcmVudCgpKSkpIHtcbiAgICAgIHByb3AgPSBwYXJzZWRQcm9wID0gdGhpcy5wYXJzZShwYXJzZWRQcm9wLm5hbWUsICdiZXppZXInLCBwcm9wSXNCeXBhc3MpO1xuICAgIH1cblxuICAgIGlmIChwcm9wW1wiZGVsZXRlXCJdKSB7XG4gICAgICAvLyBkZWxldGUgdGhlIHByb3BlcnR5IGFuZCB1c2UgdGhlIGRlZmF1bHQgdmFsdWUgb24gZmFsc2V5IHZhbHVlXG4gICAgICBzdHlsZVtwcm9wLm5hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgY2hlY2tUcmlnZ2VycygpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHByb3AuZGVsZXRlQnlwYXNzZWQpIHtcbiAgICAgIC8vIGRlbGV0ZSB0aGUgcHJvcGVydHkgdGhhdCB0aGVcbiAgICAgIGlmICghb3JpZ1Byb3ApIHtcbiAgICAgICAgY2hlY2tUcmlnZ2VycygpO1xuICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gY2FuJ3QgZGVsZXRlIGlmIG5vIHByb3BcbiAgICAgIH0gZWxzZSBpZiAob3JpZ1Byb3AuYnlwYXNzKSB7XG4gICAgICAgIC8vIGRlbGV0ZSBieXBhc3NlZFxuICAgICAgICBvcmlnUHJvcC5ieXBhc3NlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgY2hlY2tUcmlnZ2VycygpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gd2UncmUgdW5zdWNjZXNzZnVsIGRlbGV0aW5nIHRoZSBieXBhc3NlZFxuICAgICAgfVxuICAgIH0gLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBkZWxldGUgdGhlIGN1cnJlbnQgYnlwYXNzXG5cblxuICAgIGlmIChwcm9wLmRlbGV0ZUJ5cGFzcykge1xuICAgICAgLy8gdGhlbiB0aGlzIHByb3BlcnR5IGlzIGp1c3QgaGVyZSB0byBpbmRpY2F0ZSB3ZSBuZWVkIHRvIGRlbGV0ZVxuICAgICAgaWYgKCFvcmlnUHJvcCkge1xuICAgICAgICBjaGVja1RyaWdnZXJzKCk7XG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBwcm9wZXJ0eSBpcyBhbHJlYWR5IG5vdCBkZWZpbmVkXG4gICAgICB9IGVsc2UgaWYgKG9yaWdQcm9wLmJ5cGFzcykge1xuICAgICAgICAvLyB0aGVuIHJlcGxhY2UgdGhlIGJ5cGFzcyBwcm9wZXJ0eSB3aXRoIHRoZSBvcmlnaW5hbFxuICAgICAgICAvLyBiZWNhdXNlIHRoZSBieXBhc3NlZCBwcm9wZXJ0eSB3YXMgYWxyZWFkeSBhcHBsaWVkIChhbmQgdGhlcmVmb3JlIHBhcnNlZCksIHdlIGNhbiBqdXN0IHJlcGxhY2UgaXQgKG5vIHJlYXBwbHlpbmcgbmVjZXNzYXJ5KVxuICAgICAgICBzdHlsZVtwcm9wLm5hbWVdID0gb3JpZ1Byb3AuYnlwYXNzZWQ7XG4gICAgICAgIGNoZWNrVHJpZ2dlcnMoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIHdlJ3JlIHVuc3VjY2Vzc2Z1bCBkZWxldGluZyB0aGUgYnlwYXNzXG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHByaW50TWFwcGluZ0VyciA9IGZ1bmN0aW9uIHByaW50TWFwcGluZ0VycigpIHtcbiAgICAgIHdhcm4oJ0RvIG5vdCBhc3NpZ24gbWFwcGluZ3MgdG8gZWxlbWVudHMgd2l0aG91dCBjb3JyZXNwb25kaW5nIGRhdGEgKGkuZS4gZWxlIGAnICsgZWxlLmlkKCkgKyAnYCBoYXMgbm8gbWFwcGluZyBmb3IgcHJvcGVydHkgYCcgKyBwcm9wLm5hbWUgKyAnYCB3aXRoIGRhdGEgZmllbGQgYCcgKyBwcm9wLmZpZWxkICsgJ2ApOyB0cnkgYSBgWycgKyBwcm9wLmZpZWxkICsgJ11gIHNlbGVjdG9yIHRvIGxpbWl0IHNjb3BlIHRvIGVsZW1lbnRzIHdpdGggYCcgKyBwcm9wLmZpZWxkICsgJ2AgZGVmaW5lZCcpO1xuICAgIH07IC8vIHB1dCB0aGUgcHJvcGVydHkgaW4gdGhlIHN0eWxlIG9iamVjdHNcblxuXG4gICAgc3dpdGNoIChwcm9wLm1hcHBlZCkge1xuICAgICAgLy8gZmxhdHRlbiB0aGUgcHJvcGVydHkgaWYgbWFwcGVkXG4gICAgICBjYXNlIHR5cGVzLm1hcERhdGE6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBmbGF0dGVuIHRoZSBmaWVsZCAoZS5nLiBkYXRhLmZvby5iYXIpXG4gICAgICAgICAgdmFyIGZpZWxkcyA9IHByb3AuZmllbGQuc3BsaXQoJy4nKTtcbiAgICAgICAgICB2YXIgZmllbGRWYWwgPSBfcC5kYXRhO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoICYmIGZpZWxkVmFsOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBmaWVsZCA9IGZpZWxkc1tpXTtcbiAgICAgICAgICAgIGZpZWxkVmFsID0gZmllbGRWYWxbZmllbGRdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChmaWVsZFZhbCA9PSBudWxsKSB7XG4gICAgICAgICAgICBwcmludE1hcHBpbmdFcnIoKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcGVyY2VudDtcblxuICAgICAgICAgIGlmICghbnVtYmVyJDEoZmllbGRWYWwpKSB7XG4gICAgICAgICAgICAvLyB0aGVuIGRvbid0IGFwcGx5IGFuZCBmYWxsIGJhY2sgb24gdGhlIGV4aXN0aW5nIHN0eWxlXG4gICAgICAgICAgICB3YXJuKCdEbyBub3QgdXNlIGNvbnRpbnVvdXMgbWFwcGVycyB3aXRob3V0IHNwZWNpZnlpbmcgbnVtZXJpYyBkYXRhIChpLmUuIGAnICsgcHJvcC5maWVsZCArICc6ICcgKyBmaWVsZFZhbCArICdgIGZvciBgJyArIGVsZS5pZCgpICsgJ2AgaXMgbm9uLW51bWVyaWMpJyk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBmaWVsZFdpZHRoID0gcHJvcC5maWVsZE1heCAtIHByb3AuZmllbGRNaW47XG5cbiAgICAgICAgICAgIGlmIChmaWVsZFdpZHRoID09PSAwKSB7XG4gICAgICAgICAgICAgIC8vIHNhZmV0eSBjaGVjayAtLSBub3Qgc3RyaWN0bHkgbmVjZXNzYXJ5IGFzIG5vIHByb3BzIG9mIHplcm8gcmFuZ2Ugc2hvdWxkIGJlIHBhc3NlZCBoZXJlXG4gICAgICAgICAgICAgIHBlcmNlbnQgPSAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGVyY2VudCA9IChmaWVsZFZhbCAtIHByb3AuZmllbGRNaW4pIC8gZmllbGRXaWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIG1ha2Ugc3VyZSB0byBib3VuZCBwZXJjZW50IHZhbHVlXG5cblxuICAgICAgICAgIGlmIChwZXJjZW50IDwgMCkge1xuICAgICAgICAgICAgcGVyY2VudCA9IDA7XG4gICAgICAgICAgfSBlbHNlIGlmIChwZXJjZW50ID4gMSkge1xuICAgICAgICAgICAgcGVyY2VudCA9IDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHR5cGUuY29sb3IpIHtcbiAgICAgICAgICAgIHZhciByMSA9IHByb3AudmFsdWVNaW5bMF07XG4gICAgICAgICAgICB2YXIgcjIgPSBwcm9wLnZhbHVlTWF4WzBdO1xuICAgICAgICAgICAgdmFyIGcxID0gcHJvcC52YWx1ZU1pblsxXTtcbiAgICAgICAgICAgIHZhciBnMiA9IHByb3AudmFsdWVNYXhbMV07XG4gICAgICAgICAgICB2YXIgYjEgPSBwcm9wLnZhbHVlTWluWzJdO1xuICAgICAgICAgICAgdmFyIGIyID0gcHJvcC52YWx1ZU1heFsyXTtcbiAgICAgICAgICAgIHZhciBhMSA9IHByb3AudmFsdWVNaW5bM10gPT0gbnVsbCA/IDEgOiBwcm9wLnZhbHVlTWluWzNdO1xuICAgICAgICAgICAgdmFyIGEyID0gcHJvcC52YWx1ZU1heFszXSA9PSBudWxsID8gMSA6IHByb3AudmFsdWVNYXhbM107XG4gICAgICAgICAgICB2YXIgY2xyID0gW01hdGgucm91bmQocjEgKyAocjIgLSByMSkgKiBwZXJjZW50KSwgTWF0aC5yb3VuZChnMSArIChnMiAtIGcxKSAqIHBlcmNlbnQpLCBNYXRoLnJvdW5kKGIxICsgKGIyIC0gYjEpICogcGVyY2VudCksIE1hdGgucm91bmQoYTEgKyAoYTIgLSBhMSkgKiBwZXJjZW50KV07XG4gICAgICAgICAgICBmbGF0UHJvcCA9IHtcbiAgICAgICAgICAgICAgLy8gY29sb3VycyBhcmUgc2ltcGxlLCBzbyBqdXN0IGNyZWF0ZSB0aGUgZmxhdCBwcm9wZXJ0eSBpbnN0ZWFkIG9mIGV4cGVuc2l2ZSBzdHJpbmcgcGFyc2luZ1xuICAgICAgICAgICAgICBieXBhc3M6IHByb3AuYnlwYXNzLFxuICAgICAgICAgICAgICAvLyB3ZSdyZSBhIGJ5cGFzcyBpZiB0aGUgbWFwcGluZyBwcm9wZXJ0eSBpcyBhIGJ5cGFzc1xuICAgICAgICAgICAgICBuYW1lOiBwcm9wLm5hbWUsXG4gICAgICAgICAgICAgIHZhbHVlOiBjbHIsXG4gICAgICAgICAgICAgIHN0clZhbHVlOiAncmdiKCcgKyBjbHJbMF0gKyAnLCAnICsgY2xyWzFdICsgJywgJyArIGNsclsyXSArICcpJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUubnVtYmVyKSB7XG4gICAgICAgICAgICB2YXIgY2FsY1ZhbHVlID0gcHJvcC52YWx1ZU1pbiArIChwcm9wLnZhbHVlTWF4IC0gcHJvcC52YWx1ZU1pbikgKiBwZXJjZW50O1xuICAgICAgICAgICAgZmxhdFByb3AgPSB0aGlzLnBhcnNlKHByb3AubmFtZSwgY2FsY1ZhbHVlLCBwcm9wLmJ5cGFzcywgZmxhdFByb3BNYXBwaW5nKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBjYW4gb25seSBtYXAgdG8gY29sb3VycyBhbmQgbnVtYmVyc1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghZmxhdFByb3ApIHtcbiAgICAgICAgICAgIC8vIGlmIHdlIGNhbid0IGZsYXR0ZW4gdGhlIHByb3BlcnR5LCB0aGVuIGRvbid0IGFwcGx5IHRoZSBwcm9wZXJ0eSBhbmQgZmFsbCBiYWNrIG9uIHRoZSBleGlzdGluZyBzdHlsZVxuICAgICAgICAgICAgcHJpbnRNYXBwaW5nRXJyKCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZmxhdFByb3AubWFwcGluZyA9IHByb3A7IC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIG1hcHBpbmdcblxuICAgICAgICAgIHByb3AgPSBmbGF0UHJvcDsgLy8gdGhlIGZsYXR0ZW5lZCAobWFwcGVkKSBwcm9wZXJ0eSBpcyB0aGUgb25lIHdlIHdhbnRcblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAvLyBkaXJlY3QgbWFwcGluZ1xuXG4gICAgICBjYXNlIHR5cGVzLmRhdGE6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBmbGF0dGVuIHRoZSBmaWVsZCAoZS5nLiBkYXRhLmZvby5iYXIpXG4gICAgICAgICAgdmFyIF9maWVsZHMgPSBwcm9wLmZpZWxkLnNwbGl0KCcuJyk7XG5cbiAgICAgICAgICB2YXIgX2ZpZWxkVmFsID0gX3AuZGF0YTtcblxuICAgICAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IF9maWVsZHMubGVuZ3RoICYmIF9maWVsZFZhbDsgX2kzKyspIHtcbiAgICAgICAgICAgIHZhciBfZmllbGQgPSBfZmllbGRzW19pM107XG4gICAgICAgICAgICBfZmllbGRWYWwgPSBfZmllbGRWYWxbX2ZpZWxkXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoX2ZpZWxkVmFsICE9IG51bGwpIHtcbiAgICAgICAgICAgIGZsYXRQcm9wID0gdGhpcy5wYXJzZShwcm9wLm5hbWUsIF9maWVsZFZhbCwgcHJvcC5ieXBhc3MsIGZsYXRQcm9wTWFwcGluZyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFmbGF0UHJvcCkge1xuICAgICAgICAgICAgLy8gaWYgd2UgY2FuJ3QgZmxhdHRlbiB0aGUgcHJvcGVydHksIHRoZW4gZG9uJ3QgYXBwbHkgYW5kIGZhbGwgYmFjayBvbiB0aGUgZXhpc3Rpbmcgc3R5bGVcbiAgICAgICAgICAgIHByaW50TWFwcGluZ0VycigpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZsYXRQcm9wLm1hcHBpbmcgPSBwcm9wOyAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBtYXBwaW5nXG5cbiAgICAgICAgICBwcm9wID0gZmxhdFByb3A7IC8vIHRoZSBmbGF0dGVuZWQgKG1hcHBlZCkgcHJvcGVydHkgaXMgdGhlIG9uZSB3ZSB3YW50XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIHR5cGVzLmZuOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGZuID0gcHJvcC52YWx1ZTtcbiAgICAgICAgICB2YXIgZm5SZXRWYWwgPSBwcm9wLmZuVmFsdWUgIT0gbnVsbCA/IHByb3AuZm5WYWx1ZSA6IGZuKGVsZSk7IC8vIGNoZWNrIGZvciBjYWNoZWQgdmFsdWUgYmVmb3JlIGNhbGxpbmcgZnVuY3Rpb25cblxuICAgICAgICAgIHByb3AucHJldkZuVmFsdWUgPSBmblJldFZhbDtcblxuICAgICAgICAgIGlmIChmblJldFZhbCA9PSBudWxsKSB7XG4gICAgICAgICAgICB3YXJuKCdDdXN0b20gZnVuY3Rpb24gbWFwcGVycyBtYXkgbm90IHJldHVybiBudWxsIChpLmUuIGAnICsgcHJvcC5uYW1lICsgJ2AgZm9yIGVsZSBgJyArIGVsZS5pZCgpICsgJ2AgaXMgbnVsbCknKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmbGF0UHJvcCA9IHRoaXMucGFyc2UocHJvcC5uYW1lLCBmblJldFZhbCwgcHJvcC5ieXBhc3MsIGZsYXRQcm9wTWFwcGluZyk7XG5cbiAgICAgICAgICBpZiAoIWZsYXRQcm9wKSB7XG4gICAgICAgICAgICB3YXJuKCdDdXN0b20gZnVuY3Rpb24gbWFwcGVycyBtYXkgbm90IHJldHVybiBpbnZhbGlkIHZhbHVlcyBmb3IgdGhlIHByb3BlcnR5IHR5cGUgKGkuZS4gYCcgKyBwcm9wLm5hbWUgKyAnYCBmb3IgZWxlIGAnICsgZWxlLmlkKCkgKyAnYCBpcyBpbnZhbGlkKScpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZsYXRQcm9wLm1hcHBpbmcgPSBjb3B5KHByb3ApOyAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBtYXBwaW5nXG5cbiAgICAgICAgICBwcm9wID0gZmxhdFByb3A7IC8vIHRoZSBmbGF0dGVuZWQgKG1hcHBlZCkgcHJvcGVydHkgaXMgdGhlIG9uZSB3ZSB3YW50XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBqdXN0IHNldCB0aGUgcHJvcGVydHlcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgLy8gbm90IGEgdmFsaWQgbWFwcGluZ1xuICAgIH0gLy8gaWYgdGhlIHByb3BlcnR5IGlzIGEgYnlwYXNzIHByb3BlcnR5LCB0aGVuIGxpbmsgdGhlIHJlc3VsdGFudCBwcm9wZXJ0eSB0byB0aGUgb3JpZ2luYWwgb25lXG5cblxuICAgIGlmIChwcm9wSXNCeXBhc3MpIHtcbiAgICAgIGlmIChvcmlnUHJvcElzQnlwYXNzKSB7XG4gICAgICAgIC8vIHRoZW4gdGhpcyBieXBhc3Mgb3ZlcnJpZGVzIHRoZSBleGlzdGluZyBvbmVcbiAgICAgICAgcHJvcC5ieXBhc3NlZCA9IG9yaWdQcm9wLmJ5cGFzc2VkOyAvLyBzdGVhbCBieXBhc3NlZCBwcm9wIGZyb20gb2xkIGJ5cGFzc1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdGhlbiBsaW5rIHRoZSBvcmlnIHByb3AgdG8gdGhlIG5ldyBieXBhc3NcbiAgICAgICAgcHJvcC5ieXBhc3NlZCA9IG9yaWdQcm9wO1xuICAgICAgfVxuXG4gICAgICBzdHlsZVtwcm9wLm5hbWVdID0gcHJvcDsgLy8gYW5kIHNldFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBwcm9wIGlzIG5vdCBieXBhc3NcbiAgICAgIGlmIChvcmlnUHJvcElzQnlwYXNzKSB7XG4gICAgICAgIC8vIHRoZW4ga2VlcCB0aGUgb3JpZyBwcm9wIChzaW5jZSBpdCdzIGEgYnlwYXNzKSBhbmQgbGluayB0byB0aGUgbmV3IHByb3BcbiAgICAgICAgb3JpZ1Byb3AuYnlwYXNzZWQgPSBwcm9wO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdGhlbiBqdXN0IHJlcGxhY2UgdGhlIG9sZCBwcm9wIHdpdGggdGhlIG5ldyBvbmVcbiAgICAgICAgc3R5bGVbcHJvcC5uYW1lXSA9IHByb3A7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2hlY2tUcmlnZ2VycygpO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIHN0eWZuJDguY2xlYW5FbGVtZW50cyA9IGZ1bmN0aW9uIChlbGVzLCBrZWVwQnlwYXNzZXMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgdGhpcy5jbGVhclN0eWxlSGludHMoZWxlKTtcbiAgICAgIGVsZS5kaXJ0eUNvbXBvdW5kQm91bmRzQ2FjaGUoKTtcbiAgICAgIGVsZS5kaXJ0eUJvdW5kaW5nQm94Q2FjaGUoKTtcblxuICAgICAgaWYgKCFrZWVwQnlwYXNzZXMpIHtcbiAgICAgICAgZWxlLl9wcml2YXRlLnN0eWxlID0ge307XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgc3R5bGUgPSBlbGUuX3ByaXZhdGUuc3R5bGU7XG4gICAgICAgIHZhciBwcm9wTmFtZXMgPSBPYmplY3Qua2V5cyhzdHlsZSk7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwcm9wTmFtZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB2YXIgcHJvcE5hbWUgPSBwcm9wTmFtZXNbal07XG4gICAgICAgICAgdmFyIGVsZVByb3AgPSBzdHlsZVtwcm9wTmFtZV07XG5cbiAgICAgICAgICBpZiAoZWxlUHJvcCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoZWxlUHJvcC5ieXBhc3MpIHtcbiAgICAgICAgICAgICAgZWxlUHJvcC5ieXBhc3NlZCA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdHlsZVtwcm9wTmFtZV0gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTsgLy8gdXBkYXRlcyB0aGUgdmlzdWFsIHN0eWxlIGZvciBhbGwgZWxlbWVudHMgKHVzZWZ1bCBmb3IgbWFudWFsIHN0eWxlIG1vZGlmaWNhdGlvbiBhZnRlciBpbml0KVxuXG5cbiAgc3R5Zm4kOC51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgICB2YXIgZWxlcyA9IGN5Lm11dGFibGVFbGVtZW50cygpO1xuICAgIGVsZXMudXBkYXRlU3R5bGUoKTtcbiAgfTsgLy8gZGlmZlByb3BzIDogeyBuYW1lID0+IHsgcHJldiwgbmV4dCB9IH1cblxuXG4gIHN0eWZuJDgudXBkYXRlVHJhbnNpdGlvbnMgPSBmdW5jdGlvbiAoZWxlLCBkaWZmUHJvcHMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgIHZhciBwcm9wcyA9IGVsZS5wc3R5bGUoJ3RyYW5zaXRpb24tcHJvcGVydHknKS52YWx1ZTtcbiAgICB2YXIgZHVyYXRpb24gPSBlbGUucHN0eWxlKCd0cmFuc2l0aW9uLWR1cmF0aW9uJykucGZWYWx1ZTtcbiAgICB2YXIgZGVsYXkgPSBlbGUucHN0eWxlKCd0cmFuc2l0aW9uLWRlbGF5JykucGZWYWx1ZTtcblxuICAgIGlmIChwcm9wcy5sZW5ndGggPiAwICYmIGR1cmF0aW9uID4gMCkge1xuICAgICAgdmFyIHN0eWxlID0ge307IC8vIGJ1aWxkIHVwIHRoZSBzdHlsZSB0byBhbmltYXRlIHRvd2FyZHNcblxuICAgICAgdmFyIGFueVByZXYgPSBmYWxzZTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuICAgICAgICB2YXIgc3R5UHJvcCA9IGVsZS5wc3R5bGUocHJvcCk7XG4gICAgICAgIHZhciBkaWZmUHJvcCA9IGRpZmZQcm9wc1twcm9wXTtcblxuICAgICAgICBpZiAoIWRpZmZQcm9wKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJldlByb3AgPSBkaWZmUHJvcC5wcmV2O1xuICAgICAgICB2YXIgZnJvbVByb3AgPSBwcmV2UHJvcDtcbiAgICAgICAgdmFyIHRvUHJvcCA9IGRpZmZQcm9wLm5leHQgIT0gbnVsbCA/IGRpZmZQcm9wLm5leHQgOiBzdHlQcm9wO1xuICAgICAgICB2YXIgZGlmZiA9IGZhbHNlO1xuICAgICAgICB2YXIgaW5pdFZhbCA9IHZvaWQgMDtcbiAgICAgICAgdmFyIGluaXREdCA9IDAuMDAwMDAxOyAvLyBkZWx0YSB0aW1lICUgdmFsdWUgZm9yIGluaXRWYWwgKGFsbG93cyBhbmltYXRpbmcgb3V0IG9mIGluaXQgemVybyBvcGFjaXR5KVxuXG4gICAgICAgIGlmICghZnJvbVByb3ApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBjb25zaWRlciBweCB2YWx1ZXNcblxuXG4gICAgICAgIGlmIChudW1iZXIkMShmcm9tUHJvcC5wZlZhbHVlKSAmJiBudW1iZXIkMSh0b1Byb3AucGZWYWx1ZSkpIHtcbiAgICAgICAgICBkaWZmID0gdG9Qcm9wLnBmVmFsdWUgLSBmcm9tUHJvcC5wZlZhbHVlOyAvLyBub256ZXJvIGlzIHRydXRoeVxuXG4gICAgICAgICAgaW5pdFZhbCA9IGZyb21Qcm9wLnBmVmFsdWUgKyBpbml0RHQgKiBkaWZmOyAvLyBjb25zaWRlciBudW1lcmljYWwgdmFsdWVzXG4gICAgICAgIH0gZWxzZSBpZiAobnVtYmVyJDEoZnJvbVByb3AudmFsdWUpICYmIG51bWJlciQxKHRvUHJvcC52YWx1ZSkpIHtcbiAgICAgICAgICBkaWZmID0gdG9Qcm9wLnZhbHVlIC0gZnJvbVByb3AudmFsdWU7IC8vIG5vbnplcm8gaXMgdHJ1dGh5XG5cbiAgICAgICAgICBpbml0VmFsID0gZnJvbVByb3AudmFsdWUgKyBpbml0RHQgKiBkaWZmOyAvLyBjb25zaWRlciBjb2xvdXIgdmFsdWVzXG4gICAgICAgIH0gZWxzZSBpZiAoYXJyYXkoZnJvbVByb3AudmFsdWUpICYmIGFycmF5KHRvUHJvcC52YWx1ZSkpIHtcbiAgICAgICAgICBkaWZmID0gZnJvbVByb3AudmFsdWVbMF0gIT09IHRvUHJvcC52YWx1ZVswXSB8fCBmcm9tUHJvcC52YWx1ZVsxXSAhPT0gdG9Qcm9wLnZhbHVlWzFdIHx8IGZyb21Qcm9wLnZhbHVlWzJdICE9PSB0b1Byb3AudmFsdWVbMl07XG4gICAgICAgICAgaW5pdFZhbCA9IGZyb21Qcm9wLnN0clZhbHVlO1xuICAgICAgICB9IC8vIHRoZSBwcmV2aW91cyB2YWx1ZSBpcyBnb29kIGZvciBhbiBhbmltYXRpb24gb25seSBpZiBpdCdzIGRpZmZlcmVudFxuXG5cbiAgICAgICAgaWYgKGRpZmYpIHtcbiAgICAgICAgICBzdHlsZVtwcm9wXSA9IHRvUHJvcC5zdHJWYWx1ZTsgLy8gdG8gdmFsXG5cbiAgICAgICAgICB0aGlzLmFwcGx5QnlwYXNzKGVsZSwgcHJvcCwgaW5pdFZhbCk7IC8vIGZyb20gdmFsXG5cbiAgICAgICAgICBhbnlQcmV2ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBlbmQgaWYgcHJvcHMgYWxsb3cgYW5pXG4gICAgICAvLyBjYW4ndCB0cmFuc2l0aW9uIGlmIHRoZXJlJ3Mgbm90aGluZyBwcmV2aW91cyB0byB0cmFuc2l0aW9uIGZyb21cblxuXG4gICAgICBpZiAoIWFueVByZXYpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBfcC50cmFuc2l0aW9uaW5nID0gdHJ1ZTtcbiAgICAgIG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgaWYgKGRlbGF5ID4gMCkge1xuICAgICAgICAgIGVsZS5kZWxheUFuaW1hdGlvbihkZWxheSkucGxheSgpLnByb21pc2UoKS50aGVuKHJlc29sdmUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBlbGUuYW5pbWF0aW9uKHtcbiAgICAgICAgICBzdHlsZTogc3R5bGUsXG4gICAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgICAgIGVhc2luZzogZWxlLnBzdHlsZSgndHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb24nKS52YWx1ZSxcbiAgICAgICAgICBxdWV1ZTogZmFsc2VcbiAgICAgICAgfSkucGxheSgpLnByb21pc2UoKTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBpZiggIWlzQnlwYXNzICl7XG4gICAgICAgIHNlbGYucmVtb3ZlQnlwYXNzZXMoZWxlLCBwcm9wcyk7XG4gICAgICAgIGVsZS5lbWl0QW5kTm90aWZ5KCdzdHlsZScpOyAvLyB9XG5cbiAgICAgICAgX3AudHJhbnNpdGlvbmluZyA9IGZhbHNlO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChfcC50cmFuc2l0aW9uaW5nKSB7XG4gICAgICB0aGlzLnJlbW92ZUJ5cGFzc2VzKGVsZSwgcHJvcHMpO1xuICAgICAgZWxlLmVtaXRBbmROb3RpZnkoJ3N0eWxlJyk7XG4gICAgICBfcC50cmFuc2l0aW9uaW5nID0gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIHN0eWZuJDguY2hlY2tUcmlnZ2VyID0gZnVuY3Rpb24gKGVsZSwgbmFtZSwgZnJvbVZhbHVlLCB0b1ZhbHVlLCBnZXRUcmlnZ2VyLCBvblRyaWdnZXIpIHtcbiAgICB2YXIgcHJvcCA9IHRoaXMucHJvcGVydGllc1tuYW1lXTtcbiAgICB2YXIgdHJpZ2dlckNoZWNrID0gZ2V0VHJpZ2dlcihwcm9wKTtcblxuICAgIGlmICh0cmlnZ2VyQ2hlY2sgIT0gbnVsbCAmJiB0cmlnZ2VyQ2hlY2soZnJvbVZhbHVlLCB0b1ZhbHVlKSkge1xuICAgICAgb25UcmlnZ2VyKHByb3ApO1xuICAgIH1cbiAgfTtcblxuICBzdHlmbiQ4LmNoZWNrWk9yZGVyVHJpZ2dlciA9IGZ1bmN0aW9uIChlbGUsIG5hbWUsIGZyb21WYWx1ZSwgdG9WYWx1ZSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLmNoZWNrVHJpZ2dlcihlbGUsIG5hbWUsIGZyb21WYWx1ZSwgdG9WYWx1ZSwgZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgIHJldHVybiBwcm9wLnRyaWdnZXJzWk9yZGVyO1xuICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLl9wcml2YXRlLmN5Lm5vdGlmeSgnem9yZGVyJywgZWxlKTtcbiAgICB9KTtcbiAgfTtcblxuICBzdHlmbiQ4LmNoZWNrQm91bmRzVHJpZ2dlciA9IGZ1bmN0aW9uIChlbGUsIG5hbWUsIGZyb21WYWx1ZSwgdG9WYWx1ZSkge1xuICAgIHRoaXMuY2hlY2tUcmlnZ2VyKGVsZSwgbmFtZSwgZnJvbVZhbHVlLCB0b1ZhbHVlLCBmdW5jdGlvbiAocHJvcCkge1xuICAgICAgcmV0dXJuIHByb3AudHJpZ2dlcnNCb3VuZHM7XG4gICAgfSwgZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgIGVsZS5kaXJ0eUNvbXBvdW5kQm91bmRzQ2FjaGUoKTtcbiAgICAgIGVsZS5kaXJ0eUJvdW5kaW5nQm94Q2FjaGUoKTsgLy8gaWYgdGhlIHByb3AgY2hhbmdlIG1ha2VzIHRoZSBiYiBvZiBwbGwgYmV6aWVyIGVkZ2VzIGludmFsaWQsXG4gICAgICAvLyB0aGVuIGRpcnR5IHRoZSBwbGwgZWRnZSBiYiBjYWNoZSBhcyB3ZWxsXG5cbiAgICAgIGlmICggLy8gb25seSBmb3IgYmV6aWVycyAtLSBzbyBwZXJmb3JtYW5jZSBvZiBvdGhlciBlZGdlcyBpc24ndCBhZmZlY3RlZFxuICAgICAgcHJvcC50cmlnZ2Vyc0JvdW5kc09mUGFyYWxsZWxCZXppZXJzICYmIChuYW1lID09PSAnY3VydmUtc3R5bGUnICYmIChmcm9tVmFsdWUgPT09ICdiZXppZXInIHx8IHRvVmFsdWUgPT09ICdiZXppZXInKSB8fCBuYW1lID09PSAnZGlzcGxheScgJiYgKGZyb21WYWx1ZSA9PT0gJ25vbmUnIHx8IHRvVmFsdWUgPT09ICdub25lJykpKSB7XG4gICAgICAgIGVsZS5wYXJhbGxlbEVkZ2VzKCkuZm9yRWFjaChmdW5jdGlvbiAocGxsRWRnZSkge1xuICAgICAgICAgIGlmIChwbGxFZGdlLmlzQnVuZGxlZEJlemllcigpKSB7XG4gICAgICAgICAgICBwbGxFZGdlLmRpcnR5Qm91bmRpbmdCb3hDYWNoZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgc3R5Zm4kOC5jaGVja1RyaWdnZXJzID0gZnVuY3Rpb24gKGVsZSwgbmFtZSwgZnJvbVZhbHVlLCB0b1ZhbHVlKSB7XG4gICAgZWxlLmRpcnR5U3R5bGVDYWNoZSgpO1xuICAgIHRoaXMuY2hlY2taT3JkZXJUcmlnZ2VyKGVsZSwgbmFtZSwgZnJvbVZhbHVlLCB0b1ZhbHVlKTtcbiAgICB0aGlzLmNoZWNrQm91bmRzVHJpZ2dlcihlbGUsIG5hbWUsIGZyb21WYWx1ZSwgdG9WYWx1ZSk7XG4gIH07XG5cbiAgdmFyIHN0eWZuJDcgPSB7fTsgLy8gYnlwYXNzZXMgYXJlIGFwcGxpZWQgdG8gYW4gZXhpc3Rpbmcgc3R5bGUgb24gYW4gZWxlbWVudCwgYW5kIGp1c3QgdGFja2VkIG9uIHRlbXBvcmFyaWx5XG4gIC8vIHJldHVybnMgdHJ1ZSBpZmYgYXBwbGljYXRpb24gd2FzIHN1Y2Nlc3NmdWwgZm9yIGF0IGxlYXN0IDEgc3BlY2lmaWVkIHByb3BlcnR5XG5cbiAgc3R5Zm4kNy5hcHBseUJ5cGFzcyA9IGZ1bmN0aW9uIChlbGVzLCBuYW1lLCB2YWx1ZSwgdXBkYXRlVHJhbnNpdGlvbnMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHByb3BzID0gW107XG4gICAgdmFyIGlzQnlwYXNzID0gdHJ1ZTsgLy8gcHV0IGFsbCB0aGUgcHJvcGVydGllcyAoY2FuIHNwZWNpZnkgb25lIG9yIG1hbnkpIGluIGFuIGFycmF5IGFmdGVyIHBhcnNpbmcgdGhlbVxuXG4gICAgaWYgKG5hbWUgPT09ICcqJyB8fCBuYW1lID09PSAnKionKSB7XG4gICAgICAvLyBhcHBseSB0byBhbGwgcHJvcGVydHkgbmFtZXNcbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHByb3AgPSBzZWxmLnByb3BlcnRpZXNbaV07XG4gICAgICAgICAgdmFyIF9uYW1lID0gcHJvcC5uYW1lO1xuICAgICAgICAgIHZhciBwYXJzZWRQcm9wID0gdGhpcy5wYXJzZShfbmFtZSwgdmFsdWUsIHRydWUpO1xuXG4gICAgICAgICAgaWYgKHBhcnNlZFByb3ApIHtcbiAgICAgICAgICAgIHByb3BzLnB1c2gocGFyc2VkUHJvcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzdHJpbmcobmFtZSkpIHtcbiAgICAgIC8vIHRoZW4gcGFyc2UgdGhlIHNpbmdsZSBwcm9wZXJ0eVxuICAgICAgdmFyIF9wYXJzZWRQcm9wID0gdGhpcy5wYXJzZShuYW1lLCB2YWx1ZSwgdHJ1ZSk7XG5cbiAgICAgIGlmIChfcGFyc2VkUHJvcCkge1xuICAgICAgICBwcm9wcy5wdXNoKF9wYXJzZWRQcm9wKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBsYWluT2JqZWN0KG5hbWUpKSB7XG4gICAgICAvLyB0aGVuIHBhcnNlIGVhY2ggcHJvcGVydHlcbiAgICAgIHZhciBzcGVjaWZpZWRQcm9wcyA9IG5hbWU7XG4gICAgICB1cGRhdGVUcmFuc2l0aW9ucyA9IHZhbHVlO1xuICAgICAgdmFyIG5hbWVzID0gT2JqZWN0LmtleXMoc3BlY2lmaWVkUHJvcHMpO1xuXG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbmFtZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBfbmFtZTIgPSBuYW1lc1tfaV07XG4gICAgICAgIHZhciBfdmFsdWUgPSBzcGVjaWZpZWRQcm9wc1tfbmFtZTJdO1xuXG4gICAgICAgIGlmIChfdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIHRyeSBjYW1lbCBjYXNlIG5hbWUgdG9vXG4gICAgICAgICAgX3ZhbHVlID0gc3BlY2lmaWVkUHJvcHNbZGFzaDJjYW1lbChfbmFtZTIpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBfcGFyc2VkUHJvcDIgPSB0aGlzLnBhcnNlKF9uYW1lMiwgX3ZhbHVlLCB0cnVlKTtcblxuICAgICAgICAgIGlmIChfcGFyc2VkUHJvcDIpIHtcbiAgICAgICAgICAgIHByb3BzLnB1c2goX3BhcnNlZFByb3AyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY2FuJ3QgZG8gYW55dGhpbmcgd2l0aG91dCB3ZWxsIGRlZmluZWQgcHJvcGVydGllc1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gd2UndmUgZmFpbGVkIGlmIHRoZXJlIGFyZSBubyB2YWxpZCBwcm9wZXJ0aWVzXG5cblxuICAgIGlmIChwcm9wcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIG5vdywgYXBwbHkgdGhlIGJ5cGFzcyBwcm9wZXJ0aWVzIG9uIHRoZSBlbGVtZW50c1xuXG5cbiAgICB2YXIgcmV0ID0gZmFsc2U7IC8vIHJldHVybiB0cnVlIGlmIGF0IGxlYXN0IG9uZSBzdWNjZXNmdWwgYnlwYXNzIGFwcGxpZWRcblxuICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGVsZXMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgLy8gZm9yIGVhY2ggZWxlXG4gICAgICB2YXIgZWxlID0gZWxlc1tfaTJdO1xuICAgICAgdmFyIGRpZmZQcm9wcyA9IHt9O1xuICAgICAgdmFyIGRpZmZQcm9wID0gdm9pZCAwO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHByb3BzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIC8vIGZvciBlYWNoIHByb3BcbiAgICAgICAgdmFyIF9wcm9wID0gcHJvcHNbal07XG5cbiAgICAgICAgaWYgKHVwZGF0ZVRyYW5zaXRpb25zKSB7XG4gICAgICAgICAgdmFyIHByZXZQcm9wID0gZWxlLnBzdHlsZShfcHJvcC5uYW1lKTtcbiAgICAgICAgICBkaWZmUHJvcCA9IGRpZmZQcm9wc1tfcHJvcC5uYW1lXSA9IHtcbiAgICAgICAgICAgIHByZXY6IHByZXZQcm9wXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldCA9IHRoaXMuYXBwbHlQYXJzZWRQcm9wZXJ0eShlbGUsIGNvcHkoX3Byb3ApKSB8fCByZXQ7XG5cbiAgICAgICAgaWYgKHVwZGF0ZVRyYW5zaXRpb25zKSB7XG4gICAgICAgICAgZGlmZlByb3AubmV4dCA9IGVsZS5wc3R5bGUoX3Byb3AubmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gZm9yIHByb3BzXG5cblxuICAgICAgaWYgKHJldCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVN0eWxlSGludHMoZWxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHVwZGF0ZVRyYW5zaXRpb25zKSB7XG4gICAgICAgIHRoaXMudXBkYXRlVHJhbnNpdGlvbnMoZWxlLCBkaWZmUHJvcHMsIGlzQnlwYXNzKTtcbiAgICAgIH1cbiAgICB9IC8vIGZvciBlbGVzXG5cblxuICAgIHJldHVybiByZXQ7XG4gIH07IC8vIG9ubHkgdXNlZnVsIGluIHNwZWNpZmljIGNhc2VzIGxpa2UgYW5pbWF0aW9uXG5cblxuICBzdHlmbiQ3Lm92ZXJyaWRlQnlwYXNzID0gZnVuY3Rpb24gKGVsZXMsIG5hbWUsIHZhbHVlKSB7XG4gICAgbmFtZSA9IGNhbWVsMmRhc2gobmFtZSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgdmFyIHByb3AgPSBlbGUuX3ByaXZhdGUuc3R5bGVbbmFtZV07XG4gICAgICB2YXIgdHlwZSA9IHRoaXMucHJvcGVydGllc1tuYW1lXS50eXBlO1xuICAgICAgdmFyIGlzQ29sb3IgPSB0eXBlLmNvbG9yO1xuICAgICAgdmFyIGlzTXVsdGkgPSB0eXBlLm11dGlwbGU7XG4gICAgICB2YXIgb2xkVmFsdWUgPSAhcHJvcCA/IG51bGwgOiBwcm9wLnBmVmFsdWUgIT0gbnVsbCA/IHByb3AucGZWYWx1ZSA6IHByb3AudmFsdWU7XG5cbiAgICAgIGlmICghcHJvcCB8fCAhcHJvcC5ieXBhc3MpIHtcbiAgICAgICAgLy8gbmVlZCBhIGJ5cGFzcyBpZiBvbmUgZG9lc24ndCBleGlzdFxuICAgICAgICB0aGlzLmFwcGx5QnlwYXNzKGVsZSwgbmFtZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvcC52YWx1ZSA9IHZhbHVlO1xuXG4gICAgICAgIGlmIChwcm9wLnBmVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgIHByb3AucGZWYWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzQ29sb3IpIHtcbiAgICAgICAgICBwcm9wLnN0clZhbHVlID0gJ3JnYignICsgdmFsdWUuam9pbignLCcpICsgJyknO1xuICAgICAgICB9IGVsc2UgaWYgKGlzTXVsdGkpIHtcbiAgICAgICAgICBwcm9wLnN0clZhbHVlID0gdmFsdWUuam9pbignICcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3Auc3RyVmFsdWUgPSAnJyArIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51cGRhdGVTdHlsZUhpbnRzKGVsZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2hlY2tUcmlnZ2VycyhlbGUsIG5hbWUsIG9sZFZhbHVlLCB2YWx1ZSk7XG4gICAgfVxuICB9O1xuXG4gIHN0eWZuJDcucmVtb3ZlQWxsQnlwYXNzZXMgPSBmdW5jdGlvbiAoZWxlcywgdXBkYXRlVHJhbnNpdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5yZW1vdmVCeXBhc3NlcyhlbGVzLCB0aGlzLnByb3BlcnR5TmFtZXMsIHVwZGF0ZVRyYW5zaXRpb25zKTtcbiAgfTtcblxuICBzdHlmbiQ3LnJlbW92ZUJ5cGFzc2VzID0gZnVuY3Rpb24gKGVsZXMsIHByb3BzLCB1cGRhdGVUcmFuc2l0aW9ucykge1xuICAgIHZhciBpc0J5cGFzcyA9IHRydWU7XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGVsZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBlbGUgPSBlbGVzW2pdO1xuICAgICAgdmFyIGRpZmZQcm9wcyA9IHt9O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBuYW1lID0gcHJvcHNbaV07XG4gICAgICAgIHZhciBwcm9wID0gdGhpcy5wcm9wZXJ0aWVzW25hbWVdO1xuICAgICAgICB2YXIgcHJldlByb3AgPSBlbGUucHN0eWxlKHByb3AubmFtZSk7XG5cbiAgICAgICAgaWYgKCFwcmV2UHJvcCB8fCAhcHJldlByb3AuYnlwYXNzKSB7XG4gICAgICAgICAgLy8gaWYgYSBieXBhc3MgZG9lc24ndCBleGlzdCBmb3IgdGhlIHByb3AsIG5vdGhpbmcgbmVlZHMgdG8gYmUgcmVtb3ZlZFxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZhbHVlID0gJyc7IC8vIGVtcHR5ID0+IHJlbW92ZSBieXBhc3NcblxuICAgICAgICB2YXIgcGFyc2VkUHJvcCA9IHRoaXMucGFyc2UobmFtZSwgdmFsdWUsIHRydWUpO1xuICAgICAgICB2YXIgZGlmZlByb3AgPSBkaWZmUHJvcHNbcHJvcC5uYW1lXSA9IHtcbiAgICAgICAgICBwcmV2OiBwcmV2UHJvcFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmFwcGx5UGFyc2VkUHJvcGVydHkoZWxlLCBwYXJzZWRQcm9wKTtcbiAgICAgICAgZGlmZlByb3AubmV4dCA9IGVsZS5wc3R5bGUocHJvcC5uYW1lKTtcbiAgICAgIH0gLy8gZm9yIHByb3BzXG5cblxuICAgICAgdGhpcy51cGRhdGVTdHlsZUhpbnRzKGVsZSk7XG5cbiAgICAgIGlmICh1cGRhdGVUcmFuc2l0aW9ucykge1xuICAgICAgICB0aGlzLnVwZGF0ZVRyYW5zaXRpb25zKGVsZSwgZGlmZlByb3BzLCBpc0J5cGFzcyk7XG4gICAgICB9XG4gICAgfSAvLyBmb3IgZWxlc1xuXG4gIH07XG5cbiAgdmFyIHN0eWZuJDYgPSB7fTsgLy8gZ2V0cyB3aGF0IGFuIGVtIHNpemUgY29ycmVzcG9uZHMgdG8gaW4gcGl4ZWxzIHJlbGF0aXZlIHRvIGEgZG9tIGVsZW1lbnRcblxuICBzdHlmbiQ2LmdldEVtU2l6ZUluUGl4ZWxzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBweCA9IHRoaXMuY29udGFpbmVyQ3NzKCdmb250LXNpemUnKTtcblxuICAgIGlmIChweCAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gcGFyc2VGbG9hdChweCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAxOyAvLyBmb3IgaGVhZGxlc3NcbiAgICB9XG4gIH07IC8vIGdldHMgY3NzIHByb3BlcnR5IGZyb20gdGhlIGNvcmUgY29udGFpbmVyXG5cblxuICBzdHlmbiQ2LmNvbnRhaW5lckNzcyA9IGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgdmFyIGRvbUVsZW1lbnQgPSBjeS5jb250YWluZXIoKTtcblxuICAgIGlmICh3aW5kb3ckMSAmJiBkb21FbGVtZW50ICYmIHdpbmRvdyQxLmdldENvbXB1dGVkU3R5bGUpIHtcbiAgICAgIHJldHVybiB3aW5kb3ckMS5nZXRDb21wdXRlZFN0eWxlKGRvbUVsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUocHJvcE5hbWUpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgc3R5Zm4kNSA9IHt9OyAvLyBnZXRzIHRoZSByZW5kZXJlZCBzdHlsZSBmb3IgYW4gZWxlbWVudFxuXG4gIHN0eWZuJDUuZ2V0UmVuZGVyZWRTdHlsZSA9IGZ1bmN0aW9uIChlbGUsIHByb3ApIHtcbiAgICBpZiAocHJvcCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0U3R5bGVQcm9wZXJ0eVZhbHVlKGVsZSwgcHJvcCwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFJhd1N0eWxlKGVsZSwgdHJ1ZSk7XG4gICAgfVxuICB9OyAvLyBnZXRzIHRoZSByYXcgc3R5bGUgZm9yIGFuIGVsZW1lbnRcblxuXG4gIHN0eWZuJDUuZ2V0UmF3U3R5bGUgPSBmdW5jdGlvbiAoZWxlLCBpc1JlbmRlcmVkVmFsKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGVsZSA9IGVsZVswXTsgLy8gaW5zdXJlIGl0J3MgYW4gZWxlbWVudFxuXG4gICAgaWYgKGVsZSkge1xuICAgICAgdmFyIHJzdHlsZSA9IHt9O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYucHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcHJvcCA9IHNlbGYucHJvcGVydGllc1tpXTtcbiAgICAgICAgdmFyIHZhbCA9IHNlbGYuZ2V0U3R5bGVQcm9wZXJ0eVZhbHVlKGVsZSwgcHJvcC5uYW1lLCBpc1JlbmRlcmVkVmFsKTtcblxuICAgICAgICBpZiAodmFsICE9IG51bGwpIHtcbiAgICAgICAgICByc3R5bGVbcHJvcC5uYW1lXSA9IHZhbDtcbiAgICAgICAgICByc3R5bGVbZGFzaDJjYW1lbChwcm9wLm5hbWUpXSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcnN0eWxlO1xuICAgIH1cbiAgfTtcblxuICBzdHlmbiQ1LmdldEluZGV4ZWRTdHlsZSA9IGZ1bmN0aW9uIChlbGUsIHByb3BlcnR5LCBzdWJwcm9wZXJ0eSwgaW5kZXgpIHtcbiAgICB2YXIgcHN0eWxlID0gZWxlLnBzdHlsZShwcm9wZXJ0eSlbc3VicHJvcGVydHldW2luZGV4XTtcbiAgICByZXR1cm4gcHN0eWxlICE9IG51bGwgPyBwc3R5bGUgOiBlbGUuY3koKS5zdHlsZSgpLmdldERlZmF1bHRQcm9wZXJ0eShwcm9wZXJ0eSlbc3VicHJvcGVydHldWzBdO1xuICB9O1xuXG4gIHN0eWZuJDUuZ2V0U3R5bGVQcm9wZXJ0eVZhbHVlID0gZnVuY3Rpb24gKGVsZSwgcHJvcE5hbWUsIGlzUmVuZGVyZWRWYWwpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgZWxlID0gZWxlWzBdOyAvLyBpbnN1cmUgaXQncyBhbiBlbGVtZW50XG5cbiAgICBpZiAoZWxlKSB7XG4gICAgICB2YXIgcHJvcCA9IHNlbGYucHJvcGVydGllc1twcm9wTmFtZV07XG5cbiAgICAgIGlmIChwcm9wLmFsaWFzKSB7XG4gICAgICAgIHByb3AgPSBwcm9wLnBvaW50c1RvO1xuICAgICAgfVxuXG4gICAgICB2YXIgdHlwZSA9IHByb3AudHlwZTtcbiAgICAgIHZhciBzdHlsZVByb3AgPSBlbGUucHN0eWxlKHByb3AubmFtZSk7XG5cbiAgICAgIGlmIChzdHlsZVByb3ApIHtcbiAgICAgICAgdmFyIHZhbHVlID0gc3R5bGVQcm9wLnZhbHVlLFxuICAgICAgICAgICAgdW5pdHMgPSBzdHlsZVByb3AudW5pdHMsXG4gICAgICAgICAgICBzdHJWYWx1ZSA9IHN0eWxlUHJvcC5zdHJWYWx1ZTtcblxuICAgICAgICBpZiAoaXNSZW5kZXJlZFZhbCAmJiB0eXBlLm51bWJlciAmJiB2YWx1ZSAhPSBudWxsICYmIG51bWJlciQxKHZhbHVlKSkge1xuICAgICAgICAgIHZhciB6b29tID0gZWxlLmN5KCkuem9vbSgpO1xuXG4gICAgICAgICAgdmFyIGdldFJlbmRlcmVkVmFsdWUgPSBmdW5jdGlvbiBnZXRSZW5kZXJlZFZhbHVlKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbCAqIHpvb207XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHZhciBnZXRWYWx1ZVN0cmluZ1dpdGhVbml0cyA9IGZ1bmN0aW9uIGdldFZhbHVlU3RyaW5nV2l0aFVuaXRzKHZhbCwgdW5pdHMpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRSZW5kZXJlZFZhbHVlKHZhbCkgKyB1bml0cztcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdmFyIGlzQXJyYXlWYWx1ZSA9IGFycmF5KHZhbHVlKTtcbiAgICAgICAgICB2YXIgaGF2ZVVuaXRzID0gaXNBcnJheVZhbHVlID8gdW5pdHMuZXZlcnkoZnVuY3Rpb24gKHUpIHtcbiAgICAgICAgICAgIHJldHVybiB1ICE9IG51bGw7XG4gICAgICAgICAgfSkgOiB1bml0cyAhPSBudWxsO1xuXG4gICAgICAgICAgaWYgKGhhdmVVbml0cykge1xuICAgICAgICAgICAgaWYgKGlzQXJyYXlWYWx1ZSkge1xuICAgICAgICAgICAgICByZXR1cm4gdmFsdWUubWFwKGZ1bmN0aW9uICh2LCBpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldFZhbHVlU3RyaW5nV2l0aFVuaXRzKHYsIHVuaXRzW2ldKTtcbiAgICAgICAgICAgICAgfSkuam9pbignICcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldFZhbHVlU3RyaW5nV2l0aFVuaXRzKHZhbHVlLCB1bml0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpc0FycmF5VmFsdWUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmcodikgPyB2IDogJycgKyBnZXRSZW5kZXJlZFZhbHVlKHYpO1xuICAgICAgICAgICAgICB9KS5qb2luKCcgJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gJycgKyBnZXRSZW5kZXJlZFZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc3RyVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBzdHJWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgc3R5Zm4kNS5nZXRBbmltYXRpb25TdGFydFN0eWxlID0gZnVuY3Rpb24gKGVsZSwgYW5pUHJvcHMpIHtcbiAgICB2YXIgcnN0eWxlID0ge307XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFuaVByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYW5pUHJvcCA9IGFuaVByb3BzW2ldO1xuICAgICAgdmFyIG5hbWUgPSBhbmlQcm9wLm5hbWU7XG4gICAgICB2YXIgc3R5bGVQcm9wID0gZWxlLnBzdHlsZShuYW1lKTtcblxuICAgICAgaWYgKHN0eWxlUHJvcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIHRoZW4gbWFrZSBhIHByb3Agb2YgaXRcbiAgICAgICAgaWYgKHBsYWluT2JqZWN0KHN0eWxlUHJvcCkpIHtcbiAgICAgICAgICBzdHlsZVByb3AgPSB0aGlzLnBhcnNlKG5hbWUsIHN0eWxlUHJvcC5zdHJWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3R5bGVQcm9wID0gdGhpcy5wYXJzZShuYW1lLCBzdHlsZVByb3ApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzdHlsZVByb3ApIHtcbiAgICAgICAgcnN0eWxlW25hbWVdID0gc3R5bGVQcm9wO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByc3R5bGU7XG4gIH07XG5cbiAgc3R5Zm4kNS5nZXRQcm9wc0xpc3QgPSBmdW5jdGlvbiAocHJvcHNPYmopIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHJzdHlsZSA9IFtdO1xuICAgIHZhciBzdHlsZSA9IHByb3BzT2JqO1xuICAgIHZhciBwcm9wcyA9IHNlbGYucHJvcGVydGllcztcblxuICAgIGlmIChzdHlsZSkge1xuICAgICAgdmFyIG5hbWVzID0gT2JqZWN0LmtleXMoc3R5bGUpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBuYW1lID0gbmFtZXNbaV07XG4gICAgICAgIHZhciB2YWwgPSBzdHlsZVtuYW1lXTtcbiAgICAgICAgdmFyIHByb3AgPSBwcm9wc1tuYW1lXSB8fCBwcm9wc1tjYW1lbDJkYXNoKG5hbWUpXTtcbiAgICAgICAgdmFyIHN0eWxlUHJvcCA9IHRoaXMucGFyc2UocHJvcC5uYW1lLCB2YWwpO1xuXG4gICAgICAgIGlmIChzdHlsZVByb3ApIHtcbiAgICAgICAgICByc3R5bGUucHVzaChzdHlsZVByb3ApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJzdHlsZTtcbiAgfTtcblxuICBzdHlmbiQ1LmdldE5vbkRlZmF1bHRQcm9wZXJ0aWVzSGFzaCA9IGZ1bmN0aW9uIChlbGUsIHByb3BOYW1lcywgc2VlZCkge1xuICAgIHZhciBoYXNoID0gc2VlZC5zbGljZSgpO1xuICAgIHZhciBuYW1lLCB2YWwsIHN0clZhbCwgY2hWYWw7XG4gICAgdmFyIGksIGo7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgcHJvcE5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBuYW1lID0gcHJvcE5hbWVzW2ldO1xuICAgICAgdmFsID0gZWxlLnBzdHlsZShuYW1lLCBmYWxzZSk7XG5cbiAgICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSBpZiAodmFsLnBmVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBoYXNoWzBdID0gaGFzaEludChjaFZhbCwgaGFzaFswXSk7XG4gICAgICAgIGhhc2hbMV0gPSBoYXNoSW50QWx0KGNoVmFsLCBoYXNoWzFdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0clZhbCA9IHZhbC5zdHJWYWx1ZTtcblxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgc3RyVmFsLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgY2hWYWwgPSBzdHJWYWwuY2hhckNvZGVBdChqKTtcbiAgICAgICAgICBoYXNoWzBdID0gaGFzaEludChjaFZhbCwgaGFzaFswXSk7XG4gICAgICAgICAgaGFzaFsxXSA9IGhhc2hJbnRBbHQoY2hWYWwsIGhhc2hbMV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGhhc2g7XG4gIH07XG5cbiAgc3R5Zm4kNS5nZXRQcm9wZXJ0aWVzSGFzaCA9IHN0eWZuJDUuZ2V0Tm9uRGVmYXVsdFByb3BlcnRpZXNIYXNoO1xuXG4gIHZhciBzdHlmbiQ0ID0ge307XG5cbiAgc3R5Zm4kNC5hcHBlbmRGcm9tSnNvbiA9IGZ1bmN0aW9uIChqc29uKSB7XG4gICAgdmFyIHN0eWxlID0gdGhpcztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwganNvbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNvbnRleHQgPSBqc29uW2ldO1xuICAgICAgdmFyIHNlbGVjdG9yID0gY29udGV4dC5zZWxlY3RvcjtcbiAgICAgIHZhciBwcm9wcyA9IGNvbnRleHQuc3R5bGUgfHwgY29udGV4dC5jc3M7XG4gICAgICB2YXIgbmFtZXMgPSBPYmplY3Qua2V5cyhwcm9wcyk7XG4gICAgICBzdHlsZS5zZWxlY3RvcihzZWxlY3Rvcik7IC8vIGFwcGx5IHNlbGVjdG9yXG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbmFtZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIG5hbWUgPSBuYW1lc1tqXTtcbiAgICAgICAgdmFyIHZhbHVlID0gcHJvcHNbbmFtZV07XG4gICAgICAgIHN0eWxlLmNzcyhuYW1lLCB2YWx1ZSk7IC8vIGFwcGx5IHByb3BlcnR5XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0eWxlO1xuICB9OyAvLyBhY2Nlc3NpYmxlIGN5LnN0eWxlKCkgZnVuY3Rpb25cblxuXG4gIHN0eWZuJDQuZnJvbUpzb24gPSBmdW5jdGlvbiAoanNvbikge1xuICAgIHZhciBzdHlsZSA9IHRoaXM7XG4gICAgc3R5bGUucmVzZXRUb0RlZmF1bHQoKTtcbiAgICBzdHlsZS5hcHBlbmRGcm9tSnNvbihqc29uKTtcbiAgICByZXR1cm4gc3R5bGU7XG4gIH07IC8vIGdldCBqc29uIGZyb20gY3kuc3R5bGUoKSBhcGlcblxuXG4gIHN0eWZuJDQuanNvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIganNvbiA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IHRoaXMuZGVmYXVsdExlbmd0aDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjeHQgPSB0aGlzW2ldO1xuICAgICAgdmFyIHNlbGVjdG9yID0gY3h0LnNlbGVjdG9yO1xuICAgICAgdmFyIHByb3BzID0gY3h0LnByb3BlcnRpZXM7XG4gICAgICB2YXIgY3NzID0ge307XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcHJvcHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIHByb3AgPSBwcm9wc1tqXTtcbiAgICAgICAgY3NzW3Byb3AubmFtZV0gPSBwcm9wLnN0clZhbHVlO1xuICAgICAgfVxuXG4gICAgICBqc29uLnB1c2goe1xuICAgICAgICBzZWxlY3RvcjogIXNlbGVjdG9yID8gJ2NvcmUnIDogc2VsZWN0b3IudG9TdHJpbmcoKSxcbiAgICAgICAgc3R5bGU6IGNzc1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGpzb247XG4gIH07XG5cbiAgdmFyIHN0eWZuJDMgPSB7fTtcblxuICBzdHlmbiQzLmFwcGVuZEZyb21TdHJpbmcgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBzdHlsZSA9IHRoaXM7XG4gICAgdmFyIHJlbWFpbmluZyA9ICcnICsgc3RyaW5nO1xuICAgIHZhciBzZWxBbmRCbG9ja1N0cjtcbiAgICB2YXIgYmxvY2tSZW07XG4gICAgdmFyIHByb3BBbmRWYWxTdHI7IC8vIHJlbW92ZSBjb21tZW50cyBmcm9tIHRoZSBzdHlsZSBzdHJpbmdcblxuICAgIHJlbWFpbmluZyA9IHJlbWFpbmluZy5yZXBsYWNlKC9bL11bKl0oXFxzfC4pKz9bKl1bL10vZywgJycpO1xuXG4gICAgZnVuY3Rpb24gcmVtb3ZlU2VsQW5kQmxvY2tGcm9tUmVtYWluaW5nKCkge1xuICAgICAgLy8gcmVtb3ZlIHRoZSBwYXJzZWQgc2VsZWN0b3IgYW5kIGJsb2NrIGZyb20gdGhlIHJlbWFpbmluZyB0ZXh0IHRvIHBhcnNlXG4gICAgICBpZiAocmVtYWluaW5nLmxlbmd0aCA+IHNlbEFuZEJsb2NrU3RyLmxlbmd0aCkge1xuICAgICAgICByZW1haW5pbmcgPSByZW1haW5pbmcuc3Vic3RyKHNlbEFuZEJsb2NrU3RyLmxlbmd0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZW1haW5pbmcgPSAnJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmVQcm9wQW5kVmFsRnJvbVJlbSgpIHtcbiAgICAgIC8vIHJlbW92ZSB0aGUgcGFyc2VkIHByb3BlcnR5IGFuZCB2YWx1ZSBmcm9tIHRoZSByZW1haW5pbmcgYmxvY2sgdGV4dCB0byBwYXJzZVxuICAgICAgaWYgKGJsb2NrUmVtLmxlbmd0aCA+IHByb3BBbmRWYWxTdHIubGVuZ3RoKSB7XG4gICAgICAgIGJsb2NrUmVtID0gYmxvY2tSZW0uc3Vic3RyKHByb3BBbmRWYWxTdHIubGVuZ3RoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJsb2NrUmVtID0gJyc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICg7Oykge1xuICAgICAgdmFyIG5vdGhpbmdMZWZ0VG9QYXJzZSA9IHJlbWFpbmluZy5tYXRjaCgvXlxccyokLyk7XG5cbiAgICAgIGlmIChub3RoaW5nTGVmdFRvUGFyc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHZhciBzZWxBbmRCbG9jayA9IHJlbWFpbmluZy5tYXRjaCgvXlxccyooKD86LnxcXHMpKz8pXFxzKlxceygoPzoufFxccykrPylcXH0vKTtcblxuICAgICAgaWYgKCFzZWxBbmRCbG9jaykge1xuICAgICAgICB3YXJuKCdIYWx0aW5nIHN0eWxlc2hlZXQgcGFyc2luZzogU3RyaW5nIHN0eWxlc2hlZXQgY29udGFpbnMgbW9yZSB0byBwYXJzZSBidXQgbm8gc2VsZWN0b3IgYW5kIGJsb2NrIGZvdW5kIGluOiAnICsgcmVtYWluaW5nKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHNlbEFuZEJsb2NrU3RyID0gc2VsQW5kQmxvY2tbMF07IC8vIHBhcnNlIHRoZSBzZWxlY3RvclxuXG4gICAgICB2YXIgc2VsZWN0b3JTdHIgPSBzZWxBbmRCbG9ja1sxXTtcblxuICAgICAgaWYgKHNlbGVjdG9yU3RyICE9PSAnY29yZScpIHtcbiAgICAgICAgdmFyIHNlbGVjdG9yID0gbmV3IFNlbGVjdG9yKHNlbGVjdG9yU3RyKTtcblxuICAgICAgICBpZiAoc2VsZWN0b3IuaW52YWxpZCkge1xuICAgICAgICAgIHdhcm4oJ1NraXBwaW5nIHBhcnNpbmcgb2YgYmxvY2s6IEludmFsaWQgc2VsZWN0b3IgZm91bmQgaW4gc3RyaW5nIHN0eWxlc2hlZXQ6ICcgKyBzZWxlY3RvclN0cik7IC8vIHNraXAgdGhpcyBzZWxlY3RvciBhbmQgYmxvY2tcblxuICAgICAgICAgIHJlbW92ZVNlbEFuZEJsb2NrRnJvbVJlbWFpbmluZygpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9IC8vIHBhcnNlIHRoZSBibG9jayBvZiBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXNcblxuXG4gICAgICB2YXIgYmxvY2tTdHIgPSBzZWxBbmRCbG9ja1syXTtcbiAgICAgIHZhciBpbnZhbGlkQmxvY2sgPSBmYWxzZTtcbiAgICAgIGJsb2NrUmVtID0gYmxvY2tTdHI7XG4gICAgICB2YXIgcHJvcHMgPSBbXTtcblxuICAgICAgZm9yICg7Oykge1xuICAgICAgICB2YXIgX25vdGhpbmdMZWZ0VG9QYXJzZSA9IGJsb2NrUmVtLm1hdGNoKC9eXFxzKiQvKTtcblxuICAgICAgICBpZiAoX25vdGhpbmdMZWZ0VG9QYXJzZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHByb3BBbmRWYWwgPSBibG9ja1JlbS5tYXRjaCgvXlxccyooLis/KVxccyo6XFxzKiguKz8pKD86XFxzKjt8XFxzKiQpLyk7XG5cbiAgICAgICAgaWYgKCFwcm9wQW5kVmFsKSB7XG4gICAgICAgICAgd2FybignU2tpcHBpbmcgcGFyc2luZyBvZiBibG9jazogSW52YWxpZCBmb3JtYXR0aW5nIG9mIHN0eWxlIHByb3BlcnR5IGFuZCB2YWx1ZSBkZWZpbml0aW9ucyBmb3VuZCBpbjonICsgYmxvY2tTdHIpO1xuICAgICAgICAgIGludmFsaWRCbG9jayA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBwcm9wQW5kVmFsU3RyID0gcHJvcEFuZFZhbFswXTtcbiAgICAgICAgdmFyIHByb3BTdHIgPSBwcm9wQW5kVmFsWzFdO1xuICAgICAgICB2YXIgdmFsU3RyID0gcHJvcEFuZFZhbFsyXTtcbiAgICAgICAgdmFyIHByb3AgPSBzZWxmLnByb3BlcnRpZXNbcHJvcFN0cl07XG5cbiAgICAgICAgaWYgKCFwcm9wKSB7XG4gICAgICAgICAgd2FybignU2tpcHBpbmcgcHJvcGVydHk6IEludmFsaWQgcHJvcGVydHkgbmFtZSBpbjogJyArIHByb3BBbmRWYWxTdHIpOyAvLyBza2lwIHRoaXMgcHJvcGVydHkgaW4gdGhlIGJsb2NrXG5cbiAgICAgICAgICByZW1vdmVQcm9wQW5kVmFsRnJvbVJlbSgpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBhcnNlZFByb3AgPSBzdHlsZS5wYXJzZShwcm9wU3RyLCB2YWxTdHIpO1xuXG4gICAgICAgIGlmICghcGFyc2VkUHJvcCkge1xuICAgICAgICAgIHdhcm4oJ1NraXBwaW5nIHByb3BlcnR5OiBJbnZhbGlkIHByb3BlcnR5IGRlZmluaXRpb24gaW46ICcgKyBwcm9wQW5kVmFsU3RyKTsgLy8gc2tpcCB0aGlzIHByb3BlcnR5IGluIHRoZSBibG9ja1xuXG4gICAgICAgICAgcmVtb3ZlUHJvcEFuZFZhbEZyb21SZW0oKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb3BzLnB1c2goe1xuICAgICAgICAgIG5hbWU6IHByb3BTdHIsXG4gICAgICAgICAgdmFsOiB2YWxTdHJcbiAgICAgICAgfSk7XG4gICAgICAgIHJlbW92ZVByb3BBbmRWYWxGcm9tUmVtKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbnZhbGlkQmxvY2spIHtcbiAgICAgICAgcmVtb3ZlU2VsQW5kQmxvY2tGcm9tUmVtYWluaW5nKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSAvLyBwdXQgdGhlIHBhcnNlZCBibG9jayBpbiB0aGUgc3R5bGVcblxuXG4gICAgICBzdHlsZS5zZWxlY3RvcihzZWxlY3RvclN0cik7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIF9wcm9wID0gcHJvcHNbaV07XG4gICAgICAgIHN0eWxlLmNzcyhfcHJvcC5uYW1lLCBfcHJvcC52YWwpO1xuICAgICAgfVxuXG4gICAgICByZW1vdmVTZWxBbmRCbG9ja0Zyb21SZW1haW5pbmcoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3R5bGU7XG4gIH07XG5cbiAgc3R5Zm4kMy5mcm9tU3RyaW5nID0gZnVuY3Rpb24gKHN0cmluZykge1xuICAgIHZhciBzdHlsZSA9IHRoaXM7XG4gICAgc3R5bGUucmVzZXRUb0RlZmF1bHQoKTtcbiAgICBzdHlsZS5hcHBlbmRGcm9tU3RyaW5nKHN0cmluZyk7XG4gICAgcmV0dXJuIHN0eWxlO1xuICB9O1xuXG4gIHZhciBzdHlmbiQyID0ge307XG5cbiAgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbnVtYmVyJDEgPSBudW1iZXI7XG4gICAgdmFyIHJnYmEgPSByZ2JhTm9CYWNrUmVmcztcbiAgICB2YXIgaHNsYSA9IGhzbGFOb0JhY2tSZWZzO1xuICAgIHZhciBoZXgzJDEgPSBoZXgzO1xuICAgIHZhciBoZXg2JDEgPSBoZXg2O1xuXG4gICAgdmFyIGRhdGEgPSBmdW5jdGlvbiBkYXRhKHByZWZpeCkge1xuICAgICAgcmV0dXJuICdeJyArIHByZWZpeCArICdcXFxccypcXFxcKFxcXFxzKihbXFxcXHdcXFxcLl0rKVxcXFxzKlxcXFwpJCc7XG4gICAgfTtcblxuICAgIHZhciBtYXBEYXRhID0gZnVuY3Rpb24gbWFwRGF0YShwcmVmaXgpIHtcbiAgICAgIHZhciBtYXBBcmcgPSBudW1iZXIkMSArICd8XFxcXHcrfCcgKyByZ2JhICsgJ3wnICsgaHNsYSArICd8JyArIGhleDMkMSArICd8JyArIGhleDYkMTtcbiAgICAgIHJldHVybiAnXicgKyBwcmVmaXggKyAnXFxcXHMqXFxcXCgoW1xcXFx3XFxcXC5dKylcXFxccypcXFxcLFxcXFxzKignICsgbnVtYmVyJDEgKyAnKVxcXFxzKlxcXFwsXFxcXHMqKCcgKyBudW1iZXIkMSArICcpXFxcXHMqLFxcXFxzKignICsgbWFwQXJnICsgJylcXFxccypcXFxcLFxcXFxzKignICsgbWFwQXJnICsgJylcXFxcKSQnO1xuICAgIH07XG5cbiAgICB2YXIgdXJsUmVnZXhlcyA9IFsnXnVybFxcXFxzKlxcXFwoXFxcXHMqW1xcJ1wiXT8oLis/KVtcXCdcIl0/XFxcXHMqXFxcXCkkJywgJ14obm9uZSkkJywgJ14oLispJCddOyAvLyBlYWNoIHZpc3VhbCBzdHlsZSBwcm9wZXJ0eSBoYXMgYSB0eXBlIGFuZCBuZWVkcyB0byBiZSB2YWxpZGF0ZWQgYWNjb3JkaW5nIHRvIGl0XG5cbiAgICBzdHlmbiQyLnR5cGVzID0ge1xuICAgICAgdGltZToge1xuICAgICAgICBudW1iZXI6IHRydWUsXG4gICAgICAgIG1pbjogMCxcbiAgICAgICAgdW5pdHM6ICdzfG1zJyxcbiAgICAgICAgaW1wbGljaXRVbml0czogJ21zJ1xuICAgICAgfSxcbiAgICAgIHBlcmNlbnQ6IHtcbiAgICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgICBtaW46IDAsXG4gICAgICAgIG1heDogMTAwLFxuICAgICAgICB1bml0czogJyUnLFxuICAgICAgICBpbXBsaWNpdFVuaXRzOiAnJSdcbiAgICAgIH0sXG4gICAgICBwZXJjZW50YWdlczoge1xuICAgICAgICBudW1iZXI6IHRydWUsXG4gICAgICAgIG1pbjogMCxcbiAgICAgICAgbWF4OiAxMDAsXG4gICAgICAgIHVuaXRzOiAnJScsXG4gICAgICAgIGltcGxpY2l0VW5pdHM6ICclJyxcbiAgICAgICAgbXVsdGlwbGU6IHRydWVcbiAgICAgIH0sXG4gICAgICB6ZXJvT25lTnVtYmVyOiB7XG4gICAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgICAgbWluOiAwLFxuICAgICAgICBtYXg6IDEsXG4gICAgICAgIHVuaXRsZXNzOiB0cnVlXG4gICAgICB9LFxuICAgICAgemVyb09uZU51bWJlcnM6IHtcbiAgICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgICBtaW46IDAsXG4gICAgICAgIG1heDogMSxcbiAgICAgICAgdW5pdGxlc3M6IHRydWUsXG4gICAgICAgIG11bHRpcGxlOiB0cnVlXG4gICAgICB9LFxuICAgICAgbk9uZU9uZU51bWJlcjoge1xuICAgICAgICBudW1iZXI6IHRydWUsXG4gICAgICAgIG1pbjogLTEsXG4gICAgICAgIG1heDogMSxcbiAgICAgICAgdW5pdGxlc3M6IHRydWVcbiAgICAgIH0sXG4gICAgICBub25OZWdhdGl2ZUludDoge1xuICAgICAgICBudW1iZXI6IHRydWUsXG4gICAgICAgIG1pbjogMCxcbiAgICAgICAgaW50ZWdlcjogdHJ1ZSxcbiAgICAgICAgdW5pdGxlc3M6IHRydWVcbiAgICAgIH0sXG4gICAgICBwb3NpdGlvbjoge1xuICAgICAgICBlbnVtczogWydwYXJlbnQnLCAnb3JpZ2luJ11cbiAgICAgIH0sXG4gICAgICBub2RlU2l6ZToge1xuICAgICAgICBudW1iZXI6IHRydWUsXG4gICAgICAgIG1pbjogMCxcbiAgICAgICAgZW51bXM6IFsnbGFiZWwnXVxuICAgICAgfSxcbiAgICAgIG51bWJlcjoge1xuICAgICAgICBudW1iZXI6IHRydWUsXG4gICAgICAgIHVuaXRsZXNzOiB0cnVlXG4gICAgICB9LFxuICAgICAgbnVtYmVyczoge1xuICAgICAgICBudW1iZXI6IHRydWUsXG4gICAgICAgIHVuaXRsZXNzOiB0cnVlLFxuICAgICAgICBtdWx0aXBsZTogdHJ1ZVxuICAgICAgfSxcbiAgICAgIHBvc2l0aXZlTnVtYmVyOiB7XG4gICAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgICAgdW5pdGxlc3M6IHRydWUsXG4gICAgICAgIG1pbjogMCxcbiAgICAgICAgc3RyaWN0TWluOiB0cnVlXG4gICAgICB9LFxuICAgICAgc2l6ZToge1xuICAgICAgICBudW1iZXI6IHRydWUsXG4gICAgICAgIG1pbjogMFxuICAgICAgfSxcbiAgICAgIGJpZGlyZWN0aW9uYWxTaXplOiB7XG4gICAgICAgIG51bWJlcjogdHJ1ZVxuICAgICAgfSxcbiAgICAgIC8vIGFsbG93cyBuZWdhdGl2ZVxuICAgICAgYmlkaXJlY3Rpb25hbFNpemVNYXliZVBlcmNlbnQ6IHtcbiAgICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgICBhbGxvd1BlcmNlbnQ6IHRydWVcbiAgICAgIH0sXG4gICAgICAvLyBhbGxvd3MgbmVnYXRpdmVcbiAgICAgIGJpZGlyZWN0aW9uYWxTaXplczoge1xuICAgICAgICBudW1iZXI6IHRydWUsXG4gICAgICAgIG11bHRpcGxlOiB0cnVlXG4gICAgICB9LFxuICAgICAgLy8gYWxsb3dzIG5lZ2F0aXZlXG4gICAgICBzaXplTWF5YmVQZXJjZW50OiB7XG4gICAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgICAgbWluOiAwLFxuICAgICAgICBhbGxvd1BlcmNlbnQ6IHRydWVcbiAgICAgIH0sXG4gICAgICBheGlzRGlyZWN0aW9uOiB7XG4gICAgICAgIGVudW1zOiBbJ2hvcml6b250YWwnLCAnbGVmdHdhcmQnLCAncmlnaHR3YXJkJywgJ3ZlcnRpY2FsJywgJ3Vwd2FyZCcsICdkb3dud2FyZCcsICdhdXRvJ11cbiAgICAgIH0sXG4gICAgICBwYWRkaW5nUmVsYXRpdmVUbzoge1xuICAgICAgICBlbnVtczogWyd3aWR0aCcsICdoZWlnaHQnLCAnYXZlcmFnZScsICdtaW4nLCAnbWF4J11cbiAgICAgIH0sXG4gICAgICBiZ1dIOiB7XG4gICAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgICAgbWluOiAwLFxuICAgICAgICBhbGxvd1BlcmNlbnQ6IHRydWUsXG4gICAgICAgIGVudW1zOiBbJ2F1dG8nXSxcbiAgICAgICAgbXVsdGlwbGU6IHRydWVcbiAgICAgIH0sXG4gICAgICBiZ1Bvczoge1xuICAgICAgICBudW1iZXI6IHRydWUsXG4gICAgICAgIGFsbG93UGVyY2VudDogdHJ1ZSxcbiAgICAgICAgbXVsdGlwbGU6IHRydWVcbiAgICAgIH0sXG4gICAgICBiZ1JlbGF0aXZlVG86IHtcbiAgICAgICAgZW51bXM6IFsnaW5uZXInLCAnaW5jbHVkZS1wYWRkaW5nJ10sXG4gICAgICAgIG11bHRpcGxlOiB0cnVlXG4gICAgICB9LFxuICAgICAgYmdSZXBlYXQ6IHtcbiAgICAgICAgZW51bXM6IFsncmVwZWF0JywgJ3JlcGVhdC14JywgJ3JlcGVhdC15JywgJ25vLXJlcGVhdCddLFxuICAgICAgICBtdWx0aXBsZTogdHJ1ZVxuICAgICAgfSxcbiAgICAgIGJnRml0OiB7XG4gICAgICAgIGVudW1zOiBbJ25vbmUnLCAnY29udGFpbicsICdjb3ZlciddLFxuICAgICAgICBtdWx0aXBsZTogdHJ1ZVxuICAgICAgfSxcbiAgICAgIGJnQ3Jvc3NPcmlnaW46IHtcbiAgICAgICAgZW51bXM6IFsnYW5vbnltb3VzJywgJ3VzZS1jcmVkZW50aWFscycsICdudWxsJ10sXG4gICAgICAgIG11bHRpcGxlOiB0cnVlXG4gICAgICB9LFxuICAgICAgYmdDbGlwOiB7XG4gICAgICAgIGVudW1zOiBbJ25vbmUnLCAnbm9kZSddLFxuICAgICAgICBtdWx0aXBsZTogdHJ1ZVxuICAgICAgfSxcbiAgICAgIGJnQ29udGFpbm1lbnQ6IHtcbiAgICAgICAgZW51bXM6IFsnaW5zaWRlJywgJ292ZXInXSxcbiAgICAgICAgbXVsdGlwbGU6IHRydWVcbiAgICAgIH0sXG4gICAgICBjb2xvcjoge1xuICAgICAgICBjb2xvcjogdHJ1ZVxuICAgICAgfSxcbiAgICAgIGNvbG9yczoge1xuICAgICAgICBjb2xvcjogdHJ1ZSxcbiAgICAgICAgbXVsdGlwbGU6IHRydWVcbiAgICAgIH0sXG4gICAgICBmaWxsOiB7XG4gICAgICAgIGVudW1zOiBbJ3NvbGlkJywgJ2xpbmVhci1ncmFkaWVudCcsICdyYWRpYWwtZ3JhZGllbnQnXVxuICAgICAgfSxcbiAgICAgIGJvb2w6IHtcbiAgICAgICAgZW51bXM6IFsneWVzJywgJ25vJ11cbiAgICAgIH0sXG4gICAgICBib29sczoge1xuICAgICAgICBlbnVtczogWyd5ZXMnLCAnbm8nXSxcbiAgICAgICAgbXVsdGlwbGU6IHRydWVcbiAgICAgIH0sXG4gICAgICBsaW5lU3R5bGU6IHtcbiAgICAgICAgZW51bXM6IFsnc29saWQnLCAnZG90dGVkJywgJ2Rhc2hlZCddXG4gICAgICB9LFxuICAgICAgbGluZUNhcDoge1xuICAgICAgICBlbnVtczogWydidXR0JywgJ3JvdW5kJywgJ3NxdWFyZSddXG4gICAgICB9LFxuICAgICAgYm9yZGVyU3R5bGU6IHtcbiAgICAgICAgZW51bXM6IFsnc29saWQnLCAnZG90dGVkJywgJ2Rhc2hlZCcsICdkb3VibGUnXVxuICAgICAgfSxcbiAgICAgIGN1cnZlU3R5bGU6IHtcbiAgICAgICAgZW51bXM6IFsnYmV6aWVyJywgJ3VuYnVuZGxlZC1iZXppZXInLCAnaGF5c3RhY2snLCAnc2VnbWVudHMnLCAnc3RyYWlnaHQnLCAnc3RyYWlnaHQtdHJpYW5nbGUnLCAndGF4aSddXG4gICAgICB9LFxuICAgICAgZm9udEZhbWlseToge1xuICAgICAgICByZWdleDogJ14oW1xcXFx3LSBcXFxcXCJdKyg/OlxcXFxzKixcXFxccypbXFxcXHctIFxcXFxcIl0rKSopJCdcbiAgICAgIH0sXG4gICAgICBmb250U3R5bGU6IHtcbiAgICAgICAgZW51bXM6IFsnaXRhbGljJywgJ25vcm1hbCcsICdvYmxpcXVlJ11cbiAgICAgIH0sXG4gICAgICBmb250V2VpZ2h0OiB7XG4gICAgICAgIGVudW1zOiBbJ25vcm1hbCcsICdib2xkJywgJ2JvbGRlcicsICdsaWdodGVyJywgJzEwMCcsICcyMDAnLCAnMzAwJywgJzQwMCcsICc1MDAnLCAnNjAwJywgJzgwMCcsICc5MDAnLCAxMDAsIDIwMCwgMzAwLCA0MDAsIDUwMCwgNjAwLCA3MDAsIDgwMCwgOTAwXVxuICAgICAgfSxcbiAgICAgIHRleHREZWNvcmF0aW9uOiB7XG4gICAgICAgIGVudW1zOiBbJ25vbmUnLCAndW5kZXJsaW5lJywgJ292ZXJsaW5lJywgJ2xpbmUtdGhyb3VnaCddXG4gICAgICB9LFxuICAgICAgdGV4dFRyYW5zZm9ybToge1xuICAgICAgICBlbnVtczogWydub25lJywgJ3VwcGVyY2FzZScsICdsb3dlcmNhc2UnXVxuICAgICAgfSxcbiAgICAgIHRleHRXcmFwOiB7XG4gICAgICAgIGVudW1zOiBbJ25vbmUnLCAnd3JhcCcsICdlbGxpcHNpcyddXG4gICAgICB9LFxuICAgICAgdGV4dE92ZXJmbG93V3JhcDoge1xuICAgICAgICBlbnVtczogWyd3aGl0ZXNwYWNlJywgJ2FueXdoZXJlJ11cbiAgICAgIH0sXG4gICAgICB0ZXh0QmFja2dyb3VuZFNoYXBlOiB7XG4gICAgICAgIGVudW1zOiBbJ3JlY3RhbmdsZScsICdyb3VuZHJlY3RhbmdsZScsICdyb3VuZC1yZWN0YW5nbGUnXVxuICAgICAgfSxcbiAgICAgIG5vZGVTaGFwZToge1xuICAgICAgICBlbnVtczogWydyZWN0YW5nbGUnLCAncm91bmRyZWN0YW5nbGUnLCAncm91bmQtcmVjdGFuZ2xlJywgJ2N1dHJlY3RhbmdsZScsICdjdXQtcmVjdGFuZ2xlJywgJ2JvdHRvbXJvdW5kcmVjdGFuZ2xlJywgJ2JvdHRvbS1yb3VuZC1yZWN0YW5nbGUnLCAnYmFycmVsJywgJ2VsbGlwc2UnLCAndHJpYW5nbGUnLCAncm91bmQtdHJpYW5nbGUnLCAnc3F1YXJlJywgJ3BlbnRhZ29uJywgJ3JvdW5kLXBlbnRhZ29uJywgJ2hleGFnb24nLCAncm91bmQtaGV4YWdvbicsICdjb25jYXZlaGV4YWdvbicsICdjb25jYXZlLWhleGFnb24nLCAnaGVwdGFnb24nLCAncm91bmQtaGVwdGFnb24nLCAnb2N0YWdvbicsICdyb3VuZC1vY3RhZ29uJywgJ3RhZycsICdyb3VuZC10YWcnLCAnc3RhcicsICdkaWFtb25kJywgJ3JvdW5kLWRpYW1vbmQnLCAndmVlJywgJ3Job21ib2lkJywgJ3BvbHlnb24nXVxuICAgICAgfSxcbiAgICAgIG92ZXJsYXlTaGFwZToge1xuICAgICAgICBlbnVtczogWydyb3VuZHJlY3RhbmdsZScsICdyb3VuZC1yZWN0YW5nbGUnLCAnZWxsaXBzZSddXG4gICAgICB9LFxuICAgICAgY29tcG91bmRJbmNsdWRlTGFiZWxzOiB7XG4gICAgICAgIGVudW1zOiBbJ2luY2x1ZGUnLCAnZXhjbHVkZSddXG4gICAgICB9LFxuICAgICAgYXJyb3dTaGFwZToge1xuICAgICAgICBlbnVtczogWyd0ZWUnLCAndHJpYW5nbGUnLCAndHJpYW5nbGUtdGVlJywgJ2NpcmNsZS10cmlhbmdsZScsICd0cmlhbmdsZS1jcm9zcycsICd0cmlhbmdsZS1iYWNrY3VydmUnLCAndmVlJywgJ3NxdWFyZScsICdjaXJjbGUnLCAnZGlhbW9uZCcsICdjaGV2cm9uJywgJ25vbmUnXVxuICAgICAgfSxcbiAgICAgIGFycm93RmlsbDoge1xuICAgICAgICBlbnVtczogWydmaWxsZWQnLCAnaG9sbG93J11cbiAgICAgIH0sXG4gICAgICBkaXNwbGF5OiB7XG4gICAgICAgIGVudW1zOiBbJ2VsZW1lbnQnLCAnbm9uZSddXG4gICAgICB9LFxuICAgICAgdmlzaWJpbGl0eToge1xuICAgICAgICBlbnVtczogWydoaWRkZW4nLCAndmlzaWJsZSddXG4gICAgICB9LFxuICAgICAgekNvbXBvdW5kRGVwdGg6IHtcbiAgICAgICAgZW51bXM6IFsnYm90dG9tJywgJ29ycGhhbicsICdhdXRvJywgJ3RvcCddXG4gICAgICB9LFxuICAgICAgekluZGV4Q29tcGFyZToge1xuICAgICAgICBlbnVtczogWydhdXRvJywgJ21hbnVhbCddXG4gICAgICB9LFxuICAgICAgdmFsaWduOiB7XG4gICAgICAgIGVudW1zOiBbJ3RvcCcsICdjZW50ZXInLCAnYm90dG9tJ11cbiAgICAgIH0sXG4gICAgICBoYWxpZ246IHtcbiAgICAgICAgZW51bXM6IFsnbGVmdCcsICdjZW50ZXInLCAncmlnaHQnXVxuICAgICAgfSxcbiAgICAgIGp1c3RpZmljYXRpb246IHtcbiAgICAgICAgZW51bXM6IFsnbGVmdCcsICdjZW50ZXInLCAncmlnaHQnLCAnYXV0byddXG4gICAgICB9LFxuICAgICAgdGV4dDoge1xuICAgICAgICBzdHJpbmc6IHRydWVcbiAgICAgIH0sXG4gICAgICBkYXRhOiB7XG4gICAgICAgIG1hcHBpbmc6IHRydWUsXG4gICAgICAgIHJlZ2V4OiBkYXRhKCdkYXRhJylcbiAgICAgIH0sXG4gICAgICBsYXlvdXREYXRhOiB7XG4gICAgICAgIG1hcHBpbmc6IHRydWUsXG4gICAgICAgIHJlZ2V4OiBkYXRhKCdsYXlvdXREYXRhJylcbiAgICAgIH0sXG4gICAgICBzY3JhdGNoOiB7XG4gICAgICAgIG1hcHBpbmc6IHRydWUsXG4gICAgICAgIHJlZ2V4OiBkYXRhKCdzY3JhdGNoJylcbiAgICAgIH0sXG4gICAgICBtYXBEYXRhOiB7XG4gICAgICAgIG1hcHBpbmc6IHRydWUsXG4gICAgICAgIHJlZ2V4OiBtYXBEYXRhKCdtYXBEYXRhJylcbiAgICAgIH0sXG4gICAgICBtYXBMYXlvdXREYXRhOiB7XG4gICAgICAgIG1hcHBpbmc6IHRydWUsXG4gICAgICAgIHJlZ2V4OiBtYXBEYXRhKCdtYXBMYXlvdXREYXRhJylcbiAgICAgIH0sXG4gICAgICBtYXBTY3JhdGNoOiB7XG4gICAgICAgIG1hcHBpbmc6IHRydWUsXG4gICAgICAgIHJlZ2V4OiBtYXBEYXRhKCdtYXBTY3JhdGNoJylcbiAgICAgIH0sXG4gICAgICBmbjoge1xuICAgICAgICBtYXBwaW5nOiB0cnVlLFxuICAgICAgICBmbjogdHJ1ZVxuICAgICAgfSxcbiAgICAgIHVybDoge1xuICAgICAgICByZWdleGVzOiB1cmxSZWdleGVzLFxuICAgICAgICBzaW5nbGVSZWdleE1hdGNoVmFsdWU6IHRydWVcbiAgICAgIH0sXG4gICAgICB1cmxzOiB7XG4gICAgICAgIHJlZ2V4ZXM6IHVybFJlZ2V4ZXMsXG4gICAgICAgIHNpbmdsZVJlZ2V4TWF0Y2hWYWx1ZTogdHJ1ZSxcbiAgICAgICAgbXVsdGlwbGU6IHRydWVcbiAgICAgIH0sXG4gICAgICBwcm9wTGlzdDoge1xuICAgICAgICBwcm9wTGlzdDogdHJ1ZVxuICAgICAgfSxcbiAgICAgIGFuZ2xlOiB7XG4gICAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgICAgdW5pdHM6ICdkZWd8cmFkJyxcbiAgICAgICAgaW1wbGljaXRVbml0czogJ3JhZCdcbiAgICAgIH0sXG4gICAgICB0ZXh0Um90YXRpb246IHtcbiAgICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgICB1bml0czogJ2RlZ3xyYWQnLFxuICAgICAgICBpbXBsaWNpdFVuaXRzOiAncmFkJyxcbiAgICAgICAgZW51bXM6IFsnbm9uZScsICdhdXRvcm90YXRlJ11cbiAgICAgIH0sXG4gICAgICBwb2x5Z29uUG9pbnRMaXN0OiB7XG4gICAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgICAgbXVsdGlwbGU6IHRydWUsXG4gICAgICAgIGV2ZW5NdWx0aXBsZTogdHJ1ZSxcbiAgICAgICAgbWluOiAtMSxcbiAgICAgICAgbWF4OiAxLFxuICAgICAgICB1bml0bGVzczogdHJ1ZVxuICAgICAgfSxcbiAgICAgIGVkZ2VEaXN0YW5jZXM6IHtcbiAgICAgICAgZW51bXM6IFsnaW50ZXJzZWN0aW9uJywgJ25vZGUtcG9zaXRpb24nXVxuICAgICAgfSxcbiAgICAgIGVkZ2VFbmRwb2ludDoge1xuICAgICAgICBudW1iZXI6IHRydWUsXG4gICAgICAgIG11bHRpcGxlOiB0cnVlLFxuICAgICAgICB1bml0czogJyV8cHh8ZW18ZGVnfHJhZCcsXG4gICAgICAgIGltcGxpY2l0VW5pdHM6ICdweCcsXG4gICAgICAgIGVudW1zOiBbJ2luc2lkZS10by1ub2RlJywgJ291dHNpZGUtdG8tbm9kZScsICdvdXRzaWRlLXRvLW5vZGUtb3ItbGFiZWwnLCAnb3V0c2lkZS10by1saW5lJywgJ291dHNpZGUtdG8tbGluZS1vci1sYWJlbCddLFxuICAgICAgICBzaW5nbGVFbnVtOiB0cnVlLFxuICAgICAgICB2YWxpZGF0ZTogZnVuY3Rpb24gdmFsaWRhdGUodmFsQXJyLCB1bml0c0Fycikge1xuICAgICAgICAgIHN3aXRjaCAodmFsQXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAvLyBjYW4gYmUgJSBvciBweCBvbmx5XG4gICAgICAgICAgICAgIHJldHVybiB1bml0c0FyclswXSAhPT0gJ2RlZycgJiYgdW5pdHNBcnJbMF0gIT09ICdyYWQnICYmIHVuaXRzQXJyWzFdICE9PSAnZGVnJyAmJiB1bml0c0FyclsxXSAhPT0gJ3JhZCc7XG5cbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgLy8gY2FuIGJlIGVudW0sIGRlZywgb3IgcmFkIG9ubHlcbiAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZyh2YWxBcnJbMF0pIHx8IHVuaXRzQXJyWzBdID09PSAnZGVnJyB8fCB1bml0c0FyclswXSA9PT0gJ3JhZCc7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBlYXNpbmc6IHtcbiAgICAgICAgcmVnZXhlczogWydeKHNwcmluZylcXFxccypcXFxcKFxcXFxzKignICsgbnVtYmVyJDEgKyAnKVxcXFxzKixcXFxccyooJyArIG51bWJlciQxICsgJylcXFxccypcXFxcKSQnLCAnXihjdWJpYy1iZXppZXIpXFxcXHMqXFxcXChcXFxccyooJyArIG51bWJlciQxICsgJylcXFxccyosXFxcXHMqKCcgKyBudW1iZXIkMSArICcpXFxcXHMqLFxcXFxzKignICsgbnVtYmVyJDEgKyAnKVxcXFxzKixcXFxccyooJyArIG51bWJlciQxICsgJylcXFxccypcXFxcKSQnXSxcbiAgICAgICAgZW51bXM6IFsnbGluZWFyJywgJ2Vhc2UnLCAnZWFzZS1pbicsICdlYXNlLW91dCcsICdlYXNlLWluLW91dCcsICdlYXNlLWluLXNpbmUnLCAnZWFzZS1vdXQtc2luZScsICdlYXNlLWluLW91dC1zaW5lJywgJ2Vhc2UtaW4tcXVhZCcsICdlYXNlLW91dC1xdWFkJywgJ2Vhc2UtaW4tb3V0LXF1YWQnLCAnZWFzZS1pbi1jdWJpYycsICdlYXNlLW91dC1jdWJpYycsICdlYXNlLWluLW91dC1jdWJpYycsICdlYXNlLWluLXF1YXJ0JywgJ2Vhc2Utb3V0LXF1YXJ0JywgJ2Vhc2UtaW4tb3V0LXF1YXJ0JywgJ2Vhc2UtaW4tcXVpbnQnLCAnZWFzZS1vdXQtcXVpbnQnLCAnZWFzZS1pbi1vdXQtcXVpbnQnLCAnZWFzZS1pbi1leHBvJywgJ2Vhc2Utb3V0LWV4cG8nLCAnZWFzZS1pbi1vdXQtZXhwbycsICdlYXNlLWluLWNpcmMnLCAnZWFzZS1vdXQtY2lyYycsICdlYXNlLWluLW91dC1jaXJjJ11cbiAgICAgIH0sXG4gICAgICBncmFkaWVudERpcmVjdGlvbjoge1xuICAgICAgICBlbnVtczogWyd0by1ib3R0b20nLCAndG8tdG9wJywgJ3RvLWxlZnQnLCAndG8tcmlnaHQnLCAndG8tYm90dG9tLXJpZ2h0JywgJ3RvLWJvdHRvbS1sZWZ0JywgJ3RvLXRvcC1yaWdodCcsICd0by10b3AtbGVmdCcsICd0by1yaWdodC1ib3R0b20nLCAndG8tbGVmdC1ib3R0b20nLCAndG8tcmlnaHQtdG9wJywgJ3RvLWxlZnQtdG9wJyAvLyBkaWZmZXJlbnQgb3JkZXJcbiAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIGJvdW5kc0V4cGFuc2lvbjoge1xuICAgICAgICBudW1iZXI6IHRydWUsXG4gICAgICAgIG11bHRpcGxlOiB0cnVlLFxuICAgICAgICBtaW46IDAsXG4gICAgICAgIHZhbGlkYXRlOiBmdW5jdGlvbiB2YWxpZGF0ZSh2YWxBcnIpIHtcbiAgICAgICAgICB2YXIgbGVuZ3RoID0gdmFsQXJyLmxlbmd0aDtcbiAgICAgICAgICByZXR1cm4gbGVuZ3RoID09PSAxIHx8IGxlbmd0aCA9PT0gMiB8fCBsZW5ndGggPT09IDQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBkaWZmID0ge1xuICAgICAgemVyb05vblplcm86IGZ1bmN0aW9uIHplcm9Ob25aZXJvKHZhbDEsIHZhbDIpIHtcbiAgICAgICAgaWYgKCh2YWwxID09IG51bGwgfHwgdmFsMiA9PSBudWxsKSAmJiB2YWwxICE9PSB2YWwyKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7IC8vIG51bGwgY2FzZXMgY291bGQgcmVwcmVzZW50IGFueSB2YWx1ZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbDEgPT0gMCAmJiB2YWwyICE9IDApIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWwxICE9IDAgJiYgdmFsMiA9PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYW55OiBmdW5jdGlvbiBhbnkodmFsMSwgdmFsMikge1xuICAgICAgICByZXR1cm4gdmFsMSAhPSB2YWwyO1xuICAgICAgfSxcbiAgICAgIGVtcHR5Tm9uRW1wdHk6IGZ1bmN0aW9uIGVtcHR5Tm9uRW1wdHkoc3RyMSwgc3RyMikge1xuICAgICAgICB2YXIgZW1wdHkxID0gZW1wdHlTdHJpbmcoc3RyMSk7XG4gICAgICAgIHZhciBlbXB0eTIgPSBlbXB0eVN0cmluZyhzdHIyKTtcbiAgICAgICAgcmV0dXJuIGVtcHR5MSAmJiAhZW1wdHkyIHx8ICFlbXB0eTEgJiYgZW1wdHkyO1xuICAgICAgfVxuICAgIH07IC8vIGRlZmluZSB2aXN1YWwgc3R5bGUgcHJvcGVydGllc1xuICAgIC8vXG4gICAgLy8gLSBuLmIuIGFkZGluZyBhIG5ldyBncm91cCBvZiBwcm9wcyBtYXkgcmVxdWlyZSB1cGRhdGVzIHRvIHVwZGF0ZVN0eWxlSGludHMoKVxuICAgIC8vIC0gYWRkaW5nIG5ldyBwcm9wcyB0byBhbiBleGlzdGluZyBncm91cCBnZXRzIGhhbmRsZWQgYXV0b21hdGljYWxseVxuXG4gICAgdmFyIHQgPSBzdHlmbiQyLnR5cGVzO1xuICAgIHZhciBtYWluTGFiZWwgPSBbe1xuICAgICAgbmFtZTogJ2xhYmVsJyxcbiAgICAgIHR5cGU6IHQudGV4dCxcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueSxcbiAgICAgIHRyaWdnZXJzWk9yZGVyOiBkaWZmLmVtcHR5Tm9uRW1wdHlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAndGV4dC1yb3RhdGlvbicsXG4gICAgICB0eXBlOiB0LnRleHRSb3RhdGlvbixcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICd0ZXh0LW1hcmdpbi14JyxcbiAgICAgIHR5cGU6IHQuYmlkaXJlY3Rpb25hbFNpemUsXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAndGV4dC1tYXJnaW4teScsXG4gICAgICB0eXBlOiB0LmJpZGlyZWN0aW9uYWxTaXplLFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfV07XG4gICAgdmFyIHNvdXJjZUxhYmVsID0gW3tcbiAgICAgIG5hbWU6ICdzb3VyY2UtbGFiZWwnLFxuICAgICAgdHlwZTogdC50ZXh0LFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfSwge1xuICAgICAgbmFtZTogJ3NvdXJjZS10ZXh0LXJvdGF0aW9uJyxcbiAgICAgIHR5cGU6IHQudGV4dFJvdGF0aW9uLFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfSwge1xuICAgICAgbmFtZTogJ3NvdXJjZS10ZXh0LW1hcmdpbi14JyxcbiAgICAgIHR5cGU6IHQuYmlkaXJlY3Rpb25hbFNpemUsXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnc291cmNlLXRleHQtbWFyZ2luLXknLFxuICAgICAgdHlwZTogdC5iaWRpcmVjdGlvbmFsU2l6ZSxcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdzb3VyY2UtdGV4dC1vZmZzZXQnLFxuICAgICAgdHlwZTogdC5zaXplLFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfV07XG4gICAgdmFyIHRhcmdldExhYmVsID0gW3tcbiAgICAgIG5hbWU6ICd0YXJnZXQtbGFiZWwnLFxuICAgICAgdHlwZTogdC50ZXh0LFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfSwge1xuICAgICAgbmFtZTogJ3RhcmdldC10ZXh0LXJvdGF0aW9uJyxcbiAgICAgIHR5cGU6IHQudGV4dFJvdGF0aW9uLFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfSwge1xuICAgICAgbmFtZTogJ3RhcmdldC10ZXh0LW1hcmdpbi14JyxcbiAgICAgIHR5cGU6IHQuYmlkaXJlY3Rpb25hbFNpemUsXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAndGFyZ2V0LXRleHQtbWFyZ2luLXknLFxuICAgICAgdHlwZTogdC5iaWRpcmVjdGlvbmFsU2l6ZSxcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICd0YXJnZXQtdGV4dC1vZmZzZXQnLFxuICAgICAgdHlwZTogdC5zaXplLFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfV07XG4gICAgdmFyIGxhYmVsRGltZW5zaW9ucyA9IFt7XG4gICAgICBuYW1lOiAnZm9udC1mYW1pbHknLFxuICAgICAgdHlwZTogdC5mb250RmFtaWx5LFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfSwge1xuICAgICAgbmFtZTogJ2ZvbnQtc3R5bGUnLFxuICAgICAgdHlwZTogdC5mb250U3R5bGUsXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnZm9udC13ZWlnaHQnLFxuICAgICAgdHlwZTogdC5mb250V2VpZ2h0LFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfSwge1xuICAgICAgbmFtZTogJ2ZvbnQtc2l6ZScsXG4gICAgICB0eXBlOiB0LnNpemUsXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAndGV4dC10cmFuc2Zvcm0nLFxuICAgICAgdHlwZTogdC50ZXh0VHJhbnNmb3JtLFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfSwge1xuICAgICAgbmFtZTogJ3RleHQtd3JhcCcsXG4gICAgICB0eXBlOiB0LnRleHRXcmFwLFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfSwge1xuICAgICAgbmFtZTogJ3RleHQtb3ZlcmZsb3ctd3JhcCcsXG4gICAgICB0eXBlOiB0LnRleHRPdmVyZmxvd1dyYXAsXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAndGV4dC1tYXgtd2lkdGgnLFxuICAgICAgdHlwZTogdC5zaXplLFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfSwge1xuICAgICAgbmFtZTogJ3RleHQtb3V0bGluZS13aWR0aCcsXG4gICAgICB0eXBlOiB0LnNpemUsXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnbGluZS1oZWlnaHQnLFxuICAgICAgdHlwZTogdC5wb3NpdGl2ZU51bWJlcixcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH1dO1xuICAgIHZhciBjb21tb25MYWJlbCA9IFt7XG4gICAgICBuYW1lOiAndGV4dC12YWxpZ24nLFxuICAgICAgdHlwZTogdC52YWxpZ24sXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAndGV4dC1oYWxpZ24nLFxuICAgICAgdHlwZTogdC5oYWxpZ24sXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnY29sb3InLFxuICAgICAgdHlwZTogdC5jb2xvclxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICd0ZXh0LW91dGxpbmUtY29sb3InLFxuICAgICAgdHlwZTogdC5jb2xvclxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICd0ZXh0LW91dGxpbmUtb3BhY2l0eScsXG4gICAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXJcbiAgICB9LCB7XG4gICAgICBuYW1lOiAndGV4dC1iYWNrZ3JvdW5kLWNvbG9yJyxcbiAgICAgIHR5cGU6IHQuY29sb3JcbiAgICB9LCB7XG4gICAgICBuYW1lOiAndGV4dC1iYWNrZ3JvdW5kLW9wYWNpdHknLFxuICAgICAgdHlwZTogdC56ZXJvT25lTnVtYmVyXG4gICAgfSwge1xuICAgICAgbmFtZTogJ3RleHQtYmFja2dyb3VuZC1wYWRkaW5nJyxcbiAgICAgIHR5cGU6IHQuc2l6ZSxcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICd0ZXh0LWJvcmRlci1vcGFjaXR5JyxcbiAgICAgIHR5cGU6IHQuemVyb09uZU51bWJlclxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICd0ZXh0LWJvcmRlci1jb2xvcicsXG4gICAgICB0eXBlOiB0LmNvbG9yXG4gICAgfSwge1xuICAgICAgbmFtZTogJ3RleHQtYm9yZGVyLXdpZHRoJyxcbiAgICAgIHR5cGU6IHQuc2l6ZSxcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICd0ZXh0LWJvcmRlci1zdHlsZScsXG4gICAgICB0eXBlOiB0LmJvcmRlclN0eWxlLFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfSwge1xuICAgICAgbmFtZTogJ3RleHQtYmFja2dyb3VuZC1zaGFwZScsXG4gICAgICB0eXBlOiB0LnRleHRCYWNrZ3JvdW5kU2hhcGUsXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAndGV4dC1qdXN0aWZpY2F0aW9uJyxcbiAgICAgIHR5cGU6IHQuanVzdGlmaWNhdGlvblxuICAgIH1dO1xuICAgIHZhciBiZWhhdmlvciA9IFt7XG4gICAgICBuYW1lOiAnZXZlbnRzJyxcbiAgICAgIHR5cGU6IHQuYm9vbFxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICd0ZXh0LWV2ZW50cycsXG4gICAgICB0eXBlOiB0LmJvb2xcbiAgICB9XTtcbiAgICB2YXIgdmlzaWJpbGl0eSA9IFt7XG4gICAgICBuYW1lOiAnZGlzcGxheScsXG4gICAgICB0eXBlOiB0LmRpc3BsYXksXG4gICAgICB0cmlnZ2Vyc1pPcmRlcjogZGlmZi5hbnksXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnksXG4gICAgICB0cmlnZ2Vyc0JvdW5kc09mUGFyYWxsZWxCZXppZXJzOiB0cnVlXG4gICAgfSwge1xuICAgICAgbmFtZTogJ3Zpc2liaWxpdHknLFxuICAgICAgdHlwZTogdC52aXNpYmlsaXR5LFxuICAgICAgdHJpZ2dlcnNaT3JkZXI6IGRpZmYuYW55XG4gICAgfSwge1xuICAgICAgbmFtZTogJ29wYWNpdHknLFxuICAgICAgdHlwZTogdC56ZXJvT25lTnVtYmVyLFxuICAgICAgdHJpZ2dlcnNaT3JkZXI6IGRpZmYuemVyb05vblplcm9cbiAgICB9LCB7XG4gICAgICBuYW1lOiAndGV4dC1vcGFjaXR5JyxcbiAgICAgIHR5cGU6IHQuemVyb09uZU51bWJlclxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdtaW4tem9vbWVkLWZvbnQtc2l6ZScsXG4gICAgICB0eXBlOiB0LnNpemVcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnei1jb21wb3VuZC1kZXB0aCcsXG4gICAgICB0eXBlOiB0LnpDb21wb3VuZERlcHRoLFxuICAgICAgdHJpZ2dlcnNaT3JkZXI6IGRpZmYuYW55XG4gICAgfSwge1xuICAgICAgbmFtZTogJ3otaW5kZXgtY29tcGFyZScsXG4gICAgICB0eXBlOiB0LnpJbmRleENvbXBhcmUsXG4gICAgICB0cmlnZ2Vyc1pPcmRlcjogZGlmZi5hbnlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnei1pbmRleCcsXG4gICAgICB0eXBlOiB0Lm5vbk5lZ2F0aXZlSW50LFxuICAgICAgdHJpZ2dlcnNaT3JkZXI6IGRpZmYuYW55XG4gICAgfV07XG4gICAgdmFyIG92ZXJsYXkgPSBbe1xuICAgICAgbmFtZTogJ292ZXJsYXktcGFkZGluZycsXG4gICAgICB0eXBlOiB0LnNpemUsXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnb3ZlcmxheS1jb2xvcicsXG4gICAgICB0eXBlOiB0LmNvbG9yXG4gICAgfSwge1xuICAgICAgbmFtZTogJ292ZXJsYXktb3BhY2l0eScsXG4gICAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXIsXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi56ZXJvTm9uWmVyb1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdvdmVybGF5LXNoYXBlJyxcbiAgICAgIHR5cGU6IHQub3ZlcmxheVNoYXBlLFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfV07XG4gICAgdmFyIHVuZGVybGF5ID0gW3tcbiAgICAgIG5hbWU6ICd1bmRlcmxheS1wYWRkaW5nJyxcbiAgICAgIHR5cGU6IHQuc2l6ZSxcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICd1bmRlcmxheS1jb2xvcicsXG4gICAgICB0eXBlOiB0LmNvbG9yXG4gICAgfSwge1xuICAgICAgbmFtZTogJ3VuZGVybGF5LW9wYWNpdHknLFxuICAgICAgdHlwZTogdC56ZXJvT25lTnVtYmVyLFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuemVyb05vblplcm9cbiAgICB9LCB7XG4gICAgICBuYW1lOiAndW5kZXJsYXktc2hhcGUnLFxuICAgICAgdHlwZTogdC5vdmVybGF5U2hhcGUsXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9XTtcbiAgICB2YXIgdHJhbnNpdGlvbiA9IFt7XG4gICAgICBuYW1lOiAndHJhbnNpdGlvbi1wcm9wZXJ0eScsXG4gICAgICB0eXBlOiB0LnByb3BMaXN0XG4gICAgfSwge1xuICAgICAgbmFtZTogJ3RyYW5zaXRpb24tZHVyYXRpb24nLFxuICAgICAgdHlwZTogdC50aW1lXG4gICAgfSwge1xuICAgICAgbmFtZTogJ3RyYW5zaXRpb24tZGVsYXknLFxuICAgICAgdHlwZTogdC50aW1lXG4gICAgfSwge1xuICAgICAgbmFtZTogJ3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uJyxcbiAgICAgIHR5cGU6IHQuZWFzaW5nXG4gICAgfV07XG5cbiAgICB2YXIgbm9kZVNpemVIYXNoT3ZlcnJpZGUgPSBmdW5jdGlvbiBub2RlU2l6ZUhhc2hPdmVycmlkZShlbGUsIHBhcnNlZFByb3ApIHtcbiAgICAgIGlmIChwYXJzZWRQcm9wLnZhbHVlID09PSAnbGFiZWwnKSB7XG4gICAgICAgIHJldHVybiAtZWxlLnBvb2xJbmRleCgpOyAvLyBubyBoYXNoIGtleSBoaXRzIGlzIHVzaW5nIGxhYmVsIHNpemUgKGhpdHJhdGUgZm9yIHBlcmYgcHJvYmFibHkgbG93IGFueXdheSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwYXJzZWRQcm9wLnBmVmFsdWU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBub2RlQm9keSA9IFt7XG4gICAgICBuYW1lOiAnaGVpZ2h0JyxcbiAgICAgIHR5cGU6IHQubm9kZVNpemUsXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnksXG4gICAgICBoYXNoT3ZlcnJpZGU6IG5vZGVTaXplSGFzaE92ZXJyaWRlXG4gICAgfSwge1xuICAgICAgbmFtZTogJ3dpZHRoJyxcbiAgICAgIHR5cGU6IHQubm9kZVNpemUsXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnksXG4gICAgICBoYXNoT3ZlcnJpZGU6IG5vZGVTaXplSGFzaE92ZXJyaWRlXG4gICAgfSwge1xuICAgICAgbmFtZTogJ3NoYXBlJyxcbiAgICAgIHR5cGU6IHQubm9kZVNoYXBlLFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfSwge1xuICAgICAgbmFtZTogJ3NoYXBlLXBvbHlnb24tcG9pbnRzJyxcbiAgICAgIHR5cGU6IHQucG9seWdvblBvaW50TGlzdCxcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdiYWNrZ3JvdW5kLWNvbG9yJyxcbiAgICAgIHR5cGU6IHQuY29sb3JcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnYmFja2dyb3VuZC1maWxsJyxcbiAgICAgIHR5cGU6IHQuZmlsbFxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdiYWNrZ3JvdW5kLW9wYWNpdHknLFxuICAgICAgdHlwZTogdC56ZXJvT25lTnVtYmVyXG4gICAgfSwge1xuICAgICAgbmFtZTogJ2JhY2tncm91bmQtYmxhY2tlbicsXG4gICAgICB0eXBlOiB0Lm5PbmVPbmVOdW1iZXJcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnYmFja2dyb3VuZC1ncmFkaWVudC1zdG9wLWNvbG9ycycsXG4gICAgICB0eXBlOiB0LmNvbG9yc1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdiYWNrZ3JvdW5kLWdyYWRpZW50LXN0b3AtcG9zaXRpb25zJyxcbiAgICAgIHR5cGU6IHQucGVyY2VudGFnZXNcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnYmFja2dyb3VuZC1ncmFkaWVudC1kaXJlY3Rpb24nLFxuICAgICAgdHlwZTogdC5ncmFkaWVudERpcmVjdGlvblxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdwYWRkaW5nJyxcbiAgICAgIHR5cGU6IHQuc2l6ZU1heWJlUGVyY2VudCxcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdwYWRkaW5nLXJlbGF0aXZlLXRvJyxcbiAgICAgIHR5cGU6IHQucGFkZGluZ1JlbGF0aXZlVG8sXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnYm91bmRzLWV4cGFuc2lvbicsXG4gICAgICB0eXBlOiB0LmJvdW5kc0V4cGFuc2lvbixcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH1dO1xuICAgIHZhciBub2RlQm9yZGVyID0gW3tcbiAgICAgIG5hbWU6ICdib3JkZXItY29sb3InLFxuICAgICAgdHlwZTogdC5jb2xvclxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdib3JkZXItb3BhY2l0eScsXG4gICAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXJcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnYm9yZGVyLXdpZHRoJyxcbiAgICAgIHR5cGU6IHQuc2l6ZSxcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdib3JkZXItc3R5bGUnLFxuICAgICAgdHlwZTogdC5ib3JkZXJTdHlsZVxuICAgIH1dO1xuICAgIHZhciBiYWNrZ3JvdW5kSW1hZ2UgPSBbe1xuICAgICAgbmFtZTogJ2JhY2tncm91bmQtaW1hZ2UnLFxuICAgICAgdHlwZTogdC51cmxzXG4gICAgfSwge1xuICAgICAgbmFtZTogJ2JhY2tncm91bmQtaW1hZ2UtY3Jvc3NvcmlnaW4nLFxuICAgICAgdHlwZTogdC5iZ0Nyb3NzT3JpZ2luXG4gICAgfSwge1xuICAgICAgbmFtZTogJ2JhY2tncm91bmQtaW1hZ2Utb3BhY2l0eScsXG4gICAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXJzXG4gICAgfSwge1xuICAgICAgbmFtZTogJ2JhY2tncm91bmQtaW1hZ2UtY29udGFpbm1lbnQnLFxuICAgICAgdHlwZTogdC5iZ0NvbnRhaW5tZW50XG4gICAgfSwge1xuICAgICAgbmFtZTogJ2JhY2tncm91bmQtaW1hZ2Utc21vb3RoaW5nJyxcbiAgICAgIHR5cGU6IHQuYm9vbHNcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnYmFja2dyb3VuZC1wb3NpdGlvbi14JyxcbiAgICAgIHR5cGU6IHQuYmdQb3NcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnYmFja2dyb3VuZC1wb3NpdGlvbi15JyxcbiAgICAgIHR5cGU6IHQuYmdQb3NcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnYmFja2dyb3VuZC13aWR0aC1yZWxhdGl2ZS10bycsXG4gICAgICB0eXBlOiB0LmJnUmVsYXRpdmVUb1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdiYWNrZ3JvdW5kLWhlaWdodC1yZWxhdGl2ZS10bycsXG4gICAgICB0eXBlOiB0LmJnUmVsYXRpdmVUb1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdiYWNrZ3JvdW5kLXJlcGVhdCcsXG4gICAgICB0eXBlOiB0LmJnUmVwZWF0XG4gICAgfSwge1xuICAgICAgbmFtZTogJ2JhY2tncm91bmQtZml0JyxcbiAgICAgIHR5cGU6IHQuYmdGaXRcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnYmFja2dyb3VuZC1jbGlwJyxcbiAgICAgIHR5cGU6IHQuYmdDbGlwXG4gICAgfSwge1xuICAgICAgbmFtZTogJ2JhY2tncm91bmQtd2lkdGgnLFxuICAgICAgdHlwZTogdC5iZ1dIXG4gICAgfSwge1xuICAgICAgbmFtZTogJ2JhY2tncm91bmQtaGVpZ2h0JyxcbiAgICAgIHR5cGU6IHQuYmdXSFxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdiYWNrZ3JvdW5kLW9mZnNldC14JyxcbiAgICAgIHR5cGU6IHQuYmdQb3NcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnYmFja2dyb3VuZC1vZmZzZXQteScsXG4gICAgICB0eXBlOiB0LmJnUG9zXG4gICAgfV07XG4gICAgdmFyIGNvbXBvdW5kID0gW3tcbiAgICAgIG5hbWU6ICdwb3NpdGlvbicsXG4gICAgICB0eXBlOiB0LnBvc2l0aW9uLFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfSwge1xuICAgICAgbmFtZTogJ2NvbXBvdW5kLXNpemluZy13cnQtbGFiZWxzJyxcbiAgICAgIHR5cGU6IHQuY29tcG91bmRJbmNsdWRlTGFiZWxzLFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfSwge1xuICAgICAgbmFtZTogJ21pbi13aWR0aCcsXG4gICAgICB0eXBlOiB0LnNpemUsXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnbWluLXdpZHRoLWJpYXMtbGVmdCcsXG4gICAgICB0eXBlOiB0LnNpemVNYXliZVBlcmNlbnQsXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnbWluLXdpZHRoLWJpYXMtcmlnaHQnLFxuICAgICAgdHlwZTogdC5zaXplTWF5YmVQZXJjZW50LFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfSwge1xuICAgICAgbmFtZTogJ21pbi1oZWlnaHQnLFxuICAgICAgdHlwZTogdC5zaXplLFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfSwge1xuICAgICAgbmFtZTogJ21pbi1oZWlnaHQtYmlhcy10b3AnLFxuICAgICAgdHlwZTogdC5zaXplTWF5YmVQZXJjZW50LFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfSwge1xuICAgICAgbmFtZTogJ21pbi1oZWlnaHQtYmlhcy1ib3R0b20nLFxuICAgICAgdHlwZTogdC5zaXplTWF5YmVQZXJjZW50LFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfV07XG4gICAgdmFyIGVkZ2VMaW5lID0gW3tcbiAgICAgIG5hbWU6ICdsaW5lLXN0eWxlJyxcbiAgICAgIHR5cGU6IHQubGluZVN0eWxlXG4gICAgfSwge1xuICAgICAgbmFtZTogJ2xpbmUtY29sb3InLFxuICAgICAgdHlwZTogdC5jb2xvclxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdsaW5lLWZpbGwnLFxuICAgICAgdHlwZTogdC5maWxsXG4gICAgfSwge1xuICAgICAgbmFtZTogJ2xpbmUtY2FwJyxcbiAgICAgIHR5cGU6IHQubGluZUNhcFxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdsaW5lLW9wYWNpdHknLFxuICAgICAgdHlwZTogdC56ZXJvT25lTnVtYmVyXG4gICAgfSwge1xuICAgICAgbmFtZTogJ2xpbmUtZGFzaC1wYXR0ZXJuJyxcbiAgICAgIHR5cGU6IHQubnVtYmVyc1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdsaW5lLWRhc2gtb2Zmc2V0JyxcbiAgICAgIHR5cGU6IHQubnVtYmVyXG4gICAgfSwge1xuICAgICAgbmFtZTogJ2xpbmUtZ3JhZGllbnQtc3RvcC1jb2xvcnMnLFxuICAgICAgdHlwZTogdC5jb2xvcnNcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnbGluZS1ncmFkaWVudC1zdG9wLXBvc2l0aW9ucycsXG4gICAgICB0eXBlOiB0LnBlcmNlbnRhZ2VzXG4gICAgfSwge1xuICAgICAgbmFtZTogJ2N1cnZlLXN0eWxlJyxcbiAgICAgIHR5cGU6IHQuY3VydmVTdHlsZSxcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueSxcbiAgICAgIHRyaWdnZXJzQm91bmRzT2ZQYXJhbGxlbEJlemllcnM6IHRydWVcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnaGF5c3RhY2stcmFkaXVzJyxcbiAgICAgIHR5cGU6IHQuemVyb09uZU51bWJlcixcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdzb3VyY2UtZW5kcG9pbnQnLFxuICAgICAgdHlwZTogdC5lZGdlRW5kcG9pbnQsXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAndGFyZ2V0LWVuZHBvaW50JyxcbiAgICAgIHR5cGU6IHQuZWRnZUVuZHBvaW50LFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfSwge1xuICAgICAgbmFtZTogJ2NvbnRyb2wtcG9pbnQtc3RlcC1zaXplJyxcbiAgICAgIHR5cGU6IHQuc2l6ZSxcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdjb250cm9sLXBvaW50LWRpc3RhbmNlcycsXG4gICAgICB0eXBlOiB0LmJpZGlyZWN0aW9uYWxTaXplcyxcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdjb250cm9sLXBvaW50LXdlaWdodHMnLFxuICAgICAgdHlwZTogdC5udW1iZXJzLFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfSwge1xuICAgICAgbmFtZTogJ3NlZ21lbnQtZGlzdGFuY2VzJyxcbiAgICAgIHR5cGU6IHQuYmlkaXJlY3Rpb25hbFNpemVzLFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfSwge1xuICAgICAgbmFtZTogJ3NlZ21lbnQtd2VpZ2h0cycsXG4gICAgICB0eXBlOiB0Lm51bWJlcnMsXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAndGF4aS10dXJuJyxcbiAgICAgIHR5cGU6IHQuYmlkaXJlY3Rpb25hbFNpemVNYXliZVBlcmNlbnQsXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAndGF4aS10dXJuLW1pbi1kaXN0YW5jZScsXG4gICAgICB0eXBlOiB0LnNpemUsXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAndGF4aS1kaXJlY3Rpb24nLFxuICAgICAgdHlwZTogdC5heGlzRGlyZWN0aW9uLFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfSwge1xuICAgICAgbmFtZTogJ2VkZ2UtZGlzdGFuY2VzJyxcbiAgICAgIHR5cGU6IHQuZWRnZURpc3RhbmNlcyxcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdhcnJvdy1zY2FsZScsXG4gICAgICB0eXBlOiB0LnBvc2l0aXZlTnVtYmVyLFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfSwge1xuICAgICAgbmFtZTogJ2xvb3AtZGlyZWN0aW9uJyxcbiAgICAgIHR5cGU6IHQuYW5nbGUsXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnbG9vcC1zd2VlcCcsXG4gICAgICB0eXBlOiB0LmFuZ2xlLFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfSwge1xuICAgICAgbmFtZTogJ3NvdXJjZS1kaXN0YW5jZS1mcm9tLW5vZGUnLFxuICAgICAgdHlwZTogdC5zaXplLFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfSwge1xuICAgICAgbmFtZTogJ3RhcmdldC1kaXN0YW5jZS1mcm9tLW5vZGUnLFxuICAgICAgdHlwZTogdC5zaXplLFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfV07XG4gICAgdmFyIGdob3N0ID0gW3tcbiAgICAgIG5hbWU6ICdnaG9zdCcsXG4gICAgICB0eXBlOiB0LmJvb2wsXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnZ2hvc3Qtb2Zmc2V0LXgnLFxuICAgICAgdHlwZTogdC5iaWRpcmVjdGlvbmFsU2l6ZSxcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdnaG9zdC1vZmZzZXQteScsXG4gICAgICB0eXBlOiB0LmJpZGlyZWN0aW9uYWxTaXplLFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfSwge1xuICAgICAgbmFtZTogJ2dob3N0LW9wYWNpdHknLFxuICAgICAgdHlwZTogdC56ZXJvT25lTnVtYmVyXG4gICAgfV07XG4gICAgdmFyIGNvcmUgPSBbe1xuICAgICAgbmFtZTogJ3NlbGVjdGlvbi1ib3gtY29sb3InLFxuICAgICAgdHlwZTogdC5jb2xvclxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdzZWxlY3Rpb24tYm94LW9wYWNpdHknLFxuICAgICAgdHlwZTogdC56ZXJvT25lTnVtYmVyXG4gICAgfSwge1xuICAgICAgbmFtZTogJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLWNvbG9yJyxcbiAgICAgIHR5cGU6IHQuY29sb3JcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnc2VsZWN0aW9uLWJveC1ib3JkZXItd2lkdGgnLFxuICAgICAgdHlwZTogdC5zaXplXG4gICAgfSwge1xuICAgICAgbmFtZTogJ2FjdGl2ZS1iZy1jb2xvcicsXG4gICAgICB0eXBlOiB0LmNvbG9yXG4gICAgfSwge1xuICAgICAgbmFtZTogJ2FjdGl2ZS1iZy1vcGFjaXR5JyxcbiAgICAgIHR5cGU6IHQuemVyb09uZU51bWJlclxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdhY3RpdmUtYmctc2l6ZScsXG4gICAgICB0eXBlOiB0LnNpemVcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnb3V0c2lkZS10ZXh0dXJlLWJnLWNvbG9yJyxcbiAgICAgIHR5cGU6IHQuY29sb3JcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnb3V0c2lkZS10ZXh0dXJlLWJnLW9wYWNpdHknLFxuICAgICAgdHlwZTogdC56ZXJvT25lTnVtYmVyXG4gICAgfV07IC8vIHBpZSBiYWNrZ3JvdW5kcyBmb3Igbm9kZXNcblxuICAgIHZhciBwaWUgPSBbXTtcbiAgICBzdHlmbiQyLnBpZUJhY2tncm91bmROID0gMTY7IC8vIGJlY2F1c2UgdGhlIHBpZSBwcm9wZXJ0aWVzIGFyZSBudW1iZXJlZCwgZ2l2ZSBhY2Nlc3MgdG8gYSBjb25zdGFudCBOIChmb3IgcmVuZGVyZXIgdXNlKVxuXG4gICAgcGllLnB1c2goe1xuICAgICAgbmFtZTogJ3BpZS1zaXplJyxcbiAgICAgIHR5cGU6IHQuc2l6ZU1heWJlUGVyY2VudFxuICAgIH0pO1xuXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gc3R5Zm4kMi5waWVCYWNrZ3JvdW5kTjsgaSsrKSB7XG4gICAgICBwaWUucHVzaCh7XG4gICAgICAgIG5hbWU6ICdwaWUtJyArIGkgKyAnLWJhY2tncm91bmQtY29sb3InLFxuICAgICAgICB0eXBlOiB0LmNvbG9yXG4gICAgICB9KTtcbiAgICAgIHBpZS5wdXNoKHtcbiAgICAgICAgbmFtZTogJ3BpZS0nICsgaSArICctYmFja2dyb3VuZC1zaXplJyxcbiAgICAgICAgdHlwZTogdC5wZXJjZW50XG4gICAgICB9KTtcbiAgICAgIHBpZS5wdXNoKHtcbiAgICAgICAgbmFtZTogJ3BpZS0nICsgaSArICctYmFja2dyb3VuZC1vcGFjaXR5JyxcbiAgICAgICAgdHlwZTogdC56ZXJvT25lTnVtYmVyXG4gICAgICB9KTtcbiAgICB9IC8vIGVkZ2UgYXJyb3dzXG5cblxuICAgIHZhciBlZGdlQXJyb3cgPSBbXTtcbiAgICB2YXIgYXJyb3dQcmVmaXhlcyA9IHN0eWZuJDIuYXJyb3dQcmVmaXhlcyA9IFsnc291cmNlJywgJ21pZC1zb3VyY2UnLCAndGFyZ2V0JywgJ21pZC10YXJnZXQnXTtcbiAgICBbe1xuICAgICAgbmFtZTogJ2Fycm93LXNoYXBlJyxcbiAgICAgIHR5cGU6IHQuYXJyb3dTaGFwZSxcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdhcnJvdy1jb2xvcicsXG4gICAgICB0eXBlOiB0LmNvbG9yXG4gICAgfSwge1xuICAgICAgbmFtZTogJ2Fycm93LWZpbGwnLFxuICAgICAgdHlwZTogdC5hcnJvd0ZpbGxcbiAgICB9XS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICBhcnJvd1ByZWZpeGVzLmZvckVhY2goZnVuY3Rpb24gKHByZWZpeCkge1xuICAgICAgICB2YXIgbmFtZSA9IHByZWZpeCArICctJyArIHByb3AubmFtZTtcbiAgICAgICAgdmFyIHR5cGUgPSBwcm9wLnR5cGUsXG4gICAgICAgICAgICB0cmlnZ2Vyc0JvdW5kcyA9IHByb3AudHJpZ2dlcnNCb3VuZHM7XG4gICAgICAgIGVkZ2VBcnJvdy5wdXNoKHtcbiAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgdHJpZ2dlcnNCb3VuZHM6IHRyaWdnZXJzQm91bmRzXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSwge30pO1xuICAgIHZhciBwcm9wcyA9IHN0eWZuJDIucHJvcGVydGllcyA9IFtdLmNvbmNhdChiZWhhdmlvciwgdHJhbnNpdGlvbiwgdmlzaWJpbGl0eSwgb3ZlcmxheSwgdW5kZXJsYXksIGdob3N0LCBjb21tb25MYWJlbCwgbGFiZWxEaW1lbnNpb25zLCBtYWluTGFiZWwsIHNvdXJjZUxhYmVsLCB0YXJnZXRMYWJlbCwgbm9kZUJvZHksIG5vZGVCb3JkZXIsIGJhY2tncm91bmRJbWFnZSwgcGllLCBjb21wb3VuZCwgZWRnZUxpbmUsIGVkZ2VBcnJvdywgY29yZSk7XG4gICAgdmFyIHByb3BHcm91cHMgPSBzdHlmbiQyLnByb3BlcnR5R3JvdXBzID0ge1xuICAgICAgLy8gY29tbW9uIHRvIGFsbCBlbGVzXG4gICAgICBiZWhhdmlvcjogYmVoYXZpb3IsXG4gICAgICB0cmFuc2l0aW9uOiB0cmFuc2l0aW9uLFxuICAgICAgdmlzaWJpbGl0eTogdmlzaWJpbGl0eSxcbiAgICAgIG92ZXJsYXk6IG92ZXJsYXksXG4gICAgICB1bmRlcmxheTogdW5kZXJsYXksXG4gICAgICBnaG9zdDogZ2hvc3QsXG4gICAgICAvLyBsYWJlbHNcbiAgICAgIGNvbW1vbkxhYmVsOiBjb21tb25MYWJlbCxcbiAgICAgIGxhYmVsRGltZW5zaW9uczogbGFiZWxEaW1lbnNpb25zLFxuICAgICAgbWFpbkxhYmVsOiBtYWluTGFiZWwsXG4gICAgICBzb3VyY2VMYWJlbDogc291cmNlTGFiZWwsXG4gICAgICB0YXJnZXRMYWJlbDogdGFyZ2V0TGFiZWwsXG4gICAgICAvLyBub2RlIHByb3BzXG4gICAgICBub2RlQm9keTogbm9kZUJvZHksXG4gICAgICBub2RlQm9yZGVyOiBub2RlQm9yZGVyLFxuICAgICAgYmFja2dyb3VuZEltYWdlOiBiYWNrZ3JvdW5kSW1hZ2UsXG4gICAgICBwaWU6IHBpZSxcbiAgICAgIGNvbXBvdW5kOiBjb21wb3VuZCxcbiAgICAgIC8vIGVkZ2UgcHJvcHNcbiAgICAgIGVkZ2VMaW5lOiBlZGdlTGluZSxcbiAgICAgIGVkZ2VBcnJvdzogZWRnZUFycm93LFxuICAgICAgY29yZTogY29yZVxuICAgIH07XG4gICAgdmFyIHByb3BHcm91cE5hbWVzID0gc3R5Zm4kMi5wcm9wZXJ0eUdyb3VwTmFtZXMgPSB7fTtcbiAgICB2YXIgcHJvcEdyb3VwS2V5cyA9IHN0eWZuJDIucHJvcGVydHlHcm91cEtleXMgPSBPYmplY3Qua2V5cyhwcm9wR3JvdXBzKTtcbiAgICBwcm9wR3JvdXBLZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgcHJvcEdyb3VwTmFtZXNba2V5XSA9IHByb3BHcm91cHNba2V5XS5tYXAoZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgcmV0dXJuIHByb3AubmFtZTtcbiAgICAgIH0pO1xuICAgICAgcHJvcEdyb3Vwc1trZXldLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgcmV0dXJuIHByb3AuZ3JvdXBLZXkgPSBrZXk7XG4gICAgICB9KTtcbiAgICB9KTsgLy8gZGVmaW5lIGFsaWFzZXNcblxuICAgIHZhciBhbGlhc2VzID0gc3R5Zm4kMi5hbGlhc2VzID0gW3tcbiAgICAgIG5hbWU6ICdjb250ZW50JyxcbiAgICAgIHBvaW50c1RvOiAnbGFiZWwnXG4gICAgfSwge1xuICAgICAgbmFtZTogJ2NvbnRyb2wtcG9pbnQtZGlzdGFuY2UnLFxuICAgICAgcG9pbnRzVG86ICdjb250cm9sLXBvaW50LWRpc3RhbmNlcydcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnY29udHJvbC1wb2ludC13ZWlnaHQnLFxuICAgICAgcG9pbnRzVG86ICdjb250cm9sLXBvaW50LXdlaWdodHMnXG4gICAgfSwge1xuICAgICAgbmFtZTogJ2VkZ2UtdGV4dC1yb3RhdGlvbicsXG4gICAgICBwb2ludHNUbzogJ3RleHQtcm90YXRpb24nXG4gICAgfSwge1xuICAgICAgbmFtZTogJ3BhZGRpbmctbGVmdCcsXG4gICAgICBwb2ludHNUbzogJ3BhZGRpbmcnXG4gICAgfSwge1xuICAgICAgbmFtZTogJ3BhZGRpbmctcmlnaHQnLFxuICAgICAgcG9pbnRzVG86ICdwYWRkaW5nJ1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdwYWRkaW5nLXRvcCcsXG4gICAgICBwb2ludHNUbzogJ3BhZGRpbmcnXG4gICAgfSwge1xuICAgICAgbmFtZTogJ3BhZGRpbmctYm90dG9tJyxcbiAgICAgIHBvaW50c1RvOiAncGFkZGluZydcbiAgICB9XTsgLy8gbGlzdCBvZiBwcm9wZXJ0eSBuYW1lc1xuXG4gICAgc3R5Zm4kMi5wcm9wZXJ0eU5hbWVzID0gcHJvcHMubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgICByZXR1cm4gcC5uYW1lO1xuICAgIH0pOyAvLyBhbGxvdyBhY2Nlc3Mgb2YgcHJvcGVydGllcyBieSBuYW1lICggZS5nLiBzdHlsZS5wcm9wZXJ0aWVzLmhlaWdodCApXG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgcHJvcHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgcHJvcCA9IHByb3BzW19pXTtcbiAgICAgIHByb3BzW3Byb3AubmFtZV0gPSBwcm9wOyAvLyBhbGxvdyBsb29rdXAgYnkgbmFtZVxuICAgIH0gLy8gbWFwIGFsaWFzZXNcblxuXG4gICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgYWxpYXNlcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICB2YXIgYWxpYXMgPSBhbGlhc2VzW19pMl07XG4gICAgICB2YXIgcG9pbnRzVG9Qcm9wID0gcHJvcHNbYWxpYXMucG9pbnRzVG9dO1xuICAgICAgdmFyIGFsaWFzUHJvcCA9IHtcbiAgICAgICAgbmFtZTogYWxpYXMubmFtZSxcbiAgICAgICAgYWxpYXM6IHRydWUsXG4gICAgICAgIHBvaW50c1RvOiBwb2ludHNUb1Byb3BcbiAgICAgIH07IC8vIGFkZCBhbGlhcyBwcm9wIGZvciBwYXJzaW5nXG5cbiAgICAgIHByb3BzLnB1c2goYWxpYXNQcm9wKTtcbiAgICAgIHByb3BzW2FsaWFzLm5hbWVdID0gYWxpYXNQcm9wOyAvLyBhbGxvdyBsb29rdXAgYnkgbmFtZVxuICAgIH1cbiAgfSkoKTtcblxuICBzdHlmbiQyLmdldERlZmF1bHRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RGVmYXVsdFByb3BlcnRpZXMoKVtuYW1lXTtcbiAgfTtcblxuICBzdHlmbiQyLmdldERlZmF1bHRQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICBpZiAoX3AuZGVmYXVsdFByb3BlcnRpZXMgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIF9wLmRlZmF1bHRQcm9wZXJ0aWVzO1xuICAgIH1cblxuICAgIHZhciByYXdQcm9wcyA9IGV4dGVuZCh7XG4gICAgICAvLyBjb3JlIHByb3BzXG4gICAgICAnc2VsZWN0aW9uLWJveC1jb2xvcic6ICcjZGRkJyxcbiAgICAgICdzZWxlY3Rpb24tYm94LW9wYWNpdHknOiAwLjY1LFxuICAgICAgJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLWNvbG9yJzogJyNhYWEnLFxuICAgICAgJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLXdpZHRoJzogMSxcbiAgICAgICdhY3RpdmUtYmctY29sb3InOiAnYmxhY2snLFxuICAgICAgJ2FjdGl2ZS1iZy1vcGFjaXR5JzogMC4xNSxcbiAgICAgICdhY3RpdmUtYmctc2l6ZSc6IDMwLFxuICAgICAgJ291dHNpZGUtdGV4dHVyZS1iZy1jb2xvcic6ICcjMDAwJyxcbiAgICAgICdvdXRzaWRlLXRleHR1cmUtYmctb3BhY2l0eSc6IDAuMTI1LFxuICAgICAgLy8gY29tbW9uIG5vZGUvZWRnZSBwcm9wc1xuICAgICAgJ2V2ZW50cyc6ICd5ZXMnLFxuICAgICAgJ3RleHQtZXZlbnRzJzogJ25vJyxcbiAgICAgICd0ZXh0LXZhbGlnbic6ICd0b3AnLFxuICAgICAgJ3RleHQtaGFsaWduJzogJ2NlbnRlcicsXG4gICAgICAndGV4dC1qdXN0aWZpY2F0aW9uJzogJ2F1dG8nLFxuICAgICAgJ2xpbmUtaGVpZ2h0JzogMSxcbiAgICAgICdjb2xvcic6ICcjMDAwJyxcbiAgICAgICd0ZXh0LW91dGxpbmUtY29sb3InOiAnIzAwMCcsXG4gICAgICAndGV4dC1vdXRsaW5lLXdpZHRoJzogMCxcbiAgICAgICd0ZXh0LW91dGxpbmUtb3BhY2l0eSc6IDEsXG4gICAgICAndGV4dC1vcGFjaXR5JzogMSxcbiAgICAgICd0ZXh0LWRlY29yYXRpb24nOiAnbm9uZScsXG4gICAgICAndGV4dC10cmFuc2Zvcm0nOiAnbm9uZScsXG4gICAgICAndGV4dC13cmFwJzogJ25vbmUnLFxuICAgICAgJ3RleHQtb3ZlcmZsb3ctd3JhcCc6ICd3aGl0ZXNwYWNlJyxcbiAgICAgICd0ZXh0LW1heC13aWR0aCc6IDk5OTksXG4gICAgICAndGV4dC1iYWNrZ3JvdW5kLWNvbG9yJzogJyMwMDAnLFxuICAgICAgJ3RleHQtYmFja2dyb3VuZC1vcGFjaXR5JzogMCxcbiAgICAgICd0ZXh0LWJhY2tncm91bmQtc2hhcGUnOiAncmVjdGFuZ2xlJyxcbiAgICAgICd0ZXh0LWJhY2tncm91bmQtcGFkZGluZyc6IDAsXG4gICAgICAndGV4dC1ib3JkZXItb3BhY2l0eSc6IDAsXG4gICAgICAndGV4dC1ib3JkZXItd2lkdGgnOiAwLFxuICAgICAgJ3RleHQtYm9yZGVyLXN0eWxlJzogJ3NvbGlkJyxcbiAgICAgICd0ZXh0LWJvcmRlci1jb2xvcic6ICcjMDAwJyxcbiAgICAgICdmb250LWZhbWlseSc6ICdIZWx2ZXRpY2EgTmV1ZSwgSGVsdmV0aWNhLCBzYW5zLXNlcmlmJyxcbiAgICAgICdmb250LXN0eWxlJzogJ25vcm1hbCcsXG4gICAgICAnZm9udC13ZWlnaHQnOiAnbm9ybWFsJyxcbiAgICAgICdmb250LXNpemUnOiAxNixcbiAgICAgICdtaW4tem9vbWVkLWZvbnQtc2l6ZSc6IDAsXG4gICAgICAndGV4dC1yb3RhdGlvbic6ICdub25lJyxcbiAgICAgICdzb3VyY2UtdGV4dC1yb3RhdGlvbic6ICdub25lJyxcbiAgICAgICd0YXJnZXQtdGV4dC1yb3RhdGlvbic6ICdub25lJyxcbiAgICAgICd2aXNpYmlsaXR5JzogJ3Zpc2libGUnLFxuICAgICAgJ2Rpc3BsYXknOiAnZWxlbWVudCcsXG4gICAgICAnb3BhY2l0eSc6IDEsXG4gICAgICAnei1jb21wb3VuZC1kZXB0aCc6ICdhdXRvJyxcbiAgICAgICd6LWluZGV4LWNvbXBhcmUnOiAnYXV0bycsXG4gICAgICAnei1pbmRleCc6IDAsXG4gICAgICAnbGFiZWwnOiAnJyxcbiAgICAgICd0ZXh0LW1hcmdpbi14JzogMCxcbiAgICAgICd0ZXh0LW1hcmdpbi15JzogMCxcbiAgICAgICdzb3VyY2UtbGFiZWwnOiAnJyxcbiAgICAgICdzb3VyY2UtdGV4dC1vZmZzZXQnOiAwLFxuICAgICAgJ3NvdXJjZS10ZXh0LW1hcmdpbi14JzogMCxcbiAgICAgICdzb3VyY2UtdGV4dC1tYXJnaW4teSc6IDAsXG4gICAgICAndGFyZ2V0LWxhYmVsJzogJycsXG4gICAgICAndGFyZ2V0LXRleHQtb2Zmc2V0JzogMCxcbiAgICAgICd0YXJnZXQtdGV4dC1tYXJnaW4teCc6IDAsXG4gICAgICAndGFyZ2V0LXRleHQtbWFyZ2luLXknOiAwLFxuICAgICAgJ292ZXJsYXktb3BhY2l0eSc6IDAsXG4gICAgICAnb3ZlcmxheS1jb2xvcic6ICcjMDAwJyxcbiAgICAgICdvdmVybGF5LXBhZGRpbmcnOiAxMCxcbiAgICAgICdvdmVybGF5LXNoYXBlJzogJ3JvdW5kLXJlY3RhbmdsZScsXG4gICAgICAndW5kZXJsYXktb3BhY2l0eSc6IDAsXG4gICAgICAndW5kZXJsYXktY29sb3InOiAnIzAwMCcsXG4gICAgICAndW5kZXJsYXktcGFkZGluZyc6IDEwLFxuICAgICAgJ3VuZGVybGF5LXNoYXBlJzogJ3JvdW5kLXJlY3RhbmdsZScsXG4gICAgICAndHJhbnNpdGlvbi1wcm9wZXJ0eSc6ICdub25lJyxcbiAgICAgICd0cmFuc2l0aW9uLWR1cmF0aW9uJzogMCxcbiAgICAgICd0cmFuc2l0aW9uLWRlbGF5JzogMCxcbiAgICAgICd0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbic6ICdsaW5lYXInLFxuICAgICAgLy8gbm9kZSBwcm9wc1xuICAgICAgJ2JhY2tncm91bmQtYmxhY2tlbic6IDAsXG4gICAgICAnYmFja2dyb3VuZC1jb2xvcic6ICcjOTk5JyxcbiAgICAgICdiYWNrZ3JvdW5kLWZpbGwnOiAnc29saWQnLFxuICAgICAgJ2JhY2tncm91bmQtb3BhY2l0eSc6IDEsXG4gICAgICAnYmFja2dyb3VuZC1pbWFnZSc6ICdub25lJyxcbiAgICAgICdiYWNrZ3JvdW5kLWltYWdlLWNyb3Nzb3JpZ2luJzogJ2Fub255bW91cycsXG4gICAgICAnYmFja2dyb3VuZC1pbWFnZS1vcGFjaXR5JzogMSxcbiAgICAgICdiYWNrZ3JvdW5kLWltYWdlLWNvbnRhaW5tZW50JzogJ2luc2lkZScsXG4gICAgICAnYmFja2dyb3VuZC1pbWFnZS1zbW9vdGhpbmcnOiAneWVzJyxcbiAgICAgICdiYWNrZ3JvdW5kLXBvc2l0aW9uLXgnOiAnNTAlJyxcbiAgICAgICdiYWNrZ3JvdW5kLXBvc2l0aW9uLXknOiAnNTAlJyxcbiAgICAgICdiYWNrZ3JvdW5kLW9mZnNldC14JzogMCxcbiAgICAgICdiYWNrZ3JvdW5kLW9mZnNldC15JzogMCxcbiAgICAgICdiYWNrZ3JvdW5kLXdpZHRoLXJlbGF0aXZlLXRvJzogJ2luY2x1ZGUtcGFkZGluZycsXG4gICAgICAnYmFja2dyb3VuZC1oZWlnaHQtcmVsYXRpdmUtdG8nOiAnaW5jbHVkZS1wYWRkaW5nJyxcbiAgICAgICdiYWNrZ3JvdW5kLXJlcGVhdCc6ICduby1yZXBlYXQnLFxuICAgICAgJ2JhY2tncm91bmQtZml0JzogJ25vbmUnLFxuICAgICAgJ2JhY2tncm91bmQtY2xpcCc6ICdub2RlJyxcbiAgICAgICdiYWNrZ3JvdW5kLXdpZHRoJzogJ2F1dG8nLFxuICAgICAgJ2JhY2tncm91bmQtaGVpZ2h0JzogJ2F1dG8nLFxuICAgICAgJ2JvcmRlci1jb2xvcic6ICcjMDAwJyxcbiAgICAgICdib3JkZXItb3BhY2l0eSc6IDEsXG4gICAgICAnYm9yZGVyLXdpZHRoJzogMCxcbiAgICAgICdib3JkZXItc3R5bGUnOiAnc29saWQnLFxuICAgICAgJ2hlaWdodCc6IDMwLFxuICAgICAgJ3dpZHRoJzogMzAsXG4gICAgICAnc2hhcGUnOiAnZWxsaXBzZScsXG4gICAgICAnc2hhcGUtcG9seWdvbi1wb2ludHMnOiAnLTEsIC0xLCAgIDEsIC0xLCAgIDEsIDEsICAgLTEsIDEnLFxuICAgICAgJ2JvdW5kcy1leHBhbnNpb24nOiAwLFxuICAgICAgLy8gbm9kZSBncmFkaWVudFxuICAgICAgJ2JhY2tncm91bmQtZ3JhZGllbnQtZGlyZWN0aW9uJzogJ3RvLWJvdHRvbScsXG4gICAgICAnYmFja2dyb3VuZC1ncmFkaWVudC1zdG9wLWNvbG9ycyc6ICcjOTk5JyxcbiAgICAgICdiYWNrZ3JvdW5kLWdyYWRpZW50LXN0b3AtcG9zaXRpb25zJzogJzAlJyxcbiAgICAgIC8vIGdob3N0IHByb3BzXG4gICAgICAnZ2hvc3QnOiAnbm8nLFxuICAgICAgJ2dob3N0LW9mZnNldC15JzogMCxcbiAgICAgICdnaG9zdC1vZmZzZXQteCc6IDAsXG4gICAgICAnZ2hvc3Qtb3BhY2l0eSc6IDAsXG4gICAgICAvLyBjb21wb3VuZCBwcm9wc1xuICAgICAgJ3BhZGRpbmcnOiAwLFxuICAgICAgJ3BhZGRpbmctcmVsYXRpdmUtdG8nOiAnd2lkdGgnLFxuICAgICAgJ3Bvc2l0aW9uJzogJ29yaWdpbicsXG4gICAgICAnY29tcG91bmQtc2l6aW5nLXdydC1sYWJlbHMnOiAnaW5jbHVkZScsXG4gICAgICAnbWluLXdpZHRoJzogMCxcbiAgICAgICdtaW4td2lkdGgtYmlhcy1sZWZ0JzogMCxcbiAgICAgICdtaW4td2lkdGgtYmlhcy1yaWdodCc6IDAsXG4gICAgICAnbWluLWhlaWdodCc6IDAsXG4gICAgICAnbWluLWhlaWdodC1iaWFzLXRvcCc6IDAsXG4gICAgICAnbWluLWhlaWdodC1iaWFzLWJvdHRvbSc6IDBcbiAgICB9LCB7XG4gICAgICAvLyBub2RlIHBpZSBiZ1xuICAgICAgJ3BpZS1zaXplJzogJzEwMCUnXG4gICAgfSwgW3tcbiAgICAgIG5hbWU6ICdwaWUte3tpfX0tYmFja2dyb3VuZC1jb2xvcicsXG4gICAgICB2YWx1ZTogJ2JsYWNrJ1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdwaWUte3tpfX0tYmFja2dyb3VuZC1zaXplJyxcbiAgICAgIHZhbHVlOiAnMCUnXG4gICAgfSwge1xuICAgICAgbmFtZTogJ3BpZS17e2l9fS1iYWNrZ3JvdW5kLW9wYWNpdHknLFxuICAgICAgdmFsdWU6IDFcbiAgICB9XS5yZWR1Y2UoZnVuY3Rpb24gKGNzcywgcHJvcCkge1xuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gc3R5Zm4kMi5waWVCYWNrZ3JvdW5kTjsgaSsrKSB7XG4gICAgICAgIHZhciBuYW1lID0gcHJvcC5uYW1lLnJlcGxhY2UoJ3t7aX19JywgaSk7XG4gICAgICAgIHZhciB2YWwgPSBwcm9wLnZhbHVlO1xuICAgICAgICBjc3NbbmFtZV0gPSB2YWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjc3M7XG4gICAgfSwge30pLCB7XG4gICAgICAvLyBlZGdlIHByb3BzXG4gICAgICAnbGluZS1zdHlsZSc6ICdzb2xpZCcsXG4gICAgICAnbGluZS1jb2xvcic6ICcjOTk5JyxcbiAgICAgICdsaW5lLWZpbGwnOiAnc29saWQnLFxuICAgICAgJ2xpbmUtY2FwJzogJ2J1dHQnLFxuICAgICAgJ2xpbmUtb3BhY2l0eSc6IDEsXG4gICAgICAnbGluZS1ncmFkaWVudC1zdG9wLWNvbG9ycyc6ICcjOTk5JyxcbiAgICAgICdsaW5lLWdyYWRpZW50LXN0b3AtcG9zaXRpb25zJzogJzAlJyxcbiAgICAgICdjb250cm9sLXBvaW50LXN0ZXAtc2l6ZSc6IDQwLFxuICAgICAgJ2NvbnRyb2wtcG9pbnQtd2VpZ2h0cyc6IDAuNSxcbiAgICAgICdzZWdtZW50LXdlaWdodHMnOiAwLjUsXG4gICAgICAnc2VnbWVudC1kaXN0YW5jZXMnOiAyMCxcbiAgICAgICd0YXhpLXR1cm4nOiAnNTAlJyxcbiAgICAgICd0YXhpLXR1cm4tbWluLWRpc3RhbmNlJzogMTAsXG4gICAgICAndGF4aS1kaXJlY3Rpb24nOiAnYXV0bycsXG4gICAgICAnZWRnZS1kaXN0YW5jZXMnOiAnaW50ZXJzZWN0aW9uJyxcbiAgICAgICdjdXJ2ZS1zdHlsZSc6ICdoYXlzdGFjaycsXG4gICAgICAnaGF5c3RhY2stcmFkaXVzJzogMCxcbiAgICAgICdhcnJvdy1zY2FsZSc6IDEsXG4gICAgICAnbG9vcC1kaXJlY3Rpb24nOiAnLTQ1ZGVnJyxcbiAgICAgICdsb29wLXN3ZWVwJzogJy05MGRlZycsXG4gICAgICAnc291cmNlLWRpc3RhbmNlLWZyb20tbm9kZSc6IDAsXG4gICAgICAndGFyZ2V0LWRpc3RhbmNlLWZyb20tbm9kZSc6IDAsXG4gICAgICAnc291cmNlLWVuZHBvaW50JzogJ291dHNpZGUtdG8tbm9kZScsXG4gICAgICAndGFyZ2V0LWVuZHBvaW50JzogJ291dHNpZGUtdG8tbm9kZScsXG4gICAgICAnbGluZS1kYXNoLXBhdHRlcm4nOiBbNiwgM10sXG4gICAgICAnbGluZS1kYXNoLW9mZnNldCc6IDBcbiAgICB9LCBbe1xuICAgICAgbmFtZTogJ2Fycm93LXNoYXBlJyxcbiAgICAgIHZhbHVlOiAnbm9uZSdcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnYXJyb3ctY29sb3InLFxuICAgICAgdmFsdWU6ICcjOTk5J1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdhcnJvdy1maWxsJyxcbiAgICAgIHZhbHVlOiAnZmlsbGVkJ1xuICAgIH1dLnJlZHVjZShmdW5jdGlvbiAoY3NzLCBwcm9wKSB7XG4gICAgICBzdHlmbiQyLmFycm93UHJlZml4ZXMuZm9yRWFjaChmdW5jdGlvbiAocHJlZml4KSB7XG4gICAgICAgIHZhciBuYW1lID0gcHJlZml4ICsgJy0nICsgcHJvcC5uYW1lO1xuICAgICAgICB2YXIgdmFsID0gcHJvcC52YWx1ZTtcbiAgICAgICAgY3NzW25hbWVdID0gdmFsO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gY3NzO1xuICAgIH0sIHt9KSk7XG4gICAgdmFyIHBhcnNlZFByb3BzID0ge307XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHByb3AgPSB0aGlzLnByb3BlcnRpZXNbaV07XG5cbiAgICAgIGlmIChwcm9wLnBvaW50c1RvKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmFtZSA9IHByb3AubmFtZTtcbiAgICAgIHZhciB2YWwgPSByYXdQcm9wc1tuYW1lXTtcbiAgICAgIHZhciBwYXJzZWRQcm9wID0gdGhpcy5wYXJzZShuYW1lLCB2YWwpO1xuICAgICAgcGFyc2VkUHJvcHNbbmFtZV0gPSBwYXJzZWRQcm9wO1xuICAgIH1cblxuICAgIF9wLmRlZmF1bHRQcm9wZXJ0aWVzID0gcGFyc2VkUHJvcHM7XG4gICAgcmV0dXJuIF9wLmRlZmF1bHRQcm9wZXJ0aWVzO1xuICB9O1xuXG4gIHN0eWZuJDIuYWRkRGVmYXVsdFN0eWxlc2hlZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zZWxlY3RvcignOnBhcmVudCcpLmNzcyh7XG4gICAgICAnc2hhcGUnOiAncmVjdGFuZ2xlJyxcbiAgICAgICdwYWRkaW5nJzogMTAsXG4gICAgICAnYmFja2dyb3VuZC1jb2xvcic6ICcjZWVlJyxcbiAgICAgICdib3JkZXItY29sb3InOiAnI2NjYycsXG4gICAgICAnYm9yZGVyLXdpZHRoJzogMVxuICAgIH0pLnNlbGVjdG9yKCdlZGdlJykuY3NzKHtcbiAgICAgICd3aWR0aCc6IDNcbiAgICB9KS5zZWxlY3RvcignOmxvb3AnKS5jc3Moe1xuICAgICAgJ2N1cnZlLXN0eWxlJzogJ2JlemllcidcbiAgICB9KS5zZWxlY3RvcignZWRnZTpjb21wb3VuZCcpLmNzcyh7XG4gICAgICAnY3VydmUtc3R5bGUnOiAnYmV6aWVyJyxcbiAgICAgICdzb3VyY2UtZW5kcG9pbnQnOiAnb3V0c2lkZS10by1saW5lJyxcbiAgICAgICd0YXJnZXQtZW5kcG9pbnQnOiAnb3V0c2lkZS10by1saW5lJ1xuICAgIH0pLnNlbGVjdG9yKCc6c2VsZWN0ZWQnKS5jc3Moe1xuICAgICAgJ2JhY2tncm91bmQtY29sb3InOiAnIzAxNjlEOScsXG4gICAgICAnbGluZS1jb2xvcic6ICcjMDE2OUQ5JyxcbiAgICAgICdzb3VyY2UtYXJyb3ctY29sb3InOiAnIzAxNjlEOScsXG4gICAgICAndGFyZ2V0LWFycm93LWNvbG9yJzogJyMwMTY5RDknLFxuICAgICAgJ21pZC1zb3VyY2UtYXJyb3ctY29sb3InOiAnIzAxNjlEOScsXG4gICAgICAnbWlkLXRhcmdldC1hcnJvdy1jb2xvcic6ICcjMDE2OUQ5J1xuICAgIH0pLnNlbGVjdG9yKCc6cGFyZW50OnNlbGVjdGVkJykuY3NzKHtcbiAgICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogJyNDQ0UxRjknLFxuICAgICAgJ2JvcmRlci1jb2xvcic6ICcjYWVjOGU1J1xuICAgIH0pLnNlbGVjdG9yKCc6YWN0aXZlJykuY3NzKHtcbiAgICAgICdvdmVybGF5LWNvbG9yJzogJ2JsYWNrJyxcbiAgICAgICdvdmVybGF5LXBhZGRpbmcnOiAxMCxcbiAgICAgICdvdmVybGF5LW9wYWNpdHknOiAwLjI1XG4gICAgfSk7XG4gICAgdGhpcy5kZWZhdWx0TGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gIH07XG5cbiAgdmFyIHN0eWZuJDEgPSB7fTsgLy8gYSBjYWNoaW5nIGxheWVyIGZvciBwcm9wZXJ0eSBwYXJzaW5nXG5cbiAgc3R5Zm4kMS5wYXJzZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgcHJvcElzQnlwYXNzLCBwcm9wSXNGbGF0KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzOyAvLyBmdW5jdGlvbiB2YWx1ZXMgY2FuJ3QgYmUgY2FjaGVkIGluIGFsbCBjYXNlcywgYW5kIHRoZXJlIGlzbid0IG11Y2ggYmVuZWZpdCBvZiBjYWNoaW5nIHRoZW0gYW55d2F5XG5cbiAgICBpZiAoZm4kNih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBzZWxmLnBhcnNlSW1wbFdhcm4obmFtZSwgdmFsdWUsIHByb3BJc0J5cGFzcywgcHJvcElzRmxhdCk7XG4gICAgfVxuXG4gICAgdmFyIGZsYXRLZXkgPSBwcm9wSXNGbGF0ID09PSAnbWFwcGluZycgfHwgcHJvcElzRmxhdCA9PT0gdHJ1ZSB8fCBwcm9wSXNGbGF0ID09PSBmYWxzZSB8fCBwcm9wSXNGbGF0ID09IG51bGwgPyAnZG9udGNhcmUnIDogcHJvcElzRmxhdDtcbiAgICB2YXIgYnlwYXNzS2V5ID0gcHJvcElzQnlwYXNzID8gJ3QnIDogJ2YnO1xuICAgIHZhciB2YWx1ZUtleSA9ICcnICsgdmFsdWU7XG4gICAgdmFyIGFyZ0hhc2ggPSBoYXNoU3RyaW5ncyhuYW1lLCB2YWx1ZUtleSwgYnlwYXNzS2V5LCBmbGF0S2V5KTtcbiAgICB2YXIgcHJvcENhY2hlID0gc2VsZi5wcm9wQ2FjaGUgPSBzZWxmLnByb3BDYWNoZSB8fCBbXTtcbiAgICB2YXIgcmV0O1xuXG4gICAgaWYgKCEocmV0ID0gcHJvcENhY2hlW2FyZ0hhc2hdKSkge1xuICAgICAgcmV0ID0gcHJvcENhY2hlW2FyZ0hhc2hdID0gc2VsZi5wYXJzZUltcGxXYXJuKG5hbWUsIHZhbHVlLCBwcm9wSXNCeXBhc3MsIHByb3BJc0ZsYXQpO1xuICAgIH0gLy8gLSBieXBhc3NlcyBjYW4ndCBiZSBzaGFyZWQgYi9jIHRoZSB2YWx1ZSBjYW4gYmUgY2hhbmdlZCBieSBhbmltYXRpb25zIG9yIG90aGVyd2lzZSBvdmVycmlkZGVuXG4gICAgLy8gLSBtYXBwaW5ncyBjYW4ndCBiZSBzaGFyZWQgYi9jIG1hcHBpbmdzIGFyZSBwZXItZWxlbWVudFxuXG5cbiAgICBpZiAocHJvcElzQnlwYXNzIHx8IHByb3BJc0ZsYXQgPT09ICdtYXBwaW5nJykge1xuICAgICAgLy8gbmVlZCBhIGNvcHkgc2luY2UgcHJvcHMgYXJlIG11dGF0ZWQgbGF0ZXIgaW4gdGhlaXIgbGlmZWN5Y2xlc1xuICAgICAgcmV0ID0gY29weShyZXQpO1xuXG4gICAgICBpZiAocmV0KSB7XG4gICAgICAgIHJldC52YWx1ZSA9IGNvcHkocmV0LnZhbHVlKTsgLy8gYmVjYXVzZSBpdCBjb3VsZCBiZSBhbiBhcnJheSwgZS5nLiBjb2xvdXJcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9O1xuXG4gIHN0eWZuJDEucGFyc2VJbXBsV2FybiA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgcHJvcElzQnlwYXNzLCBwcm9wSXNGbGF0KSB7XG4gICAgdmFyIHByb3AgPSB0aGlzLnBhcnNlSW1wbChuYW1lLCB2YWx1ZSwgcHJvcElzQnlwYXNzLCBwcm9wSXNGbGF0KTtcblxuICAgIGlmICghcHJvcCAmJiB2YWx1ZSAhPSBudWxsKSB7XG4gICAgICB3YXJuKFwiVGhlIHN0eWxlIHByb3BlcnR5IGBcIi5jb25jYXQobmFtZSwgXCI6IFwiKS5jb25jYXQodmFsdWUsIFwiYCBpcyBpbnZhbGlkXCIpKTtcbiAgICB9XG5cbiAgICBpZiAocHJvcCAmJiAocHJvcC5uYW1lID09PSAnd2lkdGgnIHx8IHByb3AubmFtZSA9PT0gJ2hlaWdodCcpICYmIHZhbHVlID09PSAnbGFiZWwnKSB7XG4gICAgICB3YXJuKCdUaGUgc3R5bGUgdmFsdWUgb2YgYGxhYmVsYCBpcyBkZXByZWNhdGVkIGZvciBgJyArIHByb3AubmFtZSArICdgJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb3A7XG4gIH07IC8vIHBhcnNlIGEgcHJvcGVydHk7IHJldHVybiBudWxsIG9uIGludmFsaWQ7IHJldHVybiBwYXJzZWQgcHJvcGVydHkgb3RoZXJ3aXNlXG4gIC8vIGZpZWxkcyA6XG4gIC8vIC0gbmFtZSA6IHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eVxuICAvLyAtIHZhbHVlIDogdGhlIHBhcnNlZCwgbmF0aXZlLXR5cGVkIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eVxuICAvLyAtIHN0clZhbHVlIDogYSBzdHJpbmcgdmFsdWUgdGhhdCByZXByZXNlbnRzIHRoZSBwcm9wZXJ0eSB2YWx1ZSBpbiB2YWxpZCBjc3NcbiAgLy8gLSBieXBhc3MgOiB0cnVlIGlmZiB0aGUgcHJvcGVydHkgaXMgYSBieXBhc3MgcHJvcGVydHlcblxuXG4gIHN0eWZuJDEucGFyc2VJbXBsID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBwcm9wSXNCeXBhc3MsIHByb3BJc0ZsYXQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgbmFtZSA9IGNhbWVsMmRhc2gobmFtZSk7IC8vIG1ha2Ugc3VyZSB0aGUgcHJvcGVydHkgbmFtZSBpcyBpbiBkYXNoIGZvcm0gKGUuZy4gJ3Byb3BlcnR5LW5hbWUnIG5vdCAncHJvcGVydHlOYW1lJylcblxuICAgIHZhciBwcm9wZXJ0eSA9IHNlbGYucHJvcGVydGllc1tuYW1lXTtcbiAgICB2YXIgcGFzc2VkVmFsdWUgPSB2YWx1ZTtcbiAgICB2YXIgdHlwZXMgPSBzZWxmLnR5cGVzO1xuXG4gICAgaWYgKCFwcm9wZXJ0eSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSAvLyByZXR1cm4gbnVsbCBvbiBwcm9wZXJ0eSBvZiB1bmtub3duIG5hbWVcblxuXG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gLy8gY2FuJ3QgYXNzaWduIHVuZGVmaW5lZFxuICAgIC8vIHRoZSBwcm9wZXJ0eSBtYXkgYmUgYW4gYWxpYXNcblxuXG4gICAgaWYgKHByb3BlcnR5LmFsaWFzKSB7XG4gICAgICBwcm9wZXJ0eSA9IHByb3BlcnR5LnBvaW50c1RvO1xuICAgICAgbmFtZSA9IHByb3BlcnR5Lm5hbWU7XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlSXNTdHJpbmcgPSBzdHJpbmcodmFsdWUpO1xuXG4gICAgaWYgKHZhbHVlSXNTdHJpbmcpIHtcbiAgICAgIC8vIHRyaW0gdGhlIHZhbHVlIHRvIG1ha2UgcGFyc2luZyBlYXNpZXJcbiAgICAgIHZhbHVlID0gdmFsdWUudHJpbSgpO1xuICAgIH1cblxuICAgIHZhciB0eXBlID0gcHJvcGVydHkudHlwZTtcblxuICAgIGlmICghdHlwZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSAvLyBubyB0eXBlLCBubyBsdWNrXG4gICAgLy8gY2hlY2sgaWYgYnlwYXNzIGlzIG51bGwgb3IgZW1wdHkgc3RyaW5nIChpLmUuIGluZGljYXRpb24gdG8gZGVsZXRlIGJ5cGFzcyBwcm9wZXJ0eSlcblxuXG4gICAgaWYgKHByb3BJc0J5cGFzcyAmJiAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSBudWxsKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBieXBhc3M6IHRydWUsXG4gICAgICAgIGRlbGV0ZUJ5cGFzczogdHJ1ZVxuICAgICAgfTtcbiAgICB9IC8vIGNoZWNrIGlmIHZhbHVlIGlzIGEgZnVuY3Rpb24gdXNlZCBhcyBhIG1hcHBlclxuXG5cbiAgICBpZiAoZm4kNih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgc3RyVmFsdWU6ICdmbicsXG4gICAgICAgIG1hcHBlZDogdHlwZXMuZm4sXG4gICAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgICB9O1xuICAgIH0gLy8gY2hlY2sgaWYgdmFsdWUgaXMgbWFwcGVkXG5cblxuICAgIHZhciBkYXRhLCBtYXBEYXRhO1xuXG4gICAgaWYgKCF2YWx1ZUlzU3RyaW5nIHx8IHByb3BJc0ZsYXQgfHwgdmFsdWUubGVuZ3RoIDwgNyB8fCB2YWx1ZVsxXSAhPT0gJ2EnKSA7IGVsc2UgaWYgKHZhbHVlLmxlbmd0aCA+PSA3ICYmIHZhbHVlWzBdID09PSAnZCcgJiYgKGRhdGEgPSBuZXcgUmVnRXhwKHR5cGVzLmRhdGEucmVnZXgpLmV4ZWModmFsdWUpKSkge1xuICAgICAgaWYgKHByb3BJc0J5cGFzcykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IC8vIG1hcHBlcnMgbm90IGFsbG93ZWQgaW4gYnlwYXNzXG5cblxuICAgICAgdmFyIG1hcHBlZCA9IHR5cGVzLmRhdGE7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICB2YWx1ZTogZGF0YSxcbiAgICAgICAgc3RyVmFsdWU6ICcnICsgdmFsdWUsXG4gICAgICAgIG1hcHBlZDogbWFwcGVkLFxuICAgICAgICBmaWVsZDogZGF0YVsxXSxcbiAgICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3NcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICh2YWx1ZS5sZW5ndGggPj0gMTAgJiYgdmFsdWVbMF0gPT09ICdtJyAmJiAobWFwRGF0YSA9IG5ldyBSZWdFeHAodHlwZXMubWFwRGF0YS5yZWdleCkuZXhlYyh2YWx1ZSkpKSB7XG4gICAgICBpZiAocHJvcElzQnlwYXNzKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gLy8gbWFwcGVycyBub3QgYWxsb3dlZCBpbiBieXBhc3NcblxuXG4gICAgICBpZiAodHlwZS5tdWx0aXBsZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IC8vIGltcG9zc2libGUgdG8gbWFwIHRvIG51bVxuXG5cbiAgICAgIHZhciBfbWFwcGVkID0gdHlwZXMubWFwRGF0YTsgLy8gd2UgY2FuIG1hcCBvbmx5IGlmIHRoZSB0eXBlIGlzIGEgY29sb3VyIG9yIGEgbnVtYmVyXG5cbiAgICAgIGlmICghKHR5cGUuY29sb3IgfHwgdHlwZS5udW1iZXIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlTWluID0gdGhpcy5wYXJzZShuYW1lLCBtYXBEYXRhWzRdKTsgLy8gcGFyc2UgdG8gdmFsaWRhdGVcblxuICAgICAgaWYgKCF2YWx1ZU1pbiB8fCB2YWx1ZU1pbi5tYXBwZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSAvLyBjYW4ndCBiZSBpbnZhbGlkIG9yIG1hcHBlZFxuXG5cbiAgICAgIHZhciB2YWx1ZU1heCA9IHRoaXMucGFyc2UobmFtZSwgbWFwRGF0YVs1XSk7IC8vIHBhcnNlIHRvIHZhbGlkYXRlXG5cbiAgICAgIGlmICghdmFsdWVNYXggfHwgdmFsdWVNYXgubWFwcGVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gLy8gY2FuJ3QgYmUgaW52YWxpZCBvciBtYXBwZWRcbiAgICAgIC8vIGNoZWNrIGlmIHZhbHVlTWluIGFuZCB2YWx1ZU1heCBhcmUgdGhlIHNhbWVcblxuXG4gICAgICBpZiAodmFsdWVNaW4ucGZWYWx1ZSA9PT0gdmFsdWVNYXgucGZWYWx1ZSB8fCB2YWx1ZU1pbi5zdHJWYWx1ZSA9PT0gdmFsdWVNYXguc3RyVmFsdWUpIHtcbiAgICAgICAgd2FybignYCcgKyBuYW1lICsgJzogJyArIHZhbHVlICsgJ2AgaXMgbm90IGEgdmFsaWQgbWFwcGVyIGJlY2F1c2UgdGhlIG91dHB1dCByYW5nZSBpcyB6ZXJvOyBjb252ZXJ0aW5nIHRvIGAnICsgbmFtZSArICc6ICcgKyB2YWx1ZU1pbi5zdHJWYWx1ZSArICdgJyk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlKG5hbWUsIHZhbHVlTWluLnN0clZhbHVlKTsgLy8gY2FuJ3QgbWFrZSBtdWNoIG9mIGEgbWFwcGVyIHdpdGhvdXQgYSByYW5nZVxuICAgICAgfSBlbHNlIGlmICh0eXBlLmNvbG9yKSB7XG4gICAgICAgIHZhciBjMSA9IHZhbHVlTWluLnZhbHVlO1xuICAgICAgICB2YXIgYzIgPSB2YWx1ZU1heC52YWx1ZTtcbiAgICAgICAgdmFyIHNhbWUgPSBjMVswXSA9PT0gYzJbMF0gLy8gcmVkXG4gICAgICAgICYmIGMxWzFdID09PSBjMlsxXSAvLyBncmVlblxuICAgICAgICAmJiBjMVsyXSA9PT0gYzJbMl0gLy8gYmx1ZVxuICAgICAgICAmJiAoIC8vIG9wdGlvbmFsIGFscGhhXG4gICAgICAgIGMxWzNdID09PSBjMlszXSAvLyBzYW1lIGFscGhhIG91dHJpZ2h0XG4gICAgICAgIHx8IChjMVszXSA9PSBudWxsIHx8IGMxWzNdID09PSAxIC8vIGZ1bGwgb3BhY2l0eSBmb3IgY29sb3VyIDE/XG4gICAgICAgICkgJiYgKGMyWzNdID09IG51bGwgfHwgYzJbM10gPT09IDEpIC8vIGZ1bGwgb3BhY2l0eSBmb3IgY29sb3VyIDI/XG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKHNhbWUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gLy8gY2FuJ3QgbWFrZSBhIG1hcHBlciB3aXRob3V0IGEgcmFuZ2VcblxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICB2YWx1ZTogbWFwRGF0YSxcbiAgICAgICAgc3RyVmFsdWU6ICcnICsgdmFsdWUsXG4gICAgICAgIG1hcHBlZDogX21hcHBlZCxcbiAgICAgICAgZmllbGQ6IG1hcERhdGFbMV0sXG4gICAgICAgIGZpZWxkTWluOiBwYXJzZUZsb2F0KG1hcERhdGFbMl0pLFxuICAgICAgICAvLyBtaW4gJiBtYXggYXJlIG51bWVyaWNcbiAgICAgICAgZmllbGRNYXg6IHBhcnNlRmxvYXQobWFwRGF0YVszXSksXG4gICAgICAgIHZhbHVlTWluOiB2YWx1ZU1pbi52YWx1ZSxcbiAgICAgICAgdmFsdWVNYXg6IHZhbHVlTWF4LnZhbHVlLFxuICAgICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAodHlwZS5tdWx0aXBsZSAmJiBwcm9wSXNGbGF0ICE9PSAnbXVsdGlwbGUnKSB7XG4gICAgICB2YXIgdmFscztcblxuICAgICAgaWYgKHZhbHVlSXNTdHJpbmcpIHtcbiAgICAgICAgdmFscyA9IHZhbHVlLnNwbGl0KC9cXHMrLyk7XG4gICAgICB9IGVsc2UgaWYgKGFycmF5KHZhbHVlKSkge1xuICAgICAgICB2YWxzID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWxzID0gW3ZhbHVlXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUuZXZlbk11bHRpcGxlICYmIHZhbHMubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHZhbEFyciA9IFtdO1xuICAgICAgdmFyIHVuaXRzQXJyID0gW107XG4gICAgICB2YXIgcGZWYWxBcnIgPSBbXTtcbiAgICAgIHZhciBzdHJWYWwgPSAnJztcbiAgICAgIHZhciBoYXNFbnVtID0gZmFsc2U7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFscy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcCA9IHNlbGYucGFyc2UobmFtZSwgdmFsc1tpXSwgcHJvcElzQnlwYXNzLCAnbXVsdGlwbGUnKTtcbiAgICAgICAgaGFzRW51bSA9IGhhc0VudW0gfHwgc3RyaW5nKHAudmFsdWUpO1xuICAgICAgICB2YWxBcnIucHVzaChwLnZhbHVlKTtcbiAgICAgICAgcGZWYWxBcnIucHVzaChwLnBmVmFsdWUgIT0gbnVsbCA/IHAucGZWYWx1ZSA6IHAudmFsdWUpO1xuICAgICAgICB1bml0c0Fyci5wdXNoKHAudW5pdHMpO1xuICAgICAgICBzdHJWYWwgKz0gKGkgPiAwID8gJyAnIDogJycpICsgcC5zdHJWYWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUudmFsaWRhdGUgJiYgIXR5cGUudmFsaWRhdGUodmFsQXJyLCB1bml0c0FycikpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlLnNpbmdsZUVudW0gJiYgaGFzRW51bSkge1xuICAgICAgICBpZiAodmFsQXJyLmxlbmd0aCA9PT0gMSAmJiBzdHJpbmcodmFsQXJyWzBdKSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgdmFsdWU6IHZhbEFyclswXSxcbiAgICAgICAgICAgIHN0clZhbHVlOiB2YWxBcnJbMF0sXG4gICAgICAgICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgdmFsdWU6IHZhbEFycixcbiAgICAgICAgcGZWYWx1ZTogcGZWYWxBcnIsXG4gICAgICAgIHN0clZhbHVlOiBzdHJWYWwsXG4gICAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzLFxuICAgICAgICB1bml0czogdW5pdHNBcnJcbiAgICAgIH07XG4gICAgfSAvLyBzZXZlcmFsIHR5cGVzIGFsc28gYWxsb3cgZW51bXNcblxuXG4gICAgdmFyIGNoZWNrRW51bXMgPSBmdW5jdGlvbiBjaGVja0VudW1zKCkge1xuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHR5cGUuZW51bXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBlbiA9IHR5cGUuZW51bXNbX2ldO1xuXG4gICAgICAgIGlmIChlbiA9PT0gdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIHN0clZhbHVlOiAnJyArIHZhbHVlLFxuICAgICAgICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3NcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07IC8vIGNoZWNrIHRoZSB0eXBlIGFuZCByZXR1cm4gdGhlIGFwcHJvcHJpYXRlIG9iamVjdFxuXG5cbiAgICBpZiAodHlwZS5udW1iZXIpIHtcbiAgICAgIHZhciB1bml0cztcbiAgICAgIHZhciBpbXBsaWNpdFVuaXRzID0gJ3B4JzsgLy8gbm90IHNldCA9PiBweFxuXG4gICAgICBpZiAodHlwZS51bml0cykge1xuICAgICAgICAvLyB1c2Ugc3BlY2lmaWVkIHVuaXRzIGlmIHNldFxuICAgICAgICB1bml0cyA9IHR5cGUudW5pdHM7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlLmltcGxpY2l0VW5pdHMpIHtcbiAgICAgICAgaW1wbGljaXRVbml0cyA9IHR5cGUuaW1wbGljaXRVbml0cztcbiAgICAgIH1cblxuICAgICAgaWYgKCF0eXBlLnVuaXRsZXNzKSB7XG4gICAgICAgIGlmICh2YWx1ZUlzU3RyaW5nKSB7XG4gICAgICAgICAgdmFyIHVuaXRzUmVnZXggPSAncHh8ZW0nICsgKHR5cGUuYWxsb3dQZXJjZW50ID8gJ3xcXFxcJScgOiAnJyk7XG5cbiAgICAgICAgICBpZiAodW5pdHMpIHtcbiAgICAgICAgICAgIHVuaXRzUmVnZXggPSB1bml0cztcbiAgICAgICAgICB9IC8vIG9ubHkgYWxsb3cgZXhwbGljaXQgdW5pdHMgaWYgc28gc2V0XG5cblxuICAgICAgICAgIHZhciBtYXRjaCA9IHZhbHVlLm1hdGNoKCdeKCcgKyBudW1iZXIgKyAnKSgnICsgdW5pdHNSZWdleCArICcpPycgKyAnJCcpO1xuXG4gICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG1hdGNoWzFdO1xuICAgICAgICAgICAgdW5pdHMgPSBtYXRjaFsyXSB8fCBpbXBsaWNpdFVuaXRzO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghdW5pdHMgfHwgdHlwZS5pbXBsaWNpdFVuaXRzKSB7XG4gICAgICAgICAgdW5pdHMgPSBpbXBsaWNpdFVuaXRzOyAvLyBpbXBsaWNpdGx5IHB4IGlmIHVuc3BlY2lmaWVkXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTsgLy8gaWYgbm90IGEgbnVtYmVyIGFuZCBlbnVtcyBub3QgYWxsb3dlZCwgdGhlbiB0aGUgdmFsdWUgaXMgaW52YWxpZFxuXG4gICAgICBpZiAoaXNOYU4odmFsdWUpICYmIHR5cGUuZW51bXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gLy8gY2hlY2sgaWYgdGhpcyBudW1iZXIgdHlwZSBhbHNvIGFjY2VwdHMgc3BlY2lhbCBrZXl3b3JkcyBpbiBwbGFjZSBvZiBudW1iZXJzXG4gICAgICAvLyAoaS5lLiBgbGVmdGAsIGBhdXRvYCwgZXRjKVxuXG5cbiAgICAgIGlmIChpc05hTih2YWx1ZSkgJiYgdHlwZS5lbnVtcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhbHVlID0gcGFzc2VkVmFsdWU7XG4gICAgICAgIHJldHVybiBjaGVja0VudW1zKCk7XG4gICAgICB9IC8vIGNoZWNrIGlmIHZhbHVlIG11c3QgYmUgYW4gaW50ZWdlclxuXG5cbiAgICAgIGlmICh0eXBlLmludGVnZXIgJiYgIWludGVnZXIodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSAvLyBjaGVjayB2YWx1ZSBpcyB3aXRoaW4gcmFuZ2VcblxuXG4gICAgICBpZiAodHlwZS5taW4gIT09IHVuZGVmaW5lZCAmJiAodmFsdWUgPCB0eXBlLm1pbiB8fCB0eXBlLnN0cmljdE1pbiAmJiB2YWx1ZSA9PT0gdHlwZS5taW4pIHx8IHR5cGUubWF4ICE9PSB1bmRlZmluZWQgJiYgKHZhbHVlID4gdHlwZS5tYXggfHwgdHlwZS5zdHJpY3RNYXggJiYgdmFsdWUgPT09IHR5cGUubWF4KSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJldCA9IHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBzdHJWYWx1ZTogJycgKyB2YWx1ZSArICh1bml0cyA/IHVuaXRzIDogJycpLFxuICAgICAgICB1bml0czogdW5pdHMsXG4gICAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgICB9OyAvLyBub3JtYWxpc2UgdmFsdWUgaW4gcGl4ZWxzXG5cbiAgICAgIGlmICh0eXBlLnVuaXRsZXNzIHx8IHVuaXRzICE9PSAncHgnICYmIHVuaXRzICE9PSAnZW0nKSB7XG4gICAgICAgIHJldC5wZlZhbHVlID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXQucGZWYWx1ZSA9IHVuaXRzID09PSAncHgnIHx8ICF1bml0cyA/IHZhbHVlIDogdGhpcy5nZXRFbVNpemVJblBpeGVscygpICogdmFsdWU7XG4gICAgICB9IC8vIG5vcm1hbGlzZSB2YWx1ZSBpbiBtc1xuXG5cbiAgICAgIGlmICh1bml0cyA9PT0gJ21zJyB8fCB1bml0cyA9PT0gJ3MnKSB7XG4gICAgICAgIHJldC5wZlZhbHVlID0gdW5pdHMgPT09ICdtcycgPyB2YWx1ZSA6IDEwMDAgKiB2YWx1ZTtcbiAgICAgIH0gLy8gbm9ybWFsaXNlIHZhbHVlIGluIHJhZFxuXG5cbiAgICAgIGlmICh1bml0cyA9PT0gJ2RlZycgfHwgdW5pdHMgPT09ICdyYWQnKSB7XG4gICAgICAgIHJldC5wZlZhbHVlID0gdW5pdHMgPT09ICdyYWQnID8gdmFsdWUgOiBkZWcycmFkKHZhbHVlKTtcbiAgICAgIH0gLy8gbm9ybWFsaXplIHZhbHVlIGluICVcblxuXG4gICAgICBpZiAodW5pdHMgPT09ICclJykge1xuICAgICAgICByZXQucGZWYWx1ZSA9IHZhbHVlIC8gMTAwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0gZWxzZSBpZiAodHlwZS5wcm9wTGlzdCkge1xuICAgICAgdmFyIHByb3BzID0gW107XG4gICAgICB2YXIgcHJvcHNTdHIgPSAnJyArIHZhbHVlO1xuXG4gICAgICBpZiAocHJvcHNTdHIgPT09ICdub25lJykgOyBlbHNlIHtcbiAgICAgICAgLy8gZ28gb3ZlciBlYWNoIHByb3BcbiAgICAgICAgdmFyIHByb3BzU3BsaXQgPSBwcm9wc1N0ci5zcGxpdCgvXFxzKixcXHMqfFxccysvKTtcblxuICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBwcm9wc1NwbGl0Lmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgICB2YXIgcHJvcE5hbWUgPSBwcm9wc1NwbGl0W19pMl0udHJpbSgpO1xuXG4gICAgICAgICAgaWYgKHNlbGYucHJvcGVydGllc1twcm9wTmFtZV0pIHtcbiAgICAgICAgICAgIHByb3BzLnB1c2gocHJvcE5hbWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3YXJuKCdgJyArIHByb3BOYW1lICsgJ2AgaXMgbm90IGEgdmFsaWQgcHJvcGVydHkgbmFtZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9wcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICB2YWx1ZTogcHJvcHMsXG4gICAgICAgIHN0clZhbHVlOiBwcm9wcy5sZW5ndGggPT09IDAgPyAnbm9uZScgOiBwcm9wcy5qb2luKCcgJyksXG4gICAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodHlwZS5jb2xvcikge1xuICAgICAgdmFyIHR1cGxlID0gY29sb3IydHVwbGUodmFsdWUpO1xuXG4gICAgICBpZiAoIXR1cGxlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICB2YWx1ZTogdHVwbGUsXG4gICAgICAgIHBmVmFsdWU6IHR1cGxlLFxuICAgICAgICBzdHJWYWx1ZTogJ3JnYignICsgdHVwbGVbMF0gKyAnLCcgKyB0dXBsZVsxXSArICcsJyArIHR1cGxlWzJdICsgJyknLFxuICAgICAgICAvLyBuLmIuIG5vIHNwYWNlcyBiL2Mgb2YgbXVsdGlwbGUgc3VwcG9ydFxuICAgICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHR5cGUucmVnZXggfHwgdHlwZS5yZWdleGVzKSB7XG4gICAgICAvLyBmaXJzdCBjaGVjayBlbnVtc1xuICAgICAgaWYgKHR5cGUuZW51bXMpIHtcbiAgICAgICAgdmFyIGVudW1Qcm9wID0gY2hlY2tFbnVtcygpO1xuXG4gICAgICAgIGlmIChlbnVtUHJvcCkge1xuICAgICAgICAgIHJldHVybiBlbnVtUHJvcDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgcmVnZXhlcyA9IHR5cGUucmVnZXhlcyA/IHR5cGUucmVnZXhlcyA6IFt0eXBlLnJlZ2V4XTtcblxuICAgICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgcmVnZXhlcy5sZW5ndGg7IF9pMysrKSB7XG4gICAgICAgIHZhciByZWdleCA9IG5ldyBSZWdFeHAocmVnZXhlc1tfaTNdKTsgLy8gbWFrZSBhIHJlZ2V4IGZyb20gdGhlIHR5cGUgc3RyaW5nXG5cbiAgICAgICAgdmFyIG0gPSByZWdleC5leGVjKHZhbHVlKTtcblxuICAgICAgICBpZiAobSkge1xuICAgICAgICAgIC8vIHJlZ2V4IG1hdGNoZXNcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIHZhbHVlOiB0eXBlLnNpbmdsZVJlZ2V4TWF0Y2hWYWx1ZSA/IG1bMV0gOiBtLFxuICAgICAgICAgICAgc3RyVmFsdWU6ICcnICsgdmFsdWUsXG4gICAgICAgICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7IC8vIGRpZG4ndCBtYXRjaCBhbnlcbiAgICB9IGVsc2UgaWYgKHR5cGUuc3RyaW5nKSB7XG4gICAgICAvLyBqdXN0IHJldHVyblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgdmFsdWU6ICcnICsgdmFsdWUsXG4gICAgICAgIHN0clZhbHVlOiAnJyArIHZhbHVlLFxuICAgICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHR5cGUuZW51bXMpIHtcbiAgICAgIC8vIGNoZWNrIGVudW1zIGxhc3QgYmVjYXVzZSBpdCdzIGEgY29tYm8gdHlwZSBpbiBvdGhlcnNcbiAgICAgIHJldHVybiBjaGVja0VudW1zKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsOyAvLyBub3QgYSB0eXBlIHdlIGNhbiBoYW5kbGVcbiAgICB9XG4gIH07XG5cbiAgdmFyIFN0eWxlID0gZnVuY3Rpb24gU3R5bGUoY3kpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU3R5bGUpKSB7XG4gICAgICByZXR1cm4gbmV3IFN0eWxlKGN5KTtcbiAgICB9XG5cbiAgICBpZiAoIWNvcmUoY3kpKSB7XG4gICAgICBlcnJvcignQSBzdHlsZSBtdXN0IGhhdmUgYSBjb3JlIHJlZmVyZW5jZScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3ByaXZhdGUgPSB7XG4gICAgICBjeTogY3ksXG4gICAgICBjb3JlU3R5bGU6IHt9XG4gICAgfTtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5yZXNldFRvRGVmYXVsdCgpO1xuICB9O1xuXG4gIHZhciBzdHlmbiA9IFN0eWxlLnByb3RvdHlwZTtcblxuICBzdHlmbi5pbnN0YW5jZVN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gJ3N0eWxlJztcbiAgfTsgLy8gcmVtb3ZlIGFsbCBjb250ZXh0c1xuXG5cbiAgc3R5Zm4uY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICB2YXIgY3kgPSBfcC5jeTtcbiAgICB2YXIgZWxlcyA9IGN5LmVsZW1lbnRzKCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXNbaV0gPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICAgIF9wLmNvbnRleHRTdHlsZXMgPSB7fTtcbiAgICBfcC5wcm9wRGlmZnMgPSB7fTtcbiAgICB0aGlzLmNsZWFuRWxlbWVudHMoZWxlcywgdHJ1ZSk7XG4gICAgZWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgIHZhciBlbGVfcCA9IGVsZVswXS5fcHJpdmF0ZTtcbiAgICAgIGVsZV9wLnN0eWxlRGlydHkgPSB0cnVlO1xuICAgICAgZWxlX3AuYXBwbGllZEluaXRTdHlsZSA9IGZhbHNlO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9O1xuXG4gIHN0eWZuLnJlc2V0VG9EZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY2xlYXIoKTtcbiAgICB0aGlzLmFkZERlZmF1bHRTdHlsZXNoZWV0KCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07IC8vIGJ1aWxkcyBhIHN0eWxlIG9iamVjdCBmb3IgdGhlICdjb3JlJyBzZWxlY3RvclxuXG5cbiAgc3R5Zm4uY29yZSA9IGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmNvcmVTdHlsZVtwcm9wTmFtZV0gfHwgdGhpcy5nZXREZWZhdWx0UHJvcGVydHkocHJvcE5hbWUpO1xuICB9OyAvLyBjcmVhdGUgYSBuZXcgY29udGV4dCBmcm9tIHRoZSBzcGVjaWZpZWQgc2VsZWN0b3Igc3RyaW5nIGFuZCBzd2l0Y2ggdG8gdGhhdCBjb250ZXh0XG5cblxuICBzdHlmbi5zZWxlY3RvciA9IGZ1bmN0aW9uIChzZWxlY3RvclN0cikge1xuICAgIC8vICdjb3JlJyBpcyBhIHNwZWNpYWwgY2FzZSBhbmQgZG9lcyBub3QgbmVlZCBhIHNlbGVjdG9yXG4gICAgdmFyIHNlbGVjdG9yID0gc2VsZWN0b3JTdHIgPT09ICdjb3JlJyA/IG51bGwgOiBuZXcgU2VsZWN0b3Ioc2VsZWN0b3JTdHIpO1xuICAgIHZhciBpID0gdGhpcy5sZW5ndGgrKzsgLy8gbmV3IGNvbnRleHQgbWVhbnMgbmV3IGluZGV4XG5cbiAgICB0aGlzW2ldID0ge1xuICAgICAgc2VsZWN0b3I6IHNlbGVjdG9yLFxuICAgICAgcHJvcGVydGllczogW10sXG4gICAgICBtYXBwZWRQcm9wZXJ0aWVzOiBbXSxcbiAgICAgIGluZGV4OiBpXG4gICAgfTtcbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfTsgLy8gYWRkIG9uZSBvciBtYW55IGNzcyBydWxlcyB0byB0aGUgY3VycmVudCBjb250ZXh0XG5cblxuICBzdHlmbi5jc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuXG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgbWFwID0gYXJnc1swXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLnByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHByb3AgPSBzZWxmLnByb3BlcnRpZXNbaV07XG4gICAgICAgIHZhciBtYXBWYWwgPSBtYXBbcHJvcC5uYW1lXTtcblxuICAgICAgICBpZiAobWFwVmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBtYXBWYWwgPSBtYXBbZGFzaDJjYW1lbChwcm9wLm5hbWUpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXBWYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuY3NzUnVsZShwcm9wLm5hbWUsIG1hcFZhbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFyZ3MubGVuZ3RoID09PSAyKSB7XG4gICAgICB0aGlzLmNzc1J1bGUoYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgfSAvLyBkbyBub3RoaW5nIGlmIGFyZ3MgYXJlIGludmFsaWRcblxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH07XG5cbiAgc3R5Zm4uc3R5bGUgPSBzdHlmbi5jc3M7IC8vIGFkZCBhIHNpbmdsZSBjc3MgcnVsZSB0byB0aGUgY3VycmVudCBjb250ZXh0XG5cbiAgc3R5Zm4uY3NzUnVsZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIC8vIG5hbWUtdmFsdWUgcGFpclxuICAgIHZhciBwcm9wZXJ0eSA9IHRoaXMucGFyc2UobmFtZSwgdmFsdWUpOyAvLyBhZGQgcHJvcGVydHkgdG8gY3VycmVudCBjb250ZXh0IGlmIHZhbGlkXG5cbiAgICBpZiAocHJvcGVydHkpIHtcbiAgICAgIHZhciBpID0gdGhpcy5sZW5ndGggLSAxO1xuICAgICAgdGhpc1tpXS5wcm9wZXJ0aWVzLnB1c2gocHJvcGVydHkpO1xuICAgICAgdGhpc1tpXS5wcm9wZXJ0aWVzW3Byb3BlcnR5Lm5hbWVdID0gcHJvcGVydHk7IC8vIGFsbG93IGFjY2VzcyBieSBuYW1lIGFzIHdlbGxcblxuICAgICAgaWYgKHByb3BlcnR5Lm5hbWUubWF0Y2goL3BpZS0oXFxkKyktYmFja2dyb3VuZC1zaXplLykgJiYgcHJvcGVydHkudmFsdWUpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZS5oYXNQaWUgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvcGVydHkubWFwcGVkKSB7XG4gICAgICAgIHRoaXNbaV0ubWFwcGVkUHJvcGVydGllcy5wdXNoKHByb3BlcnR5KTtcbiAgICAgIH0gLy8gYWRkIHRvIGNvcmUgc3R5bGUgaWYgbmVjZXNzYXJ5XG5cblxuICAgICAgdmFyIGN1cnJlbnRTZWxlY3RvcklzQ29yZSA9ICF0aGlzW2ldLnNlbGVjdG9yO1xuXG4gICAgICBpZiAoY3VycmVudFNlbGVjdG9ySXNDb3JlKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGUuY29yZVN0eWxlW3Byb3BlcnR5Lm5hbWVdID0gcHJvcGVydHk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH07XG5cbiAgc3R5Zm4uYXBwZW5kID0gZnVuY3Rpb24gKHN0eWxlKSB7XG4gICAgaWYgKHN0eWxlc2hlZXQoc3R5bGUpKSB7XG4gICAgICBzdHlsZS5hcHBlbmRUb1N0eWxlKHRoaXMpO1xuICAgIH0gZWxzZSBpZiAoYXJyYXkoc3R5bGUpKSB7XG4gICAgICB0aGlzLmFwcGVuZEZyb21Kc29uKHN0eWxlKTtcbiAgICB9IGVsc2UgaWYgKHN0cmluZyhzdHlsZSkpIHtcbiAgICAgIHRoaXMuYXBwZW5kRnJvbVN0cmluZyhzdHlsZSk7XG4gICAgfSAvLyB5b3UgcHJvYmFibHkgd291bGRuJ3Qgd2FudCB0byBhcHBlbmQgYSBTdHlsZSwgc2luY2UgeW91J2QgZHVwbGljYXRlIHRoZSBkZWZhdWx0IHBhcnRzXG5cblxuICAgIHJldHVybiB0aGlzO1xuICB9OyAvLyBzdGF0aWMgZnVuY3Rpb25cblxuXG4gIFN0eWxlLmZyb21Kc29uID0gZnVuY3Rpb24gKGN5LCBqc29uKSB7XG4gICAgdmFyIHN0eWxlID0gbmV3IFN0eWxlKGN5KTtcbiAgICBzdHlsZS5mcm9tSnNvbihqc29uKTtcbiAgICByZXR1cm4gc3R5bGU7XG4gIH07XG5cbiAgU3R5bGUuZnJvbVN0cmluZyA9IGZ1bmN0aW9uIChjeSwgc3RyaW5nKSB7XG4gICAgcmV0dXJuIG5ldyBTdHlsZShjeSkuZnJvbVN0cmluZyhzdHJpbmcpO1xuICB9O1xuXG4gIFtzdHlmbiQ4LCBzdHlmbiQ3LCBzdHlmbiQ2LCBzdHlmbiQ1LCBzdHlmbiQ0LCBzdHlmbiQzLCBzdHlmbiQyLCBzdHlmbiQxXS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wcykge1xuICAgIGV4dGVuZChzdHlmbiwgcHJvcHMpO1xuICB9KTtcbiAgU3R5bGUudHlwZXMgPSBzdHlmbi50eXBlcztcbiAgU3R5bGUucHJvcGVydGllcyA9IHN0eWZuLnByb3BlcnRpZXM7XG4gIFN0eWxlLnByb3BlcnR5R3JvdXBzID0gc3R5Zm4ucHJvcGVydHlHcm91cHM7XG4gIFN0eWxlLnByb3BlcnR5R3JvdXBOYW1lcyA9IHN0eWZuLnByb3BlcnR5R3JvdXBOYW1lcztcbiAgU3R5bGUucHJvcGVydHlHcm91cEtleXMgPSBzdHlmbi5wcm9wZXJ0eUdyb3VwS2V5cztcblxuICB2YXIgY29yZWZuJDIgPSB7XG4gICAgc3R5bGU6IGZ1bmN0aW9uIHN0eWxlKG5ld1N0eWxlKSB7XG4gICAgICBpZiAobmV3U3R5bGUpIHtcbiAgICAgICAgdmFyIHMgPSB0aGlzLnNldFN0eWxlKG5ld1N0eWxlKTtcbiAgICAgICAgcy51cGRhdGUoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuc3R5bGU7XG4gICAgfSxcbiAgICBzZXRTdHlsZTogZnVuY3Rpb24gc2V0U3R5bGUoc3R5bGUpIHtcbiAgICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICAgIGlmIChzdHlsZXNoZWV0KHN0eWxlKSkge1xuICAgICAgICBfcC5zdHlsZSA9IHN0eWxlLmdlbmVyYXRlU3R5bGUodGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKGFycmF5KHN0eWxlKSkge1xuICAgICAgICBfcC5zdHlsZSA9IFN0eWxlLmZyb21Kc29uKHRoaXMsIHN0eWxlKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RyaW5nKHN0eWxlKSkge1xuICAgICAgICBfcC5zdHlsZSA9IFN0eWxlLmZyb21TdHJpbmcodGhpcywgc3R5bGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3Auc3R5bGUgPSBTdHlsZSh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9wLnN0eWxlO1xuICAgIH0sXG4gICAgLy8gZS5nLiBjeS5kYXRhKCkgY2hhbmdlZCA9PiByZWNhbGMgZWxlIG1hcHBlcnNcbiAgICB1cGRhdGVTdHlsZTogZnVuY3Rpb24gdXBkYXRlU3R5bGUoKSB7XG4gICAgICB0aGlzLm11dGFibGVFbGVtZW50cygpLnVwZGF0ZVN0eWxlKCk7IC8vIGp1c3Qgc2VuZCB0byBhbGwgZWxlc1xuICAgIH1cbiAgfTtcblxuICB2YXIgZGVmYXVsdFNlbGVjdGlvblR5cGUgPSAnc2luZ2xlJztcbiAgdmFyIGNvcmVmbiQxID0ge1xuICAgIGF1dG9sb2NrOiBmdW5jdGlvbiBhdXRvbG9jayhib29sKSB7XG4gICAgICBpZiAoYm9vbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGUuYXV0b2xvY2sgPSBib29sID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuYXV0b2xvY2s7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG4gICAgYXV0b3VuZ3JhYmlmeTogZnVuY3Rpb24gYXV0b3VuZ3JhYmlmeShib29sKSB7XG4gICAgICBpZiAoYm9vbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGUuYXV0b3VuZ3JhYmlmeSA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5hdXRvdW5ncmFiaWZ5O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuICAgIGF1dG91bnNlbGVjdGlmeTogZnVuY3Rpb24gYXV0b3Vuc2VsZWN0aWZ5KGJvb2wpIHtcbiAgICAgIGlmIChib29sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZS5hdXRvdW5zZWxlY3RpZnkgPSBib29sID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuYXV0b3Vuc2VsZWN0aWZ5O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuICAgIHNlbGVjdGlvblR5cGU6IGZ1bmN0aW9uIHNlbGVjdGlvblR5cGUoc2VsVHlwZSkge1xuICAgICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcblxuICAgICAgaWYgKF9wLnNlbGVjdGlvblR5cGUgPT0gbnVsbCkge1xuICAgICAgICBfcC5zZWxlY3Rpb25UeXBlID0gZGVmYXVsdFNlbGVjdGlvblR5cGU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHNlbFR5cGUgPT09ICdhZGRpdGl2ZScgfHwgc2VsVHlwZSA9PT0gJ3NpbmdsZScpIHtcbiAgICAgICAgICBfcC5zZWxlY3Rpb25UeXBlID0gc2VsVHlwZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIF9wLnNlbGVjdGlvblR5cGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgcGFubmluZ0VuYWJsZWQ6IGZ1bmN0aW9uIHBhbm5pbmdFbmFibGVkKGJvb2wpIHtcbiAgICAgIGlmIChib29sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZCA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcbiAgICB1c2VyUGFubmluZ0VuYWJsZWQ6IGZ1bmN0aW9uIHVzZXJQYW5uaW5nRW5hYmxlZChib29sKSB7XG4gICAgICBpZiAoYm9vbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGUudXNlclBhbm5pbmdFbmFibGVkID0gYm9vbCA/IHRydWUgOiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnVzZXJQYW5uaW5nRW5hYmxlZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcbiAgICB6b29taW5nRW5hYmxlZDogZnVuY3Rpb24gem9vbWluZ0VuYWJsZWQoYm9vbCkge1xuICAgICAgaWYgKGJvb2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlLnpvb21pbmdFbmFibGVkID0gYm9vbCA/IHRydWUgOiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnpvb21pbmdFbmFibGVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuICAgIHVzZXJab29taW5nRW5hYmxlZDogZnVuY3Rpb24gdXNlclpvb21pbmdFbmFibGVkKGJvb2wpIHtcbiAgICAgIGlmIChib29sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZS51c2VyWm9vbWluZ0VuYWJsZWQgPSBib29sID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUudXNlclpvb21pbmdFbmFibGVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuICAgIGJveFNlbGVjdGlvbkVuYWJsZWQ6IGZ1bmN0aW9uIGJveFNlbGVjdGlvbkVuYWJsZWQoYm9vbCkge1xuICAgICAgaWYgKGJvb2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlLmJveFNlbGVjdGlvbkVuYWJsZWQgPSBib29sID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuYm94U2VsZWN0aW9uRW5hYmxlZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcbiAgICBwYW46IGZ1bmN0aW9uIHBhbigpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgdmFyIHBhbiA9IHRoaXMuX3ByaXZhdGUucGFuO1xuICAgICAgdmFyIGRpbSwgdmFsLCBkaW1zLCB4LCB5O1xuXG4gICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAvLyAucGFuKClcbiAgICAgICAgICByZXR1cm4gcGFuO1xuXG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoc3RyaW5nKGFyZ3NbMF0pKSB7XG4gICAgICAgICAgICAvLyAucGFuKCd4JylcbiAgICAgICAgICAgIGRpbSA9IGFyZ3NbMF07XG4gICAgICAgICAgICByZXR1cm4gcGFuW2RpbV07XG4gICAgICAgICAgfSBlbHNlIGlmIChwbGFpbk9iamVjdChhcmdzWzBdKSkge1xuICAgICAgICAgICAgLy8gLnBhbih7IHg6IDAsIHk6IDEwMCB9KVxuICAgICAgICAgICAgaWYgKCF0aGlzLl9wcml2YXRlLnBhbm5pbmdFbmFibGVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkaW1zID0gYXJnc1swXTtcbiAgICAgICAgICAgIHggPSBkaW1zLng7XG4gICAgICAgICAgICB5ID0gZGltcy55O1xuXG4gICAgICAgICAgICBpZiAobnVtYmVyJDEoeCkpIHtcbiAgICAgICAgICAgICAgcGFuLnggPSB4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobnVtYmVyJDEoeSkpIHtcbiAgICAgICAgICAgICAgcGFuLnkgPSB5O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3BhbiB2aWV3cG9ydCcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAvLyAucGFuKCd4JywgMTAwKVxuICAgICAgICAgIGlmICghdGhpcy5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGltID0gYXJnc1swXTtcbiAgICAgICAgICB2YWwgPSBhcmdzWzFdO1xuXG4gICAgICAgICAgaWYgKChkaW0gPT09ICd4JyB8fCBkaW0gPT09ICd5JykgJiYgbnVtYmVyJDEodmFsKSkge1xuICAgICAgICAgICAgcGFuW2RpbV0gPSB2YWw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5lbWl0KCdwYW4gdmlld3BvcnQnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gaW52YWxpZFxuICAgICAgfVxuXG4gICAgICB0aGlzLm5vdGlmeSgndmlld3BvcnQnKTtcbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG4gICAgcGFuQnk6IGZ1bmN0aW9uIHBhbkJ5KGFyZzAsIGFyZzEpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgdmFyIHBhbiA9IHRoaXMuX3ByaXZhdGUucGFuO1xuICAgICAgdmFyIGRpbSwgdmFsLCBkaW1zLCB4LCB5O1xuXG4gICAgICBpZiAoIXRoaXMuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChwbGFpbk9iamVjdChhcmcwKSkge1xuICAgICAgICAgICAgLy8gLnBhbkJ5KHsgeDogMCwgeTogMTAwIH0pXG4gICAgICAgICAgICBkaW1zID0gYXJnc1swXTtcbiAgICAgICAgICAgIHggPSBkaW1zLng7XG4gICAgICAgICAgICB5ID0gZGltcy55O1xuXG4gICAgICAgICAgICBpZiAobnVtYmVyJDEoeCkpIHtcbiAgICAgICAgICAgICAgcGFuLnggKz0geDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG51bWJlciQxKHkpKSB7XG4gICAgICAgICAgICAgIHBhbi55ICs9IHk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZW1pdCgncGFuIHZpZXdwb3J0Jyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIC8vIC5wYW5CeSgneCcsIDEwMClcbiAgICAgICAgICBkaW0gPSBhcmcwO1xuICAgICAgICAgIHZhbCA9IGFyZzE7XG5cbiAgICAgICAgICBpZiAoKGRpbSA9PT0gJ3gnIHx8IGRpbSA9PT0gJ3knKSAmJiBudW1iZXIkMSh2YWwpKSB7XG4gICAgICAgICAgICBwYW5bZGltXSArPSB2YWw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5lbWl0KCdwYW4gdmlld3BvcnQnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gaW52YWxpZFxuICAgICAgfVxuXG4gICAgICB0aGlzLm5vdGlmeSgndmlld3BvcnQnKTtcbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG4gICAgZml0OiBmdW5jdGlvbiBmaXQoZWxlbWVudHMsIHBhZGRpbmcpIHtcbiAgICAgIHZhciB2aWV3cG9ydFN0YXRlID0gdGhpcy5nZXRGaXRWaWV3cG9ydChlbGVtZW50cywgcGFkZGluZyk7XG5cbiAgICAgIGlmICh2aWV3cG9ydFN0YXRlKSB7XG4gICAgICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgICAgIF9wLnpvb20gPSB2aWV3cG9ydFN0YXRlLnpvb207XG4gICAgICAgIF9wLnBhbiA9IHZpZXdwb3J0U3RhdGUucGFuO1xuICAgICAgICB0aGlzLmVtaXQoJ3BhbiB6b29tIHZpZXdwb3J0Jyk7XG4gICAgICAgIHRoaXMubm90aWZ5KCd2aWV3cG9ydCcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuICAgIGdldEZpdFZpZXdwb3J0OiBmdW5jdGlvbiBnZXRGaXRWaWV3cG9ydChlbGVtZW50cywgcGFkZGluZykge1xuICAgICAgaWYgKG51bWJlciQxKGVsZW1lbnRzKSAmJiBwYWRkaW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gZWxlbWVudHMgaXMgb3B0aW9uYWxcbiAgICAgICAgcGFkZGluZyA9IGVsZW1lbnRzO1xuICAgICAgICBlbGVtZW50cyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLl9wcml2YXRlLnBhbm5pbmdFbmFibGVkIHx8ICF0aGlzLl9wcml2YXRlLnpvb21pbmdFbmFibGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGJiO1xuXG4gICAgICBpZiAoc3RyaW5nKGVsZW1lbnRzKSkge1xuICAgICAgICB2YXIgc2VsID0gZWxlbWVudHM7XG4gICAgICAgIGVsZW1lbnRzID0gdGhpcy4kKHNlbCk7XG4gICAgICB9IGVsc2UgaWYgKGJvdW5kaW5nQm94KGVsZW1lbnRzKSkge1xuICAgICAgICAvLyBhc3N1bWUgYmJcbiAgICAgICAgdmFyIGJiZSA9IGVsZW1lbnRzO1xuICAgICAgICBiYiA9IHtcbiAgICAgICAgICB4MTogYmJlLngxLFxuICAgICAgICAgIHkxOiBiYmUueTEsXG4gICAgICAgICAgeDI6IGJiZS54MixcbiAgICAgICAgICB5MjogYmJlLnkyXG4gICAgICAgIH07XG4gICAgICAgIGJiLncgPSBiYi54MiAtIGJiLngxO1xuICAgICAgICBiYi5oID0gYmIueTIgLSBiYi55MTtcbiAgICAgIH0gZWxzZSBpZiAoIWVsZW1lbnRPckNvbGxlY3Rpb24oZWxlbWVudHMpKSB7XG4gICAgICAgIGVsZW1lbnRzID0gdGhpcy5tdXRhYmxlRWxlbWVudHMoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVsZW1lbnRPckNvbGxlY3Rpb24oZWxlbWVudHMpICYmIGVsZW1lbnRzLmVtcHR5KCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBjYW4ndCBmaXQgdG8gbm90aGluZ1xuXG5cbiAgICAgIGJiID0gYmIgfHwgZWxlbWVudHMuYm91bmRpbmdCb3goKTtcbiAgICAgIHZhciB3ID0gdGhpcy53aWR0aCgpO1xuICAgICAgdmFyIGggPSB0aGlzLmhlaWdodCgpO1xuICAgICAgdmFyIHpvb207XG4gICAgICBwYWRkaW5nID0gbnVtYmVyJDEocGFkZGluZykgPyBwYWRkaW5nIDogMDtcblxuICAgICAgaWYgKCFpc05hTih3KSAmJiAhaXNOYU4oaCkgJiYgdyA+IDAgJiYgaCA+IDAgJiYgIWlzTmFOKGJiLncpICYmICFpc05hTihiYi5oKSAmJiBiYi53ID4gMCAmJiBiYi5oID4gMCkge1xuICAgICAgICB6b29tID0gTWF0aC5taW4oKHcgLSAyICogcGFkZGluZykgLyBiYi53LCAoaCAtIDIgKiBwYWRkaW5nKSAvIGJiLmgpOyAvLyBjcm9wIHpvb21cblxuICAgICAgICB6b29tID0gem9vbSA+IHRoaXMuX3ByaXZhdGUubWF4Wm9vbSA/IHRoaXMuX3ByaXZhdGUubWF4Wm9vbSA6IHpvb207XG4gICAgICAgIHpvb20gPSB6b29tIDwgdGhpcy5fcHJpdmF0ZS5taW5ab29tID8gdGhpcy5fcHJpdmF0ZS5taW5ab29tIDogem9vbTtcbiAgICAgICAgdmFyIHBhbiA9IHtcbiAgICAgICAgICAvLyBub3cgcGFuIHRvIG1pZGRsZVxuICAgICAgICAgIHg6ICh3IC0gem9vbSAqIChiYi54MSArIGJiLngyKSkgLyAyLFxuICAgICAgICAgIHk6IChoIC0gem9vbSAqIChiYi55MSArIGJiLnkyKSkgLyAyXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgem9vbTogem9vbSxcbiAgICAgICAgICBwYW46IHBhblxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfSxcbiAgICB6b29tUmFuZ2U6IGZ1bmN0aW9uIHpvb21SYW5nZShtaW4sIG1heCkge1xuICAgICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcblxuICAgICAgaWYgKG1heCA9PSBudWxsKSB7XG4gICAgICAgIHZhciBvcHRzID0gbWluO1xuICAgICAgICBtaW4gPSBvcHRzLm1pbjtcbiAgICAgICAgbWF4ID0gb3B0cy5tYXg7XG4gICAgICB9XG5cbiAgICAgIGlmIChudW1iZXIkMShtaW4pICYmIG51bWJlciQxKG1heCkgJiYgbWluIDw9IG1heCkge1xuICAgICAgICBfcC5taW5ab29tID0gbWluO1xuICAgICAgICBfcC5tYXhab29tID0gbWF4O1xuICAgICAgfSBlbHNlIGlmIChudW1iZXIkMShtaW4pICYmIG1heCA9PT0gdW5kZWZpbmVkICYmIG1pbiA8PSBfcC5tYXhab29tKSB7XG4gICAgICAgIF9wLm1pblpvb20gPSBtaW47XG4gICAgICB9IGVsc2UgaWYgKG51bWJlciQxKG1heCkgJiYgbWluID09PSB1bmRlZmluZWQgJiYgbWF4ID49IF9wLm1pblpvb20pIHtcbiAgICAgICAgX3AubWF4Wm9vbSA9IG1heDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBtaW5ab29tOiBmdW5jdGlvbiBtaW5ab29tKHpvb20pIHtcbiAgICAgIGlmICh6b29tID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUubWluWm9vbTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnpvb21SYW5nZSh7XG4gICAgICAgICAgbWluOiB6b29tXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgbWF4Wm9vbTogZnVuY3Rpb24gbWF4Wm9vbSh6b29tKSB7XG4gICAgICBpZiAoem9vbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLm1heFpvb207XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy56b29tUmFuZ2Uoe1xuICAgICAgICAgIG1heDogem9vbVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldFpvb21lZFZpZXdwb3J0OiBmdW5jdGlvbiBnZXRab29tZWRWaWV3cG9ydChwYXJhbXMpIHtcbiAgICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgICB2YXIgY3VycmVudFBhbiA9IF9wLnBhbjtcbiAgICAgIHZhciBjdXJyZW50Wm9vbSA9IF9wLnpvb207XG4gICAgICB2YXIgcG9zOyAvLyBpbiByZW5kZXJlZCBweFxuXG4gICAgICB2YXIgem9vbTtcbiAgICAgIHZhciBiYWlsID0gZmFsc2U7XG5cbiAgICAgIGlmICghX3Auem9vbWluZ0VuYWJsZWQpIHtcbiAgICAgICAgLy8gem9vbWluZyBkaXNhYmxlZFxuICAgICAgICBiYWlsID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG51bWJlciQxKHBhcmFtcykpIHtcbiAgICAgICAgLy8gdGhlbiBzZXQgdGhlIHpvb21cbiAgICAgICAgem9vbSA9IHBhcmFtcztcbiAgICAgIH0gZWxzZSBpZiAocGxhaW5PYmplY3QocGFyYW1zKSkge1xuICAgICAgICAvLyB0aGVuIHpvb20gYWJvdXQgYSBwb2ludFxuICAgICAgICB6b29tID0gcGFyYW1zLmxldmVsO1xuXG4gICAgICAgIGlmIChwYXJhbXMucG9zaXRpb24gIT0gbnVsbCkge1xuICAgICAgICAgIHBvcyA9IG1vZGVsVG9SZW5kZXJlZFBvc2l0aW9uKHBhcmFtcy5wb3NpdGlvbiwgY3VycmVudFpvb20sIGN1cnJlbnRQYW4pO1xuICAgICAgICB9IGVsc2UgaWYgKHBhcmFtcy5yZW5kZXJlZFBvc2l0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICBwb3MgPSBwYXJhbXMucmVuZGVyZWRQb3NpdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3MgIT0gbnVsbCAmJiAhX3AucGFubmluZ0VuYWJsZWQpIHtcbiAgICAgICAgICAvLyBwYW5uaW5nIGRpc2FibGVkXG4gICAgICAgICAgYmFpbCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gY3JvcCB6b29tXG5cblxuICAgICAgem9vbSA9IHpvb20gPiBfcC5tYXhab29tID8gX3AubWF4Wm9vbSA6IHpvb207XG4gICAgICB6b29tID0gem9vbSA8IF9wLm1pblpvb20gPyBfcC5taW5ab29tIDogem9vbTsgLy8gY2FuJ3Qgem9vbSB3aXRoIGludmFsaWQgcGFyYW1zXG5cbiAgICAgIGlmIChiYWlsIHx8ICFudW1iZXIkMSh6b29tKSB8fCB6b29tID09PSBjdXJyZW50Wm9vbSB8fCBwb3MgIT0gbnVsbCAmJiAoIW51bWJlciQxKHBvcy54KSB8fCAhbnVtYmVyJDEocG9zLnkpKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHBvcyAhPSBudWxsKSB7XG4gICAgICAgIC8vIHNldCB6b29tIGFib3V0IHBvc2l0aW9uXG4gICAgICAgIHZhciBwYW4xID0gY3VycmVudFBhbjtcbiAgICAgICAgdmFyIHpvb20xID0gY3VycmVudFpvb207XG4gICAgICAgIHZhciB6b29tMiA9IHpvb207XG4gICAgICAgIHZhciBwYW4yID0ge1xuICAgICAgICAgIHg6IC16b29tMiAvIHpvb20xICogKHBvcy54IC0gcGFuMS54KSArIHBvcy54LFxuICAgICAgICAgIHk6IC16b29tMiAvIHpvb20xICogKHBvcy55IC0gcGFuMS55KSArIHBvcy55XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgem9vbWVkOiB0cnVlLFxuICAgICAgICAgIHBhbm5lZDogdHJ1ZSxcbiAgICAgICAgICB6b29tOiB6b29tMixcbiAgICAgICAgICBwYW46IHBhbjJcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGp1c3Qgc2V0IHRoZSB6b29tXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgem9vbWVkOiB0cnVlLFxuICAgICAgICAgIHBhbm5lZDogZmFsc2UsXG4gICAgICAgICAgem9vbTogem9vbSxcbiAgICAgICAgICBwYW46IGN1cnJlbnRQYW5cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHpvb206IGZ1bmN0aW9uIHpvb20ocGFyYW1zKSB7XG4gICAgICBpZiAocGFyYW1zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gZ2V0XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnpvb207XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzZXRcbiAgICAgICAgdmFyIHZwID0gdGhpcy5nZXRab29tZWRWaWV3cG9ydChwYXJhbXMpO1xuICAgICAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuXG4gICAgICAgIGlmICh2cCA9PSBudWxsIHx8ICF2cC56b29tZWQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIF9wLnpvb20gPSB2cC56b29tO1xuXG4gICAgICAgIGlmICh2cC5wYW5uZWQpIHtcbiAgICAgICAgICBfcC5wYW4ueCA9IHZwLnBhbi54O1xuICAgICAgICAgIF9wLnBhbi55ID0gdnAucGFuLnk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmVtaXQoJ3pvb20nICsgKHZwLnBhbm5lZCA/ICcgcGFuJyA6ICcnKSArICcgdmlld3BvcnQnKTtcbiAgICAgICAgdGhpcy5ub3RpZnkoJ3ZpZXdwb3J0Jyk7XG4gICAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgICAgfVxuICAgIH0sXG4gICAgdmlld3BvcnQ6IGZ1bmN0aW9uIHZpZXdwb3J0KG9wdHMpIHtcbiAgICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgICB2YXIgem9vbURlZmQgPSB0cnVlO1xuICAgICAgdmFyIHBhbkRlZmQgPSB0cnVlO1xuICAgICAgdmFyIGV2ZW50cyA9IFtdOyAvLyB0byB0cmlnZ2VyXG5cbiAgICAgIHZhciB6b29tRmFpbGVkID0gZmFsc2U7XG4gICAgICB2YXIgcGFuRmFpbGVkID0gZmFsc2U7XG5cbiAgICAgIGlmICghb3B0cykge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgaWYgKCFudW1iZXIkMShvcHRzLnpvb20pKSB7XG4gICAgICAgIHpvb21EZWZkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICghcGxhaW5PYmplY3Qob3B0cy5wYW4pKSB7XG4gICAgICAgIHBhbkRlZmQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF6b29tRGVmZCAmJiAhcGFuRGVmZCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgaWYgKHpvb21EZWZkKSB7XG4gICAgICAgIHZhciB6ID0gb3B0cy56b29tO1xuXG4gICAgICAgIGlmICh6IDwgX3AubWluWm9vbSB8fCB6ID4gX3AubWF4Wm9vbSB8fCAhX3Auem9vbWluZ0VuYWJsZWQpIHtcbiAgICAgICAgICB6b29tRmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfcC56b29tID0gejtcbiAgICAgICAgICBldmVudHMucHVzaCgnem9vbScpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwYW5EZWZkICYmICghem9vbUZhaWxlZCB8fCAhb3B0cy5jYW5jZWxPbkZhaWxlZFpvb20pICYmIF9wLnBhbm5pbmdFbmFibGVkKSB7XG4gICAgICAgIHZhciBwID0gb3B0cy5wYW47XG5cbiAgICAgICAgaWYgKG51bWJlciQxKHAueCkpIHtcbiAgICAgICAgICBfcC5wYW4ueCA9IHAueDtcbiAgICAgICAgICBwYW5GYWlsZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChudW1iZXIkMShwLnkpKSB7XG4gICAgICAgICAgX3AucGFuLnkgPSBwLnk7XG4gICAgICAgICAgcGFuRmFpbGVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXBhbkZhaWxlZCkge1xuICAgICAgICAgIGV2ZW50cy5wdXNoKCdwYW4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZXZlbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZXZlbnRzLnB1c2goJ3ZpZXdwb3J0Jyk7XG4gICAgICAgIHRoaXMuZW1pdChldmVudHMuam9pbignICcpKTtcbiAgICAgICAgdGhpcy5ub3RpZnkoJ3ZpZXdwb3J0Jyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG4gICAgY2VudGVyOiBmdW5jdGlvbiBjZW50ZXIoZWxlbWVudHMpIHtcbiAgICAgIHZhciBwYW4gPSB0aGlzLmdldENlbnRlclBhbihlbGVtZW50cyk7XG5cbiAgICAgIGlmIChwYW4pIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZS5wYW4gPSBwYW47XG4gICAgICAgIHRoaXMuZW1pdCgncGFuIHZpZXdwb3J0Jyk7XG4gICAgICAgIHRoaXMubm90aWZ5KCd2aWV3cG9ydCcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuICAgIGdldENlbnRlclBhbjogZnVuY3Rpb24gZ2V0Q2VudGVyUGFuKGVsZW1lbnRzLCB6b29tKSB7XG4gICAgICBpZiAoIXRoaXMuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RyaW5nKGVsZW1lbnRzKSkge1xuICAgICAgICB2YXIgc2VsZWN0b3IgPSBlbGVtZW50cztcbiAgICAgICAgZWxlbWVudHMgPSB0aGlzLm11dGFibGVFbGVtZW50cygpLmZpbHRlcihzZWxlY3Rvcik7XG4gICAgICB9IGVsc2UgaWYgKCFlbGVtZW50T3JDb2xsZWN0aW9uKGVsZW1lbnRzKSkge1xuICAgICAgICBlbGVtZW50cyA9IHRoaXMubXV0YWJsZUVsZW1lbnRzKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbGVtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBjYW4ndCBjZW50cmUgcGFuIHRvIG5vdGhpbmdcblxuXG4gICAgICB2YXIgYmIgPSBlbGVtZW50cy5ib3VuZGluZ0JveCgpO1xuICAgICAgdmFyIHcgPSB0aGlzLndpZHRoKCk7XG4gICAgICB2YXIgaCA9IHRoaXMuaGVpZ2h0KCk7XG4gICAgICB6b29tID0gem9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fcHJpdmF0ZS56b29tIDogem9vbTtcbiAgICAgIHZhciBwYW4gPSB7XG4gICAgICAgIC8vIG1pZGRsZVxuICAgICAgICB4OiAodyAtIHpvb20gKiAoYmIueDEgKyBiYi54MikpIC8gMixcbiAgICAgICAgeTogKGggLSB6b29tICogKGJiLnkxICsgYmIueTIpKSAvIDJcbiAgICAgIH07XG4gICAgICByZXR1cm4gcGFuO1xuICAgIH0sXG4gICAgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgaWYgKCF0aGlzLl9wcml2YXRlLnBhbm5pbmdFbmFibGVkIHx8ICF0aGlzLl9wcml2YXRlLnpvb21pbmdFbmFibGVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnZpZXdwb3J0KHtcbiAgICAgICAgcGFuOiB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH0sXG4gICAgICAgIHpvb206IDFcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcbiAgICBpbnZhbGlkYXRlU2l6ZTogZnVuY3Rpb24gaW52YWxpZGF0ZVNpemUoKSB7XG4gICAgICB0aGlzLl9wcml2YXRlLnNpemVDYWNoZSA9IG51bGw7XG4gICAgfSxcbiAgICBzaXplOiBmdW5jdGlvbiBzaXplKCkge1xuICAgICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICAgIHZhciBjb250YWluZXIgPSBfcC5jb250YWluZXI7XG4gICAgICByZXR1cm4gX3Auc2l6ZUNhY2hlID0gX3Auc2l6ZUNhY2hlIHx8IChjb250YWluZXIgPyBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdHlsZSA9IHdpbmRvdyQxLmdldENvbXB1dGVkU3R5bGUoY29udGFpbmVyKTtcblxuICAgICAgICB2YXIgdmFsID0gZnVuY3Rpb24gdmFsKG5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKG5hbWUpKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHdpZHRoOiBjb250YWluZXIuY2xpZW50V2lkdGggLSB2YWwoJ3BhZGRpbmctbGVmdCcpIC0gdmFsKCdwYWRkaW5nLXJpZ2h0JyksXG4gICAgICAgICAgaGVpZ2h0OiBjb250YWluZXIuY2xpZW50SGVpZ2h0IC0gdmFsKCdwYWRkaW5nLXRvcCcpIC0gdmFsKCdwYWRkaW5nLWJvdHRvbScpXG4gICAgICAgIH07XG4gICAgICB9KCkgOiB7XG4gICAgICAgIC8vIGZhbGxiYWNrIGlmIG5vIGNvbnRhaW5lciAobm90IDAgYi9jIGNhbiBiZSB1c2VkIGZvciBkaXZpZGluZyBldGMpXG4gICAgICAgIHdpZHRoOiAxLFxuICAgICAgICBoZWlnaHQ6IDFcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgd2lkdGg6IGZ1bmN0aW9uIHdpZHRoKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2l6ZSgpLndpZHRoO1xuICAgIH0sXG4gICAgaGVpZ2h0OiBmdW5jdGlvbiBoZWlnaHQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zaXplKCkuaGVpZ2h0O1xuICAgIH0sXG4gICAgZXh0ZW50OiBmdW5jdGlvbiBleHRlbnQoKSB7XG4gICAgICB2YXIgcGFuID0gdGhpcy5fcHJpdmF0ZS5wYW47XG4gICAgICB2YXIgem9vbSA9IHRoaXMuX3ByaXZhdGUuem9vbTtcbiAgICAgIHZhciByYiA9IHRoaXMucmVuZGVyZWRFeHRlbnQoKTtcbiAgICAgIHZhciBiID0ge1xuICAgICAgICB4MTogKHJiLngxIC0gcGFuLngpIC8gem9vbSxcbiAgICAgICAgeDI6IChyYi54MiAtIHBhbi54KSAvIHpvb20sXG4gICAgICAgIHkxOiAocmIueTEgLSBwYW4ueSkgLyB6b29tLFxuICAgICAgICB5MjogKHJiLnkyIC0gcGFuLnkpIC8gem9vbVxuICAgICAgfTtcbiAgICAgIGIudyA9IGIueDIgLSBiLngxO1xuICAgICAgYi5oID0gYi55MiAtIGIueTE7XG4gICAgICByZXR1cm4gYjtcbiAgICB9LFxuICAgIHJlbmRlcmVkRXh0ZW50OiBmdW5jdGlvbiByZW5kZXJlZEV4dGVudCgpIHtcbiAgICAgIHZhciB3aWR0aCA9IHRoaXMud2lkdGgoKTtcbiAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmhlaWdodCgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDE6IDAsXG4gICAgICAgIHkxOiAwLFxuICAgICAgICB4Mjogd2lkdGgsXG4gICAgICAgIHkyOiBoZWlnaHQsXG4gICAgICAgIHc6IHdpZHRoLFxuICAgICAgICBoOiBoZWlnaHRcbiAgICAgIH07XG4gICAgfSxcbiAgICBtdWx0aUNsaWNrRGVib3VuY2VUaW1lOiBmdW5jdGlvbiBtdWx0aUNsaWNrRGVib3VuY2VUaW1lKF9pbnQpIHtcbiAgICAgIGlmIChfaW50KSB0aGlzLl9wcml2YXRlLm11bHRpQ2xpY2tEZWJvdW5jZVRpbWUgPSBfaW50O2Vsc2UgcmV0dXJuIHRoaXMuX3ByaXZhdGUubXVsdGlDbGlja0RlYm91bmNlVGltZTtcbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH1cbiAgfTsgLy8gYWxpYXNlc1xuXG4gIGNvcmVmbiQxLmNlbnRyZSA9IGNvcmVmbiQxLmNlbnRlcjsgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblxuICBjb3JlZm4kMS5hdXRvbG9ja05vZGVzID0gY29yZWZuJDEuYXV0b2xvY2s7XG4gIGNvcmVmbiQxLmF1dG91bmdyYWJpZnlOb2RlcyA9IGNvcmVmbiQxLmF1dG91bmdyYWJpZnk7XG5cbiAgdmFyIGZuID0ge1xuICAgIGRhdGE6IGRlZmluZS5kYXRhKHtcbiAgICAgIGZpZWxkOiAnZGF0YScsXG4gICAgICBiaW5kaW5nRXZlbnQ6ICdkYXRhJyxcbiAgICAgIGFsbG93QmluZGluZzogdHJ1ZSxcbiAgICAgIGFsbG93U2V0dGluZzogdHJ1ZSxcbiAgICAgIHNldHRpbmdFdmVudDogJ2RhdGEnLFxuICAgICAgc2V0dGluZ1RyaWdnZXJzRXZlbnQ6IHRydWUsXG4gICAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgICBhbGxvd0dldHRpbmc6IHRydWUsXG4gICAgICB1cGRhdGVTdHlsZTogdHJ1ZVxuICAgIH0pLFxuICAgIHJlbW92ZURhdGE6IGRlZmluZS5yZW1vdmVEYXRhKHtcbiAgICAgIGZpZWxkOiAnZGF0YScsXG4gICAgICBldmVudDogJ2RhdGEnLFxuICAgICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgICAgdHJpZ2dlckV2ZW50OiB0cnVlLFxuICAgICAgdXBkYXRlU3R5bGU6IHRydWVcbiAgICB9KSxcbiAgICBzY3JhdGNoOiBkZWZpbmUuZGF0YSh7XG4gICAgICBmaWVsZDogJ3NjcmF0Y2gnLFxuICAgICAgYmluZGluZ0V2ZW50OiAnc2NyYXRjaCcsXG4gICAgICBhbGxvd0JpbmRpbmc6IHRydWUsXG4gICAgICBhbGxvd1NldHRpbmc6IHRydWUsXG4gICAgICBzZXR0aW5nRXZlbnQ6ICdzY3JhdGNoJyxcbiAgICAgIHNldHRpbmdUcmlnZ2Vyc0V2ZW50OiB0cnVlLFxuICAgICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgICAgYWxsb3dHZXR0aW5nOiB0cnVlLFxuICAgICAgdXBkYXRlU3R5bGU6IHRydWVcbiAgICB9KSxcbiAgICByZW1vdmVTY3JhdGNoOiBkZWZpbmUucmVtb3ZlRGF0YSh7XG4gICAgICBmaWVsZDogJ3NjcmF0Y2gnLFxuICAgICAgZXZlbnQ6ICdzY3JhdGNoJyxcbiAgICAgIHRyaWdnZXJGbk5hbWU6ICd0cmlnZ2VyJyxcbiAgICAgIHRyaWdnZXJFdmVudDogdHJ1ZSxcbiAgICAgIHVwZGF0ZVN0eWxlOiB0cnVlXG4gICAgfSlcbiAgfTsgLy8gYWxpYXNlc1xuXG4gIGZuLmF0dHIgPSBmbi5kYXRhO1xuICBmbi5yZW1vdmVBdHRyID0gZm4ucmVtb3ZlRGF0YTtcblxuICB2YXIgQ29yZSA9IGZ1bmN0aW9uIENvcmUob3B0cykge1xuICAgIHZhciBjeSA9IHRoaXM7XG4gICAgb3B0cyA9IGV4dGVuZCh7fSwgb3B0cyk7XG4gICAgdmFyIGNvbnRhaW5lciA9IG9wdHMuY29udGFpbmVyOyAvLyBhbGxvdyBmb3IgcGFzc2luZyBhIHdyYXBwZWQganF1ZXJ5IG9iamVjdFxuICAgIC8vIGUuZy4gY3l0b3NjYXBlKHsgY29udGFpbmVyOiAkKCcjY3knKSB9KVxuXG4gICAgaWYgKGNvbnRhaW5lciAmJiAhaHRtbEVsZW1lbnQoY29udGFpbmVyKSAmJiBodG1sRWxlbWVudChjb250YWluZXJbMF0pKSB7XG4gICAgICBjb250YWluZXIgPSBjb250YWluZXJbMF07XG4gICAgfVxuXG4gICAgdmFyIHJlZyA9IGNvbnRhaW5lciA/IGNvbnRhaW5lci5fY3lyZWcgOiBudWxsOyAvLyBlLmcuIGFscmVhZHkgcmVnaXN0ZXJlZCBzb21lIGluZm8gKGUuZy4gcmVhZGllcykgdmlhIGpxdWVyeVxuXG4gICAgcmVnID0gcmVnIHx8IHt9O1xuXG4gICAgaWYgKHJlZyAmJiByZWcuY3kpIHtcbiAgICAgIHJlZy5jeS5kZXN0cm95KCk7XG4gICAgICByZWcgPSB7fTsgLy8gb2xkIGluc3RhbmNlID0+IHJlcGxhY2UgcmVnIGNvbXBsZXRlbHlcbiAgICB9XG5cbiAgICB2YXIgcmVhZGllcyA9IHJlZy5yZWFkaWVzID0gcmVnLnJlYWRpZXMgfHwgW107XG5cbiAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICBjb250YWluZXIuX2N5cmVnID0gcmVnO1xuICAgIH0gLy8gbWFrZSBzdXJlIGNvbnRhaW5lciBhc3NvYydkIHJlZyBwb2ludHMgdG8gdGhpcyBjeVxuXG5cbiAgICByZWcuY3kgPSBjeTtcbiAgICB2YXIgaGVhZCA9IHdpbmRvdyQxICE9PSB1bmRlZmluZWQgJiYgY29udGFpbmVyICE9PSB1bmRlZmluZWQgJiYgIW9wdHMuaGVhZGxlc3M7XG4gICAgdmFyIG9wdGlvbnMgPSBvcHRzO1xuICAgIG9wdGlvbnMubGF5b3V0ID0gZXh0ZW5kKHtcbiAgICAgIG5hbWU6IGhlYWQgPyAnZ3JpZCcgOiAnbnVsbCdcbiAgICB9LCBvcHRpb25zLmxheW91dCk7XG4gICAgb3B0aW9ucy5yZW5kZXJlciA9IGV4dGVuZCh7XG4gICAgICBuYW1lOiBoZWFkID8gJ2NhbnZhcycgOiAnbnVsbCdcbiAgICB9LCBvcHRpb25zLnJlbmRlcmVyKTtcblxuICAgIHZhciBkZWZWYWwgPSBmdW5jdGlvbiBkZWZWYWwoZGVmLCB2YWwsIGFsdFZhbCkge1xuICAgICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgICB9IGVsc2UgaWYgKGFsdFZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBhbHRWYWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZGVmO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlID0ge1xuICAgICAgY29udGFpbmVyOiBjb250YWluZXIsXG4gICAgICAvLyBodG1sIGRvbSBlbGUgY29udGFpbmVyXG4gICAgICByZWFkeTogZmFsc2UsXG4gICAgICAvLyB3aGV0aGVyIHJlYWR5IGhhcyBiZWVuIHRyaWdnZXJlZFxuICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgIC8vIGNhY2hlZCBvcHRpb25zXG4gICAgICBlbGVtZW50czogbmV3IENvbGxlY3Rpb24odGhpcyksXG4gICAgICAvLyBlbGVtZW50cyBpbiB0aGUgZ3JhcGhcbiAgICAgIGxpc3RlbmVyczogW10sXG4gICAgICAvLyBsaXN0IG9mIGxpc3RlbmVyc1xuICAgICAgYW5pRWxlczogbmV3IENvbGxlY3Rpb24odGhpcyksXG4gICAgICAvLyBlbGVtZW50cyBiZWluZyBhbmltYXRlZFxuICAgICAgZGF0YTogb3B0aW9ucy5kYXRhIHx8IHt9LFxuICAgICAgLy8gZGF0YSBmb3IgdGhlIGNvcmVcbiAgICAgIHNjcmF0Y2g6IHt9LFxuICAgICAgLy8gc2NyYXRjaCBvYmplY3QgZm9yIGNvcmVcbiAgICAgIGxheW91dDogbnVsbCxcbiAgICAgIHJlbmRlcmVyOiBudWxsLFxuICAgICAgZGVzdHJveWVkOiBmYWxzZSxcbiAgICAgIC8vIHdoZXRoZXIgZGVzdHJveSB3YXMgY2FsbGVkXG4gICAgICBub3RpZmljYXRpb25zRW5hYmxlZDogdHJ1ZSxcbiAgICAgIC8vIHdoZXRoZXIgbm90aWZpY2F0aW9ucyBhcmUgc2VudCB0byB0aGUgcmVuZGVyZXJcbiAgICAgIG1pblpvb206IDFlLTUwLFxuICAgICAgbWF4Wm9vbTogMWU1MCxcbiAgICAgIHpvb21pbmdFbmFibGVkOiBkZWZWYWwodHJ1ZSwgb3B0aW9ucy56b29taW5nRW5hYmxlZCksXG4gICAgICB1c2VyWm9vbWluZ0VuYWJsZWQ6IGRlZlZhbCh0cnVlLCBvcHRpb25zLnVzZXJab29taW5nRW5hYmxlZCksXG4gICAgICBwYW5uaW5nRW5hYmxlZDogZGVmVmFsKHRydWUsIG9wdGlvbnMucGFubmluZ0VuYWJsZWQpLFxuICAgICAgdXNlclBhbm5pbmdFbmFibGVkOiBkZWZWYWwodHJ1ZSwgb3B0aW9ucy51c2VyUGFubmluZ0VuYWJsZWQpLFxuICAgICAgYm94U2VsZWN0aW9uRW5hYmxlZDogZGVmVmFsKHRydWUsIG9wdGlvbnMuYm94U2VsZWN0aW9uRW5hYmxlZCksXG4gICAgICBhdXRvbG9jazogZGVmVmFsKGZhbHNlLCBvcHRpb25zLmF1dG9sb2NrLCBvcHRpb25zLmF1dG9sb2NrTm9kZXMpLFxuICAgICAgYXV0b3VuZ3JhYmlmeTogZGVmVmFsKGZhbHNlLCBvcHRpb25zLmF1dG91bmdyYWJpZnksIG9wdGlvbnMuYXV0b3VuZ3JhYmlmeU5vZGVzKSxcbiAgICAgIGF1dG91bnNlbGVjdGlmeTogZGVmVmFsKGZhbHNlLCBvcHRpb25zLmF1dG91bnNlbGVjdGlmeSksXG4gICAgICBzdHlsZUVuYWJsZWQ6IG9wdGlvbnMuc3R5bGVFbmFibGVkID09PSB1bmRlZmluZWQgPyBoZWFkIDogb3B0aW9ucy5zdHlsZUVuYWJsZWQsXG4gICAgICB6b29tOiBudW1iZXIkMShvcHRpb25zLnpvb20pID8gb3B0aW9ucy56b29tIDogMSxcbiAgICAgIHBhbjoge1xuICAgICAgICB4OiBwbGFpbk9iamVjdChvcHRpb25zLnBhbikgJiYgbnVtYmVyJDEob3B0aW9ucy5wYW4ueCkgPyBvcHRpb25zLnBhbi54IDogMCxcbiAgICAgICAgeTogcGxhaW5PYmplY3Qob3B0aW9ucy5wYW4pICYmIG51bWJlciQxKG9wdGlvbnMucGFuLnkpID8gb3B0aW9ucy5wYW4ueSA6IDBcbiAgICAgIH0sXG4gICAgICBhbmltYXRpb246IHtcbiAgICAgICAgLy8gb2JqZWN0IGZvciBjdXJyZW50bHktcnVubmluZyBhbmltYXRpb25zXG4gICAgICAgIGN1cnJlbnQ6IFtdLFxuICAgICAgICBxdWV1ZTogW11cbiAgICAgIH0sXG4gICAgICBoYXNDb21wb3VuZE5vZGVzOiBmYWxzZSxcbiAgICAgIG11bHRpQ2xpY2tEZWJvdW5jZVRpbWU6IGRlZlZhbCgyNTAsIG9wdGlvbnMubXVsdGlDbGlja0RlYm91bmNlVGltZSlcbiAgICB9O1xuXG4gICAgdGhpcy5jcmVhdGVFbWl0dGVyKCk7IC8vIHNldCBzZWxlY3Rpb24gdHlwZVxuXG4gICAgdGhpcy5zZWxlY3Rpb25UeXBlKG9wdGlvbnMuc2VsZWN0aW9uVHlwZSk7IC8vIGluaXQgem9vbSBib3VuZHNcblxuICAgIHRoaXMuem9vbVJhbmdlKHtcbiAgICAgIG1pbjogb3B0aW9ucy5taW5ab29tLFxuICAgICAgbWF4OiBvcHRpb25zLm1heFpvb21cbiAgICB9KTtcblxuICAgIHZhciBsb2FkRXh0RGF0YSA9IGZ1bmN0aW9uIGxvYWRFeHREYXRhKGV4dERhdGEsIG5leHQpIHtcbiAgICAgIHZhciBhbnlJc1Byb21pc2UgPSBleHREYXRhLnNvbWUocHJvbWlzZSk7XG5cbiAgICAgIGlmIChhbnlJc1Byb21pc2UpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UkMS5hbGwoZXh0RGF0YSkudGhlbihuZXh0KTsgLy8gbG9hZCBhbGwgZGF0YSBhc3luY2hyb25vdXNseSwgdGhlbiBleGVjIHJlc3Qgb2YgaW5pdFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dChleHREYXRhKTsgLy8gZXhlYyBzeW5jaHJvbm91c2x5IGZvciBjb252ZW5pZW5jZVxuICAgICAgfVxuICAgIH07IC8vIHN0YXJ0IHdpdGggdGhlIGRlZmF1bHQgc3R5bGVzaGVldCBzbyB3ZSBoYXZlIHNvbWV0aGluZyBiZWZvcmUgbG9hZGluZyBhbiBleHRlcm5hbCBzdHlsZXNoZWV0XG5cblxuICAgIGlmIChfcC5zdHlsZUVuYWJsZWQpIHtcbiAgICAgIGN5LnNldFN0eWxlKFtdKTtcbiAgICB9IC8vIGNyZWF0ZSB0aGUgcmVuZGVyZXJcblxuXG4gICAgdmFyIHJlbmRlcmVyT3B0aW9ucyA9IGV4dGVuZCh7fSwgb3B0aW9ucywgb3B0aW9ucy5yZW5kZXJlcik7IC8vIGFsbG93IHJlbmRlcmluZyBoaW50cyBpbiB0b3AgbGV2ZWwgb3B0aW9uc1xuXG4gICAgY3kuaW5pdFJlbmRlcmVyKHJlbmRlcmVyT3B0aW9ucyk7XG5cbiAgICB2YXIgc2V0RWxlc0FuZExheW91dCA9IGZ1bmN0aW9uIHNldEVsZXNBbmRMYXlvdXQoZWxlbWVudHMsIG9ubG9hZCwgb25kb25lKSB7XG4gICAgICBjeS5ub3RpZmljYXRpb25zKGZhbHNlKTsgLy8gcmVtb3ZlIG9sZCBlbGVtZW50c1xuXG4gICAgICB2YXIgb2xkRWxlcyA9IGN5Lm11dGFibGVFbGVtZW50cygpO1xuXG4gICAgICBpZiAob2xkRWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIG9sZEVsZXMucmVtb3ZlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbGVtZW50cyAhPSBudWxsKSB7XG4gICAgICAgIGlmIChwbGFpbk9iamVjdChlbGVtZW50cykgfHwgYXJyYXkoZWxlbWVudHMpKSB7XG4gICAgICAgICAgY3kuYWRkKGVsZW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjeS5vbmUoJ2xheW91dHJlYWR5JywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgY3kubm90aWZpY2F0aW9ucyh0cnVlKTtcbiAgICAgICAgY3kuZW1pdChlKTsgLy8gd2UgbWlzc2VkIHRoaXMgZXZlbnQgYnkgdHVybmluZyBub3RpZmljYXRpb25zIG9mZiwgc28gcGFzcyBpdCBvblxuXG4gICAgICAgIGN5Lm9uZSgnbG9hZCcsIG9ubG9hZCk7XG4gICAgICAgIGN5LmVtaXRBbmROb3RpZnkoJ2xvYWQnKTtcbiAgICAgIH0pLm9uZSgnbGF5b3V0c3RvcCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3kub25lKCdkb25lJywgb25kb25lKTtcbiAgICAgICAgY3kuZW1pdCgnZG9uZScpO1xuICAgICAgfSk7XG4gICAgICB2YXIgbGF5b3V0T3B0cyA9IGV4dGVuZCh7fSwgY3kuX3ByaXZhdGUub3B0aW9ucy5sYXlvdXQpO1xuICAgICAgbGF5b3V0T3B0cy5lbGVzID0gY3kuZWxlbWVudHMoKTtcbiAgICAgIGN5LmxheW91dChsYXlvdXRPcHRzKS5ydW4oKTtcbiAgICB9O1xuXG4gICAgbG9hZEV4dERhdGEoW29wdGlvbnMuc3R5bGUsIG9wdGlvbnMuZWxlbWVudHNdLCBmdW5jdGlvbiAodGhlbnMpIHtcbiAgICAgIHZhciBpbml0U3R5bGUgPSB0aGVuc1swXTtcbiAgICAgIHZhciBpbml0RWxlcyA9IHRoZW5zWzFdOyAvLyBpbml0IHN0eWxlXG5cbiAgICAgIGlmIChfcC5zdHlsZUVuYWJsZWQpIHtcbiAgICAgICAgY3kuc3R5bGUoKS5hcHBlbmQoaW5pdFN0eWxlKTtcbiAgICAgIH0gLy8gaW5pdGlhbCBsb2FkXG5cblxuICAgICAgc2V0RWxlc0FuZExheW91dChpbml0RWxlcywgZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBvbnJlYWR5XG4gICAgICAgIGN5LnN0YXJ0QW5pbWF0aW9uTG9vcCgpO1xuICAgICAgICBfcC5yZWFkeSA9IHRydWU7IC8vIGlmIGEgcmVhZHkgY2FsbGJhY2sgaXMgc3BlY2lmaWVkIGFzIGFuIG9wdGlvbiwgdGhlIGJpbmQgaXRcblxuICAgICAgICBpZiAoZm4kNihvcHRpb25zLnJlYWR5KSkge1xuICAgICAgICAgIGN5Lm9uKCdyZWFkeScsIG9wdGlvbnMucmVhZHkpO1xuICAgICAgICB9IC8vIGJpbmQgYWxsIHRoZSByZWFkeSBoYW5kbGVycyByZWdpc3RlcmVkIGJlZm9yZSBjcmVhdGluZyB0aGlzIGluc3RhbmNlXG5cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlYWRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZm4gPSByZWFkaWVzW2ldO1xuICAgICAgICAgIGN5Lm9uKCdyZWFkeScsIGZuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZWcpIHtcbiAgICAgICAgICByZWcucmVhZGllcyA9IFtdO1xuICAgICAgICB9IC8vIGNsZWFyIGIvYyB3ZSd2ZSBib3VuZCB0aGVtIGFsbCBhbmQgZG9uJ3Qgd2FudCB0byBrZWVwIGl0IGFyb3VuZCBpbiBjYXNlIGEgbmV3IGNvcmUgdXNlcyB0aGUgc2FtZSBkaXYgZXRjXG5cblxuICAgICAgICBjeS5lbWl0KCdyZWFkeScpO1xuICAgICAgfSwgb3B0aW9ucy5kb25lKTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgY29yZWZuID0gQ29yZS5wcm90b3R5cGU7IC8vIHNob3J0IGFsaWFzXG5cbiAgZXh0ZW5kKGNvcmVmbiwge1xuICAgIGluc3RhbmNlU3RyaW5nOiBmdW5jdGlvbiBpbnN0YW5jZVN0cmluZygpIHtcbiAgICAgIHJldHVybiAnY29yZSc7XG4gICAgfSxcbiAgICBpc1JlYWR5OiBmdW5jdGlvbiBpc1JlYWR5KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUucmVhZHk7XG4gICAgfSxcbiAgICBkZXN0cm95ZWQ6IGZ1bmN0aW9uIGRlc3Ryb3llZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmRlc3Ryb3llZDtcbiAgICB9LFxuICAgIHJlYWR5OiBmdW5jdGlvbiByZWFkeShmbikge1xuICAgICAgaWYgKHRoaXMuaXNSZWFkeSgpKSB7XG4gICAgICAgIHRoaXMuZW1pdHRlcigpLmVtaXQoJ3JlYWR5JywgW10sIGZuKTsgLy8ganVzdCBjYWxscyBmbiBhcyB0aG91Z2ggdHJpZ2dlcmVkIHZpYSByZWFkeSBldmVudFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vbigncmVhZHknLCBmbik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHZhciBjeSA9IHRoaXM7XG4gICAgICBpZiAoY3kuZGVzdHJveWVkKCkpIHJldHVybjtcbiAgICAgIGN5LnN0b3BBbmltYXRpb25Mb29wKCk7XG4gICAgICBjeS5kZXN0cm95UmVuZGVyZXIoKTtcbiAgICAgIHRoaXMuZW1pdCgnZGVzdHJveScpO1xuICAgICAgY3kuX3ByaXZhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBjeTtcbiAgICB9LFxuICAgIGhhc0VsZW1lbnRXaXRoSWQ6IGZ1bmN0aW9uIGhhc0VsZW1lbnRXaXRoSWQoaWQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmVsZW1lbnRzLmhhc0VsZW1lbnRXaXRoSWQoaWQpO1xuICAgIH0sXG4gICAgZ2V0RWxlbWVudEJ5SWQ6IGZ1bmN0aW9uIGdldEVsZW1lbnRCeUlkKGlkKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5lbGVtZW50cy5nZXRFbGVtZW50QnlJZChpZCk7XG4gICAgfSxcbiAgICBoYXNDb21wb3VuZE5vZGVzOiBmdW5jdGlvbiBoYXNDb21wb3VuZE5vZGVzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuaGFzQ29tcG91bmROb2RlcztcbiAgICB9LFxuICAgIGhlYWRsZXNzOiBmdW5jdGlvbiBoZWFkbGVzcygpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnJlbmRlcmVyLmlzSGVhZGxlc3MoKTtcbiAgICB9LFxuICAgIHN0eWxlRW5hYmxlZDogZnVuY3Rpb24gc3R5bGVFbmFibGVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuc3R5bGVFbmFibGVkO1xuICAgIH0sXG4gICAgYWRkVG9Qb29sOiBmdW5jdGlvbiBhZGRUb1Bvb2woZWxlcykge1xuICAgICAgdGhpcy5fcHJpdmF0ZS5lbGVtZW50cy5tZXJnZShlbGVzKTtcblxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcbiAgICByZW1vdmVGcm9tUG9vbDogZnVuY3Rpb24gcmVtb3ZlRnJvbVBvb2woZWxlcykge1xuICAgICAgdGhpcy5fcHJpdmF0ZS5lbGVtZW50cy51bm1lcmdlKGVsZXMpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGNvbnRhaW5lcjogZnVuY3Rpb24gY29udGFpbmVyKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuY29udGFpbmVyIHx8IG51bGw7XG4gICAgfSxcbiAgICBtb3VudDogZnVuY3Rpb24gbW91bnQoY29udGFpbmVyKSB7XG4gICAgICBpZiAoY29udGFpbmVyID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3kgPSB0aGlzO1xuICAgICAgdmFyIF9wID0gY3kuX3ByaXZhdGU7XG4gICAgICB2YXIgb3B0aW9ucyA9IF9wLm9wdGlvbnM7XG5cbiAgICAgIGlmICghaHRtbEVsZW1lbnQoY29udGFpbmVyKSAmJiBodG1sRWxlbWVudChjb250YWluZXJbMF0pKSB7XG4gICAgICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lclswXTtcbiAgICAgIH1cblxuICAgICAgY3kuc3RvcEFuaW1hdGlvbkxvb3AoKTtcbiAgICAgIGN5LmRlc3Ryb3lSZW5kZXJlcigpO1xuICAgICAgX3AuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgX3Auc3R5bGVFbmFibGVkID0gdHJ1ZTtcbiAgICAgIGN5LmludmFsaWRhdGVTaXplKCk7XG4gICAgICBjeS5pbml0UmVuZGVyZXIoZXh0ZW5kKHt9LCBvcHRpb25zLCBvcHRpb25zLnJlbmRlcmVyLCB7XG4gICAgICAgIC8vIGFsbG93IGN1c3RvbSByZW5kZXJlciBuYW1lIHRvIGJlIHJlLXVzZWQsIG90aGVyd2lzZSB1c2UgY2FudmFzXG4gICAgICAgIG5hbWU6IG9wdGlvbnMucmVuZGVyZXIubmFtZSA9PT0gJ251bGwnID8gJ2NhbnZhcycgOiBvcHRpb25zLnJlbmRlcmVyLm5hbWVcbiAgICAgIH0pKTtcbiAgICAgIGN5LnN0YXJ0QW5pbWF0aW9uTG9vcCgpO1xuICAgICAgY3kuc3R5bGUob3B0aW9ucy5zdHlsZSk7XG4gICAgICBjeS5lbWl0KCdtb3VudCcpO1xuICAgICAgcmV0dXJuIGN5O1xuICAgIH0sXG4gICAgdW5tb3VudDogZnVuY3Rpb24gdW5tb3VudCgpIHtcbiAgICAgIHZhciBjeSA9IHRoaXM7XG4gICAgICBjeS5zdG9wQW5pbWF0aW9uTG9vcCgpO1xuICAgICAgY3kuZGVzdHJveVJlbmRlcmVyKCk7XG4gICAgICBjeS5pbml0UmVuZGVyZXIoe1xuICAgICAgICBuYW1lOiAnbnVsbCdcbiAgICAgIH0pO1xuICAgICAgY3kuZW1pdCgndW5tb3VudCcpO1xuICAgICAgcmV0dXJuIGN5O1xuICAgIH0sXG4gICAgb3B0aW9uczogZnVuY3Rpb24gb3B0aW9ucygpIHtcbiAgICAgIHJldHVybiBjb3B5KHRoaXMuX3ByaXZhdGUub3B0aW9ucyk7XG4gICAgfSxcbiAgICBqc29uOiBmdW5jdGlvbiBqc29uKG9iaikge1xuICAgICAgdmFyIGN5ID0gdGhpcztcbiAgICAgIHZhciBfcCA9IGN5Ll9wcml2YXRlO1xuICAgICAgdmFyIGVsZXMgPSBjeS5tdXRhYmxlRWxlbWVudHMoKTtcblxuICAgICAgdmFyIGdldEZyZXNoUmVmID0gZnVuY3Rpb24gZ2V0RnJlc2hSZWYoZWxlKSB7XG4gICAgICAgIHJldHVybiBjeS5nZXRFbGVtZW50QnlJZChlbGUuaWQoKSk7XG4gICAgICB9O1xuXG4gICAgICBpZiAocGxhaW5PYmplY3Qob2JqKSkge1xuICAgICAgICAvLyBzZXRcbiAgICAgICAgY3kuc3RhcnRCYXRjaCgpO1xuXG4gICAgICAgIGlmIChvYmouZWxlbWVudHMpIHtcbiAgICAgICAgICB2YXIgaWRJbkpzb24gPSB7fTtcblxuICAgICAgICAgIHZhciB1cGRhdGVFbGVzID0gZnVuY3Rpb24gdXBkYXRlRWxlcyhqc29ucywgZ3IpIHtcbiAgICAgICAgICAgIHZhciB0b0FkZCA9IFtdO1xuICAgICAgICAgICAgdmFyIHRvTW9kID0gW107XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwganNvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIGpzb24gPSBqc29uc1tpXTtcblxuICAgICAgICAgICAgICBpZiAoIWpzb24uZGF0YS5pZCkge1xuICAgICAgICAgICAgICAgIHdhcm4oJ2N5Lmpzb24oKSBjYW5ub3QgaGFuZGxlIGVsZW1lbnRzIHdpdGhvdXQgYW4gSUQgYXR0cmlidXRlJyk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgaWQgPSAnJyArIGpzb24uZGF0YS5pZDsgLy8gaWQgbXVzdCBiZSBzdHJpbmdcblxuICAgICAgICAgICAgICB2YXIgZWxlID0gY3kuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICAgICAgICAgICAgICBpZEluSnNvbltpZF0gPSB0cnVlO1xuXG4gICAgICAgICAgICAgIGlmIChlbGUubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gZXhpc3RpbmcgZWxlbWVudCBzaG91bGQgYmUgdXBkYXRlZFxuICAgICAgICAgICAgICAgIHRvTW9kLnB1c2goe1xuICAgICAgICAgICAgICAgICAgZWxlOiBlbGUsXG4gICAgICAgICAgICAgICAgICBqc29uOiBqc29uXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHNob3VsZCBiZSBhZGRlZFxuICAgICAgICAgICAgICAgIGlmIChncikge1xuICAgICAgICAgICAgICAgICAganNvbi5ncm91cCA9IGdyO1xuICAgICAgICAgICAgICAgICAgdG9BZGQucHVzaChqc29uKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdG9BZGQucHVzaChqc29uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3kuYWRkKHRvQWRkKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHRvTW9kLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICB2YXIgX3RvTW9kJF9pID0gdG9Nb2RbX2ldLFxuICAgICAgICAgICAgICAgICAgX2VsZSA9IF90b01vZCRfaS5lbGUsXG4gICAgICAgICAgICAgICAgICBfanNvbiA9IF90b01vZCRfaS5qc29uO1xuXG4gICAgICAgICAgICAgIF9lbGUuanNvbihfanNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmIChhcnJheShvYmouZWxlbWVudHMpKSB7XG4gICAgICAgICAgICAvLyBlbGVtZW50czogW11cbiAgICAgICAgICAgIHVwZGF0ZUVsZXMob2JqLmVsZW1lbnRzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZWxlbWVudHM6IHsgbm9kZXM6IFtdLCBlZGdlczogW10gfVxuICAgICAgICAgICAgdmFyIGdycyA9IFsnbm9kZXMnLCAnZWRnZXMnXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIGdyID0gZ3JzW2ldO1xuICAgICAgICAgICAgICB2YXIgZWxlbWVudHMgPSBvYmouZWxlbWVudHNbZ3JdO1xuXG4gICAgICAgICAgICAgIGlmIChhcnJheShlbGVtZW50cykpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVFbGVzKGVsZW1lbnRzLCBncik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcGFyZW50c1RvUmVtb3ZlID0gY3kuY29sbGVjdGlvbigpO1xuICAgICAgICAgIGVsZXMuZmlsdGVyKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgICAgIHJldHVybiAhaWRJbkpzb25bZWxlLmlkKCldO1xuICAgICAgICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICAgICAgaWYgKGVsZS5pc1BhcmVudCgpKSB7XG4gICAgICAgICAgICAgIHBhcmVudHNUb1JlbW92ZS5tZXJnZShlbGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZWxlLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pOyAvLyBzbyB0aGF0IGNoaWxkcmVuIGFyZSBub3QgcmVtb3ZlZCB3L3BhcmVudFxuXG4gICAgICAgICAgcGFyZW50c1RvUmVtb3ZlLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZS5jaGlsZHJlbigpLm1vdmUoe1xuICAgICAgICAgICAgICBwYXJlbnQ6IG51bGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pOyAvLyBpbnRlcm1lZGlhdGUgcGFyZW50cyBtYXkgYmUgbW92ZWQgYnkgcHJpb3IgbGluZSwgc28gbWFrZSBzdXJlIHdlIHJlbW92ZSBieSBmcmVzaCByZWZzXG5cbiAgICAgICAgICBwYXJlbnRzVG9SZW1vdmUuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0RnJlc2hSZWYoZWxlKS5yZW1vdmUoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvYmouc3R5bGUpIHtcbiAgICAgICAgICBjeS5zdHlsZShvYmouc3R5bGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9iai56b29tICE9IG51bGwgJiYgb2JqLnpvb20gIT09IF9wLnpvb20pIHtcbiAgICAgICAgICBjeS56b29tKG9iai56b29tKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvYmoucGFuKSB7XG4gICAgICAgICAgaWYgKG9iai5wYW4ueCAhPT0gX3AucGFuLnggfHwgb2JqLnBhbi55ICE9PSBfcC5wYW4ueSkge1xuICAgICAgICAgICAgY3kucGFuKG9iai5wYW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvYmouZGF0YSkge1xuICAgICAgICAgIGN5LmRhdGEob2JqLmRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZpZWxkcyA9IFsnbWluWm9vbScsICdtYXhab29tJywgJ3pvb21pbmdFbmFibGVkJywgJ3VzZXJab29taW5nRW5hYmxlZCcsICdwYW5uaW5nRW5hYmxlZCcsICd1c2VyUGFubmluZ0VuYWJsZWQnLCAnYm94U2VsZWN0aW9uRW5hYmxlZCcsICdhdXRvbG9jaycsICdhdXRvdW5ncmFiaWZ5JywgJ2F1dG91bnNlbGVjdGlmeScsICdtdWx0aUNsaWNrRGVib3VuY2VUaW1lJ107XG5cbiAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgZmllbGRzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgICB2YXIgZiA9IGZpZWxkc1tfaTJdO1xuXG4gICAgICAgICAgaWYgKG9ialtmXSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjeVtmXShvYmpbZl0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGN5LmVuZEJhdGNoKCk7XG4gICAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZ2V0XG4gICAgICAgIHZhciBmbGF0ID0gISFvYmo7XG4gICAgICAgIHZhciBqc29uID0ge307XG5cbiAgICAgICAgaWYgKGZsYXQpIHtcbiAgICAgICAgICBqc29uLmVsZW1lbnRzID0gdGhpcy5lbGVtZW50cygpLm1hcChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlLmpzb24oKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBqc29uLmVsZW1lbnRzID0ge307XG4gICAgICAgICAgZWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgICAgIHZhciBncm91cCA9IGVsZS5ncm91cCgpO1xuXG4gICAgICAgICAgICBpZiAoIWpzb24uZWxlbWVudHNbZ3JvdXBdKSB7XG4gICAgICAgICAgICAgIGpzb24uZWxlbWVudHNbZ3JvdXBdID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGpzb24uZWxlbWVudHNbZ3JvdXBdLnB1c2goZWxlLmpzb24oKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fcHJpdmF0ZS5zdHlsZUVuYWJsZWQpIHtcbiAgICAgICAgICBqc29uLnN0eWxlID0gY3kuc3R5bGUoKS5qc29uKCk7XG4gICAgICAgIH1cblxuICAgICAgICBqc29uLmRhdGEgPSBjb3B5KGN5LmRhdGEoKSk7XG4gICAgICAgIHZhciBvcHRpb25zID0gX3Aub3B0aW9ucztcbiAgICAgICAganNvbi56b29taW5nRW5hYmxlZCA9IF9wLnpvb21pbmdFbmFibGVkO1xuICAgICAgICBqc29uLnVzZXJab29taW5nRW5hYmxlZCA9IF9wLnVzZXJab29taW5nRW5hYmxlZDtcbiAgICAgICAganNvbi56b29tID0gX3Auem9vbTtcbiAgICAgICAganNvbi5taW5ab29tID0gX3AubWluWm9vbTtcbiAgICAgICAganNvbi5tYXhab29tID0gX3AubWF4Wm9vbTtcbiAgICAgICAganNvbi5wYW5uaW5nRW5hYmxlZCA9IF9wLnBhbm5pbmdFbmFibGVkO1xuICAgICAgICBqc29uLnVzZXJQYW5uaW5nRW5hYmxlZCA9IF9wLnVzZXJQYW5uaW5nRW5hYmxlZDtcbiAgICAgICAganNvbi5wYW4gPSBjb3B5KF9wLnBhbik7XG4gICAgICAgIGpzb24uYm94U2VsZWN0aW9uRW5hYmxlZCA9IF9wLmJveFNlbGVjdGlvbkVuYWJsZWQ7XG4gICAgICAgIGpzb24ucmVuZGVyZXIgPSBjb3B5KG9wdGlvbnMucmVuZGVyZXIpO1xuICAgICAgICBqc29uLmhpZGVFZGdlc09uVmlld3BvcnQgPSBvcHRpb25zLmhpZGVFZGdlc09uVmlld3BvcnQ7XG4gICAgICAgIGpzb24udGV4dHVyZU9uVmlld3BvcnQgPSBvcHRpb25zLnRleHR1cmVPblZpZXdwb3J0O1xuICAgICAgICBqc29uLndoZWVsU2Vuc2l0aXZpdHkgPSBvcHRpb25zLndoZWVsU2Vuc2l0aXZpdHk7XG4gICAgICAgIGpzb24ubW90aW9uQmx1ciA9IG9wdGlvbnMubW90aW9uQmx1cjtcbiAgICAgICAganNvbi5tdWx0aUNsaWNrRGVib3VuY2VUaW1lID0gb3B0aW9ucy5tdWx0aUNsaWNrRGVib3VuY2VUaW1lO1xuICAgICAgICByZXR1cm4ganNvbjtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBjb3JlZm4uJGlkID0gY29yZWZuLmdldEVsZW1lbnRCeUlkO1xuICBbY29yZWZuJDksIGNvcmVmbiQ4LCBlbGVzZm4sIGNvcmVmbiQ3LCBjb3JlZm4kNiwgY29yZWZuJDUsIGNvcmVmbiQ0LCBjb3JlZm4kMywgY29yZWZuJDIsIGNvcmVmbiQxLCBmbl0uZm9yRWFjaChmdW5jdGlvbiAocHJvcHMpIHtcbiAgICBleHRlbmQoY29yZWZuLCBwcm9wcyk7XG4gIH0pO1xuXG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5cbiAgdmFyIGRlZmF1bHRzJDcgPSB7XG4gICAgZml0OiB0cnVlLFxuICAgIC8vIHdoZXRoZXIgdG8gZml0IHRoZSB2aWV3cG9ydCB0byB0aGUgZ3JhcGhcbiAgICBkaXJlY3RlZDogZmFsc2UsXG4gICAgLy8gd2hldGhlciB0aGUgdHJlZSBpcyBkaXJlY3RlZCBkb3dud2FyZHMgKG9yIGVkZ2VzIGNhbiBwb2ludCBpbiBhbnkgZGlyZWN0aW9uIGlmIGZhbHNlKVxuICAgIHBhZGRpbmc6IDMwLFxuICAgIC8vIHBhZGRpbmcgb24gZml0XG4gICAgY2lyY2xlOiBmYWxzZSxcbiAgICAvLyBwdXQgZGVwdGhzIGluIGNvbmNlbnRyaWMgY2lyY2xlcyBpZiB0cnVlLCBwdXQgZGVwdGhzIHRvcCBkb3duIGlmIGZhbHNlXG4gICAgZ3JpZDogZmFsc2UsXG4gICAgLy8gd2hldGhlciB0byBjcmVhdGUgYW4gZXZlbiBncmlkIGludG8gd2hpY2ggdGhlIERBRyBpcyBwbGFjZWQgKGNpcmNsZTpmYWxzZSBvbmx5KVxuICAgIHNwYWNpbmdGYWN0b3I6IDEuNzUsXG4gICAgLy8gcG9zaXRpdmUgc3BhY2luZyBmYWN0b3IsIGxhcmdlciA9PiBtb3JlIHNwYWNlIGJldHdlZW4gbm9kZXMgKE4uQi4gbi9hIGlmIGNhdXNlcyBvdmVybGFwKVxuICAgIGJvdW5kaW5nQm94OiB1bmRlZmluZWQsXG4gICAgLy8gY29uc3RyYWluIGxheW91dCBib3VuZHM7IHsgeDEsIHkxLCB4MiwgeTIgfSBvciB7IHgxLCB5MSwgdywgaCB9XG4gICAgYXZvaWRPdmVybGFwOiB0cnVlLFxuICAgIC8vIHByZXZlbnRzIG5vZGUgb3ZlcmxhcCwgbWF5IG92ZXJmbG93IGJvdW5kaW5nQm94IGlmIG5vdCBlbm91Z2ggc3BhY2VcbiAgICBub2RlRGltZW5zaW9uc0luY2x1ZGVMYWJlbHM6IGZhbHNlLFxuICAgIC8vIEV4Y2x1ZGVzIHRoZSBsYWJlbCB3aGVuIGNhbGN1bGF0aW5nIG5vZGUgYm91bmRpbmcgYm94ZXMgZm9yIHRoZSBsYXlvdXQgYWxnb3JpdGhtXG4gICAgcm9vdHM6IHVuZGVmaW5lZCxcbiAgICAvLyB0aGUgcm9vdHMgb2YgdGhlIHRyZWVzXG4gICAgZGVwdGhTb3J0OiB1bmRlZmluZWQsXG4gICAgLy8gYSBzb3J0aW5nIGZ1bmN0aW9uIHRvIG9yZGVyIG5vZGVzIGF0IGVxdWFsIGRlcHRoLiBlLmcuIGZ1bmN0aW9uKGEsIGIpeyByZXR1cm4gYS5kYXRhKCd3ZWlnaHQnKSAtIGIuZGF0YSgnd2VpZ2h0JykgfVxuICAgIGFuaW1hdGU6IGZhbHNlLFxuICAgIC8vIHdoZXRoZXIgdG8gdHJhbnNpdGlvbiB0aGUgbm9kZSBwb3NpdGlvbnNcbiAgICBhbmltYXRpb25EdXJhdGlvbjogNTAwLFxuICAgIC8vIGR1cmF0aW9uIG9mIGFuaW1hdGlvbiBpbiBtcyBpZiBlbmFibGVkXG4gICAgYW5pbWF0aW9uRWFzaW5nOiB1bmRlZmluZWQsXG4gICAgLy8gZWFzaW5nIG9mIGFuaW1hdGlvbiBpZiBlbmFibGVkLFxuICAgIGFuaW1hdGVGaWx0ZXI6IGZ1bmN0aW9uIGFuaW1hdGVGaWx0ZXIobm9kZSwgaSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICAvLyBhIGZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBub2RlIHNob3VsZCBiZSBhbmltYXRlZC4gIEFsbCBub2RlcyBhbmltYXRlZCBieSBkZWZhdWx0IG9uIGFuaW1hdGUgZW5hYmxlZC4gIE5vbi1hbmltYXRlZCBub2RlcyBhcmUgcG9zaXRpb25lZCBpbW1lZGlhdGVseSB3aGVuIHRoZSBsYXlvdXQgc3RhcnRzXG4gICAgcmVhZHk6IHVuZGVmaW5lZCxcbiAgICAvLyBjYWxsYmFjayBvbiBsYXlvdXRyZWFkeVxuICAgIHN0b3A6IHVuZGVmaW5lZCxcbiAgICAvLyBjYWxsYmFjayBvbiBsYXlvdXRzdG9wXG4gICAgdHJhbnNmb3JtOiBmdW5jdGlvbiB0cmFuc2Zvcm0obm9kZSwgcG9zaXRpb24pIHtcbiAgICAgIHJldHVybiBwb3NpdGlvbjtcbiAgICB9IC8vIHRyYW5zZm9ybSBhIGdpdmVuIG5vZGUgcG9zaXRpb24uIFVzZWZ1bCBmb3IgY2hhbmdpbmcgZmxvdyBkaXJlY3Rpb24gaW4gZGlzY3JldGUgbGF5b3V0c1xuXG4gIH07XG4gIHZhciBkZXByZWNhdGVkT3B0aW9uRGVmYXVsdHMgPSB7XG4gICAgbWF4aW1hbDogZmFsc2UsXG4gICAgLy8gd2hldGhlciB0byBzaGlmdCBub2RlcyBkb3duIHRoZWlyIG5hdHVyYWwgQkZTIGRlcHRocyBpbiBvcmRlciB0byBhdm9pZCB1cHdhcmRzIGVkZ2VzIChEQUdTIG9ubHkpOyBzZXR0aW5nIGFjeWNsaWMgdG8gdHJ1ZSBzZXRzIG1heGltYWwgdG8gdHJ1ZSBhbHNvXG4gICAgYWN5Y2xpYzogZmFsc2UgLy8gd2hldGhlciB0aGUgdHJlZSBpcyBhY3ljbGljIGFuZCB0aHVzIGEgbm9kZSBjb3VsZCBiZSBzaGlmdGVkIChkdWUgdG8gdGhlIG1heGltYWwgb3B0aW9uKSBtdWx0aXBsZSB0aW1lcyB3aXRob3V0IGNhdXNpbmcgYW4gaW5maW5pdGUgbG9vcDsgc2V0dGluZyB0byB0cnVlIHNldHMgbWF4aW1hbCB0byB0cnVlIGFsc287IGlmIHlvdSBhcmUgdW5jZXJ0YWluIHdoZXRoZXIgYSB0cmVlIGlzIGFjeWNsaWMsIHNldCB0byBmYWxzZSB0byBhdm9pZCBwb3RlbnRpYWwgaW5maW5pdGUgbG9vcHNcblxuICB9O1xuICAvKiBlc2xpbnQtZW5hYmxlICovXG5cbiAgdmFyIGdldEluZm8gPSBmdW5jdGlvbiBnZXRJbmZvKGVsZSkge1xuICAgIHJldHVybiBlbGUuc2NyYXRjaCgnYnJlYWR0aGZpcnN0Jyk7XG4gIH07XG5cbiAgdmFyIHNldEluZm8gPSBmdW5jdGlvbiBzZXRJbmZvKGVsZSwgb2JqKSB7XG4gICAgcmV0dXJuIGVsZS5zY3JhdGNoKCdicmVhZHRoZmlyc3QnLCBvYmopO1xuICB9O1xuXG4gIGZ1bmN0aW9uIEJyZWFkdGhGaXJzdExheW91dChvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gZXh0ZW5kKHt9LCBkZWZhdWx0cyQ3LCBkZXByZWNhdGVkT3B0aW9uRGVmYXVsdHMsIG9wdGlvbnMpO1xuICB9XG5cbiAgQnJlYWR0aEZpcnN0TGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBhcmFtcyA9IHRoaXMub3B0aW9ucztcbiAgICB2YXIgb3B0aW9ucyA9IHBhcmFtcztcbiAgICB2YXIgY3kgPSBwYXJhbXMuY3k7XG4gICAgdmFyIGVsZXMgPSBvcHRpb25zLmVsZXM7XG4gICAgdmFyIG5vZGVzID0gZWxlcy5ub2RlcygpLmZpbHRlcihmdW5jdGlvbiAobikge1xuICAgICAgcmV0dXJuICFuLmlzUGFyZW50KCk7XG4gICAgfSk7XG4gICAgdmFyIGdyYXBoID0gZWxlcztcbiAgICB2YXIgZGlyZWN0ZWQgPSBvcHRpb25zLmRpcmVjdGVkO1xuICAgIHZhciBtYXhpbWFsID0gb3B0aW9ucy5hY3ljbGljIHx8IG9wdGlvbnMubWF4aW1hbCB8fCBvcHRpb25zLm1heGltYWxBZGp1c3RtZW50cyA+IDA7IC8vIG1heGltYWxBZGp1c3RtZW50cyBmb3IgY29tcGF0LiB3LyBvbGQgY29kZTsgYWxzbywgc2V0dGluZyBhY3ljbGljIHRvIHRydWUgc2V0cyBtYXhpbWFsIHRvIHRydWVcblxuICAgIHZhciBiYiA9IG1ha2VCb3VuZGluZ0JveChvcHRpb25zLmJvdW5kaW5nQm94ID8gb3B0aW9ucy5ib3VuZGluZ0JveCA6IHtcbiAgICAgIHgxOiAwLFxuICAgICAgeTE6IDAsXG4gICAgICB3OiBjeS53aWR0aCgpLFxuICAgICAgaDogY3kuaGVpZ2h0KClcbiAgICB9KTtcbiAgICB2YXIgcm9vdHM7XG5cbiAgICBpZiAoZWxlbWVudE9yQ29sbGVjdGlvbihvcHRpb25zLnJvb3RzKSkge1xuICAgICAgcm9vdHMgPSBvcHRpb25zLnJvb3RzO1xuICAgIH0gZWxzZSBpZiAoYXJyYXkob3B0aW9ucy5yb290cykpIHtcbiAgICAgIHZhciByb290c0FycmF5ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0aW9ucy5yb290cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaWQgPSBvcHRpb25zLnJvb3RzW2ldO1xuICAgICAgICB2YXIgZWxlID0gY3kuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICAgICAgICByb290c0FycmF5LnB1c2goZWxlKTtcbiAgICAgIH1cblxuICAgICAgcm9vdHMgPSBjeS5jb2xsZWN0aW9uKHJvb3RzQXJyYXkpO1xuICAgIH0gZWxzZSBpZiAoc3RyaW5nKG9wdGlvbnMucm9vdHMpKSB7XG4gICAgICByb290cyA9IGN5LiQob3B0aW9ucy5yb290cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkaXJlY3RlZCkge1xuICAgICAgICByb290cyA9IG5vZGVzLnJvb3RzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY29tcG9uZW50cyA9IGVsZXMuY29tcG9uZW50cygpO1xuICAgICAgICByb290cyA9IGN5LmNvbGxlY3Rpb24oKTtcblxuICAgICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChfaSkge1xuICAgICAgICAgIHZhciBjb21wID0gY29tcG9uZW50c1tfaV07XG4gICAgICAgICAgdmFyIG1heERlZ3JlZSA9IGNvbXAubWF4RGVncmVlKGZhbHNlKTtcbiAgICAgICAgICB2YXIgY29tcFJvb3RzID0gY29tcC5maWx0ZXIoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZS5kZWdyZWUoZmFsc2UpID09PSBtYXhEZWdyZWU7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcm9vdHMgPSByb290cy5hZGQoY29tcFJvb3RzKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgY29tcG9uZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICBfbG9vcChfaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGVwdGhzID0gW107XG4gICAgdmFyIGZvdW5kQnlCZnMgPSB7fTtcblxuICAgIHZhciBhZGRUb0RlcHRoID0gZnVuY3Rpb24gYWRkVG9EZXB0aChlbGUsIGQpIHtcbiAgICAgIGlmIChkZXB0aHNbZF0gPT0gbnVsbCkge1xuICAgICAgICBkZXB0aHNbZF0gPSBbXTtcbiAgICAgIH1cblxuICAgICAgdmFyIGkgPSBkZXB0aHNbZF0ubGVuZ3RoO1xuICAgICAgZGVwdGhzW2RdLnB1c2goZWxlKTtcbiAgICAgIHNldEluZm8oZWxlLCB7XG4gICAgICAgIGluZGV4OiBpLFxuICAgICAgICBkZXB0aDogZFxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBjaGFuZ2VEZXB0aCA9IGZ1bmN0aW9uIGNoYW5nZURlcHRoKGVsZSwgbmV3RGVwdGgpIHtcbiAgICAgIHZhciBfZ2V0SW5mbyA9IGdldEluZm8oZWxlKSxcbiAgICAgICAgICBkZXB0aCA9IF9nZXRJbmZvLmRlcHRoLFxuICAgICAgICAgIGluZGV4ID0gX2dldEluZm8uaW5kZXg7XG5cbiAgICAgIGRlcHRoc1tkZXB0aF1baW5kZXhdID0gbnVsbDtcbiAgICAgIGFkZFRvRGVwdGgoZWxlLCBuZXdEZXB0aCk7XG4gICAgfTsgLy8gZmluZCB0aGUgZGVwdGhzIG9mIHRoZSBub2Rlc1xuXG5cbiAgICBncmFwaC5iZnMoe1xuICAgICAgcm9vdHM6IHJvb3RzLFxuICAgICAgZGlyZWN0ZWQ6IG9wdGlvbnMuZGlyZWN0ZWQsXG4gICAgICB2aXNpdDogZnVuY3Rpb24gdmlzaXQobm9kZSwgZWRnZSwgcE5vZGUsIGksIGRlcHRoKSB7XG4gICAgICAgIHZhciBlbGUgPSBub2RlWzBdO1xuICAgICAgICB2YXIgaWQgPSBlbGUuaWQoKTtcbiAgICAgICAgYWRkVG9EZXB0aChlbGUsIGRlcHRoKTtcbiAgICAgICAgZm91bmRCeUJmc1tpZF0gPSB0cnVlO1xuICAgICAgfVxuICAgIH0pOyAvLyBjaGVjayBmb3Igbm9kZXMgbm90IGZvdW5kIGJ5IGJmc1xuXG4gICAgdmFyIG9ycGhhbk5vZGVzID0gW107XG5cbiAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBub2Rlcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICB2YXIgX2VsZSA9IG5vZGVzW19pMl07XG5cbiAgICAgIGlmIChmb3VuZEJ5QmZzW19lbGUuaWQoKV0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcnBoYW5Ob2Rlcy5wdXNoKF9lbGUpO1xuICAgICAgfVxuICAgIH0gLy8gYXNzaWduIHRoZSBub2RlcyBhIGRlcHRoIGFuZCBpbmRleFxuXG5cbiAgICB2YXIgYXNzaWduRGVwdGhzQXQgPSBmdW5jdGlvbiBhc3NpZ25EZXB0aHNBdChpKSB7XG4gICAgICB2YXIgZWxlcyA9IGRlcHRoc1tpXTtcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBlbGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBfZWxlMiA9IGVsZXNbal07XG5cbiAgICAgICAgaWYgKF9lbGUyID09IG51bGwpIHtcbiAgICAgICAgICBlbGVzLnNwbGljZShqLCAxKTtcbiAgICAgICAgICBqLS07XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBzZXRJbmZvKF9lbGUyLCB7XG4gICAgICAgICAgZGVwdGg6IGksXG4gICAgICAgICAgaW5kZXg6IGpcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBhc3NpZ25EZXB0aHMgPSBmdW5jdGlvbiBhc3NpZ25EZXB0aHMoKSB7XG4gICAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBkZXB0aHMubGVuZ3RoOyBfaTMrKykge1xuICAgICAgICBhc3NpZ25EZXB0aHNBdChfaTMpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgYWRqdXN0TWF4aW1hbGx5ID0gZnVuY3Rpb24gYWRqdXN0TWF4aW1hbGx5KGVsZSwgc2hpZnRlZCkge1xuICAgICAgdmFyIGVJbmZvID0gZ2V0SW5mbyhlbGUpO1xuICAgICAgdmFyIGluY29tZXJzID0gZWxlLmluY29tZXJzKCkuZmlsdGVyKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICByZXR1cm4gZWwuaXNOb2RlKCkgJiYgZWxlcy5oYXMoZWwpO1xuICAgICAgfSk7XG4gICAgICB2YXIgbWF4RGVwdGggPSAtMTtcbiAgICAgIHZhciBpZCA9IGVsZS5pZCgpO1xuXG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IGluY29tZXJzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIHZhciBpbmNtciA9IGluY29tZXJzW2tdO1xuICAgICAgICB2YXIgaUluZm8gPSBnZXRJbmZvKGluY21yKTtcbiAgICAgICAgbWF4RGVwdGggPSBNYXRoLm1heChtYXhEZXB0aCwgaUluZm8uZGVwdGgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZUluZm8uZGVwdGggPD0gbWF4RGVwdGgpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zLmFjeWNsaWMgJiYgc2hpZnRlZFtpZF0pIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuZXdEZXB0aCA9IG1heERlcHRoICsgMTtcbiAgICAgICAgY2hhbmdlRGVwdGgoZWxlLCBuZXdEZXB0aCk7XG4gICAgICAgIHNoaWZ0ZWRbaWRdID0gbmV3RGVwdGg7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTsgLy8gZm9yIHRoZSBkaXJlY3RlZCBjYXNlLCB0cnkgdG8gbWFrZSB0aGUgZWRnZXMgYWxsIGdvIGRvd24gKGkuZS4gZGVwdGggaSA9PiBkZXB0aCBpICsgMSlcblxuXG4gICAgaWYgKGRpcmVjdGVkICYmIG1heGltYWwpIHtcbiAgICAgIHZhciBRID0gW107XG4gICAgICB2YXIgc2hpZnRlZCA9IHt9O1xuXG4gICAgICB2YXIgZW5xdWV1ZSA9IGZ1bmN0aW9uIGVucXVldWUobikge1xuICAgICAgICByZXR1cm4gUS5wdXNoKG4pO1xuICAgICAgfTtcblxuICAgICAgdmFyIGRlcXVldWUgPSBmdW5jdGlvbiBkZXF1ZXVlKCkge1xuICAgICAgICByZXR1cm4gUS5zaGlmdCgpO1xuICAgICAgfTtcblxuICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobikge1xuICAgICAgICByZXR1cm4gUS5wdXNoKG4pO1xuICAgICAgfSk7XG5cbiAgICAgIHdoaWxlIChRLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIF9lbGUzID0gZGVxdWV1ZSgpO1xuXG4gICAgICAgIHZhciBkaWRTaGlmdCA9IGFkanVzdE1heGltYWxseShfZWxlMywgc2hpZnRlZCk7XG5cbiAgICAgICAgaWYgKGRpZFNoaWZ0KSB7XG4gICAgICAgICAgX2VsZTMub3V0Z29lcnMoKS5maWx0ZXIoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gZWwuaXNOb2RlKCkgJiYgZWxlcy5oYXMoZWwpO1xuICAgICAgICAgIH0pLmZvckVhY2goZW5xdWV1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZGlkU2hpZnQgPT09IG51bGwpIHtcbiAgICAgICAgICB3YXJuKCdEZXRlY3RlZCBkb3VibGUgbWF4aW1hbCBzaGlmdCBmb3Igbm9kZSBgJyArIF9lbGUzLmlkKCkgKyAnYC4gIEJhaWxpbmcgbWF4aW1hbCBhZGp1c3RtZW50IGR1ZSB0byBjeWNsZS4gIFVzZSBgb3B0aW9ucy5tYXhpbWFsOiB0cnVlYCBvbmx5IG9uIERBR3MuJyk7XG4gICAgICAgICAgYnJlYWs7IC8vIGV4aXQgb24gZmFpbHVyZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgYXNzaWduRGVwdGhzKCk7IC8vIGNsZWFyIGhvbGVzXG4gICAgLy8gZmluZCBtaW4gZGlzdGFuY2Ugd2UgbmVlZCB0byBsZWF2ZSBiZXR3ZWVuIG5vZGVzXG5cbiAgICB2YXIgbWluRGlzdGFuY2UgPSAwO1xuXG4gICAgaWYgKG9wdGlvbnMuYXZvaWRPdmVybGFwKSB7XG4gICAgICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBub2Rlcy5sZW5ndGg7IF9pNCsrKSB7XG4gICAgICAgIHZhciBuID0gbm9kZXNbX2k0XTtcbiAgICAgICAgdmFyIG5iYiA9IG4ubGF5b3V0RGltZW5zaW9ucyhvcHRpb25zKTtcbiAgICAgICAgdmFyIHcgPSBuYmIudztcbiAgICAgICAgdmFyIGggPSBuYmIuaDtcbiAgICAgICAgbWluRGlzdGFuY2UgPSBNYXRoLm1heChtaW5EaXN0YW5jZSwgdywgaCk7XG4gICAgICB9XG4gICAgfSAvLyBnZXQgdGhlIHdlaWdodGVkIHBlcmNlbnQgZm9yIGFuIGVsZW1lbnQgYmFzZWQgb24gaXRzIGNvbm5lY3Rpdml0eSB0byBvdGhlciBsZXZlbHNcblxuXG4gICAgdmFyIGNhY2hlZFdlaWdodGVkUGVyY2VudCA9IHt9O1xuXG4gICAgdmFyIGdldFdlaWdodGVkUGVyY2VudCA9IGZ1bmN0aW9uIGdldFdlaWdodGVkUGVyY2VudChlbGUpIHtcbiAgICAgIGlmIChjYWNoZWRXZWlnaHRlZFBlcmNlbnRbZWxlLmlkKCldKSB7XG4gICAgICAgIHJldHVybiBjYWNoZWRXZWlnaHRlZFBlcmNlbnRbZWxlLmlkKCldO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxlRGVwdGggPSBnZXRJbmZvKGVsZSkuZGVwdGg7XG4gICAgICB2YXIgbmVpZ2hib3JzID0gZWxlLm5laWdoYm9yaG9vZCgpO1xuICAgICAgdmFyIHBlcmNlbnQgPSAwO1xuICAgICAgdmFyIHNhbXBsZXMgPSAwO1xuXG4gICAgICBmb3IgKHZhciBfaTUgPSAwOyBfaTUgPCBuZWlnaGJvcnMubGVuZ3RoOyBfaTUrKykge1xuICAgICAgICB2YXIgbmVpZ2hib3IgPSBuZWlnaGJvcnNbX2k1XTtcblxuICAgICAgICBpZiAobmVpZ2hib3IuaXNFZGdlKCkgfHwgbmVpZ2hib3IuaXNQYXJlbnQoKSB8fCAhbm9kZXMuaGFzKG5laWdoYm9yKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJmID0gZ2V0SW5mbyhuZWlnaGJvcik7XG5cbiAgICAgICAgaWYgKGJmID09IG51bGwpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbmRleCA9IGJmLmluZGV4O1xuICAgICAgICB2YXIgZGVwdGggPSBiZi5kZXB0aDsgLy8gdW5hc3NpZ25lZCBuZWlnaGJvdXJzIHNob3VsZG4ndCBhZmZlY3QgdGhlIG9yZGVyaW5nXG5cbiAgICAgICAgaWYgKGluZGV4ID09IG51bGwgfHwgZGVwdGggPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5EZXB0aCA9IGRlcHRoc1tkZXB0aF0ubGVuZ3RoO1xuXG4gICAgICAgIGlmIChkZXB0aCA8IGVsZURlcHRoKSB7XG4gICAgICAgICAgLy8gb25seSBnZXQgaW5mbHVlbmNlZCBieSBlbGVtZW50cyBhYm92ZVxuICAgICAgICAgIHBlcmNlbnQgKz0gaW5kZXggLyBuRGVwdGg7XG4gICAgICAgICAgc2FtcGxlcysrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNhbXBsZXMgPSBNYXRoLm1heCgxLCBzYW1wbGVzKTtcbiAgICAgIHBlcmNlbnQgPSBwZXJjZW50IC8gc2FtcGxlcztcblxuICAgICAgaWYgKHNhbXBsZXMgPT09IDApIHtcbiAgICAgICAgLy8gcHV0IGxvbmUgbm9kZXMgYXQgdGhlIHN0YXJ0XG4gICAgICAgIHBlcmNlbnQgPSAwO1xuICAgICAgfVxuXG4gICAgICBjYWNoZWRXZWlnaHRlZFBlcmNlbnRbZWxlLmlkKCldID0gcGVyY2VudDtcbiAgICAgIHJldHVybiBwZXJjZW50O1xuICAgIH07IC8vIHJlYXJyYW5nZSB0aGUgaW5kaWNlcyBpbiBlYWNoIGRlcHRoIGxldmVsIGJhc2VkIG9uIGNvbm5lY3Rpdml0eVxuXG5cbiAgICB2YXIgc29ydEZuID0gZnVuY3Rpb24gc29ydEZuKGEsIGIpIHtcbiAgICAgIHZhciBhcGN0ID0gZ2V0V2VpZ2h0ZWRQZXJjZW50KGEpO1xuICAgICAgdmFyIGJwY3QgPSBnZXRXZWlnaHRlZFBlcmNlbnQoYik7XG4gICAgICB2YXIgZGlmZiA9IGFwY3QgLSBicGN0O1xuXG4gICAgICBpZiAoZGlmZiA9PT0gMCkge1xuICAgICAgICByZXR1cm4gYXNjZW5kaW5nKGEuaWQoKSwgYi5pZCgpKTsgLy8gbWFrZSBzdXJlIHNvcnQgZG9lc24ndCBoYXZlIGRvbid0LWNhcmUgY29tcGFyaXNvbnNcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBkaWZmO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAob3B0aW9ucy5kZXB0aFNvcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgc29ydEZuID0gb3B0aW9ucy5kZXB0aFNvcnQ7XG4gICAgfSAvLyBzb3J0IGVhY2ggbGV2ZWwgdG8gbWFrZSBjb25uZWN0ZWQgbm9kZXMgY2xvc2VyXG5cblxuICAgIGZvciAodmFyIF9pNiA9IDA7IF9pNiA8IGRlcHRocy5sZW5ndGg7IF9pNisrKSB7XG4gICAgICBkZXB0aHNbX2k2XS5zb3J0KHNvcnRGbik7XG5cbiAgICAgIGFzc2lnbkRlcHRoc0F0KF9pNik7XG4gICAgfSAvLyBhc3NpZ24gb3JwaGFuIG5vZGVzIHRvIGEgbmV3IHRvcC1sZXZlbCBkZXB0aFxuXG5cbiAgICB2YXIgb3JwaGFuRGVwdGggPSBbXTtcblxuICAgIGZvciAodmFyIF9pNyA9IDA7IF9pNyA8IG9ycGhhbk5vZGVzLmxlbmd0aDsgX2k3KyspIHtcbiAgICAgIG9ycGhhbkRlcHRoLnB1c2gob3JwaGFuTm9kZXNbX2k3XSk7XG4gICAgfVxuXG4gICAgZGVwdGhzLnVuc2hpZnQob3JwaGFuRGVwdGgpO1xuICAgIGFzc2lnbkRlcHRocygpO1xuICAgIHZhciBiaWdnZXN0RGVwdGhTaXplID0gMDtcblxuICAgIGZvciAodmFyIF9pOCA9IDA7IF9pOCA8IGRlcHRocy5sZW5ndGg7IF9pOCsrKSB7XG4gICAgICBiaWdnZXN0RGVwdGhTaXplID0gTWF0aC5tYXgoZGVwdGhzW19pOF0ubGVuZ3RoLCBiaWdnZXN0RGVwdGhTaXplKTtcbiAgICB9XG5cbiAgICB2YXIgY2VudGVyID0ge1xuICAgICAgeDogYmIueDEgKyBiYi53IC8gMixcbiAgICAgIHk6IGJiLngxICsgYmIuaCAvIDJcbiAgICB9O1xuICAgIHZhciBtYXhEZXB0aFNpemUgPSBkZXB0aHMucmVkdWNlKGZ1bmN0aW9uIChtYXgsIGVsZXMpIHtcbiAgICAgIHJldHVybiBNYXRoLm1heChtYXgsIGVsZXMubGVuZ3RoKTtcbiAgICB9LCAwKTtcblxuICAgIHZhciBnZXRQb3NpdGlvbiA9IGZ1bmN0aW9uIGdldFBvc2l0aW9uKGVsZSkge1xuICAgICAgdmFyIF9nZXRJbmZvMiA9IGdldEluZm8oZWxlKSxcbiAgICAgICAgICBkZXB0aCA9IF9nZXRJbmZvMi5kZXB0aCxcbiAgICAgICAgICBpbmRleCA9IF9nZXRJbmZvMi5pbmRleDtcblxuICAgICAgdmFyIGRlcHRoU2l6ZSA9IGRlcHRoc1tkZXB0aF0ubGVuZ3RoO1xuICAgICAgdmFyIGRpc3RhbmNlWCA9IE1hdGgubWF4KGJiLncgLyAoKG9wdGlvbnMuZ3JpZCA/IG1heERlcHRoU2l6ZSA6IGRlcHRoU2l6ZSkgKyAxKSwgbWluRGlzdGFuY2UpO1xuICAgICAgdmFyIGRpc3RhbmNlWSA9IE1hdGgubWF4KGJiLmggLyAoZGVwdGhzLmxlbmd0aCArIDEpLCBtaW5EaXN0YW5jZSk7XG4gICAgICB2YXIgcmFkaXVzU3RlcFNpemUgPSBNYXRoLm1pbihiYi53IC8gMiAvIGRlcHRocy5sZW5ndGgsIGJiLmggLyAyIC8gZGVwdGhzLmxlbmd0aCk7XG4gICAgICByYWRpdXNTdGVwU2l6ZSA9IE1hdGgubWF4KHJhZGl1c1N0ZXBTaXplLCBtaW5EaXN0YW5jZSk7XG5cbiAgICAgIGlmICghb3B0aW9ucy5jaXJjbGUpIHtcbiAgICAgICAgdmFyIGVwb3MgPSB7XG4gICAgICAgICAgeDogY2VudGVyLnggKyAoaW5kZXggKyAxIC0gKGRlcHRoU2l6ZSArIDEpIC8gMikgKiBkaXN0YW5jZVgsXG4gICAgICAgICAgeTogKGRlcHRoICsgMSkgKiBkaXN0YW5jZVlcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGVwb3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmFkaXVzID0gcmFkaXVzU3RlcFNpemUgKiBkZXB0aCArIHJhZGl1c1N0ZXBTaXplIC0gKGRlcHRocy5sZW5ndGggPiAwICYmIGRlcHRoc1swXS5sZW5ndGggPD0gMyA/IHJhZGl1c1N0ZXBTaXplIC8gMiA6IDApO1xuICAgICAgICB2YXIgdGhldGEgPSAyICogTWF0aC5QSSAvIGRlcHRoc1tkZXB0aF0ubGVuZ3RoICogaW5kZXg7XG5cbiAgICAgICAgaWYgKGRlcHRoID09PSAwICYmIGRlcHRoc1swXS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICByYWRpdXMgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiBjZW50ZXIueCArIHJhZGl1cyAqIE1hdGguY29zKHRoZXRhKSxcbiAgICAgICAgICB5OiBjZW50ZXIueSArIHJhZGl1cyAqIE1hdGguc2luKHRoZXRhKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBlbGVzLm5vZGVzKCkubGF5b3V0UG9zaXRpb25zKHRoaXMsIG9wdGlvbnMsIGdldFBvc2l0aW9uKTtcbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfTtcblxuICB2YXIgZGVmYXVsdHMkNiA9IHtcbiAgICBmaXQ6IHRydWUsXG4gICAgLy8gd2hldGhlciB0byBmaXQgdGhlIHZpZXdwb3J0IHRvIHRoZSBncmFwaFxuICAgIHBhZGRpbmc6IDMwLFxuICAgIC8vIHRoZSBwYWRkaW5nIG9uIGZpdFxuICAgIGJvdW5kaW5nQm94OiB1bmRlZmluZWQsXG4gICAgLy8gY29uc3RyYWluIGxheW91dCBib3VuZHM7IHsgeDEsIHkxLCB4MiwgeTIgfSBvciB7IHgxLCB5MSwgdywgaCB9XG4gICAgYXZvaWRPdmVybGFwOiB0cnVlLFxuICAgIC8vIHByZXZlbnRzIG5vZGUgb3ZlcmxhcCwgbWF5IG92ZXJmbG93IGJvdW5kaW5nQm94IGFuZCByYWRpdXMgaWYgbm90IGVub3VnaCBzcGFjZVxuICAgIG5vZGVEaW1lbnNpb25zSW5jbHVkZUxhYmVsczogZmFsc2UsXG4gICAgLy8gRXhjbHVkZXMgdGhlIGxhYmVsIHdoZW4gY2FsY3VsYXRpbmcgbm9kZSBib3VuZGluZyBib3hlcyBmb3IgdGhlIGxheW91dCBhbGdvcml0aG1cbiAgICBzcGFjaW5nRmFjdG9yOiB1bmRlZmluZWQsXG4gICAgLy8gQXBwbGllcyBhIG11bHRpcGxpY2F0aXZlIGZhY3RvciAoPjApIHRvIGV4cGFuZCBvciBjb21wcmVzcyB0aGUgb3ZlcmFsbCBhcmVhIHRoYXQgdGhlIG5vZGVzIHRha2UgdXBcbiAgICByYWRpdXM6IHVuZGVmaW5lZCxcbiAgICAvLyB0aGUgcmFkaXVzIG9mIHRoZSBjaXJjbGVcbiAgICBzdGFydEFuZ2xlOiAzIC8gMiAqIE1hdGguUEksXG4gICAgLy8gd2hlcmUgbm9kZXMgc3RhcnQgaW4gcmFkaWFuc1xuICAgIHN3ZWVwOiB1bmRlZmluZWQsXG4gICAgLy8gaG93IG1hbnkgcmFkaWFucyBzaG91bGQgYmUgYmV0d2VlbiB0aGUgZmlyc3QgYW5kIGxhc3Qgbm9kZSAoZGVmYXVsdHMgdG8gZnVsbCBjaXJjbGUpXG4gICAgY2xvY2t3aXNlOiB0cnVlLFxuICAgIC8vIHdoZXRoZXIgdGhlIGxheW91dCBzaG91bGQgZ28gY2xvY2t3aXNlICh0cnVlKSBvciBjb3VudGVyY2xvY2t3aXNlL2FudGljbG9ja3dpc2UgKGZhbHNlKVxuICAgIHNvcnQ6IHVuZGVmaW5lZCxcbiAgICAvLyBhIHNvcnRpbmcgZnVuY3Rpb24gdG8gb3JkZXIgdGhlIG5vZGVzOyBlLmcuIGZ1bmN0aW9uKGEsIGIpeyByZXR1cm4gYS5kYXRhKCd3ZWlnaHQnKSAtIGIuZGF0YSgnd2VpZ2h0JykgfVxuICAgIGFuaW1hdGU6IGZhbHNlLFxuICAgIC8vIHdoZXRoZXIgdG8gdHJhbnNpdGlvbiB0aGUgbm9kZSBwb3NpdGlvbnNcbiAgICBhbmltYXRpb25EdXJhdGlvbjogNTAwLFxuICAgIC8vIGR1cmF0aW9uIG9mIGFuaW1hdGlvbiBpbiBtcyBpZiBlbmFibGVkXG4gICAgYW5pbWF0aW9uRWFzaW5nOiB1bmRlZmluZWQsXG4gICAgLy8gZWFzaW5nIG9mIGFuaW1hdGlvbiBpZiBlbmFibGVkXG4gICAgYW5pbWF0ZUZpbHRlcjogZnVuY3Rpb24gYW5pbWF0ZUZpbHRlcihub2RlLCBpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIC8vIGEgZnVuY3Rpb24gdGhhdCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG5vZGUgc2hvdWxkIGJlIGFuaW1hdGVkLiAgQWxsIG5vZGVzIGFuaW1hdGVkIGJ5IGRlZmF1bHQgb24gYW5pbWF0ZSBlbmFibGVkLiAgTm9uLWFuaW1hdGVkIG5vZGVzIGFyZSBwb3NpdGlvbmVkIGltbWVkaWF0ZWx5IHdoZW4gdGhlIGxheW91dCBzdGFydHNcbiAgICByZWFkeTogdW5kZWZpbmVkLFxuICAgIC8vIGNhbGxiYWNrIG9uIGxheW91dHJlYWR5XG4gICAgc3RvcDogdW5kZWZpbmVkLFxuICAgIC8vIGNhbGxiYWNrIG9uIGxheW91dHN0b3BcbiAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uIHRyYW5zZm9ybShub2RlLCBwb3NpdGlvbikge1xuICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgIH0gLy8gdHJhbnNmb3JtIGEgZ2l2ZW4gbm9kZSBwb3NpdGlvbi4gVXNlZnVsIGZvciBjaGFuZ2luZyBmbG93IGRpcmVjdGlvbiBpbiBkaXNjcmV0ZSBsYXlvdXRzIFxuXG4gIH07XG5cbiAgZnVuY3Rpb24gQ2lyY2xlTGF5b3V0KG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBleHRlbmQoe30sIGRlZmF1bHRzJDYsIG9wdGlvbnMpO1xuICB9XG5cbiAgQ2lyY2xlTGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBhcmFtcyA9IHRoaXMub3B0aW9ucztcbiAgICB2YXIgb3B0aW9ucyA9IHBhcmFtcztcbiAgICB2YXIgY3kgPSBwYXJhbXMuY3k7XG4gICAgdmFyIGVsZXMgPSBvcHRpb25zLmVsZXM7XG4gICAgdmFyIGNsb2Nrd2lzZSA9IG9wdGlvbnMuY291bnRlcmNsb2Nrd2lzZSAhPT0gdW5kZWZpbmVkID8gIW9wdGlvbnMuY291bnRlcmNsb2Nrd2lzZSA6IG9wdGlvbnMuY2xvY2t3aXNlO1xuICAgIHZhciBub2RlcyA9IGVsZXMubm9kZXMoKS5ub3QoJzpwYXJlbnQnKTtcblxuICAgIGlmIChvcHRpb25zLnNvcnQpIHtcbiAgICAgIG5vZGVzID0gbm9kZXMuc29ydChvcHRpb25zLnNvcnQpO1xuICAgIH1cblxuICAgIHZhciBiYiA9IG1ha2VCb3VuZGluZ0JveChvcHRpb25zLmJvdW5kaW5nQm94ID8gb3B0aW9ucy5ib3VuZGluZ0JveCA6IHtcbiAgICAgIHgxOiAwLFxuICAgICAgeTE6IDAsXG4gICAgICB3OiBjeS53aWR0aCgpLFxuICAgICAgaDogY3kuaGVpZ2h0KClcbiAgICB9KTtcbiAgICB2YXIgY2VudGVyID0ge1xuICAgICAgeDogYmIueDEgKyBiYi53IC8gMixcbiAgICAgIHk6IGJiLnkxICsgYmIuaCAvIDJcbiAgICB9O1xuICAgIHZhciBzd2VlcCA9IG9wdGlvbnMuc3dlZXAgPT09IHVuZGVmaW5lZCA/IDIgKiBNYXRoLlBJIC0gMiAqIE1hdGguUEkgLyBub2Rlcy5sZW5ndGggOiBvcHRpb25zLnN3ZWVwO1xuICAgIHZhciBkVGhldGEgPSBzd2VlcCAvIE1hdGgubWF4KDEsIG5vZGVzLmxlbmd0aCAtIDEpO1xuICAgIHZhciByO1xuICAgIHZhciBtaW5EaXN0YW5jZSA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbiA9IG5vZGVzW2ldO1xuICAgICAgdmFyIG5iYiA9IG4ubGF5b3V0RGltZW5zaW9ucyhvcHRpb25zKTtcbiAgICAgIHZhciB3ID0gbmJiLnc7XG4gICAgICB2YXIgaCA9IG5iYi5oO1xuICAgICAgbWluRGlzdGFuY2UgPSBNYXRoLm1heChtaW5EaXN0YW5jZSwgdywgaCk7XG4gICAgfVxuXG4gICAgaWYgKG51bWJlciQxKG9wdGlvbnMucmFkaXVzKSkge1xuICAgICAgciA9IG9wdGlvbnMucmFkaXVzO1xuICAgIH0gZWxzZSBpZiAobm9kZXMubGVuZ3RoIDw9IDEpIHtcbiAgICAgIHIgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICByID0gTWF0aC5taW4oYmIuaCwgYmIudykgLyAyIC0gbWluRGlzdGFuY2U7XG4gICAgfSAvLyBjYWxjdWxhdGUgdGhlIHJhZGl1c1xuXG5cbiAgICBpZiAobm9kZXMubGVuZ3RoID4gMSAmJiBvcHRpb25zLmF2b2lkT3ZlcmxhcCkge1xuICAgICAgLy8gYnV0IG9ubHkgaWYgbW9yZSB0aGFuIG9uZSBub2RlIChjYW4ndCBvdmVybGFwKVxuICAgICAgbWluRGlzdGFuY2UgKj0gMS43NTsgLy8ganVzdCB0byBoYXZlIHNvbWUgbmljZSBzcGFjaW5nXG5cbiAgICAgIHZhciBkY29zID0gTWF0aC5jb3MoZFRoZXRhKSAtIE1hdGguY29zKDApO1xuICAgICAgdmFyIGRzaW4gPSBNYXRoLnNpbihkVGhldGEpIC0gTWF0aC5zaW4oMCk7XG4gICAgICB2YXIgck1pbiA9IE1hdGguc3FydChtaW5EaXN0YW5jZSAqIG1pbkRpc3RhbmNlIC8gKGRjb3MgKiBkY29zICsgZHNpbiAqIGRzaW4pKTsgLy8gcy50LiBubyBub2RlcyBvdmVybGFwcGluZ1xuXG4gICAgICByID0gTWF0aC5tYXgock1pbiwgcik7XG4gICAgfVxuXG4gICAgdmFyIGdldFBvcyA9IGZ1bmN0aW9uIGdldFBvcyhlbGUsIGkpIHtcbiAgICAgIHZhciB0aGV0YSA9IG9wdGlvbnMuc3RhcnRBbmdsZSArIGkgKiBkVGhldGEgKiAoY2xvY2t3aXNlID8gMSA6IC0xKTtcbiAgICAgIHZhciByeCA9IHIgKiBNYXRoLmNvcyh0aGV0YSk7XG4gICAgICB2YXIgcnkgPSByICogTWF0aC5zaW4odGhldGEpO1xuICAgICAgdmFyIHBvcyA9IHtcbiAgICAgICAgeDogY2VudGVyLnggKyByeCxcbiAgICAgICAgeTogY2VudGVyLnkgKyByeVxuICAgICAgfTtcbiAgICAgIHJldHVybiBwb3M7XG4gICAgfTtcblxuICAgIGVsZXMubm9kZXMoKS5sYXlvdXRQb3NpdGlvbnModGhpcywgb3B0aW9ucywgZ2V0UG9zKTtcbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfTtcblxuICB2YXIgZGVmYXVsdHMkNSA9IHtcbiAgICBmaXQ6IHRydWUsXG4gICAgLy8gd2hldGhlciB0byBmaXQgdGhlIHZpZXdwb3J0IHRvIHRoZSBncmFwaFxuICAgIHBhZGRpbmc6IDMwLFxuICAgIC8vIHRoZSBwYWRkaW5nIG9uIGZpdFxuICAgIHN0YXJ0QW5nbGU6IDMgLyAyICogTWF0aC5QSSxcbiAgICAvLyB3aGVyZSBub2RlcyBzdGFydCBpbiByYWRpYW5zXG4gICAgc3dlZXA6IHVuZGVmaW5lZCxcbiAgICAvLyBob3cgbWFueSByYWRpYW5zIHNob3VsZCBiZSBiZXR3ZWVuIHRoZSBmaXJzdCBhbmQgbGFzdCBub2RlIChkZWZhdWx0cyB0byBmdWxsIGNpcmNsZSlcbiAgICBjbG9ja3dpc2U6IHRydWUsXG4gICAgLy8gd2hldGhlciB0aGUgbGF5b3V0IHNob3VsZCBnbyBjbG9ja3dpc2UgKHRydWUpIG9yIGNvdW50ZXJjbG9ja3dpc2UvYW50aWNsb2Nrd2lzZSAoZmFsc2UpXG4gICAgZXF1aWRpc3RhbnQ6IGZhbHNlLFxuICAgIC8vIHdoZXRoZXIgbGV2ZWxzIGhhdmUgYW4gZXF1YWwgcmFkaWFsIGRpc3RhbmNlIGJldHdlbiB0aGVtLCBtYXkgY2F1c2UgYm91bmRpbmcgYm94IG92ZXJmbG93XG4gICAgbWluTm9kZVNwYWNpbmc6IDEwLFxuICAgIC8vIG1pbiBzcGFjaW5nIGJldHdlZW4gb3V0c2lkZSBvZiBub2RlcyAodXNlZCBmb3IgcmFkaXVzIGFkanVzdG1lbnQpXG4gICAgYm91bmRpbmdCb3g6IHVuZGVmaW5lZCxcbiAgICAvLyBjb25zdHJhaW4gbGF5b3V0IGJvdW5kczsgeyB4MSwgeTEsIHgyLCB5MiB9IG9yIHsgeDEsIHkxLCB3LCBoIH1cbiAgICBhdm9pZE92ZXJsYXA6IHRydWUsXG4gICAgLy8gcHJldmVudHMgbm9kZSBvdmVybGFwLCBtYXkgb3ZlcmZsb3cgYm91bmRpbmdCb3ggaWYgbm90IGVub3VnaCBzcGFjZVxuICAgIG5vZGVEaW1lbnNpb25zSW5jbHVkZUxhYmVsczogZmFsc2UsXG4gICAgLy8gRXhjbHVkZXMgdGhlIGxhYmVsIHdoZW4gY2FsY3VsYXRpbmcgbm9kZSBib3VuZGluZyBib3hlcyBmb3IgdGhlIGxheW91dCBhbGdvcml0aG1cbiAgICBoZWlnaHQ6IHVuZGVmaW5lZCxcbiAgICAvLyBoZWlnaHQgb2YgbGF5b3V0IGFyZWEgKG92ZXJyaWRlcyBjb250YWluZXIgaGVpZ2h0KVxuICAgIHdpZHRoOiB1bmRlZmluZWQsXG4gICAgLy8gd2lkdGggb2YgbGF5b3V0IGFyZWEgKG92ZXJyaWRlcyBjb250YWluZXIgd2lkdGgpXG4gICAgc3BhY2luZ0ZhY3RvcjogdW5kZWZpbmVkLFxuICAgIC8vIEFwcGxpZXMgYSBtdWx0aXBsaWNhdGl2ZSBmYWN0b3IgKD4wKSB0byBleHBhbmQgb3IgY29tcHJlc3MgdGhlIG92ZXJhbGwgYXJlYSB0aGF0IHRoZSBub2RlcyB0YWtlIHVwXG4gICAgY29uY2VudHJpYzogZnVuY3Rpb24gY29uY2VudHJpYyhub2RlKSB7XG4gICAgICAvLyByZXR1cm5zIG51bWVyaWMgdmFsdWUgZm9yIGVhY2ggbm9kZSwgcGxhY2luZyBoaWdoZXIgbm9kZXMgaW4gbGV2ZWxzIHRvd2FyZHMgdGhlIGNlbnRyZVxuICAgICAgcmV0dXJuIG5vZGUuZGVncmVlKCk7XG4gICAgfSxcbiAgICBsZXZlbFdpZHRoOiBmdW5jdGlvbiBsZXZlbFdpZHRoKG5vZGVzKSB7XG4gICAgICAvLyB0aGUgdmFyaWF0aW9uIG9mIGNvbmNlbnRyaWMgdmFsdWVzIGluIGVhY2ggbGV2ZWxcbiAgICAgIHJldHVybiBub2Rlcy5tYXhEZWdyZWUoKSAvIDQ7XG4gICAgfSxcbiAgICBhbmltYXRlOiBmYWxzZSxcbiAgICAvLyB3aGV0aGVyIHRvIHRyYW5zaXRpb24gdGhlIG5vZGUgcG9zaXRpb25zXG4gICAgYW5pbWF0aW9uRHVyYXRpb246IDUwMCxcbiAgICAvLyBkdXJhdGlvbiBvZiBhbmltYXRpb24gaW4gbXMgaWYgZW5hYmxlZFxuICAgIGFuaW1hdGlvbkVhc2luZzogdW5kZWZpbmVkLFxuICAgIC8vIGVhc2luZyBvZiBhbmltYXRpb24gaWYgZW5hYmxlZFxuICAgIGFuaW1hdGVGaWx0ZXI6IGZ1bmN0aW9uIGFuaW1hdGVGaWx0ZXIobm9kZSwgaSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICAvLyBhIGZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBub2RlIHNob3VsZCBiZSBhbmltYXRlZC4gIEFsbCBub2RlcyBhbmltYXRlZCBieSBkZWZhdWx0IG9uIGFuaW1hdGUgZW5hYmxlZC4gIE5vbi1hbmltYXRlZCBub2RlcyBhcmUgcG9zaXRpb25lZCBpbW1lZGlhdGVseSB3aGVuIHRoZSBsYXlvdXQgc3RhcnRzXG4gICAgcmVhZHk6IHVuZGVmaW5lZCxcbiAgICAvLyBjYWxsYmFjayBvbiBsYXlvdXRyZWFkeVxuICAgIHN0b3A6IHVuZGVmaW5lZCxcbiAgICAvLyBjYWxsYmFjayBvbiBsYXlvdXRzdG9wXG4gICAgdHJhbnNmb3JtOiBmdW5jdGlvbiB0cmFuc2Zvcm0obm9kZSwgcG9zaXRpb24pIHtcbiAgICAgIHJldHVybiBwb3NpdGlvbjtcbiAgICB9IC8vIHRyYW5zZm9ybSBhIGdpdmVuIG5vZGUgcG9zaXRpb24uIFVzZWZ1bCBmb3IgY2hhbmdpbmcgZmxvdyBkaXJlY3Rpb24gaW4gZGlzY3JldGUgbGF5b3V0c1xuXG4gIH07XG5cbiAgZnVuY3Rpb24gQ29uY2VudHJpY0xheW91dChvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gZXh0ZW5kKHt9LCBkZWZhdWx0cyQ1LCBvcHRpb25zKTtcbiAgfVxuXG4gIENvbmNlbnRyaWNMYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGFyYW1zID0gdGhpcy5vcHRpb25zO1xuICAgIHZhciBvcHRpb25zID0gcGFyYW1zO1xuICAgIHZhciBjbG9ja3dpc2UgPSBvcHRpb25zLmNvdW50ZXJjbG9ja3dpc2UgIT09IHVuZGVmaW5lZCA/ICFvcHRpb25zLmNvdW50ZXJjbG9ja3dpc2UgOiBvcHRpb25zLmNsb2Nrd2lzZTtcbiAgICB2YXIgY3kgPSBwYXJhbXMuY3k7XG4gICAgdmFyIGVsZXMgPSBvcHRpb25zLmVsZXM7XG4gICAgdmFyIG5vZGVzID0gZWxlcy5ub2RlcygpLm5vdCgnOnBhcmVudCcpO1xuICAgIHZhciBiYiA9IG1ha2VCb3VuZGluZ0JveChvcHRpb25zLmJvdW5kaW5nQm94ID8gb3B0aW9ucy5ib3VuZGluZ0JveCA6IHtcbiAgICAgIHgxOiAwLFxuICAgICAgeTE6IDAsXG4gICAgICB3OiBjeS53aWR0aCgpLFxuICAgICAgaDogY3kuaGVpZ2h0KClcbiAgICB9KTtcbiAgICB2YXIgY2VudGVyID0ge1xuICAgICAgeDogYmIueDEgKyBiYi53IC8gMixcbiAgICAgIHk6IGJiLnkxICsgYmIuaCAvIDJcbiAgICB9O1xuICAgIHZhciBub2RlVmFsdWVzID0gW107IC8vIHsgbm9kZSwgdmFsdWUgfVxuXG4gICAgdmFyIG1heE5vZGVTaXplID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICB2YXIgdmFsdWUgPSB2b2lkIDA7IC8vIGNhbGN1bGF0ZSB0aGUgbm9kZSB2YWx1ZVxuXG4gICAgICB2YWx1ZSA9IG9wdGlvbnMuY29uY2VudHJpYyhub2RlKTtcbiAgICAgIG5vZGVWYWx1ZXMucHVzaCh7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgbm9kZTogbm9kZVxuICAgICAgfSk7IC8vIGZvciBzdHlsZSBtYXBwaW5nXG5cbiAgICAgIG5vZGUuX3ByaXZhdGUuc2NyYXRjaC5jb25jZW50cmljID0gdmFsdWU7XG4gICAgfSAvLyBpbiBjYXNlIHdlIHVzZWQgdGhlIGBjb25jZW50cmljYCBpbiBzdHlsZVxuXG5cbiAgICBub2Rlcy51cGRhdGVTdHlsZSgpOyAvLyBjYWxjdWxhdGUgbWF4IHNpemUgbm93IGJhc2VkIG9uIHBvdGVudGlhbGx5IHVwZGF0ZWQgbWFwcGVyc1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG5vZGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF9ub2RlID0gbm9kZXNbX2ldO1xuXG4gICAgICB2YXIgbmJiID0gX25vZGUubGF5b3V0RGltZW5zaW9ucyhvcHRpb25zKTtcblxuICAgICAgbWF4Tm9kZVNpemUgPSBNYXRoLm1heChtYXhOb2RlU2l6ZSwgbmJiLncsIG5iYi5oKTtcbiAgICB9IC8vIHNvcnQgbm9kZSB2YWx1ZXMgaW4gZGVzY3JlYXNpbmcgb3JkZXJcblxuXG4gICAgbm9kZVZhbHVlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYi52YWx1ZSAtIGEudmFsdWU7XG4gICAgfSk7XG4gICAgdmFyIGxldmVsV2lkdGggPSBvcHRpb25zLmxldmVsV2lkdGgobm9kZXMpOyAvLyBwdXQgdGhlIHZhbHVlcyBpbnRvIGxldmVsc1xuXG4gICAgdmFyIGxldmVscyA9IFtbXV07XG4gICAgdmFyIGN1cnJlbnRMZXZlbCA9IGxldmVsc1swXTtcblxuICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG5vZGVWYWx1ZXMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgdmFyIHZhbCA9IG5vZGVWYWx1ZXNbX2kyXTtcblxuICAgICAgaWYgKGN1cnJlbnRMZXZlbC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBkaWZmID0gTWF0aC5hYnMoY3VycmVudExldmVsWzBdLnZhbHVlIC0gdmFsLnZhbHVlKTtcblxuICAgICAgICBpZiAoZGlmZiA+PSBsZXZlbFdpZHRoKSB7XG4gICAgICAgICAgY3VycmVudExldmVsID0gW107XG4gICAgICAgICAgbGV2ZWxzLnB1c2goY3VycmVudExldmVsKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjdXJyZW50TGV2ZWwucHVzaCh2YWwpO1xuICAgIH0gLy8gY3JlYXRlIHBvc2l0aW9ucyBmcm9tIGxldmVsc1xuXG5cbiAgICB2YXIgbWluRGlzdCA9IG1heE5vZGVTaXplICsgb3B0aW9ucy5taW5Ob2RlU3BhY2luZzsgLy8gbWluIGRpc3QgYmV0d2VlbiBub2Rlc1xuXG4gICAgaWYgKCFvcHRpb25zLmF2b2lkT3ZlcmxhcCkge1xuICAgICAgLy8gdGhlbiBzdHJpY3RseSBjb25zdHJhaW4gdG8gYmJcbiAgICAgIHZhciBmaXJzdEx2bEhhc011bHRpID0gbGV2ZWxzLmxlbmd0aCA+IDAgJiYgbGV2ZWxzWzBdLmxlbmd0aCA+IDE7XG4gICAgICB2YXIgbWF4UiA9IE1hdGgubWluKGJiLncsIGJiLmgpIC8gMiAtIG1pbkRpc3Q7XG4gICAgICB2YXIgclN0ZXAgPSBtYXhSIC8gKGxldmVscy5sZW5ndGggKyBmaXJzdEx2bEhhc011bHRpID8gMSA6IDApO1xuICAgICAgbWluRGlzdCA9IE1hdGgubWluKG1pbkRpc3QsIHJTdGVwKTtcbiAgICB9IC8vIGZpbmQgdGhlIG1ldHJpY3MgZm9yIGVhY2ggbGV2ZWxcblxuXG4gICAgdmFyIHIgPSAwO1xuXG4gICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgbGV2ZWxzLmxlbmd0aDsgX2kzKyspIHtcbiAgICAgIHZhciBsZXZlbCA9IGxldmVsc1tfaTNdO1xuICAgICAgdmFyIHN3ZWVwID0gb3B0aW9ucy5zd2VlcCA9PT0gdW5kZWZpbmVkID8gMiAqIE1hdGguUEkgLSAyICogTWF0aC5QSSAvIGxldmVsLmxlbmd0aCA6IG9wdGlvbnMuc3dlZXA7XG4gICAgICB2YXIgZFRoZXRhID0gbGV2ZWwuZFRoZXRhID0gc3dlZXAgLyBNYXRoLm1heCgxLCBsZXZlbC5sZW5ndGggLSAxKTsgLy8gY2FsY3VsYXRlIHRoZSByYWRpdXNcblxuICAgICAgaWYgKGxldmVsLmxlbmd0aCA+IDEgJiYgb3B0aW9ucy5hdm9pZE92ZXJsYXApIHtcbiAgICAgICAgLy8gYnV0IG9ubHkgaWYgbW9yZSB0aGFuIG9uZSBub2RlIChjYW4ndCBvdmVybGFwKVxuICAgICAgICB2YXIgZGNvcyA9IE1hdGguY29zKGRUaGV0YSkgLSBNYXRoLmNvcygwKTtcbiAgICAgICAgdmFyIGRzaW4gPSBNYXRoLnNpbihkVGhldGEpIC0gTWF0aC5zaW4oMCk7XG4gICAgICAgIHZhciByTWluID0gTWF0aC5zcXJ0KG1pbkRpc3QgKiBtaW5EaXN0IC8gKGRjb3MgKiBkY29zICsgZHNpbiAqIGRzaW4pKTsgLy8gcy50LiBubyBub2RlcyBvdmVybGFwcGluZ1xuXG4gICAgICAgIHIgPSBNYXRoLm1heChyTWluLCByKTtcbiAgICAgIH1cblxuICAgICAgbGV2ZWwuciA9IHI7XG4gICAgICByICs9IG1pbkRpc3Q7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuZXF1aWRpc3RhbnQpIHtcbiAgICAgIHZhciByRGVsdGFNYXggPSAwO1xuICAgICAgdmFyIF9yID0gMDtcblxuICAgICAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgbGV2ZWxzLmxlbmd0aDsgX2k0KyspIHtcbiAgICAgICAgdmFyIF9sZXZlbCA9IGxldmVsc1tfaTRdO1xuICAgICAgICB2YXIgckRlbHRhID0gX2xldmVsLnIgLSBfcjtcbiAgICAgICAgckRlbHRhTWF4ID0gTWF0aC5tYXgockRlbHRhTWF4LCByRGVsdGEpO1xuICAgICAgfVxuXG4gICAgICBfciA9IDA7XG5cbiAgICAgIGZvciAodmFyIF9pNSA9IDA7IF9pNSA8IGxldmVscy5sZW5ndGg7IF9pNSsrKSB7XG4gICAgICAgIHZhciBfbGV2ZWwyID0gbGV2ZWxzW19pNV07XG5cbiAgICAgICAgaWYgKF9pNSA9PT0gMCkge1xuICAgICAgICAgIF9yID0gX2xldmVsMi5yO1xuICAgICAgICB9XG5cbiAgICAgICAgX2xldmVsMi5yID0gX3I7XG4gICAgICAgIF9yICs9IHJEZWx0YU1heDtcbiAgICAgIH1cbiAgICB9IC8vIGNhbGN1bGF0ZSB0aGUgbm9kZSBwb3NpdGlvbnNcblxuXG4gICAgdmFyIHBvcyA9IHt9OyAvLyBpZCA9PiBwb3NpdGlvblxuXG4gICAgZm9yICh2YXIgX2k2ID0gMDsgX2k2IDwgbGV2ZWxzLmxlbmd0aDsgX2k2KyspIHtcbiAgICAgIHZhciBfbGV2ZWwzID0gbGV2ZWxzW19pNl07XG4gICAgICB2YXIgX2RUaGV0YSA9IF9sZXZlbDMuZFRoZXRhO1xuICAgICAgdmFyIF9yMiA9IF9sZXZlbDMucjtcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBfbGV2ZWwzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBfdmFsID0gX2xldmVsM1tqXTtcbiAgICAgICAgdmFyIHRoZXRhID0gb3B0aW9ucy5zdGFydEFuZ2xlICsgKGNsb2Nrd2lzZSA/IDEgOiAtMSkgKiBfZFRoZXRhICogajtcbiAgICAgICAgdmFyIHAgPSB7XG4gICAgICAgICAgeDogY2VudGVyLnggKyBfcjIgKiBNYXRoLmNvcyh0aGV0YSksXG4gICAgICAgICAgeTogY2VudGVyLnkgKyBfcjIgKiBNYXRoLnNpbih0aGV0YSlcbiAgICAgICAgfTtcbiAgICAgICAgcG9zW192YWwubm9kZS5pZCgpXSA9IHA7XG4gICAgICB9XG4gICAgfSAvLyBwb3NpdGlvbiB0aGUgbm9kZXNcblxuXG4gICAgZWxlcy5ub2RlcygpLmxheW91dFBvc2l0aW9ucyh0aGlzLCBvcHRpb25zLCBmdW5jdGlvbiAoZWxlKSB7XG4gICAgICB2YXIgaWQgPSBlbGUuaWQoKTtcbiAgICAgIHJldHVybiBwb3NbaWRdO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9O1xuXG4gIC8qXG4gIFRoZSBDb1NFIGxheW91dCB3YXMgd3JpdHRlbiBieSBHZXJhcmRvIEh1Y2suXG4gIGh0dHBzOi8vd3d3LmxpbmtlZGluLmNvbS9pbi9nZXJhcmRvaHVjay9cblxuICBCYXNlZCBvbiB0aGUgZm9sbG93aW5nIGFydGljbGU6XG4gIGh0dHA6Ly9kbC5hY20ub3JnL2NpdGF0aW9uLmNmbT9pZD0xNDk4MDQ3XG5cbiAgTW9kaWZpY2F0aW9ucyB0cmFja2VkIG9uIEdpdGh1Yi5cbiAgKi9cbiAgdmFyIERFQlVHO1xuICAvKipcbiAgICogQGJyaWVmIDogIGRlZmF1bHQgbGF5b3V0IG9wdGlvbnNcbiAgICovXG5cbiAgdmFyIGRlZmF1bHRzJDQgPSB7XG4gICAgLy8gQ2FsbGVkIG9uIGBsYXlvdXRyZWFkeWBcbiAgICByZWFkeTogZnVuY3Rpb24gcmVhZHkoKSB7fSxcbiAgICAvLyBDYWxsZWQgb24gYGxheW91dHN0b3BgXG4gICAgc3RvcDogZnVuY3Rpb24gc3RvcCgpIHt9LFxuICAgIC8vIFdoZXRoZXIgdG8gYW5pbWF0ZSB3aGlsZSBydW5uaW5nIHRoZSBsYXlvdXRcbiAgICAvLyB0cnVlIDogQW5pbWF0ZSBjb250aW51b3VzbHkgYXMgdGhlIGxheW91dCBpcyBydW5uaW5nXG4gICAgLy8gZmFsc2UgOiBKdXN0IHNob3cgdGhlIGVuZCByZXN1bHRcbiAgICAvLyAnZW5kJyA6IEFuaW1hdGUgd2l0aCB0aGUgZW5kIHJlc3VsdCwgZnJvbSB0aGUgaW5pdGlhbCBwb3NpdGlvbnMgdG8gdGhlIGVuZCBwb3NpdGlvbnNcbiAgICBhbmltYXRlOiB0cnVlLFxuICAgIC8vIEVhc2luZyBvZiB0aGUgYW5pbWF0aW9uIGZvciBhbmltYXRlOidlbmQnXG4gICAgYW5pbWF0aW9uRWFzaW5nOiB1bmRlZmluZWQsXG4gICAgLy8gVGhlIGR1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24gZm9yIGFuaW1hdGU6J2VuZCdcbiAgICBhbmltYXRpb25EdXJhdGlvbjogdW5kZWZpbmVkLFxuICAgIC8vIEEgZnVuY3Rpb24gdGhhdCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG5vZGUgc2hvdWxkIGJlIGFuaW1hdGVkXG4gICAgLy8gQWxsIG5vZGVzIGFuaW1hdGVkIGJ5IGRlZmF1bHQgb24gYW5pbWF0ZSBlbmFibGVkXG4gICAgLy8gTm9uLWFuaW1hdGVkIG5vZGVzIGFyZSBwb3NpdGlvbmVkIGltbWVkaWF0ZWx5IHdoZW4gdGhlIGxheW91dCBzdGFydHNcbiAgICBhbmltYXRlRmlsdGVyOiBmdW5jdGlvbiBhbmltYXRlRmlsdGVyKG5vZGUsIGkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgLy8gVGhlIGxheW91dCBhbmltYXRlcyBvbmx5IGFmdGVyIHRoaXMgbWFueSBtaWxsaXNlY29uZHMgZm9yIGFuaW1hdGU6dHJ1ZVxuICAgIC8vIChwcmV2ZW50cyBmbGFzaGluZyBvbiBmYXN0IHJ1bnMpXG4gICAgYW5pbWF0aW9uVGhyZXNob2xkOiAyNTAsXG4gICAgLy8gTnVtYmVyIG9mIGl0ZXJhdGlvbnMgYmV0d2VlbiBjb25zZWN1dGl2ZSBzY3JlZW4gcG9zaXRpb25zIHVwZGF0ZVxuICAgIHJlZnJlc2g6IDIwLFxuICAgIC8vIFdoZXRoZXIgdG8gZml0IHRoZSBuZXR3b3JrIHZpZXcgYWZ0ZXIgd2hlbiBkb25lXG4gICAgZml0OiB0cnVlLFxuICAgIC8vIFBhZGRpbmcgb24gZml0XG4gICAgcGFkZGluZzogMzAsXG4gICAgLy8gQ29uc3RyYWluIGxheW91dCBib3VuZHM7IHsgeDEsIHkxLCB4MiwgeTIgfSBvciB7IHgxLCB5MSwgdywgaCB9XG4gICAgYm91bmRpbmdCb3g6IHVuZGVmaW5lZCxcbiAgICAvLyBFeGNsdWRlcyB0aGUgbGFiZWwgd2hlbiBjYWxjdWxhdGluZyBub2RlIGJvdW5kaW5nIGJveGVzIGZvciB0aGUgbGF5b3V0IGFsZ29yaXRobVxuICAgIG5vZGVEaW1lbnNpb25zSW5jbHVkZUxhYmVsczogZmFsc2UsXG4gICAgLy8gUmFuZG9taXplIHRoZSBpbml0aWFsIHBvc2l0aW9ucyBvZiB0aGUgbm9kZXMgKHRydWUpIG9yIHVzZSBleGlzdGluZyBwb3NpdGlvbnMgKGZhbHNlKVxuICAgIHJhbmRvbWl6ZTogZmFsc2UsXG4gICAgLy8gRXh0cmEgc3BhY2luZyBiZXR3ZWVuIGNvbXBvbmVudHMgaW4gbm9uLWNvbXBvdW5kIGdyYXBoc1xuICAgIGNvbXBvbmVudFNwYWNpbmc6IDQwLFxuICAgIC8vIE5vZGUgcmVwdWxzaW9uIChub24gb3ZlcmxhcHBpbmcpIG11bHRpcGxpZXJcbiAgICBub2RlUmVwdWxzaW9uOiBmdW5jdGlvbiBub2RlUmVwdWxzaW9uKG5vZGUpIHtcbiAgICAgIHJldHVybiAyMDQ4O1xuICAgIH0sXG4gICAgLy8gTm9kZSByZXB1bHNpb24gKG92ZXJsYXBwaW5nKSBtdWx0aXBsaWVyXG4gICAgbm9kZU92ZXJsYXA6IDQsXG4gICAgLy8gSWRlYWwgZWRnZSAobm9uIG5lc3RlZCkgbGVuZ3RoXG4gICAgaWRlYWxFZGdlTGVuZ3RoOiBmdW5jdGlvbiBpZGVhbEVkZ2VMZW5ndGgoZWRnZSkge1xuICAgICAgcmV0dXJuIDMyO1xuICAgIH0sXG4gICAgLy8gRGl2aXNvciB0byBjb21wdXRlIGVkZ2UgZm9yY2VzXG4gICAgZWRnZUVsYXN0aWNpdHk6IGZ1bmN0aW9uIGVkZ2VFbGFzdGljaXR5KGVkZ2UpIHtcbiAgICAgIHJldHVybiAzMjtcbiAgICB9LFxuICAgIC8vIE5lc3RpbmcgZmFjdG9yIChtdWx0aXBsaWVyKSB0byBjb21wdXRlIGlkZWFsIGVkZ2UgbGVuZ3RoIGZvciBuZXN0ZWQgZWRnZXNcbiAgICBuZXN0aW5nRmFjdG9yOiAxLjIsXG4gICAgLy8gR3Jhdml0eSBmb3JjZSAoY29uc3RhbnQpXG4gICAgZ3Jhdml0eTogMSxcbiAgICAvLyBNYXhpbXVtIG51bWJlciBvZiBpdGVyYXRpb25zIHRvIHBlcmZvcm1cbiAgICBudW1JdGVyOiAxMDAwLFxuICAgIC8vIEluaXRpYWwgdGVtcGVyYXR1cmUgKG1heGltdW0gbm9kZSBkaXNwbGFjZW1lbnQpXG4gICAgaW5pdGlhbFRlbXA6IDEwMDAsXG4gICAgLy8gQ29vbGluZyBmYWN0b3IgKGhvdyB0aGUgdGVtcGVyYXR1cmUgaXMgcmVkdWNlZCBiZXR3ZWVuIGNvbnNlY3V0aXZlIGl0ZXJhdGlvbnNcbiAgICBjb29saW5nRmFjdG9yOiAwLjk5LFxuICAgIC8vIExvd2VyIHRlbXBlcmF0dXJlIHRocmVzaG9sZCAoYmVsb3cgdGhpcyBwb2ludCB0aGUgbGF5b3V0IHdpbGwgZW5kKVxuICAgIG1pblRlbXA6IDEuMFxuICB9O1xuICAvKipcbiAgICogQGJyaWVmICAgICAgIDogY29uc3RydWN0b3JcbiAgICogQGFyZyBvcHRpb25zIDogb2JqZWN0IGNvbnRhaW5pbmcgbGF5b3V0IG9wdGlvbnNcbiAgICovXG5cbiAgZnVuY3Rpb24gQ29zZUxheW91dChvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gZXh0ZW5kKHt9LCBkZWZhdWx0cyQ0LCBvcHRpb25zKTtcbiAgICB0aGlzLm9wdGlvbnMubGF5b3V0ID0gdGhpcztcbiAgfVxuICAvKipcbiAgICogQGJyaWVmIDogcnVucyB0aGUgbGF5b3V0XG4gICAqL1xuXG5cbiAgQ29zZUxheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIHZhciBjeSA9IG9wdGlvbnMuY3k7XG4gICAgdmFyIGxheW91dCA9IHRoaXM7XG4gICAgbGF5b3V0LnN0b3BwZWQgPSBmYWxzZTtcblxuICAgIGlmIChvcHRpb25zLmFuaW1hdGUgPT09IHRydWUgfHwgb3B0aW9ucy5hbmltYXRlID09PSBmYWxzZSkge1xuICAgICAgbGF5b3V0LmVtaXQoe1xuICAgICAgICB0eXBlOiAnbGF5b3V0c3RhcnQnLFxuICAgICAgICBsYXlvdXQ6IGxheW91dFxuICAgICAgfSk7XG4gICAgfSAvLyBTZXQgREVCVUcgLSBHbG9iYWwgdmFyaWFibGVcblxuXG4gICAgaWYgKHRydWUgPT09IG9wdGlvbnMuZGVidWcpIHtcbiAgICAgIERFQlVHID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgREVCVUcgPSBmYWxzZTtcbiAgICB9IC8vIEluaXRpYWxpemUgbGF5b3V0IGluZm9cblxuXG4gICAgdmFyIGxheW91dEluZm8gPSBjcmVhdGVMYXlvdXRJbmZvKGN5LCBsYXlvdXQsIG9wdGlvbnMpOyAvLyBTaG93IExheW91dEluZm8gY29udGVudHMgaWYgZGVidWdnaW5nXG5cbiAgICBpZiAoREVCVUcpIHtcbiAgICAgIHByaW50TGF5b3V0SW5mbyhsYXlvdXRJbmZvKTtcbiAgICB9IC8vIElmIHJlcXVpcmVkLCByYW5kb21pemUgbm9kZSBwb3NpdGlvbnNcblxuXG4gICAgaWYgKG9wdGlvbnMucmFuZG9taXplKSB7XG4gICAgICByYW5kb21pemVQb3NpdGlvbnMobGF5b3V0SW5mbyk7XG4gICAgfVxuXG4gICAgdmFyIHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlTm93KCk7XG5cbiAgICB2YXIgcmVmcmVzaCA9IGZ1bmN0aW9uIHJlZnJlc2goKSB7XG4gICAgICByZWZyZXNoUG9zaXRpb25zKGxheW91dEluZm8sIGN5LCBvcHRpb25zKTsgLy8gRml0IHRoZSBncmFwaCBpZiBuZWNlc3NhcnlcblxuICAgICAgaWYgKHRydWUgPT09IG9wdGlvbnMuZml0KSB7XG4gICAgICAgIGN5LmZpdChvcHRpb25zLnBhZGRpbmcpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgbWFpbkxvb3AgPSBmdW5jdGlvbiBtYWluTG9vcChpKSB7XG4gICAgICBpZiAobGF5b3V0LnN0b3BwZWQgfHwgaSA+PSBvcHRpb25zLm51bUl0ZXIpIHtcbiAgICAgICAgLy8gbG9nRGVidWcoXCJMYXlvdXQgbWFudWFsbHkgc3RvcHBlZC4gU3RvcHBpbmcgY29tcHV0YXRpb24gaW4gc3RlcCBcIiArIGkpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IC8vIERvIG9uZSBzdGVwIGluIHRoZSBwaGlzaWNhbCBzaW11bGF0aW9uXG5cblxuICAgICAgc3RlcChsYXlvdXRJbmZvLCBvcHRpb25zKTsgLy8gVXBkYXRlIHRlbXBlcmF0dXJlXG5cbiAgICAgIGxheW91dEluZm8udGVtcGVyYXR1cmUgPSBsYXlvdXRJbmZvLnRlbXBlcmF0dXJlICogb3B0aW9ucy5jb29saW5nRmFjdG9yOyAvLyBsb2dEZWJ1ZyhcIk5ldyB0ZW1wZXJhdHVyZTogXCIgKyBsYXlvdXRJbmZvLnRlbXBlcmF0dXJlKTtcblxuICAgICAgaWYgKGxheW91dEluZm8udGVtcGVyYXR1cmUgPCBvcHRpb25zLm1pblRlbXApIHtcbiAgICAgICAgLy8gbG9nRGVidWcoXCJUZW1wZXJhdHVyZSBkcm9wIGJlbG93IG1pbmltdW0gdGhyZXNob2xkLiBTdG9wcGluZyBjb21wdXRhdGlvbiBpbiBzdGVwIFwiICsgaSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIHZhciBkb25lID0gZnVuY3Rpb24gZG9uZSgpIHtcbiAgICAgIGlmIChvcHRpb25zLmFuaW1hdGUgPT09IHRydWUgfHwgb3B0aW9ucy5hbmltYXRlID09PSBmYWxzZSkge1xuICAgICAgICByZWZyZXNoKCk7IC8vIExheW91dCBoYXMgZmluaXNoZWRcblxuICAgICAgICBsYXlvdXQub25lKCdsYXlvdXRzdG9wJywgb3B0aW9ucy5zdG9wKTtcbiAgICAgICAgbGF5b3V0LmVtaXQoe1xuICAgICAgICAgIHR5cGU6ICdsYXlvdXRzdG9wJyxcbiAgICAgICAgICBsYXlvdXQ6IGxheW91dFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBub2RlcyA9IG9wdGlvbnMuZWxlcy5ub2RlcygpO1xuICAgICAgICB2YXIgZ2V0U2NhbGVkUG9zID0gZ2V0U2NhbGVJbkJvdW5kc0ZuKGxheW91dEluZm8sIG9wdGlvbnMsIG5vZGVzKTtcbiAgICAgICAgbm9kZXMubGF5b3V0UG9zaXRpb25zKGxheW91dCwgb3B0aW9ucywgZ2V0U2NhbGVkUG9zKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsb29wUmV0ID0gdHJ1ZTtcblxuICAgIGlmIChvcHRpb25zLmFuaW1hdGUgPT09IHRydWUpIHtcbiAgICAgIHZhciBmcmFtZSA9IGZ1bmN0aW9uIGZyYW1lKCkge1xuICAgICAgICB2YXIgZiA9IDA7XG5cbiAgICAgICAgd2hpbGUgKGxvb3BSZXQgJiYgZiA8IG9wdGlvbnMucmVmcmVzaCkge1xuICAgICAgICAgIGxvb3BSZXQgPSBtYWluTG9vcChpKTtcbiAgICAgICAgICBpKys7XG4gICAgICAgICAgZisrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFsb29wUmV0KSB7XG4gICAgICAgICAgLy8gaXQncyBkb25lXG4gICAgICAgICAgc2VwYXJhdGVDb21wb25lbnRzKGxheW91dEluZm8sIG9wdGlvbnMpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbm93ID0gcGVyZm9ybWFuY2VOb3coKTtcblxuICAgICAgICAgIGlmIChub3cgLSBzdGFydFRpbWUgPj0gb3B0aW9ucy5hbmltYXRpb25UaHJlc2hvbGQpIHtcbiAgICAgICAgICAgIHJlZnJlc2goKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnJhbWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmcmFtZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aGlsZSAobG9vcFJldCkge1xuICAgICAgICBsb29wUmV0ID0gbWFpbkxvb3AoaSk7XG4gICAgICAgIGkrKztcbiAgICAgIH1cblxuICAgICAgc2VwYXJhdGVDb21wb25lbnRzKGxheW91dEluZm8sIG9wdGlvbnMpO1xuICAgICAgZG9uZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9O1xuICAvKipcbiAgICogQGJyaWVmIDogY2FsbGVkIG9uIGNvbnRpbnVvdXMgbGF5b3V0cyB0byBzdG9wIHRoZW0gYmVmb3JlIHRoZXkgZmluaXNoXG4gICAqL1xuXG5cbiAgQ29zZUxheW91dC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnN0b3BwZWQgPSB0cnVlO1xuXG4gICAgaWYgKHRoaXMudGhyZWFkKSB7XG4gICAgICB0aGlzLnRocmVhZC5zdG9wKCk7XG4gICAgfVxuXG4gICAgdGhpcy5lbWl0KCdsYXlvdXRzdG9wJyk7XG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH07XG5cbiAgQ29zZUxheW91dC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy50aHJlYWQpIHtcbiAgICAgIHRoaXMudGhyZWFkLnN0b3AoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfTtcbiAgLyoqXG4gICAqIEBicmllZiAgICAgOiBDcmVhdGVzIGFuIG9iamVjdCB3aGljaCBpcyBjb250YWlucyBhbGwgdGhlIGRhdGFcbiAgICogICAgICAgICAgICAgIHVzZWQgaW4gdGhlIGxheW91dCBwcm9jZXNzXG4gICAqIEBhcmcgY3kgICAgOiBjeXRvc2NhcGUuanMgb2JqZWN0XG4gICAqIEByZXR1cm4gICAgOiBsYXlvdXRJbmZvIG9iamVjdCBpbml0aWFsaXplZFxuICAgKi9cblxuXG4gIHZhciBjcmVhdGVMYXlvdXRJbmZvID0gZnVuY3Rpb24gY3JlYXRlTGF5b3V0SW5mbyhjeSwgbGF5b3V0LCBvcHRpb25zKSB7XG4gICAgLy8gU2hvcnRjdXRcbiAgICB2YXIgZWRnZXMgPSBvcHRpb25zLmVsZXMuZWRnZXMoKTtcbiAgICB2YXIgbm9kZXMgPSBvcHRpb25zLmVsZXMubm9kZXMoKTtcbiAgICB2YXIgbGF5b3V0SW5mbyA9IHtcbiAgICAgIGlzQ29tcG91bmQ6IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKSxcbiAgICAgIGxheW91dE5vZGVzOiBbXSxcbiAgICAgIGlkVG9JbmRleDoge30sXG4gICAgICBub2RlU2l6ZTogbm9kZXMuc2l6ZSgpLFxuICAgICAgZ3JhcGhTZXQ6IFtdLFxuICAgICAgaW5kZXhUb0dyYXBoOiBbXSxcbiAgICAgIGxheW91dEVkZ2VzOiBbXSxcbiAgICAgIGVkZ2VTaXplOiBlZGdlcy5zaXplKCksXG4gICAgICB0ZW1wZXJhdHVyZTogb3B0aW9ucy5pbml0aWFsVGVtcCxcbiAgICAgIGNsaWVudFdpZHRoOiBjeS53aWR0aCgpLFxuICAgICAgY2xpZW50SGVpZ2h0OiBjeS53aWR0aCgpLFxuICAgICAgYm91bmRpbmdCb3g6IG1ha2VCb3VuZGluZ0JveChvcHRpb25zLmJvdW5kaW5nQm94ID8gb3B0aW9ucy5ib3VuZGluZ0JveCA6IHtcbiAgICAgICAgeDE6IDAsXG4gICAgICAgIHkxOiAwLFxuICAgICAgICB3OiBjeS53aWR0aCgpLFxuICAgICAgICBoOiBjeS5oZWlnaHQoKVxuICAgICAgfSlcbiAgICB9O1xuICAgIHZhciBjb21wb25lbnRzID0gb3B0aW9ucy5lbGVzLmNvbXBvbmVudHMoKTtcbiAgICB2YXIgaWQyY21wdElkID0ge307XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbXBvbmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjb21wb25lbnQgPSBjb21wb25lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvbXBvbmVudC5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgbm9kZSA9IGNvbXBvbmVudFtqXTtcbiAgICAgICAgaWQyY21wdElkW25vZGUuaWQoKV0gPSBpO1xuICAgICAgfVxuICAgIH0gLy8gSXRlcmF0ZSBvdmVyIGFsbCBub2RlcywgY3JlYXRpbmcgbGF5b3V0IG5vZGVzXG5cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5ub2RlU2l6ZTsgaSsrKSB7XG4gICAgICB2YXIgbiA9IG5vZGVzW2ldO1xuICAgICAgdmFyIG5iYiA9IG4ubGF5b3V0RGltZW5zaW9ucyhvcHRpb25zKTtcbiAgICAgIHZhciB0ZW1wTm9kZSA9IHt9O1xuICAgICAgdGVtcE5vZGUuaXNMb2NrZWQgPSBuLmxvY2tlZCgpO1xuICAgICAgdGVtcE5vZGUuaWQgPSBuLmRhdGEoJ2lkJyk7XG4gICAgICB0ZW1wTm9kZS5wYXJlbnRJZCA9IG4uZGF0YSgncGFyZW50Jyk7XG4gICAgICB0ZW1wTm9kZS5jbXB0SWQgPSBpZDJjbXB0SWRbbi5pZCgpXTtcbiAgICAgIHRlbXBOb2RlLmNoaWxkcmVuID0gW107XG4gICAgICB0ZW1wTm9kZS5wb3NpdGlvblggPSBuLnBvc2l0aW9uKCd4Jyk7XG4gICAgICB0ZW1wTm9kZS5wb3NpdGlvblkgPSBuLnBvc2l0aW9uKCd5Jyk7XG4gICAgICB0ZW1wTm9kZS5vZmZzZXRYID0gMDtcbiAgICAgIHRlbXBOb2RlLm9mZnNldFkgPSAwO1xuICAgICAgdGVtcE5vZGUuaGVpZ2h0ID0gbmJiLnc7XG4gICAgICB0ZW1wTm9kZS53aWR0aCA9IG5iYi5oO1xuICAgICAgdGVtcE5vZGUubWF4WCA9IHRlbXBOb2RlLnBvc2l0aW9uWCArIHRlbXBOb2RlLndpZHRoIC8gMjtcbiAgICAgIHRlbXBOb2RlLm1pblggPSB0ZW1wTm9kZS5wb3NpdGlvblggLSB0ZW1wTm9kZS53aWR0aCAvIDI7XG4gICAgICB0ZW1wTm9kZS5tYXhZID0gdGVtcE5vZGUucG9zaXRpb25ZICsgdGVtcE5vZGUuaGVpZ2h0IC8gMjtcbiAgICAgIHRlbXBOb2RlLm1pblkgPSB0ZW1wTm9kZS5wb3NpdGlvblkgLSB0ZW1wTm9kZS5oZWlnaHQgLyAyO1xuICAgICAgdGVtcE5vZGUucGFkTGVmdCA9IHBhcnNlRmxvYXQobi5zdHlsZSgncGFkZGluZycpKTtcbiAgICAgIHRlbXBOb2RlLnBhZFJpZ2h0ID0gcGFyc2VGbG9hdChuLnN0eWxlKCdwYWRkaW5nJykpO1xuICAgICAgdGVtcE5vZGUucGFkVG9wID0gcGFyc2VGbG9hdChuLnN0eWxlKCdwYWRkaW5nJykpO1xuICAgICAgdGVtcE5vZGUucGFkQm90dG9tID0gcGFyc2VGbG9hdChuLnN0eWxlKCdwYWRkaW5nJykpOyAvLyBmb3JjZXNcblxuICAgICAgdGVtcE5vZGUubm9kZVJlcHVsc2lvbiA9IGZuJDYob3B0aW9ucy5ub2RlUmVwdWxzaW9uKSA/IG9wdGlvbnMubm9kZVJlcHVsc2lvbihuKSA6IG9wdGlvbnMubm9kZVJlcHVsc2lvbjsgLy8gQWRkIG5ldyBub2RlXG5cbiAgICAgIGxheW91dEluZm8ubGF5b3V0Tm9kZXMucHVzaCh0ZW1wTm9kZSk7IC8vIEFkZCBlbnRyeSB0byBpZC1pbmRleCBtYXBcblxuICAgICAgbGF5b3V0SW5mby5pZFRvSW5kZXhbdGVtcE5vZGUuaWRdID0gaTtcbiAgICB9IC8vIElubGluZSBpbXBsZW1lbnRhdGlvbiBvZiBhIHF1ZXVlLCB1c2VkIGZvciB0cmF2ZXJzaW5nIHRoZSBncmFwaCBpbiBCRlMgb3JkZXJcblxuXG4gICAgdmFyIHF1ZXVlID0gW107XG4gICAgdmFyIHN0YXJ0ID0gMDsgLy8gUG9pbnRzIHRvIHRoZSBzdGFydCB0aGUgcXVldWVcblxuICAgIHZhciBlbmQgPSAtMTsgLy8gUG9pbnRzIHRvIHRoZSBlbmQgb2YgdGhlIHF1ZXVlXG5cbiAgICB2YXIgdGVtcEdyYXBoID0gW107IC8vIFNlY29uZCBwYXNzIHRvIGFkZCBjaGlsZCBpbmZvcm1hdGlvbiBhbmRcbiAgICAvLyBpbml0aWFsaXplIHF1ZXVlIGZvciBoaWVyYXJjaGljYWwgdHJhdmVyc2FsXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8ubm9kZVNpemU7IGkrKykge1xuICAgICAgdmFyIG4gPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2ldO1xuICAgICAgdmFyIHBfaWQgPSBuLnBhcmVudElkOyAvLyBDaGVjayBpZiBub2RlIG4gaGFzIGEgcGFyZW50IG5vZGVcblxuICAgICAgaWYgKG51bGwgIT0gcF9pZCkge1xuICAgICAgICAvLyBBZGQgbm9kZSBJZCB0byBwYXJlbnQncyBsaXN0IG9mIGNoaWxkcmVuXG4gICAgICAgIGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbcF9pZF1dLmNoaWxkcmVuLnB1c2gobi5pZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiBhIG5vZGUgZG9lc24ndCBoYXZlIGEgcGFyZW50LCB0aGVuIGl0J3MgaW4gdGhlIHJvb3QgZ3JhcGhcbiAgICAgICAgcXVldWVbKytlbmRdID0gbi5pZDtcbiAgICAgICAgdGVtcEdyYXBoLnB1c2gobi5pZCk7XG4gICAgICB9XG4gICAgfSAvLyBBZGQgcm9vdCBncmFwaCB0byBncmFwaFNldFxuXG5cbiAgICBsYXlvdXRJbmZvLmdyYXBoU2V0LnB1c2godGVtcEdyYXBoKTsgLy8gVHJhdmVyc2UgdGhlIGdyYXBoLCBsZXZlbCBieSBsZXZlbCxcblxuICAgIHdoaWxlIChzdGFydCA8PSBlbmQpIHtcbiAgICAgIC8vIEdldCB0aGUgbm9kZSB0byB2aXNpdCBhbmQgcmVtb3ZlIGl0IGZyb20gcXVldWVcbiAgICAgIHZhciBub2RlX2lkID0gcXVldWVbc3RhcnQrK107XG4gICAgICB2YXIgbm9kZV9peCA9IGxheW91dEluZm8uaWRUb0luZGV4W25vZGVfaWRdO1xuICAgICAgdmFyIG5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW25vZGVfaXhdO1xuICAgICAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gQWRkIGNoaWxkcmVuIG5vZGVzIGFzIGEgbmV3IGdyYXBoIHRvIGdyYXBoIHNldFxuICAgICAgICBsYXlvdXRJbmZvLmdyYXBoU2V0LnB1c2goY2hpbGRyZW4pOyAvLyBBZGQgY2hpbGRyZW4gdG8gcXVlIHF1ZXVlIHRvIGJlIHZpc2l0ZWRcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgcXVldWVbKytlbmRdID0gY2hpbGRyZW5baV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIENyZWF0ZSBpbmRleFRvR3JhcGggbWFwXG5cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5ncmFwaFNldC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGdyYXBoID0gbGF5b3V0SW5mby5ncmFwaFNldFtpXTtcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBncmFwaC5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgaW5kZXggPSBsYXlvdXRJbmZvLmlkVG9JbmRleFtncmFwaFtqXV07XG4gICAgICAgIGxheW91dEluZm8uaW5kZXhUb0dyYXBoW2luZGV4XSA9IGk7XG4gICAgICB9XG4gICAgfSAvLyBJdGVyYXRlIG92ZXIgYWxsIGVkZ2VzLCBjcmVhdGluZyBMYXlvdXQgRWRnZXNcblxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLmVkZ2VTaXplOyBpKyspIHtcbiAgICAgIHZhciBlID0gZWRnZXNbaV07XG4gICAgICB2YXIgdGVtcEVkZ2UgPSB7fTtcbiAgICAgIHRlbXBFZGdlLmlkID0gZS5kYXRhKCdpZCcpO1xuICAgICAgdGVtcEVkZ2Uuc291cmNlSWQgPSBlLmRhdGEoJ3NvdXJjZScpO1xuICAgICAgdGVtcEVkZ2UudGFyZ2V0SWQgPSBlLmRhdGEoJ3RhcmdldCcpOyAvLyBDb21wdXRlIGlkZWFsIGxlbmd0aFxuXG4gICAgICB2YXIgaWRlYWxMZW5ndGggPSBmbiQ2KG9wdGlvbnMuaWRlYWxFZGdlTGVuZ3RoKSA/IG9wdGlvbnMuaWRlYWxFZGdlTGVuZ3RoKGUpIDogb3B0aW9ucy5pZGVhbEVkZ2VMZW5ndGg7XG4gICAgICB2YXIgZWxhc3RpY2l0eSA9IGZuJDYob3B0aW9ucy5lZGdlRWxhc3RpY2l0eSkgPyBvcHRpb25zLmVkZ2VFbGFzdGljaXR5KGUpIDogb3B0aW9ucy5lZGdlRWxhc3RpY2l0eTsgLy8gQ2hlY2sgaWYgaXQncyBhbiBpbnRlciBncmFwaCBlZGdlXG5cbiAgICAgIHZhciBzb3VyY2VJeCA9IGxheW91dEluZm8uaWRUb0luZGV4W3RlbXBFZGdlLnNvdXJjZUlkXTtcbiAgICAgIHZhciB0YXJnZXRJeCA9IGxheW91dEluZm8uaWRUb0luZGV4W3RlbXBFZGdlLnRhcmdldElkXTtcbiAgICAgIHZhciBzb3VyY2VHcmFwaCA9IGxheW91dEluZm8uaW5kZXhUb0dyYXBoW3NvdXJjZUl4XTtcbiAgICAgIHZhciB0YXJnZXRHcmFwaCA9IGxheW91dEluZm8uaW5kZXhUb0dyYXBoW3RhcmdldEl4XTtcblxuICAgICAgaWYgKHNvdXJjZUdyYXBoICE9IHRhcmdldEdyYXBoKSB7XG4gICAgICAgIC8vIEZpbmQgbG93ZXN0IGNvbW1vbiBncmFwaCBhbmNlc3RvclxuICAgICAgICB2YXIgbGNhID0gZmluZExDQSh0ZW1wRWRnZS5zb3VyY2VJZCwgdGVtcEVkZ2UudGFyZ2V0SWQsIGxheW91dEluZm8pOyAvLyBDb21wdXRlIHN1bSBvZiBub2RlIGRlcHRocywgcmVsYXRpdmUgdG8gbGNhIGdyYXBoXG5cbiAgICAgICAgdmFyIGxjYUdyYXBoID0gbGF5b3V0SW5mby5ncmFwaFNldFtsY2FdO1xuICAgICAgICB2YXIgZGVwdGggPSAwOyAvLyBTb3VyY2UgZGVwdGhcblxuICAgICAgICB2YXIgdGVtcE5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW3NvdXJjZUl4XTtcblxuICAgICAgICB3aGlsZSAoLTEgPT09IGxjYUdyYXBoLmluZGV4T2YodGVtcE5vZGUuaWQpKSB7XG4gICAgICAgICAgdGVtcE5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W3RlbXBOb2RlLnBhcmVudElkXV07XG4gICAgICAgICAgZGVwdGgrKztcbiAgICAgICAgfSAvLyBUYXJnZXQgZGVwdGhcblxuXG4gICAgICAgIHRlbXBOb2RlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1t0YXJnZXRJeF07XG5cbiAgICAgICAgd2hpbGUgKC0xID09PSBsY2FHcmFwaC5pbmRleE9mKHRlbXBOb2RlLmlkKSkge1xuICAgICAgICAgIHRlbXBOb2RlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFt0ZW1wTm9kZS5wYXJlbnRJZF1dO1xuICAgICAgICAgIGRlcHRoKys7XG4gICAgICAgIH0gLy8gbG9nRGVidWcoJ0xDQSBvZiBub2RlcyAnICsgdGVtcEVkZ2Uuc291cmNlSWQgKyAnIGFuZCAnICsgdGVtcEVkZ2UudGFyZ2V0SWQgK1xuICAgICAgICAvLyAgXCIuIEluZGV4OiBcIiArIGxjYSArIFwiIENvbnRlbnRzOiBcIiArIGxjYUdyYXBoLnRvU3RyaW5nKCkgK1xuICAgICAgICAvLyAgXCIuIERlcHRoOiBcIiArIGRlcHRoKTtcbiAgICAgICAgLy8gVXBkYXRlIGlkZWFsTGVuZ3RoXG5cblxuICAgICAgICBpZGVhbExlbmd0aCAqPSBkZXB0aCAqIG9wdGlvbnMubmVzdGluZ0ZhY3RvcjtcbiAgICAgIH1cblxuICAgICAgdGVtcEVkZ2UuaWRlYWxMZW5ndGggPSBpZGVhbExlbmd0aDtcbiAgICAgIHRlbXBFZGdlLmVsYXN0aWNpdHkgPSBlbGFzdGljaXR5O1xuICAgICAgbGF5b3V0SW5mby5sYXlvdXRFZGdlcy5wdXNoKHRlbXBFZGdlKTtcbiAgICB9IC8vIEZpbmFsbHksIHJldHVybiBsYXlvdXRJbmZvIG9iamVjdFxuXG5cbiAgICByZXR1cm4gbGF5b3V0SW5mbztcbiAgfTtcbiAgLyoqXG4gICAqIEBicmllZiA6IFRoaXMgZnVuY3Rpb24gZmluZHMgdGhlIGluZGV4IG9mIHRoZSBsb3dlc3QgY29tbW9uXG4gICAqICAgICAgICAgIGdyYXBoIGFuY2VzdG9yIGJldHdlZW4gMiBub2RlcyBpbiB0aGUgc3VidHJlZVxuICAgKiAgICAgICAgICAoZnJvbSB0aGUgZ3JhcGggaGllcmFyY2h5IGluZHVjZWQgdHJlZSkgd2hvc2VcbiAgICogICAgICAgICAgcm9vdCBpcyBncmFwaEl4XG4gICAqXG4gICAqIEBhcmcgbm9kZTE6IG5vZGUxJ3MgSURcbiAgICogQGFyZyBub2RlMjogbm9kZTIncyBJRFxuICAgKiBAYXJnIGxheW91dEluZm86IGxheW91dEluZm8gb2JqZWN0XG4gICAqXG4gICAqL1xuXG5cbiAgdmFyIGZpbmRMQ0EgPSBmdW5jdGlvbiBmaW5kTENBKG5vZGUxLCBub2RlMiwgbGF5b3V0SW5mbykge1xuICAgIC8vIEZpbmQgdGhlaXIgY29tbW9uIGFuY2VzdGVyLCBzdGFydGluZyBmcm9tIHRoZSByb290IGdyYXBoXG4gICAgdmFyIHJlcyA9IGZpbmRMQ0FfYXV4KG5vZGUxLCBub2RlMiwgMCwgbGF5b3V0SW5mbyk7XG5cbiAgICBpZiAoMiA+IHJlcy5jb3VudCkge1xuICAgICAgLy8gSWYgYXV4IGZ1bmN0aW9uIGNvdWxkbid0IGZpbmQgdGhlIGNvbW1vbiBhbmNlc3RlcixcbiAgICAgIC8vIHRoZW4gaXQgaXMgdGhlIHJvb3QgZ3JhcGhcbiAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcmVzLmdyYXBoO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIEBicmllZiAgICAgICAgICA6IEF1eGlsaWFyeSBmdW5jdGlvbiB1c2VkIGZvciBMQ0EgY29tcHV0YXRpb25cbiAgICpcbiAgICogQGFyZyBub2RlMSAgICAgIDogbm9kZTEncyBJRFxuICAgKiBAYXJnIG5vZGUyICAgICAgOiBub2RlMidzIElEXG4gICAqIEBhcmcgZ3JhcGhJeCAgICA6IHN1YmdyYXBoIGluZGV4XG4gICAqIEBhcmcgbGF5b3V0SW5mbyA6IGxheW91dEluZm8gb2JqZWN0XG4gICAqXG4gICAqIEByZXR1cm4gICAgICAgICA6IG9iamVjdCBvZiB0aGUgZm9ybSB7Y291bnQ6IFgsIGdyYXBoOiBZfSwgd2hlcmU6XG4gICAqICAgICAgICAgICAgICAgICAgIFggaXMgdGhlIG51bWJlciBvZiBhbmNlc3RvcnMgKG1heDogMikgZm91bmQgaW5cbiAgICogICAgICAgICAgICAgICAgICAgZ3JhcGhJeCAoYW5kIGl0J3Mgc3ViZ3JhcGhzKSxcbiAgICogICAgICAgICAgICAgICAgICAgWSBpcyB0aGUgZ3JhcGggaW5kZXggb2YgdGhlIGxvd2VzdCBncmFwaCBjb250YWluaW5nXG4gICAqICAgICAgICAgICAgICAgICAgIGFsbCBYIG5vZGVzXG4gICAqL1xuXG5cbiAgdmFyIGZpbmRMQ0FfYXV4ID0gZnVuY3Rpb24gZmluZExDQV9hdXgobm9kZTEsIG5vZGUyLCBncmFwaEl4LCBsYXlvdXRJbmZvKSB7XG4gICAgdmFyIGdyYXBoID0gbGF5b3V0SW5mby5ncmFwaFNldFtncmFwaEl4XTsgLy8gSWYgYm90aCBub2RlcyBiZWxvbmdzIHRvIGdyYXBoSXhcblxuICAgIGlmICgtMSA8IGdyYXBoLmluZGV4T2Yobm9kZTEpICYmIC0xIDwgZ3JhcGguaW5kZXhPZihub2RlMikpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvdW50OiAyLFxuICAgICAgICBncmFwaDogZ3JhcGhJeFxuICAgICAgfTtcbiAgICB9IC8vIE1ha2UgcmVjdXJzaXZlIGNhbGxzIGZvciBhbGwgc3ViZ3JhcGhzXG5cblxuICAgIHZhciBjID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JhcGgubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBub2RlSWQgPSBncmFwaFtpXTtcbiAgICAgIHZhciBub2RlSXggPSBsYXlvdXRJbmZvLmlkVG9JbmRleFtub2RlSWRdO1xuICAgICAgdmFyIGNoaWxkcmVuID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tub2RlSXhdLmNoaWxkcmVuOyAvLyBJZiB0aGUgbm9kZSBoYXMgbm8gY2hpbGQsIHNraXAgaXRcblxuICAgICAgaWYgKDAgPT09IGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNoaWxkR3JhcGhJeCA9IGxheW91dEluZm8uaW5kZXhUb0dyYXBoW2xheW91dEluZm8uaWRUb0luZGV4W2NoaWxkcmVuWzBdXV07XG4gICAgICB2YXIgcmVzdWx0ID0gZmluZExDQV9hdXgobm9kZTEsIG5vZGUyLCBjaGlsZEdyYXBoSXgsIGxheW91dEluZm8pO1xuXG4gICAgICBpZiAoMCA9PT0gcmVzdWx0LmNvdW50KSB7XG4gICAgICAgIC8vIE5laXRoZXIgbm9kZTEgbm9yIG5vZGUyIGFyZSBwcmVzZW50IGluIHRoaXMgc3ViZ3JhcGhcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKDEgPT09IHJlc3VsdC5jb3VudCkge1xuICAgICAgICAvLyBPbmUgb2YgKG5vZGUxLCBub2RlMikgaXMgcHJlc2VudCBpbiB0aGlzIHN1YmdyYXBoXG4gICAgICAgIGMrKztcblxuICAgICAgICBpZiAoMiA9PT0gYykge1xuICAgICAgICAgIC8vIFdlJ3ZlIGFscmVhZHkgZm91bmQgYm90aCBub2Rlcywgbm8gbmVlZCB0byBrZWVwIHNlYXJjaGluZ1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBCb3RoIG5vZGVzIGFyZSBwcmVzZW50IGluIHRoaXMgc3ViZ3JhcGhcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgY291bnQ6IGMsXG4gICAgICBncmFwaDogZ3JhcGhJeFxuICAgIH07XG4gIH07XG4gIC8qKlxuICAgKiBAYnJpZWY6IHByaW50c0xheW91dEluZm8gaW50byBqcyBjb25zb2xlXG4gICAqICAgICAgICAgT25seSB1c2VkIGZvciBkZWJidWdpbmdcbiAgICovXG5cblxudmFyIHByaW50TGF5b3V0SW5mbzsgXG4gIC8qKlxuICAgKiBAYnJpZWYgOiBSYW5kb21pemVzIHRoZSBwb3NpdGlvbiBvZiBhbGwgbm9kZXNcbiAgICovXG5cblxuICB2YXIgcmFuZG9taXplUG9zaXRpb25zID0gZnVuY3Rpb24gcmFuZG9taXplUG9zaXRpb25zKGxheW91dEluZm8sIGN5KSB7XG4gICAgdmFyIHdpZHRoID0gbGF5b3V0SW5mby5jbGllbnRXaWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gbGF5b3V0SW5mby5jbGllbnRIZWlnaHQ7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8ubm9kZVNpemU7IGkrKykge1xuICAgICAgdmFyIG4gPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2ldOyAvLyBObyBuZWVkIHRvIHJhbmRvbWl6ZSBjb21wb3VuZCBub2RlcyBvciBsb2NrZWQgbm9kZXNcblxuICAgICAgaWYgKDAgPT09IG4uY2hpbGRyZW4ubGVuZ3RoICYmICFuLmlzTG9ja2VkKSB7XG4gICAgICAgIG4ucG9zaXRpb25YID0gTWF0aC5yYW5kb20oKSAqIHdpZHRoO1xuICAgICAgICBuLnBvc2l0aW9uWSA9IE1hdGgucmFuZG9tKCkgKiBoZWlnaHQ7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBnZXRTY2FsZUluQm91bmRzRm4gPSBmdW5jdGlvbiBnZXRTY2FsZUluQm91bmRzRm4obGF5b3V0SW5mbywgb3B0aW9ucywgbm9kZXMpIHtcbiAgICB2YXIgYmIgPSBsYXlvdXRJbmZvLmJvdW5kaW5nQm94O1xuICAgIHZhciBjb3NlQkIgPSB7XG4gICAgICB4MTogSW5maW5pdHksXG4gICAgICB4MjogLUluZmluaXR5LFxuICAgICAgeTE6IEluZmluaXR5LFxuICAgICAgeTI6IC1JbmZpbml0eVxuICAgIH07XG5cbiAgICBpZiAob3B0aW9ucy5ib3VuZGluZ0JveCkge1xuICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgbG5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W25vZGUuZGF0YSgnaWQnKV1dO1xuICAgICAgICBjb3NlQkIueDEgPSBNYXRoLm1pbihjb3NlQkIueDEsIGxub2RlLnBvc2l0aW9uWCk7XG4gICAgICAgIGNvc2VCQi54MiA9IE1hdGgubWF4KGNvc2VCQi54MiwgbG5vZGUucG9zaXRpb25YKTtcbiAgICAgICAgY29zZUJCLnkxID0gTWF0aC5taW4oY29zZUJCLnkxLCBsbm9kZS5wb3NpdGlvblkpO1xuICAgICAgICBjb3NlQkIueTIgPSBNYXRoLm1heChjb3NlQkIueTIsIGxub2RlLnBvc2l0aW9uWSk7XG4gICAgICB9KTtcbiAgICAgIGNvc2VCQi53ID0gY29zZUJCLngyIC0gY29zZUJCLngxO1xuICAgICAgY29zZUJCLmggPSBjb3NlQkIueTIgLSBjb3NlQkIueTE7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlbGUsIGkpIHtcbiAgICAgIHZhciBsbm9kZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbZWxlLmRhdGEoJ2lkJyldXTtcblxuICAgICAgaWYgKG9wdGlvbnMuYm91bmRpbmdCb3gpIHtcbiAgICAgICAgLy8gdGhlbiBhZGQgZXh0cmEgYm91bmRpbmcgYm94IGNvbnN0cmFpbnRcbiAgICAgICAgdmFyIHBjdFggPSAobG5vZGUucG9zaXRpb25YIC0gY29zZUJCLngxKSAvIGNvc2VCQi53O1xuICAgICAgICB2YXIgcGN0WSA9IChsbm9kZS5wb3NpdGlvblkgLSBjb3NlQkIueTEpIC8gY29zZUJCLmg7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogYmIueDEgKyBwY3RYICogYmIudyxcbiAgICAgICAgICB5OiBiYi55MSArIHBjdFkgKiBiYi5oXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IGxub2RlLnBvc2l0aW9uWCxcbiAgICAgICAgICB5OiBsbm9kZS5wb3NpdGlvbllcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuICAvKipcbiAgICogQGJyaWVmICAgICAgICAgIDogVXBkYXRlcyB0aGUgcG9zaXRpb25zIG9mIG5vZGVzIGluIHRoZSBuZXR3b3JrXG4gICAqIEBhcmcgbGF5b3V0SW5mbyA6IExheW91dEluZm8gb2JqZWN0XG4gICAqIEBhcmcgY3kgICAgICAgICA6IEN5dG9zY2FwZSBvYmplY3RcbiAgICogQGFyZyBvcHRpb25zICAgIDogTGF5b3V0IG9wdGlvbnNcbiAgICovXG5cblxuICB2YXIgcmVmcmVzaFBvc2l0aW9ucyA9IGZ1bmN0aW9uIHJlZnJlc2hQb3NpdGlvbnMobGF5b3V0SW5mbywgY3ksIG9wdGlvbnMpIHtcbiAgICAvLyB2YXIgcyA9ICdSZWZyZXNoaW5nIHBvc2l0aW9ucyc7XG4gICAgLy8gbG9nRGVidWcocyk7XG4gICAgdmFyIGxheW91dCA9IG9wdGlvbnMubGF5b3V0O1xuICAgIHZhciBub2RlcyA9IG9wdGlvbnMuZWxlcy5ub2RlcygpO1xuICAgIHZhciBnZXRTY2FsZWRQb3MgPSBnZXRTY2FsZUluQm91bmRzRm4obGF5b3V0SW5mbywgb3B0aW9ucywgbm9kZXMpO1xuICAgIG5vZGVzLnBvc2l0aW9ucyhnZXRTY2FsZWRQb3MpOyAvLyBUcmlnZ2VyIGxheW91dFJlYWR5IG9ubHkgb24gZmlyc3QgY2FsbFxuXG4gICAgaWYgKHRydWUgIT09IGxheW91dEluZm8ucmVhZHkpIHtcbiAgICAgIC8vIHMgPSAnVHJpZ2dlcmluZyBsYXlvdXRyZWFkeSc7XG4gICAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICAgIGxheW91dEluZm8ucmVhZHkgPSB0cnVlO1xuICAgICAgbGF5b3V0Lm9uZSgnbGF5b3V0cmVhZHknLCBvcHRpb25zLnJlYWR5KTtcbiAgICAgIGxheW91dC5lbWl0KHtcbiAgICAgICAgdHlwZTogJ2xheW91dHJlYWR5JyxcbiAgICAgICAgbGF5b3V0OiB0aGlzXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBAYnJpZWYgOiBMb2dzIGEgZGVidWcgbWVzc2FnZSBpbiBKUyBjb25zb2xlLCBpZiBERUJVRyBpcyBPTlxuICAgKi9cbiAgLy8gdmFyIGxvZ0RlYnVnID0gZnVuY3Rpb24odGV4dCkge1xuICAvLyAgIGlmIChERUJVRykge1xuICAvLyAgICAgY29uc29sZS5kZWJ1Zyh0ZXh0KTtcbiAgLy8gICB9XG4gIC8vIH07XG5cbiAgLyoqXG4gICAqIEBicmllZiAgICAgICAgICA6IFBlcmZvcm1zIG9uZSBpdGVyYXRpb24gb2YgdGhlIHBoeXNpY2FsIHNpbXVsYXRpb25cbiAgICogQGFyZyBsYXlvdXRJbmZvIDogTGF5b3V0SW5mbyBvYmplY3QgYWxyZWFkeSBpbml0aWFsaXplZFxuICAgKiBAYXJnIGN5ICAgICAgICAgOiBDeXRvc2NhcGUgb2JqZWN0XG4gICAqIEBhcmcgb3B0aW9ucyAgICA6IExheW91dCBvcHRpb25zXG4gICAqL1xuXG5cbiAgdmFyIHN0ZXAgPSBmdW5jdGlvbiBzdGVwKGxheW91dEluZm8sIG9wdGlvbnMsIF9zdGVwKSB7XG4gICAgLy8gdmFyIHMgPSBcIlxcblxcbiMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcIjtcbiAgICAvLyBzICs9IFwiXFxuU1RFUDogXCIgKyBzdGVwO1xuICAgIC8vIHMgKz0gXCJcXG4jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXFxuXCI7XG4gICAgLy8gbG9nRGVidWcocyk7XG4gICAgLy8gQ2FsY3VsYXRlIG5vZGUgcmVwdWxzaW9uc1xuICAgIGNhbGN1bGF0ZU5vZGVGb3JjZXMobGF5b3V0SW5mbywgb3B0aW9ucyk7IC8vIENhbGN1bGF0ZSBlZGdlIGZvcmNlc1xuXG4gICAgY2FsY3VsYXRlRWRnZUZvcmNlcyhsYXlvdXRJbmZvKTsgLy8gQ2FsY3VsYXRlIGdyYXZpdHkgZm9yY2VzXG5cbiAgICBjYWxjdWxhdGVHcmF2aXR5Rm9yY2VzKGxheW91dEluZm8sIG9wdGlvbnMpOyAvLyBQcm9wYWdhdGUgZm9yY2VzIGZyb20gcGFyZW50IHRvIGNoaWxkXG5cbiAgICBwcm9wYWdhdGVGb3JjZXMobGF5b3V0SW5mbyk7IC8vIFVwZGF0ZSBwb3NpdGlvbnMgYmFzZWQgb24gY2FsY3VsYXRlZCBmb3JjZXNcblxuICAgIHVwZGF0ZVBvc2l0aW9ucyhsYXlvdXRJbmZvKTtcbiAgfTtcbiAgLyoqXG4gICAqIEBicmllZiA6IENvbXB1dGVzIHRoZSBub2RlIHJlcHVsc2lvbiBmb3JjZXNcbiAgICovXG5cblxuICB2YXIgY2FsY3VsYXRlTm9kZUZvcmNlcyA9IGZ1bmN0aW9uIGNhbGN1bGF0ZU5vZGVGb3JjZXMobGF5b3V0SW5mbywgb3B0aW9ucykge1xuICAgIC8vIEdvIHRocm91Z2ggZWFjaCBvZiB0aGUgZ3JhcGhzIGluIGdyYXBoU2V0XG4gICAgLy8gTm9kZXMgb25seSByZXBlbCBlYWNoIG90aGVyIGlmIHRoZXkgYmVsb25nIHRvIHRoZSBzYW1lIGdyYXBoXG4gICAgLy8gdmFyIHMgPSAnY2FsY3VsYXRlTm9kZUZvcmNlcyc7XG4gICAgLy8gbG9nRGVidWcocyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLmdyYXBoU2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZ3JhcGggPSBsYXlvdXRJbmZvLmdyYXBoU2V0W2ldO1xuICAgICAgdmFyIG51bU5vZGVzID0gZ3JhcGgubGVuZ3RoOyAvLyBzID0gXCJTZXQ6IFwiICsgZ3JhcGgudG9TdHJpbmcoKTtcbiAgICAgIC8vIGxvZ0RlYnVnKHMpO1xuICAgICAgLy8gTm93IGdldCBhbGwgdGhlIHBhaXJzIG9mIG5vZGVzXG4gICAgICAvLyBPbmx5IGdldCBlYWNoIHBhaXIgb25jZSwgKEEsIEIpID0gKEIsIEEpXG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnVtTm9kZXM7IGorKykge1xuICAgICAgICB2YXIgbm9kZTEgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W2dyYXBoW2pdXV07XG5cbiAgICAgICAgZm9yICh2YXIgayA9IGogKyAxOyBrIDwgbnVtTm9kZXM7IGsrKykge1xuICAgICAgICAgIHZhciBub2RlMiA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbZ3JhcGhba11dXTtcbiAgICAgICAgICBub2RlUmVwdWxzaW9uKG5vZGUxLCBub2RlMiwgbGF5b3V0SW5mbywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIHJhbmRvbURpc3RhbmNlID0gZnVuY3Rpb24gcmFuZG9tRGlzdGFuY2UobWF4KSB7XG4gICAgcmV0dXJuIC1tYXggKyAyICogbWF4ICogTWF0aC5yYW5kb20oKTtcbiAgfTtcbiAgLyoqXG4gICAqIEBicmllZiA6IENvbXB1dGUgdGhlIG5vZGUgcmVwdWxzaW9uIGZvcmNlcyBiZXR3ZWVuIGEgcGFpciBvZiBub2Rlc1xuICAgKi9cblxuXG4gIHZhciBub2RlUmVwdWxzaW9uID0gZnVuY3Rpb24gbm9kZVJlcHVsc2lvbihub2RlMSwgbm9kZTIsIGxheW91dEluZm8sIG9wdGlvbnMpIHtcbiAgICAvLyB2YXIgcyA9IFwiTm9kZSByZXB1bHNpb24uIE5vZGUxOiBcIiArIG5vZGUxLmlkICsgXCIgTm9kZTI6IFwiICsgbm9kZTIuaWQ7XG4gICAgdmFyIGNtcHRJZDEgPSBub2RlMS5jbXB0SWQ7XG4gICAgdmFyIGNtcHRJZDIgPSBub2RlMi5jbXB0SWQ7XG5cbiAgICBpZiAoY21wdElkMSAhPT0gY21wdElkMiAmJiAhbGF5b3V0SW5mby5pc0NvbXBvdW5kKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBHZXQgZGlyZWN0aW9uIG9mIGxpbmUgY29ubmVjdGluZyBib3RoIG5vZGUgY2VudGVyc1xuXG5cbiAgICB2YXIgZGlyZWN0aW9uWCA9IG5vZGUyLnBvc2l0aW9uWCAtIG5vZGUxLnBvc2l0aW9uWDtcbiAgICB2YXIgZGlyZWN0aW9uWSA9IG5vZGUyLnBvc2l0aW9uWSAtIG5vZGUxLnBvc2l0aW9uWTtcbiAgICB2YXIgbWF4UmFuZERpc3QgPSAxOyAvLyBzICs9IFwiXFxuZGlyZWN0aW9uWDogXCIgKyBkaXJlY3Rpb25YICsgXCIsIGRpcmVjdGlvblk6IFwiICsgZGlyZWN0aW9uWTtcbiAgICAvLyBJZiBib3RoIGNlbnRlcnMgYXJlIHRoZSBzYW1lLCBhcHBseSBhIHJhbmRvbSBmb3JjZVxuXG4gICAgaWYgKDAgPT09IGRpcmVjdGlvblggJiYgMCA9PT0gZGlyZWN0aW9uWSkge1xuICAgICAgZGlyZWN0aW9uWCA9IHJhbmRvbURpc3RhbmNlKG1heFJhbmREaXN0KTtcbiAgICAgIGRpcmVjdGlvblkgPSByYW5kb21EaXN0YW5jZShtYXhSYW5kRGlzdCk7XG4gICAgfVxuXG4gICAgdmFyIG92ZXJsYXAgPSBub2Rlc092ZXJsYXAobm9kZTEsIG5vZGUyLCBkaXJlY3Rpb25YLCBkaXJlY3Rpb25ZKTtcblxuICAgIGlmIChvdmVybGFwID4gMCkge1xuICAgICAgLy8gcyArPSBcIlxcbk5vZGVzIERPIG92ZXJsYXAuXCI7XG4gICAgICAvLyBzICs9IFwiXFxuT3ZlcmxhcDogXCIgKyBvdmVybGFwO1xuICAgICAgLy8gSWYgbm9kZXMgb3ZlcmxhcCwgcmVwdWxzaW9uIGZvcmNlIGlzIHByb3BvcnRpb25hbFxuICAgICAgLy8gdG8gdGhlIG92ZXJsYXBcbiAgICAgIHZhciBmb3JjZSA9IG9wdGlvbnMubm9kZU92ZXJsYXAgKiBvdmVybGFwOyAvLyBDb21wdXRlIHRoZSBtb2R1bGUgYW5kIGNvbXBvbmVudHMgb2YgdGhlIGZvcmNlIHZlY3RvclxuXG4gICAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZGlyZWN0aW9uWCAqIGRpcmVjdGlvblggKyBkaXJlY3Rpb25ZICogZGlyZWN0aW9uWSk7IC8vIHMgKz0gXCJcXG5EaXN0YW5jZTogXCIgKyBkaXN0YW5jZTtcblxuICAgICAgdmFyIGZvcmNlWCA9IGZvcmNlICogZGlyZWN0aW9uWCAvIGRpc3RhbmNlO1xuICAgICAgdmFyIGZvcmNlWSA9IGZvcmNlICogZGlyZWN0aW9uWSAvIGRpc3RhbmNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBzICs9IFwiXFxuTm9kZXMgZG8gTk9UIG92ZXJsYXAuXCI7XG4gICAgICAvLyBJZiB0aGVyZSdzIG5vIG92ZXJsYXAsIGZvcmNlIGlzIGludmVyc2VseSBwcm9wb3J0aW9uYWxcbiAgICAgIC8vIHRvIHNxdWFyZWQgZGlzdGFuY2VcbiAgICAgIC8vIEdldCBjbGlwcGluZyBwb2ludHMgZm9yIGJvdGggbm9kZXNcbiAgICAgIHZhciBwb2ludDEgPSBmaW5kQ2xpcHBpbmdQb2ludChub2RlMSwgZGlyZWN0aW9uWCwgZGlyZWN0aW9uWSk7XG4gICAgICB2YXIgcG9pbnQyID0gZmluZENsaXBwaW5nUG9pbnQobm9kZTIsIC0xICogZGlyZWN0aW9uWCwgLTEgKiBkaXJlY3Rpb25ZKTsgLy8gVXNlIGNsaXBwaW5nIHBvaW50cyB0byBjb21wdXRlIGRpc3RhbmNlXG5cbiAgICAgIHZhciBkaXN0YW5jZVggPSBwb2ludDIueCAtIHBvaW50MS54O1xuICAgICAgdmFyIGRpc3RhbmNlWSA9IHBvaW50Mi55IC0gcG9pbnQxLnk7XG4gICAgICB2YXIgZGlzdGFuY2VTcXIgPSBkaXN0YW5jZVggKiBkaXN0YW5jZVggKyBkaXN0YW5jZVkgKiBkaXN0YW5jZVk7XG4gICAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZGlzdGFuY2VTcXIpOyAvLyBzICs9IFwiXFxuRGlzdGFuY2U6IFwiICsgZGlzdGFuY2U7XG4gICAgICAvLyBDb21wdXRlIHRoZSBtb2R1bGUgYW5kIGNvbXBvbmVudHMgb2YgdGhlIGZvcmNlIHZlY3RvclxuXG4gICAgICB2YXIgZm9yY2UgPSAobm9kZTEubm9kZVJlcHVsc2lvbiArIG5vZGUyLm5vZGVSZXB1bHNpb24pIC8gZGlzdGFuY2VTcXI7XG4gICAgICB2YXIgZm9yY2VYID0gZm9yY2UgKiBkaXN0YW5jZVggLyBkaXN0YW5jZTtcbiAgICAgIHZhciBmb3JjZVkgPSBmb3JjZSAqIGRpc3RhbmNlWSAvIGRpc3RhbmNlO1xuICAgIH0gLy8gQXBwbHkgZm9yY2VcblxuXG4gICAgaWYgKCFub2RlMS5pc0xvY2tlZCkge1xuICAgICAgbm9kZTEub2Zmc2V0WCAtPSBmb3JjZVg7XG4gICAgICBub2RlMS5vZmZzZXRZIC09IGZvcmNlWTtcbiAgICB9XG5cbiAgICBpZiAoIW5vZGUyLmlzTG9ja2VkKSB7XG4gICAgICBub2RlMi5vZmZzZXRYICs9IGZvcmNlWDtcbiAgICAgIG5vZGUyLm9mZnNldFkgKz0gZm9yY2VZO1xuICAgIH0gLy8gcyArPSBcIlxcbkZvcmNlWDogXCIgKyBmb3JjZVggKyBcIiBGb3JjZVk6IFwiICsgZm9yY2VZO1xuICAgIC8vIGxvZ0RlYnVnKHMpO1xuXG5cbiAgICByZXR1cm47XG4gIH07XG4gIC8qKlxuICAgKiBAYnJpZWYgIDogRGV0ZXJtaW5lcyB3aGV0aGVyIHR3byBub2RlcyBvdmVybGFwIG9yIG5vdFxuICAgKiBAcmV0dXJuIDogQW1vdW50IG9mIG92ZXJsYXBwaW5nICgwID0+IG5vIG92ZXJsYXApXG4gICAqL1xuXG5cbiAgdmFyIG5vZGVzT3ZlcmxhcCA9IGZ1bmN0aW9uIG5vZGVzT3ZlcmxhcChub2RlMSwgbm9kZTIsIGRYLCBkWSkge1xuICAgIGlmIChkWCA+IDApIHtcbiAgICAgIHZhciBvdmVybGFwWCA9IG5vZGUxLm1heFggLSBub2RlMi5taW5YO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgb3ZlcmxhcFggPSBub2RlMi5tYXhYIC0gbm9kZTEubWluWDtcbiAgICB9XG5cbiAgICBpZiAoZFkgPiAwKSB7XG4gICAgICB2YXIgb3ZlcmxhcFkgPSBub2RlMS5tYXhZIC0gbm9kZTIubWluWTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG92ZXJsYXBZID0gbm9kZTIubWF4WSAtIG5vZGUxLm1pblk7XG4gICAgfVxuXG4gICAgaWYgKG92ZXJsYXBYID49IDAgJiYgb3ZlcmxhcFkgPj0gMCkge1xuICAgICAgcmV0dXJuIE1hdGguc3FydChvdmVybGFwWCAqIG92ZXJsYXBYICsgb3ZlcmxhcFkgKiBvdmVybGFwWSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIEBicmllZiA6IEZpbmRzIHRoZSBwb2ludCBpbiB3aGljaCBhbiBlZGdlIChkaXJlY3Rpb24gZFgsIGRZKSBpbnRlcnNlY3RzXG4gICAqICAgICAgICAgIHRoZSByZWN0YW5ndWxhciBib3VuZGluZyBib3ggb2YgaXQncyBzb3VyY2UvdGFyZ2V0IG5vZGVcbiAgICovXG5cblxuICB2YXIgZmluZENsaXBwaW5nUG9pbnQgPSBmdW5jdGlvbiBmaW5kQ2xpcHBpbmdQb2ludChub2RlLCBkWCwgZFkpIHtcbiAgICAvLyBTaG9yY3V0c1xuICAgIHZhciBYID0gbm9kZS5wb3NpdGlvblg7XG4gICAgdmFyIFkgPSBub2RlLnBvc2l0aW9uWTtcbiAgICB2YXIgSCA9IG5vZGUuaGVpZ2h0IHx8IDE7XG4gICAgdmFyIFcgPSBub2RlLndpZHRoIHx8IDE7XG4gICAgdmFyIGRpclNsb3BlID0gZFkgLyBkWDtcbiAgICB2YXIgbm9kZVNsb3BlID0gSCAvIFc7IC8vIHZhciBzID0gJ0NvbXB1dGluZyBjbGlwcGluZyBwb2ludCBvZiBub2RlICcgKyBub2RlLmlkICtcbiAgICAvLyAgIFwiIC4gSGVpZ2h0OiAgXCIgKyBIICsgXCIsIFdpZHRoOiBcIiArIFcgK1xuICAgIC8vICAgXCJcXG5EaXJlY3Rpb24gXCIgKyBkWCArIFwiLCBcIiArIGRZO1xuICAgIC8vXG4gICAgLy8gQ29tcHV0ZSBpbnRlcnNlY3Rpb25cblxuICAgIHZhciByZXMgPSB7fTsgLy8gQ2FzZTogVmVydGljYWwgZGlyZWN0aW9uICh1cClcblxuICAgIGlmICgwID09PSBkWCAmJiAwIDwgZFkpIHtcbiAgICAgIHJlcy54ID0gWDsgLy8gcyArPSBcIlxcblVwIGRpcmVjdGlvblwiO1xuXG4gICAgICByZXMueSA9IFkgKyBIIC8gMjtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfSAvLyBDYXNlOiBWZXJ0aWNhbCBkaXJlY3Rpb24gKGRvd24pXG5cblxuICAgIGlmICgwID09PSBkWCAmJiAwID4gZFkpIHtcbiAgICAgIHJlcy54ID0gWDtcbiAgICAgIHJlcy55ID0gWSArIEggLyAyOyAvLyBzICs9IFwiXFxuRG93biBkaXJlY3Rpb25cIjtcblxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9IC8vIENhc2U6IEludGVyc2VjdHMgdGhlIHJpZ2h0IGJvcmRlclxuXG5cbiAgICBpZiAoMCA8IGRYICYmIC0xICogbm9kZVNsb3BlIDw9IGRpclNsb3BlICYmIGRpclNsb3BlIDw9IG5vZGVTbG9wZSkge1xuICAgICAgcmVzLnggPSBYICsgVyAvIDI7XG4gICAgICByZXMueSA9IFkgKyBXICogZFkgLyAyIC8gZFg7IC8vIHMgKz0gXCJcXG5SaWdodGJvcmRlclwiO1xuXG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0gLy8gQ2FzZTogSW50ZXJzZWN0cyB0aGUgbGVmdCBib3JkZXJcblxuXG4gICAgaWYgKDAgPiBkWCAmJiAtMSAqIG5vZGVTbG9wZSA8PSBkaXJTbG9wZSAmJiBkaXJTbG9wZSA8PSBub2RlU2xvcGUpIHtcbiAgICAgIHJlcy54ID0gWCAtIFcgLyAyO1xuICAgICAgcmVzLnkgPSBZIC0gVyAqIGRZIC8gMiAvIGRYOyAvLyBzICs9IFwiXFxuTGVmdGJvcmRlclwiO1xuXG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0gLy8gQ2FzZTogSW50ZXJzZWN0cyB0aGUgdG9wIGJvcmRlclxuXG5cbiAgICBpZiAoMCA8IGRZICYmIChkaXJTbG9wZSA8PSAtMSAqIG5vZGVTbG9wZSB8fCBkaXJTbG9wZSA+PSBub2RlU2xvcGUpKSB7XG4gICAgICByZXMueCA9IFggKyBIICogZFggLyAyIC8gZFk7XG4gICAgICByZXMueSA9IFkgKyBIIC8gMjsgLy8gcyArPSBcIlxcblRvcCBib3JkZXJcIjtcblxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9IC8vIENhc2U6IEludGVyc2VjdHMgdGhlIGJvdHRvbSBib3JkZXJcblxuXG4gICAgaWYgKDAgPiBkWSAmJiAoZGlyU2xvcGUgPD0gLTEgKiBub2RlU2xvcGUgfHwgZGlyU2xvcGUgPj0gbm9kZVNsb3BlKSkge1xuICAgICAgcmVzLnggPSBYIC0gSCAqIGRYIC8gMiAvIGRZO1xuICAgICAgcmVzLnkgPSBZIC0gSCAvIDI7IC8vIHMgKz0gXCJcXG5Cb3R0b20gYm9yZGVyXCI7XG5cbiAgICAgIHJldHVybiByZXM7XG4gICAgfSAvLyBzICs9IFwiXFxuQ2xpcHBpbmcgcG9pbnQgZm91bmQgYXQgXCIgKyByZXMueCArIFwiLCBcIiArIHJlcy55O1xuICAgIC8vIGxvZ0RlYnVnKHMpO1xuXG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuICAvKipcbiAgICogQGJyaWVmIDogQ2FsY3VsYXRlcyBhbGwgZWRnZSBmb3JjZXNcbiAgICovXG5cblxuICB2YXIgY2FsY3VsYXRlRWRnZUZvcmNlcyA9IGZ1bmN0aW9uIGNhbGN1bGF0ZUVkZ2VGb3JjZXMobGF5b3V0SW5mbywgb3B0aW9ucykge1xuICAgIC8vIEl0ZXJhdGUgb3ZlciBhbGwgZWRnZXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8uZWRnZVNpemU7IGkrKykge1xuICAgICAgLy8gR2V0IGVkZ2UsIHNvdXJjZSAmIHRhcmdldCBub2Rlc1xuICAgICAgdmFyIGVkZ2UgPSBsYXlvdXRJbmZvLmxheW91dEVkZ2VzW2ldO1xuICAgICAgdmFyIHNvdXJjZUl4ID0gbGF5b3V0SW5mby5pZFRvSW5kZXhbZWRnZS5zb3VyY2VJZF07XG4gICAgICB2YXIgc291cmNlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tzb3VyY2VJeF07XG4gICAgICB2YXIgdGFyZ2V0SXggPSBsYXlvdXRJbmZvLmlkVG9JbmRleFtlZGdlLnRhcmdldElkXTtcbiAgICAgIHZhciB0YXJnZXQgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW3RhcmdldEl4XTsgLy8gR2V0IGRpcmVjdGlvbiBvZiBsaW5lIGNvbm5lY3RpbmcgYm90aCBub2RlIGNlbnRlcnNcblxuICAgICAgdmFyIGRpcmVjdGlvblggPSB0YXJnZXQucG9zaXRpb25YIC0gc291cmNlLnBvc2l0aW9uWDtcbiAgICAgIHZhciBkaXJlY3Rpb25ZID0gdGFyZ2V0LnBvc2l0aW9uWSAtIHNvdXJjZS5wb3NpdGlvblk7IC8vIElmIGJvdGggY2VudGVycyBhcmUgdGhlIHNhbWUsIGRvIG5vdGhpbmcuXG4gICAgICAvLyBBIHJhbmRvbSBmb3JjZSBoYXMgYWxyZWFkeSBiZWVuIGFwcGxpZWQgYXMgbm9kZSByZXB1bHNpb25cblxuICAgICAgaWYgKDAgPT09IGRpcmVjdGlvblggJiYgMCA9PT0gZGlyZWN0aW9uWSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8gR2V0IGNsaXBwaW5nIHBvaW50cyBmb3IgYm90aCBub2Rlc1xuXG5cbiAgICAgIHZhciBwb2ludDEgPSBmaW5kQ2xpcHBpbmdQb2ludChzb3VyY2UsIGRpcmVjdGlvblgsIGRpcmVjdGlvblkpO1xuICAgICAgdmFyIHBvaW50MiA9IGZpbmRDbGlwcGluZ1BvaW50KHRhcmdldCwgLTEgKiBkaXJlY3Rpb25YLCAtMSAqIGRpcmVjdGlvblkpO1xuICAgICAgdmFyIGx4ID0gcG9pbnQyLnggLSBwb2ludDEueDtcbiAgICAgIHZhciBseSA9IHBvaW50Mi55IC0gcG9pbnQxLnk7XG4gICAgICB2YXIgbCA9IE1hdGguc3FydChseCAqIGx4ICsgbHkgKiBseSk7XG4gICAgICB2YXIgZm9yY2UgPSBNYXRoLnBvdyhlZGdlLmlkZWFsTGVuZ3RoIC0gbCwgMikgLyBlZGdlLmVsYXN0aWNpdHk7XG5cbiAgICAgIGlmICgwICE9PSBsKSB7XG4gICAgICAgIHZhciBmb3JjZVggPSBmb3JjZSAqIGx4IC8gbDtcbiAgICAgICAgdmFyIGZvcmNlWSA9IGZvcmNlICogbHkgLyBsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGZvcmNlWCA9IDA7XG4gICAgICAgIHZhciBmb3JjZVkgPSAwO1xuICAgICAgfSAvLyBBZGQgdGhpcyBmb3JjZSB0byB0YXJnZXQgYW5kIHNvdXJjZSBub2Rlc1xuXG5cbiAgICAgIGlmICghc291cmNlLmlzTG9ja2VkKSB7XG4gICAgICAgIHNvdXJjZS5vZmZzZXRYICs9IGZvcmNlWDtcbiAgICAgICAgc291cmNlLm9mZnNldFkgKz0gZm9yY2VZO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRhcmdldC5pc0xvY2tlZCkge1xuICAgICAgICB0YXJnZXQub2Zmc2V0WCAtPSBmb3JjZVg7XG4gICAgICAgIHRhcmdldC5vZmZzZXRZIC09IGZvcmNlWTtcbiAgICAgIH0gLy8gdmFyIHMgPSAnRWRnZSBmb3JjZSBiZXR3ZWVuIG5vZGVzICcgKyBzb3VyY2UuaWQgKyAnIGFuZCAnICsgdGFyZ2V0LmlkO1xuICAgICAgLy8gcyArPSBcIlxcbkRpc3RhbmNlOiBcIiArIGwgKyBcIiBGb3JjZTogKFwiICsgZm9yY2VYICsgXCIsIFwiICsgZm9yY2VZICsgXCIpXCI7XG4gICAgICAvLyBsb2dEZWJ1ZyhzKTtcblxuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIEBicmllZiA6IENvbXB1dGVzIGdyYXZpdHkgZm9yY2VzIGZvciBhbGwgbm9kZXNcbiAgICovXG5cblxuICB2YXIgY2FsY3VsYXRlR3Jhdml0eUZvcmNlcyA9IGZ1bmN0aW9uIGNhbGN1bGF0ZUdyYXZpdHlGb3JjZXMobGF5b3V0SW5mbywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLmdyYXZpdHkgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZGlzdFRocmVzaG9sZCA9IDE7IC8vIHZhciBzID0gJ2NhbGN1bGF0ZUdyYXZpdHlGb3JjZXMnO1xuICAgIC8vIGxvZ0RlYnVnKHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLmdyYXBoU2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZ3JhcGggPSBsYXlvdXRJbmZvLmdyYXBoU2V0W2ldO1xuICAgICAgdmFyIG51bU5vZGVzID0gZ3JhcGgubGVuZ3RoOyAvLyBzID0gXCJTZXQ6IFwiICsgZ3JhcGgudG9TdHJpbmcoKTtcbiAgICAgIC8vIGxvZ0RlYnVnKHMpO1xuICAgICAgLy8gQ29tcHV0ZSBncmFwaCBjZW50ZXJcblxuICAgICAgaWYgKDAgPT09IGkpIHtcbiAgICAgICAgdmFyIGNlbnRlclggPSBsYXlvdXRJbmZvLmNsaWVudEhlaWdodCAvIDI7XG4gICAgICAgIHZhciBjZW50ZXJZID0gbGF5b3V0SW5mby5jbGllbnRXaWR0aCAvIDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBHZXQgUGFyZW50IG5vZGUgZm9yIHRoaXMgZ3JhcGgsIGFuZCB1c2UgaXRzIHBvc2l0aW9uIGFzIGNlbnRlclxuICAgICAgICB2YXIgdGVtcCA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbZ3JhcGhbMF1dXTtcbiAgICAgICAgdmFyIHBhcmVudCA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbdGVtcC5wYXJlbnRJZF1dO1xuICAgICAgICB2YXIgY2VudGVyWCA9IHBhcmVudC5wb3NpdGlvblg7XG4gICAgICAgIHZhciBjZW50ZXJZID0gcGFyZW50LnBvc2l0aW9uWTtcbiAgICAgIH0gLy8gcyA9IFwiQ2VudGVyIGZvdW5kIGF0OiBcIiArIGNlbnRlclggKyBcIiwgXCIgKyBjZW50ZXJZO1xuICAgICAgLy8gbG9nRGVidWcocyk7XG4gICAgICAvLyBBcHBseSBmb3JjZSB0byBhbGwgbm9kZXMgaW4gZ3JhcGhcblxuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG51bU5vZGVzOyBqKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W2dyYXBoW2pdXV07IC8vIHMgPSBcIk5vZGU6IFwiICsgbm9kZS5pZDtcblxuICAgICAgICBpZiAobm9kZS5pc0xvY2tlZCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGR4ID0gY2VudGVyWCAtIG5vZGUucG9zaXRpb25YO1xuICAgICAgICB2YXIgZHkgPSBjZW50ZXJZIC0gbm9kZS5wb3NpdGlvblk7XG4gICAgICAgIHZhciBkID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblxuICAgICAgICBpZiAoZCA+IGRpc3RUaHJlc2hvbGQpIHtcbiAgICAgICAgICB2YXIgZnggPSBvcHRpb25zLmdyYXZpdHkgKiBkeCAvIGQ7XG4gICAgICAgICAgdmFyIGZ5ID0gb3B0aW9ucy5ncmF2aXR5ICogZHkgLyBkO1xuICAgICAgICAgIG5vZGUub2Zmc2V0WCArPSBmeDtcbiAgICAgICAgICBub2RlLm9mZnNldFkgKz0gZnk7IC8vIHMgKz0gXCI6IEFwcGxpZWQgZm9yY2U6IFwiICsgZnggKyBcIiwgXCIgKyBmeTtcbiAgICAgICAgfSAvLyBsb2dEZWJ1ZyhzKTtcblxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIEBicmllZiAgICAgICAgICA6IFRoaXMgZnVuY3Rpb24gcHJvcGFnYXRlcyB0aGUgZXhpc3Rpbmcgb2Zmc2V0cyBmcm9tXG4gICAqICAgICAgICAgICAgICAgICAgIHBhcmVudCBub2RlcyB0byBpdHMgZGVzY2VuZGVudHMuXG4gICAqIEBhcmcgbGF5b3V0SW5mbyA6IGxheW91dEluZm8gT2JqZWN0XG4gICAqIEBhcmcgY3kgICAgICAgICA6IGN5dG9zY2FwZSBPYmplY3RcbiAgICogQGFyZyBvcHRpb25zICAgIDogTGF5b3V0IG9wdGlvbnNcbiAgICovXG5cblxuICB2YXIgcHJvcGFnYXRlRm9yY2VzID0gZnVuY3Rpb24gcHJvcGFnYXRlRm9yY2VzKGxheW91dEluZm8sIG9wdGlvbnMpIHtcbiAgICAvLyBJbmxpbmUgaW1wbGVtZW50YXRpb24gb2YgYSBxdWV1ZSwgdXNlZCBmb3IgdHJhdmVyc2luZyB0aGUgZ3JhcGggaW4gQkZTIG9yZGVyXG4gICAgdmFyIHF1ZXVlID0gW107XG4gICAgdmFyIHN0YXJ0ID0gMDsgLy8gUG9pbnRzIHRvIHRoZSBzdGFydCB0aGUgcXVldWVcblxuICAgIHZhciBlbmQgPSAtMTsgLy8gUG9pbnRzIHRvIHRoZSBlbmQgb2YgdGhlIHF1ZXVlXG4gICAgLy8gbG9nRGVidWcoJ3Byb3BhZ2F0ZUZvcmNlcycpO1xuICAgIC8vIFN0YXJ0IGJ5IHZpc2l0aW5nIHRoZSBub2RlcyBpbiB0aGUgcm9vdCBncmFwaFxuXG4gICAgcXVldWUucHVzaC5hcHBseShxdWV1ZSwgbGF5b3V0SW5mby5ncmFwaFNldFswXSk7XG4gICAgZW5kICs9IGxheW91dEluZm8uZ3JhcGhTZXRbMF0ubGVuZ3RoOyAvLyBUcmF2ZXJzZSB0aGUgZ3JhcGgsIGxldmVsIGJ5IGxldmVsLFxuXG4gICAgd2hpbGUgKHN0YXJ0IDw9IGVuZCkge1xuICAgICAgLy8gR2V0IHRoZSBub2RlIHRvIHZpc2l0IGFuZCByZW1vdmUgaXQgZnJvbSBxdWV1ZVxuICAgICAgdmFyIG5vZGVJZCA9IHF1ZXVlW3N0YXJ0KytdO1xuICAgICAgdmFyIG5vZGVJbmRleCA9IGxheW91dEluZm8uaWRUb0luZGV4W25vZGVJZF07XG4gICAgICB2YXIgbm9kZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbm9kZUluZGV4XTtcbiAgICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47IC8vIFdlIG9ubHkgbmVlZCB0byBwcm9jZXNzIHRoZSBub2RlIGlmIGl0J3MgY29tcG91bmRcblxuICAgICAgaWYgKDAgPCBjaGlsZHJlbi5sZW5ndGggJiYgIW5vZGUuaXNMb2NrZWQpIHtcbiAgICAgICAgdmFyIG9mZlggPSBub2RlLm9mZnNldFg7XG4gICAgICAgIHZhciBvZmZZID0gbm9kZS5vZmZzZXRZOyAvLyB2YXIgcyA9IFwiUHJvcGFnYXRpbmcgb2Zmc2V0IGZyb20gcGFyZW50IG5vZGUgOiBcIiArIG5vZGUuaWQgK1xuICAgICAgICAvLyAgIFwiLiBPZmZzZXRYOiBcIiArIG9mZlggKyBcIi4gT2Zmc2V0WTogXCIgKyBvZmZZO1xuICAgICAgICAvLyBzICs9IFwiXFxuIENoaWxkcmVuOiBcIiArIGNoaWxkcmVuLnRvU3RyaW5nKCk7XG4gICAgICAgIC8vIGxvZ0RlYnVnKHMpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgY2hpbGROb2RlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFtjaGlsZHJlbltpXV1dOyAvLyBQcm9wYWdhdGUgb2Zmc2V0XG5cbiAgICAgICAgICBjaGlsZE5vZGUub2Zmc2V0WCArPSBvZmZYO1xuICAgICAgICAgIGNoaWxkTm9kZS5vZmZzZXRZICs9IG9mZlk7IC8vIEFkZCBjaGlsZHJlbiB0byBxdWV1ZSB0byBiZSB2aXNpdGVkXG5cbiAgICAgICAgICBxdWV1ZVsrK2VuZF0gPSBjaGlsZHJlbltpXTtcbiAgICAgICAgfSAvLyBSZXNldCBwYXJlbnQgb2Zmc2V0c1xuXG5cbiAgICAgICAgbm9kZS5vZmZzZXRYID0gMDtcbiAgICAgICAgbm9kZS5vZmZzZXRZID0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBAYnJpZWYgOiBVcGRhdGVzIHRoZSBsYXlvdXQgbW9kZWwgcG9zaXRpb25zLCBiYXNlZCBvblxuICAgKiAgICAgICAgICB0aGUgYWNjdW11bGF0ZWQgZm9yY2VzXG4gICAqL1xuXG5cbiAgdmFyIHVwZGF0ZVBvc2l0aW9ucyA9IGZ1bmN0aW9uIHVwZGF0ZVBvc2l0aW9ucyhsYXlvdXRJbmZvLCBvcHRpb25zKSB7XG4gICAgLy8gdmFyIHMgPSAnVXBkYXRpbmcgcG9zaXRpb25zJztcbiAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICAvLyBSZXNldCBib3VuZGFyaWVzIGZvciBjb21wb3VuZCBub2Rlc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5ub2RlU2l6ZTsgaSsrKSB7XG4gICAgICB2YXIgbiA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbaV07XG5cbiAgICAgIGlmICgwIDwgbi5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgLy8gbG9nRGVidWcoXCJSZXNldHRpbmcgYm91bmRhcmllcyBvZiBjb21wb3VuZCBub2RlOiBcIiArIG4uaWQpO1xuICAgICAgICBuLm1heFggPSB1bmRlZmluZWQ7XG4gICAgICAgIG4ubWluWCA9IHVuZGVmaW5lZDtcbiAgICAgICAgbi5tYXhZID0gdW5kZWZpbmVkO1xuICAgICAgICBuLm1pblkgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLm5vZGVTaXplOyBpKyspIHtcbiAgICAgIHZhciBuID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tpXTtcblxuICAgICAgaWYgKDAgPCBuLmNoaWxkcmVuLmxlbmd0aCB8fCBuLmlzTG9ja2VkKSB7XG4gICAgICAgIC8vIE5vIG5lZWQgdG8gc2V0IGNvbXBvdW5kIG9yIGxvY2tlZCBub2RlIHBvc2l0aW9uXG4gICAgICAgIC8vIGxvZ0RlYnVnKFwiU2tpcHBpbmcgcG9zaXRpb24gdXBkYXRlIG9mIG5vZGU6IFwiICsgbi5pZCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvLyBzID0gXCJOb2RlOiBcIiArIG4uaWQgKyBcIiBQcmV2aW91cyBwb3NpdGlvbjogKFwiICtcbiAgICAgIC8vIG4ucG9zaXRpb25YICsgXCIsIFwiICsgbi5wb3NpdGlvblkgKyBcIikuXCI7XG4gICAgICAvLyBMaW1pdCBkaXNwbGFjZW1lbnQgaW4gb3JkZXIgdG8gaW1wcm92ZSBzdGFiaWxpdHlcblxuXG4gICAgICB2YXIgdGVtcEZvcmNlID0gbGltaXRGb3JjZShuLm9mZnNldFgsIG4ub2Zmc2V0WSwgbGF5b3V0SW5mby50ZW1wZXJhdHVyZSk7XG4gICAgICBuLnBvc2l0aW9uWCArPSB0ZW1wRm9yY2UueDtcbiAgICAgIG4ucG9zaXRpb25ZICs9IHRlbXBGb3JjZS55O1xuICAgICAgbi5vZmZzZXRYID0gMDtcbiAgICAgIG4ub2Zmc2V0WSA9IDA7XG4gICAgICBuLm1pblggPSBuLnBvc2l0aW9uWCAtIG4ud2lkdGg7XG4gICAgICBuLm1heFggPSBuLnBvc2l0aW9uWCArIG4ud2lkdGg7XG4gICAgICBuLm1pblkgPSBuLnBvc2l0aW9uWSAtIG4uaGVpZ2h0O1xuICAgICAgbi5tYXhZID0gbi5wb3NpdGlvblkgKyBuLmhlaWdodDsgLy8gcyArPSBcIiBOZXcgUG9zaXRpb246IChcIiArIG4ucG9zaXRpb25YICsgXCIsIFwiICsgbi5wb3NpdGlvblkgKyBcIikuXCI7XG4gICAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICAgIC8vIFVwZGF0ZSBhbmNlc3RyeSBib3VkYXJpZXNcblxuICAgICAgdXBkYXRlQW5jZXN0cnlCb3VuZGFyaWVzKG4sIGxheW91dEluZm8pO1xuICAgIH0gLy8gVXBkYXRlIHNpemUsIHBvc2l0aW9uIG9mIGNvbXB1bmQgbm9kZXNcblxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLm5vZGVTaXplOyBpKyspIHtcbiAgICAgIHZhciBuID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tpXTtcblxuICAgICAgaWYgKDAgPCBuLmNoaWxkcmVuLmxlbmd0aCAmJiAhbi5pc0xvY2tlZCkge1xuICAgICAgICBuLnBvc2l0aW9uWCA9IChuLm1heFggKyBuLm1pblgpIC8gMjtcbiAgICAgICAgbi5wb3NpdGlvblkgPSAobi5tYXhZICsgbi5taW5ZKSAvIDI7XG4gICAgICAgIG4ud2lkdGggPSBuLm1heFggLSBuLm1pblg7XG4gICAgICAgIG4uaGVpZ2h0ID0gbi5tYXhZIC0gbi5taW5ZOyAvLyBzID0gXCJVcGRhdGluZyBwb3NpdGlvbiwgc2l6ZSBvZiBjb21wb3VuZCBub2RlIFwiICsgbi5pZDtcbiAgICAgICAgLy8gcyArPSBcIlxcblBvc2l0aW9uWDogXCIgKyBuLnBvc2l0aW9uWCArIFwiLCBQb3NpdGlvblk6IFwiICsgbi5wb3NpdGlvblk7XG4gICAgICAgIC8vIHMgKz0gXCJcXG5XaWR0aDogXCIgKyBuLndpZHRoICsgXCIsIEhlaWdodDogXCIgKyBuLmhlaWdodDtcbiAgICAgICAgLy8gbG9nRGVidWcocyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogQGJyaWVmIDogTGltaXRzIGEgZm9yY2UgKGZvcmNlWCwgZm9yY2VZKSB0byBiZSBub3RcbiAgICogICAgICAgICAgZ3JlYXRlciAoaW4gbW9kdWxvKSB0aGFuIG1heC5cbiAgIDggICAgICAgICAgUHJlc2VydmVzIGZvcmNlIGRpcmVjdGlvbi5cbiAgICAqL1xuXG5cbiAgdmFyIGxpbWl0Rm9yY2UgPSBmdW5jdGlvbiBsaW1pdEZvcmNlKGZvcmNlWCwgZm9yY2VZLCBtYXgpIHtcbiAgICAvLyB2YXIgcyA9IFwiTGltaXRpbmcgZm9yY2U6IChcIiArIGZvcmNlWCArIFwiLCBcIiArIGZvcmNlWSArIFwiKS4gTWF4OiBcIiArIG1heDtcbiAgICB2YXIgZm9yY2UgPSBNYXRoLnNxcnQoZm9yY2VYICogZm9yY2VYICsgZm9yY2VZICogZm9yY2VZKTtcblxuICAgIGlmIChmb3JjZSA+IG1heCkge1xuICAgICAgdmFyIHJlcyA9IHtcbiAgICAgICAgeDogbWF4ICogZm9yY2VYIC8gZm9yY2UsXG4gICAgICAgIHk6IG1heCAqIGZvcmNlWSAvIGZvcmNlXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcmVzID0ge1xuICAgICAgICB4OiBmb3JjZVgsXG4gICAgICAgIHk6IGZvcmNlWVxuICAgICAgfTtcbiAgICB9IC8vIHMgKz0gXCIuXFxuUmVzdWx0OiAoXCIgKyByZXMueCArIFwiLCBcIiArIHJlcy55ICsgXCIpXCI7XG4gICAgLy8gbG9nRGVidWcocyk7XG5cblxuICAgIHJldHVybiByZXM7XG4gIH07XG4gIC8qKlxuICAgKiBAYnJpZWYgOiBGdW5jdGlvbiB1c2VkIGZvciBrZWVwaW5nIHRyYWNrIG9mIGNvbXBvdW5kIG5vZGVcbiAgICogICAgICAgICAgc2l6ZXMsIHNpbmNlIHRoZXkgc2hvdWxkIGJvdW5kIGFsbCB0aGVpciBzdWJub2Rlcy5cbiAgICovXG5cblxuICB2YXIgdXBkYXRlQW5jZXN0cnlCb3VuZGFyaWVzID0gZnVuY3Rpb24gdXBkYXRlQW5jZXN0cnlCb3VuZGFyaWVzKG5vZGUsIGxheW91dEluZm8pIHtcbiAgICAvLyB2YXIgcyA9IFwiUHJvcGFnYXRpbmcgbmV3IHBvc2l0aW9uL3NpemUgb2Ygbm9kZSBcIiArIG5vZGUuaWQ7XG4gICAgdmFyIHBhcmVudElkID0gbm9kZS5wYXJlbnRJZDtcblxuICAgIGlmIChudWxsID09IHBhcmVudElkKSB7XG4gICAgICAvLyBJZiB0aGVyZSdzIG5vIHBhcmVudCwgd2UgYXJlIGRvbmVcbiAgICAgIC8vIHMgKz0gXCIuIE5vIHBhcmVudCBub2RlLlwiO1xuICAgICAgLy8gbG9nRGVidWcocyk7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBHZXQgUGFyZW50IE5vZGVcblxuXG4gICAgdmFyIHAgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W3BhcmVudElkXV07XG4gICAgdmFyIGZsYWcgPSBmYWxzZTsgLy8gTWF4WFxuXG4gICAgaWYgKG51bGwgPT0gcC5tYXhYIHx8IG5vZGUubWF4WCArIHAucGFkUmlnaHQgPiBwLm1heFgpIHtcbiAgICAgIHAubWF4WCA9IG5vZGUubWF4WCArIHAucGFkUmlnaHQ7XG4gICAgICBmbGFnID0gdHJ1ZTsgLy8gcyArPSBcIlxcbk5ldyBtYXhYIGZvciBwYXJlbnQgbm9kZSBcIiArIHAuaWQgKyBcIjogXCIgKyBwLm1heFg7XG4gICAgfSAvLyBNaW5YXG5cblxuICAgIGlmIChudWxsID09IHAubWluWCB8fCBub2RlLm1pblggLSBwLnBhZExlZnQgPCBwLm1pblgpIHtcbiAgICAgIHAubWluWCA9IG5vZGUubWluWCAtIHAucGFkTGVmdDtcbiAgICAgIGZsYWcgPSB0cnVlOyAvLyBzICs9IFwiXFxuTmV3IG1pblggZm9yIHBhcmVudCBub2RlIFwiICsgcC5pZCArIFwiOiBcIiArIHAubWluWDtcbiAgICB9IC8vIE1heFlcblxuXG4gICAgaWYgKG51bGwgPT0gcC5tYXhZIHx8IG5vZGUubWF4WSArIHAucGFkQm90dG9tID4gcC5tYXhZKSB7XG4gICAgICBwLm1heFkgPSBub2RlLm1heFkgKyBwLnBhZEJvdHRvbTtcbiAgICAgIGZsYWcgPSB0cnVlOyAvLyBzICs9IFwiXFxuTmV3IG1heFkgZm9yIHBhcmVudCBub2RlIFwiICsgcC5pZCArIFwiOiBcIiArIHAubWF4WTtcbiAgICB9IC8vIE1pbllcblxuXG4gICAgaWYgKG51bGwgPT0gcC5taW5ZIHx8IG5vZGUubWluWSAtIHAucGFkVG9wIDwgcC5taW5ZKSB7XG4gICAgICBwLm1pblkgPSBub2RlLm1pblkgLSBwLnBhZFRvcDtcbiAgICAgIGZsYWcgPSB0cnVlOyAvLyBzICs9IFwiXFxuTmV3IG1pblkgZm9yIHBhcmVudCBub2RlIFwiICsgcC5pZCArIFwiOiBcIiArIHAubWluWTtcbiAgICB9IC8vIElmIHVwZGF0ZWQgYm91bmRhcmllcywgcHJvcGFnYXRlIGNoYW5nZXMgdXB3YXJkXG5cblxuICAgIGlmIChmbGFnKSB7XG4gICAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICAgIHJldHVybiB1cGRhdGVBbmNlc3RyeUJvdW5kYXJpZXMocCwgbGF5b3V0SW5mbyk7XG4gICAgfSAvLyBzICs9IFwiLiBObyBjaGFuZ2VzIGluIGJvdW5kYXJpZXMvcG9zaXRpb24gb2YgcGFyZW50IG5vZGUgXCIgKyBwLmlkO1xuICAgIC8vIGxvZ0RlYnVnKHMpO1xuXG5cbiAgICByZXR1cm47XG4gIH07XG5cbiAgdmFyIHNlcGFyYXRlQ29tcG9uZW50cyA9IGZ1bmN0aW9uIHNlcGFyYXRlQ29tcG9uZW50cyhsYXlvdXRJbmZvLCBvcHRpb25zKSB7XG4gICAgdmFyIG5vZGVzID0gbGF5b3V0SW5mby5sYXlvdXROb2RlcztcbiAgICB2YXIgY29tcG9uZW50cyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgIHZhciBjaWQgPSBub2RlLmNtcHRJZDtcbiAgICAgIHZhciBjb21wb25lbnQgPSBjb21wb25lbnRzW2NpZF0gPSBjb21wb25lbnRzW2NpZF0gfHwgW107XG4gICAgICBjb21wb25lbnQucHVzaChub2RlKTtcbiAgICB9XG5cbiAgICB2YXIgdG90YWxBID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tcG9uZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGMgPSBjb21wb25lbnRzW2ldO1xuXG4gICAgICBpZiAoIWMpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGMueDEgPSBJbmZpbml0eTtcbiAgICAgIGMueDIgPSAtSW5maW5pdHk7XG4gICAgICBjLnkxID0gSW5maW5pdHk7XG4gICAgICBjLnkyID0gLUluZmluaXR5O1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIG4gPSBjW2pdO1xuICAgICAgICBjLngxID0gTWF0aC5taW4oYy54MSwgbi5wb3NpdGlvblggLSBuLndpZHRoIC8gMik7XG4gICAgICAgIGMueDIgPSBNYXRoLm1heChjLngyLCBuLnBvc2l0aW9uWCArIG4ud2lkdGggLyAyKTtcbiAgICAgICAgYy55MSA9IE1hdGgubWluKGMueTEsIG4ucG9zaXRpb25ZIC0gbi5oZWlnaHQgLyAyKTtcbiAgICAgICAgYy55MiA9IE1hdGgubWF4KGMueTIsIG4ucG9zaXRpb25ZICsgbi5oZWlnaHQgLyAyKTtcbiAgICAgIH1cblxuICAgICAgYy53ID0gYy54MiAtIGMueDE7XG4gICAgICBjLmggPSBjLnkyIC0gYy55MTtcbiAgICAgIHRvdGFsQSArPSBjLncgKiBjLmg7XG4gICAgfVxuXG4gICAgY29tcG9uZW50cy5zb3J0KGZ1bmN0aW9uIChjMSwgYzIpIHtcbiAgICAgIHJldHVybiBjMi53ICogYzIuaCAtIGMxLncgKiBjMS5oO1xuICAgIH0pO1xuICAgIHZhciB4ID0gMDtcbiAgICB2YXIgeSA9IDA7XG4gICAgdmFyIHVzZWRXID0gMDtcbiAgICB2YXIgcm93SCA9IDA7XG4gICAgdmFyIG1heFJvd1cgPSBNYXRoLnNxcnQodG90YWxBKSAqIGxheW91dEluZm8uY2xpZW50V2lkdGggLyBsYXlvdXRJbmZvLmNsaWVudEhlaWdodDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tcG9uZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGMgPSBjb21wb25lbnRzW2ldO1xuXG4gICAgICBpZiAoIWMpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgbiA9IGNbal07XG5cbiAgICAgICAgaWYgKCFuLmlzTG9ja2VkKSB7XG4gICAgICAgICAgbi5wb3NpdGlvblggKz0geCAtIGMueDE7XG4gICAgICAgICAgbi5wb3NpdGlvblkgKz0geSAtIGMueTE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgeCArPSBjLncgKyBvcHRpb25zLmNvbXBvbmVudFNwYWNpbmc7XG4gICAgICB1c2VkVyArPSBjLncgKyBvcHRpb25zLmNvbXBvbmVudFNwYWNpbmc7XG4gICAgICByb3dIID0gTWF0aC5tYXgocm93SCwgYy5oKTtcblxuICAgICAgaWYgKHVzZWRXID4gbWF4Um93Vykge1xuICAgICAgICB5ICs9IHJvd0ggKyBvcHRpb25zLmNvbXBvbmVudFNwYWNpbmc7XG4gICAgICAgIHggPSAwO1xuICAgICAgICB1c2VkVyA9IDA7XG4gICAgICAgIHJvd0ggPSAwO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgZGVmYXVsdHMkMyA9IHtcbiAgICBmaXQ6IHRydWUsXG4gICAgLy8gd2hldGhlciB0byBmaXQgdGhlIHZpZXdwb3J0IHRvIHRoZSBncmFwaFxuICAgIHBhZGRpbmc6IDMwLFxuICAgIC8vIHBhZGRpbmcgdXNlZCBvbiBmaXRcbiAgICBib3VuZGluZ0JveDogdW5kZWZpbmVkLFxuICAgIC8vIGNvbnN0cmFpbiBsYXlvdXQgYm91bmRzOyB7IHgxLCB5MSwgeDIsIHkyIH0gb3IgeyB4MSwgeTEsIHcsIGggfVxuICAgIGF2b2lkT3ZlcmxhcDogdHJ1ZSxcbiAgICAvLyBwcmV2ZW50cyBub2RlIG92ZXJsYXAsIG1heSBvdmVyZmxvdyBib3VuZGluZ0JveCBpZiBub3QgZW5vdWdoIHNwYWNlXG4gICAgYXZvaWRPdmVybGFwUGFkZGluZzogMTAsXG4gICAgLy8gZXh0cmEgc3BhY2luZyBhcm91bmQgbm9kZXMgd2hlbiBhdm9pZE92ZXJsYXA6IHRydWVcbiAgICBub2RlRGltZW5zaW9uc0luY2x1ZGVMYWJlbHM6IGZhbHNlLFxuICAgIC8vIEV4Y2x1ZGVzIHRoZSBsYWJlbCB3aGVuIGNhbGN1bGF0aW5nIG5vZGUgYm91bmRpbmcgYm94ZXMgZm9yIHRoZSBsYXlvdXQgYWxnb3JpdGhtXG4gICAgc3BhY2luZ0ZhY3RvcjogdW5kZWZpbmVkLFxuICAgIC8vIEFwcGxpZXMgYSBtdWx0aXBsaWNhdGl2ZSBmYWN0b3IgKD4wKSB0byBleHBhbmQgb3IgY29tcHJlc3MgdGhlIG92ZXJhbGwgYXJlYSB0aGF0IHRoZSBub2RlcyB0YWtlIHVwXG4gICAgY29uZGVuc2U6IGZhbHNlLFxuICAgIC8vIHVzZXMgYWxsIGF2YWlsYWJsZSBzcGFjZSBvbiBmYWxzZSwgdXNlcyBtaW5pbWFsIHNwYWNlIG9uIHRydWVcbiAgICByb3dzOiB1bmRlZmluZWQsXG4gICAgLy8gZm9yY2UgbnVtIG9mIHJvd3MgaW4gdGhlIGdyaWRcbiAgICBjb2xzOiB1bmRlZmluZWQsXG4gICAgLy8gZm9yY2UgbnVtIG9mIGNvbHVtbnMgaW4gdGhlIGdyaWRcbiAgICBwb3NpdGlvbjogZnVuY3Rpb24gcG9zaXRpb24obm9kZSkge30sXG4gICAgLy8gcmV0dXJucyB7IHJvdywgY29sIH0gZm9yIGVsZW1lbnRcbiAgICBzb3J0OiB1bmRlZmluZWQsXG4gICAgLy8gYSBzb3J0aW5nIGZ1bmN0aW9uIHRvIG9yZGVyIHRoZSBub2RlczsgZS5nLiBmdW5jdGlvbihhLCBiKXsgcmV0dXJuIGEuZGF0YSgnd2VpZ2h0JykgLSBiLmRhdGEoJ3dlaWdodCcpIH1cbiAgICBhbmltYXRlOiBmYWxzZSxcbiAgICAvLyB3aGV0aGVyIHRvIHRyYW5zaXRpb24gdGhlIG5vZGUgcG9zaXRpb25zXG4gICAgYW5pbWF0aW9uRHVyYXRpb246IDUwMCxcbiAgICAvLyBkdXJhdGlvbiBvZiBhbmltYXRpb24gaW4gbXMgaWYgZW5hYmxlZFxuICAgIGFuaW1hdGlvbkVhc2luZzogdW5kZWZpbmVkLFxuICAgIC8vIGVhc2luZyBvZiBhbmltYXRpb24gaWYgZW5hYmxlZFxuICAgIGFuaW1hdGVGaWx0ZXI6IGZ1bmN0aW9uIGFuaW1hdGVGaWx0ZXIobm9kZSwgaSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICAvLyBhIGZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBub2RlIHNob3VsZCBiZSBhbmltYXRlZC4gIEFsbCBub2RlcyBhbmltYXRlZCBieSBkZWZhdWx0IG9uIGFuaW1hdGUgZW5hYmxlZC4gIE5vbi1hbmltYXRlZCBub2RlcyBhcmUgcG9zaXRpb25lZCBpbW1lZGlhdGVseSB3aGVuIHRoZSBsYXlvdXQgc3RhcnRzXG4gICAgcmVhZHk6IHVuZGVmaW5lZCxcbiAgICAvLyBjYWxsYmFjayBvbiBsYXlvdXRyZWFkeVxuICAgIHN0b3A6IHVuZGVmaW5lZCxcbiAgICAvLyBjYWxsYmFjayBvbiBsYXlvdXRzdG9wXG4gICAgdHJhbnNmb3JtOiBmdW5jdGlvbiB0cmFuc2Zvcm0obm9kZSwgcG9zaXRpb24pIHtcbiAgICAgIHJldHVybiBwb3NpdGlvbjtcbiAgICB9IC8vIHRyYW5zZm9ybSBhIGdpdmVuIG5vZGUgcG9zaXRpb24uIFVzZWZ1bCBmb3IgY2hhbmdpbmcgZmxvdyBkaXJlY3Rpb24gaW4gZGlzY3JldGUgbGF5b3V0cyBcblxuICB9O1xuXG4gIGZ1bmN0aW9uIEdyaWRMYXlvdXQob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IGV4dGVuZCh7fSwgZGVmYXVsdHMkMywgb3B0aW9ucyk7XG4gIH1cblxuICBHcmlkTGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBhcmFtcyA9IHRoaXMub3B0aW9ucztcbiAgICB2YXIgb3B0aW9ucyA9IHBhcmFtcztcbiAgICB2YXIgY3kgPSBwYXJhbXMuY3k7XG4gICAgdmFyIGVsZXMgPSBvcHRpb25zLmVsZXM7XG4gICAgdmFyIG5vZGVzID0gZWxlcy5ub2RlcygpLm5vdCgnOnBhcmVudCcpO1xuXG4gICAgaWYgKG9wdGlvbnMuc29ydCkge1xuICAgICAgbm9kZXMgPSBub2Rlcy5zb3J0KG9wdGlvbnMuc29ydCk7XG4gICAgfVxuXG4gICAgdmFyIGJiID0gbWFrZUJvdW5kaW5nQm94KG9wdGlvbnMuYm91bmRpbmdCb3ggPyBvcHRpb25zLmJvdW5kaW5nQm94IDoge1xuICAgICAgeDE6IDAsXG4gICAgICB5MTogMCxcbiAgICAgIHc6IGN5LndpZHRoKCksXG4gICAgICBoOiBjeS5oZWlnaHQoKVxuICAgIH0pO1xuXG4gICAgaWYgKGJiLmggPT09IDAgfHwgYmIudyA9PT0gMCkge1xuICAgICAgZWxlcy5ub2RlcygpLmxheW91dFBvc2l0aW9ucyh0aGlzLCBvcHRpb25zLCBmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogYmIueDEsXG4gICAgICAgICAgeTogYmIueTFcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB3aWR0aC9oZWlnaHQgKiBzcGxpdHNeMiA9IGNlbGxzIHdoZXJlIHNwbGl0cyBpcyBudW1iZXIgb2YgdGltZXMgdG8gc3BsaXQgd2lkdGhcbiAgICAgIHZhciBjZWxscyA9IG5vZGVzLnNpemUoKTtcbiAgICAgIHZhciBzcGxpdHMgPSBNYXRoLnNxcnQoY2VsbHMgKiBiYi5oIC8gYmIudyk7XG4gICAgICB2YXIgcm93cyA9IE1hdGgucm91bmQoc3BsaXRzKTtcbiAgICAgIHZhciBjb2xzID0gTWF0aC5yb3VuZChiYi53IC8gYmIuaCAqIHNwbGl0cyk7XG5cbiAgICAgIHZhciBzbWFsbCA9IGZ1bmN0aW9uIHNtYWxsKHZhbCkge1xuICAgICAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gTWF0aC5taW4ocm93cywgY29scyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG1pbiA9IE1hdGgubWluKHJvd3MsIGNvbHMpO1xuXG4gICAgICAgICAgaWYgKG1pbiA9PSByb3dzKSB7XG4gICAgICAgICAgICByb3dzID0gdmFsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2xzID0gdmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdmFyIGxhcmdlID0gZnVuY3Rpb24gbGFyZ2UodmFsKSB7XG4gICAgICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBNYXRoLm1heChyb3dzLCBjb2xzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbWF4ID0gTWF0aC5tYXgocm93cywgY29scyk7XG5cbiAgICAgICAgICBpZiAobWF4ID09IHJvd3MpIHtcbiAgICAgICAgICAgIHJvd3MgPSB2YWw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbHMgPSB2YWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgb1Jvd3MgPSBvcHRpb25zLnJvd3M7XG4gICAgICB2YXIgb0NvbHMgPSBvcHRpb25zLmNvbHMgIT0gbnVsbCA/IG9wdGlvbnMuY29scyA6IG9wdGlvbnMuY29sdW1uczsgLy8gaWYgcm93cyBvciBjb2x1bW5zIHdlcmUgc2V0IGluIG9wdGlvbnMsIHVzZSB0aG9zZSB2YWx1ZXNcblxuICAgICAgaWYgKG9Sb3dzICE9IG51bGwgJiYgb0NvbHMgIT0gbnVsbCkge1xuICAgICAgICByb3dzID0gb1Jvd3M7XG4gICAgICAgIGNvbHMgPSBvQ29scztcbiAgICAgIH0gZWxzZSBpZiAob1Jvd3MgIT0gbnVsbCAmJiBvQ29scyA9PSBudWxsKSB7XG4gICAgICAgIHJvd3MgPSBvUm93cztcbiAgICAgICAgY29scyA9IE1hdGguY2VpbChjZWxscyAvIHJvd3MpO1xuICAgICAgfSBlbHNlIGlmIChvUm93cyA9PSBudWxsICYmIG9Db2xzICE9IG51bGwpIHtcbiAgICAgICAgY29scyA9IG9Db2xzO1xuICAgICAgICByb3dzID0gTWF0aC5jZWlsKGNlbGxzIC8gY29scyk7XG4gICAgICB9IC8vIG90aGVyd2lzZSB1c2UgdGhlIGF1dG9tYXRpYyB2YWx1ZXMgYW5kIGFkanVzdCBhY2NvcmRpbmdseVxuICAgICAgLy8gaWYgcm91bmRpbmcgd2FzIHVwLCBzZWUgaWYgd2UgY2FuIHJlZHVjZSByb3dzIG9yIGNvbHVtbnNcbiAgICAgIGVsc2UgaWYgKGNvbHMgKiByb3dzID4gY2VsbHMpIHtcbiAgICAgICAgdmFyIHNtID0gc21hbGwoKTtcbiAgICAgICAgdmFyIGxnID0gbGFyZ2UoKTsgLy8gcmVkdWNpbmcgdGhlIHNtYWxsIHNpZGUgdGFrZXMgYXdheSB0aGUgbW9zdCBjZWxscywgc28gdHJ5IGl0IGZpcnN0XG5cbiAgICAgICAgaWYgKChzbSAtIDEpICogbGcgPj0gY2VsbHMpIHtcbiAgICAgICAgICBzbWFsbChzbSAtIDEpO1xuICAgICAgICB9IGVsc2UgaWYgKChsZyAtIDEpICogc20gPj0gY2VsbHMpIHtcbiAgICAgICAgICBsYXJnZShsZyAtIDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZiByb3VuZGluZyB3YXMgdG9vIGxvdywgYWRkIHJvd3Mgb3IgY29sdW1uc1xuICAgICAgICB3aGlsZSAoY29scyAqIHJvd3MgPCBjZWxscykge1xuICAgICAgICAgIHZhciBfc20gPSBzbWFsbCgpO1xuXG4gICAgICAgICAgdmFyIF9sZyA9IGxhcmdlKCk7IC8vIHRyeSB0byBhZGQgdG8gbGFyZ2VyIHNpZGUgZmlyc3QgKGFkZHMgbGVzcyBpbiBtdWx0aXBsaWNhdGlvbilcblxuXG4gICAgICAgICAgaWYgKChfbGcgKyAxKSAqIF9zbSA+PSBjZWxscykge1xuICAgICAgICAgICAgbGFyZ2UoX2xnICsgMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNtYWxsKF9zbSArIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgY2VsbFdpZHRoID0gYmIudyAvIGNvbHM7XG4gICAgICB2YXIgY2VsbEhlaWdodCA9IGJiLmggLyByb3dzO1xuXG4gICAgICBpZiAob3B0aW9ucy5jb25kZW5zZSkge1xuICAgICAgICBjZWxsV2lkdGggPSAwO1xuICAgICAgICBjZWxsSGVpZ2h0ID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuYXZvaWRPdmVybGFwKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgIHZhciBwb3MgPSBub2RlLl9wcml2YXRlLnBvc2l0aW9uO1xuXG4gICAgICAgICAgaWYgKHBvcy54ID09IG51bGwgfHwgcG9zLnkgPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gZm9yIGJiXG4gICAgICAgICAgICBwb3MueCA9IDA7XG4gICAgICAgICAgICBwb3MueSA9IDA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG5iYiA9IG5vZGUubGF5b3V0RGltZW5zaW9ucyhvcHRpb25zKTtcbiAgICAgICAgICB2YXIgcCA9IG9wdGlvbnMuYXZvaWRPdmVybGFwUGFkZGluZztcbiAgICAgICAgICB2YXIgdyA9IG5iYi53ICsgcDtcbiAgICAgICAgICB2YXIgaCA9IG5iYi5oICsgcDtcbiAgICAgICAgICBjZWxsV2lkdGggPSBNYXRoLm1heChjZWxsV2lkdGgsIHcpO1xuICAgICAgICAgIGNlbGxIZWlnaHQgPSBNYXRoLm1heChjZWxsSGVpZ2h0LCBoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgY2VsbFVzZWQgPSB7fTsgLy8gZS5nLiAnYy0wLTInID0+IHRydWVcblxuICAgICAgdmFyIHVzZWQgPSBmdW5jdGlvbiB1c2VkKHJvdywgY29sKSB7XG4gICAgICAgIHJldHVybiBjZWxsVXNlZFsnYy0nICsgcm93ICsgJy0nICsgY29sXSA/IHRydWUgOiBmYWxzZTtcbiAgICAgIH07XG5cbiAgICAgIHZhciB1c2UgPSBmdW5jdGlvbiB1c2Uocm93LCBjb2wpIHtcbiAgICAgICAgY2VsbFVzZWRbJ2MtJyArIHJvdyArICctJyArIGNvbF0gPSB0cnVlO1xuICAgICAgfTsgLy8gdG8ga2VlcCB0cmFjayBvZiBjdXJyZW50IGNlbGwgcG9zaXRpb25cblxuXG4gICAgICB2YXIgcm93ID0gMDtcbiAgICAgIHZhciBjb2wgPSAwO1xuXG4gICAgICB2YXIgbW92ZVRvTmV4dENlbGwgPSBmdW5jdGlvbiBtb3ZlVG9OZXh0Q2VsbCgpIHtcbiAgICAgICAgY29sKys7XG5cbiAgICAgICAgaWYgKGNvbCA+PSBjb2xzKSB7XG4gICAgICAgICAgY29sID0gMDtcbiAgICAgICAgICByb3crKztcbiAgICAgICAgfVxuICAgICAgfTsgLy8gZ2V0IGEgY2FjaGUgb2YgYWxsIHRoZSBtYW51YWwgcG9zaXRpb25zXG5cblxuICAgICAgdmFyIGlkMm1hblBvcyA9IHt9O1xuXG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbm9kZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBfbm9kZSA9IG5vZGVzW19pXTtcbiAgICAgICAgdmFyIHJjUG9zID0gb3B0aW9ucy5wb3NpdGlvbihfbm9kZSk7XG5cbiAgICAgICAgaWYgKHJjUG9zICYmIChyY1Bvcy5yb3cgIT09IHVuZGVmaW5lZCB8fCByY1Bvcy5jb2wgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAvLyBtdXN0IGhhdmUgYXQgbGVhc3Qgcm93IG9yIGNvbCBkZWYnZFxuICAgICAgICAgIHZhciBfcG9zID0ge1xuICAgICAgICAgICAgcm93OiByY1Bvcy5yb3csXG4gICAgICAgICAgICBjb2w6IHJjUG9zLmNvbFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAoX3Bvcy5jb2wgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gZmluZCB1bnVzZWQgY29sXG4gICAgICAgICAgICBfcG9zLmNvbCA9IDA7XG5cbiAgICAgICAgICAgIHdoaWxlICh1c2VkKF9wb3Mucm93LCBfcG9zLmNvbCkpIHtcbiAgICAgICAgICAgICAgX3Bvcy5jb2wrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKF9wb3Mucm93ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIGZpbmQgdW51c2VkIHJvd1xuICAgICAgICAgICAgX3Bvcy5yb3cgPSAwO1xuXG4gICAgICAgICAgICB3aGlsZSAodXNlZChfcG9zLnJvdywgX3Bvcy5jb2wpKSB7XG4gICAgICAgICAgICAgIF9wb3Mucm93Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWQybWFuUG9zW19ub2RlLmlkKCldID0gX3BvcztcbiAgICAgICAgICB1c2UoX3Bvcy5yb3csIF9wb3MuY29sKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZ2V0UG9zID0gZnVuY3Rpb24gZ2V0UG9zKGVsZW1lbnQsIGkpIHtcbiAgICAgICAgdmFyIHgsIHk7XG5cbiAgICAgICAgaWYgKGVsZW1lbnQubG9ja2VkKCkgfHwgZWxlbWVudC5pc1BhcmVudCgpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IC8vIHNlZSBpZiB3ZSBoYXZlIGEgbWFudWFsIHBvc2l0aW9uIHNldFxuXG5cbiAgICAgICAgdmFyIHJjUG9zID0gaWQybWFuUG9zW2VsZW1lbnQuaWQoKV07XG5cbiAgICAgICAgaWYgKHJjUG9zKSB7XG4gICAgICAgICAgeCA9IHJjUG9zLmNvbCAqIGNlbGxXaWR0aCArIGNlbGxXaWR0aCAvIDIgKyBiYi54MTtcbiAgICAgICAgICB5ID0gcmNQb3Mucm93ICogY2VsbEhlaWdodCArIGNlbGxIZWlnaHQgLyAyICsgYmIueTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gb3RoZXJ3aXNlIHNldCBhdXRvbWF0aWNhbGx5XG4gICAgICAgICAgd2hpbGUgKHVzZWQocm93LCBjb2wpKSB7XG4gICAgICAgICAgICBtb3ZlVG9OZXh0Q2VsbCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHggPSBjb2wgKiBjZWxsV2lkdGggKyBjZWxsV2lkdGggLyAyICsgYmIueDE7XG4gICAgICAgICAgeSA9IHJvdyAqIGNlbGxIZWlnaHQgKyBjZWxsSGVpZ2h0IC8gMiArIGJiLnkxO1xuICAgICAgICAgIHVzZShyb3csIGNvbCk7XG4gICAgICAgICAgbW92ZVRvTmV4dENlbGwoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogeCxcbiAgICAgICAgICB5OiB5XG4gICAgICAgIH07XG4gICAgICB9O1xuXG4gICAgICBub2Rlcy5sYXlvdXRQb3NpdGlvbnModGhpcywgb3B0aW9ucywgZ2V0UG9zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfTtcblxuICB2YXIgZGVmYXVsdHMkMiA9IHtcbiAgICByZWFkeTogZnVuY3Rpb24gcmVhZHkoKSB7fSxcbiAgICAvLyBvbiBsYXlvdXRyZWFkeVxuICAgIHN0b3A6IGZ1bmN0aW9uIHN0b3AoKSB7fSAvLyBvbiBsYXlvdXRzdG9wXG5cbiAgfTsgLy8gY29uc3RydWN0b3JcbiAgLy8gb3B0aW9ucyA6IG9iamVjdCBjb250YWluaW5nIGxheW91dCBvcHRpb25zXG5cbiAgZnVuY3Rpb24gTnVsbExheW91dChvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gZXh0ZW5kKHt9LCBkZWZhdWx0cyQyLCBvcHRpb25zKTtcbiAgfSAvLyBydW5zIHRoZSBsYXlvdXRcblxuXG4gIE51bGxMYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICB2YXIgZWxlcyA9IG9wdGlvbnMuZWxlczsgLy8gZWxlbWVudHMgdG8gY29uc2lkZXIgaW4gdGhlIGxheW91dFxuXG4gICAgdmFyIGxheW91dCA9IHRoaXM7IC8vIGN5IGlzIGF1dG9tYXRpY2FsbHkgcG9wdWxhdGVkIGZvciB1cyBpbiB0aGUgY29uc3RydWN0b3JcbiAgICAvLyAoZGlzYWJsZSBlc2xpbnQgZm9yIG5leHQgbGluZSBhcyB0aGlzIHNlcnZlcyBhcyBleGFtcGxlIGxheW91dCBjb2RlIHRvIGV4dGVybmFsIGRldmVsb3BlcnMpXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgICBvcHRpb25zLmN5O1xuICAgIGxheW91dC5lbWl0KCdsYXlvdXRzdGFydCcpOyAvLyBwdXRzIGFsbCBub2RlcyBhdCAoMCwgMClcbiAgICAvLyBuLmIuIG1vc3QgbGF5b3V0cyB3b3VsZCB1c2UgbGF5b3V0UG9zaXRpb25zKCksIGluc3RlYWQgb2YgcG9zaXRpb25zKCkgYW5kIG1hbnVhbCBldmVudHNcblxuICAgIGVsZXMubm9kZXMoKS5wb3NpdGlvbnMoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfTtcbiAgICB9KTsgLy8gdHJpZ2dlciBsYXlvdXRyZWFkeSB3aGVuIGVhY2ggbm9kZSBoYXMgaGFkIGl0cyBwb3NpdGlvbiBzZXQgYXQgbGVhc3Qgb25jZVxuXG4gICAgbGF5b3V0Lm9uZSgnbGF5b3V0cmVhZHknLCBvcHRpb25zLnJlYWR5KTtcbiAgICBsYXlvdXQuZW1pdCgnbGF5b3V0cmVhZHknKTsgLy8gdHJpZ2dlciBsYXlvdXRzdG9wIHdoZW4gdGhlIGxheW91dCBzdG9wcyAoZS5nLiBmaW5pc2hlcylcblxuICAgIGxheW91dC5vbmUoJ2xheW91dHN0b3AnLCBvcHRpb25zLnN0b3ApO1xuICAgIGxheW91dC5lbWl0KCdsYXlvdXRzdG9wJyk7XG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH07IC8vIGNhbGxlZCBvbiBjb250aW51b3VzIGxheW91dHMgdG8gc3RvcCB0aGVtIGJlZm9yZSB0aGV5IGZpbmlzaFxuXG5cbiAgTnVsbExheW91dC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfTtcblxuICB2YXIgZGVmYXVsdHMkMSA9IHtcbiAgICBwb3NpdGlvbnM6IHVuZGVmaW5lZCxcbiAgICAvLyBtYXAgb2YgKG5vZGUgaWQpID0+IChwb3NpdGlvbiBvYmopOyBvciBmdW5jdGlvbihub2RlKXsgcmV0dXJuIHNvbVBvczsgfVxuICAgIHpvb206IHVuZGVmaW5lZCxcbiAgICAvLyB0aGUgem9vbSBsZXZlbCB0byBzZXQgKHByb2Igd2FudCBmaXQgPSBmYWxzZSBpZiBzZXQpXG4gICAgcGFuOiB1bmRlZmluZWQsXG4gICAgLy8gdGhlIHBhbiBsZXZlbCB0byBzZXQgKHByb2Igd2FudCBmaXQgPSBmYWxzZSBpZiBzZXQpXG4gICAgZml0OiB0cnVlLFxuICAgIC8vIHdoZXRoZXIgdG8gZml0IHRvIHZpZXdwb3J0XG4gICAgcGFkZGluZzogMzAsXG4gICAgLy8gcGFkZGluZyBvbiBmaXRcbiAgICBhbmltYXRlOiBmYWxzZSxcbiAgICAvLyB3aGV0aGVyIHRvIHRyYW5zaXRpb24gdGhlIG5vZGUgcG9zaXRpb25zXG4gICAgYW5pbWF0aW9uRHVyYXRpb246IDUwMCxcbiAgICAvLyBkdXJhdGlvbiBvZiBhbmltYXRpb24gaW4gbXMgaWYgZW5hYmxlZFxuICAgIGFuaW1hdGlvbkVhc2luZzogdW5kZWZpbmVkLFxuICAgIC8vIGVhc2luZyBvZiBhbmltYXRpb24gaWYgZW5hYmxlZFxuICAgIGFuaW1hdGVGaWx0ZXI6IGZ1bmN0aW9uIGFuaW1hdGVGaWx0ZXIobm9kZSwgaSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICAvLyBhIGZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBub2RlIHNob3VsZCBiZSBhbmltYXRlZC4gIEFsbCBub2RlcyBhbmltYXRlZCBieSBkZWZhdWx0IG9uIGFuaW1hdGUgZW5hYmxlZC4gIE5vbi1hbmltYXRlZCBub2RlcyBhcmUgcG9zaXRpb25lZCBpbW1lZGlhdGVseSB3aGVuIHRoZSBsYXlvdXQgc3RhcnRzXG4gICAgcmVhZHk6IHVuZGVmaW5lZCxcbiAgICAvLyBjYWxsYmFjayBvbiBsYXlvdXRyZWFkeVxuICAgIHN0b3A6IHVuZGVmaW5lZCxcbiAgICAvLyBjYWxsYmFjayBvbiBsYXlvdXRzdG9wXG4gICAgdHJhbnNmb3JtOiBmdW5jdGlvbiB0cmFuc2Zvcm0obm9kZSwgcG9zaXRpb24pIHtcbiAgICAgIHJldHVybiBwb3NpdGlvbjtcbiAgICB9IC8vIHRyYW5zZm9ybSBhIGdpdmVuIG5vZGUgcG9zaXRpb24uIFVzZWZ1bCBmb3IgY2hhbmdpbmcgZmxvdyBkaXJlY3Rpb24gaW4gZGlzY3JldGUgbGF5b3V0c1xuXG4gIH07XG5cbiAgZnVuY3Rpb24gUHJlc2V0TGF5b3V0KG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBleHRlbmQoe30sIGRlZmF1bHRzJDEsIG9wdGlvbnMpO1xuICB9XG5cbiAgUHJlc2V0TGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgdmFyIGVsZXMgPSBvcHRpb25zLmVsZXM7XG4gICAgdmFyIG5vZGVzID0gZWxlcy5ub2RlcygpO1xuICAgIHZhciBwb3NJc0ZuID0gZm4kNihvcHRpb25zLnBvc2l0aW9ucyk7XG5cbiAgICBmdW5jdGlvbiBnZXRQb3NpdGlvbihub2RlKSB7XG4gICAgICBpZiAob3B0aW9ucy5wb3NpdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gY29weVBvc2l0aW9uKG5vZGUucG9zaXRpb24oKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwb3NJc0ZuKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLnBvc2l0aW9ucyhub2RlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBvcyA9IG9wdGlvbnMucG9zaXRpb25zW25vZGUuX3ByaXZhdGUuZGF0YS5pZF07XG5cbiAgICAgIGlmIChwb3MgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG5cbiAgICBub2Rlcy5sYXlvdXRQb3NpdGlvbnModGhpcywgb3B0aW9ucywgZnVuY3Rpb24gKG5vZGUsIGkpIHtcbiAgICAgIHZhciBwb3NpdGlvbiA9IGdldFBvc2l0aW9uKG5vZGUpO1xuXG4gICAgICBpZiAobm9kZS5sb2NrZWQoKSB8fCBwb3NpdGlvbiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9O1xuXG4gIHZhciBkZWZhdWx0cyA9IHtcbiAgICBmaXQ6IHRydWUsXG4gICAgLy8gd2hldGhlciB0byBmaXQgdG8gdmlld3BvcnRcbiAgICBwYWRkaW5nOiAzMCxcbiAgICAvLyBmaXQgcGFkZGluZ1xuICAgIGJvdW5kaW5nQm94OiB1bmRlZmluZWQsXG4gICAgLy8gY29uc3RyYWluIGxheW91dCBib3VuZHM7IHsgeDEsIHkxLCB4MiwgeTIgfSBvciB7IHgxLCB5MSwgdywgaCB9XG4gICAgYW5pbWF0ZTogZmFsc2UsXG4gICAgLy8gd2hldGhlciB0byB0cmFuc2l0aW9uIHRoZSBub2RlIHBvc2l0aW9uc1xuICAgIGFuaW1hdGlvbkR1cmF0aW9uOiA1MDAsXG4gICAgLy8gZHVyYXRpb24gb2YgYW5pbWF0aW9uIGluIG1zIGlmIGVuYWJsZWRcbiAgICBhbmltYXRpb25FYXNpbmc6IHVuZGVmaW5lZCxcbiAgICAvLyBlYXNpbmcgb2YgYW5pbWF0aW9uIGlmIGVuYWJsZWRcbiAgICBhbmltYXRlRmlsdGVyOiBmdW5jdGlvbiBhbmltYXRlRmlsdGVyKG5vZGUsIGkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgLy8gYSBmdW5jdGlvbiB0aGF0IGRldGVybWluZXMgd2hldGhlciB0aGUgbm9kZSBzaG91bGQgYmUgYW5pbWF0ZWQuICBBbGwgbm9kZXMgYW5pbWF0ZWQgYnkgZGVmYXVsdCBvbiBhbmltYXRlIGVuYWJsZWQuICBOb24tYW5pbWF0ZWQgbm9kZXMgYXJlIHBvc2l0aW9uZWQgaW1tZWRpYXRlbHkgd2hlbiB0aGUgbGF5b3V0IHN0YXJ0c1xuICAgIHJlYWR5OiB1bmRlZmluZWQsXG4gICAgLy8gY2FsbGJhY2sgb24gbGF5b3V0cmVhZHlcbiAgICBzdG9wOiB1bmRlZmluZWQsXG4gICAgLy8gY2FsbGJhY2sgb24gbGF5b3V0c3RvcFxuICAgIHRyYW5zZm9ybTogZnVuY3Rpb24gdHJhbnNmb3JtKG5vZGUsIHBvc2l0aW9uKSB7XG4gICAgICByZXR1cm4gcG9zaXRpb247XG4gICAgfSAvLyB0cmFuc2Zvcm0gYSBnaXZlbiBub2RlIHBvc2l0aW9uLiBVc2VmdWwgZm9yIGNoYW5naW5nIGZsb3cgZGlyZWN0aW9uIGluIGRpc2NyZXRlIGxheW91dHMgXG5cbiAgfTtcblxuICBmdW5jdGlvbiBSYW5kb21MYXlvdXQob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IGV4dGVuZCh7fSwgZGVmYXVsdHMsIG9wdGlvbnMpO1xuICB9XG5cbiAgUmFuZG9tTGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgdmFyIGN5ID0gb3B0aW9ucy5jeTtcbiAgICB2YXIgZWxlcyA9IG9wdGlvbnMuZWxlcztcbiAgICB2YXIgYmIgPSBtYWtlQm91bmRpbmdCb3gob3B0aW9ucy5ib3VuZGluZ0JveCA/IG9wdGlvbnMuYm91bmRpbmdCb3ggOiB7XG4gICAgICB4MTogMCxcbiAgICAgIHkxOiAwLFxuICAgICAgdzogY3kud2lkdGgoKSxcbiAgICAgIGg6IGN5LmhlaWdodCgpXG4gICAgfSk7XG5cbiAgICB2YXIgZ2V0UG9zID0gZnVuY3Rpb24gZ2V0UG9zKG5vZGUsIGkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IGJiLngxICsgTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogYmIudyksXG4gICAgICAgIHk6IGJiLnkxICsgTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogYmIuaClcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGVsZXMubm9kZXMoKS5sYXlvdXRQb3NpdGlvbnModGhpcywgb3B0aW9ucywgZ2V0UG9zKTtcbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfTtcblxuICB2YXIgbGF5b3V0ID0gW3tcbiAgICBuYW1lOiAnYnJlYWR0aGZpcnN0JyxcbiAgICBpbXBsOiBCcmVhZHRoRmlyc3RMYXlvdXRcbiAgfSwge1xuICAgIG5hbWU6ICdjaXJjbGUnLFxuICAgIGltcGw6IENpcmNsZUxheW91dFxuICB9LCB7XG4gICAgbmFtZTogJ2NvbmNlbnRyaWMnLFxuICAgIGltcGw6IENvbmNlbnRyaWNMYXlvdXRcbiAgfSwge1xuICAgIG5hbWU6ICdjb3NlJyxcbiAgICBpbXBsOiBDb3NlTGF5b3V0XG4gIH0sIHtcbiAgICBuYW1lOiAnZ3JpZCcsXG4gICAgaW1wbDogR3JpZExheW91dFxuICB9LCB7XG4gICAgbmFtZTogJ251bGwnLFxuICAgIGltcGw6IE51bGxMYXlvdXRcbiAgfSwge1xuICAgIG5hbWU6ICdwcmVzZXQnLFxuICAgIGltcGw6IFByZXNldExheW91dFxuICB9LCB7XG4gICAgbmFtZTogJ3JhbmRvbScsXG4gICAgaW1wbDogUmFuZG9tTGF5b3V0XG4gIH1dO1xuXG4gIGZ1bmN0aW9uIE51bGxSZW5kZXJlcihvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLm5vdGlmaWNhdGlvbnMgPSAwOyAvLyBmb3IgdGVzdGluZ1xuICB9XG5cbiAgdmFyIG5vb3AgPSBmdW5jdGlvbiBub29wKCkge307XG5cbiAgdmFyIHRocm93SW1nRXJyID0gZnVuY3Rpb24gdGhyb3dJbWdFcnIoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBIGhlYWRsZXNzIGluc3RhbmNlIGNhbiBub3QgcmVuZGVyIGltYWdlcycpO1xuICB9O1xuXG4gIE51bGxSZW5kZXJlci5wcm90b3R5cGUgPSB7XG4gICAgcmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlOiBub29wLFxuICAgIG5vdGlmeTogZnVuY3Rpb24gbm90aWZ5KCkge1xuICAgICAgdGhpcy5ub3RpZmljYXRpb25zKys7XG4gICAgfSxcbiAgICBpbml0OiBub29wLFxuICAgIGlzSGVhZGxlc3M6IGZ1bmN0aW9uIGlzSGVhZGxlc3MoKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIHBuZzogdGhyb3dJbWdFcnIsXG4gICAganBnOiB0aHJvd0ltZ0VyclxuICB9O1xuXG4gIHZhciBCUnAkZiA9IHt9O1xuICBCUnAkZi5hcnJvd1NoYXBlV2lkdGggPSAwLjM7XG5cbiAgQlJwJGYucmVnaXN0ZXJBcnJvd1NoYXBlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJyb3dTaGFwZXMgPSB0aGlzLmFycm93U2hhcGVzID0ge307XG4gICAgdmFyIHJlbmRlcmVyID0gdGhpczsgLy8gQ29udHJhY3QgZm9yIGFycm93IHNoYXBlczpcbiAgICAvLyAwLCAwIGlzIGFycm93IHRpcFxuICAgIC8vICgwLCAxKSBpcyBkaXJlY3Rpb24gdG93YXJkcyBub2RlXG4gICAgLy8gKDEsIDApIGlzIHJpZ2h0XG4gICAgLy9cbiAgICAvLyBmdW5jdGlvbmFsIGFwaTpcbiAgICAvLyBjb2xsaWRlOiBjaGVjayB4LCB5IGluIHNoYXBlXG4gICAgLy8gcm91Z2hDb2xsaWRlOiBjYWxsZWQgYmVmb3JlIGNvbGxpZGUsIG5vIGZhbHNlIG5lZ2F0aXZlc1xuICAgIC8vIGRyYXc6IGRyYXdcbiAgICAvLyBzcGFjaW5nOiBkaXN0KGFycm93VGlwLCBub2RlQm91bmRhcnkpXG4gICAgLy8gZ2FwOiBkaXN0KGVkZ2VUaXAsIG5vZGVCb3VuZGFyeSksIGVkZ2VUaXAgbWF5ICE9IGFycm93VGlwXG5cbiAgICB2YXIgYmJDb2xsaWRlID0gZnVuY3Rpb24gYmJDb2xsaWRlKHgsIHksIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiwgZWRnZVdpZHRoLCBwYWRkaW5nKSB7XG4gICAgICB2YXIgeDEgPSB0cmFuc2xhdGlvbi54IC0gc2l6ZSAvIDIgLSBwYWRkaW5nO1xuICAgICAgdmFyIHgyID0gdHJhbnNsYXRpb24ueCArIHNpemUgLyAyICsgcGFkZGluZztcbiAgICAgIHZhciB5MSA9IHRyYW5zbGF0aW9uLnkgLSBzaXplIC8gMiAtIHBhZGRpbmc7XG4gICAgICB2YXIgeTIgPSB0cmFuc2xhdGlvbi55ICsgc2l6ZSAvIDIgKyBwYWRkaW5nO1xuICAgICAgdmFyIGluc2lkZSA9IHgxIDw9IHggJiYgeCA8PSB4MiAmJiB5MSA8PSB5ICYmIHkgPD0geTI7XG4gICAgICByZXR1cm4gaW5zaWRlO1xuICAgIH07XG5cbiAgICB2YXIgdHJhbnNmb3JtID0gZnVuY3Rpb24gdHJhbnNmb3JtKHgsIHksIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbikge1xuICAgICAgdmFyIHhSb3RhdGVkID0geCAqIE1hdGguY29zKGFuZ2xlKSAtIHkgKiBNYXRoLnNpbihhbmdsZSk7XG4gICAgICB2YXIgeVJvdGF0ZWQgPSB4ICogTWF0aC5zaW4oYW5nbGUpICsgeSAqIE1hdGguY29zKGFuZ2xlKTtcbiAgICAgIHZhciB4U2NhbGVkID0geFJvdGF0ZWQgKiBzaXplO1xuICAgICAgdmFyIHlTY2FsZWQgPSB5Um90YXRlZCAqIHNpemU7XG4gICAgICB2YXIgeFRyYW5zbGF0ZWQgPSB4U2NhbGVkICsgdHJhbnNsYXRpb24ueDtcbiAgICAgIHZhciB5VHJhbnNsYXRlZCA9IHlTY2FsZWQgKyB0cmFuc2xhdGlvbi55O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogeFRyYW5zbGF0ZWQsXG4gICAgICAgIHk6IHlUcmFuc2xhdGVkXG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgdHJhbnNmb3JtUG9pbnRzID0gZnVuY3Rpb24gdHJhbnNmb3JtUG9pbnRzKHB0cywgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uKSB7XG4gICAgICB2YXIgcmV0UHRzID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHRzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIHZhciB4ID0gcHRzW2ldO1xuICAgICAgICB2YXIgeSA9IHB0c1tpICsgMV07XG4gICAgICAgIHJldFB0cy5wdXNoKHRyYW5zZm9ybSh4LCB5LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldFB0cztcbiAgICB9O1xuXG4gICAgdmFyIHBvaW50c1RvQXJyID0gZnVuY3Rpb24gcG9pbnRzVG9BcnIocHRzKSB7XG4gICAgICB2YXIgcmV0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwID0gcHRzW2ldO1xuICAgICAgICByZXQucHVzaChwLngsIHAueSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcblxuICAgIHZhciBzdGFuZGFyZEdhcCA9IGZ1bmN0aW9uIHN0YW5kYXJkR2FwKGVkZ2UpIHtcbiAgICAgIHJldHVybiBlZGdlLnBzdHlsZSgnd2lkdGgnKS5wZlZhbHVlICogZWRnZS5wc3R5bGUoJ2Fycm93LXNjYWxlJykucGZWYWx1ZSAqIDI7XG4gICAgfTtcblxuICAgIHZhciBkZWZpbmVBcnJvd1NoYXBlID0gZnVuY3Rpb24gZGVmaW5lQXJyb3dTaGFwZShuYW1lLCBkZWZuKSB7XG4gICAgICBpZiAoc3RyaW5nKGRlZm4pKSB7XG4gICAgICAgIGRlZm4gPSBhcnJvd1NoYXBlc1tkZWZuXTtcbiAgICAgIH1cblxuICAgICAgYXJyb3dTaGFwZXNbbmFtZV0gPSBleHRlbmQoe1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICBwb2ludHM6IFstMC4xNSwgLTAuMywgMC4xNSwgLTAuMywgMC4xNSwgMC4zLCAtMC4xNSwgMC4zXSxcbiAgICAgICAgY29sbGlkZTogZnVuY3Rpb24gY29sbGlkZSh4LCB5LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24sIHBhZGRpbmcpIHtcbiAgICAgICAgICB2YXIgcG9pbnRzID0gcG9pbnRzVG9BcnIodHJhbnNmb3JtUG9pbnRzKHRoaXMucG9pbnRzLCBzaXplICsgMiAqIHBhZGRpbmcsIGFuZ2xlLCB0cmFuc2xhdGlvbikpO1xuICAgICAgICAgIHZhciBpbnNpZGUgPSBwb2ludEluc2lkZVBvbHlnb25Qb2ludHMoeCwgeSwgcG9pbnRzKTtcbiAgICAgICAgICByZXR1cm4gaW5zaWRlO1xuICAgICAgICB9LFxuICAgICAgICByb3VnaENvbGxpZGU6IGJiQ29sbGlkZSxcbiAgICAgICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjb250ZXh0LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pIHtcbiAgICAgICAgICB2YXIgcG9pbnRzID0gdHJhbnNmb3JtUG9pbnRzKHRoaXMucG9pbnRzLCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pO1xuICAgICAgICAgIHJlbmRlcmVyLmFycm93U2hhcGVJbXBsKCdwb2x5Z29uJykoY29udGV4dCwgcG9pbnRzKTtcbiAgICAgICAgfSxcbiAgICAgICAgc3BhY2luZzogZnVuY3Rpb24gc3BhY2luZyhlZGdlKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0sXG4gICAgICAgIGdhcDogc3RhbmRhcmRHYXBcbiAgICAgIH0sIGRlZm4pO1xuICAgIH07XG5cbiAgICBkZWZpbmVBcnJvd1NoYXBlKCdub25lJywge1xuICAgICAgY29sbGlkZTogZmFsc2lmeSxcbiAgICAgIHJvdWdoQ29sbGlkZTogZmFsc2lmeSxcbiAgICAgIGRyYXc6IG5vb3AkMSxcbiAgICAgIHNwYWNpbmc6IHplcm9pZnksXG4gICAgICBnYXA6IHplcm9pZnlcbiAgICB9KTtcbiAgICBkZWZpbmVBcnJvd1NoYXBlKCd0cmlhbmdsZScsIHtcbiAgICAgIHBvaW50czogWy0wLjE1LCAtMC4zLCAwLCAwLCAwLjE1LCAtMC4zXVxuICAgIH0pO1xuICAgIGRlZmluZUFycm93U2hhcGUoJ2Fycm93JywgJ3RyaWFuZ2xlJyk7XG4gICAgZGVmaW5lQXJyb3dTaGFwZSgndHJpYW5nbGUtYmFja2N1cnZlJywge1xuICAgICAgcG9pbnRzOiBhcnJvd1NoYXBlc1sndHJpYW5nbGUnXS5wb2ludHMsXG4gICAgICBjb250cm9sUG9pbnQ6IFswLCAtMC4xNV0sXG4gICAgICByb3VnaENvbGxpZGU6IGJiQ29sbGlkZSxcbiAgICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY29udGV4dCwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uLCBlZGdlV2lkdGgpIHtcbiAgICAgICAgdmFyIHB0c1RyYW5zID0gdHJhbnNmb3JtUG9pbnRzKHRoaXMucG9pbnRzLCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pO1xuICAgICAgICB2YXIgY3RybFB0ID0gdGhpcy5jb250cm9sUG9pbnQ7XG4gICAgICAgIHZhciBjdHJsUHRUcmFucyA9IHRyYW5zZm9ybShjdHJsUHRbMF0sIGN0cmxQdFsxXSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uKTtcbiAgICAgICAgcmVuZGVyZXIuYXJyb3dTaGFwZUltcGwodGhpcy5uYW1lKShjb250ZXh0LCBwdHNUcmFucywgY3RybFB0VHJhbnMpO1xuICAgICAgfSxcbiAgICAgIGdhcDogZnVuY3Rpb24gZ2FwKGVkZ2UpIHtcbiAgICAgICAgcmV0dXJuIHN0YW5kYXJkR2FwKGVkZ2UpICogMC44O1xuICAgICAgfVxuICAgIH0pO1xuICAgIGRlZmluZUFycm93U2hhcGUoJ3RyaWFuZ2xlLXRlZScsIHtcbiAgICAgIHBvaW50czogWzAsIDAsIDAuMTUsIC0wLjMsIC0wLjE1LCAtMC4zLCAwLCAwXSxcbiAgICAgIHBvaW50c1RlZTogWy0wLjE1LCAtMC40LCAtMC4xNSwgLTAuNSwgMC4xNSwgLTAuNSwgMC4xNSwgLTAuNF0sXG4gICAgICBjb2xsaWRlOiBmdW5jdGlvbiBjb2xsaWRlKHgsIHksIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiwgZWRnZVdpZHRoLCBwYWRkaW5nKSB7XG4gICAgICAgIHZhciB0cmlQdHMgPSBwb2ludHNUb0Fycih0cmFuc2Zvcm1Qb2ludHModGhpcy5wb2ludHMsIHNpemUgKyAyICogcGFkZGluZywgYW5nbGUsIHRyYW5zbGF0aW9uKSk7XG4gICAgICAgIHZhciB0ZWVQdHMgPSBwb2ludHNUb0Fycih0cmFuc2Zvcm1Qb2ludHModGhpcy5wb2ludHNUZWUsIHNpemUgKyAyICogcGFkZGluZywgYW5nbGUsIHRyYW5zbGF0aW9uKSk7XG4gICAgICAgIHZhciBpbnNpZGUgPSBwb2ludEluc2lkZVBvbHlnb25Qb2ludHMoeCwgeSwgdHJpUHRzKSB8fCBwb2ludEluc2lkZVBvbHlnb25Qb2ludHMoeCwgeSwgdGVlUHRzKTtcbiAgICAgICAgcmV0dXJuIGluc2lkZTtcbiAgICAgIH0sXG4gICAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNvbnRleHQsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiwgZWRnZVdpZHRoKSB7XG4gICAgICAgIHZhciB0cmlQdHMgPSB0cmFuc2Zvcm1Qb2ludHModGhpcy5wb2ludHMsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbik7XG4gICAgICAgIHZhciB0ZWVQdHMgPSB0cmFuc2Zvcm1Qb2ludHModGhpcy5wb2ludHNUZWUsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbik7XG4gICAgICAgIHJlbmRlcmVyLmFycm93U2hhcGVJbXBsKHRoaXMubmFtZSkoY29udGV4dCwgdHJpUHRzLCB0ZWVQdHMpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGRlZmluZUFycm93U2hhcGUoJ2NpcmNsZS10cmlhbmdsZScsIHtcbiAgICAgIHJhZGl1czogMC4xNSxcbiAgICAgIHBvaW50c1RyOiBbMCwgLTAuMTUsIDAuMTUsIC0wLjQ1LCAtMC4xNSwgLTAuNDUsIDAsIC0wLjE1XSxcbiAgICAgIGNvbGxpZGU6IGZ1bmN0aW9uIGNvbGxpZGUoeCwgeSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uLCBlZGdlV2lkdGgsIHBhZGRpbmcpIHtcbiAgICAgICAgdmFyIHQgPSB0cmFuc2xhdGlvbjtcbiAgICAgICAgdmFyIGNpcmNsZUluc2lkZSA9IE1hdGgucG93KHQueCAtIHgsIDIpICsgTWF0aC5wb3codC55IC0geSwgMikgPD0gTWF0aC5wb3coKHNpemUgKyAyICogcGFkZGluZykgKiB0aGlzLnJhZGl1cywgMik7XG4gICAgICAgIHZhciB0cmlQdHMgPSBwb2ludHNUb0Fycih0cmFuc2Zvcm1Qb2ludHModGhpcy5wb2ludHMsIHNpemUgKyAyICogcGFkZGluZywgYW5nbGUsIHRyYW5zbGF0aW9uKSk7XG4gICAgICAgIHJldHVybiBwb2ludEluc2lkZVBvbHlnb25Qb2ludHMoeCwgeSwgdHJpUHRzKSB8fCBjaXJjbGVJbnNpZGU7XG4gICAgICB9LFxuICAgICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjb250ZXh0LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24sIGVkZ2VXaWR0aCkge1xuICAgICAgICB2YXIgdHJpUHRzID0gdHJhbnNmb3JtUG9pbnRzKHRoaXMucG9pbnRzVHIsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbik7XG4gICAgICAgIHJlbmRlcmVyLmFycm93U2hhcGVJbXBsKHRoaXMubmFtZSkoY29udGV4dCwgdHJpUHRzLCB0cmFuc2xhdGlvbi54LCB0cmFuc2xhdGlvbi55LCB0aGlzLnJhZGl1cyAqIHNpemUpO1xuICAgICAgfSxcbiAgICAgIHNwYWNpbmc6IGZ1bmN0aW9uIHNwYWNpbmcoZWRnZSkge1xuICAgICAgICByZXR1cm4gcmVuZGVyZXIuZ2V0QXJyb3dXaWR0aChlZGdlLnBzdHlsZSgnd2lkdGgnKS5wZlZhbHVlLCBlZGdlLnBzdHlsZSgnYXJyb3ctc2NhbGUnKS52YWx1ZSkgKiB0aGlzLnJhZGl1cztcbiAgICAgIH1cbiAgICB9KTtcbiAgICBkZWZpbmVBcnJvd1NoYXBlKCd0cmlhbmdsZS1jcm9zcycsIHtcbiAgICAgIHBvaW50czogWzAsIDAsIDAuMTUsIC0wLjMsIC0wLjE1LCAtMC4zLCAwLCAwXSxcbiAgICAgIGJhc2VDcm9zc0xpbmVQdHM6IFstMC4xNSwgLTAuNCwgLy8gZmlyc3QgaGFsZiBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICAtMC4xNSwgLTAuNCwgMC4xNSwgLTAuNCwgLy8gc2Vjb25kIGhhbGYgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAgMC4xNSwgLTAuNF0sXG4gICAgICBjcm9zc0xpbmVQdHM6IGZ1bmN0aW9uIGNyb3NzTGluZVB0cyhzaXplLCBlZGdlV2lkdGgpIHtcbiAgICAgICAgLy8gc2hpZnQgcG9pbnRzIHNvIHRoYXQgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIGNyb3NzIHBvaW50cyBtYXRjaGVzIGVkZ2Ugd2lkdGhcbiAgICAgICAgdmFyIHAgPSB0aGlzLmJhc2VDcm9zc0xpbmVQdHMuc2xpY2UoKTtcbiAgICAgICAgdmFyIHNoaWZ0RmFjdG9yID0gZWRnZVdpZHRoIC8gc2l6ZTtcbiAgICAgICAgdmFyIHkwID0gMztcbiAgICAgICAgdmFyIHkxID0gNTtcbiAgICAgICAgcFt5MF0gPSBwW3kwXSAtIHNoaWZ0RmFjdG9yO1xuICAgICAgICBwW3kxXSA9IHBbeTFdIC0gc2hpZnRGYWN0b3I7XG4gICAgICAgIHJldHVybiBwO1xuICAgICAgfSxcbiAgICAgIGNvbGxpZGU6IGZ1bmN0aW9uIGNvbGxpZGUoeCwgeSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uLCBlZGdlV2lkdGgsIHBhZGRpbmcpIHtcbiAgICAgICAgdmFyIHRyaVB0cyA9IHBvaW50c1RvQXJyKHRyYW5zZm9ybVBvaW50cyh0aGlzLnBvaW50cywgc2l6ZSArIDIgKiBwYWRkaW5nLCBhbmdsZSwgdHJhbnNsYXRpb24pKTtcbiAgICAgICAgdmFyIHRlZVB0cyA9IHBvaW50c1RvQXJyKHRyYW5zZm9ybVBvaW50cyh0aGlzLmNyb3NzTGluZVB0cyhzaXplLCBlZGdlV2lkdGgpLCBzaXplICsgMiAqIHBhZGRpbmcsIGFuZ2xlLCB0cmFuc2xhdGlvbikpO1xuICAgICAgICB2YXIgaW5zaWRlID0gcG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKHgsIHksIHRyaVB0cykgfHwgcG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKHgsIHksIHRlZVB0cyk7XG4gICAgICAgIHJldHVybiBpbnNpZGU7XG4gICAgICB9LFxuICAgICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjb250ZXh0LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24sIGVkZ2VXaWR0aCkge1xuICAgICAgICB2YXIgdHJpUHRzID0gdHJhbnNmb3JtUG9pbnRzKHRoaXMucG9pbnRzLCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pO1xuICAgICAgICB2YXIgY3Jvc3NMaW5lUHRzID0gdHJhbnNmb3JtUG9pbnRzKHRoaXMuY3Jvc3NMaW5lUHRzKHNpemUsIGVkZ2VXaWR0aCksIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbik7XG4gICAgICAgIHJlbmRlcmVyLmFycm93U2hhcGVJbXBsKHRoaXMubmFtZSkoY29udGV4dCwgdHJpUHRzLCBjcm9zc0xpbmVQdHMpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGRlZmluZUFycm93U2hhcGUoJ3ZlZScsIHtcbiAgICAgIHBvaW50czogWy0wLjE1LCAtMC4zLCAwLCAwLCAwLjE1LCAtMC4zLCAwLCAtMC4xNV0sXG4gICAgICBnYXA6IGZ1bmN0aW9uIGdhcChlZGdlKSB7XG4gICAgICAgIHJldHVybiBzdGFuZGFyZEdhcChlZGdlKSAqIDAuNTI1O1xuICAgICAgfVxuICAgIH0pO1xuICAgIGRlZmluZUFycm93U2hhcGUoJ2NpcmNsZScsIHtcbiAgICAgIHJhZGl1czogMC4xNSxcbiAgICAgIGNvbGxpZGU6IGZ1bmN0aW9uIGNvbGxpZGUoeCwgeSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uLCBlZGdlV2lkdGgsIHBhZGRpbmcpIHtcbiAgICAgICAgdmFyIHQgPSB0cmFuc2xhdGlvbjtcbiAgICAgICAgdmFyIGluc2lkZSA9IE1hdGgucG93KHQueCAtIHgsIDIpICsgTWF0aC5wb3codC55IC0geSwgMikgPD0gTWF0aC5wb3coKHNpemUgKyAyICogcGFkZGluZykgKiB0aGlzLnJhZGl1cywgMik7XG4gICAgICAgIHJldHVybiBpbnNpZGU7XG4gICAgICB9LFxuICAgICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjb250ZXh0LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24sIGVkZ2VXaWR0aCkge1xuICAgICAgICByZW5kZXJlci5hcnJvd1NoYXBlSW1wbCh0aGlzLm5hbWUpKGNvbnRleHQsIHRyYW5zbGF0aW9uLngsIHRyYW5zbGF0aW9uLnksIHRoaXMucmFkaXVzICogc2l6ZSk7XG4gICAgICB9LFxuICAgICAgc3BhY2luZzogZnVuY3Rpb24gc3BhY2luZyhlZGdlKSB7XG4gICAgICAgIHJldHVybiByZW5kZXJlci5nZXRBcnJvd1dpZHRoKGVkZ2UucHN0eWxlKCd3aWR0aCcpLnBmVmFsdWUsIGVkZ2UucHN0eWxlKCdhcnJvdy1zY2FsZScpLnZhbHVlKSAqIHRoaXMucmFkaXVzO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGRlZmluZUFycm93U2hhcGUoJ3RlZScsIHtcbiAgICAgIHBvaW50czogWy0wLjE1LCAwLCAtMC4xNSwgLTAuMSwgMC4xNSwgLTAuMSwgMC4xNSwgMF0sXG4gICAgICBzcGFjaW5nOiBmdW5jdGlvbiBzcGFjaW5nKGVkZ2UpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9LFxuICAgICAgZ2FwOiBmdW5jdGlvbiBnYXAoZWRnZSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBkZWZpbmVBcnJvd1NoYXBlKCdzcXVhcmUnLCB7XG4gICAgICBwb2ludHM6IFstMC4xNSwgMC4wMCwgMC4xNSwgMC4wMCwgMC4xNSwgLTAuMywgLTAuMTUsIC0wLjNdXG4gICAgfSk7XG4gICAgZGVmaW5lQXJyb3dTaGFwZSgnZGlhbW9uZCcsIHtcbiAgICAgIHBvaW50czogWy0wLjE1LCAtMC4xNSwgMCwgLTAuMywgMC4xNSwgLTAuMTUsIDAsIDBdLFxuICAgICAgZ2FwOiBmdW5jdGlvbiBnYXAoZWRnZSkge1xuICAgICAgICByZXR1cm4gZWRnZS5wc3R5bGUoJ3dpZHRoJykucGZWYWx1ZSAqIGVkZ2UucHN0eWxlKCdhcnJvdy1zY2FsZScpLnZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGRlZmluZUFycm93U2hhcGUoJ2NoZXZyb24nLCB7XG4gICAgICBwb2ludHM6IFswLCAwLCAtMC4xNSwgLTAuMTUsIC0wLjEsIC0wLjIsIDAsIC0wLjEsIDAuMSwgLTAuMiwgMC4xNSwgLTAuMTVdLFxuICAgICAgZ2FwOiBmdW5jdGlvbiBnYXAoZWRnZSkge1xuICAgICAgICByZXR1cm4gMC45NSAqIGVkZ2UucHN0eWxlKCd3aWR0aCcpLnBmVmFsdWUgKiBlZGdlLnBzdHlsZSgnYXJyb3ctc2NhbGUnKS52YWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICB2YXIgQlJwJGUgPSB7fTsgLy8gUHJvamVjdCBtb3VzZVxuXG4gIEJScCRlLnByb2plY3RJbnRvVmlld3BvcnQgPSBmdW5jdGlvbiAoY2xpZW50WCwgY2xpZW50WSkge1xuICAgIHZhciBjeSA9IHRoaXMuY3k7XG4gICAgdmFyIG9mZnNldHMgPSB0aGlzLmZpbmRDb250YWluZXJDbGllbnRDb29yZHMoKTtcbiAgICB2YXIgb2Zmc2V0TGVmdCA9IG9mZnNldHNbMF07XG4gICAgdmFyIG9mZnNldFRvcCA9IG9mZnNldHNbMV07XG4gICAgdmFyIHNjYWxlID0gb2Zmc2V0c1s0XTtcbiAgICB2YXIgcGFuID0gY3kucGFuKCk7XG4gICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgdmFyIHggPSAoKGNsaWVudFggLSBvZmZzZXRMZWZ0KSAvIHNjYWxlIC0gcGFuLngpIC8gem9vbTtcbiAgICB2YXIgeSA9ICgoY2xpZW50WSAtIG9mZnNldFRvcCkgLyBzY2FsZSAtIHBhbi55KSAvIHpvb207XG4gICAgcmV0dXJuIFt4LCB5XTtcbiAgfTtcblxuICBCUnAkZS5maW5kQ29udGFpbmVyQ2xpZW50Q29vcmRzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmNvbnRhaW5lckJCKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250YWluZXJCQjtcbiAgICB9XG5cbiAgICB2YXIgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgdmFyIHJlY3QgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdmFyIHN0eWxlID0gd2luZG93JDEuZ2V0Q29tcHV0ZWRTdHlsZShjb250YWluZXIpO1xuXG4gICAgdmFyIHN0eWxlVmFsdWUgPSBmdW5jdGlvbiBzdHlsZVZhbHVlKG5hbWUpIHtcbiAgICAgIHJldHVybiBwYXJzZUZsb2F0KHN0eWxlLmdldFByb3BlcnR5VmFsdWUobmFtZSkpO1xuICAgIH07XG5cbiAgICB2YXIgcGFkZGluZyA9IHtcbiAgICAgIGxlZnQ6IHN0eWxlVmFsdWUoJ3BhZGRpbmctbGVmdCcpLFxuICAgICAgcmlnaHQ6IHN0eWxlVmFsdWUoJ3BhZGRpbmctcmlnaHQnKSxcbiAgICAgIHRvcDogc3R5bGVWYWx1ZSgncGFkZGluZy10b3AnKSxcbiAgICAgIGJvdHRvbTogc3R5bGVWYWx1ZSgncGFkZGluZy1ib3R0b20nKVxuICAgIH07XG4gICAgdmFyIGJvcmRlciA9IHtcbiAgICAgIGxlZnQ6IHN0eWxlVmFsdWUoJ2JvcmRlci1sZWZ0LXdpZHRoJyksXG4gICAgICByaWdodDogc3R5bGVWYWx1ZSgnYm9yZGVyLXJpZ2h0LXdpZHRoJyksXG4gICAgICB0b3A6IHN0eWxlVmFsdWUoJ2JvcmRlci10b3Atd2lkdGgnKSxcbiAgICAgIGJvdHRvbTogc3R5bGVWYWx1ZSgnYm9yZGVyLWJvdHRvbS13aWR0aCcpXG4gICAgfTtcbiAgICB2YXIgY2xpZW50V2lkdGggPSBjb250YWluZXIuY2xpZW50V2lkdGg7XG4gICAgdmFyIGNsaWVudEhlaWdodCA9IGNvbnRhaW5lci5jbGllbnRIZWlnaHQ7XG4gICAgdmFyIHBhZGRpbmdIb3IgPSBwYWRkaW5nLmxlZnQgKyBwYWRkaW5nLnJpZ2h0O1xuICAgIHZhciBwYWRkaW5nVmVyID0gcGFkZGluZy50b3AgKyBwYWRkaW5nLmJvdHRvbTtcbiAgICB2YXIgYm9yZGVySG9yID0gYm9yZGVyLmxlZnQgKyBib3JkZXIucmlnaHQ7XG4gICAgdmFyIHNjYWxlID0gcmVjdC53aWR0aCAvIChjbGllbnRXaWR0aCArIGJvcmRlckhvcik7XG4gICAgdmFyIHVuc2NhbGVkVyA9IGNsaWVudFdpZHRoIC0gcGFkZGluZ0hvcjtcbiAgICB2YXIgdW5zY2FsZWRIID0gY2xpZW50SGVpZ2h0IC0gcGFkZGluZ1ZlcjtcbiAgICB2YXIgbGVmdCA9IHJlY3QubGVmdCArIHBhZGRpbmcubGVmdCArIGJvcmRlci5sZWZ0O1xuICAgIHZhciB0b3AgPSByZWN0LnRvcCArIHBhZGRpbmcudG9wICsgYm9yZGVyLnRvcDtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXJCQiA9IFtsZWZ0LCB0b3AsIHVuc2NhbGVkVywgdW5zY2FsZWRILCBzY2FsZV07XG4gIH07XG5cbiAgQlJwJGUuaW52YWxpZGF0ZUNvbnRhaW5lckNsaWVudENvb3Jkc0NhY2hlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY29udGFpbmVyQkIgPSBudWxsO1xuICB9O1xuXG4gIEJScCRlLmZpbmROZWFyZXN0RWxlbWVudCA9IGZ1bmN0aW9uICh4LCB5LCBpbnRlcmFjdGl2ZUVsZW1lbnRzT25seSwgaXNUb3VjaCkge1xuICAgIHJldHVybiB0aGlzLmZpbmROZWFyZXN0RWxlbWVudHMoeCwgeSwgaW50ZXJhY3RpdmVFbGVtZW50c09ubHksIGlzVG91Y2gpWzBdO1xuICB9O1xuXG4gIEJScCRlLmZpbmROZWFyZXN0RWxlbWVudHMgPSBmdW5jdGlvbiAoeCwgeSwgaW50ZXJhY3RpdmVFbGVtZW50c09ubHksIGlzVG91Y2gpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHIgPSB0aGlzO1xuICAgIHZhciBlbGVzID0gci5nZXRDYWNoZWRaU29ydGVkRWxlcygpO1xuICAgIHZhciBuZWFyID0gW107IC8vIDEgbm9kZSBtYXgsIDEgZWRnZSBtYXhcblxuICAgIHZhciB6b29tID0gci5jeS56b29tKCk7XG4gICAgdmFyIGhhc0NvbXBvdW5kcyA9IHIuY3kuaGFzQ29tcG91bmROb2RlcygpO1xuICAgIHZhciBlZGdlVGhyZXNob2xkID0gKGlzVG91Y2ggPyAyNCA6IDgpIC8gem9vbTtcbiAgICB2YXIgbm9kZVRocmVzaG9sZCA9IChpc1RvdWNoID8gOCA6IDIpIC8gem9vbTtcbiAgICB2YXIgbGFiZWxUaHJlc2hvbGQgPSAoaXNUb3VjaCA/IDggOiAyKSAvIHpvb207XG4gICAgdmFyIG1pblNxRGlzdCA9IEluZmluaXR5O1xuICAgIHZhciBuZWFyRWRnZTtcbiAgICB2YXIgbmVhck5vZGU7XG5cbiAgICBpZiAoaW50ZXJhY3RpdmVFbGVtZW50c09ubHkpIHtcbiAgICAgIGVsZXMgPSBlbGVzLmludGVyYWN0aXZlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZEVsZShlbGUsIHNxRGlzdCkge1xuICAgICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgICBpZiAobmVhck5vZGUpIHtcbiAgICAgICAgICByZXR1cm47IC8vIGNhbid0IHJlcGxhY2Ugbm9kZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5lYXJOb2RlID0gZWxlO1xuICAgICAgICAgIG5lYXIucHVzaChlbGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChlbGUuaXNFZGdlKCkgJiYgKHNxRGlzdCA9PSBudWxsIHx8IHNxRGlzdCA8IG1pblNxRGlzdCkpIHtcbiAgICAgICAgaWYgKG5lYXJFZGdlKSB7XG4gICAgICAgICAgLy8gdGhlbiByZXBsYWNlIGV4aXN0aW5nIGVkZ2VcbiAgICAgICAgICAvLyBjYW4gcmVwbGFjZSBvbmx5IGlmIHNhbWUgei1pbmRleFxuICAgICAgICAgIGlmIChuZWFyRWRnZS5wc3R5bGUoJ3otY29tcG91bmQtZGVwdGgnKS52YWx1ZSA9PT0gZWxlLnBzdHlsZSgnei1jb21wb3VuZC1kZXB0aCcpLnZhbHVlICYmIG5lYXJFZGdlLnBzdHlsZSgnei1jb21wb3VuZC1kZXB0aCcpLnZhbHVlID09PSBlbGUucHN0eWxlKCd6LWNvbXBvdW5kLWRlcHRoJykudmFsdWUpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmVhci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBpZiAobmVhcltpXS5pc0VkZ2UoKSkge1xuICAgICAgICAgICAgICAgIG5lYXJbaV0gPSBlbGU7XG4gICAgICAgICAgICAgICAgbmVhckVkZ2UgPSBlbGU7XG4gICAgICAgICAgICAgICAgbWluU3FEaXN0ID0gc3FEaXN0ICE9IG51bGwgPyBzcURpc3QgOiBtaW5TcURpc3Q7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmVhci5wdXNoKGVsZSk7XG4gICAgICAgICAgbmVhckVkZ2UgPSBlbGU7XG4gICAgICAgICAgbWluU3FEaXN0ID0gc3FEaXN0ICE9IG51bGwgPyBzcURpc3QgOiBtaW5TcURpc3Q7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja05vZGUobm9kZSkge1xuICAgICAgdmFyIHdpZHRoID0gbm9kZS5vdXRlcldpZHRoKCkgKyAyICogbm9kZVRocmVzaG9sZDtcbiAgICAgIHZhciBoZWlnaHQgPSBub2RlLm91dGVySGVpZ2h0KCkgKyAyICogbm9kZVRocmVzaG9sZDtcbiAgICAgIHZhciBodyA9IHdpZHRoIC8gMjtcbiAgICAgIHZhciBoaCA9IGhlaWdodCAvIDI7XG4gICAgICB2YXIgcG9zID0gbm9kZS5wb3NpdGlvbigpO1xuXG4gICAgICBpZiAocG9zLnggLSBodyA8PSB4ICYmIHggPD0gcG9zLnggKyBodyAvLyBiYiBjaGVjayB4XG4gICAgICAmJiBwb3MueSAtIGhoIDw9IHkgJiYgeSA8PSBwb3MueSArIGhoIC8vIGJiIGNoZWNrIHlcbiAgICAgICkge1xuICAgICAgICB2YXIgc2hhcGUgPSByLm5vZGVTaGFwZXNbc2VsZi5nZXROb2RlU2hhcGUobm9kZSldO1xuXG4gICAgICAgIGlmIChzaGFwZS5jaGVja1BvaW50KHgsIHksIDAsIHdpZHRoLCBoZWlnaHQsIHBvcy54LCBwb3MueSkpIHtcbiAgICAgICAgICBhZGRFbGUobm9kZSwgMCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja0VkZ2UoZWRnZSkge1xuICAgICAgdmFyIF9wID0gZWRnZS5fcHJpdmF0ZTtcbiAgICAgIHZhciBycyA9IF9wLnJzY3JhdGNoO1xuICAgICAgdmFyIHN0eWxlV2lkdGggPSBlZGdlLnBzdHlsZSgnd2lkdGgnKS5wZlZhbHVlO1xuICAgICAgdmFyIHNjYWxlID0gZWRnZS5wc3R5bGUoJ2Fycm93LXNjYWxlJykudmFsdWU7XG4gICAgICB2YXIgd2lkdGggPSBzdHlsZVdpZHRoIC8gMiArIGVkZ2VUaHJlc2hvbGQ7IC8vIG1vcmUgbGlrZSBhIGRpc3RhbmNlIHJhZGl1cyBmcm9tIGNlbnRyZVxuXG4gICAgICB2YXIgd2lkdGhTcSA9IHdpZHRoICogd2lkdGg7XG4gICAgICB2YXIgd2lkdGgyID0gd2lkdGggKiAyO1xuICAgICAgdmFyIHNyYyA9IF9wLnNvdXJjZTtcbiAgICAgIHZhciB0Z3QgPSBfcC50YXJnZXQ7XG4gICAgICB2YXIgc3FEaXN0O1xuXG4gICAgICBpZiAocnMuZWRnZVR5cGUgPT09ICdzZWdtZW50cycgfHwgcnMuZWRnZVR5cGUgPT09ICdzdHJhaWdodCcgfHwgcnMuZWRnZVR5cGUgPT09ICdoYXlzdGFjaycpIHtcbiAgICAgICAgdmFyIHB0cyA9IHJzLmFsbHB0cztcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSArIDMgPCBwdHMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICBpZiAoaW5MaW5lVmljaW5pdHkoeCwgeSwgcHRzW2ldLCBwdHNbaSArIDFdLCBwdHNbaSArIDJdLCBwdHNbaSArIDNdLCB3aWR0aDIpICYmIHdpZHRoU3EgPiAoc3FEaXN0ID0gc3FkaXN0VG9GaW5pdGVMaW5lKHgsIHksIHB0c1tpXSwgcHRzW2kgKyAxXSwgcHRzW2kgKyAyXSwgcHRzW2kgKyAzXSkpKSB7XG4gICAgICAgICAgICBhZGRFbGUoZWRnZSwgc3FEaXN0KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChycy5lZGdlVHlwZSA9PT0gJ2JlemllcicgfHwgcnMuZWRnZVR5cGUgPT09ICdtdWx0aWJlemllcicgfHwgcnMuZWRnZVR5cGUgPT09ICdzZWxmJyB8fCBycy5lZGdlVHlwZSA9PT0gJ2NvbXBvdW5kJykge1xuICAgICAgICB2YXIgcHRzID0gcnMuYWxscHRzO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpICsgNSA8IHJzLmFsbHB0cy5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgICAgIGlmIChpbkJlemllclZpY2luaXR5KHgsIHksIHB0c1tpXSwgcHRzW2kgKyAxXSwgcHRzW2kgKyAyXSwgcHRzW2kgKyAzXSwgcHRzW2kgKyA0XSwgcHRzW2kgKyA1XSwgd2lkdGgyKSAmJiB3aWR0aFNxID4gKHNxRGlzdCA9IHNxZGlzdFRvUXVhZHJhdGljQmV6aWVyKHgsIHksIHB0c1tpXSwgcHRzW2kgKyAxXSwgcHRzW2kgKyAyXSwgcHRzW2kgKyAzXSwgcHRzW2kgKyA0XSwgcHRzW2kgKyA1XSkpKSB7XG4gICAgICAgICAgICBhZGRFbGUoZWRnZSwgc3FEaXN0KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBpZiB3ZSdyZSBjbG9zZSB0byB0aGUgZWRnZSBidXQgZGlkbid0IGhpdCBpdCwgbWF5YmUgd2UgaGl0IGl0cyBhcnJvd3NcblxuXG4gICAgICB2YXIgc3JjID0gc3JjIHx8IF9wLnNvdXJjZTtcbiAgICAgIHZhciB0Z3QgPSB0Z3QgfHwgX3AudGFyZ2V0O1xuICAgICAgdmFyIGFyU2l6ZSA9IHNlbGYuZ2V0QXJyb3dXaWR0aChzdHlsZVdpZHRoLCBzY2FsZSk7XG4gICAgICB2YXIgYXJyb3dzID0gW3tcbiAgICAgICAgbmFtZTogJ3NvdXJjZScsXG4gICAgICAgIHg6IHJzLmFycm93U3RhcnRYLFxuICAgICAgICB5OiBycy5hcnJvd1N0YXJ0WSxcbiAgICAgICAgYW5nbGU6IHJzLnNyY0Fycm93QW5nbGVcbiAgICAgIH0sIHtcbiAgICAgICAgbmFtZTogJ3RhcmdldCcsXG4gICAgICAgIHg6IHJzLmFycm93RW5kWCxcbiAgICAgICAgeTogcnMuYXJyb3dFbmRZLFxuICAgICAgICBhbmdsZTogcnMudGd0QXJyb3dBbmdsZVxuICAgICAgfSwge1xuICAgICAgICBuYW1lOiAnbWlkLXNvdXJjZScsXG4gICAgICAgIHg6IHJzLm1pZFgsXG4gICAgICAgIHk6IHJzLm1pZFksXG4gICAgICAgIGFuZ2xlOiBycy5taWRzcmNBcnJvd0FuZ2xlXG4gICAgICB9LCB7XG4gICAgICAgIG5hbWU6ICdtaWQtdGFyZ2V0JyxcbiAgICAgICAgeDogcnMubWlkWCxcbiAgICAgICAgeTogcnMubWlkWSxcbiAgICAgICAgYW5nbGU6IHJzLm1pZHRndEFycm93QW5nbGVcbiAgICAgIH1dO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycm93cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYXIgPSBhcnJvd3NbaV07XG4gICAgICAgIHZhciBzaGFwZSA9IHIuYXJyb3dTaGFwZXNbZWRnZS5wc3R5bGUoYXIubmFtZSArICctYXJyb3ctc2hhcGUnKS52YWx1ZV07XG4gICAgICAgIHZhciBlZGdlV2lkdGggPSBlZGdlLnBzdHlsZSgnd2lkdGgnKS5wZlZhbHVlO1xuXG4gICAgICAgIGlmIChzaGFwZS5yb3VnaENvbGxpZGUoeCwgeSwgYXJTaXplLCBhci5hbmdsZSwge1xuICAgICAgICAgIHg6IGFyLngsXG4gICAgICAgICAgeTogYXIueVxuICAgICAgICB9LCBlZGdlV2lkdGgsIGVkZ2VUaHJlc2hvbGQpICYmIHNoYXBlLmNvbGxpZGUoeCwgeSwgYXJTaXplLCBhci5hbmdsZSwge1xuICAgICAgICAgIHg6IGFyLngsXG4gICAgICAgICAgeTogYXIueVxuICAgICAgICB9LCBlZGdlV2lkdGgsIGVkZ2VUaHJlc2hvbGQpKSB7XG4gICAgICAgICAgYWRkRWxlKGVkZ2UpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IC8vIGZvciBjb21wb3VuZCBncmFwaHMsIGhpdHRpbmcgZWRnZSBtYXkgYWN0dWFsbHkgd2FudCBhIGNvbm5lY3RlZCBub2RlIGluc3RlYWQgKGIvYyBlZGdlIG1heSBoYXZlIGdyZWF0ZXIgei1pbmRleCBwcmVjZWRlbmNlKVxuXG5cbiAgICAgIGlmIChoYXNDb21wb3VuZHMgJiYgbmVhci5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNoZWNrTm9kZShzcmMpO1xuICAgICAgICBjaGVja05vZGUodGd0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVwcm9wKG9iaiwgbmFtZSwgcHJlKSB7XG4gICAgICByZXR1cm4gZ2V0UHJlZml4ZWRQcm9wZXJ0eShvYmosIG5hbWUsIHByZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tMYWJlbChlbGUsIHByZWZpeCkge1xuICAgICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgICAgdmFyIHRoID0gbGFiZWxUaHJlc2hvbGQ7XG4gICAgICB2YXIgcHJlZml4RGFzaDtcblxuICAgICAgaWYgKHByZWZpeCkge1xuICAgICAgICBwcmVmaXhEYXNoID0gcHJlZml4ICsgJy0nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJlZml4RGFzaCA9ICcnO1xuICAgICAgfVxuXG4gICAgICBlbGUuYm91bmRpbmdCb3goKTtcbiAgICAgIHZhciBiYiA9IF9wLmxhYmVsQm91bmRzW3ByZWZpeCB8fCAnbWFpbiddO1xuICAgICAgdmFyIHRleHQgPSBlbGUucHN0eWxlKHByZWZpeERhc2ggKyAnbGFiZWwnKS52YWx1ZTtcbiAgICAgIHZhciBldmVudHNFbmFibGVkID0gZWxlLnBzdHlsZSgndGV4dC1ldmVudHMnKS5zdHJWYWx1ZSA9PT0gJ3llcyc7XG5cbiAgICAgIGlmICghZXZlbnRzRW5hYmxlZCB8fCAhdGV4dCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBseCA9IHByZXByb3AoX3AucnNjcmF0Y2gsICdsYWJlbFgnLCBwcmVmaXgpO1xuICAgICAgdmFyIGx5ID0gcHJlcHJvcChfcC5yc2NyYXRjaCwgJ2xhYmVsWScsIHByZWZpeCk7XG4gICAgICB2YXIgdGhldGEgPSBwcmVwcm9wKF9wLnJzY3JhdGNoLCAnbGFiZWxBbmdsZScsIHByZWZpeCk7XG4gICAgICB2YXIgb3ggPSBlbGUucHN0eWxlKHByZWZpeERhc2ggKyAndGV4dC1tYXJnaW4teCcpLnBmVmFsdWU7XG4gICAgICB2YXIgb3kgPSBlbGUucHN0eWxlKHByZWZpeERhc2ggKyAndGV4dC1tYXJnaW4teScpLnBmVmFsdWU7XG4gICAgICB2YXIgbHgxID0gYmIueDEgLSB0aCAtIG94OyAvLyAoLW94LCAtb3kpIGFzIGJiIGFscmVhZHkgaW5jbHVkZXMgbWFyZ2luXG5cbiAgICAgIHZhciBseDIgPSBiYi54MiArIHRoIC0gb3g7IC8vIGFuZCByb3RhdGlvbiBpcyBhYm91dCAobHgsIGx5KVxuXG4gICAgICB2YXIgbHkxID0gYmIueTEgLSB0aCAtIG95O1xuICAgICAgdmFyIGx5MiA9IGJiLnkyICsgdGggLSBveTtcblxuICAgICAgaWYgKHRoZXRhKSB7XG4gICAgICAgIHZhciBjb3MgPSBNYXRoLmNvcyh0aGV0YSk7XG4gICAgICAgIHZhciBzaW4gPSBNYXRoLnNpbih0aGV0YSk7XG5cbiAgICAgICAgdmFyIHJvdGF0ZSA9IGZ1bmN0aW9uIHJvdGF0ZSh4LCB5KSB7XG4gICAgICAgICAgeCA9IHggLSBseDtcbiAgICAgICAgICB5ID0geSAtIGx5O1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiB4ICogY29zIC0geSAqIHNpbiArIGx4LFxuICAgICAgICAgICAgeTogeCAqIHNpbiArIHkgKiBjb3MgKyBseVxuICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHB4MXkxID0gcm90YXRlKGx4MSwgbHkxKTtcbiAgICAgICAgdmFyIHB4MXkyID0gcm90YXRlKGx4MSwgbHkyKTtcbiAgICAgICAgdmFyIHB4MnkxID0gcm90YXRlKGx4MiwgbHkxKTtcbiAgICAgICAgdmFyIHB4MnkyID0gcm90YXRlKGx4MiwgbHkyKTtcbiAgICAgICAgdmFyIHBvaW50cyA9IFsvLyB3aXRoIHRoZSBtYXJnaW4gYWRkZWQgYWZ0ZXIgdGhlIHJvdGF0aW9uIGlzIGFwcGxpZWRcbiAgICAgICAgcHgxeTEueCArIG94LCBweDF5MS55ICsgb3ksIHB4MnkxLnggKyBveCwgcHgyeTEueSArIG95LCBweDJ5Mi54ICsgb3gsIHB4MnkyLnkgKyBveSwgcHgxeTIueCArIG94LCBweDF5Mi55ICsgb3ldO1xuXG4gICAgICAgIGlmIChwb2ludEluc2lkZVBvbHlnb25Qb2ludHMoeCwgeSwgcG9pbnRzKSkge1xuICAgICAgICAgIGFkZEVsZShlbGUpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkbyBhIGNoZWFwZXIgYmIgY2hlY2tcbiAgICAgICAgaWYgKGluQm91bmRpbmdCb3goYmIsIHgsIHkpKSB7XG4gICAgICAgICAgYWRkRWxlKGVsZSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gZWxlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgLy8gcmV2ZXJzZSBvcmRlciBmb3IgcHJlY2VkZW5jZVxuICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG5cbiAgICAgIGlmIChlbGUuaXNOb2RlKCkpIHtcbiAgICAgICAgY2hlY2tOb2RlKGVsZSkgfHwgY2hlY2tMYWJlbChlbGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdGhlbiBlZGdlXG4gICAgICAgIGNoZWNrRWRnZShlbGUpIHx8IGNoZWNrTGFiZWwoZWxlKSB8fCBjaGVja0xhYmVsKGVsZSwgJ3NvdXJjZScpIHx8IGNoZWNrTGFiZWwoZWxlLCAndGFyZ2V0Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5lYXI7XG4gIH07IC8vICdHaXZlIG1lIGV2ZXJ5dGhpbmcgZnJvbSB0aGlzIGJveCdcblxuXG4gIEJScCRlLmdldEFsbEluQm94ID0gZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgdmFyIGVsZXMgPSB0aGlzLmdldENhY2hlZFpTb3J0ZWRFbGVzKCkuaW50ZXJhY3RpdmU7XG4gICAgdmFyIGJveCA9IFtdO1xuICAgIHZhciB4MWMgPSBNYXRoLm1pbih4MSwgeDIpO1xuICAgIHZhciB4MmMgPSBNYXRoLm1heCh4MSwgeDIpO1xuICAgIHZhciB5MWMgPSBNYXRoLm1pbih5MSwgeTIpO1xuICAgIHZhciB5MmMgPSBNYXRoLm1heCh5MSwgeTIpO1xuICAgIHgxID0geDFjO1xuICAgIHgyID0geDJjO1xuICAgIHkxID0geTFjO1xuICAgIHkyID0geTJjO1xuICAgIHZhciBib3hCYiA9IG1ha2VCb3VuZGluZ0JveCh7XG4gICAgICB4MTogeDEsXG4gICAgICB5MTogeTEsXG4gICAgICB4MjogeDIsXG4gICAgICB5MjogeTJcbiAgICB9KTtcblxuICAgIGZvciAodmFyIGUgPSAwOyBlIDwgZWxlcy5sZW5ndGg7IGUrKykge1xuICAgICAgdmFyIGVsZSA9IGVsZXNbZV07XG5cbiAgICAgIGlmIChlbGUuaXNOb2RlKCkpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBlbGU7XG4gICAgICAgIHZhciBub2RlQmIgPSBub2RlLmJvdW5kaW5nQm94KHtcbiAgICAgICAgICBpbmNsdWRlTm9kZXM6IHRydWUsXG4gICAgICAgICAgaW5jbHVkZUVkZ2VzOiBmYWxzZSxcbiAgICAgICAgICBpbmNsdWRlTGFiZWxzOiBmYWxzZVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoYm91bmRpbmdCb3hlc0ludGVyc2VjdChib3hCYiwgbm9kZUJiKSAmJiAhYm91bmRpbmdCb3hJbkJvdW5kaW5nQm94KG5vZGVCYiwgYm94QmIpKSB7XG4gICAgICAgICAgYm94LnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBlZGdlID0gZWxlO1xuICAgICAgICB2YXIgX3AgPSBlZGdlLl9wcml2YXRlO1xuICAgICAgICB2YXIgcnMgPSBfcC5yc2NyYXRjaDtcblxuICAgICAgICBpZiAocnMuc3RhcnRYICE9IG51bGwgJiYgcnMuc3RhcnRZICE9IG51bGwgJiYgIWluQm91bmRpbmdCb3goYm94QmIsIHJzLnN0YXJ0WCwgcnMuc3RhcnRZKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJzLmVuZFggIT0gbnVsbCAmJiBycy5lbmRZICE9IG51bGwgJiYgIWluQm91bmRpbmdCb3goYm94QmIsIHJzLmVuZFgsIHJzLmVuZFkpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocnMuZWRnZVR5cGUgPT09ICdiZXppZXInIHx8IHJzLmVkZ2VUeXBlID09PSAnbXVsdGliZXppZXInIHx8IHJzLmVkZ2VUeXBlID09PSAnc2VsZicgfHwgcnMuZWRnZVR5cGUgPT09ICdjb21wb3VuZCcgfHwgcnMuZWRnZVR5cGUgPT09ICdzZWdtZW50cycgfHwgcnMuZWRnZVR5cGUgPT09ICdoYXlzdGFjaycpIHtcbiAgICAgICAgICB2YXIgcHRzID0gX3AucnN0eWxlLmJlemllclB0cyB8fCBfcC5yc3R5bGUubGluZVB0cyB8fCBfcC5yc3R5bGUuaGF5c3RhY2tQdHM7XG4gICAgICAgICAgdmFyIGFsbEluc2lkZSA9IHRydWU7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHB0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCFwb2ludEluQm91bmRpbmdCb3goYm94QmIsIHB0c1tpXSkpIHtcbiAgICAgICAgICAgICAgYWxsSW5zaWRlID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChhbGxJbnNpZGUpIHtcbiAgICAgICAgICAgIGJveC5wdXNoKGVkZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChycy5lZGdlVHlwZSA9PT0gJ2hheXN0YWNrJyB8fCBycy5lZGdlVHlwZSA9PT0gJ3N0cmFpZ2h0Jykge1xuICAgICAgICAgIGJveC5wdXNoKGVkZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGJveDtcbiAgfTtcblxuICB2YXIgQlJwJGQgPSB7fTtcblxuICBCUnAkZC5jYWxjdWxhdGVBcnJvd0FuZ2xlcyA9IGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICB2YXIgaXNIYXlzdGFjayA9IHJzLmVkZ2VUeXBlID09PSAnaGF5c3RhY2snO1xuICAgIHZhciBpc0JlemllciA9IHJzLmVkZ2VUeXBlID09PSAnYmV6aWVyJztcbiAgICB2YXIgaXNNdWx0aWJlemllciA9IHJzLmVkZ2VUeXBlID09PSAnbXVsdGliZXppZXInO1xuICAgIHZhciBpc1NlZ21lbnRzID0gcnMuZWRnZVR5cGUgPT09ICdzZWdtZW50cyc7XG4gICAgdmFyIGlzQ29tcG91bmQgPSBycy5lZGdlVHlwZSA9PT0gJ2NvbXBvdW5kJztcbiAgICB2YXIgaXNTZWxmID0gcnMuZWRnZVR5cGUgPT09ICdzZWxmJzsgLy8gRGlzcGxhY2VtZW50IGdpdmVzIGRpcmVjdGlvbiBmb3IgYXJyb3doZWFkIG9yaWVudGF0aW9uXG5cbiAgICB2YXIgZGlzcFgsIGRpc3BZO1xuICAgIHZhciBzdGFydFgsIHN0YXJ0WSwgZW5kWCwgZW5kWSwgbWlkWCwgbWlkWTtcblxuICAgIGlmIChpc0hheXN0YWNrKSB7XG4gICAgICBzdGFydFggPSBycy5oYXlzdGFja1B0c1swXTtcbiAgICAgIHN0YXJ0WSA9IHJzLmhheXN0YWNrUHRzWzFdO1xuICAgICAgZW5kWCA9IHJzLmhheXN0YWNrUHRzWzJdO1xuICAgICAgZW5kWSA9IHJzLmhheXN0YWNrUHRzWzNdO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydFggPSBycy5hcnJvd1N0YXJ0WDtcbiAgICAgIHN0YXJ0WSA9IHJzLmFycm93U3RhcnRZO1xuICAgICAgZW5kWCA9IHJzLmFycm93RW5kWDtcbiAgICAgIGVuZFkgPSBycy5hcnJvd0VuZFk7XG4gICAgfVxuXG4gICAgbWlkWCA9IHJzLm1pZFg7XG4gICAgbWlkWSA9IHJzLm1pZFk7IC8vIHNvdXJjZVxuICAgIC8vXG5cbiAgICBpZiAoaXNTZWdtZW50cykge1xuICAgICAgZGlzcFggPSBzdGFydFggLSBycy5zZWdwdHNbMF07XG4gICAgICBkaXNwWSA9IHN0YXJ0WSAtIHJzLnNlZ3B0c1sxXTtcbiAgICB9IGVsc2UgaWYgKGlzTXVsdGliZXppZXIgfHwgaXNDb21wb3VuZCB8fCBpc1NlbGYgfHwgaXNCZXppZXIpIHtcbiAgICAgIHZhciBwdHMgPSBycy5hbGxwdHM7XG4gICAgICB2YXIgYlggPSBxYmV6aWVyQXQocHRzWzBdLCBwdHNbMl0sIHB0c1s0XSwgMC4xKTtcbiAgICAgIHZhciBiWSA9IHFiZXppZXJBdChwdHNbMV0sIHB0c1szXSwgcHRzWzVdLCAwLjEpO1xuICAgICAgZGlzcFggPSBzdGFydFggLSBiWDtcbiAgICAgIGRpc3BZID0gc3RhcnRZIC0gYlk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpc3BYID0gc3RhcnRYIC0gbWlkWDtcbiAgICAgIGRpc3BZID0gc3RhcnRZIC0gbWlkWTtcbiAgICB9XG5cbiAgICBycy5zcmNBcnJvd0FuZ2xlID0gZ2V0QW5nbGVGcm9tRGlzcChkaXNwWCwgZGlzcFkpOyAvLyBtaWQgdGFyZ2V0XG4gICAgLy9cblxuICAgIHZhciBtaWRYID0gcnMubWlkWDtcbiAgICB2YXIgbWlkWSA9IHJzLm1pZFk7XG5cbiAgICBpZiAoaXNIYXlzdGFjaykge1xuICAgICAgbWlkWCA9IChzdGFydFggKyBlbmRYKSAvIDI7XG4gICAgICBtaWRZID0gKHN0YXJ0WSArIGVuZFkpIC8gMjtcbiAgICB9XG5cbiAgICBkaXNwWCA9IGVuZFggLSBzdGFydFg7XG4gICAgZGlzcFkgPSBlbmRZIC0gc3RhcnRZO1xuXG4gICAgaWYgKGlzU2VnbWVudHMpIHtcbiAgICAgIHZhciBwdHMgPSBycy5hbGxwdHM7XG5cbiAgICAgIGlmIChwdHMubGVuZ3RoIC8gMiAlIDIgPT09IDApIHtcbiAgICAgICAgdmFyIGkyID0gcHRzLmxlbmd0aCAvIDI7XG4gICAgICAgIHZhciBpMSA9IGkyIC0gMjtcbiAgICAgICAgZGlzcFggPSBwdHNbaTJdIC0gcHRzW2kxXTtcbiAgICAgICAgZGlzcFkgPSBwdHNbaTIgKyAxXSAtIHB0c1tpMSArIDFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGkyID0gcHRzLmxlbmd0aCAvIDIgLSAxO1xuICAgICAgICB2YXIgaTEgPSBpMiAtIDI7XG4gICAgICAgIHZhciBpMyA9IGkyICsgMjtcbiAgICAgICAgZGlzcFggPSBwdHNbaTJdIC0gcHRzW2kxXTtcbiAgICAgICAgZGlzcFkgPSBwdHNbaTIgKyAxXSAtIHB0c1tpMSArIDFdO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNNdWx0aWJlemllciB8fCBpc0NvbXBvdW5kIHx8IGlzU2VsZikge1xuICAgICAgdmFyIHB0cyA9IHJzLmFsbHB0cztcbiAgICAgIHZhciBjcHRzID0gcnMuY3RybHB0cztcbiAgICAgIHZhciBicDB4LCBicDB5O1xuICAgICAgdmFyIGJwMXgsIGJwMXk7XG5cbiAgICAgIGlmIChjcHRzLmxlbmd0aCAvIDIgJSAyID09PSAwKSB7XG4gICAgICAgIHZhciBwMCA9IHB0cy5sZW5ndGggLyAyIC0gMTsgLy8gc3RhcnRwdFxuXG4gICAgICAgIHZhciBpYyA9IHAwICsgMjtcbiAgICAgICAgdmFyIHAxID0gaWMgKyAyO1xuICAgICAgICBicDB4ID0gcWJlemllckF0KHB0c1twMF0sIHB0c1tpY10sIHB0c1twMV0sIDAuMCk7XG4gICAgICAgIGJwMHkgPSBxYmV6aWVyQXQocHRzW3AwICsgMV0sIHB0c1tpYyArIDFdLCBwdHNbcDEgKyAxXSwgMC4wKTtcbiAgICAgICAgYnAxeCA9IHFiZXppZXJBdChwdHNbcDBdLCBwdHNbaWNdLCBwdHNbcDFdLCAwLjAwMDEpO1xuICAgICAgICBicDF5ID0gcWJlemllckF0KHB0c1twMCArIDFdLCBwdHNbaWMgKyAxXSwgcHRzW3AxICsgMV0sIDAuMDAwMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaWMgPSBwdHMubGVuZ3RoIC8gMiAtIDE7IC8vIGN0cnB0XG5cbiAgICAgICAgdmFyIHAwID0gaWMgLSAyOyAvLyBzdGFydHB0XG5cbiAgICAgICAgdmFyIHAxID0gaWMgKyAyOyAvLyBlbmRwdFxuXG4gICAgICAgIGJwMHggPSBxYmV6aWVyQXQocHRzW3AwXSwgcHRzW2ljXSwgcHRzW3AxXSwgMC40OTk5KTtcbiAgICAgICAgYnAweSA9IHFiZXppZXJBdChwdHNbcDAgKyAxXSwgcHRzW2ljICsgMV0sIHB0c1twMSArIDFdLCAwLjQ5OTkpO1xuICAgICAgICBicDF4ID0gcWJlemllckF0KHB0c1twMF0sIHB0c1tpY10sIHB0c1twMV0sIDAuNSk7XG4gICAgICAgIGJwMXkgPSBxYmV6aWVyQXQocHRzW3AwICsgMV0sIHB0c1tpYyArIDFdLCBwdHNbcDEgKyAxXSwgMC41KTtcbiAgICAgIH1cblxuICAgICAgZGlzcFggPSBicDF4IC0gYnAweDtcbiAgICAgIGRpc3BZID0gYnAxeSAtIGJwMHk7XG4gICAgfVxuXG4gICAgcnMubWlkdGd0QXJyb3dBbmdsZSA9IGdldEFuZ2xlRnJvbURpc3AoZGlzcFgsIGRpc3BZKTtcbiAgICBycy5taWREaXNwWCA9IGRpc3BYO1xuICAgIHJzLm1pZERpc3BZID0gZGlzcFk7IC8vIG1pZCBzb3VyY2VcbiAgICAvL1xuXG4gICAgZGlzcFggKj0gLTE7XG4gICAgZGlzcFkgKj0gLTE7XG5cbiAgICBpZiAoaXNTZWdtZW50cykge1xuICAgICAgdmFyIHB0cyA9IHJzLmFsbHB0cztcblxuICAgICAgaWYgKHB0cy5sZW5ndGggLyAyICUgMiA9PT0gMCkgOyBlbHNlIHtcbiAgICAgICAgdmFyIGkyID0gcHRzLmxlbmd0aCAvIDIgLSAxO1xuICAgICAgICB2YXIgaTMgPSBpMiArIDI7XG4gICAgICAgIGRpc3BYID0gLShwdHNbaTNdIC0gcHRzW2kyXSk7XG4gICAgICAgIGRpc3BZID0gLShwdHNbaTMgKyAxXSAtIHB0c1tpMiArIDFdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBycy5taWRzcmNBcnJvd0FuZ2xlID0gZ2V0QW5nbGVGcm9tRGlzcChkaXNwWCwgZGlzcFkpOyAvLyB0YXJnZXRcbiAgICAvL1xuXG4gICAgaWYgKGlzU2VnbWVudHMpIHtcbiAgICAgIGRpc3BYID0gZW5kWCAtIHJzLnNlZ3B0c1tycy5zZWdwdHMubGVuZ3RoIC0gMl07XG4gICAgICBkaXNwWSA9IGVuZFkgLSBycy5zZWdwdHNbcnMuc2VncHRzLmxlbmd0aCAtIDFdO1xuICAgIH0gZWxzZSBpZiAoaXNNdWx0aWJlemllciB8fCBpc0NvbXBvdW5kIHx8IGlzU2VsZiB8fCBpc0Jlemllcikge1xuICAgICAgdmFyIHB0cyA9IHJzLmFsbHB0cztcbiAgICAgIHZhciBsID0gcHRzLmxlbmd0aDtcbiAgICAgIHZhciBiWCA9IHFiZXppZXJBdChwdHNbbCAtIDZdLCBwdHNbbCAtIDRdLCBwdHNbbCAtIDJdLCAwLjkpO1xuICAgICAgdmFyIGJZID0gcWJlemllckF0KHB0c1tsIC0gNV0sIHB0c1tsIC0gM10sIHB0c1tsIC0gMV0sIDAuOSk7XG4gICAgICBkaXNwWCA9IGVuZFggLSBiWDtcbiAgICAgIGRpc3BZID0gZW5kWSAtIGJZO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaXNwWCA9IGVuZFggLSBtaWRYO1xuICAgICAgZGlzcFkgPSBlbmRZIC0gbWlkWTtcbiAgICB9XG5cbiAgICBycy50Z3RBcnJvd0FuZ2xlID0gZ2V0QW5nbGVGcm9tRGlzcChkaXNwWCwgZGlzcFkpO1xuICB9O1xuXG4gIEJScCRkLmdldEFycm93V2lkdGggPSBCUnAkZC5nZXRBcnJvd0hlaWdodCA9IGZ1bmN0aW9uIChlZGdlV2lkdGgsIHNjYWxlKSB7XG4gICAgdmFyIGNhY2hlID0gdGhpcy5hcnJvd1dpZHRoQ2FjaGUgPSB0aGlzLmFycm93V2lkdGhDYWNoZSB8fCB7fTtcbiAgICB2YXIgY2FjaGVkVmFsID0gY2FjaGVbZWRnZVdpZHRoICsgJywgJyArIHNjYWxlXTtcblxuICAgIGlmIChjYWNoZWRWYWwpIHtcbiAgICAgIHJldHVybiBjYWNoZWRWYWw7XG4gICAgfVxuXG4gICAgY2FjaGVkVmFsID0gTWF0aC5tYXgoTWF0aC5wb3coZWRnZVdpZHRoICogMTMuMzcsIDAuOSksIDI5KSAqIHNjYWxlO1xuICAgIGNhY2hlW2VkZ2VXaWR0aCArICcsICcgKyBzY2FsZV0gPSBjYWNoZWRWYWw7XG4gICAgcmV0dXJuIGNhY2hlZFZhbDtcbiAgfTtcblxuICB2YXIgQlJwJGMgPSB7fTtcblxuICBCUnAkYy5maW5kSGF5c3RhY2tQb2ludHMgPSBmdW5jdGlvbiAoZWRnZXMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWRnZSA9IGVkZ2VzW2ldO1xuICAgICAgdmFyIF9wID0gZWRnZS5fcHJpdmF0ZTtcbiAgICAgIHZhciBycyA9IF9wLnJzY3JhdGNoO1xuXG4gICAgICBpZiAoIXJzLmhheXN0YWNrKSB7XG4gICAgICAgIHZhciBhbmdsZSA9IE1hdGgucmFuZG9tKCkgKiAyICogTWF0aC5QSTtcbiAgICAgICAgcnMuc291cmNlID0ge1xuICAgICAgICAgIHg6IE1hdGguY29zKGFuZ2xlKSxcbiAgICAgICAgICB5OiBNYXRoLnNpbihhbmdsZSlcbiAgICAgICAgfTtcbiAgICAgICAgYW5nbGUgPSBNYXRoLnJhbmRvbSgpICogMiAqIE1hdGguUEk7XG4gICAgICAgIHJzLnRhcmdldCA9IHtcbiAgICAgICAgICB4OiBNYXRoLmNvcyhhbmdsZSksXG4gICAgICAgICAgeTogTWF0aC5zaW4oYW5nbGUpXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHZhciBzcmMgPSBfcC5zb3VyY2U7XG4gICAgICB2YXIgdGd0ID0gX3AudGFyZ2V0O1xuICAgICAgdmFyIHNyY1BvcyA9IHNyYy5wb3NpdGlvbigpO1xuICAgICAgdmFyIHRndFBvcyA9IHRndC5wb3NpdGlvbigpO1xuICAgICAgdmFyIHNyY1cgPSBzcmMud2lkdGgoKTtcbiAgICAgIHZhciB0Z3RXID0gdGd0LndpZHRoKCk7XG4gICAgICB2YXIgc3JjSCA9IHNyYy5oZWlnaHQoKTtcbiAgICAgIHZhciB0Z3RIID0gdGd0LmhlaWdodCgpO1xuICAgICAgdmFyIHJhZGl1cyA9IGVkZ2UucHN0eWxlKCdoYXlzdGFjay1yYWRpdXMnKS52YWx1ZTtcbiAgICAgIHZhciBoYWxmUmFkaXVzID0gcmFkaXVzIC8gMjsgLy8gYi9jIGhhdmUgdG8gaGFsZiB3aWR0aC9oZWlnaHRcblxuICAgICAgcnMuaGF5c3RhY2tQdHMgPSBycy5hbGxwdHMgPSBbcnMuc291cmNlLnggKiBzcmNXICogaGFsZlJhZGl1cyArIHNyY1Bvcy54LCBycy5zb3VyY2UueSAqIHNyY0ggKiBoYWxmUmFkaXVzICsgc3JjUG9zLnksIHJzLnRhcmdldC54ICogdGd0VyAqIGhhbGZSYWRpdXMgKyB0Z3RQb3MueCwgcnMudGFyZ2V0LnkgKiB0Z3RIICogaGFsZlJhZGl1cyArIHRndFBvcy55XTtcbiAgICAgIHJzLm1pZFggPSAocnMuYWxscHRzWzBdICsgcnMuYWxscHRzWzJdKSAvIDI7XG4gICAgICBycy5taWRZID0gKHJzLmFsbHB0c1sxXSArIHJzLmFsbHB0c1szXSkgLyAyOyAvLyBhbHdheXMgb3ZlcnJpZGUgYXMgaGF5c3RhY2sgaW4gY2FzZSBzZXQgdG8gZGlmZmVyZW50IHR5cGUgcHJldmlvdXNseVxuXG4gICAgICBycy5lZGdlVHlwZSA9ICdoYXlzdGFjayc7XG4gICAgICBycy5oYXlzdGFjayA9IHRydWU7XG4gICAgICB0aGlzLnN0b3JlRWRnZVByb2plY3Rpb25zKGVkZ2UpO1xuICAgICAgdGhpcy5jYWxjdWxhdGVBcnJvd0FuZ2xlcyhlZGdlKTtcbiAgICAgIHRoaXMucmVjYWxjdWxhdGVFZGdlTGFiZWxQcm9qZWN0aW9ucyhlZGdlKTtcbiAgICAgIHRoaXMuY2FsY3VsYXRlTGFiZWxBbmdsZXMoZWRnZSk7XG4gICAgfVxuICB9O1xuXG4gIEJScCRjLmZpbmRTZWdtZW50c1BvaW50cyA9IGZ1bmN0aW9uIChlZGdlLCBwYWlySW5mbykge1xuICAgIC8vIFNlZ21lbnRzIChtdWx0aXBsZSBzdHJhaWdodCBsaW5lcylcbiAgICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICAgIHZhciBwb3NQdHMgPSBwYWlySW5mby5wb3NQdHMsXG4gICAgICAgIGludGVyc2VjdGlvblB0cyA9IHBhaXJJbmZvLmludGVyc2VjdGlvblB0cyxcbiAgICAgICAgdmVjdG9yTm9ybUludmVyc2UgPSBwYWlySW5mby52ZWN0b3JOb3JtSW52ZXJzZTtcbiAgICB2YXIgZWRnZURpc3RhbmNlcyA9IGVkZ2UucHN0eWxlKCdlZGdlLWRpc3RhbmNlcycpLnZhbHVlO1xuICAgIHZhciBzZWdtZW50V3MgPSBlZGdlLnBzdHlsZSgnc2VnbWVudC13ZWlnaHRzJyk7XG4gICAgdmFyIHNlZ21lbnREcyA9IGVkZ2UucHN0eWxlKCdzZWdtZW50LWRpc3RhbmNlcycpO1xuICAgIHZhciBzZWdtZW50c04gPSBNYXRoLm1pbihzZWdtZW50V3MucGZWYWx1ZS5sZW5ndGgsIHNlZ21lbnREcy5wZlZhbHVlLmxlbmd0aCk7XG4gICAgcnMuZWRnZVR5cGUgPSAnc2VnbWVudHMnO1xuICAgIHJzLnNlZ3B0cyA9IFtdO1xuXG4gICAgZm9yICh2YXIgcyA9IDA7IHMgPCBzZWdtZW50c047IHMrKykge1xuICAgICAgdmFyIHcgPSBzZWdtZW50V3MucGZWYWx1ZVtzXTtcbiAgICAgIHZhciBkID0gc2VnbWVudERzLnBmVmFsdWVbc107XG4gICAgICB2YXIgdzEgPSAxIC0gdztcbiAgICAgIHZhciB3MiA9IHc7XG4gICAgICB2YXIgbWlkcHRQdHMgPSBlZGdlRGlzdGFuY2VzID09PSAnbm9kZS1wb3NpdGlvbicgPyBwb3NQdHMgOiBpbnRlcnNlY3Rpb25QdHM7XG4gICAgICB2YXIgYWRqdXN0ZWRNaWRwdCA9IHtcbiAgICAgICAgeDogbWlkcHRQdHMueDEgKiB3MSArIG1pZHB0UHRzLngyICogdzIsXG4gICAgICAgIHk6IG1pZHB0UHRzLnkxICogdzEgKyBtaWRwdFB0cy55MiAqIHcyXG4gICAgICB9O1xuICAgICAgcnMuc2VncHRzLnB1c2goYWRqdXN0ZWRNaWRwdC54ICsgdmVjdG9yTm9ybUludmVyc2UueCAqIGQsIGFkanVzdGVkTWlkcHQueSArIHZlY3Rvck5vcm1JbnZlcnNlLnkgKiBkKTtcbiAgICB9XG4gIH07XG5cbiAgQlJwJGMuZmluZExvb3BQb2ludHMgPSBmdW5jdGlvbiAoZWRnZSwgcGFpckluZm8sIGksIGVkZ2VJc1VuYnVuZGxlZCkge1xuICAgIC8vIFNlbGYtZWRnZVxuICAgIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgdmFyIGRpckNvdW50cyA9IHBhaXJJbmZvLmRpckNvdW50cyxcbiAgICAgICAgc3JjUG9zID0gcGFpckluZm8uc3JjUG9zO1xuICAgIHZhciBjdHJscHREaXN0cyA9IGVkZ2UucHN0eWxlKCdjb250cm9sLXBvaW50LWRpc3RhbmNlcycpO1xuICAgIHZhciBjdHJscHREaXN0ID0gY3RybHB0RGlzdHMgPyBjdHJscHREaXN0cy5wZlZhbHVlWzBdIDogdW5kZWZpbmVkO1xuICAgIHZhciBsb29wRGlyID0gZWRnZS5wc3R5bGUoJ2xvb3AtZGlyZWN0aW9uJykucGZWYWx1ZTtcbiAgICB2YXIgbG9vcFN3cCA9IGVkZ2UucHN0eWxlKCdsb29wLXN3ZWVwJykucGZWYWx1ZTtcbiAgICB2YXIgc3RlcFNpemUgPSBlZGdlLnBzdHlsZSgnY29udHJvbC1wb2ludC1zdGVwLXNpemUnKS5wZlZhbHVlO1xuICAgIHJzLmVkZ2VUeXBlID0gJ3NlbGYnO1xuICAgIHZhciBqID0gaTtcbiAgICB2YXIgbG9vcERpc3QgPSBzdGVwU2l6ZTtcblxuICAgIGlmIChlZGdlSXNVbmJ1bmRsZWQpIHtcbiAgICAgIGogPSAwO1xuICAgICAgbG9vcERpc3QgPSBjdHJscHREaXN0O1xuICAgIH1cblxuICAgIHZhciBsb29wQW5nbGUgPSBsb29wRGlyIC0gTWF0aC5QSSAvIDI7XG4gICAgdmFyIG91dEFuZ2xlID0gbG9vcEFuZ2xlIC0gbG9vcFN3cCAvIDI7XG4gICAgdmFyIGluQW5nbGUgPSBsb29wQW5nbGUgKyBsb29wU3dwIC8gMjsgLy8gaW5jcmVhc2UgYnkgc3RlcCBzaXplIGZvciBvdmVybGFwcGluZyBsb29wcywga2V5ZWQgb24gZGlyZWN0aW9uIGFuZCBzd2VlcCB2YWx1ZXNcblxuICAgIHZhciBkYyA9IFN0cmluZyhsb29wRGlyICsgJ18nICsgbG9vcFN3cCk7XG4gICAgaiA9IGRpckNvdW50c1tkY10gPT09IHVuZGVmaW5lZCA/IGRpckNvdW50c1tkY10gPSAwIDogKytkaXJDb3VudHNbZGNdO1xuICAgIHJzLmN0cmxwdHMgPSBbc3JjUG9zLnggKyBNYXRoLmNvcyhvdXRBbmdsZSkgKiAxLjQgKiBsb29wRGlzdCAqIChqIC8gMyArIDEpLCBzcmNQb3MueSArIE1hdGguc2luKG91dEFuZ2xlKSAqIDEuNCAqIGxvb3BEaXN0ICogKGogLyAzICsgMSksIHNyY1Bvcy54ICsgTWF0aC5jb3MoaW5BbmdsZSkgKiAxLjQgKiBsb29wRGlzdCAqIChqIC8gMyArIDEpLCBzcmNQb3MueSArIE1hdGguc2luKGluQW5nbGUpICogMS40ICogbG9vcERpc3QgKiAoaiAvIDMgKyAxKV07XG4gIH07XG5cbiAgQlJwJGMuZmluZENvbXBvdW5kTG9vcFBvaW50cyA9IGZ1bmN0aW9uIChlZGdlLCBwYWlySW5mbywgaSwgZWRnZUlzVW5idW5kbGVkKSB7XG4gICAgLy8gQ29tcG91bmQgZWRnZVxuICAgIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgcnMuZWRnZVR5cGUgPSAnY29tcG91bmQnO1xuICAgIHZhciBzcmNQb3MgPSBwYWlySW5mby5zcmNQb3MsXG4gICAgICAgIHRndFBvcyA9IHBhaXJJbmZvLnRndFBvcyxcbiAgICAgICAgc3JjVyA9IHBhaXJJbmZvLnNyY1csXG4gICAgICAgIHNyY0ggPSBwYWlySW5mby5zcmNILFxuICAgICAgICB0Z3RXID0gcGFpckluZm8udGd0VyxcbiAgICAgICAgdGd0SCA9IHBhaXJJbmZvLnRndEg7XG4gICAgdmFyIHN0ZXBTaXplID0gZWRnZS5wc3R5bGUoJ2NvbnRyb2wtcG9pbnQtc3RlcC1zaXplJykucGZWYWx1ZTtcbiAgICB2YXIgY3RybHB0RGlzdHMgPSBlZGdlLnBzdHlsZSgnY29udHJvbC1wb2ludC1kaXN0YW5jZXMnKTtcbiAgICB2YXIgY3RybHB0RGlzdCA9IGN0cmxwdERpc3RzID8gY3RybHB0RGlzdHMucGZWYWx1ZVswXSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgaiA9IGk7XG4gICAgdmFyIGxvb3BEaXN0ID0gc3RlcFNpemU7XG5cbiAgICBpZiAoZWRnZUlzVW5idW5kbGVkKSB7XG4gICAgICBqID0gMDtcbiAgICAgIGxvb3BEaXN0ID0gY3RybHB0RGlzdDtcbiAgICB9XG5cbiAgICB2YXIgbG9vcFcgPSA1MDtcbiAgICB2YXIgbG9vcGFQb3MgPSB7XG4gICAgICB4OiBzcmNQb3MueCAtIHNyY1cgLyAyLFxuICAgICAgeTogc3JjUG9zLnkgLSBzcmNIIC8gMlxuICAgIH07XG4gICAgdmFyIGxvb3BiUG9zID0ge1xuICAgICAgeDogdGd0UG9zLnggLSB0Z3RXIC8gMixcbiAgICAgIHk6IHRndFBvcy55IC0gdGd0SCAvIDJcbiAgICB9O1xuICAgIHZhciBsb29wUG9zID0ge1xuICAgICAgeDogTWF0aC5taW4obG9vcGFQb3MueCwgbG9vcGJQb3MueCksXG4gICAgICB5OiBNYXRoLm1pbihsb29wYVBvcy55LCBsb29wYlBvcy55KVxuICAgIH07IC8vIGF2b2lkcyBjYXNlcyB3aXRoIGltcG9zc2libGUgYmV6aWVyc1xuXG4gICAgdmFyIG1pbkNvbXBvdW5kU3RyZXRjaCA9IDAuNTtcbiAgICB2YXIgY29tcG91bmRTdHJldGNoQSA9IE1hdGgubWF4KG1pbkNvbXBvdW5kU3RyZXRjaCwgTWF0aC5sb2coc3JjVyAqIDAuMDEpKTtcbiAgICB2YXIgY29tcG91bmRTdHJldGNoQiA9IE1hdGgubWF4KG1pbkNvbXBvdW5kU3RyZXRjaCwgTWF0aC5sb2codGd0VyAqIDAuMDEpKTtcbiAgICBycy5jdHJscHRzID0gW2xvb3BQb3MueCwgbG9vcFBvcy55IC0gKDEgKyBNYXRoLnBvdyhsb29wVywgMS4xMikgLyAxMDApICogbG9vcERpc3QgKiAoaiAvIDMgKyAxKSAqIGNvbXBvdW5kU3RyZXRjaEEsIGxvb3BQb3MueCAtICgxICsgTWF0aC5wb3cobG9vcFcsIDEuMTIpIC8gMTAwKSAqIGxvb3BEaXN0ICogKGogLyAzICsgMSkgKiBjb21wb3VuZFN0cmV0Y2hCLCBsb29wUG9zLnldO1xuICB9O1xuXG4gIEJScCRjLmZpbmRTdHJhaWdodEVkZ2VQb2ludHMgPSBmdW5jdGlvbiAoZWRnZSkge1xuICAgIC8vIFN0cmFpZ2h0IGVkZ2Ugd2l0aGluIGJ1bmRsZVxuICAgIGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2guZWRnZVR5cGUgPSAnc3RyYWlnaHQnO1xuICB9O1xuXG4gIEJScCRjLmZpbmRCZXppZXJQb2ludHMgPSBmdW5jdGlvbiAoZWRnZSwgcGFpckluZm8sIGksIGVkZ2VJc1VuYnVuZGxlZCwgZWRnZUlzU3dhcHBlZCkge1xuICAgIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgdmFyIHZlY3Rvck5vcm1JbnZlcnNlID0gcGFpckluZm8udmVjdG9yTm9ybUludmVyc2UsXG4gICAgICAgIHBvc1B0cyA9IHBhaXJJbmZvLnBvc1B0cyxcbiAgICAgICAgaW50ZXJzZWN0aW9uUHRzID0gcGFpckluZm8uaW50ZXJzZWN0aW9uUHRzO1xuICAgIHZhciBlZGdlRGlzdGFuY2VzID0gZWRnZS5wc3R5bGUoJ2VkZ2UtZGlzdGFuY2VzJykudmFsdWU7XG4gICAgdmFyIHN0ZXBTaXplID0gZWRnZS5wc3R5bGUoJ2NvbnRyb2wtcG9pbnQtc3RlcC1zaXplJykucGZWYWx1ZTtcbiAgICB2YXIgY3RybHB0RGlzdHMgPSBlZGdlLnBzdHlsZSgnY29udHJvbC1wb2ludC1kaXN0YW5jZXMnKTtcbiAgICB2YXIgY3RybHB0V3MgPSBlZGdlLnBzdHlsZSgnY29udHJvbC1wb2ludC13ZWlnaHRzJyk7XG4gICAgdmFyIGJlemllck4gPSBjdHJscHREaXN0cyAmJiBjdHJscHRXcyA/IE1hdGgubWluKGN0cmxwdERpc3RzLnZhbHVlLmxlbmd0aCwgY3RybHB0V3MudmFsdWUubGVuZ3RoKSA6IDE7XG4gICAgdmFyIGN0cmxwdERpc3QgPSBjdHJscHREaXN0cyA/IGN0cmxwdERpc3RzLnBmVmFsdWVbMF0gOiB1bmRlZmluZWQ7XG4gICAgdmFyIGN0cmxwdFdlaWdodCA9IGN0cmxwdFdzLnZhbHVlWzBdOyAvLyAoTXVsdGkpYmV6aWVyXG5cbiAgICB2YXIgbXVsdGkgPSBlZGdlSXNVbmJ1bmRsZWQ7XG4gICAgcnMuZWRnZVR5cGUgPSBtdWx0aSA/ICdtdWx0aWJlemllcicgOiAnYmV6aWVyJztcbiAgICBycy5jdHJscHRzID0gW107XG5cbiAgICBmb3IgKHZhciBiID0gMDsgYiA8IGJlemllck47IGIrKykge1xuICAgICAgdmFyIG5vcm1jdHJscHREaXN0ID0gKDAuNSAtIHBhaXJJbmZvLmVsZXMubGVuZ3RoIC8gMiArIGkpICogc3RlcFNpemUgKiAoZWRnZUlzU3dhcHBlZCA/IC0xIDogMSk7XG4gICAgICB2YXIgbWFuY3RybHB0RGlzdCA9IHZvaWQgMDtcbiAgICAgIHZhciBzaWduID0gc2lnbnVtKG5vcm1jdHJscHREaXN0KTtcblxuICAgICAgaWYgKG11bHRpKSB7XG4gICAgICAgIGN0cmxwdERpc3QgPSBjdHJscHREaXN0cyA/IGN0cmxwdERpc3RzLnBmVmFsdWVbYl0gOiBzdGVwU2l6ZTsgLy8gZmFsbCBiYWNrIG9uIHN0ZXAgc2l6ZVxuXG4gICAgICAgIGN0cmxwdFdlaWdodCA9IGN0cmxwdFdzLnZhbHVlW2JdO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWRnZUlzVW5idW5kbGVkKSB7XG4gICAgICAgIC8vIG11bHRpIG9yIHNpbmdsZSB1bmJ1bmRsZWRcbiAgICAgICAgbWFuY3RybHB0RGlzdCA9IGN0cmxwdERpc3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYW5jdHJscHREaXN0ID0gY3RybHB0RGlzdCAhPT0gdW5kZWZpbmVkID8gc2lnbiAqIGN0cmxwdERpc3QgOiB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBkaXN0YW5jZUZyb21NaWRwb2ludCA9IG1hbmN0cmxwdERpc3QgIT09IHVuZGVmaW5lZCA/IG1hbmN0cmxwdERpc3QgOiBub3JtY3RybHB0RGlzdDtcbiAgICAgIHZhciB3MSA9IDEgLSBjdHJscHRXZWlnaHQ7XG4gICAgICB2YXIgdzIgPSBjdHJscHRXZWlnaHQ7XG4gICAgICB2YXIgbWlkcHRQdHMgPSBlZGdlRGlzdGFuY2VzID09PSAnbm9kZS1wb3NpdGlvbicgPyBwb3NQdHMgOiBpbnRlcnNlY3Rpb25QdHM7XG4gICAgICB2YXIgYWRqdXN0ZWRNaWRwdCA9IHtcbiAgICAgICAgeDogbWlkcHRQdHMueDEgKiB3MSArIG1pZHB0UHRzLngyICogdzIsXG4gICAgICAgIHk6IG1pZHB0UHRzLnkxICogdzEgKyBtaWRwdFB0cy55MiAqIHcyXG4gICAgICB9O1xuICAgICAgcnMuY3RybHB0cy5wdXNoKGFkanVzdGVkTWlkcHQueCArIHZlY3Rvck5vcm1JbnZlcnNlLnggKiBkaXN0YW5jZUZyb21NaWRwb2ludCwgYWRqdXN0ZWRNaWRwdC55ICsgdmVjdG9yTm9ybUludmVyc2UueSAqIGRpc3RhbmNlRnJvbU1pZHBvaW50KTtcbiAgICB9XG4gIH07XG5cbiAgQlJwJGMuZmluZFRheGlQb2ludHMgPSBmdW5jdGlvbiAoZWRnZSwgcGFpckluZm8pIHtcbiAgICAvLyBUYXhpY2FiIGdlb21ldHJ5IHdpdGggdHdvIHR1cm5zIG1heGltdW1cbiAgICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICAgIHJzLmVkZ2VUeXBlID0gJ3NlZ21lbnRzJztcbiAgICB2YXIgVkVSVElDQUwgPSAndmVydGljYWwnO1xuICAgIHZhciBIT1JJWk9OVEFMID0gJ2hvcml6b250YWwnO1xuICAgIHZhciBMRUZUV0FSRCA9ICdsZWZ0d2FyZCc7XG4gICAgdmFyIFJJR0hUV0FSRCA9ICdyaWdodHdhcmQnO1xuICAgIHZhciBET1dOV0FSRCA9ICdkb3dud2FyZCc7XG4gICAgdmFyIFVQV0FSRCA9ICd1cHdhcmQnO1xuICAgIHZhciBBVVRPID0gJ2F1dG8nO1xuICAgIHZhciBwb3NQdHMgPSBwYWlySW5mby5wb3NQdHMsXG4gICAgICAgIHNyY1cgPSBwYWlySW5mby5zcmNXLFxuICAgICAgICBzcmNIID0gcGFpckluZm8uc3JjSCxcbiAgICAgICAgdGd0VyA9IHBhaXJJbmZvLnRndFcsXG4gICAgICAgIHRndEggPSBwYWlySW5mby50Z3RIO1xuICAgIHZhciBlZGdlRGlzdGFuY2VzID0gZWRnZS5wc3R5bGUoJ2VkZ2UtZGlzdGFuY2VzJykudmFsdWU7XG4gICAgdmFyIGRJbmNsdWRlc05vZGVCb2R5ID0gZWRnZURpc3RhbmNlcyAhPT0gJ25vZGUtcG9zaXRpb24nO1xuICAgIHZhciB0YXhpRGlyID0gZWRnZS5wc3R5bGUoJ3RheGktZGlyZWN0aW9uJykudmFsdWU7XG4gICAgdmFyIHJhd1RheGlEaXIgPSB0YXhpRGlyOyAvLyB1bnByb2Nlc3NlZCB2YWx1ZVxuXG4gICAgdmFyIHRheGlUdXJuID0gZWRnZS5wc3R5bGUoJ3RheGktdHVybicpO1xuICAgIHZhciB0dXJuSXNQZXJjZW50ID0gdGF4aVR1cm4udW5pdHMgPT09ICclJztcbiAgICB2YXIgdGF4aVR1cm5QZlZhbCA9IHRheGlUdXJuLnBmVmFsdWU7XG4gICAgdmFyIHR1cm5Jc05lZ2F0aXZlID0gdGF4aVR1cm5QZlZhbCA8IDA7IC8vIGkuZS4gZnJvbSB0YXJnZXQgc2lkZVxuXG4gICAgdmFyIG1pbkQgPSBlZGdlLnBzdHlsZSgndGF4aS10dXJuLW1pbi1kaXN0YW5jZScpLnBmVmFsdWU7XG4gICAgdmFyIGR3ID0gZEluY2x1ZGVzTm9kZUJvZHkgPyAoc3JjVyArIHRndFcpIC8gMiA6IDA7XG4gICAgdmFyIGRoID0gZEluY2x1ZGVzTm9kZUJvZHkgPyAoc3JjSCArIHRndEgpIC8gMiA6IDA7XG4gICAgdmFyIHBkeCA9IHBvc1B0cy54MiAtIHBvc1B0cy54MTtcbiAgICB2YXIgcGR5ID0gcG9zUHRzLnkyIC0gcG9zUHRzLnkxOyAvLyB0YWtlIGF3YXkgdGhlIGVmZmVjdGl2ZSB3L2ggZnJvbSB0aGUgbWFnbml0dWRlIG9mIHRoZSBkZWx0YSB2YWx1ZVxuXG4gICAgdmFyIHN1YkRXSCA9IGZ1bmN0aW9uIHN1YkRXSChkeHksIGR3aCkge1xuICAgICAgaWYgKGR4eSA+IDApIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KGR4eSAtIGR3aCwgMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gTWF0aC5taW4oZHh5ICsgZHdoLCAwKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGR4ID0gc3ViRFdIKHBkeCwgZHcpO1xuICAgIHZhciBkeSA9IHN1YkRXSChwZHksIGRoKTtcbiAgICB2YXIgaXNFeHBsaWNpdERpciA9IGZhbHNlO1xuXG4gICAgaWYgKHJhd1RheGlEaXIgPT09IEFVVE8pIHtcbiAgICAgIHRheGlEaXIgPSBNYXRoLmFicyhkeCkgPiBNYXRoLmFicyhkeSkgPyBIT1JJWk9OVEFMIDogVkVSVElDQUw7XG4gICAgfSBlbHNlIGlmIChyYXdUYXhpRGlyID09PSBVUFdBUkQgfHwgcmF3VGF4aURpciA9PT0gRE9XTldBUkQpIHtcbiAgICAgIHRheGlEaXIgPSBWRVJUSUNBTDtcbiAgICAgIGlzRXhwbGljaXREaXIgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAocmF3VGF4aURpciA9PT0gTEVGVFdBUkQgfHwgcmF3VGF4aURpciA9PT0gUklHSFRXQVJEKSB7XG4gICAgICB0YXhpRGlyID0gSE9SSVpPTlRBTDtcbiAgICAgIGlzRXhwbGljaXREaXIgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBpc1ZlcnQgPSB0YXhpRGlyID09PSBWRVJUSUNBTDtcbiAgICB2YXIgbCA9IGlzVmVydCA/IGR5IDogZHg7XG4gICAgdmFyIHBsID0gaXNWZXJ0ID8gcGR5IDogcGR4O1xuICAgIHZhciBzZ25MID0gc2lnbnVtKHBsKTtcbiAgICB2YXIgZm9yY2VkRGlyID0gZmFsc2U7XG5cbiAgICBpZiAoIShpc0V4cGxpY2l0RGlyICYmICh0dXJuSXNQZXJjZW50IHx8IHR1cm5Jc05lZ2F0aXZlKSkgLy8gZm9yY2luZyBpbiB0aGlzIGNhc2Ugd291bGQgY2F1c2Ugd2VpcmQgZ3Jvd2luZyBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uXG4gICAgJiYgKHJhd1RheGlEaXIgPT09IERPV05XQVJEICYmIHBsIDwgMCB8fCByYXdUYXhpRGlyID09PSBVUFdBUkQgJiYgcGwgPiAwIHx8IHJhd1RheGlEaXIgPT09IExFRlRXQVJEICYmIHBsID4gMCB8fCByYXdUYXhpRGlyID09PSBSSUdIVFdBUkQgJiYgcGwgPCAwKSkge1xuICAgICAgc2duTCAqPSAtMTtcbiAgICAgIGwgPSBzZ25MICogTWF0aC5hYnMobCk7XG4gICAgICBmb3JjZWREaXIgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBkO1xuXG4gICAgaWYgKHR1cm5Jc1BlcmNlbnQpIHtcbiAgICAgIHZhciBwID0gdGF4aVR1cm5QZlZhbCA8IDAgPyAxICsgdGF4aVR1cm5QZlZhbCA6IHRheGlUdXJuUGZWYWw7XG4gICAgICBkID0gcCAqIGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrID0gdGF4aVR1cm5QZlZhbCA8IDAgPyBsIDogMDtcbiAgICAgIGQgPSBrICsgdGF4aVR1cm5QZlZhbCAqIHNnbkw7XG4gICAgfVxuXG4gICAgdmFyIGdldElzVG9vQ2xvc2UgPSBmdW5jdGlvbiBnZXRJc1Rvb0Nsb3NlKGQpIHtcbiAgICAgIHJldHVybiBNYXRoLmFicyhkKSA8IG1pbkQgfHwgTWF0aC5hYnMoZCkgPj0gTWF0aC5hYnMobCk7XG4gICAgfTtcblxuICAgIHZhciBpc1Rvb0Nsb3NlU3JjID0gZ2V0SXNUb29DbG9zZShkKTtcbiAgICB2YXIgaXNUb29DbG9zZVRndCA9IGdldElzVG9vQ2xvc2UoTWF0aC5hYnMobCkgLSBNYXRoLmFicyhkKSk7XG4gICAgdmFyIGlzVG9vQ2xvc2UgPSBpc1Rvb0Nsb3NlU3JjIHx8IGlzVG9vQ2xvc2VUZ3Q7XG5cbiAgICBpZiAoaXNUb29DbG9zZSAmJiAhZm9yY2VkRGlyKSB7XG4gICAgICAvLyBub24taWRlYWwgcm91dGluZ1xuICAgICAgaWYgKGlzVmVydCkge1xuICAgICAgICAvLyB2ZXJ0aWNhbCBmYWxsYmFja3NcbiAgICAgICAgdmFyIGxTaGFwZUluc2lkZVNyYyA9IE1hdGguYWJzKHBsKSA8PSBzcmNIIC8gMjtcbiAgICAgICAgdmFyIGxTaGFwZUluc2lkZVRndCA9IE1hdGguYWJzKHBkeCkgPD0gdGd0VyAvIDI7XG5cbiAgICAgICAgaWYgKGxTaGFwZUluc2lkZVNyYykge1xuICAgICAgICAgIC8vIGhvcml6b250YWwgWi1zaGFwZSAoZGlyZWN0aW9uIG5vdCByZXNwZWN0ZWQpXG4gICAgICAgICAgdmFyIHggPSAocG9zUHRzLngxICsgcG9zUHRzLngyKSAvIDI7XG4gICAgICAgICAgdmFyIHkxID0gcG9zUHRzLnkxLFxuICAgICAgICAgICAgICB5MiA9IHBvc1B0cy55MjtcbiAgICAgICAgICBycy5zZWdwdHMgPSBbeCwgeTEsIHgsIHkyXTtcbiAgICAgICAgfSBlbHNlIGlmIChsU2hhcGVJbnNpZGVUZ3QpIHtcbiAgICAgICAgICAvLyB2ZXJ0aWNhbCBaLXNoYXBlIChkaXN0YW5jZSBub3QgcmVzcGVjdGVkKVxuICAgICAgICAgIHZhciB5ID0gKHBvc1B0cy55MSArIHBvc1B0cy55MikgLyAyO1xuICAgICAgICAgIHZhciB4MSA9IHBvc1B0cy54MSxcbiAgICAgICAgICAgICAgeDIgPSBwb3NQdHMueDI7XG4gICAgICAgICAgcnMuc2VncHRzID0gW3gxLCB5LCB4MiwgeV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTC1zaGFwZSBmYWxsYmFjayAodHVybiBkaXN0YW5jZSBub3QgcmVzcGVjdGVkLCBidXQgd29ya3Mgd2VsbCB3aXRoIHRyZWUgc2libGluZ3MpXG4gICAgICAgICAgcnMuc2VncHRzID0gW3Bvc1B0cy54MSwgcG9zUHRzLnkyXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaG9yaXpvbnRhbCBmYWxsYmFja3NcbiAgICAgICAgdmFyIF9sU2hhcGVJbnNpZGVTcmMgPSBNYXRoLmFicyhwbCkgPD0gc3JjVyAvIDI7XG5cbiAgICAgICAgdmFyIF9sU2hhcGVJbnNpZGVUZ3QgPSBNYXRoLmFicyhwZHkpIDw9IHRndEggLyAyO1xuXG4gICAgICAgIGlmIChfbFNoYXBlSW5zaWRlU3JjKSB7XG4gICAgICAgICAgLy8gdmVydGljYWwgWi1zaGFwZSAoZGlyZWN0aW9uIG5vdCByZXNwZWN0ZWQpXG4gICAgICAgICAgdmFyIF95ID0gKHBvc1B0cy55MSArIHBvc1B0cy55MikgLyAyO1xuXG4gICAgICAgICAgdmFyIF94ID0gcG9zUHRzLngxLFxuICAgICAgICAgICAgICBfeDIgPSBwb3NQdHMueDI7XG4gICAgICAgICAgcnMuc2VncHRzID0gW194LCBfeSwgX3gyLCBfeV07XG4gICAgICAgIH0gZWxzZSBpZiAoX2xTaGFwZUluc2lkZVRndCkge1xuICAgICAgICAgIC8vIGhvcml6b250YWwgWi1zaGFwZSAodHVybiBkaXN0YW5jZSBub3QgcmVzcGVjdGVkKVxuICAgICAgICAgIHZhciBfeDMgPSAocG9zUHRzLngxICsgcG9zUHRzLngyKSAvIDI7XG5cbiAgICAgICAgICB2YXIgX3kyID0gcG9zUHRzLnkxLFxuICAgICAgICAgICAgICBfeTMgPSBwb3NQdHMueTI7XG4gICAgICAgICAgcnMuc2VncHRzID0gW194MywgX3kyLCBfeDMsIF95M107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTC1zaGFwZSAodHVybiBkaXN0YW5jZSBub3QgcmVzcGVjdGVkLCBidXQgd29ya3Mgd2VsbCBmb3IgdHJlZSBzaWJsaW5ncylcbiAgICAgICAgICBycy5zZWdwdHMgPSBbcG9zUHRzLngyLCBwb3NQdHMueTFdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlkZWFsIHJvdXRpbmdcbiAgICAgIGlmIChpc1ZlcnQpIHtcbiAgICAgICAgdmFyIF95NCA9IHBvc1B0cy55MSArIGQgKyAoZEluY2x1ZGVzTm9kZUJvZHkgPyBzcmNIIC8gMiAqIHNnbkwgOiAwKTtcblxuICAgICAgICB2YXIgX3g0ID0gcG9zUHRzLngxLFxuICAgICAgICAgICAgX3g1ID0gcG9zUHRzLngyO1xuICAgICAgICBycy5zZWdwdHMgPSBbX3g0LCBfeTQsIF94NSwgX3k0XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGhvcml6b250YWxcbiAgICAgICAgdmFyIF94NiA9IHBvc1B0cy54MSArIGQgKyAoZEluY2x1ZGVzTm9kZUJvZHkgPyBzcmNXIC8gMiAqIHNnbkwgOiAwKTtcblxuICAgICAgICB2YXIgX3k1ID0gcG9zUHRzLnkxLFxuICAgICAgICAgICAgX3k2ID0gcG9zUHRzLnkyO1xuICAgICAgICBycy5zZWdwdHMgPSBbX3g2LCBfeTUsIF94NiwgX3k2XTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgQlJwJGMudHJ5VG9Db3JyZWN0SW52YWxpZFBvaW50cyA9IGZ1bmN0aW9uIChlZGdlLCBwYWlySW5mbykge1xuICAgIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7IC8vIGNhbiBvbmx5IGNvcnJlY3QgYmV6aWVycyBmb3Igbm93Li4uXG5cbiAgICBpZiAocnMuZWRnZVR5cGUgPT09ICdiZXppZXInKSB7XG4gICAgICB2YXIgc3JjUG9zID0gcGFpckluZm8uc3JjUG9zLFxuICAgICAgICAgIHRndFBvcyA9IHBhaXJJbmZvLnRndFBvcyxcbiAgICAgICAgICBzcmNXID0gcGFpckluZm8uc3JjVyxcbiAgICAgICAgICBzcmNIID0gcGFpckluZm8uc3JjSCxcbiAgICAgICAgICB0Z3RXID0gcGFpckluZm8udGd0VyxcbiAgICAgICAgICB0Z3RIID0gcGFpckluZm8udGd0SCxcbiAgICAgICAgICBzcmNTaGFwZSA9IHBhaXJJbmZvLnNyY1NoYXBlLFxuICAgICAgICAgIHRndFNoYXBlID0gcGFpckluZm8udGd0U2hhcGU7XG4gICAgICB2YXIgYmFkU3RhcnQgPSAhbnVtYmVyJDEocnMuc3RhcnRYKSB8fCAhbnVtYmVyJDEocnMuc3RhcnRZKTtcbiAgICAgIHZhciBiYWRBU3RhcnQgPSAhbnVtYmVyJDEocnMuYXJyb3dTdGFydFgpIHx8ICFudW1iZXIkMShycy5hcnJvd1N0YXJ0WSk7XG4gICAgICB2YXIgYmFkRW5kID0gIW51bWJlciQxKHJzLmVuZFgpIHx8ICFudW1iZXIkMShycy5lbmRZKTtcbiAgICAgIHZhciBiYWRBRW5kID0gIW51bWJlciQxKHJzLmFycm93RW5kWCkgfHwgIW51bWJlciQxKHJzLmFycm93RW5kWSk7XG4gICAgICB2YXIgbWluQ3BBRGlzdEZhY3RvciA9IDM7XG4gICAgICB2YXIgYXJyb3dXID0gdGhpcy5nZXRBcnJvd1dpZHRoKGVkZ2UucHN0eWxlKCd3aWR0aCcpLnBmVmFsdWUsIGVkZ2UucHN0eWxlKCdhcnJvdy1zY2FsZScpLnZhbHVlKSAqIHRoaXMuYXJyb3dTaGFwZVdpZHRoO1xuICAgICAgdmFyIG1pbkNwQURpc3QgPSBtaW5DcEFEaXN0RmFjdG9yICogYXJyb3dXO1xuICAgICAgdmFyIHN0YXJ0QUNwRGlzdCA9IGRpc3Qoe1xuICAgICAgICB4OiBycy5jdHJscHRzWzBdLFxuICAgICAgICB5OiBycy5jdHJscHRzWzFdXG4gICAgICB9LCB7XG4gICAgICAgIHg6IHJzLnN0YXJ0WCxcbiAgICAgICAgeTogcnMuc3RhcnRZXG4gICAgICB9KTtcbiAgICAgIHZhciBjbG9zZVN0YXJ0QUNwID0gc3RhcnRBQ3BEaXN0IDwgbWluQ3BBRGlzdDtcbiAgICAgIHZhciBlbmRBQ3BEaXN0ID0gZGlzdCh7XG4gICAgICAgIHg6IHJzLmN0cmxwdHNbMF0sXG4gICAgICAgIHk6IHJzLmN0cmxwdHNbMV1cbiAgICAgIH0sIHtcbiAgICAgICAgeDogcnMuZW5kWCxcbiAgICAgICAgeTogcnMuZW5kWVxuICAgICAgfSk7XG4gICAgICB2YXIgY2xvc2VFbmRBQ3AgPSBlbmRBQ3BEaXN0IDwgbWluQ3BBRGlzdDtcbiAgICAgIHZhciBvdmVybGFwcGluZyA9IGZhbHNlO1xuXG4gICAgICBpZiAoYmFkU3RhcnQgfHwgYmFkQVN0YXJ0IHx8IGNsb3NlU3RhcnRBQ3ApIHtcbiAgICAgICAgb3ZlcmxhcHBpbmcgPSB0cnVlOyAvLyBwcm9qZWN0IGNvbnRyb2wgcG9pbnQgYWxvbmcgbGluZSBmcm9tIHNyYyBjZW50cmUgdG8gb3V0c2lkZSB0aGUgc3JjIHNoYXBlXG4gICAgICAgIC8vIChvdGhlcndpc2UgaW50ZXJzZWN0aW9uIHdpbGwgeWllbGQgbm90aGluZylcblxuICAgICAgICB2YXIgY3BEID0ge1xuICAgICAgICAgIC8vIGRlbHRhXG4gICAgICAgICAgeDogcnMuY3RybHB0c1swXSAtIHNyY1Bvcy54LFxuICAgICAgICAgIHk6IHJzLmN0cmxwdHNbMV0gLSBzcmNQb3MueVxuICAgICAgICB9O1xuICAgICAgICB2YXIgY3BMID0gTWF0aC5zcXJ0KGNwRC54ICogY3BELnggKyBjcEQueSAqIGNwRC55KTsgLy8gbGVuZ3RoIG9mIGxpbmVcblxuICAgICAgICB2YXIgY3BNID0ge1xuICAgICAgICAgIC8vIG5vcm1hbGlzZWQgZGVsdGFcbiAgICAgICAgICB4OiBjcEQueCAvIGNwTCxcbiAgICAgICAgICB5OiBjcEQueSAvIGNwTFxuICAgICAgICB9O1xuICAgICAgICB2YXIgcmFkaXVzID0gTWF0aC5tYXgoc3JjVywgc3JjSCk7XG4gICAgICAgIHZhciBjcFByb2ogPSB7XG4gICAgICAgICAgLy8gKjIgcmFkaXVzIGd1YXJhbnRlZXMgb3V0c2lkZSBzaGFwZVxuICAgICAgICAgIHg6IHJzLmN0cmxwdHNbMF0gKyBjcE0ueCAqIDIgKiByYWRpdXMsXG4gICAgICAgICAgeTogcnMuY3RybHB0c1sxXSArIGNwTS55ICogMiAqIHJhZGl1c1xuICAgICAgICB9O1xuICAgICAgICB2YXIgc3JjQ3RybFB0SW50biA9IHNyY1NoYXBlLmludGVyc2VjdExpbmUoc3JjUG9zLngsIHNyY1Bvcy55LCBzcmNXLCBzcmNILCBjcFByb2oueCwgY3BQcm9qLnksIDApO1xuXG4gICAgICAgIGlmIChjbG9zZVN0YXJ0QUNwKSB7XG4gICAgICAgICAgcnMuY3RybHB0c1swXSA9IHJzLmN0cmxwdHNbMF0gKyBjcE0ueCAqIChtaW5DcEFEaXN0IC0gc3RhcnRBQ3BEaXN0KTtcbiAgICAgICAgICBycy5jdHJscHRzWzFdID0gcnMuY3RybHB0c1sxXSArIGNwTS55ICogKG1pbkNwQURpc3QgLSBzdGFydEFDcERpc3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJzLmN0cmxwdHNbMF0gPSBzcmNDdHJsUHRJbnRuWzBdICsgY3BNLnggKiBtaW5DcEFEaXN0O1xuICAgICAgICAgIHJzLmN0cmxwdHNbMV0gPSBzcmNDdHJsUHRJbnRuWzFdICsgY3BNLnkgKiBtaW5DcEFEaXN0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChiYWRFbmQgfHwgYmFkQUVuZCB8fCBjbG9zZUVuZEFDcCkge1xuICAgICAgICBvdmVybGFwcGluZyA9IHRydWU7IC8vIHByb2plY3QgY29udHJvbCBwb2ludCBhbG9uZyBsaW5lIGZyb20gdGd0IGNlbnRyZSB0byBvdXRzaWRlIHRoZSB0Z3Qgc2hhcGVcbiAgICAgICAgLy8gKG90aGVyd2lzZSBpbnRlcnNlY3Rpb24gd2lsbCB5aWVsZCBub3RoaW5nKVxuXG4gICAgICAgIHZhciBfY3BEID0ge1xuICAgICAgICAgIC8vIGRlbHRhXG4gICAgICAgICAgeDogcnMuY3RybHB0c1swXSAtIHRndFBvcy54LFxuICAgICAgICAgIHk6IHJzLmN0cmxwdHNbMV0gLSB0Z3RQb3MueVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBfY3BMID0gTWF0aC5zcXJ0KF9jcEQueCAqIF9jcEQueCArIF9jcEQueSAqIF9jcEQueSk7IC8vIGxlbmd0aCBvZiBsaW5lXG5cblxuICAgICAgICB2YXIgX2NwTSA9IHtcbiAgICAgICAgICAvLyBub3JtYWxpc2VkIGRlbHRhXG4gICAgICAgICAgeDogX2NwRC54IC8gX2NwTCxcbiAgICAgICAgICB5OiBfY3BELnkgLyBfY3BMXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIF9yYWRpdXMgPSBNYXRoLm1heChzcmNXLCBzcmNIKTtcblxuICAgICAgICB2YXIgX2NwUHJvaiA9IHtcbiAgICAgICAgICAvLyAqMiByYWRpdXMgZ3VhcmFudGVlcyBvdXRzaWRlIHNoYXBlXG4gICAgICAgICAgeDogcnMuY3RybHB0c1swXSArIF9jcE0ueCAqIDIgKiBfcmFkaXVzLFxuICAgICAgICAgIHk6IHJzLmN0cmxwdHNbMV0gKyBfY3BNLnkgKiAyICogX3JhZGl1c1xuICAgICAgICB9O1xuICAgICAgICB2YXIgdGd0Q3RybFB0SW50biA9IHRndFNoYXBlLmludGVyc2VjdExpbmUodGd0UG9zLngsIHRndFBvcy55LCB0Z3RXLCB0Z3RILCBfY3BQcm9qLngsIF9jcFByb2oueSwgMCk7XG5cbiAgICAgICAgaWYgKGNsb3NlRW5kQUNwKSB7XG4gICAgICAgICAgcnMuY3RybHB0c1swXSA9IHJzLmN0cmxwdHNbMF0gKyBfY3BNLnggKiAobWluQ3BBRGlzdCAtIGVuZEFDcERpc3QpO1xuICAgICAgICAgIHJzLmN0cmxwdHNbMV0gPSBycy5jdHJscHRzWzFdICsgX2NwTS55ICogKG1pbkNwQURpc3QgLSBlbmRBQ3BEaXN0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBycy5jdHJscHRzWzBdID0gdGd0Q3RybFB0SW50blswXSArIF9jcE0ueCAqIG1pbkNwQURpc3Q7XG4gICAgICAgICAgcnMuY3RybHB0c1sxXSA9IHRndEN0cmxQdEludG5bMV0gKyBfY3BNLnkgKiBtaW5DcEFEaXN0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChvdmVybGFwcGluZykge1xuICAgICAgICAvLyByZWNhbGMgZW5kcHRzXG4gICAgICAgIHRoaXMuZmluZEVuZHBvaW50cyhlZGdlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgQlJwJGMuc3RvcmVBbGxwdHMgPSBmdW5jdGlvbiAoZWRnZSkge1xuICAgIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG5cbiAgICBpZiAocnMuZWRnZVR5cGUgPT09ICdtdWx0aWJlemllcicgfHwgcnMuZWRnZVR5cGUgPT09ICdiZXppZXInIHx8IHJzLmVkZ2VUeXBlID09PSAnc2VsZicgfHwgcnMuZWRnZVR5cGUgPT09ICdjb21wb3VuZCcpIHtcbiAgICAgIHJzLmFsbHB0cyA9IFtdO1xuICAgICAgcnMuYWxscHRzLnB1c2gocnMuc3RhcnRYLCBycy5zdGFydFkpO1xuXG4gICAgICBmb3IgKHZhciBiID0gMDsgYiArIDEgPCBycy5jdHJscHRzLmxlbmd0aDsgYiArPSAyKSB7XG4gICAgICAgIC8vIGN0cmwgcHQgaXRzZWxmXG4gICAgICAgIHJzLmFsbHB0cy5wdXNoKHJzLmN0cmxwdHNbYl0sIHJzLmN0cmxwdHNbYiArIDFdKTsgLy8gdGhlIG1pZHB0IGJldHdlZW4gY3RybHB0cyBhcyBpbnRlcm1lZGlhdGUgZGVzdGluYXRpb24gcHRzXG5cbiAgICAgICAgaWYgKGIgKyAzIDwgcnMuY3RybHB0cy5sZW5ndGgpIHtcbiAgICAgICAgICBycy5hbGxwdHMucHVzaCgocnMuY3RybHB0c1tiXSArIHJzLmN0cmxwdHNbYiArIDJdKSAvIDIsIChycy5jdHJscHRzW2IgKyAxXSArIHJzLmN0cmxwdHNbYiArIDNdKSAvIDIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJzLmFsbHB0cy5wdXNoKHJzLmVuZFgsIHJzLmVuZFkpO1xuICAgICAgdmFyIG0sIG10O1xuXG4gICAgICBpZiAocnMuY3RybHB0cy5sZW5ndGggLyAyICUgMiA9PT0gMCkge1xuICAgICAgICBtID0gcnMuYWxscHRzLmxlbmd0aCAvIDIgLSAxO1xuICAgICAgICBycy5taWRYID0gcnMuYWxscHRzW21dO1xuICAgICAgICBycy5taWRZID0gcnMuYWxscHRzW20gKyAxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG0gPSBycy5hbGxwdHMubGVuZ3RoIC8gMiAtIDM7XG4gICAgICAgIG10ID0gMC41O1xuICAgICAgICBycy5taWRYID0gcWJlemllckF0KHJzLmFsbHB0c1ttXSwgcnMuYWxscHRzW20gKyAyXSwgcnMuYWxscHRzW20gKyA0XSwgbXQpO1xuICAgICAgICBycy5taWRZID0gcWJlemllckF0KHJzLmFsbHB0c1ttICsgMV0sIHJzLmFsbHB0c1ttICsgM10sIHJzLmFsbHB0c1ttICsgNV0sIG10KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJzLmVkZ2VUeXBlID09PSAnc3RyYWlnaHQnKSB7XG4gICAgICAvLyBuZWVkIHRvIGNhbGMgdGhlc2UgYWZ0ZXIgZW5kcHRzXG4gICAgICBycy5hbGxwdHMgPSBbcnMuc3RhcnRYLCBycy5zdGFydFksIHJzLmVuZFgsIHJzLmVuZFldOyAvLyBkZWZhdWx0IG1pZHB0IGZvciBsYWJlbHMgZXRjXG5cbiAgICAgIHJzLm1pZFggPSAocnMuc3RhcnRYICsgcnMuZW5kWCArIHJzLmFycm93U3RhcnRYICsgcnMuYXJyb3dFbmRYKSAvIDQ7XG4gICAgICBycy5taWRZID0gKHJzLnN0YXJ0WSArIHJzLmVuZFkgKyBycy5hcnJvd1N0YXJ0WSArIHJzLmFycm93RW5kWSkgLyA0O1xuICAgIH0gZWxzZSBpZiAocnMuZWRnZVR5cGUgPT09ICdzZWdtZW50cycpIHtcbiAgICAgIHJzLmFsbHB0cyA9IFtdO1xuICAgICAgcnMuYWxscHRzLnB1c2gocnMuc3RhcnRYLCBycy5zdGFydFkpO1xuICAgICAgcnMuYWxscHRzLnB1c2guYXBwbHkocnMuYWxscHRzLCBycy5zZWdwdHMpO1xuICAgICAgcnMuYWxscHRzLnB1c2gocnMuZW5kWCwgcnMuZW5kWSk7XG5cbiAgICAgIGlmIChycy5zZWdwdHMubGVuZ3RoICUgNCA9PT0gMCkge1xuICAgICAgICB2YXIgaTIgPSBycy5zZWdwdHMubGVuZ3RoIC8gMjtcbiAgICAgICAgdmFyIGkxID0gaTIgLSAyO1xuICAgICAgICBycy5taWRYID0gKHJzLnNlZ3B0c1tpMV0gKyBycy5zZWdwdHNbaTJdKSAvIDI7XG4gICAgICAgIHJzLm1pZFkgPSAocnMuc2VncHRzW2kxICsgMV0gKyBycy5zZWdwdHNbaTIgKyAxXSkgLyAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIF9pID0gcnMuc2VncHRzLmxlbmd0aCAvIDIgLSAxO1xuXG4gICAgICAgIHJzLm1pZFggPSBycy5zZWdwdHNbX2ldO1xuICAgICAgICBycy5taWRZID0gcnMuc2VncHRzW19pICsgMV07XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEJScCRjLmNoZWNrRm9ySW52YWxpZEVkZ2VXYXJuaW5nID0gZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICB2YXIgcnMgPSBlZGdlWzBdLl9wcml2YXRlLnJzY3JhdGNoO1xuXG4gICAgaWYgKHJzLm5vZGVzT3ZlcmxhcCB8fCBudW1iZXIkMShycy5zdGFydFgpICYmIG51bWJlciQxKHJzLnN0YXJ0WSkgJiYgbnVtYmVyJDEocnMuZW5kWCkgJiYgbnVtYmVyJDEocnMuZW5kWSkpIHtcbiAgICAgIHJzLmxvZ2dlZEVyciA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXJzLmxvZ2dlZEVycikge1xuICAgICAgICBycy5sb2dnZWRFcnIgPSB0cnVlO1xuICAgICAgICB3YXJuKCdFZGdlIGAnICsgZWRnZS5pZCgpICsgJ2AgaGFzIGludmFsaWQgZW5kcG9pbnRzIGFuZCBzbyBpdCBpcyBpbXBvc3NpYmxlIHRvIGRyYXcuICBBZGp1c3QgeW91ciBlZGdlIHN0eWxlIChlLmcuIGNvbnRyb2wgcG9pbnRzKSBhY2NvcmRpbmdseSBvciB1c2UgYW4gYWx0ZXJuYXRpdmUgZWRnZSB0eXBlLiAgVGhpcyBpcyBleHBlY3RlZCBiZWhhdmlvdXIgd2hlbiB0aGUgc291cmNlIG5vZGUgYW5kIHRoZSB0YXJnZXQgbm9kZSBvdmVybGFwLicpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBCUnAkYy5maW5kRWRnZUNvbnRyb2xQb2ludHMgPSBmdW5jdGlvbiAoZWRnZXMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgaWYgKCFlZGdlcyB8fCBlZGdlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgciA9IHRoaXM7XG4gICAgdmFyIGN5ID0gci5jeTtcbiAgICB2YXIgaGFzQ29tcG91bmRzID0gY3kuaGFzQ29tcG91bmROb2RlcygpO1xuICAgIHZhciBoYXNoVGFibGUgPSB7XG4gICAgICBtYXA6IG5ldyBNYXAkMigpLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQocGFpcklkKSB7XG4gICAgICAgIHZhciBtYXAyID0gdGhpcy5tYXAuZ2V0KHBhaXJJZFswXSk7XG5cbiAgICAgICAgaWYgKG1hcDIgIT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBtYXAyLmdldChwYWlySWRbMV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQocGFpcklkLCB2YWwpIHtcbiAgICAgICAgdmFyIG1hcDIgPSB0aGlzLm1hcC5nZXQocGFpcklkWzBdKTtcblxuICAgICAgICBpZiAobWFwMiA9PSBudWxsKSB7XG4gICAgICAgICAgbWFwMiA9IG5ldyBNYXAkMigpO1xuICAgICAgICAgIHRoaXMubWFwLnNldChwYWlySWRbMF0sIG1hcDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgbWFwMi5zZXQocGFpcklkWzFdLCB2YWwpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHBhaXJJZHMgPSBbXTtcbiAgICB2YXIgaGF5c3RhY2tFZGdlcyA9IFtdOyAvLyBjcmVhdGUgYSB0YWJsZSBvZiBlZGdlIChzcmMsIHRndCkgPT4gbGlzdCBvZiBlZGdlcyBiZXR3ZWVuIHRoZW1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlZGdlID0gZWRnZXNbaV07XG4gICAgICB2YXIgX3AgPSBlZGdlLl9wcml2YXRlO1xuICAgICAgdmFyIGN1cnZlU3R5bGUgPSBlZGdlLnBzdHlsZSgnY3VydmUtc3R5bGUnKS52YWx1ZTsgLy8gaWdub3JlIGVkZ2VzIHdobyBhcmUgbm90IHRvIGJlIGRpc3BsYXllZFxuICAgICAgLy8gdGhleSBzaG91bGRuJ3QgdGFrZSB1cCBzcGFjZVxuXG4gICAgICBpZiAoZWRnZS5yZW1vdmVkKCkgfHwgIWVkZ2UudGFrZXNVcFNwYWNlKCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChjdXJ2ZVN0eWxlID09PSAnaGF5c3RhY2snKSB7XG4gICAgICAgIGhheXN0YWNrRWRnZXMucHVzaChlZGdlKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBlZGdlSXNVbmJ1bmRsZWQgPSBjdXJ2ZVN0eWxlID09PSAndW5idW5kbGVkLWJlemllcicgfHwgY3VydmVTdHlsZSA9PT0gJ3NlZ21lbnRzJyB8fCBjdXJ2ZVN0eWxlID09PSAnc3RyYWlnaHQnIHx8IGN1cnZlU3R5bGUgPT09ICdzdHJhaWdodC10cmlhbmdsZScgfHwgY3VydmVTdHlsZSA9PT0gJ3RheGknO1xuICAgICAgdmFyIGVkZ2VJc0JlemllciA9IGN1cnZlU3R5bGUgPT09ICd1bmJ1bmRsZWQtYmV6aWVyJyB8fCBjdXJ2ZVN0eWxlID09PSAnYmV6aWVyJztcbiAgICAgIHZhciBzcmMgPSBfcC5zb3VyY2U7XG4gICAgICB2YXIgdGd0ID0gX3AudGFyZ2V0O1xuICAgICAgdmFyIHNyY0luZGV4ID0gc3JjLnBvb2xJbmRleCgpO1xuICAgICAgdmFyIHRndEluZGV4ID0gdGd0LnBvb2xJbmRleCgpO1xuICAgICAgdmFyIHBhaXJJZCA9IFtzcmNJbmRleCwgdGd0SW5kZXhdLnNvcnQoKTtcbiAgICAgIHZhciB0YWJsZUVudHJ5ID0gaGFzaFRhYmxlLmdldChwYWlySWQpO1xuXG4gICAgICBpZiAodGFibGVFbnRyeSA9PSBudWxsKSB7XG4gICAgICAgIHRhYmxlRW50cnkgPSB7XG4gICAgICAgICAgZWxlczogW11cbiAgICAgICAgfTtcbiAgICAgICAgaGFzaFRhYmxlLnNldChwYWlySWQsIHRhYmxlRW50cnkpO1xuICAgICAgICBwYWlySWRzLnB1c2gocGFpcklkKTtcbiAgICAgIH1cblxuICAgICAgdGFibGVFbnRyeS5lbGVzLnB1c2goZWRnZSk7XG5cbiAgICAgIGlmIChlZGdlSXNVbmJ1bmRsZWQpIHtcbiAgICAgICAgdGFibGVFbnRyeS5oYXNVbmJ1bmRsZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWRnZUlzQmV6aWVyKSB7XG4gICAgICAgIHRhYmxlRW50cnkuaGFzQmV6aWVyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IC8vIGZvciBlYWNoIHBhaXIgKHNyYywgdGd0KSwgY3JlYXRlIHRoZSBjdHJsIHB0c1xuICAgIC8vIE5lc3RlZCBmb3IgbG9vcCBpcyBPSzsgdG90YWwgbnVtYmVyIG9mIGl0ZXJhdGlvbnMgZm9yIGJvdGggbG9vcHMgPSBlZGdlQ291bnRcblxuXG4gICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AocCkge1xuICAgICAgdmFyIHBhaXJJZCA9IHBhaXJJZHNbcF07XG4gICAgICB2YXIgcGFpckluZm8gPSBoYXNoVGFibGUuZ2V0KHBhaXJJZCk7XG4gICAgICB2YXIgc3dhcHBlZHBhaXJJbmZvID0gdm9pZCAwO1xuXG4gICAgICBpZiAoIXBhaXJJbmZvLmhhc1VuYnVuZGxlZCkge1xuICAgICAgICB2YXIgcGxsRWRnZXMgPSBwYWlySW5mby5lbGVzWzBdLnBhcmFsbGVsRWRnZXMoKS5maWx0ZXIoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICByZXR1cm4gZS5pc0J1bmRsZWRCZXppZXIoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNsZWFyQXJyYXkocGFpckluZm8uZWxlcyk7XG4gICAgICAgIHBsbEVkZ2VzLmZvckVhY2goZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgICAgICByZXR1cm4gcGFpckluZm8uZWxlcy5wdXNoKGVkZ2UpO1xuICAgICAgICB9KTsgLy8gZm9yIGVhY2ggcGFpciBpZCwgdGhlIGVkZ2VzIHNob3VsZCBiZSBzb3J0ZWQgYnkgaW5kZXhcblxuICAgICAgICBwYWlySW5mby5lbGVzLnNvcnQoZnVuY3Rpb24gKGVkZ2UxLCBlZGdlMikge1xuICAgICAgICAgIHJldHVybiBlZGdlMS5wb29sSW5kZXgoKSAtIGVkZ2UyLnBvb2xJbmRleCgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGZpcnN0RWRnZSA9IHBhaXJJbmZvLmVsZXNbMF07XG4gICAgICB2YXIgc3JjID0gZmlyc3RFZGdlLnNvdXJjZSgpO1xuICAgICAgdmFyIHRndCA9IGZpcnN0RWRnZS50YXJnZXQoKTsgLy8gbWFrZSBzdXJlIHNyYy90Z3QgZGlzdGluY3Rpb24gaXMgY29uc2lzdGVudCB3LnIudC4gcGFpcklkXG5cbiAgICAgIGlmIChzcmMucG9vbEluZGV4KCkgPiB0Z3QucG9vbEluZGV4KCkpIHtcbiAgICAgICAgdmFyIHRlbXAgPSBzcmM7XG4gICAgICAgIHNyYyA9IHRndDtcbiAgICAgICAgdGd0ID0gdGVtcDtcbiAgICAgIH1cblxuICAgICAgdmFyIHNyY1BvcyA9IHBhaXJJbmZvLnNyY1BvcyA9IHNyYy5wb3NpdGlvbigpO1xuICAgICAgdmFyIHRndFBvcyA9IHBhaXJJbmZvLnRndFBvcyA9IHRndC5wb3NpdGlvbigpO1xuICAgICAgdmFyIHNyY1cgPSBwYWlySW5mby5zcmNXID0gc3JjLm91dGVyV2lkdGgoKTtcbiAgICAgIHZhciBzcmNIID0gcGFpckluZm8uc3JjSCA9IHNyYy5vdXRlckhlaWdodCgpO1xuICAgICAgdmFyIHRndFcgPSBwYWlySW5mby50Z3RXID0gdGd0Lm91dGVyV2lkdGgoKTtcbiAgICAgIHZhciB0Z3RIID0gcGFpckluZm8udGd0SCA9IHRndC5vdXRlckhlaWdodCgpO1xuXG4gICAgICB2YXIgc3JjU2hhcGUgPSBwYWlySW5mby5zcmNTaGFwZSA9IHIubm9kZVNoYXBlc1tfdGhpcy5nZXROb2RlU2hhcGUoc3JjKV07XG5cbiAgICAgIHZhciB0Z3RTaGFwZSA9IHBhaXJJbmZvLnRndFNoYXBlID0gci5ub2RlU2hhcGVzW190aGlzLmdldE5vZGVTaGFwZSh0Z3QpXTtcblxuICAgICAgcGFpckluZm8uZGlyQ291bnRzID0ge1xuICAgICAgICAnbm9ydGgnOiAwLFxuICAgICAgICAnd2VzdCc6IDAsXG4gICAgICAgICdzb3V0aCc6IDAsXG4gICAgICAgICdlYXN0JzogMCxcbiAgICAgICAgJ25vcnRod2VzdCc6IDAsXG4gICAgICAgICdzb3V0aHdlc3QnOiAwLFxuICAgICAgICAnbm9ydGhlYXN0JzogMCxcbiAgICAgICAgJ3NvdXRoZWFzdCc6IDBcbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IHBhaXJJbmZvLmVsZXMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICB2YXIgX2VkZ2UgPSBwYWlySW5mby5lbGVzW19pMl07XG4gICAgICAgIHZhciBycyA9IF9lZGdlWzBdLl9wcml2YXRlLnJzY3JhdGNoO1xuXG4gICAgICAgIHZhciBfY3VydmVTdHlsZSA9IF9lZGdlLnBzdHlsZSgnY3VydmUtc3R5bGUnKS52YWx1ZTtcblxuICAgICAgICB2YXIgX2VkZ2VJc1VuYnVuZGxlZCA9IF9jdXJ2ZVN0eWxlID09PSAndW5idW5kbGVkLWJlemllcicgfHwgX2N1cnZlU3R5bGUgPT09ICdzZWdtZW50cycgfHwgX2N1cnZlU3R5bGUgPT09ICd0YXhpJzsgLy8gd2hldGhlciB0aGUgbm9ybWFsaXNlZCBwYWlyIG9yZGVyIGlzIHRoZSByZXZlcnNlIG9mIHRoZSBlZGdlJ3Mgc3JjLXRndCBvcmRlclxuXG5cbiAgICAgICAgdmFyIGVkZ2VJc1N3YXBwZWQgPSAhc3JjLnNhbWUoX2VkZ2Uuc291cmNlKCkpO1xuXG4gICAgICAgIGlmICghcGFpckluZm8uY2FsY3VsYXRlZEludGVyc2VjdGlvbiAmJiBzcmMgIT09IHRndCAmJiAocGFpckluZm8uaGFzQmV6aWVyIHx8IHBhaXJJbmZvLmhhc1VuYnVuZGxlZCkpIHtcbiAgICAgICAgICBwYWlySW5mby5jYWxjdWxhdGVkSW50ZXJzZWN0aW9uID0gdHJ1ZTsgLy8gcHQgb3V0c2lkZSBzcmMgc2hhcGUgdG8gY2FsYyBkaXN0YW5jZS9kaXNwbGFjZW1lbnQgZnJvbSBzcmMgdG8gdGd0XG5cbiAgICAgICAgICB2YXIgc3JjT3V0c2lkZSA9IHNyY1NoYXBlLmludGVyc2VjdExpbmUoc3JjUG9zLngsIHNyY1Bvcy55LCBzcmNXLCBzcmNILCB0Z3RQb3MueCwgdGd0UG9zLnksIDApO1xuICAgICAgICAgIHZhciBzcmNJbnRuID0gcGFpckluZm8uc3JjSW50biA9IHNyY091dHNpZGU7IC8vIHB0IG91dHNpZGUgdGd0IHNoYXBlIHRvIGNhbGMgZGlzdGFuY2UvZGlzcGxhY2VtZW50IGZyb20gc3JjIHRvIHRndFxuXG4gICAgICAgICAgdmFyIHRndE91dHNpZGUgPSB0Z3RTaGFwZS5pbnRlcnNlY3RMaW5lKHRndFBvcy54LCB0Z3RQb3MueSwgdGd0VywgdGd0SCwgc3JjUG9zLngsIHNyY1Bvcy55LCAwKTtcbiAgICAgICAgICB2YXIgdGd0SW50biA9IHBhaXJJbmZvLnRndEludG4gPSB0Z3RPdXRzaWRlO1xuICAgICAgICAgIHZhciBpbnRlcnNlY3Rpb25QdHMgPSBwYWlySW5mby5pbnRlcnNlY3Rpb25QdHMgPSB7XG4gICAgICAgICAgICB4MTogc3JjT3V0c2lkZVswXSxcbiAgICAgICAgICAgIHgyOiB0Z3RPdXRzaWRlWzBdLFxuICAgICAgICAgICAgeTE6IHNyY091dHNpZGVbMV0sXG4gICAgICAgICAgICB5MjogdGd0T3V0c2lkZVsxXVxuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIHBvc1B0cyA9IHBhaXJJbmZvLnBvc1B0cyA9IHtcbiAgICAgICAgICAgIHgxOiBzcmNQb3MueCxcbiAgICAgICAgICAgIHgyOiB0Z3RQb3MueCxcbiAgICAgICAgICAgIHkxOiBzcmNQb3MueSxcbiAgICAgICAgICAgIHkyOiB0Z3RQb3MueVxuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIGR5ID0gdGd0T3V0c2lkZVsxXSAtIHNyY091dHNpZGVbMV07XG4gICAgICAgICAgdmFyIGR4ID0gdGd0T3V0c2lkZVswXSAtIHNyY091dHNpZGVbMF07XG4gICAgICAgICAgdmFyIGwgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgICAgIHZhciB2ZWN0b3IgPSBwYWlySW5mby52ZWN0b3IgPSB7XG4gICAgICAgICAgICB4OiBkeCxcbiAgICAgICAgICAgIHk6IGR5XG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgdmVjdG9yTm9ybSA9IHBhaXJJbmZvLnZlY3Rvck5vcm0gPSB7XG4gICAgICAgICAgICB4OiB2ZWN0b3IueCAvIGwsXG4gICAgICAgICAgICB5OiB2ZWN0b3IueSAvIGxcbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciB2ZWN0b3JOb3JtSW52ZXJzZSA9IHtcbiAgICAgICAgICAgIHg6IC12ZWN0b3JOb3JtLnksXG4gICAgICAgICAgICB5OiB2ZWN0b3JOb3JtLnhcbiAgICAgICAgICB9OyAvLyBpZiBub2RlIHNoYXBlcyBvdmVybGFwLCB0aGVuIG5vIGN0cmwgcHRzIHRvIGRyYXdcblxuICAgICAgICAgIHBhaXJJbmZvLm5vZGVzT3ZlcmxhcCA9ICFudW1iZXIkMShsKSB8fCB0Z3RTaGFwZS5jaGVja1BvaW50KHNyY091dHNpZGVbMF0sIHNyY091dHNpZGVbMV0sIDAsIHRndFcsIHRndEgsIHRndFBvcy54LCB0Z3RQb3MueSkgfHwgc3JjU2hhcGUuY2hlY2tQb2ludCh0Z3RPdXRzaWRlWzBdLCB0Z3RPdXRzaWRlWzFdLCAwLCBzcmNXLCBzcmNILCBzcmNQb3MueCwgc3JjUG9zLnkpO1xuICAgICAgICAgIHBhaXJJbmZvLnZlY3Rvck5vcm1JbnZlcnNlID0gdmVjdG9yTm9ybUludmVyc2U7XG4gICAgICAgICAgc3dhcHBlZHBhaXJJbmZvID0ge1xuICAgICAgICAgICAgbm9kZXNPdmVybGFwOiBwYWlySW5mby5ub2Rlc092ZXJsYXAsXG4gICAgICAgICAgICBkaXJDb3VudHM6IHBhaXJJbmZvLmRpckNvdW50cyxcbiAgICAgICAgICAgIGNhbGN1bGF0ZWRJbnRlcnNlY3Rpb246IHRydWUsXG4gICAgICAgICAgICBoYXNCZXppZXI6IHBhaXJJbmZvLmhhc0JlemllcixcbiAgICAgICAgICAgIGhhc1VuYnVuZGxlZDogcGFpckluZm8uaGFzVW5idW5kbGVkLFxuICAgICAgICAgICAgZWxlczogcGFpckluZm8uZWxlcyxcbiAgICAgICAgICAgIHNyY1BvczogdGd0UG9zLFxuICAgICAgICAgICAgdGd0UG9zOiBzcmNQb3MsXG4gICAgICAgICAgICBzcmNXOiB0Z3RXLFxuICAgICAgICAgICAgc3JjSDogdGd0SCxcbiAgICAgICAgICAgIHRndFc6IHNyY1csXG4gICAgICAgICAgICB0Z3RIOiBzcmNILFxuICAgICAgICAgICAgc3JjSW50bjogdGd0SW50bixcbiAgICAgICAgICAgIHRndEludG46IHNyY0ludG4sXG4gICAgICAgICAgICBzcmNTaGFwZTogdGd0U2hhcGUsXG4gICAgICAgICAgICB0Z3RTaGFwZTogc3JjU2hhcGUsXG4gICAgICAgICAgICBwb3NQdHM6IHtcbiAgICAgICAgICAgICAgeDE6IHBvc1B0cy54MixcbiAgICAgICAgICAgICAgeTE6IHBvc1B0cy55MixcbiAgICAgICAgICAgICAgeDI6IHBvc1B0cy54MSxcbiAgICAgICAgICAgICAgeTI6IHBvc1B0cy55MVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGludGVyc2VjdGlvblB0czoge1xuICAgICAgICAgICAgICB4MTogaW50ZXJzZWN0aW9uUHRzLngyLFxuICAgICAgICAgICAgICB5MTogaW50ZXJzZWN0aW9uUHRzLnkyLFxuICAgICAgICAgICAgICB4MjogaW50ZXJzZWN0aW9uUHRzLngxLFxuICAgICAgICAgICAgICB5MjogaW50ZXJzZWN0aW9uUHRzLnkxXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmVjdG9yOiB7XG4gICAgICAgICAgICAgIHg6IC12ZWN0b3IueCxcbiAgICAgICAgICAgICAgeTogLXZlY3Rvci55XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmVjdG9yTm9ybToge1xuICAgICAgICAgICAgICB4OiAtdmVjdG9yTm9ybS54LFxuICAgICAgICAgICAgICB5OiAtdmVjdG9yTm9ybS55XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdmVjdG9yTm9ybUludmVyc2U6IHtcbiAgICAgICAgICAgICAgeDogLXZlY3Rvck5vcm1JbnZlcnNlLngsXG4gICAgICAgICAgICAgIHk6IC12ZWN0b3JOb3JtSW52ZXJzZS55XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXNzZWRQYWlySW5mbyA9IGVkZ2VJc1N3YXBwZWQgPyBzd2FwcGVkcGFpckluZm8gOiBwYWlySW5mbztcbiAgICAgICAgcnMubm9kZXNPdmVybGFwID0gcGFzc2VkUGFpckluZm8ubm9kZXNPdmVybGFwO1xuICAgICAgICBycy5zcmNJbnRuID0gcGFzc2VkUGFpckluZm8uc3JjSW50bjtcbiAgICAgICAgcnMudGd0SW50biA9IHBhc3NlZFBhaXJJbmZvLnRndEludG47XG5cbiAgICAgICAgaWYgKGhhc0NvbXBvdW5kcyAmJiAoc3JjLmlzUGFyZW50KCkgfHwgc3JjLmlzQ2hpbGQoKSB8fCB0Z3QuaXNQYXJlbnQoKSB8fCB0Z3QuaXNDaGlsZCgpKSAmJiAoc3JjLnBhcmVudHMoKS5hbnlTYW1lKHRndCkgfHwgdGd0LnBhcmVudHMoKS5hbnlTYW1lKHNyYykgfHwgc3JjLnNhbWUodGd0KSAmJiBzcmMuaXNQYXJlbnQoKSkpIHtcbiAgICAgICAgICBfdGhpcy5maW5kQ29tcG91bmRMb29wUG9pbnRzKF9lZGdlLCBwYXNzZWRQYWlySW5mbywgX2kyLCBfZWRnZUlzVW5idW5kbGVkKTtcbiAgICAgICAgfSBlbHNlIGlmIChzcmMgPT09IHRndCkge1xuICAgICAgICAgIF90aGlzLmZpbmRMb29wUG9pbnRzKF9lZGdlLCBwYXNzZWRQYWlySW5mbywgX2kyLCBfZWRnZUlzVW5idW5kbGVkKTtcbiAgICAgICAgfSBlbHNlIGlmIChfY3VydmVTdHlsZSA9PT0gJ3NlZ21lbnRzJykge1xuICAgICAgICAgIF90aGlzLmZpbmRTZWdtZW50c1BvaW50cyhfZWRnZSwgcGFzc2VkUGFpckluZm8pO1xuICAgICAgICB9IGVsc2UgaWYgKF9jdXJ2ZVN0eWxlID09PSAndGF4aScpIHtcbiAgICAgICAgICBfdGhpcy5maW5kVGF4aVBvaW50cyhfZWRnZSwgcGFzc2VkUGFpckluZm8pO1xuICAgICAgICB9IGVsc2UgaWYgKF9jdXJ2ZVN0eWxlID09PSAnc3RyYWlnaHQnIHx8ICFfZWRnZUlzVW5idW5kbGVkICYmIHBhaXJJbmZvLmVsZXMubGVuZ3RoICUgMiA9PT0gMSAmJiBfaTIgPT09IE1hdGguZmxvb3IocGFpckluZm8uZWxlcy5sZW5ndGggLyAyKSkge1xuICAgICAgICAgIF90aGlzLmZpbmRTdHJhaWdodEVkZ2VQb2ludHMoX2VkZ2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzLmZpbmRCZXppZXJQb2ludHMoX2VkZ2UsIHBhc3NlZFBhaXJJbmZvLCBfaTIsIF9lZGdlSXNVbmJ1bmRsZWQsIGVkZ2VJc1N3YXBwZWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMuZmluZEVuZHBvaW50cyhfZWRnZSk7XG5cbiAgICAgICAgX3RoaXMudHJ5VG9Db3JyZWN0SW52YWxpZFBvaW50cyhfZWRnZSwgcGFzc2VkUGFpckluZm8pO1xuXG4gICAgICAgIF90aGlzLmNoZWNrRm9ySW52YWxpZEVkZ2VXYXJuaW5nKF9lZGdlKTtcblxuICAgICAgICBfdGhpcy5zdG9yZUFsbHB0cyhfZWRnZSk7XG5cbiAgICAgICAgX3RoaXMuc3RvcmVFZGdlUHJvamVjdGlvbnMoX2VkZ2UpO1xuXG4gICAgICAgIF90aGlzLmNhbGN1bGF0ZUFycm93QW5nbGVzKF9lZGdlKTtcblxuICAgICAgICBfdGhpcy5yZWNhbGN1bGF0ZUVkZ2VMYWJlbFByb2plY3Rpb25zKF9lZGdlKTtcblxuICAgICAgICBfdGhpcy5jYWxjdWxhdGVMYWJlbEFuZ2xlcyhfZWRnZSk7XG4gICAgICB9IC8vIGZvciBwYWlyIGVkZ2VzXG5cbiAgICB9O1xuXG4gICAgZm9yICh2YXIgcCA9IDA7IHAgPCBwYWlySWRzLmxlbmd0aDsgcCsrKSB7XG4gICAgICBfbG9vcChwKTtcbiAgICB9IC8vIGZvciBwYWlyIGlkc1xuICAgIC8vIGhheXN0YWNrcyBhdm9pZCB0aGUgZXhwZW5zZSBvZiBwYWlySW5mbyBzdHVmZiAoaW50ZXJzZWN0aW9ucyBldGMuKVxuXG5cbiAgICB0aGlzLmZpbmRIYXlzdGFja1BvaW50cyhoYXlzdGFja0VkZ2VzKTtcbiAgfTtcblxuICBmdW5jdGlvbiBnZXRQdHMocHRzKSB7XG4gICAgdmFyIHJldFB0cyA9IFtdO1xuXG4gICAgaWYgKHB0cyA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwdHMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIHZhciB4ID0gcHRzW2ldO1xuICAgICAgdmFyIHkgPSBwdHNbaSArIDFdO1xuICAgICAgcmV0UHRzLnB1c2goe1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0UHRzO1xuICB9XG5cbiAgQlJwJGMuZ2V0U2VnbWVudFBvaW50cyA9IGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgdmFyIHJzID0gZWRnZVswXS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICB2YXIgdHlwZSA9IHJzLmVkZ2VUeXBlO1xuXG4gICAgaWYgKHR5cGUgPT09ICdzZWdtZW50cycpIHtcbiAgICAgIHRoaXMucmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlKGVkZ2UpO1xuICAgICAgcmV0dXJuIGdldFB0cyhycy5zZWdwdHMpO1xuICAgIH1cbiAgfTtcblxuICBCUnAkYy5nZXRDb250cm9sUG9pbnRzID0gZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICB2YXIgcnMgPSBlZGdlWzBdLl9wcml2YXRlLnJzY3JhdGNoO1xuICAgIHZhciB0eXBlID0gcnMuZWRnZVR5cGU7XG5cbiAgICBpZiAodHlwZSA9PT0gJ2JlemllcicgfHwgdHlwZSA9PT0gJ211bHRpYmV6aWVyJyB8fCB0eXBlID09PSAnc2VsZicgfHwgdHlwZSA9PT0gJ2NvbXBvdW5kJykge1xuICAgICAgdGhpcy5yZWNhbGN1bGF0ZVJlbmRlcmVkU3R5bGUoZWRnZSk7XG4gICAgICByZXR1cm4gZ2V0UHRzKHJzLmN0cmxwdHMpO1xuICAgIH1cbiAgfTtcblxuICBCUnAkYy5nZXRFZGdlTWlkcG9pbnQgPSBmdW5jdGlvbiAoZWRnZSkge1xuICAgIHZhciBycyA9IGVkZ2VbMF0uX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgdGhpcy5yZWNhbGN1bGF0ZVJlbmRlcmVkU3R5bGUoZWRnZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHJzLm1pZFgsXG4gICAgICB5OiBycy5taWRZXG4gICAgfTtcbiAgfTtcblxuICB2YXIgQlJwJGIgPSB7fTtcblxuICBCUnAkYi5tYW51YWxFbmRwdFRvUHggPSBmdW5jdGlvbiAobm9kZSwgcHJvcCkge1xuICAgIHZhciByID0gdGhpcztcbiAgICB2YXIgbnBvcyA9IG5vZGUucG9zaXRpb24oKTtcbiAgICB2YXIgdyA9IG5vZGUub3V0ZXJXaWR0aCgpO1xuICAgIHZhciBoID0gbm9kZS5vdXRlckhlaWdodCgpO1xuXG4gICAgaWYgKHByb3AudmFsdWUubGVuZ3RoID09PSAyKSB7XG4gICAgICB2YXIgcCA9IFtwcm9wLnBmVmFsdWVbMF0sIHByb3AucGZWYWx1ZVsxXV07XG5cbiAgICAgIGlmIChwcm9wLnVuaXRzWzBdID09PSAnJScpIHtcbiAgICAgICAgcFswXSA9IHBbMF0gKiB3O1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvcC51bml0c1sxXSA9PT0gJyUnKSB7XG4gICAgICAgIHBbMV0gPSBwWzFdICogaDtcbiAgICAgIH1cblxuICAgICAgcFswXSArPSBucG9zLng7XG4gICAgICBwWzFdICs9IG5wb3MueTtcbiAgICAgIHJldHVybiBwO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYW5nbGUgPSBwcm9wLnBmVmFsdWVbMF07XG4gICAgICBhbmdsZSA9IC1NYXRoLlBJIC8gMiArIGFuZ2xlOyAvLyBzdGFydCBhdCAxMiBvJ2Nsb2NrXG5cbiAgICAgIHZhciBsID0gMiAqIE1hdGgubWF4KHcsIGgpO1xuICAgICAgdmFyIF9wID0gW25wb3MueCArIE1hdGguY29zKGFuZ2xlKSAqIGwsIG5wb3MueSArIE1hdGguc2luKGFuZ2xlKSAqIGxdO1xuICAgICAgcmV0dXJuIHIubm9kZVNoYXBlc1t0aGlzLmdldE5vZGVTaGFwZShub2RlKV0uaW50ZXJzZWN0TGluZShucG9zLngsIG5wb3MueSwgdywgaCwgX3BbMF0sIF9wWzFdLCAwKTtcbiAgICB9XG4gIH07XG5cbiAgQlJwJGIuZmluZEVuZHBvaW50cyA9IGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgdmFyIHIgPSB0aGlzO1xuICAgIHZhciBpbnRlcnNlY3Q7XG4gICAgdmFyIHNvdXJjZSA9IGVkZ2Uuc291cmNlKClbMF07XG4gICAgdmFyIHRhcmdldCA9IGVkZ2UudGFyZ2V0KClbMF07XG4gICAgdmFyIHNyY1BvcyA9IHNvdXJjZS5wb3NpdGlvbigpO1xuICAgIHZhciB0Z3RQb3MgPSB0YXJnZXQucG9zaXRpb24oKTtcbiAgICB2YXIgdGd0QXJTaGFwZSA9IGVkZ2UucHN0eWxlKCd0YXJnZXQtYXJyb3ctc2hhcGUnKS52YWx1ZTtcbiAgICB2YXIgc3JjQXJTaGFwZSA9IGVkZ2UucHN0eWxlKCdzb3VyY2UtYXJyb3ctc2hhcGUnKS52YWx1ZTtcbiAgICB2YXIgdGd0RGlzdCA9IGVkZ2UucHN0eWxlKCd0YXJnZXQtZGlzdGFuY2UtZnJvbS1ub2RlJykucGZWYWx1ZTtcbiAgICB2YXIgc3JjRGlzdCA9IGVkZ2UucHN0eWxlKCdzb3VyY2UtZGlzdGFuY2UtZnJvbS1ub2RlJykucGZWYWx1ZTtcbiAgICB2YXIgY3VydmVTdHlsZSA9IGVkZ2UucHN0eWxlKCdjdXJ2ZS1zdHlsZScpLnZhbHVlO1xuICAgIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgdmFyIGV0ID0gcnMuZWRnZVR5cGU7XG4gICAgdmFyIHRheGkgPSBjdXJ2ZVN0eWxlID09PSAndGF4aSc7XG4gICAgdmFyIHNlbGYgPSBldCA9PT0gJ3NlbGYnIHx8IGV0ID09PSAnY29tcG91bmQnO1xuICAgIHZhciBiZXppZXIgPSBldCA9PT0gJ2JlemllcicgfHwgZXQgPT09ICdtdWx0aWJlemllcicgfHwgc2VsZjtcbiAgICB2YXIgbXVsdGkgPSBldCAhPT0gJ2Jlemllcic7XG4gICAgdmFyIGxpbmVzID0gZXQgPT09ICdzdHJhaWdodCcgfHwgZXQgPT09ICdzZWdtZW50cyc7XG4gICAgdmFyIHNlZ21lbnRzID0gZXQgPT09ICdzZWdtZW50cyc7XG4gICAgdmFyIGhhc0VuZHB0cyA9IGJlemllciB8fCBtdWx0aSB8fCBsaW5lcztcbiAgICB2YXIgb3ZlcnJpZGVFbmRwdHMgPSBzZWxmIHx8IHRheGk7XG4gICAgdmFyIHNyY01hbkVuZHB0ID0gZWRnZS5wc3R5bGUoJ3NvdXJjZS1lbmRwb2ludCcpO1xuICAgIHZhciBzcmNNYW5FbmRwdFZhbCA9IG92ZXJyaWRlRW5kcHRzID8gJ291dHNpZGUtdG8tbm9kZScgOiBzcmNNYW5FbmRwdC52YWx1ZTtcbiAgICB2YXIgdGd0TWFuRW5kcHQgPSBlZGdlLnBzdHlsZSgndGFyZ2V0LWVuZHBvaW50Jyk7XG4gICAgdmFyIHRndE1hbkVuZHB0VmFsID0gb3ZlcnJpZGVFbmRwdHMgPyAnb3V0c2lkZS10by1ub2RlJyA6IHRndE1hbkVuZHB0LnZhbHVlO1xuICAgIHJzLnNyY01hbkVuZHB0ID0gc3JjTWFuRW5kcHQ7XG4gICAgcnMudGd0TWFuRW5kcHQgPSB0Z3RNYW5FbmRwdDtcbiAgICB2YXIgcDE7IC8vIGxhc3Qga25vd24gcG9pbnQgb2YgZWRnZSBvbiB0YXJnZXQgc2lkZVxuXG4gICAgdmFyIHAyOyAvLyBsYXN0IGtub3duIHBvaW50IG9mIGVkZ2Ugb24gc291cmNlIHNpZGVcblxuICAgIHZhciBwMV9pOyAvLyBwb2ludCB0byBpbnRlcnNlY3Qgd2l0aCB0YXJnZXQgc2hhcGVcblxuICAgIHZhciBwMl9pOyAvLyBwb2ludCB0byBpbnRlcnNlY3Qgd2l0aCBzb3VyY2Ugc2hhcGVcblxuICAgIGlmIChiZXppZXIpIHtcbiAgICAgIHZhciBjcFN0YXJ0ID0gW3JzLmN0cmxwdHNbMF0sIHJzLmN0cmxwdHNbMV1dO1xuICAgICAgdmFyIGNwRW5kID0gbXVsdGkgPyBbcnMuY3RybHB0c1tycy5jdHJscHRzLmxlbmd0aCAtIDJdLCBycy5jdHJscHRzW3JzLmN0cmxwdHMubGVuZ3RoIC0gMV1dIDogY3BTdGFydDtcbiAgICAgIHAxID0gY3BFbmQ7XG4gICAgICBwMiA9IGNwU3RhcnQ7XG4gICAgfSBlbHNlIGlmIChsaW5lcykge1xuICAgICAgdmFyIHNyY0Fycm93RnJvbVB0ID0gIXNlZ21lbnRzID8gW3RndFBvcy54LCB0Z3RQb3MueV0gOiBycy5zZWdwdHMuc2xpY2UoMCwgMik7XG4gICAgICB2YXIgdGd0QXJyb3dGcm9tUHQgPSAhc2VnbWVudHMgPyBbc3JjUG9zLngsIHNyY1Bvcy55XSA6IHJzLnNlZ3B0cy5zbGljZShycy5zZWdwdHMubGVuZ3RoIC0gMik7XG4gICAgICBwMSA9IHRndEFycm93RnJvbVB0O1xuICAgICAgcDIgPSBzcmNBcnJvd0Zyb21QdDtcbiAgICB9XG5cbiAgICBpZiAodGd0TWFuRW5kcHRWYWwgPT09ICdpbnNpZGUtdG8tbm9kZScpIHtcbiAgICAgIGludGVyc2VjdCA9IFt0Z3RQb3MueCwgdGd0UG9zLnldO1xuICAgIH0gZWxzZSBpZiAodGd0TWFuRW5kcHQudW5pdHMpIHtcbiAgICAgIGludGVyc2VjdCA9IHRoaXMubWFudWFsRW5kcHRUb1B4KHRhcmdldCwgdGd0TWFuRW5kcHQpO1xuICAgIH0gZWxzZSBpZiAodGd0TWFuRW5kcHRWYWwgPT09ICdvdXRzaWRlLXRvLWxpbmUnKSB7XG4gICAgICBpbnRlcnNlY3QgPSBycy50Z3RJbnRuOyAvLyB1c2UgY2FjaGVkIHZhbHVlIGZyb20gY3RybHB0IGNhbGNcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRndE1hbkVuZHB0VmFsID09PSAnb3V0c2lkZS10by1ub2RlJyB8fCB0Z3RNYW5FbmRwdFZhbCA9PT0gJ291dHNpZGUtdG8tbm9kZS1vci1sYWJlbCcpIHtcbiAgICAgICAgcDFfaSA9IHAxO1xuICAgICAgfSBlbHNlIGlmICh0Z3RNYW5FbmRwdFZhbCA9PT0gJ291dHNpZGUtdG8tbGluZScgfHwgdGd0TWFuRW5kcHRWYWwgPT09ICdvdXRzaWRlLXRvLWxpbmUtb3ItbGFiZWwnKSB7XG4gICAgICAgIHAxX2kgPSBbc3JjUG9zLngsIHNyY1Bvcy55XTtcbiAgICAgIH1cblxuICAgICAgaW50ZXJzZWN0ID0gci5ub2RlU2hhcGVzW3RoaXMuZ2V0Tm9kZVNoYXBlKHRhcmdldCldLmludGVyc2VjdExpbmUodGd0UG9zLngsIHRndFBvcy55LCB0YXJnZXQub3V0ZXJXaWR0aCgpLCB0YXJnZXQub3V0ZXJIZWlnaHQoKSwgcDFfaVswXSwgcDFfaVsxXSwgMCk7XG5cbiAgICAgIGlmICh0Z3RNYW5FbmRwdFZhbCA9PT0gJ291dHNpZGUtdG8tbm9kZS1vci1sYWJlbCcgfHwgdGd0TWFuRW5kcHRWYWwgPT09ICdvdXRzaWRlLXRvLWxpbmUtb3ItbGFiZWwnKSB7XG4gICAgICAgIHZhciB0cnMgPSB0YXJnZXQuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgICAgIHZhciBsdyA9IHRycy5sYWJlbFdpZHRoO1xuICAgICAgICB2YXIgbGggPSB0cnMubGFiZWxIZWlnaHQ7XG4gICAgICAgIHZhciBseCA9IHRycy5sYWJlbFg7XG4gICAgICAgIHZhciBseSA9IHRycy5sYWJlbFk7XG4gICAgICAgIHZhciBsdzIgPSBsdyAvIDI7XG4gICAgICAgIHZhciBsaDIgPSBsaCAvIDI7XG4gICAgICAgIHZhciB2YSA9IHRhcmdldC5wc3R5bGUoJ3RleHQtdmFsaWduJykudmFsdWU7XG5cbiAgICAgICAgaWYgKHZhID09PSAndG9wJykge1xuICAgICAgICAgIGx5IC09IGxoMjtcbiAgICAgICAgfSBlbHNlIGlmICh2YSA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICBseSArPSBsaDI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaGEgPSB0YXJnZXQucHN0eWxlKCd0ZXh0LWhhbGlnbicpLnZhbHVlO1xuXG4gICAgICAgIGlmIChoYSA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgbHggLT0gbHcyO1xuICAgICAgICB9IGVsc2UgaWYgKGhhID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgbHggKz0gbHcyO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxhYmVsSW50ZXJzZWN0ID0gcG9seWdvbkludGVyc2VjdExpbmUocDFfaVswXSwgcDFfaVsxXSwgW2x4IC0gbHcyLCBseSAtIGxoMiwgbHggKyBsdzIsIGx5IC0gbGgyLCBseCArIGx3MiwgbHkgKyBsaDIsIGx4IC0gbHcyLCBseSArIGxoMl0sIHRndFBvcy54LCB0Z3RQb3MueSk7XG5cbiAgICAgICAgaWYgKGxhYmVsSW50ZXJzZWN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgcmVmUHQgPSBzcmNQb3M7XG4gICAgICAgICAgdmFyIGludFNxZGlzdCA9IHNxZGlzdChyZWZQdCwgYXJyYXkycG9pbnQoaW50ZXJzZWN0KSk7XG4gICAgICAgICAgdmFyIGxhYkludFNxZGlzdCA9IHNxZGlzdChyZWZQdCwgYXJyYXkycG9pbnQobGFiZWxJbnRlcnNlY3QpKTtcbiAgICAgICAgICB2YXIgbWluU3FEaXN0ID0gaW50U3FkaXN0O1xuXG4gICAgICAgICAgaWYgKGxhYkludFNxZGlzdCA8IGludFNxZGlzdCkge1xuICAgICAgICAgICAgaW50ZXJzZWN0ID0gbGFiZWxJbnRlcnNlY3Q7XG4gICAgICAgICAgICBtaW5TcURpc3QgPSBsYWJJbnRTcWRpc3Q7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGxhYmVsSW50ZXJzZWN0Lmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIHZhciBsYWJJbnQyU3FEaXN0ID0gc3FkaXN0KHJlZlB0LCB7XG4gICAgICAgICAgICAgIHg6IGxhYmVsSW50ZXJzZWN0WzJdLFxuICAgICAgICAgICAgICB5OiBsYWJlbEludGVyc2VjdFszXVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChsYWJJbnQyU3FEaXN0IDwgbWluU3FEaXN0KSB7XG4gICAgICAgICAgICAgIGludGVyc2VjdCA9IFtsYWJlbEludGVyc2VjdFsyXSwgbGFiZWxJbnRlcnNlY3RbM11dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBhcnJvd0VuZCA9IHNob3J0ZW5JbnRlcnNlY3Rpb24oaW50ZXJzZWN0LCBwMSwgci5hcnJvd1NoYXBlc1t0Z3RBclNoYXBlXS5zcGFjaW5nKGVkZ2UpICsgdGd0RGlzdCk7XG4gICAgdmFyIGVkZ2VFbmQgPSBzaG9ydGVuSW50ZXJzZWN0aW9uKGludGVyc2VjdCwgcDEsIHIuYXJyb3dTaGFwZXNbdGd0QXJTaGFwZV0uZ2FwKGVkZ2UpICsgdGd0RGlzdCk7XG4gICAgcnMuZW5kWCA9IGVkZ2VFbmRbMF07XG4gICAgcnMuZW5kWSA9IGVkZ2VFbmRbMV07XG4gICAgcnMuYXJyb3dFbmRYID0gYXJyb3dFbmRbMF07XG4gICAgcnMuYXJyb3dFbmRZID0gYXJyb3dFbmRbMV07XG5cbiAgICBpZiAoc3JjTWFuRW5kcHRWYWwgPT09ICdpbnNpZGUtdG8tbm9kZScpIHtcbiAgICAgIGludGVyc2VjdCA9IFtzcmNQb3MueCwgc3JjUG9zLnldO1xuICAgIH0gZWxzZSBpZiAoc3JjTWFuRW5kcHQudW5pdHMpIHtcbiAgICAgIGludGVyc2VjdCA9IHRoaXMubWFudWFsRW5kcHRUb1B4KHNvdXJjZSwgc3JjTWFuRW5kcHQpO1xuICAgIH0gZWxzZSBpZiAoc3JjTWFuRW5kcHRWYWwgPT09ICdvdXRzaWRlLXRvLWxpbmUnKSB7XG4gICAgICBpbnRlcnNlY3QgPSBycy5zcmNJbnRuOyAvLyB1c2UgY2FjaGVkIHZhbHVlIGZyb20gY3RybHB0IGNhbGNcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHNyY01hbkVuZHB0VmFsID09PSAnb3V0c2lkZS10by1ub2RlJyB8fCBzcmNNYW5FbmRwdFZhbCA9PT0gJ291dHNpZGUtdG8tbm9kZS1vci1sYWJlbCcpIHtcbiAgICAgICAgcDJfaSA9IHAyO1xuICAgICAgfSBlbHNlIGlmIChzcmNNYW5FbmRwdFZhbCA9PT0gJ291dHNpZGUtdG8tbGluZScgfHwgc3JjTWFuRW5kcHRWYWwgPT09ICdvdXRzaWRlLXRvLWxpbmUtb3ItbGFiZWwnKSB7XG4gICAgICAgIHAyX2kgPSBbdGd0UG9zLngsIHRndFBvcy55XTtcbiAgICAgIH1cblxuICAgICAgaW50ZXJzZWN0ID0gci5ub2RlU2hhcGVzW3RoaXMuZ2V0Tm9kZVNoYXBlKHNvdXJjZSldLmludGVyc2VjdExpbmUoc3JjUG9zLngsIHNyY1Bvcy55LCBzb3VyY2Uub3V0ZXJXaWR0aCgpLCBzb3VyY2Uub3V0ZXJIZWlnaHQoKSwgcDJfaVswXSwgcDJfaVsxXSwgMCk7XG5cbiAgICAgIGlmIChzcmNNYW5FbmRwdFZhbCA9PT0gJ291dHNpZGUtdG8tbm9kZS1vci1sYWJlbCcgfHwgc3JjTWFuRW5kcHRWYWwgPT09ICdvdXRzaWRlLXRvLWxpbmUtb3ItbGFiZWwnKSB7XG4gICAgICAgIHZhciBzcnMgPSBzb3VyY2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgICAgIHZhciBfbHcgPSBzcnMubGFiZWxXaWR0aDtcbiAgICAgICAgdmFyIF9saCA9IHNycy5sYWJlbEhlaWdodDtcbiAgICAgICAgdmFyIF9seCA9IHNycy5sYWJlbFg7XG4gICAgICAgIHZhciBfbHkgPSBzcnMubGFiZWxZO1xuXG4gICAgICAgIHZhciBfbHcyID0gX2x3IC8gMjtcblxuICAgICAgICB2YXIgX2xoMiA9IF9saCAvIDI7XG5cbiAgICAgICAgdmFyIF92YSA9IHNvdXJjZS5wc3R5bGUoJ3RleHQtdmFsaWduJykudmFsdWU7XG5cbiAgICAgICAgaWYgKF92YSA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICBfbHkgLT0gX2xoMjtcbiAgICAgICAgfSBlbHNlIGlmIChfdmEgPT09ICdib3R0b20nKSB7XG4gICAgICAgICAgX2x5ICs9IF9saDI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX2hhID0gc291cmNlLnBzdHlsZSgndGV4dC1oYWxpZ24nKS52YWx1ZTtcblxuICAgICAgICBpZiAoX2hhID09PSAnbGVmdCcpIHtcbiAgICAgICAgICBfbHggLT0gX2x3MjtcbiAgICAgICAgfSBlbHNlIGlmIChfaGEgPT09ICdyaWdodCcpIHtcbiAgICAgICAgICBfbHggKz0gX2x3MjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfbGFiZWxJbnRlcnNlY3QgPSBwb2x5Z29uSW50ZXJzZWN0TGluZShwMl9pWzBdLCBwMl9pWzFdLCBbX2x4IC0gX2x3MiwgX2x5IC0gX2xoMiwgX2x4ICsgX2x3MiwgX2x5IC0gX2xoMiwgX2x4ICsgX2x3MiwgX2x5ICsgX2xoMiwgX2x4IC0gX2x3MiwgX2x5ICsgX2xoMl0sIHNyY1Bvcy54LCBzcmNQb3MueSk7XG5cbiAgICAgICAgaWYgKF9sYWJlbEludGVyc2VjdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIF9yZWZQdCA9IHRndFBvcztcblxuICAgICAgICAgIHZhciBfaW50U3FkaXN0ID0gc3FkaXN0KF9yZWZQdCwgYXJyYXkycG9pbnQoaW50ZXJzZWN0KSk7XG5cbiAgICAgICAgICB2YXIgX2xhYkludFNxZGlzdCA9IHNxZGlzdChfcmVmUHQsIGFycmF5MnBvaW50KF9sYWJlbEludGVyc2VjdCkpO1xuXG4gICAgICAgICAgdmFyIF9taW5TcURpc3QgPSBfaW50U3FkaXN0O1xuXG4gICAgICAgICAgaWYgKF9sYWJJbnRTcWRpc3QgPCBfaW50U3FkaXN0KSB7XG4gICAgICAgICAgICBpbnRlcnNlY3QgPSBbX2xhYmVsSW50ZXJzZWN0WzBdLCBfbGFiZWxJbnRlcnNlY3RbMV1dO1xuICAgICAgICAgICAgX21pblNxRGlzdCA9IF9sYWJJbnRTcWRpc3Q7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKF9sYWJlbEludGVyc2VjdC5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICB2YXIgX2xhYkludDJTcURpc3QgPSBzcWRpc3QoX3JlZlB0LCB7XG4gICAgICAgICAgICAgIHg6IF9sYWJlbEludGVyc2VjdFsyXSxcbiAgICAgICAgICAgICAgeTogX2xhYmVsSW50ZXJzZWN0WzNdXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKF9sYWJJbnQyU3FEaXN0IDwgX21pblNxRGlzdCkge1xuICAgICAgICAgICAgICBpbnRlcnNlY3QgPSBbX2xhYmVsSW50ZXJzZWN0WzJdLCBfbGFiZWxJbnRlcnNlY3RbM11dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBhcnJvd1N0YXJ0ID0gc2hvcnRlbkludGVyc2VjdGlvbihpbnRlcnNlY3QsIHAyLCByLmFycm93U2hhcGVzW3NyY0FyU2hhcGVdLnNwYWNpbmcoZWRnZSkgKyBzcmNEaXN0KTtcbiAgICB2YXIgZWRnZVN0YXJ0ID0gc2hvcnRlbkludGVyc2VjdGlvbihpbnRlcnNlY3QsIHAyLCByLmFycm93U2hhcGVzW3NyY0FyU2hhcGVdLmdhcChlZGdlKSArIHNyY0Rpc3QpO1xuICAgIHJzLnN0YXJ0WCA9IGVkZ2VTdGFydFswXTtcbiAgICBycy5zdGFydFkgPSBlZGdlU3RhcnRbMV07XG4gICAgcnMuYXJyb3dTdGFydFggPSBhcnJvd1N0YXJ0WzBdO1xuICAgIHJzLmFycm93U3RhcnRZID0gYXJyb3dTdGFydFsxXTtcblxuICAgIGlmIChoYXNFbmRwdHMpIHtcbiAgICAgIGlmICghbnVtYmVyJDEocnMuc3RhcnRYKSB8fCAhbnVtYmVyJDEocnMuc3RhcnRZKSB8fCAhbnVtYmVyJDEocnMuZW5kWCkgfHwgIW51bWJlciQxKHJzLmVuZFkpKSB7XG4gICAgICAgIHJzLmJhZExpbmUgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcnMuYmFkTGluZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBCUnAkYi5nZXRTb3VyY2VFbmRwb2ludCA9IGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgdmFyIHJzID0gZWRnZVswXS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICB0aGlzLnJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZShlZGdlKTtcblxuICAgIHN3aXRjaCAocnMuZWRnZVR5cGUpIHtcbiAgICAgIGNhc2UgJ2hheXN0YWNrJzpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiBycy5oYXlzdGFja1B0c1swXSxcbiAgICAgICAgICB5OiBycy5oYXlzdGFja1B0c1sxXVxuICAgICAgICB9O1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IHJzLmFycm93U3RhcnRYLFxuICAgICAgICAgIHk6IHJzLmFycm93U3RhcnRZXG4gICAgICAgIH07XG4gICAgfVxuICB9O1xuXG4gIEJScCRiLmdldFRhcmdldEVuZHBvaW50ID0gZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICB2YXIgcnMgPSBlZGdlWzBdLl9wcml2YXRlLnJzY3JhdGNoO1xuICAgIHRoaXMucmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlKGVkZ2UpO1xuXG4gICAgc3dpdGNoIChycy5lZGdlVHlwZSkge1xuICAgICAgY2FzZSAnaGF5c3RhY2snOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IHJzLmhheXN0YWNrUHRzWzJdLFxuICAgICAgICAgIHk6IHJzLmhheXN0YWNrUHRzWzNdXG4gICAgICAgIH07XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogcnMuYXJyb3dFbmRYLFxuICAgICAgICAgIHk6IHJzLmFycm93RW5kWVxuICAgICAgICB9O1xuICAgIH1cbiAgfTtcblxuICB2YXIgQlJwJGEgPSB7fTtcblxuICBmdW5jdGlvbiBwdXNoQmV6aWVyUHRzKHIsIGVkZ2UsIHB0cykge1xuICAgIHZhciBxYmV6aWVyQXQkMSA9IGZ1bmN0aW9uIHFiZXppZXJBdCQxKHAxLCBwMiwgcDMsIHQpIHtcbiAgICAgIHJldHVybiBxYmV6aWVyQXQocDEsIHAyLCBwMywgdCk7XG4gICAgfTtcblxuICAgIHZhciBfcCA9IGVkZ2UuX3ByaXZhdGU7XG4gICAgdmFyIGJwdHMgPSBfcC5yc3R5bGUuYmV6aWVyUHRzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByLmJlemllclByb2pQY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcCA9IHIuYmV6aWVyUHJvalBjdHNbaV07XG4gICAgICBicHRzLnB1c2goe1xuICAgICAgICB4OiBxYmV6aWVyQXQkMShwdHNbMF0sIHB0c1syXSwgcHRzWzRdLCBwKSxcbiAgICAgICAgeTogcWJlemllckF0JDEocHRzWzFdLCBwdHNbM10sIHB0c1s1XSwgcClcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIEJScCRhLnN0b3JlRWRnZVByb2plY3Rpb25zID0gZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICB2YXIgX3AgPSBlZGdlLl9wcml2YXRlO1xuICAgIHZhciBycyA9IF9wLnJzY3JhdGNoO1xuICAgIHZhciBldCA9IHJzLmVkZ2VUeXBlOyAvLyBjbGVhciB0aGUgY2FjaGVkIHBvaW50cyBzdGF0ZVxuXG4gICAgX3AucnN0eWxlLmJlemllclB0cyA9IG51bGw7XG4gICAgX3AucnN0eWxlLmxpbmVQdHMgPSBudWxsO1xuICAgIF9wLnJzdHlsZS5oYXlzdGFja1B0cyA9IG51bGw7XG5cbiAgICBpZiAoZXQgPT09ICdtdWx0aWJlemllcicgfHwgZXQgPT09ICdiZXppZXInIHx8IGV0ID09PSAnc2VsZicgfHwgZXQgPT09ICdjb21wb3VuZCcpIHtcbiAgICAgIF9wLnJzdHlsZS5iZXppZXJQdHMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgKyA1IDwgcnMuYWxscHRzLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICAgIHB1c2hCZXppZXJQdHModGhpcywgZWRnZSwgcnMuYWxscHRzLnNsaWNlKGksIGkgKyA2KSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChldCA9PT0gJ3NlZ21lbnRzJykge1xuICAgICAgdmFyIGxwdHMgPSBfcC5yc3R5bGUubGluZVB0cyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSArIDEgPCBycy5hbGxwdHMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgbHB0cy5wdXNoKHtcbiAgICAgICAgICB4OiBycy5hbGxwdHNbaV0sXG4gICAgICAgICAgeTogcnMuYWxscHRzW2kgKyAxXVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGV0ID09PSAnaGF5c3RhY2snKSB7XG4gICAgICB2YXIgaHB0cyA9IHJzLmhheXN0YWNrUHRzO1xuICAgICAgX3AucnN0eWxlLmhheXN0YWNrUHRzID0gW3tcbiAgICAgICAgeDogaHB0c1swXSxcbiAgICAgICAgeTogaHB0c1sxXVxuICAgICAgfSwge1xuICAgICAgICB4OiBocHRzWzJdLFxuICAgICAgICB5OiBocHRzWzNdXG4gICAgICB9XTtcbiAgICB9XG5cbiAgICBfcC5yc3R5bGUuYXJyb3dXaWR0aCA9IHRoaXMuZ2V0QXJyb3dXaWR0aChlZGdlLnBzdHlsZSgnd2lkdGgnKS5wZlZhbHVlLCBlZGdlLnBzdHlsZSgnYXJyb3ctc2NhbGUnKS52YWx1ZSkgKiB0aGlzLmFycm93U2hhcGVXaWR0aDtcbiAgfTtcblxuICBCUnAkYS5yZWNhbGN1bGF0ZUVkZ2VQcm9qZWN0aW9ucyA9IGZ1bmN0aW9uIChlZGdlcykge1xuICAgIHRoaXMuZmluZEVkZ2VDb250cm9sUG9pbnRzKGVkZ2VzKTtcbiAgfTtcblxuICAvKiBnbG9iYWwgZG9jdW1lbnQgKi9cblxuICB2YXIgQlJwJDkgPSB7fTtcblxuICBCUnAkOS5yZWNhbGN1bGF0ZU5vZGVMYWJlbFByb2plY3Rpb24gPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIHZhciBjb250ZW50ID0gbm9kZS5wc3R5bGUoJ2xhYmVsJykuc3RyVmFsdWU7XG5cbiAgICBpZiAoZW1wdHlTdHJpbmcoY29udGVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdGV4dFgsIHRleHRZO1xuICAgIHZhciBfcCA9IG5vZGUuX3ByaXZhdGU7XG4gICAgdmFyIG5vZGVXaWR0aCA9IG5vZGUud2lkdGgoKTtcbiAgICB2YXIgbm9kZUhlaWdodCA9IG5vZGUuaGVpZ2h0KCk7XG4gICAgdmFyIHBhZGRpbmcgPSBub2RlLnBhZGRpbmcoKTtcbiAgICB2YXIgbm9kZVBvcyA9IG5vZGUucG9zaXRpb24oKTtcbiAgICB2YXIgdGV4dEhhbGlnbiA9IG5vZGUucHN0eWxlKCd0ZXh0LWhhbGlnbicpLnN0clZhbHVlO1xuICAgIHZhciB0ZXh0VmFsaWduID0gbm9kZS5wc3R5bGUoJ3RleHQtdmFsaWduJykuc3RyVmFsdWU7XG4gICAgdmFyIHJzID0gX3AucnNjcmF0Y2g7XG4gICAgdmFyIHJzdHlsZSA9IF9wLnJzdHlsZTtcblxuICAgIHN3aXRjaCAodGV4dEhhbGlnbikge1xuICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgIHRleHRYID0gbm9kZVBvcy54IC0gbm9kZVdpZHRoIC8gMiAtIHBhZGRpbmc7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgIHRleHRYID0gbm9kZVBvcy54ICsgbm9kZVdpZHRoIC8gMiArIHBhZGRpbmc7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBlLmcuIGNlbnRlclxuICAgICAgICB0ZXh0WCA9IG5vZGVQb3MueDtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRleHRWYWxpZ24pIHtcbiAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgIHRleHRZID0gbm9kZVBvcy55IC0gbm9kZUhlaWdodCAvIDIgLSBwYWRkaW5nO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgdGV4dFkgPSBub2RlUG9zLnkgKyBub2RlSGVpZ2h0IC8gMiArIHBhZGRpbmc7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBlLmcuIG1pZGRsZVxuICAgICAgICB0ZXh0WSA9IG5vZGVQb3MueTtcbiAgICB9XG5cbiAgICBycy5sYWJlbFggPSB0ZXh0WDtcbiAgICBycy5sYWJlbFkgPSB0ZXh0WTtcbiAgICByc3R5bGUubGFiZWxYID0gdGV4dFg7XG4gICAgcnN0eWxlLmxhYmVsWSA9IHRleHRZO1xuICAgIHRoaXMuY2FsY3VsYXRlTGFiZWxBbmdsZXMobm9kZSk7XG4gICAgdGhpcy5hcHBseUxhYmVsRGltZW5zaW9ucyhub2RlKTtcbiAgfTtcblxuICB2YXIgbGluZUFuZ2xlRnJvbURlbHRhID0gZnVuY3Rpb24gbGluZUFuZ2xlRnJvbURlbHRhKGR4LCBkeSkge1xuICAgIHZhciBhbmdsZSA9IE1hdGguYXRhbihkeSAvIGR4KTtcblxuICAgIGlmIChkeCA9PT0gMCAmJiBhbmdsZSA8IDApIHtcbiAgICAgIGFuZ2xlID0gYW5nbGUgKiAtMTtcbiAgICB9XG5cbiAgICByZXR1cm4gYW5nbGU7XG4gIH07XG5cbiAgdmFyIGxpbmVBbmdsZSA9IGZ1bmN0aW9uIGxpbmVBbmdsZShwMCwgcDEpIHtcbiAgICB2YXIgZHggPSBwMS54IC0gcDAueDtcbiAgICB2YXIgZHkgPSBwMS55IC0gcDAueTtcbiAgICByZXR1cm4gbGluZUFuZ2xlRnJvbURlbHRhKGR4LCBkeSk7XG4gIH07XG5cbiAgdmFyIGJlemllckFuZ2xlID0gZnVuY3Rpb24gYmV6aWVyQW5nbGUocDAsIHAxLCBwMiwgdCkge1xuICAgIHZhciB0MCA9IGJvdW5kKDAsIHQgLSAwLjAwMSwgMSk7XG4gICAgdmFyIHQxID0gYm91bmQoMCwgdCArIDAuMDAxLCAxKTtcbiAgICB2YXIgbHAwID0gcWJlemllclB0QXQocDAsIHAxLCBwMiwgdDApO1xuICAgIHZhciBscDEgPSBxYmV6aWVyUHRBdChwMCwgcDEsIHAyLCB0MSk7XG4gICAgcmV0dXJuIGxpbmVBbmdsZShscDAsIGxwMSk7XG4gIH07XG5cbiAgQlJwJDkucmVjYWxjdWxhdGVFZGdlTGFiZWxQcm9qZWN0aW9ucyA9IGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgdmFyIHA7XG4gICAgdmFyIF9wID0gZWRnZS5fcHJpdmF0ZTtcbiAgICB2YXIgcnMgPSBfcC5yc2NyYXRjaDtcbiAgICB2YXIgciA9IHRoaXM7XG4gICAgdmFyIGNvbnRlbnQgPSB7XG4gICAgICBtaWQ6IGVkZ2UucHN0eWxlKCdsYWJlbCcpLnN0clZhbHVlLFxuICAgICAgc291cmNlOiBlZGdlLnBzdHlsZSgnc291cmNlLWxhYmVsJykuc3RyVmFsdWUsXG4gICAgICB0YXJnZXQ6IGVkZ2UucHN0eWxlKCd0YXJnZXQtbGFiZWwnKS5zdHJWYWx1ZVxuICAgIH07XG5cbiAgICBpZiAoY29udGVudC5taWQgfHwgY29udGVudC5zb3VyY2UgfHwgY29udGVudC50YXJnZXQpIDsgZWxzZSB7XG4gICAgICByZXR1cm47IC8vIG5vIGxhYmVscyA9PiBubyBjYWxjc1xuICAgIH0gLy8gYWRkIGNlbnRlciBwb2ludCB0byBzdHlsZSBzbyBib3VuZGluZyBib3ggY2FsY3VsYXRpb25zIGNhbiB1c2UgaXRcbiAgICAvL1xuXG5cbiAgICBwID0ge1xuICAgICAgeDogcnMubWlkWCxcbiAgICAgIHk6IHJzLm1pZFlcbiAgICB9O1xuXG4gICAgdmFyIHNldFJzID0gZnVuY3Rpb24gc2V0UnMocHJvcE5hbWUsIHByZWZpeCwgdmFsdWUpIHtcbiAgICAgIHNldFByZWZpeGVkUHJvcGVydHkoX3AucnNjcmF0Y2gsIHByb3BOYW1lLCBwcmVmaXgsIHZhbHVlKTtcbiAgICAgIHNldFByZWZpeGVkUHJvcGVydHkoX3AucnN0eWxlLCBwcm9wTmFtZSwgcHJlZml4LCB2YWx1ZSk7XG4gICAgfTtcblxuICAgIHNldFJzKCdsYWJlbFgnLCBudWxsLCBwLngpO1xuICAgIHNldFJzKCdsYWJlbFknLCBudWxsLCBwLnkpO1xuICAgIHZhciBtaWRBbmdsZSA9IGxpbmVBbmdsZUZyb21EZWx0YShycy5taWREaXNwWCwgcnMubWlkRGlzcFkpO1xuICAgIHNldFJzKCdsYWJlbEF1dG9BbmdsZScsIG51bGwsIG1pZEFuZ2xlKTtcblxuICAgIHZhciBjcmVhdGVDb250cm9sUG9pbnRJbmZvID0gZnVuY3Rpb24gY3JlYXRlQ29udHJvbFBvaW50SW5mbygpIHtcbiAgICAgIGlmIChjcmVhdGVDb250cm9sUG9pbnRJbmZvLmNhY2hlKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVDb250cm9sUG9pbnRJbmZvLmNhY2hlO1xuICAgICAgfSAvLyB1c2UgY2FjaGUgc28gb25seSAxeCBwZXIgZWRnZVxuXG5cbiAgICAgIHZhciBjdHJscHRzID0gW107IC8vIHN0b3JlIGVhY2ggY3RybHB0IGluZm8gaW5pdFxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSArIDUgPCBycy5hbGxwdHMubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgICAgdmFyIHAwID0ge1xuICAgICAgICAgIHg6IHJzLmFsbHB0c1tpXSxcbiAgICAgICAgICB5OiBycy5hbGxwdHNbaSArIDFdXG4gICAgICAgIH07XG4gICAgICAgIHZhciBwMSA9IHtcbiAgICAgICAgICB4OiBycy5hbGxwdHNbaSArIDJdLFxuICAgICAgICAgIHk6IHJzLmFsbHB0c1tpICsgM11cbiAgICAgICAgfTsgLy8gY3RybHB0XG5cbiAgICAgICAgdmFyIHAyID0ge1xuICAgICAgICAgIHg6IHJzLmFsbHB0c1tpICsgNF0sXG4gICAgICAgICAgeTogcnMuYWxscHRzW2kgKyA1XVxuICAgICAgICB9O1xuICAgICAgICBjdHJscHRzLnB1c2goe1xuICAgICAgICAgIHAwOiBwMCxcbiAgICAgICAgICBwMTogcDEsXG4gICAgICAgICAgcDI6IHAyLFxuICAgICAgICAgIHN0YXJ0RGlzdDogMCxcbiAgICAgICAgICBsZW5ndGg6IDAsXG4gICAgICAgICAgc2VnbWVudHM6IFtdXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgYnB0cyA9IF9wLnJzdHlsZS5iZXppZXJQdHM7XG4gICAgICB2YXIgblByb2pzID0gci5iZXppZXJQcm9qUGN0cy5sZW5ndGg7XG5cbiAgICAgIGZ1bmN0aW9uIGFkZFNlZ21lbnQoY3AsIHAwLCBwMSwgdDAsIHQxKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBkaXN0KHAwLCBwMSk7XG4gICAgICAgIHZhciBwcmV2U2VnbWVudCA9IGNwLnNlZ21lbnRzW2NwLnNlZ21lbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgc2VnbWVudCA9IHtcbiAgICAgICAgICBwMDogcDAsXG4gICAgICAgICAgcDE6IHAxLFxuICAgICAgICAgIHQwOiB0MCxcbiAgICAgICAgICB0MTogdDEsXG4gICAgICAgICAgc3RhcnREaXN0OiBwcmV2U2VnbWVudCA/IHByZXZTZWdtZW50LnN0YXJ0RGlzdCArIHByZXZTZWdtZW50Lmxlbmd0aCA6IDAsXG4gICAgICAgICAgbGVuZ3RoOiBsZW5ndGhcbiAgICAgICAgfTtcbiAgICAgICAgY3Auc2VnbWVudHMucHVzaChzZWdtZW50KTtcbiAgICAgICAgY3AubGVuZ3RoICs9IGxlbmd0aDtcbiAgICAgIH0gLy8gdXBkYXRlIGVhY2ggY3RybHB0IHdpdGggc2VnbWVudCBpbmZvXG5cblxuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGN0cmxwdHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBjcCA9IGN0cmxwdHNbX2ldO1xuICAgICAgICB2YXIgcHJldkNwID0gY3RybHB0c1tfaSAtIDFdO1xuXG4gICAgICAgIGlmIChwcmV2Q3ApIHtcbiAgICAgICAgICBjcC5zdGFydERpc3QgPSBwcmV2Q3Auc3RhcnREaXN0ICsgcHJldkNwLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGFkZFNlZ21lbnQoY3AsIGNwLnAwLCBicHRzW19pICogblByb2pzXSwgMCwgci5iZXppZXJQcm9qUGN0c1swXSk7IC8vIGZpcnN0XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBuUHJvanMgLSAxOyBqKyspIHtcbiAgICAgICAgICBhZGRTZWdtZW50KGNwLCBicHRzW19pICogblByb2pzICsgal0sIGJwdHNbX2kgKiBuUHJvanMgKyBqICsgMV0sIHIuYmV6aWVyUHJvalBjdHNbal0sIHIuYmV6aWVyUHJvalBjdHNbaiArIDFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFkZFNlZ21lbnQoY3AsIGJwdHNbX2kgKiBuUHJvanMgKyBuUHJvanMgLSAxXSwgY3AucDIsIHIuYmV6aWVyUHJvalBjdHNbblByb2pzIC0gMV0sIDEpOyAvLyBsYXN0XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjcmVhdGVDb250cm9sUG9pbnRJbmZvLmNhY2hlID0gY3RybHB0cztcbiAgICB9O1xuXG4gICAgdmFyIGNhbGN1bGF0ZUVuZFByb2plY3Rpb24gPSBmdW5jdGlvbiBjYWxjdWxhdGVFbmRQcm9qZWN0aW9uKHByZWZpeCkge1xuICAgICAgdmFyIGFuZ2xlO1xuICAgICAgdmFyIGlzU3JjID0gcHJlZml4ID09PSAnc291cmNlJztcblxuICAgICAgaWYgKCFjb250ZW50W3ByZWZpeF0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgb2Zmc2V0ID0gZWRnZS5wc3R5bGUocHJlZml4ICsgJy10ZXh0LW9mZnNldCcpLnBmVmFsdWU7XG5cbiAgICAgIHN3aXRjaCAocnMuZWRnZVR5cGUpIHtcbiAgICAgICAgY2FzZSAnc2VsZic6XG4gICAgICAgIGNhc2UgJ2NvbXBvdW5kJzpcbiAgICAgICAgY2FzZSAnYmV6aWVyJzpcbiAgICAgICAgY2FzZSAnbXVsdGliZXppZXInOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBjcHMgPSBjcmVhdGVDb250cm9sUG9pbnRJbmZvKCk7XG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWQ7XG4gICAgICAgICAgICB2YXIgc3RhcnREaXN0ID0gMDtcbiAgICAgICAgICAgIHZhciB0b3RhbERpc3QgPSAwOyAvLyBmaW5kIHRoZSBzZWdtZW50IHdlJ3JlIG9uXG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBfY3AgPSBjcHNbaXNTcmMgPyBpIDogY3BzLmxlbmd0aCAtIDEgLSBpXTtcblxuICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IF9jcC5zZWdtZW50cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHZhciBfc2VnID0gX2NwLnNlZ21lbnRzW2lzU3JjID8gaiA6IF9jcC5zZWdtZW50cy5sZW5ndGggLSAxIC0gal07XG4gICAgICAgICAgICAgICAgdmFyIGxhc3RTZWcgPSBpID09PSBjcHMubGVuZ3RoIC0gMSAmJiBqID09PSBfY3Auc2VnbWVudHMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICBzdGFydERpc3QgPSB0b3RhbERpc3Q7XG4gICAgICAgICAgICAgICAgdG90YWxEaXN0ICs9IF9zZWcubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRvdGFsRGlzdCA+PSBvZmZzZXQgfHwgbGFzdFNlZykge1xuICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNwOiBfY3AsXG4gICAgICAgICAgICAgICAgICAgIHNlZ21lbnQ6IF9zZWdcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY3AgPSBzZWxlY3RlZC5jcDtcbiAgICAgICAgICAgIHZhciBzZWcgPSBzZWxlY3RlZC5zZWdtZW50O1xuICAgICAgICAgICAgdmFyIHRTZWdtZW50ID0gKG9mZnNldCAtIHN0YXJ0RGlzdCkgLyBzZWcubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIHNlZ0R0ID0gc2VnLnQxIC0gc2VnLnQwO1xuICAgICAgICAgICAgdmFyIHQgPSBpc1NyYyA/IHNlZy50MCArIHNlZ0R0ICogdFNlZ21lbnQgOiBzZWcudDEgLSBzZWdEdCAqIHRTZWdtZW50O1xuICAgICAgICAgICAgdCA9IGJvdW5kKDAsIHQsIDEpO1xuICAgICAgICAgICAgcCA9IHFiZXppZXJQdEF0KGNwLnAwLCBjcC5wMSwgY3AucDIsIHQpO1xuICAgICAgICAgICAgYW5nbGUgPSBiZXppZXJBbmdsZShjcC5wMCwgY3AucDEsIGNwLnAyLCB0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdzdHJhaWdodCc6XG4gICAgICAgIGNhc2UgJ3NlZ21lbnRzJzpcbiAgICAgICAgY2FzZSAnaGF5c3RhY2snOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBkID0gMCxcbiAgICAgICAgICAgICAgICBkaSxcbiAgICAgICAgICAgICAgICBkMDtcbiAgICAgICAgICAgIHZhciBwMCwgcDE7XG4gICAgICAgICAgICB2YXIgbCA9IHJzLmFsbHB0cy5sZW5ndGg7XG5cbiAgICAgICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiArIDMgPCBsOyBfaTIgKz0gMikge1xuICAgICAgICAgICAgICBpZiAoaXNTcmMpIHtcbiAgICAgICAgICAgICAgICBwMCA9IHtcbiAgICAgICAgICAgICAgICAgIHg6IHJzLmFsbHB0c1tfaTJdLFxuICAgICAgICAgICAgICAgICAgeTogcnMuYWxscHRzW19pMiArIDFdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBwMSA9IHtcbiAgICAgICAgICAgICAgICAgIHg6IHJzLmFsbHB0c1tfaTIgKyAyXSxcbiAgICAgICAgICAgICAgICAgIHk6IHJzLmFsbHB0c1tfaTIgKyAzXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcDAgPSB7XG4gICAgICAgICAgICAgICAgICB4OiBycy5hbGxwdHNbbCAtIDIgLSBfaTJdLFxuICAgICAgICAgICAgICAgICAgeTogcnMuYWxscHRzW2wgLSAxIC0gX2kyXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcDEgPSB7XG4gICAgICAgICAgICAgICAgICB4OiBycy5hbGxwdHNbbCAtIDQgLSBfaTJdLFxuICAgICAgICAgICAgICAgICAgeTogcnMuYWxscHRzW2wgLSAzIC0gX2kyXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBkaSA9IGRpc3QocDAsIHAxKTtcbiAgICAgICAgICAgICAgZDAgPSBkO1xuICAgICAgICAgICAgICBkICs9IGRpO1xuXG4gICAgICAgICAgICAgIGlmIChkID49IG9mZnNldCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwRCA9IG9mZnNldCAtIGQwO1xuXG4gICAgICAgICAgICB2YXIgX3QgPSBwRCAvIGRpO1xuXG4gICAgICAgICAgICBfdCA9IGJvdW5kKDAsIF90LCAxKTtcbiAgICAgICAgICAgIHAgPSBsaW5lQXQocDAsIHAxLCBfdCk7XG4gICAgICAgICAgICBhbmdsZSA9IGxpbmVBbmdsZShwMCwgcDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzZXRScygnbGFiZWxYJywgcHJlZml4LCBwLngpO1xuICAgICAgc2V0UnMoJ2xhYmVsWScsIHByZWZpeCwgcC55KTtcbiAgICAgIHNldFJzKCdsYWJlbEF1dG9BbmdsZScsIHByZWZpeCwgYW5nbGUpO1xuICAgIH07XG5cbiAgICBjYWxjdWxhdGVFbmRQcm9qZWN0aW9uKCdzb3VyY2UnKTtcbiAgICBjYWxjdWxhdGVFbmRQcm9qZWN0aW9uKCd0YXJnZXQnKTtcbiAgICB0aGlzLmFwcGx5TGFiZWxEaW1lbnNpb25zKGVkZ2UpO1xuICB9O1xuXG4gIEJScCQ5LmFwcGx5TGFiZWxEaW1lbnNpb25zID0gZnVuY3Rpb24gKGVsZSkge1xuICAgIHRoaXMuYXBwbHlQcmVmaXhlZExhYmVsRGltZW5zaW9ucyhlbGUpO1xuXG4gICAgaWYgKGVsZS5pc0VkZ2UoKSkge1xuICAgICAgdGhpcy5hcHBseVByZWZpeGVkTGFiZWxEaW1lbnNpb25zKGVsZSwgJ3NvdXJjZScpO1xuICAgICAgdGhpcy5hcHBseVByZWZpeGVkTGFiZWxEaW1lbnNpb25zKGVsZSwgJ3RhcmdldCcpO1xuICAgIH1cbiAgfTtcblxuICBCUnAkOS5hcHBseVByZWZpeGVkTGFiZWxEaW1lbnNpb25zID0gZnVuY3Rpb24gKGVsZSwgcHJlZml4KSB7XG4gICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgIHZhciB0ZXh0ID0gdGhpcy5nZXRMYWJlbFRleHQoZWxlLCBwcmVmaXgpO1xuICAgIHZhciBsYWJlbERpbXMgPSB0aGlzLmNhbGN1bGF0ZUxhYmVsRGltZW5zaW9ucyhlbGUsIHRleHQpO1xuICAgIHZhciBsaW5lSGVpZ2h0ID0gZWxlLnBzdHlsZSgnbGluZS1oZWlnaHQnKS5wZlZhbHVlO1xuICAgIHZhciB0ZXh0V3JhcCA9IGVsZS5wc3R5bGUoJ3RleHQtd3JhcCcpLnN0clZhbHVlO1xuICAgIHZhciBsaW5lcyA9IGdldFByZWZpeGVkUHJvcGVydHkoX3AucnNjcmF0Y2gsICdsYWJlbFdyYXBDYWNoZWRMaW5lcycsIHByZWZpeCkgfHwgW107XG4gICAgdmFyIG51bUxpbmVzID0gdGV4dFdyYXAgIT09ICd3cmFwJyA/IDEgOiBNYXRoLm1heChsaW5lcy5sZW5ndGgsIDEpO1xuICAgIHZhciBub3JtUGVyTGluZUhlaWdodCA9IGxhYmVsRGltcy5oZWlnaHQgLyBudW1MaW5lcztcbiAgICB2YXIgbGFiZWxMaW5lSGVpZ2h0ID0gbm9ybVBlckxpbmVIZWlnaHQgKiBsaW5lSGVpZ2h0O1xuICAgIHZhciB3aWR0aCA9IGxhYmVsRGltcy53aWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gbGFiZWxEaW1zLmhlaWdodCArIChudW1MaW5lcyAtIDEpICogKGxpbmVIZWlnaHQgLSAxKSAqIG5vcm1QZXJMaW5lSGVpZ2h0O1xuICAgIHNldFByZWZpeGVkUHJvcGVydHkoX3AucnN0eWxlLCAnbGFiZWxXaWR0aCcsIHByZWZpeCwgd2lkdGgpO1xuICAgIHNldFByZWZpeGVkUHJvcGVydHkoX3AucnNjcmF0Y2gsICdsYWJlbFdpZHRoJywgcHJlZml4LCB3aWR0aCk7XG4gICAgc2V0UHJlZml4ZWRQcm9wZXJ0eShfcC5yc3R5bGUsICdsYWJlbEhlaWdodCcsIHByZWZpeCwgaGVpZ2h0KTtcbiAgICBzZXRQcmVmaXhlZFByb3BlcnR5KF9wLnJzY3JhdGNoLCAnbGFiZWxIZWlnaHQnLCBwcmVmaXgsIGhlaWdodCk7XG4gICAgc2V0UHJlZml4ZWRQcm9wZXJ0eShfcC5yc2NyYXRjaCwgJ2xhYmVsTGluZUhlaWdodCcsIHByZWZpeCwgbGFiZWxMaW5lSGVpZ2h0KTtcbiAgfTtcblxuICBCUnAkOS5nZXRMYWJlbFRleHQgPSBmdW5jdGlvbiAoZWxlLCBwcmVmaXgpIHtcbiAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgdmFyIHBmZCA9IHByZWZpeCA/IHByZWZpeCArICctJyA6ICcnO1xuICAgIHZhciB0ZXh0ID0gZWxlLnBzdHlsZShwZmQgKyAnbGFiZWwnKS5zdHJWYWx1ZTtcbiAgICB2YXIgdGV4dFRyYW5zZm9ybSA9IGVsZS5wc3R5bGUoJ3RleHQtdHJhbnNmb3JtJykudmFsdWU7XG5cbiAgICB2YXIgcnNjcmF0Y2ggPSBmdW5jdGlvbiByc2NyYXRjaChwcm9wTmFtZSwgdmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBzZXRQcmVmaXhlZFByb3BlcnR5KF9wLnJzY3JhdGNoLCBwcm9wTmFtZSwgcHJlZml4LCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBnZXRQcmVmaXhlZFByb3BlcnR5KF9wLnJzY3JhdGNoLCBwcm9wTmFtZSwgcHJlZml4KTtcbiAgICAgIH1cbiAgICB9OyAvLyBmb3IgZW1wdHkgdGV4dCwgc2tpcCBhbGwgcHJvY2Vzc2luZ1xuXG5cbiAgICBpZiAoIXRleHQpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICBpZiAodGV4dFRyYW5zZm9ybSA9PSAnbm9uZScpIDsgZWxzZSBpZiAodGV4dFRyYW5zZm9ybSA9PSAndXBwZXJjYXNlJykge1xuICAgICAgdGV4dCA9IHRleHQudG9VcHBlckNhc2UoKTtcbiAgICB9IGVsc2UgaWYgKHRleHRUcmFuc2Zvcm0gPT0gJ2xvd2VyY2FzZScpIHtcbiAgICAgIHRleHQgPSB0ZXh0LnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgdmFyIHdyYXBTdHlsZSA9IGVsZS5wc3R5bGUoJ3RleHQtd3JhcCcpLnZhbHVlO1xuXG4gICAgaWYgKHdyYXBTdHlsZSA9PT0gJ3dyYXAnKSB7XG4gICAgICB2YXIgbGFiZWxLZXkgPSByc2NyYXRjaCgnbGFiZWxLZXknKTsgLy8gc2F2ZSByZWNhbGMgaWYgdGhlIGxhYmVsIGlzIHRoZSBzYW1lIGFzIGJlZm9yZVxuXG4gICAgICBpZiAobGFiZWxLZXkgIT0gbnVsbCAmJiByc2NyYXRjaCgnbGFiZWxXcmFwS2V5JykgPT09IGxhYmVsS2V5KSB7XG4gICAgICAgIHJldHVybiByc2NyYXRjaCgnbGFiZWxXcmFwQ2FjaGVkVGV4dCcpO1xuICAgICAgfVxuXG4gICAgICB2YXIgendzcCA9IFwiXFx1MjAwQlwiO1xuICAgICAgdmFyIGxpbmVzID0gdGV4dC5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgbWF4VyA9IGVsZS5wc3R5bGUoJ3RleHQtbWF4LXdpZHRoJykucGZWYWx1ZTtcbiAgICAgIHZhciBvdmVyZmxvdyA9IGVsZS5wc3R5bGUoJ3RleHQtb3ZlcmZsb3ctd3JhcCcpLnZhbHVlO1xuICAgICAgdmFyIG92ZXJmbG93QW55ID0gb3ZlcmZsb3cgPT09ICdhbnl3aGVyZSc7XG4gICAgICB2YXIgd3JhcHBlZExpbmVzID0gW107XG4gICAgICB2YXIgd29yZHNSZWdleCA9IC9bXFxzXFx1MjAwYl0rLztcbiAgICAgIHZhciB3b3JkU2VwYXJhdG9yID0gb3ZlcmZsb3dBbnkgPyAnJyA6ICcgJztcblxuICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCBsaW5lcy5sZW5ndGg7IGwrKykge1xuICAgICAgICB2YXIgbGluZSA9IGxpbmVzW2xdO1xuICAgICAgICB2YXIgbGluZURpbXMgPSB0aGlzLmNhbGN1bGF0ZUxhYmVsRGltZW5zaW9ucyhlbGUsIGxpbmUpO1xuICAgICAgICB2YXIgbGluZVcgPSBsaW5lRGltcy53aWR0aDtcblxuICAgICAgICBpZiAob3ZlcmZsb3dBbnkpIHtcbiAgICAgICAgICB2YXIgcHJvY2Vzc2VkTGluZSA9IGxpbmUuc3BsaXQoJycpLmpvaW4oendzcCk7XG4gICAgICAgICAgbGluZSA9IHByb2Nlc3NlZExpbmU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGluZVcgPiBtYXhXKSB7XG4gICAgICAgICAgLy8gbGluZSBpcyB0b28gbG9uZ1xuICAgICAgICAgIHZhciB3b3JkcyA9IGxpbmUuc3BsaXQod29yZHNSZWdleCk7XG4gICAgICAgICAgdmFyIHN1YmxpbmUgPSAnJztcblxuICAgICAgICAgIGZvciAodmFyIHcgPSAwOyB3IDwgd29yZHMubGVuZ3RoOyB3KyspIHtcbiAgICAgICAgICAgIHZhciB3b3JkID0gd29yZHNbd107XG4gICAgICAgICAgICB2YXIgdGVzdExpbmUgPSBzdWJsaW5lLmxlbmd0aCA9PT0gMCA/IHdvcmQgOiBzdWJsaW5lICsgd29yZFNlcGFyYXRvciArIHdvcmQ7XG4gICAgICAgICAgICB2YXIgdGVzdERpbXMgPSB0aGlzLmNhbGN1bGF0ZUxhYmVsRGltZW5zaW9ucyhlbGUsIHRlc3RMaW5lKTtcbiAgICAgICAgICAgIHZhciB0ZXN0VyA9IHRlc3REaW1zLndpZHRoO1xuXG4gICAgICAgICAgICBpZiAodGVzdFcgPD0gbWF4Vykge1xuICAgICAgICAgICAgICAvLyB3b3JkIGZpdHMgb24gY3VycmVudCBsaW5lXG4gICAgICAgICAgICAgIHN1YmxpbmUgKz0gd29yZCArIHdvcmRTZXBhcmF0b3I7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyB3b3JkIHN0YXJ0cyBuZXcgbGluZVxuICAgICAgICAgICAgICBpZiAoc3VibGluZSkge1xuICAgICAgICAgICAgICAgIHdyYXBwZWRMaW5lcy5wdXNoKHN1YmxpbmUpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgc3VibGluZSA9IHdvcmQgKyB3b3JkU2VwYXJhdG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gaWYgdGhlcmUncyByZW1haW5pbmcgdGV4dCwgcHV0IGl0IGluIGEgd3JhcHBlZCBsaW5lXG5cblxuICAgICAgICAgIGlmICghc3VibGluZS5tYXRjaCgvXltcXHNcXHUyMDBiXSskLykpIHtcbiAgICAgICAgICAgIHdyYXBwZWRMaW5lcy5wdXNoKHN1YmxpbmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBsaW5lIGlzIGFscmVhZHkgc2hvcnQgZW5vdWdoXG4gICAgICAgICAgd3JhcHBlZExpbmVzLnB1c2gobGluZSk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gZm9yXG5cblxuICAgICAgcnNjcmF0Y2goJ2xhYmVsV3JhcENhY2hlZExpbmVzJywgd3JhcHBlZExpbmVzKTtcbiAgICAgIHRleHQgPSByc2NyYXRjaCgnbGFiZWxXcmFwQ2FjaGVkVGV4dCcsIHdyYXBwZWRMaW5lcy5qb2luKCdcXG4nKSk7XG4gICAgICByc2NyYXRjaCgnbGFiZWxXcmFwS2V5JywgbGFiZWxLZXkpO1xuICAgIH0gZWxzZSBpZiAod3JhcFN0eWxlID09PSAnZWxsaXBzaXMnKSB7XG4gICAgICB2YXIgX21heFcgPSBlbGUucHN0eWxlKCd0ZXh0LW1heC13aWR0aCcpLnBmVmFsdWU7XG4gICAgICB2YXIgZWxsaXBzaXplZCA9ICcnO1xuICAgICAgdmFyIGVsbGlwc2lzID0gXCJcXHUyMDI2XCI7XG4gICAgICB2YXIgaW5jTGFzdENoID0gZmFsc2U7XG5cbiAgICAgIGlmICh0aGlzLmNhbGN1bGF0ZUxhYmVsRGltZW5zaW9ucyhlbGUsIHRleHQpLndpZHRoIDwgX21heFcpIHtcbiAgICAgICAgLy8gdGhlIGxhYmVsIGFscmVhZHkgZml0c1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB3aWR0aFdpdGhOZXh0Q2ggPSB0aGlzLmNhbGN1bGF0ZUxhYmVsRGltZW5zaW9ucyhlbGUsIGVsbGlwc2l6ZWQgKyB0ZXh0W2ldICsgZWxsaXBzaXMpLndpZHRoO1xuXG4gICAgICAgIGlmICh3aWR0aFdpdGhOZXh0Q2ggPiBfbWF4Vykge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxsaXBzaXplZCArPSB0ZXh0W2ldO1xuXG4gICAgICAgIGlmIChpID09PSB0ZXh0Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBpbmNMYXN0Q2ggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghaW5jTGFzdENoKSB7XG4gICAgICAgIGVsbGlwc2l6ZWQgKz0gZWxsaXBzaXM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbGxpcHNpemVkO1xuICAgIH0gLy8gaWYgZWxsaXBzaXplXG5cblxuICAgIHJldHVybiB0ZXh0O1xuICB9O1xuXG4gIEJScCQ5LmdldExhYmVsSnVzdGlmaWNhdGlvbiA9IGZ1bmN0aW9uIChlbGUpIHtcbiAgICB2YXIganVzdGlmaWNhdGlvbiA9IGVsZS5wc3R5bGUoJ3RleHQtanVzdGlmaWNhdGlvbicpLnN0clZhbHVlO1xuICAgIHZhciB0ZXh0SGFsaWduID0gZWxlLnBzdHlsZSgndGV4dC1oYWxpZ24nKS5zdHJWYWx1ZTtcblxuICAgIGlmIChqdXN0aWZpY2F0aW9uID09PSAnYXV0bycpIHtcbiAgICAgIGlmIChlbGUuaXNOb2RlKCkpIHtcbiAgICAgICAgc3dpdGNoICh0ZXh0SGFsaWduKSB7XG4gICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICByZXR1cm4gJ3JpZ2h0JztcblxuICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgIHJldHVybiAnbGVmdCc7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuICdjZW50ZXInO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gJ2NlbnRlcic7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBqdXN0aWZpY2F0aW9uO1xuICAgIH1cbiAgfTtcblxuICBCUnAkOS5jYWxjdWxhdGVMYWJlbERpbWVuc2lvbnMgPSBmdW5jdGlvbiAoZWxlLCB0ZXh0KSB7XG4gICAgdmFyIHIgPSB0aGlzO1xuICAgIHZhciBjYWNoZUtleSA9IGhhc2hTdHJpbmcodGV4dCwgZWxlLl9wcml2YXRlLmxhYmVsRGltc0tleSk7XG4gICAgdmFyIGNhY2hlID0gci5sYWJlbERpbUNhY2hlIHx8IChyLmxhYmVsRGltQ2FjaGUgPSBbXSk7XG4gICAgdmFyIGV4aXN0aW5nVmFsID0gY2FjaGVbY2FjaGVLZXldO1xuXG4gICAgaWYgKGV4aXN0aW5nVmFsICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBleGlzdGluZ1ZhbDtcbiAgICB9XG5cbiAgICB2YXIgcGFkZGluZyA9IDA7IC8vIGFkZCBwYWRkaW5nIGFyb3VuZCB0ZXh0IGRpbXMsIGFzIHRoZSBtZWFzdXJlbWVudCBpc24ndCB0aGF0IGFjY3VyYXRlXG5cbiAgICB2YXIgZlN0eWxlID0gZWxlLnBzdHlsZSgnZm9udC1zdHlsZScpLnN0clZhbHVlO1xuICAgIHZhciBzaXplID0gZWxlLnBzdHlsZSgnZm9udC1zaXplJykucGZWYWx1ZTtcbiAgICB2YXIgZmFtaWx5ID0gZWxlLnBzdHlsZSgnZm9udC1mYW1pbHknKS5zdHJWYWx1ZTtcbiAgICB2YXIgd2VpZ2h0ID0gZWxlLnBzdHlsZSgnZm9udC13ZWlnaHQnKS5zdHJWYWx1ZTtcbiAgICB2YXIgY2FudmFzID0gdGhpcy5sYWJlbENhbGNDYW52YXM7XG4gICAgdmFyIGMyZCA9IHRoaXMubGFiZWxDYWxjQ2FudmFzQ29udGV4dDtcblxuICAgIGlmICghY2FudmFzKSB7XG4gICAgICBjYW52YXMgPSB0aGlzLmxhYmVsQ2FsY0NhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgYzJkID0gdGhpcy5sYWJlbENhbGNDYW52YXNDb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICB2YXIgZHMgPSBjYW52YXMuc3R5bGU7XG4gICAgICBkcy5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICBkcy5sZWZ0ID0gJy05OTk5cHgnO1xuICAgICAgZHMudG9wID0gJy05OTk5cHgnO1xuICAgICAgZHMuekluZGV4ID0gJy0xJztcbiAgICAgIGRzLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgIGRzLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgfVxuXG4gICAgYzJkLmZvbnQgPSBcIlwiLmNvbmNhdChmU3R5bGUsIFwiIFwiKS5jb25jYXQod2VpZ2h0LCBcIiBcIikuY29uY2F0KHNpemUsIFwicHggXCIpLmNvbmNhdChmYW1pbHkpO1xuICAgIHZhciB3aWR0aCA9IDA7XG4gICAgdmFyIGhlaWdodCA9IDA7XG4gICAgdmFyIGxpbmVzID0gdGV4dC5zcGxpdCgnXFxuJyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbGluZSA9IGxpbmVzW2ldO1xuICAgICAgdmFyIG1ldHJpY3MgPSBjMmQubWVhc3VyZVRleHQobGluZSk7XG4gICAgICB2YXIgdyA9IE1hdGguY2VpbChtZXRyaWNzLndpZHRoKTtcbiAgICAgIHZhciBoID0gc2l6ZTtcbiAgICAgIHdpZHRoID0gTWF0aC5tYXgodywgd2lkdGgpO1xuICAgICAgaGVpZ2h0ICs9IGg7XG4gICAgfVxuXG4gICAgd2lkdGggKz0gcGFkZGluZztcbiAgICBoZWlnaHQgKz0gcGFkZGluZztcbiAgICByZXR1cm4gY2FjaGVbY2FjaGVLZXldID0ge1xuICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICB9O1xuICB9O1xuXG4gIEJScCQ5LmNhbGN1bGF0ZUxhYmVsQW5nbGUgPSBmdW5jdGlvbiAoZWxlLCBwcmVmaXgpIHtcbiAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgdmFyIHJzID0gX3AucnNjcmF0Y2g7XG4gICAgdmFyIGlzRWRnZSA9IGVsZS5pc0VkZ2UoKTtcbiAgICB2YXIgcHJlZml4RGFzaCA9IHByZWZpeCA/IHByZWZpeCArICctJyA6ICcnO1xuICAgIHZhciByb3QgPSBlbGUucHN0eWxlKHByZWZpeERhc2ggKyAndGV4dC1yb3RhdGlvbicpO1xuICAgIHZhciByb3RTdHIgPSByb3Quc3RyVmFsdWU7XG5cbiAgICBpZiAocm90U3RyID09PSAnbm9uZScpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZSBpZiAoaXNFZGdlICYmIHJvdFN0ciA9PT0gJ2F1dG9yb3RhdGUnKSB7XG4gICAgICByZXR1cm4gcnMubGFiZWxBdXRvQW5nbGU7XG4gICAgfSBlbHNlIGlmIChyb3RTdHIgPT09ICdhdXRvcm90YXRlJykge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByb3QucGZWYWx1ZTtcbiAgICB9XG4gIH07XG5cbiAgQlJwJDkuY2FsY3VsYXRlTGFiZWxBbmdsZXMgPSBmdW5jdGlvbiAoZWxlKSB7XG4gICAgdmFyIHIgPSB0aGlzO1xuICAgIHZhciBpc0VkZ2UgPSBlbGUuaXNFZGdlKCk7XG4gICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgIHZhciBycyA9IF9wLnJzY3JhdGNoO1xuICAgIHJzLmxhYmVsQW5nbGUgPSByLmNhbGN1bGF0ZUxhYmVsQW5nbGUoZWxlKTtcblxuICAgIGlmIChpc0VkZ2UpIHtcbiAgICAgIHJzLnNvdXJjZUxhYmVsQW5nbGUgPSByLmNhbGN1bGF0ZUxhYmVsQW5nbGUoZWxlLCAnc291cmNlJyk7XG4gICAgICBycy50YXJnZXRMYWJlbEFuZ2xlID0gci5jYWxjdWxhdGVMYWJlbEFuZ2xlKGVsZSwgJ3RhcmdldCcpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgQlJwJDggPSB7fTtcbiAgdmFyIFRPT19TTUFMTF9DVVRfUkVDVCA9IDI4O1xuICB2YXIgd2FybmVkQ3V0UmVjdCA9IGZhbHNlO1xuXG4gIEJScCQ4LmdldE5vZGVTaGFwZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgdmFyIHIgPSB0aGlzO1xuICAgIHZhciBzaGFwZSA9IG5vZGUucHN0eWxlKCdzaGFwZScpLnZhbHVlO1xuXG4gICAgaWYgKHNoYXBlID09PSAnY3V0cmVjdGFuZ2xlJyAmJiAobm9kZS53aWR0aCgpIDwgVE9PX1NNQUxMX0NVVF9SRUNUIHx8IG5vZGUuaGVpZ2h0KCkgPCBUT09fU01BTExfQ1VUX1JFQ1QpKSB7XG4gICAgICBpZiAoIXdhcm5lZEN1dFJlY3QpIHtcbiAgICAgICAgd2FybignVGhlIGBjdXRyZWN0YW5nbGVgIG5vZGUgc2hhcGUgY2FuIG5vdCBiZSB1c2VkIGF0IHNtYWxsIHNpemVzIHNvIGByZWN0YW5nbGVgIGlzIHVzZWQgaW5zdGVhZCcpO1xuICAgICAgICB3YXJuZWRDdXRSZWN0ID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICdyZWN0YW5nbGUnO1xuICAgIH1cblxuICAgIGlmIChub2RlLmlzUGFyZW50KCkpIHtcbiAgICAgIGlmIChzaGFwZSA9PT0gJ3JlY3RhbmdsZScgfHwgc2hhcGUgPT09ICdyb3VuZHJlY3RhbmdsZScgfHwgc2hhcGUgPT09ICdyb3VuZC1yZWN0YW5nbGUnIHx8IHNoYXBlID09PSAnY3V0cmVjdGFuZ2xlJyB8fCBzaGFwZSA9PT0gJ2N1dC1yZWN0YW5nbGUnIHx8IHNoYXBlID09PSAnYmFycmVsJykge1xuICAgICAgICByZXR1cm4gc2hhcGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gJ3JlY3RhbmdsZSc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNoYXBlID09PSAncG9seWdvbicpIHtcbiAgICAgIHZhciBwb2ludHMgPSBub2RlLnBzdHlsZSgnc2hhcGUtcG9seWdvbi1wb2ludHMnKS52YWx1ZTtcbiAgICAgIHJldHVybiByLm5vZGVTaGFwZXMubWFrZVBvbHlnb24ocG9pbnRzKS5uYW1lO1xuICAgIH1cblxuICAgIHJldHVybiBzaGFwZTtcbiAgfTtcblxuICB2YXIgQlJwJDcgPSB7fTtcblxuICBCUnAkNy5yZWdpc3RlckNhbGN1bGF0aW9uTGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjeSA9IHRoaXMuY3k7XG4gICAgdmFyIGVsZXNUb1VwZGF0ZSA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICB2YXIgciA9IHRoaXM7XG5cbiAgICB2YXIgZW5xdWV1ZSA9IGZ1bmN0aW9uIGVucXVldWUoZWxlcykge1xuICAgICAgdmFyIGRpcnR5U3R5bGVDYWNoZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgICBlbGVzVG9VcGRhdGUubWVyZ2UoZWxlcyk7XG5cbiAgICAgIGlmIChkaXJ0eVN0eWxlQ2FjaGVzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICAgICAgICB2YXIgcnN0eWxlID0gX3AucnN0eWxlO1xuICAgICAgICAgIHJzdHlsZS5jbGVhbiA9IGZhbHNlO1xuICAgICAgICAgIHJzdHlsZS5jbGVhbkNvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHIuYmluZGVyKGN5KS5vbignYm91bmRzLiogZGlydHkuKicsIGZ1bmN0aW9uIG9uRGlydHlCb3VuZHMoZSkge1xuICAgICAgdmFyIGVsZSA9IGUudGFyZ2V0O1xuICAgICAgZW5xdWV1ZShlbGUpO1xuICAgIH0pLm9uKCdzdHlsZS4qIGJhY2tncm91bmQuKicsIGZ1bmN0aW9uIG9uRGlydHlTdHlsZShlKSB7XG4gICAgICB2YXIgZWxlID0gZS50YXJnZXQ7XG4gICAgICBlbnF1ZXVlKGVsZSwgZmFsc2UpO1xuICAgIH0pO1xuXG4gICAgdmFyIHVwZGF0ZUVsZUNhbGNzID0gZnVuY3Rpb24gdXBkYXRlRWxlQ2FsY3Mod2lsbERyYXcpIHtcbiAgICAgIGlmICh3aWxsRHJhdykge1xuICAgICAgICB2YXIgZm5zID0gci5vblVwZGF0ZUVsZUNhbGNzRm5zOyAvLyBiZWNhdXNlIHdlIG5lZWQgdG8gaGF2ZSB1cC10by1kYXRlIHN0eWxlIChlLmcuIHN0eWxlc2hlZXQgbWFwcGVycylcbiAgICAgICAgLy8gYmVmb3JlIGNhbGN1bGF0aW5nIHJlbmRlcmVkIHN0eWxlIChhbmQgcHN0eWxlIG1pZ2h0IG5vdCBiZSBjYWxsZWQgeWV0KVxuXG4gICAgICAgIGVsZXNUb1VwZGF0ZS5jbGVhblN0eWxlKCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzVG9VcGRhdGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZWxlID0gZWxlc1RvVXBkYXRlW2ldO1xuICAgICAgICAgIHZhciByc3R5bGUgPSBlbGUuX3ByaXZhdGUucnN0eWxlO1xuXG4gICAgICAgICAgaWYgKGVsZS5pc05vZGUoKSAmJiAhcnN0eWxlLmNsZWFuQ29ubmVjdGVkKSB7XG4gICAgICAgICAgICBlbnF1ZXVlKGVsZS5jb25uZWN0ZWRFZGdlcygpKTtcbiAgICAgICAgICAgIHJzdHlsZS5jbGVhbkNvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZucykge1xuICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBmbnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgZm4gPSBmbnNbX2ldO1xuICAgICAgICAgICAgZm4od2lsbERyYXcsIGVsZXNUb1VwZGF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgci5yZWNhbGN1bGF0ZVJlbmRlcmVkU3R5bGUoZWxlc1RvVXBkYXRlKTtcbiAgICAgICAgZWxlc1RvVXBkYXRlID0gY3kuY29sbGVjdGlvbigpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByLmZsdXNoUmVuZGVyZWRTdHlsZVF1ZXVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdXBkYXRlRWxlQ2FsY3ModHJ1ZSk7XG4gICAgfTtcblxuICAgIHIuYmVmb3JlUmVuZGVyKHVwZGF0ZUVsZUNhbGNzLCByLmJlZm9yZVJlbmRlclByaW9yaXRpZXMuZWxlQ2FsY3MpO1xuICB9O1xuXG4gIEJScCQ3Lm9uVXBkYXRlRWxlQ2FsY3MgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICB2YXIgZm5zID0gdGhpcy5vblVwZGF0ZUVsZUNhbGNzRm5zID0gdGhpcy5vblVwZGF0ZUVsZUNhbGNzRm5zIHx8IFtdO1xuICAgIGZucy5wdXNoKGZuKTtcbiAgfTtcblxuICBCUnAkNy5yZWNhbGN1bGF0ZVJlbmRlcmVkU3R5bGUgPSBmdW5jdGlvbiAoZWxlcywgdXNlQ2FjaGUpIHtcbiAgICB2YXIgaXNDbGVhbkNvbm5lY3RlZCA9IGZ1bmN0aW9uIGlzQ2xlYW5Db25uZWN0ZWQoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLl9wcml2YXRlLnJzdHlsZS5jbGVhbkNvbm5lY3RlZDtcbiAgICB9O1xuXG4gICAgdmFyIGVkZ2VzID0gW107XG4gICAgdmFyIG5vZGVzID0gW107IC8vIHRoZSByZW5kZXJlciBjYW4ndCBiZSB1c2VkIGZvciBjYWxjcyB3aGVuIGRlc3Ryb3llZCwgZS5nLiBlbGUuYm91bmRpbmdCb3goKVxuXG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyB1c2UgY2FjaGUgYnkgZGVmYXVsdCBmb3IgcGVyZlxuXG5cbiAgICBpZiAodXNlQ2FjaGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdXNlQ2FjaGUgPSB0cnVlO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgICB2YXIgcnN0eWxlID0gX3AucnN0eWxlOyAvLyBhbiBlZGdlIG1heSBiZSBpbXBsaWNpdGx5IGRpcnR5IGIvYyBvZiBvbmUgb2YgaXRzIGNvbm5lY3RlZCBub2Rlc1xuICAgICAgLy8gKGFuZCBhIHJlcXVlc3QgZm9yIHJlY2FsYyBtYXkgY29tZSBpbiBiZXR3ZWVuIGZyYW1lcylcblxuICAgICAgaWYgKGVsZS5pc0VkZ2UoKSAmJiAoIWlzQ2xlYW5Db25uZWN0ZWQoZWxlLnNvdXJjZSgpKSB8fCAhaXNDbGVhbkNvbm5lY3RlZChlbGUudGFyZ2V0KCkpKSkge1xuICAgICAgICByc3R5bGUuY2xlYW4gPSBmYWxzZTtcbiAgICAgIH0gLy8gb25seSB1cGRhdGUgaWYgZGlydHkgYW5kIGluIGdyYXBoXG5cblxuICAgICAgaWYgKHVzZUNhY2hlICYmIHJzdHlsZS5jbGVhbiB8fCBlbGUucmVtb3ZlZCgpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvLyBvbmx5IHVwZGF0ZSBpZiBub3QgZGlzcGxheTogbm9uZVxuXG5cbiAgICAgIGlmIChlbGUucHN0eWxlKCdkaXNwbGF5JykudmFsdWUgPT09ICdub25lJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKF9wLmdyb3VwID09PSAnbm9kZXMnKSB7XG4gICAgICAgIG5vZGVzLnB1c2goZWxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGVkZ2VzXG4gICAgICAgIGVkZ2VzLnB1c2goZWxlKTtcbiAgICAgIH1cblxuICAgICAgcnN0eWxlLmNsZWFuID0gdHJ1ZTtcbiAgICB9IC8vIHVwZGF0ZSBub2RlIGRhdGEgZnJvbSBwcm9qZWN0aW9uc1xuXG5cbiAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBub2Rlcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICB2YXIgX2VsZSA9IG5vZGVzW19pMl07XG4gICAgICB2YXIgX3AyID0gX2VsZS5fcHJpdmF0ZTtcbiAgICAgIHZhciBfcnN0eWxlID0gX3AyLnJzdHlsZTtcblxuICAgICAgdmFyIHBvcyA9IF9lbGUucG9zaXRpb24oKTtcblxuICAgICAgdGhpcy5yZWNhbGN1bGF0ZU5vZGVMYWJlbFByb2plY3Rpb24oX2VsZSk7XG4gICAgICBfcnN0eWxlLm5vZGVYID0gcG9zLng7XG4gICAgICBfcnN0eWxlLm5vZGVZID0gcG9zLnk7XG4gICAgICBfcnN0eWxlLm5vZGVXID0gX2VsZS5wc3R5bGUoJ3dpZHRoJykucGZWYWx1ZTtcbiAgICAgIF9yc3R5bGUubm9kZUggPSBfZWxlLnBzdHlsZSgnaGVpZ2h0JykucGZWYWx1ZTtcbiAgICB9XG5cbiAgICB0aGlzLnJlY2FsY3VsYXRlRWRnZVByb2plY3Rpb25zKGVkZ2VzKTsgLy8gdXBkYXRlIGVkZ2UgZGF0YSBmcm9tIHByb2plY3Rpb25zXG5cbiAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBlZGdlcy5sZW5ndGg7IF9pMysrKSB7XG4gICAgICB2YXIgX2VsZTIgPSBlZGdlc1tfaTNdO1xuICAgICAgdmFyIF9wMyA9IF9lbGUyLl9wcml2YXRlO1xuICAgICAgdmFyIF9yc3R5bGUyID0gX3AzLnJzdHlsZTtcbiAgICAgIHZhciBycyA9IF9wMy5yc2NyYXRjaDsgLy8gdXBkYXRlIHJzdHlsZSBwb3NpdGlvbnNcblxuICAgICAgX3JzdHlsZTIuc3JjWCA9IHJzLmFycm93U3RhcnRYO1xuICAgICAgX3JzdHlsZTIuc3JjWSA9IHJzLmFycm93U3RhcnRZO1xuICAgICAgX3JzdHlsZTIudGd0WCA9IHJzLmFycm93RW5kWDtcbiAgICAgIF9yc3R5bGUyLnRndFkgPSBycy5hcnJvd0VuZFk7XG4gICAgICBfcnN0eWxlMi5taWRYID0gcnMubWlkWDtcbiAgICAgIF9yc3R5bGUyLm1pZFkgPSBycy5taWRZO1xuICAgICAgX3JzdHlsZTIubGFiZWxBbmdsZSA9IHJzLmxhYmVsQW5nbGU7XG4gICAgICBfcnN0eWxlMi5zb3VyY2VMYWJlbEFuZ2xlID0gcnMuc291cmNlTGFiZWxBbmdsZTtcbiAgICAgIF9yc3R5bGUyLnRhcmdldExhYmVsQW5nbGUgPSBycy50YXJnZXRMYWJlbEFuZ2xlO1xuICAgIH1cbiAgfTtcblxuICB2YXIgQlJwJDYgPSB7fTtcblxuICBCUnAkNi51cGRhdGVDYWNoZWRHcmFiYmVkRWxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWxlcyA9IHRoaXMuY2FjaGVkWlNvcnRlZEVsZXM7XG5cbiAgICBpZiAoIWVsZXMpIHtcbiAgICAgIC8vIGp1c3QgbGV0IHRoaXMgYmUgcmVjYWxjdWxhdGVkIG9uIHRoZSBuZXh0IHogc29ydCB0aWNrXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZWxlcy5kcmFnID0gW107XG4gICAgZWxlcy5ub25kcmFnID0gW107XG4gICAgdmFyIGdyYWJUYXJnZXRzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgdmFyIHJzID0gZWxlLl9wcml2YXRlLnJzY3JhdGNoO1xuXG4gICAgICBpZiAoZWxlLmdyYWJiZWQoKSAmJiAhZWxlLmlzUGFyZW50KCkpIHtcbiAgICAgICAgZ3JhYlRhcmdldHMucHVzaChlbGUpO1xuICAgICAgfSBlbHNlIGlmIChycy5pbkRyYWdMYXllcikge1xuICAgICAgICBlbGVzLmRyYWcucHVzaChlbGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlcy5ub25kcmFnLnB1c2goZWxlKTtcbiAgICAgIH1cbiAgICB9IC8vIHB1dCB0aGUgZ3JhYiB0YXJnZXQgbm9kZXMgbGFzdCBzbyBpdCdzIG9uIHRvcCBvZiBpdHMgbmVpZ2hib3VyaG9vZFxuXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyYWJUYXJnZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gZ3JhYlRhcmdldHNbaV07XG4gICAgICBlbGVzLmRyYWcucHVzaChlbGUpO1xuICAgIH1cbiAgfTtcblxuICBCUnAkNi5pbnZhbGlkYXRlQ2FjaGVkWlNvcnRlZEVsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jYWNoZWRaU29ydGVkRWxlcyA9IG51bGw7XG4gIH07XG5cbiAgQlJwJDYuZ2V0Q2FjaGVkWlNvcnRlZEVsZXMgPSBmdW5jdGlvbiAoZm9yY2VSZWNhbGMpIHtcbiAgICBpZiAoZm9yY2VSZWNhbGMgfHwgIXRoaXMuY2FjaGVkWlNvcnRlZEVsZXMpIHtcbiAgICAgIHZhciBlbGVzID0gdGhpcy5jeS5tdXRhYmxlRWxlbWVudHMoKS50b0FycmF5KCk7XG4gICAgICBlbGVzLnNvcnQoekluZGV4U29ydCk7XG4gICAgICBlbGVzLmludGVyYWN0aXZlID0gZWxlcy5maWx0ZXIoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICByZXR1cm4gZWxlLmludGVyYWN0aXZlKCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuY2FjaGVkWlNvcnRlZEVsZXMgPSBlbGVzO1xuICAgICAgdGhpcy51cGRhdGVDYWNoZWRHcmFiYmVkRWxlcygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVzID0gdGhpcy5jYWNoZWRaU29ydGVkRWxlcztcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlcztcbiAgfTtcblxuICB2YXIgQlJwJDUgPSB7fTtcbiAgW0JScCRlLCBCUnAkZCwgQlJwJGMsIEJScCRiLCBCUnAkYSwgQlJwJDksIEJScCQ4LCBCUnAkNywgQlJwJDZdLmZvckVhY2goZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgZXh0ZW5kKEJScCQ1LCBwcm9wcyk7XG4gIH0pO1xuXG4gIHZhciBCUnAkNCA9IHt9O1xuXG4gIEJScCQ0LmdldENhY2hlZEltYWdlID0gZnVuY3Rpb24gKHVybCwgY3Jvc3NPcmlnaW4sIG9uTG9hZCkge1xuICAgIHZhciByID0gdGhpcztcbiAgICB2YXIgaW1hZ2VDYWNoZSA9IHIuaW1hZ2VDYWNoZSA9IHIuaW1hZ2VDYWNoZSB8fCB7fTtcbiAgICB2YXIgY2FjaGUgPSBpbWFnZUNhY2hlW3VybF07XG5cbiAgICBpZiAoY2FjaGUpIHtcbiAgICAgIGlmICghY2FjaGUuaW1hZ2UuY29tcGxldGUpIHtcbiAgICAgICAgY2FjaGUuaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIG9uTG9hZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjYWNoZS5pbWFnZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FjaGUgPSBpbWFnZUNhY2hlW3VybF0gPSBpbWFnZUNhY2hlW3VybF0gfHwge307XG4gICAgICB2YXIgaW1hZ2UgPSBjYWNoZS5pbWFnZSA9IG5ldyBJbWFnZSgpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cbiAgICAgIGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBvbkxvYWQpO1xuICAgICAgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGltYWdlLmVycm9yID0gdHJ1ZTtcbiAgICAgIH0pOyAvLyAjMTU4MiBzYWZhcmkgZG9lc24ndCBsb2FkIGRhdGEgdXJpcyB3aXRoIGNyb3NzT3JpZ2luIHByb3Blcmx5XG4gICAgICAvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTIzOTc4XG5cbiAgICAgIHZhciBkYXRhVXJpUHJlZml4ID0gJ2RhdGE6JztcbiAgICAgIHZhciBpc0RhdGFVcmkgPSB1cmwuc3Vic3RyaW5nKDAsIGRhdGFVcmlQcmVmaXgubGVuZ3RoKS50b0xvd2VyQ2FzZSgpID09PSBkYXRhVXJpUHJlZml4O1xuXG4gICAgICBpZiAoIWlzRGF0YVVyaSkge1xuICAgICAgICAvLyBpZiBjcm9zc29yaWdpbiBpcyAnbnVsbCcoc3RyaW5naWZpZWQpLCB0aGVuIG1hbnVhbGx5IHNldCBpdCB0byBudWxsIFxuICAgICAgICBjcm9zc09yaWdpbiA9IGNyb3NzT3JpZ2luID09PSAnbnVsbCcgPyBudWxsIDogY3Jvc3NPcmlnaW47XG4gICAgICAgIGltYWdlLmNyb3NzT3JpZ2luID0gY3Jvc3NPcmlnaW47IC8vIHByZXZlbnQgdGFpbnRlZCBjYW52YXNcbiAgICAgIH1cblxuICAgICAgaW1hZ2Uuc3JjID0gdXJsO1xuICAgICAgcmV0dXJuIGltYWdlO1xuICAgIH1cbiAgfTtcblxuICB2YXIgQlJwJDMgPSB7fTtcbiAgLyogZ2xvYmFsIGRvY3VtZW50LCB3aW5kb3csIFJlc2l6ZU9ic2VydmVyLCBNdXRhdGlvbk9ic2VydmVyICovXG5cbiAgQlJwJDMucmVnaXN0ZXJCaW5kaW5nID0gZnVuY3Rpb24gKHRhcmdldCwgZXZlbnQsIGhhbmRsZXIsIHVzZUNhcHR1cmUpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoYXJndW1lbnRzLCBbMV0pOyAvLyBjb3B5XG5cbiAgICB2YXIgYiA9IHRoaXMuYmluZGVyKHRhcmdldCk7XG4gICAgcmV0dXJuIGIub24uYXBwbHkoYiwgYXJncyk7XG4gIH07XG5cbiAgQlJwJDMuYmluZGVyID0gZnVuY3Rpb24gKHRndCkge1xuICAgIHZhciByID0gdGhpcztcbiAgICB2YXIgdGd0SXNEb20gPSB0Z3QgPT09IHdpbmRvdyB8fCB0Z3QgPT09IGRvY3VtZW50IHx8IHRndCA9PT0gZG9jdW1lbnQuYm9keSB8fCBkb21FbGVtZW50KHRndCk7XG5cbiAgICBpZiAoci5zdXBwb3J0c1Bhc3NpdmVFdmVudHMgPT0gbnVsbCkge1xuICAgICAgLy8gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vV0lDRy9FdmVudExpc3RlbmVyT3B0aW9ucy9ibG9iL2doLXBhZ2VzL2V4cGxhaW5lci5tZCNmZWF0dXJlLWRldGVjdGlvblxuICAgICAgdmFyIHN1cHBvcnRzUGFzc2l2ZSA9IGZhbHNlO1xuXG4gICAgICB0cnkge1xuICAgICAgICB2YXIgb3B0cyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3Bhc3NpdmUnLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICBzdXBwb3J0c1Bhc3NpdmUgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsLCBvcHRzKTtcbiAgICAgIH0gY2F0Y2ggKGVycikgey8vIG5vdCBzdXBwb3J0ZWRcbiAgICAgIH1cblxuICAgICAgci5zdXBwb3J0c1Bhc3NpdmVFdmVudHMgPSBzdXBwb3J0c1Bhc3NpdmU7XG4gICAgfVxuXG4gICAgdmFyIG9uID0gZnVuY3Rpb24gb24oZXZlbnQsIGhhbmRsZXIsIHVzZUNhcHR1cmUpIHtcbiAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuICAgICAgaWYgKHRndElzRG9tICYmIHIuc3VwcG9ydHNQYXNzaXZlRXZlbnRzKSB7XG4gICAgICAgIC8vIHJlcGxhY2UgdXNlQ2FwdHVyZSB3LyBvcHRzIG9ialxuICAgICAgICBhcmdzWzJdID0ge1xuICAgICAgICAgIGNhcHR1cmU6IHVzZUNhcHR1cmUgIT0gbnVsbCA/IHVzZUNhcHR1cmUgOiBmYWxzZSxcbiAgICAgICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgICAgICBvbmNlOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByLmJpbmRpbmdzLnB1c2goe1xuICAgICAgICB0YXJnZXQ6IHRndCxcbiAgICAgICAgYXJnczogYXJnc1xuICAgICAgfSk7XG4gICAgICAodGd0LmFkZEV2ZW50TGlzdGVuZXIgfHwgdGd0Lm9uKS5hcHBseSh0Z3QsIGFyZ3MpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICBvbjogb24sXG4gICAgICBhZGRFdmVudExpc3RlbmVyOiBvbixcbiAgICAgIGFkZExpc3RlbmVyOiBvbixcbiAgICAgIGJpbmQ6IG9uXG4gICAgfTtcbiAgfTtcblxuICBCUnAkMy5ub2RlSXNEcmFnZ2FibGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIHJldHVybiBub2RlICYmIG5vZGUuaXNOb2RlKCkgJiYgIW5vZGUubG9ja2VkKCkgJiYgbm9kZS5ncmFiYmFibGUoKTtcbiAgfTtcblxuICBCUnAkMy5ub2RlSXNHcmFiYmFibGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIHJldHVybiB0aGlzLm5vZGVJc0RyYWdnYWJsZShub2RlKSAmJiBub2RlLmludGVyYWN0aXZlKCk7XG4gIH07XG5cbiAgQlJwJDMubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgciA9IHRoaXM7XG5cbiAgICB2YXIgaXNTZWxlY3RlZCA9IGZ1bmN0aW9uIGlzU2VsZWN0ZWQoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLnNlbGVjdGVkKCk7XG4gICAgfTtcblxuICAgIHZhciB0cmlnZ2VyRXZlbnRzID0gZnVuY3Rpb24gdHJpZ2dlckV2ZW50cyh0YXJnZXQsIG5hbWVzLCBlLCBwb3NpdGlvbikge1xuICAgICAgaWYgKHRhcmdldCA9PSBudWxsKSB7XG4gICAgICAgIHRhcmdldCA9IHIuY3k7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgICAgdGFyZ2V0LmVtaXQoe1xuICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgICAgdHlwZTogbmFtZSxcbiAgICAgICAgICBwb3NpdGlvbjogcG9zaXRpb25cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBpc011bHRTZWxLZXlEb3duID0gZnVuY3Rpb24gaXNNdWx0U2VsS2V5RG93bihlKSB7XG4gICAgICByZXR1cm4gZS5zaGlmdEtleSB8fCBlLm1ldGFLZXkgfHwgZS5jdHJsS2V5OyAvLyBtYXliZSBlLmFsdEtleVxuICAgIH07XG5cbiAgICB2YXIgYWxsb3dQYW5uaW5nUGFzc3Rocm91Z2ggPSBmdW5jdGlvbiBhbGxvd1Bhbm5pbmdQYXNzdGhyb3VnaChkb3duLCBkb3ducykge1xuICAgICAgdmFyIGFsbG93UGFzc3Rocm91Z2ggPSB0cnVlO1xuXG4gICAgICBpZiAoci5jeS5oYXNDb21wb3VuZE5vZGVzKCkgJiYgZG93biAmJiBkb3duLnBhbm5hYmxlKCkpIHtcbiAgICAgICAgLy8gYSBncmFiYmFibGUgY29tcG91bmQgbm9kZSBiZWxvdyB0aGUgZWxlID0+IG5vIHBhc3N0aHJvdWdoIHBhbm5pbmdcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGRvd25zICYmIGkgPCBkb3ducy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBkb3duID0gZG93bnNbaV07IC8vaWYgYW55IHBhcmVudCBub2RlIGluIGV2ZW50IGhpZXJhcmNoeSBpc24ndCBwYW5uYWJsZSwgcmVqZWN0IHBhc3N0aHJvdWdoXG5cbiAgICAgICAgICBpZiAoZG93bi5pc05vZGUoKSAmJiBkb3duLmlzUGFyZW50KCkgJiYgIWRvd24ucGFubmFibGUoKSkge1xuICAgICAgICAgICAgYWxsb3dQYXNzdGhyb3VnaCA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbGxvd1Bhc3N0aHJvdWdoID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFsbG93UGFzc3Rocm91Z2g7XG4gICAgfTtcblxuICAgIHZhciBzZXRHcmFiYmVkID0gZnVuY3Rpb24gc2V0R3JhYmJlZChlbGUpIHtcbiAgICAgIGVsZVswXS5fcHJpdmF0ZS5ncmFiYmVkID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgdmFyIHNldEZyZWVkID0gZnVuY3Rpb24gc2V0RnJlZWQoZWxlKSB7XG4gICAgICBlbGVbMF0uX3ByaXZhdGUuZ3JhYmJlZCA9IGZhbHNlO1xuICAgIH07XG5cbiAgICB2YXIgc2V0SW5EcmFnTGF5ZXIgPSBmdW5jdGlvbiBzZXRJbkRyYWdMYXllcihlbGUpIHtcbiAgICAgIGVsZVswXS5fcHJpdmF0ZS5yc2NyYXRjaC5pbkRyYWdMYXllciA9IHRydWU7XG4gICAgfTtcblxuICAgIHZhciBzZXRPdXREcmFnTGF5ZXIgPSBmdW5jdGlvbiBzZXRPdXREcmFnTGF5ZXIoZWxlKSB7XG4gICAgICBlbGVbMF0uX3ByaXZhdGUucnNjcmF0Y2guaW5EcmFnTGF5ZXIgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgdmFyIHNldEdyYWJUYXJnZXQgPSBmdW5jdGlvbiBzZXRHcmFiVGFyZ2V0KGVsZSkge1xuICAgICAgZWxlWzBdLl9wcml2YXRlLnJzY3JhdGNoLmlzR3JhYlRhcmdldCA9IHRydWU7XG4gICAgfTtcblxuICAgIHZhciByZW1vdmVHcmFiVGFyZ2V0ID0gZnVuY3Rpb24gcmVtb3ZlR3JhYlRhcmdldChlbGUpIHtcbiAgICAgIGVsZVswXS5fcHJpdmF0ZS5yc2NyYXRjaC5pc0dyYWJUYXJnZXQgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgdmFyIGFkZFRvRHJhZ0xpc3QgPSBmdW5jdGlvbiBhZGRUb0RyYWdMaXN0KGVsZSwgb3B0cykge1xuICAgICAgdmFyIGxpc3QgPSBvcHRzLmFkZFRvTGlzdDtcbiAgICAgIHZhciBsaXN0SGFzRWxlID0gbGlzdC5oYXMoZWxlKTtcblxuICAgICAgaWYgKCFsaXN0SGFzRWxlICYmIGVsZS5ncmFiYmFibGUoKSAmJiAhZWxlLmxvY2tlZCgpKSB7XG4gICAgICAgIGxpc3QubWVyZ2UoZWxlKTtcbiAgICAgICAgc2V0R3JhYmJlZChlbGUpO1xuICAgICAgfVxuICAgIH07IC8vIGhlbHBlciBmdW5jdGlvbiB0byBkZXRlcm1pbmUgd2hpY2ggY2hpbGQgbm9kZXMgYW5kIGlubmVyIGVkZ2VzXG4gICAgLy8gb2YgYSBjb21wb3VuZCBub2RlIHRvIGJlIGRyYWdnZWQgYXMgd2VsbCBhcyB0aGUgZ3JhYmJlZCBhbmQgc2VsZWN0ZWQgbm9kZXNcblxuXG4gICAgdmFyIGFkZERlc2NlbmRhbnRzVG9EcmFnID0gZnVuY3Rpb24gYWRkRGVzY2VuZGFudHNUb0RyYWcobm9kZSwgb3B0cykge1xuICAgICAgaWYgKCFub2RlLmN5KCkuaGFzQ29tcG91bmROb2RlcygpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdHMuaW5EcmFnTGF5ZXIgPT0gbnVsbCAmJiBvcHRzLmFkZFRvTGlzdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gbm90aGluZyB0byBkb1xuXG5cbiAgICAgIHZhciBpbm5lck5vZGVzID0gbm9kZS5kZXNjZW5kYW50cygpO1xuXG4gICAgICBpZiAob3B0cy5pbkRyYWdMYXllcikge1xuICAgICAgICBpbm5lck5vZGVzLmZvckVhY2goc2V0SW5EcmFnTGF5ZXIpO1xuICAgICAgICBpbm5lck5vZGVzLmNvbm5lY3RlZEVkZ2VzKCkuZm9yRWFjaChzZXRJbkRyYWdMYXllcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRzLmFkZFRvTGlzdCkge1xuICAgICAgICBhZGRUb0RyYWdMaXN0KGlubmVyTm9kZXMsIG9wdHMpO1xuICAgICAgfVxuICAgIH07IC8vIGFkZHMgdGhlIGdpdmVuIG5vZGVzIGFuZCBpdHMgbmVpZ2hib3VyaG9vZCB0byB0aGUgZHJhZyBsYXllclxuXG5cbiAgICB2YXIgYWRkTm9kZXNUb0RyYWcgPSBmdW5jdGlvbiBhZGROb2Rlc1RvRHJhZyhub2Rlcywgb3B0cykge1xuICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICB2YXIgaGFzQ29tcG91bmROb2RlcyA9IG5vZGVzLmN5KCkuaGFzQ29tcG91bmROb2RlcygpO1xuXG4gICAgICBpZiAob3B0cy5pbkRyYWdMYXllcikge1xuICAgICAgICBub2Rlcy5mb3JFYWNoKHNldEluRHJhZ0xheWVyKTtcbiAgICAgICAgbm9kZXMubmVpZ2hib3Job29kKCkuc3RkRmlsdGVyKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgICByZXR1cm4gIWhhc0NvbXBvdW5kTm9kZXMgfHwgZWxlLmlzRWRnZSgpO1xuICAgICAgICB9KS5mb3JFYWNoKHNldEluRHJhZ0xheWVyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdHMuYWRkVG9MaXN0KSB7XG4gICAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICAgIGFkZFRvRHJhZ0xpc3QoZWxlLCBvcHRzKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGFkZERlc2NlbmRhbnRzVG9EcmFnKG5vZGVzLCBvcHRzKTsgLy8gYWx3YXlzIGFkZCB0byBkcmFnXG4gICAgICAvLyBhbHNvIGFkZCBub2RlcyBhbmQgZWRnZXMgcmVsYXRlZCB0byB0aGUgdG9wbW9zdCBhbmNlc3RvclxuXG4gICAgICB1cGRhdGVBbmNlc3RvcnNJbkRyYWdMYXllcihub2Rlcywge1xuICAgICAgICBpbkRyYWdMYXllcjogb3B0cy5pbkRyYWdMYXllclxuICAgICAgfSk7XG4gICAgICByLnVwZGF0ZUNhY2hlZEdyYWJiZWRFbGVzKCk7XG4gICAgfTtcblxuICAgIHZhciBhZGROb2RlVG9EcmFnID0gYWRkTm9kZXNUb0RyYWc7XG5cbiAgICB2YXIgZnJlZURyYWdnZWRFbGVtZW50cyA9IGZ1bmN0aW9uIGZyZWVEcmFnZ2VkRWxlbWVudHMoZ3JhYmJlZEVsZXMpIHtcbiAgICAgIGlmICghZ3JhYmJlZEVsZXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBqdXN0IGdvIG92ZXIgYWxsIGVsZW1lbnRzIHJhdGhlciB0aGFuIGRvaW5nIGEgYnVuY2ggb2YgKHBvc3NpYmx5IGV4cGVuc2l2ZSkgdHJhdmVyc2Fsc1xuXG5cbiAgICAgIHIuZ2V0Q2FjaGVkWlNvcnRlZEVsZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgc2V0RnJlZWQoZWxlKTtcbiAgICAgICAgc2V0T3V0RHJhZ0xheWVyKGVsZSk7XG4gICAgICAgIHJlbW92ZUdyYWJUYXJnZXQoZWxlKTtcbiAgICAgIH0pO1xuICAgICAgci51cGRhdGVDYWNoZWRHcmFiYmVkRWxlcygpO1xuICAgIH07IC8vIGhlbHBlciBmdW5jdGlvbiB0byBkZXRlcm1pbmUgd2hpY2ggYW5jZXN0b3Igbm9kZXMgYW5kIGVkZ2VzIHNob3VsZCBnb1xuICAgIC8vIHRvIHRoZSBkcmFnIGxheWVyIChvciBzaG91bGQgYmUgcmVtb3ZlZCBmcm9tIGRyYWcgbGF5ZXIpLlxuXG5cbiAgICB2YXIgdXBkYXRlQW5jZXN0b3JzSW5EcmFnTGF5ZXIgPSBmdW5jdGlvbiB1cGRhdGVBbmNlc3RvcnNJbkRyYWdMYXllcihub2RlLCBvcHRzKSB7XG4gICAgICBpZiAob3B0cy5pbkRyYWdMYXllciA9PSBudWxsICYmIG9wdHMuYWRkVG9MaXN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBub3RoaW5nIHRvIGRvXG5cblxuICAgICAgaWYgKCFub2RlLmN5KCkuaGFzQ29tcG91bmROb2RlcygpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gZmluZCB0b3AtbGV2ZWwgcGFyZW50XG5cblxuICAgICAgdmFyIHBhcmVudCA9IG5vZGUuYW5jZXN0b3JzKCkub3JwaGFucygpOyAvLyBubyBwYXJlbnQgbm9kZTogbm8gbm9kZXMgdG8gYWRkIHRvIHRoZSBkcmFnIGxheWVyXG5cbiAgICAgIGlmIChwYXJlbnQuc2FtZShub2RlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBub2RlcyA9IHBhcmVudC5kZXNjZW5kYW50cygpLnNwYXduU2VsZigpLm1lcmdlKHBhcmVudCkudW5tZXJnZShub2RlKS51bm1lcmdlKG5vZGUuZGVzY2VuZGFudHMoKSk7XG4gICAgICB2YXIgZWRnZXMgPSBub2Rlcy5jb25uZWN0ZWRFZGdlcygpO1xuXG4gICAgICBpZiAob3B0cy5pbkRyYWdMYXllcikge1xuICAgICAgICBlZGdlcy5mb3JFYWNoKHNldEluRHJhZ0xheWVyKTtcbiAgICAgICAgbm9kZXMuZm9yRWFjaChzZXRJbkRyYWdMYXllcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRzLmFkZFRvTGlzdCkge1xuICAgICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgICBhZGRUb0RyYWdMaXN0KGVsZSwgb3B0cyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgYmx1ckFjdGl2ZURvbUVsZW1lbnQgPSBmdW5jdGlvbiBibHVyQWN0aXZlRG9tRWxlbWVudCgpIHtcbiAgICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9IG51bGwgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ibHVyICE9IG51bGwpIHtcbiAgICAgICAgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ibHVyKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBoYXZlTXV0YXRpb25zQXBpID0gdHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnO1xuICAgIHZhciBoYXZlUmVzaXplT2JzZXJ2ZXJBcGkgPSB0eXBlb2YgUmVzaXplT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnOyAvLyB3YXRjaCBmb3Igd2hlbiB0aGUgY3kgY29udGFpbmVyIGlzIHJlbW92ZWQgZnJvbSB0aGUgZG9tXG5cbiAgICBpZiAoaGF2ZU11dGF0aW9uc0FwaSkge1xuICAgICAgci5yZW1vdmVPYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGZ1bmN0aW9uIChtdXRucykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXV0bnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgbXV0biA9IG11dG5zW2ldO1xuICAgICAgICAgIHZhciByTm9kZXMgPSBtdXRuLnJlbW92ZWROb2RlcztcblxuICAgICAgICAgIGlmIChyTm9kZXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgck5vZGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIHZhciByTm9kZSA9IHJOb2Rlc1tqXTtcblxuICAgICAgICAgICAgICBpZiAock5vZGUgPT09IHIuY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgci5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoci5jb250YWluZXIucGFyZW50Tm9kZSkge1xuICAgICAgICByLnJlbW92ZU9ic2VydmVyLm9ic2VydmUoci5jb250YWluZXIucGFyZW50Tm9kZSwge1xuICAgICAgICAgIGNoaWxkTGlzdDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICdET01Ob2RlUmVtb3ZlZCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgICAgci5kZXN0cm95KCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgb25SZXNpemUgPSBkZWJvdW5jZV8xKGZ1bmN0aW9uICgpIHtcbiAgICAgIHIuY3kucmVzaXplKCk7XG4gICAgfSwgMTAwKTtcblxuICAgIGlmIChoYXZlTXV0YXRpb25zQXBpKSB7XG4gICAgICByLnN0eWxlT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihvblJlc2l6ZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuICAgICAgci5zdHlsZU9ic2VydmVyLm9ic2VydmUoci5jb250YWluZXIsIHtcbiAgICAgICAgYXR0cmlidXRlczogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSAvLyBhdXRvIHJlc2l6ZVxuXG5cbiAgICByLnJlZ2lzdGVyQmluZGluZyh3aW5kb3csICdyZXNpemUnLCBvblJlc2l6ZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuICAgIGlmIChoYXZlUmVzaXplT2JzZXJ2ZXJBcGkpIHtcbiAgICAgIHIucmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIob25SZXNpemUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cbiAgICAgIHIucmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShyLmNvbnRhaW5lcik7XG4gICAgfVxuXG4gICAgdmFyIGZvckVhY2hVcCA9IGZ1bmN0aW9uIGZvckVhY2hVcChkb21FbGUsIGZuKSB7XG4gICAgICB3aGlsZSAoZG9tRWxlICE9IG51bGwpIHtcbiAgICAgICAgZm4oZG9tRWxlKTtcbiAgICAgICAgZG9tRWxlID0gZG9tRWxlLnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBpbnZhbGlkYXRlQ29vcmRzID0gZnVuY3Rpb24gaW52YWxpZGF0ZUNvb3JkcygpIHtcbiAgICAgIHIuaW52YWxpZGF0ZUNvbnRhaW5lckNsaWVudENvb3Jkc0NhY2hlKCk7XG4gICAgfTtcblxuICAgIGZvckVhY2hVcChyLmNvbnRhaW5lciwgZnVuY3Rpb24gKGRvbUVsZSkge1xuICAgICAgci5yZWdpc3RlckJpbmRpbmcoZG9tRWxlLCAndHJhbnNpdGlvbmVuZCcsIGludmFsaWRhdGVDb29yZHMpO1xuICAgICAgci5yZWdpc3RlckJpbmRpbmcoZG9tRWxlLCAnYW5pbWF0aW9uZW5kJywgaW52YWxpZGF0ZUNvb3Jkcyk7XG4gICAgICByLnJlZ2lzdGVyQmluZGluZyhkb21FbGUsICdzY3JvbGwnLCBpbnZhbGlkYXRlQ29vcmRzKTtcbiAgICB9KTsgLy8gc3RvcCByaWdodCBjbGljayBtZW51IGZyb20gYXBwZWFyaW5nIG9uIGN5XG5cbiAgICByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ2NvbnRleHRtZW51JywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9KTtcblxuICAgIHZhciBpbkJveFNlbGVjdGlvbiA9IGZ1bmN0aW9uIGluQm94U2VsZWN0aW9uKCkge1xuICAgICAgcmV0dXJuIHIuc2VsZWN0aW9uWzRdICE9PSAwO1xuICAgIH07XG5cbiAgICB2YXIgZXZlbnRJbkNvbnRhaW5lciA9IGZ1bmN0aW9uIGV2ZW50SW5Db250YWluZXIoZSkge1xuICAgICAgLy8gc2F2ZSBjeWNsZXMgaWYgbW91c2UgZXZlbnRzIGFyZW4ndCB0byBiZSBjYXB0dXJlZFxuICAgICAgdmFyIGNvbnRhaW5lclBhZ2VDb29yZHMgPSByLmZpbmRDb250YWluZXJDbGllbnRDb29yZHMoKTtcbiAgICAgIHZhciB4ID0gY29udGFpbmVyUGFnZUNvb3Jkc1swXTtcbiAgICAgIHZhciB5ID0gY29udGFpbmVyUGFnZUNvb3Jkc1sxXTtcbiAgICAgIHZhciB3aWR0aCA9IGNvbnRhaW5lclBhZ2VDb29yZHNbMl07XG4gICAgICB2YXIgaGVpZ2h0ID0gY29udGFpbmVyUGFnZUNvb3Jkc1szXTtcbiAgICAgIHZhciBwb3NpdGlvbnMgPSBlLnRvdWNoZXMgPyBlLnRvdWNoZXMgOiBbZV07XG4gICAgICB2YXIgYXRMZWFzdE9uZVBvc0luc2lkZSA9IGZhbHNlO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvc2l0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcCA9IHBvc2l0aW9uc1tpXTtcblxuICAgICAgICBpZiAoeCA8PSBwLmNsaWVudFggJiYgcC5jbGllbnRYIDw9IHggKyB3aWR0aCAmJiB5IDw9IHAuY2xpZW50WSAmJiBwLmNsaWVudFkgPD0geSArIGhlaWdodCkge1xuICAgICAgICAgIGF0TGVhc3RPbmVQb3NJbnNpZGUgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghYXRMZWFzdE9uZVBvc0luc2lkZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250YWluZXIgPSByLmNvbnRhaW5lcjtcbiAgICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldDtcbiAgICAgIHZhciB0UGFyZW50ID0gdGFyZ2V0LnBhcmVudE5vZGU7XG4gICAgICB2YXIgY29udGFpbmVySXNUYXJnZXQgPSBmYWxzZTtcblxuICAgICAgd2hpbGUgKHRQYXJlbnQpIHtcbiAgICAgICAgaWYgKHRQYXJlbnQgPT09IGNvbnRhaW5lcikge1xuICAgICAgICAgIGNvbnRhaW5lcklzVGFyZ2V0ID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHRQYXJlbnQgPSB0UGFyZW50LnBhcmVudE5vZGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghY29udGFpbmVySXNUYXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSAvLyBpZiB0YXJnZXQgaXMgb3V0aXNkZSBjeSBjb250YWluZXIsIHRoZW4gdGhpcyBldmVudCBpcyBub3QgZm9yIHVzXG5cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTsgLy8gUHJpbWFyeSBrZXlcblxuXG4gICAgci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICdtb3VzZWRvd24nLCBmdW5jdGlvbiBtb3VzZWRvd25IYW5kbGVyKGUpIHtcbiAgICAgIGlmICghZXZlbnRJbkNvbnRhaW5lcihlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGJsdXJBY3RpdmVEb21FbGVtZW50KCk7XG4gICAgICByLmhvdmVyRGF0YS5jYXB0dXJlID0gdHJ1ZTtcbiAgICAgIHIuaG92ZXJEYXRhLndoaWNoID0gZS53aGljaDtcbiAgICAgIHZhciBjeSA9IHIuY3k7XG4gICAgICB2YXIgZ3BvcyA9IFtlLmNsaWVudFgsIGUuY2xpZW50WV07XG4gICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGdwb3NbMF0sIGdwb3NbMV0pO1xuICAgICAgdmFyIHNlbGVjdCA9IHIuc2VsZWN0aW9uO1xuICAgICAgdmFyIG5lYXJzID0gci5maW5kTmVhcmVzdEVsZW1lbnRzKHBvc1swXSwgcG9zWzFdLCB0cnVlLCBmYWxzZSk7XG4gICAgICB2YXIgbmVhciA9IG5lYXJzWzBdO1xuICAgICAgdmFyIGRyYWdnZWRFbGVtZW50cyA9IHIuZHJhZ0RhdGEucG9zc2libGVEcmFnRWxlbWVudHM7XG4gICAgICByLmhvdmVyRGF0YS5tZG93blBvcyA9IHBvcztcbiAgICAgIHIuaG92ZXJEYXRhLm1kb3duR1BvcyA9IGdwb3M7XG5cbiAgICAgIHZhciBjaGVja0ZvclRhcGhvbGQgPSBmdW5jdGlvbiBjaGVja0ZvclRhcGhvbGQoKSB7XG4gICAgICAgIHIuaG92ZXJEYXRhLnRhcGhvbGRDYW5jZWxsZWQgPSBmYWxzZTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHIuaG92ZXJEYXRhLnRhcGhvbGRUaW1lb3V0KTtcbiAgICAgICAgci5ob3ZlckRhdGEudGFwaG9sZFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoci5ob3ZlckRhdGEudGFwaG9sZENhbmNlbGxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZWxlID0gci5ob3ZlckRhdGEuZG93bjtcblxuICAgICAgICAgICAgaWYgKGVsZSkge1xuICAgICAgICAgICAgICBlbGUuZW1pdCh7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICAgICAgICB0eXBlOiAndGFwaG9sZCcsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjeS5lbWl0KHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgICAgICAgIHR5cGU6ICd0YXBob2xkJyxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIHIudGFwaG9sZER1cmF0aW9uKTtcbiAgICAgIH07IC8vIFJpZ2h0IGNsaWNrIGJ1dHRvblxuXG5cbiAgICAgIGlmIChlLndoaWNoID09IDMpIHtcbiAgICAgICAgci5ob3ZlckRhdGEuY3h0U3RhcnRlZCA9IHRydWU7XG4gICAgICAgIHZhciBjeHRFdnQgPSB7XG4gICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICB0eXBlOiAnY3h0dGFwc3RhcnQnLFxuICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG5lYXIpIHtcbiAgICAgICAgICBuZWFyLmFjdGl2YXRlKCk7XG4gICAgICAgICAgbmVhci5lbWl0KGN4dEV2dCk7XG4gICAgICAgICAgci5ob3ZlckRhdGEuZG93biA9IG5lYXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3kuZW1pdChjeHRFdnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgci5ob3ZlckRhdGEuZG93blRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgci5ob3ZlckRhdGEuY3h0RHJhZ2dlZCA9IGZhbHNlOyAvLyBQcmltYXJ5IGJ1dHRvblxuICAgICAgfSBlbHNlIGlmIChlLndoaWNoID09IDEpIHtcbiAgICAgICAgaWYgKG5lYXIpIHtcbiAgICAgICAgICBuZWFyLmFjdGl2YXRlKCk7XG4gICAgICAgIH0gLy8gRWxlbWVudCBkcmFnZ2luZ1xuXG5cbiAgICAgICAge1xuICAgICAgICAgIC8vIElmIHNvbWV0aGluZyBpcyB1bmRlciB0aGUgY3Vyc29yIGFuZCBpdCBpcyBkcmFnZ2FibGUsIHByZXBhcmUgdG8gZ3JhYiBpdFxuICAgICAgICAgIGlmIChuZWFyICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChyLm5vZGVJc0dyYWJiYWJsZShuZWFyKSkge1xuICAgICAgICAgICAgICB2YXIgbWFrZUV2ZW50ID0gZnVuY3Rpb24gbWFrZUV2ZW50KHR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgdmFyIHRyaWdnZXJHcmFiID0gZnVuY3Rpb24gdHJpZ2dlckdyYWIoZWxlKSB7XG4gICAgICAgICAgICAgICAgZWxlLmVtaXQobWFrZUV2ZW50KCdncmFiJykpO1xuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIHNldEdyYWJUYXJnZXQobmVhcik7XG5cbiAgICAgICAgICAgICAgaWYgKCFuZWFyLnNlbGVjdGVkKCkpIHtcbiAgICAgICAgICAgICAgICBkcmFnZ2VkRWxlbWVudHMgPSByLmRyYWdEYXRhLnBvc3NpYmxlRHJhZ0VsZW1lbnRzID0gY3kuY29sbGVjdGlvbigpO1xuICAgICAgICAgICAgICAgIGFkZE5vZGVUb0RyYWcobmVhciwge1xuICAgICAgICAgICAgICAgICAgYWRkVG9MaXN0OiBkcmFnZ2VkRWxlbWVudHNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBuZWFyLmVtaXQobWFrZUV2ZW50KCdncmFib24nKSkuZW1pdChtYWtlRXZlbnQoJ2dyYWInKSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZHJhZ2dlZEVsZW1lbnRzID0gci5kcmFnRGF0YS5wb3NzaWJsZURyYWdFbGVtZW50cyA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0ZWROb2RlcyA9IGN5LiQoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZS5pc05vZGUoKSAmJiBlbGUuc2VsZWN0ZWQoKSAmJiByLm5vZGVJc0dyYWJiYWJsZShlbGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGFkZE5vZGVzVG9EcmFnKHNlbGVjdGVkTm9kZXMsIHtcbiAgICAgICAgICAgICAgICAgIGFkZFRvTGlzdDogZHJhZ2dlZEVsZW1lbnRzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbmVhci5lbWl0KG1ha2VFdmVudCgnZ3JhYm9uJykpO1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkTm9kZXMuZm9yRWFjaCh0cmlnZ2VyR3JhYik7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgICAgICAgICAgICAgci5yZWRyYXdIaW50KCdkcmFnJywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgci5ob3ZlckRhdGEuZG93biA9IG5lYXI7XG4gICAgICAgICAgci5ob3ZlckRhdGEuZG93bnMgPSBuZWFycztcbiAgICAgICAgICByLmhvdmVyRGF0YS5kb3duVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRyaWdnZXJFdmVudHMobmVhciwgWydtb3VzZWRvd24nLCAndGFwc3RhcnQnLCAndm1vdXNlZG93biddLCBlLCB7XG4gICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAobmVhciA9PSBudWxsKSB7XG4gICAgICAgICAgc2VsZWN0WzRdID0gMTtcbiAgICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB7XG4gICAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgICB9O1xuICAgICAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG4gICAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgICAgfSBlbHNlIGlmIChuZWFyLnBhbm5hYmxlKCkpIHtcbiAgICAgICAgICBzZWxlY3RbNF0gPSAxOyAvLyBmb3IgZnV0dXJlIHBhblxuICAgICAgICB9XG5cbiAgICAgICAgY2hlY2tGb3JUYXBob2xkKCk7XG4gICAgICB9IC8vIEluaXRpYWxpemUgc2VsZWN0aW9uIGJveCBjb29yZGluYXRlc1xuXG5cbiAgICAgIHNlbGVjdFswXSA9IHNlbGVjdFsyXSA9IHBvc1swXTtcbiAgICAgIHNlbGVjdFsxXSA9IHNlbGVjdFszXSA9IHBvc1sxXTtcbiAgICB9LCBmYWxzZSk7XG4gICAgci5yZWdpc3RlckJpbmRpbmcod2luZG93LCAnbW91c2Vtb3ZlJywgZnVuY3Rpb24gbW91c2Vtb3ZlSGFuZGxlcihlKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gICAgICB2YXIgY2FwdHVyZSA9IHIuaG92ZXJEYXRhLmNhcHR1cmU7XG5cbiAgICAgIGlmICghY2FwdHVyZSAmJiAhZXZlbnRJbkNvbnRhaW5lcihlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBwcmV2ZW50RGVmYXVsdCA9IGZhbHNlO1xuICAgICAgdmFyIGN5ID0gci5jeTtcbiAgICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuICAgICAgdmFyIGdwb3MgPSBbZS5jbGllbnRYLCBlLmNsaWVudFldO1xuICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChncG9zWzBdLCBncG9zWzFdKTtcbiAgICAgIHZhciBtZG93blBvcyA9IHIuaG92ZXJEYXRhLm1kb3duUG9zO1xuICAgICAgdmFyIG1kb3duR1BvcyA9IHIuaG92ZXJEYXRhLm1kb3duR1BvcztcbiAgICAgIHZhciBzZWxlY3QgPSByLnNlbGVjdGlvbjtcbiAgICAgIHZhciBuZWFyID0gbnVsbDtcblxuICAgICAgaWYgKCFyLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgJiYgIXIuaG92ZXJEYXRhLmRyYWdnaW5nICYmICFyLmhvdmVyRGF0YS5zZWxlY3RpbmcpIHtcbiAgICAgICAgbmVhciA9IHIuZmluZE5lYXJlc3RFbGVtZW50KHBvc1swXSwgcG9zWzFdLCB0cnVlLCBmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBsYXN0ID0gci5ob3ZlckRhdGEubGFzdDtcbiAgICAgIHZhciBkb3duID0gci5ob3ZlckRhdGEuZG93bjtcbiAgICAgIHZhciBkaXNwID0gW3Bvc1swXSAtIHNlbGVjdFsyXSwgcG9zWzFdIC0gc2VsZWN0WzNdXTtcbiAgICAgIHZhciBkcmFnZ2VkRWxlbWVudHMgPSByLmRyYWdEYXRhLnBvc3NpYmxlRHJhZ0VsZW1lbnRzO1xuICAgICAgdmFyIGlzT3ZlclRocmVzaG9sZERyYWc7XG5cbiAgICAgIGlmIChtZG93bkdQb3MpIHtcbiAgICAgICAgdmFyIGR4ID0gZ3Bvc1swXSAtIG1kb3duR1Bvc1swXTtcbiAgICAgICAgdmFyIGR4MiA9IGR4ICogZHg7XG4gICAgICAgIHZhciBkeSA9IGdwb3NbMV0gLSBtZG93bkdQb3NbMV07XG4gICAgICAgIHZhciBkeTIgPSBkeSAqIGR5O1xuICAgICAgICB2YXIgZGlzdDIgPSBkeDIgKyBkeTI7XG4gICAgICAgIHIuaG92ZXJEYXRhLmlzT3ZlclRocmVzaG9sZERyYWcgPSBpc092ZXJUaHJlc2hvbGREcmFnID0gZGlzdDIgPj0gci5kZXNrdG9wVGFwVGhyZXNob2xkMjtcbiAgICAgIH1cblxuICAgICAgdmFyIG11bHRTZWxLZXlEb3duID0gaXNNdWx0U2VsS2V5RG93bihlKTtcblxuICAgICAgaWYgKGlzT3ZlclRocmVzaG9sZERyYWcpIHtcbiAgICAgICAgci5ob3ZlckRhdGEudGFwaG9sZENhbmNlbGxlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciB1cGRhdGVEcmFnRGVsdGEgPSBmdW5jdGlvbiB1cGRhdGVEcmFnRGVsdGEoKSB7XG4gICAgICAgIHZhciBkcmFnRGVsdGEgPSByLmhvdmVyRGF0YS5kcmFnRGVsdGEgPSByLmhvdmVyRGF0YS5kcmFnRGVsdGEgfHwgW107XG5cbiAgICAgICAgaWYgKGRyYWdEZWx0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBkcmFnRGVsdGEucHVzaChkaXNwWzBdKTtcbiAgICAgICAgICBkcmFnRGVsdGEucHVzaChkaXNwWzFdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkcmFnRGVsdGFbMF0gKz0gZGlzcFswXTtcbiAgICAgICAgICBkcmFnRGVsdGFbMV0gKz0gZGlzcFsxXTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcHJldmVudERlZmF1bHQgPSB0cnVlO1xuICAgICAgdHJpZ2dlckV2ZW50cyhuZWFyLCBbJ21vdXNlbW92ZScsICd2bW91c2Vtb3ZlJywgJ3RhcGRyYWcnXSwgZSwge1xuICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgIHk6IHBvc1sxXVxuICAgICAgfSk7XG5cbiAgICAgIHZhciBnb0ludG9Cb3hNb2RlID0gZnVuY3Rpb24gZ29JbnRvQm94TW9kZSgpIHtcbiAgICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmICghci5ob3ZlckRhdGEuc2VsZWN0aW5nKSB7XG4gICAgICAgICAgY3kuZW1pdCh7XG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgICAgdHlwZTogJ2JveHN0YXJ0JyxcbiAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxlY3RbNF0gPSAxO1xuICAgICAgICByLmhvdmVyRGF0YS5zZWxlY3RpbmcgPSB0cnVlO1xuICAgICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICAgICAgICByLnJlZHJhdygpO1xuICAgICAgfTsgLy8gdHJpZ2dlciBjb250ZXh0IGRyYWcgaWYgcm1vdXNlIGRvd25cblxuXG4gICAgICBpZiAoci5ob3ZlckRhdGEud2hpY2ggPT09IDMpIHtcbiAgICAgICAgLy8gYnV0IG9ubHkgaWYgb3ZlciB0aHJlc2hvbGRcbiAgICAgICAgaWYgKGlzT3ZlclRocmVzaG9sZERyYWcpIHtcbiAgICAgICAgICB2YXIgY3h0RXZ0ID0ge1xuICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICAgIHR5cGU6ICdjeHRkcmFnJyxcbiAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmIChkb3duKSB7XG4gICAgICAgICAgICBkb3duLmVtaXQoY3h0RXZ0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3kuZW1pdChjeHRFdnQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHIuaG92ZXJEYXRhLmN4dERyYWdnZWQgPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKCFyLmhvdmVyRGF0YS5jeHRPdmVyIHx8IG5lYXIgIT09IHIuaG92ZXJEYXRhLmN4dE92ZXIpIHtcbiAgICAgICAgICAgIGlmIChyLmhvdmVyRGF0YS5jeHRPdmVyKSB7XG4gICAgICAgICAgICAgIHIuaG92ZXJEYXRhLmN4dE92ZXIuZW1pdCh7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICAgICAgICB0eXBlOiAnY3h0ZHJhZ291dCcsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHIuaG92ZXJEYXRhLmN4dE92ZXIgPSBuZWFyO1xuXG4gICAgICAgICAgICBpZiAobmVhcikge1xuICAgICAgICAgICAgICBuZWFyLmVtaXQoe1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2N4dGRyYWdvdmVyJyxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gQ2hlY2sgaWYgd2UgYXJlIGRyYWcgcGFubmluZyB0aGUgZW50aXJlIGdyYXBoXG5cbiAgICAgIH0gZWxzZSBpZiAoci5ob3ZlckRhdGEuZHJhZ2dpbmcpIHtcbiAgICAgICAgcHJldmVudERlZmF1bHQgPSB0cnVlO1xuXG4gICAgICAgIGlmIChjeS5wYW5uaW5nRW5hYmxlZCgpICYmIGN5LnVzZXJQYW5uaW5nRW5hYmxlZCgpKSB7XG4gICAgICAgICAgdmFyIGRlbHRhUDtcblxuICAgICAgICAgIGlmIChyLmhvdmVyRGF0YS5qdXN0U3RhcnRlZFBhbikge1xuICAgICAgICAgICAgdmFyIG1kUG9zID0gci5ob3ZlckRhdGEubWRvd25Qb3M7XG4gICAgICAgICAgICBkZWx0YVAgPSB7XG4gICAgICAgICAgICAgIHg6IChwb3NbMF0gLSBtZFBvc1swXSkgKiB6b29tLFxuICAgICAgICAgICAgICB5OiAocG9zWzFdIC0gbWRQb3NbMV0pICogem9vbVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHIuaG92ZXJEYXRhLmp1c3RTdGFydGVkUGFuID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbHRhUCA9IHtcbiAgICAgICAgICAgICAgeDogZGlzcFswXSAqIHpvb20sXG4gICAgICAgICAgICAgIHk6IGRpc3BbMV0gKiB6b29tXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGN5LnBhbkJ5KGRlbHRhUCk7XG4gICAgICAgICAgY3kuZW1pdCgnZHJhZ3BhbicpO1xuICAgICAgICAgIHIuaG92ZXJEYXRhLmRyYWdnZWQgPSB0cnVlO1xuICAgICAgICB9IC8vIE5lZWRzIHJlcHJvamVjdCBkdWUgdG8gcGFuIGNoYW5naW5nIHZpZXdwb3J0XG5cblxuICAgICAgICBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS5jbGllbnRYLCBlLmNsaWVudFkpOyAvLyBDaGVja3MgcHJpbWFyeSBidXR0b24gZG93biAmIG91dCBvZiB0aW1lICYgbW91c2Ugbm90IG1vdmVkIG11Y2hcbiAgICAgIH0gZWxzZSBpZiAoc2VsZWN0WzRdID09IDEgJiYgKGRvd24gPT0gbnVsbCB8fCBkb3duLnBhbm5hYmxlKCkpKSB7XG4gICAgICAgIGlmIChpc092ZXJUaHJlc2hvbGREcmFnKSB7XG4gICAgICAgICAgaWYgKCFyLmhvdmVyRGF0YS5kcmFnZ2luZyAmJiBjeS5ib3hTZWxlY3Rpb25FbmFibGVkKCkgJiYgKG11bHRTZWxLZXlEb3duIHx8ICFjeS5wYW5uaW5nRW5hYmxlZCgpIHx8ICFjeS51c2VyUGFubmluZ0VuYWJsZWQoKSkpIHtcbiAgICAgICAgICAgIGdvSW50b0JveE1vZGUoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFyLmhvdmVyRGF0YS5zZWxlY3RpbmcgJiYgY3kucGFubmluZ0VuYWJsZWQoKSAmJiBjeS51c2VyUGFubmluZ0VuYWJsZWQoKSkge1xuICAgICAgICAgICAgdmFyIGFsbG93UGFzc3Rocm91Z2ggPSBhbGxvd1Bhbm5pbmdQYXNzdGhyb3VnaChkb3duLCByLmhvdmVyRGF0YS5kb3ducyk7XG5cbiAgICAgICAgICAgIGlmIChhbGxvd1Bhc3N0aHJvdWdoKSB7XG4gICAgICAgICAgICAgIHIuaG92ZXJEYXRhLmRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgci5ob3ZlckRhdGEuanVzdFN0YXJ0ZWRQYW4gPSB0cnVlO1xuICAgICAgICAgICAgICBzZWxlY3RbNF0gPSAwO1xuICAgICAgICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSBhcnJheTJwb2ludChtZG93blBvcyk7XG4gICAgICAgICAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG4gICAgICAgICAgICAgIHIucmVkcmF3KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGRvd24gJiYgZG93bi5wYW5uYWJsZSgpICYmIGRvd24uYWN0aXZlKCkpIHtcbiAgICAgICAgICAgIGRvd24udW5hY3RpdmF0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGRvd24gJiYgZG93bi5wYW5uYWJsZSgpICYmIGRvd24uYWN0aXZlKCkpIHtcbiAgICAgICAgICBkb3duLnVuYWN0aXZhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgoIWRvd24gfHwgIWRvd24uZ3JhYmJlZCgpKSAmJiBuZWFyICE9IGxhc3QpIHtcbiAgICAgICAgICBpZiAobGFzdCkge1xuICAgICAgICAgICAgdHJpZ2dlckV2ZW50cyhsYXN0LCBbJ21vdXNlb3V0JywgJ3RhcGRyYWdvdXQnXSwgZSwge1xuICAgICAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG5lYXIpIHtcbiAgICAgICAgICAgIHRyaWdnZXJFdmVudHMobmVhciwgWydtb3VzZW92ZXInLCAndGFwZHJhZ292ZXInXSwgZSwge1xuICAgICAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgci5ob3ZlckRhdGEubGFzdCA9IG5lYXI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZG93bikge1xuICAgICAgICAgIGlmIChpc092ZXJUaHJlc2hvbGREcmFnKSB7XG4gICAgICAgICAgICAvLyB0aGVuIHdlIGNhbiB0YWtlIGFjdGlvblxuICAgICAgICAgICAgaWYgKGN5LmJveFNlbGVjdGlvbkVuYWJsZWQoKSAmJiBtdWx0U2VsS2V5RG93bikge1xuICAgICAgICAgICAgICAvLyB0aGVuIHNlbGVjdGlvbiBvdmVycmlkZXNcbiAgICAgICAgICAgICAgaWYgKGRvd24gJiYgZG93bi5ncmFiYmVkKCkpIHtcbiAgICAgICAgICAgICAgICBmcmVlRHJhZ2dlZEVsZW1lbnRzKGRyYWdnZWRFbGVtZW50cyk7XG4gICAgICAgICAgICAgICAgZG93bi5lbWl0KCdmcmVlb24nKTtcbiAgICAgICAgICAgICAgICBkcmFnZ2VkRWxlbWVudHMuZW1pdCgnZnJlZScpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHIuZHJhZ0RhdGEuZGlkRHJhZykge1xuICAgICAgICAgICAgICAgICAgZG93bi5lbWl0KCdkcmFnZnJlZW9uJyk7XG4gICAgICAgICAgICAgICAgICBkcmFnZ2VkRWxlbWVudHMuZW1pdCgnZHJhZ2ZyZWUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBnb0ludG9Cb3hNb2RlKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRvd24gJiYgZG93bi5ncmFiYmVkKCkgJiYgci5ub2RlSXNEcmFnZ2FibGUoZG93bikpIHtcbiAgICAgICAgICAgICAgLy8gZHJhZyBub2RlXG4gICAgICAgICAgICAgIHZhciBqdXN0U3RhcnRlZERyYWcgPSAhci5kcmFnRGF0YS5kaWREcmFnO1xuXG4gICAgICAgICAgICAgIGlmIChqdXN0U3RhcnRlZERyYWcpIHtcbiAgICAgICAgICAgICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHIuZHJhZ0RhdGEuZGlkRHJhZyA9IHRydWU7IC8vIGluZGljYXRlIHRoYXQgd2UgYWN0dWFsbHkgZGlkIGRyYWcgdGhlIG5vZGVcbiAgICAgICAgICAgICAgLy8gbm93LCBhZGQgdGhlIGVsZW1lbnRzIHRvIHRoZSBkcmFnIGxheWVyIGlmIG5vdCBkb25lIGFscmVhZHlcblxuICAgICAgICAgICAgICBpZiAoIXIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcykge1xuICAgICAgICAgICAgICAgIGFkZE5vZGVzVG9EcmFnKGRyYWdnZWRFbGVtZW50cywge1xuICAgICAgICAgICAgICAgICAgaW5EcmFnTGF5ZXI6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciB0b3RhbFNoaWZ0ID0ge1xuICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgeTogMFxuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIGlmIChudW1iZXIkMShkaXNwWzBdKSAmJiBudW1iZXIkMShkaXNwWzFdKSkge1xuICAgICAgICAgICAgICAgIHRvdGFsU2hpZnQueCArPSBkaXNwWzBdO1xuICAgICAgICAgICAgICAgIHRvdGFsU2hpZnQueSArPSBkaXNwWzFdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGp1c3RTdGFydGVkRHJhZykge1xuICAgICAgICAgICAgICAgICAgdmFyIGRyYWdEZWx0YSA9IHIuaG92ZXJEYXRhLmRyYWdEZWx0YTtcblxuICAgICAgICAgICAgICAgICAgaWYgKGRyYWdEZWx0YSAmJiBudW1iZXIkMShkcmFnRGVsdGFbMF0pICYmIG51bWJlciQxKGRyYWdEZWx0YVsxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdG90YWxTaGlmdC54ICs9IGRyYWdEZWx0YVswXTtcbiAgICAgICAgICAgICAgICAgICAgdG90YWxTaGlmdC55ICs9IGRyYWdEZWx0YVsxXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgPSB0cnVlO1xuICAgICAgICAgICAgICBkcmFnZ2VkRWxlbWVudHMuc2lsZW50U2hpZnQodG90YWxTaGlmdCkuZW1pdCgncG9zaXRpb24gZHJhZycpO1xuICAgICAgICAgICAgICByLnJlZHJhd0hpbnQoJ2RyYWcnLCB0cnVlKTtcbiAgICAgICAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHNhdmUgZHJhZyBkZWx0YSBmb3Igd2hlbiB3ZSBhY3R1YWxseSBzdGFydCBkcmFnZ2luZyBzbyB0aGUgcmVsYXRpdmUgZ3JhYiBwb3MgaXMgY29uc3RhbnRcbiAgICAgICAgICAgIHVwZGF0ZURyYWdEZWx0YSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBwcmV2ZW50IHRoZSBkcmFnZ2luZyBmcm9tIHRyaWdnZXJpbmcgdGV4dCBzZWxlY3Rpb24gb24gdGhlIHBhZ2VcblxuXG4gICAgICAgIHByZXZlbnREZWZhdWx0ID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgc2VsZWN0WzJdID0gcG9zWzBdO1xuICAgICAgc2VsZWN0WzNdID0gcG9zWzFdO1xuXG4gICAgICBpZiAocHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgaWYgKGUuc3RvcFByb3BhZ2F0aW9uKSBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSwgZmFsc2UpO1xuICAgIHZhciBjbGlja1RpbWVvdXQsIGRpZERvdWJsZUNsaWNrLCBwcmV2Q2xpY2tUaW1lU3RhbXA7XG4gICAgci5yZWdpc3RlckJpbmRpbmcod2luZG93LCAnbW91c2V1cCcsIGZ1bmN0aW9uIG1vdXNldXBIYW5kbGVyKGUpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgICAgIHZhciBjYXB0dXJlID0gci5ob3ZlckRhdGEuY2FwdHVyZTtcblxuICAgICAgaWYgKCFjYXB0dXJlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgci5ob3ZlckRhdGEuY2FwdHVyZSA9IGZhbHNlO1xuICAgICAgdmFyIGN5ID0gci5jeTtcbiAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS5jbGllbnRYLCBlLmNsaWVudFkpO1xuICAgICAgdmFyIHNlbGVjdCA9IHIuc2VsZWN0aW9uO1xuICAgICAgdmFyIG5lYXIgPSByLmZpbmROZWFyZXN0RWxlbWVudChwb3NbMF0sIHBvc1sxXSwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgdmFyIGRyYWdnZWRFbGVtZW50cyA9IHIuZHJhZ0RhdGEucG9zc2libGVEcmFnRWxlbWVudHM7XG4gICAgICB2YXIgZG93biA9IHIuaG92ZXJEYXRhLmRvd247XG4gICAgICB2YXIgbXVsdFNlbEtleURvd24gPSBpc011bHRTZWxLZXlEb3duKGUpO1xuXG4gICAgICBpZiAoci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uKSB7XG4gICAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG4gICAgICAgIHIucmVkcmF3KCk7XG4gICAgICB9XG5cbiAgICAgIHIuaG92ZXJEYXRhLnRhcGhvbGRDYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkOyAvLyBub3QgYWN0aXZlIGJnIG5vd1xuXG4gICAgICBpZiAoZG93bikge1xuICAgICAgICBkb3duLnVuYWN0aXZhdGUoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHIuaG92ZXJEYXRhLndoaWNoID09PSAzKSB7XG4gICAgICAgIHZhciBjeHRFdnQgPSB7XG4gICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICB0eXBlOiAnY3h0dGFwZW5kJyxcbiAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChkb3duKSB7XG4gICAgICAgICAgZG93bi5lbWl0KGN4dEV2dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3kuZW1pdChjeHRFdnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFyLmhvdmVyRGF0YS5jeHREcmFnZ2VkKSB7XG4gICAgICAgICAgdmFyIGN4dFRhcCA9IHtcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgICAgICB0eXBlOiAnY3h0dGFwJyxcbiAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmIChkb3duKSB7XG4gICAgICAgICAgICBkb3duLmVtaXQoY3h0VGFwKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3kuZW1pdChjeHRUYXApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHIuaG92ZXJEYXRhLmN4dERyYWdnZWQgPSBmYWxzZTtcbiAgICAgICAgci5ob3ZlckRhdGEud2hpY2ggPSBudWxsO1xuICAgICAgfSBlbHNlIGlmIChyLmhvdmVyRGF0YS53aGljaCA9PT0gMSkge1xuICAgICAgICB0cmlnZ2VyRXZlbnRzKG5lYXIsIFsnbW91c2V1cCcsICd0YXBlbmQnLCAndm1vdXNldXAnXSwgZSwge1xuICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCFyLmRyYWdEYXRhLmRpZERyYWcgJiYgLy8gZGlkbid0IG1vdmUgYSBub2RlIGFyb3VuZFxuICAgICAgICAhci5ob3ZlckRhdGEuZHJhZ2dlZCAmJiAvLyBkaWRuJ3QgcGFuXG4gICAgICAgICFyLmhvdmVyRGF0YS5zZWxlY3RpbmcgJiYgLy8gbm90IGJveCBzZWxlY3Rpb25cbiAgICAgICAgIXIuaG92ZXJEYXRhLmlzT3ZlclRocmVzaG9sZERyYWcgLy8gZGlkbid0IG1vdmUgdG9vIG11Y2hcbiAgICAgICAgKSB7XG4gICAgICAgICAgdHJpZ2dlckV2ZW50cyhkb3duLCBbXCJjbGlja1wiLCBcInRhcFwiLCBcInZjbGlja1wiXSwgZSwge1xuICAgICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZGlkRG91YmxlQ2xpY2sgPSBmYWxzZTtcblxuICAgICAgICAgIGlmIChlLnRpbWVTdGFtcCAtIHByZXZDbGlja1RpbWVTdGFtcCA8PSBjeS5tdWx0aUNsaWNrRGVib3VuY2VUaW1lKCkpIHtcbiAgICAgICAgICAgIGNsaWNrVGltZW91dCAmJiBjbGVhclRpbWVvdXQoY2xpY2tUaW1lb3V0KTtcbiAgICAgICAgICAgIGRpZERvdWJsZUNsaWNrID0gdHJ1ZTtcbiAgICAgICAgICAgIHByZXZDbGlja1RpbWVTdGFtcCA9IG51bGw7XG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnRzKGRvd24sIFtcImRibGNsaWNrXCIsIFwiZGJsdGFwXCIsIFwidmRibGNsaWNrXCJdLCBlLCB7XG4gICAgICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2xpY2tUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGlmIChkaWREb3VibGVDbGljaykgcmV0dXJuO1xuICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnRzKGRvd24sIFtcIm9uZWNsaWNrXCIsIFwib25ldGFwXCIsIFwidm9uZWNsaWNrXCJdLCBlLCB7XG4gICAgICAgICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIGN5Lm11bHRpQ2xpY2tEZWJvdW5jZVRpbWUoKSk7XG4gICAgICAgICAgICBwcmV2Q2xpY2tUaW1lU3RhbXAgPSBlLnRpbWVTdGFtcDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gRGVzZWxlY3QgYWxsIGVsZW1lbnRzIGlmIG5vdGhpbmcgaXMgY3VycmVudGx5IHVuZGVyIHRoZSBtb3VzZSBjdXJzb3IgYW5kIHdlIGFyZW4ndCBkcmFnZ2luZyBzb21ldGhpbmdcblxuXG4gICAgICAgIGlmIChkb3duID09IG51bGwgLy8gbm90IG1vdXNlZG93biBvbiBub2RlXG4gICAgICAgICYmICFyLmRyYWdEYXRhLmRpZERyYWcgLy8gZGlkbid0IG1vdmUgdGhlIG5vZGUgYXJvdW5kXG4gICAgICAgICYmICFyLmhvdmVyRGF0YS5zZWxlY3RpbmcgLy8gbm90IGJveCBzZWxlY3Rpb25cbiAgICAgICAgJiYgIXIuaG92ZXJEYXRhLmRyYWdnZWQgLy8gZGlkbid0IHBhblxuICAgICAgICAmJiAhaXNNdWx0U2VsS2V5RG93bihlKSkge1xuICAgICAgICAgIGN5LiQoaXNTZWxlY3RlZCkudW5zZWxlY3QoWyd0YXB1bnNlbGVjdCddKTtcblxuICAgICAgICAgIGlmIChkcmFnZ2VkRWxlbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgci5kcmFnRGF0YS5wb3NzaWJsZURyYWdFbGVtZW50cyA9IGRyYWdnZWRFbGVtZW50cyA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICAgICAgfSAvLyBTaW5nbGUgc2VsZWN0aW9uXG5cblxuICAgICAgICBpZiAobmVhciA9PSBkb3duICYmICFyLmRyYWdEYXRhLmRpZERyYWcgJiYgIXIuaG92ZXJEYXRhLnNlbGVjdGluZykge1xuICAgICAgICAgIGlmIChuZWFyICE9IG51bGwgJiYgbmVhci5fcHJpdmF0ZS5zZWxlY3RhYmxlKSB7XG4gICAgICAgICAgICBpZiAoci5ob3ZlckRhdGEuZHJhZ2dpbmcpIDsgZWxzZSBpZiAoY3kuc2VsZWN0aW9uVHlwZSgpID09PSAnYWRkaXRpdmUnIHx8IG11bHRTZWxLZXlEb3duKSB7XG4gICAgICAgICAgICAgIGlmIChuZWFyLnNlbGVjdGVkKCkpIHtcbiAgICAgICAgICAgICAgICBuZWFyLnVuc2VsZWN0KFsndGFwdW5zZWxlY3QnXSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmVhci5zZWxlY3QoWyd0YXBzZWxlY3QnXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmICghbXVsdFNlbEtleURvd24pIHtcbiAgICAgICAgICAgICAgICBjeS4kKGlzU2VsZWN0ZWQpLnVubWVyZ2UobmVhcikudW5zZWxlY3QoWyd0YXB1bnNlbGVjdCddKTtcbiAgICAgICAgICAgICAgICBuZWFyLnNlbGVjdChbJ3RhcHNlbGVjdCddKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoci5ob3ZlckRhdGEuc2VsZWN0aW5nKSB7XG4gICAgICAgICAgdmFyIGJveCA9IGN5LmNvbGxlY3Rpb24oci5nZXRBbGxJbkJveChzZWxlY3RbMF0sIHNlbGVjdFsxXSwgc2VsZWN0WzJdLCBzZWxlY3RbM10pKTtcbiAgICAgICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuXG4gICAgICAgICAgaWYgKGJveC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjeS5lbWl0KHtcbiAgICAgICAgICAgIHR5cGU6ICdib3hlbmQnLFxuICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgZWxlV291bGRCZVNlbGVjdGVkID0gZnVuY3Rpb24gZWxlV291bGRCZVNlbGVjdGVkKGVsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZS5zZWxlY3RhYmxlKCkgJiYgIWVsZS5zZWxlY3RlZCgpO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAoY3kuc2VsZWN0aW9uVHlwZSgpID09PSAnYWRkaXRpdmUnKSB7XG4gICAgICAgICAgICBib3guZW1pdCgnYm94Jykuc3RkRmlsdGVyKGVsZVdvdWxkQmVTZWxlY3RlZCkuc2VsZWN0KCkuZW1pdCgnYm94c2VsZWN0Jyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghbXVsdFNlbEtleURvd24pIHtcbiAgICAgICAgICAgICAgY3kuJChpc1NlbGVjdGVkKS51bm1lcmdlKGJveCkudW5zZWxlY3QoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYm94LmVtaXQoJ2JveCcpLnN0ZEZpbHRlcihlbGVXb3VsZEJlU2VsZWN0ZWQpLnNlbGVjdCgpLmVtaXQoJ2JveHNlbGVjdCcpO1xuICAgICAgICAgIH0gLy8gYWx3YXlzIG5lZWQgcmVkcmF3IGluIGNhc2UgZWxlcyB1bnNlbGVjdGFibGVcblxuXG4gICAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgICAgfSAvLyBDYW5jZWwgZHJhZyBwYW5cblxuXG4gICAgICAgIGlmIChyLmhvdmVyRGF0YS5kcmFnZ2luZykge1xuICAgICAgICAgIHIuaG92ZXJEYXRhLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgICAgICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgICAgICAgICByLnJlZHJhdygpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzZWxlY3RbNF0pIHtcbiAgICAgICAgICByLnJlZHJhd0hpbnQoJ2RyYWcnLCB0cnVlKTtcbiAgICAgICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgICAgICAgICB2YXIgZG93bldhc0dyYWJiZWQgPSBkb3duICYmIGRvd24uZ3JhYmJlZCgpO1xuICAgICAgICAgIGZyZWVEcmFnZ2VkRWxlbWVudHMoZHJhZ2dlZEVsZW1lbnRzKTtcblxuICAgICAgICAgIGlmIChkb3duV2FzR3JhYmJlZCkge1xuICAgICAgICAgICAgZG93bi5lbWl0KCdmcmVlb24nKTtcbiAgICAgICAgICAgIGRyYWdnZWRFbGVtZW50cy5lbWl0KCdmcmVlJyk7XG5cbiAgICAgICAgICAgIGlmIChyLmRyYWdEYXRhLmRpZERyYWcpIHtcbiAgICAgICAgICAgICAgZG93bi5lbWl0KCdkcmFnZnJlZW9uJyk7XG4gICAgICAgICAgICAgIGRyYWdnZWRFbGVtZW50cy5lbWl0KCdkcmFnZnJlZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBlbHNlIG5vdCByaWdodCBtb3VzZVxuXG5cbiAgICAgIHNlbGVjdFs0XSA9IDA7XG4gICAgICByLmhvdmVyRGF0YS5kb3duID0gbnVsbDtcbiAgICAgIHIuaG92ZXJEYXRhLmN4dFN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgIHIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcyA9IGZhbHNlO1xuICAgICAgci5ob3ZlckRhdGEuc2VsZWN0aW5nID0gZmFsc2U7XG4gICAgICByLmhvdmVyRGF0YS5pc092ZXJUaHJlc2hvbGREcmFnID0gZmFsc2U7XG4gICAgICByLmRyYWdEYXRhLmRpZERyYWcgPSBmYWxzZTtcbiAgICAgIHIuaG92ZXJEYXRhLmRyYWdnZWQgPSBmYWxzZTtcbiAgICAgIHIuaG92ZXJEYXRhLmRyYWdEZWx0YSA9IFtdO1xuICAgICAgci5ob3ZlckRhdGEubWRvd25Qb3MgPSBudWxsO1xuICAgICAgci5ob3ZlckRhdGEubWRvd25HUG9zID0gbnVsbDtcbiAgICB9LCBmYWxzZSk7XG5cbiAgICB2YXIgd2hlZWxIYW5kbGVyID0gZnVuY3Rpb24gd2hlZWxIYW5kbGVyKGUpIHtcbiAgICAgIGlmIChyLnNjcm9sbGluZ1BhZ2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyB3aGlsZSBzY3JvbGxpbmcsIGlnbm9yZSB3aGVlbC10by16b29tXG5cblxuICAgICAgdmFyIGN5ID0gci5jeTtcbiAgICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuICAgICAgdmFyIHBhbiA9IGN5LnBhbigpO1xuICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLmNsaWVudFgsIGUuY2xpZW50WSk7XG4gICAgICB2YXIgcnBvcyA9IFtwb3NbMF0gKiB6b29tICsgcGFuLngsIHBvc1sxXSAqIHpvb20gKyBwYW4ueV07XG5cbiAgICAgIGlmIChyLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgfHwgci5ob3ZlckRhdGEuZHJhZ2dpbmcgfHwgci5ob3ZlckRhdGEuY3h0U3RhcnRlZCB8fCBpbkJveFNlbGVjdGlvbigpKSB7XG4gICAgICAgIC8vIGlmIHBhbiBkcmFnZ2luZyBvciBjeHQgZHJhZ2dpbmcsIHdoZWVsIG1vdmVtZW50cyBtYWtlIG5vIHpvb21cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChjeS5wYW5uaW5nRW5hYmxlZCgpICYmIGN5LnVzZXJQYW5uaW5nRW5hYmxlZCgpICYmIGN5Lnpvb21pbmdFbmFibGVkKCkgJiYgY3kudXNlclpvb21pbmdFbmFibGVkKCkpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByLmRhdGEud2hlZWxab29taW5nID0gdHJ1ZTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHIuZGF0YS53aGVlbFRpbWVvdXQpO1xuICAgICAgICByLmRhdGEud2hlZWxUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgci5kYXRhLndoZWVsWm9vbWluZyA9IGZhbHNlO1xuICAgICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgICAgIHIucmVkcmF3KCk7XG4gICAgICAgIH0sIDE1MCk7XG4gICAgICAgIHZhciBkaWZmO1xuXG4gICAgICAgIGlmIChlLmRlbHRhWSAhPSBudWxsKSB7XG4gICAgICAgICAgZGlmZiA9IGUuZGVsdGFZIC8gLTI1MDtcbiAgICAgICAgfSBlbHNlIGlmIChlLndoZWVsRGVsdGFZICE9IG51bGwpIHtcbiAgICAgICAgICBkaWZmID0gZS53aGVlbERlbHRhWSAvIDEwMDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGlmZiA9IGUud2hlZWxEZWx0YSAvIDEwMDA7XG4gICAgICAgIH1cblxuICAgICAgICBkaWZmID0gZGlmZiAqIHIud2hlZWxTZW5zaXRpdml0eTtcbiAgICAgICAgdmFyIG5lZWRzV2hlZWxGaXggPSBlLmRlbHRhTW9kZSA9PT0gMTtcblxuICAgICAgICBpZiAobmVlZHNXaGVlbEZpeCkge1xuICAgICAgICAgIC8vIGZpeGVzIHNsb3cgd2hlZWwgZXZlbnRzIG9uIGZmL2xpbnV4IGFuZCBmZi93aW5kb3dzXG4gICAgICAgICAgZGlmZiAqPSAzMztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuZXdab29tID0gY3kuem9vbSgpICogTWF0aC5wb3coMTAsIGRpZmYpO1xuXG4gICAgICAgIGlmIChlLnR5cGUgPT09ICdnZXN0dXJlY2hhbmdlJykge1xuICAgICAgICAgIG5ld1pvb20gPSByLmdlc3R1cmVTdGFydFpvb20gKiBlLnNjYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgY3kuem9vbSh7XG4gICAgICAgICAgbGV2ZWw6IG5ld1pvb20sXG4gICAgICAgICAgcmVuZGVyZWRQb3NpdGlvbjoge1xuICAgICAgICAgICAgeDogcnBvc1swXSxcbiAgICAgICAgICAgIHk6IHJwb3NbMV1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjeS5lbWl0KGUudHlwZSA9PT0gJ2dlc3R1cmVjaGFuZ2UnID8gJ3BpbmNoem9vbScgOiAnc2Nyb2xsem9vbScpO1xuICAgICAgfVxuICAgIH07IC8vIEZ1bmN0aW9ucyB0byBoZWxwIHdpdGggd2hldGhlciBtb3VzZSB3aGVlbCBzaG91bGQgdHJpZ2dlciB6b29taW5nXG4gICAgLy8gLS1cblxuXG4gICAgci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICd3aGVlbCcsIHdoZWVsSGFuZGxlciwgdHJ1ZSk7IC8vIGRpc2FibGUgbm9uc3RhbmRhcmQgd2hlZWwgZXZlbnRzXG4gICAgLy8gci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICdtb3VzZXdoZWVsJywgd2hlZWxIYW5kbGVyLCB0cnVlKTtcbiAgICAvLyByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ0RPTU1vdXNlU2Nyb2xsJywgd2hlZWxIYW5kbGVyLCB0cnVlKTtcbiAgICAvLyByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ01vek1vdXNlUGl4ZWxTY3JvbGwnLCB3aGVlbEhhbmRsZXIsIHRydWUpOyAvLyBvbGRlciBmaXJlZm94XG5cbiAgICByLnJlZ2lzdGVyQmluZGluZyh3aW5kb3csICdzY3JvbGwnLCBmdW5jdGlvbiBzY3JvbGxIYW5kbGVyKGUpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHIuc2Nyb2xsaW5nUGFnZSA9IHRydWU7XG4gICAgICBjbGVhclRpbWVvdXQoci5zY3JvbGxpbmdQYWdlVGltZW91dCk7XG4gICAgICByLnNjcm9sbGluZ1BhZ2VUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHIuc2Nyb2xsaW5nUGFnZSA9IGZhbHNlO1xuICAgICAgfSwgMjUwKTtcbiAgICB9LCB0cnVlKTsgLy8gZGVza3RvcCBzYWZhcmkgcGluY2ggdG8gem9vbSBzdGFydFxuXG4gICAgci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICdnZXN0dXJlc3RhcnQnLCBmdW5jdGlvbiBnZXN0dXJlU3RhcnRIYW5kbGVyKGUpIHtcbiAgICAgIHIuZ2VzdHVyZVN0YXJ0Wm9vbSA9IHIuY3kuem9vbSgpO1xuXG4gICAgICBpZiAoIXIuaGFzVG91Y2hTdGFydGVkKSB7XG4gICAgICAgIC8vIGRvbid0IGFmZmVjdCB0b3VjaCBkZXZpY2VzIGxpa2UgaXBob25lXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICB9LCB0cnVlKTtcbiAgICByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ2dlc3R1cmVjaGFuZ2UnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKCFyLmhhc1RvdWNoU3RhcnRlZCkge1xuICAgICAgICAvLyBkb24ndCBhZmZlY3QgdG91Y2ggZGV2aWNlcyBsaWtlIGlwaG9uZVxuICAgICAgICB3aGVlbEhhbmRsZXIoZSk7XG4gICAgICB9XG4gICAgfSwgdHJ1ZSk7IC8vIEZ1bmN0aW9ucyB0byBoZWxwIHdpdGggaGFuZGxpbmcgbW91c2VvdXQvbW91c2VvdmVyIG9uIHRoZSBDeXRvc2NhcGUgY29udGFpbmVyXG4gICAgLy8gSGFuZGxlIG1vdXNlb3V0IG9uIEN5dG9zY2FwZSBjb250YWluZXJcblxuICAgIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAnbW91c2VvdXQnLCBmdW5jdGlvbiBtb3VzZU91dEhhbmRsZXIoZSkge1xuICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLmNsaWVudFgsIGUuY2xpZW50WSk7XG4gICAgICByLmN5LmVtaXQoe1xuICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICB0eXBlOiAnbW91c2VvdXQnLFxuICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSwgZmFsc2UpO1xuICAgIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAnbW91c2VvdmVyJywgZnVuY3Rpb24gbW91c2VPdmVySGFuZGxlcihlKSB7XG4gICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUuY2xpZW50WCwgZS5jbGllbnRZKTtcbiAgICAgIHIuY3kuZW1pdCh7XG4gICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgIHR5cGU6ICdtb3VzZW92ZXInLFxuICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSwgZmFsc2UpO1xuICAgIHZhciBmMXgxLCBmMXkxLCBmMngxLCBmMnkxOyAvLyBzdGFydGluZyBwb2ludHMgZm9yIHBpbmNoLXRvLXpvb21cblxuICAgIHZhciBkaXN0YW5jZTEsIGRpc3RhbmNlMVNxOyAvLyBpbml0aWFsIGRpc3RhbmNlIGJldHdlZW4gZmluZ2VyIDEgYW5kIGZpbmdlciAyIGZvciBwaW5jaC10by16b29tXG5cbiAgICB2YXIgY2VudGVyMSwgbW9kZWxDZW50ZXIxOyAvLyBjZW50ZXIgcG9pbnQgb24gc3RhcnQgcGluY2ggdG8gem9vbVxuXG4gICAgdmFyIG9mZnNldExlZnQsIG9mZnNldFRvcDtcbiAgICB2YXIgY29udGFpbmVyV2lkdGgsIGNvbnRhaW5lckhlaWdodDtcbiAgICB2YXIgdHdvRmluZ2Vyc1N0YXJ0SW5zaWRlO1xuXG4gICAgdmFyIGRpc3RhbmNlID0gZnVuY3Rpb24gZGlzdGFuY2UoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgIHJldHVybiBNYXRoLnNxcnQoKHgyIC0geDEpICogKHgyIC0geDEpICsgKHkyIC0geTEpICogKHkyIC0geTEpKTtcbiAgICB9O1xuXG4gICAgdmFyIGRpc3RhbmNlU3EgPSBmdW5jdGlvbiBkaXN0YW5jZVNxKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgICByZXR1cm4gKHgyIC0geDEpICogKHgyIC0geDEpICsgKHkyIC0geTEpICogKHkyIC0geTEpO1xuICAgIH07XG5cbiAgICB2YXIgdG91Y2hzdGFydEhhbmRsZXI7XG4gICAgci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICd0b3VjaHN0YXJ0JywgdG91Y2hzdGFydEhhbmRsZXIgPSBmdW5jdGlvbiB0b3VjaHN0YXJ0SGFuZGxlcihlKSB7XG4gICAgICByLmhhc1RvdWNoU3RhcnRlZCA9IHRydWU7XG5cbiAgICAgIGlmICghZXZlbnRJbkNvbnRhaW5lcihlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGJsdXJBY3RpdmVEb21FbGVtZW50KCk7XG4gICAgICByLnRvdWNoRGF0YS5jYXB0dXJlID0gdHJ1ZTtcbiAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgIHZhciBjeSA9IHIuY3k7XG4gICAgICB2YXIgbm93ID0gci50b3VjaERhdGEubm93O1xuICAgICAgdmFyIGVhcmxpZXIgPSByLnRvdWNoRGF0YS5lYXJsaWVyO1xuXG4gICAgICBpZiAoZS50b3VjaGVzWzBdKSB7XG4gICAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzBdLmNsaWVudFgsIGUudG91Y2hlc1swXS5jbGllbnRZKTtcbiAgICAgICAgbm93WzBdID0gcG9zWzBdO1xuICAgICAgICBub3dbMV0gPSBwb3NbMV07XG4gICAgICB9XG5cbiAgICAgIGlmIChlLnRvdWNoZXNbMV0pIHtcbiAgICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMV0uY2xpZW50WCwgZS50b3VjaGVzWzFdLmNsaWVudFkpO1xuICAgICAgICBub3dbMl0gPSBwb3NbMF07XG4gICAgICAgIG5vd1szXSA9IHBvc1sxXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGUudG91Y2hlc1syXSkge1xuICAgICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1syXS5jbGllbnRYLCBlLnRvdWNoZXNbMl0uY2xpZW50WSk7XG4gICAgICAgIG5vd1s0XSA9IHBvc1swXTtcbiAgICAgICAgbm93WzVdID0gcG9zWzFdO1xuICAgICAgfSAvLyByZWNvcmQgc3RhcnRpbmcgcG9pbnRzIGZvciBwaW5jaC10by16b29tXG5cblxuICAgICAgaWYgKGUudG91Y2hlc1sxXSkge1xuICAgICAgICByLnRvdWNoRGF0YS5zaW5nbGVUb3VjaE1vdmVkID0gdHJ1ZTtcbiAgICAgICAgZnJlZURyYWdnZWRFbGVtZW50cyhyLmRyYWdEYXRhLnRvdWNoRHJhZ0VsZXMpO1xuICAgICAgICB2YXIgb2Zmc2V0cyA9IHIuZmluZENvbnRhaW5lckNsaWVudENvb3JkcygpO1xuICAgICAgICBvZmZzZXRMZWZ0ID0gb2Zmc2V0c1swXTtcbiAgICAgICAgb2Zmc2V0VG9wID0gb2Zmc2V0c1sxXTtcbiAgICAgICAgY29udGFpbmVyV2lkdGggPSBvZmZzZXRzWzJdO1xuICAgICAgICBjb250YWluZXJIZWlnaHQgPSBvZmZzZXRzWzNdO1xuICAgICAgICBmMXgxID0gZS50b3VjaGVzWzBdLmNsaWVudFggLSBvZmZzZXRMZWZ0O1xuICAgICAgICBmMXkxID0gZS50b3VjaGVzWzBdLmNsaWVudFkgLSBvZmZzZXRUb3A7XG4gICAgICAgIGYyeDEgPSBlLnRvdWNoZXNbMV0uY2xpZW50WCAtIG9mZnNldExlZnQ7XG4gICAgICAgIGYyeTEgPSBlLnRvdWNoZXNbMV0uY2xpZW50WSAtIG9mZnNldFRvcDtcbiAgICAgICAgdHdvRmluZ2Vyc1N0YXJ0SW5zaWRlID0gMCA8PSBmMXgxICYmIGYxeDEgPD0gY29udGFpbmVyV2lkdGggJiYgMCA8PSBmMngxICYmIGYyeDEgPD0gY29udGFpbmVyV2lkdGggJiYgMCA8PSBmMXkxICYmIGYxeTEgPD0gY29udGFpbmVySGVpZ2h0ICYmIDAgPD0gZjJ5MSAmJiBmMnkxIDw9IGNvbnRhaW5lckhlaWdodDtcbiAgICAgICAgdmFyIHBhbiA9IGN5LnBhbigpO1xuICAgICAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcbiAgICAgICAgZGlzdGFuY2UxID0gZGlzdGFuY2UoZjF4MSwgZjF5MSwgZjJ4MSwgZjJ5MSk7XG4gICAgICAgIGRpc3RhbmNlMVNxID0gZGlzdGFuY2VTcShmMXgxLCBmMXkxLCBmMngxLCBmMnkxKTtcbiAgICAgICAgY2VudGVyMSA9IFsoZjF4MSArIGYyeDEpIC8gMiwgKGYxeTEgKyBmMnkxKSAvIDJdO1xuICAgICAgICBtb2RlbENlbnRlcjEgPSBbKGNlbnRlcjFbMF0gLSBwYW4ueCkgLyB6b29tLCAoY2VudGVyMVsxXSAtIHBhbi55KSAvIHpvb21dOyAvLyBjb25zaWRlciBjb250ZXh0IHRhcFxuXG4gICAgICAgIHZhciBjeHREaXN0VGhyZXNob2xkID0gMjAwO1xuICAgICAgICB2YXIgY3h0RGlzdFRocmVzaG9sZFNxID0gY3h0RGlzdFRocmVzaG9sZCAqIGN4dERpc3RUaHJlc2hvbGQ7XG5cbiAgICAgICAgaWYgKGRpc3RhbmNlMVNxIDwgY3h0RGlzdFRocmVzaG9sZFNxICYmICFlLnRvdWNoZXNbMl0pIHtcbiAgICAgICAgICB2YXIgbmVhcjEgPSByLmZpbmROZWFyZXN0RWxlbWVudChub3dbMF0sIG5vd1sxXSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgdmFyIG5lYXIyID0gci5maW5kTmVhcmVzdEVsZW1lbnQobm93WzJdLCBub3dbM10sIHRydWUsIHRydWUpO1xuXG4gICAgICAgICAgaWYgKG5lYXIxICYmIG5lYXIxLmlzTm9kZSgpKSB7XG4gICAgICAgICAgICBuZWFyMS5hY3RpdmF0ZSgpLmVtaXQoe1xuICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgICAgICB0eXBlOiAnY3h0dGFwc3RhcnQnLFxuICAgICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgICAgICAgICB5OiBub3dbMV1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydCA9IG5lYXIxO1xuICAgICAgICAgIH0gZWxzZSBpZiAobmVhcjIgJiYgbmVhcjIuaXNOb2RlKCkpIHtcbiAgICAgICAgICAgIG5lYXIyLmFjdGl2YXRlKCkuZW1pdCh7XG4gICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgICAgICAgIHR5cGU6ICdjeHR0YXBzdGFydCcsXG4gICAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0ID0gbmVhcjI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN5LmVtaXQoe1xuICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgICAgICB0eXBlOiAnY3h0dGFwc3RhcnQnLFxuICAgICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgICAgICAgICB5OiBub3dbMV1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHIudG91Y2hEYXRhLnN0YXJ0KSB7XG4gICAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydC5fcHJpdmF0ZS5ncmFiYmVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgci50b3VjaERhdGEuY3h0ID0gdHJ1ZTtcbiAgICAgICAgICByLnRvdWNoRGF0YS5jeHREcmFnZ2VkID0gZmFsc2U7XG4gICAgICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHIucmVkcmF3KCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChlLnRvdWNoZXNbMl0pIHtcbiAgICAgICAgLy8gaWdub3JlXG4gICAgICAgIC8vIHNhZmFyaSBvbiBpb3MgcGFucyB0aGUgcGFnZSBvdGhlcndpc2UgKG5vcm1hbGx5IHlvdSBzaG91bGQgYmUgYWJsZSB0byBwcmV2ZW50ZGVmYXVsdCBvbiB0b3VjaG1vdmUuLi4pXG4gICAgICAgIGlmIChjeS5ib3hTZWxlY3Rpb25FbmFibGVkKCkpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZS50b3VjaGVzWzFdKSA7IGVsc2UgaWYgKGUudG91Y2hlc1swXSkge1xuICAgICAgICB2YXIgbmVhcnMgPSByLmZpbmROZWFyZXN0RWxlbWVudHMobm93WzBdLCBub3dbMV0sIHRydWUsIHRydWUpO1xuICAgICAgICB2YXIgbmVhciA9IG5lYXJzWzBdO1xuXG4gICAgICAgIGlmIChuZWFyICE9IG51bGwpIHtcbiAgICAgICAgICBuZWFyLmFjdGl2YXRlKCk7XG4gICAgICAgICAgci50b3VjaERhdGEuc3RhcnQgPSBuZWFyO1xuICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0cyA9IG5lYXJzO1xuXG4gICAgICAgICAgaWYgKHIubm9kZUlzR3JhYmJhYmxlKG5lYXIpKSB7XG4gICAgICAgICAgICB2YXIgZHJhZ2dlZEVsZXMgPSByLmRyYWdEYXRhLnRvdWNoRHJhZ0VsZXMgPSBjeS5jb2xsZWN0aW9uKCk7XG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWROb2RlcyA9IG51bGw7XG4gICAgICAgICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgICAgICAgICAgIHIucmVkcmF3SGludCgnZHJhZycsIHRydWUpO1xuXG4gICAgICAgICAgICBpZiAobmVhci5zZWxlY3RlZCgpKSB7XG4gICAgICAgICAgICAgIC8vIHJlc2V0IGRyYWcgZWxlbWVudHMsIHNpbmNlIG5lYXIgd2lsbCBiZSBhZGRlZCBhZ2FpblxuICAgICAgICAgICAgICBzZWxlY3RlZE5vZGVzID0gY3kuJChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZS5zZWxlY3RlZCgpICYmIHIubm9kZUlzR3JhYmJhYmxlKGVsZSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBhZGROb2Rlc1RvRHJhZyhzZWxlY3RlZE5vZGVzLCB7XG4gICAgICAgICAgICAgICAgYWRkVG9MaXN0OiBkcmFnZ2VkRWxlc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGFkZE5vZGVUb0RyYWcobmVhciwge1xuICAgICAgICAgICAgICAgIGFkZFRvTGlzdDogZHJhZ2dlZEVsZXNcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNldEdyYWJUYXJnZXQobmVhcik7XG5cbiAgICAgICAgICAgIHZhciBtYWtlRXZlbnQgPSBmdW5jdGlvbiBtYWtlRXZlbnQodHlwZSkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgICAgICAgICAgeTogbm93WzFdXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgbmVhci5lbWl0KG1ha2VFdmVudCgnZ3JhYm9uJykpO1xuXG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWROb2Rlcykge1xuICAgICAgICAgICAgICBzZWxlY3RlZE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgICAgICBuLmVtaXQobWFrZUV2ZW50KCdncmFiJykpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5lYXIuZW1pdChtYWtlRXZlbnQoJ2dyYWInKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdHJpZ2dlckV2ZW50cyhuZWFyLCBbJ3RvdWNoc3RhcnQnLCAndGFwc3RhcnQnLCAndm1vdXNlZG93biddLCBlLCB7XG4gICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAobmVhciA9PSBudWxsKSB7XG4gICAgICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0ge1xuICAgICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgICAgfTtcbiAgICAgICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICAgICAgICAgIHIucmVkcmF3KCk7XG4gICAgICAgIH0gLy8gVGFwLCB0YXBob2xkXG4gICAgICAgIC8vIC0tLS0tXG5cblxuICAgICAgICByLnRvdWNoRGF0YS5zaW5nbGVUb3VjaE1vdmVkID0gZmFsc2U7XG4gICAgICAgIHIudG91Y2hEYXRhLnNpbmdsZVRvdWNoU3RhcnRUaW1lID0gK25ldyBEYXRlKCk7XG4gICAgICAgIGNsZWFyVGltZW91dChyLnRvdWNoRGF0YS50YXBob2xkVGltZW91dCk7XG4gICAgICAgIHIudG91Y2hEYXRhLnRhcGhvbGRUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHIudG91Y2hEYXRhLnNpbmdsZVRvdWNoTW92ZWQgPT09IGZhbHNlICYmICFyLnBpbmNoaW5nIC8vIGlmIHBpbmNoaW5nLCB0aGVuIHRhcGhvbGQgdW5zZWxlY3Qgc2hvdWxkbid0IHRha2UgZWZmZWN0XG4gICAgICAgICAgJiYgIXIudG91Y2hEYXRhLnNlbGVjdGluZyAvLyBib3ggc2VsZWN0aW9uIHNob3VsZG4ndCBhbGxvdyB0YXBob2xkIHRocm91Z2hcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHRyaWdnZXJFdmVudHMoci50b3VjaERhdGEuc3RhcnQsIFsndGFwaG9sZCddLCBlLCB7XG4gICAgICAgICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgICAgICAgeTogbm93WzFdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHIudGFwaG9sZER1cmF0aW9uKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPj0gMSkge1xuICAgICAgICB2YXIgc1BvcyA9IHIudG91Y2hEYXRhLnN0YXJ0UG9zaXRpb24gPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vdy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHNQb3NbaV0gPSBlYXJsaWVyW2ldID0gbm93W2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRvdWNoMCA9IGUudG91Y2hlc1swXTtcbiAgICAgICAgci50b3VjaERhdGEuc3RhcnRHUG9zaXRpb24gPSBbdG91Y2gwLmNsaWVudFgsIHRvdWNoMC5jbGllbnRZXTtcbiAgICAgIH1cbiAgICB9LCBmYWxzZSk7XG4gICAgdmFyIHRvdWNobW92ZUhhbmRsZXI7XG4gICAgci5yZWdpc3RlckJpbmRpbmcod2luZG93LCAndG91Y2htb3ZlJywgdG91Y2htb3ZlSGFuZGxlciA9IGZ1bmN0aW9uIHRvdWNobW92ZUhhbmRsZXIoZSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgICAgdmFyIGNhcHR1cmUgPSByLnRvdWNoRGF0YS5jYXB0dXJlO1xuXG4gICAgICBpZiAoIWNhcHR1cmUgJiYgIWV2ZW50SW5Db250YWluZXIoZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2VsZWN0ID0gci5zZWxlY3Rpb247XG4gICAgICB2YXIgY3kgPSByLmN5O1xuICAgICAgdmFyIG5vdyA9IHIudG91Y2hEYXRhLm5vdztcbiAgICAgIHZhciBlYXJsaWVyID0gci50b3VjaERhdGEuZWFybGllcjtcbiAgICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuXG4gICAgICBpZiAoZS50b3VjaGVzWzBdKSB7XG4gICAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzBdLmNsaWVudFgsIGUudG91Y2hlc1swXS5jbGllbnRZKTtcbiAgICAgICAgbm93WzBdID0gcG9zWzBdO1xuICAgICAgICBub3dbMV0gPSBwb3NbMV07XG4gICAgICB9XG5cbiAgICAgIGlmIChlLnRvdWNoZXNbMV0pIHtcbiAgICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMV0uY2xpZW50WCwgZS50b3VjaGVzWzFdLmNsaWVudFkpO1xuICAgICAgICBub3dbMl0gPSBwb3NbMF07XG4gICAgICAgIG5vd1szXSA9IHBvc1sxXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGUudG91Y2hlc1syXSkge1xuICAgICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1syXS5jbGllbnRYLCBlLnRvdWNoZXNbMl0uY2xpZW50WSk7XG4gICAgICAgIG5vd1s0XSA9IHBvc1swXTtcbiAgICAgICAgbm93WzVdID0gcG9zWzFdO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3RhcnRHUG9zID0gci50b3VjaERhdGEuc3RhcnRHUG9zaXRpb247XG4gICAgICB2YXIgaXNPdmVyVGhyZXNob2xkRHJhZztcblxuICAgICAgaWYgKGNhcHR1cmUgJiYgZS50b3VjaGVzWzBdICYmIHN0YXJ0R1Bvcykge1xuICAgICAgICB2YXIgZGlzcCA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbm93Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgZGlzcFtqXSA9IG5vd1tqXSAtIGVhcmxpZXJbal07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZHggPSBlLnRvdWNoZXNbMF0uY2xpZW50WCAtIHN0YXJ0R1Bvc1swXTtcbiAgICAgICAgdmFyIGR4MiA9IGR4ICogZHg7XG4gICAgICAgIHZhciBkeSA9IGUudG91Y2hlc1swXS5jbGllbnRZIC0gc3RhcnRHUG9zWzFdO1xuICAgICAgICB2YXIgZHkyID0gZHkgKiBkeTtcbiAgICAgICAgdmFyIGRpc3QyID0gZHgyICsgZHkyO1xuICAgICAgICBpc092ZXJUaHJlc2hvbGREcmFnID0gZGlzdDIgPj0gci50b3VjaFRhcFRocmVzaG9sZDI7XG4gICAgICB9IC8vIGNvbnRleHQgc3dpcGUgY2FuY2VsbGluZ1xuXG5cbiAgICAgIGlmIChjYXB0dXJlICYmIHIudG91Y2hEYXRhLmN4dCkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHZhciBmMXgyID0gZS50b3VjaGVzWzBdLmNsaWVudFggLSBvZmZzZXRMZWZ0LFxuICAgICAgICAgICAgZjF5MiA9IGUudG91Y2hlc1swXS5jbGllbnRZIC0gb2Zmc2V0VG9wO1xuICAgICAgICB2YXIgZjJ4MiA9IGUudG91Y2hlc1sxXS5jbGllbnRYIC0gb2Zmc2V0TGVmdCxcbiAgICAgICAgICAgIGYyeTIgPSBlLnRvdWNoZXNbMV0uY2xpZW50WSAtIG9mZnNldFRvcDsgLy8gdmFyIGRpc3RhbmNlMiA9IGRpc3RhbmNlKCBmMXgyLCBmMXkyLCBmMngyLCBmMnkyICk7XG5cbiAgICAgICAgdmFyIGRpc3RhbmNlMlNxID0gZGlzdGFuY2VTcShmMXgyLCBmMXkyLCBmMngyLCBmMnkyKTtcbiAgICAgICAgdmFyIGZhY3RvclNxID0gZGlzdGFuY2UyU3EgLyBkaXN0YW5jZTFTcTtcbiAgICAgICAgdmFyIGRpc3RUaHJlc2hvbGQgPSAxNTA7XG4gICAgICAgIHZhciBkaXN0VGhyZXNob2xkU3EgPSBkaXN0VGhyZXNob2xkICogZGlzdFRocmVzaG9sZDtcbiAgICAgICAgdmFyIGZhY3RvclRocmVzaG9sZCA9IDEuNTtcbiAgICAgICAgdmFyIGZhY3RvclRocmVzaG9sZFNxID0gZmFjdG9yVGhyZXNob2xkICogZmFjdG9yVGhyZXNob2xkOyAvLyBjYW5jZWwgY3R4IGdlc3R1cmVzIGlmIHRoZSBkaXN0YW5jZSBiL3QgdGhlIGZpbmdlcnMgaW5jcmVhc2VzXG5cbiAgICAgICAgaWYgKGZhY3RvclNxID49IGZhY3RvclRocmVzaG9sZFNxIHx8IGRpc3RhbmNlMlNxID49IGRpc3RUaHJlc2hvbGRTcSkge1xuICAgICAgICAgIHIudG91Y2hEYXRhLmN4dCA9IGZhbHNlO1xuICAgICAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICAgICAgICAgIHZhciBjeHRFdnQgPSB7XG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgICAgdHlwZTogJ2N4dHRhcGVuZCcsXG4gICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAoci50b3VjaERhdGEuc3RhcnQpIHtcbiAgICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0LnVuYWN0aXZhdGUoKS5lbWl0KGN4dEV2dCk7XG4gICAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydCA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN5LmVtaXQoY3h0RXZ0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gY29udGV4dCBzd2lwZVxuXG5cbiAgICAgIGlmIChjYXB0dXJlICYmIHIudG91Y2hEYXRhLmN4dCkge1xuICAgICAgICB2YXIgY3h0RXZ0ID0ge1xuICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgICAgdHlwZTogJ2N4dGRyYWcnLFxuICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgICB5OiBub3dbMV1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcblxuICAgICAgICBpZiAoci50b3VjaERhdGEuc3RhcnQpIHtcbiAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydC5lbWl0KGN4dEV2dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3kuZW1pdChjeHRFdnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHIudG91Y2hEYXRhLnN0YXJ0KSB7XG4gICAgICAgICAgci50b3VjaERhdGEuc3RhcnQuX3ByaXZhdGUuZ3JhYmJlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgci50b3VjaERhdGEuY3h0RHJhZ2dlZCA9IHRydWU7XG4gICAgICAgIHZhciBuZWFyID0gci5maW5kTmVhcmVzdEVsZW1lbnQobm93WzBdLCBub3dbMV0sIHRydWUsIHRydWUpO1xuXG4gICAgICAgIGlmICghci50b3VjaERhdGEuY3h0T3ZlciB8fCBuZWFyICE9PSByLnRvdWNoRGF0YS5jeHRPdmVyKSB7XG4gICAgICAgICAgaWYgKHIudG91Y2hEYXRhLmN4dE92ZXIpIHtcbiAgICAgICAgICAgIHIudG91Y2hEYXRhLmN4dE92ZXIuZW1pdCh7XG4gICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgICAgICAgIHR5cGU6ICdjeHRkcmFnb3V0JyxcbiAgICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgICAgICAgeTogbm93WzFdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHIudG91Y2hEYXRhLmN4dE92ZXIgPSBuZWFyO1xuXG4gICAgICAgICAgaWYgKG5lYXIpIHtcbiAgICAgICAgICAgIG5lYXIuZW1pdCh7XG4gICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgICAgICAgIHR5cGU6ICdjeHRkcmFnb3ZlcicsXG4gICAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gYm94IHNlbGVjdGlvblxuXG4gICAgICB9IGVsc2UgaWYgKGNhcHR1cmUgJiYgZS50b3VjaGVzWzJdICYmIGN5LmJveFNlbGVjdGlvbkVuYWJsZWQoKSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5sYXN0VGhyZWVUb3VjaCA9ICtuZXcgRGF0ZSgpO1xuXG4gICAgICAgIGlmICghci50b3VjaERhdGEuc2VsZWN0aW5nKSB7XG4gICAgICAgICAgY3kuZW1pdCh7XG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgICAgdHlwZTogJ2JveHN0YXJ0JyxcbiAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgICAgICAgeTogbm93WzFdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByLnRvdWNoRGF0YS5zZWxlY3RpbmcgPSB0cnVlO1xuICAgICAgICByLnRvdWNoRGF0YS5kaWRTZWxlY3QgPSB0cnVlO1xuICAgICAgICBzZWxlY3RbNF0gPSAxO1xuXG4gICAgICAgIGlmICghc2VsZWN0IHx8IHNlbGVjdC5sZW5ndGggPT09IDAgfHwgc2VsZWN0WzBdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBzZWxlY3RbMF0gPSAobm93WzBdICsgbm93WzJdICsgbm93WzRdKSAvIDM7XG4gICAgICAgICAgc2VsZWN0WzFdID0gKG5vd1sxXSArIG5vd1szXSArIG5vd1s1XSkgLyAzO1xuICAgICAgICAgIHNlbGVjdFsyXSA9IChub3dbMF0gKyBub3dbMl0gKyBub3dbNF0pIC8gMyArIDE7XG4gICAgICAgICAgc2VsZWN0WzNdID0gKG5vd1sxXSArIG5vd1szXSArIG5vd1s1XSkgLyAzICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxlY3RbMl0gPSAobm93WzBdICsgbm93WzJdICsgbm93WzRdKSAvIDM7XG4gICAgICAgICAgc2VsZWN0WzNdID0gKG5vd1sxXSArIG5vd1szXSArIG5vd1s1XSkgLyAzO1xuICAgICAgICB9XG5cbiAgICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgICAgICAgci5yZWRyYXcoKTsgLy8gcGluY2ggdG8gem9vbVxuICAgICAgfSBlbHNlIGlmIChjYXB0dXJlICYmIGUudG91Y2hlc1sxXSAmJiAhci50b3VjaERhdGEuZGlkU2VsZWN0IC8vIGRvbid0IGFsbG93IGJveCBzZWxlY3Rpb24gdG8gZGVncmFkZSB0byBwaW5jaC10by16b29tXG4gICAgICAmJiBjeS56b29taW5nRW5hYmxlZCgpICYmIGN5LnBhbm5pbmdFbmFibGVkKCkgJiYgY3kudXNlclpvb21pbmdFbmFibGVkKCkgJiYgY3kudXNlclBhbm5pbmdFbmFibGVkKCkpIHtcbiAgICAgICAgLy8gdHdvIGZpbmdlcnMgPT4gcGluY2ggdG8gem9vbVxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgICAgICAgdmFyIGRyYWdnZWRFbGVzID0gci5kcmFnRGF0YS50b3VjaERyYWdFbGVzO1xuXG4gICAgICAgIGlmIChkcmFnZ2VkRWxlcykge1xuICAgICAgICAgIHIucmVkcmF3SGludCgnZHJhZycsIHRydWUpO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkcmFnZ2VkRWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGRlX3AgPSBkcmFnZ2VkRWxlc1tpXS5fcHJpdmF0ZTtcbiAgICAgICAgICAgIGRlX3AuZ3JhYmJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgZGVfcC5yc2NyYXRjaC5pbkRyYWdMYXllciA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfc3RhcnQgPSByLnRvdWNoRGF0YS5zdGFydDsgLy8gKHgyLCB5MikgZm9yIGZpbmdlcnMgMSBhbmQgMlxuXG4gICAgICAgIHZhciBmMXgyID0gZS50b3VjaGVzWzBdLmNsaWVudFggLSBvZmZzZXRMZWZ0LFxuICAgICAgICAgICAgZjF5MiA9IGUudG91Y2hlc1swXS5jbGllbnRZIC0gb2Zmc2V0VG9wO1xuICAgICAgICB2YXIgZjJ4MiA9IGUudG91Y2hlc1sxXS5jbGllbnRYIC0gb2Zmc2V0TGVmdCxcbiAgICAgICAgICAgIGYyeTIgPSBlLnRvdWNoZXNbMV0uY2xpZW50WSAtIG9mZnNldFRvcDtcbiAgICAgICAgdmFyIGRpc3RhbmNlMiA9IGRpc3RhbmNlKGYxeDIsIGYxeTIsIGYyeDIsIGYyeTIpOyAvLyB2YXIgZGlzdGFuY2UyU3EgPSBkaXN0YW5jZVNxKCBmMXgyLCBmMXkyLCBmMngyLCBmMnkyICk7XG4gICAgICAgIC8vIHZhciBmYWN0b3IgPSBNYXRoLnNxcnQoIGRpc3RhbmNlMlNxICkgLyBNYXRoLnNxcnQoIGRpc3RhbmNlMVNxICk7XG5cbiAgICAgICAgdmFyIGZhY3RvciA9IGRpc3RhbmNlMiAvIGRpc3RhbmNlMTtcblxuICAgICAgICBpZiAodHdvRmluZ2Vyc1N0YXJ0SW5zaWRlKSB7XG4gICAgICAgICAgLy8gZGVsdGEgZmluZ2VyMVxuICAgICAgICAgIHZhciBkZjF4ID0gZjF4MiAtIGYxeDE7XG4gICAgICAgICAgdmFyIGRmMXkgPSBmMXkyIC0gZjF5MTsgLy8gZGVsdGEgZmluZ2VyIDJcblxuICAgICAgICAgIHZhciBkZjJ4ID0gZjJ4MiAtIGYyeDE7XG4gICAgICAgICAgdmFyIGRmMnkgPSBmMnkyIC0gZjJ5MTsgLy8gdHJhbnNsYXRpb24gaXMgdGhlIG5vcm1hbGlzZWQgdmVjdG9yIG9mIHRoZSB0d28gZmluZ2VycyBtb3ZlbWVudFxuICAgICAgICAgIC8vIGkuZS4gc28gcGluY2hpbmcgY2FuY2VscyBvdXQgYW5kIG1vdmluZyB0b2dldGhlciBwYW5zXG5cbiAgICAgICAgICB2YXIgdHggPSAoZGYxeCArIGRmMngpIC8gMjtcbiAgICAgICAgICB2YXIgdHkgPSAoZGYxeSArIGRmMnkpIC8gMjsgLy8gbm93IGNhbGN1bGF0ZSB0aGUgem9vbVxuXG4gICAgICAgICAgdmFyIHpvb20xID0gY3kuem9vbSgpO1xuICAgICAgICAgIHZhciB6b29tMiA9IHpvb20xICogZmFjdG9yO1xuICAgICAgICAgIHZhciBwYW4xID0gY3kucGFuKCk7IC8vIHRoZSBtb2RlbCBjZW50ZXIgcG9pbnQgY29udmVydGVkIHRvIHRoZSBjdXJyZW50IHJlbmRlcmVkIHBvc1xuXG4gICAgICAgICAgdmFyIGN0cnggPSBtb2RlbENlbnRlcjFbMF0gKiB6b29tMSArIHBhbjEueDtcbiAgICAgICAgICB2YXIgY3RyeSA9IG1vZGVsQ2VudGVyMVsxXSAqIHpvb20xICsgcGFuMS55O1xuICAgICAgICAgIHZhciBwYW4yID0ge1xuICAgICAgICAgICAgeDogLXpvb20yIC8gem9vbTEgKiAoY3RyeCAtIHBhbjEueCAtIHR4KSArIGN0cngsXG4gICAgICAgICAgICB5OiAtem9vbTIgLyB6b29tMSAqIChjdHJ5IC0gcGFuMS55IC0gdHkpICsgY3RyeVxuICAgICAgICAgIH07IC8vIHJlbW92ZSBkcmFnZ2VkIGVsZXNcblxuICAgICAgICAgIGlmIChfc3RhcnQgJiYgX3N0YXJ0LmFjdGl2ZSgpKSB7XG4gICAgICAgICAgICB2YXIgZHJhZ2dlZEVsZXMgPSByLmRyYWdEYXRhLnRvdWNoRHJhZ0VsZXM7XG4gICAgICAgICAgICBmcmVlRHJhZ2dlZEVsZW1lbnRzKGRyYWdnZWRFbGVzKTtcbiAgICAgICAgICAgIHIucmVkcmF3SGludCgnZHJhZycsIHRydWUpO1xuICAgICAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG5cbiAgICAgICAgICAgIF9zdGFydC51bmFjdGl2YXRlKCkuZW1pdCgnZnJlZW9uJyk7XG5cbiAgICAgICAgICAgIGRyYWdnZWRFbGVzLmVtaXQoJ2ZyZWUnKTtcblxuICAgICAgICAgICAgaWYgKHIuZHJhZ0RhdGEuZGlkRHJhZykge1xuICAgICAgICAgICAgICBfc3RhcnQuZW1pdCgnZHJhZ2ZyZWVvbicpO1xuXG4gICAgICAgICAgICAgIGRyYWdnZWRFbGVzLmVtaXQoJ2RyYWdmcmVlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3kudmlld3BvcnQoe1xuICAgICAgICAgICAgem9vbTogem9vbTIsXG4gICAgICAgICAgICBwYW46IHBhbjIsXG4gICAgICAgICAgICBjYW5jZWxPbkZhaWxlZFpvb206IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjeS5lbWl0KCdwaW5jaHpvb20nKTtcbiAgICAgICAgICBkaXN0YW5jZTEgPSBkaXN0YW5jZTI7XG4gICAgICAgICAgZjF4MSA9IGYxeDI7XG4gICAgICAgICAgZjF5MSA9IGYxeTI7XG4gICAgICAgICAgZjJ4MSA9IGYyeDI7XG4gICAgICAgICAgZjJ5MSA9IGYyeTI7XG4gICAgICAgICAgci5waW5jaGluZyA9IHRydWU7XG4gICAgICAgIH0gLy8gUmUtcHJvamVjdFxuXG5cbiAgICAgICAgaWYgKGUudG91Y2hlc1swXSkge1xuICAgICAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzBdLmNsaWVudFgsIGUudG91Y2hlc1swXS5jbGllbnRZKTtcbiAgICAgICAgICBub3dbMF0gPSBwb3NbMF07XG4gICAgICAgICAgbm93WzFdID0gcG9zWzFdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGUudG91Y2hlc1sxXSkge1xuICAgICAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzFdLmNsaWVudFgsIGUudG91Y2hlc1sxXS5jbGllbnRZKTtcbiAgICAgICAgICBub3dbMl0gPSBwb3NbMF07XG4gICAgICAgICAgbm93WzNdID0gcG9zWzFdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGUudG91Y2hlc1syXSkge1xuICAgICAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzJdLmNsaWVudFgsIGUudG91Y2hlc1syXS5jbGllbnRZKTtcbiAgICAgICAgICBub3dbNF0gPSBwb3NbMF07XG4gICAgICAgICAgbm93WzVdID0gcG9zWzFdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGUudG91Y2hlc1swXSAmJiAhci50b3VjaERhdGEuZGlkU2VsZWN0IC8vIGRvbid0IGFsbG93IGJveCBzZWxlY3Rpb24gdG8gZGVncmFkZSB0byBzaW5nbGUgZmluZ2VyIGV2ZW50cyBsaWtlIHBhbm5pbmdcbiAgICAgICkge1xuICAgICAgICB2YXIgc3RhcnQgPSByLnRvdWNoRGF0YS5zdGFydDtcbiAgICAgICAgdmFyIGxhc3QgPSByLnRvdWNoRGF0YS5sYXN0O1xuICAgICAgICB2YXIgbmVhcjtcblxuICAgICAgICBpZiAoIXIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcyAmJiAhci5zd2lwZVBhbm5pbmcpIHtcbiAgICAgICAgICBuZWFyID0gci5maW5kTmVhcmVzdEVsZW1lbnQobm93WzBdLCBub3dbMV0sIHRydWUsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNhcHR1cmUgJiYgc3RhcnQgIT0gbnVsbCkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSAvLyBkcmFnZ2luZyBub2Rlc1xuXG5cbiAgICAgICAgaWYgKGNhcHR1cmUgJiYgc3RhcnQgIT0gbnVsbCAmJiByLm5vZGVJc0RyYWdnYWJsZShzdGFydCkpIHtcbiAgICAgICAgICBpZiAoaXNPdmVyVGhyZXNob2xkRHJhZykge1xuICAgICAgICAgICAgLy8gdGhlbiBkcmFnZ2luZyBjYW4gaGFwcGVuXG4gICAgICAgICAgICB2YXIgZHJhZ2dlZEVsZXMgPSByLmRyYWdEYXRhLnRvdWNoRHJhZ0VsZXM7XG4gICAgICAgICAgICB2YXIganVzdFN0YXJ0ZWREcmFnID0gIXIuZHJhZ0RhdGEuZGlkRHJhZztcblxuICAgICAgICAgICAgaWYgKGp1c3RTdGFydGVkRHJhZykge1xuICAgICAgICAgICAgICBhZGROb2Rlc1RvRHJhZyhkcmFnZ2VkRWxlcywge1xuICAgICAgICAgICAgICAgIGluRHJhZ0xheWVyOiB0cnVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByLmRyYWdEYXRhLmRpZERyYWcgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIHRvdGFsU2hpZnQgPSB7XG4gICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgIHk6IDBcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmIChudW1iZXIkMShkaXNwWzBdKSAmJiBudW1iZXIkMShkaXNwWzFdKSkge1xuICAgICAgICAgICAgICB0b3RhbFNoaWZ0LnggKz0gZGlzcFswXTtcbiAgICAgICAgICAgICAgdG90YWxTaGlmdC55ICs9IGRpc3BbMV07XG5cbiAgICAgICAgICAgICAgaWYgKGp1c3RTdGFydGVkRHJhZykge1xuICAgICAgICAgICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgICAgICAgICAgIHZhciBkcmFnRGVsdGEgPSByLnRvdWNoRGF0YS5kcmFnRGVsdGE7XG5cbiAgICAgICAgICAgICAgICBpZiAoZHJhZ0RlbHRhICYmIG51bWJlciQxKGRyYWdEZWx0YVswXSkgJiYgbnVtYmVyJDEoZHJhZ0RlbHRhWzFdKSkge1xuICAgICAgICAgICAgICAgICAgdG90YWxTaGlmdC54ICs9IGRyYWdEZWx0YVswXTtcbiAgICAgICAgICAgICAgICAgIHRvdGFsU2hpZnQueSArPSBkcmFnRGVsdGFbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcyA9IHRydWU7XG4gICAgICAgICAgICBkcmFnZ2VkRWxlcy5zaWxlbnRTaGlmdCh0b3RhbFNoaWZ0KS5lbWl0KCdwb3NpdGlvbiBkcmFnJyk7XG4gICAgICAgICAgICByLnJlZHJhd0hpbnQoJ2RyYWcnLCB0cnVlKTtcblxuICAgICAgICAgICAgaWYgKHIudG91Y2hEYXRhLnN0YXJ0UG9zaXRpb25bMF0gPT0gZWFybGllclswXSAmJiByLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uWzFdID09IGVhcmxpZXJbMV0pIHtcbiAgICAgICAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHIucmVkcmF3KCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSBrZWVwIHRyYWNrIG9mIGRyYWcgZGVsdGEgZm9yIGxhdGVyXG4gICAgICAgICAgICB2YXIgZHJhZ0RlbHRhID0gci50b3VjaERhdGEuZHJhZ0RlbHRhID0gci50b3VjaERhdGEuZHJhZ0RlbHRhIHx8IFtdO1xuXG4gICAgICAgICAgICBpZiAoZHJhZ0RlbHRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICBkcmFnRGVsdGEucHVzaChkaXNwWzBdKTtcbiAgICAgICAgICAgICAgZHJhZ0RlbHRhLnB1c2goZGlzcFsxXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkcmFnRGVsdGFbMF0gKz0gZGlzcFswXTtcbiAgICAgICAgICAgICAgZHJhZ0RlbHRhWzFdICs9IGRpc3BbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIHRvdWNobW92ZVxuXG5cbiAgICAgICAge1xuICAgICAgICAgIHRyaWdnZXJFdmVudHMoc3RhcnQgfHwgbmVhciwgWyd0b3VjaG1vdmUnLCAndGFwZHJhZycsICd2bW91c2Vtb3ZlJ10sIGUsIHtcbiAgICAgICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKCghc3RhcnQgfHwgIXN0YXJ0LmdyYWJiZWQoKSkgJiYgbmVhciAhPSBsYXN0KSB7XG4gICAgICAgICAgICBpZiAobGFzdCkge1xuICAgICAgICAgICAgICBsYXN0LmVtaXQoe1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3RhcGRyYWdvdXQnLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgICAgICAgICB5OiBub3dbMV1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobmVhcikge1xuICAgICAgICAgICAgICBuZWFyLmVtaXQoe1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3RhcGRyYWdvdmVyJyxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgICAgICAgICAgeTogbm93WzFdXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByLnRvdWNoRGF0YS5sYXN0ID0gbmVhcjtcbiAgICAgICAgfSAvLyBjaGVjayB0byBjYW5jZWwgdGFwaG9sZFxuXG4gICAgICAgIGlmIChjYXB0dXJlKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub3cubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChub3dbaV0gJiYgci50b3VjaERhdGEuc3RhcnRQb3NpdGlvbltpXSAmJiBpc092ZXJUaHJlc2hvbGREcmFnKSB7XG4gICAgICAgICAgICAgIHIudG91Y2hEYXRhLnNpbmdsZVRvdWNoTW92ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBwYW5uaW5nXG5cblxuICAgICAgICBpZiAoY2FwdHVyZSAmJiAoc3RhcnQgPT0gbnVsbCB8fCBzdGFydC5wYW5uYWJsZSgpKSAmJiBjeS5wYW5uaW5nRW5hYmxlZCgpICYmIGN5LnVzZXJQYW5uaW5nRW5hYmxlZCgpKSB7XG4gICAgICAgICAgdmFyIGFsbG93UGFzc3Rocm91Z2ggPSBhbGxvd1Bhbm5pbmdQYXNzdGhyb3VnaChzdGFydCwgci50b3VjaERhdGEuc3RhcnRzKTtcblxuICAgICAgICAgIGlmIChhbGxvd1Bhc3N0aHJvdWdoKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIGlmICghci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uKSB7XG4gICAgICAgICAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IGFycmF5MnBvaW50KHIudG91Y2hEYXRhLnN0YXJ0UG9zaXRpb24pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoci5zd2lwZVBhbm5pbmcpIHtcbiAgICAgICAgICAgICAgY3kucGFuQnkoe1xuICAgICAgICAgICAgICAgIHg6IGRpc3BbMF0gKiB6b29tLFxuICAgICAgICAgICAgICAgIHk6IGRpc3BbMV0gKiB6b29tXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBjeS5lbWl0KCdkcmFncGFuJyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzT3ZlclRocmVzaG9sZERyYWcpIHtcbiAgICAgICAgICAgICAgci5zd2lwZVBhbm5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgICBjeS5wYW5CeSh7XG4gICAgICAgICAgICAgICAgeDogZHggKiB6b29tLFxuICAgICAgICAgICAgICAgIHk6IGR5ICogem9vbVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY3kuZW1pdCgnZHJhZ3BhbicpO1xuXG4gICAgICAgICAgICAgIGlmIChzdGFydCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0LnVuYWN0aXZhdGUoKTtcbiAgICAgICAgICAgICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICAgICAgICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0ID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gUmUtcHJvamVjdFxuXG5cbiAgICAgICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1swXS5jbGllbnRYLCBlLnRvdWNoZXNbMF0uY2xpZW50WSk7XG4gICAgICAgICAgbm93WzBdID0gcG9zWzBdO1xuICAgICAgICAgIG5vd1sxXSA9IHBvc1sxXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5vdy5sZW5ndGg7IGorKykge1xuICAgICAgICBlYXJsaWVyW2pdID0gbm93W2pdO1xuICAgICAgfSAvLyB0aGUgYWN0aXZlIGJnIGluZGljYXRvciBzaG91bGQgYmUgcmVtb3ZlZCB3aGVuIG1ha2luZyBhIHN3aXBlIHRoYXQgaXMgbmVpdGhlciBmb3IgZHJhZ2dpbmcgbm9kZXMgb3IgcGFubmluZ1xuXG5cbiAgICAgIGlmIChjYXB0dXJlICYmIGUudG91Y2hlcy5sZW5ndGggPiAwICYmICFyLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgJiYgIXIuc3dpcGVQYW5uaW5nICYmIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgIH1cbiAgICB9LCBmYWxzZSk7XG4gICAgdmFyIHRvdWNoY2FuY2VsSGFuZGxlcjtcbiAgICByLnJlZ2lzdGVyQmluZGluZyh3aW5kb3csICd0b3VjaGNhbmNlbCcsIHRvdWNoY2FuY2VsSGFuZGxlciA9IGZ1bmN0aW9uIHRvdWNoY2FuY2VsSGFuZGxlcihlKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICB2YXIgc3RhcnQgPSByLnRvdWNoRGF0YS5zdGFydDtcbiAgICAgIHIudG91Y2hEYXRhLmNhcHR1cmUgPSBmYWxzZTtcblxuICAgICAgaWYgKHN0YXJ0KSB7XG4gICAgICAgIHN0YXJ0LnVuYWN0aXZhdGUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgdG91Y2hlbmRIYW5kbGVyLCBkaWREb3VibGVUb3VjaCwgdG91Y2hUaW1lb3V0LCBwcmV2VG91Y2hUaW1lU3RhbXA7XG4gICAgci5yZWdpc3RlckJpbmRpbmcod2luZG93LCAndG91Y2hlbmQnLCB0b3VjaGVuZEhhbmRsZXIgPSBmdW5jdGlvbiB0b3VjaGVuZEhhbmRsZXIoZSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgdmFyIHN0YXJ0ID0gci50b3VjaERhdGEuc3RhcnQ7XG4gICAgICB2YXIgY2FwdHVyZSA9IHIudG91Y2hEYXRhLmNhcHR1cmU7XG5cbiAgICAgIGlmIChjYXB0dXJlKSB7XG4gICAgICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgci50b3VjaERhdGEuY2FwdHVyZSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2VsZWN0ID0gci5zZWxlY3Rpb247XG4gICAgICByLnN3aXBlUGFubmluZyA9IGZhbHNlO1xuICAgICAgci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzID0gZmFsc2U7XG4gICAgICB2YXIgY3kgPSByLmN5O1xuICAgICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgICB2YXIgbm93ID0gci50b3VjaERhdGEubm93O1xuICAgICAgdmFyIGVhcmxpZXIgPSByLnRvdWNoRGF0YS5lYXJsaWVyO1xuXG4gICAgICBpZiAoZS50b3VjaGVzWzBdKSB7XG4gICAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzBdLmNsaWVudFgsIGUudG91Y2hlc1swXS5jbGllbnRZKTtcbiAgICAgICAgbm93WzBdID0gcG9zWzBdO1xuICAgICAgICBub3dbMV0gPSBwb3NbMV07XG4gICAgICB9XG5cbiAgICAgIGlmIChlLnRvdWNoZXNbMV0pIHtcbiAgICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMV0uY2xpZW50WCwgZS50b3VjaGVzWzFdLmNsaWVudFkpO1xuICAgICAgICBub3dbMl0gPSBwb3NbMF07XG4gICAgICAgIG5vd1szXSA9IHBvc1sxXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGUudG91Y2hlc1syXSkge1xuICAgICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1syXS5jbGllbnRYLCBlLnRvdWNoZXNbMl0uY2xpZW50WSk7XG4gICAgICAgIG5vd1s0XSA9IHBvc1swXTtcbiAgICAgICAgbm93WzVdID0gcG9zWzFdO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgc3RhcnQudW5hY3RpdmF0ZSgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3R4VGFwZW5kO1xuXG4gICAgICBpZiAoci50b3VjaERhdGEuY3h0KSB7XG4gICAgICAgIGN0eFRhcGVuZCA9IHtcbiAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgIHR5cGU6ICdjeHR0YXBlbmQnLFxuICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgICB5OiBub3dbMV1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHN0YXJ0KSB7XG4gICAgICAgICAgc3RhcnQuZW1pdChjdHhUYXBlbmQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN5LmVtaXQoY3R4VGFwZW5kKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghci50b3VjaERhdGEuY3h0RHJhZ2dlZCkge1xuICAgICAgICAgIHZhciBjdHhUYXAgPSB7XG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgICAgdHlwZTogJ2N4dHRhcCcsXG4gICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXJ0LmVtaXQoY3R4VGFwKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3kuZW1pdChjdHhUYXApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyLnRvdWNoRGF0YS5zdGFydCkge1xuICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0Ll9wcml2YXRlLmdyYWJiZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHIudG91Y2hEYXRhLmN4dCA9IGZhbHNlO1xuICAgICAgICByLnRvdWNoRGF0YS5zdGFydCA9IG51bGw7XG4gICAgICAgIHIucmVkcmF3KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gbm8gbW9yZSBib3ggc2VsZWN0aW9uIGlmIHdlIGRvbid0IGhhdmUgdGhyZWUgZmluZ2Vyc1xuXG5cbiAgICAgIGlmICghZS50b3VjaGVzWzJdICYmIGN5LmJveFNlbGVjdGlvbkVuYWJsZWQoKSAmJiByLnRvdWNoRGF0YS5zZWxlY3RpbmcpIHtcbiAgICAgICAgci50b3VjaERhdGEuc2VsZWN0aW5nID0gZmFsc2U7XG4gICAgICAgIHZhciBib3ggPSBjeS5jb2xsZWN0aW9uKHIuZ2V0QWxsSW5Cb3goc2VsZWN0WzBdLCBzZWxlY3RbMV0sIHNlbGVjdFsyXSwgc2VsZWN0WzNdKSk7XG4gICAgICAgIHNlbGVjdFswXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgc2VsZWN0WzFdID0gdW5kZWZpbmVkO1xuICAgICAgICBzZWxlY3RbMl0gPSB1bmRlZmluZWQ7XG4gICAgICAgIHNlbGVjdFszXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgc2VsZWN0WzRdID0gMDtcbiAgICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgICAgICAgY3kuZW1pdCh7XG4gICAgICAgICAgdHlwZTogJ2JveGVuZCcsXG4gICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgICAgeTogbm93WzFdXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgZWxlV291bGRCZVNlbGVjdGVkID0gZnVuY3Rpb24gZWxlV291bGRCZVNlbGVjdGVkKGVsZSkge1xuICAgICAgICAgIHJldHVybiBlbGUuc2VsZWN0YWJsZSgpICYmICFlbGUuc2VsZWN0ZWQoKTtcbiAgICAgICAgfTtcblxuICAgICAgICBib3guZW1pdCgnYm94Jykuc3RkRmlsdGVyKGVsZVdvdWxkQmVTZWxlY3RlZCkuc2VsZWN0KCkuZW1pdCgnYm94c2VsZWN0Jyk7XG5cbiAgICAgICAgaWYgKGJveC5ub25lbXB0eSgpKSB7XG4gICAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByLnJlZHJhdygpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhcnQgIT0gbnVsbCkge1xuICAgICAgICBzdGFydC51bmFjdGl2YXRlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlLnRvdWNoZXNbMl0pIHtcbiAgICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICAgICAgfSBlbHNlIGlmIChlLnRvdWNoZXNbMV0pIDsgZWxzZSBpZiAoZS50b3VjaGVzWzBdKSA7IGVsc2UgaWYgKCFlLnRvdWNoZXNbMF0pIHtcbiAgICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICAgICAgICB2YXIgZHJhZ2dlZEVsZXMgPSByLmRyYWdEYXRhLnRvdWNoRHJhZ0VsZXM7XG5cbiAgICAgICAgaWYgKHN0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgICB2YXIgc3RhcnRXYXNHcmFiYmVkID0gc3RhcnQuX3ByaXZhdGUuZ3JhYmJlZDtcbiAgICAgICAgICBmcmVlRHJhZ2dlZEVsZW1lbnRzKGRyYWdnZWRFbGVzKTtcbiAgICAgICAgICByLnJlZHJhd0hpbnQoJ2RyYWcnLCB0cnVlKTtcbiAgICAgICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcblxuICAgICAgICAgIGlmIChzdGFydFdhc0dyYWJiZWQpIHtcbiAgICAgICAgICAgIHN0YXJ0LmVtaXQoJ2ZyZWVvbicpO1xuICAgICAgICAgICAgZHJhZ2dlZEVsZXMuZW1pdCgnZnJlZScpO1xuXG4gICAgICAgICAgICBpZiAoci5kcmFnRGF0YS5kaWREcmFnKSB7XG4gICAgICAgICAgICAgIHN0YXJ0LmVtaXQoJ2RyYWdmcmVlb24nKTtcbiAgICAgICAgICAgICAgZHJhZ2dlZEVsZXMuZW1pdCgnZHJhZ2ZyZWUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0cmlnZ2VyRXZlbnRzKHN0YXJ0LCBbJ3RvdWNoZW5kJywgJ3RhcGVuZCcsICd2bW91c2V1cCcsICd0YXBkcmFnb3V0J10sIGUsIHtcbiAgICAgICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHN0YXJ0LnVuYWN0aXZhdGUoKTtcbiAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydCA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG5lYXIgPSByLmZpbmROZWFyZXN0RWxlbWVudChub3dbMF0sIG5vd1sxXSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgdHJpZ2dlckV2ZW50cyhuZWFyLCBbJ3RvdWNoZW5kJywgJ3RhcGVuZCcsICd2bW91c2V1cCcsICd0YXBkcmFnb3V0J10sIGUsIHtcbiAgICAgICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGR4ID0gci50b3VjaERhdGEuc3RhcnRQb3NpdGlvblswXSAtIG5vd1swXTtcbiAgICAgICAgdmFyIGR4MiA9IGR4ICogZHg7XG4gICAgICAgIHZhciBkeSA9IHIudG91Y2hEYXRhLnN0YXJ0UG9zaXRpb25bMV0gLSBub3dbMV07XG4gICAgICAgIHZhciBkeTIgPSBkeSAqIGR5O1xuICAgICAgICB2YXIgZGlzdDIgPSBkeDIgKyBkeTI7XG4gICAgICAgIHZhciByZGlzdDIgPSBkaXN0MiAqIHpvb20gKiB6b29tOyAvLyBUYXAgZXZlbnQsIHJvdWdobHkgc2FtZSBhcyBtb3VzZSBjbGljayBldmVudCBmb3IgdG91Y2hcblxuICAgICAgICBpZiAoIXIudG91Y2hEYXRhLnNpbmdsZVRvdWNoTW92ZWQpIHtcbiAgICAgICAgICBpZiAoIXN0YXJ0KSB7XG4gICAgICAgICAgICBjeS4kKCc6c2VsZWN0ZWQnKS51bnNlbGVjdChbJ3RhcHVuc2VsZWN0J10pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRyaWdnZXJFdmVudHMoc3RhcnQsIFsndGFwJywgJ3ZjbGljayddLCBlLCB7XG4gICAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgICB5OiBub3dbMV1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBkaWREb3VibGVUb3VjaCA9IGZhbHNlO1xuXG4gICAgICAgICAgaWYgKGUudGltZVN0YW1wIC0gcHJldlRvdWNoVGltZVN0YW1wIDw9IGN5Lm11bHRpQ2xpY2tEZWJvdW5jZVRpbWUoKSkge1xuICAgICAgICAgICAgdG91Y2hUaW1lb3V0ICYmIGNsZWFyVGltZW91dCh0b3VjaFRpbWVvdXQpO1xuICAgICAgICAgICAgZGlkRG91YmxlVG91Y2ggPSB0cnVlO1xuICAgICAgICAgICAgcHJldlRvdWNoVGltZVN0YW1wID0gbnVsbDtcbiAgICAgICAgICAgIHRyaWdnZXJFdmVudHMoc3RhcnQsIFsnZGJsdGFwJywgJ3ZkYmxjbGljayddLCBlLCB7XG4gICAgICAgICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgICAgICAgeTogbm93WzFdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG91Y2hUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGlmIChkaWREb3VibGVUb3VjaCkgcmV0dXJuO1xuICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnRzKHN0YXJ0LCBbJ29uZXRhcCcsICd2b25lY2xpY2snXSwgZSwge1xuICAgICAgICAgICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgICAgICAgICB5OiBub3dbMV1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCBjeS5tdWx0aUNsaWNrRGVib3VuY2VUaW1lKCkpO1xuICAgICAgICAgICAgcHJldlRvdWNoVGltZVN0YW1wID0gZS50aW1lU3RhbXA7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIFByZXBhcmUgdG8gc2VsZWN0IHRoZSBjdXJyZW50bHkgdG91Y2hlZCBub2RlLCBvbmx5IGlmIGl0IGhhc24ndCBiZWVuIGRyYWdnZWQgcGFzdCBhIGNlcnRhaW4gZGlzdGFuY2VcblxuXG4gICAgICAgIGlmIChzdGFydCAhPSBudWxsICYmICFyLmRyYWdEYXRhLmRpZERyYWcgLy8gZGlkbid0IGRyYWcgbm9kZXMgYXJvdW5kXG4gICAgICAgICYmIHN0YXJ0Ll9wcml2YXRlLnNlbGVjdGFibGUgJiYgcmRpc3QyIDwgci50b3VjaFRhcFRocmVzaG9sZDIgJiYgIXIucGluY2hpbmcgLy8gcGluY2ggdG8gem9vbSBzaG91bGQgbm90IGFmZmVjdCBzZWxlY3Rpb25cbiAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKGN5LnNlbGVjdGlvblR5cGUoKSA9PT0gJ3NpbmdsZScpIHtcbiAgICAgICAgICAgIGN5LiQoaXNTZWxlY3RlZCkudW5tZXJnZShzdGFydCkudW5zZWxlY3QoWyd0YXB1bnNlbGVjdCddKTtcbiAgICAgICAgICAgIHN0YXJ0LnNlbGVjdChbJ3RhcHNlbGVjdCddKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHN0YXJ0LnNlbGVjdGVkKCkpIHtcbiAgICAgICAgICAgICAgc3RhcnQudW5zZWxlY3QoWyd0YXB1bnNlbGVjdCddKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0YXJ0LnNlbGVjdChbJ3RhcHNlbGVjdCddKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHIudG91Y2hEYXRhLnNpbmdsZVRvdWNoTW92ZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5vdy5sZW5ndGg7IGorKykge1xuICAgICAgICBlYXJsaWVyW2pdID0gbm93W2pdO1xuICAgICAgfVxuXG4gICAgICByLmRyYWdEYXRhLmRpZERyYWcgPSBmYWxzZTsgLy8gcmVzZXQgZm9yIG5leHQgdG91Y2hzdGFydFxuXG4gICAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByLnRvdWNoRGF0YS5kcmFnRGVsdGEgPSBbXTtcbiAgICAgICAgci50b3VjaERhdGEuc3RhcnRQb3NpdGlvbiA9IG51bGw7XG4gICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0R1Bvc2l0aW9uID0gbnVsbDtcbiAgICAgICAgci50b3VjaERhdGEuZGlkU2VsZWN0ID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoIDwgMikge1xuICAgICAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIC8vIHRoZSBvbGQgc3RhcnQgZ2xvYmFsIHBvcyduIG1heSBub3QgYmUgdGhlIHNhbWUgZmluZ2VyIHRoYXQgcmVtYWluc1xuICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0R1Bvc2l0aW9uID0gW2UudG91Y2hlc1swXS5jbGllbnRYLCBlLnRvdWNoZXNbMF0uY2xpZW50WV07XG4gICAgICAgIH1cblxuICAgICAgICByLnBpbmNoaW5nID0gZmFsc2U7XG4gICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgICByLnJlZHJhdygpO1xuICAgICAgfSAvL3IucmVkcmF3KCk7XG5cbiAgICB9LCBmYWxzZSk7IC8vIGZhbGxiYWNrIGNvbXBhdGliaWxpdHkgbGF5ZXIgZm9yIG1zIHBvaW50ZXIgZXZlbnRzXG5cbiAgICBpZiAodHlwZW9mIFRvdWNoRXZlbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB2YXIgcG9pbnRlcnMgPSBbXTtcblxuICAgICAgdmFyIG1ha2VUb3VjaCA9IGZ1bmN0aW9uIG1ha2VUb3VjaChlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY2xpZW50WDogZS5jbGllbnRYLFxuICAgICAgICAgIGNsaWVudFk6IGUuY2xpZW50WSxcbiAgICAgICAgICBmb3JjZTogMSxcbiAgICAgICAgICBpZGVudGlmaWVyOiBlLnBvaW50ZXJJZCxcbiAgICAgICAgICBwYWdlWDogZS5wYWdlWCxcbiAgICAgICAgICBwYWdlWTogZS5wYWdlWSxcbiAgICAgICAgICByYWRpdXNYOiBlLndpZHRoIC8gMixcbiAgICAgICAgICByYWRpdXNZOiBlLmhlaWdodCAvIDIsXG4gICAgICAgICAgc2NyZWVuWDogZS5zY3JlZW5YLFxuICAgICAgICAgIHNjcmVlblk6IGUuc2NyZWVuWSxcbiAgICAgICAgICB0YXJnZXQ6IGUudGFyZ2V0XG4gICAgICAgIH07XG4gICAgICB9O1xuXG4gICAgICB2YXIgbWFrZVBvaW50ZXIgPSBmdW5jdGlvbiBtYWtlUG9pbnRlcihlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZXZlbnQ6IGUsXG4gICAgICAgICAgdG91Y2g6IG1ha2VUb3VjaChlKVxuICAgICAgICB9O1xuICAgICAgfTtcblxuICAgICAgdmFyIGFkZFBvaW50ZXIgPSBmdW5jdGlvbiBhZGRQb2ludGVyKGUpIHtcbiAgICAgICAgcG9pbnRlcnMucHVzaChtYWtlUG9pbnRlcihlKSk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgcmVtb3ZlUG9pbnRlciA9IGZ1bmN0aW9uIHJlbW92ZVBvaW50ZXIoZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHAgPSBwb2ludGVyc1tpXTtcblxuICAgICAgICAgIGlmIChwLmV2ZW50LnBvaW50ZXJJZCA9PT0gZS5wb2ludGVySWQpIHtcbiAgICAgICAgICAgIHBvaW50ZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciB1cGRhdGVQb2ludGVyID0gZnVuY3Rpb24gdXBkYXRlUG9pbnRlcihlKSB7XG4gICAgICAgIHZhciBwID0gcG9pbnRlcnMuZmlsdGVyKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgcmV0dXJuIHAuZXZlbnQucG9pbnRlcklkID09PSBlLnBvaW50ZXJJZDtcbiAgICAgICAgfSlbMF07XG4gICAgICAgIHAuZXZlbnQgPSBlO1xuICAgICAgICBwLnRvdWNoID0gbWFrZVRvdWNoKGUpO1xuICAgICAgfTtcblxuICAgICAgdmFyIGFkZFRvdWNoZXNUb0V2ZW50ID0gZnVuY3Rpb24gYWRkVG91Y2hlc1RvRXZlbnQoZSkge1xuICAgICAgICBlLnRvdWNoZXMgPSBwb2ludGVycy5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICByZXR1cm4gcC50b3VjaDtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgcG9pbnRlcklzTW91c2UgPSBmdW5jdGlvbiBwb2ludGVySXNNb3VzZShlKSB7XG4gICAgICAgIHJldHVybiBlLnBvaW50ZXJUeXBlID09PSAnbW91c2UnIHx8IGUucG9pbnRlclR5cGUgPT09IDQ7XG4gICAgICB9O1xuXG4gICAgICByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ3BvaW50ZXJkb3duJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHBvaW50ZXJJc01vdXNlKGUpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIG1vdXNlIGFscmVhZHkgaGFuZGxlZFxuXG5cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBhZGRQb2ludGVyKGUpO1xuICAgICAgICBhZGRUb3VjaGVzVG9FdmVudChlKTtcbiAgICAgICAgdG91Y2hzdGFydEhhbmRsZXIoZSk7XG4gICAgICB9KTtcbiAgICAgIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAncG9pbnRlcnVwJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHBvaW50ZXJJc01vdXNlKGUpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIG1vdXNlIGFscmVhZHkgaGFuZGxlZFxuXG5cbiAgICAgICAgcmVtb3ZlUG9pbnRlcihlKTtcbiAgICAgICAgYWRkVG91Y2hlc1RvRXZlbnQoZSk7XG4gICAgICAgIHRvdWNoZW5kSGFuZGxlcihlKTtcbiAgICAgIH0pO1xuICAgICAgci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICdwb2ludGVyY2FuY2VsJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHBvaW50ZXJJc01vdXNlKGUpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIG1vdXNlIGFscmVhZHkgaGFuZGxlZFxuXG5cbiAgICAgICAgcmVtb3ZlUG9pbnRlcihlKTtcbiAgICAgICAgYWRkVG91Y2hlc1RvRXZlbnQoZSk7XG4gICAgICAgIHRvdWNoY2FuY2VsSGFuZGxlcihlKTtcbiAgICAgIH0pO1xuICAgICAgci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICdwb2ludGVybW92ZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChwb2ludGVySXNNb3VzZShlKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBtb3VzZSBhbHJlYWR5IGhhbmRsZWRcblxuXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdXBkYXRlUG9pbnRlcihlKTtcbiAgICAgICAgYWRkVG91Y2hlc1RvRXZlbnQoZSk7XG4gICAgICAgIHRvdWNobW92ZUhhbmRsZXIoZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIEJScCQyID0ge307XG5cbiAgQlJwJDIuZ2VuZXJhdGVQb2x5Z29uID0gZnVuY3Rpb24gKG5hbWUsIHBvaW50cykge1xuICAgIHJldHVybiB0aGlzLm5vZGVTaGFwZXNbbmFtZV0gPSB7XG4gICAgICByZW5kZXJlcjogdGhpcyxcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBwb2ludHM6IHBvaW50cyxcbiAgICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLm5vZGVTaGFwZUltcGwoJ3BvbHlnb24nLCBjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCB0aGlzLnBvaW50cyk7XG4gICAgICB9LFxuICAgICAgaW50ZXJzZWN0TGluZTogZnVuY3Rpb24gaW50ZXJzZWN0TGluZShub2RlWCwgbm9kZVksIHdpZHRoLCBoZWlnaHQsIHgsIHksIHBhZGRpbmcpIHtcbiAgICAgICAgcmV0dXJuIHBvbHlnb25JbnRlcnNlY3RMaW5lKHgsIHksIHRoaXMucG9pbnRzLCBub2RlWCwgbm9kZVksIHdpZHRoIC8gMiwgaGVpZ2h0IC8gMiwgcGFkZGluZyk7XG4gICAgICB9LFxuICAgICAgY2hlY2tQb2ludDogZnVuY3Rpb24gY2hlY2tQb2ludCh4LCB5LCBwYWRkaW5nLCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZKSB7XG4gICAgICAgIHJldHVybiBwb2ludEluc2lkZVBvbHlnb24oeCwgeSwgdGhpcy5wb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIFswLCAtMV0sIHBhZGRpbmcpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgQlJwJDIuZ2VuZXJhdGVFbGxpcHNlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm5vZGVTaGFwZXNbJ2VsbGlwc2UnXSA9IHtcbiAgICAgIHJlbmRlcmVyOiB0aGlzLFxuICAgICAgbmFtZTogJ2VsbGlwc2UnLFxuICAgICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIubm9kZVNoYXBlSW1wbCh0aGlzLm5hbWUsIGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfSxcbiAgICAgIGludGVyc2VjdExpbmU6IGZ1bmN0aW9uIGludGVyc2VjdExpbmUobm9kZVgsIG5vZGVZLCB3aWR0aCwgaGVpZ2h0LCB4LCB5LCBwYWRkaW5nKSB7XG4gICAgICAgIHJldHVybiBpbnRlcnNlY3RMaW5lRWxsaXBzZSh4LCB5LCBub2RlWCwgbm9kZVksIHdpZHRoIC8gMiArIHBhZGRpbmcsIGhlaWdodCAvIDIgKyBwYWRkaW5nKTtcbiAgICAgIH0sXG4gICAgICBjaGVja1BvaW50OiBmdW5jdGlvbiBjaGVja1BvaW50KHgsIHksIHBhZGRpbmcsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclkpIHtcbiAgICAgICAgcmV0dXJuIGNoZWNrSW5FbGxpcHNlKHgsIHksIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclksIHBhZGRpbmcpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgQlJwJDIuZ2VuZXJhdGVSb3VuZFBvbHlnb24gPSBmdW5jdGlvbiAobmFtZSwgcG9pbnRzKSB7XG4gICAgLy8gUHJlLWNvbXB1dGUgY29udHJvbCBwb2ludHNcbiAgICAvLyBTaW5jZSB0aGVzZSBwb2ludHMgZGVwZW5kIG9uIHRoZSByYWRpdXMgbGVuZ3RoICh3aGljaCBpbiB0dXJucyBkZXBlbmQgb24gdGhlIHdpZHRoL2hlaWdodCBvZiB0aGUgbm9kZSkgd2Ugd2lsbCBvbmx5IHByZS1jb21wdXRlXG4gICAgLy8gdGhlIHVuaXQgdmVjdG9ycy5cbiAgICAvLyBGb3Igc2ltcGxpY2l0eSB0aGUgbGF5b3V0IHdpbGwgYmU6XG4gICAgLy8gWyBwMCwgVW5pdFZlY3RvclAwUDEsIHAxLCBVbmlWZWN0b3JQMVAyLCAuLi4sIHBuLCBVbml0VmVjdG9yUG5QMCBdXG4gICAgdmFyIGFsbFBvaW50cyA9IG5ldyBBcnJheShwb2ludHMubGVuZ3RoICogMik7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2VJbmRleCA9IGkgKiAyO1xuICAgICAgdmFyIGRlc3RJbmRleCA9IHZvaWQgMDtcblxuICAgICAgaWYgKGkgPCBwb2ludHMubGVuZ3RoIC8gMiAtIDEpIHtcbiAgICAgICAgZGVzdEluZGV4ID0gKGkgKyAxKSAqIDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZXN0SW5kZXggPSAwO1xuICAgICAgfVxuXG4gICAgICBhbGxQb2ludHNbaSAqIDRdID0gcG9pbnRzW3NvdXJjZUluZGV4XTtcbiAgICAgIGFsbFBvaW50c1tpICogNCArIDFdID0gcG9pbnRzW3NvdXJjZUluZGV4ICsgMV07XG4gICAgICB2YXIgeERlc3QgPSBwb2ludHNbZGVzdEluZGV4XSAtIHBvaW50c1tzb3VyY2VJbmRleF07XG4gICAgICB2YXIgeURlc3QgPSBwb2ludHNbZGVzdEluZGV4ICsgMV0gLSBwb2ludHNbc291cmNlSW5kZXggKyAxXTtcbiAgICAgIHZhciBub3JtID0gTWF0aC5zcXJ0KHhEZXN0ICogeERlc3QgKyB5RGVzdCAqIHlEZXN0KTtcbiAgICAgIGFsbFBvaW50c1tpICogNCArIDJdID0geERlc3QgLyBub3JtO1xuICAgICAgYWxsUG9pbnRzW2kgKiA0ICsgM10gPSB5RGVzdCAvIG5vcm07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubm9kZVNoYXBlc1tuYW1lXSA9IHtcbiAgICAgIHJlbmRlcmVyOiB0aGlzLFxuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHBvaW50czogYWxsUG9pbnRzLFxuICAgICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIubm9kZVNoYXBlSW1wbCgncm91bmQtcG9seWdvbicsIGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIHRoaXMucG9pbnRzKTtcbiAgICAgIH0sXG4gICAgICBpbnRlcnNlY3RMaW5lOiBmdW5jdGlvbiBpbnRlcnNlY3RMaW5lKG5vZGVYLCBub2RlWSwgd2lkdGgsIGhlaWdodCwgeCwgeSwgcGFkZGluZykge1xuICAgICAgICByZXR1cm4gcm91bmRQb2x5Z29uSW50ZXJzZWN0TGluZSh4LCB5LCB0aGlzLnBvaW50cywgbm9kZVgsIG5vZGVZLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH0sXG4gICAgICBjaGVja1BvaW50OiBmdW5jdGlvbiBjaGVja1BvaW50KHgsIHksIHBhZGRpbmcsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclkpIHtcbiAgICAgICAgcmV0dXJuIHBvaW50SW5zaWRlUm91bmRQb2x5Z29uKHgsIHksIHRoaXMucG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIEJScCQyLmdlbmVyYXRlUm91bmRSZWN0YW5nbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZVNoYXBlc1sncm91bmQtcmVjdGFuZ2xlJ10gPSB0aGlzLm5vZGVTaGFwZXNbJ3JvdW5kcmVjdGFuZ2xlJ10gPSB7XG4gICAgICByZW5kZXJlcjogdGhpcyxcbiAgICAgIG5hbWU6ICdyb3VuZC1yZWN0YW5nbGUnLFxuICAgICAgcG9pbnRzOiBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoNCwgMCksXG4gICAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5ub2RlU2hhcGVJbXBsKHRoaXMubmFtZSwgY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB9LFxuICAgICAgaW50ZXJzZWN0TGluZTogZnVuY3Rpb24gaW50ZXJzZWN0TGluZShub2RlWCwgbm9kZVksIHdpZHRoLCBoZWlnaHQsIHgsIHksIHBhZGRpbmcpIHtcbiAgICAgICAgcmV0dXJuIHJvdW5kUmVjdGFuZ2xlSW50ZXJzZWN0TGluZSh4LCB5LCBub2RlWCwgbm9kZVksIHdpZHRoLCBoZWlnaHQsIHBhZGRpbmcpO1xuICAgICAgfSxcbiAgICAgIGNoZWNrUG9pbnQ6IGZ1bmN0aW9uIGNoZWNrUG9pbnQoeCwgeSwgcGFkZGluZywgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSkge1xuICAgICAgICB2YXIgY29ybmVyUmFkaXVzID0gZ2V0Um91bmRSZWN0YW5nbGVSYWRpdXMod2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHZhciBkaWFtID0gY29ybmVyUmFkaXVzICogMjsgLy8gQ2hlY2sgaEJveFxuXG4gICAgICAgIGlmIChwb2ludEluc2lkZVBvbHlnb24oeCwgeSwgdGhpcy5wb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQgLSBkaWFtLCBbMCwgLTFdLCBwYWRkaW5nKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IC8vIENoZWNrIHZCb3hcblxuXG4gICAgICAgIGlmIChwb2ludEluc2lkZVBvbHlnb24oeCwgeSwgdGhpcy5wb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoIC0gZGlhbSwgaGVpZ2h0LCBbMCwgLTFdLCBwYWRkaW5nKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IC8vIENoZWNrIHRvcCBsZWZ0IHF1YXJ0ZXIgY2lyY2xlXG5cblxuICAgICAgICBpZiAoY2hlY2tJbkVsbGlwc2UoeCwgeSwgZGlhbSwgZGlhbSwgY2VudGVyWCAtIHdpZHRoIC8gMiArIGNvcm5lclJhZGl1cywgY2VudGVyWSAtIGhlaWdodCAvIDIgKyBjb3JuZXJSYWRpdXMsIHBhZGRpbmcpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gLy8gQ2hlY2sgdG9wIHJpZ2h0IHF1YXJ0ZXIgY2lyY2xlXG5cblxuICAgICAgICBpZiAoY2hlY2tJbkVsbGlwc2UoeCwgeSwgZGlhbSwgZGlhbSwgY2VudGVyWCArIHdpZHRoIC8gMiAtIGNvcm5lclJhZGl1cywgY2VudGVyWSAtIGhlaWdodCAvIDIgKyBjb3JuZXJSYWRpdXMsIHBhZGRpbmcpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gLy8gQ2hlY2sgYm90dG9tIHJpZ2h0IHF1YXJ0ZXIgY2lyY2xlXG5cblxuICAgICAgICBpZiAoY2hlY2tJbkVsbGlwc2UoeCwgeSwgZGlhbSwgZGlhbSwgY2VudGVyWCArIHdpZHRoIC8gMiAtIGNvcm5lclJhZGl1cywgY2VudGVyWSArIGhlaWdodCAvIDIgLSBjb3JuZXJSYWRpdXMsIHBhZGRpbmcpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gLy8gQ2hlY2sgYm90dG9tIGxlZnQgcXVhcnRlciBjaXJjbGVcblxuXG4gICAgICAgIGlmIChjaGVja0luRWxsaXBzZSh4LCB5LCBkaWFtLCBkaWFtLCBjZW50ZXJYIC0gd2lkdGggLyAyICsgY29ybmVyUmFkaXVzLCBjZW50ZXJZICsgaGVpZ2h0IC8gMiAtIGNvcm5lclJhZGl1cywgcGFkZGluZykpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIEJScCQyLmdlbmVyYXRlQ3V0UmVjdGFuZ2xlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm5vZGVTaGFwZXNbJ2N1dC1yZWN0YW5nbGUnXSA9IHRoaXMubm9kZVNoYXBlc1snY3V0cmVjdGFuZ2xlJ10gPSB7XG4gICAgICByZW5kZXJlcjogdGhpcyxcbiAgICAgIG5hbWU6ICdjdXQtcmVjdGFuZ2xlJyxcbiAgICAgIGNvcm5lckxlbmd0aDogZ2V0Q3V0UmVjdGFuZ2xlQ29ybmVyTGVuZ3RoKCksXG4gICAgICBwb2ludHM6IGdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSg0LCAwKSxcbiAgICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLm5vZGVTaGFwZUltcGwodGhpcy5uYW1lLCBjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH0sXG4gICAgICBnZW5lcmF0ZUN1dFRyaWFuZ2xlUHRzOiBmdW5jdGlvbiBnZW5lcmF0ZUN1dFRyaWFuZ2xlUHRzKHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclkpIHtcbiAgICAgICAgdmFyIGNsID0gdGhpcy5jb3JuZXJMZW5ndGg7XG4gICAgICAgIHZhciBoaCA9IGhlaWdodCAvIDI7XG4gICAgICAgIHZhciBodyA9IHdpZHRoIC8gMjtcbiAgICAgICAgdmFyIHhCZWdpbiA9IGNlbnRlclggLSBodztcbiAgICAgICAgdmFyIHhFbmQgPSBjZW50ZXJYICsgaHc7XG4gICAgICAgIHZhciB5QmVnaW4gPSBjZW50ZXJZIC0gaGg7XG4gICAgICAgIHZhciB5RW5kID0gY2VudGVyWSArIGhoOyAvLyBwb2ludHMgYXJlIGluIGNsb2Nrd2lzZSBvcmRlciwgaW5uZXIgKGltYWdpbmFyeSkgdHJpYW5nbGUgcHQgb24gWzQsIDVdXG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0b3BMZWZ0OiBbeEJlZ2luLCB5QmVnaW4gKyBjbCwgeEJlZ2luICsgY2wsIHlCZWdpbiwgeEJlZ2luICsgY2wsIHlCZWdpbiArIGNsXSxcbiAgICAgICAgICB0b3BSaWdodDogW3hFbmQgLSBjbCwgeUJlZ2luLCB4RW5kLCB5QmVnaW4gKyBjbCwgeEVuZCAtIGNsLCB5QmVnaW4gKyBjbF0sXG4gICAgICAgICAgYm90dG9tUmlnaHQ6IFt4RW5kLCB5RW5kIC0gY2wsIHhFbmQgLSBjbCwgeUVuZCwgeEVuZCAtIGNsLCB5RW5kIC0gY2xdLFxuICAgICAgICAgIGJvdHRvbUxlZnQ6IFt4QmVnaW4gKyBjbCwgeUVuZCwgeEJlZ2luLCB5RW5kIC0gY2wsIHhCZWdpbiArIGNsLCB5RW5kIC0gY2xdXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgaW50ZXJzZWN0TGluZTogZnVuY3Rpb24gaW50ZXJzZWN0TGluZShub2RlWCwgbm9kZVksIHdpZHRoLCBoZWlnaHQsIHgsIHksIHBhZGRpbmcpIHtcbiAgICAgICAgdmFyIGNQdHMgPSB0aGlzLmdlbmVyYXRlQ3V0VHJpYW5nbGVQdHMod2lkdGggKyAyICogcGFkZGluZywgaGVpZ2h0ICsgMiAqIHBhZGRpbmcsIG5vZGVYLCBub2RlWSk7XG4gICAgICAgIHZhciBwdHMgPSBbXS5jb25jYXQuYXBwbHkoW10sIFtjUHRzLnRvcExlZnQuc3BsaWNlKDAsIDQpLCBjUHRzLnRvcFJpZ2h0LnNwbGljZSgwLCA0KSwgY1B0cy5ib3R0b21SaWdodC5zcGxpY2UoMCwgNCksIGNQdHMuYm90dG9tTGVmdC5zcGxpY2UoMCwgNCldKTtcbiAgICAgICAgcmV0dXJuIHBvbHlnb25JbnRlcnNlY3RMaW5lKHgsIHksIHB0cywgbm9kZVgsIG5vZGVZKTtcbiAgICAgIH0sXG4gICAgICBjaGVja1BvaW50OiBmdW5jdGlvbiBjaGVja1BvaW50KHgsIHksIHBhZGRpbmcsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclkpIHtcbiAgICAgICAgLy8gQ2hlY2sgaEJveFxuICAgICAgICBpZiAocG9pbnRJbnNpZGVQb2x5Z29uKHgsIHksIHRoaXMucG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0IC0gMiAqIHRoaXMuY29ybmVyTGVuZ3RoLCBbMCwgLTFdLCBwYWRkaW5nKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IC8vIENoZWNrIHZCb3hcblxuXG4gICAgICAgIGlmIChwb2ludEluc2lkZVBvbHlnb24oeCwgeSwgdGhpcy5wb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoIC0gMiAqIHRoaXMuY29ybmVyTGVuZ3RoLCBoZWlnaHQsIFswLCAtMV0sIHBhZGRpbmcpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY3V0VHJpYW5nbGVQdHMgPSB0aGlzLmdlbmVyYXRlQ3V0VHJpYW5nbGVQdHMod2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSk7XG4gICAgICAgIHJldHVybiBwb2ludEluc2lkZVBvbHlnb25Qb2ludHMoeCwgeSwgY3V0VHJpYW5nbGVQdHMudG9wTGVmdCkgfHwgcG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKHgsIHksIGN1dFRyaWFuZ2xlUHRzLnRvcFJpZ2h0KSB8fCBwb2ludEluc2lkZVBvbHlnb25Qb2ludHMoeCwgeSwgY3V0VHJpYW5nbGVQdHMuYm90dG9tUmlnaHQpIHx8IHBvaW50SW5zaWRlUG9seWdvblBvaW50cyh4LCB5LCBjdXRUcmlhbmdsZVB0cy5ib3R0b21MZWZ0KTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIEJScCQyLmdlbmVyYXRlQmFycmVsID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm5vZGVTaGFwZXNbJ2JhcnJlbCddID0ge1xuICAgICAgcmVuZGVyZXI6IHRoaXMsXG4gICAgICBuYW1lOiAnYmFycmVsJyxcbiAgICAgIHBvaW50czogZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDQsIDApLFxuICAgICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIubm9kZVNoYXBlSW1wbCh0aGlzLm5hbWUsIGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfSxcbiAgICAgIGludGVyc2VjdExpbmU6IGZ1bmN0aW9uIGludGVyc2VjdExpbmUobm9kZVgsIG5vZGVZLCB3aWR0aCwgaGVpZ2h0LCB4LCB5LCBwYWRkaW5nKSB7XG4gICAgICAgIC8vIHVzZSB0d28gZml4ZWQgdCB2YWx1ZXMgZm9yIHRoZSBiZXppZXIgY3VydmUgYXBwcm94aW1hdGlvblxuICAgICAgICB2YXIgdDAgPSAwLjE1O1xuICAgICAgICB2YXIgdDEgPSAwLjU7XG4gICAgICAgIHZhciB0MiA9IDAuODU7XG4gICAgICAgIHZhciBiUHRzID0gdGhpcy5nZW5lcmF0ZUJhcnJlbEJlemllclB0cyh3aWR0aCArIDIgKiBwYWRkaW5nLCBoZWlnaHQgKyAyICogcGFkZGluZywgbm9kZVgsIG5vZGVZKTtcblxuICAgICAgICB2YXIgYXBwcm94aW1hdGVCYXJyZWxDdXJ2ZVB0cyA9IGZ1bmN0aW9uIGFwcHJveGltYXRlQmFycmVsQ3VydmVQdHMocHRzKSB7XG4gICAgICAgICAgLy8gYXBwcm94aW1hdGUgY3VydmUgcHRzIGJhc2VkIG9uIHRoZSB0d28gdCB2YWx1ZXNcbiAgICAgICAgICB2YXIgbTAgPSBxYmV6aWVyUHRBdCh7XG4gICAgICAgICAgICB4OiBwdHNbMF0sXG4gICAgICAgICAgICB5OiBwdHNbMV1cbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICB4OiBwdHNbMl0sXG4gICAgICAgICAgICB5OiBwdHNbM11cbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICB4OiBwdHNbNF0sXG4gICAgICAgICAgICB5OiBwdHNbNV1cbiAgICAgICAgICB9LCB0MCk7XG4gICAgICAgICAgdmFyIG0xID0gcWJlemllclB0QXQoe1xuICAgICAgICAgICAgeDogcHRzWzBdLFxuICAgICAgICAgICAgeTogcHRzWzFdXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgeDogcHRzWzJdLFxuICAgICAgICAgICAgeTogcHRzWzNdXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgeDogcHRzWzRdLFxuICAgICAgICAgICAgeTogcHRzWzVdXG4gICAgICAgICAgfSwgdDEpO1xuICAgICAgICAgIHZhciBtMiA9IHFiZXppZXJQdEF0KHtcbiAgICAgICAgICAgIHg6IHB0c1swXSxcbiAgICAgICAgICAgIHk6IHB0c1sxXVxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIHg6IHB0c1syXSxcbiAgICAgICAgICAgIHk6IHB0c1szXVxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIHg6IHB0c1s0XSxcbiAgICAgICAgICAgIHk6IHB0c1s1XVxuICAgICAgICAgIH0sIHQyKTtcbiAgICAgICAgICByZXR1cm4gW3B0c1swXSwgcHRzWzFdLCBtMC54LCBtMC55LCBtMS54LCBtMS55LCBtMi54LCBtMi55LCBwdHNbNF0sIHB0c1s1XV07XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHB0cyA9IFtdLmNvbmNhdChhcHByb3hpbWF0ZUJhcnJlbEN1cnZlUHRzKGJQdHMudG9wTGVmdCksIGFwcHJveGltYXRlQmFycmVsQ3VydmVQdHMoYlB0cy50b3BSaWdodCksIGFwcHJveGltYXRlQmFycmVsQ3VydmVQdHMoYlB0cy5ib3R0b21SaWdodCksIGFwcHJveGltYXRlQmFycmVsQ3VydmVQdHMoYlB0cy5ib3R0b21MZWZ0KSk7XG4gICAgICAgIHJldHVybiBwb2x5Z29uSW50ZXJzZWN0TGluZSh4LCB5LCBwdHMsIG5vZGVYLCBub2RlWSk7XG4gICAgICB9LFxuICAgICAgZ2VuZXJhdGVCYXJyZWxCZXppZXJQdHM6IGZ1bmN0aW9uIGdlbmVyYXRlQmFycmVsQmV6aWVyUHRzKHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclkpIHtcbiAgICAgICAgdmFyIGhoID0gaGVpZ2h0IC8gMjtcbiAgICAgICAgdmFyIGh3ID0gd2lkdGggLyAyO1xuICAgICAgICB2YXIgeEJlZ2luID0gY2VudGVyWCAtIGh3O1xuICAgICAgICB2YXIgeEVuZCA9IGNlbnRlclggKyBodztcbiAgICAgICAgdmFyIHlCZWdpbiA9IGNlbnRlclkgLSBoaDtcbiAgICAgICAgdmFyIHlFbmQgPSBjZW50ZXJZICsgaGg7XG4gICAgICAgIHZhciBjdXJ2ZUNvbnN0YW50cyA9IGdldEJhcnJlbEN1cnZlQ29uc3RhbnRzKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB2YXIgaE9mZnNldCA9IGN1cnZlQ29uc3RhbnRzLmhlaWdodE9mZnNldDtcbiAgICAgICAgdmFyIHdPZmZzZXQgPSBjdXJ2ZUNvbnN0YW50cy53aWR0aE9mZnNldDtcbiAgICAgICAgdmFyIGN0cmxQdFhPZmZzZXQgPSBjdXJ2ZUNvbnN0YW50cy5jdHJsUHRPZmZzZXRQY3QgKiB3aWR0aDsgLy8gcG9pbnRzIGFyZSBpbiBjbG9ja3dpc2Ugb3JkZXIsIGlubmVyIChpbWFnaW5hcnkpIGNvbnRyb2wgcHQgb24gWzQsIDVdXG5cbiAgICAgICAgdmFyIHB0cyA9IHtcbiAgICAgICAgICB0b3BMZWZ0OiBbeEJlZ2luLCB5QmVnaW4gKyBoT2Zmc2V0LCB4QmVnaW4gKyBjdHJsUHRYT2Zmc2V0LCB5QmVnaW4sIHhCZWdpbiArIHdPZmZzZXQsIHlCZWdpbl0sXG4gICAgICAgICAgdG9wUmlnaHQ6IFt4RW5kIC0gd09mZnNldCwgeUJlZ2luLCB4RW5kIC0gY3RybFB0WE9mZnNldCwgeUJlZ2luLCB4RW5kLCB5QmVnaW4gKyBoT2Zmc2V0XSxcbiAgICAgICAgICBib3R0b21SaWdodDogW3hFbmQsIHlFbmQgLSBoT2Zmc2V0LCB4RW5kIC0gY3RybFB0WE9mZnNldCwgeUVuZCwgeEVuZCAtIHdPZmZzZXQsIHlFbmRdLFxuICAgICAgICAgIGJvdHRvbUxlZnQ6IFt4QmVnaW4gKyB3T2Zmc2V0LCB5RW5kLCB4QmVnaW4gKyBjdHJsUHRYT2Zmc2V0LCB5RW5kLCB4QmVnaW4sIHlFbmQgLSBoT2Zmc2V0XVxuICAgICAgICB9O1xuICAgICAgICBwdHMudG9wTGVmdC5pc1RvcCA9IHRydWU7XG4gICAgICAgIHB0cy50b3BSaWdodC5pc1RvcCA9IHRydWU7XG4gICAgICAgIHB0cy5ib3R0b21MZWZ0LmlzQm90dG9tID0gdHJ1ZTtcbiAgICAgICAgcHRzLmJvdHRvbVJpZ2h0LmlzQm90dG9tID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHB0cztcbiAgICAgIH0sXG4gICAgICBjaGVja1BvaW50OiBmdW5jdGlvbiBjaGVja1BvaW50KHgsIHksIHBhZGRpbmcsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclkpIHtcbiAgICAgICAgdmFyIGN1cnZlQ29uc3RhbnRzID0gZ2V0QmFycmVsQ3VydmVDb25zdGFudHMod2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHZhciBoT2Zmc2V0ID0gY3VydmVDb25zdGFudHMuaGVpZ2h0T2Zmc2V0O1xuICAgICAgICB2YXIgd09mZnNldCA9IGN1cnZlQ29uc3RhbnRzLndpZHRoT2Zmc2V0OyAvLyBDaGVjayBoQm94XG5cbiAgICAgICAgaWYgKHBvaW50SW5zaWRlUG9seWdvbih4LCB5LCB0aGlzLnBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCAtIDIgKiBoT2Zmc2V0LCBbMCwgLTFdLCBwYWRkaW5nKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IC8vIENoZWNrIHZCb3hcblxuXG4gICAgICAgIGlmIChwb2ludEluc2lkZVBvbHlnb24oeCwgeSwgdGhpcy5wb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoIC0gMiAqIHdPZmZzZXQsIGhlaWdodCwgWzAsIC0xXSwgcGFkZGluZykpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBiYXJyZWxDdXJ2ZVB0cyA9IHRoaXMuZ2VuZXJhdGVCYXJyZWxCZXppZXJQdHMod2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSk7XG5cbiAgICAgICAgdmFyIGdldEN1cnZlVCA9IGZ1bmN0aW9uIGdldEN1cnZlVCh4LCB5LCBjdXJ2ZVB0cykge1xuICAgICAgICAgIHZhciB4MCA9IGN1cnZlUHRzWzRdO1xuICAgICAgICAgIHZhciB4MSA9IGN1cnZlUHRzWzJdO1xuICAgICAgICAgIHZhciB4MiA9IGN1cnZlUHRzWzBdO1xuICAgICAgICAgIHZhciB5MCA9IGN1cnZlUHRzWzVdOyAvLyB2YXIgeTEgPSBjdXJ2ZVB0c1sgMyBdO1xuXG4gICAgICAgICAgdmFyIHkyID0gY3VydmVQdHNbMV07XG4gICAgICAgICAgdmFyIHhNaW4gPSBNYXRoLm1pbih4MCwgeDIpO1xuICAgICAgICAgIHZhciB4TWF4ID0gTWF0aC5tYXgoeDAsIHgyKTtcbiAgICAgICAgICB2YXIgeU1pbiA9IE1hdGgubWluKHkwLCB5Mik7XG4gICAgICAgICAgdmFyIHlNYXggPSBNYXRoLm1heCh5MCwgeTIpO1xuXG4gICAgICAgICAgaWYgKHhNaW4gPD0geCAmJiB4IDw9IHhNYXggJiYgeU1pbiA8PSB5ICYmIHkgPD0geU1heCkge1xuICAgICAgICAgICAgdmFyIGNvZWZmID0gYmV6aWVyUHRzVG9RdWFkQ29lZmYoeDAsIHgxLCB4Mik7XG4gICAgICAgICAgICB2YXIgcm9vdHMgPSBzb2x2ZVF1YWRyYXRpYyhjb2VmZlswXSwgY29lZmZbMV0sIGNvZWZmWzJdLCB4KTtcbiAgICAgICAgICAgIHZhciB2YWxpZFJvb3RzID0gcm9vdHMuZmlsdGVyKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgICAgIHJldHVybiAwIDw9IHIgJiYgciA8PSAxO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICh2YWxpZFJvb3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbGlkUm9vdHNbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGN1cnZlUmVnaW9ucyA9IE9iamVjdC5rZXlzKGJhcnJlbEN1cnZlUHRzKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGN1cnZlUmVnaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBjb3JuZXIgPSBjdXJ2ZVJlZ2lvbnNbaV07XG4gICAgICAgICAgdmFyIGNvcm5lclB0cyA9IGJhcnJlbEN1cnZlUHRzW2Nvcm5lcl07XG4gICAgICAgICAgdmFyIHQgPSBnZXRDdXJ2ZVQoeCwgeSwgY29ybmVyUHRzKTtcblxuICAgICAgICAgIGlmICh0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciB5MCA9IGNvcm5lclB0c1s1XTtcbiAgICAgICAgICB2YXIgeTEgPSBjb3JuZXJQdHNbM107XG4gICAgICAgICAgdmFyIHkyID0gY29ybmVyUHRzWzFdO1xuICAgICAgICAgIHZhciBiZXpZID0gcWJlemllckF0KHkwLCB5MSwgeTIsIHQpO1xuXG4gICAgICAgICAgaWYgKGNvcm5lclB0cy5pc1RvcCAmJiBiZXpZIDw9IHkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjb3JuZXJQdHMuaXNCb3R0b20gJiYgeSA8PSBiZXpZKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICBCUnAkMi5nZW5lcmF0ZUJvdHRvbVJvdW5kcmVjdGFuZ2xlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm5vZGVTaGFwZXNbJ2JvdHRvbS1yb3VuZC1yZWN0YW5nbGUnXSA9IHRoaXMubm9kZVNoYXBlc1snYm90dG9tcm91bmRyZWN0YW5nbGUnXSA9IHtcbiAgICAgIHJlbmRlcmVyOiB0aGlzLFxuICAgICAgbmFtZTogJ2JvdHRvbS1yb3VuZC1yZWN0YW5nbGUnLFxuICAgICAgcG9pbnRzOiBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoNCwgMCksXG4gICAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5ub2RlU2hhcGVJbXBsKHRoaXMubmFtZSwgY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB9LFxuICAgICAgaW50ZXJzZWN0TGluZTogZnVuY3Rpb24gaW50ZXJzZWN0TGluZShub2RlWCwgbm9kZVksIHdpZHRoLCBoZWlnaHQsIHgsIHksIHBhZGRpbmcpIHtcbiAgICAgICAgdmFyIHRvcFN0YXJ0WCA9IG5vZGVYIC0gKHdpZHRoIC8gMiArIHBhZGRpbmcpO1xuICAgICAgICB2YXIgdG9wU3RhcnRZID0gbm9kZVkgLSAoaGVpZ2h0IC8gMiArIHBhZGRpbmcpO1xuICAgICAgICB2YXIgdG9wRW5kWSA9IHRvcFN0YXJ0WTtcbiAgICAgICAgdmFyIHRvcEVuZFggPSBub2RlWCArICh3aWR0aCAvIDIgKyBwYWRkaW5nKTtcbiAgICAgICAgdmFyIHRvcEludGVyc2VjdGlvbnMgPSBmaW5pdGVMaW5lc0ludGVyc2VjdCh4LCB5LCBub2RlWCwgbm9kZVksIHRvcFN0YXJ0WCwgdG9wU3RhcnRZLCB0b3BFbmRYLCB0b3BFbmRZLCBmYWxzZSk7XG5cbiAgICAgICAgaWYgKHRvcEludGVyc2VjdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHJldHVybiB0b3BJbnRlcnNlY3Rpb25zO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJvdW5kUmVjdGFuZ2xlSW50ZXJzZWN0TGluZSh4LCB5LCBub2RlWCwgbm9kZVksIHdpZHRoLCBoZWlnaHQsIHBhZGRpbmcpO1xuICAgICAgfSxcbiAgICAgIGNoZWNrUG9pbnQ6IGZ1bmN0aW9uIGNoZWNrUG9pbnQoeCwgeSwgcGFkZGluZywgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSkge1xuICAgICAgICB2YXIgY29ybmVyUmFkaXVzID0gZ2V0Um91bmRSZWN0YW5nbGVSYWRpdXMod2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHZhciBkaWFtID0gMiAqIGNvcm5lclJhZGl1czsgLy8gQ2hlY2sgaEJveFxuXG4gICAgICAgIGlmIChwb2ludEluc2lkZVBvbHlnb24oeCwgeSwgdGhpcy5wb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQgLSBkaWFtLCBbMCwgLTFdLCBwYWRkaW5nKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IC8vIENoZWNrIHZCb3hcblxuXG4gICAgICAgIGlmIChwb2ludEluc2lkZVBvbHlnb24oeCwgeSwgdGhpcy5wb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoIC0gZGlhbSwgaGVpZ2h0LCBbMCwgLTFdLCBwYWRkaW5nKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IC8vIGNoZWNrIG5vbi1yb3VuZGVkIHRvcCBzaWRlXG5cblxuICAgICAgICB2YXIgb3V0ZXJXaWR0aCA9IHdpZHRoIC8gMiArIDIgKiBwYWRkaW5nO1xuICAgICAgICB2YXIgb3V0ZXJIZWlnaHQgPSBoZWlnaHQgLyAyICsgMiAqIHBhZGRpbmc7XG4gICAgICAgIHZhciBwb2ludHMgPSBbY2VudGVyWCAtIG91dGVyV2lkdGgsIGNlbnRlclkgLSBvdXRlckhlaWdodCwgY2VudGVyWCAtIG91dGVyV2lkdGgsIGNlbnRlclksIGNlbnRlclggKyBvdXRlcldpZHRoLCBjZW50ZXJZLCBjZW50ZXJYICsgb3V0ZXJXaWR0aCwgY2VudGVyWSAtIG91dGVySGVpZ2h0XTtcblxuICAgICAgICBpZiAocG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKHgsIHksIHBvaW50cykpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSAvLyBDaGVjayBib3R0b20gcmlnaHQgcXVhcnRlciBjaXJjbGVcblxuXG4gICAgICAgIGlmIChjaGVja0luRWxsaXBzZSh4LCB5LCBkaWFtLCBkaWFtLCBjZW50ZXJYICsgd2lkdGggLyAyIC0gY29ybmVyUmFkaXVzLCBjZW50ZXJZICsgaGVpZ2h0IC8gMiAtIGNvcm5lclJhZGl1cywgcGFkZGluZykpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSAvLyBDaGVjayBib3R0b20gbGVmdCBxdWFydGVyIGNpcmNsZVxuXG5cbiAgICAgICAgaWYgKGNoZWNrSW5FbGxpcHNlKHgsIHksIGRpYW0sIGRpYW0sIGNlbnRlclggLSB3aWR0aCAvIDIgKyBjb3JuZXJSYWRpdXMsIGNlbnRlclkgKyBoZWlnaHQgLyAyIC0gY29ybmVyUmFkaXVzLCBwYWRkaW5nKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgQlJwJDIucmVnaXN0ZXJOb2RlU2hhcGVzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBub2RlU2hhcGVzID0gdGhpcy5ub2RlU2hhcGVzID0ge307XG4gICAgdmFyIHJlbmRlcmVyID0gdGhpcztcbiAgICB0aGlzLmdlbmVyYXRlRWxsaXBzZSgpO1xuICAgIHRoaXMuZ2VuZXJhdGVQb2x5Z29uKCd0cmlhbmdsZScsIGdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSgzLCAwKSk7XG4gICAgdGhpcy5nZW5lcmF0ZVJvdW5kUG9seWdvbigncm91bmQtdHJpYW5nbGUnLCBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoMywgMCkpO1xuICAgIHRoaXMuZ2VuZXJhdGVQb2x5Z29uKCdyZWN0YW5nbGUnLCBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoNCwgMCkpO1xuICAgIG5vZGVTaGFwZXNbJ3NxdWFyZSddID0gbm9kZVNoYXBlc1sncmVjdGFuZ2xlJ107XG4gICAgdGhpcy5nZW5lcmF0ZVJvdW5kUmVjdGFuZ2xlKCk7XG4gICAgdGhpcy5nZW5lcmF0ZUN1dFJlY3RhbmdsZSgpO1xuICAgIHRoaXMuZ2VuZXJhdGVCYXJyZWwoKTtcbiAgICB0aGlzLmdlbmVyYXRlQm90dG9tUm91bmRyZWN0YW5nbGUoKTtcbiAgICB7XG4gICAgICB2YXIgZGlhbW9uZFBvaW50cyA9IFswLCAxLCAxLCAwLCAwLCAtMSwgLTEsIDBdO1xuICAgICAgdGhpcy5nZW5lcmF0ZVBvbHlnb24oJ2RpYW1vbmQnLCBkaWFtb25kUG9pbnRzKTtcbiAgICAgIHRoaXMuZ2VuZXJhdGVSb3VuZFBvbHlnb24oJ3JvdW5kLWRpYW1vbmQnLCBkaWFtb25kUG9pbnRzKTtcbiAgICB9XG4gICAgdGhpcy5nZW5lcmF0ZVBvbHlnb24oJ3BlbnRhZ29uJywgZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDUsIDApKTtcbiAgICB0aGlzLmdlbmVyYXRlUm91bmRQb2x5Z29uKCdyb3VuZC1wZW50YWdvbicsIGdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSg1LCAwKSk7XG4gICAgdGhpcy5nZW5lcmF0ZVBvbHlnb24oJ2hleGFnb24nLCBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoNiwgMCkpO1xuICAgIHRoaXMuZ2VuZXJhdGVSb3VuZFBvbHlnb24oJ3JvdW5kLWhleGFnb24nLCBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoNiwgMCkpO1xuICAgIHRoaXMuZ2VuZXJhdGVQb2x5Z29uKCdoZXB0YWdvbicsIGdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSg3LCAwKSk7XG4gICAgdGhpcy5nZW5lcmF0ZVJvdW5kUG9seWdvbigncm91bmQtaGVwdGFnb24nLCBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoNywgMCkpO1xuICAgIHRoaXMuZ2VuZXJhdGVQb2x5Z29uKCdvY3RhZ29uJywgZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDgsIDApKTtcbiAgICB0aGlzLmdlbmVyYXRlUm91bmRQb2x5Z29uKCdyb3VuZC1vY3RhZ29uJywgZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDgsIDApKTtcbiAgICB2YXIgc3RhcjVQb2ludHMgPSBuZXcgQXJyYXkoMjApO1xuICAgIHtcbiAgICAgIHZhciBvdXRlclBvaW50cyA9IGdlbmVyYXRlVW5pdE5nb25Qb2ludHMoNSwgMCk7XG4gICAgICB2YXIgaW5uZXJQb2ludHMgPSBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzKDUsIE1hdGguUEkgLyA1KTsgLy8gT3V0ZXIgcmFkaXVzIGlzIDE7IGlubmVyIHJhZGl1cyBvZiBzdGFyIGlzIHNtYWxsZXJcblxuICAgICAgdmFyIGlubmVyUmFkaXVzID0gMC41ICogKDMgLSBNYXRoLnNxcnQoNSkpO1xuICAgICAgaW5uZXJSYWRpdXMgKj0gMS41NztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbm5lclBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgICAgaW5uZXJQb2ludHNbaSAqIDJdICo9IGlubmVyUmFkaXVzO1xuICAgICAgICBpbm5lclBvaW50c1tpICogMiArIDFdICo9IGlubmVyUmFkaXVzO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDIwIC8gNDsgaSsrKSB7XG4gICAgICAgIHN0YXI1UG9pbnRzW2kgKiA0XSA9IG91dGVyUG9pbnRzW2kgKiAyXTtcbiAgICAgICAgc3RhcjVQb2ludHNbaSAqIDQgKyAxXSA9IG91dGVyUG9pbnRzW2kgKiAyICsgMV07XG4gICAgICAgIHN0YXI1UG9pbnRzW2kgKiA0ICsgMl0gPSBpbm5lclBvaW50c1tpICogMl07XG4gICAgICAgIHN0YXI1UG9pbnRzW2kgKiA0ICsgM10gPSBpbm5lclBvaW50c1tpICogMiArIDFdO1xuICAgICAgfVxuICAgIH1cbiAgICBzdGFyNVBvaW50cyA9IGZpdFBvbHlnb25Ub1NxdWFyZShzdGFyNVBvaW50cyk7XG4gICAgdGhpcy5nZW5lcmF0ZVBvbHlnb24oJ3N0YXInLCBzdGFyNVBvaW50cyk7XG4gICAgdGhpcy5nZW5lcmF0ZVBvbHlnb24oJ3ZlZScsIFstMSwgLTEsIDAsIC0wLjMzMywgMSwgLTEsIDAsIDFdKTtcbiAgICB0aGlzLmdlbmVyYXRlUG9seWdvbigncmhvbWJvaWQnLCBbLTEsIC0xLCAwLjMzMywgLTEsIDEsIDEsIC0wLjMzMywgMV0pO1xuICAgIHRoaXMubm9kZVNoYXBlc1snY29uY2F2ZWhleGFnb24nXSA9IHRoaXMuZ2VuZXJhdGVQb2x5Z29uKCdjb25jYXZlLWhleGFnb24nLCBbLTEsIC0wLjk1LCAtMC43NSwgMCwgLTEsIDAuOTUsIDEsIDAuOTUsIDAuNzUsIDAsIDEsIC0wLjk1XSk7XG4gICAge1xuICAgICAgdmFyIHRhZ1BvaW50cyA9IFstMSwgLTEsIDAuMjUsIC0xLCAxLCAwLCAwLjI1LCAxLCAtMSwgMV07XG4gICAgICB0aGlzLmdlbmVyYXRlUG9seWdvbigndGFnJywgdGFnUG9pbnRzKTtcbiAgICAgIHRoaXMuZ2VuZXJhdGVSb3VuZFBvbHlnb24oJ3JvdW5kLXRhZycsIHRhZ1BvaW50cyk7XG4gICAgfVxuXG4gICAgbm9kZVNoYXBlcy5tYWtlUG9seWdvbiA9IGZ1bmN0aW9uIChwb2ludHMpIHtcbiAgICAgIC8vIHVzZSBjYWNoaW5nIG9uIHVzZXItc3BlY2lmaWVkIHBvbHlnb25zIHNvIHRoZXkgYXJlIGFzIGZhc3QgYXMgbmF0aXZlIHNoYXBlc1xuICAgICAgdmFyIGtleSA9IHBvaW50cy5qb2luKCckJyk7XG4gICAgICB2YXIgbmFtZSA9ICdwb2x5Z29uLScgKyBrZXk7XG4gICAgICB2YXIgc2hhcGU7XG5cbiAgICAgIGlmIChzaGFwZSA9IHRoaXNbbmFtZV0pIHtcbiAgICAgICAgLy8gZ290IGNhY2hlZCBzaGFwZVxuICAgICAgICByZXR1cm4gc2hhcGU7XG4gICAgICB9IC8vIGNyZWF0ZSBhbmQgY2FjaGUgbmV3IHNoYXBlXG5cblxuICAgICAgcmV0dXJuIHJlbmRlcmVyLmdlbmVyYXRlUG9seWdvbihuYW1lLCBwb2ludHMpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIEJScCQxID0ge307XG5cbiAgQlJwJDEudGltZVRvUmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnJlZHJhd1RvdGFsVGltZSAvIHRoaXMucmVkcmF3Q291bnQ7XG4gIH07XG5cbiAgQlJwJDEucmVkcmF3ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCBzdGF0aWNFbXB0eU9iamVjdCgpO1xuICAgIHZhciByID0gdGhpcztcblxuICAgIGlmIChyLmF2ZXJhZ2VSZWRyYXdUaW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHIuYXZlcmFnZVJlZHJhd1RpbWUgPSAwO1xuICAgIH1cblxuICAgIGlmIChyLmxhc3RSZWRyYXdUaW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHIubGFzdFJlZHJhd1RpbWUgPSAwO1xuICAgIH1cblxuICAgIGlmIChyLmxhc3REcmF3VGltZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByLmxhc3REcmF3VGltZSA9IDA7XG4gICAgfVxuXG4gICAgci5yZXF1ZXN0ZWRGcmFtZSA9IHRydWU7XG4gICAgci5yZW5kZXJPcHRpb25zID0gb3B0aW9ucztcbiAgfTtcblxuICBCUnAkMS5iZWZvcmVSZW5kZXIgPSBmdW5jdGlvbiAoZm4sIHByaW9yaXR5KSB7XG4gICAgLy8gdGhlIHJlbmRlcmVyIGNhbid0IGFkZCB0aWNrIGNhbGxiYWNrcyB3aGVuIGRlc3Ryb3llZFxuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcmlvcml0eSA9PSBudWxsKSB7XG4gICAgICBlcnJvcignUHJpb3JpdHkgaXMgbm90IG9wdGlvbmFsIGZvciBiZWZvcmVSZW5kZXInKTtcbiAgICB9XG5cbiAgICB2YXIgY2JzID0gdGhpcy5iZWZvcmVSZW5kZXJDYWxsYmFja3M7XG4gICAgY2JzLnB1c2goe1xuICAgICAgZm46IGZuLFxuICAgICAgcHJpb3JpdHk6IHByaW9yaXR5XG4gICAgfSk7IC8vIGhpZ2hlciBwcmlvcml0eSBjYWxsYmFja3MgZXhlY3V0ZWQgZmlyc3RcblxuICAgIGNicy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYi5wcmlvcml0eSAtIGEucHJpb3JpdHk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGJlZm9yZVJlbmRlckNhbGxiYWNrcyA9IGZ1bmN0aW9uIGJlZm9yZVJlbmRlckNhbGxiYWNrcyhyLCB3aWxsRHJhdywgc3RhcnRUaW1lKSB7XG4gICAgdmFyIGNicyA9IHIuYmVmb3JlUmVuZGVyQ2FsbGJhY2tzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNic1tpXS5mbih3aWxsRHJhdywgc3RhcnRUaW1lKTtcbiAgICB9XG4gIH07XG5cbiAgQlJwJDEuc3RhcnRSZW5kZXJMb29wID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByID0gdGhpcztcbiAgICB2YXIgY3kgPSByLmN5O1xuXG4gICAgaWYgKHIucmVuZGVyTG9vcFN0YXJ0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgci5yZW5kZXJMb29wU3RhcnRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHJlbmRlckZuID0gZnVuY3Rpb24gcmVuZGVyRm4ocmVxdWVzdFRpbWUpIHtcbiAgICAgIGlmIChyLmRlc3Ryb3llZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChjeS5iYXRjaGluZygpKSA7IGVsc2UgaWYgKHIucmVxdWVzdGVkRnJhbWUgJiYgIXIuc2tpcEZyYW1lKSB7XG4gICAgICAgIGJlZm9yZVJlbmRlckNhbGxiYWNrcyhyLCB0cnVlLCByZXF1ZXN0VGltZSk7XG4gICAgICAgIHZhciBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZU5vdygpO1xuICAgICAgICByLnJlbmRlcihyLnJlbmRlck9wdGlvbnMpO1xuICAgICAgICB2YXIgZW5kVGltZSA9IHIubGFzdERyYXdUaW1lID0gcGVyZm9ybWFuY2VOb3coKTtcblxuICAgICAgICBpZiAoci5hdmVyYWdlUmVkcmF3VGltZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgci5hdmVyYWdlUmVkcmF3VGltZSA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoci5yZWRyYXdDb3VudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgci5yZWRyYXdDb3VudCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICByLnJlZHJhd0NvdW50Kys7XG5cbiAgICAgICAgaWYgKHIucmVkcmF3VG90YWxUaW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByLnJlZHJhd1RvdGFsVGltZSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZHVyYXRpb24gPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuICAgICAgICByLnJlZHJhd1RvdGFsVGltZSArPSBkdXJhdGlvbjtcbiAgICAgICAgci5sYXN0UmVkcmF3VGltZSA9IGR1cmF0aW9uOyAvLyB1c2UgYSB3ZWlnaHRlZCBhdmVyYWdlIHdpdGggYSBiaWFzIGZyb20gdGhlIHByZXZpb3VzIGF2ZXJhZ2Ugc28gd2UgZG9uJ3Qgc3Bpa2Ugc28gZWFzaWx5XG5cbiAgICAgICAgci5hdmVyYWdlUmVkcmF3VGltZSA9IHIuYXZlcmFnZVJlZHJhd1RpbWUgLyAyICsgZHVyYXRpb24gLyAyO1xuICAgICAgICByLnJlcXVlc3RlZEZyYW1lID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiZWZvcmVSZW5kZXJDYWxsYmFja3MociwgZmFsc2UsIHJlcXVlc3RUaW1lKTtcbiAgICAgIH1cblxuICAgICAgci5za2lwRnJhbWUgPSBmYWxzZTtcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShyZW5kZXJGbik7XG4gICAgfTtcblxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShyZW5kZXJGbik7XG4gIH07XG5cbiAgdmFyIEJhc2VSZW5kZXJlciA9IGZ1bmN0aW9uIEJhc2VSZW5kZXJlcihvcHRpb25zKSB7XG4gICAgdGhpcy5pbml0KG9wdGlvbnMpO1xuICB9O1xuXG4gIHZhciBCUiA9IEJhc2VSZW5kZXJlcjtcbiAgdmFyIEJScCA9IEJSLnByb3RvdHlwZTtcbiAgQlJwLmNsaWVudEZ1bmN0aW9ucyA9IFsncmVkcmF3SGludCcsICdyZW5kZXInLCAncmVuZGVyVG8nLCAnbWF0Y2hDYW52YXNTaXplJywgJ25vZGVTaGFwZUltcGwnLCAnYXJyb3dTaGFwZUltcGwnXTtcblxuICBCUnAuaW5pdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIHIgPSB0aGlzO1xuICAgIHIub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgci5jeSA9IG9wdGlvbnMuY3k7XG4gICAgdmFyIGN0ciA9IHIuY29udGFpbmVyID0gb3B0aW9ucy5jeS5jb250YWluZXIoKTsgLy8gcHJlcGVuZCBhIHN0eWxlc2hlZXQgaW4gdGhlIGhlYWQgc3VjaCB0aGF0XG5cbiAgICBpZiAod2luZG93JDEpIHtcbiAgICAgIHZhciBkb2N1bWVudCA9IHdpbmRvdyQxLmRvY3VtZW50O1xuICAgICAgdmFyIGhlYWQgPSBkb2N1bWVudC5oZWFkO1xuICAgICAgdmFyIHN0eWxlc2hlZXRJZCA9ICdfX19fX19fX19fY3l0b3NjYXBlX3N0eWxlc2hlZXQnO1xuICAgICAgdmFyIGNsYXNzTmFtZSA9ICdfX19fX19fX19fY3l0b3NjYXBlX2NvbnRhaW5lcic7XG4gICAgICB2YXIgc3R5bGVzaGVldEFscmVhZHlFeGlzdHMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzdHlsZXNoZWV0SWQpICE9IG51bGw7XG5cbiAgICAgIGlmIChjdHIuY2xhc3NOYW1lLmluZGV4T2YoY2xhc3NOYW1lKSA8IDApIHtcbiAgICAgICAgY3RyLmNsYXNzTmFtZSA9IChjdHIuY2xhc3NOYW1lIHx8ICcnKSArICcgJyArIGNsYXNzTmFtZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFzdHlsZXNoZWV0QWxyZWFkeUV4aXN0cykge1xuICAgICAgICB2YXIgc3R5bGVzaGVldCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICAgIHN0eWxlc2hlZXQuaWQgPSBzdHlsZXNoZWV0SWQ7XG4gICAgICAgIHN0eWxlc2hlZXQuaW5uZXJIVE1MID0gJy4nICsgY2xhc3NOYW1lICsgJyB7IHBvc2l0aW9uOiByZWxhdGl2ZTsgfSc7XG4gICAgICAgIGhlYWQuaW5zZXJ0QmVmb3JlKHN0eWxlc2hlZXQsIGhlYWQuY2hpbGRyZW5bMF0pOyAvLyBmaXJzdCBzbyBsb3dlc3QgcHJpb3JpdHlcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbXB1dGVkU3R5bGUgPSB3aW5kb3ckMS5nZXRDb21wdXRlZFN0eWxlKGN0cik7XG4gICAgICB2YXIgcG9zaXRpb24gPSBjb21wdXRlZFN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ3Bvc2l0aW9uJyk7XG5cbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ3N0YXRpYycpIHtcbiAgICAgICAgd2FybignQSBDeXRvc2NhcGUgY29udGFpbmVyIGhhcyBzdHlsZSBwb3NpdGlvbjpzdGF0aWMgYW5kIHNvIGNhbiBub3QgdXNlIFVJIGV4dGVuc2lvbnMgcHJvcGVybHknKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByLnNlbGVjdGlvbiA9IFt1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIDBdOyAvLyBDb29yZGluYXRlcyBmb3Igc2VsZWN0aW9uIGJveCwgcGx1cyBlbmFibGVkIGZsYWdcblxuICAgIHIuYmV6aWVyUHJvalBjdHMgPSBbMC4wNSwgMC4yMjUsIDAuNCwgMC41LCAwLjYsIDAuNzc1LCAwLjk1XTsgLy8tLVBvaW50ZXItcmVsYXRlZCBkYXRhXG5cbiAgICByLmhvdmVyRGF0YSA9IHtcbiAgICAgIGRvd246IG51bGwsXG4gICAgICBsYXN0OiBudWxsLFxuICAgICAgZG93blRpbWU6IG51bGwsXG4gICAgICB0cmlnZ2VyTW9kZTogbnVsbCxcbiAgICAgIGRyYWdnaW5nOiBmYWxzZSxcbiAgICAgIGluaXRpYWxQYW46IFtudWxsLCBudWxsXSxcbiAgICAgIGNhcHR1cmU6IGZhbHNlXG4gICAgfTtcbiAgICByLmRyYWdEYXRhID0ge1xuICAgICAgcG9zc2libGVEcmFnRWxlbWVudHM6IFtdXG4gICAgfTtcbiAgICByLnRvdWNoRGF0YSA9IHtcbiAgICAgIHN0YXJ0OiBudWxsLFxuICAgICAgY2FwdHVyZTogZmFsc2UsXG4gICAgICAvLyBUaGVzZSAzIGZpZWxkcyByZWxhdGVkIHRvIHRhcCwgdGFwaG9sZCBldmVudHNcbiAgICAgIHN0YXJ0UG9zaXRpb246IFtudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsXSxcbiAgICAgIHNpbmdsZVRvdWNoU3RhcnRUaW1lOiBudWxsLFxuICAgICAgc2luZ2xlVG91Y2hNb3ZlZDogdHJ1ZSxcbiAgICAgIG5vdzogW251bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGxdLFxuICAgICAgZWFybGllcjogW251bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGxdXG4gICAgfTtcbiAgICByLnJlZHJhd3MgPSAwO1xuICAgIHIuc2hvd0ZwcyA9IG9wdGlvbnMuc2hvd0ZwcztcbiAgICByLmRlYnVnID0gb3B0aW9ucy5kZWJ1ZztcbiAgICByLmhpZGVFZGdlc09uVmlld3BvcnQgPSBvcHRpb25zLmhpZGVFZGdlc09uVmlld3BvcnQ7XG4gICAgci50ZXh0dXJlT25WaWV3cG9ydCA9IG9wdGlvbnMudGV4dHVyZU9uVmlld3BvcnQ7XG4gICAgci53aGVlbFNlbnNpdGl2aXR5ID0gb3B0aW9ucy53aGVlbFNlbnNpdGl2aXR5O1xuICAgIHIubW90aW9uQmx1ckVuYWJsZWQgPSBvcHRpb25zLm1vdGlvbkJsdXI7IC8vIG9uIGJ5IGRlZmF1bHRcblxuICAgIHIuZm9yY2VkUGl4ZWxSYXRpbyA9IG51bWJlciQxKG9wdGlvbnMucGl4ZWxSYXRpbykgPyBvcHRpb25zLnBpeGVsUmF0aW8gOiBudWxsO1xuICAgIHIubW90aW9uQmx1ciA9IG9wdGlvbnMubW90aW9uQmx1cjsgLy8gZm9yIGluaXRpYWwga2ljayBvZmZcblxuICAgIHIubW90aW9uQmx1ck9wYWNpdHkgPSBvcHRpb25zLm1vdGlvbkJsdXJPcGFjaXR5O1xuICAgIHIubW90aW9uQmx1clRyYW5zcGFyZW5jeSA9IDEgLSByLm1vdGlvbkJsdXJPcGFjaXR5O1xuICAgIHIubW90aW9uQmx1clB4UmF0aW8gPSAxO1xuICAgIHIubWJQeFJCbHVycnkgPSAxOyAvLzAuODtcblxuICAgIHIubWluTWJMb3dRdWFsRnJhbWVzID0gNDtcbiAgICByLmZ1bGxRdWFsaXR5TWIgPSBmYWxzZTtcbiAgICByLmNsZWFyZWRGb3JNb3Rpb25CbHVyID0gW107XG4gICAgci5kZXNrdG9wVGFwVGhyZXNob2xkID0gb3B0aW9ucy5kZXNrdG9wVGFwVGhyZXNob2xkO1xuICAgIHIuZGVza3RvcFRhcFRocmVzaG9sZDIgPSBvcHRpb25zLmRlc2t0b3BUYXBUaHJlc2hvbGQgKiBvcHRpb25zLmRlc2t0b3BUYXBUaHJlc2hvbGQ7XG4gICAgci50b3VjaFRhcFRocmVzaG9sZCA9IG9wdGlvbnMudG91Y2hUYXBUaHJlc2hvbGQ7XG4gICAgci50b3VjaFRhcFRocmVzaG9sZDIgPSBvcHRpb25zLnRvdWNoVGFwVGhyZXNob2xkICogb3B0aW9ucy50b3VjaFRhcFRocmVzaG9sZDtcbiAgICByLnRhcGhvbGREdXJhdGlvbiA9IDUwMDtcbiAgICByLmJpbmRpbmdzID0gW107XG4gICAgci5iZWZvcmVSZW5kZXJDYWxsYmFja3MgPSBbXTtcbiAgICByLmJlZm9yZVJlbmRlclByaW9yaXRpZXMgPSB7XG4gICAgICAvLyBoaWdoZXIgcHJpb3JpdHkgZXhlY3MgYmVmb3JlIGxvd2VyIG9uZVxuICAgICAgYW5pbWF0aW9uczogNDAwLFxuICAgICAgZWxlQ2FsY3M6IDMwMCxcbiAgICAgIGVsZVR4ckRlcTogMjAwLFxuICAgICAgbHlyVHhyRGVxOiAxNTAsXG4gICAgICBseXJUeHJTa2lwOiAxMDBcbiAgICB9O1xuICAgIHIucmVnaXN0ZXJOb2RlU2hhcGVzKCk7XG4gICAgci5yZWdpc3RlckFycm93U2hhcGVzKCk7XG4gICAgci5yZWdpc3RlckNhbGN1bGF0aW9uTGlzdGVuZXJzKCk7XG4gIH07XG5cbiAgQlJwLm5vdGlmeSA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGVsZXMpIHtcbiAgICB2YXIgciA9IHRoaXM7XG4gICAgdmFyIGN5ID0gci5jeTsgLy8gdGhlIHJlbmRlcmVyIGNhbid0IGJlIG5vdGlmaWVkIGFmdGVyIGl0J3MgZGVzdHJveWVkXG5cbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnROYW1lID09PSAnaW5pdCcpIHtcbiAgICAgIHIubG9hZCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChldmVudE5hbWUgPT09ICdkZXN0cm95Jykge1xuICAgICAgci5kZXN0cm95KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50TmFtZSA9PT0gJ2FkZCcgfHwgZXZlbnROYW1lID09PSAncmVtb3ZlJyB8fCBldmVudE5hbWUgPT09ICdtb3ZlJyAmJiBjeS5oYXNDb21wb3VuZE5vZGVzKCkgfHwgZXZlbnROYW1lID09PSAnbG9hZCcgfHwgZXZlbnROYW1lID09PSAnem9yZGVyJyB8fCBldmVudE5hbWUgPT09ICdtb3VudCcpIHtcbiAgICAgIHIuaW52YWxpZGF0ZUNhY2hlZFpTb3J0ZWRFbGVzKCk7XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50TmFtZSA9PT0gJ3ZpZXdwb3J0Jykge1xuICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnROYW1lID09PSAnbG9hZCcgfHwgZXZlbnROYW1lID09PSAncmVzaXplJyB8fCBldmVudE5hbWUgPT09ICdtb3VudCcpIHtcbiAgICAgIHIuaW52YWxpZGF0ZUNvbnRhaW5lckNsaWVudENvb3Jkc0NhY2hlKCk7XG4gICAgICByLm1hdGNoQ2FudmFzU2l6ZShyLmNvbnRhaW5lcik7XG4gICAgfVxuXG4gICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgci5yZWRyYXdIaW50KCdkcmFnJywgdHJ1ZSk7XG4gICAgdGhpcy5zdGFydFJlbmRlckxvb3AoKTtcbiAgICB0aGlzLnJlZHJhdygpO1xuICB9O1xuXG4gIEJScC5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByID0gdGhpcztcbiAgICByLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgci5jeS5zdG9wQW5pbWF0aW9uTG9vcCgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByLmJpbmRpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYmluZGluZyA9IHIuYmluZGluZ3NbaV07XG4gICAgICB2YXIgYiA9IGJpbmRpbmc7XG4gICAgICB2YXIgdGd0ID0gYi50YXJnZXQ7XG4gICAgICAodGd0Lm9mZiB8fCB0Z3QucmVtb3ZlRXZlbnRMaXN0ZW5lcikuYXBwbHkodGd0LCBiLmFyZ3MpO1xuICAgIH1cblxuICAgIHIuYmluZGluZ3MgPSBbXTtcbiAgICByLmJlZm9yZVJlbmRlckNhbGxiYWNrcyA9IFtdO1xuICAgIHIub25VcGRhdGVFbGVDYWxjc0ZucyA9IFtdO1xuXG4gICAgaWYgKHIucmVtb3ZlT2JzZXJ2ZXIpIHtcbiAgICAgIHIucmVtb3ZlT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIH1cblxuICAgIGlmIChyLnN0eWxlT2JzZXJ2ZXIpIHtcbiAgICAgIHIuc3R5bGVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgfVxuXG4gICAgaWYgKHIucmVzaXplT2JzZXJ2ZXIpIHtcbiAgICAgIHIucmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIH1cblxuICAgIGlmIChyLmxhYmVsQ2FsY0Rpdikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChyLmxhYmVsQ2FsY0Rpdik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgICAgIH0gY2F0Y2ggKGUpIHsvLyBpZTEwIGlzc3VlICMxMDE0XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEJScC5pc0hlYWRsZXNzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBbQlJwJGYsIEJScCQ1LCBCUnAkNCwgQlJwJDMsIEJScCQyLCBCUnAkMV0uZm9yRWFjaChmdW5jdGlvbiAocHJvcHMpIHtcbiAgICBleHRlbmQoQlJwLCBwcm9wcyk7XG4gIH0pO1xuXG4gIHZhciBmdWxsRnBzVGltZSA9IDEwMDAgLyA2MDsgLy8gYXNzdW1lIDYwIGZyYW1lcyBwZXIgc2Vjb25kXG5cbiAgdmFyIGRlZnMgPSB7XG4gICAgc2V0dXBEZXF1ZXVlaW5nOiBmdW5jdGlvbiBzZXR1cERlcXVldWVpbmcob3B0cykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNldHVwRGVxdWV1ZWluZ0ltcGwoKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHIgPSB0aGlzLnJlbmRlcmVyO1xuXG4gICAgICAgIGlmIChzZWxmLmRlcXVldWVpbmdTZXR1cCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxmLmRlcXVldWVpbmdTZXR1cCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcXVldWVSZWRyYXcgPSBkZWJvdW5jZV8xKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgICAgICAgICByLnJlZHJhd0hpbnQoJ2RyYWcnLCB0cnVlKTtcbiAgICAgICAgICByLnJlZHJhdygpO1xuICAgICAgICB9LCBvcHRzLmRlcVJlZHJhd1RocmVzaG9sZCk7XG5cbiAgICAgICAgdmFyIGRlcXVldWUgPSBmdW5jdGlvbiBkZXF1ZXVlKHdpbGxEcmF3LCBmcmFtZVN0YXJ0VGltZSkge1xuICAgICAgICAgIHZhciBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZU5vdygpO1xuICAgICAgICAgIHZhciBhdmdSZW5kZXJUaW1lID0gci5hdmVyYWdlUmVkcmF3VGltZTtcbiAgICAgICAgICB2YXIgcmVuZGVyVGltZSA9IHIubGFzdFJlZHJhd1RpbWU7XG4gICAgICAgICAgdmFyIGRlcWQgPSBbXTtcbiAgICAgICAgICB2YXIgZXh0ZW50ID0gci5jeS5leHRlbnQoKTtcbiAgICAgICAgICB2YXIgcGl4ZWxSYXRpbyA9IHIuZ2V0UGl4ZWxSYXRpbygpOyAvLyBpZiB3ZSBhcmVuJ3QgaW4gYSB0aWNrIHRoYXQgY2F1c2VzIGEgZHJhdywgdGhlbiB0aGUgcmVuZGVyZWQgc3R5bGVcbiAgICAgICAgICAvLyBxdWV1ZSB3b24ndCBhdXRvbWF0aWNhbGx5IGJlIGZsdXNoZWQgYmVmb3JlIGRlcXVldWVpbmcgc3RhcnRzXG5cbiAgICAgICAgICBpZiAoIXdpbGxEcmF3KSB7XG4gICAgICAgICAgICByLmZsdXNoUmVuZGVyZWRTdHlsZVF1ZXVlKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG4gICAgICAgICAgICB2YXIgbm93ID0gcGVyZm9ybWFuY2VOb3coKTtcbiAgICAgICAgICAgIHZhciBkdXJhdGlvbiA9IG5vdyAtIHN0YXJ0VGltZTtcbiAgICAgICAgICAgIHZhciBmcmFtZUR1cmF0aW9uID0gbm93IC0gZnJhbWVTdGFydFRpbWU7XG5cbiAgICAgICAgICAgIGlmIChyZW5kZXJUaW1lIDwgZnVsbEZwc1RpbWUpIHtcbiAgICAgICAgICAgICAgLy8gaWYgd2UncmUgcmVuZGVyaW5nIGZhc3RlciB0aGFuIHRoZSBpZGVhbCBmcHMsIHRoZW4gZG8gZGVxdWV1ZWluZ1xuICAgICAgICAgICAgICAvLyBkdXJpbmcgYWxsIG9mIHRoZSByZW1haW5pbmcgZnJhbWUgdGltZVxuICAgICAgICAgICAgICB2YXIgdGltZUF2YWlsYWJsZSA9IGZ1bGxGcHNUaW1lIC0gKHdpbGxEcmF3ID8gYXZnUmVuZGVyVGltZSA6IDApO1xuXG4gICAgICAgICAgICAgIGlmIChmcmFtZUR1cmF0aW9uID49IG9wdHMuZGVxRmFzdENvc3QgKiB0aW1lQXZhaWxhYmxlKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmICh3aWxsRHJhdykge1xuICAgICAgICAgICAgICAgIGlmIChkdXJhdGlvbiA+PSBvcHRzLmRlcUNvc3QgKiByZW5kZXJUaW1lIHx8IGR1cmF0aW9uID49IG9wdHMuZGVxQXZnQ29zdCAqIGF2Z1JlbmRlclRpbWUpIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChmcmFtZUR1cmF0aW9uID49IG9wdHMuZGVxTm9EcmF3Q29zdCAqIGZ1bGxGcHNUaW1lKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHRoaXNEZXFkID0gb3B0cy5kZXEoc2VsZiwgcGl4ZWxSYXRpbywgZXh0ZW50KTtcblxuICAgICAgICAgICAgaWYgKHRoaXNEZXFkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzRGVxZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGRlcWQucHVzaCh0aGlzRGVxZFtpXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gY2FsbGJhY2tzIG9uIGRlcXVldWVcblxuXG4gICAgICAgICAgaWYgKGRlcWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgb3B0cy5vbkRlcWQoc2VsZiwgZGVxZCk7XG5cbiAgICAgICAgICAgIGlmICghd2lsbERyYXcgJiYgb3B0cy5zaG91bGRSZWRyYXcoc2VsZiwgZGVxZCwgcGl4ZWxSYXRpbywgZXh0ZW50KSkge1xuICAgICAgICAgICAgICBxdWV1ZVJlZHJhdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcHJpb3JpdHkgPSBvcHRzLnByaW9yaXR5IHx8IG5vb3AkMTtcbiAgICAgICAgci5iZWZvcmVSZW5kZXIoZGVxdWV1ZSwgcHJpb3JpdHkoc2VsZikpO1xuICAgICAgfTtcbiAgICB9XG4gIH07XG5cbiAgLy8gVXNlcyBrZXlzIHNvIGVsZW1lbnRzIG1heSBzaGFyZSB0aGUgc2FtZSBjYWNoZS5cblxuICB2YXIgRWxlbWVudFRleHR1cmVDYWNoZUxvb2t1cCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRWxlbWVudFRleHR1cmVDYWNoZUxvb2t1cChnZXRLZXkpIHtcbiAgICAgIHZhciBkb2VzRWxlSW52YWxpZGF0ZUtleSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2lmeTtcblxuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVsZW1lbnRUZXh0dXJlQ2FjaGVMb29rdXApO1xuXG4gICAgICB0aGlzLmlkc0J5S2V5ID0gbmV3IE1hcCQyKCk7XG4gICAgICB0aGlzLmtleUZvcklkID0gbmV3IE1hcCQyKCk7XG4gICAgICB0aGlzLmNhY2hlc0J5THZsID0gbmV3IE1hcCQyKCk7XG4gICAgICB0aGlzLmx2bHMgPSBbXTtcbiAgICAgIHRoaXMuZ2V0S2V5ID0gZ2V0S2V5O1xuICAgICAgdGhpcy5kb2VzRWxlSW52YWxpZGF0ZUtleSA9IGRvZXNFbGVJbnZhbGlkYXRlS2V5O1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhFbGVtZW50VGV4dHVyZUNhY2hlTG9va3VwLCBbe1xuICAgICAga2V5OiBcImdldElkc0ZvclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldElkc0ZvcihrZXkpIHtcbiAgICAgICAgaWYgKGtleSA9PSBudWxsKSB7XG4gICAgICAgICAgZXJyb3IoXCJDYW4gbm90IGdldCBpZCBsaXN0IGZvciBudWxsIGtleVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpZHNCeUtleSA9IHRoaXMuaWRzQnlLZXk7XG4gICAgICAgIHZhciBpZHMgPSB0aGlzLmlkc0J5S2V5LmdldChrZXkpO1xuXG4gICAgICAgIGlmICghaWRzKSB7XG4gICAgICAgICAgaWRzID0gbmV3IFNldCQxKCk7XG4gICAgICAgICAgaWRzQnlLZXkuc2V0KGtleSwgaWRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpZHM7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImFkZElkRm9yS2V5XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkSWRGb3JLZXkoa2V5LCBpZCkge1xuICAgICAgICBpZiAoa2V5ICE9IG51bGwpIHtcbiAgICAgICAgICB0aGlzLmdldElkc0ZvcihrZXkpLmFkZChpZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZGVsZXRlSWRGb3JLZXlcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZWxldGVJZEZvcktleShrZXksIGlkKSB7XG4gICAgICAgIGlmIChrZXkgIT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuZ2V0SWRzRm9yKGtleSlbXCJkZWxldGVcIl0oaWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdldE51bWJlck9mSWRzRm9yS2V5XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TnVtYmVyT2ZJZHNGb3JLZXkoa2V5KSB7XG4gICAgICAgIGlmIChrZXkgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLmdldElkc0ZvcihrZXkpLnNpemU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwidXBkYXRlS2V5TWFwcGluZ0ZvclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUtleU1hcHBpbmdGb3IoZWxlKSB7XG4gICAgICAgIHZhciBpZCA9IGVsZS5pZCgpO1xuICAgICAgICB2YXIgcHJldktleSA9IHRoaXMua2V5Rm9ySWQuZ2V0KGlkKTtcbiAgICAgICAgdmFyIGN1cnJLZXkgPSB0aGlzLmdldEtleShlbGUpO1xuICAgICAgICB0aGlzLmRlbGV0ZUlkRm9yS2V5KHByZXZLZXksIGlkKTtcbiAgICAgICAgdGhpcy5hZGRJZEZvcktleShjdXJyS2V5LCBpZCk7XG4gICAgICAgIHRoaXMua2V5Rm9ySWQuc2V0KGlkLCBjdXJyS2V5KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZGVsZXRlS2V5TWFwcGluZ0ZvclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlbGV0ZUtleU1hcHBpbmdGb3IoZWxlKSB7XG4gICAgICAgIHZhciBpZCA9IGVsZS5pZCgpO1xuICAgICAgICB2YXIgcHJldktleSA9IHRoaXMua2V5Rm9ySWQuZ2V0KGlkKTtcbiAgICAgICAgdGhpcy5kZWxldGVJZEZvcktleShwcmV2S2V5LCBpZCk7XG4gICAgICAgIHRoaXMua2V5Rm9ySWRbXCJkZWxldGVcIl0oaWQpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJrZXlIYXNDaGFuZ2VkRm9yXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24ga2V5SGFzQ2hhbmdlZEZvcihlbGUpIHtcbiAgICAgICAgdmFyIGlkID0gZWxlLmlkKCk7XG4gICAgICAgIHZhciBwcmV2S2V5ID0gdGhpcy5rZXlGb3JJZC5nZXQoaWQpO1xuICAgICAgICB2YXIgbmV3S2V5ID0gdGhpcy5nZXRLZXkoZWxlKTtcbiAgICAgICAgcmV0dXJuIHByZXZLZXkgIT09IG5ld0tleTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiaXNJbnZhbGlkXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaXNJbnZhbGlkKGVsZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5rZXlIYXNDaGFuZ2VkRm9yKGVsZSkgfHwgdGhpcy5kb2VzRWxlSW52YWxpZGF0ZUtleShlbGUpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRDYWNoZXNBdFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldENhY2hlc0F0KGx2bCkge1xuICAgICAgICB2YXIgY2FjaGVzQnlMdmwgPSB0aGlzLmNhY2hlc0J5THZsLFxuICAgICAgICAgICAgbHZscyA9IHRoaXMubHZscztcbiAgICAgICAgdmFyIGNhY2hlcyA9IGNhY2hlc0J5THZsLmdldChsdmwpO1xuXG4gICAgICAgIGlmICghY2FjaGVzKSB7XG4gICAgICAgICAgY2FjaGVzID0gbmV3IE1hcCQyKCk7XG4gICAgICAgICAgY2FjaGVzQnlMdmwuc2V0KGx2bCwgY2FjaGVzKTtcbiAgICAgICAgICBsdmxzLnB1c2gobHZsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjYWNoZXM7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdldENhY2hlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2FjaGUoa2V5LCBsdmwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2FjaGVzQXQobHZsKS5nZXQoa2V5KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0KGVsZSwgbHZsKSB7XG4gICAgICAgIHZhciBrZXkgPSB0aGlzLmdldEtleShlbGUpO1xuICAgICAgICB2YXIgY2FjaGUgPSB0aGlzLmdldENhY2hlKGtleSwgbHZsKTsgLy8gZ2V0dGluZyBmb3IgYW4gZWxlbWVudCBtYXkgbmVlZCB0byBhZGQgdG8gdGhlIGlkIGxpc3QgYi9jIGVsZXMgY2FuIHNoYXJlIGtleXNcblxuICAgICAgICBpZiAoY2FjaGUgIT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMudXBkYXRlS2V5TWFwcGluZ0ZvcihlbGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNhY2hlO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRGb3JDYWNoZWRLZXlcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGb3JDYWNoZWRLZXkoZWxlLCBsdmwpIHtcbiAgICAgICAgdmFyIGtleSA9IHRoaXMua2V5Rm9ySWQuZ2V0KGVsZS5pZCgpKTsgLy8gbi5iLiB1c2UgY2FjaGVkIGtleSwgbm90IG5ld2x5IGNvbXB1dGVkIGtleVxuXG4gICAgICAgIHZhciBjYWNoZSA9IHRoaXMuZ2V0Q2FjaGUoa2V5LCBsdmwpO1xuICAgICAgICByZXR1cm4gY2FjaGU7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImhhc0NhY2hlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaGFzQ2FjaGUoa2V5LCBsdmwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2FjaGVzQXQobHZsKS5oYXMoa2V5KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiaGFzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaGFzKGVsZSwgbHZsKSB7XG4gICAgICAgIHZhciBrZXkgPSB0aGlzLmdldEtleShlbGUpO1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNDYWNoZShrZXksIGx2bCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInNldENhY2hlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Q2FjaGUoa2V5LCBsdmwsIGNhY2hlKSB7XG4gICAgICAgIGNhY2hlLmtleSA9IGtleTtcbiAgICAgICAgdGhpcy5nZXRDYWNoZXNBdChsdmwpLnNldChrZXksIGNhY2hlKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2V0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0KGVsZSwgbHZsLCBjYWNoZSkge1xuICAgICAgICB2YXIga2V5ID0gdGhpcy5nZXRLZXkoZWxlKTtcbiAgICAgICAgdGhpcy5zZXRDYWNoZShrZXksIGx2bCwgY2FjaGUpO1xuICAgICAgICB0aGlzLnVwZGF0ZUtleU1hcHBpbmdGb3IoZWxlKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZGVsZXRlQ2FjaGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZWxldGVDYWNoZShrZXksIGx2bCkge1xuICAgICAgICB0aGlzLmdldENhY2hlc0F0KGx2bClbXCJkZWxldGVcIl0oa2V5KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZGVsZXRlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2RlbGV0ZShlbGUsIGx2bCkge1xuICAgICAgICB2YXIga2V5ID0gdGhpcy5nZXRLZXkoZWxlKTtcbiAgICAgICAgdGhpcy5kZWxldGVDYWNoZShrZXksIGx2bCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImludmFsaWRhdGVLZXlcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpbnZhbGlkYXRlS2V5KGtleSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMubHZscy5mb3JFYWNoKGZ1bmN0aW9uIChsdmwpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuZGVsZXRlQ2FjaGUoa2V5LCBsdmwpO1xuICAgICAgICB9KTtcbiAgICAgIH0gLy8gcmV0dXJucyB0cnVlIGlmIG5vIG90aGVyIGVsZXMgcmVmZXJlbmNlIHRoZSBpbnZhbGlkYXRlZCBjYWNoZSAobi5iLiBvdGhlciBlbGVzIG1heSBuZWVkIHRoZSBjYWNoZSB3aXRoIHRoZSBzYW1lIGtleSlcblxuICAgIH0sIHtcbiAgICAgIGtleTogXCJpbnZhbGlkYXRlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaW52YWxpZGF0ZShlbGUpIHtcbiAgICAgICAgdmFyIGlkID0gZWxlLmlkKCk7XG4gICAgICAgIHZhciBrZXkgPSB0aGlzLmtleUZvcklkLmdldChpZCk7IC8vIG4uYi4gdXNlIHN0b3JlZCBrZXkgcmF0aGVyIHRoYW4gY3VycmVudCAocG90ZW50aWFsIGtleSlcblxuICAgICAgICB0aGlzLmRlbGV0ZUtleU1hcHBpbmdGb3IoZWxlKTtcbiAgICAgICAgdmFyIGVudGlyZUtleUludmFsaWRhdGVkID0gdGhpcy5kb2VzRWxlSW52YWxpZGF0ZUtleShlbGUpO1xuXG4gICAgICAgIGlmIChlbnRpcmVLZXlJbnZhbGlkYXRlZCkge1xuICAgICAgICAgIC8vIGNsZWFyIG1hcHBpbmcgZm9yIGN1cnJlbnQga2V5XG4gICAgICAgICAgdGhpcy5pbnZhbGlkYXRlS2V5KGtleSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZW50aXJlS2V5SW52YWxpZGF0ZWQgfHwgdGhpcy5nZXROdW1iZXJPZklkc0ZvcktleShrZXkpID09PSAwO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBFbGVtZW50VGV4dHVyZUNhY2hlTG9va3VwO1xuICB9KCk7XG5cbiAgdmFyIG1pblR4ckggPSAyNTsgLy8gdGhlIHNpemUgb2YgdGhlIHRleHR1cmUgY2FjaGUgZm9yIHNtYWxsIGhlaWdodCBlbGVzIChzcGVjaWFsIGNhc2UpXG5cbiAgdmFyIHR4clN0ZXBIID0gNTA7IC8vIHRoZSBtaW4gc2l6ZSBvZiB0aGUgcmVndWxhciBjYWNoZSwgYW5kIHRoZSBzaXplIGl0IGluY3JlYXNlcyB3aXRoIGVhY2ggc3RlcCB1cFxuXG4gIHZhciBtaW5MdmwkMSA9IC00OyAvLyB3aGVuIHNjYWxpbmcgc21hbGxlciB0aGFuIHRoYXQgd2UgZG9uJ3QgbmVlZCB0byByZS1yZW5kZXJcblxuICB2YXIgbWF4THZsJDEgPSAzOyAvLyB3aGVuIGxhcmdlciB0aGFuIHRoaXMgc2NhbGUganVzdCByZW5kZXIgZGlyZWN0bHkgKGNhY2hpbmcgaXMgbm90IGhlbHBmdWwpXG5cbiAgdmFyIG1heFpvb20kMSA9IDcuOTk7IC8vIGJleW9uZCB0aGlzIHpvb20gbGV2ZWwsIGxheWVyZWQgdGV4dHVyZXMgYXJlIG5vdCB1c2VkXG5cbiAgdmFyIGVsZVR4clNwYWNpbmcgPSA4OyAvLyBzcGFjaW5nIGJldHdlZW4gZWxlbWVudHMgb24gdGV4dHVyZXMgdG8gYXZvaWQgYmxpdHRpbmcgb3ZlcmxhcHNcblxuICB2YXIgZGVmVHhyV2lkdGggPSAxMDI0OyAvLyBkZWZhdWx0L21pbmltdW0gdGV4dHVyZSB3aWR0aFxuXG4gIHZhciBtYXhUeHJXID0gMTAyNDsgLy8gdGhlIG1heGltdW0gd2lkdGggb2YgYSB0ZXh0dXJlXG5cbiAgdmFyIG1heFR4ckggPSAxMDI0OyAvLyB0aGUgbWF4aW11bSBoZWlnaHQgb2YgYSB0ZXh0dXJlXG5cbiAgdmFyIG1pblV0aWxpdHkgPSAwLjI7IC8vIGlmIHVzYWdlIG9mIHRleHR1cmUgaXMgbGVzcyB0aGFuIHRoaXMsIGl0IGlzIHJldGlyZWRcblxuICB2YXIgbWF4RnVsbG5lc3MgPSAwLjg7IC8vIGZ1bGxuZXNzIG9mIHRleHR1cmUgYWZ0ZXIgd2hpY2ggcXVldWUgcmVtb3ZhbCBpcyBjaGVja2VkXG5cbiAgdmFyIG1heEZ1bGxuZXNzQ2hlY2tzID0gMTA7IC8vIGRlcXVldWVkIGFmdGVyIHRoaXMgbWFueSBjaGVja3NcblxuICB2YXIgZGVxQ29zdCQxID0gMC4xNTsgLy8gJSBvZiBhZGQnbCByZW5kZXJpbmcgY29zdCBhbGxvd2VkIGZvciBkZXF1ZXVpbmcgZWxlIGNhY2hlcyBlYWNoIGZyYW1lXG5cbiAgdmFyIGRlcUF2Z0Nvc3QkMSA9IDAuMTsgLy8gJSBvZiBhZGQnbCByZW5kZXJpbmcgY29zdCBjb21wYXJlZCB0byBhdmVyYWdlIG92ZXJhbGwgcmVkcmF3IHRpbWVcblxuICB2YXIgZGVxTm9EcmF3Q29zdCQxID0gMC45OyAvLyAlIG9mIGF2ZyBmcmFtZSB0aW1lIHRoYXQgY2FuIGJlIHVzZWQgZm9yIGRlcXVldWVpbmcgd2hlbiBub3QgZHJhd2luZ1xuXG4gIHZhciBkZXFGYXN0Q29zdCQxID0gMC45OyAvLyAlIG9mIGZyYW1lIHRpbWUgdG8gYmUgdXNlZCB3aGVuID42MGZwc1xuXG4gIHZhciBkZXFSZWRyYXdUaHJlc2hvbGQkMSA9IDEwMDsgLy8gdGltZSB0byBiYXRjaCByZWRyYXdzIHRvZ2V0aGVyIGZyb20gZGVxdWV1ZWluZyB0byBhbGxvdyBtb3JlIGRlcXVldWVpbmcgY2FsY3MgdG8gaGFwcGVuIGluIHRoZSBtZWFud2hpbGVcblxuICB2YXIgbWF4RGVxU2l6ZSQxID0gMTsgLy8gbnVtYmVyIG9mIGVsZXMgdG8gZGVxdWV1ZSBhbmQgcmVuZGVyIGF0IGhpZ2hlciB0ZXh0dXJlIGluIGVhY2ggYmF0Y2hcblxuICB2YXIgZ2V0VHhyUmVhc29ucyA9IHtcbiAgICBkZXF1ZXVlOiAnZGVxdWV1ZScsXG4gICAgZG93bnNjYWxlOiAnZG93bnNjYWxlJyxcbiAgICBoaWdoUXVhbGl0eTogJ2hpZ2hRdWFsaXR5J1xuICB9O1xuICB2YXIgaW5pdERlZmF1bHRzID0gZGVmYXVsdHMkZyh7XG4gICAgZ2V0S2V5OiBudWxsLFxuICAgIGRvZXNFbGVJbnZhbGlkYXRlS2V5OiBmYWxzaWZ5LFxuICAgIGRyYXdFbGVtZW50OiBudWxsLFxuICAgIGdldEJvdW5kaW5nQm94OiBudWxsLFxuICAgIGdldFJvdGF0aW9uUG9pbnQ6IG51bGwsXG4gICAgZ2V0Um90YXRpb25PZmZzZXQ6IG51bGwsXG4gICAgaXNWaXNpYmxlOiB0cnVlaWZ5LFxuICAgIGFsbG93RWRnZVR4ckNhY2hpbmc6IHRydWUsXG4gICAgYWxsb3dQYXJlbnRUeHJDYWNoaW5nOiB0cnVlXG4gIH0pO1xuXG4gIHZhciBFbGVtZW50VGV4dHVyZUNhY2hlID0gZnVuY3Rpb24gRWxlbWVudFRleHR1cmVDYWNoZShyZW5kZXJlciwgaW5pdE9wdGlvbnMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2VsZi5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgIHNlbGYub25EZXF1ZXVlcyA9IFtdO1xuICAgIHZhciBvcHRzID0gaW5pdERlZmF1bHRzKGluaXRPcHRpb25zKTtcbiAgICBleHRlbmQoc2VsZiwgb3B0cyk7XG4gICAgc2VsZi5sb29rdXAgPSBuZXcgRWxlbWVudFRleHR1cmVDYWNoZUxvb2t1cChvcHRzLmdldEtleSwgb3B0cy5kb2VzRWxlSW52YWxpZGF0ZUtleSk7XG4gICAgc2VsZi5zZXR1cERlcXVldWVpbmcoKTtcbiAgfTtcblxuICB2YXIgRVRDcCA9IEVsZW1lbnRUZXh0dXJlQ2FjaGUucHJvdG90eXBlO1xuICBFVENwLnJlYXNvbnMgPSBnZXRUeHJSZWFzb25zOyAvLyB0aGUgbGlzdCBvZiB0ZXh0dXJlcyBpbiB3aGljaCBuZXcgc3VidGV4dHVyZXMgZm9yIGVsZW1lbnRzIGNhbiBiZSBwbGFjZWRcblxuICBFVENwLmdldFRleHR1cmVRdWV1ZSA9IGZ1bmN0aW9uICh0eHJIKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNlbGYuZWxlSW1nQ2FjaGVzID0gc2VsZi5lbGVJbWdDYWNoZXMgfHwge307XG4gICAgcmV0dXJuIHNlbGYuZWxlSW1nQ2FjaGVzW3R4ckhdID0gc2VsZi5lbGVJbWdDYWNoZXNbdHhySF0gfHwgW107XG4gIH07IC8vIHRoZSBsaXN0IG9mIHVzdXNlZCB0ZXh0dXJlcyB3aGljaCBjYW4gYmUgcmVjeWNsZWQgKGluIHVzZSBpbiB0ZXh0dXJlIHF1ZXVlKVxuXG5cbiAgRVRDcC5nZXRSZXRpcmVkVGV4dHVyZVF1ZXVlID0gZnVuY3Rpb24gKHR4ckgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHJ0eHRyUXMgPSBzZWxmLmVsZUltZ0NhY2hlcy5yZXRpcmVkID0gc2VsZi5lbGVJbWdDYWNoZXMucmV0aXJlZCB8fCB7fTtcbiAgICB2YXIgcnR4dHJRID0gcnR4dHJRc1t0eHJIXSA9IHJ0eHRyUXNbdHhySF0gfHwgW107XG4gICAgcmV0dXJuIHJ0eHRyUTtcbiAgfTsgLy8gcXVldWUgb2YgZWxlbWVudCBkcmF3IHJlcXVlc3RzIGF0IGRpZmZlcmVudCBzY2FsZSBsZXZlbHNcblxuXG4gIEVUQ3AuZ2V0RWxlbWVudFF1ZXVlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgcSA9IHNlbGYuZWxlQ2FjaGVRdWV1ZSA9IHNlbGYuZWxlQ2FjaGVRdWV1ZSB8fCBuZXcgaGVhcChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGIucmVxcyAtIGEucmVxcztcbiAgICB9KTtcbiAgICByZXR1cm4gcTtcbiAgfTsgLy8gcXVldWUgb2YgZWxlbWVudCBkcmF3IHJlcXVlc3RzIGF0IGRpZmZlcmVudCBzY2FsZSBsZXZlbHMgKGVsZW1lbnQgaWQgbG9va3VwKVxuXG5cbiAgRVRDcC5nZXRFbGVtZW50S2V5VG9RdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGsycSA9IHNlbGYuZWxlS2V5VG9DYWNoZVF1ZXVlID0gc2VsZi5lbGVLZXlUb0NhY2hlUXVldWUgfHwge307XG4gICAgcmV0dXJuIGsycTtcbiAgfTtcblxuICBFVENwLmdldEVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlLCBiYiwgcHhSYXRpbywgbHZsLCByZWFzb24pIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHIgPSB0aGlzLnJlbmRlcmVyO1xuICAgIHZhciB6b29tID0gci5jeS56b29tKCk7XG4gICAgdmFyIGxvb2t1cCA9IHRoaXMubG9va3VwO1xuXG4gICAgaWYgKCFiYiB8fCBiYi53ID09PSAwIHx8IGJiLmggPT09IDAgfHwgaXNOYU4oYmIudykgfHwgaXNOYU4oYmIuaCkgfHwgIWVsZS52aXNpYmxlKCkgfHwgZWxlLnJlbW92ZWQoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKCFzZWxmLmFsbG93RWRnZVR4ckNhY2hpbmcgJiYgZWxlLmlzRWRnZSgpIHx8ICFzZWxmLmFsbG93UGFyZW50VHhyQ2FjaGluZyAmJiBlbGUuaXNQYXJlbnQoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGx2bCA9PSBudWxsKSB7XG4gICAgICBsdmwgPSBNYXRoLmNlaWwobG9nMih6b29tICogcHhSYXRpbykpO1xuICAgIH1cblxuICAgIGlmIChsdmwgPCBtaW5MdmwkMSkge1xuICAgICAgbHZsID0gbWluTHZsJDE7XG4gICAgfSBlbHNlIGlmICh6b29tID49IG1heFpvb20kMSB8fCBsdmwgPiBtYXhMdmwkMSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHNjYWxlID0gTWF0aC5wb3coMiwgbHZsKTtcbiAgICB2YXIgZWxlU2NhbGVkSCA9IGJiLmggKiBzY2FsZTtcbiAgICB2YXIgZWxlU2NhbGVkVyA9IGJiLncgKiBzY2FsZTtcbiAgICB2YXIgc2NhbGVkTGFiZWxTaG93biA9IHIuZWxlVGV4dEJpZ2dlclRoYW5NaW4oZWxlLCBzY2FsZSk7XG5cbiAgICBpZiAoIXRoaXMuaXNWaXNpYmxlKGVsZSwgc2NhbGVkTGFiZWxTaG93bikpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBlbGVDYWNoZSA9IGxvb2t1cC5nZXQoZWxlLCBsdmwpOyAvLyBpZiB0aGlzIGdldCB3YXMgb24gYW4gdW51c2VkL2ludmFsaWRhdGVkIGNhY2hlLCB0aGVuIHJlc3RvcmUgdGhlIHRleHR1cmUgdXNhZ2UgbWV0cmljXG5cbiAgICBpZiAoZWxlQ2FjaGUgJiYgZWxlQ2FjaGUuaW52YWxpZGF0ZWQpIHtcbiAgICAgIGVsZUNhY2hlLmludmFsaWRhdGVkID0gZmFsc2U7XG4gICAgICBlbGVDYWNoZS50ZXh0dXJlLmludmFsaWRhdGVkV2lkdGggLT0gZWxlQ2FjaGUud2lkdGg7XG4gICAgfVxuXG4gICAgaWYgKGVsZUNhY2hlKSB7XG4gICAgICByZXR1cm4gZWxlQ2FjaGU7XG4gICAgfVxuXG4gICAgdmFyIHR4ckg7IC8vIHdoaWNoIHRleHR1cmUgaGVpZ2h0IHRoaXMgZWxlIGJlbG9uZ3MgdG9cblxuICAgIGlmIChlbGVTY2FsZWRIIDw9IG1pblR4ckgpIHtcbiAgICAgIHR4ckggPSBtaW5UeHJIO1xuICAgIH0gZWxzZSBpZiAoZWxlU2NhbGVkSCA8PSB0eHJTdGVwSCkge1xuICAgICAgdHhySCA9IHR4clN0ZXBIO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eHJIID0gTWF0aC5jZWlsKGVsZVNjYWxlZEggLyB0eHJTdGVwSCkgKiB0eHJTdGVwSDtcbiAgICB9XG5cbiAgICBpZiAoZWxlU2NhbGVkSCA+IG1heFR4ckggfHwgZWxlU2NhbGVkVyA+IG1heFR4clcpIHtcbiAgICAgIHJldHVybiBudWxsOyAvLyBjYWNoaW5nIGxhcmdlIGVsZW1lbnRzIGlzIG5vdCBlZmZpY2llbnRcbiAgICB9XG5cbiAgICB2YXIgdHhyUSA9IHNlbGYuZ2V0VGV4dHVyZVF1ZXVlKHR4ckgpOyAvLyBmaXJzdCB0cnkgdGhlIHNlY29uZCBsYXN0IG9uZSBpbiBjYXNlIGl0IGhhcyBzcGFjZSBhdCB0aGUgZW5kXG5cbiAgICB2YXIgdHhyID0gdHhyUVt0eHJRLmxlbmd0aCAtIDJdO1xuXG4gICAgdmFyIGFkZE5ld1R4ciA9IGZ1bmN0aW9uIGFkZE5ld1R4cigpIHtcbiAgICAgIHJldHVybiBzZWxmLnJlY3ljbGVUZXh0dXJlKHR4ckgsIGVsZVNjYWxlZFcpIHx8IHNlbGYuYWRkVGV4dHVyZSh0eHJILCBlbGVTY2FsZWRXKTtcbiAgICB9OyAvLyB0cnkgdGhlIGxhc3Qgb25lIGlmIHRoZXJlIGlzIG5vIHNlY29uZCBsYXN0IG9uZVxuXG5cbiAgICBpZiAoIXR4cikge1xuICAgICAgdHhyID0gdHhyUVt0eHJRLmxlbmd0aCAtIDFdO1xuICAgIH0gLy8gaWYgdGhlIGxhc3Qgb25lIGRvZXNuJ3QgZXhpc3QsIHdlIG5lZWQgYSBmaXJzdCBvbmVcblxuXG4gICAgaWYgKCF0eHIpIHtcbiAgICAgIHR4ciA9IGFkZE5ld1R4cigpO1xuICAgIH0gLy8gaWYgdGhlcmUncyBubyByb29tIGluIHRoZSBjdXJyZW50IHRleHR1cmUsIHdlIG5lZWQgYSBuZXcgb25lXG5cblxuICAgIGlmICh0eHIud2lkdGggLSB0eHIudXNlZFdpZHRoIDwgZWxlU2NhbGVkVykge1xuICAgICAgdHhyID0gYWRkTmV3VHhyKCk7XG4gICAgfVxuXG4gICAgdmFyIHNjYWxhYmxlRnJvbSA9IGZ1bmN0aW9uIHNjYWxhYmxlRnJvbShvdGhlckNhY2hlKSB7XG4gICAgICByZXR1cm4gb3RoZXJDYWNoZSAmJiBvdGhlckNhY2hlLnNjYWxlZExhYmVsU2hvd24gPT09IHNjYWxlZExhYmVsU2hvd247XG4gICAgfTtcblxuICAgIHZhciBkZXFpbmcgPSByZWFzb24gJiYgcmVhc29uID09PSBnZXRUeHJSZWFzb25zLmRlcXVldWU7XG4gICAgdmFyIGhpZ2hRdWFsaXR5UmVxID0gcmVhc29uICYmIHJlYXNvbiA9PT0gZ2V0VHhyUmVhc29ucy5oaWdoUXVhbGl0eTtcbiAgICB2YXIgZG93bnNjYWxlUmVxID0gcmVhc29uICYmIHJlYXNvbiA9PT0gZ2V0VHhyUmVhc29ucy5kb3duc2NhbGU7XG4gICAgdmFyIGhpZ2hlckNhY2hlOyAvLyB0aGUgbmVhcmVzdCBjYWNoZSB3aXRoIGEgaGlnaGVyIGxldmVsXG5cbiAgICBmb3IgKHZhciBsID0gbHZsICsgMTsgbCA8PSBtYXhMdmwkMTsgbCsrKSB7XG4gICAgICB2YXIgYyA9IGxvb2t1cC5nZXQoZWxlLCBsKTtcblxuICAgICAgaWYgKGMpIHtcbiAgICAgICAgaGlnaGVyQ2FjaGUgPSBjO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgb25lVXBDYWNoZSA9IGhpZ2hlckNhY2hlICYmIGhpZ2hlckNhY2hlLmxldmVsID09PSBsdmwgKyAxID8gaGlnaGVyQ2FjaGUgOiBudWxsO1xuXG4gICAgdmFyIGRvd25zY2FsZSA9IGZ1bmN0aW9uIGRvd25zY2FsZSgpIHtcbiAgICAgIHR4ci5jb250ZXh0LmRyYXdJbWFnZShvbmVVcENhY2hlLnRleHR1cmUuY2FudmFzLCBvbmVVcENhY2hlLngsIDAsIG9uZVVwQ2FjaGUud2lkdGgsIG9uZVVwQ2FjaGUuaGVpZ2h0LCB0eHIudXNlZFdpZHRoLCAwLCBlbGVTY2FsZWRXLCBlbGVTY2FsZWRIKTtcbiAgICB9OyAvLyByZXNldCBlbGUgYXJlYSBpbiB0ZXh0dXJlXG5cblxuICAgIHR4ci5jb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICB0eHIuY29udGV4dC5jbGVhclJlY3QodHhyLnVzZWRXaWR0aCwgMCwgZWxlU2NhbGVkVywgdHhySCk7XG5cbiAgICBpZiAoc2NhbGFibGVGcm9tKG9uZVVwQ2FjaGUpKSB7XG4gICAgICAvLyB0aGVuIHdlIGNhbiByZWxhdGl2ZWx5IGNoZWFwbHkgcmVzY2FsZSB0aGUgZXhpc3RpbmcgaW1hZ2Ugdy9vIHJlcmVuZGVyaW5nXG4gICAgICBkb3duc2NhbGUoKTtcbiAgICB9IGVsc2UgaWYgKHNjYWxhYmxlRnJvbShoaWdoZXJDYWNoZSkpIHtcbiAgICAgIC8vIHRoZW4gdXNlIHRoZSBoaWdoZXIgY2FjaGUgZm9yIG5vdyBhbmQgcXVldWUgdGhlIG5leHQgbGV2ZWwgZG93blxuICAgICAgLy8gdG8gY2hlYXBseSBzY2FsZSB0b3dhcmRzIHRoZSBzbWFsbGVyIGxldmVsXG4gICAgICBpZiAoaGlnaFF1YWxpdHlSZXEpIHtcbiAgICAgICAgZm9yICh2YXIgX2wgPSBoaWdoZXJDYWNoZS5sZXZlbDsgX2wgPiBsdmw7IF9sLS0pIHtcbiAgICAgICAgICBvbmVVcENhY2hlID0gc2VsZi5nZXRFbGVtZW50KGVsZSwgYmIsIHB4UmF0aW8sIF9sLCBnZXRUeHJSZWFzb25zLmRvd25zY2FsZSk7XG4gICAgICAgIH1cblxuICAgICAgICBkb3duc2NhbGUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYucXVldWVFbGVtZW50KGVsZSwgaGlnaGVyQ2FjaGUubGV2ZWwgLSAxKTtcbiAgICAgICAgcmV0dXJuIGhpZ2hlckNhY2hlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbG93ZXJDYWNoZTsgLy8gdGhlIG5lYXJlc3QgY2FjaGUgd2l0aCBhIGxvd2VyIGxldmVsXG5cbiAgICAgIGlmICghZGVxaW5nICYmICFoaWdoUXVhbGl0eVJlcSAmJiAhZG93bnNjYWxlUmVxKSB7XG4gICAgICAgIGZvciAodmFyIF9sMiA9IGx2bCAtIDE7IF9sMiA+PSBtaW5MdmwkMTsgX2wyLS0pIHtcbiAgICAgICAgICB2YXIgX2MgPSBsb29rdXAuZ2V0KGVsZSwgX2wyKTtcblxuICAgICAgICAgIGlmIChfYykge1xuICAgICAgICAgICAgbG93ZXJDYWNoZSA9IF9jO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzY2FsYWJsZUZyb20obG93ZXJDYWNoZSkpIHtcbiAgICAgICAgLy8gdGhlbiB1c2UgdGhlIGxvd2VyIHF1YWxpdHkgY2FjaGUgZm9yIG5vdyBhbmQgcXVldWUgdGhlIGJldHRlciBvbmUgZm9yIGxhdGVyXG4gICAgICAgIHNlbGYucXVldWVFbGVtZW50KGVsZSwgbHZsKTtcbiAgICAgICAgcmV0dXJuIGxvd2VyQ2FjaGU7XG4gICAgICB9XG5cbiAgICAgIHR4ci5jb250ZXh0LnRyYW5zbGF0ZSh0eHIudXNlZFdpZHRoLCAwKTtcbiAgICAgIHR4ci5jb250ZXh0LnNjYWxlKHNjYWxlLCBzY2FsZSk7XG4gICAgICB0aGlzLmRyYXdFbGVtZW50KHR4ci5jb250ZXh0LCBlbGUsIGJiLCBzY2FsZWRMYWJlbFNob3duLCBmYWxzZSk7XG4gICAgICB0eHIuY29udGV4dC5zY2FsZSgxIC8gc2NhbGUsIDEgLyBzY2FsZSk7XG4gICAgICB0eHIuY29udGV4dC50cmFuc2xhdGUoLXR4ci51c2VkV2lkdGgsIDApO1xuICAgIH1cblxuICAgIGVsZUNhY2hlID0ge1xuICAgICAgeDogdHhyLnVzZWRXaWR0aCxcbiAgICAgIHRleHR1cmU6IHR4cixcbiAgICAgIGxldmVsOiBsdmwsXG4gICAgICBzY2FsZTogc2NhbGUsXG4gICAgICB3aWR0aDogZWxlU2NhbGVkVyxcbiAgICAgIGhlaWdodDogZWxlU2NhbGVkSCxcbiAgICAgIHNjYWxlZExhYmVsU2hvd246IHNjYWxlZExhYmVsU2hvd25cbiAgICB9O1xuICAgIHR4ci51c2VkV2lkdGggKz0gTWF0aC5jZWlsKGVsZVNjYWxlZFcgKyBlbGVUeHJTcGFjaW5nKTtcbiAgICB0eHIuZWxlQ2FjaGVzLnB1c2goZWxlQ2FjaGUpO1xuICAgIGxvb2t1cC5zZXQoZWxlLCBsdmwsIGVsZUNhY2hlKTtcbiAgICBzZWxmLmNoZWNrVGV4dHVyZUZ1bGxuZXNzKHR4cik7XG4gICAgcmV0dXJuIGVsZUNhY2hlO1xuICB9O1xuXG4gIEVUQ3AuaW52YWxpZGF0ZUVsZW1lbnRzID0gZnVuY3Rpb24gKGVsZXMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZUVsZW1lbnQoZWxlc1tpXSk7XG4gICAgfVxuICB9O1xuXG4gIEVUQ3AuaW52YWxpZGF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBsb29rdXAgPSBzZWxmLmxvb2t1cDtcbiAgICB2YXIgY2FjaGVzID0gW107XG4gICAgdmFyIGludmFsaWQgPSBsb29rdXAuaXNJbnZhbGlkKGVsZSk7XG5cbiAgICBpZiAoIWludmFsaWQpIHtcbiAgICAgIHJldHVybjsgLy8gb3ZlcnJpZGUgdGhlIGludmFsaWRhdGlvbiByZXF1ZXN0IGlmIHRoZSBlbGVtZW50IGtleSBoYXMgbm90IGNoYW5nZWRcbiAgICB9XG5cbiAgICBmb3IgKHZhciBsdmwgPSBtaW5MdmwkMTsgbHZsIDw9IG1heEx2bCQxOyBsdmwrKykge1xuICAgICAgdmFyIGNhY2hlID0gbG9va3VwLmdldEZvckNhY2hlZEtleShlbGUsIGx2bCk7XG5cbiAgICAgIGlmIChjYWNoZSkge1xuICAgICAgICBjYWNoZXMucHVzaChjYWNoZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG5vT3RoZXJFbGVzVXNlQ2FjaGUgPSBsb29rdXAuaW52YWxpZGF0ZShlbGUpO1xuXG4gICAgaWYgKG5vT3RoZXJFbGVzVXNlQ2FjaGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2FjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBfY2FjaGUgPSBjYWNoZXNbaV07XG4gICAgICAgIHZhciB0eHIgPSBfY2FjaGUudGV4dHVyZTsgLy8gcmVtb3ZlIHNwYWNlIGZyb20gdGhlIHRleHR1cmUgaXQgYmVsb25ncyB0b1xuXG4gICAgICAgIHR4ci5pbnZhbGlkYXRlZFdpZHRoICs9IF9jYWNoZS53aWR0aDsgLy8gbWFyayB0aGUgY2FjaGUgYXMgaW52YWxpZGF0ZWRcblxuICAgICAgICBfY2FjaGUuaW52YWxpZGF0ZWQgPSB0cnVlOyAvLyByZXRpcmUgdGhlIHRleHR1cmUgaWYgaXRzIHV0aWxpdHkgaXMgbG93XG5cbiAgICAgICAgc2VsZi5jaGVja1RleHR1cmVVdGlsaXR5KHR4cik7XG4gICAgICB9XG4gICAgfSAvLyByZW1vdmUgZnJvbSBxdWV1ZSBzaW5jZSB0aGUgb2xkIHJlcSB3YXMgZm9yIHRoZSBvbGQgc3RhdGVcblxuXG4gICAgc2VsZi5yZW1vdmVGcm9tUXVldWUoZWxlKTtcbiAgfTtcblxuICBFVENwLmNoZWNrVGV4dHVyZVV0aWxpdHkgPSBmdW5jdGlvbiAodHhyKSB7XG4gICAgLy8gaW52YWxpZGF0ZSBhbGwgZW50cmllcyBpbiB0aGUgY2FjaGUgaWYgdGhlIGNhY2hlIHNpemUgaXMgc21hbGxcbiAgICBpZiAodHhyLmludmFsaWRhdGVkV2lkdGggPj0gbWluVXRpbGl0eSAqIHR4ci53aWR0aCkge1xuICAgICAgdGhpcy5yZXRpcmVUZXh0dXJlKHR4cik7XG4gICAgfVxuICB9O1xuXG4gIEVUQ3AuY2hlY2tUZXh0dXJlRnVsbG5lc3MgPSBmdW5jdGlvbiAodHhyKSB7XG4gICAgLy8gaWYgdGV4dHVyZSBoYXMgYmVlbiBtb3N0bHkgZmlsbGVkIGFuZCBwYXNzZWQgb3ZlciBzZXZlcmFsIHRpbWVzLCByZW1vdmVcbiAgICAvLyBpdCBmcm9tIHRoZSBxdWV1ZSBzbyB3ZSBkb24ndCBuZWVkIHRvIHdhc3RlIHRpbWUgbG9va2luZyBhdCBpdCB0byBwdXQgbmV3IHRoaW5nc1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgdHhyUSA9IHNlbGYuZ2V0VGV4dHVyZVF1ZXVlKHR4ci5oZWlnaHQpO1xuXG4gICAgaWYgKHR4ci51c2VkV2lkdGggLyB0eHIud2lkdGggPiBtYXhGdWxsbmVzcyAmJiB0eHIuZnVsbG5lc3NDaGVja3MgPj0gbWF4RnVsbG5lc3NDaGVja3MpIHtcbiAgICAgIHJlbW92ZUZyb21BcnJheSh0eHJRLCB0eHIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eHIuZnVsbG5lc3NDaGVja3MrKztcbiAgICB9XG4gIH07XG5cbiAgRVRDcC5yZXRpcmVUZXh0dXJlID0gZnVuY3Rpb24gKHR4cikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgdHhySCA9IHR4ci5oZWlnaHQ7XG4gICAgdmFyIHR4clEgPSBzZWxmLmdldFRleHR1cmVRdWV1ZSh0eHJIKTtcbiAgICB2YXIgbG9va3VwID0gdGhpcy5sb29rdXA7IC8vIHJldGlyZSB0aGUgdGV4dHVyZSBmcm9tIHRoZSBhY3RpdmUgLyBzZWFyY2hhYmxlIHF1ZXVlOlxuXG4gICAgcmVtb3ZlRnJvbUFycmF5KHR4clEsIHR4cik7XG4gICAgdHhyLnJldGlyZWQgPSB0cnVlOyAvLyByZW1vdmUgdGhlIHJlZnMgZnJvbSB0aGUgZWxlcyB0byB0aGUgY2FjaGVzOlxuXG4gICAgdmFyIGVsZUNhY2hlcyA9IHR4ci5lbGVDYWNoZXM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZUNhY2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZUNhY2hlID0gZWxlQ2FjaGVzW2ldO1xuICAgICAgbG9va3VwLmRlbGV0ZUNhY2hlKGVsZUNhY2hlLmtleSwgZWxlQ2FjaGUubGV2ZWwpO1xuICAgIH1cblxuICAgIGNsZWFyQXJyYXkoZWxlQ2FjaGVzKTsgLy8gYWRkIHRoZSB0ZXh0dXJlIHRvIGEgcmV0aXJlZCBxdWV1ZSBzbyBpdCBjYW4gYmUgcmVjeWNsZWQgaW4gZnV0dXJlOlxuXG4gICAgdmFyIHJ0eHRyUSA9IHNlbGYuZ2V0UmV0aXJlZFRleHR1cmVRdWV1ZSh0eHJIKTtcbiAgICBydHh0clEucHVzaCh0eHIpO1xuICB9O1xuXG4gIEVUQ3AuYWRkVGV4dHVyZSA9IGZ1bmN0aW9uICh0eHJILCBtaW5XKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciB0eHJRID0gc2VsZi5nZXRUZXh0dXJlUXVldWUodHhySCk7XG4gICAgdmFyIHR4ciA9IHt9O1xuICAgIHR4clEucHVzaCh0eHIpO1xuICAgIHR4ci5lbGVDYWNoZXMgPSBbXTtcbiAgICB0eHIuaGVpZ2h0ID0gdHhySDtcbiAgICB0eHIud2lkdGggPSBNYXRoLm1heChkZWZUeHJXaWR0aCwgbWluVyk7XG4gICAgdHhyLnVzZWRXaWR0aCA9IDA7XG4gICAgdHhyLmludmFsaWRhdGVkV2lkdGggPSAwO1xuICAgIHR4ci5mdWxsbmVzc0NoZWNrcyA9IDA7XG4gICAgdHhyLmNhbnZhcyA9IHNlbGYucmVuZGVyZXIubWFrZU9mZnNjcmVlbkNhbnZhcyh0eHIud2lkdGgsIHR4ci5oZWlnaHQpO1xuICAgIHR4ci5jb250ZXh0ID0gdHhyLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHJldHVybiB0eHI7XG4gIH07XG5cbiAgRVRDcC5yZWN5Y2xlVGV4dHVyZSA9IGZ1bmN0aW9uICh0eHJILCBtaW5XKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciB0eHJRID0gc2VsZi5nZXRUZXh0dXJlUXVldWUodHhySCk7XG4gICAgdmFyIHJ0eHRyUSA9IHNlbGYuZ2V0UmV0aXJlZFRleHR1cmVRdWV1ZSh0eHJIKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcnR4dHJRLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdHhyID0gcnR4dHJRW2ldO1xuXG4gICAgICBpZiAodHhyLndpZHRoID49IG1pblcpIHtcbiAgICAgICAgdHhyLnJldGlyZWQgPSBmYWxzZTtcbiAgICAgICAgdHhyLnVzZWRXaWR0aCA9IDA7XG4gICAgICAgIHR4ci5pbnZhbGlkYXRlZFdpZHRoID0gMDtcbiAgICAgICAgdHhyLmZ1bGxuZXNzQ2hlY2tzID0gMDtcbiAgICAgICAgY2xlYXJBcnJheSh0eHIuZWxlQ2FjaGVzKTtcbiAgICAgICAgdHhyLmNvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgICB0eHIuY29udGV4dC5jbGVhclJlY3QoMCwgMCwgdHhyLndpZHRoLCB0eHIuaGVpZ2h0KTtcbiAgICAgICAgcmVtb3ZlRnJvbUFycmF5KHJ0eHRyUSwgdHhyKTtcbiAgICAgICAgdHhyUS5wdXNoKHR4cik7XG4gICAgICAgIHJldHVybiB0eHI7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEVUQ3AucXVldWVFbGVtZW50ID0gZnVuY3Rpb24gKGVsZSwgbHZsKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBxID0gc2VsZi5nZXRFbGVtZW50UXVldWUoKTtcbiAgICB2YXIgazJxID0gc2VsZi5nZXRFbGVtZW50S2V5VG9RdWV1ZSgpO1xuICAgIHZhciBrZXkgPSB0aGlzLmdldEtleShlbGUpO1xuICAgIHZhciBleGlzdGluZ1JlcSA9IGsycVtrZXldO1xuXG4gICAgaWYgKGV4aXN0aW5nUmVxKSB7XG4gICAgICAvLyB1c2UgdGhlIG1heCBsdmwgYi9jIGluIGJldHdlZW4gbHZscyBhcmUgY2hlYXAgdG8gbWFrZVxuICAgICAgZXhpc3RpbmdSZXEubGV2ZWwgPSBNYXRoLm1heChleGlzdGluZ1JlcS5sZXZlbCwgbHZsKTtcbiAgICAgIGV4aXN0aW5nUmVxLmVsZXMubWVyZ2UoZWxlKTtcbiAgICAgIGV4aXN0aW5nUmVxLnJlcXMrKztcbiAgICAgIHEudXBkYXRlSXRlbShleGlzdGluZ1JlcSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciByZXEgPSB7XG4gICAgICAgIGVsZXM6IGVsZS5zcGF3bigpLm1lcmdlKGVsZSksXG4gICAgICAgIGxldmVsOiBsdmwsXG4gICAgICAgIHJlcXM6IDEsXG4gICAgICAgIGtleToga2V5XG4gICAgICB9O1xuICAgICAgcS5wdXNoKHJlcSk7XG4gICAgICBrMnFba2V5XSA9IHJlcTtcbiAgICB9XG4gIH07XG5cbiAgRVRDcC5kZXF1ZXVlID0gZnVuY3Rpb24gKHB4UmF0aW9cbiAgLyosIGV4dGVudCovXG4gICkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgcSA9IHNlbGYuZ2V0RWxlbWVudFF1ZXVlKCk7XG4gICAgdmFyIGsycSA9IHNlbGYuZ2V0RWxlbWVudEtleVRvUXVldWUoKTtcbiAgICB2YXIgZGVxdWV1ZWQgPSBbXTtcbiAgICB2YXIgbG9va3VwID0gc2VsZi5sb29rdXA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1heERlcVNpemUkMTsgaSsrKSB7XG4gICAgICBpZiAocS5zaXplKCkgPiAwKSB7XG4gICAgICAgIHZhciByZXEgPSBxLnBvcCgpO1xuICAgICAgICB2YXIga2V5ID0gcmVxLmtleTtcbiAgICAgICAgdmFyIGVsZSA9IHJlcS5lbGVzWzBdOyAvLyBhbGwgZWxlcyBoYXZlIHRoZSBzYW1lIGtleVxuXG4gICAgICAgIHZhciBjYWNoZUV4aXN0cyA9IGxvb2t1cC5oYXNDYWNoZShlbGUsIHJlcS5sZXZlbCk7IC8vIGNsZWFyIG91dCB0aGUga2V5IHRvIHJlcSBsb29rdXBcblxuICAgICAgICBrMnFba2V5XSA9IG51bGw7IC8vIGRlcXVldWVpbmcgaXNuJ3QgbmVjZXNzYXJ5IHdpdGggYW4gZXhpc3RpbmcgY2FjaGVcblxuICAgICAgICBpZiAoY2FjaGVFeGlzdHMpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlcXVldWVkLnB1c2gocmVxKTtcbiAgICAgICAgdmFyIGJiID0gc2VsZi5nZXRCb3VuZGluZ0JveChlbGUpO1xuICAgICAgICBzZWxmLmdldEVsZW1lbnQoZWxlLCBiYiwgcHhSYXRpbywgcmVxLmxldmVsLCBnZXRUeHJSZWFzb25zLmRlcXVldWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlcXVldWVkO1xuICB9O1xuXG4gIEVUQ3AucmVtb3ZlRnJvbVF1ZXVlID0gZnVuY3Rpb24gKGVsZSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgcSA9IHNlbGYuZ2V0RWxlbWVudFF1ZXVlKCk7XG4gICAgdmFyIGsycSA9IHNlbGYuZ2V0RWxlbWVudEtleVRvUXVldWUoKTtcbiAgICB2YXIga2V5ID0gdGhpcy5nZXRLZXkoZWxlKTtcbiAgICB2YXIgcmVxID0gazJxW2tleV07XG5cbiAgICBpZiAocmVxICE9IG51bGwpIHtcbiAgICAgIGlmIChyZXEuZWxlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgLy8gcmVtb3ZlIGlmIGxhc3QgZWxlIGluIHRoZSByZXFcbiAgICAgICAgLy8gYnJpbmcgdG8gZnJvbnQgb2YgcXVldWVcbiAgICAgICAgcmVxLnJlcXMgPSBNQVhfSU5UJDE7XG4gICAgICAgIHEudXBkYXRlSXRlbShyZXEpO1xuICAgICAgICBxLnBvcCgpOyAvLyByZW1vdmUgZnJvbSBxdWV1ZVxuXG4gICAgICAgIGsycVtrZXldID0gbnVsbDsgLy8gcmVtb3ZlIGZyb20gbG9va3VwIG1hcFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gb3RoZXJ3aXNlIGp1c3QgcmVtb3ZlIGVsZSBmcm9tIHJlcVxuICAgICAgICByZXEuZWxlcy51bm1lcmdlKGVsZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEVUQ3Aub25EZXF1ZXVlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgdGhpcy5vbkRlcXVldWVzLnB1c2goZm4pO1xuICB9O1xuXG4gIEVUQ3Aub2ZmRGVxdWV1ZSA9IGZ1bmN0aW9uIChmbikge1xuICAgIHJlbW92ZUZyb21BcnJheSh0aGlzLm9uRGVxdWV1ZXMsIGZuKTtcbiAgfTtcblxuICBFVENwLnNldHVwRGVxdWV1ZWluZyA9IGRlZnMuc2V0dXBEZXF1ZXVlaW5nKHtcbiAgICBkZXFSZWRyYXdUaHJlc2hvbGQ6IGRlcVJlZHJhd1RocmVzaG9sZCQxLFxuICAgIGRlcUNvc3Q6IGRlcUNvc3QkMSxcbiAgICBkZXFBdmdDb3N0OiBkZXFBdmdDb3N0JDEsXG4gICAgZGVxTm9EcmF3Q29zdDogZGVxTm9EcmF3Q29zdCQxLFxuICAgIGRlcUZhc3RDb3N0OiBkZXFGYXN0Q29zdCQxLFxuICAgIGRlcTogZnVuY3Rpb24gZGVxKHNlbGYsIHB4UmF0aW8sIGV4dGVudCkge1xuICAgICAgcmV0dXJuIHNlbGYuZGVxdWV1ZShweFJhdGlvLCBleHRlbnQpO1xuICAgIH0sXG4gICAgb25EZXFkOiBmdW5jdGlvbiBvbkRlcWQoc2VsZiwgZGVxZCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLm9uRGVxdWV1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGZuID0gc2VsZi5vbkRlcXVldWVzW2ldO1xuICAgICAgICBmbihkZXFkKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNob3VsZFJlZHJhdzogZnVuY3Rpb24gc2hvdWxkUmVkcmF3KHNlbGYsIGRlcWQsIHB4UmF0aW8sIGV4dGVudCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZXFkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGVzID0gZGVxZFtpXS5lbGVzO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZWxlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHZhciBiYiA9IGVsZXNbal0uYm91bmRpbmdCb3goKTtcblxuICAgICAgICAgIGlmIChib3VuZGluZ0JveGVzSW50ZXJzZWN0KGJiLCBleHRlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgcHJpb3JpdHk6IGZ1bmN0aW9uIHByaW9yaXR5KHNlbGYpIHtcbiAgICAgIHJldHVybiBzZWxmLnJlbmRlcmVyLmJlZm9yZVJlbmRlclByaW9yaXRpZXMuZWxlVHhyRGVxO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIGRlZk51bUxheWVycyA9IDE7IC8vIGRlZmF1bHQgbnVtYmVyIG9mIGxheWVycyB0byB1c2VcblxuICB2YXIgbWluTHZsID0gLTQ7IC8vIHdoZW4gc2NhbGluZyBzbWFsbGVyIHRoYW4gdGhhdCB3ZSBkb24ndCBuZWVkIHRvIHJlLXJlbmRlclxuXG4gIHZhciBtYXhMdmwgPSAyOyAvLyB3aGVuIGxhcmdlciB0aGFuIHRoaXMgc2NhbGUganVzdCByZW5kZXIgZGlyZWN0bHkgKGNhY2hpbmcgaXMgbm90IGhlbHBmdWwpXG5cbiAgdmFyIG1heFpvb20gPSAzLjk5OyAvLyBiZXlvbmQgdGhpcyB6b29tIGxldmVsLCBsYXllcmVkIHRleHR1cmVzIGFyZSBub3QgdXNlZFxuXG4gIHZhciBkZXFSZWRyYXdUaHJlc2hvbGQgPSA1MDsgLy8gdGltZSB0byBiYXRjaCByZWRyYXdzIHRvZ2V0aGVyIGZyb20gZGVxdWV1ZWluZyB0byBhbGxvdyBtb3JlIGRlcXVldWVpbmcgY2FsY3MgdG8gaGFwcGVuIGluIHRoZSBtZWFud2hpbGVcblxuICB2YXIgcmVmaW5lRWxlRGVib3VuY2VUaW1lID0gNTA7IC8vIHRpbWUgdG8gZGVib3VuY2Ugc2hhcnBlciBlbGUgdGV4dHVyZSB1cGRhdGVzXG5cbiAgdmFyIGRlcUNvc3QgPSAwLjE1OyAvLyAlIG9mIGFkZCdsIHJlbmRlcmluZyBjb3N0IGFsbG93ZWQgZm9yIGRlcXVldWluZyBlbGUgY2FjaGVzIGVhY2ggZnJhbWVcblxuICB2YXIgZGVxQXZnQ29zdCA9IDAuMTsgLy8gJSBvZiBhZGQnbCByZW5kZXJpbmcgY29zdCBjb21wYXJlZCB0byBhdmVyYWdlIG92ZXJhbGwgcmVkcmF3IHRpbWVcblxuICB2YXIgZGVxTm9EcmF3Q29zdCA9IDAuOTsgLy8gJSBvZiBhdmcgZnJhbWUgdGltZSB0aGF0IGNhbiBiZSB1c2VkIGZvciBkZXF1ZXVlaW5nIHdoZW4gbm90IGRyYXdpbmdcblxuICB2YXIgZGVxRmFzdENvc3QgPSAwLjk7IC8vICUgb2YgZnJhbWUgdGltZSB0byBiZSB1c2VkIHdoZW4gPjYwZnBzXG5cbiAgdmFyIG1heERlcVNpemUgPSAxOyAvLyBudW1iZXIgb2YgZWxlcyB0byBkZXF1ZXVlIGFuZCByZW5kZXIgYXQgaGlnaGVyIHRleHR1cmUgaW4gZWFjaCBiYXRjaFxuXG4gIHZhciBpbnZhbGlkVGhyZXNob2xkID0gMjUwOyAvLyB0aW1lIHRocmVzaG9sZCBmb3IgZGlzYWJsaW5nIGIvYyBvZiBpbnZhbGlkYXRpb25zXG5cbiAgdmFyIG1heExheWVyQXJlYSA9IDQwMDAgKiA0MDAwOyAvLyBsYXllcnMgY2FuJ3QgYmUgYmlnZ2VyIHRoYW4gdGhpc1xuXG4gIHZhciB1c2VIaWdoUXVhbGl0eUVsZVR4clJlcXMgPSB0cnVlOyAvLyB3aGV0aGVyIHRvIHVzZSBoaWdoIHF1YWxpdHkgZWxlIHR4ciByZXF1ZXN0cyAoZ2VuZXJhbGx5IGZhc3RlciBhbmQgY2hlYXBlciBpbiB0aGUgbG9uZ3Rlcm0pXG4gIC8vIHZhciBsb2cgPSBmdW5jdGlvbigpeyBjb25zb2xlLmxvZy5hcHBseSggY29uc29sZSwgYXJndW1lbnRzICk7IH07XG5cbiAgdmFyIExheWVyZWRUZXh0dXJlQ2FjaGUgPSBmdW5jdGlvbiBMYXllcmVkVGV4dHVyZUNhY2hlKHJlbmRlcmVyKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciByID0gc2VsZi5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgIHZhciBjeSA9IHIuY3k7XG4gICAgc2VsZi5sYXllcnNCeUxldmVsID0ge307IC8vIGUuZy4gMiA9PiBbIGxheWVyMSwgbGF5ZXIyLCAuLi4sIGxheWVyTiBdXG5cbiAgICBzZWxmLmZpcnN0R2V0ID0gdHJ1ZTtcbiAgICBzZWxmLmxhc3RJbnZhbGlkYXRpb25UaW1lID0gcGVyZm9ybWFuY2VOb3coKSAtIDIgKiBpbnZhbGlkVGhyZXNob2xkO1xuICAgIHNlbGYuc2tpcHBpbmcgPSBmYWxzZTtcbiAgICBzZWxmLmVsZVR4ckRlcXMgPSBjeS5jb2xsZWN0aW9uKCk7XG4gICAgc2VsZi5zY2hlZHVsZUVsZW1lbnRSZWZpbmVtZW50ID0gZGVib3VuY2VfMShmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLnJlZmluZUVsZW1lbnRUZXh0dXJlcyhzZWxmLmVsZVR4ckRlcXMpO1xuICAgICAgc2VsZi5lbGVUeHJEZXFzLnVubWVyZ2Uoc2VsZi5lbGVUeHJEZXFzKTtcbiAgICB9LCByZWZpbmVFbGVEZWJvdW5jZVRpbWUpO1xuICAgIHIuYmVmb3JlUmVuZGVyKGZ1bmN0aW9uICh3aWxsRHJhdywgbm93KSB7XG4gICAgICBpZiAobm93IC0gc2VsZi5sYXN0SW52YWxpZGF0aW9uVGltZSA8PSBpbnZhbGlkVGhyZXNob2xkKSB7XG4gICAgICAgIHNlbGYuc2tpcHBpbmcgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5za2lwcGluZyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0sIHIuYmVmb3JlUmVuZGVyUHJpb3JpdGllcy5seXJUeHJTa2lwKTtcblxuICAgIHZhciBxU29ydCA9IGZ1bmN0aW9uIHFTb3J0KGEsIGIpIHtcbiAgICAgIHJldHVybiBiLnJlcXMgLSBhLnJlcXM7XG4gICAgfTtcblxuICAgIHNlbGYubGF5ZXJzUXVldWUgPSBuZXcgaGVhcChxU29ydCk7XG4gICAgc2VsZi5zZXR1cERlcXVldWVpbmcoKTtcbiAgfTtcblxuICB2YXIgTFRDcCA9IExheWVyZWRUZXh0dXJlQ2FjaGUucHJvdG90eXBlO1xuICB2YXIgbGF5ZXJJZFBvb2wgPSAwO1xuICB2YXIgTUFYX0lOVCA9IE1hdGgucG93KDIsIDUzKSAtIDE7XG5cbiAgTFRDcC5tYWtlTGF5ZXIgPSBmdW5jdGlvbiAoYmIsIGx2bCkge1xuICAgIHZhciBzY2FsZSA9IE1hdGgucG93KDIsIGx2bCk7XG4gICAgdmFyIHcgPSBNYXRoLmNlaWwoYmIudyAqIHNjYWxlKTtcbiAgICB2YXIgaCA9IE1hdGguY2VpbChiYi5oICogc2NhbGUpO1xuICAgIHZhciBjYW52YXMgPSB0aGlzLnJlbmRlcmVyLm1ha2VPZmZzY3JlZW5DYW52YXModywgaCk7XG4gICAgdmFyIGxheWVyID0ge1xuICAgICAgaWQ6IGxheWVySWRQb29sID0gKytsYXllcklkUG9vbCAlIE1BWF9JTlQsXG4gICAgICBiYjogYmIsXG4gICAgICBsZXZlbDogbHZsLFxuICAgICAgd2lkdGg6IHcsXG4gICAgICBoZWlnaHQ6IGgsXG4gICAgICBjYW52YXM6IGNhbnZhcyxcbiAgICAgIGNvbnRleHQ6IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLFxuICAgICAgZWxlczogW10sXG4gICAgICBlbGVzUXVldWU6IFtdLFxuICAgICAgcmVxczogMFxuICAgIH07IC8vIGxvZygnbWFrZSBsYXllciAlcyB3aXRoIHcgJXMgYW5kIGggJXMgYW5kIGx2bCAlcycsIGxheWVyLmlkLCBsYXllci53aWR0aCwgbGF5ZXIuaGVpZ2h0LCBsYXllci5sZXZlbCk7XG5cbiAgICB2YXIgY3h0ID0gbGF5ZXIuY29udGV4dDtcbiAgICB2YXIgZHggPSAtbGF5ZXIuYmIueDE7XG4gICAgdmFyIGR5ID0gLWxheWVyLmJiLnkxOyAvLyBkbyB0aGUgdHJhbnNmb3JtIG9uIGNyZWF0aW9uIHRvIHNhdmUgY3ljbGVzIChpdCdzIHRoZSBzYW1lIGZvciBhbGwgZWxlcylcblxuICAgIGN4dC5zY2FsZShzY2FsZSwgc2NhbGUpO1xuICAgIGN4dC50cmFuc2xhdGUoZHgsIGR5KTtcbiAgICByZXR1cm4gbGF5ZXI7XG4gIH07XG5cbiAgTFRDcC5nZXRMYXllcnMgPSBmdW5jdGlvbiAoZWxlcywgcHhSYXRpbywgbHZsKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciByID0gc2VsZi5yZW5kZXJlcjtcbiAgICB2YXIgY3kgPSByLmN5O1xuICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuICAgIHZhciBmaXJzdEdldCA9IHNlbGYuZmlyc3RHZXQ7XG4gICAgc2VsZi5maXJzdEdldCA9IGZhbHNlOyAvLyBsb2coJy0tXFxuZ2V0IGxheWVycyB3aXRoICVzIGVsZXMnLCBlbGVzLmxlbmd0aCk7XG4gICAgLy9sb2cgZWxlcy5tYXAoZnVuY3Rpb24oZWxlKXsgcmV0dXJuIGVsZS5pZCgpIH0pICk7XG5cbiAgICBpZiAobHZsID09IG51bGwpIHtcbiAgICAgIGx2bCA9IE1hdGguY2VpbChsb2cyKHpvb20gKiBweFJhdGlvKSk7XG5cbiAgICAgIGlmIChsdmwgPCBtaW5MdmwpIHtcbiAgICAgICAgbHZsID0gbWluTHZsO1xuICAgICAgfSBlbHNlIGlmICh6b29tID49IG1heFpvb20gfHwgbHZsID4gbWF4THZsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGYudmFsaWRhdGVMYXllcnNFbGVzT3JkZXJpbmcobHZsLCBlbGVzKTtcbiAgICB2YXIgbGF5ZXJzQnlMdmwgPSBzZWxmLmxheWVyc0J5TGV2ZWw7XG4gICAgdmFyIHNjYWxlID0gTWF0aC5wb3coMiwgbHZsKTtcbiAgICB2YXIgbGF5ZXJzID0gbGF5ZXJzQnlMdmxbbHZsXSA9IGxheWVyc0J5THZsW2x2bF0gfHwgW107XG4gICAgdmFyIGJiO1xuICAgIHZhciBsdmxDb21wbGV0ZSA9IHNlbGYubGV2ZWxJc0NvbXBsZXRlKGx2bCwgZWxlcyk7XG4gICAgdmFyIHRtcExheWVycztcblxuICAgIHZhciBjaGVja1RlbXBMZXZlbHMgPSBmdW5jdGlvbiBjaGVja1RlbXBMZXZlbHMoKSB7XG4gICAgICB2YXIgY2FuVXNlQXNUbXBMdmwgPSBmdW5jdGlvbiBjYW5Vc2VBc1RtcEx2bChsKSB7XG4gICAgICAgIHNlbGYudmFsaWRhdGVMYXllcnNFbGVzT3JkZXJpbmcobCwgZWxlcyk7XG5cbiAgICAgICAgaWYgKHNlbGYubGV2ZWxJc0NvbXBsZXRlKGwsIGVsZXMpKSB7XG4gICAgICAgICAgdG1wTGF5ZXJzID0gbGF5ZXJzQnlMdmxbbF07XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciBjaGVja0x2bHMgPSBmdW5jdGlvbiBjaGVja0x2bHMoZGlyKSB7XG4gICAgICAgIGlmICh0bXBMYXllcnMpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBsID0gbHZsICsgZGlyOyBtaW5MdmwgPD0gbCAmJiBsIDw9IG1heEx2bDsgbCArPSBkaXIpIHtcbiAgICAgICAgICBpZiAoY2FuVXNlQXNUbXBMdmwobCkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgY2hlY2tMdmxzKCsxKTtcbiAgICAgIGNoZWNrTHZscygtMSk7IC8vIHJlbW92ZSB0aGUgaW52YWxpZCBsYXllcnM7IHRoZXkgd2lsbCBiZSByZXBsYWNlZCBhcyBuZWVkZWQgbGF0ZXIgaW4gdGhpcyBmdW5jdGlvblxuXG4gICAgICBmb3IgKHZhciBpID0gbGF5ZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBsYXllciA9IGxheWVyc1tpXTtcblxuICAgICAgICBpZiAobGF5ZXIuaW52YWxpZCkge1xuICAgICAgICAgIHJlbW92ZUZyb21BcnJheShsYXllcnMsIGxheWVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoIWx2bENvbXBsZXRlKSB7XG4gICAgICAvLyBpZiB0aGUgY3VycmVudCBsZXZlbCBpcyBpbmNvbXBsZXRlLCB0aGVuIHVzZSB0aGUgY2xvc2VzdCwgYmVzdCBxdWFsaXR5IGxheWVyc2V0IHRlbXBvcmFyaWx5XG4gICAgICAvLyBhbmQgbGF0ZXIgcXVldWUgdGhlIGN1cnJlbnQgbGF5ZXJzZXQgc28gd2UgY2FuIGdldCB0aGUgcHJvcGVyIHF1YWxpdHkgbGV2ZWwgc29vblxuICAgICAgY2hlY2tUZW1wTGV2ZWxzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGxvZygnbGV2ZWwgY29tcGxldGUsIHVzaW5nIGV4aXN0aW5nIGxheWVyc1xcbi0tJyk7XG4gICAgICByZXR1cm4gbGF5ZXJzO1xuICAgIH1cblxuICAgIHZhciBnZXRCYiA9IGZ1bmN0aW9uIGdldEJiKCkge1xuICAgICAgaWYgKCFiYikge1xuICAgICAgICBiYiA9IG1ha2VCb3VuZGluZ0JveCgpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHVwZGF0ZUJvdW5kaW5nQm94KGJiLCBlbGVzW2ldLmJvdW5kaW5nQm94KCkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBiYjtcbiAgICB9O1xuXG4gICAgdmFyIG1ha2VMYXllciA9IGZ1bmN0aW9uIG1ha2VMYXllcihvcHRzKSB7XG4gICAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICAgIHZhciBhZnRlciA9IG9wdHMuYWZ0ZXI7XG4gICAgICBnZXRCYigpO1xuICAgICAgdmFyIGFyZWEgPSBiYi53ICogc2NhbGUgKiAoYmIuaCAqIHNjYWxlKTtcblxuICAgICAgaWYgKGFyZWEgPiBtYXhMYXllckFyZWEpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBsYXllciA9IHNlbGYubWFrZUxheWVyKGJiLCBsdmwpO1xuXG4gICAgICBpZiAoYWZ0ZXIgIT0gbnVsbCkge1xuICAgICAgICB2YXIgaW5kZXggPSBsYXllcnMuaW5kZXhPZihhZnRlcikgKyAxO1xuICAgICAgICBsYXllcnMuc3BsaWNlKGluZGV4LCAwLCBsYXllcik7XG4gICAgICB9IGVsc2UgaWYgKG9wdHMuaW5zZXJ0ID09PSB1bmRlZmluZWQgfHwgb3B0cy5pbnNlcnQpIHtcbiAgICAgICAgLy8gbm8gYWZ0ZXIgc3BlY2lmaWVkID0+IGZpcnN0IGxheWVyIG1hZGUgc28gcHV0IGF0IHN0YXJ0XG4gICAgICAgIGxheWVycy51bnNoaWZ0KGxheWVyKTtcbiAgICAgIH0gLy8gaWYoIHRtcExheWVycyApe1xuICAgICAgLy9zZWxmLnF1ZXVlTGF5ZXIoIGxheWVyICk7XG4gICAgICAvLyB9XG5cblxuICAgICAgcmV0dXJuIGxheWVyO1xuICAgIH07XG5cbiAgICBpZiAoc2VsZi5za2lwcGluZyAmJiAhZmlyc3RHZXQpIHtcbiAgICAgIC8vIGxvZygnc2tpcCBsYXllcnMnKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gLy8gbG9nKCdkbyBsYXllcnMnKTtcblxuXG4gICAgdmFyIGxheWVyID0gbnVsbDtcbiAgICB2YXIgbWF4RWxlc1BlckxheWVyID0gZWxlcy5sZW5ndGggLyBkZWZOdW1MYXllcnM7XG4gICAgdmFyIGFsbG93TGF6eVF1ZXVlaW5nID0gIWZpcnN0R2V0O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgIHZhciBycyA9IGVsZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICAgIHZhciBjYWNoZXMgPSBycy5pbWdMYXllckNhY2hlcyA9IHJzLmltZ0xheWVyQ2FjaGVzIHx8IHt9OyAvLyBsb2coJ2xvb2sgYXQgZWxlJywgZWxlLmlkKCkpO1xuXG4gICAgICB2YXIgZXhpc3RpbmdMYXllciA9IGNhY2hlc1tsdmxdO1xuXG4gICAgICBpZiAoZXhpc3RpbmdMYXllcikge1xuICAgICAgICAvLyByZXVzZSBsYXllciBmb3IgbGF0ZXIgZWxlc1xuICAgICAgICAvLyBsb2coJ3JldXNlIGxheWVyIGZvcicsIGVsZS5pZCgpKTtcbiAgICAgICAgbGF5ZXIgPSBleGlzdGluZ0xheWVyO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFsYXllciB8fCBsYXllci5lbGVzLmxlbmd0aCA+PSBtYXhFbGVzUGVyTGF5ZXIgfHwgIWJvdW5kaW5nQm94SW5Cb3VuZGluZ0JveChsYXllci5iYiwgZWxlLmJvdW5kaW5nQm94KCkpKSB7XG4gICAgICAgIC8vIGxvZygnbWFrZSBuZXcgbGF5ZXIgZm9yIGVsZSAlcycsIGVsZS5pZCgpKTtcbiAgICAgICAgbGF5ZXIgPSBtYWtlTGF5ZXIoe1xuICAgICAgICAgIGluc2VydDogdHJ1ZSxcbiAgICAgICAgICBhZnRlcjogbGF5ZXJcbiAgICAgICAgfSk7IC8vIGlmIG5vdyBsYXllciBjYW4gYmUgYnVpbHQgdGhlbiB3ZSBjYW4ndCB1c2UgbGF5ZXJzIGF0IHRoaXMgbGV2ZWxcblxuICAgICAgICBpZiAoIWxheWVyKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0gLy8gbG9nKCduZXcgbGF5ZXIgd2l0aCBpZCAlcycsIGxheWVyLmlkKTtcblxuICAgICAgfVxuXG4gICAgICBpZiAodG1wTGF5ZXJzIHx8IGFsbG93TGF6eVF1ZXVlaW5nKSB7XG4gICAgICAgIC8vIGxvZygncXVldWUgZWxlICVzIGluIGxheWVyICVzJywgZWxlLmlkKCksIGxheWVyLmlkKTtcbiAgICAgICAgc2VsZi5xdWV1ZUxheWVyKGxheWVyLCBlbGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbG9nKCdkcmF3IGVsZSAlcyBpbiBsYXllciAlcycsIGVsZS5pZCgpLCBsYXllci5pZCk7XG4gICAgICAgIHNlbGYuZHJhd0VsZUluTGF5ZXIobGF5ZXIsIGVsZSwgbHZsLCBweFJhdGlvKTtcbiAgICAgIH1cblxuICAgICAgbGF5ZXIuZWxlcy5wdXNoKGVsZSk7XG4gICAgICBjYWNoZXNbbHZsXSA9IGxheWVyO1xuICAgIH0gLy8gbG9nKCctLScpO1xuXG5cbiAgICBpZiAodG1wTGF5ZXJzKSB7XG4gICAgICAvLyB0aGVuIHdlIG9ubHkgcXVldWVkIHRoZSBjdXJyZW50IGxheWVyc2V0IGFuZCBjYW4ndCBkcmF3IGl0IHlldFxuICAgICAgcmV0dXJuIHRtcExheWVycztcbiAgICB9XG5cbiAgICBpZiAoYWxsb3dMYXp5UXVldWVpbmcpIHtcbiAgICAgIC8vIGxvZygnbGF6eSBxdWV1ZSBsZXZlbCcsIGx2bCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gbGF5ZXJzO1xuICB9OyAvLyBhIGxheWVyIG1heSB3YW50IHRvIHVzZSBhbiBlbGUgY2FjaGUgb2YgYSBoaWdoZXIgbGV2ZWwgdG8gYXZvaWQgYmx1cnJpbmVzc1xuICAvLyBzbyB0aGUgbGF5ZXIgbGV2ZWwgbWlnaHQgbm90IGVxdWFsIHRoZSBlbGUgbGV2ZWxcblxuXG4gIExUQ3AuZ2V0RWxlTGV2ZWxGb3JMYXllckxldmVsID0gZnVuY3Rpb24gKGx2bCwgcHhSYXRpbykge1xuICAgIHJldHVybiBsdmw7XG4gIH07XG5cbiAgTFRDcC5kcmF3RWxlSW5MYXllciA9IGZ1bmN0aW9uIChsYXllciwgZWxlLCBsdmwsIHB4UmF0aW8pIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHIgPSB0aGlzLnJlbmRlcmVyO1xuICAgIHZhciBjb250ZXh0ID0gbGF5ZXIuY29udGV4dDtcbiAgICB2YXIgYmIgPSBlbGUuYm91bmRpbmdCb3goKTtcblxuICAgIGlmIChiYi53ID09PSAwIHx8IGJiLmggPT09IDAgfHwgIWVsZS52aXNpYmxlKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsdmwgPSBzZWxmLmdldEVsZUxldmVsRm9yTGF5ZXJMZXZlbChsdmwsIHB4UmF0aW8pO1xuXG4gICAge1xuICAgICAgci5zZXRJbWdTbW9vdGhpbmcoY29udGV4dCwgZmFsc2UpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIHIuZHJhd0NhY2hlZEVsZW1lbnQoY29udGV4dCwgZWxlLCBudWxsLCBudWxsLCBsdmwsIHVzZUhpZ2hRdWFsaXR5RWxlVHhyUmVxcyk7XG4gICAgfVxuXG4gICAge1xuICAgICAgci5zZXRJbWdTbW9vdGhpbmcoY29udGV4dCwgdHJ1ZSk7XG4gICAgfVxuICB9O1xuXG4gIExUQ3AubGV2ZWxJc0NvbXBsZXRlID0gZnVuY3Rpb24gKGx2bCwgZWxlcykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgbGF5ZXJzID0gc2VsZi5sYXllcnNCeUxldmVsW2x2bF07XG5cbiAgICBpZiAoIWxheWVycyB8fCBsYXllcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIG51bUVsZXNJbkxheWVycyA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGxheWVyID0gbGF5ZXJzW2ldOyAvLyBpZiB0aGVyZSBhcmUgYW55IGVsZXMgbmVlZGVkIHRvIGJlIGRyYXduIHlldCwgdGhlIGxldmVsIGlzIG5vdCBjb21wbGV0ZVxuXG4gICAgICBpZiAobGF5ZXIucmVxcyA+IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSAvLyBpZiB0aGUgbGF5ZXIgaXMgaW52YWxpZCwgdGhlIGxldmVsIGlzIG5vdCBjb21wbGV0ZVxuXG5cbiAgICAgIGlmIChsYXllci5pbnZhbGlkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgbnVtRWxlc0luTGF5ZXJzICs9IGxheWVyLmVsZXMubGVuZ3RoO1xuICAgIH0gLy8gd2Ugc2hvdWxkIGhhdmUgZXhhY3RseSB0aGUgbnVtYmVyIG9mIGVsZXMgcGFzc2VkIGluIHRvIGJlIGNvbXBsZXRlXG5cblxuICAgIGlmIChudW1FbGVzSW5MYXllcnMgIT09IGVsZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgTFRDcC52YWxpZGF0ZUxheWVyc0VsZXNPcmRlcmluZyA9IGZ1bmN0aW9uIChsdmwsIGVsZXMpIHtcbiAgICB2YXIgbGF5ZXJzID0gdGhpcy5sYXllcnNCeUxldmVsW2x2bF07XG5cbiAgICBpZiAoIWxheWVycykge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gaWYgaW4gYSBsYXllciB0aGUgZWxlcyBhcmUgbm90IGluIHRoZSBzYW1lIG9yZGVyLCB0aGVuIHRoZSBsYXllciBpcyBpbnZhbGlkXG4gICAgLy8gKGkuZS4gdGhlcmUgaXMgYW4gZWxlIGluIGJldHdlZW4gdGhlIGVsZXMgaW4gdGhlIGxheWVyKVxuXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGxheWVyID0gbGF5ZXJzW2ldO1xuICAgICAgdmFyIG9mZnNldCA9IC0xOyAvLyBmaW5kIHRoZSBvZmZzZXRcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBlbGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChsYXllci5lbGVzWzBdID09PSBlbGVzW2pdKSB7XG4gICAgICAgICAgb2Zmc2V0ID0gajtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAvLyB0aGVuIHRoZSBsYXllciBoYXMgbm9uZXhpc3RlbnQgZWxlbWVudHMgYW5kIGlzIGludmFsaWRcbiAgICAgICAgdGhpcy5pbnZhbGlkYXRlTGF5ZXIobGF5ZXIpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8gdGhlIGVsZXMgaW4gdGhlIGxheWVyIG11c3QgYmUgaW4gdGhlIHNhbWUgY29udGludW91cyBvcmRlciwgZWxzZSB0aGUgbGF5ZXIgaXMgaW52YWxpZFxuXG5cbiAgICAgIHZhciBvID0gb2Zmc2V0O1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxheWVyLmVsZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKGxheWVyLmVsZXNbal0gIT09IGVsZXNbbyArIGpdKSB7XG4gICAgICAgICAgLy8gbG9nKCdpbnZhbGlkYXRlIGJhc2VkIG9uIG9yZGVyaW5nJywgbGF5ZXIuaWQpO1xuICAgICAgICAgIHRoaXMuaW52YWxpZGF0ZUxheWVyKGxheWVyKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBMVENwLnVwZGF0ZUVsZW1lbnRzSW5MYXllcnMgPSBmdW5jdGlvbiAoZWxlcywgdXBkYXRlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBpc0VsZXMgPSBlbGVtZW50KGVsZXNbMF0pOyAvLyBjb2xsZWN0IHVkcGF0ZWQgZWxlbWVudHMgKGNhc2NhZGVkIGZyb20gdGhlIGxheWVycykgYW5kIHVwZGF0ZSBlYWNoXG4gICAgLy8gbGF5ZXIgaXRzZWxmIGFsb25nIHRoZSB3YXlcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHJlcSA9IGlzRWxlcyA/IG51bGwgOiBlbGVzW2ldO1xuICAgICAgdmFyIGVsZSA9IGlzRWxlcyA/IGVsZXNbaV0gOiBlbGVzW2ldLmVsZTtcbiAgICAgIHZhciBycyA9IGVsZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICAgIHZhciBjYWNoZXMgPSBycy5pbWdMYXllckNhY2hlcyA9IHJzLmltZ0xheWVyQ2FjaGVzIHx8IHt9O1xuXG4gICAgICBmb3IgKHZhciBsID0gbWluTHZsOyBsIDw9IG1heEx2bDsgbCsrKSB7XG4gICAgICAgIHZhciBsYXllciA9IGNhY2hlc1tsXTtcblxuICAgICAgICBpZiAoIWxheWVyKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gaWYgdXBkYXRlIGlzIGEgcmVxdWVzdCBmcm9tIHRoZSBlbGUgY2FjaGUsIHRoZW4gaXQgYWZmZWN0cyBvbmx5XG4gICAgICAgIC8vIHRoZSBtYXRjaGluZyBsZXZlbFxuXG5cbiAgICAgICAgaWYgKHJlcSAmJiBzZWxmLmdldEVsZUxldmVsRm9yTGF5ZXJMZXZlbChsYXllci5sZXZlbCkgIT09IHJlcS5sZXZlbCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdXBkYXRlKGxheWVyLCBlbGUsIHJlcSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIExUQ3AuaGF2ZUxheWVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGhhdmVMYXllcnMgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGwgPSBtaW5Mdmw7IGwgPD0gbWF4THZsOyBsKyspIHtcbiAgICAgIHZhciBsYXllcnMgPSBzZWxmLmxheWVyc0J5TGV2ZWxbbF07XG5cbiAgICAgIGlmIChsYXllcnMgJiYgbGF5ZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaGF2ZUxheWVycyA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBoYXZlTGF5ZXJzO1xuICB9O1xuXG4gIExUQ3AuaW52YWxpZGF0ZUVsZW1lbnRzID0gZnVuY3Rpb24gKGVsZXMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAoZWxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzZWxmLmxhc3RJbnZhbGlkYXRpb25UaW1lID0gcGVyZm9ybWFuY2VOb3coKTsgLy8gbG9nKCd1cGRhdGUgaW52YWxpZGF0ZSBsYXllciB0aW1lIGZyb20gZWxlcycpO1xuXG4gICAgaWYgKGVsZXMubGVuZ3RoID09PSAwIHx8ICFzZWxmLmhhdmVMYXllcnMoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNlbGYudXBkYXRlRWxlbWVudHNJbkxheWVycyhlbGVzLCBmdW5jdGlvbiBpbnZhbEFzc29jTGF5ZXJzKGxheWVyLCBlbGUsIHJlcSkge1xuICAgICAgc2VsZi5pbnZhbGlkYXRlTGF5ZXIobGF5ZXIpO1xuICAgIH0pO1xuICB9O1xuXG4gIExUQ3AuaW52YWxpZGF0ZUxheWVyID0gZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgLy8gbG9nKCd1cGRhdGUgaW52YWxpZGF0ZSBsYXllciB0aW1lJyk7XG4gICAgdGhpcy5sYXN0SW52YWxpZGF0aW9uVGltZSA9IHBlcmZvcm1hbmNlTm93KCk7XG5cbiAgICBpZiAobGF5ZXIuaW52YWxpZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gc2F2ZSBjeWNsZXNcblxuXG4gICAgdmFyIGx2bCA9IGxheWVyLmxldmVsO1xuICAgIHZhciBlbGVzID0gbGF5ZXIuZWxlcztcbiAgICB2YXIgbGF5ZXJzID0gdGhpcy5sYXllcnNCeUxldmVsW2x2bF07IC8vIGxvZygnaW52YWxpZGF0ZSBsYXllcicsIGxheWVyLmlkICk7XG5cbiAgICByZW1vdmVGcm9tQXJyYXkobGF5ZXJzLCBsYXllcik7IC8vIGxheWVyLmVsZXMgPSBbXTtcblxuICAgIGxheWVyLmVsZXNRdWV1ZSA9IFtdO1xuICAgIGxheWVyLmludmFsaWQgPSB0cnVlO1xuXG4gICAgaWYgKGxheWVyLnJlcGxhY2VtZW50KSB7XG4gICAgICBsYXllci5yZXBsYWNlbWVudC5pbnZhbGlkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjYWNoZXMgPSBlbGVzW2ldLl9wcml2YXRlLnJzY3JhdGNoLmltZ0xheWVyQ2FjaGVzO1xuXG4gICAgICBpZiAoY2FjaGVzKSB7XG4gICAgICAgIGNhY2hlc1tsdmxdID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgTFRDcC5yZWZpbmVFbGVtZW50VGV4dHVyZXMgPSBmdW5jdGlvbiAoZWxlcykge1xuICAgIHZhciBzZWxmID0gdGhpczsgLy8gbG9nKCdyZWZpbmUnLCBlbGVzLmxlbmd0aCk7XG5cbiAgICBzZWxmLnVwZGF0ZUVsZW1lbnRzSW5MYXllcnMoZWxlcywgZnVuY3Rpb24gcmVmaW5lRWFjaEVsZShsYXllciwgZWxlLCByZXEpIHtcbiAgICAgIHZhciByTHlyID0gbGF5ZXIucmVwbGFjZW1lbnQ7XG5cbiAgICAgIGlmICghckx5cikge1xuICAgICAgICByTHlyID0gbGF5ZXIucmVwbGFjZW1lbnQgPSBzZWxmLm1ha2VMYXllcihsYXllci5iYiwgbGF5ZXIubGV2ZWwpO1xuICAgICAgICByTHlyLnJlcGxhY2VzID0gbGF5ZXI7XG4gICAgICAgIHJMeXIuZWxlcyA9IGxheWVyLmVsZXM7IC8vIGxvZygnbWFrZSByZXBsYWNlbWVudCBsYXllciAlcyBmb3IgJXMgd2l0aCBsZXZlbCAlcycsIHJMeXIuaWQsIGxheWVyLmlkLCByTHlyLmxldmVsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFyTHlyLnJlcXMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByTHlyLmVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBzZWxmLnF1ZXVlTGF5ZXIockx5ciwgckx5ci5lbGVzW2ldKTtcbiAgICAgICAgfSAvLyBsb2coJ3F1ZXVlIHJlcGxhY2VtZW50IGxheWVyIHJlZmluZW1lbnQnLCByTHlyLmlkKTtcblxuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIExUQ3AuZW5xdWV1ZUVsZW1lbnRSZWZpbmVtZW50ID0gZnVuY3Rpb24gKGVsZSkge1xuXG4gICAgdGhpcy5lbGVUeHJEZXFzLm1lcmdlKGVsZSk7XG4gICAgdGhpcy5zY2hlZHVsZUVsZW1lbnRSZWZpbmVtZW50KCk7XG4gIH07XG5cbiAgTFRDcC5xdWV1ZUxheWVyID0gZnVuY3Rpb24gKGxheWVyLCBlbGUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHEgPSBzZWxmLmxheWVyc1F1ZXVlO1xuICAgIHZhciBlbGVzUSA9IGxheWVyLmVsZXNRdWV1ZTtcbiAgICB2YXIgaGFzSWQgPSBlbGVzUS5oYXNJZCA9IGVsZXNRLmhhc0lkIHx8IHt9OyAvLyBpZiBhIGxheWVyIGlzIGdvaW5nIHRvIGJlIHJlcGxhY2VkLCBxdWV1aW5nIGlzIGEgd2FzdGUgb2YgdGltZVxuXG4gICAgaWYgKGxheWVyLnJlcGxhY2VtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGVsZSkge1xuICAgICAgaWYgKGhhc0lkW2VsZS5pZCgpXSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGVsZXNRLnB1c2goZWxlKTtcbiAgICAgIGhhc0lkW2VsZS5pZCgpXSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGxheWVyLnJlcXMpIHtcbiAgICAgIGxheWVyLnJlcXMrKztcbiAgICAgIHEudXBkYXRlSXRlbShsYXllcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxheWVyLnJlcXMgPSAxO1xuICAgICAgcS5wdXNoKGxheWVyKTtcbiAgICB9XG4gIH07XG5cbiAgTFRDcC5kZXF1ZXVlID0gZnVuY3Rpb24gKHB4UmF0aW8pIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHEgPSBzZWxmLmxheWVyc1F1ZXVlO1xuICAgIHZhciBkZXFkID0gW107XG4gICAgdmFyIGVsZURlcXMgPSAwO1xuXG4gICAgd2hpbGUgKGVsZURlcXMgPCBtYXhEZXFTaXplKSB7XG4gICAgICBpZiAocS5zaXplKCkgPT09IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHZhciBsYXllciA9IHEucGVlaygpOyAvLyBpZiBhIGxheWVyIGhhcyBiZWVuIG9yIHdpbGwgYmUgcmVwbGFjZWQsIHRoZW4gZG9uJ3Qgd2FzdGUgdGltZSB3aXRoIGl0XG5cbiAgICAgIGlmIChsYXllci5yZXBsYWNlbWVudCkge1xuICAgICAgICAvLyBsb2coJ2xheWVyICVzIGluIHF1ZXVlIHNraXBwZWQgYi9jIGl0IGFscmVhZHkgaGFzIGEgcmVwbGFjZW1lbnQnLCBsYXllci5pZCk7XG4gICAgICAgIHEucG9wKCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvLyBpZiB0aGlzIGlzIGEgcmVwbGFjZW1lbnQgbGF5ZXIgdGhhdCBoYXMgYmVlbiBzdXBlcmNlZGVkLCB0aGVuIGZvcmdldCBpdFxuXG5cbiAgICAgIGlmIChsYXllci5yZXBsYWNlcyAmJiBsYXllciAhPT0gbGF5ZXIucmVwbGFjZXMucmVwbGFjZW1lbnQpIHtcbiAgICAgICAgLy8gbG9nKCdsYXllciBpcyBubyBsb25nZXIgdGhlIG1vc3QgdXB0b2RhdGUgcmVwbGFjZW1lbnQ7IGRlcXVldWVkJywgbGF5ZXIuaWQpXG4gICAgICAgIHEucG9wKCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobGF5ZXIuaW52YWxpZCkge1xuICAgICAgICAvLyBsb2coJ3JlcGxhY2VtZW50IGxheWVyICVzIGlzIGludmFsaWQ7IGRlcXVldWVkJywgbGF5ZXIuaWQpO1xuICAgICAgICBxLnBvcCgpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVsZSA9IGxheWVyLmVsZXNRdWV1ZS5zaGlmdCgpO1xuXG4gICAgICBpZiAoZWxlKSB7XG4gICAgICAgIC8vIGxvZygnZGVxdWV1ZSBsYXllciAlcycsIGxheWVyLmlkKTtcbiAgICAgICAgc2VsZi5kcmF3RWxlSW5MYXllcihsYXllciwgZWxlLCBsYXllci5sZXZlbCwgcHhSYXRpbyk7XG4gICAgICAgIGVsZURlcXMrKztcbiAgICAgIH1cblxuICAgICAgaWYgKGRlcWQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIHdlIG5lZWQgb25seSBvbmUgZW50cnkgaW4gZGVxZCB0byBxdWV1ZSByZWRyYXdpbmcgZXRjXG4gICAgICAgIGRlcWQucHVzaCh0cnVlKTtcbiAgICAgIH0gLy8gaWYgdGhlIGxheWVyIGhhcyBhbGwgaXRzIGVsZXMgZG9uZSwgdGhlbiByZW1vdmUgZnJvbSB0aGUgcXVldWVcblxuXG4gICAgICBpZiAobGF5ZXIuZWxlc1F1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBxLnBvcCgpO1xuICAgICAgICBsYXllci5yZXFzID0gMDsgLy8gbG9nKCdkZXF1ZXVlIG9mIGxheWVyICVzIGNvbXBsZXRlJywgbGF5ZXIuaWQpO1xuICAgICAgICAvLyB3aGVuIGEgcmVwbGFjZW1lbnQgbGF5ZXIgaXMgZGVxdWV1ZWQsIGl0IHJlcGxhY2VzIHRoZSBvbGQgbGF5ZXIgaW4gdGhlIGxldmVsXG5cbiAgICAgICAgaWYgKGxheWVyLnJlcGxhY2VzKSB7XG4gICAgICAgICAgc2VsZi5hcHBseUxheWVyUmVwbGFjZW1lbnQobGF5ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5yZXF1ZXN0UmVkcmF3KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlcWQ7XG4gIH07XG5cbiAgTFRDcC5hcHBseUxheWVyUmVwbGFjZW1lbnQgPSBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGxheWVyc0luTGV2ZWwgPSBzZWxmLmxheWVyc0J5TGV2ZWxbbGF5ZXIubGV2ZWxdO1xuICAgIHZhciByZXBsYWNlZCA9IGxheWVyLnJlcGxhY2VzO1xuICAgIHZhciBpbmRleCA9IGxheWVyc0luTGV2ZWwuaW5kZXhPZihyZXBsYWNlZCk7IC8vIGlmIHRoZSByZXBsYWNlZCBsYXllciBpcyBub3QgaW4gdGhlIGFjdGl2ZSBsaXN0IGZvciB0aGUgbGV2ZWwsIHRoZW4gcmVwbGFjaW5nXG4gICAgLy8gcmVmcyB3b3VsZCBiZSBhIG1pc3Rha2UgKGkuZS4gb3ZlcndyaXRpbmcgdGhlIHRydWUgYWN0aXZlIGxheWVyKVxuXG4gICAgaWYgKGluZGV4IDwgMCB8fCByZXBsYWNlZC5pbnZhbGlkKSB7XG4gICAgICAvLyBsb2coJ3JlcGxhY2VtZW50IGxheWVyIHdvdWxkIGhhdmUgbm8gZWZmZWN0JywgbGF5ZXIuaWQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxheWVyc0luTGV2ZWxbaW5kZXhdID0gbGF5ZXI7IC8vIHJlcGxhY2UgbGV2ZWwgcmVmXG4gICAgLy8gcmVwbGFjZSByZWZzIGluIGVsZXNcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5ZXIuZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIF9wID0gbGF5ZXIuZWxlc1tpXS5fcHJpdmF0ZTtcbiAgICAgIHZhciBjYWNoZSA9IF9wLmltZ0xheWVyQ2FjaGVzID0gX3AuaW1nTGF5ZXJDYWNoZXMgfHwge307XG5cbiAgICAgIGlmIChjYWNoZSkge1xuICAgICAgICBjYWNoZVtsYXllci5sZXZlbF0gPSBsYXllcjtcbiAgICAgIH1cbiAgICB9IC8vIGxvZygnYXBwbHkgcmVwbGFjZW1lbnQgbGF5ZXIgJXMgb3ZlciAlcycsIGxheWVyLmlkLCByZXBsYWNlZC5pZCk7XG5cblxuICAgIHNlbGYucmVxdWVzdFJlZHJhdygpO1xuICB9O1xuXG4gIExUQ3AucmVxdWVzdFJlZHJhdyA9IGRlYm91bmNlXzEoZnVuY3Rpb24gKCkge1xuICAgIHZhciByID0gdGhpcy5yZW5kZXJlcjtcbiAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgICByLnJlZHJhd0hpbnQoJ2RyYWcnLCB0cnVlKTtcbiAgICByLnJlZHJhdygpO1xuICB9LCAxMDApO1xuICBMVENwLnNldHVwRGVxdWV1ZWluZyA9IGRlZnMuc2V0dXBEZXF1ZXVlaW5nKHtcbiAgICBkZXFSZWRyYXdUaHJlc2hvbGQ6IGRlcVJlZHJhd1RocmVzaG9sZCxcbiAgICBkZXFDb3N0OiBkZXFDb3N0LFxuICAgIGRlcUF2Z0Nvc3Q6IGRlcUF2Z0Nvc3QsXG4gICAgZGVxTm9EcmF3Q29zdDogZGVxTm9EcmF3Q29zdCxcbiAgICBkZXFGYXN0Q29zdDogZGVxRmFzdENvc3QsXG4gICAgZGVxOiBmdW5jdGlvbiBkZXEoc2VsZiwgcHhSYXRpbykge1xuICAgICAgcmV0dXJuIHNlbGYuZGVxdWV1ZShweFJhdGlvKTtcbiAgICB9LFxuICAgIG9uRGVxZDogbm9vcCQxLFxuICAgIHNob3VsZFJlZHJhdzogdHJ1ZWlmeSxcbiAgICBwcmlvcml0eTogZnVuY3Rpb24gcHJpb3JpdHkoc2VsZikge1xuICAgICAgcmV0dXJuIHNlbGYucmVuZGVyZXIuYmVmb3JlUmVuZGVyUHJpb3JpdGllcy5seXJUeHJEZXE7XG4gICAgfVxuICB9KTtcblxuICB2YXIgQ1JwJGEgPSB7fTtcbiAgdmFyIGltcGw7XG5cbiAgZnVuY3Rpb24gcG9seWdvbihjb250ZXh0LCBwb2ludHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHB0ID0gcG9pbnRzW2ldO1xuICAgICAgY29udGV4dC5saW5lVG8ocHQueCwgcHQueSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdHJpYW5nbGVCYWNrY3VydmUoY29udGV4dCwgcG9pbnRzLCBjb250cm9sUG9pbnQpIHtcbiAgICB2YXIgZmlyc3RQdDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcHQgPSBwb2ludHNbaV07XG5cbiAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgIGZpcnN0UHQgPSBwdDtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5saW5lVG8ocHQueCwgcHQueSk7XG4gICAgfVxuXG4gICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKGNvbnRyb2xQb2ludC54LCBjb250cm9sUG9pbnQueSwgZmlyc3RQdC54LCBmaXJzdFB0LnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJpYW5nbGVUZWUoY29udGV4dCwgdHJpYW5nbGVQb2ludHMsIHRlZVBvaW50cykge1xuICAgIGlmIChjb250ZXh0LmJlZ2luUGF0aCkge1xuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICB9XG5cbiAgICB2YXIgdHJpUHRzID0gdHJpYW5nbGVQb2ludHM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyaVB0cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHB0ID0gdHJpUHRzW2ldO1xuICAgICAgY29udGV4dC5saW5lVG8ocHQueCwgcHQueSk7XG4gICAgfVxuXG4gICAgdmFyIHRlZVB0cyA9IHRlZVBvaW50cztcbiAgICB2YXIgZmlyc3RUZWVQdCA9IHRlZVBvaW50c1swXTtcbiAgICBjb250ZXh0Lm1vdmVUbyhmaXJzdFRlZVB0LngsIGZpcnN0VGVlUHQueSk7XG5cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRlZVB0cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHB0ID0gdGVlUHRzW2ldO1xuICAgICAgY29udGV4dC5saW5lVG8ocHQueCwgcHQueSk7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRleHQuY2xvc2VQYXRoKSB7XG4gICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNpcmNsZVRyaWFuZ2xlKGNvbnRleHQsIHRyaWFuZ2xlUG9pbnRzLCByeCwgcnksIHIpIHtcbiAgICBpZiAoY29udGV4dC5iZWdpblBhdGgpIHtcbiAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgfVxuXG4gICAgY29udGV4dC5hcmMocngsIHJ5LCByLCAwLCBNYXRoLlBJICogMiwgZmFsc2UpO1xuICAgIHZhciB0cmlQdHMgPSB0cmlhbmdsZVBvaW50cztcbiAgICB2YXIgZmlyc3RUclB0ID0gdHJpUHRzWzBdO1xuICAgIGNvbnRleHQubW92ZVRvKGZpcnN0VHJQdC54LCBmaXJzdFRyUHQueSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyaVB0cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHB0ID0gdHJpUHRzW2ldO1xuICAgICAgY29udGV4dC5saW5lVG8ocHQueCwgcHQueSk7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRleHQuY2xvc2VQYXRoKSB7XG4gICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNpcmNsZShjb250ZXh0LCByeCwgcnksIHIpIHtcbiAgICBjb250ZXh0LmFyYyhyeCwgcnksIHIsIDAsIE1hdGguUEkgKiAyLCBmYWxzZSk7XG4gIH1cblxuICBDUnAkYS5hcnJvd1NoYXBlSW1wbCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIChpbXBsIHx8IChpbXBsID0ge1xuICAgICAgJ3BvbHlnb24nOiBwb2x5Z29uLFxuICAgICAgJ3RyaWFuZ2xlLWJhY2tjdXJ2ZSc6IHRyaWFuZ2xlQmFja2N1cnZlLFxuICAgICAgJ3RyaWFuZ2xlLXRlZSc6IHRyaWFuZ2xlVGVlLFxuICAgICAgJ2NpcmNsZS10cmlhbmdsZSc6IGNpcmNsZVRyaWFuZ2xlLFxuICAgICAgJ3RyaWFuZ2xlLWNyb3NzJzogdHJpYW5nbGVUZWUsXG4gICAgICAnY2lyY2xlJzogY2lyY2xlXG4gICAgfSkpW25hbWVdO1xuICB9O1xuXG4gIHZhciBDUnAkOSA9IHt9O1xuXG4gIENScCQ5LmRyYXdFbGVtZW50ID0gZnVuY3Rpb24gKGNvbnRleHQsIGVsZSwgc2hpZnRUb09yaWdpbldpdGhCYiwgc2hvd0xhYmVsLCBzaG93T3ZlcmxheSwgc2hvd09wYWNpdHkpIHtcbiAgICB2YXIgciA9IHRoaXM7XG5cbiAgICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgICByLmRyYXdOb2RlKGNvbnRleHQsIGVsZSwgc2hpZnRUb09yaWdpbldpdGhCYiwgc2hvd0xhYmVsLCBzaG93T3ZlcmxheSwgc2hvd09wYWNpdHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByLmRyYXdFZGdlKGNvbnRleHQsIGVsZSwgc2hpZnRUb09yaWdpbldpdGhCYiwgc2hvd0xhYmVsLCBzaG93T3ZlcmxheSwgc2hvd09wYWNpdHkpO1xuICAgIH1cbiAgfTtcblxuICBDUnAkOS5kcmF3RWxlbWVudE92ZXJsYXkgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlKSB7XG4gICAgdmFyIHIgPSB0aGlzO1xuXG4gICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgci5kcmF3Tm9kZU92ZXJsYXkoY29udGV4dCwgZWxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgci5kcmF3RWRnZU92ZXJsYXkoY29udGV4dCwgZWxlKTtcbiAgICB9XG4gIH07XG5cbiAgQ1JwJDkuZHJhd0VsZW1lbnRVbmRlcmxheSA9IGZ1bmN0aW9uIChjb250ZXh0LCBlbGUpIHtcbiAgICB2YXIgciA9IHRoaXM7XG5cbiAgICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgICByLmRyYXdOb2RlVW5kZXJsYXkoY29udGV4dCwgZWxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgci5kcmF3RWRnZVVuZGVybGF5KGNvbnRleHQsIGVsZSk7XG4gICAgfVxuICB9O1xuXG4gIENScCQ5LmRyYXdDYWNoZWRFbGVtZW50UG9ydGlvbiA9IGZ1bmN0aW9uIChjb250ZXh0LCBlbGUsIGVsZVR4ckNhY2hlLCBweFJhdGlvLCBsdmwsIHJlYXNvbiwgZ2V0Um90YXRpb24sIGdldE9wYWNpdHkpIHtcbiAgICB2YXIgciA9IHRoaXM7XG4gICAgdmFyIGJiID0gZWxlVHhyQ2FjaGUuZ2V0Qm91bmRpbmdCb3goZWxlKTtcblxuICAgIGlmIChiYi53ID09PSAwIHx8IGJiLmggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGlnbm9yZSB6ZXJvIHNpemUgY2FzZVxuXG5cbiAgICB2YXIgZWxlQ2FjaGUgPSBlbGVUeHJDYWNoZS5nZXRFbGVtZW50KGVsZSwgYmIsIHB4UmF0aW8sIGx2bCwgcmVhc29uKTtcblxuICAgIGlmIChlbGVDYWNoZSAhPSBudWxsKSB7XG4gICAgICB2YXIgb3BhY2l0eSA9IGdldE9wYWNpdHkociwgZWxlKTtcblxuICAgICAgaWYgKG9wYWNpdHkgPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgdGhldGEgPSBnZXRSb3RhdGlvbihyLCBlbGUpO1xuICAgICAgdmFyIHgxID0gYmIueDEsXG4gICAgICAgICAgeTEgPSBiYi55MSxcbiAgICAgICAgICB3ID0gYmIudyxcbiAgICAgICAgICBoID0gYmIuaDtcbiAgICAgIHZhciB4LCB5LCBzeCwgc3ksIHNtb290aDtcblxuICAgICAgaWYgKHRoZXRhICE9PSAwKSB7XG4gICAgICAgIHZhciByb3RQdCA9IGVsZVR4ckNhY2hlLmdldFJvdGF0aW9uUG9pbnQoZWxlKTtcbiAgICAgICAgc3ggPSByb3RQdC54O1xuICAgICAgICBzeSA9IHJvdFB0Lnk7XG4gICAgICAgIGNvbnRleHQudHJhbnNsYXRlKHN4LCBzeSk7XG4gICAgICAgIGNvbnRleHQucm90YXRlKHRoZXRhKTtcbiAgICAgICAgc21vb3RoID0gci5nZXRJbWdTbW9vdGhpbmcoY29udGV4dCk7XG5cbiAgICAgICAgaWYgKCFzbW9vdGgpIHtcbiAgICAgICAgICByLnNldEltZ1Ntb290aGluZyhjb250ZXh0LCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvZmYgPSBlbGVUeHJDYWNoZS5nZXRSb3RhdGlvbk9mZnNldChlbGUpO1xuICAgICAgICB4ID0gb2ZmLng7XG4gICAgICAgIHkgPSBvZmYueTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHggPSB4MTtcbiAgICAgICAgeSA9IHkxO1xuICAgICAgfVxuXG4gICAgICB2YXIgb2xkR2xvYmFsQWxwaGE7XG5cbiAgICAgIGlmIChvcGFjaXR5ICE9PSAxKSB7XG4gICAgICAgIG9sZEdsb2JhbEFscGhhID0gY29udGV4dC5nbG9iYWxBbHBoYTtcbiAgICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IG9sZEdsb2JhbEFscGhhICogb3BhY2l0eTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5kcmF3SW1hZ2UoZWxlQ2FjaGUudGV4dHVyZS5jYW52YXMsIGVsZUNhY2hlLngsIDAsIGVsZUNhY2hlLndpZHRoLCBlbGVDYWNoZS5oZWlnaHQsIHgsIHksIHcsIGgpO1xuXG4gICAgICBpZiAob3BhY2l0eSAhPT0gMSkge1xuICAgICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gb2xkR2xvYmFsQWxwaGE7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGV0YSAhPT0gMCkge1xuICAgICAgICBjb250ZXh0LnJvdGF0ZSgtdGhldGEpO1xuICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZSgtc3gsIC1zeSk7XG5cbiAgICAgICAgaWYgKCFzbW9vdGgpIHtcbiAgICAgICAgICByLnNldEltZ1Ntb290aGluZyhjb250ZXh0LCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWxlVHhyQ2FjaGUuZHJhd0VsZW1lbnQoY29udGV4dCwgZWxlKTsgLy8gZGlyZWN0IGRyYXcgZmFsbGJhY2tcbiAgICB9XG4gIH07XG5cbiAgdmFyIGdldFplcm9Sb3RhdGlvbiA9IGZ1bmN0aW9uIGdldFplcm9Sb3RhdGlvbigpIHtcbiAgICByZXR1cm4gMDtcbiAgfTtcblxuICB2YXIgZ2V0TGFiZWxSb3RhdGlvbiA9IGZ1bmN0aW9uIGdldExhYmVsUm90YXRpb24ociwgZWxlKSB7XG4gICAgcmV0dXJuIHIuZ2V0VGV4dEFuZ2xlKGVsZSwgbnVsbCk7XG4gIH07XG5cbiAgdmFyIGdldFNvdXJjZUxhYmVsUm90YXRpb24gPSBmdW5jdGlvbiBnZXRTb3VyY2VMYWJlbFJvdGF0aW9uKHIsIGVsZSkge1xuICAgIHJldHVybiByLmdldFRleHRBbmdsZShlbGUsICdzb3VyY2UnKTtcbiAgfTtcblxuICB2YXIgZ2V0VGFyZ2V0TGFiZWxSb3RhdGlvbiA9IGZ1bmN0aW9uIGdldFRhcmdldExhYmVsUm90YXRpb24ociwgZWxlKSB7XG4gICAgcmV0dXJuIHIuZ2V0VGV4dEFuZ2xlKGVsZSwgJ3RhcmdldCcpO1xuICB9O1xuXG4gIHZhciBnZXRPcGFjaXR5ID0gZnVuY3Rpb24gZ2V0T3BhY2l0eShyLCBlbGUpIHtcbiAgICByZXR1cm4gZWxlLmVmZmVjdGl2ZU9wYWNpdHkoKTtcbiAgfTtcblxuICB2YXIgZ2V0VGV4dE9wYWNpdHkgPSBmdW5jdGlvbiBnZXRUZXh0T3BhY2l0eShlLCBlbGUpIHtcbiAgICByZXR1cm4gZWxlLnBzdHlsZSgndGV4dC1vcGFjaXR5JykucGZWYWx1ZSAqIGVsZS5lZmZlY3RpdmVPcGFjaXR5KCk7XG4gIH07XG5cbiAgQ1JwJDkuZHJhd0NhY2hlZEVsZW1lbnQgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlLCBweFJhdGlvLCBleHRlbnQsIGx2bCwgcmVxdWVzdEhpZ2hRdWFsaXR5KSB7XG4gICAgdmFyIHIgPSB0aGlzO1xuICAgIHZhciBfciRkYXRhID0gci5kYXRhLFxuICAgICAgICBlbGVUeHJDYWNoZSA9IF9yJGRhdGEuZWxlVHhyQ2FjaGUsXG4gICAgICAgIGxibFR4ckNhY2hlID0gX3IkZGF0YS5sYmxUeHJDYWNoZSxcbiAgICAgICAgc2xiVHhyQ2FjaGUgPSBfciRkYXRhLnNsYlR4ckNhY2hlLFxuICAgICAgICB0bGJUeHJDYWNoZSA9IF9yJGRhdGEudGxiVHhyQ2FjaGU7XG4gICAgdmFyIGJiID0gZWxlLmJvdW5kaW5nQm94KCk7XG4gICAgdmFyIHJlYXNvbiA9IHJlcXVlc3RIaWdoUXVhbGl0eSA9PT0gdHJ1ZSA/IGVsZVR4ckNhY2hlLnJlYXNvbnMuaGlnaFF1YWxpdHkgOiBudWxsO1xuXG4gICAgaWYgKGJiLncgPT09IDAgfHwgYmIuaCA9PT0gMCB8fCAhZWxlLnZpc2libGUoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghZXh0ZW50IHx8IGJvdW5kaW5nQm94ZXNJbnRlcnNlY3QoYmIsIGV4dGVudCkpIHtcbiAgICAgIHZhciBpc0VkZ2UgPSBlbGUuaXNFZGdlKCk7XG5cbiAgICAgIHZhciBiYWRMaW5lID0gZWxlLmVsZW1lbnQoKS5fcHJpdmF0ZS5yc2NyYXRjaC5iYWRMaW5lO1xuXG4gICAgICByLmRyYXdFbGVtZW50VW5kZXJsYXkoY29udGV4dCwgZWxlKTtcbiAgICAgIHIuZHJhd0NhY2hlZEVsZW1lbnRQb3J0aW9uKGNvbnRleHQsIGVsZSwgZWxlVHhyQ2FjaGUsIHB4UmF0aW8sIGx2bCwgcmVhc29uLCBnZXRaZXJvUm90YXRpb24sIGdldE9wYWNpdHkpO1xuXG4gICAgICBpZiAoIWlzRWRnZSB8fCAhYmFkTGluZSkge1xuICAgICAgICByLmRyYXdDYWNoZWRFbGVtZW50UG9ydGlvbihjb250ZXh0LCBlbGUsIGxibFR4ckNhY2hlLCBweFJhdGlvLCBsdmwsIHJlYXNvbiwgZ2V0TGFiZWxSb3RhdGlvbiwgZ2V0VGV4dE9wYWNpdHkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNFZGdlICYmICFiYWRMaW5lKSB7XG4gICAgICAgIHIuZHJhd0NhY2hlZEVsZW1lbnRQb3J0aW9uKGNvbnRleHQsIGVsZSwgc2xiVHhyQ2FjaGUsIHB4UmF0aW8sIGx2bCwgcmVhc29uLCBnZXRTb3VyY2VMYWJlbFJvdGF0aW9uLCBnZXRUZXh0T3BhY2l0eSk7XG4gICAgICAgIHIuZHJhd0NhY2hlZEVsZW1lbnRQb3J0aW9uKGNvbnRleHQsIGVsZSwgdGxiVHhyQ2FjaGUsIHB4UmF0aW8sIGx2bCwgcmVhc29uLCBnZXRUYXJnZXRMYWJlbFJvdGF0aW9uLCBnZXRUZXh0T3BhY2l0eSk7XG4gICAgICB9XG5cbiAgICAgIHIuZHJhd0VsZW1lbnRPdmVybGF5KGNvbnRleHQsIGVsZSk7XG4gICAgfVxuICB9O1xuXG4gIENScCQ5LmRyYXdFbGVtZW50cyA9IGZ1bmN0aW9uIChjb250ZXh0LCBlbGVzKSB7XG4gICAgdmFyIHIgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgIHIuZHJhd0VsZW1lbnQoY29udGV4dCwgZWxlKTtcbiAgICB9XG4gIH07XG5cbiAgQ1JwJDkuZHJhd0NhY2hlZEVsZW1lbnRzID0gZnVuY3Rpb24gKGNvbnRleHQsIGVsZXMsIHB4UmF0aW8sIGV4dGVudCkge1xuICAgIHZhciByID0gdGhpcztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICByLmRyYXdDYWNoZWRFbGVtZW50KGNvbnRleHQsIGVsZSwgcHhSYXRpbywgZXh0ZW50KTtcbiAgICB9XG4gIH07XG5cbiAgQ1JwJDkuZHJhd0NhY2hlZE5vZGVzID0gZnVuY3Rpb24gKGNvbnRleHQsIGVsZXMsIHB4UmF0aW8sIGV4dGVudCkge1xuICAgIHZhciByID0gdGhpcztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG5cbiAgICAgIGlmICghZWxlLmlzTm9kZSgpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICByLmRyYXdDYWNoZWRFbGVtZW50KGNvbnRleHQsIGVsZSwgcHhSYXRpbywgZXh0ZW50KTtcbiAgICB9XG4gIH07XG5cbiAgQ1JwJDkuZHJhd0xheWVyZWRFbGVtZW50cyA9IGZ1bmN0aW9uIChjb250ZXh0LCBlbGVzLCBweFJhdGlvLCBleHRlbnQpIHtcbiAgICB2YXIgciA9IHRoaXM7XG4gICAgdmFyIGxheWVycyA9IHIuZGF0YS5seXJUeHJDYWNoZS5nZXRMYXllcnMoZWxlcywgcHhSYXRpbyk7XG5cbiAgICBpZiAobGF5ZXJzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbGF5ZXIgPSBsYXllcnNbaV07XG4gICAgICAgIHZhciBiYiA9IGxheWVyLmJiO1xuXG4gICAgICAgIGlmIChiYi53ID09PSAwIHx8IGJiLmggPT09IDApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGxheWVyLmNhbnZhcywgYmIueDEsIGJiLnkxLCBiYi53LCBiYi5oKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZmFsbCBiYWNrIG9uIHBsYWluIGNhY2hpbmcgaWYgbm8gbGF5ZXJzXG4gICAgICByLmRyYXdDYWNoZWRFbGVtZW50cyhjb250ZXh0LCBlbGVzLCBweFJhdGlvLCBleHRlbnQpO1xuICAgIH1cbiAgfTtcblxuICAvKiBnbG9iYWwgUGF0aDJEICovXG4gIHZhciBDUnAkOCA9IHt9O1xuXG4gIENScCQ4LmRyYXdFZGdlID0gZnVuY3Rpb24gKGNvbnRleHQsIGVkZ2UsIHNoaWZ0VG9PcmlnaW5XaXRoQmIpIHtcbiAgICB2YXIgZHJhd0xhYmVsID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB0cnVlO1xuICAgIHZhciBzaG91bGREcmF3T3ZlcmxheSA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogdHJ1ZTtcbiAgICB2YXIgc2hvdWxkRHJhd09wYWNpdHkgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IHRydWU7XG4gICAgdmFyIHIgPSB0aGlzO1xuICAgIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG5cbiAgICBpZiAoc2hvdWxkRHJhd09wYWNpdHkgJiYgIWVkZ2UudmlzaWJsZSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBpZiBiZXppZXIgY3RybCBwdHMgY2FuIG5vdCBiZSBjYWxjdWxhdGVkLCB0aGVuIGRpZVxuXG5cbiAgICBpZiAocnMuYmFkTGluZSB8fCBycy5hbGxwdHMgPT0gbnVsbCB8fCBpc05hTihycy5hbGxwdHNbMF0pKSB7XG4gICAgICAvLyBpc05hTiBpbiBjYXNlIGVkZ2UgaXMgaW1wb3NzaWJsZSBhbmQgYnJvd3NlciBidWdzIChlLmcuIHNhZmFyaSlcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYmI7XG5cbiAgICBpZiAoc2hpZnRUb09yaWdpbldpdGhCYikge1xuICAgICAgYmIgPSBzaGlmdFRvT3JpZ2luV2l0aEJiO1xuICAgICAgY29udGV4dC50cmFuc2xhdGUoLWJiLngxLCAtYmIueTEpO1xuICAgIH1cblxuICAgIHZhciBvcGFjaXR5ID0gc2hvdWxkRHJhd09wYWNpdHkgPyBlZGdlLnBzdHlsZSgnb3BhY2l0eScpLnZhbHVlIDogMTtcbiAgICB2YXIgbGluZU9wYWNpdHkgPSBzaG91bGREcmF3T3BhY2l0eSA/IGVkZ2UucHN0eWxlKCdsaW5lLW9wYWNpdHknKS52YWx1ZSA6IDE7XG4gICAgdmFyIGN1cnZlU3R5bGUgPSBlZGdlLnBzdHlsZSgnY3VydmUtc3R5bGUnKS52YWx1ZTtcbiAgICB2YXIgbGluZVN0eWxlID0gZWRnZS5wc3R5bGUoJ2xpbmUtc3R5bGUnKS52YWx1ZTtcbiAgICB2YXIgZWRnZVdpZHRoID0gZWRnZS5wc3R5bGUoJ3dpZHRoJykucGZWYWx1ZTtcbiAgICB2YXIgbGluZUNhcCA9IGVkZ2UucHN0eWxlKCdsaW5lLWNhcCcpLnZhbHVlO1xuICAgIHZhciBlZmZlY3RpdmVMaW5lT3BhY2l0eSA9IG9wYWNpdHkgKiBsaW5lT3BhY2l0eTsgLy8gc2VwYXJhdGUgYXJyb3cgb3BhY2l0eSB3b3VsZCByZXF1aXJlIGFycm93LW9wYWNpdHkgcHJvcGVydHlcblxuICAgIHZhciBlZmZlY3RpdmVBcnJvd09wYWNpdHkgPSBvcGFjaXR5ICogbGluZU9wYWNpdHk7XG5cbiAgICB2YXIgZHJhd0xpbmUgPSBmdW5jdGlvbiBkcmF3TGluZSgpIHtcbiAgICAgIHZhciBzdHJva2VPcGFjaXR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBlZmZlY3RpdmVMaW5lT3BhY2l0eTtcblxuICAgICAgaWYgKGN1cnZlU3R5bGUgPT09ICdzdHJhaWdodC10cmlhbmdsZScpIHtcbiAgICAgICAgci5lbGVTdHJva2VTdHlsZShjb250ZXh0LCBlZGdlLCBzdHJva2VPcGFjaXR5KTtcbiAgICAgICAgci5kcmF3RWRnZVRyaWFuZ2xlUGF0aChlZGdlLCBjb250ZXh0LCBycy5hbGxwdHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSBlZGdlV2lkdGg7XG4gICAgICAgIGNvbnRleHQubGluZUNhcCA9IGxpbmVDYXA7XG4gICAgICAgIHIuZWxlU3Ryb2tlU3R5bGUoY29udGV4dCwgZWRnZSwgc3Ryb2tlT3BhY2l0eSk7XG4gICAgICAgIHIuZHJhd0VkZ2VQYXRoKGVkZ2UsIGNvbnRleHQsIHJzLmFsbHB0cywgbGluZVN0eWxlKTtcbiAgICAgICAgY29udGV4dC5saW5lQ2FwID0gJ2J1dHQnOyAvLyByZXNldCBmb3Igb3RoZXIgZHJhd2luZyBmdW5jdGlvbnNcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGRyYXdPdmVybGF5ID0gZnVuY3Rpb24gZHJhd092ZXJsYXkoKSB7XG4gICAgICBpZiAoIXNob3VsZERyYXdPdmVybGF5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgci5kcmF3RWRnZU92ZXJsYXkoY29udGV4dCwgZWRnZSk7XG4gICAgfTtcblxuICAgIHZhciBkcmF3VW5kZXJsYXkgPSBmdW5jdGlvbiBkcmF3VW5kZXJsYXkoKSB7XG4gICAgICBpZiAoIXNob3VsZERyYXdPdmVybGF5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgci5kcmF3RWRnZVVuZGVybGF5KGNvbnRleHQsIGVkZ2UpO1xuICAgIH07XG5cbiAgICB2YXIgZHJhd0Fycm93cyA9IGZ1bmN0aW9uIGRyYXdBcnJvd3MoKSB7XG4gICAgICB2YXIgYXJyb3dPcGFjaXR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBlZmZlY3RpdmVBcnJvd09wYWNpdHk7XG4gICAgICByLmRyYXdBcnJvd2hlYWRzKGNvbnRleHQsIGVkZ2UsIGFycm93T3BhY2l0eSk7XG4gICAgfTtcblxuICAgIHZhciBkcmF3VGV4dCA9IGZ1bmN0aW9uIGRyYXdUZXh0KCkge1xuICAgICAgci5kcmF3RWxlbWVudFRleHQoY29udGV4dCwgZWRnZSwgbnVsbCwgZHJhd0xhYmVsKTtcbiAgICB9O1xuXG4gICAgY29udGV4dC5saW5lSm9pbiA9ICdyb3VuZCc7XG4gICAgdmFyIGdob3N0ID0gZWRnZS5wc3R5bGUoJ2dob3N0JykudmFsdWUgPT09ICd5ZXMnO1xuXG4gICAgaWYgKGdob3N0KSB7XG4gICAgICB2YXIgZ3ggPSBlZGdlLnBzdHlsZSgnZ2hvc3Qtb2Zmc2V0LXgnKS5wZlZhbHVlO1xuICAgICAgdmFyIGd5ID0gZWRnZS5wc3R5bGUoJ2dob3N0LW9mZnNldC15JykucGZWYWx1ZTtcbiAgICAgIHZhciBnaG9zdE9wYWNpdHkgPSBlZGdlLnBzdHlsZSgnZ2hvc3Qtb3BhY2l0eScpLnZhbHVlO1xuICAgICAgdmFyIGVmZmVjdGl2ZUdob3N0T3BhY2l0eSA9IGVmZmVjdGl2ZUxpbmVPcGFjaXR5ICogZ2hvc3RPcGFjaXR5O1xuICAgICAgY29udGV4dC50cmFuc2xhdGUoZ3gsIGd5KTtcbiAgICAgIGRyYXdMaW5lKGVmZmVjdGl2ZUdob3N0T3BhY2l0eSk7XG4gICAgICBkcmF3QXJyb3dzKGVmZmVjdGl2ZUdob3N0T3BhY2l0eSk7XG4gICAgICBjb250ZXh0LnRyYW5zbGF0ZSgtZ3gsIC1neSk7XG4gICAgfVxuXG4gICAgZHJhd1VuZGVybGF5KCk7XG4gICAgZHJhd0xpbmUoKTtcbiAgICBkcmF3QXJyb3dzKCk7XG4gICAgZHJhd092ZXJsYXkoKTtcbiAgICBkcmF3VGV4dCgpO1xuXG4gICAgaWYgKHNoaWZ0VG9PcmlnaW5XaXRoQmIpIHtcbiAgICAgIGNvbnRleHQudHJhbnNsYXRlKGJiLngxLCBiYi55MSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBkcmF3RWRnZU92ZXJsYXlVbmRlcmxheSA9IGZ1bmN0aW9uIGRyYXdFZGdlT3ZlcmxheVVuZGVybGF5KG92ZXJsYXlPclVuZGVybGF5KSB7XG4gICAgaWYgKCFbJ292ZXJsYXknLCAndW5kZXJsYXknXS5pbmNsdWRlcyhvdmVybGF5T3JVbmRlcmxheSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdGF0ZScpO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoY29udGV4dCwgZWRnZSkge1xuICAgICAgaWYgKCFlZGdlLnZpc2libGUoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBvcGFjaXR5ID0gZWRnZS5wc3R5bGUoXCJcIi5jb25jYXQob3ZlcmxheU9yVW5kZXJsYXksIFwiLW9wYWNpdHlcIikpLnZhbHVlO1xuXG4gICAgICBpZiAob3BhY2l0eSA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciByID0gdGhpcztcbiAgICAgIHZhciB1c2VQYXRocyA9IHIudXNlUGF0aHMoKTtcbiAgICAgIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgICB2YXIgcGFkZGluZyA9IGVkZ2UucHN0eWxlKFwiXCIuY29uY2F0KG92ZXJsYXlPclVuZGVybGF5LCBcIi1wYWRkaW5nXCIpKS5wZlZhbHVlO1xuICAgICAgdmFyIHdpZHRoID0gMiAqIHBhZGRpbmc7XG4gICAgICB2YXIgY29sb3IgPSBlZGdlLnBzdHlsZShcIlwiLmNvbmNhdChvdmVybGF5T3JVbmRlcmxheSwgXCItY29sb3JcIikpLnZhbHVlO1xuICAgICAgY29udGV4dC5saW5lV2lkdGggPSB3aWR0aDtcblxuICAgICAgaWYgKHJzLmVkZ2VUeXBlID09PSAnc2VsZicgJiYgIXVzZVBhdGhzKSB7XG4gICAgICAgIGNvbnRleHQubGluZUNhcCA9ICdidXR0JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRleHQubGluZUNhcCA9ICdyb3VuZCc7XG4gICAgICB9XG5cbiAgICAgIHIuY29sb3JTdHJva2VTdHlsZShjb250ZXh0LCBjb2xvclswXSwgY29sb3JbMV0sIGNvbG9yWzJdLCBvcGFjaXR5KTtcbiAgICAgIHIuZHJhd0VkZ2VQYXRoKGVkZ2UsIGNvbnRleHQsIHJzLmFsbHB0cywgJ3NvbGlkJyk7XG4gICAgfTtcbiAgfTtcblxuICBDUnAkOC5kcmF3RWRnZU92ZXJsYXkgPSBkcmF3RWRnZU92ZXJsYXlVbmRlcmxheSgnb3ZlcmxheScpO1xuICBDUnAkOC5kcmF3RWRnZVVuZGVybGF5ID0gZHJhd0VkZ2VPdmVybGF5VW5kZXJsYXkoJ3VuZGVybGF5Jyk7XG5cbiAgQ1JwJDguZHJhd0VkZ2VQYXRoID0gZnVuY3Rpb24gKGVkZ2UsIGNvbnRleHQsIHB0cywgdHlwZSkge1xuICAgIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgdmFyIGNhbnZhc0N4dCA9IGNvbnRleHQ7XG4gICAgdmFyIHBhdGg7XG4gICAgdmFyIHBhdGhDYWNoZUhpdCA9IGZhbHNlO1xuICAgIHZhciB1c2VQYXRocyA9IHRoaXMudXNlUGF0aHMoKTtcbiAgICB2YXIgbGluZURhc2hQYXR0ZXJuID0gZWRnZS5wc3R5bGUoJ2xpbmUtZGFzaC1wYXR0ZXJuJykucGZWYWx1ZTtcbiAgICB2YXIgbGluZURhc2hPZmZzZXQgPSBlZGdlLnBzdHlsZSgnbGluZS1kYXNoLW9mZnNldCcpLnBmVmFsdWU7XG5cbiAgICBpZiAodXNlUGF0aHMpIHtcbiAgICAgIHZhciBwYXRoQ2FjaGVLZXkgPSBwdHMuam9pbignJCcpO1xuICAgICAgdmFyIGtleU1hdGNoZXMgPSBycy5wYXRoQ2FjaGVLZXkgJiYgcnMucGF0aENhY2hlS2V5ID09PSBwYXRoQ2FjaGVLZXk7XG5cbiAgICAgIGlmIChrZXlNYXRjaGVzKSB7XG4gICAgICAgIHBhdGggPSBjb250ZXh0ID0gcnMucGF0aENhY2hlO1xuICAgICAgICBwYXRoQ2FjaGVIaXQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGF0aCA9IGNvbnRleHQgPSBuZXcgUGF0aDJEKCk7XG4gICAgICAgIHJzLnBhdGhDYWNoZUtleSA9IHBhdGhDYWNoZUtleTtcbiAgICAgICAgcnMucGF0aENhY2hlID0gcGF0aDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2FudmFzQ3h0LnNldExpbmVEYXNoKSB7XG4gICAgICAvLyBmb3IgdmVyeSBvdXRvZmRhdGUgYnJvd3NlcnNcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdkb3R0ZWQnOlxuICAgICAgICAgIGNhbnZhc0N4dC5zZXRMaW5lRGFzaChbMSwgMV0pO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Rhc2hlZCc6XG4gICAgICAgICAgY2FudmFzQ3h0LnNldExpbmVEYXNoKGxpbmVEYXNoUGF0dGVybik7XG4gICAgICAgICAgY2FudmFzQ3h0LmxpbmVEYXNoT2Zmc2V0ID0gbGluZURhc2hPZmZzZXQ7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnc29saWQnOlxuICAgICAgICAgIGNhbnZhc0N4dC5zZXRMaW5lRGFzaChbXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFwYXRoQ2FjaGVIaXQgJiYgIXJzLmJhZExpbmUpIHtcbiAgICAgIGlmIChjb250ZXh0LmJlZ2luUGF0aCkge1xuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Lm1vdmVUbyhwdHNbMF0sIHB0c1sxXSk7XG5cbiAgICAgIHN3aXRjaCAocnMuZWRnZVR5cGUpIHtcbiAgICAgICAgY2FzZSAnYmV6aWVyJzpcbiAgICAgICAgY2FzZSAnc2VsZic6XG4gICAgICAgIGNhc2UgJ2NvbXBvdW5kJzpcbiAgICAgICAgY2FzZSAnbXVsdGliZXppZXInOlxuICAgICAgICAgIGZvciAodmFyIGkgPSAyOyBpICsgMyA8IHB0cy5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgICAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKHB0c1tpXSwgcHRzW2kgKyAxXSwgcHRzW2kgKyAyXSwgcHRzW2kgKyAzXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnc3RyYWlnaHQnOlxuICAgICAgICBjYXNlICdzZWdtZW50cyc6XG4gICAgICAgIGNhc2UgJ2hheXN0YWNrJzpcbiAgICAgICAgICBmb3IgKHZhciBfaSA9IDI7IF9pICsgMSA8IHB0cy5sZW5ndGg7IF9pICs9IDIpIHtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHB0c1tfaV0sIHB0c1tfaSArIDFdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb250ZXh0ID0gY2FudmFzQ3h0O1xuXG4gICAgaWYgKHVzZVBhdGhzKSB7XG4gICAgICBjb250ZXh0LnN0cm9rZShwYXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICB9IC8vIHJlc2V0IGFueSBsaW5lIGRhc2hlc1xuXG5cbiAgICBpZiAoY29udGV4dC5zZXRMaW5lRGFzaCkge1xuICAgICAgLy8gZm9yIHZlcnkgb3V0b2ZkYXRlIGJyb3dzZXJzXG4gICAgICBjb250ZXh0LnNldExpbmVEYXNoKFtdKTtcbiAgICB9XG4gIH07XG5cbiAgQ1JwJDguZHJhd0VkZ2VUcmlhbmdsZVBhdGggPSBmdW5jdGlvbiAoZWRnZSwgY29udGV4dCwgcHRzKSB7XG4gICAgLy8gdXNlIGxpbmUgc3Ryb2tlIHN0eWxlIGZvciB0cmlhbmdsZSBmaWxsIHN0eWxlXG4gICAgY29udGV4dC5maWxsU3R5bGUgPSBjb250ZXh0LnN0cm9rZVN0eWxlO1xuICAgIHZhciBlZGdlV2lkdGggPSBlZGdlLnBzdHlsZSgnd2lkdGgnKS5wZlZhbHVlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgKyAxIDwgcHRzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICB2YXIgdmVjdG9yID0gW3B0c1tpICsgMl0gLSBwdHNbaV0sIHB0c1tpICsgM10gLSBwdHNbaSArIDFdXTtcbiAgICAgIHZhciBsZW5ndGggPSBNYXRoLnNxcnQodmVjdG9yWzBdICogdmVjdG9yWzBdICsgdmVjdG9yWzFdICogdmVjdG9yWzFdKTtcbiAgICAgIHZhciBub3JtYWwgPSBbdmVjdG9yWzFdIC8gbGVuZ3RoLCAtdmVjdG9yWzBdIC8gbGVuZ3RoXTtcbiAgICAgIHZhciB0cmlhbmdsZUhlYWQgPSBbbm9ybWFsWzBdICogZWRnZVdpZHRoIC8gMiwgbm9ybWFsWzFdICogZWRnZVdpZHRoIC8gMl07XG4gICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgY29udGV4dC5tb3ZlVG8ocHRzW2ldIC0gdHJpYW5nbGVIZWFkWzBdLCBwdHNbaSArIDFdIC0gdHJpYW5nbGVIZWFkWzFdKTtcbiAgICAgIGNvbnRleHQubGluZVRvKHB0c1tpXSArIHRyaWFuZ2xlSGVhZFswXSwgcHRzW2kgKyAxXSArIHRyaWFuZ2xlSGVhZFsxXSk7XG4gICAgICBjb250ZXh0LmxpbmVUbyhwdHNbaSArIDJdLCBwdHNbaSArIDNdKTtcbiAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICB9XG4gIH07XG5cbiAgQ1JwJDguZHJhd0Fycm93aGVhZHMgPSBmdW5jdGlvbiAoY29udGV4dCwgZWRnZSwgb3BhY2l0eSkge1xuICAgIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgdmFyIGlzSGF5c3RhY2sgPSBycy5lZGdlVHlwZSA9PT0gJ2hheXN0YWNrJztcblxuICAgIGlmICghaXNIYXlzdGFjaykge1xuICAgICAgdGhpcy5kcmF3QXJyb3doZWFkKGNvbnRleHQsIGVkZ2UsICdzb3VyY2UnLCBycy5hcnJvd1N0YXJ0WCwgcnMuYXJyb3dTdGFydFksIHJzLnNyY0Fycm93QW5nbGUsIG9wYWNpdHkpO1xuICAgIH1cblxuICAgIHRoaXMuZHJhd0Fycm93aGVhZChjb250ZXh0LCBlZGdlLCAnbWlkLXRhcmdldCcsIHJzLm1pZFgsIHJzLm1pZFksIHJzLm1pZHRndEFycm93QW5nbGUsIG9wYWNpdHkpO1xuICAgIHRoaXMuZHJhd0Fycm93aGVhZChjb250ZXh0LCBlZGdlLCAnbWlkLXNvdXJjZScsIHJzLm1pZFgsIHJzLm1pZFksIHJzLm1pZHNyY0Fycm93QW5nbGUsIG9wYWNpdHkpO1xuXG4gICAgaWYgKCFpc0hheXN0YWNrKSB7XG4gICAgICB0aGlzLmRyYXdBcnJvd2hlYWQoY29udGV4dCwgZWRnZSwgJ3RhcmdldCcsIHJzLmFycm93RW5kWCwgcnMuYXJyb3dFbmRZLCBycy50Z3RBcnJvd0FuZ2xlLCBvcGFjaXR5KTtcbiAgICB9XG4gIH07XG5cbiAgQ1JwJDguZHJhd0Fycm93aGVhZCA9IGZ1bmN0aW9uIChjb250ZXh0LCBlZGdlLCBwcmVmaXgsIHgsIHksIGFuZ2xlLCBvcGFjaXR5KSB7XG4gICAgaWYgKGlzTmFOKHgpIHx8IHggPT0gbnVsbCB8fCBpc05hTih5KSB8fCB5ID09IG51bGwgfHwgaXNOYU4oYW5nbGUpIHx8IGFuZ2xlID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGFycm93U2hhcGUgPSBlZGdlLnBzdHlsZShwcmVmaXggKyAnLWFycm93LXNoYXBlJykudmFsdWU7XG5cbiAgICBpZiAoYXJyb3dTaGFwZSA9PT0gJ25vbmUnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGFycm93Q2xlYXJGaWxsID0gZWRnZS5wc3R5bGUocHJlZml4ICsgJy1hcnJvdy1maWxsJykudmFsdWUgPT09ICdob2xsb3cnID8gJ2JvdGgnIDogJ2ZpbGxlZCc7XG4gICAgdmFyIGFycm93RmlsbCA9IGVkZ2UucHN0eWxlKHByZWZpeCArICctYXJyb3ctZmlsbCcpLnZhbHVlO1xuICAgIHZhciBlZGdlV2lkdGggPSBlZGdlLnBzdHlsZSgnd2lkdGgnKS5wZlZhbHVlO1xuICAgIHZhciBlZGdlT3BhY2l0eSA9IGVkZ2UucHN0eWxlKCdvcGFjaXR5JykudmFsdWU7XG5cbiAgICBpZiAob3BhY2l0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBvcGFjaXR5ID0gZWRnZU9wYWNpdHk7XG4gICAgfVxuXG4gICAgdmFyIGdjbyA9IGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uO1xuXG4gICAgaWYgKG9wYWNpdHkgIT09IDEgfHwgYXJyb3dGaWxsID09PSAnaG9sbG93Jykge1xuICAgICAgLy8gdGhlbiBleHRyYSBjbGVhciBpcyBuZWVkZWRcbiAgICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLW91dCc7XG4gICAgICBzZWxmLmNvbG9yRmlsbFN0eWxlKGNvbnRleHQsIDI1NSwgMjU1LCAyNTUsIDEpO1xuICAgICAgc2VsZi5jb2xvclN0cm9rZVN0eWxlKGNvbnRleHQsIDI1NSwgMjU1LCAyNTUsIDEpO1xuICAgICAgc2VsZi5kcmF3QXJyb3dTaGFwZShlZGdlLCBjb250ZXh0LCBhcnJvd0NsZWFyRmlsbCwgZWRnZVdpZHRoLCBhcnJvd1NoYXBlLCB4LCB5LCBhbmdsZSk7XG4gICAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IGdjbztcbiAgICB9IC8vIG90aGVyd2lzZSwgdGhlIG9wYXF1ZSBhcnJvdyBjbGVhcnMgaXQgZm9yIGZyZWUgOilcblxuXG4gICAgdmFyIGNvbG9yID0gZWRnZS5wc3R5bGUocHJlZml4ICsgJy1hcnJvdy1jb2xvcicpLnZhbHVlO1xuICAgIHNlbGYuY29sb3JGaWxsU3R5bGUoY29udGV4dCwgY29sb3JbMF0sIGNvbG9yWzFdLCBjb2xvclsyXSwgb3BhY2l0eSk7XG4gICAgc2VsZi5jb2xvclN0cm9rZVN0eWxlKGNvbnRleHQsIGNvbG9yWzBdLCBjb2xvclsxXSwgY29sb3JbMl0sIG9wYWNpdHkpO1xuICAgIHNlbGYuZHJhd0Fycm93U2hhcGUoZWRnZSwgY29udGV4dCwgYXJyb3dGaWxsLCBlZGdlV2lkdGgsIGFycm93U2hhcGUsIHgsIHksIGFuZ2xlKTtcbiAgfTtcblxuICBDUnAkOC5kcmF3QXJyb3dTaGFwZSA9IGZ1bmN0aW9uIChlZGdlLCBjb250ZXh0LCBmaWxsLCBlZGdlV2lkdGgsIHNoYXBlLCB4LCB5LCBhbmdsZSkge1xuICAgIHZhciByID0gdGhpcztcbiAgICB2YXIgdXNlUGF0aHMgPSB0aGlzLnVzZVBhdGhzKCkgJiYgc2hhcGUgIT09ICd0cmlhbmdsZS1jcm9zcyc7XG4gICAgdmFyIHBhdGhDYWNoZUhpdCA9IGZhbHNlO1xuICAgIHZhciBwYXRoO1xuICAgIHZhciBjYW52YXNDb250ZXh0ID0gY29udGV4dDtcbiAgICB2YXIgdHJhbnNsYXRpb24gPSB7XG4gICAgICB4OiB4LFxuICAgICAgeTogeVxuICAgIH07XG4gICAgdmFyIHNjYWxlID0gZWRnZS5wc3R5bGUoJ2Fycm93LXNjYWxlJykudmFsdWU7XG4gICAgdmFyIHNpemUgPSB0aGlzLmdldEFycm93V2lkdGgoZWRnZVdpZHRoLCBzY2FsZSk7XG4gICAgdmFyIHNoYXBlSW1wbCA9IHIuYXJyb3dTaGFwZXNbc2hhcGVdO1xuXG4gICAgaWYgKHVzZVBhdGhzKSB7XG4gICAgICB2YXIgY2FjaGUgPSByLmFycm93UGF0aENhY2hlID0gci5hcnJvd1BhdGhDYWNoZSB8fCBbXTtcbiAgICAgIHZhciBrZXkgPSBoYXNoU3RyaW5nKHNoYXBlKTtcbiAgICAgIHZhciBjYWNoZWRQYXRoID0gY2FjaGVba2V5XTtcblxuICAgICAgaWYgKGNhY2hlZFBhdGggIT0gbnVsbCkge1xuICAgICAgICBwYXRoID0gY29udGV4dCA9IGNhY2hlZFBhdGg7XG4gICAgICAgIHBhdGhDYWNoZUhpdCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXRoID0gY29udGV4dCA9IG5ldyBQYXRoMkQoKTtcbiAgICAgICAgY2FjaGVba2V5XSA9IHBhdGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFwYXRoQ2FjaGVIaXQpIHtcbiAgICAgIGlmIChjb250ZXh0LmJlZ2luUGF0aCkge1xuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodXNlUGF0aHMpIHtcbiAgICAgICAgLy8gc3RvcmUgaW4gdGhlIHBhdGggY2FjaGUgd2l0aCB2YWx1ZXMgZWFzaWx5IG1hbmlwdWxhdGVkIGxhdGVyXG4gICAgICAgIHNoYXBlSW1wbC5kcmF3KGNvbnRleHQsIDEsIDAsIHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDBcbiAgICAgICAgfSwgMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaGFwZUltcGwuZHJhdyhjb250ZXh0LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24sIGVkZ2VXaWR0aCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb250ZXh0LmNsb3NlUGF0aCkge1xuICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnRleHQgPSBjYW52YXNDb250ZXh0O1xuXG4gICAgaWYgKHVzZVBhdGhzKSB7XG4gICAgICAvLyBzZXQgdHJhbnNmb3JtIHRvIGFycm93IHBvc2l0aW9uL29yaWVudGF0aW9uXG4gICAgICBjb250ZXh0LnRyYW5zbGF0ZSh4LCB5KTtcbiAgICAgIGNvbnRleHQucm90YXRlKGFuZ2xlKTtcbiAgICAgIGNvbnRleHQuc2NhbGUoc2l6ZSwgc2l6ZSk7XG4gICAgfVxuXG4gICAgaWYgKGZpbGwgPT09ICdmaWxsZWQnIHx8IGZpbGwgPT09ICdib3RoJykge1xuICAgICAgaWYgKHVzZVBhdGhzKSB7XG4gICAgICAgIGNvbnRleHQuZmlsbChwYXRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmaWxsID09PSAnaG9sbG93JyB8fCBmaWxsID09PSAnYm90aCcpIHtcbiAgICAgIGNvbnRleHQubGluZVdpZHRoID0gKHNoYXBlSW1wbC5tYXRjaEVkZ2VXaWR0aCA/IGVkZ2VXaWR0aCA6IDEpIC8gKHVzZVBhdGhzID8gc2l6ZSA6IDEpO1xuICAgICAgY29udGV4dC5saW5lSm9pbiA9ICdtaXRlcic7XG5cbiAgICAgIGlmICh1c2VQYXRocykge1xuICAgICAgICBjb250ZXh0LnN0cm9rZShwYXRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHVzZVBhdGhzKSB7XG4gICAgICAvLyByZXNldCB0cmFuc2Zvcm0gYnkgYXBwbHlpbmcgaW52ZXJzZVxuICAgICAgY29udGV4dC5zY2FsZSgxIC8gc2l6ZSwgMSAvIHNpemUpO1xuICAgICAgY29udGV4dC5yb3RhdGUoLWFuZ2xlKTtcbiAgICAgIGNvbnRleHQudHJhbnNsYXRlKC14LCAteSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBDUnAkNyA9IHt9O1xuXG4gIENScCQ3LnNhZmVEcmF3SW1hZ2UgPSBmdW5jdGlvbiAoY29udGV4dCwgaW1nLCBpeCwgaXksIGl3LCBpaCwgeCwgeSwgdywgaCkge1xuICAgIC8vIGRldGVjdCBwcm9ibGVtYXRpYyBjYXNlcyBmb3Igb2xkIGJyb3dzZXJzIHdpdGggYmFkIGltYWdlcyAoY2hlYXBlciB0aGFuIHRyeS1jYXRjaClcbiAgICBpZiAoaXcgPD0gMCB8fCBpaCA8PSAwIHx8IHcgPD0gMCB8fCBoIDw9IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29udGV4dC5kcmF3SW1hZ2UoaW1nLCBpeCwgaXksIGl3LCBpaCwgeCwgeSwgdywgaCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgd2FybihlKTtcbiAgICB9XG4gIH07XG5cbiAgQ1JwJDcuZHJhd0luc2NyaWJlZEltYWdlID0gZnVuY3Rpb24gKGNvbnRleHQsIGltZywgbm9kZSwgaW5kZXgsIG5vZGVPcGFjaXR5KSB7XG4gICAgdmFyIHIgPSB0aGlzO1xuICAgIHZhciBwb3MgPSBub2RlLnBvc2l0aW9uKCk7XG4gICAgdmFyIG5vZGVYID0gcG9zLng7XG4gICAgdmFyIG5vZGVZID0gcG9zLnk7XG4gICAgdmFyIHN0eWxlT2JqID0gbm9kZS5jeSgpLnN0eWxlKCk7XG4gICAgdmFyIGdldEluZGV4ZWRTdHlsZSA9IHN0eWxlT2JqLmdldEluZGV4ZWRTdHlsZS5iaW5kKHN0eWxlT2JqKTtcbiAgICB2YXIgZml0ID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLWZpdCcsICd2YWx1ZScsIGluZGV4KTtcbiAgICB2YXIgcmVwZWF0ID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLXJlcGVhdCcsICd2YWx1ZScsIGluZGV4KTtcbiAgICB2YXIgbm9kZVcgPSBub2RlLndpZHRoKCk7XG4gICAgdmFyIG5vZGVIID0gbm9kZS5oZWlnaHQoKTtcbiAgICB2YXIgcGFkZGluZ1gyID0gbm9kZS5wYWRkaW5nKCkgKiAyO1xuICAgIHZhciBub2RlVFcgPSBub2RlVyArIChnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtd2lkdGgtcmVsYXRpdmUtdG8nLCAndmFsdWUnLCBpbmRleCkgPT09ICdpbm5lcicgPyAwIDogcGFkZGluZ1gyKTtcbiAgICB2YXIgbm9kZVRIID0gbm9kZUggKyAoZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLWhlaWdodC1yZWxhdGl2ZS10bycsICd2YWx1ZScsIGluZGV4KSA9PT0gJ2lubmVyJyA/IDAgOiBwYWRkaW5nWDIpO1xuICAgIHZhciBycyA9IG5vZGUuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgdmFyIGNsaXAgPSBnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtY2xpcCcsICd2YWx1ZScsIGluZGV4KTtcbiAgICB2YXIgc2hvdWxkQ2xpcCA9IGNsaXAgPT09ICdub2RlJztcbiAgICB2YXIgaW1nT3BhY2l0eSA9IGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1pbWFnZS1vcGFjaXR5JywgJ3ZhbHVlJywgaW5kZXgpICogbm9kZU9wYWNpdHk7XG4gICAgdmFyIHNtb290aCA9IGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1pbWFnZS1zbW9vdGhpbmcnLCAndmFsdWUnLCBpbmRleCk7XG4gICAgdmFyIGltZ1cgPSBpbWcud2lkdGggfHwgaW1nLmNhY2hlZFc7XG4gICAgdmFyIGltZ0ggPSBpbWcuaGVpZ2h0IHx8IGltZy5jYWNoZWRIOyAvLyB3b3JrYXJvdW5kIGZvciBicm9rZW4gYnJvd3NlcnMgbGlrZSBpZVxuXG4gICAgaWYgKG51bGwgPT0gaW1nVyB8fCBudWxsID09IGltZ0gpIHtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaW1nKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4gICAgICBpbWdXID0gaW1nLmNhY2hlZFcgPSBpbWcud2lkdGggfHwgaW1nLm9mZnNldFdpZHRoO1xuICAgICAgaW1nSCA9IGltZy5jYWNoZWRIID0gaW1nLmhlaWdodCB8fCBpbWcub2Zmc2V0SGVpZ2h0O1xuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChpbWcpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gICAgfVxuXG4gICAgdmFyIHcgPSBpbWdXO1xuICAgIHZhciBoID0gaW1nSDtcblxuICAgIGlmIChnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtd2lkdGgnLCAndmFsdWUnLCBpbmRleCkgIT09ICdhdXRvJykge1xuICAgICAgaWYgKGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC13aWR0aCcsICd1bml0cycsIGluZGV4KSA9PT0gJyUnKSB7XG4gICAgICAgIHcgPSBnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtd2lkdGgnLCAncGZWYWx1ZScsIGluZGV4KSAqIG5vZGVUVztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHcgPSBnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtd2lkdGgnLCAncGZWYWx1ZScsIGluZGV4KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLWhlaWdodCcsICd2YWx1ZScsIGluZGV4KSAhPT0gJ2F1dG8nKSB7XG4gICAgICBpZiAoZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLWhlaWdodCcsICd1bml0cycsIGluZGV4KSA9PT0gJyUnKSB7XG4gICAgICAgIGggPSBnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtaGVpZ2h0JywgJ3BmVmFsdWUnLCBpbmRleCkgKiBub2RlVEg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLWhlaWdodCcsICdwZlZhbHVlJywgaW5kZXgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh3ID09PSAwIHx8IGggPT09IDApIHtcbiAgICAgIHJldHVybjsgLy8gbm8gcG9pbnQgaW4gZHJhd2luZyBlbXB0eSBpbWFnZSAoYW5kIGNocm9tZSBpcyBicm9rZW4gaW4gdGhpcyBjYXNlKVxuICAgIH1cblxuICAgIGlmIChmaXQgPT09ICdjb250YWluJykge1xuICAgICAgdmFyIHNjYWxlID0gTWF0aC5taW4obm9kZVRXIC8gdywgbm9kZVRIIC8gaCk7XG4gICAgICB3ICo9IHNjYWxlO1xuICAgICAgaCAqPSBzY2FsZTtcbiAgICB9IGVsc2UgaWYgKGZpdCA9PT0gJ2NvdmVyJykge1xuICAgICAgdmFyIHNjYWxlID0gTWF0aC5tYXgobm9kZVRXIC8gdywgbm9kZVRIIC8gaCk7XG4gICAgICB3ICo9IHNjYWxlO1xuICAgICAgaCAqPSBzY2FsZTtcbiAgICB9XG5cbiAgICB2YXIgeCA9IG5vZGVYIC0gbm9kZVRXIC8gMjsgLy8gbGVmdFxuXG4gICAgdmFyIHBvc1hVbml0cyA9IGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1wb3NpdGlvbi14JywgJ3VuaXRzJywgaW5kZXgpO1xuICAgIHZhciBwb3NYUGZWYWwgPSBnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtcG9zaXRpb24teCcsICdwZlZhbHVlJywgaW5kZXgpO1xuXG4gICAgaWYgKHBvc1hVbml0cyA9PT0gJyUnKSB7XG4gICAgICB4ICs9IChub2RlVFcgLSB3KSAqIHBvc1hQZlZhbDtcbiAgICB9IGVsc2Uge1xuICAgICAgeCArPSBwb3NYUGZWYWw7XG4gICAgfVxuXG4gICAgdmFyIG9mZlhVbml0cyA9IGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1vZmZzZXQteCcsICd1bml0cycsIGluZGV4KTtcbiAgICB2YXIgb2ZmWFBmVmFsID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLW9mZnNldC14JywgJ3BmVmFsdWUnLCBpbmRleCk7XG5cbiAgICBpZiAob2ZmWFVuaXRzID09PSAnJScpIHtcbiAgICAgIHggKz0gKG5vZGVUVyAtIHcpICogb2ZmWFBmVmFsO1xuICAgIH0gZWxzZSB7XG4gICAgICB4ICs9IG9mZlhQZlZhbDtcbiAgICB9XG5cbiAgICB2YXIgeSA9IG5vZGVZIC0gbm9kZVRIIC8gMjsgLy8gdG9wXG5cbiAgICB2YXIgcG9zWVVuaXRzID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLXBvc2l0aW9uLXknLCAndW5pdHMnLCBpbmRleCk7XG4gICAgdmFyIHBvc1lQZlZhbCA9IGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1wb3NpdGlvbi15JywgJ3BmVmFsdWUnLCBpbmRleCk7XG5cbiAgICBpZiAocG9zWVVuaXRzID09PSAnJScpIHtcbiAgICAgIHkgKz0gKG5vZGVUSCAtIGgpICogcG9zWVBmVmFsO1xuICAgIH0gZWxzZSB7XG4gICAgICB5ICs9IHBvc1lQZlZhbDtcbiAgICB9XG5cbiAgICB2YXIgb2ZmWVVuaXRzID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLW9mZnNldC15JywgJ3VuaXRzJywgaW5kZXgpO1xuICAgIHZhciBvZmZZUGZWYWwgPSBnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtb2Zmc2V0LXknLCAncGZWYWx1ZScsIGluZGV4KTtcblxuICAgIGlmIChvZmZZVW5pdHMgPT09ICclJykge1xuICAgICAgeSArPSAobm9kZVRIIC0gaCkgKiBvZmZZUGZWYWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHkgKz0gb2ZmWVBmVmFsO1xuICAgIH1cblxuICAgIGlmIChycy5wYXRoQ2FjaGUpIHtcbiAgICAgIHggLT0gbm9kZVg7XG4gICAgICB5IC09IG5vZGVZO1xuICAgICAgbm9kZVggPSAwO1xuICAgICAgbm9kZVkgPSAwO1xuICAgIH1cblxuICAgIHZhciBnQWxwaGEgPSBjb250ZXh0Lmdsb2JhbEFscGhhO1xuICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSBpbWdPcGFjaXR5O1xuICAgIHZhciBzbW9vdGhpbmdFbmFibGVkID0gci5nZXRJbWdTbW9vdGhpbmcoY29udGV4dCk7XG4gICAgdmFyIGlzU21vb3RoaW5nU3dpdGNoZWQgPSBmYWxzZTtcblxuICAgIGlmIChzbW9vdGggPT09ICdubycgJiYgc21vb3RoaW5nRW5hYmxlZCkge1xuICAgICAgci5zZXRJbWdTbW9vdGhpbmcoY29udGV4dCwgZmFsc2UpO1xuICAgICAgaXNTbW9vdGhpbmdTd2l0Y2hlZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChzbW9vdGggPT09ICd5ZXMnICYmICFzbW9vdGhpbmdFbmFibGVkKSB7XG4gICAgICByLnNldEltZ1Ntb290aGluZyhjb250ZXh0LCB0cnVlKTtcbiAgICAgIGlzU21vb3RoaW5nU3dpdGNoZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChyZXBlYXQgPT09ICduby1yZXBlYXQnKSB7XG4gICAgICBpZiAoc2hvdWxkQ2xpcCkge1xuICAgICAgICBjb250ZXh0LnNhdmUoKTtcblxuICAgICAgICBpZiAocnMucGF0aENhY2hlKSB7XG4gICAgICAgICAgY29udGV4dC5jbGlwKHJzLnBhdGhDYWNoZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgci5ub2RlU2hhcGVzW3IuZ2V0Tm9kZVNoYXBlKG5vZGUpXS5kcmF3KGNvbnRleHQsIG5vZGVYLCBub2RlWSwgbm9kZVRXLCBub2RlVEgpO1xuICAgICAgICAgIGNvbnRleHQuY2xpcCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHIuc2FmZURyYXdJbWFnZShjb250ZXh0LCBpbWcsIDAsIDAsIGltZ1csIGltZ0gsIHgsIHksIHcsIGgpO1xuXG4gICAgICBpZiAoc2hvdWxkQ2xpcCkge1xuICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHBhdHRlcm4gPSBjb250ZXh0LmNyZWF0ZVBhdHRlcm4oaW1nLCByZXBlYXQpO1xuICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBwYXR0ZXJuO1xuICAgICAgci5ub2RlU2hhcGVzW3IuZ2V0Tm9kZVNoYXBlKG5vZGUpXS5kcmF3KGNvbnRleHQsIG5vZGVYLCBub2RlWSwgbm9kZVRXLCBub2RlVEgpO1xuICAgICAgY29udGV4dC50cmFuc2xhdGUoeCwgeSk7XG4gICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICAgIGNvbnRleHQudHJhbnNsYXRlKC14LCAteSk7XG4gICAgfVxuXG4gICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGdBbHBoYTtcblxuICAgIGlmIChpc1Ntb290aGluZ1N3aXRjaGVkKSB7XG4gICAgICByLnNldEltZ1Ntb290aGluZyhjb250ZXh0LCBzbW9vdGhpbmdFbmFibGVkKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIENScCQ2ID0ge307XG5cbiAgQ1JwJDYuZWxlVGV4dEJpZ2dlclRoYW5NaW4gPSBmdW5jdGlvbiAoZWxlLCBzY2FsZSkge1xuICAgIGlmICghc2NhbGUpIHtcbiAgICAgIHZhciB6b29tID0gZWxlLmN5KCkuem9vbSgpO1xuICAgICAgdmFyIHB4UmF0aW8gPSB0aGlzLmdldFBpeGVsUmF0aW8oKTtcbiAgICAgIHZhciBsdmwgPSBNYXRoLmNlaWwobG9nMih6b29tICogcHhSYXRpbykpOyAvLyB0aGUgZWZmZWN0aXZlIHRleHR1cmUgbGV2ZWxcblxuICAgICAgc2NhbGUgPSBNYXRoLnBvdygyLCBsdmwpO1xuICAgIH1cblxuICAgIHZhciBjb21wdXRlZFNpemUgPSBlbGUucHN0eWxlKCdmb250LXNpemUnKS5wZlZhbHVlICogc2NhbGU7XG4gICAgdmFyIG1pblNpemUgPSBlbGUucHN0eWxlKCdtaW4tem9vbWVkLWZvbnQtc2l6ZScpLnBmVmFsdWU7XG5cbiAgICBpZiAoY29tcHV0ZWRTaXplIDwgbWluU2l6ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIENScCQ2LmRyYXdFbGVtZW50VGV4dCA9IGZ1bmN0aW9uIChjb250ZXh0LCBlbGUsIHNoaWZ0VG9PcmlnaW5XaXRoQmIsIGZvcmNlLCBwcmVmaXgpIHtcbiAgICB2YXIgdXNlRWxlT3BhY2l0eSA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogdHJ1ZTtcbiAgICB2YXIgciA9IHRoaXM7XG5cbiAgICBpZiAoZm9yY2UgPT0gbnVsbCkge1xuICAgICAgaWYgKHVzZUVsZU9wYWNpdHkgJiYgIXIuZWxlVGV4dEJpZ2dlclRoYW5NaW4oZWxlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChmb3JjZSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgICB2YXIgbGFiZWwgPSBlbGUucHN0eWxlKCdsYWJlbCcpO1xuXG4gICAgICBpZiAoIWxhYmVsIHx8ICFsYWJlbC52YWx1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBqdXN0aWZpY2F0aW9uID0gci5nZXRMYWJlbEp1c3RpZmljYXRpb24oZWxlKTtcbiAgICAgIGNvbnRleHQudGV4dEFsaWduID0ganVzdGlmaWNhdGlvbjtcbiAgICAgIGNvbnRleHQudGV4dEJhc2VsaW5lID0gJ2JvdHRvbSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBiYWRMaW5lID0gZWxlLmVsZW1lbnQoKS5fcHJpdmF0ZS5yc2NyYXRjaC5iYWRMaW5lO1xuXG4gICAgICB2YXIgX2xhYmVsID0gZWxlLnBzdHlsZSgnbGFiZWwnKTtcblxuICAgICAgdmFyIHNyY0xhYmVsID0gZWxlLnBzdHlsZSgnc291cmNlLWxhYmVsJyk7XG4gICAgICB2YXIgdGd0TGFiZWwgPSBlbGUucHN0eWxlKCd0YXJnZXQtbGFiZWwnKTtcblxuICAgICAgaWYgKGJhZExpbmUgfHwgKCFfbGFiZWwgfHwgIV9sYWJlbC52YWx1ZSkgJiYgKCFzcmNMYWJlbCB8fCAhc3JjTGFiZWwudmFsdWUpICYmICghdGd0TGFiZWwgfHwgIXRndExhYmVsLnZhbHVlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICBjb250ZXh0LnRleHRCYXNlbGluZSA9ICdib3R0b20nO1xuICAgIH1cblxuICAgIHZhciBhcHBseVJvdGF0aW9uID0gIXNoaWZ0VG9PcmlnaW5XaXRoQmI7XG4gICAgdmFyIGJiO1xuXG4gICAgaWYgKHNoaWZ0VG9PcmlnaW5XaXRoQmIpIHtcbiAgICAgIGJiID0gc2hpZnRUb09yaWdpbldpdGhCYjtcbiAgICAgIGNvbnRleHQudHJhbnNsYXRlKC1iYi54MSwgLWJiLnkxKTtcbiAgICB9XG5cbiAgICBpZiAocHJlZml4ID09IG51bGwpIHtcbiAgICAgIHIuZHJhd1RleHQoY29udGV4dCwgZWxlLCBudWxsLCBhcHBseVJvdGF0aW9uLCB1c2VFbGVPcGFjaXR5KTtcblxuICAgICAgaWYgKGVsZS5pc0VkZ2UoKSkge1xuICAgICAgICByLmRyYXdUZXh0KGNvbnRleHQsIGVsZSwgJ3NvdXJjZScsIGFwcGx5Um90YXRpb24sIHVzZUVsZU9wYWNpdHkpO1xuICAgICAgICByLmRyYXdUZXh0KGNvbnRleHQsIGVsZSwgJ3RhcmdldCcsIGFwcGx5Um90YXRpb24sIHVzZUVsZU9wYWNpdHkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByLmRyYXdUZXh0KGNvbnRleHQsIGVsZSwgcHJlZml4LCBhcHBseVJvdGF0aW9uLCB1c2VFbGVPcGFjaXR5KTtcbiAgICB9XG5cbiAgICBpZiAoc2hpZnRUb09yaWdpbldpdGhCYikge1xuICAgICAgY29udGV4dC50cmFuc2xhdGUoYmIueDEsIGJiLnkxKTtcbiAgICB9XG4gIH07XG5cbiAgQ1JwJDYuZ2V0Rm9udENhY2hlID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICB2YXIgY2FjaGU7XG4gICAgdGhpcy5mb250Q2FjaGVzID0gdGhpcy5mb250Q2FjaGVzIHx8IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmZvbnRDYWNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNhY2hlID0gdGhpcy5mb250Q2FjaGVzW2ldO1xuXG4gICAgICBpZiAoY2FjaGUuY29udGV4dCA9PT0gY29udGV4dCkge1xuICAgICAgICByZXR1cm4gY2FjaGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2FjaGUgPSB7XG4gICAgICBjb250ZXh0OiBjb250ZXh0XG4gICAgfTtcbiAgICB0aGlzLmZvbnRDYWNoZXMucHVzaChjYWNoZSk7XG4gICAgcmV0dXJuIGNhY2hlO1xuICB9OyAvLyBzZXQgdXAgY2FudmFzIGNvbnRleHQgd2l0aCBmb250XG4gIC8vIHJldHVybnMgdHJhbnNmb3JtZWQgdGV4dCBzdHJpbmdcblxuXG4gIENScCQ2LnNldHVwVGV4dFN0eWxlID0gZnVuY3Rpb24gKGNvbnRleHQsIGVsZSkge1xuICAgIHZhciB1c2VFbGVPcGFjaXR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0cnVlO1xuICAgIC8vIEZvbnQgc3R5bGVcbiAgICB2YXIgbGFiZWxTdHlsZSA9IGVsZS5wc3R5bGUoJ2ZvbnQtc3R5bGUnKS5zdHJWYWx1ZTtcbiAgICB2YXIgbGFiZWxTaXplID0gZWxlLnBzdHlsZSgnZm9udC1zaXplJykucGZWYWx1ZSArICdweCc7XG4gICAgdmFyIGxhYmVsRmFtaWx5ID0gZWxlLnBzdHlsZSgnZm9udC1mYW1pbHknKS5zdHJWYWx1ZTtcbiAgICB2YXIgbGFiZWxXZWlnaHQgPSBlbGUucHN0eWxlKCdmb250LXdlaWdodCcpLnN0clZhbHVlO1xuICAgIHZhciBvcGFjaXR5ID0gdXNlRWxlT3BhY2l0eSA/IGVsZS5lZmZlY3RpdmVPcGFjaXR5KCkgKiBlbGUucHN0eWxlKCd0ZXh0LW9wYWNpdHknKS52YWx1ZSA6IDE7XG4gICAgdmFyIG91dGxpbmVPcGFjaXR5ID0gZWxlLnBzdHlsZSgndGV4dC1vdXRsaW5lLW9wYWNpdHknKS52YWx1ZSAqIG9wYWNpdHk7XG4gICAgdmFyIGNvbG9yID0gZWxlLnBzdHlsZSgnY29sb3InKS52YWx1ZTtcbiAgICB2YXIgb3V0bGluZUNvbG9yID0gZWxlLnBzdHlsZSgndGV4dC1vdXRsaW5lLWNvbG9yJykudmFsdWU7XG4gICAgY29udGV4dC5mb250ID0gbGFiZWxTdHlsZSArICcgJyArIGxhYmVsV2VpZ2h0ICsgJyAnICsgbGFiZWxTaXplICsgJyAnICsgbGFiZWxGYW1pbHk7XG4gICAgY29udGV4dC5saW5lSm9pbiA9ICdyb3VuZCc7IC8vIHNvIHRleHQgb3V0bGluZXMgYXJlbid0IGphZ2dlZFxuXG4gICAgdGhpcy5jb2xvckZpbGxTdHlsZShjb250ZXh0LCBjb2xvclswXSwgY29sb3JbMV0sIGNvbG9yWzJdLCBvcGFjaXR5KTtcbiAgICB0aGlzLmNvbG9yU3Ryb2tlU3R5bGUoY29udGV4dCwgb3V0bGluZUNvbG9yWzBdLCBvdXRsaW5lQ29sb3JbMV0sIG91dGxpbmVDb2xvclsyXSwgb3V0bGluZU9wYWNpdHkpO1xuICB9OyAvLyBUT0RPIGVuc3VyZSByZS11c2VkXG5cblxuICBmdW5jdGlvbiByb3VuZFJlY3QoY3R4LCB4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdmFyIHJhZGl1cyA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogNTtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4Lm1vdmVUbyh4ICsgcmFkaXVzLCB5KTtcbiAgICBjdHgubGluZVRvKHggKyB3aWR0aCAtIHJhZGl1cywgeSk7XG4gICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5LCB4ICsgd2lkdGgsIHkgKyByYWRpdXMpO1xuICAgIGN0eC5saW5lVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0IC0gcmFkaXVzKTtcbiAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQsIHggKyB3aWR0aCAtIHJhZGl1cywgeSArIGhlaWdodCk7XG4gICAgY3R4LmxpbmVUbyh4ICsgcmFkaXVzLCB5ICsgaGVpZ2h0KTtcbiAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5ICsgaGVpZ2h0LCB4LCB5ICsgaGVpZ2h0IC0gcmFkaXVzKTtcbiAgICBjdHgubGluZVRvKHgsIHkgKyByYWRpdXMpO1xuICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHksIHggKyByYWRpdXMsIHkpO1xuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICBjdHguZmlsbCgpO1xuICB9XG5cbiAgQ1JwJDYuZ2V0VGV4dEFuZ2xlID0gZnVuY3Rpb24gKGVsZSwgcHJlZml4KSB7XG4gICAgdmFyIHRoZXRhO1xuICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICB2YXIgcnNjcmF0Y2ggPSBfcC5yc2NyYXRjaDtcbiAgICB2YXIgcGRhc2ggPSBwcmVmaXggPyBwcmVmaXggKyAnLScgOiAnJztcbiAgICB2YXIgcm90YXRpb24gPSBlbGUucHN0eWxlKHBkYXNoICsgJ3RleHQtcm90YXRpb24nKTtcbiAgICB2YXIgdGV4dEFuZ2xlID0gZ2V0UHJlZml4ZWRQcm9wZXJ0eShyc2NyYXRjaCwgJ2xhYmVsQW5nbGUnLCBwcmVmaXgpO1xuXG4gICAgaWYgKHJvdGF0aW9uLnN0clZhbHVlID09PSAnYXV0b3JvdGF0ZScpIHtcbiAgICAgIHRoZXRhID0gZWxlLmlzRWRnZSgpID8gdGV4dEFuZ2xlIDogMDtcbiAgICB9IGVsc2UgaWYgKHJvdGF0aW9uLnN0clZhbHVlID09PSAnbm9uZScpIHtcbiAgICAgIHRoZXRhID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhldGEgPSByb3RhdGlvbi5wZlZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGV0YTtcbiAgfTtcblxuICBDUnAkNi5kcmF3VGV4dCA9IGZ1bmN0aW9uIChjb250ZXh0LCBlbGUsIHByZWZpeCkge1xuICAgIHZhciBhcHBseVJvdGF0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB0cnVlO1xuICAgIHZhciB1c2VFbGVPcGFjaXR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiB0cnVlO1xuICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICB2YXIgcnNjcmF0Y2ggPSBfcC5yc2NyYXRjaDtcbiAgICB2YXIgcGFyZW50T3BhY2l0eSA9IHVzZUVsZU9wYWNpdHkgPyBlbGUuZWZmZWN0aXZlT3BhY2l0eSgpIDogMTtcblxuICAgIGlmICh1c2VFbGVPcGFjaXR5ICYmIChwYXJlbnRPcGFjaXR5ID09PSAwIHx8IGVsZS5wc3R5bGUoJ3RleHQtb3BhY2l0eScpLnZhbHVlID09PSAwKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gdXNlICdtYWluJyBhcyBhbiBhbGlhcyBmb3IgdGhlIG1haW4gbGFiZWwgKGkuZS4gbnVsbCBwcmVmaXgpXG5cblxuICAgIGlmIChwcmVmaXggPT09ICdtYWluJykge1xuICAgICAgcHJlZml4ID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgdGV4dFggPSBnZXRQcmVmaXhlZFByb3BlcnR5KHJzY3JhdGNoLCAnbGFiZWxYJywgcHJlZml4KTtcbiAgICB2YXIgdGV4dFkgPSBnZXRQcmVmaXhlZFByb3BlcnR5KHJzY3JhdGNoLCAnbGFiZWxZJywgcHJlZml4KTtcbiAgICB2YXIgb3JnVGV4dFgsIG9yZ1RleHRZOyAvLyB1c2VkIGZvciByb3RhdGlvblxuXG4gICAgdmFyIHRleHQgPSB0aGlzLmdldExhYmVsVGV4dChlbGUsIHByZWZpeCk7XG5cbiAgICBpZiAodGV4dCAhPSBudWxsICYmIHRleHQgIT09ICcnICYmICFpc05hTih0ZXh0WCkgJiYgIWlzTmFOKHRleHRZKSkge1xuICAgICAgdGhpcy5zZXR1cFRleHRTdHlsZShjb250ZXh0LCBlbGUsIHVzZUVsZU9wYWNpdHkpO1xuICAgICAgdmFyIHBkYXNoID0gcHJlZml4ID8gcHJlZml4ICsgJy0nIDogJyc7XG4gICAgICB2YXIgdGV4dFcgPSBnZXRQcmVmaXhlZFByb3BlcnR5KHJzY3JhdGNoLCAnbGFiZWxXaWR0aCcsIHByZWZpeCk7XG4gICAgICB2YXIgdGV4dEggPSBnZXRQcmVmaXhlZFByb3BlcnR5KHJzY3JhdGNoLCAnbGFiZWxIZWlnaHQnLCBwcmVmaXgpO1xuICAgICAgdmFyIG1hcmdpblggPSBlbGUucHN0eWxlKHBkYXNoICsgJ3RleHQtbWFyZ2luLXgnKS5wZlZhbHVlO1xuICAgICAgdmFyIG1hcmdpblkgPSBlbGUucHN0eWxlKHBkYXNoICsgJ3RleHQtbWFyZ2luLXknKS5wZlZhbHVlO1xuICAgICAgdmFyIGlzRWRnZSA9IGVsZS5pc0VkZ2UoKTtcbiAgICAgIHZhciBoYWxpZ24gPSBlbGUucHN0eWxlKCd0ZXh0LWhhbGlnbicpLnZhbHVlO1xuICAgICAgdmFyIHZhbGlnbiA9IGVsZS5wc3R5bGUoJ3RleHQtdmFsaWduJykudmFsdWU7XG5cbiAgICAgIGlmIChpc0VkZ2UpIHtcbiAgICAgICAgaGFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgIHZhbGlnbiA9ICdjZW50ZXInO1xuICAgICAgfVxuXG4gICAgICB0ZXh0WCArPSBtYXJnaW5YO1xuICAgICAgdGV4dFkgKz0gbWFyZ2luWTtcbiAgICAgIHZhciB0aGV0YTtcblxuICAgICAgaWYgKCFhcHBseVJvdGF0aW9uKSB7XG4gICAgICAgIHRoZXRhID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoZXRhID0gdGhpcy5nZXRUZXh0QW5nbGUoZWxlLCBwcmVmaXgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhldGEgIT09IDApIHtcbiAgICAgICAgb3JnVGV4dFggPSB0ZXh0WDtcbiAgICAgICAgb3JnVGV4dFkgPSB0ZXh0WTtcbiAgICAgICAgY29udGV4dC50cmFuc2xhdGUob3JnVGV4dFgsIG9yZ1RleHRZKTtcbiAgICAgICAgY29udGV4dC5yb3RhdGUodGhldGEpO1xuICAgICAgICB0ZXh0WCA9IDA7XG4gICAgICAgIHRleHRZID0gMDtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoICh2YWxpZ24pIHtcbiAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgIHRleHRZICs9IHRleHRIIC8gMjtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgIHRleHRZICs9IHRleHRIO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB2YXIgYmFja2dyb3VuZE9wYWNpdHkgPSBlbGUucHN0eWxlKCd0ZXh0LWJhY2tncm91bmQtb3BhY2l0eScpLnZhbHVlO1xuICAgICAgdmFyIGJvcmRlck9wYWNpdHkgPSBlbGUucHN0eWxlKCd0ZXh0LWJvcmRlci1vcGFjaXR5JykudmFsdWU7XG4gICAgICB2YXIgdGV4dEJvcmRlcldpZHRoID0gZWxlLnBzdHlsZSgndGV4dC1ib3JkZXItd2lkdGgnKS5wZlZhbHVlO1xuICAgICAgdmFyIGJhY2tncm91bmRQYWRkaW5nID0gZWxlLnBzdHlsZSgndGV4dC1iYWNrZ3JvdW5kLXBhZGRpbmcnKS5wZlZhbHVlO1xuXG4gICAgICBpZiAoYmFja2dyb3VuZE9wYWNpdHkgPiAwIHx8IHRleHRCb3JkZXJXaWR0aCA+IDAgJiYgYm9yZGVyT3BhY2l0eSA+IDApIHtcbiAgICAgICAgdmFyIGJnWCA9IHRleHRYIC0gYmFja2dyb3VuZFBhZGRpbmc7XG5cbiAgICAgICAgc3dpdGNoIChoYWxpZ24pIHtcbiAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgIGJnWCAtPSB0ZXh0VztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICAgIGJnWCAtPSB0ZXh0VyAvIDI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBiZ1kgPSB0ZXh0WSAtIHRleHRIIC0gYmFja2dyb3VuZFBhZGRpbmc7XG4gICAgICAgIHZhciBiZ1cgPSB0ZXh0VyArIDIgKiBiYWNrZ3JvdW5kUGFkZGluZztcbiAgICAgICAgdmFyIGJnSCA9IHRleHRIICsgMiAqIGJhY2tncm91bmRQYWRkaW5nO1xuXG4gICAgICAgIGlmIChiYWNrZ3JvdW5kT3BhY2l0eSA+IDApIHtcbiAgICAgICAgICB2YXIgdGV4dEZpbGwgPSBjb250ZXh0LmZpbGxTdHlsZTtcbiAgICAgICAgICB2YXIgdGV4dEJhY2tncm91bmRDb2xvciA9IGVsZS5wc3R5bGUoJ3RleHQtYmFja2dyb3VuZC1jb2xvcicpLnZhbHVlO1xuICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJ3JnYmEoJyArIHRleHRCYWNrZ3JvdW5kQ29sb3JbMF0gKyAnLCcgKyB0ZXh0QmFja2dyb3VuZENvbG9yWzFdICsgJywnICsgdGV4dEJhY2tncm91bmRDb2xvclsyXSArICcsJyArIGJhY2tncm91bmRPcGFjaXR5ICogcGFyZW50T3BhY2l0eSArICcpJztcbiAgICAgICAgICB2YXIgc3R5bGVTaGFwZSA9IGVsZS5wc3R5bGUoJ3RleHQtYmFja2dyb3VuZC1zaGFwZScpLnN0clZhbHVlO1xuXG4gICAgICAgICAgaWYgKHN0eWxlU2hhcGUuaW5kZXhPZigncm91bmQnKSA9PT0gMCkge1xuICAgICAgICAgICAgcm91bmRSZWN0KGNvbnRleHQsIGJnWCwgYmdZLCBiZ1csIGJnSCwgMik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbFJlY3QoYmdYLCBiZ1ksIGJnVywgYmdIKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHRleHRGaWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRleHRCb3JkZXJXaWR0aCA+IDAgJiYgYm9yZGVyT3BhY2l0eSA+IDApIHtcbiAgICAgICAgICB2YXIgdGV4dFN0cm9rZSA9IGNvbnRleHQuc3Ryb2tlU3R5bGU7XG4gICAgICAgICAgdmFyIHRleHRMaW5lV2lkdGggPSBjb250ZXh0LmxpbmVXaWR0aDtcbiAgICAgICAgICB2YXIgdGV4dEJvcmRlckNvbG9yID0gZWxlLnBzdHlsZSgndGV4dC1ib3JkZXItY29sb3InKS52YWx1ZTtcbiAgICAgICAgICB2YXIgdGV4dEJvcmRlclN0eWxlID0gZWxlLnBzdHlsZSgndGV4dC1ib3JkZXItc3R5bGUnKS52YWx1ZTtcbiAgICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gJ3JnYmEoJyArIHRleHRCb3JkZXJDb2xvclswXSArICcsJyArIHRleHRCb3JkZXJDb2xvclsxXSArICcsJyArIHRleHRCb3JkZXJDb2xvclsyXSArICcsJyArIGJvcmRlck9wYWNpdHkgKiBwYXJlbnRPcGFjaXR5ICsgJyknO1xuICAgICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gdGV4dEJvcmRlcldpZHRoO1xuXG4gICAgICAgICAgaWYgKGNvbnRleHQuc2V0TGluZURhc2gpIHtcbiAgICAgICAgICAgIC8vIGZvciB2ZXJ5IG91dG9mZGF0ZSBicm93c2Vyc1xuICAgICAgICAgICAgc3dpdGNoICh0ZXh0Qm9yZGVyU3R5bGUpIHtcbiAgICAgICAgICAgICAgY2FzZSAnZG90dGVkJzpcbiAgICAgICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFsxLCAxXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSAnZGFzaGVkJzpcbiAgICAgICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFs0LCAyXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSAnZG91YmxlJzpcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHRleHRCb3JkZXJXaWR0aCAvIDQ7IC8vIDUwJSByZXNlcnZlZCBmb3Igd2hpdGUgYmV0d2VlbiB0aGUgdHdvIGJvcmRlcnNcblxuICAgICAgICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goW10pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgJ3NvbGlkJzpcbiAgICAgICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFtdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LnN0cm9rZVJlY3QoYmdYLCBiZ1ksIGJnVywgYmdIKTtcblxuICAgICAgICAgIGlmICh0ZXh0Qm9yZGVyU3R5bGUgPT09ICdkb3VibGUnKSB7XG4gICAgICAgICAgICB2YXIgd2hpdGVXaWR0aCA9IHRleHRCb3JkZXJXaWR0aCAvIDI7XG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZVJlY3QoYmdYICsgd2hpdGVXaWR0aCwgYmdZICsgd2hpdGVXaWR0aCwgYmdXIC0gd2hpdGVXaWR0aCAqIDIsIGJnSCAtIHdoaXRlV2lkdGggKiAyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5zZXRMaW5lRGFzaCkge1xuICAgICAgICAgICAgLy8gZm9yIHZlcnkgb3V0b2ZkYXRlIGJyb3dzZXJzXG4gICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFtdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHRleHRMaW5lV2lkdGg7XG4gICAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IHRleHRTdHJva2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGxpbmVXaWR0aCA9IDIgKiBlbGUucHN0eWxlKCd0ZXh0LW91dGxpbmUtd2lkdGgnKS5wZlZhbHVlOyAvLyAqMiBiL2MgdGhlIHN0cm9rZSBpcyBkcmF3biBjZW50cmVkIG9uIHRoZSBtaWRkbGVcblxuICAgICAgaWYgKGxpbmVXaWR0aCA+IDApIHtcbiAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbGUucHN0eWxlKCd0ZXh0LXdyYXAnKS52YWx1ZSA9PT0gJ3dyYXAnKSB7XG4gICAgICAgIHZhciBsaW5lcyA9IGdldFByZWZpeGVkUHJvcGVydHkocnNjcmF0Y2gsICdsYWJlbFdyYXBDYWNoZWRMaW5lcycsIHByZWZpeCk7XG4gICAgICAgIHZhciBsaW5lSGVpZ2h0ID0gZ2V0UHJlZml4ZWRQcm9wZXJ0eShyc2NyYXRjaCwgJ2xhYmVsTGluZUhlaWdodCcsIHByZWZpeCk7XG4gICAgICAgIHZhciBoYWxmVGV4dFcgPSB0ZXh0VyAvIDI7XG4gICAgICAgIHZhciBqdXN0aWZpY2F0aW9uID0gdGhpcy5nZXRMYWJlbEp1c3RpZmljYXRpb24oZWxlKTtcblxuICAgICAgICBpZiAoanVzdGlmaWNhdGlvbiA9PT0gJ2F1dG8nKSA7IGVsc2UgaWYgKGhhbGlnbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgLy8gYXV0byBqdXN0aWZpY2F0aW9uIDogcmlnaHRcbiAgICAgICAgICBpZiAoanVzdGlmaWNhdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgICB0ZXh0WCArPSAtdGV4dFc7XG4gICAgICAgICAgfSBlbHNlIGlmIChqdXN0aWZpY2F0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgdGV4dFggKz0gLWhhbGZUZXh0VztcbiAgICAgICAgICB9IC8vIGVsc2Ugc2FtZSBhcyBhdXRvXG5cbiAgICAgICAgfSBlbHNlIGlmIChoYWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgLy8gYXV0byBqdXN0ZmljYXRpb24gOiBjZW50ZXJcbiAgICAgICAgICBpZiAoanVzdGlmaWNhdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgICB0ZXh0WCArPSAtaGFsZlRleHRXO1xuICAgICAgICAgIH0gZWxzZSBpZiAoanVzdGlmaWNhdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgdGV4dFggKz0gaGFsZlRleHRXO1xuICAgICAgICAgIH0gLy8gZWxzZSBzYW1lIGFzIGF1dG9cblxuICAgICAgICB9IGVsc2UgaWYgKGhhbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgIC8vIGF1dG8ganVzdGlmaWNhdGlvbiA6IGxlZnRcbiAgICAgICAgICBpZiAoanVzdGlmaWNhdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgIHRleHRYICs9IGhhbGZUZXh0VztcbiAgICAgICAgICB9IGVsc2UgaWYgKGp1c3RpZmljYXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgIHRleHRYICs9IHRleHRXO1xuICAgICAgICAgIH0gLy8gZWxzZSBzYW1lIGFzIGF1dG9cblxuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoICh2YWxpZ24pIHtcbiAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgdGV4dFkgLT0gKGxpbmVzLmxlbmd0aCAtIDEpICogbGluZUhlaWdodDtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgdGV4dFkgLT0gKGxpbmVzLmxlbmd0aCAtIDEpICogbGluZUhlaWdodDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCBsaW5lcy5sZW5ndGg7IGwrKykge1xuICAgICAgICAgIGlmIChsaW5lV2lkdGggPiAwKSB7XG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZVRleHQobGluZXNbbF0sIHRleHRYLCB0ZXh0WSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5maWxsVGV4dChsaW5lc1tsXSwgdGV4dFgsIHRleHRZKTtcbiAgICAgICAgICB0ZXh0WSArPSBsaW5lSGVpZ2h0O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobGluZVdpZHRoID4gMCkge1xuICAgICAgICAgIGNvbnRleHQuc3Ryb2tlVGV4dCh0ZXh0LCB0ZXh0WCwgdGV4dFkpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5maWxsVGV4dCh0ZXh0LCB0ZXh0WCwgdGV4dFkpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhldGEgIT09IDApIHtcbiAgICAgICAgY29udGV4dC5yb3RhdGUoLXRoZXRhKTtcbiAgICAgICAgY29udGV4dC50cmFuc2xhdGUoLW9yZ1RleHRYLCAtb3JnVGV4dFkpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKiBnbG9iYWwgUGF0aDJEICovXG4gIHZhciBDUnAkNSA9IHt9O1xuXG4gIENScCQ1LmRyYXdOb2RlID0gZnVuY3Rpb24gKGNvbnRleHQsIG5vZGUsIHNoaWZ0VG9PcmlnaW5XaXRoQmIpIHtcbiAgICB2YXIgZHJhd0xhYmVsID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB0cnVlO1xuICAgIHZhciBzaG91bGREcmF3T3ZlcmxheSA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogdHJ1ZTtcbiAgICB2YXIgc2hvdWxkRHJhd09wYWNpdHkgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IHRydWU7XG4gICAgdmFyIHIgPSB0aGlzO1xuICAgIHZhciBub2RlV2lkdGgsIG5vZGVIZWlnaHQ7XG4gICAgdmFyIF9wID0gbm9kZS5fcHJpdmF0ZTtcbiAgICB2YXIgcnMgPSBfcC5yc2NyYXRjaDtcbiAgICB2YXIgcG9zID0gbm9kZS5wb3NpdGlvbigpO1xuXG4gICAgaWYgKCFudW1iZXIkMShwb3MueCkgfHwgIW51bWJlciQxKHBvcy55KSkge1xuICAgICAgcmV0dXJuOyAvLyBjYW4ndCBkcmF3IG5vZGUgd2l0aCB1bmRlZmluZWQgcG9zaXRpb25cbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkRHJhd09wYWNpdHkgJiYgIW5vZGUudmlzaWJsZSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGVsZU9wYWNpdHkgPSBzaG91bGREcmF3T3BhY2l0eSA/IG5vZGUuZWZmZWN0aXZlT3BhY2l0eSgpIDogMTtcbiAgICB2YXIgdXNlUGF0aHMgPSByLnVzZVBhdGhzKCk7XG4gICAgdmFyIHBhdGg7XG4gICAgdmFyIHBhdGhDYWNoZUhpdCA9IGZhbHNlO1xuICAgIHZhciBwYWRkaW5nID0gbm9kZS5wYWRkaW5nKCk7XG4gICAgbm9kZVdpZHRoID0gbm9kZS53aWR0aCgpICsgMiAqIHBhZGRpbmc7XG4gICAgbm9kZUhlaWdodCA9IG5vZGUuaGVpZ2h0KCkgKyAyICogcGFkZGluZzsgLy9cbiAgICAvLyBzZXR1cCBzaGlmdFxuXG4gICAgdmFyIGJiO1xuXG4gICAgaWYgKHNoaWZ0VG9PcmlnaW5XaXRoQmIpIHtcbiAgICAgIGJiID0gc2hpZnRUb09yaWdpbldpdGhCYjtcbiAgICAgIGNvbnRleHQudHJhbnNsYXRlKC1iYi54MSwgLWJiLnkxKTtcbiAgICB9IC8vXG4gICAgLy8gbG9hZCBiZyBpbWFnZVxuXG5cbiAgICB2YXIgYmdJbWdQcm9wID0gbm9kZS5wc3R5bGUoJ2JhY2tncm91bmQtaW1hZ2UnKTtcbiAgICB2YXIgdXJscyA9IGJnSW1nUHJvcC52YWx1ZTtcbiAgICB2YXIgdXJsRGVmaW5lZCA9IG5ldyBBcnJheSh1cmxzLmxlbmd0aCk7XG4gICAgdmFyIGltYWdlID0gbmV3IEFycmF5KHVybHMubGVuZ3RoKTtcbiAgICB2YXIgbnVtSW1hZ2VzID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdXJscy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHVybCA9IHVybHNbaV07XG4gICAgICB2YXIgZGVmZCA9IHVybERlZmluZWRbaV0gPSB1cmwgIT0gbnVsbCAmJiB1cmwgIT09ICdub25lJztcblxuICAgICAgaWYgKGRlZmQpIHtcbiAgICAgICAgdmFyIGJnSW1nQ3Jvc3NPcmlnaW4gPSBub2RlLmN5KCkuc3R5bGUoKS5nZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtaW1hZ2UtY3Jvc3NvcmlnaW4nLCAndmFsdWUnLCBpKTtcbiAgICAgICAgbnVtSW1hZ2VzKys7IC8vIGdldCBpbWFnZSwgYW5kIGlmIG5vdCBsb2FkZWQgdGhlbiBhc2sgdG8gcmVkcmF3IHdoZW4gbGF0ZXIgbG9hZGVkXG5cbiAgICAgICAgaW1hZ2VbaV0gPSByLmdldENhY2hlZEltYWdlKHVybCwgYmdJbWdDcm9zc09yaWdpbiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF9wLmJhY2tncm91bmRUaW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgICAgIG5vZGUuZW1pdEFuZE5vdGlmeSgnYmFja2dyb3VuZCcpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IC8vXG4gICAgLy8gc2V0dXAgc3R5bGVzXG5cblxuICAgIHZhciBkYXJrbmVzcyA9IG5vZGUucHN0eWxlKCdiYWNrZ3JvdW5kLWJsYWNrZW4nKS52YWx1ZTtcbiAgICB2YXIgYm9yZGVyV2lkdGggPSBub2RlLnBzdHlsZSgnYm9yZGVyLXdpZHRoJykucGZWYWx1ZTtcbiAgICB2YXIgYmdPcGFjaXR5ID0gbm9kZS5wc3R5bGUoJ2JhY2tncm91bmQtb3BhY2l0eScpLnZhbHVlICogZWxlT3BhY2l0eTtcbiAgICB2YXIgYm9yZGVyQ29sb3IgPSBub2RlLnBzdHlsZSgnYm9yZGVyLWNvbG9yJykudmFsdWU7XG4gICAgdmFyIGJvcmRlclN0eWxlID0gbm9kZS5wc3R5bGUoJ2JvcmRlci1zdHlsZScpLnZhbHVlO1xuICAgIHZhciBib3JkZXJPcGFjaXR5ID0gbm9kZS5wc3R5bGUoJ2JvcmRlci1vcGFjaXR5JykudmFsdWUgKiBlbGVPcGFjaXR5O1xuICAgIGNvbnRleHQubGluZUpvaW4gPSAnbWl0ZXInOyAvLyBzbyBib3JkZXJzIGFyZSBzcXVhcmUgd2l0aCB0aGUgbm9kZSBzaGFwZVxuXG4gICAgdmFyIHNldHVwU2hhcGVDb2xvciA9IGZ1bmN0aW9uIHNldHVwU2hhcGVDb2xvcigpIHtcbiAgICAgIHZhciBiZ09weSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogYmdPcGFjaXR5O1xuICAgICAgci5lbGVGaWxsU3R5bGUoY29udGV4dCwgbm9kZSwgYmdPcHkpO1xuICAgIH07XG5cbiAgICB2YXIgc2V0dXBCb3JkZXJDb2xvciA9IGZ1bmN0aW9uIHNldHVwQm9yZGVyQ29sb3IoKSB7XG4gICAgICB2YXIgYmRyT3B5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBib3JkZXJPcGFjaXR5O1xuICAgICAgci5jb2xvclN0cm9rZVN0eWxlKGNvbnRleHQsIGJvcmRlckNvbG9yWzBdLCBib3JkZXJDb2xvclsxXSwgYm9yZGVyQ29sb3JbMl0sIGJkck9weSk7XG4gICAgfTsgLy9cbiAgICAvLyBzZXR1cCBzaGFwZVxuXG5cbiAgICB2YXIgc3R5bGVTaGFwZSA9IG5vZGUucHN0eWxlKCdzaGFwZScpLnN0clZhbHVlO1xuICAgIHZhciBzaGFwZVB0cyA9IG5vZGUucHN0eWxlKCdzaGFwZS1wb2x5Z29uLXBvaW50cycpLnBmVmFsdWU7XG5cbiAgICBpZiAodXNlUGF0aHMpIHtcbiAgICAgIGNvbnRleHQudHJhbnNsYXRlKHBvcy54LCBwb3MueSk7XG4gICAgICB2YXIgcGF0aENhY2hlID0gci5ub2RlUGF0aENhY2hlID0gci5ub2RlUGF0aENhY2hlIHx8IFtdO1xuICAgICAgdmFyIGtleSA9IGhhc2hTdHJpbmdzKHN0eWxlU2hhcGUgPT09ICdwb2x5Z29uJyA/IHN0eWxlU2hhcGUgKyAnLCcgKyBzaGFwZVB0cy5qb2luKCcsJykgOiBzdHlsZVNoYXBlLCAnJyArIG5vZGVIZWlnaHQsICcnICsgbm9kZVdpZHRoKTtcbiAgICAgIHZhciBjYWNoZWRQYXRoID0gcGF0aENhY2hlW2tleV07XG5cbiAgICAgIGlmIChjYWNoZWRQYXRoICE9IG51bGwpIHtcbiAgICAgICAgcGF0aCA9IGNhY2hlZFBhdGg7XG4gICAgICAgIHBhdGhDYWNoZUhpdCA9IHRydWU7XG4gICAgICAgIHJzLnBhdGhDYWNoZSA9IHBhdGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXRoID0gbmV3IFBhdGgyRCgpO1xuICAgICAgICBwYXRoQ2FjaGVba2V5XSA9IHJzLnBhdGhDYWNoZSA9IHBhdGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRyYXdTaGFwZSA9IGZ1bmN0aW9uIGRyYXdTaGFwZSgpIHtcbiAgICAgIGlmICghcGF0aENhY2hlSGl0KSB7XG4gICAgICAgIHZhciBucG9zID0gcG9zO1xuXG4gICAgICAgIGlmICh1c2VQYXRocykge1xuICAgICAgICAgIG5wb3MgPSB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMFxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByLm5vZGVTaGFwZXNbci5nZXROb2RlU2hhcGUobm9kZSldLmRyYXcocGF0aCB8fCBjb250ZXh0LCBucG9zLngsIG5wb3MueSwgbm9kZVdpZHRoLCBub2RlSGVpZ2h0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHVzZVBhdGhzKSB7XG4gICAgICAgIGNvbnRleHQuZmlsbChwYXRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgZHJhd0ltYWdlcyA9IGZ1bmN0aW9uIGRyYXdJbWFnZXMoKSB7XG4gICAgICB2YXIgbm9kZU9wYWNpdHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGVsZU9wYWNpdHk7XG4gICAgICB2YXIgaW5zaWRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICAgICAgdmFyIHByZXZCZ2luZyA9IF9wLmJhY2tncm91bmRpbmc7XG4gICAgICB2YXIgdG90YWxDb21wbGV0ZWQgPSAwO1xuXG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgaW1hZ2UubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBiZ0NvbnRhaW5tZW50ID0gbm9kZS5jeSgpLnN0eWxlKCkuZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLWltYWdlLWNvbnRhaW5tZW50JywgJ3ZhbHVlJywgX2kpO1xuXG4gICAgICAgIGlmIChpbnNpZGUgJiYgYmdDb250YWlubWVudCA9PT0gJ292ZXInIHx8ICFpbnNpZGUgJiYgYmdDb250YWlubWVudCA9PT0gJ2luc2lkZScpIHtcbiAgICAgICAgICB0b3RhbENvbXBsZXRlZCsrO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHVybERlZmluZWRbX2ldICYmIGltYWdlW19pXS5jb21wbGV0ZSAmJiAhaW1hZ2VbX2ldLmVycm9yKSB7XG4gICAgICAgICAgdG90YWxDb21wbGV0ZWQrKztcbiAgICAgICAgICByLmRyYXdJbnNjcmliZWRJbWFnZShjb250ZXh0LCBpbWFnZVtfaV0sIG5vZGUsIF9pLCBub2RlT3BhY2l0eSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgX3AuYmFja2dyb3VuZGluZyA9ICEodG90YWxDb21wbGV0ZWQgPT09IG51bUltYWdlcyk7XG5cbiAgICAgIGlmIChwcmV2QmdpbmcgIT09IF9wLmJhY2tncm91bmRpbmcpIHtcbiAgICAgICAgLy8gdXBkYXRlIHN0eWxlIGIvYyA6YmFja2dyb3VuZGluZyBzdGF0ZSBjaGFuZ2VkXG4gICAgICAgIG5vZGUudXBkYXRlU3R5bGUoZmFsc2UpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgZHJhd1BpZSA9IGZ1bmN0aW9uIGRyYXdQaWUoKSB7XG4gICAgICB2YXIgcmVkcmF3U2hhcGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuICAgICAgdmFyIHBpZU9wYWNpdHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGVsZU9wYWNpdHk7XG5cbiAgICAgIGlmIChyLmhhc1BpZShub2RlKSkge1xuICAgICAgICByLmRyYXdQaWUoY29udGV4dCwgbm9kZSwgcGllT3BhY2l0eSk7IC8vIHJlZHJhdy9yZXN0b3JlIHBhdGggaWYgc3RlcHMgYWZ0ZXIgcGllIG5lZWQgaXRcblxuICAgICAgICBpZiAocmVkcmF3U2hhcGUpIHtcbiAgICAgICAgICBpZiAoIXVzZVBhdGhzKSB7XG4gICAgICAgICAgICByLm5vZGVTaGFwZXNbci5nZXROb2RlU2hhcGUobm9kZSldLmRyYXcoY29udGV4dCwgcG9zLngsIHBvcy55LCBub2RlV2lkdGgsIG5vZGVIZWlnaHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgZGFya2VuID0gZnVuY3Rpb24gZGFya2VuKCkge1xuICAgICAgdmFyIGRhcmtlbk9wYWNpdHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGVsZU9wYWNpdHk7XG4gICAgICB2YXIgb3BhY2l0eSA9IChkYXJrbmVzcyA+IDAgPyBkYXJrbmVzcyA6IC1kYXJrbmVzcykgKiBkYXJrZW5PcGFjaXR5O1xuICAgICAgdmFyIGMgPSBkYXJrbmVzcyA+IDAgPyAwIDogMjU1O1xuXG4gICAgICBpZiAoZGFya25lc3MgIT09IDApIHtcbiAgICAgICAgci5jb2xvckZpbGxTdHlsZShjb250ZXh0LCBjLCBjLCBjLCBvcGFjaXR5KTtcblxuICAgICAgICBpZiAodXNlUGF0aHMpIHtcbiAgICAgICAgICBjb250ZXh0LmZpbGwocGF0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGRyYXdCb3JkZXIgPSBmdW5jdGlvbiBkcmF3Qm9yZGVyKCkge1xuICAgICAgaWYgKGJvcmRlcldpZHRoID4gMCkge1xuICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGJvcmRlcldpZHRoO1xuICAgICAgICBjb250ZXh0LmxpbmVDYXAgPSAnYnV0dCc7XG5cbiAgICAgICAgaWYgKGNvbnRleHQuc2V0TGluZURhc2gpIHtcbiAgICAgICAgICAvLyBmb3IgdmVyeSBvdXRvZmRhdGUgYnJvd3NlcnNcbiAgICAgICAgICBzd2l0Y2ggKGJvcmRlclN0eWxlKSB7XG4gICAgICAgICAgICBjYXNlICdkb3R0ZWQnOlxuICAgICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFsxLCAxXSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdkYXNoZWQnOlxuICAgICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFs0LCAyXSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdzb2xpZCc6XG4gICAgICAgICAgICBjYXNlICdkb3VibGUnOlxuICAgICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFtdKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHVzZVBhdGhzKSB7XG4gICAgICAgICAgY29udGV4dC5zdHJva2UocGF0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChib3JkZXJTdHlsZSA9PT0gJ2RvdWJsZScpIHtcbiAgICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGJvcmRlcldpZHRoIC8gMztcbiAgICAgICAgICB2YXIgZ2NvID0gY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb247XG4gICAgICAgICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnZGVzdGluYXRpb24tb3V0JztcblxuICAgICAgICAgIGlmICh1c2VQYXRocykge1xuICAgICAgICAgICAgY29udGV4dC5zdHJva2UocGF0aCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBnY287XG4gICAgICAgIH0gLy8gcmVzZXQgaW4gY2FzZSB3ZSBjaGFuZ2VkIHRoZSBib3JkZXIgc3R5bGVcblxuXG4gICAgICAgIGlmIChjb250ZXh0LnNldExpbmVEYXNoKSB7XG4gICAgICAgICAgLy8gZm9yIHZlcnkgb3V0b2ZkYXRlIGJyb3dzZXJzXG4gICAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChbXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGRyYXdPdmVybGF5ID0gZnVuY3Rpb24gZHJhd092ZXJsYXkoKSB7XG4gICAgICBpZiAoc2hvdWxkRHJhd092ZXJsYXkpIHtcbiAgICAgICAgci5kcmF3Tm9kZU92ZXJsYXkoY29udGV4dCwgbm9kZSwgcG9zLCBub2RlV2lkdGgsIG5vZGVIZWlnaHQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgZHJhd1VuZGVybGF5ID0gZnVuY3Rpb24gZHJhd1VuZGVybGF5KCkge1xuICAgICAgaWYgKHNob3VsZERyYXdPdmVybGF5KSB7XG4gICAgICAgIHIuZHJhd05vZGVVbmRlcmxheShjb250ZXh0LCBub2RlLCBwb3MsIG5vZGVXaWR0aCwgbm9kZUhlaWdodCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBkcmF3VGV4dCA9IGZ1bmN0aW9uIGRyYXdUZXh0KCkge1xuICAgICAgci5kcmF3RWxlbWVudFRleHQoY29udGV4dCwgbm9kZSwgbnVsbCwgZHJhd0xhYmVsKTtcbiAgICB9O1xuXG4gICAgdmFyIGdob3N0ID0gbm9kZS5wc3R5bGUoJ2dob3N0JykudmFsdWUgPT09ICd5ZXMnO1xuXG4gICAgaWYgKGdob3N0KSB7XG4gICAgICB2YXIgZ3ggPSBub2RlLnBzdHlsZSgnZ2hvc3Qtb2Zmc2V0LXgnKS5wZlZhbHVlO1xuICAgICAgdmFyIGd5ID0gbm9kZS5wc3R5bGUoJ2dob3N0LW9mZnNldC15JykucGZWYWx1ZTtcbiAgICAgIHZhciBnaG9zdE9wYWNpdHkgPSBub2RlLnBzdHlsZSgnZ2hvc3Qtb3BhY2l0eScpLnZhbHVlO1xuICAgICAgdmFyIGVmZkdob3N0T3BhY2l0eSA9IGdob3N0T3BhY2l0eSAqIGVsZU9wYWNpdHk7XG4gICAgICBjb250ZXh0LnRyYW5zbGF0ZShneCwgZ3kpO1xuICAgICAgc2V0dXBTaGFwZUNvbG9yKGdob3N0T3BhY2l0eSAqIGJnT3BhY2l0eSk7XG4gICAgICBkcmF3U2hhcGUoKTtcbiAgICAgIGRyYXdJbWFnZXMoZWZmR2hvc3RPcGFjaXR5LCB0cnVlKTtcbiAgICAgIHNldHVwQm9yZGVyQ29sb3IoZ2hvc3RPcGFjaXR5ICogYm9yZGVyT3BhY2l0eSk7XG4gICAgICBkcmF3Qm9yZGVyKCk7XG4gICAgICBkcmF3UGllKGRhcmtuZXNzICE9PSAwIHx8IGJvcmRlcldpZHRoICE9PSAwKTtcbiAgICAgIGRyYXdJbWFnZXMoZWZmR2hvc3RPcGFjaXR5LCBmYWxzZSk7XG4gICAgICBkYXJrZW4oZWZmR2hvc3RPcGFjaXR5KTtcbiAgICAgIGNvbnRleHQudHJhbnNsYXRlKC1neCwgLWd5KTtcbiAgICB9XG5cbiAgICBpZiAodXNlUGF0aHMpIHtcbiAgICAgIGNvbnRleHQudHJhbnNsYXRlKC1wb3MueCwgLXBvcy55KTtcbiAgICB9XG5cbiAgICBkcmF3VW5kZXJsYXkoKTtcblxuICAgIGlmICh1c2VQYXRocykge1xuICAgICAgY29udGV4dC50cmFuc2xhdGUocG9zLngsIHBvcy55KTtcbiAgICB9XG5cbiAgICBzZXR1cFNoYXBlQ29sb3IoKTtcbiAgICBkcmF3U2hhcGUoKTtcbiAgICBkcmF3SW1hZ2VzKGVsZU9wYWNpdHksIHRydWUpO1xuICAgIHNldHVwQm9yZGVyQ29sb3IoKTtcbiAgICBkcmF3Qm9yZGVyKCk7XG4gICAgZHJhd1BpZShkYXJrbmVzcyAhPT0gMCB8fCBib3JkZXJXaWR0aCAhPT0gMCk7XG4gICAgZHJhd0ltYWdlcyhlbGVPcGFjaXR5LCBmYWxzZSk7XG4gICAgZGFya2VuKCk7XG5cbiAgICBpZiAodXNlUGF0aHMpIHtcbiAgICAgIGNvbnRleHQudHJhbnNsYXRlKC1wb3MueCwgLXBvcy55KTtcbiAgICB9XG5cbiAgICBkcmF3VGV4dCgpO1xuICAgIGRyYXdPdmVybGF5KCk7IC8vXG4gICAgLy8gY2xlYW4gdXAgc2hpZnRcblxuICAgIGlmIChzaGlmdFRvT3JpZ2luV2l0aEJiKSB7XG4gICAgICBjb250ZXh0LnRyYW5zbGF0ZShiYi54MSwgYmIueTEpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgZHJhd05vZGVPdmVybGF5VW5kZXJsYXkgPSBmdW5jdGlvbiBkcmF3Tm9kZU92ZXJsYXlVbmRlcmxheShvdmVybGF5T3JVbmRlcmxheSkge1xuICAgIGlmICghWydvdmVybGF5JywgJ3VuZGVybGF5J10uaW5jbHVkZXMob3ZlcmxheU9yVW5kZXJsYXkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RhdGUnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKGNvbnRleHQsIG5vZGUsIHBvcywgbm9kZVdpZHRoLCBub2RlSGVpZ2h0KSB7XG4gICAgICB2YXIgciA9IHRoaXM7XG5cbiAgICAgIGlmICghbm9kZS52aXNpYmxlKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGFkZGluZyA9IG5vZGUucHN0eWxlKFwiXCIuY29uY2F0KG92ZXJsYXlPclVuZGVybGF5LCBcIi1wYWRkaW5nXCIpKS5wZlZhbHVlO1xuICAgICAgdmFyIG9wYWNpdHkgPSBub2RlLnBzdHlsZShcIlwiLmNvbmNhdChvdmVybGF5T3JVbmRlcmxheSwgXCItb3BhY2l0eVwiKSkudmFsdWU7XG4gICAgICB2YXIgY29sb3IgPSBub2RlLnBzdHlsZShcIlwiLmNvbmNhdChvdmVybGF5T3JVbmRlcmxheSwgXCItY29sb3JcIikpLnZhbHVlO1xuICAgICAgdmFyIHNoYXBlID0gbm9kZS5wc3R5bGUoXCJcIi5jb25jYXQob3ZlcmxheU9yVW5kZXJsYXksIFwiLXNoYXBlXCIpKS52YWx1ZTtcblxuICAgICAgaWYgKG9wYWNpdHkgPiAwKSB7XG4gICAgICAgIHBvcyA9IHBvcyB8fCBub2RlLnBvc2l0aW9uKCk7XG5cbiAgICAgICAgaWYgKG5vZGVXaWR0aCA9PSBudWxsIHx8IG5vZGVIZWlnaHQgPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBfcGFkZGluZyA9IG5vZGUucGFkZGluZygpO1xuXG4gICAgICAgICAgbm9kZVdpZHRoID0gbm9kZS53aWR0aCgpICsgMiAqIF9wYWRkaW5nO1xuICAgICAgICAgIG5vZGVIZWlnaHQgPSBub2RlLmhlaWdodCgpICsgMiAqIF9wYWRkaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgci5jb2xvckZpbGxTdHlsZShjb250ZXh0LCBjb2xvclswXSwgY29sb3JbMV0sIGNvbG9yWzJdLCBvcGFjaXR5KTtcbiAgICAgICAgci5ub2RlU2hhcGVzW3NoYXBlXS5kcmF3KGNvbnRleHQsIHBvcy54LCBwb3MueSwgbm9kZVdpZHRoICsgcGFkZGluZyAqIDIsIG5vZGVIZWlnaHQgKyBwYWRkaW5nICogMik7XG4gICAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgQ1JwJDUuZHJhd05vZGVPdmVybGF5ID0gZHJhd05vZGVPdmVybGF5VW5kZXJsYXkoJ292ZXJsYXknKTtcbiAgQ1JwJDUuZHJhd05vZGVVbmRlcmxheSA9IGRyYXdOb2RlT3ZlcmxheVVuZGVybGF5KCd1bmRlcmxheScpOyAvLyBkb2VzIHRoZSBub2RlIGhhdmUgYXQgbGVhc3Qgb25lIHBpZSBwaWVjZT9cblxuICBDUnAkNS5oYXNQaWUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIG5vZGUgPSBub2RlWzBdOyAvLyBlbnN1cmUgZWxlIHJlZlxuXG4gICAgcmV0dXJuIG5vZGUuX3ByaXZhdGUuaGFzUGllO1xuICB9O1xuXG4gIENScCQ1LmRyYXdQaWUgPSBmdW5jdGlvbiAoY29udGV4dCwgbm9kZSwgbm9kZU9wYWNpdHksIHBvcykge1xuICAgIG5vZGUgPSBub2RlWzBdOyAvLyBlbnN1cmUgZWxlIHJlZlxuXG4gICAgcG9zID0gcG9zIHx8IG5vZGUucG9zaXRpb24oKTtcbiAgICB2YXIgY3lTdHlsZSA9IG5vZGUuY3koKS5zdHlsZSgpO1xuICAgIHZhciBwaWVTaXplID0gbm9kZS5wc3R5bGUoJ3BpZS1zaXplJyk7XG4gICAgdmFyIHggPSBwb3MueDtcbiAgICB2YXIgeSA9IHBvcy55O1xuICAgIHZhciBub2RlVyA9IG5vZGUud2lkdGgoKTtcbiAgICB2YXIgbm9kZUggPSBub2RlLmhlaWdodCgpO1xuICAgIHZhciByYWRpdXMgPSBNYXRoLm1pbihub2RlVywgbm9kZUgpIC8gMjsgLy8gbXVzdCBmaXQgaW4gbm9kZVxuXG4gICAgdmFyIGxhc3RQZXJjZW50ID0gMDsgLy8gd2hhdCAlIHRvIGNvbnRpbnVlIGRyYXdpbmcgcGllIHNsaWNlcyBmcm9tIG9uIFswLCAxXVxuXG4gICAgdmFyIHVzZVBhdGhzID0gdGhpcy51c2VQYXRocygpO1xuXG4gICAgaWYgKHVzZVBhdGhzKSB7XG4gICAgICB4ID0gMDtcbiAgICAgIHkgPSAwO1xuICAgIH1cblxuICAgIGlmIChwaWVTaXplLnVuaXRzID09PSAnJScpIHtcbiAgICAgIHJhZGl1cyA9IHJhZGl1cyAqIHBpZVNpemUucGZWYWx1ZTtcbiAgICB9IGVsc2UgaWYgKHBpZVNpemUucGZWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByYWRpdXMgPSBwaWVTaXplLnBmVmFsdWUgLyAyO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IGN5U3R5bGUucGllQmFja2dyb3VuZE47IGkrKykge1xuICAgICAgLy8gMS4uTlxuICAgICAgdmFyIHNpemUgPSBub2RlLnBzdHlsZSgncGllLScgKyBpICsgJy1iYWNrZ3JvdW5kLXNpemUnKS52YWx1ZTtcbiAgICAgIHZhciBjb2xvciA9IG5vZGUucHN0eWxlKCdwaWUtJyArIGkgKyAnLWJhY2tncm91bmQtY29sb3InKS52YWx1ZTtcbiAgICAgIHZhciBvcGFjaXR5ID0gbm9kZS5wc3R5bGUoJ3BpZS0nICsgaSArICctYmFja2dyb3VuZC1vcGFjaXR5JykudmFsdWUgKiBub2RlT3BhY2l0eTtcbiAgICAgIHZhciBwZXJjZW50ID0gc2l6ZSAvIDEwMDsgLy8gbWFwIGludGVnZXIgcmFuZ2UgWzAsIDEwMF0gdG8gWzAsIDFdXG4gICAgICAvLyBwZXJjZW50IGNhbid0IHB1c2ggYmV5b25kIDFcblxuICAgICAgaWYgKHBlcmNlbnQgKyBsYXN0UGVyY2VudCA+IDEpIHtcbiAgICAgICAgcGVyY2VudCA9IDEgLSBsYXN0UGVyY2VudDtcbiAgICAgIH1cblxuICAgICAgdmFyIGFuZ2xlU3RhcnQgPSAxLjUgKiBNYXRoLlBJICsgMiAqIE1hdGguUEkgKiBsYXN0UGVyY2VudDsgLy8gc3RhcnQgYXQgMTIgbydjbG9jayBhbmQgZ28gY2xvY2t3aXNlXG5cbiAgICAgIHZhciBhbmdsZURlbHRhID0gMiAqIE1hdGguUEkgKiBwZXJjZW50O1xuICAgICAgdmFyIGFuZ2xlRW5kID0gYW5nbGVTdGFydCArIGFuZ2xlRGVsdGE7IC8vIGlnbm9yZSBpZlxuICAgICAgLy8gLSB6ZXJvIHNpemVcbiAgICAgIC8vIC0gd2UncmUgYWxyZWFkeSBiZXlvbmQgdGhlIGZ1bGwgY2lyY2xlXG4gICAgICAvLyAtIGFkZGluZyB0aGUgY3VycmVudCBzbGljZSB3b3VsZCBnbyBiZXlvbmQgdGhlIGZ1bGwgY2lyY2xlXG5cbiAgICAgIGlmIChzaXplID09PSAwIHx8IGxhc3RQZXJjZW50ID49IDEgfHwgbGFzdFBlcmNlbnQgKyBwZXJjZW50ID4gMSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgIGNvbnRleHQubW92ZVRvKHgsIHkpO1xuICAgICAgY29udGV4dC5hcmMoeCwgeSwgcmFkaXVzLCBhbmdsZVN0YXJ0LCBhbmdsZUVuZCk7XG4gICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgdGhpcy5jb2xvckZpbGxTdHlsZShjb250ZXh0LCBjb2xvclswXSwgY29sb3JbMV0sIGNvbG9yWzJdLCBvcGFjaXR5KTtcbiAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgICAgbGFzdFBlcmNlbnQgKz0gcGVyY2VudDtcbiAgICB9XG4gIH07XG5cbiAgdmFyIENScCQ0ID0ge307XG4gIHZhciBtb3Rpb25CbHVyRGVsYXkgPSAxMDA7IC8vIHZhciBpc0ZpcmVmb3ggPSB0eXBlb2YgSW5zdGFsbFRyaWdnZXIgIT09ICd1bmRlZmluZWQnO1xuXG4gIENScCQ0LmdldFBpeGVsUmF0aW8gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvbnRleHQgPSB0aGlzLmRhdGEuY29udGV4dHNbMF07XG5cbiAgICBpZiAodGhpcy5mb3JjZWRQaXhlbFJhdGlvICE9IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLmZvcmNlZFBpeGVsUmF0aW87XG4gICAgfVxuXG4gICAgdmFyIGJhY2tpbmdTdG9yZSA9IGNvbnRleHQuYmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjb250ZXh0LndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY29udGV4dC5tb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGNvbnRleHQubXNCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGNvbnRleHQub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY29udGV4dC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IDE7XG4gICAgcmV0dXJuICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKSAvIGJhY2tpbmdTdG9yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICB9O1xuXG4gIENScCQ0LnBhaW50Q2FjaGUgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciBjYWNoZXMgPSB0aGlzLnBhaW50Q2FjaGVzID0gdGhpcy5wYWludENhY2hlcyB8fCBbXTtcbiAgICB2YXIgbmVlZFRvQ3JlYXRlQ2FjaGUgPSB0cnVlO1xuICAgIHZhciBjYWNoZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2FjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjYWNoZSA9IGNhY2hlc1tpXTtcblxuICAgICAgaWYgKGNhY2hlLmNvbnRleHQgPT09IGNvbnRleHQpIHtcbiAgICAgICAgbmVlZFRvQ3JlYXRlQ2FjaGUgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5lZWRUb0NyZWF0ZUNhY2hlKSB7XG4gICAgICBjYWNoZSA9IHtcbiAgICAgICAgY29udGV4dDogY29udGV4dFxuICAgICAgfTtcbiAgICAgIGNhY2hlcy5wdXNoKGNhY2hlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2FjaGU7XG4gIH07XG5cbiAgQ1JwJDQuY3JlYXRlR3JhZGllbnRTdHlsZUZvciA9IGZ1bmN0aW9uIChjb250ZXh0LCBzaGFwZVN0eWxlTmFtZSwgZWxlLCBmaWxsLCBvcGFjaXR5KSB7XG4gICAgdmFyIGdyYWRpZW50U3R5bGU7XG4gICAgdmFyIHVzZVBhdGhzID0gdGhpcy51c2VQYXRocygpO1xuICAgIHZhciBjb2xvcnMgPSBlbGUucHN0eWxlKHNoYXBlU3R5bGVOYW1lICsgJy1ncmFkaWVudC1zdG9wLWNvbG9ycycpLnZhbHVlLFxuICAgICAgICBwb3NpdGlvbnMgPSBlbGUucHN0eWxlKHNoYXBlU3R5bGVOYW1lICsgJy1ncmFkaWVudC1zdG9wLXBvc2l0aW9ucycpLnBmVmFsdWU7XG5cbiAgICBpZiAoZmlsbCA9PT0gJ3JhZGlhbC1ncmFkaWVudCcpIHtcbiAgICAgIGlmIChlbGUuaXNFZGdlKCkpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gZWxlLnNvdXJjZUVuZHBvaW50KCksXG4gICAgICAgICAgICBlbmQgPSBlbGUudGFyZ2V0RW5kcG9pbnQoKSxcbiAgICAgICAgICAgIG1pZCA9IGVsZS5taWRwb2ludCgpO1xuICAgICAgICB2YXIgZDEgPSBkaXN0KHN0YXJ0LCBtaWQpO1xuICAgICAgICB2YXIgZDIgPSBkaXN0KGVuZCwgbWlkKTtcbiAgICAgICAgZ3JhZGllbnRTdHlsZSA9IGNvbnRleHQuY3JlYXRlUmFkaWFsR3JhZGllbnQobWlkLngsIG1pZC55LCAwLCBtaWQueCwgbWlkLnksIE1hdGgubWF4KGQxLCBkMikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHBvcyA9IHVzZVBhdGhzID8ge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMFxuICAgICAgICB9IDogZWxlLnBvc2l0aW9uKCksXG4gICAgICAgICAgICB3aWR0aCA9IGVsZS5wYWRkZWRXaWR0aCgpLFxuICAgICAgICAgICAgaGVpZ2h0ID0gZWxlLnBhZGRlZEhlaWdodCgpO1xuICAgICAgICBncmFkaWVudFN0eWxlID0gY29udGV4dC5jcmVhdGVSYWRpYWxHcmFkaWVudChwb3MueCwgcG9zLnksIDAsIHBvcy54LCBwb3MueSwgTWF0aC5tYXgod2lkdGgsIGhlaWdodCkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZWxlLmlzRWRnZSgpKSB7XG4gICAgICAgIHZhciBfc3RhcnQgPSBlbGUuc291cmNlRW5kcG9pbnQoKSxcbiAgICAgICAgICAgIF9lbmQgPSBlbGUudGFyZ2V0RW5kcG9pbnQoKTtcblxuICAgICAgICBncmFkaWVudFN0eWxlID0gY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudChfc3RhcnQueCwgX3N0YXJ0LnksIF9lbmQueCwgX2VuZC55KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfcG9zID0gdXNlUGF0aHMgPyB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH0gOiBlbGUucG9zaXRpb24oKSxcbiAgICAgICAgICAgIF93aWR0aCA9IGVsZS5wYWRkZWRXaWR0aCgpLFxuICAgICAgICAgICAgX2hlaWdodCA9IGVsZS5wYWRkZWRIZWlnaHQoKSxcbiAgICAgICAgICAgIGhhbGZXaWR0aCA9IF93aWR0aCAvIDIsXG4gICAgICAgICAgICBoYWxmSGVpZ2h0ID0gX2hlaWdodCAvIDI7XG5cbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGVsZS5wc3R5bGUoJ2JhY2tncm91bmQtZ3JhZGllbnQtZGlyZWN0aW9uJykudmFsdWU7XG5cbiAgICAgICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICAgICAgICBjYXNlICd0by1ib3R0b20nOlxuICAgICAgICAgICAgZ3JhZGllbnRTdHlsZSA9IGNvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQoX3Bvcy54LCBfcG9zLnkgLSBoYWxmSGVpZ2h0LCBfcG9zLngsIF9wb3MueSArIGhhbGZIZWlnaHQpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd0by10b3AnOlxuICAgICAgICAgICAgZ3JhZGllbnRTdHlsZSA9IGNvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQoX3Bvcy54LCBfcG9zLnkgKyBoYWxmSGVpZ2h0LCBfcG9zLngsIF9wb3MueSAtIGhhbGZIZWlnaHQpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd0by1sZWZ0JzpcbiAgICAgICAgICAgIGdyYWRpZW50U3R5bGUgPSBjb250ZXh0LmNyZWF0ZUxpbmVhckdyYWRpZW50KF9wb3MueCArIGhhbGZXaWR0aCwgX3Bvcy55LCBfcG9zLnggLSBoYWxmV2lkdGgsIF9wb3MueSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3RvLXJpZ2h0JzpcbiAgICAgICAgICAgIGdyYWRpZW50U3R5bGUgPSBjb250ZXh0LmNyZWF0ZUxpbmVhckdyYWRpZW50KF9wb3MueCAtIGhhbGZXaWR0aCwgX3Bvcy55LCBfcG9zLnggKyBoYWxmV2lkdGgsIF9wb3MueSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3RvLWJvdHRvbS1yaWdodCc6XG4gICAgICAgICAgY2FzZSAndG8tcmlnaHQtYm90dG9tJzpcbiAgICAgICAgICAgIGdyYWRpZW50U3R5bGUgPSBjb250ZXh0LmNyZWF0ZUxpbmVhckdyYWRpZW50KF9wb3MueCAtIGhhbGZXaWR0aCwgX3Bvcy55IC0gaGFsZkhlaWdodCwgX3Bvcy54ICsgaGFsZldpZHRoLCBfcG9zLnkgKyBoYWxmSGVpZ2h0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAndG8tdG9wLXJpZ2h0JzpcbiAgICAgICAgICBjYXNlICd0by1yaWdodC10b3AnOlxuICAgICAgICAgICAgZ3JhZGllbnRTdHlsZSA9IGNvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQoX3Bvcy54IC0gaGFsZldpZHRoLCBfcG9zLnkgKyBoYWxmSGVpZ2h0LCBfcG9zLnggKyBoYWxmV2lkdGgsIF9wb3MueSAtIGhhbGZIZWlnaHQpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd0by1ib3R0b20tbGVmdCc6XG4gICAgICAgICAgY2FzZSAndG8tbGVmdC1ib3R0b20nOlxuICAgICAgICAgICAgZ3JhZGllbnRTdHlsZSA9IGNvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQoX3Bvcy54ICsgaGFsZldpZHRoLCBfcG9zLnkgLSBoYWxmSGVpZ2h0LCBfcG9zLnggLSBoYWxmV2lkdGgsIF9wb3MueSArIGhhbGZIZWlnaHQpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd0by10b3AtbGVmdCc6XG4gICAgICAgICAgY2FzZSAndG8tbGVmdC10b3AnOlxuICAgICAgICAgICAgZ3JhZGllbnRTdHlsZSA9IGNvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQoX3Bvcy54ICsgaGFsZldpZHRoLCBfcG9zLnkgKyBoYWxmSGVpZ2h0LCBfcG9zLnggLSBoYWxmV2lkdGgsIF9wb3MueSAtIGhhbGZIZWlnaHQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWdyYWRpZW50U3R5bGUpIHJldHVybiBudWxsOyAvLyBpbnZhbGlkIGdyYWRpZW50IHN0eWxlXG5cbiAgICB2YXIgaGFzUG9zaXRpb25zID0gcG9zaXRpb25zLmxlbmd0aCA9PT0gY29sb3JzLmxlbmd0aDtcbiAgICB2YXIgbGVuZ3RoID0gY29sb3JzLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGdyYWRpZW50U3R5bGUuYWRkQ29sb3JTdG9wKGhhc1Bvc2l0aW9ucyA/IHBvc2l0aW9uc1tpXSA6IGkgLyAobGVuZ3RoIC0gMSksICdyZ2JhKCcgKyBjb2xvcnNbaV1bMF0gKyAnLCcgKyBjb2xvcnNbaV1bMV0gKyAnLCcgKyBjb2xvcnNbaV1bMl0gKyAnLCcgKyBvcGFjaXR5ICsgJyknKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZ3JhZGllbnRTdHlsZTtcbiAgfTtcblxuICBDUnAkNC5ncmFkaWVudEZpbGxTdHlsZSA9IGZ1bmN0aW9uIChjb250ZXh0LCBlbGUsIGZpbGwsIG9wYWNpdHkpIHtcbiAgICB2YXIgZ3JhZGllbnRTdHlsZSA9IHRoaXMuY3JlYXRlR3JhZGllbnRTdHlsZUZvcihjb250ZXh0LCAnYmFja2dyb3VuZCcsIGVsZSwgZmlsbCwgb3BhY2l0eSk7XG4gICAgaWYgKCFncmFkaWVudFN0eWxlKSByZXR1cm4gbnVsbDsgLy8gZXJyb3JcblxuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gZ3JhZGllbnRTdHlsZTtcbiAgfTtcblxuICBDUnAkNC5jb2xvckZpbGxTdHlsZSA9IGZ1bmN0aW9uIChjb250ZXh0LCByLCBnLCBiLCBhKSB7XG4gICAgY29udGV4dC5maWxsU3R5bGUgPSAncmdiYSgnICsgciArICcsJyArIGcgKyAnLCcgKyBiICsgJywnICsgYSArICcpJzsgLy8gdHVybiBvZmYgZm9yIG5vdywgc2VlbXMgY29udGV4dCBkb2VzIGl0cyBvd24gY2FjaGluZ1xuICAgIC8vIHZhciBjYWNoZSA9IHRoaXMucGFpbnRDYWNoZShjb250ZXh0KTtcbiAgICAvLyB2YXIgZmlsbFN0eWxlID0gJ3JnYmEoJyArIHIgKyAnLCcgKyBnICsgJywnICsgYiArICcsJyArIGEgKyAnKSc7XG4gICAgLy8gaWYoIGNhY2hlLmZpbGxTdHlsZSAhPT0gZmlsbFN0eWxlICl7XG4gICAgLy8gICBjb250ZXh0LmZpbGxTdHlsZSA9IGNhY2hlLmZpbGxTdHlsZSA9IGZpbGxTdHlsZTtcbiAgICAvLyB9XG4gIH07XG5cbiAgQ1JwJDQuZWxlRmlsbFN0eWxlID0gZnVuY3Rpb24gKGNvbnRleHQsIGVsZSwgb3BhY2l0eSkge1xuICAgIHZhciBiYWNrZ3JvdW5kRmlsbCA9IGVsZS5wc3R5bGUoJ2JhY2tncm91bmQtZmlsbCcpLnZhbHVlO1xuXG4gICAgaWYgKGJhY2tncm91bmRGaWxsID09PSAnbGluZWFyLWdyYWRpZW50JyB8fCBiYWNrZ3JvdW5kRmlsbCA9PT0gJ3JhZGlhbC1ncmFkaWVudCcpIHtcbiAgICAgIHRoaXMuZ3JhZGllbnRGaWxsU3R5bGUoY29udGV4dCwgZWxlLCBiYWNrZ3JvdW5kRmlsbCwgb3BhY2l0eSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBiYWNrZ3JvdW5kQ29sb3IgPSBlbGUucHN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJykudmFsdWU7XG4gICAgICB0aGlzLmNvbG9yRmlsbFN0eWxlKGNvbnRleHQsIGJhY2tncm91bmRDb2xvclswXSwgYmFja2dyb3VuZENvbG9yWzFdLCBiYWNrZ3JvdW5kQ29sb3JbMl0sIG9wYWNpdHkpO1xuICAgIH1cbiAgfTtcblxuICBDUnAkNC5ncmFkaWVudFN0cm9rZVN0eWxlID0gZnVuY3Rpb24gKGNvbnRleHQsIGVsZSwgZmlsbCwgb3BhY2l0eSkge1xuICAgIHZhciBncmFkaWVudFN0eWxlID0gdGhpcy5jcmVhdGVHcmFkaWVudFN0eWxlRm9yKGNvbnRleHQsICdsaW5lJywgZWxlLCBmaWxsLCBvcGFjaXR5KTtcbiAgICBpZiAoIWdyYWRpZW50U3R5bGUpIHJldHVybiBudWxsOyAvLyBlcnJvclxuXG4gICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGdyYWRpZW50U3R5bGU7XG4gIH07XG5cbiAgQ1JwJDQuY29sb3JTdHJva2VTdHlsZSA9IGZ1bmN0aW9uIChjb250ZXh0LCByLCBnLCBiLCBhKSB7XG4gICAgY29udGV4dC5zdHJva2VTdHlsZSA9ICdyZ2JhKCcgKyByICsgJywnICsgZyArICcsJyArIGIgKyAnLCcgKyBhICsgJyknOyAvLyB0dXJuIG9mZiBmb3Igbm93LCBzZWVtcyBjb250ZXh0IGRvZXMgaXRzIG93biBjYWNoaW5nXG4gICAgLy8gdmFyIGNhY2hlID0gdGhpcy5wYWludENhY2hlKGNvbnRleHQpO1xuICAgIC8vIHZhciBzdHJva2VTdHlsZSA9ICdyZ2JhKCcgKyByICsgJywnICsgZyArICcsJyArIGIgKyAnLCcgKyBhICsgJyknO1xuICAgIC8vIGlmKCBjYWNoZS5zdHJva2VTdHlsZSAhPT0gc3Ryb2tlU3R5bGUgKXtcbiAgICAvLyAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjYWNoZS5zdHJva2VTdHlsZSA9IHN0cm9rZVN0eWxlO1xuICAgIC8vIH1cbiAgfTtcblxuICBDUnAkNC5lbGVTdHJva2VTdHlsZSA9IGZ1bmN0aW9uIChjb250ZXh0LCBlbGUsIG9wYWNpdHkpIHtcbiAgICB2YXIgbGluZUZpbGwgPSBlbGUucHN0eWxlKCdsaW5lLWZpbGwnKS52YWx1ZTtcblxuICAgIGlmIChsaW5lRmlsbCA9PT0gJ2xpbmVhci1ncmFkaWVudCcgfHwgbGluZUZpbGwgPT09ICdyYWRpYWwtZ3JhZGllbnQnKSB7XG4gICAgICB0aGlzLmdyYWRpZW50U3Ryb2tlU3R5bGUoY29udGV4dCwgZWxlLCBsaW5lRmlsbCwgb3BhY2l0eSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBsaW5lQ29sb3IgPSBlbGUucHN0eWxlKCdsaW5lLWNvbG9yJykudmFsdWU7XG4gICAgICB0aGlzLmNvbG9yU3Ryb2tlU3R5bGUoY29udGV4dCwgbGluZUNvbG9yWzBdLCBsaW5lQ29sb3JbMV0sIGxpbmVDb2xvclsyXSwgb3BhY2l0eSk7XG4gICAgfVxuICB9OyAvLyBSZXNpemUgY2FudmFzXG5cblxuICBDUnAkNC5tYXRjaENhbnZhc1NpemUgPSBmdW5jdGlvbiAoY29udGFpbmVyKSB7XG4gICAgdmFyIHIgPSB0aGlzO1xuICAgIHZhciBkYXRhID0gci5kYXRhO1xuICAgIHZhciBiYiA9IHIuZmluZENvbnRhaW5lckNsaWVudENvb3JkcygpO1xuICAgIHZhciB3aWR0aCA9IGJiWzJdO1xuICAgIHZhciBoZWlnaHQgPSBiYlszXTtcbiAgICB2YXIgcGl4ZWxSYXRpbyA9IHIuZ2V0UGl4ZWxSYXRpbygpO1xuICAgIHZhciBtYlB4UmF0aW8gPSByLm1vdGlvbkJsdXJQeFJhdGlvO1xuXG4gICAgaWYgKGNvbnRhaW5lciA9PT0gci5kYXRhLmJ1ZmZlckNhbnZhc2VzW3IuTU9USU9OQkxVUl9CVUZGRVJfTk9ERV0gfHwgY29udGFpbmVyID09PSByLmRhdGEuYnVmZmVyQ2FudmFzZXNbci5NT1RJT05CTFVSX0JVRkZFUl9EUkFHXSkge1xuICAgICAgcGl4ZWxSYXRpbyA9IG1iUHhSYXRpbztcbiAgICB9XG5cbiAgICB2YXIgY2FudmFzV2lkdGggPSB3aWR0aCAqIHBpeGVsUmF0aW87XG4gICAgdmFyIGNhbnZhc0hlaWdodCA9IGhlaWdodCAqIHBpeGVsUmF0aW87XG4gICAgdmFyIGNhbnZhcztcblxuICAgIGlmIChjYW52YXNXaWR0aCA9PT0gci5jYW52YXNXaWR0aCAmJiBjYW52YXNIZWlnaHQgPT09IHIuY2FudmFzSGVpZ2h0KSB7XG4gICAgICByZXR1cm47IC8vIHNhdmUgY3ljbGVzIGlmIHNhbWVcbiAgICB9XG5cbiAgICByLmZvbnRDYWNoZXMgPSBudWxsOyAvLyByZXNpemluZyByZXNldHMgdGhlIHN0eWxlXG5cbiAgICB2YXIgY2FudmFzQ29udGFpbmVyID0gZGF0YS5jYW52YXNDb250YWluZXI7XG4gICAgY2FudmFzQ29udGFpbmVyLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgIGNhbnZhc0NvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByLkNBTlZBU19MQVlFUlM7IGkrKykge1xuICAgICAgY2FudmFzID0gZGF0YS5jYW52YXNlc1tpXTtcbiAgICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhc1dpZHRoO1xuICAgICAgY2FudmFzLmhlaWdodCA9IGNhbnZhc0hlaWdodDtcbiAgICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgci5CVUZGRVJfQ09VTlQ7IGkrKykge1xuICAgICAgY2FudmFzID0gZGF0YS5idWZmZXJDYW52YXNlc1tpXTtcbiAgICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhc1dpZHRoO1xuICAgICAgY2FudmFzLmhlaWdodCA9IGNhbnZhc0hlaWdodDtcbiAgICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICAgIH1cblxuICAgIHIudGV4dHVyZU11bHQgPSAxO1xuXG4gICAgaWYgKHBpeGVsUmF0aW8gPD0gMSkge1xuICAgICAgY2FudmFzID0gZGF0YS5idWZmZXJDYW52YXNlc1tyLlRFWFRVUkVfQlVGRkVSXTtcbiAgICAgIHIudGV4dHVyZU11bHQgPSAyO1xuICAgICAgY2FudmFzLndpZHRoID0gY2FudmFzV2lkdGggKiByLnRleHR1cmVNdWx0O1xuICAgICAgY2FudmFzLmhlaWdodCA9IGNhbnZhc0hlaWdodCAqIHIudGV4dHVyZU11bHQ7XG4gICAgfVxuXG4gICAgci5jYW52YXNXaWR0aCA9IGNhbnZhc1dpZHRoO1xuICAgIHIuY2FudmFzSGVpZ2h0ID0gY2FudmFzSGVpZ2h0O1xuICB9O1xuXG4gIENScCQ0LnJlbmRlclRvID0gZnVuY3Rpb24gKGN4dCwgem9vbSwgcGFuLCBweFJhdGlvKSB7XG4gICAgdGhpcy5yZW5kZXIoe1xuICAgICAgZm9yY2VkQ29udGV4dDogY3h0LFxuICAgICAgZm9yY2VkWm9vbTogem9vbSxcbiAgICAgIGZvcmNlZFBhbjogcGFuLFxuICAgICAgZHJhd0FsbExheWVyczogdHJ1ZSxcbiAgICAgIGZvcmNlZFB4UmF0aW86IHB4UmF0aW9cbiAgICB9KTtcbiAgfTtcblxuICBDUnAkNC5yZW5kZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHN0YXRpY0VtcHR5T2JqZWN0KCk7XG4gICAgdmFyIGZvcmNlZENvbnRleHQgPSBvcHRpb25zLmZvcmNlZENvbnRleHQ7XG4gICAgdmFyIGRyYXdBbGxMYXllcnMgPSBvcHRpb25zLmRyYXdBbGxMYXllcnM7XG4gICAgdmFyIGRyYXdPbmx5Tm9kZUxheWVyID0gb3B0aW9ucy5kcmF3T25seU5vZGVMYXllcjtcbiAgICB2YXIgZm9yY2VkWm9vbSA9IG9wdGlvbnMuZm9yY2VkWm9vbTtcbiAgICB2YXIgZm9yY2VkUGFuID0gb3B0aW9ucy5mb3JjZWRQYW47XG4gICAgdmFyIHIgPSB0aGlzO1xuICAgIHZhciBwaXhlbFJhdGlvID0gb3B0aW9ucy5mb3JjZWRQeFJhdGlvID09PSB1bmRlZmluZWQgPyB0aGlzLmdldFBpeGVsUmF0aW8oKSA6IG9wdGlvbnMuZm9yY2VkUHhSYXRpbztcbiAgICB2YXIgY3kgPSByLmN5O1xuICAgIHZhciBkYXRhID0gci5kYXRhO1xuICAgIHZhciBuZWVkRHJhdyA9IGRhdGEuY2FudmFzTmVlZHNSZWRyYXc7XG4gICAgdmFyIHRleHR1cmVEcmF3ID0gci50ZXh0dXJlT25WaWV3cG9ydCAmJiAhZm9yY2VkQ29udGV4dCAmJiAoci5waW5jaGluZyB8fCByLmhvdmVyRGF0YS5kcmFnZ2luZyB8fCByLnN3aXBlUGFubmluZyB8fCByLmRhdGEud2hlZWxab29taW5nKTtcbiAgICB2YXIgbW90aW9uQmx1ciA9IG9wdGlvbnMubW90aW9uQmx1ciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tb3Rpb25CbHVyIDogci5tb3Rpb25CbHVyO1xuICAgIHZhciBtYlB4UmF0aW8gPSByLm1vdGlvbkJsdXJQeFJhdGlvO1xuICAgIHZhciBoYXNDb21wb3VuZE5vZGVzID0gY3kuaGFzQ29tcG91bmROb2RlcygpO1xuICAgIHZhciBpbk5vZGVEcmFnR2VzdHVyZSA9IHIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcztcbiAgICB2YXIgaW5Cb3hTZWxlY3Rpb24gPSByLmhvdmVyRGF0YS5zZWxlY3RpbmcgfHwgci50b3VjaERhdGEuc2VsZWN0aW5nID8gdHJ1ZSA6IGZhbHNlO1xuICAgIG1vdGlvbkJsdXIgPSBtb3Rpb25CbHVyICYmICFmb3JjZWRDb250ZXh0ICYmIHIubW90aW9uQmx1ckVuYWJsZWQgJiYgIWluQm94U2VsZWN0aW9uO1xuICAgIHZhciBtb3Rpb25CbHVyRmFkZUVmZmVjdCA9IG1vdGlvbkJsdXI7XG5cbiAgICBpZiAoIWZvcmNlZENvbnRleHQpIHtcbiAgICAgIGlmIChyLnByZXZQeFJhdGlvICE9PSBwaXhlbFJhdGlvKSB7XG4gICAgICAgIHIuaW52YWxpZGF0ZUNvbnRhaW5lckNsaWVudENvb3Jkc0NhY2hlKCk7XG4gICAgICAgIHIubWF0Y2hDYW52YXNTaXplKHIuY29udGFpbmVyKTtcbiAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgIHIucmVkcmF3SGludCgnZHJhZycsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICByLnByZXZQeFJhdGlvID0gcGl4ZWxSYXRpbztcbiAgICB9XG5cbiAgICBpZiAoIWZvcmNlZENvbnRleHQgJiYgci5tb3Rpb25CbHVyVGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHIubW90aW9uQmx1clRpbWVvdXQpO1xuICAgIH1cblxuICAgIGlmIChtb3Rpb25CbHVyKSB7XG4gICAgICBpZiAoci5tYkZyYW1lcyA9PSBudWxsKSB7XG4gICAgICAgIHIubWJGcmFtZXMgPSAwO1xuICAgICAgfVxuXG4gICAgICByLm1iRnJhbWVzKys7XG5cbiAgICAgIGlmIChyLm1iRnJhbWVzIDwgMykge1xuICAgICAgICAvLyBuZWVkIHNldmVyYWwgZnJhbWVzIGJlZm9yZSBldmVuIGhpZ2ggcXVhbGl0eSBtb3Rpb25ibHVyXG4gICAgICAgIG1vdGlvbkJsdXJGYWRlRWZmZWN0ID0gZmFsc2U7XG4gICAgICB9IC8vIGdvIHRvIGxvd2VyIHF1YWxpdHkgYmx1cnJ5IGZyYW1lcyB3aGVuIHNldmVyYWwgbS9iIGZyYW1lcyBoYXZlIGJlZW4gcmVuZGVyZWQgKGF2b2lkcyBmbGFzaGluZylcblxuXG4gICAgICBpZiAoci5tYkZyYW1lcyA+IHIubWluTWJMb3dRdWFsRnJhbWVzKSB7XG4gICAgICAgIC8vci5mdWxsUXVhbGl0eU1iID0gZmFsc2U7XG4gICAgICAgIHIubW90aW9uQmx1clB4UmF0aW8gPSByLm1iUHhSQmx1cnJ5O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyLmNsZWFyaW5nTW90aW9uQmx1cikge1xuICAgICAgci5tb3Rpb25CbHVyUHhSYXRpbyA9IDE7XG4gICAgfSAvLyBiL2MgZHJhd1RvQ29udGV4dCgpIG1heSBiZSBhc3luYyB3LnIudC4gcmVkcmF3KCksIGtlZXAgdHJhY2sgb2YgbGFzdCB0ZXh0dXJlIGZyYW1lXG4gICAgLy8gYmVjYXVzZSBhIHJvZ3VlIGFzeW5jIHRleHR1cmUgZnJhbWUgd291bGQgY2xlYXIgbmVlZERyYXdcblxuXG4gICAgaWYgKHIudGV4dHVyZURyYXdMYXN0RnJhbWUgJiYgIXRleHR1cmVEcmF3KSB7XG4gICAgICBuZWVkRHJhd1tyLk5PREVdID0gdHJ1ZTtcbiAgICAgIG5lZWREcmF3W3IuU0VMRUNUX0JPWF0gPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBzdHlsZSA9IGN5LnN0eWxlKCk7XG4gICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgdmFyIGVmZmVjdGl2ZVpvb20gPSBmb3JjZWRab29tICE9PSB1bmRlZmluZWQgPyBmb3JjZWRab29tIDogem9vbTtcbiAgICB2YXIgcGFuID0gY3kucGFuKCk7XG4gICAgdmFyIGVmZmVjdGl2ZVBhbiA9IHtcbiAgICAgIHg6IHBhbi54LFxuICAgICAgeTogcGFuLnlcbiAgICB9O1xuICAgIHZhciB2cCA9IHtcbiAgICAgIHpvb206IHpvb20sXG4gICAgICBwYW46IHtcbiAgICAgICAgeDogcGFuLngsXG4gICAgICAgIHk6IHBhbi55XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgcHJldlZwID0gci5wcmV2Vmlld3BvcnQ7XG4gICAgdmFyIHZpZXdwb3J0SXNEaWZmID0gcHJldlZwID09PSB1bmRlZmluZWQgfHwgdnAuem9vbSAhPT0gcHJldlZwLnpvb20gfHwgdnAucGFuLnggIT09IHByZXZWcC5wYW4ueCB8fCB2cC5wYW4ueSAhPT0gcHJldlZwLnBhbi55OyAvLyB3ZSB3YW50IHRoZSBsb3cgcXVhbGl0eSBtb3Rpb25ibHVyIG9ubHkgd2hlbiB0aGUgdmlld3BvcnQgaXMgYmVpbmcgbWFuaXB1bGF0ZWQgZXRjICh3aGVyZSBpdCdzIG5vdCBub3RpY2VkKVxuXG4gICAgaWYgKCF2aWV3cG9ydElzRGlmZiAmJiAhKGluTm9kZURyYWdHZXN0dXJlICYmICFoYXNDb21wb3VuZE5vZGVzKSkge1xuICAgICAgci5tb3Rpb25CbHVyUHhSYXRpbyA9IDE7XG4gICAgfVxuXG4gICAgaWYgKGZvcmNlZFBhbikge1xuICAgICAgZWZmZWN0aXZlUGFuID0gZm9yY2VkUGFuO1xuICAgIH0gLy8gYXBwbHkgcGl4ZWwgcmF0aW9cblxuXG4gICAgZWZmZWN0aXZlWm9vbSAqPSBwaXhlbFJhdGlvO1xuICAgIGVmZmVjdGl2ZVBhbi54ICo9IHBpeGVsUmF0aW87XG4gICAgZWZmZWN0aXZlUGFuLnkgKj0gcGl4ZWxSYXRpbztcbiAgICB2YXIgZWxlcyA9IHIuZ2V0Q2FjaGVkWlNvcnRlZEVsZXMoKTtcblxuICAgIGZ1bmN0aW9uIG1iY2xlYXIoY29udGV4dCwgeCwgeSwgdywgaCkge1xuICAgICAgdmFyIGdjbyA9IGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uO1xuICAgICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnZGVzdGluYXRpb24tb3V0JztcbiAgICAgIHIuY29sb3JGaWxsU3R5bGUoY29udGV4dCwgMjU1LCAyNTUsIDI1NSwgci5tb3Rpb25CbHVyVHJhbnNwYXJlbmN5KTtcbiAgICAgIGNvbnRleHQuZmlsbFJlY3QoeCwgeSwgdywgaCk7XG4gICAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IGdjbztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRDb250ZXh0VHJhbnNmb3JtKGNvbnRleHQsIGNsZWFyKSB7XG4gICAgICB2YXIgZVBhbiwgZVpvb20sIHcsIGg7XG5cbiAgICAgIGlmICghci5jbGVhcmluZ01vdGlvbkJsdXIgJiYgKGNvbnRleHQgPT09IGRhdGEuYnVmZmVyQ29udGV4dHNbci5NT1RJT05CTFVSX0JVRkZFUl9OT0RFXSB8fCBjb250ZXh0ID09PSBkYXRhLmJ1ZmZlckNvbnRleHRzW3IuTU9USU9OQkxVUl9CVUZGRVJfRFJBR10pKSB7XG4gICAgICAgIGVQYW4gPSB7XG4gICAgICAgICAgeDogcGFuLnggKiBtYlB4UmF0aW8sXG4gICAgICAgICAgeTogcGFuLnkgKiBtYlB4UmF0aW9cbiAgICAgICAgfTtcbiAgICAgICAgZVpvb20gPSB6b29tICogbWJQeFJhdGlvO1xuICAgICAgICB3ID0gci5jYW52YXNXaWR0aCAqIG1iUHhSYXRpbztcbiAgICAgICAgaCA9IHIuY2FudmFzSGVpZ2h0ICogbWJQeFJhdGlvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZVBhbiA9IGVmZmVjdGl2ZVBhbjtcbiAgICAgICAgZVpvb20gPSBlZmZlY3RpdmVab29tO1xuICAgICAgICB3ID0gci5jYW52YXNXaWR0aDtcbiAgICAgICAgaCA9IHIuY2FudmFzSGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcblxuICAgICAgaWYgKGNsZWFyID09PSAnbW90aW9uQmx1cicpIHtcbiAgICAgICAgbWJjbGVhcihjb250ZXh0LCAwLCAwLCB3LCBoKTtcbiAgICAgIH0gZWxzZSBpZiAoIWZvcmNlZENvbnRleHQgJiYgKGNsZWFyID09PSB1bmRlZmluZWQgfHwgY2xlYXIpKSB7XG4gICAgICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHcsIGgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWRyYXdBbGxMYXllcnMpIHtcbiAgICAgICAgY29udGV4dC50cmFuc2xhdGUoZVBhbi54LCBlUGFuLnkpO1xuICAgICAgICBjb250ZXh0LnNjYWxlKGVab29tLCBlWm9vbSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChmb3JjZWRQYW4pIHtcbiAgICAgICAgY29udGV4dC50cmFuc2xhdGUoZm9yY2VkUGFuLngsIGZvcmNlZFBhbi55KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZvcmNlZFpvb20pIHtcbiAgICAgICAgY29udGV4dC5zY2FsZShmb3JjZWRab29tLCBmb3JjZWRab29tKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRleHR1cmVEcmF3KSB7XG4gICAgICByLnRleHR1cmVEcmF3TGFzdEZyYW1lID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHRleHR1cmVEcmF3KSB7XG4gICAgICByLnRleHR1cmVEcmF3TGFzdEZyYW1lID0gdHJ1ZTtcblxuICAgICAgaWYgKCFyLnRleHR1cmVDYWNoZSkge1xuICAgICAgICByLnRleHR1cmVDYWNoZSA9IHt9O1xuICAgICAgICByLnRleHR1cmVDYWNoZS5iYiA9IGN5Lm11dGFibGVFbGVtZW50cygpLmJvdW5kaW5nQm94KCk7XG4gICAgICAgIHIudGV4dHVyZUNhY2hlLnRleHR1cmUgPSByLmRhdGEuYnVmZmVyQ2FudmFzZXNbci5URVhUVVJFX0JVRkZFUl07XG4gICAgICAgIHZhciBjeHQgPSByLmRhdGEuYnVmZmVyQ29udGV4dHNbci5URVhUVVJFX0JVRkZFUl07XG4gICAgICAgIGN4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICAgIGN4dC5jbGVhclJlY3QoMCwgMCwgci5jYW52YXNXaWR0aCAqIHIudGV4dHVyZU11bHQsIHIuY2FudmFzSGVpZ2h0ICogci50ZXh0dXJlTXVsdCk7XG4gICAgICAgIHIucmVuZGVyKHtcbiAgICAgICAgICBmb3JjZWRDb250ZXh0OiBjeHQsXG4gICAgICAgICAgZHJhd09ubHlOb2RlTGF5ZXI6IHRydWUsXG4gICAgICAgICAgZm9yY2VkUHhSYXRpbzogcGl4ZWxSYXRpbyAqIHIudGV4dHVyZU11bHRcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciB2cCA9IHIudGV4dHVyZUNhY2hlLnZpZXdwb3J0ID0ge1xuICAgICAgICAgIHpvb206IGN5Lnpvb20oKSxcbiAgICAgICAgICBwYW46IGN5LnBhbigpLFxuICAgICAgICAgIHdpZHRoOiByLmNhbnZhc1dpZHRoLFxuICAgICAgICAgIGhlaWdodDogci5jYW52YXNIZWlnaHRcbiAgICAgICAgfTtcbiAgICAgICAgdnAubXBhbiA9IHtcbiAgICAgICAgICB4OiAoMCAtIHZwLnBhbi54KSAvIHZwLnpvb20sXG4gICAgICAgICAgeTogKDAgLSB2cC5wYW4ueSkgLyB2cC56b29tXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIG5lZWREcmF3W3IuRFJBR10gPSBmYWxzZTtcbiAgICAgIG5lZWREcmF3W3IuTk9ERV0gPSBmYWxzZTtcbiAgICAgIHZhciBjb250ZXh0ID0gZGF0YS5jb250ZXh0c1tyLk5PREVdO1xuICAgICAgdmFyIHRleHR1cmUgPSByLnRleHR1cmVDYWNoZS50ZXh0dXJlO1xuICAgICAgdmFyIHZwID0gci50ZXh0dXJlQ2FjaGUudmlld3BvcnQ7XG4gICAgICBjb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcblxuICAgICAgaWYgKG1vdGlvbkJsdXIpIHtcbiAgICAgICAgbWJjbGVhcihjb250ZXh0LCAwLCAwLCB2cC53aWR0aCwgdnAuaGVpZ2h0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHZwLndpZHRoLCB2cC5oZWlnaHQpO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3V0c2lkZUJnQ29sb3IgPSBzdHlsZS5jb3JlKCdvdXRzaWRlLXRleHR1cmUtYmctY29sb3InKS52YWx1ZTtcbiAgICAgIHZhciBvdXRzaWRlQmdPcGFjaXR5ID0gc3R5bGUuY29yZSgnb3V0c2lkZS10ZXh0dXJlLWJnLW9wYWNpdHknKS52YWx1ZTtcbiAgICAgIHIuY29sb3JGaWxsU3R5bGUoY29udGV4dCwgb3V0c2lkZUJnQ29sb3JbMF0sIG91dHNpZGVCZ0NvbG9yWzFdLCBvdXRzaWRlQmdDb2xvclsyXSwgb3V0c2lkZUJnT3BhY2l0eSk7XG4gICAgICBjb250ZXh0LmZpbGxSZWN0KDAsIDAsIHZwLndpZHRoLCB2cC5oZWlnaHQpO1xuICAgICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgICBzZXRDb250ZXh0VHJhbnNmb3JtKGNvbnRleHQsIGZhbHNlKTtcbiAgICAgIGNvbnRleHQuY2xlYXJSZWN0KHZwLm1wYW4ueCwgdnAubXBhbi55LCB2cC53aWR0aCAvIHZwLnpvb20gLyBwaXhlbFJhdGlvLCB2cC5oZWlnaHQgLyB2cC56b29tIC8gcGl4ZWxSYXRpbyk7XG4gICAgICBjb250ZXh0LmRyYXdJbWFnZSh0ZXh0dXJlLCB2cC5tcGFuLngsIHZwLm1wYW4ueSwgdnAud2lkdGggLyB2cC56b29tIC8gcGl4ZWxSYXRpbywgdnAuaGVpZ2h0IC8gdnAuem9vbSAvIHBpeGVsUmF0aW8pO1xuICAgIH0gZWxzZSBpZiAoci50ZXh0dXJlT25WaWV3cG9ydCAmJiAhZm9yY2VkQ29udGV4dCkge1xuICAgICAgLy8gY2xlYXIgdGhlIGNhY2hlIHNpbmNlIHdlIGRvbid0IG5lZWQgaXRcbiAgICAgIHIudGV4dHVyZUNhY2hlID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgZXh0ZW50ID0gY3kuZXh0ZW50KCk7XG4gICAgdmFyIHZwTWFuaXAgPSByLnBpbmNoaW5nIHx8IHIuaG92ZXJEYXRhLmRyYWdnaW5nIHx8IHIuc3dpcGVQYW5uaW5nIHx8IHIuZGF0YS53aGVlbFpvb21pbmcgfHwgci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzIHx8IHIuY3kuYW5pbWF0ZWQoKTtcbiAgICB2YXIgaGlkZUVkZ2VzID0gci5oaWRlRWRnZXNPblZpZXdwb3J0ICYmIHZwTWFuaXA7XG4gICAgdmFyIG5lZWRNYkNsZWFyID0gW107XG4gICAgbmVlZE1iQ2xlYXJbci5OT0RFXSA9ICFuZWVkRHJhd1tyLk5PREVdICYmIG1vdGlvbkJsdXIgJiYgIXIuY2xlYXJlZEZvck1vdGlvbkJsdXJbci5OT0RFXSB8fCByLmNsZWFyaW5nTW90aW9uQmx1cjtcblxuICAgIGlmIChuZWVkTWJDbGVhcltyLk5PREVdKSB7XG4gICAgICByLmNsZWFyZWRGb3JNb3Rpb25CbHVyW3IuTk9ERV0gPSB0cnVlO1xuICAgIH1cblxuICAgIG5lZWRNYkNsZWFyW3IuRFJBR10gPSAhbmVlZERyYXdbci5EUkFHXSAmJiBtb3Rpb25CbHVyICYmICFyLmNsZWFyZWRGb3JNb3Rpb25CbHVyW3IuRFJBR10gfHwgci5jbGVhcmluZ01vdGlvbkJsdXI7XG5cbiAgICBpZiAobmVlZE1iQ2xlYXJbci5EUkFHXSkge1xuICAgICAgci5jbGVhcmVkRm9yTW90aW9uQmx1cltyLkRSQUddID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobmVlZERyYXdbci5OT0RFXSB8fCBkcmF3QWxsTGF5ZXJzIHx8IGRyYXdPbmx5Tm9kZUxheWVyIHx8IG5lZWRNYkNsZWFyW3IuTk9ERV0pIHtcbiAgICAgIHZhciB1c2VCdWZmZXIgPSBtb3Rpb25CbHVyICYmICFuZWVkTWJDbGVhcltyLk5PREVdICYmIG1iUHhSYXRpbyAhPT0gMTtcbiAgICAgIHZhciBjb250ZXh0ID0gZm9yY2VkQ29udGV4dCB8fCAodXNlQnVmZmVyID8gci5kYXRhLmJ1ZmZlckNvbnRleHRzW3IuTU9USU9OQkxVUl9CVUZGRVJfTk9ERV0gOiBkYXRhLmNvbnRleHRzW3IuTk9ERV0pO1xuICAgICAgdmFyIGNsZWFyID0gbW90aW9uQmx1ciAmJiAhdXNlQnVmZmVyID8gJ21vdGlvbkJsdXInIDogdW5kZWZpbmVkO1xuICAgICAgc2V0Q29udGV4dFRyYW5zZm9ybShjb250ZXh0LCBjbGVhcik7XG5cbiAgICAgIGlmIChoaWRlRWRnZXMpIHtcbiAgICAgICAgci5kcmF3Q2FjaGVkTm9kZXMoY29udGV4dCwgZWxlcy5ub25kcmFnLCBwaXhlbFJhdGlvLCBleHRlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgci5kcmF3TGF5ZXJlZEVsZW1lbnRzKGNvbnRleHQsIGVsZXMubm9uZHJhZywgcGl4ZWxSYXRpbywgZXh0ZW50KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHIuZGVidWcpIHtcbiAgICAgICAgci5kcmF3RGVidWdQb2ludHMoY29udGV4dCwgZWxlcy5ub25kcmFnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFkcmF3QWxsTGF5ZXJzICYmICFtb3Rpb25CbHVyKSB7XG4gICAgICAgIG5lZWREcmF3W3IuTk9ERV0gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWRyYXdPbmx5Tm9kZUxheWVyICYmIChuZWVkRHJhd1tyLkRSQUddIHx8IGRyYXdBbGxMYXllcnMgfHwgbmVlZE1iQ2xlYXJbci5EUkFHXSkpIHtcbiAgICAgIHZhciB1c2VCdWZmZXIgPSBtb3Rpb25CbHVyICYmICFuZWVkTWJDbGVhcltyLkRSQUddICYmIG1iUHhSYXRpbyAhPT0gMTtcbiAgICAgIHZhciBjb250ZXh0ID0gZm9yY2VkQ29udGV4dCB8fCAodXNlQnVmZmVyID8gci5kYXRhLmJ1ZmZlckNvbnRleHRzW3IuTU9USU9OQkxVUl9CVUZGRVJfRFJBR10gOiBkYXRhLmNvbnRleHRzW3IuRFJBR10pO1xuICAgICAgc2V0Q29udGV4dFRyYW5zZm9ybShjb250ZXh0LCBtb3Rpb25CbHVyICYmICF1c2VCdWZmZXIgPyAnbW90aW9uQmx1cicgOiB1bmRlZmluZWQpO1xuXG4gICAgICBpZiAoaGlkZUVkZ2VzKSB7XG4gICAgICAgIHIuZHJhd0NhY2hlZE5vZGVzKGNvbnRleHQsIGVsZXMuZHJhZywgcGl4ZWxSYXRpbywgZXh0ZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHIuZHJhd0NhY2hlZEVsZW1lbnRzKGNvbnRleHQsIGVsZXMuZHJhZywgcGl4ZWxSYXRpbywgZXh0ZW50KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHIuZGVidWcpIHtcbiAgICAgICAgci5kcmF3RGVidWdQb2ludHMoY29udGV4dCwgZWxlcy5kcmFnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFkcmF3QWxsTGF5ZXJzICYmICFtb3Rpb25CbHVyKSB7XG4gICAgICAgIG5lZWREcmF3W3IuRFJBR10gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoci5zaG93RnBzIHx8ICFkcmF3T25seU5vZGVMYXllciAmJiBuZWVkRHJhd1tyLlNFTEVDVF9CT1hdICYmICFkcmF3QWxsTGF5ZXJzKSB7XG4gICAgICB2YXIgY29udGV4dCA9IGZvcmNlZENvbnRleHQgfHwgZGF0YS5jb250ZXh0c1tyLlNFTEVDVF9CT1hdO1xuICAgICAgc2V0Q29udGV4dFRyYW5zZm9ybShjb250ZXh0KTtcblxuICAgICAgaWYgKHIuc2VsZWN0aW9uWzRdID09IDEgJiYgKHIuaG92ZXJEYXRhLnNlbGVjdGluZyB8fCByLnRvdWNoRGF0YS5zZWxlY3RpbmcpKSB7XG4gICAgICAgIHZhciB6b29tID0gci5jeS56b29tKCk7XG4gICAgICAgIHZhciBib3JkZXJXaWR0aCA9IHN0eWxlLmNvcmUoJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLXdpZHRoJykudmFsdWUgLyB6b29tO1xuICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGJvcmRlcldpZHRoO1xuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICdyZ2JhKCcgKyBzdHlsZS5jb3JlKCdzZWxlY3Rpb24tYm94LWNvbG9yJykudmFsdWVbMF0gKyAnLCcgKyBzdHlsZS5jb3JlKCdzZWxlY3Rpb24tYm94LWNvbG9yJykudmFsdWVbMV0gKyAnLCcgKyBzdHlsZS5jb3JlKCdzZWxlY3Rpb24tYm94LWNvbG9yJykudmFsdWVbMl0gKyAnLCcgKyBzdHlsZS5jb3JlKCdzZWxlY3Rpb24tYm94LW9wYWNpdHknKS52YWx1ZSArICcpJztcbiAgICAgICAgY29udGV4dC5maWxsUmVjdChyLnNlbGVjdGlvblswXSwgci5zZWxlY3Rpb25bMV0sIHIuc2VsZWN0aW9uWzJdIC0gci5zZWxlY3Rpb25bMF0sIHIuc2VsZWN0aW9uWzNdIC0gci5zZWxlY3Rpb25bMV0pO1xuXG4gICAgICAgIGlmIChib3JkZXJXaWR0aCA+IDApIHtcbiAgICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gJ3JnYmEoJyArIHN0eWxlLmNvcmUoJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLWNvbG9yJykudmFsdWVbMF0gKyAnLCcgKyBzdHlsZS5jb3JlKCdzZWxlY3Rpb24tYm94LWJvcmRlci1jb2xvcicpLnZhbHVlWzFdICsgJywnICsgc3R5bGUuY29yZSgnc2VsZWN0aW9uLWJveC1ib3JkZXItY29sb3InKS52YWx1ZVsyXSArICcsJyArIHN0eWxlLmNvcmUoJ3NlbGVjdGlvbi1ib3gtb3BhY2l0eScpLnZhbHVlICsgJyknO1xuICAgICAgICAgIGNvbnRleHQuc3Ryb2tlUmVjdChyLnNlbGVjdGlvblswXSwgci5zZWxlY3Rpb25bMV0sIHIuc2VsZWN0aW9uWzJdIC0gci5zZWxlY3Rpb25bMF0sIHIuc2VsZWN0aW9uWzNdIC0gci5zZWxlY3Rpb25bMV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChkYXRhLmJnQWN0aXZlUG9zaXN0aW9uICYmICFyLmhvdmVyRGF0YS5zZWxlY3RpbmcpIHtcbiAgICAgICAgdmFyIHpvb20gPSByLmN5Lnpvb20oKTtcbiAgICAgICAgdmFyIHBvcyA9IGRhdGEuYmdBY3RpdmVQb3Npc3Rpb247XG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJ3JnYmEoJyArIHN0eWxlLmNvcmUoJ2FjdGl2ZS1iZy1jb2xvcicpLnZhbHVlWzBdICsgJywnICsgc3R5bGUuY29yZSgnYWN0aXZlLWJnLWNvbG9yJykudmFsdWVbMV0gKyAnLCcgKyBzdHlsZS5jb3JlKCdhY3RpdmUtYmctY29sb3InKS52YWx1ZVsyXSArICcsJyArIHN0eWxlLmNvcmUoJ2FjdGl2ZS1iZy1vcGFjaXR5JykudmFsdWUgKyAnKSc7XG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgIGNvbnRleHQuYXJjKHBvcy54LCBwb3MueSwgc3R5bGUuY29yZSgnYWN0aXZlLWJnLXNpemUnKS5wZlZhbHVlIC8gem9vbSwgMCwgMiAqIE1hdGguUEkpO1xuICAgICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRpbWVUb1JlbmRlciA9IHIubGFzdFJlZHJhd1RpbWU7XG5cbiAgICAgIGlmIChyLnNob3dGcHMgJiYgdGltZVRvUmVuZGVyKSB7XG4gICAgICAgIHRpbWVUb1JlbmRlciA9IE1hdGgucm91bmQodGltZVRvUmVuZGVyKTtcbiAgICAgICAgdmFyIGZwcyA9IE1hdGgucm91bmQoMTAwMCAvIHRpbWVUb1JlbmRlcik7XG4gICAgICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICdyZ2JhKDI1NSwgMCwgMCwgMC43NSknO1xuICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gJ3JnYmEoMjU1LCAwLCAwLCAwLjc1KSc7XG4gICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gMTtcbiAgICAgICAgY29udGV4dC5maWxsVGV4dCgnMSBmcmFtZSA9ICcgKyB0aW1lVG9SZW5kZXIgKyAnIG1zID0gJyArIGZwcyArICcgZnBzJywgMCwgMjApO1xuICAgICAgICB2YXIgbWF4RnBzID0gNjA7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlUmVjdCgwLCAzMCwgMjUwLCAyMCk7XG4gICAgICAgIGNvbnRleHQuZmlsbFJlY3QoMCwgMzAsIDI1MCAqIE1hdGgubWluKGZwcyAvIG1heEZwcywgMSksIDIwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFkcmF3QWxsTGF5ZXJzKSB7XG4gICAgICAgIG5lZWREcmF3W3IuU0VMRUNUX0JPWF0gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9IC8vIG1vdGlvbmJsdXI6IGJsaXQgcmVuZGVyZWQgYmx1cnJ5IGZyYW1lc1xuXG5cbiAgICBpZiAobW90aW9uQmx1ciAmJiBtYlB4UmF0aW8gIT09IDEpIHtcbiAgICAgIHZhciBjeHROb2RlID0gZGF0YS5jb250ZXh0c1tyLk5PREVdO1xuICAgICAgdmFyIHR4dE5vZGUgPSByLmRhdGEuYnVmZmVyQ2FudmFzZXNbci5NT1RJT05CTFVSX0JVRkZFUl9OT0RFXTtcbiAgICAgIHZhciBjeHREcmFnID0gZGF0YS5jb250ZXh0c1tyLkRSQUddO1xuICAgICAgdmFyIHR4dERyYWcgPSByLmRhdGEuYnVmZmVyQ2FudmFzZXNbci5NT1RJT05CTFVSX0JVRkZFUl9EUkFHXTtcblxuICAgICAgdmFyIGRyYXdNb3Rpb25CbHVyID0gZnVuY3Rpb24gZHJhd01vdGlvbkJsdXIoY3h0LCB0eHQsIG5lZWRDbGVhcikge1xuICAgICAgICBjeHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuXG4gICAgICAgIGlmIChuZWVkQ2xlYXIgfHwgIW1vdGlvbkJsdXJGYWRlRWZmZWN0KSB7XG4gICAgICAgICAgY3h0LmNsZWFyUmVjdCgwLCAwLCByLmNhbnZhc1dpZHRoLCByLmNhbnZhc0hlaWdodCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWJjbGVhcihjeHQsIDAsIDAsIHIuY2FudmFzV2lkdGgsIHIuY2FudmFzSGVpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBweHIgPSBtYlB4UmF0aW87XG4gICAgICAgIGN4dC5kcmF3SW1hZ2UodHh0LCAvLyBpbWdcbiAgICAgICAgMCwgMCwgLy8gc3gsIHN5XG4gICAgICAgIHIuY2FudmFzV2lkdGggKiBweHIsIHIuY2FudmFzSGVpZ2h0ICogcHhyLCAvLyBzdywgc2hcbiAgICAgICAgMCwgMCwgLy8geCwgeVxuICAgICAgICByLmNhbnZhc1dpZHRoLCByLmNhbnZhc0hlaWdodCAvLyB3LCBoXG4gICAgICAgICk7XG4gICAgICB9O1xuXG4gICAgICBpZiAobmVlZERyYXdbci5OT0RFXSB8fCBuZWVkTWJDbGVhcltyLk5PREVdKSB7XG4gICAgICAgIGRyYXdNb3Rpb25CbHVyKGN4dE5vZGUsIHR4dE5vZGUsIG5lZWRNYkNsZWFyW3IuTk9ERV0pO1xuICAgICAgICBuZWVkRHJhd1tyLk5PREVdID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZWVkRHJhd1tyLkRSQUddIHx8IG5lZWRNYkNsZWFyW3IuRFJBR10pIHtcbiAgICAgICAgZHJhd01vdGlvbkJsdXIoY3h0RHJhZywgdHh0RHJhZywgbmVlZE1iQ2xlYXJbci5EUkFHXSk7XG4gICAgICAgIG5lZWREcmF3W3IuRFJBR10gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByLnByZXZWaWV3cG9ydCA9IHZwO1xuXG4gICAgaWYgKHIuY2xlYXJpbmdNb3Rpb25CbHVyKSB7XG4gICAgICByLmNsZWFyaW5nTW90aW9uQmx1ciA9IGZhbHNlO1xuICAgICAgci5tb3Rpb25CbHVyQ2xlYXJlZCA9IHRydWU7XG4gICAgICByLm1vdGlvbkJsdXIgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChtb3Rpb25CbHVyKSB7XG4gICAgICByLm1vdGlvbkJsdXJUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHIubW90aW9uQmx1clRpbWVvdXQgPSBudWxsO1xuICAgICAgICByLmNsZWFyZWRGb3JNb3Rpb25CbHVyW3IuTk9ERV0gPSBmYWxzZTtcbiAgICAgICAgci5jbGVhcmVkRm9yTW90aW9uQmx1cltyLkRSQUddID0gZmFsc2U7XG4gICAgICAgIHIubW90aW9uQmx1ciA9IGZhbHNlO1xuICAgICAgICByLmNsZWFyaW5nTW90aW9uQmx1ciA9ICF0ZXh0dXJlRHJhdztcbiAgICAgICAgci5tYkZyYW1lcyA9IDA7XG4gICAgICAgIG5lZWREcmF3W3IuTk9ERV0gPSB0cnVlO1xuICAgICAgICBuZWVkRHJhd1tyLkRSQUddID0gdHJ1ZTtcbiAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgIH0sIG1vdGlvbkJsdXJEZWxheSk7XG4gICAgfVxuXG4gICAgaWYgKCFmb3JjZWRDb250ZXh0KSB7XG4gICAgICBjeS5lbWl0KCdyZW5kZXInKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIENScCQzID0ge307IC8vIEBPIFBvbHlnb24gZHJhd2luZ1xuXG4gIENScCQzLmRyYXdQb2x5Z29uUGF0aCA9IGZ1bmN0aW9uIChjb250ZXh0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBwb2ludHMpIHtcbiAgICB2YXIgaGFsZlcgPSB3aWR0aCAvIDI7XG4gICAgdmFyIGhhbGZIID0gaGVpZ2h0IC8gMjtcblxuICAgIGlmIChjb250ZXh0LmJlZ2luUGF0aCkge1xuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICB9XG5cbiAgICBjb250ZXh0Lm1vdmVUbyh4ICsgaGFsZlcgKiBwb2ludHNbMF0sIHkgKyBoYWxmSCAqIHBvaW50c1sxXSk7XG5cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgIGNvbnRleHQubGluZVRvKHggKyBoYWxmVyAqIHBvaW50c1tpICogMl0sIHkgKyBoYWxmSCAqIHBvaW50c1tpICogMiArIDFdKTtcbiAgICB9XG5cbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9O1xuXG4gIENScCQzLmRyYXdSb3VuZFBvbHlnb25QYXRoID0gZnVuY3Rpb24gKGNvbnRleHQsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHBvaW50cykge1xuICAgIHZhciBoYWxmVyA9IHdpZHRoIC8gMjtcbiAgICB2YXIgaGFsZkggPSBoZWlnaHQgLyAyO1xuICAgIHZhciBjb3JuZXJSYWRpdXMgPSBnZXRSb3VuZFBvbHlnb25SYWRpdXMod2lkdGgsIGhlaWdodCk7XG5cbiAgICBpZiAoY29udGV4dC5iZWdpblBhdGgpIHtcbiAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHBvaW50cy5sZW5ndGggLyA0OyBfaSsrKSB7XG4gICAgICB2YXIgc291cmNlVXYgPSB2b2lkIDAsXG4gICAgICAgICAgZGVzdFV2ID0gdm9pZCAwO1xuXG4gICAgICBpZiAoX2kgPT09IDApIHtcbiAgICAgICAgc291cmNlVXYgPSBwb2ludHMubGVuZ3RoIC0gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNvdXJjZVV2ID0gX2kgKiA0IC0gMjtcbiAgICAgIH1cblxuICAgICAgZGVzdFV2ID0gX2kgKiA0ICsgMjtcbiAgICAgIHZhciBweCA9IHggKyBoYWxmVyAqIHBvaW50c1tfaSAqIDRdO1xuICAgICAgdmFyIHB5ID0geSArIGhhbGZIICogcG9pbnRzW19pICogNCArIDFdO1xuICAgICAgdmFyIGNvc1RoZXRhID0gLXBvaW50c1tzb3VyY2VVdl0gKiBwb2ludHNbZGVzdFV2XSAtIHBvaW50c1tzb3VyY2VVdiArIDFdICogcG9pbnRzW2Rlc3RVdiArIDFdO1xuICAgICAgdmFyIG9mZnNldCA9IGNvcm5lclJhZGl1cyAvIE1hdGgudGFuKE1hdGguYWNvcyhjb3NUaGV0YSkgLyAyKTtcbiAgICAgIHZhciBjcDB4ID0gcHggLSBvZmZzZXQgKiBwb2ludHNbc291cmNlVXZdO1xuICAgICAgdmFyIGNwMHkgPSBweSAtIG9mZnNldCAqIHBvaW50c1tzb3VyY2VVdiArIDFdO1xuICAgICAgdmFyIGNwMXggPSBweCArIG9mZnNldCAqIHBvaW50c1tkZXN0VXZdO1xuICAgICAgdmFyIGNwMXkgPSBweSArIG9mZnNldCAqIHBvaW50c1tkZXN0VXYgKyAxXTtcblxuICAgICAgaWYgKF9pID09PSAwKSB7XG4gICAgICAgIGNvbnRleHQubW92ZVRvKGNwMHgsIGNwMHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dC5saW5lVG8oY3AweCwgY3AweSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQuYXJjVG8ocHgsIHB5LCBjcDF4LCBjcDF5LCBjb3JuZXJSYWRpdXMpO1xuICAgIH1cblxuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH07IC8vIFJvdW5kIHJlY3RhbmdsZSBkcmF3aW5nXG5cblxuICBDUnAkMy5kcmF3Um91bmRSZWN0YW5nbGVQYXRoID0gZnVuY3Rpb24gKGNvbnRleHQsIHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICB2YXIgaGFsZldpZHRoID0gd2lkdGggLyAyO1xuICAgIHZhciBoYWxmSGVpZ2h0ID0gaGVpZ2h0IC8gMjtcbiAgICB2YXIgY29ybmVyUmFkaXVzID0gZ2V0Um91bmRSZWN0YW5nbGVSYWRpdXMod2lkdGgsIGhlaWdodCk7XG5cbiAgICBpZiAoY29udGV4dC5iZWdpblBhdGgpIHtcbiAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgfSAvLyBTdGFydCBhdCB0b3AgbWlkZGxlXG5cblxuICAgIGNvbnRleHQubW92ZVRvKHgsIHkgLSBoYWxmSGVpZ2h0KTsgLy8gQXJjIGZyb20gbWlkZGxlIHRvcCB0byByaWdodCBzaWRlXG5cbiAgICBjb250ZXh0LmFyY1RvKHggKyBoYWxmV2lkdGgsIHkgLSBoYWxmSGVpZ2h0LCB4ICsgaGFsZldpZHRoLCB5LCBjb3JuZXJSYWRpdXMpOyAvLyBBcmMgZnJvbSByaWdodCBzaWRlIHRvIGJvdHRvbVxuXG4gICAgY29udGV4dC5hcmNUbyh4ICsgaGFsZldpZHRoLCB5ICsgaGFsZkhlaWdodCwgeCwgeSArIGhhbGZIZWlnaHQsIGNvcm5lclJhZGl1cyk7IC8vIEFyYyBmcm9tIGJvdHRvbSB0byBsZWZ0IHNpZGVcblxuICAgIGNvbnRleHQuYXJjVG8oeCAtIGhhbGZXaWR0aCwgeSArIGhhbGZIZWlnaHQsIHggLSBoYWxmV2lkdGgsIHksIGNvcm5lclJhZGl1cyk7IC8vIEFyYyBmcm9tIGxlZnQgc2lkZSB0byB0b3BCb3JkZXJcblxuICAgIGNvbnRleHQuYXJjVG8oeCAtIGhhbGZXaWR0aCwgeSAtIGhhbGZIZWlnaHQsIHgsIHkgLSBoYWxmSGVpZ2h0LCBjb3JuZXJSYWRpdXMpOyAvLyBKb2luIGxpbmVcblxuICAgIGNvbnRleHQubGluZVRvKHgsIHkgLSBoYWxmSGVpZ2h0KTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9O1xuXG4gIENScCQzLmRyYXdCb3R0b21Sb3VuZFJlY3RhbmdsZVBhdGggPSBmdW5jdGlvbiAoY29udGV4dCwgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgIHZhciBoYWxmV2lkdGggPSB3aWR0aCAvIDI7XG4gICAgdmFyIGhhbGZIZWlnaHQgPSBoZWlnaHQgLyAyO1xuICAgIHZhciBjb3JuZXJSYWRpdXMgPSBnZXRSb3VuZFJlY3RhbmdsZVJhZGl1cyh3aWR0aCwgaGVpZ2h0KTtcblxuICAgIGlmIChjb250ZXh0LmJlZ2luUGF0aCkge1xuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICB9IC8vIFN0YXJ0IGF0IHRvcCBtaWRkbGVcblxuXG4gICAgY29udGV4dC5tb3ZlVG8oeCwgeSAtIGhhbGZIZWlnaHQpO1xuICAgIGNvbnRleHQubGluZVRvKHggKyBoYWxmV2lkdGgsIHkgLSBoYWxmSGVpZ2h0KTtcbiAgICBjb250ZXh0LmxpbmVUbyh4ICsgaGFsZldpZHRoLCB5KTtcbiAgICBjb250ZXh0LmFyY1RvKHggKyBoYWxmV2lkdGgsIHkgKyBoYWxmSGVpZ2h0LCB4LCB5ICsgaGFsZkhlaWdodCwgY29ybmVyUmFkaXVzKTtcbiAgICBjb250ZXh0LmFyY1RvKHggLSBoYWxmV2lkdGgsIHkgKyBoYWxmSGVpZ2h0LCB4IC0gaGFsZldpZHRoLCB5LCBjb3JuZXJSYWRpdXMpO1xuICAgIGNvbnRleHQubGluZVRvKHggLSBoYWxmV2lkdGgsIHkgLSBoYWxmSGVpZ2h0KTtcbiAgICBjb250ZXh0LmxpbmVUbyh4LCB5IC0gaGFsZkhlaWdodCk7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfTtcblxuICBDUnAkMy5kcmF3Q3V0UmVjdGFuZ2xlUGF0aCA9IGZ1bmN0aW9uIChjb250ZXh0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdmFyIGhhbGZXaWR0aCA9IHdpZHRoIC8gMjtcbiAgICB2YXIgaGFsZkhlaWdodCA9IGhlaWdodCAvIDI7XG4gICAgdmFyIGNvcm5lckxlbmd0aCA9IGdldEN1dFJlY3RhbmdsZUNvcm5lckxlbmd0aCgpO1xuXG4gICAgaWYgKGNvbnRleHQuYmVnaW5QYXRoKSB7XG4gICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIH1cblxuICAgIGNvbnRleHQubW92ZVRvKHggLSBoYWxmV2lkdGggKyBjb3JuZXJMZW5ndGgsIHkgLSBoYWxmSGVpZ2h0KTtcbiAgICBjb250ZXh0LmxpbmVUbyh4ICsgaGFsZldpZHRoIC0gY29ybmVyTGVuZ3RoLCB5IC0gaGFsZkhlaWdodCk7XG4gICAgY29udGV4dC5saW5lVG8oeCArIGhhbGZXaWR0aCwgeSAtIGhhbGZIZWlnaHQgKyBjb3JuZXJMZW5ndGgpO1xuICAgIGNvbnRleHQubGluZVRvKHggKyBoYWxmV2lkdGgsIHkgKyBoYWxmSGVpZ2h0IC0gY29ybmVyTGVuZ3RoKTtcbiAgICBjb250ZXh0LmxpbmVUbyh4ICsgaGFsZldpZHRoIC0gY29ybmVyTGVuZ3RoLCB5ICsgaGFsZkhlaWdodCk7XG4gICAgY29udGV4dC5saW5lVG8oeCAtIGhhbGZXaWR0aCArIGNvcm5lckxlbmd0aCwgeSArIGhhbGZIZWlnaHQpO1xuICAgIGNvbnRleHQubGluZVRvKHggLSBoYWxmV2lkdGgsIHkgKyBoYWxmSGVpZ2h0IC0gY29ybmVyTGVuZ3RoKTtcbiAgICBjb250ZXh0LmxpbmVUbyh4IC0gaGFsZldpZHRoLCB5IC0gaGFsZkhlaWdodCArIGNvcm5lckxlbmd0aCk7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfTtcblxuICBDUnAkMy5kcmF3QmFycmVsUGF0aCA9IGZ1bmN0aW9uIChjb250ZXh0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdmFyIGhhbGZXaWR0aCA9IHdpZHRoIC8gMjtcbiAgICB2YXIgaGFsZkhlaWdodCA9IGhlaWdodCAvIDI7XG4gICAgdmFyIHhCZWdpbiA9IHggLSBoYWxmV2lkdGg7XG4gICAgdmFyIHhFbmQgPSB4ICsgaGFsZldpZHRoO1xuICAgIHZhciB5QmVnaW4gPSB5IC0gaGFsZkhlaWdodDtcbiAgICB2YXIgeUVuZCA9IHkgKyBoYWxmSGVpZ2h0O1xuICAgIHZhciBiYXJyZWxDdXJ2ZUNvbnN0YW50cyA9IGdldEJhcnJlbEN1cnZlQ29uc3RhbnRzKHdpZHRoLCBoZWlnaHQpO1xuICAgIHZhciB3T2Zmc2V0ID0gYmFycmVsQ3VydmVDb25zdGFudHMud2lkdGhPZmZzZXQ7XG4gICAgdmFyIGhPZmZzZXQgPSBiYXJyZWxDdXJ2ZUNvbnN0YW50cy5oZWlnaHRPZmZzZXQ7XG4gICAgdmFyIGN0cmxQdFhPZmZzZXQgPSBiYXJyZWxDdXJ2ZUNvbnN0YW50cy5jdHJsUHRPZmZzZXRQY3QgKiB3T2Zmc2V0O1xuXG4gICAgaWYgKGNvbnRleHQuYmVnaW5QYXRoKSB7XG4gICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIH1cblxuICAgIGNvbnRleHQubW92ZVRvKHhCZWdpbiwgeUJlZ2luICsgaE9mZnNldCk7XG4gICAgY29udGV4dC5saW5lVG8oeEJlZ2luLCB5RW5kIC0gaE9mZnNldCk7XG4gICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKHhCZWdpbiArIGN0cmxQdFhPZmZzZXQsIHlFbmQsIHhCZWdpbiArIHdPZmZzZXQsIHlFbmQpO1xuICAgIGNvbnRleHQubGluZVRvKHhFbmQgLSB3T2Zmc2V0LCB5RW5kKTtcbiAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8oeEVuZCAtIGN0cmxQdFhPZmZzZXQsIHlFbmQsIHhFbmQsIHlFbmQgLSBoT2Zmc2V0KTtcbiAgICBjb250ZXh0LmxpbmVUbyh4RW5kLCB5QmVnaW4gKyBoT2Zmc2V0KTtcbiAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8oeEVuZCAtIGN0cmxQdFhPZmZzZXQsIHlCZWdpbiwgeEVuZCAtIHdPZmZzZXQsIHlCZWdpbik7XG4gICAgY29udGV4dC5saW5lVG8oeEJlZ2luICsgd09mZnNldCwgeUJlZ2luKTtcbiAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8oeEJlZ2luICsgY3RybFB0WE9mZnNldCwgeUJlZ2luLCB4QmVnaW4sIHlCZWdpbiArIGhPZmZzZXQpO1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH07XG5cbiAgdmFyIHNpbjAgPSBNYXRoLnNpbigwKTtcbiAgdmFyIGNvczAgPSBNYXRoLmNvcygwKTtcbiAgdmFyIHNpbiA9IHt9O1xuICB2YXIgY29zID0ge307XG4gIHZhciBlbGxpcHNlU3RlcFNpemUgPSBNYXRoLlBJIC8gNDA7XG5cbiAgZm9yICh2YXIgaSA9IDAgKiBNYXRoLlBJOyBpIDwgMiAqIE1hdGguUEk7IGkgKz0gZWxsaXBzZVN0ZXBTaXplKSB7XG4gICAgc2luW2ldID0gTWF0aC5zaW4oaSk7XG4gICAgY29zW2ldID0gTWF0aC5jb3MoaSk7XG4gIH1cblxuICBDUnAkMy5kcmF3RWxsaXBzZVBhdGggPSBmdW5jdGlvbiAoY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCkge1xuICAgIGlmIChjb250ZXh0LmJlZ2luUGF0aCkge1xuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICB9XG5cbiAgICBpZiAoY29udGV4dC5lbGxpcHNlKSB7XG4gICAgICBjb250ZXh0LmVsbGlwc2UoY2VudGVyWCwgY2VudGVyWSwgd2lkdGggLyAyLCBoZWlnaHQgLyAyLCAwLCAwLCAyICogTWF0aC5QSSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB4UG9zLCB5UG9zO1xuICAgICAgdmFyIHJ3ID0gd2lkdGggLyAyO1xuICAgICAgdmFyIHJoID0gaGVpZ2h0IC8gMjtcblxuICAgICAgZm9yICh2YXIgaSA9IDAgKiBNYXRoLlBJOyBpIDwgMiAqIE1hdGguUEk7IGkgKz0gZWxsaXBzZVN0ZXBTaXplKSB7XG4gICAgICAgIHhQb3MgPSBjZW50ZXJYIC0gcncgKiBzaW5baV0gKiBzaW4wICsgcncgKiBjb3NbaV0gKiBjb3MwO1xuICAgICAgICB5UG9zID0gY2VudGVyWSArIHJoICogY29zW2ldICogc2luMCArIHJoICogc2luW2ldICogY29zMDtcblxuICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgIGNvbnRleHQubW92ZVRvKHhQb3MsIHlQb3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRleHQubGluZVRvKHhQb3MsIHlQb3MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfTtcblxuICAvKiBnbG9iYWwgYXRvYiwgQXJyYXlCdWZmZXIsIFVpbnQ4QXJyYXksIEJsb2IgKi9cbiAgdmFyIENScCQyID0ge307XG5cbiAgQ1JwJDIuY3JlYXRlQnVmZmVyID0gZnVuY3Rpb24gKHcsIGgpIHtcbiAgICB2YXIgYnVmZmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuICAgIGJ1ZmZlci53aWR0aCA9IHc7XG4gICAgYnVmZmVyLmhlaWdodCA9IGg7XG4gICAgcmV0dXJuIFtidWZmZXIsIGJ1ZmZlci5nZXRDb250ZXh0KCcyZCcpXTtcbiAgfTtcblxuICBDUnAkMi5idWZmZXJDYW52YXNJbWFnZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIGN5ID0gdGhpcy5jeTtcbiAgICB2YXIgZWxlcyA9IGN5Lm11dGFibGVFbGVtZW50cygpO1xuICAgIHZhciBiYiA9IGVsZXMuYm91bmRpbmdCb3goKTtcbiAgICB2YXIgY3RyUmVjdCA9IHRoaXMuZmluZENvbnRhaW5lckNsaWVudENvb3JkcygpO1xuICAgIHZhciB3aWR0aCA9IG9wdGlvbnMuZnVsbCA/IE1hdGguY2VpbChiYi53KSA6IGN0clJlY3RbMl07XG4gICAgdmFyIGhlaWdodCA9IG9wdGlvbnMuZnVsbCA/IE1hdGguY2VpbChiYi5oKSA6IGN0clJlY3RbM107XG4gICAgdmFyIHNwZWNkTWF4RGltcyA9IG51bWJlciQxKG9wdGlvbnMubWF4V2lkdGgpIHx8IG51bWJlciQxKG9wdGlvbnMubWF4SGVpZ2h0KTtcbiAgICB2YXIgcHhSYXRpbyA9IHRoaXMuZ2V0UGl4ZWxSYXRpbygpO1xuICAgIHZhciBzY2FsZSA9IDE7XG5cbiAgICBpZiAob3B0aW9ucy5zY2FsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB3aWR0aCAqPSBvcHRpb25zLnNjYWxlO1xuICAgICAgaGVpZ2h0ICo9IG9wdGlvbnMuc2NhbGU7XG4gICAgICBzY2FsZSA9IG9wdGlvbnMuc2NhbGU7XG4gICAgfSBlbHNlIGlmIChzcGVjZE1heERpbXMpIHtcbiAgICAgIHZhciBtYXhTY2FsZVcgPSBJbmZpbml0eTtcbiAgICAgIHZhciBtYXhTY2FsZUggPSBJbmZpbml0eTtcblxuICAgICAgaWYgKG51bWJlciQxKG9wdGlvbnMubWF4V2lkdGgpKSB7XG4gICAgICAgIG1heFNjYWxlVyA9IHNjYWxlICogb3B0aW9ucy5tYXhXaWR0aCAvIHdpZHRoO1xuICAgICAgfVxuXG4gICAgICBpZiAobnVtYmVyJDEob3B0aW9ucy5tYXhIZWlnaHQpKSB7XG4gICAgICAgIG1heFNjYWxlSCA9IHNjYWxlICogb3B0aW9ucy5tYXhIZWlnaHQgLyBoZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIHNjYWxlID0gTWF0aC5taW4obWF4U2NhbGVXLCBtYXhTY2FsZUgpO1xuICAgICAgd2lkdGggKj0gc2NhbGU7XG4gICAgICBoZWlnaHQgKj0gc2NhbGU7XG4gICAgfVxuXG4gICAgaWYgKCFzcGVjZE1heERpbXMpIHtcbiAgICAgIHdpZHRoICo9IHB4UmF0aW87XG4gICAgICBoZWlnaHQgKj0gcHhSYXRpbztcbiAgICAgIHNjYWxlICo9IHB4UmF0aW87XG4gICAgfVxuXG4gICAgdmFyIGJ1ZmZDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4gICAgYnVmZkNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgIGJ1ZmZDYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIGJ1ZmZDYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgYnVmZkNhbnZhcy5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICAgIHZhciBidWZmQ3h0ID0gYnVmZkNhbnZhcy5nZXRDb250ZXh0KCcyZCcpOyAvLyBSYXN0ZXJpemUgdGhlIGxheWVycywgYnV0IG9ubHkgaWYgY29udGFpbmVyIGhhcyBub256ZXJvIHNpemVcblxuICAgIGlmICh3aWR0aCA+IDAgJiYgaGVpZ2h0ID4gMCkge1xuICAgICAgYnVmZkN4dC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBidWZmQ3h0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdzb3VyY2Utb3Zlcic7XG4gICAgICB2YXIgenNvcnRlZEVsZXMgPSB0aGlzLmdldENhY2hlZFpTb3J0ZWRFbGVzKCk7XG5cbiAgICAgIGlmIChvcHRpb25zLmZ1bGwpIHtcbiAgICAgICAgLy8gZHJhdyB0aGUgZnVsbCBib3VuZHMgb2YgdGhlIGdyYXBoXG4gICAgICAgIGJ1ZmZDeHQudHJhbnNsYXRlKC1iYi54MSAqIHNjYWxlLCAtYmIueTEgKiBzY2FsZSk7XG4gICAgICAgIGJ1ZmZDeHQuc2NhbGUoc2NhbGUsIHNjYWxlKTtcbiAgICAgICAgdGhpcy5kcmF3RWxlbWVudHMoYnVmZkN4dCwgenNvcnRlZEVsZXMpO1xuICAgICAgICBidWZmQ3h0LnNjYWxlKDEgLyBzY2FsZSwgMSAvIHNjYWxlKTtcbiAgICAgICAgYnVmZkN4dC50cmFuc2xhdGUoYmIueDEgKiBzY2FsZSwgYmIueTEgKiBzY2FsZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkcmF3IHRoZSBjdXJyZW50IHZpZXdcbiAgICAgICAgdmFyIHBhbiA9IGN5LnBhbigpO1xuICAgICAgICB2YXIgdHJhbnNsYXRpb24gPSB7XG4gICAgICAgICAgeDogcGFuLnggKiBzY2FsZSxcbiAgICAgICAgICB5OiBwYW4ueSAqIHNjYWxlXG4gICAgICAgIH07XG4gICAgICAgIHNjYWxlICo9IGN5Lnpvb20oKTtcbiAgICAgICAgYnVmZkN4dC50cmFuc2xhdGUodHJhbnNsYXRpb24ueCwgdHJhbnNsYXRpb24ueSk7XG4gICAgICAgIGJ1ZmZDeHQuc2NhbGUoc2NhbGUsIHNjYWxlKTtcbiAgICAgICAgdGhpcy5kcmF3RWxlbWVudHMoYnVmZkN4dCwgenNvcnRlZEVsZXMpO1xuICAgICAgICBidWZmQ3h0LnNjYWxlKDEgLyBzY2FsZSwgMSAvIHNjYWxlKTtcbiAgICAgICAgYnVmZkN4dC50cmFuc2xhdGUoLXRyYW5zbGF0aW9uLngsIC10cmFuc2xhdGlvbi55KTtcbiAgICAgIH0gLy8gbmVlZCB0byBmaWxsIGJnIGF0IGVuZCBsaWtlIHRoaXMgaW4gb3JkZXIgdG8gZmlsbCBjbGVhcmVkIHRyYW5zcGFyZW50IHBpeGVscyBpbiBqcGdzXG5cblxuICAgICAgaWYgKG9wdGlvbnMuYmcpIHtcbiAgICAgICAgYnVmZkN4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnZGVzdGluYXRpb24tb3Zlcic7XG4gICAgICAgIGJ1ZmZDeHQuZmlsbFN0eWxlID0gb3B0aW9ucy5iZztcbiAgICAgICAgYnVmZkN4dC5yZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBidWZmQ3h0LmZpbGwoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYnVmZkNhbnZhcztcbiAgfTtcblxuICBmdW5jdGlvbiBiNjRUb0Jsb2IoYjY0LCBtaW1lVHlwZSkge1xuICAgIHZhciBieXRlcyA9IGF0b2IoYjY0KTtcbiAgICB2YXIgYnVmZiA9IG5ldyBBcnJheUJ1ZmZlcihieXRlcy5sZW5ndGgpO1xuICAgIHZhciBidWZmVWludDggPSBuZXcgVWludDhBcnJheShidWZmKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGJ1ZmZVaW50OFtpXSA9IGJ5dGVzLmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBCbG9iKFtidWZmXSwge1xuICAgICAgdHlwZTogbWltZVR5cGVcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGI2NFVyaVRvQjY0KGI2NHVyaSkge1xuICAgIHZhciBpID0gYjY0dXJpLmluZGV4T2YoJywnKTtcbiAgICByZXR1cm4gYjY0dXJpLnN1YnN0cihpICsgMSk7XG4gIH1cblxuICBmdW5jdGlvbiBvdXRwdXQob3B0aW9ucywgY2FudmFzLCBtaW1lVHlwZSkge1xuICAgIHZhciBnZXRCNjRVcmkgPSBmdW5jdGlvbiBnZXRCNjRVcmkoKSB7XG4gICAgICByZXR1cm4gY2FudmFzLnRvRGF0YVVSTChtaW1lVHlwZSwgb3B0aW9ucy5xdWFsaXR5KTtcbiAgICB9O1xuXG4gICAgc3dpdGNoIChvcHRpb25zLm91dHB1dCkge1xuICAgICAgY2FzZSAnYmxvYi1wcm9taXNlJzpcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjYW52YXMudG9CbG9iKGZ1bmN0aW9uIChibG9iKSB7XG4gICAgICAgICAgICAgIGlmIChibG9iICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKGJsb2IpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ2BjYW52YXMudG9CbG9iKClgIHNlbnQgYSBudWxsIHZhbHVlIGluIGl0cyBjYWxsYmFjaycpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgbWltZVR5cGUsIG9wdGlvbnMucXVhbGl0eSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICBjYXNlICdibG9iJzpcbiAgICAgICAgcmV0dXJuIGI2NFRvQmxvYihiNjRVcmlUb0I2NChnZXRCNjRVcmkoKSksIG1pbWVUeXBlKTtcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGI2NFVyaVRvQjY0KGdldEI2NFVyaSgpKTtcblxuICAgICAgY2FzZSAnYmFzZTY0dXJpJzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBnZXRCNjRVcmkoKTtcbiAgICB9XG4gIH1cblxuICBDUnAkMi5wbmcgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHJldHVybiBvdXRwdXQob3B0aW9ucywgdGhpcy5idWZmZXJDYW52YXNJbWFnZShvcHRpb25zKSwgJ2ltYWdlL3BuZycpO1xuICB9O1xuXG4gIENScCQyLmpwZyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgcmV0dXJuIG91dHB1dChvcHRpb25zLCB0aGlzLmJ1ZmZlckNhbnZhc0ltYWdlKG9wdGlvbnMpLCAnaW1hZ2UvanBlZycpO1xuICB9O1xuXG4gIHZhciBDUnAkMSA9IHt9O1xuXG4gIENScCQxLm5vZGVTaGFwZUltcGwgPSBmdW5jdGlvbiAobmFtZSwgY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgcG9pbnRzKSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdlbGxpcHNlJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhd0VsbGlwc2VQYXRoKGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICBjYXNlICdwb2x5Z29uJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhd1BvbHlnb25QYXRoKGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIHBvaW50cyk7XG5cbiAgICAgIGNhc2UgJ3JvdW5kLXBvbHlnb24nOlxuICAgICAgICByZXR1cm4gdGhpcy5kcmF3Um91bmRQb2x5Z29uUGF0aChjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBwb2ludHMpO1xuXG4gICAgICBjYXNlICdyb3VuZHJlY3RhbmdsZSc6XG4gICAgICBjYXNlICdyb3VuZC1yZWN0YW5nbGUnOlxuICAgICAgICByZXR1cm4gdGhpcy5kcmF3Um91bmRSZWN0YW5nbGVQYXRoKGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICBjYXNlICdjdXRyZWN0YW5nbGUnOlxuICAgICAgY2FzZSAnY3V0LXJlY3RhbmdsZSc6XG4gICAgICAgIHJldHVybiB0aGlzLmRyYXdDdXRSZWN0YW5nbGVQYXRoKGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICBjYXNlICdib3R0b21yb3VuZHJlY3RhbmdsZSc6XG4gICAgICBjYXNlICdib3R0b20tcm91bmQtcmVjdGFuZ2xlJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhd0JvdHRvbVJvdW5kUmVjdGFuZ2xlUGF0aChjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgY2FzZSAnYmFycmVsJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhd0JhcnJlbFBhdGgoY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBDUiA9IENhbnZhc1JlbmRlcmVyO1xuICB2YXIgQ1JwID0gQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlO1xuICBDUnAuQ0FOVkFTX0xBWUVSUyA9IDM7IC8vXG5cbiAgQ1JwLlNFTEVDVF9CT1ggPSAwO1xuICBDUnAuRFJBRyA9IDE7XG4gIENScC5OT0RFID0gMjtcbiAgQ1JwLkJVRkZFUl9DT1VOVCA9IDM7IC8vXG5cbiAgQ1JwLlRFWFRVUkVfQlVGRkVSID0gMDtcbiAgQ1JwLk1PVElPTkJMVVJfQlVGRkVSX05PREUgPSAxO1xuICBDUnAuTU9USU9OQkxVUl9CVUZGRVJfRFJBRyA9IDI7XG5cbiAgZnVuY3Rpb24gQ2FudmFzUmVuZGVyZXIob3B0aW9ucykge1xuICAgIHZhciByID0gdGhpcztcbiAgICByLmRhdGEgPSB7XG4gICAgICBjYW52YXNlczogbmV3IEFycmF5KENScC5DQU5WQVNfTEFZRVJTKSxcbiAgICAgIGNvbnRleHRzOiBuZXcgQXJyYXkoQ1JwLkNBTlZBU19MQVlFUlMpLFxuICAgICAgY2FudmFzTmVlZHNSZWRyYXc6IG5ldyBBcnJheShDUnAuQ0FOVkFTX0xBWUVSUyksXG4gICAgICBidWZmZXJDYW52YXNlczogbmV3IEFycmF5KENScC5CVUZGRVJfQ09VTlQpLFxuICAgICAgYnVmZmVyQ29udGV4dHM6IG5ldyBBcnJheShDUnAuQ0FOVkFTX0xBWUVSUylcbiAgICB9O1xuICAgIHZhciB0YXBIbE9mZkF0dHIgPSAnLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yJztcbiAgICB2YXIgdGFwSGxPZmZTdHlsZSA9ICdyZ2JhKDAsMCwwLDApJztcbiAgICByLmRhdGEuY2FudmFzQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuICAgIHZhciBjb250YWluZXJTdHlsZSA9IHIuZGF0YS5jYW52YXNDb250YWluZXIuc3R5bGU7XG4gICAgci5kYXRhLmNhbnZhc0NvbnRhaW5lci5zdHlsZVt0YXBIbE9mZkF0dHJdID0gdGFwSGxPZmZTdHlsZTtcbiAgICBjb250YWluZXJTdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgY29udGFpbmVyU3R5bGUuekluZGV4ID0gJzAnO1xuICAgIGNvbnRhaW5lclN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gICAgdmFyIGNvbnRhaW5lciA9IG9wdGlvbnMuY3kuY29udGFpbmVyKCk7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHIuZGF0YS5jYW52YXNDb250YWluZXIpO1xuICAgIGNvbnRhaW5lci5zdHlsZVt0YXBIbE9mZkF0dHJdID0gdGFwSGxPZmZTdHlsZTtcbiAgICB2YXIgc3R5bGVNYXAgPSB7XG4gICAgICAnLXdlYmtpdC11c2VyLXNlbGVjdCc6ICdub25lJyxcbiAgICAgICctbW96LXVzZXItc2VsZWN0JzogJy1tb3otbm9uZScsXG4gICAgICAndXNlci1zZWxlY3QnOiAnbm9uZScsXG4gICAgICAnLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yJzogJ3JnYmEoMCwwLDAsMCknLFxuICAgICAgJ291dGxpbmUtc3R5bGUnOiAnbm9uZSdcbiAgICB9O1xuXG4gICAgaWYgKG1zKCkpIHtcbiAgICAgIHN0eWxlTWFwWyctbXMtdG91Y2gtYWN0aW9uJ10gPSAnbm9uZSc7XG4gICAgICBzdHlsZU1hcFsndG91Y2gtYWN0aW9uJ10gPSAnbm9uZSc7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBDUnAuQ0FOVkFTX0xBWUVSUzsgaSsrKSB7XG4gICAgICB2YXIgY2FudmFzID0gci5kYXRhLmNhbnZhc2VzW2ldID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuICAgICAgci5kYXRhLmNvbnRleHRzW2ldID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBPYmplY3Qua2V5cyhzdHlsZU1hcCkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICBjYW52YXMuc3R5bGVba10gPSBzdHlsZU1hcFtrXTtcbiAgICAgIH0pO1xuICAgICAgY2FudmFzLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUoJ2RhdGEtaWQnLCAnbGF5ZXInICsgaSk7XG4gICAgICBjYW52YXMuc3R5bGUuekluZGV4ID0gU3RyaW5nKENScC5DQU5WQVNfTEFZRVJTIC0gaSk7XG4gICAgICByLmRhdGEuY2FudmFzQ29udGFpbmVyLmFwcGVuZENoaWxkKGNhbnZhcyk7XG4gICAgICByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbaV0gPSBmYWxzZTtcbiAgICB9XG5cbiAgICByLmRhdGEudG9wQ2FudmFzID0gci5kYXRhLmNhbnZhc2VzWzBdO1xuICAgIHIuZGF0YS5jYW52YXNlc1tDUnAuTk9ERV0uc2V0QXR0cmlidXRlKCdkYXRhLWlkJywgJ2xheWVyJyArIENScC5OT0RFICsgJy1ub2RlJyk7XG4gICAgci5kYXRhLmNhbnZhc2VzW0NScC5TRUxFQ1RfQk9YXS5zZXRBdHRyaWJ1dGUoJ2RhdGEtaWQnLCAnbGF5ZXInICsgQ1JwLlNFTEVDVF9CT1ggKyAnLXNlbGVjdGJveCcpO1xuICAgIHIuZGF0YS5jYW52YXNlc1tDUnAuRFJBR10uc2V0QXR0cmlidXRlKCdkYXRhLWlkJywgJ2xheWVyJyArIENScC5EUkFHICsgJy1kcmFnJyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IENScC5CVUZGRVJfQ09VTlQ7IGkrKykge1xuICAgICAgci5kYXRhLmJ1ZmZlckNhbnZhc2VzW2ldID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuICAgICAgci5kYXRhLmJ1ZmZlckNvbnRleHRzW2ldID0gci5kYXRhLmJ1ZmZlckNhbnZhc2VzW2ldLmdldENvbnRleHQoJzJkJyk7XG4gICAgICByLmRhdGEuYnVmZmVyQ2FudmFzZXNbaV0uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgci5kYXRhLmJ1ZmZlckNhbnZhc2VzW2ldLnNldEF0dHJpYnV0ZSgnZGF0YS1pZCcsICdidWZmZXInICsgaSk7XG4gICAgICByLmRhdGEuYnVmZmVyQ2FudmFzZXNbaV0uc3R5bGUuekluZGV4ID0gU3RyaW5nKC1pIC0gMSk7XG4gICAgICByLmRhdGEuYnVmZmVyQ2FudmFzZXNbaV0uc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nOyAvL3IuZGF0YS5jYW52YXNDb250YWluZXIuYXBwZW5kQ2hpbGQoci5kYXRhLmJ1ZmZlckNhbnZhc2VzW2ldKTtcbiAgICB9XG5cbiAgICByLnBhdGhzRW5hYmxlZCA9IHRydWU7XG4gICAgdmFyIGVtcHR5QmIgPSBtYWtlQm91bmRpbmdCb3goKTtcblxuICAgIHZhciBnZXRCb3hDZW50ZXIgPSBmdW5jdGlvbiBnZXRCb3hDZW50ZXIoYmIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IChiYi54MSArIGJiLngyKSAvIDIsXG4gICAgICAgIHk6IChiYi55MSArIGJiLnkyKSAvIDJcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBnZXRDZW50ZXJPZmZzZXQgPSBmdW5jdGlvbiBnZXRDZW50ZXJPZmZzZXQoYmIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IC1iYi53IC8gMixcbiAgICAgICAgeTogLWJiLmggLyAyXG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgYmFja2dyb3VuZFRpbWVzdGFtcEhhc0NoYW5nZWQgPSBmdW5jdGlvbiBiYWNrZ3JvdW5kVGltZXN0YW1wSGFzQ2hhbmdlZChlbGUpIHtcbiAgICAgIHZhciBfcCA9IGVsZVswXS5fcHJpdmF0ZTtcbiAgICAgIHZhciBzYW1lID0gX3Aub2xkQmFja2dyb3VuZFRpbWVzdGFtcCA9PT0gX3AuYmFja2dyb3VuZFRpbWVzdGFtcDtcbiAgICAgIHJldHVybiAhc2FtZTtcbiAgICB9O1xuXG4gICAgdmFyIGdldFN0eWxlS2V5ID0gZnVuY3Rpb24gZ2V0U3R5bGVLZXkoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlWzBdLl9wcml2YXRlLm5vZGVLZXk7XG4gICAgfTtcblxuICAgIHZhciBnZXRMYWJlbEtleSA9IGZ1bmN0aW9uIGdldExhYmVsS2V5KGVsZSkge1xuICAgICAgcmV0dXJuIGVsZVswXS5fcHJpdmF0ZS5sYWJlbFN0eWxlS2V5O1xuICAgIH07XG5cbiAgICB2YXIgZ2V0U291cmNlTGFiZWxLZXkgPSBmdW5jdGlvbiBnZXRTb3VyY2VMYWJlbEtleShlbGUpIHtcbiAgICAgIHJldHVybiBlbGVbMF0uX3ByaXZhdGUuc291cmNlTGFiZWxTdHlsZUtleTtcbiAgICB9O1xuXG4gICAgdmFyIGdldFRhcmdldExhYmVsS2V5ID0gZnVuY3Rpb24gZ2V0VGFyZ2V0TGFiZWxLZXkoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlWzBdLl9wcml2YXRlLnRhcmdldExhYmVsU3R5bGVLZXk7XG4gICAgfTtcblxuICAgIHZhciBkcmF3RWxlbWVudCA9IGZ1bmN0aW9uIGRyYXdFbGVtZW50KGNvbnRleHQsIGVsZSwgYmIsIHNjYWxlZExhYmVsU2hvd24sIHVzZUVsZU9wYWNpdHkpIHtcbiAgICAgIHJldHVybiByLmRyYXdFbGVtZW50KGNvbnRleHQsIGVsZSwgYmIsIGZhbHNlLCBmYWxzZSwgdXNlRWxlT3BhY2l0eSk7XG4gICAgfTtcblxuICAgIHZhciBkcmF3TGFiZWwgPSBmdW5jdGlvbiBkcmF3TGFiZWwoY29udGV4dCwgZWxlLCBiYiwgc2NhbGVkTGFiZWxTaG93biwgdXNlRWxlT3BhY2l0eSkge1xuICAgICAgcmV0dXJuIHIuZHJhd0VsZW1lbnRUZXh0KGNvbnRleHQsIGVsZSwgYmIsIHNjYWxlZExhYmVsU2hvd24sICdtYWluJywgdXNlRWxlT3BhY2l0eSk7XG4gICAgfTtcblxuICAgIHZhciBkcmF3U291cmNlTGFiZWwgPSBmdW5jdGlvbiBkcmF3U291cmNlTGFiZWwoY29udGV4dCwgZWxlLCBiYiwgc2NhbGVkTGFiZWxTaG93biwgdXNlRWxlT3BhY2l0eSkge1xuICAgICAgcmV0dXJuIHIuZHJhd0VsZW1lbnRUZXh0KGNvbnRleHQsIGVsZSwgYmIsIHNjYWxlZExhYmVsU2hvd24sICdzb3VyY2UnLCB1c2VFbGVPcGFjaXR5KTtcbiAgICB9O1xuXG4gICAgdmFyIGRyYXdUYXJnZXRMYWJlbCA9IGZ1bmN0aW9uIGRyYXdUYXJnZXRMYWJlbChjb250ZXh0LCBlbGUsIGJiLCBzY2FsZWRMYWJlbFNob3duLCB1c2VFbGVPcGFjaXR5KSB7XG4gICAgICByZXR1cm4gci5kcmF3RWxlbWVudFRleHQoY29udGV4dCwgZWxlLCBiYiwgc2NhbGVkTGFiZWxTaG93biwgJ3RhcmdldCcsIHVzZUVsZU9wYWNpdHkpO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0RWxlbWVudEJveCA9IGZ1bmN0aW9uIGdldEVsZW1lbnRCb3goZWxlKSB7XG4gICAgICBlbGUuYm91bmRpbmdCb3goKTtcbiAgICAgIHJldHVybiBlbGVbMF0uX3ByaXZhdGUuYm9keUJvdW5kcztcbiAgICB9O1xuXG4gICAgdmFyIGdldExhYmVsQm94ID0gZnVuY3Rpb24gZ2V0TGFiZWxCb3goZWxlKSB7XG4gICAgICBlbGUuYm91bmRpbmdCb3goKTtcbiAgICAgIHJldHVybiBlbGVbMF0uX3ByaXZhdGUubGFiZWxCb3VuZHMubWFpbiB8fCBlbXB0eUJiO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0U291cmNlTGFiZWxCb3ggPSBmdW5jdGlvbiBnZXRTb3VyY2VMYWJlbEJveChlbGUpIHtcbiAgICAgIGVsZS5ib3VuZGluZ0JveCgpO1xuICAgICAgcmV0dXJuIGVsZVswXS5fcHJpdmF0ZS5sYWJlbEJvdW5kcy5zb3VyY2UgfHwgZW1wdHlCYjtcbiAgICB9O1xuXG4gICAgdmFyIGdldFRhcmdldExhYmVsQm94ID0gZnVuY3Rpb24gZ2V0VGFyZ2V0TGFiZWxCb3goZWxlKSB7XG4gICAgICBlbGUuYm91bmRpbmdCb3goKTtcbiAgICAgIHJldHVybiBlbGVbMF0uX3ByaXZhdGUubGFiZWxCb3VuZHMudGFyZ2V0IHx8IGVtcHR5QmI7XG4gICAgfTtcblxuICAgIHZhciBpc0xhYmVsVmlzaWJsZUF0U2NhbGUgPSBmdW5jdGlvbiBpc0xhYmVsVmlzaWJsZUF0U2NhbGUoZWxlLCBzY2FsZWRMYWJlbFNob3duKSB7XG4gICAgICByZXR1cm4gc2NhbGVkTGFiZWxTaG93bjtcbiAgICB9O1xuXG4gICAgdmFyIGdldEVsZW1lbnRSb3RhdGlvblBvaW50ID0gZnVuY3Rpb24gZ2V0RWxlbWVudFJvdGF0aW9uUG9pbnQoZWxlKSB7XG4gICAgICByZXR1cm4gZ2V0Qm94Q2VudGVyKGdldEVsZW1lbnRCb3goZWxlKSk7XG4gICAgfTtcblxuICAgIHZhciBhZGRUZXh0TWFyZ2luID0gZnVuY3Rpb24gYWRkVGV4dE1hcmdpbihwcmVmaXgsIHB0LCBlbGUpIHtcbiAgICAgIHZhciBwcmUgPSBwcmVmaXggPyBwcmVmaXggKyAnLScgOiAnJztcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHB0LnggKyBlbGUucHN0eWxlKHByZSArICd0ZXh0LW1hcmdpbi14JykucGZWYWx1ZSxcbiAgICAgICAgeTogcHQueSArIGVsZS5wc3R5bGUocHJlICsgJ3RleHQtbWFyZ2luLXknKS5wZlZhbHVlXG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgZ2V0UnNQdCA9IGZ1bmN0aW9uIGdldFJzUHQoZWxlLCB4LCB5KSB7XG4gICAgICB2YXIgcnMgPSBlbGVbMF0uX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiByc1t4XSxcbiAgICAgICAgeTogcnNbeV1cbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBnZXRMYWJlbFJvdGF0aW9uUG9pbnQgPSBmdW5jdGlvbiBnZXRMYWJlbFJvdGF0aW9uUG9pbnQoZWxlKSB7XG4gICAgICByZXR1cm4gYWRkVGV4dE1hcmdpbignJywgZ2V0UnNQdChlbGUsICdsYWJlbFgnLCAnbGFiZWxZJyksIGVsZSk7XG4gICAgfTtcblxuICAgIHZhciBnZXRTb3VyY2VMYWJlbFJvdGF0aW9uUG9pbnQgPSBmdW5jdGlvbiBnZXRTb3VyY2VMYWJlbFJvdGF0aW9uUG9pbnQoZWxlKSB7XG4gICAgICByZXR1cm4gYWRkVGV4dE1hcmdpbignc291cmNlJywgZ2V0UnNQdChlbGUsICdzb3VyY2VMYWJlbFgnLCAnc291cmNlTGFiZWxZJyksIGVsZSk7XG4gICAgfTtcblxuICAgIHZhciBnZXRUYXJnZXRMYWJlbFJvdGF0aW9uUG9pbnQgPSBmdW5jdGlvbiBnZXRUYXJnZXRMYWJlbFJvdGF0aW9uUG9pbnQoZWxlKSB7XG4gICAgICByZXR1cm4gYWRkVGV4dE1hcmdpbigndGFyZ2V0JywgZ2V0UnNQdChlbGUsICd0YXJnZXRMYWJlbFgnLCAndGFyZ2V0TGFiZWxZJyksIGVsZSk7XG4gICAgfTtcblxuICAgIHZhciBnZXRFbGVtZW50Um90YXRpb25PZmZzZXQgPSBmdW5jdGlvbiBnZXRFbGVtZW50Um90YXRpb25PZmZzZXQoZWxlKSB7XG4gICAgICByZXR1cm4gZ2V0Q2VudGVyT2Zmc2V0KGdldEVsZW1lbnRCb3goZWxlKSk7XG4gICAgfTtcblxuICAgIHZhciBnZXRTb3VyY2VMYWJlbFJvdGF0aW9uT2Zmc2V0ID0gZnVuY3Rpb24gZ2V0U291cmNlTGFiZWxSb3RhdGlvbk9mZnNldChlbGUpIHtcbiAgICAgIHJldHVybiBnZXRDZW50ZXJPZmZzZXQoZ2V0U291cmNlTGFiZWxCb3goZWxlKSk7XG4gICAgfTtcblxuICAgIHZhciBnZXRUYXJnZXRMYWJlbFJvdGF0aW9uT2Zmc2V0ID0gZnVuY3Rpb24gZ2V0VGFyZ2V0TGFiZWxSb3RhdGlvbk9mZnNldChlbGUpIHtcbiAgICAgIHJldHVybiBnZXRDZW50ZXJPZmZzZXQoZ2V0VGFyZ2V0TGFiZWxCb3goZWxlKSk7XG4gICAgfTtcblxuICAgIHZhciBnZXRMYWJlbFJvdGF0aW9uT2Zmc2V0ID0gZnVuY3Rpb24gZ2V0TGFiZWxSb3RhdGlvbk9mZnNldChlbGUpIHtcbiAgICAgIHZhciBiYiA9IGdldExhYmVsQm94KGVsZSk7XG4gICAgICB2YXIgcCA9IGdldENlbnRlck9mZnNldChnZXRMYWJlbEJveChlbGUpKTtcblxuICAgICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgICBzd2l0Y2ggKGVsZS5wc3R5bGUoJ3RleHQtaGFsaWduJykudmFsdWUpIHtcbiAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgIHAueCA9IC1iYi53O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICBwLnggPSAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKGVsZS5wc3R5bGUoJ3RleHQtdmFsaWduJykudmFsdWUpIHtcbiAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgcC55ID0gLWJiLmg7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICBwLnkgPSAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHA7XG4gICAgfTtcblxuICAgIHZhciBlbGVUeHJDYWNoZSA9IHIuZGF0YS5lbGVUeHJDYWNoZSA9IG5ldyBFbGVtZW50VGV4dHVyZUNhY2hlKHIsIHtcbiAgICAgIGdldEtleTogZ2V0U3R5bGVLZXksXG4gICAgICBkb2VzRWxlSW52YWxpZGF0ZUtleTogYmFja2dyb3VuZFRpbWVzdGFtcEhhc0NoYW5nZWQsXG4gICAgICBkcmF3RWxlbWVudDogZHJhd0VsZW1lbnQsXG4gICAgICBnZXRCb3VuZGluZ0JveDogZ2V0RWxlbWVudEJveCxcbiAgICAgIGdldFJvdGF0aW9uUG9pbnQ6IGdldEVsZW1lbnRSb3RhdGlvblBvaW50LFxuICAgICAgZ2V0Um90YXRpb25PZmZzZXQ6IGdldEVsZW1lbnRSb3RhdGlvbk9mZnNldCxcbiAgICAgIGFsbG93RWRnZVR4ckNhY2hpbmc6IGZhbHNlLFxuICAgICAgYWxsb3dQYXJlbnRUeHJDYWNoaW5nOiBmYWxzZVxuICAgIH0pO1xuICAgIHZhciBsYmxUeHJDYWNoZSA9IHIuZGF0YS5sYmxUeHJDYWNoZSA9IG5ldyBFbGVtZW50VGV4dHVyZUNhY2hlKHIsIHtcbiAgICAgIGdldEtleTogZ2V0TGFiZWxLZXksXG4gICAgICBkcmF3RWxlbWVudDogZHJhd0xhYmVsLFxuICAgICAgZ2V0Qm91bmRpbmdCb3g6IGdldExhYmVsQm94LFxuICAgICAgZ2V0Um90YXRpb25Qb2ludDogZ2V0TGFiZWxSb3RhdGlvblBvaW50LFxuICAgICAgZ2V0Um90YXRpb25PZmZzZXQ6IGdldExhYmVsUm90YXRpb25PZmZzZXQsXG4gICAgICBpc1Zpc2libGU6IGlzTGFiZWxWaXNpYmxlQXRTY2FsZVxuICAgIH0pO1xuICAgIHZhciBzbGJUeHJDYWNoZSA9IHIuZGF0YS5zbGJUeHJDYWNoZSA9IG5ldyBFbGVtZW50VGV4dHVyZUNhY2hlKHIsIHtcbiAgICAgIGdldEtleTogZ2V0U291cmNlTGFiZWxLZXksXG4gICAgICBkcmF3RWxlbWVudDogZHJhd1NvdXJjZUxhYmVsLFxuICAgICAgZ2V0Qm91bmRpbmdCb3g6IGdldFNvdXJjZUxhYmVsQm94LFxuICAgICAgZ2V0Um90YXRpb25Qb2ludDogZ2V0U291cmNlTGFiZWxSb3RhdGlvblBvaW50LFxuICAgICAgZ2V0Um90YXRpb25PZmZzZXQ6IGdldFNvdXJjZUxhYmVsUm90YXRpb25PZmZzZXQsXG4gICAgICBpc1Zpc2libGU6IGlzTGFiZWxWaXNpYmxlQXRTY2FsZVxuICAgIH0pO1xuICAgIHZhciB0bGJUeHJDYWNoZSA9IHIuZGF0YS50bGJUeHJDYWNoZSA9IG5ldyBFbGVtZW50VGV4dHVyZUNhY2hlKHIsIHtcbiAgICAgIGdldEtleTogZ2V0VGFyZ2V0TGFiZWxLZXksXG4gICAgICBkcmF3RWxlbWVudDogZHJhd1RhcmdldExhYmVsLFxuICAgICAgZ2V0Qm91bmRpbmdCb3g6IGdldFRhcmdldExhYmVsQm94LFxuICAgICAgZ2V0Um90YXRpb25Qb2ludDogZ2V0VGFyZ2V0TGFiZWxSb3RhdGlvblBvaW50LFxuICAgICAgZ2V0Um90YXRpb25PZmZzZXQ6IGdldFRhcmdldExhYmVsUm90YXRpb25PZmZzZXQsXG4gICAgICBpc1Zpc2libGU6IGlzTGFiZWxWaXNpYmxlQXRTY2FsZVxuICAgIH0pO1xuICAgIHZhciBseXJUeHJDYWNoZSA9IHIuZGF0YS5seXJUeHJDYWNoZSA9IG5ldyBMYXllcmVkVGV4dHVyZUNhY2hlKHIpO1xuICAgIHIub25VcGRhdGVFbGVDYWxjcyhmdW5jdGlvbiBpbnZhbGlkYXRlVGV4dHVyZUNhY2hlcyh3aWxsRHJhdywgZWxlcykge1xuICAgICAgLy8gZWFjaCBjYWNoZSBzaG91bGQgY2hlY2sgZm9yIHN1Yi1rZXkgZGlmZiB0byBzZWUgdGhhdCB0aGUgdXBkYXRlIGFmZmVjdHMgdGhhdCBjYWNoZSBwYXJ0aWN1bGFybHlcbiAgICAgIGVsZVR4ckNhY2hlLmludmFsaWRhdGVFbGVtZW50cyhlbGVzKTtcbiAgICAgIGxibFR4ckNhY2hlLmludmFsaWRhdGVFbGVtZW50cyhlbGVzKTtcbiAgICAgIHNsYlR4ckNhY2hlLmludmFsaWRhdGVFbGVtZW50cyhlbGVzKTtcbiAgICAgIHRsYlR4ckNhY2hlLmludmFsaWRhdGVFbGVtZW50cyhlbGVzKTsgLy8gYW55IGNoYW5nZSBpbnZhbGlkYXRlcyB0aGUgbGF5ZXJzXG5cbiAgICAgIGx5clR4ckNhY2hlLmludmFsaWRhdGVFbGVtZW50cyhlbGVzKTsgLy8gdXBkYXRlIHRoZSBvbGQgYmcgdGltZXN0YW1wIHNvIGRpZmZzIGNhbiBiZSBkb25lIGluIHRoZSBlbGUgdHhyIGNhY2hlc1xuXG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgZWxlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIF9wID0gZWxlc1tfaV0uX3ByaXZhdGU7XG4gICAgICAgIF9wLm9sZEJhY2tncm91bmRUaW1lc3RhbXAgPSBfcC5iYWNrZ3JvdW5kVGltZXN0YW1wO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHJlZmluZUluTGF5ZXJzID0gZnVuY3Rpb24gcmVmaW5lSW5MYXllcnMocmVxcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXFzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGx5clR4ckNhY2hlLmVucXVldWVFbGVtZW50UmVmaW5lbWVudChyZXFzW2ldLmVsZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGVsZVR4ckNhY2hlLm9uRGVxdWV1ZShyZWZpbmVJbkxheWVycyk7XG4gICAgbGJsVHhyQ2FjaGUub25EZXF1ZXVlKHJlZmluZUluTGF5ZXJzKTtcbiAgICBzbGJUeHJDYWNoZS5vbkRlcXVldWUocmVmaW5lSW5MYXllcnMpO1xuICAgIHRsYlR4ckNhY2hlLm9uRGVxdWV1ZShyZWZpbmVJbkxheWVycyk7XG4gIH1cblxuICBDUnAucmVkcmF3SGludCA9IGZ1bmN0aW9uIChncm91cCwgYm9vbCkge1xuICAgIHZhciByID0gdGhpcztcblxuICAgIHN3aXRjaCAoZ3JvdXApIHtcbiAgICAgIGNhc2UgJ2VsZXMnOlxuICAgICAgICByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbQ1JwLk5PREVdID0gYm9vbDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2RyYWcnOlxuICAgICAgICByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbQ1JwLkRSQUddID0gYm9vbDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgIHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1tDUnAuU0VMRUNUX0JPWF0gPSBib29sO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH07IC8vIHdoZXRoZXIgdG8gdXNlIFBhdGgyRCBjYWNoaW5nIGZvciBkcmF3aW5nXG5cblxuICB2YXIgcGF0aHNJbXBsZCA9IHR5cGVvZiBQYXRoMkQgIT09ICd1bmRlZmluZWQnO1xuXG4gIENScC5wYXRoMmRFbmFibGVkID0gZnVuY3Rpb24gKG9uKSB7XG4gICAgaWYgKG9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhdGhzRW5hYmxlZDtcbiAgICB9XG5cbiAgICB0aGlzLnBhdGhzRW5hYmxlZCA9IG9uID8gdHJ1ZSA6IGZhbHNlO1xuICB9O1xuXG4gIENScC51c2VQYXRocyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcGF0aHNJbXBsZCAmJiB0aGlzLnBhdGhzRW5hYmxlZDtcbiAgfTtcblxuICBDUnAuc2V0SW1nU21vb3RoaW5nID0gZnVuY3Rpb24gKGNvbnRleHQsIGJvb2wpIHtcbiAgICBpZiAoY29udGV4dC5pbWFnZVNtb290aGluZ0VuYWJsZWQgIT0gbnVsbCkge1xuICAgICAgY29udGV4dC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBib29sO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0LndlYmtpdEltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGJvb2w7XG4gICAgICBjb250ZXh0Lm1vekltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGJvb2w7XG4gICAgICBjb250ZXh0Lm1zSW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gYm9vbDtcbiAgICB9XG4gIH07XG5cbiAgQ1JwLmdldEltZ1Ntb290aGluZyA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgaWYgKGNvbnRleHQuaW1hZ2VTbW9vdGhpbmdFbmFibGVkICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBjb250ZXh0LmltYWdlU21vb3RoaW5nRW5hYmxlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNvbnRleHQud2Via2l0SW1hZ2VTbW9vdGhpbmdFbmFibGVkIHx8IGNvbnRleHQubW96SW1hZ2VTbW9vdGhpbmdFbmFibGVkIHx8IGNvbnRleHQubXNJbWFnZVNtb290aGluZ0VuYWJsZWQ7XG4gICAgfVxuICB9O1xuXG4gIENScC5tYWtlT2Zmc2NyZWVuQ2FudmFzID0gZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB2YXIgY2FudmFzO1xuXG4gICAgaWYgKCh0eXBlb2YgT2Zmc2NyZWVuQ2FudmFzID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoT2Zmc2NyZWVuQ2FudmFzKSkgIT09IChcInVuZGVmaW5lZFwiICkpIHtcbiAgICAgIGNhbnZhcyA9IG5ldyBPZmZzY3JlZW5DYW52YXMod2lkdGgsIGhlaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cbiAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICB9XG5cbiAgICByZXR1cm4gY2FudmFzO1xuICB9O1xuXG4gIFtDUnAkYSwgQ1JwJDksIENScCQ4LCBDUnAkNywgQ1JwJDYsIENScCQ1LCBDUnAkNCwgQ1JwJDMsIENScCQyLCBDUnAkMV0uZm9yRWFjaChmdW5jdGlvbiAocHJvcHMpIHtcbiAgICBleHRlbmQoQ1JwLCBwcm9wcyk7XG4gIH0pO1xuXG4gIHZhciByZW5kZXJlciA9IFt7XG4gICAgbmFtZTogJ251bGwnLFxuICAgIGltcGw6IE51bGxSZW5kZXJlclxuICB9LCB7XG4gICAgbmFtZTogJ2Jhc2UnLFxuICAgIGltcGw6IEJSXG4gIH0sIHtcbiAgICBuYW1lOiAnY2FudmFzJyxcbiAgICBpbXBsOiBDUlxuICB9XTtcblxuICB2YXIgaW5jRXh0cyA9IFt7XG4gICAgdHlwZTogJ2xheW91dCcsXG4gICAgZXh0ZW5zaW9uczogbGF5b3V0XG4gIH0sIHtcbiAgICB0eXBlOiAncmVuZGVyZXInLFxuICAgIGV4dGVuc2lvbnM6IHJlbmRlcmVyXG4gIH1dO1xuXG4gIHZhciBleHRlbnNpb25zID0ge307IC8vIHJlZ2lzdGVyZWQgbW9kdWxlcyBmb3IgZXh0ZW5zaW9ucywgaW5kZXhlZCBieSBuYW1lXG5cbiAgdmFyIG1vZHVsZXMgPSB7fTtcblxuICBmdW5jdGlvbiBzZXRFeHRlbnNpb24odHlwZSwgbmFtZSwgcmVnaXN0cmFudCkge1xuICAgIHZhciBleHQgPSByZWdpc3RyYW50O1xuXG4gICAgdmFyIG92ZXJyaWRlRXJyID0gZnVuY3Rpb24gb3ZlcnJpZGVFcnIoZmllbGQpIHtcbiAgICAgIHdhcm4oJ0NhbiBub3QgcmVnaXN0ZXIgYCcgKyBuYW1lICsgJ2AgZm9yIGAnICsgdHlwZSArICdgIHNpbmNlIGAnICsgZmllbGQgKyAnYCBhbHJlYWR5IGV4aXN0cyBpbiB0aGUgcHJvdG90eXBlIGFuZCBjYW4gbm90IGJlIG92ZXJyaWRkZW4nKTtcbiAgICB9O1xuXG4gICAgaWYgKHR5cGUgPT09ICdjb3JlJykge1xuICAgICAgaWYgKENvcmUucHJvdG90eXBlW25hbWVdKSB7XG4gICAgICAgIHJldHVybiBvdmVycmlkZUVycihuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIENvcmUucHJvdG90eXBlW25hbWVdID0gcmVnaXN0cmFudDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdjb2xsZWN0aW9uJykge1xuICAgICAgaWYgKENvbGxlY3Rpb24ucHJvdG90eXBlW25hbWVdKSB7XG4gICAgICAgIHJldHVybiBvdmVycmlkZUVycihuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIENvbGxlY3Rpb24ucHJvdG90eXBlW25hbWVdID0gcmVnaXN0cmFudDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdsYXlvdXQnKSB7XG4gICAgICAvLyBmaWxsIGluIG1pc3NpbmcgbGF5b3V0IGZ1bmN0aW9ucyBpbiB0aGUgcHJvdG90eXBlXG4gICAgICB2YXIgTGF5b3V0ID0gZnVuY3Rpb24gTGF5b3V0KG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgcmVnaXN0cmFudC5jYWxsKHRoaXMsIG9wdGlvbnMpOyAvLyBtYWtlIHN1cmUgbGF5b3V0IGhhcyBfcHJpdmF0ZSBmb3IgdXNlIHcvIHN0ZCBhcGlzIGxpa2UgLm9uKClcblxuICAgICAgICBpZiAoIXBsYWluT2JqZWN0KHRoaXMuX3ByaXZhdGUpKSB7XG4gICAgICAgICAgdGhpcy5fcHJpdmF0ZSA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcHJpdmF0ZS5jeSA9IG9wdGlvbnMuY3k7XG4gICAgICAgIHRoaXMuX3ByaXZhdGUubGlzdGVuZXJzID0gW107XG4gICAgICAgIHRoaXMuY3JlYXRlRW1pdHRlcigpO1xuICAgICAgfTtcblxuICAgICAgdmFyIGxheW91dFByb3RvID0gTGF5b3V0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUocmVnaXN0cmFudC5wcm90b3R5cGUpO1xuICAgICAgdmFyIG9wdExheW91dEZucyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdExheW91dEZucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZm5OYW1lID0gb3B0TGF5b3V0Rm5zW2ldO1xuXG4gICAgICAgIGxheW91dFByb3RvW2ZuTmFtZV0gPSBsYXlvdXRQcm90b1tmbk5hbWVdIHx8IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgIH0gLy8gZWl0aGVyIC5zdGFydCgpIG9yIC5ydW4oKSBpcyBkZWZpbmVkLCBzbyBhdXRvZ2VuIHRoZSBvdGhlclxuXG5cbiAgICAgIGlmIChsYXlvdXRQcm90by5zdGFydCAmJiAhbGF5b3V0UHJvdG8ucnVuKSB7XG4gICAgICAgIGxheW91dFByb3RvLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKCFsYXlvdXRQcm90by5zdGFydCAmJiBsYXlvdXRQcm90by5ydW4pIHtcbiAgICAgICAgbGF5b3V0UHJvdG8uc3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy5ydW4oKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlZ1N0b3AgPSByZWdpc3RyYW50LnByb3RvdHlwZS5zdG9wO1xuXG4gICAgICBsYXlvdXRQcm90by5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3B0cyA9IHRoaXMub3B0aW9ucztcblxuICAgICAgICBpZiAob3B0cyAmJiBvcHRzLmFuaW1hdGUpIHtcbiAgICAgICAgICB2YXIgYW5pcyA9IHRoaXMuYW5pbWF0aW9ucztcblxuICAgICAgICAgIGlmIChhbmlzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYW5pcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgYW5pc1tfaV0uc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZWdTdG9wKSB7XG4gICAgICAgICAgcmVnU3RvcC5jYWxsKHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZW1pdCgnbGF5b3V0c3RvcCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuXG4gICAgICBpZiAoIWxheW91dFByb3RvLmRlc3Ryb3kpIHtcbiAgICAgICAgbGF5b3V0UHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgbGF5b3V0UHJvdG8uY3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmN5O1xuICAgICAgfTtcblxuICAgICAgdmFyIGdldEN5ID0gZnVuY3Rpb24gZ2V0Q3kobGF5b3V0KSB7XG4gICAgICAgIHJldHVybiBsYXlvdXQuX3ByaXZhdGUuY3k7XG4gICAgICB9O1xuXG4gICAgICB2YXIgZW1pdHRlck9wdHMgPSB7XG4gICAgICAgIGFkZEV2ZW50RmllbGRzOiBmdW5jdGlvbiBhZGRFdmVudEZpZWxkcyhsYXlvdXQsIGV2dCkge1xuICAgICAgICAgIGV2dC5sYXlvdXQgPSBsYXlvdXQ7XG4gICAgICAgICAgZXZ0LmN5ID0gZ2V0Q3kobGF5b3V0KTtcbiAgICAgICAgICBldnQudGFyZ2V0ID0gbGF5b3V0O1xuICAgICAgICB9LFxuICAgICAgICBidWJibGU6IGZ1bmN0aW9uIGJ1YmJsZSgpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgcGFyZW50OiBmdW5jdGlvbiBwYXJlbnQobGF5b3V0KSB7XG4gICAgICAgICAgcmV0dXJuIGdldEN5KGxheW91dCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBleHRlbmQobGF5b3V0UHJvdG8sIHtcbiAgICAgICAgY3JlYXRlRW1pdHRlcjogZnVuY3Rpb24gY3JlYXRlRW1pdHRlcigpIHtcbiAgICAgICAgICB0aGlzLl9wcml2YXRlLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcihlbWl0dGVyT3B0cywgdGhpcyk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIGVtaXR0ZXI6IGZ1bmN0aW9uIGVtaXR0ZXIoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuZW1pdHRlcjtcbiAgICAgICAgfSxcbiAgICAgICAgb246IGZ1bmN0aW9uIG9uKGV2dCwgY2IpIHtcbiAgICAgICAgICB0aGlzLmVtaXR0ZXIoKS5vbihldnQsIGNiKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgb25lOiBmdW5jdGlvbiBvbmUoZXZ0LCBjYikge1xuICAgICAgICAgIHRoaXMuZW1pdHRlcigpLm9uZShldnQsIGNiKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgb25jZTogZnVuY3Rpb24gb25jZShldnQsIGNiKSB7XG4gICAgICAgICAgdGhpcy5lbWl0dGVyKCkub25lKGV2dCwgY2IpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmVMaXN0ZW5lcjogZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoZXZ0LCBjYikge1xuICAgICAgICAgIHRoaXMuZW1pdHRlcigpLnJlbW92ZUxpc3RlbmVyKGV2dCwgY2IpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmVBbGxMaXN0ZW5lcnM6IGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycygpIHtcbiAgICAgICAgICB0aGlzLmVtaXR0ZXIoKS5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgZW1pdDogZnVuY3Rpb24gZW1pdChldnQsIHBhcmFtcykge1xuICAgICAgICAgIHRoaXMuZW1pdHRlcigpLmVtaXQoZXZ0LCBwYXJhbXMpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGRlZmluZS5ldmVudEFsaWFzZXNPbihsYXlvdXRQcm90byk7XG4gICAgICBleHQgPSBMYXlvdXQ7IC8vIHJlcGxhY2Ugd2l0aCBvdXIgd3JhcHBlZCBsYXlvdXRcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdyZW5kZXJlcicgJiYgbmFtZSAhPT0gJ251bGwnICYmIG5hbWUgIT09ICdiYXNlJykge1xuICAgICAgLy8gdXNlciByZWdpc3RlcmVkIHJlbmRlcmVycyBpbmhlcml0IGZyb20gYmFzZVxuICAgICAgdmFyIEJhc2VSZW5kZXJlciA9IGdldEV4dGVuc2lvbigncmVuZGVyZXInLCAnYmFzZScpO1xuICAgICAgdmFyIGJQcm90byA9IEJhc2VSZW5kZXJlci5wcm90b3R5cGU7XG4gICAgICB2YXIgUmVnaXN0cmFudFJlbmRlcmVyID0gcmVnaXN0cmFudDtcbiAgICAgIHZhciByUHJvdG8gPSByZWdpc3RyYW50LnByb3RvdHlwZTtcblxuICAgICAgdmFyIFJlbmRlcmVyID0gZnVuY3Rpb24gUmVuZGVyZXIoKSB7XG4gICAgICAgIEJhc2VSZW5kZXJlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBSZWdpc3RyYW50UmVuZGVyZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBwcm90byA9IFJlbmRlcmVyLnByb3RvdHlwZTtcblxuICAgICAgZm9yICh2YXIgcE5hbWUgaW4gYlByb3RvKSB7XG4gICAgICAgIHZhciBwVmFsID0gYlByb3RvW3BOYW1lXTtcbiAgICAgICAgdmFyIGV4aXN0c0luUiA9IHJQcm90b1twTmFtZV0gIT0gbnVsbDtcblxuICAgICAgICBpZiAoZXhpc3RzSW5SKSB7XG4gICAgICAgICAgcmV0dXJuIG92ZXJyaWRlRXJyKHBOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb3RvW3BOYW1lXSA9IHBWYWw7IC8vIHRha2UgaW1wbCBmcm9tIGJhc2VcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX3BOYW1lIGluIHJQcm90bykge1xuICAgICAgICBwcm90b1tfcE5hbWVdID0gclByb3RvW19wTmFtZV07IC8vIHRha2UgaW1wbCBmcm9tIHJlZ2lzdHJhbnRcbiAgICAgIH1cblxuICAgICAgYlByb3RvLmNsaWVudEZ1bmN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHByb3RvW25hbWVdID0gcHJvdG9bbmFtZV0gfHwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGVycm9yKCdSZW5kZXJlciBkb2VzIG5vdCBpbXBsZW1lbnQgYHJlbmRlcmVyLicgKyBuYW1lICsgJygpYCBvbiBpdHMgcHJvdG90eXBlJyk7XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIGV4dCA9IFJlbmRlcmVyO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ19fcHJvdG9fXycgfHwgdHlwZSA9PT0gJ2NvbnN0cnVjdG9yJyB8fCB0eXBlID09PSAncHJvdG90eXBlJykge1xuICAgICAgLy8gdG8gYXZvaWQgcG90ZW50aWFsIHByb3RvdHlwZSBwb2xsdXRpb25cbiAgICAgIHJldHVybiBlcnJvcih0eXBlICsgJyBpcyBhbiBpbGxlZ2FsIHR5cGUgdG8gYmUgcmVnaXN0ZXJlZCwgcG9zc2libHkgbGVhZCB0byBwcm90b3R5cGUgcG9sbHV0aW9ucycpO1xuICAgIH1cblxuICAgIHJldHVybiBzZXRNYXAoe1xuICAgICAgbWFwOiBleHRlbnNpb25zLFxuICAgICAga2V5czogW3R5cGUsIG5hbWVdLFxuICAgICAgdmFsdWU6IGV4dFxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RXh0ZW5zaW9uKHR5cGUsIG5hbWUpIHtcbiAgICByZXR1cm4gZ2V0TWFwKHtcbiAgICAgIG1hcDogZXh0ZW5zaW9ucyxcbiAgICAgIGtleXM6IFt0eXBlLCBuYW1lXVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0TW9kdWxlKHR5cGUsIG5hbWUsIG1vZHVsZVR5cGUsIG1vZHVsZU5hbWUsIHJlZ2lzdHJhbnQpIHtcbiAgICByZXR1cm4gc2V0TWFwKHtcbiAgICAgIG1hcDogbW9kdWxlcyxcbiAgICAgIGtleXM6IFt0eXBlLCBuYW1lLCBtb2R1bGVUeXBlLCBtb2R1bGVOYW1lXSxcbiAgICAgIHZhbHVlOiByZWdpc3RyYW50XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRNb2R1bGUodHlwZSwgbmFtZSwgbW9kdWxlVHlwZSwgbW9kdWxlTmFtZSkge1xuICAgIHJldHVybiBnZXRNYXAoe1xuICAgICAgbWFwOiBtb2R1bGVzLFxuICAgICAga2V5czogW3R5cGUsIG5hbWUsIG1vZHVsZVR5cGUsIG1vZHVsZU5hbWVdXG4gICAgfSk7XG4gIH1cblxuICB2YXIgZXh0ZW5zaW9uID0gZnVuY3Rpb24gZXh0ZW5zaW9uKCkge1xuICAgIC8vIGUuZy4gZXh0ZW5zaW9uKCdyZW5kZXJlcicsICdzdmcnKVxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICByZXR1cm4gZ2V0RXh0ZW5zaW9uLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSAvLyBlLmcuIGV4dGVuc2lvbigncmVuZGVyZXInLCAnc3ZnJywgeyAuLi4gfSlcbiAgICBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgICByZXR1cm4gc2V0RXh0ZW5zaW9uLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSAvLyBlLmcuIGV4dGVuc2lvbigncmVuZGVyZXInLCAnc3ZnJywgJ25vZGVTaGFwZScsICdlbGxpcHNlJylcbiAgICBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA0KSB7XG4gICAgICByZXR1cm4gZ2V0TW9kdWxlLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSAvLyBlLmcuIGV4dGVuc2lvbigncmVuZGVyZXInLCAnc3ZnJywgJ25vZGVTaGFwZScsICdlbGxpcHNlJywgeyAuLi4gfSlcbiAgICBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA1KSB7XG4gICAgICByZXR1cm4gc2V0TW9kdWxlLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVycm9yKCdJbnZhbGlkIGV4dGVuc2lvbiBhY2Nlc3Mgc3ludGF4Jyk7XG4gICAgfVxuICB9OyAvLyBhbGxvd3MgYSBjb3JlIGluc3RhbmNlIHRvIGFjY2VzcyBleHRlbnNpb25zIGludGVybmFsbHlcblxuXG4gIENvcmUucHJvdG90eXBlLmV4dGVuc2lvbiA9IGV4dGVuc2lvbjsgLy8gaW5jbHVkZWQgZXh0ZW5zaW9uc1xuXG4gIGluY0V4dHMuZm9yRWFjaChmdW5jdGlvbiAoZ3JvdXApIHtcbiAgICBncm91cC5leHRlbnNpb25zLmZvckVhY2goZnVuY3Rpb24gKGV4dCkge1xuICAgICAgc2V0RXh0ZW5zaW9uKGdyb3VwLnR5cGUsIGV4dC5uYW1lLCBleHQuaW1wbCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vICh1c2VmdWwgZm9yIGluaXQpXG5cbiAgdmFyIFN0eWxlc2hlZXQgPSBmdW5jdGlvbiBTdHlsZXNoZWV0KCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTdHlsZXNoZWV0KSkge1xuICAgICAgcmV0dXJuIG5ldyBTdHlsZXNoZWV0KCk7XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICB9O1xuXG4gIHZhciBzaGVldGZuID0gU3R5bGVzaGVldC5wcm90b3R5cGU7XG5cbiAgc2hlZXRmbi5pbnN0YW5jZVN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gJ3N0eWxlc2hlZXQnO1xuICB9OyAvLyBqdXN0IHN0b3JlIHRoZSBzZWxlY3RvciB0byBiZSBwYXJzZWQgbGF0ZXJcblxuXG4gIHNoZWV0Zm4uc2VsZWN0b3IgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICB2YXIgaSA9IHRoaXMubGVuZ3RoKys7XG4gICAgdGhpc1tpXSA9IHtcbiAgICAgIHNlbGVjdG9yOiBzZWxlY3RvcixcbiAgICAgIHByb3BlcnRpZXM6IFtdXG4gICAgfTtcbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfTsgLy8ganVzdCBzdG9yZSB0aGUgcHJvcGVydHkgdG8gYmUgcGFyc2VkIGxhdGVyXG5cblxuICBzaGVldGZuLmNzcyA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBpID0gdGhpcy5sZW5ndGggLSAxO1xuXG4gICAgaWYgKHN0cmluZyhuYW1lKSkge1xuICAgICAgdGhpc1tpXS5wcm9wZXJ0aWVzLnB1c2goe1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAocGxhaW5PYmplY3QobmFtZSkpIHtcbiAgICAgIHZhciBtYXAgPSBuYW1lO1xuICAgICAgdmFyIHByb3BOYW1lcyA9IE9iamVjdC5rZXlzKG1hcCk7XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcHJvcE5hbWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wTmFtZXNbal07XG4gICAgICAgIHZhciBtYXBWYWwgPSBtYXBba2V5XTtcblxuICAgICAgICBpZiAobWFwVmFsID09IG51bGwpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcm9wID0gU3R5bGUucHJvcGVydGllc1trZXldIHx8IFN0eWxlLnByb3BlcnRpZXNbZGFzaDJjYW1lbChrZXkpXTtcblxuICAgICAgICBpZiAocHJvcCA9PSBudWxsKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX25hbWUgPSBwcm9wLm5hbWU7XG4gICAgICAgIHZhciBfdmFsdWUgPSBtYXBWYWw7XG4gICAgICAgIHRoaXNbaV0ucHJvcGVydGllcy5wdXNoKHtcbiAgICAgICAgICBuYW1lOiBfbmFtZSxcbiAgICAgICAgICB2YWx1ZTogX3ZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9O1xuXG4gIHNoZWV0Zm4uc3R5bGUgPSBzaGVldGZuLmNzczsgLy8gZ2VuZXJhdGUgYSByZWFsIHN0eWxlIG9iamVjdCBmcm9tIHRoZSBkdW1teSBzdHlsZXNoZWV0XG5cbiAgc2hlZXRmbi5nZW5lcmF0ZVN0eWxlID0gZnVuY3Rpb24gKGN5KSB7XG4gICAgdmFyIHN0eWxlID0gbmV3IFN0eWxlKGN5KTtcbiAgICByZXR1cm4gdGhpcy5hcHBlbmRUb1N0eWxlKHN0eWxlKTtcbiAgfTsgLy8gYXBwZW5kIGEgZHVtbXkgc3R5bGVzaGVldCBvYmplY3Qgb24gYSByZWFsIHN0eWxlIG9iamVjdFxuXG5cbiAgc2hlZXRmbi5hcHBlbmRUb1N0eWxlID0gZnVuY3Rpb24gKHN0eWxlKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY29udGV4dCA9IHRoaXNbaV07XG4gICAgICB2YXIgc2VsZWN0b3IgPSBjb250ZXh0LnNlbGVjdG9yO1xuICAgICAgdmFyIHByb3BzID0gY29udGV4dC5wcm9wZXJ0aWVzO1xuICAgICAgc3R5bGUuc2VsZWN0b3Ioc2VsZWN0b3IpOyAvLyBhcHBseSBzZWxlY3RvclxuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHByb3BzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBwcm9wID0gcHJvcHNbal07XG4gICAgICAgIHN0eWxlLmNzcyhwcm9wLm5hbWUsIHByb3AudmFsdWUpOyAvLyBhcHBseSBwcm9wZXJ0eVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdHlsZTtcbiAgfTtcblxuICB2YXIgdmVyc2lvbiA9IFwiMy4yNC4wXCI7XG5cbiAgdmFyIGN5dG9zY2FwZSA9IGZ1bmN0aW9uIGN5dG9zY2FwZShvcHRpb25zKSB7XG4gICAgLy8gaWYgbm8gb3B0aW9ucyBzcGVjaWZpZWQsIHVzZSBkZWZhdWx0XG4gICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH0gLy8gY3JlYXRlIGluc3RhbmNlXG5cblxuICAgIGlmIChwbGFpbk9iamVjdChvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIG5ldyBDb3JlKG9wdGlvbnMpO1xuICAgIH0gLy8gYWxsb3cgZm9yIHJlZ2lzdHJhdGlvbiBvZiBleHRlbnNpb25zXG4gICAgZWxzZSBpZiAoc3RyaW5nKG9wdGlvbnMpKSB7XG4gICAgICByZXR1cm4gZXh0ZW5zaW9uLmFwcGx5KGV4dGVuc2lvbiwgYXJndW1lbnRzKTtcbiAgICB9XG4gIH07IC8vIGUuZy4gY3l0b3NjYXBlLnVzZSggcmVxdWlyZSgnY3l0b3NjYXBlLWZvbycpLCBiYXIgKVxuXG5cbiAgY3l0b3NjYXBlLnVzZSA9IGZ1bmN0aW9uIChleHQpIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7IC8vIGFyZ3MgdG8gcGFzcyB0byBleHRcblxuICAgIGFyZ3MudW5zaGlmdChjeXRvc2NhcGUpOyAvLyBjeXRvc2NhcGUgaXMgZmlyc3QgYXJnIHRvIGV4dFxuXG4gICAgZXh0LmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIGN5dG9zY2FwZS53YXJuaW5ncyA9IGZ1bmN0aW9uIChib29sKSB7XG4gICAgcmV0dXJuIHdhcm5pbmdzKGJvb2wpO1xuICB9OyAvLyByZXBsYWNlZCBieSBidWlsZCBzeXN0ZW1cblxuXG4gIGN5dG9zY2FwZS52ZXJzaW9uID0gdmVyc2lvbjsgLy8gZXhwb3NlIHB1YmxpYyBhcGlzIChtb3N0bHkgZm9yIGV4dGVuc2lvbnMpXG5cbiAgY3l0b3NjYXBlLnN0eWxlc2hlZXQgPSBjeXRvc2NhcGUuU3R5bGVzaGVldCA9IFN0eWxlc2hlZXQ7XG5cbiAgcmV0dXJuIGN5dG9zY2FwZTtcblxufSkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/cytoscape/dist/cytoscape.umd.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/layout-base/layout-base.js":
/*!*************************************************!*\
  !*** ./node_modules/layout-base/layout-base.js ***!
  \*************************************************/
/***/ (function(module) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_543__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_543__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__nested_webpack_require_543__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__nested_webpack_require_543__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__nested_webpack_require_543__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__nested_webpack_require_543__.d = function(exports, name, getter) {\n/******/ \t\tif(!__nested_webpack_require_543__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__nested_webpack_require_543__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__nested_webpack_require_543__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__nested_webpack_require_543__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__nested_webpack_require_543__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __nested_webpack_require_543__(__nested_webpack_require_543__.s = 26);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction LayoutConstants() {}\n\n/**\r\n * Layout Quality: 0:draft, 1:default, 2:proof\r\n */\nLayoutConstants.QUALITY = 1;\n\n/**\r\n * Default parameters\r\n */\nLayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED = false;\nLayoutConstants.DEFAULT_INCREMENTAL = false;\nLayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT = true;\nLayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT = false;\nLayoutConstants.DEFAULT_ANIMATION_PERIOD = 50;\nLayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES = false;\n\n// -----------------------------------------------------------------------------\n// Section: General other constants\n// -----------------------------------------------------------------------------\n/*\r\n * Margins of a graph to be applied on bouding rectangle of its contents. We\r\n * assume margins on all four sides to be uniform.\r\n */\nLayoutConstants.DEFAULT_GRAPH_MARGIN = 15;\n\n/*\r\n * Whether to consider labels in node dimensions or not\r\n */\nLayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = false;\n\n/*\r\n * Default dimension of a non-compound node.\r\n */\nLayoutConstants.SIMPLE_NODE_SIZE = 40;\n\n/*\r\n * Default dimension of a non-compound node.\r\n */\nLayoutConstants.SIMPLE_NODE_HALF_SIZE = LayoutConstants.SIMPLE_NODE_SIZE / 2;\n\n/*\r\n * Empty compound node size. When a compound node is empty, its both\r\n * dimensions should be of this value.\r\n */\nLayoutConstants.EMPTY_COMPOUND_NODE_SIZE = 40;\n\n/*\r\n * Minimum length that an edge should take during layout\r\n */\nLayoutConstants.MIN_EDGE_LENGTH = 1;\n\n/*\r\n * World boundaries that layout operates on\r\n */\nLayoutConstants.WORLD_BOUNDARY = 1000000;\n\n/*\r\n * World boundaries that random positioning can be performed with\r\n */\nLayoutConstants.INITIAL_WORLD_BOUNDARY = LayoutConstants.WORLD_BOUNDARY / 1000;\n\n/*\r\n * Coordinates of the world center\r\n */\nLayoutConstants.WORLD_CENTER_X = 1200;\nLayoutConstants.WORLD_CENTER_Y = 900;\n\nmodule.exports = LayoutConstants;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __nested_webpack_require_4947__) {\n\n\"use strict\";\n\n\nvar LGraphObject = __nested_webpack_require_4947__(2);\nvar IGeometry = __nested_webpack_require_4947__(8);\nvar IMath = __nested_webpack_require_4947__(9);\n\nfunction LEdge(source, target, vEdge) {\n  LGraphObject.call(this, vEdge);\n\n  this.isOverlapingSourceAndTarget = false;\n  this.vGraphObject = vEdge;\n  this.bendpoints = [];\n  this.source = source;\n  this.target = target;\n}\n\nLEdge.prototype = Object.create(LGraphObject.prototype);\n\nfor (var prop in LGraphObject) {\n  LEdge[prop] = LGraphObject[prop];\n}\n\nLEdge.prototype.getSource = function () {\n  return this.source;\n};\n\nLEdge.prototype.getTarget = function () {\n  return this.target;\n};\n\nLEdge.prototype.isInterGraph = function () {\n  return this.isInterGraph;\n};\n\nLEdge.prototype.getLength = function () {\n  return this.length;\n};\n\nLEdge.prototype.isOverlapingSourceAndTarget = function () {\n  return this.isOverlapingSourceAndTarget;\n};\n\nLEdge.prototype.getBendpoints = function () {\n  return this.bendpoints;\n};\n\nLEdge.prototype.getLca = function () {\n  return this.lca;\n};\n\nLEdge.prototype.getSourceInLca = function () {\n  return this.sourceInLca;\n};\n\nLEdge.prototype.getTargetInLca = function () {\n  return this.targetInLca;\n};\n\nLEdge.prototype.getOtherEnd = function (node) {\n  if (this.source === node) {\n    return this.target;\n  } else if (this.target === node) {\n    return this.source;\n  } else {\n    throw \"Node is not incident with this edge\";\n  }\n};\n\nLEdge.prototype.getOtherEndInGraph = function (node, graph) {\n  var otherEnd = this.getOtherEnd(node);\n  var root = graph.getGraphManager().getRoot();\n\n  while (true) {\n    if (otherEnd.getOwner() == graph) {\n      return otherEnd;\n    }\n\n    if (otherEnd.getOwner() == root) {\n      break;\n    }\n\n    otherEnd = otherEnd.getOwner().getParent();\n  }\n\n  return null;\n};\n\nLEdge.prototype.updateLength = function () {\n  var clipPointCoordinates = new Array(4);\n\n  this.isOverlapingSourceAndTarget = IGeometry.getIntersection(this.target.getRect(), this.source.getRect(), clipPointCoordinates);\n\n  if (!this.isOverlapingSourceAndTarget) {\n    this.lengthX = clipPointCoordinates[0] - clipPointCoordinates[2];\n    this.lengthY = clipPointCoordinates[1] - clipPointCoordinates[3];\n\n    if (Math.abs(this.lengthX) < 1.0) {\n      this.lengthX = IMath.sign(this.lengthX);\n    }\n\n    if (Math.abs(this.lengthY) < 1.0) {\n      this.lengthY = IMath.sign(this.lengthY);\n    }\n\n    this.length = Math.sqrt(this.lengthX * this.lengthX + this.lengthY * this.lengthY);\n  }\n};\n\nLEdge.prototype.updateLengthSimple = function () {\n  this.lengthX = this.target.getCenterX() - this.source.getCenterX();\n  this.lengthY = this.target.getCenterY() - this.source.getCenterY();\n\n  if (Math.abs(this.lengthX) < 1.0) {\n    this.lengthX = IMath.sign(this.lengthX);\n  }\n\n  if (Math.abs(this.lengthY) < 1.0) {\n    this.lengthY = IMath.sign(this.lengthY);\n  }\n\n  this.length = Math.sqrt(this.lengthX * this.lengthX + this.lengthY * this.lengthY);\n};\n\nmodule.exports = LEdge;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction LGraphObject(vGraphObject) {\n  this.vGraphObject = vGraphObject;\n}\n\nmodule.exports = LGraphObject;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __nested_webpack_require_8167__) {\n\n\"use strict\";\n\n\nvar LGraphObject = __nested_webpack_require_8167__(2);\nvar Integer = __nested_webpack_require_8167__(10);\nvar RectangleD = __nested_webpack_require_8167__(13);\nvar LayoutConstants = __nested_webpack_require_8167__(0);\nvar RandomSeed = __nested_webpack_require_8167__(16);\nvar PointD = __nested_webpack_require_8167__(4);\n\nfunction LNode(gm, loc, size, vNode) {\n  //Alternative constructor 1 : LNode(LGraphManager gm, Point loc, Dimension size, Object vNode)\n  if (size == null && vNode == null) {\n    vNode = loc;\n  }\n\n  LGraphObject.call(this, vNode);\n\n  //Alternative constructor 2 : LNode(Layout layout, Object vNode)\n  if (gm.graphManager != null) gm = gm.graphManager;\n\n  this.estimatedSize = Integer.MIN_VALUE;\n  this.inclusionTreeDepth = Integer.MAX_VALUE;\n  this.vGraphObject = vNode;\n  this.edges = [];\n  this.graphManager = gm;\n\n  if (size != null && loc != null) this.rect = new RectangleD(loc.x, loc.y, size.width, size.height);else this.rect = new RectangleD();\n}\n\nLNode.prototype = Object.create(LGraphObject.prototype);\nfor (var prop in LGraphObject) {\n  LNode[prop] = LGraphObject[prop];\n}\n\nLNode.prototype.getEdges = function () {\n  return this.edges;\n};\n\nLNode.prototype.getChild = function () {\n  return this.child;\n};\n\nLNode.prototype.getOwner = function () {\n  //  if (this.owner != null) {\n  //    if (!(this.owner == null || this.owner.getNodes().indexOf(this) > -1)) {\n  //      throw \"assert failed\";\n  //    }\n  //  }\n\n  return this.owner;\n};\n\nLNode.prototype.getWidth = function () {\n  return this.rect.width;\n};\n\nLNode.prototype.setWidth = function (width) {\n  this.rect.width = width;\n};\n\nLNode.prototype.getHeight = function () {\n  return this.rect.height;\n};\n\nLNode.prototype.setHeight = function (height) {\n  this.rect.height = height;\n};\n\nLNode.prototype.getCenterX = function () {\n  return this.rect.x + this.rect.width / 2;\n};\n\nLNode.prototype.getCenterY = function () {\n  return this.rect.y + this.rect.height / 2;\n};\n\nLNode.prototype.getCenter = function () {\n  return new PointD(this.rect.x + this.rect.width / 2, this.rect.y + this.rect.height / 2);\n};\n\nLNode.prototype.getLocation = function () {\n  return new PointD(this.rect.x, this.rect.y);\n};\n\nLNode.prototype.getRect = function () {\n  return this.rect;\n};\n\nLNode.prototype.getDiagonal = function () {\n  return Math.sqrt(this.rect.width * this.rect.width + this.rect.height * this.rect.height);\n};\n\n/**\n * This method returns half the diagonal length of this node.\n */\nLNode.prototype.getHalfTheDiagonal = function () {\n  return Math.sqrt(this.rect.height * this.rect.height + this.rect.width * this.rect.width) / 2;\n};\n\nLNode.prototype.setRect = function (upperLeft, dimension) {\n  this.rect.x = upperLeft.x;\n  this.rect.y = upperLeft.y;\n  this.rect.width = dimension.width;\n  this.rect.height = dimension.height;\n};\n\nLNode.prototype.setCenter = function (cx, cy) {\n  this.rect.x = cx - this.rect.width / 2;\n  this.rect.y = cy - this.rect.height / 2;\n};\n\nLNode.prototype.setLocation = function (x, y) {\n  this.rect.x = x;\n  this.rect.y = y;\n};\n\nLNode.prototype.moveBy = function (dx, dy) {\n  this.rect.x += dx;\n  this.rect.y += dy;\n};\n\nLNode.prototype.getEdgeListToNode = function (to) {\n  var edgeList = [];\n  var edge;\n  var self = this;\n\n  self.edges.forEach(function (edge) {\n\n    if (edge.target == to) {\n      if (edge.source != self) throw \"Incorrect edge source!\";\n\n      edgeList.push(edge);\n    }\n  });\n\n  return edgeList;\n};\n\nLNode.prototype.getEdgesBetween = function (other) {\n  var edgeList = [];\n  var edge;\n\n  var self = this;\n  self.edges.forEach(function (edge) {\n\n    if (!(edge.source == self || edge.target == self)) throw \"Incorrect edge source and/or target\";\n\n    if (edge.target == other || edge.source == other) {\n      edgeList.push(edge);\n    }\n  });\n\n  return edgeList;\n};\n\nLNode.prototype.getNeighborsList = function () {\n  var neighbors = new Set();\n\n  var self = this;\n  self.edges.forEach(function (edge) {\n\n    if (edge.source == self) {\n      neighbors.add(edge.target);\n    } else {\n      if (edge.target != self) {\n        throw \"Incorrect incidency!\";\n      }\n\n      neighbors.add(edge.source);\n    }\n  });\n\n  return neighbors;\n};\n\nLNode.prototype.withChildren = function () {\n  var withNeighborsList = new Set();\n  var childNode;\n  var children;\n\n  withNeighborsList.add(this);\n\n  if (this.child != null) {\n    var nodes = this.child.getNodes();\n    for (var i = 0; i < nodes.length; i++) {\n      childNode = nodes[i];\n      children = childNode.withChildren();\n      children.forEach(function (node) {\n        withNeighborsList.add(node);\n      });\n    }\n  }\n\n  return withNeighborsList;\n};\n\nLNode.prototype.getNoOfChildren = function () {\n  var noOfChildren = 0;\n  var childNode;\n\n  if (this.child == null) {\n    noOfChildren = 1;\n  } else {\n    var nodes = this.child.getNodes();\n    for (var i = 0; i < nodes.length; i++) {\n      childNode = nodes[i];\n\n      noOfChildren += childNode.getNoOfChildren();\n    }\n  }\n\n  if (noOfChildren == 0) {\n    noOfChildren = 1;\n  }\n  return noOfChildren;\n};\n\nLNode.prototype.getEstimatedSize = function () {\n  if (this.estimatedSize == Integer.MIN_VALUE) {\n    throw \"assert failed\";\n  }\n  return this.estimatedSize;\n};\n\nLNode.prototype.calcEstimatedSize = function () {\n  if (this.child == null) {\n    return this.estimatedSize = (this.rect.width + this.rect.height) / 2;\n  } else {\n    this.estimatedSize = this.child.calcEstimatedSize();\n    this.rect.width = this.estimatedSize;\n    this.rect.height = this.estimatedSize;\n\n    return this.estimatedSize;\n  }\n};\n\nLNode.prototype.scatter = function () {\n  var randomCenterX;\n  var randomCenterY;\n\n  var minX = -LayoutConstants.INITIAL_WORLD_BOUNDARY;\n  var maxX = LayoutConstants.INITIAL_WORLD_BOUNDARY;\n  randomCenterX = LayoutConstants.WORLD_CENTER_X + RandomSeed.nextDouble() * (maxX - minX) + minX;\n\n  var minY = -LayoutConstants.INITIAL_WORLD_BOUNDARY;\n  var maxY = LayoutConstants.INITIAL_WORLD_BOUNDARY;\n  randomCenterY = LayoutConstants.WORLD_CENTER_Y + RandomSeed.nextDouble() * (maxY - minY) + minY;\n\n  this.rect.x = randomCenterX;\n  this.rect.y = randomCenterY;\n};\n\nLNode.prototype.updateBounds = function () {\n  if (this.getChild() == null) {\n    throw \"assert failed\";\n  }\n  if (this.getChild().getNodes().length != 0) {\n    // wrap the children nodes by re-arranging the boundaries\n    var childGraph = this.getChild();\n    childGraph.updateBounds(true);\n\n    this.rect.x = childGraph.getLeft();\n    this.rect.y = childGraph.getTop();\n\n    this.setWidth(childGraph.getRight() - childGraph.getLeft());\n    this.setHeight(childGraph.getBottom() - childGraph.getTop());\n\n    // Update compound bounds considering its label properties    \n    if (LayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS) {\n\n      var width = childGraph.getRight() - childGraph.getLeft();\n      var height = childGraph.getBottom() - childGraph.getTop();\n\n      if (this.labelWidth > width) {\n        this.rect.x -= (this.labelWidth - width) / 2;\n        this.setWidth(this.labelWidth);\n      }\n\n      if (this.labelHeight > height) {\n        if (this.labelPos == \"center\") {\n          this.rect.y -= (this.labelHeight - height) / 2;\n        } else if (this.labelPos == \"top\") {\n          this.rect.y -= this.labelHeight - height;\n        }\n        this.setHeight(this.labelHeight);\n      }\n    }\n  }\n};\n\nLNode.prototype.getInclusionTreeDepth = function () {\n  if (this.inclusionTreeDepth == Integer.MAX_VALUE) {\n    throw \"assert failed\";\n  }\n  return this.inclusionTreeDepth;\n};\n\nLNode.prototype.transform = function (trans) {\n  var left = this.rect.x;\n\n  if (left > LayoutConstants.WORLD_BOUNDARY) {\n    left = LayoutConstants.WORLD_BOUNDARY;\n  } else if (left < -LayoutConstants.WORLD_BOUNDARY) {\n    left = -LayoutConstants.WORLD_BOUNDARY;\n  }\n\n  var top = this.rect.y;\n\n  if (top > LayoutConstants.WORLD_BOUNDARY) {\n    top = LayoutConstants.WORLD_BOUNDARY;\n  } else if (top < -LayoutConstants.WORLD_BOUNDARY) {\n    top = -LayoutConstants.WORLD_BOUNDARY;\n  }\n\n  var leftTop = new PointD(left, top);\n  var vLeftTop = trans.inverseTransformPoint(leftTop);\n\n  this.setLocation(vLeftTop.x, vLeftTop.y);\n};\n\nLNode.prototype.getLeft = function () {\n  return this.rect.x;\n};\n\nLNode.prototype.getRight = function () {\n  return this.rect.x + this.rect.width;\n};\n\nLNode.prototype.getTop = function () {\n  return this.rect.y;\n};\n\nLNode.prototype.getBottom = function () {\n  return this.rect.y + this.rect.height;\n};\n\nLNode.prototype.getParent = function () {\n  if (this.owner == null) {\n    return null;\n  }\n\n  return this.owner.getParent();\n};\n\nmodule.exports = LNode;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction PointD(x, y) {\n  if (x == null && y == null) {\n    this.x = 0;\n    this.y = 0;\n  } else {\n    this.x = x;\n    this.y = y;\n  }\n}\n\nPointD.prototype.getX = function () {\n  return this.x;\n};\n\nPointD.prototype.getY = function () {\n  return this.y;\n};\n\nPointD.prototype.setX = function (x) {\n  this.x = x;\n};\n\nPointD.prototype.setY = function (y) {\n  this.y = y;\n};\n\nPointD.prototype.getDifference = function (pt) {\n  return new DimensionD(this.x - pt.x, this.y - pt.y);\n};\n\nPointD.prototype.getCopy = function () {\n  return new PointD(this.x, this.y);\n};\n\nPointD.prototype.translate = function (dim) {\n  this.x += dim.width;\n  this.y += dim.height;\n  return this;\n};\n\nmodule.exports = PointD;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __nested_webpack_require_17549__) {\n\n\"use strict\";\n\n\nvar LGraphObject = __nested_webpack_require_17549__(2);\nvar Integer = __nested_webpack_require_17549__(10);\nvar LayoutConstants = __nested_webpack_require_17549__(0);\nvar LGraphManager = __nested_webpack_require_17549__(6);\nvar LNode = __nested_webpack_require_17549__(3);\nvar LEdge = __nested_webpack_require_17549__(1);\nvar RectangleD = __nested_webpack_require_17549__(13);\nvar Point = __nested_webpack_require_17549__(12);\nvar LinkedList = __nested_webpack_require_17549__(11);\n\nfunction LGraph(parent, obj2, vGraph) {\n  LGraphObject.call(this, vGraph);\n  this.estimatedSize = Integer.MIN_VALUE;\n  this.margin = LayoutConstants.DEFAULT_GRAPH_MARGIN;\n  this.edges = [];\n  this.nodes = [];\n  this.isConnected = false;\n  this.parent = parent;\n\n  if (obj2 != null && obj2 instanceof LGraphManager) {\n    this.graphManager = obj2;\n  } else if (obj2 != null && obj2 instanceof Layout) {\n    this.graphManager = obj2.graphManager;\n  }\n}\n\nLGraph.prototype = Object.create(LGraphObject.prototype);\nfor (var prop in LGraphObject) {\n  LGraph[prop] = LGraphObject[prop];\n}\n\nLGraph.prototype.getNodes = function () {\n  return this.nodes;\n};\n\nLGraph.prototype.getEdges = function () {\n  return this.edges;\n};\n\nLGraph.prototype.getGraphManager = function () {\n  return this.graphManager;\n};\n\nLGraph.prototype.getParent = function () {\n  return this.parent;\n};\n\nLGraph.prototype.getLeft = function () {\n  return this.left;\n};\n\nLGraph.prototype.getRight = function () {\n  return this.right;\n};\n\nLGraph.prototype.getTop = function () {\n  return this.top;\n};\n\nLGraph.prototype.getBottom = function () {\n  return this.bottom;\n};\n\nLGraph.prototype.isConnected = function () {\n  return this.isConnected;\n};\n\nLGraph.prototype.add = function (obj1, sourceNode, targetNode) {\n  if (sourceNode == null && targetNode == null) {\n    var newNode = obj1;\n    if (this.graphManager == null) {\n      throw \"Graph has no graph mgr!\";\n    }\n    if (this.getNodes().indexOf(newNode) > -1) {\n      throw \"Node already in graph!\";\n    }\n    newNode.owner = this;\n    this.getNodes().push(newNode);\n\n    return newNode;\n  } else {\n    var newEdge = obj1;\n    if (!(this.getNodes().indexOf(sourceNode) > -1 && this.getNodes().indexOf(targetNode) > -1)) {\n      throw \"Source or target not in graph!\";\n    }\n\n    if (!(sourceNode.owner == targetNode.owner && sourceNode.owner == this)) {\n      throw \"Both owners must be this graph!\";\n    }\n\n    if (sourceNode.owner != targetNode.owner) {\n      return null;\n    }\n\n    // set source and target\n    newEdge.source = sourceNode;\n    newEdge.target = targetNode;\n\n    // set as intra-graph edge\n    newEdge.isInterGraph = false;\n\n    // add to graph edge list\n    this.getEdges().push(newEdge);\n\n    // add to incidency lists\n    sourceNode.edges.push(newEdge);\n\n    if (targetNode != sourceNode) {\n      targetNode.edges.push(newEdge);\n    }\n\n    return newEdge;\n  }\n};\n\nLGraph.prototype.remove = function (obj) {\n  var node = obj;\n  if (obj instanceof LNode) {\n    if (node == null) {\n      throw \"Node is null!\";\n    }\n    if (!(node.owner != null && node.owner == this)) {\n      throw \"Owner graph is invalid!\";\n    }\n    if (this.graphManager == null) {\n      throw \"Owner graph manager is invalid!\";\n    }\n    // remove incident edges first (make a copy to do it safely)\n    var edgesToBeRemoved = node.edges.slice();\n    var edge;\n    var s = edgesToBeRemoved.length;\n    for (var i = 0; i < s; i++) {\n      edge = edgesToBeRemoved[i];\n\n      if (edge.isInterGraph) {\n        this.graphManager.remove(edge);\n      } else {\n        edge.source.owner.remove(edge);\n      }\n    }\n\n    // now the node itself\n    var index = this.nodes.indexOf(node);\n    if (index == -1) {\n      throw \"Node not in owner node list!\";\n    }\n\n    this.nodes.splice(index, 1);\n  } else if (obj instanceof LEdge) {\n    var edge = obj;\n    if (edge == null) {\n      throw \"Edge is null!\";\n    }\n    if (!(edge.source != null && edge.target != null)) {\n      throw \"Source and/or target is null!\";\n    }\n    if (!(edge.source.owner != null && edge.target.owner != null && edge.source.owner == this && edge.target.owner == this)) {\n      throw \"Source and/or target owner is invalid!\";\n    }\n\n    var sourceIndex = edge.source.edges.indexOf(edge);\n    var targetIndex = edge.target.edges.indexOf(edge);\n    if (!(sourceIndex > -1 && targetIndex > -1)) {\n      throw \"Source and/or target doesn't know this edge!\";\n    }\n\n    edge.source.edges.splice(sourceIndex, 1);\n\n    if (edge.target != edge.source) {\n      edge.target.edges.splice(targetIndex, 1);\n    }\n\n    var index = edge.source.owner.getEdges().indexOf(edge);\n    if (index == -1) {\n      throw \"Not in owner's edge list!\";\n    }\n\n    edge.source.owner.getEdges().splice(index, 1);\n  }\n};\n\nLGraph.prototype.updateLeftTop = function () {\n  var top = Integer.MAX_VALUE;\n  var left = Integer.MAX_VALUE;\n  var nodeTop;\n  var nodeLeft;\n  var margin;\n\n  var nodes = this.getNodes();\n  var s = nodes.length;\n\n  for (var i = 0; i < s; i++) {\n    var lNode = nodes[i];\n    nodeTop = lNode.getTop();\n    nodeLeft = lNode.getLeft();\n\n    if (top > nodeTop) {\n      top = nodeTop;\n    }\n\n    if (left > nodeLeft) {\n      left = nodeLeft;\n    }\n  }\n\n  // Do we have any nodes in this graph?\n  if (top == Integer.MAX_VALUE) {\n    return null;\n  }\n\n  if (nodes[0].getParent().paddingLeft != undefined) {\n    margin = nodes[0].getParent().paddingLeft;\n  } else {\n    margin = this.margin;\n  }\n\n  this.left = left - margin;\n  this.top = top - margin;\n\n  // Apply the margins and return the result\n  return new Point(this.left, this.top);\n};\n\nLGraph.prototype.updateBounds = function (recursive) {\n  // calculate bounds\n  var left = Integer.MAX_VALUE;\n  var right = -Integer.MAX_VALUE;\n  var top = Integer.MAX_VALUE;\n  var bottom = -Integer.MAX_VALUE;\n  var nodeLeft;\n  var nodeRight;\n  var nodeTop;\n  var nodeBottom;\n  var margin;\n\n  var nodes = this.nodes;\n  var s = nodes.length;\n  for (var i = 0; i < s; i++) {\n    var lNode = nodes[i];\n\n    if (recursive && lNode.child != null) {\n      lNode.updateBounds();\n    }\n    nodeLeft = lNode.getLeft();\n    nodeRight = lNode.getRight();\n    nodeTop = lNode.getTop();\n    nodeBottom = lNode.getBottom();\n\n    if (left > nodeLeft) {\n      left = nodeLeft;\n    }\n\n    if (right < nodeRight) {\n      right = nodeRight;\n    }\n\n    if (top > nodeTop) {\n      top = nodeTop;\n    }\n\n    if (bottom < nodeBottom) {\n      bottom = nodeBottom;\n    }\n  }\n\n  var boundingRect = new RectangleD(left, top, right - left, bottom - top);\n  if (left == Integer.MAX_VALUE) {\n    this.left = this.parent.getLeft();\n    this.right = this.parent.getRight();\n    this.top = this.parent.getTop();\n    this.bottom = this.parent.getBottom();\n  }\n\n  if (nodes[0].getParent().paddingLeft != undefined) {\n    margin = nodes[0].getParent().paddingLeft;\n  } else {\n    margin = this.margin;\n  }\n\n  this.left = boundingRect.x - margin;\n  this.right = boundingRect.x + boundingRect.width + margin;\n  this.top = boundingRect.y - margin;\n  this.bottom = boundingRect.y + boundingRect.height + margin;\n};\n\nLGraph.calculateBounds = function (nodes) {\n  var left = Integer.MAX_VALUE;\n  var right = -Integer.MAX_VALUE;\n  var top = Integer.MAX_VALUE;\n  var bottom = -Integer.MAX_VALUE;\n  var nodeLeft;\n  var nodeRight;\n  var nodeTop;\n  var nodeBottom;\n\n  var s = nodes.length;\n\n  for (var i = 0; i < s; i++) {\n    var lNode = nodes[i];\n    nodeLeft = lNode.getLeft();\n    nodeRight = lNode.getRight();\n    nodeTop = lNode.getTop();\n    nodeBottom = lNode.getBottom();\n\n    if (left > nodeLeft) {\n      left = nodeLeft;\n    }\n\n    if (right < nodeRight) {\n      right = nodeRight;\n    }\n\n    if (top > nodeTop) {\n      top = nodeTop;\n    }\n\n    if (bottom < nodeBottom) {\n      bottom = nodeBottom;\n    }\n  }\n\n  var boundingRect = new RectangleD(left, top, right - left, bottom - top);\n\n  return boundingRect;\n};\n\nLGraph.prototype.getInclusionTreeDepth = function () {\n  if (this == this.graphManager.getRoot()) {\n    return 1;\n  } else {\n    return this.parent.getInclusionTreeDepth();\n  }\n};\n\nLGraph.prototype.getEstimatedSize = function () {\n  if (this.estimatedSize == Integer.MIN_VALUE) {\n    throw \"assert failed\";\n  }\n  return this.estimatedSize;\n};\n\nLGraph.prototype.calcEstimatedSize = function () {\n  var size = 0;\n  var nodes = this.nodes;\n  var s = nodes.length;\n\n  for (var i = 0; i < s; i++) {\n    var lNode = nodes[i];\n    size += lNode.calcEstimatedSize();\n  }\n\n  if (size == 0) {\n    this.estimatedSize = LayoutConstants.EMPTY_COMPOUND_NODE_SIZE;\n  } else {\n    this.estimatedSize = size / Math.sqrt(this.nodes.length);\n  }\n\n  return this.estimatedSize;\n};\n\nLGraph.prototype.updateConnected = function () {\n  var self = this;\n  if (this.nodes.length == 0) {\n    this.isConnected = true;\n    return;\n  }\n\n  var queue = new LinkedList();\n  var visited = new Set();\n  var currentNode = this.nodes[0];\n  var neighborEdges;\n  var currentNeighbor;\n  var childrenOfNode = currentNode.withChildren();\n  childrenOfNode.forEach(function (node) {\n    queue.push(node);\n    visited.add(node);\n  });\n\n  while (queue.length !== 0) {\n    currentNode = queue.shift();\n\n    // Traverse all neighbors of this node\n    neighborEdges = currentNode.getEdges();\n    var size = neighborEdges.length;\n    for (var i = 0; i < size; i++) {\n      var neighborEdge = neighborEdges[i];\n      currentNeighbor = neighborEdge.getOtherEndInGraph(currentNode, this);\n\n      // Add unvisited neighbors to the list to visit\n      if (currentNeighbor != null && !visited.has(currentNeighbor)) {\n        var childrenOfNeighbor = currentNeighbor.withChildren();\n\n        childrenOfNeighbor.forEach(function (node) {\n          queue.push(node);\n          visited.add(node);\n        });\n      }\n    }\n  }\n\n  this.isConnected = false;\n\n  if (visited.size >= this.nodes.length) {\n    var noOfVisitedInThisGraph = 0;\n\n    visited.forEach(function (visitedNode) {\n      if (visitedNode.owner == self) {\n        noOfVisitedInThisGraph++;\n      }\n    });\n\n    if (noOfVisitedInThisGraph == this.nodes.length) {\n      this.isConnected = true;\n    }\n  }\n};\n\nmodule.exports = LGraph;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __nested_webpack_require_27617__) {\n\n\"use strict\";\n\n\nvar LGraph;\nvar LEdge = __nested_webpack_require_27617__(1);\n\nfunction LGraphManager(layout) {\n  LGraph = __nested_webpack_require_27617__(5); // It may be better to initilize this out of this function but it gives an error (Right-hand side of 'instanceof' is not callable) now.\n  this.layout = layout;\n\n  this.graphs = [];\n  this.edges = [];\n}\n\nLGraphManager.prototype.addRoot = function () {\n  var ngraph = this.layout.newGraph();\n  var nnode = this.layout.newNode(null);\n  var root = this.add(ngraph, nnode);\n  this.setRootGraph(root);\n  return this.rootGraph;\n};\n\nLGraphManager.prototype.add = function (newGraph, parentNode, newEdge, sourceNode, targetNode) {\n  //there are just 2 parameters are passed then it adds an LGraph else it adds an LEdge\n  if (newEdge == null && sourceNode == null && targetNode == null) {\n    if (newGraph == null) {\n      throw \"Graph is null!\";\n    }\n    if (parentNode == null) {\n      throw \"Parent node is null!\";\n    }\n    if (this.graphs.indexOf(newGraph) > -1) {\n      throw \"Graph already in this graph mgr!\";\n    }\n\n    this.graphs.push(newGraph);\n\n    if (newGraph.parent != null) {\n      throw \"Already has a parent!\";\n    }\n    if (parentNode.child != null) {\n      throw \"Already has a child!\";\n    }\n\n    newGraph.parent = parentNode;\n    parentNode.child = newGraph;\n\n    return newGraph;\n  } else {\n    //change the order of the parameters\n    targetNode = newEdge;\n    sourceNode = parentNode;\n    newEdge = newGraph;\n    var sourceGraph = sourceNode.getOwner();\n    var targetGraph = targetNode.getOwner();\n\n    if (!(sourceGraph != null && sourceGraph.getGraphManager() == this)) {\n      throw \"Source not in this graph mgr!\";\n    }\n    if (!(targetGraph != null && targetGraph.getGraphManager() == this)) {\n      throw \"Target not in this graph mgr!\";\n    }\n\n    if (sourceGraph == targetGraph) {\n      newEdge.isInterGraph = false;\n      return sourceGraph.add(newEdge, sourceNode, targetNode);\n    } else {\n      newEdge.isInterGraph = true;\n\n      // set source and target\n      newEdge.source = sourceNode;\n      newEdge.target = targetNode;\n\n      // add edge to inter-graph edge list\n      if (this.edges.indexOf(newEdge) > -1) {\n        throw \"Edge already in inter-graph edge list!\";\n      }\n\n      this.edges.push(newEdge);\n\n      // add edge to source and target incidency lists\n      if (!(newEdge.source != null && newEdge.target != null)) {\n        throw \"Edge source and/or target is null!\";\n      }\n\n      if (!(newEdge.source.edges.indexOf(newEdge) == -1 && newEdge.target.edges.indexOf(newEdge) == -1)) {\n        throw \"Edge already in source and/or target incidency list!\";\n      }\n\n      newEdge.source.edges.push(newEdge);\n      newEdge.target.edges.push(newEdge);\n\n      return newEdge;\n    }\n  }\n};\n\nLGraphManager.prototype.remove = function (lObj) {\n  if (lObj instanceof LGraph) {\n    var graph = lObj;\n    if (graph.getGraphManager() != this) {\n      throw \"Graph not in this graph mgr\";\n    }\n    if (!(graph == this.rootGraph || graph.parent != null && graph.parent.graphManager == this)) {\n      throw \"Invalid parent node!\";\n    }\n\n    // first the edges (make a copy to do it safely)\n    var edgesToBeRemoved = [];\n\n    edgesToBeRemoved = edgesToBeRemoved.concat(graph.getEdges());\n\n    var edge;\n    var s = edgesToBeRemoved.length;\n    for (var i = 0; i < s; i++) {\n      edge = edgesToBeRemoved[i];\n      graph.remove(edge);\n    }\n\n    // then the nodes (make a copy to do it safely)\n    var nodesToBeRemoved = [];\n\n    nodesToBeRemoved = nodesToBeRemoved.concat(graph.getNodes());\n\n    var node;\n    s = nodesToBeRemoved.length;\n    for (var i = 0; i < s; i++) {\n      node = nodesToBeRemoved[i];\n      graph.remove(node);\n    }\n\n    // check if graph is the root\n    if (graph == this.rootGraph) {\n      this.setRootGraph(null);\n    }\n\n    // now remove the graph itself\n    var index = this.graphs.indexOf(graph);\n    this.graphs.splice(index, 1);\n\n    // also reset the parent of the graph\n    graph.parent = null;\n  } else if (lObj instanceof LEdge) {\n    edge = lObj;\n    if (edge == null) {\n      throw \"Edge is null!\";\n    }\n    if (!edge.isInterGraph) {\n      throw \"Not an inter-graph edge!\";\n    }\n    if (!(edge.source != null && edge.target != null)) {\n      throw \"Source and/or target is null!\";\n    }\n\n    // remove edge from source and target nodes' incidency lists\n\n    if (!(edge.source.edges.indexOf(edge) != -1 && edge.target.edges.indexOf(edge) != -1)) {\n      throw \"Source and/or target doesn't know this edge!\";\n    }\n\n    var index = edge.source.edges.indexOf(edge);\n    edge.source.edges.splice(index, 1);\n    index = edge.target.edges.indexOf(edge);\n    edge.target.edges.splice(index, 1);\n\n    // remove edge from owner graph manager's inter-graph edge list\n\n    if (!(edge.source.owner != null && edge.source.owner.getGraphManager() != null)) {\n      throw \"Edge owner graph or owner graph manager is null!\";\n    }\n    if (edge.source.owner.getGraphManager().edges.indexOf(edge) == -1) {\n      throw \"Not in owner graph manager's edge list!\";\n    }\n\n    var index = edge.source.owner.getGraphManager().edges.indexOf(edge);\n    edge.source.owner.getGraphManager().edges.splice(index, 1);\n  }\n};\n\nLGraphManager.prototype.updateBounds = function () {\n  this.rootGraph.updateBounds(true);\n};\n\nLGraphManager.prototype.getGraphs = function () {\n  return this.graphs;\n};\n\nLGraphManager.prototype.getAllNodes = function () {\n  if (this.allNodes == null) {\n    var nodeList = [];\n    var graphs = this.getGraphs();\n    var s = graphs.length;\n    for (var i = 0; i < s; i++) {\n      nodeList = nodeList.concat(graphs[i].getNodes());\n    }\n    this.allNodes = nodeList;\n  }\n  return this.allNodes;\n};\n\nLGraphManager.prototype.resetAllNodes = function () {\n  this.allNodes = null;\n};\n\nLGraphManager.prototype.resetAllEdges = function () {\n  this.allEdges = null;\n};\n\nLGraphManager.prototype.resetAllNodesToApplyGravitation = function () {\n  this.allNodesToApplyGravitation = null;\n};\n\nLGraphManager.prototype.getAllEdges = function () {\n  if (this.allEdges == null) {\n    var edgeList = [];\n    var graphs = this.getGraphs();\n    var s = graphs.length;\n    for (var i = 0; i < graphs.length; i++) {\n      edgeList = edgeList.concat(graphs[i].getEdges());\n    }\n\n    edgeList = edgeList.concat(this.edges);\n\n    this.allEdges = edgeList;\n  }\n  return this.allEdges;\n};\n\nLGraphManager.prototype.getAllNodesToApplyGravitation = function () {\n  return this.allNodesToApplyGravitation;\n};\n\nLGraphManager.prototype.setAllNodesToApplyGravitation = function (nodeList) {\n  if (this.allNodesToApplyGravitation != null) {\n    throw \"assert failed\";\n  }\n\n  this.allNodesToApplyGravitation = nodeList;\n};\n\nLGraphManager.prototype.getRoot = function () {\n  return this.rootGraph;\n};\n\nLGraphManager.prototype.setRootGraph = function (graph) {\n  if (graph.getGraphManager() != this) {\n    throw \"Root not in this graph mgr!\";\n  }\n\n  this.rootGraph = graph;\n  // root graph must have a root node associated with it for convenience\n  if (graph.parent == null) {\n    graph.parent = this.layout.newNode(\"Root node\");\n  }\n};\n\nLGraphManager.prototype.getLayout = function () {\n  return this.layout;\n};\n\nLGraphManager.prototype.isOneAncestorOfOther = function (firstNode, secondNode) {\n  if (!(firstNode != null && secondNode != null)) {\n    throw \"assert failed\";\n  }\n\n  if (firstNode == secondNode) {\n    return true;\n  }\n  // Is second node an ancestor of the first one?\n  var ownerGraph = firstNode.getOwner();\n  var parentNode;\n\n  do {\n    parentNode = ownerGraph.getParent();\n\n    if (parentNode == null) {\n      break;\n    }\n\n    if (parentNode == secondNode) {\n      return true;\n    }\n\n    ownerGraph = parentNode.getOwner();\n    if (ownerGraph == null) {\n      break;\n    }\n  } while (true);\n  // Is first node an ancestor of the second one?\n  ownerGraph = secondNode.getOwner();\n\n  do {\n    parentNode = ownerGraph.getParent();\n\n    if (parentNode == null) {\n      break;\n    }\n\n    if (parentNode == firstNode) {\n      return true;\n    }\n\n    ownerGraph = parentNode.getOwner();\n    if (ownerGraph == null) {\n      break;\n    }\n  } while (true);\n\n  return false;\n};\n\nLGraphManager.prototype.calcLowestCommonAncestors = function () {\n  var edge;\n  var sourceNode;\n  var targetNode;\n  var sourceAncestorGraph;\n  var targetAncestorGraph;\n\n  var edges = this.getAllEdges();\n  var s = edges.length;\n  for (var i = 0; i < s; i++) {\n    edge = edges[i];\n\n    sourceNode = edge.source;\n    targetNode = edge.target;\n    edge.lca = null;\n    edge.sourceInLca = sourceNode;\n    edge.targetInLca = targetNode;\n\n    if (sourceNode == targetNode) {\n      edge.lca = sourceNode.getOwner();\n      continue;\n    }\n\n    sourceAncestorGraph = sourceNode.getOwner();\n\n    while (edge.lca == null) {\n      edge.targetInLca = targetNode;\n      targetAncestorGraph = targetNode.getOwner();\n\n      while (edge.lca == null) {\n        if (targetAncestorGraph == sourceAncestorGraph) {\n          edge.lca = targetAncestorGraph;\n          break;\n        }\n\n        if (targetAncestorGraph == this.rootGraph) {\n          break;\n        }\n\n        if (edge.lca != null) {\n          throw \"assert failed\";\n        }\n        edge.targetInLca = targetAncestorGraph.getParent();\n        targetAncestorGraph = edge.targetInLca.getOwner();\n      }\n\n      if (sourceAncestorGraph == this.rootGraph) {\n        break;\n      }\n\n      if (edge.lca == null) {\n        edge.sourceInLca = sourceAncestorGraph.getParent();\n        sourceAncestorGraph = edge.sourceInLca.getOwner();\n      }\n    }\n\n    if (edge.lca == null) {\n      throw \"assert failed\";\n    }\n  }\n};\n\nLGraphManager.prototype.calcLowestCommonAncestor = function (firstNode, secondNode) {\n  if (firstNode == secondNode) {\n    return firstNode.getOwner();\n  }\n  var firstOwnerGraph = firstNode.getOwner();\n\n  do {\n    if (firstOwnerGraph == null) {\n      break;\n    }\n    var secondOwnerGraph = secondNode.getOwner();\n\n    do {\n      if (secondOwnerGraph == null) {\n        break;\n      }\n\n      if (secondOwnerGraph == firstOwnerGraph) {\n        return secondOwnerGraph;\n      }\n      secondOwnerGraph = secondOwnerGraph.getParent().getOwner();\n    } while (true);\n\n    firstOwnerGraph = firstOwnerGraph.getParent().getOwner();\n  } while (true);\n\n  return firstOwnerGraph;\n};\n\nLGraphManager.prototype.calcInclusionTreeDepths = function (graph, depth) {\n  if (graph == null && depth == null) {\n    graph = this.rootGraph;\n    depth = 1;\n  }\n  var node;\n\n  var nodes = graph.getNodes();\n  var s = nodes.length;\n  for (var i = 0; i < s; i++) {\n    node = nodes[i];\n    node.inclusionTreeDepth = depth;\n\n    if (node.child != null) {\n      this.calcInclusionTreeDepths(node.child, depth + 1);\n    }\n  }\n};\n\nLGraphManager.prototype.includesInvalidEdge = function () {\n  var edge;\n\n  var s = this.edges.length;\n  for (var i = 0; i < s; i++) {\n    edge = this.edges[i];\n\n    if (this.isOneAncestorOfOther(edge.source, edge.target)) {\n      return true;\n    }\n  }\n  return false;\n};\n\nmodule.exports = LGraphManager;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __nested_webpack_require_38707__) {\n\n\"use strict\";\n\n\nvar LayoutConstants = __nested_webpack_require_38707__(0);\n\nfunction FDLayoutConstants() {}\n\n//FDLayoutConstants inherits static props in LayoutConstants\nfor (var prop in LayoutConstants) {\n  FDLayoutConstants[prop] = LayoutConstants[prop];\n}\n\nFDLayoutConstants.MAX_ITERATIONS = 2500;\n\nFDLayoutConstants.DEFAULT_EDGE_LENGTH = 50;\nFDLayoutConstants.DEFAULT_SPRING_STRENGTH = 0.45;\nFDLayoutConstants.DEFAULT_REPULSION_STRENGTH = 4500.0;\nFDLayoutConstants.DEFAULT_GRAVITY_STRENGTH = 0.4;\nFDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = 1.0;\nFDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR = 3.8;\nFDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = 1.5;\nFDLayoutConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION = true;\nFDLayoutConstants.DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION = true;\nFDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = 0.3;\nFDLayoutConstants.COOLING_ADAPTATION_FACTOR = 0.33;\nFDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT = 1000;\nFDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT = 5000;\nFDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL = 100.0;\nFDLayoutConstants.MAX_NODE_DISPLACEMENT = FDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL * 3;\nFDLayoutConstants.MIN_REPULSION_DIST = FDLayoutConstants.DEFAULT_EDGE_LENGTH / 10.0;\nFDLayoutConstants.CONVERGENCE_CHECK_PERIOD = 100;\nFDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = 0.1;\nFDLayoutConstants.MIN_EDGE_LENGTH = 1;\nFDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD = 10;\n\nmodule.exports = FDLayoutConstants;\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __nested_webpack_require_40298__) {\n\n\"use strict\";\n\n\n/**\n * This class maintains a list of static geometry related utility methods.\n *\n *\n * Copyright: i-Vis Research Group, Bilkent University, 2007 - present\n */\n\nvar Point = __nested_webpack_require_40298__(12);\n\nfunction IGeometry() {}\n\n/**\n * This method calculates *half* the amount in x and y directions of the two\n * input rectangles needed to separate them keeping their respective\n * positioning, and returns the result in the input array. An input\n * separation buffer added to the amount in both directions. We assume that\n * the two rectangles do intersect.\n */\nIGeometry.calcSeparationAmount = function (rectA, rectB, overlapAmount, separationBuffer) {\n  if (!rectA.intersects(rectB)) {\n    throw \"assert failed\";\n  }\n\n  var directions = new Array(2);\n\n  this.decideDirectionsForOverlappingNodes(rectA, rectB, directions);\n\n  overlapAmount[0] = Math.min(rectA.getRight(), rectB.getRight()) - Math.max(rectA.x, rectB.x);\n  overlapAmount[1] = Math.min(rectA.getBottom(), rectB.getBottom()) - Math.max(rectA.y, rectB.y);\n\n  // update the overlapping amounts for the following cases:\n  if (rectA.getX() <= rectB.getX() && rectA.getRight() >= rectB.getRight()) {\n    /* Case x.1:\n    *\n    * rectA\n    * \t|                       |\n    * \t|        _________      |\n    * \t|        |       |      |\n    * \t|________|_______|______|\n    * \t\t\t |       |\n    *           |       |\n    *        rectB\n    */\n    overlapAmount[0] += Math.min(rectB.getX() - rectA.getX(), rectA.getRight() - rectB.getRight());\n  } else if (rectB.getX() <= rectA.getX() && rectB.getRight() >= rectA.getRight()) {\n    /* Case x.2:\n    *\n    * rectB\n    * \t|                       |\n    * \t|        _________      |\n    * \t|        |       |      |\n    * \t|________|_______|______|\n    * \t\t\t |       |\n    *           |       |\n    *        rectA\n    */\n    overlapAmount[0] += Math.min(rectA.getX() - rectB.getX(), rectB.getRight() - rectA.getRight());\n  }\n  if (rectA.getY() <= rectB.getY() && rectA.getBottom() >= rectB.getBottom()) {\n    /* Case y.1:\n     *          ________ rectA\n     *         |\n     *         |\n     *   ______|____  rectB\n     *         |    |\n     *         |    |\n     *   ______|____|\n     *         |\n     *         |\n     *         |________\n     *\n     */\n    overlapAmount[1] += Math.min(rectB.getY() - rectA.getY(), rectA.getBottom() - rectB.getBottom());\n  } else if (rectB.getY() <= rectA.getY() && rectB.getBottom() >= rectA.getBottom()) {\n    /* Case y.2:\n    *          ________ rectB\n    *         |\n    *         |\n    *   ______|____  rectA\n    *         |    |\n    *         |    |\n    *   ______|____|\n    *         |\n    *         |\n    *         |________\n    *\n    */\n    overlapAmount[1] += Math.min(rectA.getY() - rectB.getY(), rectB.getBottom() - rectA.getBottom());\n  }\n\n  // find slope of the line passes two centers\n  var slope = Math.abs((rectB.getCenterY() - rectA.getCenterY()) / (rectB.getCenterX() - rectA.getCenterX()));\n  // if centers are overlapped\n  if (rectB.getCenterY() === rectA.getCenterY() && rectB.getCenterX() === rectA.getCenterX()) {\n    // assume the slope is 1 (45 degree)\n    slope = 1.0;\n  }\n\n  var moveByY = slope * overlapAmount[0];\n  var moveByX = overlapAmount[1] / slope;\n  if (overlapAmount[0] < moveByX) {\n    moveByX = overlapAmount[0];\n  } else {\n    moveByY = overlapAmount[1];\n  }\n  // return half the amount so that if each rectangle is moved by these\n  // amounts in opposite directions, overlap will be resolved\n  overlapAmount[0] = -1 * directions[0] * (moveByX / 2 + separationBuffer);\n  overlapAmount[1] = -1 * directions[1] * (moveByY / 2 + separationBuffer);\n};\n\n/**\n * This method decides the separation direction of overlapping nodes\n *\n * if directions[0] = -1, then rectA goes left\n * if directions[0] = 1,  then rectA goes right\n * if directions[1] = -1, then rectA goes up\n * if directions[1] = 1,  then rectA goes down\n */\nIGeometry.decideDirectionsForOverlappingNodes = function (rectA, rectB, directions) {\n  if (rectA.getCenterX() < rectB.getCenterX()) {\n    directions[0] = -1;\n  } else {\n    directions[0] = 1;\n  }\n\n  if (rectA.getCenterY() < rectB.getCenterY()) {\n    directions[1] = -1;\n  } else {\n    directions[1] = 1;\n  }\n};\n\n/**\n * This method calculates the intersection (clipping) points of the two\n * input rectangles with line segment defined by the centers of these two\n * rectangles. The clipping points are saved in the input double array and\n * whether or not the two rectangles overlap is returned.\n */\nIGeometry.getIntersection2 = function (rectA, rectB, result) {\n  //result[0-1] will contain clipPoint of rectA, result[2-3] will contain clipPoint of rectB\n  var p1x = rectA.getCenterX();\n  var p1y = rectA.getCenterY();\n  var p2x = rectB.getCenterX();\n  var p2y = rectB.getCenterY();\n\n  //if two rectangles intersect, then clipping points are centers\n  if (rectA.intersects(rectB)) {\n    result[0] = p1x;\n    result[1] = p1y;\n    result[2] = p2x;\n    result[3] = p2y;\n    return true;\n  }\n  //variables for rectA\n  var topLeftAx = rectA.getX();\n  var topLeftAy = rectA.getY();\n  var topRightAx = rectA.getRight();\n  var bottomLeftAx = rectA.getX();\n  var bottomLeftAy = rectA.getBottom();\n  var bottomRightAx = rectA.getRight();\n  var halfWidthA = rectA.getWidthHalf();\n  var halfHeightA = rectA.getHeightHalf();\n  //variables for rectB\n  var topLeftBx = rectB.getX();\n  var topLeftBy = rectB.getY();\n  var topRightBx = rectB.getRight();\n  var bottomLeftBx = rectB.getX();\n  var bottomLeftBy = rectB.getBottom();\n  var bottomRightBx = rectB.getRight();\n  var halfWidthB = rectB.getWidthHalf();\n  var halfHeightB = rectB.getHeightHalf();\n\n  //flag whether clipping points are found\n  var clipPointAFound = false;\n  var clipPointBFound = false;\n\n  // line is vertical\n  if (p1x === p2x) {\n    if (p1y > p2y) {\n      result[0] = p1x;\n      result[1] = topLeftAy;\n      result[2] = p2x;\n      result[3] = bottomLeftBy;\n      return false;\n    } else if (p1y < p2y) {\n      result[0] = p1x;\n      result[1] = bottomLeftAy;\n      result[2] = p2x;\n      result[3] = topLeftBy;\n      return false;\n    } else {\n      //not line, return null;\n    }\n  }\n  // line is horizontal\n  else if (p1y === p2y) {\n      if (p1x > p2x) {\n        result[0] = topLeftAx;\n        result[1] = p1y;\n        result[2] = topRightBx;\n        result[3] = p2y;\n        return false;\n      } else if (p1x < p2x) {\n        result[0] = topRightAx;\n        result[1] = p1y;\n        result[2] = topLeftBx;\n        result[3] = p2y;\n        return false;\n      } else {\n        //not valid line, return null;\n      }\n    } else {\n      //slopes of rectA's and rectB's diagonals\n      var slopeA = rectA.height / rectA.width;\n      var slopeB = rectB.height / rectB.width;\n\n      //slope of line between center of rectA and center of rectB\n      var slopePrime = (p2y - p1y) / (p2x - p1x);\n      var cardinalDirectionA = void 0;\n      var cardinalDirectionB = void 0;\n      var tempPointAx = void 0;\n      var tempPointAy = void 0;\n      var tempPointBx = void 0;\n      var tempPointBy = void 0;\n\n      //determine whether clipping point is the corner of nodeA\n      if (-slopeA === slopePrime) {\n        if (p1x > p2x) {\n          result[0] = bottomLeftAx;\n          result[1] = bottomLeftAy;\n          clipPointAFound = true;\n        } else {\n          result[0] = topRightAx;\n          result[1] = topLeftAy;\n          clipPointAFound = true;\n        }\n      } else if (slopeA === slopePrime) {\n        if (p1x > p2x) {\n          result[0] = topLeftAx;\n          result[1] = topLeftAy;\n          clipPointAFound = true;\n        } else {\n          result[0] = bottomRightAx;\n          result[1] = bottomLeftAy;\n          clipPointAFound = true;\n        }\n      }\n\n      //determine whether clipping point is the corner of nodeB\n      if (-slopeB === slopePrime) {\n        if (p2x > p1x) {\n          result[2] = bottomLeftBx;\n          result[3] = bottomLeftBy;\n          clipPointBFound = true;\n        } else {\n          result[2] = topRightBx;\n          result[3] = topLeftBy;\n          clipPointBFound = true;\n        }\n      } else if (slopeB === slopePrime) {\n        if (p2x > p1x) {\n          result[2] = topLeftBx;\n          result[3] = topLeftBy;\n          clipPointBFound = true;\n        } else {\n          result[2] = bottomRightBx;\n          result[3] = bottomLeftBy;\n          clipPointBFound = true;\n        }\n      }\n\n      //if both clipping points are corners\n      if (clipPointAFound && clipPointBFound) {\n        return false;\n      }\n\n      //determine Cardinal Direction of rectangles\n      if (p1x > p2x) {\n        if (p1y > p2y) {\n          cardinalDirectionA = this.getCardinalDirection(slopeA, slopePrime, 4);\n          cardinalDirectionB = this.getCardinalDirection(slopeB, slopePrime, 2);\n        } else {\n          cardinalDirectionA = this.getCardinalDirection(-slopeA, slopePrime, 3);\n          cardinalDirectionB = this.getCardinalDirection(-slopeB, slopePrime, 1);\n        }\n      } else {\n        if (p1y > p2y) {\n          cardinalDirectionA = this.getCardinalDirection(-slopeA, slopePrime, 1);\n          cardinalDirectionB = this.getCardinalDirection(-slopeB, slopePrime, 3);\n        } else {\n          cardinalDirectionA = this.getCardinalDirection(slopeA, slopePrime, 2);\n          cardinalDirectionB = this.getCardinalDirection(slopeB, slopePrime, 4);\n        }\n      }\n      //calculate clipping Point if it is not found before\n      if (!clipPointAFound) {\n        switch (cardinalDirectionA) {\n          case 1:\n            tempPointAy = topLeftAy;\n            tempPointAx = p1x + -halfHeightA / slopePrime;\n            result[0] = tempPointAx;\n            result[1] = tempPointAy;\n            break;\n          case 2:\n            tempPointAx = bottomRightAx;\n            tempPointAy = p1y + halfWidthA * slopePrime;\n            result[0] = tempPointAx;\n            result[1] = tempPointAy;\n            break;\n          case 3:\n            tempPointAy = bottomLeftAy;\n            tempPointAx = p1x + halfHeightA / slopePrime;\n            result[0] = tempPointAx;\n            result[1] = tempPointAy;\n            break;\n          case 4:\n            tempPointAx = bottomLeftAx;\n            tempPointAy = p1y + -halfWidthA * slopePrime;\n            result[0] = tempPointAx;\n            result[1] = tempPointAy;\n            break;\n        }\n      }\n      if (!clipPointBFound) {\n        switch (cardinalDirectionB) {\n          case 1:\n            tempPointBy = topLeftBy;\n            tempPointBx = p2x + -halfHeightB / slopePrime;\n            result[2] = tempPointBx;\n            result[3] = tempPointBy;\n            break;\n          case 2:\n            tempPointBx = bottomRightBx;\n            tempPointBy = p2y + halfWidthB * slopePrime;\n            result[2] = tempPointBx;\n            result[3] = tempPointBy;\n            break;\n          case 3:\n            tempPointBy = bottomLeftBy;\n            tempPointBx = p2x + halfHeightB / slopePrime;\n            result[2] = tempPointBx;\n            result[3] = tempPointBy;\n            break;\n          case 4:\n            tempPointBx = bottomLeftBx;\n            tempPointBy = p2y + -halfWidthB * slopePrime;\n            result[2] = tempPointBx;\n            result[3] = tempPointBy;\n            break;\n        }\n      }\n    }\n  return false;\n};\n\n/**\n * This method returns in which cardinal direction does input point stays\n * 1: North\n * 2: East\n * 3: South\n * 4: West\n */\nIGeometry.getCardinalDirection = function (slope, slopePrime, line) {\n  if (slope > slopePrime) {\n    return line;\n  } else {\n    return 1 + line % 4;\n  }\n};\n\n/**\n * This method calculates the intersection of the two lines defined by\n * point pairs (s1,s2) and (f1,f2).\n */\nIGeometry.getIntersection = function (s1, s2, f1, f2) {\n  if (f2 == null) {\n    return this.getIntersection2(s1, s2, f1);\n  }\n\n  var x1 = s1.x;\n  var y1 = s1.y;\n  var x2 = s2.x;\n  var y2 = s2.y;\n  var x3 = f1.x;\n  var y3 = f1.y;\n  var x4 = f2.x;\n  var y4 = f2.y;\n  var x = void 0,\n      y = void 0; // intersection point\n  var a1 = void 0,\n      a2 = void 0,\n      b1 = void 0,\n      b2 = void 0,\n      c1 = void 0,\n      c2 = void 0; // coefficients of line eqns.\n  var denom = void 0;\n\n  a1 = y2 - y1;\n  b1 = x1 - x2;\n  c1 = x2 * y1 - x1 * y2; // { a1*x + b1*y + c1 = 0 is line 1 }\n\n  a2 = y4 - y3;\n  b2 = x3 - x4;\n  c2 = x4 * y3 - x3 * y4; // { a2*x + b2*y + c2 = 0 is line 2 }\n\n  denom = a1 * b2 - a2 * b1;\n\n  if (denom === 0) {\n    return null;\n  }\n\n  x = (b1 * c2 - b2 * c1) / denom;\n  y = (a2 * c1 - a1 * c2) / denom;\n\n  return new Point(x, y);\n};\n\n/**\n * This method finds and returns the angle of the vector from the + x-axis\n * in clockwise direction (compatible w/ Java coordinate system!).\n */\nIGeometry.angleOfVector = function (Cx, Cy, Nx, Ny) {\n  var C_angle = void 0;\n\n  if (Cx !== Nx) {\n    C_angle = Math.atan((Ny - Cy) / (Nx - Cx));\n\n    if (Nx < Cx) {\n      C_angle += Math.PI;\n    } else if (Ny < Cy) {\n      C_angle += this.TWO_PI;\n    }\n  } else if (Ny < Cy) {\n    C_angle = this.ONE_AND_HALF_PI; // 270 degrees\n  } else {\n    C_angle = this.HALF_PI; // 90 degrees\n  }\n\n  return C_angle;\n};\n\n/**\n * This method checks whether the given two line segments (one with point\n * p1 and p2, the other with point p3 and p4) intersect at a point other\n * than these points.\n */\nIGeometry.doIntersect = function (p1, p2, p3, p4) {\n  var a = p1.x;\n  var b = p1.y;\n  var c = p2.x;\n  var d = p2.y;\n  var p = p3.x;\n  var q = p3.y;\n  var r = p4.x;\n  var s = p4.y;\n  var det = (c - a) * (s - q) - (r - p) * (d - b);\n\n  if (det === 0) {\n    return false;\n  } else {\n    var lambda = ((s - q) * (r - a) + (p - r) * (s - b)) / det;\n    var gamma = ((b - d) * (r - a) + (c - a) * (s - b)) / det;\n    return 0 < lambda && lambda < 1 && 0 < gamma && gamma < 1;\n  }\n};\n\n// -----------------------------------------------------------------------------\n// Section: Class Constants\n// -----------------------------------------------------------------------------\n/**\n * Some useful pre-calculated constants\n */\nIGeometry.HALF_PI = 0.5 * Math.PI;\nIGeometry.ONE_AND_HALF_PI = 1.5 * Math.PI;\nIGeometry.TWO_PI = 2.0 * Math.PI;\nIGeometry.THREE_PI = 3.0 * Math.PI;\n\nmodule.exports = IGeometry;\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction IMath() {}\n\n/**\n * This method returns the sign of the input value.\n */\nIMath.sign = function (value) {\n  if (value > 0) {\n    return 1;\n  } else if (value < 0) {\n    return -1;\n  } else {\n    return 0;\n  }\n};\n\nIMath.floor = function (value) {\n  return value < 0 ? Math.ceil(value) : Math.floor(value);\n};\n\nIMath.ceil = function (value) {\n  return value < 0 ? Math.floor(value) : Math.ceil(value);\n};\n\nmodule.exports = IMath;\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction Integer() {}\n\nInteger.MAX_VALUE = 2147483647;\nInteger.MIN_VALUE = -2147483648;\n\nmodule.exports = Integer;\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar nodeFrom = function nodeFrom(value) {\n  return { value: value, next: null, prev: null };\n};\n\nvar add = function add(prev, node, next, list) {\n  if (prev !== null) {\n    prev.next = node;\n  } else {\n    list.head = node;\n  }\n\n  if (next !== null) {\n    next.prev = node;\n  } else {\n    list.tail = node;\n  }\n\n  node.prev = prev;\n  node.next = next;\n\n  list.length++;\n\n  return node;\n};\n\nvar _remove = function _remove(node, list) {\n  var prev = node.prev,\n      next = node.next;\n\n\n  if (prev !== null) {\n    prev.next = next;\n  } else {\n    list.head = next;\n  }\n\n  if (next !== null) {\n    next.prev = prev;\n  } else {\n    list.tail = prev;\n  }\n\n  node.prev = node.next = null;\n\n  list.length--;\n\n  return node;\n};\n\nvar LinkedList = function () {\n  function LinkedList(vals) {\n    var _this = this;\n\n    _classCallCheck(this, LinkedList);\n\n    this.length = 0;\n    this.head = null;\n    this.tail = null;\n\n    if (vals != null) {\n      vals.forEach(function (v) {\n        return _this.push(v);\n      });\n    }\n  }\n\n  _createClass(LinkedList, [{\n    key: \"size\",\n    value: function size() {\n      return this.length;\n    }\n  }, {\n    key: \"insertBefore\",\n    value: function insertBefore(val, otherNode) {\n      return add(otherNode.prev, nodeFrom(val), otherNode, this);\n    }\n  }, {\n    key: \"insertAfter\",\n    value: function insertAfter(val, otherNode) {\n      return add(otherNode, nodeFrom(val), otherNode.next, this);\n    }\n  }, {\n    key: \"insertNodeBefore\",\n    value: function insertNodeBefore(newNode, otherNode) {\n      return add(otherNode.prev, newNode, otherNode, this);\n    }\n  }, {\n    key: \"insertNodeAfter\",\n    value: function insertNodeAfter(newNode, otherNode) {\n      return add(otherNode, newNode, otherNode.next, this);\n    }\n  }, {\n    key: \"push\",\n    value: function push(val) {\n      return add(this.tail, nodeFrom(val), null, this);\n    }\n  }, {\n    key: \"unshift\",\n    value: function unshift(val) {\n      return add(null, nodeFrom(val), this.head, this);\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(node) {\n      return _remove(node, this);\n    }\n  }, {\n    key: \"pop\",\n    value: function pop() {\n      return _remove(this.tail, this).value;\n    }\n  }, {\n    key: \"popNode\",\n    value: function popNode() {\n      return _remove(this.tail, this);\n    }\n  }, {\n    key: \"shift\",\n    value: function shift() {\n      return _remove(this.head, this).value;\n    }\n  }, {\n    key: \"shiftNode\",\n    value: function shiftNode() {\n      return _remove(this.head, this);\n    }\n  }, {\n    key: \"get_object_at\",\n    value: function get_object_at(index) {\n      if (index <= this.length()) {\n        var i = 1;\n        var current = this.head;\n        while (i < index) {\n          current = current.next;\n          i++;\n        }\n        return current.value;\n      }\n    }\n  }, {\n    key: \"set_object_at\",\n    value: function set_object_at(index, value) {\n      if (index <= this.length()) {\n        var i = 1;\n        var current = this.head;\n        while (i < index) {\n          current = current.next;\n          i++;\n        }\n        current.value = value;\n      }\n    }\n  }]);\n\n  return LinkedList;\n}();\n\nmodule.exports = LinkedList;\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/*\r\n *This class is the javascript implementation of the Point.java class in jdk\r\n */\nfunction Point(x, y, p) {\n  this.x = null;\n  this.y = null;\n  if (x == null && y == null && p == null) {\n    this.x = 0;\n    this.y = 0;\n  } else if (typeof x == 'number' && typeof y == 'number' && p == null) {\n    this.x = x;\n    this.y = y;\n  } else if (x.constructor.name == 'Point' && y == null && p == null) {\n    p = x;\n    this.x = p.x;\n    this.y = p.y;\n  }\n}\n\nPoint.prototype.getX = function () {\n  return this.x;\n};\n\nPoint.prototype.getY = function () {\n  return this.y;\n};\n\nPoint.prototype.getLocation = function () {\n  return new Point(this.x, this.y);\n};\n\nPoint.prototype.setLocation = function (x, y, p) {\n  if (x.constructor.name == 'Point' && y == null && p == null) {\n    p = x;\n    this.setLocation(p.x, p.y);\n  } else if (typeof x == 'number' && typeof y == 'number' && p == null) {\n    //if both parameters are integer just move (x,y) location\n    if (parseInt(x) == x && parseInt(y) == y) {\n      this.move(x, y);\n    } else {\n      this.x = Math.floor(x + 0.5);\n      this.y = Math.floor(y + 0.5);\n    }\n  }\n};\n\nPoint.prototype.move = function (x, y) {\n  this.x = x;\n  this.y = y;\n};\n\nPoint.prototype.translate = function (dx, dy) {\n  this.x += dx;\n  this.y += dy;\n};\n\nPoint.prototype.equals = function (obj) {\n  if (obj.constructor.name == \"Point\") {\n    var pt = obj;\n    return this.x == pt.x && this.y == pt.y;\n  }\n  return this == obj;\n};\n\nPoint.prototype.toString = function () {\n  return new Point().constructor.name + \"[x=\" + this.x + \",y=\" + this.y + \"]\";\n};\n\nmodule.exports = Point;\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction RectangleD(x, y, width, height) {\n  this.x = 0;\n  this.y = 0;\n  this.width = 0;\n  this.height = 0;\n\n  if (x != null && y != null && width != null && height != null) {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n  }\n}\n\nRectangleD.prototype.getX = function () {\n  return this.x;\n};\n\nRectangleD.prototype.setX = function (x) {\n  this.x = x;\n};\n\nRectangleD.prototype.getY = function () {\n  return this.y;\n};\n\nRectangleD.prototype.setY = function (y) {\n  this.y = y;\n};\n\nRectangleD.prototype.getWidth = function () {\n  return this.width;\n};\n\nRectangleD.prototype.setWidth = function (width) {\n  this.width = width;\n};\n\nRectangleD.prototype.getHeight = function () {\n  return this.height;\n};\n\nRectangleD.prototype.setHeight = function (height) {\n  this.height = height;\n};\n\nRectangleD.prototype.getRight = function () {\n  return this.x + this.width;\n};\n\nRectangleD.prototype.getBottom = function () {\n  return this.y + this.height;\n};\n\nRectangleD.prototype.intersects = function (a) {\n  if (this.getRight() < a.x) {\n    return false;\n  }\n\n  if (this.getBottom() < a.y) {\n    return false;\n  }\n\n  if (a.getRight() < this.x) {\n    return false;\n  }\n\n  if (a.getBottom() < this.y) {\n    return false;\n  }\n\n  return true;\n};\n\nRectangleD.prototype.getCenterX = function () {\n  return this.x + this.width / 2;\n};\n\nRectangleD.prototype.getMinX = function () {\n  return this.getX();\n};\n\nRectangleD.prototype.getMaxX = function () {\n  return this.getX() + this.width;\n};\n\nRectangleD.prototype.getCenterY = function () {\n  return this.y + this.height / 2;\n};\n\nRectangleD.prototype.getMinY = function () {\n  return this.getY();\n};\n\nRectangleD.prototype.getMaxY = function () {\n  return this.getY() + this.height;\n};\n\nRectangleD.prototype.getWidthHalf = function () {\n  return this.width / 2;\n};\n\nRectangleD.prototype.getHeightHalf = function () {\n  return this.height / 2;\n};\n\nmodule.exports = RectangleD;\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction UniqueIDGeneretor() {}\n\nUniqueIDGeneretor.lastID = 0;\n\nUniqueIDGeneretor.createID = function (obj) {\n  if (UniqueIDGeneretor.isPrimitive(obj)) {\n    return obj;\n  }\n  if (obj.uniqueID != null) {\n    return obj.uniqueID;\n  }\n  obj.uniqueID = UniqueIDGeneretor.getString();\n  UniqueIDGeneretor.lastID++;\n  return obj.uniqueID;\n};\n\nUniqueIDGeneretor.getString = function (id) {\n  if (id == null) id = UniqueIDGeneretor.lastID;\n  return \"Object#\" + id + \"\";\n};\n\nUniqueIDGeneretor.isPrimitive = function (arg) {\n  var type = typeof arg === \"undefined\" ? \"undefined\" : _typeof(arg);\n  return arg == null || type != \"object\" && type != \"function\";\n};\n\nmodule.exports = UniqueIDGeneretor;\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __nested_webpack_require_64072__) {\n\n\"use strict\";\n\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar LayoutConstants = __nested_webpack_require_64072__(0);\nvar LGraphManager = __nested_webpack_require_64072__(6);\nvar LNode = __nested_webpack_require_64072__(3);\nvar LEdge = __nested_webpack_require_64072__(1);\nvar LGraph = __nested_webpack_require_64072__(5);\nvar PointD = __nested_webpack_require_64072__(4);\nvar Transform = __nested_webpack_require_64072__(17);\nvar Emitter = __nested_webpack_require_64072__(27);\n\nfunction Layout(isRemoteUse) {\n  Emitter.call(this);\n\n  //Layout Quality: 0:draft, 1:default, 2:proof\n  this.layoutQuality = LayoutConstants.QUALITY;\n  //Whether layout should create bendpoints as needed or not\n  this.createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\n  //Whether layout should be incremental or not\n  this.incremental = LayoutConstants.DEFAULT_INCREMENTAL;\n  //Whether we animate from before to after layout node positions\n  this.animationOnLayout = LayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT;\n  //Whether we animate the layout process or not\n  this.animationDuringLayout = LayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT;\n  //Number iterations that should be done between two successive animations\n  this.animationPeriod = LayoutConstants.DEFAULT_ANIMATION_PERIOD;\n  /**\r\n   * Whether or not leaf nodes (non-compound nodes) are of uniform sizes. When\r\n   * they are, both spring and repulsion forces between two leaf nodes can be\r\n   * calculated without the expensive clipping point calculations, resulting\r\n   * in major speed-up.\r\n   */\n  this.uniformLeafNodeSizes = LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES;\n  /**\r\n   * This is used for creation of bendpoints by using dummy nodes and edges.\r\n   * Maps an LEdge to its dummy bendpoint path.\r\n   */\n  this.edgeToDummyNodes = new Map();\n  this.graphManager = new LGraphManager(this);\n  this.isLayoutFinished = false;\n  this.isSubLayout = false;\n  this.isRemoteUse = false;\n\n  if (isRemoteUse != null) {\n    this.isRemoteUse = isRemoteUse;\n  }\n}\n\nLayout.RANDOM_SEED = 1;\n\nLayout.prototype = Object.create(Emitter.prototype);\n\nLayout.prototype.getGraphManager = function () {\n  return this.graphManager;\n};\n\nLayout.prototype.getAllNodes = function () {\n  return this.graphManager.getAllNodes();\n};\n\nLayout.prototype.getAllEdges = function () {\n  return this.graphManager.getAllEdges();\n};\n\nLayout.prototype.getAllNodesToApplyGravitation = function () {\n  return this.graphManager.getAllNodesToApplyGravitation();\n};\n\nLayout.prototype.newGraphManager = function () {\n  var gm = new LGraphManager(this);\n  this.graphManager = gm;\n  return gm;\n};\n\nLayout.prototype.newGraph = function (vGraph) {\n  return new LGraph(null, this.graphManager, vGraph);\n};\n\nLayout.prototype.newNode = function (vNode) {\n  return new LNode(this.graphManager, vNode);\n};\n\nLayout.prototype.newEdge = function (vEdge) {\n  return new LEdge(null, null, vEdge);\n};\n\nLayout.prototype.checkLayoutSuccess = function () {\n  return this.graphManager.getRoot() == null || this.graphManager.getRoot().getNodes().length == 0 || this.graphManager.includesInvalidEdge();\n};\n\nLayout.prototype.runLayout = function () {\n  this.isLayoutFinished = false;\n\n  if (this.tilingPreLayout) {\n    this.tilingPreLayout();\n  }\n\n  this.initParameters();\n  var isLayoutSuccessfull;\n\n  if (this.checkLayoutSuccess()) {\n    isLayoutSuccessfull = false;\n  } else {\n    isLayoutSuccessfull = this.layout();\n  }\n\n  if (LayoutConstants.ANIMATE === 'during') {\n    // If this is a 'during' layout animation. Layout is not finished yet. \n    // We need to perform these in index.js when layout is really finished.\n    return false;\n  }\n\n  if (isLayoutSuccessfull) {\n    if (!this.isSubLayout) {\n      this.doPostLayout();\n    }\n  }\n\n  if (this.tilingPostLayout) {\n    this.tilingPostLayout();\n  }\n\n  this.isLayoutFinished = true;\n\n  return isLayoutSuccessfull;\n};\n\n/**\r\n * This method performs the operations required after layout.\r\n */\nLayout.prototype.doPostLayout = function () {\n  //assert !isSubLayout : \"Should not be called on sub-layout!\";\n  // Propagate geometric changes to v-level objects\n  if (!this.incremental) {\n    this.transform();\n  }\n  this.update();\n};\n\n/**\r\n * This method updates the geometry of the target graph according to\r\n * calculated layout.\r\n */\nLayout.prototype.update2 = function () {\n  // update bend points\n  if (this.createBendsAsNeeded) {\n    this.createBendpointsFromDummyNodes();\n\n    // reset all edges, since the topology has changed\n    this.graphManager.resetAllEdges();\n  }\n\n  // perform edge, node and root updates if layout is not called\n  // remotely\n  if (!this.isRemoteUse) {\n    // update all edges\n    var edge;\n    var allEdges = this.graphManager.getAllEdges();\n    for (var i = 0; i < allEdges.length; i++) {\n      edge = allEdges[i];\n      //      this.update(edge);\n    }\n\n    // recursively update nodes\n    var node;\n    var nodes = this.graphManager.getRoot().getNodes();\n    for (var i = 0; i < nodes.length; i++) {\n      node = nodes[i];\n      //      this.update(node);\n    }\n\n    // update root graph\n    this.update(this.graphManager.getRoot());\n  }\n};\n\nLayout.prototype.update = function (obj) {\n  if (obj == null) {\n    this.update2();\n  } else if (obj instanceof LNode) {\n    var node = obj;\n    if (node.getChild() != null) {\n      // since node is compound, recursively update child nodes\n      var nodes = node.getChild().getNodes();\n      for (var i = 0; i < nodes.length; i++) {\n        update(nodes[i]);\n      }\n    }\n\n    // if the l-level node is associated with a v-level graph object,\n    // then it is assumed that the v-level node implements the\n    // interface Updatable.\n    if (node.vGraphObject != null) {\n      // cast to Updatable without any type check\n      var vNode = node.vGraphObject;\n\n      // call the update method of the interface\n      vNode.update(node);\n    }\n  } else if (obj instanceof LEdge) {\n    var edge = obj;\n    // if the l-level edge is associated with a v-level graph object,\n    // then it is assumed that the v-level edge implements the\n    // interface Updatable.\n\n    if (edge.vGraphObject != null) {\n      // cast to Updatable without any type check\n      var vEdge = edge.vGraphObject;\n\n      // call the update method of the interface\n      vEdge.update(edge);\n    }\n  } else if (obj instanceof LGraph) {\n    var graph = obj;\n    // if the l-level graph is associated with a v-level graph object,\n    // then it is assumed that the v-level object implements the\n    // interface Updatable.\n\n    if (graph.vGraphObject != null) {\n      // cast to Updatable without any type check\n      var vGraph = graph.vGraphObject;\n\n      // call the update method of the interface\n      vGraph.update(graph);\n    }\n  }\n};\n\n/**\r\n * This method is used to set all layout parameters to default values\r\n * determined at compile time.\r\n */\nLayout.prototype.initParameters = function () {\n  if (!this.isSubLayout) {\n    this.layoutQuality = LayoutConstants.QUALITY;\n    this.animationDuringLayout = LayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT;\n    this.animationPeriod = LayoutConstants.DEFAULT_ANIMATION_PERIOD;\n    this.animationOnLayout = LayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT;\n    this.incremental = LayoutConstants.DEFAULT_INCREMENTAL;\n    this.createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\n    this.uniformLeafNodeSizes = LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES;\n  }\n\n  if (this.animationDuringLayout) {\n    this.animationOnLayout = false;\n  }\n};\n\nLayout.prototype.transform = function (newLeftTop) {\n  if (newLeftTop == undefined) {\n    this.transform(new PointD(0, 0));\n  } else {\n    // create a transformation object (from Eclipse to layout). When an\n    // inverse transform is applied, we get upper-left coordinate of the\n    // drawing or the root graph at given input coordinate (some margins\n    // already included in calculation of left-top).\n\n    var trans = new Transform();\n    var leftTop = this.graphManager.getRoot().updateLeftTop();\n\n    if (leftTop != null) {\n      trans.setWorldOrgX(newLeftTop.x);\n      trans.setWorldOrgY(newLeftTop.y);\n\n      trans.setDeviceOrgX(leftTop.x);\n      trans.setDeviceOrgY(leftTop.y);\n\n      var nodes = this.getAllNodes();\n      var node;\n\n      for (var i = 0; i < nodes.length; i++) {\n        node = nodes[i];\n        node.transform(trans);\n      }\n    }\n  }\n};\n\nLayout.prototype.positionNodesRandomly = function (graph) {\n\n  if (graph == undefined) {\n    //assert !this.incremental;\n    this.positionNodesRandomly(this.getGraphManager().getRoot());\n    this.getGraphManager().getRoot().updateBounds(true);\n  } else {\n    var lNode;\n    var childGraph;\n\n    var nodes = graph.getNodes();\n    for (var i = 0; i < nodes.length; i++) {\n      lNode = nodes[i];\n      childGraph = lNode.getChild();\n\n      if (childGraph == null) {\n        lNode.scatter();\n      } else if (childGraph.getNodes().length == 0) {\n        lNode.scatter();\n      } else {\n        this.positionNodesRandomly(childGraph);\n        lNode.updateBounds();\n      }\n    }\n  }\n};\n\n/**\r\n * This method returns a list of trees where each tree is represented as a\r\n * list of l-nodes. The method returns a list of size 0 when:\r\n * - The graph is not flat or\r\n * - One of the component(s) of the graph is not a tree.\r\n */\nLayout.prototype.getFlatForest = function () {\n  var flatForest = [];\n  var isForest = true;\n\n  // Quick reference for all nodes in the graph manager associated with\n  // this layout. The list should not be changed.\n  var allNodes = this.graphManager.getRoot().getNodes();\n\n  // First be sure that the graph is flat\n  var isFlat = true;\n\n  for (var i = 0; i < allNodes.length; i++) {\n    if (allNodes[i].getChild() != null) {\n      isFlat = false;\n    }\n  }\n\n  // Return empty forest if the graph is not flat.\n  if (!isFlat) {\n    return flatForest;\n  }\n\n  // Run BFS for each component of the graph.\n\n  var visited = new Set();\n  var toBeVisited = [];\n  var parents = new Map();\n  var unProcessedNodes = [];\n\n  unProcessedNodes = unProcessedNodes.concat(allNodes);\n\n  // Each iteration of this loop finds a component of the graph and\n  // decides whether it is a tree or not. If it is a tree, adds it to the\n  // forest and continued with the next component.\n\n  while (unProcessedNodes.length > 0 && isForest) {\n    toBeVisited.push(unProcessedNodes[0]);\n\n    // Start the BFS. Each iteration of this loop visits a node in a\n    // BFS manner.\n    while (toBeVisited.length > 0 && isForest) {\n      //pool operation\n      var currentNode = toBeVisited[0];\n      toBeVisited.splice(0, 1);\n      visited.add(currentNode);\n\n      // Traverse all neighbors of this node\n      var neighborEdges = currentNode.getEdges();\n\n      for (var i = 0; i < neighborEdges.length; i++) {\n        var currentNeighbor = neighborEdges[i].getOtherEnd(currentNode);\n\n        // If BFS is not growing from this neighbor.\n        if (parents.get(currentNode) != currentNeighbor) {\n          // We haven't previously visited this neighbor.\n          if (!visited.has(currentNeighbor)) {\n            toBeVisited.push(currentNeighbor);\n            parents.set(currentNeighbor, currentNode);\n          }\n          // Since we have previously visited this neighbor and\n          // this neighbor is not parent of currentNode, given\n          // graph contains a component that is not tree, hence\n          // it is not a forest.\n          else {\n              isForest = false;\n              break;\n            }\n        }\n      }\n    }\n\n    // The graph contains a component that is not a tree. Empty\n    // previously found trees. The method will end.\n    if (!isForest) {\n      flatForest = [];\n    }\n    // Save currently visited nodes as a tree in our forest. Reset\n    // visited and parents lists. Continue with the next component of\n    // the graph, if any.\n    else {\n        var temp = [].concat(_toConsumableArray(visited));\n        flatForest.push(temp);\n        //flatForest = flatForest.concat(temp);\n        //unProcessedNodes.removeAll(visited);\n        for (var i = 0; i < temp.length; i++) {\n          var value = temp[i];\n          var index = unProcessedNodes.indexOf(value);\n          if (index > -1) {\n            unProcessedNodes.splice(index, 1);\n          }\n        }\n        visited = new Set();\n        parents = new Map();\n      }\n  }\n\n  return flatForest;\n};\n\n/**\r\n * This method creates dummy nodes (an l-level node with minimal dimensions)\r\n * for the given edge (one per bendpoint). The existing l-level structure\r\n * is updated accordingly.\r\n */\nLayout.prototype.createDummyNodesForBendpoints = function (edge) {\n  var dummyNodes = [];\n  var prev = edge.source;\n\n  var graph = this.graphManager.calcLowestCommonAncestor(edge.source, edge.target);\n\n  for (var i = 0; i < edge.bendpoints.length; i++) {\n    // create new dummy node\n    var dummyNode = this.newNode(null);\n    dummyNode.setRect(new Point(0, 0), new Dimension(1, 1));\n\n    graph.add(dummyNode);\n\n    // create new dummy edge between prev and dummy node\n    var dummyEdge = this.newEdge(null);\n    this.graphManager.add(dummyEdge, prev, dummyNode);\n\n    dummyNodes.add(dummyNode);\n    prev = dummyNode;\n  }\n\n  var dummyEdge = this.newEdge(null);\n  this.graphManager.add(dummyEdge, prev, edge.target);\n\n  this.edgeToDummyNodes.set(edge, dummyNodes);\n\n  // remove real edge from graph manager if it is inter-graph\n  if (edge.isInterGraph()) {\n    this.graphManager.remove(edge);\n  }\n  // else, remove the edge from the current graph\n  else {\n      graph.remove(edge);\n    }\n\n  return dummyNodes;\n};\n\n/**\r\n * This method creates bendpoints for edges from the dummy nodes\r\n * at l-level.\r\n */\nLayout.prototype.createBendpointsFromDummyNodes = function () {\n  var edges = [];\n  edges = edges.concat(this.graphManager.getAllEdges());\n  edges = [].concat(_toConsumableArray(this.edgeToDummyNodes.keys())).concat(edges);\n\n  for (var k = 0; k < edges.length; k++) {\n    var lEdge = edges[k];\n\n    if (lEdge.bendpoints.length > 0) {\n      var path = this.edgeToDummyNodes.get(lEdge);\n\n      for (var i = 0; i < path.length; i++) {\n        var dummyNode = path[i];\n        var p = new PointD(dummyNode.getCenterX(), dummyNode.getCenterY());\n\n        // update bendpoint's location according to dummy node\n        var ebp = lEdge.bendpoints.get(i);\n        ebp.x = p.x;\n        ebp.y = p.y;\n\n        // remove the dummy node, dummy edges incident with this\n        // dummy node is also removed (within the remove method)\n        dummyNode.getOwner().remove(dummyNode);\n      }\n\n      // add the real edge to graph\n      this.graphManager.add(lEdge, lEdge.source, lEdge.target);\n    }\n  }\n};\n\nLayout.transform = function (sliderValue, defaultValue, minDiv, maxMul) {\n  if (minDiv != undefined && maxMul != undefined) {\n    var value = defaultValue;\n\n    if (sliderValue <= 50) {\n      var minValue = defaultValue / minDiv;\n      value -= (defaultValue - minValue) / 50 * (50 - sliderValue);\n    } else {\n      var maxValue = defaultValue * maxMul;\n      value += (maxValue - defaultValue) / 50 * (sliderValue - 50);\n    }\n\n    return value;\n  } else {\n    var a, b;\n\n    if (sliderValue <= 50) {\n      a = 9.0 * defaultValue / 500.0;\n      b = defaultValue / 10.0;\n    } else {\n      a = 9.0 * defaultValue / 50.0;\n      b = -8 * defaultValue;\n    }\n\n    return a * sliderValue + b;\n  }\n};\n\n/**\r\n * This method finds and returns the center of the given nodes, assuming\r\n * that the given nodes form a tree in themselves.\r\n */\nLayout.findCenterOfTree = function (nodes) {\n  var list = [];\n  list = list.concat(nodes);\n\n  var removedNodes = [];\n  var remainingDegrees = new Map();\n  var foundCenter = false;\n  var centerNode = null;\n\n  if (list.length == 1 || list.length == 2) {\n    foundCenter = true;\n    centerNode = list[0];\n  }\n\n  for (var i = 0; i < list.length; i++) {\n    var node = list[i];\n    var degree = node.getNeighborsList().size;\n    remainingDegrees.set(node, node.getNeighborsList().size);\n\n    if (degree == 1) {\n      removedNodes.push(node);\n    }\n  }\n\n  var tempList = [];\n  tempList = tempList.concat(removedNodes);\n\n  while (!foundCenter) {\n    var tempList2 = [];\n    tempList2 = tempList2.concat(tempList);\n    tempList = [];\n\n    for (var i = 0; i < list.length; i++) {\n      var node = list[i];\n\n      var index = list.indexOf(node);\n      if (index >= 0) {\n        list.splice(index, 1);\n      }\n\n      var neighbours = node.getNeighborsList();\n\n      neighbours.forEach(function (neighbour) {\n        if (removedNodes.indexOf(neighbour) < 0) {\n          var otherDegree = remainingDegrees.get(neighbour);\n          var newDegree = otherDegree - 1;\n\n          if (newDegree == 1) {\n            tempList.push(neighbour);\n          }\n\n          remainingDegrees.set(neighbour, newDegree);\n        }\n      });\n    }\n\n    removedNodes = removedNodes.concat(tempList);\n\n    if (list.length == 1 || list.length == 2) {\n      foundCenter = true;\n      centerNode = list[0];\n    }\n  }\n\n  return centerNode;\n};\n\n/**\r\n * During the coarsening process, this layout may be referenced by two graph managers\r\n * this setter function grants access to change the currently being used graph manager\r\n */\nLayout.prototype.setGraphManager = function (gm) {\n  this.graphManager = gm;\n};\n\nmodule.exports = Layout;\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction RandomSeed() {}\n// adapted from: https://stackoverflow.com/a/19303725\nRandomSeed.seed = 1;\nRandomSeed.x = 0;\n\nRandomSeed.nextDouble = function () {\n  RandomSeed.x = Math.sin(RandomSeed.seed++) * 10000;\n  return RandomSeed.x - Math.floor(RandomSeed.x);\n};\n\nmodule.exports = RandomSeed;\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __nested_webpack_require_81860__) {\n\n\"use strict\";\n\n\nvar PointD = __nested_webpack_require_81860__(4);\n\nfunction Transform(x, y) {\n  this.lworldOrgX = 0.0;\n  this.lworldOrgY = 0.0;\n  this.ldeviceOrgX = 0.0;\n  this.ldeviceOrgY = 0.0;\n  this.lworldExtX = 1.0;\n  this.lworldExtY = 1.0;\n  this.ldeviceExtX = 1.0;\n  this.ldeviceExtY = 1.0;\n}\n\nTransform.prototype.getWorldOrgX = function () {\n  return this.lworldOrgX;\n};\n\nTransform.prototype.setWorldOrgX = function (wox) {\n  this.lworldOrgX = wox;\n};\n\nTransform.prototype.getWorldOrgY = function () {\n  return this.lworldOrgY;\n};\n\nTransform.prototype.setWorldOrgY = function (woy) {\n  this.lworldOrgY = woy;\n};\n\nTransform.prototype.getWorldExtX = function () {\n  return this.lworldExtX;\n};\n\nTransform.prototype.setWorldExtX = function (wex) {\n  this.lworldExtX = wex;\n};\n\nTransform.prototype.getWorldExtY = function () {\n  return this.lworldExtY;\n};\n\nTransform.prototype.setWorldExtY = function (wey) {\n  this.lworldExtY = wey;\n};\n\n/* Device related */\n\nTransform.prototype.getDeviceOrgX = function () {\n  return this.ldeviceOrgX;\n};\n\nTransform.prototype.setDeviceOrgX = function (dox) {\n  this.ldeviceOrgX = dox;\n};\n\nTransform.prototype.getDeviceOrgY = function () {\n  return this.ldeviceOrgY;\n};\n\nTransform.prototype.setDeviceOrgY = function (doy) {\n  this.ldeviceOrgY = doy;\n};\n\nTransform.prototype.getDeviceExtX = function () {\n  return this.ldeviceExtX;\n};\n\nTransform.prototype.setDeviceExtX = function (dex) {\n  this.ldeviceExtX = dex;\n};\n\nTransform.prototype.getDeviceExtY = function () {\n  return this.ldeviceExtY;\n};\n\nTransform.prototype.setDeviceExtY = function (dey) {\n  this.ldeviceExtY = dey;\n};\n\nTransform.prototype.transformX = function (x) {\n  var xDevice = 0.0;\n  var worldExtX = this.lworldExtX;\n  if (worldExtX != 0.0) {\n    xDevice = this.ldeviceOrgX + (x - this.lworldOrgX) * this.ldeviceExtX / worldExtX;\n  }\n\n  return xDevice;\n};\n\nTransform.prototype.transformY = function (y) {\n  var yDevice = 0.0;\n  var worldExtY = this.lworldExtY;\n  if (worldExtY != 0.0) {\n    yDevice = this.ldeviceOrgY + (y - this.lworldOrgY) * this.ldeviceExtY / worldExtY;\n  }\n\n  return yDevice;\n};\n\nTransform.prototype.inverseTransformX = function (x) {\n  var xWorld = 0.0;\n  var deviceExtX = this.ldeviceExtX;\n  if (deviceExtX != 0.0) {\n    xWorld = this.lworldOrgX + (x - this.ldeviceOrgX) * this.lworldExtX / deviceExtX;\n  }\n\n  return xWorld;\n};\n\nTransform.prototype.inverseTransformY = function (y) {\n  var yWorld = 0.0;\n  var deviceExtY = this.ldeviceExtY;\n  if (deviceExtY != 0.0) {\n    yWorld = this.lworldOrgY + (y - this.ldeviceOrgY) * this.lworldExtY / deviceExtY;\n  }\n  return yWorld;\n};\n\nTransform.prototype.inverseTransformPoint = function (inPoint) {\n  var outPoint = new PointD(this.inverseTransformX(inPoint.x), this.inverseTransformY(inPoint.y));\n  return outPoint;\n};\n\nmodule.exports = Transform;\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __nested_webpack_require_84747__) {\n\n\"use strict\";\n\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar Layout = __nested_webpack_require_84747__(15);\nvar FDLayoutConstants = __nested_webpack_require_84747__(7);\nvar LayoutConstants = __nested_webpack_require_84747__(0);\nvar IGeometry = __nested_webpack_require_84747__(8);\nvar IMath = __nested_webpack_require_84747__(9);\n\nfunction FDLayout() {\n  Layout.call(this);\n\n  this.useSmartIdealEdgeLengthCalculation = FDLayoutConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION;\n  this.idealEdgeLength = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\n  this.springConstant = FDLayoutConstants.DEFAULT_SPRING_STRENGTH;\n  this.repulsionConstant = FDLayoutConstants.DEFAULT_REPULSION_STRENGTH;\n  this.gravityConstant = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH;\n  this.compoundGravityConstant = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH;\n  this.gravityRangeFactor = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR;\n  this.compoundGravityRangeFactor = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR;\n  this.displacementThresholdPerNode = 3.0 * FDLayoutConstants.DEFAULT_EDGE_LENGTH / 100;\n  this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;\n  this.initialCoolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;\n  this.totalDisplacement = 0.0;\n  this.oldTotalDisplacement = 0.0;\n  this.maxIterations = FDLayoutConstants.MAX_ITERATIONS;\n}\n\nFDLayout.prototype = Object.create(Layout.prototype);\n\nfor (var prop in Layout) {\n  FDLayout[prop] = Layout[prop];\n}\n\nFDLayout.prototype.initParameters = function () {\n  Layout.prototype.initParameters.call(this, arguments);\n\n  this.totalIterations = 0;\n  this.notAnimatedIterations = 0;\n\n  this.useFRGridVariant = FDLayoutConstants.DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION;\n\n  this.grid = [];\n};\n\nFDLayout.prototype.calcIdealEdgeLengths = function () {\n  var edge;\n  var lcaDepth;\n  var source;\n  var target;\n  var sizeOfSourceInLca;\n  var sizeOfTargetInLca;\n\n  var allEdges = this.getGraphManager().getAllEdges();\n  for (var i = 0; i < allEdges.length; i++) {\n    edge = allEdges[i];\n\n    edge.idealLength = this.idealEdgeLength;\n\n    if (edge.isInterGraph) {\n      source = edge.getSource();\n      target = edge.getTarget();\n\n      sizeOfSourceInLca = edge.getSourceInLca().getEstimatedSize();\n      sizeOfTargetInLca = edge.getTargetInLca().getEstimatedSize();\n\n      if (this.useSmartIdealEdgeLengthCalculation) {\n        edge.idealLength += sizeOfSourceInLca + sizeOfTargetInLca - 2 * LayoutConstants.SIMPLE_NODE_SIZE;\n      }\n\n      lcaDepth = edge.getLca().getInclusionTreeDepth();\n\n      edge.idealLength += FDLayoutConstants.DEFAULT_EDGE_LENGTH * FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR * (source.getInclusionTreeDepth() + target.getInclusionTreeDepth() - 2 * lcaDepth);\n    }\n  }\n};\n\nFDLayout.prototype.initSpringEmbedder = function () {\n\n  var s = this.getAllNodes().length;\n  if (this.incremental) {\n    if (s > FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) {\n      this.coolingFactor = Math.max(this.coolingFactor * FDLayoutConstants.COOLING_ADAPTATION_FACTOR, this.coolingFactor - (s - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) / (FDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) * this.coolingFactor * (1 - FDLayoutConstants.COOLING_ADAPTATION_FACTOR));\n    }\n    this.maxNodeDisplacement = FDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL;\n  } else {\n    if (s > FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) {\n      this.coolingFactor = Math.max(FDLayoutConstants.COOLING_ADAPTATION_FACTOR, 1.0 - (s - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) / (FDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) * (1 - FDLayoutConstants.COOLING_ADAPTATION_FACTOR));\n    } else {\n      this.coolingFactor = 1.0;\n    }\n    this.initialCoolingFactor = this.coolingFactor;\n    this.maxNodeDisplacement = FDLayoutConstants.MAX_NODE_DISPLACEMENT;\n  }\n\n  this.maxIterations = Math.max(this.getAllNodes().length * 5, this.maxIterations);\n\n  this.totalDisplacementThreshold = this.displacementThresholdPerNode * this.getAllNodes().length;\n\n  this.repulsionRange = this.calcRepulsionRange();\n};\n\nFDLayout.prototype.calcSpringForces = function () {\n  var lEdges = this.getAllEdges();\n  var edge;\n\n  for (var i = 0; i < lEdges.length; i++) {\n    edge = lEdges[i];\n\n    this.calcSpringForce(edge, edge.idealLength);\n  }\n};\n\nFDLayout.prototype.calcRepulsionForces = function () {\n  var gridUpdateAllowed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n  var forceToNodeSurroundingUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  var i, j;\n  var nodeA, nodeB;\n  var lNodes = this.getAllNodes();\n  var processedNodeSet;\n\n  if (this.useFRGridVariant) {\n    if (this.totalIterations % FDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD == 1 && gridUpdateAllowed) {\n      this.updateGrid();\n    }\n\n    processedNodeSet = new Set();\n\n    // calculate repulsion forces between each nodes and its surrounding\n    for (i = 0; i < lNodes.length; i++) {\n      nodeA = lNodes[i];\n      this.calculateRepulsionForceOfANode(nodeA, processedNodeSet, gridUpdateAllowed, forceToNodeSurroundingUpdate);\n      processedNodeSet.add(nodeA);\n    }\n  } else {\n    for (i = 0; i < lNodes.length; i++) {\n      nodeA = lNodes[i];\n\n      for (j = i + 1; j < lNodes.length; j++) {\n        nodeB = lNodes[j];\n\n        // If both nodes are not members of the same graph, skip.\n        if (nodeA.getOwner() != nodeB.getOwner()) {\n          continue;\n        }\n\n        this.calcRepulsionForce(nodeA, nodeB);\n      }\n    }\n  }\n};\n\nFDLayout.prototype.calcGravitationalForces = function () {\n  var node;\n  var lNodes = this.getAllNodesToApplyGravitation();\n\n  for (var i = 0; i < lNodes.length; i++) {\n    node = lNodes[i];\n    this.calcGravitationalForce(node);\n  }\n};\n\nFDLayout.prototype.moveNodes = function () {\n  var lNodes = this.getAllNodes();\n  var node;\n\n  for (var i = 0; i < lNodes.length; i++) {\n    node = lNodes[i];\n    node.move();\n  }\n};\n\nFDLayout.prototype.calcSpringForce = function (edge, idealLength) {\n  var sourceNode = edge.getSource();\n  var targetNode = edge.getTarget();\n\n  var length;\n  var springForce;\n  var springForceX;\n  var springForceY;\n\n  // Update edge length\n  if (this.uniformLeafNodeSizes && sourceNode.getChild() == null && targetNode.getChild() == null) {\n    edge.updateLengthSimple();\n  } else {\n    edge.updateLength();\n\n    if (edge.isOverlapingSourceAndTarget) {\n      return;\n    }\n  }\n\n  length = edge.getLength();\n\n  if (length == 0) return;\n\n  // Calculate spring forces\n  springForce = this.springConstant * (length - idealLength);\n\n  // Project force onto x and y axes\n  springForceX = springForce * (edge.lengthX / length);\n  springForceY = springForce * (edge.lengthY / length);\n\n  // Apply forces on the end nodes\n  sourceNode.springForceX += springForceX;\n  sourceNode.springForceY += springForceY;\n  targetNode.springForceX -= springForceX;\n  targetNode.springForceY -= springForceY;\n};\n\nFDLayout.prototype.calcRepulsionForce = function (nodeA, nodeB) {\n  var rectA = nodeA.getRect();\n  var rectB = nodeB.getRect();\n  var overlapAmount = new Array(2);\n  var clipPoints = new Array(4);\n  var distanceX;\n  var distanceY;\n  var distanceSquared;\n  var distance;\n  var repulsionForce;\n  var repulsionForceX;\n  var repulsionForceY;\n\n  if (rectA.intersects(rectB)) // two nodes overlap\n    {\n      // calculate separation amount in x and y directions\n      IGeometry.calcSeparationAmount(rectA, rectB, overlapAmount, FDLayoutConstants.DEFAULT_EDGE_LENGTH / 2.0);\n\n      repulsionForceX = 2 * overlapAmount[0];\n      repulsionForceY = 2 * overlapAmount[1];\n\n      var childrenConstant = nodeA.noOfChildren * nodeB.noOfChildren / (nodeA.noOfChildren + nodeB.noOfChildren);\n\n      // Apply forces on the two nodes\n      nodeA.repulsionForceX -= childrenConstant * repulsionForceX;\n      nodeA.repulsionForceY -= childrenConstant * repulsionForceY;\n      nodeB.repulsionForceX += childrenConstant * repulsionForceX;\n      nodeB.repulsionForceY += childrenConstant * repulsionForceY;\n    } else // no overlap\n    {\n      // calculate distance\n\n      if (this.uniformLeafNodeSizes && nodeA.getChild() == null && nodeB.getChild() == null) // simply base repulsion on distance of node centers\n        {\n          distanceX = rectB.getCenterX() - rectA.getCenterX();\n          distanceY = rectB.getCenterY() - rectA.getCenterY();\n        } else // use clipping points\n        {\n          IGeometry.getIntersection(rectA, rectB, clipPoints);\n\n          distanceX = clipPoints[2] - clipPoints[0];\n          distanceY = clipPoints[3] - clipPoints[1];\n        }\n\n      // No repulsion range. FR grid variant should take care of this.\n      if (Math.abs(distanceX) < FDLayoutConstants.MIN_REPULSION_DIST) {\n        distanceX = IMath.sign(distanceX) * FDLayoutConstants.MIN_REPULSION_DIST;\n      }\n\n      if (Math.abs(distanceY) < FDLayoutConstants.MIN_REPULSION_DIST) {\n        distanceY = IMath.sign(distanceY) * FDLayoutConstants.MIN_REPULSION_DIST;\n      }\n\n      distanceSquared = distanceX * distanceX + distanceY * distanceY;\n      distance = Math.sqrt(distanceSquared);\n\n      repulsionForce = this.repulsionConstant * nodeA.noOfChildren * nodeB.noOfChildren / distanceSquared;\n\n      // Project force onto x and y axes\n      repulsionForceX = repulsionForce * distanceX / distance;\n      repulsionForceY = repulsionForce * distanceY / distance;\n\n      // Apply forces on the two nodes    \n      nodeA.repulsionForceX -= repulsionForceX;\n      nodeA.repulsionForceY -= repulsionForceY;\n      nodeB.repulsionForceX += repulsionForceX;\n      nodeB.repulsionForceY += repulsionForceY;\n    }\n};\n\nFDLayout.prototype.calcGravitationalForce = function (node) {\n  var ownerGraph;\n  var ownerCenterX;\n  var ownerCenterY;\n  var distanceX;\n  var distanceY;\n  var absDistanceX;\n  var absDistanceY;\n  var estimatedSize;\n  ownerGraph = node.getOwner();\n\n  ownerCenterX = (ownerGraph.getRight() + ownerGraph.getLeft()) / 2;\n  ownerCenterY = (ownerGraph.getTop() + ownerGraph.getBottom()) / 2;\n  distanceX = node.getCenterX() - ownerCenterX;\n  distanceY = node.getCenterY() - ownerCenterY;\n  absDistanceX = Math.abs(distanceX) + node.getWidth() / 2;\n  absDistanceY = Math.abs(distanceY) + node.getHeight() / 2;\n\n  if (node.getOwner() == this.graphManager.getRoot()) // in the root graph\n    {\n      estimatedSize = ownerGraph.getEstimatedSize() * this.gravityRangeFactor;\n\n      if (absDistanceX > estimatedSize || absDistanceY > estimatedSize) {\n        node.gravitationForceX = -this.gravityConstant * distanceX;\n        node.gravitationForceY = -this.gravityConstant * distanceY;\n      }\n    } else // inside a compound\n    {\n      estimatedSize = ownerGraph.getEstimatedSize() * this.compoundGravityRangeFactor;\n\n      if (absDistanceX > estimatedSize || absDistanceY > estimatedSize) {\n        node.gravitationForceX = -this.gravityConstant * distanceX * this.compoundGravityConstant;\n        node.gravitationForceY = -this.gravityConstant * distanceY * this.compoundGravityConstant;\n      }\n    }\n};\n\nFDLayout.prototype.isConverged = function () {\n  var converged;\n  var oscilating = false;\n\n  if (this.totalIterations > this.maxIterations / 3) {\n    oscilating = Math.abs(this.totalDisplacement - this.oldTotalDisplacement) < 2;\n  }\n\n  converged = this.totalDisplacement < this.totalDisplacementThreshold;\n\n  this.oldTotalDisplacement = this.totalDisplacement;\n\n  return converged || oscilating;\n};\n\nFDLayout.prototype.animate = function () {\n  if (this.animationDuringLayout && !this.isSubLayout) {\n    if (this.notAnimatedIterations == this.animationPeriod) {\n      this.update();\n      this.notAnimatedIterations = 0;\n    } else {\n      this.notAnimatedIterations++;\n    }\n  }\n};\n\n//This method calculates the number of children (weight) for all nodes\nFDLayout.prototype.calcNoOfChildrenForAllNodes = function () {\n  var node;\n  var allNodes = this.graphManager.getAllNodes();\n\n  for (var i = 0; i < allNodes.length; i++) {\n    node = allNodes[i];\n    node.noOfChildren = node.getNoOfChildren();\n  }\n};\n\n// -----------------------------------------------------------------------------\n// Section: FR-Grid Variant Repulsion Force Calculation\n// -----------------------------------------------------------------------------\n\nFDLayout.prototype.calcGrid = function (graph) {\n\n  var sizeX = 0;\n  var sizeY = 0;\n\n  sizeX = parseInt(Math.ceil((graph.getRight() - graph.getLeft()) / this.repulsionRange));\n  sizeY = parseInt(Math.ceil((graph.getBottom() - graph.getTop()) / this.repulsionRange));\n\n  var grid = new Array(sizeX);\n\n  for (var i = 0; i < sizeX; i++) {\n    grid[i] = new Array(sizeY);\n  }\n\n  for (var i = 0; i < sizeX; i++) {\n    for (var j = 0; j < sizeY; j++) {\n      grid[i][j] = new Array();\n    }\n  }\n\n  return grid;\n};\n\nFDLayout.prototype.addNodeToGrid = function (v, left, top) {\n\n  var startX = 0;\n  var finishX = 0;\n  var startY = 0;\n  var finishY = 0;\n\n  startX = parseInt(Math.floor((v.getRect().x - left) / this.repulsionRange));\n  finishX = parseInt(Math.floor((v.getRect().width + v.getRect().x - left) / this.repulsionRange));\n  startY = parseInt(Math.floor((v.getRect().y - top) / this.repulsionRange));\n  finishY = parseInt(Math.floor((v.getRect().height + v.getRect().y - top) / this.repulsionRange));\n\n  for (var i = startX; i <= finishX; i++) {\n    for (var j = startY; j <= finishY; j++) {\n      this.grid[i][j].push(v);\n      v.setGridCoordinates(startX, finishX, startY, finishY);\n    }\n  }\n};\n\nFDLayout.prototype.updateGrid = function () {\n  var i;\n  var nodeA;\n  var lNodes = this.getAllNodes();\n\n  this.grid = this.calcGrid(this.graphManager.getRoot());\n\n  // put all nodes to proper grid cells\n  for (i = 0; i < lNodes.length; i++) {\n    nodeA = lNodes[i];\n    this.addNodeToGrid(nodeA, this.graphManager.getRoot().getLeft(), this.graphManager.getRoot().getTop());\n  }\n};\n\nFDLayout.prototype.calculateRepulsionForceOfANode = function (nodeA, processedNodeSet, gridUpdateAllowed, forceToNodeSurroundingUpdate) {\n\n  if (this.totalIterations % FDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD == 1 && gridUpdateAllowed || forceToNodeSurroundingUpdate) {\n    var surrounding = new Set();\n    nodeA.surrounding = new Array();\n    var nodeB;\n    var grid = this.grid;\n\n    for (var i = nodeA.startX - 1; i < nodeA.finishX + 2; i++) {\n      for (var j = nodeA.startY - 1; j < nodeA.finishY + 2; j++) {\n        if (!(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length)) {\n          for (var k = 0; k < grid[i][j].length; k++) {\n            nodeB = grid[i][j][k];\n\n            // If both nodes are not members of the same graph, \n            // or both nodes are the same, skip.\n            if (nodeA.getOwner() != nodeB.getOwner() || nodeA == nodeB) {\n              continue;\n            }\n\n            // check if the repulsion force between\n            // nodeA and nodeB has already been calculated\n            if (!processedNodeSet.has(nodeB) && !surrounding.has(nodeB)) {\n              var distanceX = Math.abs(nodeA.getCenterX() - nodeB.getCenterX()) - (nodeA.getWidth() / 2 + nodeB.getWidth() / 2);\n              var distanceY = Math.abs(nodeA.getCenterY() - nodeB.getCenterY()) - (nodeA.getHeight() / 2 + nodeB.getHeight() / 2);\n\n              // if the distance between nodeA and nodeB \n              // is less then calculation range\n              if (distanceX <= this.repulsionRange && distanceY <= this.repulsionRange) {\n                //then add nodeB to surrounding of nodeA\n                surrounding.add(nodeB);\n              }\n            }\n          }\n        }\n      }\n    }\n\n    nodeA.surrounding = [].concat(_toConsumableArray(surrounding));\n  }\n  for (i = 0; i < nodeA.surrounding.length; i++) {\n    this.calcRepulsionForce(nodeA, nodeA.surrounding[i]);\n  }\n};\n\nFDLayout.prototype.calcRepulsionRange = function () {\n  return 0.0;\n};\n\nmodule.exports = FDLayout;\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __nested_webpack_require_100902__) {\n\n\"use strict\";\n\n\nvar LEdge = __nested_webpack_require_100902__(1);\nvar FDLayoutConstants = __nested_webpack_require_100902__(7);\n\nfunction FDLayoutEdge(source, target, vEdge) {\n  LEdge.call(this, source, target, vEdge);\n  this.idealLength = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\n}\n\nFDLayoutEdge.prototype = Object.create(LEdge.prototype);\n\nfor (var prop in LEdge) {\n  FDLayoutEdge[prop] = LEdge[prop];\n}\n\nmodule.exports = FDLayoutEdge;\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __nested_webpack_require_101387__) {\n\n\"use strict\";\n\n\nvar LNode = __nested_webpack_require_101387__(3);\n\nfunction FDLayoutNode(gm, loc, size, vNode) {\n  // alternative constructor is handled inside LNode\n  LNode.call(this, gm, loc, size, vNode);\n  //Spring, repulsion and gravitational forces acting on this node\n  this.springForceX = 0;\n  this.springForceY = 0;\n  this.repulsionForceX = 0;\n  this.repulsionForceY = 0;\n  this.gravitationForceX = 0;\n  this.gravitationForceY = 0;\n  //Amount by which this node is to be moved in this iteration\n  this.displacementX = 0;\n  this.displacementY = 0;\n\n  //Start and finish grid coordinates that this node is fallen into\n  this.startX = 0;\n  this.finishX = 0;\n  this.startY = 0;\n  this.finishY = 0;\n\n  //Geometric neighbors of this node\n  this.surrounding = [];\n}\n\nFDLayoutNode.prototype = Object.create(LNode.prototype);\n\nfor (var prop in LNode) {\n  FDLayoutNode[prop] = LNode[prop];\n}\n\nFDLayoutNode.prototype.setGridCoordinates = function (_startX, _finishX, _startY, _finishY) {\n  this.startX = _startX;\n  this.finishX = _finishX;\n  this.startY = _startY;\n  this.finishY = _finishY;\n};\n\nmodule.exports = FDLayoutNode;\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction DimensionD(width, height) {\n  this.width = 0;\n  this.height = 0;\n  if (width !== null && height !== null) {\n    this.height = height;\n    this.width = width;\n  }\n}\n\nDimensionD.prototype.getWidth = function () {\n  return this.width;\n};\n\nDimensionD.prototype.setWidth = function (width) {\n  this.width = width;\n};\n\nDimensionD.prototype.getHeight = function () {\n  return this.height;\n};\n\nDimensionD.prototype.setHeight = function (height) {\n  this.height = height;\n};\n\nmodule.exports = DimensionD;\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __nested_webpack_require_103173__) {\n\n\"use strict\";\n\n\nvar UniqueIDGeneretor = __nested_webpack_require_103173__(14);\n\nfunction HashMap() {\n  this.map = {};\n  this.keys = [];\n}\n\nHashMap.prototype.put = function (key, value) {\n  var theId = UniqueIDGeneretor.createID(key);\n  if (!this.contains(theId)) {\n    this.map[theId] = value;\n    this.keys.push(key);\n  }\n};\n\nHashMap.prototype.contains = function (key) {\n  var theId = UniqueIDGeneretor.createID(key);\n  return this.map[key] != null;\n};\n\nHashMap.prototype.get = function (key) {\n  var theId = UniqueIDGeneretor.createID(key);\n  return this.map[theId];\n};\n\nHashMap.prototype.keySet = function () {\n  return this.keys;\n};\n\nmodule.exports = HashMap;\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __nested_webpack_require_103901__) {\n\n\"use strict\";\n\n\nvar UniqueIDGeneretor = __nested_webpack_require_103901__(14);\n\nfunction HashSet() {\n  this.set = {};\n}\n;\n\nHashSet.prototype.add = function (obj) {\n  var theId = UniqueIDGeneretor.createID(obj);\n  if (!this.contains(theId)) this.set[theId] = obj;\n};\n\nHashSet.prototype.remove = function (obj) {\n  delete this.set[UniqueIDGeneretor.createID(obj)];\n};\n\nHashSet.prototype.clear = function () {\n  this.set = {};\n};\n\nHashSet.prototype.contains = function (obj) {\n  return this.set[UniqueIDGeneretor.createID(obj)] == obj;\n};\n\nHashSet.prototype.isEmpty = function () {\n  return this.size() === 0;\n};\n\nHashSet.prototype.size = function () {\n  return Object.keys(this.set).length;\n};\n\n//concats this.set to the given list\nHashSet.prototype.addAllTo = function (list) {\n  var keys = Object.keys(this.set);\n  var length = keys.length;\n  for (var i = 0; i < length; i++) {\n    list.push(this.set[keys[i]]);\n  }\n};\n\nHashSet.prototype.size = function () {\n  return Object.keys(this.set).length;\n};\n\nHashSet.prototype.addAll = function (list) {\n  var s = list.length;\n  for (var i = 0; i < s; i++) {\n    var v = list[i];\n    this.add(v);\n  }\n};\n\nmodule.exports = HashSet;\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __nested_webpack_require_105138__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * A classic Quicksort algorithm with Hoare's partition\n * - Works also on LinkedList objects\n *\n * Copyright: i-Vis Research Group, Bilkent University, 2007 - present\n */\n\nvar LinkedList = __nested_webpack_require_105138__(11);\n\nvar Quicksort = function () {\n    function Quicksort(A, compareFunction) {\n        _classCallCheck(this, Quicksort);\n\n        if (compareFunction !== null || compareFunction !== undefined) this.compareFunction = this._defaultCompareFunction;\n\n        var length = void 0;\n        if (A instanceof LinkedList) length = A.size();else length = A.length;\n\n        this._quicksort(A, 0, length - 1);\n    }\n\n    _createClass(Quicksort, [{\n        key: '_quicksort',\n        value: function _quicksort(A, p, r) {\n            if (p < r) {\n                var q = this._partition(A, p, r);\n                this._quicksort(A, p, q);\n                this._quicksort(A, q + 1, r);\n            }\n        }\n    }, {\n        key: '_partition',\n        value: function _partition(A, p, r) {\n            var x = this._get(A, p);\n            var i = p;\n            var j = r;\n            while (true) {\n                while (this.compareFunction(x, this._get(A, j))) {\n                    j--;\n                }while (this.compareFunction(this._get(A, i), x)) {\n                    i++;\n                }if (i < j) {\n                    this._swap(A, i, j);\n                    i++;\n                    j--;\n                } else return j;\n            }\n        }\n    }, {\n        key: '_get',\n        value: function _get(object, index) {\n            if (object instanceof LinkedList) return object.get_object_at(index);else return object[index];\n        }\n    }, {\n        key: '_set',\n        value: function _set(object, index, value) {\n            if (object instanceof LinkedList) object.set_object_at(index, value);else object[index] = value;\n        }\n    }, {\n        key: '_swap',\n        value: function _swap(A, i, j) {\n            var temp = this._get(A, i);\n            this._set(A, i, this._get(A, j));\n            this._set(A, j, temp);\n        }\n    }, {\n        key: '_defaultCompareFunction',\n        value: function _defaultCompareFunction(a, b) {\n            return b > a;\n        }\n    }]);\n\n    return Quicksort;\n}();\n\nmodule.exports = Quicksort;\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n *   Needleman-Wunsch algorithm is an procedure to compute the optimal global alignment of two string\n *   sequences by S.B.Needleman and C.D.Wunsch (1970).\n *\n *   Aside from the inputs, you can assign the scores for,\n *   - Match: The two characters at the current index are same.\n *   - Mismatch: The two characters at the current index are different.\n *   - Insertion/Deletion(gaps): The best alignment involves one letter aligning to a gap in the other string.\n */\n\nvar NeedlemanWunsch = function () {\n    function NeedlemanWunsch(sequence1, sequence2) {\n        var match_score = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n        var mismatch_penalty = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -1;\n        var gap_penalty = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : -1;\n\n        _classCallCheck(this, NeedlemanWunsch);\n\n        this.sequence1 = sequence1;\n        this.sequence2 = sequence2;\n        this.match_score = match_score;\n        this.mismatch_penalty = mismatch_penalty;\n        this.gap_penalty = gap_penalty;\n\n        // Just the remove redundancy\n        this.iMax = sequence1.length + 1;\n        this.jMax = sequence2.length + 1;\n\n        // Grid matrix of scores\n        this.grid = new Array(this.iMax);\n        for (var i = 0; i < this.iMax; i++) {\n            this.grid[i] = new Array(this.jMax);\n\n            for (var j = 0; j < this.jMax; j++) {\n                this.grid[i][j] = 0;\n            }\n        }\n\n        // Traceback matrix (2D array, each cell is an array of boolean values for [`Diag`, `Up`, `Left`] positions)\n        this.tracebackGrid = new Array(this.iMax);\n        for (var _i = 0; _i < this.iMax; _i++) {\n            this.tracebackGrid[_i] = new Array(this.jMax);\n\n            for (var _j = 0; _j < this.jMax; _j++) {\n                this.tracebackGrid[_i][_j] = [null, null, null];\n            }\n        }\n\n        // The aligned sequences (return multiple possibilities)\n        this.alignments = [];\n\n        // Final alignment score\n        this.score = -1;\n\n        // Calculate scores and tracebacks\n        this.computeGrids();\n    }\n\n    _createClass(NeedlemanWunsch, [{\n        key: \"getScore\",\n        value: function getScore() {\n            return this.score;\n        }\n    }, {\n        key: \"getAlignments\",\n        value: function getAlignments() {\n            return this.alignments;\n        }\n\n        // Main dynamic programming procedure\n\n    }, {\n        key: \"computeGrids\",\n        value: function computeGrids() {\n            // Fill in the first row\n            for (var j = 1; j < this.jMax; j++) {\n                this.grid[0][j] = this.grid[0][j - 1] + this.gap_penalty;\n                this.tracebackGrid[0][j] = [false, false, true];\n            }\n\n            // Fill in the first column\n            for (var i = 1; i < this.iMax; i++) {\n                this.grid[i][0] = this.grid[i - 1][0] + this.gap_penalty;\n                this.tracebackGrid[i][0] = [false, true, false];\n            }\n\n            // Fill the rest of the grid\n            for (var _i2 = 1; _i2 < this.iMax; _i2++) {\n                for (var _j2 = 1; _j2 < this.jMax; _j2++) {\n                    // Find the max score(s) among [`Diag`, `Up`, `Left`]\n                    var diag = void 0;\n                    if (this.sequence1[_i2 - 1] === this.sequence2[_j2 - 1]) diag = this.grid[_i2 - 1][_j2 - 1] + this.match_score;else diag = this.grid[_i2 - 1][_j2 - 1] + this.mismatch_penalty;\n\n                    var up = this.grid[_i2 - 1][_j2] + this.gap_penalty;\n                    var left = this.grid[_i2][_j2 - 1] + this.gap_penalty;\n\n                    // If there exists multiple max values, capture them for multiple paths\n                    var maxOf = [diag, up, left];\n                    var indices = this.arrayAllMaxIndexes(maxOf);\n\n                    // Update Grids\n                    this.grid[_i2][_j2] = maxOf[indices[0]];\n                    this.tracebackGrid[_i2][_j2] = [indices.includes(0), indices.includes(1), indices.includes(2)];\n                }\n            }\n\n            // Update alignment score\n            this.score = this.grid[this.iMax - 1][this.jMax - 1];\n        }\n\n        // Gets all possible valid sequence combinations\n\n    }, {\n        key: \"alignmentTraceback\",\n        value: function alignmentTraceback() {\n            var inProcessAlignments = [];\n\n            inProcessAlignments.push({ pos: [this.sequence1.length, this.sequence2.length],\n                seq1: \"\",\n                seq2: \"\"\n            });\n\n            while (inProcessAlignments[0]) {\n                var current = inProcessAlignments[0];\n                var directions = this.tracebackGrid[current.pos[0]][current.pos[1]];\n\n                if (directions[0]) {\n                    inProcessAlignments.push({ pos: [current.pos[0] - 1, current.pos[1] - 1],\n                        seq1: this.sequence1[current.pos[0] - 1] + current.seq1,\n                        seq2: this.sequence2[current.pos[1] - 1] + current.seq2\n                    });\n                }\n                if (directions[1]) {\n                    inProcessAlignments.push({ pos: [current.pos[0] - 1, current.pos[1]],\n                        seq1: this.sequence1[current.pos[0] - 1] + current.seq1,\n                        seq2: '-' + current.seq2\n                    });\n                }\n                if (directions[2]) {\n                    inProcessAlignments.push({ pos: [current.pos[0], current.pos[1] - 1],\n                        seq1: '-' + current.seq1,\n                        seq2: this.sequence2[current.pos[1] - 1] + current.seq2\n                    });\n                }\n\n                if (current.pos[0] === 0 && current.pos[1] === 0) this.alignments.push({ sequence1: current.seq1,\n                    sequence2: current.seq2\n                });\n\n                inProcessAlignments.shift();\n            }\n\n            return this.alignments;\n        }\n\n        // Helper Functions\n\n    }, {\n        key: \"getAllIndexes\",\n        value: function getAllIndexes(arr, val) {\n            var indexes = [],\n                i = -1;\n            while ((i = arr.indexOf(val, i + 1)) !== -1) {\n                indexes.push(i);\n            }\n            return indexes;\n        }\n    }, {\n        key: \"arrayAllMaxIndexes\",\n        value: function arrayAllMaxIndexes(array) {\n            return this.getAllIndexes(array, Math.max.apply(null, array));\n        }\n    }]);\n\n    return NeedlemanWunsch;\n}();\n\nmodule.exports = NeedlemanWunsch;\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __nested_webpack_require_115611__) {\n\n\"use strict\";\n\n\nvar layoutBase = function layoutBase() {\n  return;\n};\n\nlayoutBase.FDLayout = __nested_webpack_require_115611__(18);\nlayoutBase.FDLayoutConstants = __nested_webpack_require_115611__(7);\nlayoutBase.FDLayoutEdge = __nested_webpack_require_115611__(19);\nlayoutBase.FDLayoutNode = __nested_webpack_require_115611__(20);\nlayoutBase.DimensionD = __nested_webpack_require_115611__(21);\nlayoutBase.HashMap = __nested_webpack_require_115611__(22);\nlayoutBase.HashSet = __nested_webpack_require_115611__(23);\nlayoutBase.IGeometry = __nested_webpack_require_115611__(8);\nlayoutBase.IMath = __nested_webpack_require_115611__(9);\nlayoutBase.Integer = __nested_webpack_require_115611__(10);\nlayoutBase.Point = __nested_webpack_require_115611__(12);\nlayoutBase.PointD = __nested_webpack_require_115611__(4);\nlayoutBase.RandomSeed = __nested_webpack_require_115611__(16);\nlayoutBase.RectangleD = __nested_webpack_require_115611__(13);\nlayoutBase.Transform = __nested_webpack_require_115611__(17);\nlayoutBase.UniqueIDGeneretor = __nested_webpack_require_115611__(14);\nlayoutBase.Quicksort = __nested_webpack_require_115611__(24);\nlayoutBase.LinkedList = __nested_webpack_require_115611__(11);\nlayoutBase.LGraphObject = __nested_webpack_require_115611__(2);\nlayoutBase.LGraph = __nested_webpack_require_115611__(5);\nlayoutBase.LEdge = __nested_webpack_require_115611__(1);\nlayoutBase.LGraphManager = __nested_webpack_require_115611__(6);\nlayoutBase.LNode = __nested_webpack_require_115611__(3);\nlayoutBase.Layout = __nested_webpack_require_115611__(15);\nlayoutBase.LayoutConstants = __nested_webpack_require_115611__(0);\nlayoutBase.NeedlemanWunsch = __nested_webpack_require_115611__(25);\n\nmodule.exports = layoutBase;\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction Emitter() {\n  this.listeners = [];\n}\n\nvar p = Emitter.prototype;\n\np.addListener = function (event, callback) {\n  this.listeners.push({\n    event: event,\n    callback: callback\n  });\n};\n\np.removeListener = function (event, callback) {\n  for (var i = this.listeners.length; i >= 0; i--) {\n    var l = this.listeners[i];\n\n    if (l.event === event && l.callback === callback) {\n      this.listeners.splice(i, 1);\n    }\n  }\n};\n\np.emit = function (event, data) {\n  for (var i = 0; i < this.listeners.length; i++) {\n    var l = this.listeners[i];\n\n    if (event === l.event) {\n      l.callback(data);\n    }\n  }\n};\n\nmodule.exports = Emitter;\n\n/***/ })\n/******/ ]);\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbGF5b3V0LWJhc2UvbGF5b3V0LWJhc2UuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxJQUFJLElBQXlEO0FBQzdEO0FBQ0EsTUFBTSxFQUsyQjtBQUNqQyxDQUFDO0FBQ0QscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDhCQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSw4QkFBbUI7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QjtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7QUFDN0I7QUFDQTtBQUNBLFVBQVUsOEJBQW1CLHVCQUF1QjtBQUNwRDtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7QUFDN0IsZUFBZSw4QkFBbUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QjtBQUNBLG9DQUFvQyw0QkFBNEI7QUFDaEUsMENBQTBDO0FBQzFDLFdBQVcsOEJBQW1CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4QkFBbUIsa0NBQWtDO0FBQy9EO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QjtBQUNBO0FBQ0EsaUJBQWlCLDhCQUFtQixDQUFDLDhCQUFtQjtBQUN4RCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25COztBQUVBO0FBQ0E7QUFDQSwwQkFBMEIsS0FBSzs7QUFFL0I7QUFDQTtBQUNBLDBCQUEwQixLQUFLOztBQUUvQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSixvQ0FBb0M7QUFDcEMsSUFBSTtBQUNKLDRCQUE0QjtBQUM1Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0EsaUNBQWlDLDJDQUEyQyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVELCtEQUErRCx5REFBeUQscUVBQXFFLDZEQUE2RCx3QkFBd0I7O0FBRWpqQixrREFBa0QsMENBQTBDOztBQUU1RjtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FB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QkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0Is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d0JBQXdCLGlDQUFtQjtBQUMzQyx3QkFBd0IsaUNBQW1CO0FBQzNDLHVCQUF1QixpQ0FBbUI7QUFDMUMsK0JBQStCLGlDQUFtQjtBQUNsRCx1QkFBdUIsaUNBQW1CO0FBQzFDLHdCQUF3QixpQ0FBbUI7QUFDM0MsMEJBQTBCLGlDQUFtQjtBQUM3QyxvQkFBb0IsaUNBQW1CO0FBQ3ZDLG1CQUFtQixpQ0FBbUI7QUFDdEMsMkJBQTJCLGlDQUFtQjtBQUM5QyxtQkFBbUIsaUNBQW1CO0FBQ3RDLG9CQUFvQixpQ0FBbUI7QUFDdkMsNkJBQTZCLGlDQUFtQjtBQUNoRCw2QkFBNkIsaUNBQW1COztBQUVoRDs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQiwyQkFBMkI7QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2hhdGdwdC1uZXh0LXdlYi8uL25vZGVfbW9kdWxlcy9sYXlvdXQtYmFzZS9sYXlvdXQtYmFzZS5qcz84ZTBiIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcImxheW91dEJhc2VcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wibGF5b3V0QmFzZVwiXSA9IGZhY3RvcnkoKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBpZGVudGl0eSBmdW5jdGlvbiBmb3IgY2FsbGluZyBoYXJtb255IGltcG9ydHMgd2l0aCB0aGUgY29ycmVjdCBjb250ZXh0XG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uaSA9IGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuLyoqKioqKi8gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuLyoqKioqKi8gXHRcdFx0XHRnZXQ6IGdldHRlclxuLyoqKioqKi8gXHRcdFx0fSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDI2KTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gTGF5b3V0Q29uc3RhbnRzKCkge31cblxuLyoqXHJcbiAqIExheW91dCBRdWFsaXR5OiAwOmRyYWZ0LCAxOmRlZmF1bHQsIDI6cHJvb2ZcclxuICovXG5MYXlvdXRDb25zdGFudHMuUVVBTElUWSA9IDE7XG5cbi8qKlxyXG4gKiBEZWZhdWx0IHBhcmFtZXRlcnNcclxuICovXG5MYXlvdXRDb25zdGFudHMuREVGQVVMVF9DUkVBVEVfQkVORFNfQVNfTkVFREVEID0gZmFsc2U7XG5MYXlvdXRDb25zdGFudHMuREVGQVVMVF9JTkNSRU1FTlRBTCA9IGZhbHNlO1xuTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQU5JTUFUSU9OX09OX0xBWU9VVCA9IHRydWU7XG5MYXlvdXRDb25zdGFudHMuREVGQVVMVF9BTklNQVRJT05fRFVSSU5HX0xBWU9VVCA9IGZhbHNlO1xuTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQU5JTUFUSU9OX1BFUklPRCA9IDUwO1xuTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfVU5JRk9STV9MRUFGX05PREVfU0laRVMgPSBmYWxzZTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFNlY3Rpb246IEdlbmVyYWwgb3RoZXIgY29uc3RhbnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLypcclxuICogTWFyZ2lucyBvZiBhIGdyYXBoIHRvIGJlIGFwcGxpZWQgb24gYm91ZGluZyByZWN0YW5nbGUgb2YgaXRzIGNvbnRlbnRzLiBXZVxyXG4gKiBhc3N1bWUgbWFyZ2lucyBvbiBhbGwgZm91ciBzaWRlcyB0byBiZSB1bmlmb3JtLlxyXG4gKi9cbkxheW91dENvbnN0YW50cy5ERUZBVUxUX0dSQVBIX01BUkdJTiA9IDE1O1xuXG4vKlxyXG4gKiBXaGV0aGVyIHRvIGNvbnNpZGVyIGxhYmVscyBpbiBub2RlIGRpbWVuc2lvbnMgb3Igbm90XHJcbiAqL1xuTGF5b3V0Q29uc3RhbnRzLk5PREVfRElNRU5TSU9OU19JTkNMVURFX0xBQkVMUyA9IGZhbHNlO1xuXG4vKlxyXG4gKiBEZWZhdWx0IGRpbWVuc2lvbiBvZiBhIG5vbi1jb21wb3VuZCBub2RlLlxyXG4gKi9cbkxheW91dENvbnN0YW50cy5TSU1QTEVfTk9ERV9TSVpFID0gNDA7XG5cbi8qXHJcbiAqIERlZmF1bHQgZGltZW5zaW9uIG9mIGEgbm9uLWNvbXBvdW5kIG5vZGUuXHJcbiAqL1xuTGF5b3V0Q29uc3RhbnRzLlNJTVBMRV9OT0RFX0hBTEZfU0laRSA9IExheW91dENvbnN0YW50cy5TSU1QTEVfTk9ERV9TSVpFIC8gMjtcblxuLypcclxuICogRW1wdHkgY29tcG91bmQgbm9kZSBzaXplLiBXaGVuIGEgY29tcG91bmQgbm9kZSBpcyBlbXB0eSwgaXRzIGJvdGhcclxuICogZGltZW5zaW9ucyBzaG91bGQgYmUgb2YgdGhpcyB2YWx1ZS5cclxuICovXG5MYXlvdXRDb25zdGFudHMuRU1QVFlfQ09NUE9VTkRfTk9ERV9TSVpFID0gNDA7XG5cbi8qXHJcbiAqIE1pbmltdW0gbGVuZ3RoIHRoYXQgYW4gZWRnZSBzaG91bGQgdGFrZSBkdXJpbmcgbGF5b3V0XHJcbiAqL1xuTGF5b3V0Q29uc3RhbnRzLk1JTl9FREdFX0xFTkdUSCA9IDE7XG5cbi8qXHJcbiAqIFdvcmxkIGJvdW5kYXJpZXMgdGhhdCBsYXlvdXQgb3BlcmF0ZXMgb25cclxuICovXG5MYXlvdXRDb25zdGFudHMuV09STERfQk9VTkRBUlkgPSAxMDAwMDAwO1xuXG4vKlxyXG4gKiBXb3JsZCBib3VuZGFyaWVzIHRoYXQgcmFuZG9tIHBvc2l0aW9uaW5nIGNhbiBiZSBwZXJmb3JtZWQgd2l0aFxyXG4gKi9cbkxheW91dENvbnN0YW50cy5JTklUSUFMX1dPUkxEX0JPVU5EQVJZID0gTGF5b3V0Q29uc3RhbnRzLldPUkxEX0JPVU5EQVJZIC8gMTAwMDtcblxuLypcclxuICogQ29vcmRpbmF0ZXMgb2YgdGhlIHdvcmxkIGNlbnRlclxyXG4gKi9cbkxheW91dENvbnN0YW50cy5XT1JMRF9DRU5URVJfWCA9IDEyMDA7XG5MYXlvdXRDb25zdGFudHMuV09STERfQ0VOVEVSX1kgPSA5MDA7XG5cbm1vZHVsZS5leHBvcnRzID0gTGF5b3V0Q29uc3RhbnRzO1xuXG4vKioqLyB9KSxcbi8qIDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIExHcmFwaE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG52YXIgSUdlb21ldHJ5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcbnZhciBJTWF0aCA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbmZ1bmN0aW9uIExFZGdlKHNvdXJjZSwgdGFyZ2V0LCB2RWRnZSkge1xuICBMR3JhcGhPYmplY3QuY2FsbCh0aGlzLCB2RWRnZSk7XG5cbiAgdGhpcy5pc092ZXJsYXBpbmdTb3VyY2VBbmRUYXJnZXQgPSBmYWxzZTtcbiAgdGhpcy52R3JhcGhPYmplY3QgPSB2RWRnZTtcbiAgdGhpcy5iZW5kcG9pbnRzID0gW107XG4gIHRoaXMuc291cmNlID0gc291cmNlO1xuICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbn1cblxuTEVkZ2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShMR3JhcGhPYmplY3QucHJvdG90eXBlKTtcblxuZm9yICh2YXIgcHJvcCBpbiBMR3JhcGhPYmplY3QpIHtcbiAgTEVkZ2VbcHJvcF0gPSBMR3JhcGhPYmplY3RbcHJvcF07XG59XG5cbkxFZGdlLnByb3RvdHlwZS5nZXRTb3VyY2UgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnNvdXJjZTtcbn07XG5cbkxFZGdlLnByb3RvdHlwZS5nZXRUYXJnZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnRhcmdldDtcbn07XG5cbkxFZGdlLnByb3RvdHlwZS5pc0ludGVyR3JhcGggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmlzSW50ZXJHcmFwaDtcbn07XG5cbkxFZGdlLnByb3RvdHlwZS5nZXRMZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmxlbmd0aDtcbn07XG5cbkxFZGdlLnByb3RvdHlwZS5pc092ZXJsYXBpbmdTb3VyY2VBbmRUYXJnZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmlzT3ZlcmxhcGluZ1NvdXJjZUFuZFRhcmdldDtcbn07XG5cbkxFZGdlLnByb3RvdHlwZS5nZXRCZW5kcG9pbnRzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5iZW5kcG9pbnRzO1xufTtcblxuTEVkZ2UucHJvdG90eXBlLmdldExjYSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubGNhO1xufTtcblxuTEVkZ2UucHJvdG90eXBlLmdldFNvdXJjZUluTGNhID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5zb3VyY2VJbkxjYTtcbn07XG5cbkxFZGdlLnByb3RvdHlwZS5nZXRUYXJnZXRJbkxjYSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMudGFyZ2V0SW5MY2E7XG59O1xuXG5MRWRnZS5wcm90b3R5cGUuZ2V0T3RoZXJFbmQgPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAodGhpcy5zb3VyY2UgPT09IG5vZGUpIHtcbiAgICByZXR1cm4gdGhpcy50YXJnZXQ7XG4gIH0gZWxzZSBpZiAodGhpcy50YXJnZXQgPT09IG5vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5zb3VyY2U7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgXCJOb2RlIGlzIG5vdCBpbmNpZGVudCB3aXRoIHRoaXMgZWRnZVwiO1xuICB9XG59O1xuXG5MRWRnZS5wcm90b3R5cGUuZ2V0T3RoZXJFbmRJbkdyYXBoID0gZnVuY3Rpb24gKG5vZGUsIGdyYXBoKSB7XG4gIHZhciBvdGhlckVuZCA9IHRoaXMuZ2V0T3RoZXJFbmQobm9kZSk7XG4gIHZhciByb290ID0gZ3JhcGguZ2V0R3JhcGhNYW5hZ2VyKCkuZ2V0Um9vdCgpO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKG90aGVyRW5kLmdldE93bmVyKCkgPT0gZ3JhcGgpIHtcbiAgICAgIHJldHVybiBvdGhlckVuZDtcbiAgICB9XG5cbiAgICBpZiAob3RoZXJFbmQuZ2V0T3duZXIoKSA9PSByb290KSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBvdGhlckVuZCA9IG90aGVyRW5kLmdldE93bmVyKCkuZ2V0UGFyZW50KCk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG5cbkxFZGdlLnByb3RvdHlwZS51cGRhdGVMZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjbGlwUG9pbnRDb29yZGluYXRlcyA9IG5ldyBBcnJheSg0KTtcblxuICB0aGlzLmlzT3ZlcmxhcGluZ1NvdXJjZUFuZFRhcmdldCA9IElHZW9tZXRyeS5nZXRJbnRlcnNlY3Rpb24odGhpcy50YXJnZXQuZ2V0UmVjdCgpLCB0aGlzLnNvdXJjZS5nZXRSZWN0KCksIGNsaXBQb2ludENvb3JkaW5hdGVzKTtcblxuICBpZiAoIXRoaXMuaXNPdmVybGFwaW5nU291cmNlQW5kVGFyZ2V0KSB7XG4gICAgdGhpcy5sZW5ndGhYID0gY2xpcFBvaW50Q29vcmRpbmF0ZXNbMF0gLSBjbGlwUG9pbnRDb29yZGluYXRlc1syXTtcbiAgICB0aGlzLmxlbmd0aFkgPSBjbGlwUG9pbnRDb29yZGluYXRlc1sxXSAtIGNsaXBQb2ludENvb3JkaW5hdGVzWzNdO1xuXG4gICAgaWYgKE1hdGguYWJzKHRoaXMubGVuZ3RoWCkgPCAxLjApIHtcbiAgICAgIHRoaXMubGVuZ3RoWCA9IElNYXRoLnNpZ24odGhpcy5sZW5ndGhYKTtcbiAgICB9XG5cbiAgICBpZiAoTWF0aC5hYnModGhpcy5sZW5ndGhZKSA8IDEuMCkge1xuICAgICAgdGhpcy5sZW5ndGhZID0gSU1hdGguc2lnbih0aGlzLmxlbmd0aFkpO1xuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5zcXJ0KHRoaXMubGVuZ3RoWCAqIHRoaXMubGVuZ3RoWCArIHRoaXMubGVuZ3RoWSAqIHRoaXMubGVuZ3RoWSk7XG4gIH1cbn07XG5cbkxFZGdlLnByb3RvdHlwZS51cGRhdGVMZW5ndGhTaW1wbGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMubGVuZ3RoWCA9IHRoaXMudGFyZ2V0LmdldENlbnRlclgoKSAtIHRoaXMuc291cmNlLmdldENlbnRlclgoKTtcbiAgdGhpcy5sZW5ndGhZID0gdGhpcy50YXJnZXQuZ2V0Q2VudGVyWSgpIC0gdGhpcy5zb3VyY2UuZ2V0Q2VudGVyWSgpO1xuXG4gIGlmIChNYXRoLmFicyh0aGlzLmxlbmd0aFgpIDwgMS4wKSB7XG4gICAgdGhpcy5sZW5ndGhYID0gSU1hdGguc2lnbih0aGlzLmxlbmd0aFgpO1xuICB9XG5cbiAgaWYgKE1hdGguYWJzKHRoaXMubGVuZ3RoWSkgPCAxLjApIHtcbiAgICB0aGlzLmxlbmd0aFkgPSBJTWF0aC5zaWduKHRoaXMubGVuZ3RoWSk7XG4gIH1cblxuICB0aGlzLmxlbmd0aCA9IE1hdGguc3FydCh0aGlzLmxlbmd0aFggKiB0aGlzLmxlbmd0aFggKyB0aGlzLmxlbmd0aFkgKiB0aGlzLmxlbmd0aFkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBMRWRnZTtcblxuLyoqKi8gfSksXG4vKiAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIExHcmFwaE9iamVjdCh2R3JhcGhPYmplY3QpIHtcbiAgdGhpcy52R3JhcGhPYmplY3QgPSB2R3JhcGhPYmplY3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTEdyYXBoT2JqZWN0O1xuXG4vKioqLyB9KSxcbi8qIDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIExHcmFwaE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG52YXIgSW50ZWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xudmFyIFJlY3RhbmdsZUQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcbnZhciBMYXlvdXRDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIFJhbmRvbVNlZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcbnZhciBQb2ludEQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG5mdW5jdGlvbiBMTm9kZShnbSwgbG9jLCBzaXplLCB2Tm9kZSkge1xuICAvL0FsdGVybmF0aXZlIGNvbnN0cnVjdG9yIDEgOiBMTm9kZShMR3JhcGhNYW5hZ2VyIGdtLCBQb2ludCBsb2MsIERpbWVuc2lvbiBzaXplLCBPYmplY3Qgdk5vZGUpXG4gIGlmIChzaXplID09IG51bGwgJiYgdk5vZGUgPT0gbnVsbCkge1xuICAgIHZOb2RlID0gbG9jO1xuICB9XG5cbiAgTEdyYXBoT2JqZWN0LmNhbGwodGhpcywgdk5vZGUpO1xuXG4gIC8vQWx0ZXJuYXRpdmUgY29uc3RydWN0b3IgMiA6IExOb2RlKExheW91dCBsYXlvdXQsIE9iamVjdCB2Tm9kZSlcbiAgaWYgKGdtLmdyYXBoTWFuYWdlciAhPSBudWxsKSBnbSA9IGdtLmdyYXBoTWFuYWdlcjtcblxuICB0aGlzLmVzdGltYXRlZFNpemUgPSBJbnRlZ2VyLk1JTl9WQUxVRTtcbiAgdGhpcy5pbmNsdXNpb25UcmVlRGVwdGggPSBJbnRlZ2VyLk1BWF9WQUxVRTtcbiAgdGhpcy52R3JhcGhPYmplY3QgPSB2Tm9kZTtcbiAgdGhpcy5lZGdlcyA9IFtdO1xuICB0aGlzLmdyYXBoTWFuYWdlciA9IGdtO1xuXG4gIGlmIChzaXplICE9IG51bGwgJiYgbG9jICE9IG51bGwpIHRoaXMucmVjdCA9IG5ldyBSZWN0YW5nbGVEKGxvYy54LCBsb2MueSwgc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQpO2Vsc2UgdGhpcy5yZWN0ID0gbmV3IFJlY3RhbmdsZUQoKTtcbn1cblxuTE5vZGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShMR3JhcGhPYmplY3QucHJvdG90eXBlKTtcbmZvciAodmFyIHByb3AgaW4gTEdyYXBoT2JqZWN0KSB7XG4gIExOb2RlW3Byb3BdID0gTEdyYXBoT2JqZWN0W3Byb3BdO1xufVxuXG5MTm9kZS5wcm90b3R5cGUuZ2V0RWRnZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmVkZ2VzO1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldENoaWxkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jaGlsZDtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXRPd25lciA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gIGlmICh0aGlzLm93bmVyICE9IG51bGwpIHtcbiAgLy8gICAgaWYgKCEodGhpcy5vd25lciA9PSBudWxsIHx8IHRoaXMub3duZXIuZ2V0Tm9kZXMoKS5pbmRleE9mKHRoaXMpID4gLTEpKSB7XG4gIC8vICAgICAgdGhyb3cgXCJhc3NlcnQgZmFpbGVkXCI7XG4gIC8vICAgIH1cbiAgLy8gIH1cblxuICByZXR1cm4gdGhpcy5vd25lcjtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXRXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucmVjdC53aWR0aDtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5zZXRXaWR0aCA9IGZ1bmN0aW9uICh3aWR0aCkge1xuICB0aGlzLnJlY3Qud2lkdGggPSB3aWR0aDtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnJlY3QuaGVpZ2h0O1xufTtcblxuTE5vZGUucHJvdG90eXBlLnNldEhlaWdodCA9IGZ1bmN0aW9uIChoZWlnaHQpIHtcbiAgdGhpcy5yZWN0LmhlaWdodCA9IGhlaWdodDtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXRDZW50ZXJYID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5yZWN0LnggKyB0aGlzLnJlY3Qud2lkdGggLyAyO1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldENlbnRlclkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnJlY3QueSArIHRoaXMucmVjdC5oZWlnaHQgLyAyO1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldENlbnRlciA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBQb2ludEQodGhpcy5yZWN0LnggKyB0aGlzLnJlY3Qud2lkdGggLyAyLCB0aGlzLnJlY3QueSArIHRoaXMucmVjdC5oZWlnaHQgLyAyKTtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXRMb2NhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBQb2ludEQodGhpcy5yZWN0LngsIHRoaXMucmVjdC55KTtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXRSZWN0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5yZWN0O1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldERpYWdvbmFsID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMucmVjdC53aWR0aCAqIHRoaXMucmVjdC53aWR0aCArIHRoaXMucmVjdC5oZWlnaHQgKiB0aGlzLnJlY3QuaGVpZ2h0KTtcbn07XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBoYWxmIHRoZSBkaWFnb25hbCBsZW5ndGggb2YgdGhpcyBub2RlLlxuICovXG5MTm9kZS5wcm90b3R5cGUuZ2V0SGFsZlRoZURpYWdvbmFsID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMucmVjdC5oZWlnaHQgKiB0aGlzLnJlY3QuaGVpZ2h0ICsgdGhpcy5yZWN0LndpZHRoICogdGhpcy5yZWN0LndpZHRoKSAvIDI7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuc2V0UmVjdCA9IGZ1bmN0aW9uICh1cHBlckxlZnQsIGRpbWVuc2lvbikge1xuICB0aGlzLnJlY3QueCA9IHVwcGVyTGVmdC54O1xuICB0aGlzLnJlY3QueSA9IHVwcGVyTGVmdC55O1xuICB0aGlzLnJlY3Qud2lkdGggPSBkaW1lbnNpb24ud2lkdGg7XG4gIHRoaXMucmVjdC5oZWlnaHQgPSBkaW1lbnNpb24uaGVpZ2h0O1xufTtcblxuTE5vZGUucHJvdG90eXBlLnNldENlbnRlciA9IGZ1bmN0aW9uIChjeCwgY3kpIHtcbiAgdGhpcy5yZWN0LnggPSBjeCAtIHRoaXMucmVjdC53aWR0aCAvIDI7XG4gIHRoaXMucmVjdC55ID0gY3kgLSB0aGlzLnJlY3QuaGVpZ2h0IC8gMjtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5zZXRMb2NhdGlvbiA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gIHRoaXMucmVjdC54ID0geDtcbiAgdGhpcy5yZWN0LnkgPSB5O1xufTtcblxuTE5vZGUucHJvdG90eXBlLm1vdmVCeSA9IGZ1bmN0aW9uIChkeCwgZHkpIHtcbiAgdGhpcy5yZWN0LnggKz0gZHg7XG4gIHRoaXMucmVjdC55ICs9IGR5O1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldEVkZ2VMaXN0VG9Ob2RlID0gZnVuY3Rpb24gKHRvKSB7XG4gIHZhciBlZGdlTGlzdCA9IFtdO1xuICB2YXIgZWRnZTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHNlbGYuZWRnZXMuZm9yRWFjaChmdW5jdGlvbiAoZWRnZSkge1xuXG4gICAgaWYgKGVkZ2UudGFyZ2V0ID09IHRvKSB7XG4gICAgICBpZiAoZWRnZS5zb3VyY2UgIT0gc2VsZikgdGhyb3cgXCJJbmNvcnJlY3QgZWRnZSBzb3VyY2UhXCI7XG5cbiAgICAgIGVkZ2VMaXN0LnB1c2goZWRnZSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gZWRnZUxpc3Q7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0RWRnZXNCZXR3ZWVuID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gIHZhciBlZGdlTGlzdCA9IFtdO1xuICB2YXIgZWRnZTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNlbGYuZWRnZXMuZm9yRWFjaChmdW5jdGlvbiAoZWRnZSkge1xuXG4gICAgaWYgKCEoZWRnZS5zb3VyY2UgPT0gc2VsZiB8fCBlZGdlLnRhcmdldCA9PSBzZWxmKSkgdGhyb3cgXCJJbmNvcnJlY3QgZWRnZSBzb3VyY2UgYW5kL29yIHRhcmdldFwiO1xuXG4gICAgaWYgKGVkZ2UudGFyZ2V0ID09IG90aGVyIHx8IGVkZ2Uuc291cmNlID09IG90aGVyKSB7XG4gICAgICBlZGdlTGlzdC5wdXNoKGVkZ2UpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGVkZ2VMaXN0O1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldE5laWdoYm9yc0xpc3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBuZWlnaGJvcnMgPSBuZXcgU2V0KCk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLmVkZ2VzLmZvckVhY2goZnVuY3Rpb24gKGVkZ2UpIHtcblxuICAgIGlmIChlZGdlLnNvdXJjZSA9PSBzZWxmKSB7XG4gICAgICBuZWlnaGJvcnMuYWRkKGVkZ2UudGFyZ2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGVkZ2UudGFyZ2V0ICE9IHNlbGYpIHtcbiAgICAgICAgdGhyb3cgXCJJbmNvcnJlY3QgaW5jaWRlbmN5IVwiO1xuICAgICAgfVxuXG4gICAgICBuZWlnaGJvcnMuYWRkKGVkZ2Uuc291cmNlKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBuZWlnaGJvcnM7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUud2l0aENoaWxkcmVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgd2l0aE5laWdoYm9yc0xpc3QgPSBuZXcgU2V0KCk7XG4gIHZhciBjaGlsZE5vZGU7XG4gIHZhciBjaGlsZHJlbjtcblxuICB3aXRoTmVpZ2hib3JzTGlzdC5hZGQodGhpcyk7XG5cbiAgaWYgKHRoaXMuY2hpbGQgIT0gbnVsbCkge1xuICAgIHZhciBub2RlcyA9IHRoaXMuY2hpbGQuZ2V0Tm9kZXMoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZE5vZGUgPSBub2Rlc1tpXTtcbiAgICAgIGNoaWxkcmVuID0gY2hpbGROb2RlLndpdGhDaGlsZHJlbigpO1xuICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB3aXRoTmVpZ2hib3JzTGlzdC5hZGQobm9kZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gd2l0aE5laWdoYm9yc0xpc3Q7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0Tm9PZkNoaWxkcmVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm9PZkNoaWxkcmVuID0gMDtcbiAgdmFyIGNoaWxkTm9kZTtcblxuICBpZiAodGhpcy5jaGlsZCA9PSBudWxsKSB7XG4gICAgbm9PZkNoaWxkcmVuID0gMTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLmNoaWxkLmdldE5vZGVzKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGROb2RlID0gbm9kZXNbaV07XG5cbiAgICAgIG5vT2ZDaGlsZHJlbiArPSBjaGlsZE5vZGUuZ2V0Tm9PZkNoaWxkcmVuKCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG5vT2ZDaGlsZHJlbiA9PSAwKSB7XG4gICAgbm9PZkNoaWxkcmVuID0gMTtcbiAgfVxuICByZXR1cm4gbm9PZkNoaWxkcmVuO1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldEVzdGltYXRlZFNpemUgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmVzdGltYXRlZFNpemUgPT0gSW50ZWdlci5NSU5fVkFMVUUpIHtcbiAgICB0aHJvdyBcImFzc2VydCBmYWlsZWRcIjtcbiAgfVxuICByZXR1cm4gdGhpcy5lc3RpbWF0ZWRTaXplO1xufTtcblxuTE5vZGUucHJvdG90eXBlLmNhbGNFc3RpbWF0ZWRTaXplID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5jaGlsZCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuZXN0aW1hdGVkU2l6ZSA9ICh0aGlzLnJlY3Qud2lkdGggKyB0aGlzLnJlY3QuaGVpZ2h0KSAvIDI7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5lc3RpbWF0ZWRTaXplID0gdGhpcy5jaGlsZC5jYWxjRXN0aW1hdGVkU2l6ZSgpO1xuICAgIHRoaXMucmVjdC53aWR0aCA9IHRoaXMuZXN0aW1hdGVkU2l6ZTtcbiAgICB0aGlzLnJlY3QuaGVpZ2h0ID0gdGhpcy5lc3RpbWF0ZWRTaXplO1xuXG4gICAgcmV0dXJuIHRoaXMuZXN0aW1hdGVkU2l6ZTtcbiAgfVxufTtcblxuTE5vZGUucHJvdG90eXBlLnNjYXR0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciByYW5kb21DZW50ZXJYO1xuICB2YXIgcmFuZG9tQ2VudGVyWTtcblxuICB2YXIgbWluWCA9IC1MYXlvdXRDb25zdGFudHMuSU5JVElBTF9XT1JMRF9CT1VOREFSWTtcbiAgdmFyIG1heFggPSBMYXlvdXRDb25zdGFudHMuSU5JVElBTF9XT1JMRF9CT1VOREFSWTtcbiAgcmFuZG9tQ2VudGVyWCA9IExheW91dENvbnN0YW50cy5XT1JMRF9DRU5URVJfWCArIFJhbmRvbVNlZWQubmV4dERvdWJsZSgpICogKG1heFggLSBtaW5YKSArIG1pblg7XG5cbiAgdmFyIG1pblkgPSAtTGF5b3V0Q29uc3RhbnRzLklOSVRJQUxfV09STERfQk9VTkRBUlk7XG4gIHZhciBtYXhZID0gTGF5b3V0Q29uc3RhbnRzLklOSVRJQUxfV09STERfQk9VTkRBUlk7XG4gIHJhbmRvbUNlbnRlclkgPSBMYXlvdXRDb25zdGFudHMuV09STERfQ0VOVEVSX1kgKyBSYW5kb21TZWVkLm5leHREb3VibGUoKSAqIChtYXhZIC0gbWluWSkgKyBtaW5ZO1xuXG4gIHRoaXMucmVjdC54ID0gcmFuZG9tQ2VudGVyWDtcbiAgdGhpcy5yZWN0LnkgPSByYW5kb21DZW50ZXJZO1xufTtcblxuTE5vZGUucHJvdG90eXBlLnVwZGF0ZUJvdW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuZ2V0Q2hpbGQoKSA9PSBudWxsKSB7XG4gICAgdGhyb3cgXCJhc3NlcnQgZmFpbGVkXCI7XG4gIH1cbiAgaWYgKHRoaXMuZ2V0Q2hpbGQoKS5nZXROb2RlcygpLmxlbmd0aCAhPSAwKSB7XG4gICAgLy8gd3JhcCB0aGUgY2hpbGRyZW4gbm9kZXMgYnkgcmUtYXJyYW5naW5nIHRoZSBib3VuZGFyaWVzXG4gICAgdmFyIGNoaWxkR3JhcGggPSB0aGlzLmdldENoaWxkKCk7XG4gICAgY2hpbGRHcmFwaC51cGRhdGVCb3VuZHModHJ1ZSk7XG5cbiAgICB0aGlzLnJlY3QueCA9IGNoaWxkR3JhcGguZ2V0TGVmdCgpO1xuICAgIHRoaXMucmVjdC55ID0gY2hpbGRHcmFwaC5nZXRUb3AoKTtcblxuICAgIHRoaXMuc2V0V2lkdGgoY2hpbGRHcmFwaC5nZXRSaWdodCgpIC0gY2hpbGRHcmFwaC5nZXRMZWZ0KCkpO1xuICAgIHRoaXMuc2V0SGVpZ2h0KGNoaWxkR3JhcGguZ2V0Qm90dG9tKCkgLSBjaGlsZEdyYXBoLmdldFRvcCgpKTtcblxuICAgIC8vIFVwZGF0ZSBjb21wb3VuZCBib3VuZHMgY29uc2lkZXJpbmcgaXRzIGxhYmVsIHByb3BlcnRpZXMgICAgXG4gICAgaWYgKExheW91dENvbnN0YW50cy5OT0RFX0RJTUVOU0lPTlNfSU5DTFVERV9MQUJFTFMpIHtcblxuICAgICAgdmFyIHdpZHRoID0gY2hpbGRHcmFwaC5nZXRSaWdodCgpIC0gY2hpbGRHcmFwaC5nZXRMZWZ0KCk7XG4gICAgICB2YXIgaGVpZ2h0ID0gY2hpbGRHcmFwaC5nZXRCb3R0b20oKSAtIGNoaWxkR3JhcGguZ2V0VG9wKCk7XG5cbiAgICAgIGlmICh0aGlzLmxhYmVsV2lkdGggPiB3aWR0aCkge1xuICAgICAgICB0aGlzLnJlY3QueCAtPSAodGhpcy5sYWJlbFdpZHRoIC0gd2lkdGgpIC8gMjtcbiAgICAgICAgdGhpcy5zZXRXaWR0aCh0aGlzLmxhYmVsV2lkdGgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5sYWJlbEhlaWdodCA+IGhlaWdodCkge1xuICAgICAgICBpZiAodGhpcy5sYWJlbFBvcyA9PSBcImNlbnRlclwiKSB7XG4gICAgICAgICAgdGhpcy5yZWN0LnkgLT0gKHRoaXMubGFiZWxIZWlnaHQgLSBoZWlnaHQpIC8gMjtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmxhYmVsUG9zID09IFwidG9wXCIpIHtcbiAgICAgICAgICB0aGlzLnJlY3QueSAtPSB0aGlzLmxhYmVsSGVpZ2h0IC0gaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0SGVpZ2h0KHRoaXMubGFiZWxIZWlnaHQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuTE5vZGUucHJvdG90eXBlLmdldEluY2x1c2lvblRyZWVEZXB0aCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuaW5jbHVzaW9uVHJlZURlcHRoID09IEludGVnZXIuTUFYX1ZBTFVFKSB7XG4gICAgdGhyb3cgXCJhc3NlcnQgZmFpbGVkXCI7XG4gIH1cbiAgcmV0dXJuIHRoaXMuaW5jbHVzaW9uVHJlZURlcHRoO1xufTtcblxuTE5vZGUucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uICh0cmFucykge1xuICB2YXIgbGVmdCA9IHRoaXMucmVjdC54O1xuXG4gIGlmIChsZWZ0ID4gTGF5b3V0Q29uc3RhbnRzLldPUkxEX0JPVU5EQVJZKSB7XG4gICAgbGVmdCA9IExheW91dENvbnN0YW50cy5XT1JMRF9CT1VOREFSWTtcbiAgfSBlbHNlIGlmIChsZWZ0IDwgLUxheW91dENvbnN0YW50cy5XT1JMRF9CT1VOREFSWSkge1xuICAgIGxlZnQgPSAtTGF5b3V0Q29uc3RhbnRzLldPUkxEX0JPVU5EQVJZO1xuICB9XG5cbiAgdmFyIHRvcCA9IHRoaXMucmVjdC55O1xuXG4gIGlmICh0b3AgPiBMYXlvdXRDb25zdGFudHMuV09STERfQk9VTkRBUlkpIHtcbiAgICB0b3AgPSBMYXlvdXRDb25zdGFudHMuV09STERfQk9VTkRBUlk7XG4gIH0gZWxzZSBpZiAodG9wIDwgLUxheW91dENvbnN0YW50cy5XT1JMRF9CT1VOREFSWSkge1xuICAgIHRvcCA9IC1MYXlvdXRDb25zdGFudHMuV09STERfQk9VTkRBUlk7XG4gIH1cblxuICB2YXIgbGVmdFRvcCA9IG5ldyBQb2ludEQobGVmdCwgdG9wKTtcbiAgdmFyIHZMZWZ0VG9wID0gdHJhbnMuaW52ZXJzZVRyYW5zZm9ybVBvaW50KGxlZnRUb3ApO1xuXG4gIHRoaXMuc2V0TG9jYXRpb24odkxlZnRUb3AueCwgdkxlZnRUb3AueSk7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0TGVmdCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucmVjdC54O1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldFJpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5yZWN0LnggKyB0aGlzLnJlY3Qud2lkdGg7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0VG9wID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5yZWN0Lnk7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0Qm90dG9tID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5yZWN0LnkgKyB0aGlzLnJlY3QuaGVpZ2h0O1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldFBhcmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMub3duZXIgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMub3duZXIuZ2V0UGFyZW50KCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExOb2RlO1xuXG4vKioqLyB9KSxcbi8qIDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gUG9pbnREKHgsIHkpIHtcbiAgaWYgKHggPT0gbnVsbCAmJiB5ID09IG51bGwpIHtcbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMueSA9IDA7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICB9XG59XG5cblBvaW50RC5wcm90b3R5cGUuZ2V0WCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMueDtcbn07XG5cblBvaW50RC5wcm90b3R5cGUuZ2V0WSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMueTtcbn07XG5cblBvaW50RC5wcm90b3R5cGUuc2V0WCA9IGZ1bmN0aW9uICh4KSB7XG4gIHRoaXMueCA9IHg7XG59O1xuXG5Qb2ludEQucHJvdG90eXBlLnNldFkgPSBmdW5jdGlvbiAoeSkge1xuICB0aGlzLnkgPSB5O1xufTtcblxuUG9pbnRELnByb3RvdHlwZS5nZXREaWZmZXJlbmNlID0gZnVuY3Rpb24gKHB0KSB7XG4gIHJldHVybiBuZXcgRGltZW5zaW9uRCh0aGlzLnggLSBwdC54LCB0aGlzLnkgLSBwdC55KTtcbn07XG5cblBvaW50RC5wcm90b3R5cGUuZ2V0Q29weSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBQb2ludEQodGhpcy54LCB0aGlzLnkpO1xufTtcblxuUG9pbnRELnByb3RvdHlwZS50cmFuc2xhdGUgPSBmdW5jdGlvbiAoZGltKSB7XG4gIHRoaXMueCArPSBkaW0ud2lkdGg7XG4gIHRoaXMueSArPSBkaW0uaGVpZ2h0O1xuICByZXR1cm4gdGhpcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUG9pbnREO1xuXG4vKioqLyB9KSxcbi8qIDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIExHcmFwaE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG52YXIgSW50ZWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xudmFyIExheW91dENvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgTEdyYXBoTWFuYWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG52YXIgTE5vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xudmFyIExFZGdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbnZhciBSZWN0YW5nbGVEID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG52YXIgUG9pbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcbnZhciBMaW5rZWRMaXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cbmZ1bmN0aW9uIExHcmFwaChwYXJlbnQsIG9iajIsIHZHcmFwaCkge1xuICBMR3JhcGhPYmplY3QuY2FsbCh0aGlzLCB2R3JhcGgpO1xuICB0aGlzLmVzdGltYXRlZFNpemUgPSBJbnRlZ2VyLk1JTl9WQUxVRTtcbiAgdGhpcy5tYXJnaW4gPSBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9HUkFQSF9NQVJHSU47XG4gIHRoaXMuZWRnZXMgPSBbXTtcbiAgdGhpcy5ub2RlcyA9IFtdO1xuICB0aGlzLmlzQ29ubmVjdGVkID0gZmFsc2U7XG4gIHRoaXMucGFyZW50ID0gcGFyZW50O1xuXG4gIGlmIChvYmoyICE9IG51bGwgJiYgb2JqMiBpbnN0YW5jZW9mIExHcmFwaE1hbmFnZXIpIHtcbiAgICB0aGlzLmdyYXBoTWFuYWdlciA9IG9iajI7XG4gIH0gZWxzZSBpZiAob2JqMiAhPSBudWxsICYmIG9iajIgaW5zdGFuY2VvZiBMYXlvdXQpIHtcbiAgICB0aGlzLmdyYXBoTWFuYWdlciA9IG9iajIuZ3JhcGhNYW5hZ2VyO1xuICB9XG59XG5cbkxHcmFwaC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKExHcmFwaE9iamVjdC5wcm90b3R5cGUpO1xuZm9yICh2YXIgcHJvcCBpbiBMR3JhcGhPYmplY3QpIHtcbiAgTEdyYXBoW3Byb3BdID0gTEdyYXBoT2JqZWN0W3Byb3BdO1xufVxuXG5MR3JhcGgucHJvdG90eXBlLmdldE5vZGVzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ub2Rlcztcbn07XG5cbkxHcmFwaC5wcm90b3R5cGUuZ2V0RWRnZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmVkZ2VzO1xufTtcblxuTEdyYXBoLnByb3RvdHlwZS5nZXRHcmFwaE1hbmFnZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmdyYXBoTWFuYWdlcjtcbn07XG5cbkxHcmFwaC5wcm90b3R5cGUuZ2V0UGFyZW50ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5wYXJlbnQ7XG59O1xuXG5MR3JhcGgucHJvdG90eXBlLmdldExlZnQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmxlZnQ7XG59O1xuXG5MR3JhcGgucHJvdG90eXBlLmdldFJpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5yaWdodDtcbn07XG5cbkxHcmFwaC5wcm90b3R5cGUuZ2V0VG9wID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy50b3A7XG59O1xuXG5MR3JhcGgucHJvdG90eXBlLmdldEJvdHRvbSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuYm90dG9tO1xufTtcblxuTEdyYXBoLnByb3RvdHlwZS5pc0Nvbm5lY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuaXNDb25uZWN0ZWQ7XG59O1xuXG5MR3JhcGgucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChvYmoxLCBzb3VyY2VOb2RlLCB0YXJnZXROb2RlKSB7XG4gIGlmIChzb3VyY2VOb2RlID09IG51bGwgJiYgdGFyZ2V0Tm9kZSA9PSBudWxsKSB7XG4gICAgdmFyIG5ld05vZGUgPSBvYmoxO1xuICAgIGlmICh0aGlzLmdyYXBoTWFuYWdlciA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBcIkdyYXBoIGhhcyBubyBncmFwaCBtZ3IhXCI7XG4gICAgfVxuICAgIGlmICh0aGlzLmdldE5vZGVzKCkuaW5kZXhPZihuZXdOb2RlKSA+IC0xKSB7XG4gICAgICB0aHJvdyBcIk5vZGUgYWxyZWFkeSBpbiBncmFwaCFcIjtcbiAgICB9XG4gICAgbmV3Tm9kZS5vd25lciA9IHRoaXM7XG4gICAgdGhpcy5nZXROb2RlcygpLnB1c2gobmV3Tm9kZSk7XG5cbiAgICByZXR1cm4gbmV3Tm9kZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbmV3RWRnZSA9IG9iajE7XG4gICAgaWYgKCEodGhpcy5nZXROb2RlcygpLmluZGV4T2Yoc291cmNlTm9kZSkgPiAtMSAmJiB0aGlzLmdldE5vZGVzKCkuaW5kZXhPZih0YXJnZXROb2RlKSA+IC0xKSkge1xuICAgICAgdGhyb3cgXCJTb3VyY2Ugb3IgdGFyZ2V0IG5vdCBpbiBncmFwaCFcIjtcbiAgICB9XG5cbiAgICBpZiAoIShzb3VyY2VOb2RlLm93bmVyID09IHRhcmdldE5vZGUub3duZXIgJiYgc291cmNlTm9kZS5vd25lciA9PSB0aGlzKSkge1xuICAgICAgdGhyb3cgXCJCb3RoIG93bmVycyBtdXN0IGJlIHRoaXMgZ3JhcGghXCI7XG4gICAgfVxuXG4gICAgaWYgKHNvdXJjZU5vZGUub3duZXIgIT0gdGFyZ2V0Tm9kZS5vd25lcikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gc2V0IHNvdXJjZSBhbmQgdGFyZ2V0XG4gICAgbmV3RWRnZS5zb3VyY2UgPSBzb3VyY2VOb2RlO1xuICAgIG5ld0VkZ2UudGFyZ2V0ID0gdGFyZ2V0Tm9kZTtcblxuICAgIC8vIHNldCBhcyBpbnRyYS1ncmFwaCBlZGdlXG4gICAgbmV3RWRnZS5pc0ludGVyR3JhcGggPSBmYWxzZTtcblxuICAgIC8vIGFkZCB0byBncmFwaCBlZGdlIGxpc3RcbiAgICB0aGlzLmdldEVkZ2VzKCkucHVzaChuZXdFZGdlKTtcblxuICAgIC8vIGFkZCB0byBpbmNpZGVuY3kgbGlzdHNcbiAgICBzb3VyY2VOb2RlLmVkZ2VzLnB1c2gobmV3RWRnZSk7XG5cbiAgICBpZiAodGFyZ2V0Tm9kZSAhPSBzb3VyY2VOb2RlKSB7XG4gICAgICB0YXJnZXROb2RlLmVkZ2VzLnB1c2gobmV3RWRnZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld0VkZ2U7XG4gIH1cbn07XG5cbkxHcmFwaC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKG9iaikge1xuICB2YXIgbm9kZSA9IG9iajtcbiAgaWYgKG9iaiBpbnN0YW5jZW9mIExOb2RlKSB7XG4gICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgXCJOb2RlIGlzIG51bGwhXCI7XG4gICAgfVxuICAgIGlmICghKG5vZGUub3duZXIgIT0gbnVsbCAmJiBub2RlLm93bmVyID09IHRoaXMpKSB7XG4gICAgICB0aHJvdyBcIk93bmVyIGdyYXBoIGlzIGludmFsaWQhXCI7XG4gICAgfVxuICAgIGlmICh0aGlzLmdyYXBoTWFuYWdlciA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBcIk93bmVyIGdyYXBoIG1hbmFnZXIgaXMgaW52YWxpZCFcIjtcbiAgICB9XG4gICAgLy8gcmVtb3ZlIGluY2lkZW50IGVkZ2VzIGZpcnN0IChtYWtlIGEgY29weSB0byBkbyBpdCBzYWZlbHkpXG4gICAgdmFyIGVkZ2VzVG9CZVJlbW92ZWQgPSBub2RlLmVkZ2VzLnNsaWNlKCk7XG4gICAgdmFyIGVkZ2U7XG4gICAgdmFyIHMgPSBlZGdlc1RvQmVSZW1vdmVkLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKykge1xuICAgICAgZWRnZSA9IGVkZ2VzVG9CZVJlbW92ZWRbaV07XG5cbiAgICAgIGlmIChlZGdlLmlzSW50ZXJHcmFwaCkge1xuICAgICAgICB0aGlzLmdyYXBoTWFuYWdlci5yZW1vdmUoZWRnZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlZGdlLnNvdXJjZS5vd25lci5yZW1vdmUoZWRnZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gbm93IHRoZSBub2RlIGl0c2VsZlxuICAgIHZhciBpbmRleCA9IHRoaXMubm9kZXMuaW5kZXhPZihub2RlKTtcbiAgICBpZiAoaW5kZXggPT0gLTEpIHtcbiAgICAgIHRocm93IFwiTm9kZSBub3QgaW4gb3duZXIgbm9kZSBsaXN0IVwiO1xuICAgIH1cblxuICAgIHRoaXMubm9kZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgfSBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBMRWRnZSkge1xuICAgIHZhciBlZGdlID0gb2JqO1xuICAgIGlmIChlZGdlID09IG51bGwpIHtcbiAgICAgIHRocm93IFwiRWRnZSBpcyBudWxsIVwiO1xuICAgIH1cbiAgICBpZiAoIShlZGdlLnNvdXJjZSAhPSBudWxsICYmIGVkZ2UudGFyZ2V0ICE9IG51bGwpKSB7XG4gICAgICB0aHJvdyBcIlNvdXJjZSBhbmQvb3IgdGFyZ2V0IGlzIG51bGwhXCI7XG4gICAgfVxuICAgIGlmICghKGVkZ2Uuc291cmNlLm93bmVyICE9IG51bGwgJiYgZWRnZS50YXJnZXQub3duZXIgIT0gbnVsbCAmJiBlZGdlLnNvdXJjZS5vd25lciA9PSB0aGlzICYmIGVkZ2UudGFyZ2V0Lm93bmVyID09IHRoaXMpKSB7XG4gICAgICB0aHJvdyBcIlNvdXJjZSBhbmQvb3IgdGFyZ2V0IG93bmVyIGlzIGludmFsaWQhXCI7XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZUluZGV4ID0gZWRnZS5zb3VyY2UuZWRnZXMuaW5kZXhPZihlZGdlKTtcbiAgICB2YXIgdGFyZ2V0SW5kZXggPSBlZGdlLnRhcmdldC5lZGdlcy5pbmRleE9mKGVkZ2UpO1xuICAgIGlmICghKHNvdXJjZUluZGV4ID4gLTEgJiYgdGFyZ2V0SW5kZXggPiAtMSkpIHtcbiAgICAgIHRocm93IFwiU291cmNlIGFuZC9vciB0YXJnZXQgZG9lc24ndCBrbm93IHRoaXMgZWRnZSFcIjtcbiAgICB9XG5cbiAgICBlZGdlLnNvdXJjZS5lZGdlcy5zcGxpY2Uoc291cmNlSW5kZXgsIDEpO1xuXG4gICAgaWYgKGVkZ2UudGFyZ2V0ICE9IGVkZ2Uuc291cmNlKSB7XG4gICAgICBlZGdlLnRhcmdldC5lZGdlcy5zcGxpY2UodGFyZ2V0SW5kZXgsIDEpO1xuICAgIH1cblxuICAgIHZhciBpbmRleCA9IGVkZ2Uuc291cmNlLm93bmVyLmdldEVkZ2VzKCkuaW5kZXhPZihlZGdlKTtcbiAgICBpZiAoaW5kZXggPT0gLTEpIHtcbiAgICAgIHRocm93IFwiTm90IGluIG93bmVyJ3MgZWRnZSBsaXN0IVwiO1xuICAgIH1cblxuICAgIGVkZ2Uuc291cmNlLm93bmVyLmdldEVkZ2VzKCkuc3BsaWNlKGluZGV4LCAxKTtcbiAgfVxufTtcblxuTEdyYXBoLnByb3RvdHlwZS51cGRhdGVMZWZ0VG9wID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdG9wID0gSW50ZWdlci5NQVhfVkFMVUU7XG4gIHZhciBsZWZ0ID0gSW50ZWdlci5NQVhfVkFMVUU7XG4gIHZhciBub2RlVG9wO1xuICB2YXIgbm9kZUxlZnQ7XG4gIHZhciBtYXJnaW47XG5cbiAgdmFyIG5vZGVzID0gdGhpcy5nZXROb2RlcygpO1xuICB2YXIgcyA9IG5vZGVzLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKykge1xuICAgIHZhciBsTm9kZSA9IG5vZGVzW2ldO1xuICAgIG5vZGVUb3AgPSBsTm9kZS5nZXRUb3AoKTtcbiAgICBub2RlTGVmdCA9IGxOb2RlLmdldExlZnQoKTtcblxuICAgIGlmICh0b3AgPiBub2RlVG9wKSB7XG4gICAgICB0b3AgPSBub2RlVG9wO1xuICAgIH1cblxuICAgIGlmIChsZWZ0ID4gbm9kZUxlZnQpIHtcbiAgICAgIGxlZnQgPSBub2RlTGVmdDtcbiAgICB9XG4gIH1cblxuICAvLyBEbyB3ZSBoYXZlIGFueSBub2RlcyBpbiB0aGlzIGdyYXBoP1xuICBpZiAodG9wID09IEludGVnZXIuTUFYX1ZBTFVFKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAobm9kZXNbMF0uZ2V0UGFyZW50KCkucGFkZGluZ0xlZnQgIT0gdW5kZWZpbmVkKSB7XG4gICAgbWFyZ2luID0gbm9kZXNbMF0uZ2V0UGFyZW50KCkucGFkZGluZ0xlZnQ7XG4gIH0gZWxzZSB7XG4gICAgbWFyZ2luID0gdGhpcy5tYXJnaW47XG4gIH1cblxuICB0aGlzLmxlZnQgPSBsZWZ0IC0gbWFyZ2luO1xuICB0aGlzLnRvcCA9IHRvcCAtIG1hcmdpbjtcblxuICAvLyBBcHBseSB0aGUgbWFyZ2lucyBhbmQgcmV0dXJuIHRoZSByZXN1bHRcbiAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLmxlZnQsIHRoaXMudG9wKTtcbn07XG5cbkxHcmFwaC5wcm90b3R5cGUudXBkYXRlQm91bmRzID0gZnVuY3Rpb24gKHJlY3Vyc2l2ZSkge1xuICAvLyBjYWxjdWxhdGUgYm91bmRzXG4gIHZhciBsZWZ0ID0gSW50ZWdlci5NQVhfVkFMVUU7XG4gIHZhciByaWdodCA9IC1JbnRlZ2VyLk1BWF9WQUxVRTtcbiAgdmFyIHRvcCA9IEludGVnZXIuTUFYX1ZBTFVFO1xuICB2YXIgYm90dG9tID0gLUludGVnZXIuTUFYX1ZBTFVFO1xuICB2YXIgbm9kZUxlZnQ7XG4gIHZhciBub2RlUmlnaHQ7XG4gIHZhciBub2RlVG9wO1xuICB2YXIgbm9kZUJvdHRvbTtcbiAgdmFyIG1hcmdpbjtcblxuICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzO1xuICB2YXIgcyA9IG5vZGVzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICB2YXIgbE5vZGUgPSBub2Rlc1tpXTtcblxuICAgIGlmIChyZWN1cnNpdmUgJiYgbE5vZGUuY2hpbGQgIT0gbnVsbCkge1xuICAgICAgbE5vZGUudXBkYXRlQm91bmRzKCk7XG4gICAgfVxuICAgIG5vZGVMZWZ0ID0gbE5vZGUuZ2V0TGVmdCgpO1xuICAgIG5vZGVSaWdodCA9IGxOb2RlLmdldFJpZ2h0KCk7XG4gICAgbm9kZVRvcCA9IGxOb2RlLmdldFRvcCgpO1xuICAgIG5vZGVCb3R0b20gPSBsTm9kZS5nZXRCb3R0b20oKTtcblxuICAgIGlmIChsZWZ0ID4gbm9kZUxlZnQpIHtcbiAgICAgIGxlZnQgPSBub2RlTGVmdDtcbiAgICB9XG5cbiAgICBpZiAocmlnaHQgPCBub2RlUmlnaHQpIHtcbiAgICAgIHJpZ2h0ID0gbm9kZVJpZ2h0O1xuICAgIH1cblxuICAgIGlmICh0b3AgPiBub2RlVG9wKSB7XG4gICAgICB0b3AgPSBub2RlVG9wO1xuICAgIH1cblxuICAgIGlmIChib3R0b20gPCBub2RlQm90dG9tKSB7XG4gICAgICBib3R0b20gPSBub2RlQm90dG9tO1xuICAgIH1cbiAgfVxuXG4gIHZhciBib3VuZGluZ1JlY3QgPSBuZXcgUmVjdGFuZ2xlRChsZWZ0LCB0b3AsIHJpZ2h0IC0gbGVmdCwgYm90dG9tIC0gdG9wKTtcbiAgaWYgKGxlZnQgPT0gSW50ZWdlci5NQVhfVkFMVUUpIHtcbiAgICB0aGlzLmxlZnQgPSB0aGlzLnBhcmVudC5nZXRMZWZ0KCk7XG4gICAgdGhpcy5yaWdodCA9IHRoaXMucGFyZW50LmdldFJpZ2h0KCk7XG4gICAgdGhpcy50b3AgPSB0aGlzLnBhcmVudC5nZXRUb3AoKTtcbiAgICB0aGlzLmJvdHRvbSA9IHRoaXMucGFyZW50LmdldEJvdHRvbSgpO1xuICB9XG5cbiAgaWYgKG5vZGVzWzBdLmdldFBhcmVudCgpLnBhZGRpbmdMZWZ0ICE9IHVuZGVmaW5lZCkge1xuICAgIG1hcmdpbiA9IG5vZGVzWzBdLmdldFBhcmVudCgpLnBhZGRpbmdMZWZ0O1xuICB9IGVsc2Uge1xuICAgIG1hcmdpbiA9IHRoaXMubWFyZ2luO1xuICB9XG5cbiAgdGhpcy5sZWZ0ID0gYm91bmRpbmdSZWN0LnggLSBtYXJnaW47XG4gIHRoaXMucmlnaHQgPSBib3VuZGluZ1JlY3QueCArIGJvdW5kaW5nUmVjdC53aWR0aCArIG1hcmdpbjtcbiAgdGhpcy50b3AgPSBib3VuZGluZ1JlY3QueSAtIG1hcmdpbjtcbiAgdGhpcy5ib3R0b20gPSBib3VuZGluZ1JlY3QueSArIGJvdW5kaW5nUmVjdC5oZWlnaHQgKyBtYXJnaW47XG59O1xuXG5MR3JhcGguY2FsY3VsYXRlQm91bmRzID0gZnVuY3Rpb24gKG5vZGVzKSB7XG4gIHZhciBsZWZ0ID0gSW50ZWdlci5NQVhfVkFMVUU7XG4gIHZhciByaWdodCA9IC1JbnRlZ2VyLk1BWF9WQUxVRTtcbiAgdmFyIHRvcCA9IEludGVnZXIuTUFYX1ZBTFVFO1xuICB2YXIgYm90dG9tID0gLUludGVnZXIuTUFYX1ZBTFVFO1xuICB2YXIgbm9kZUxlZnQ7XG4gIHZhciBub2RlUmlnaHQ7XG4gIHZhciBub2RlVG9wO1xuICB2YXIgbm9kZUJvdHRvbTtcblxuICB2YXIgcyA9IG5vZGVzLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKykge1xuICAgIHZhciBsTm9kZSA9IG5vZGVzW2ldO1xuICAgIG5vZGVMZWZ0ID0gbE5vZGUuZ2V0TGVmdCgpO1xuICAgIG5vZGVSaWdodCA9IGxOb2RlLmdldFJpZ2h0KCk7XG4gICAgbm9kZVRvcCA9IGxOb2RlLmdldFRvcCgpO1xuICAgIG5vZGVCb3R0b20gPSBsTm9kZS5nZXRCb3R0b20oKTtcblxuICAgIGlmIChsZWZ0ID4gbm9kZUxlZnQpIHtcbiAgICAgIGxlZnQgPSBub2RlTGVmdDtcbiAgICB9XG5cbiAgICBpZiAocmlnaHQgPCBub2RlUmlnaHQpIHtcbiAgICAgIHJpZ2h0ID0gbm9kZVJpZ2h0O1xuICAgIH1cblxuICAgIGlmICh0b3AgPiBub2RlVG9wKSB7XG4gICAgICB0b3AgPSBub2RlVG9wO1xuICAgIH1cblxuICAgIGlmIChib3R0b20gPCBub2RlQm90dG9tKSB7XG4gICAgICBib3R0b20gPSBub2RlQm90dG9tO1xuICAgIH1cbiAgfVxuXG4gIHZhciBib3VuZGluZ1JlY3QgPSBuZXcgUmVjdGFuZ2xlRChsZWZ0LCB0b3AsIHJpZ2h0IC0gbGVmdCwgYm90dG9tIC0gdG9wKTtcblxuICByZXR1cm4gYm91bmRpbmdSZWN0O1xufTtcblxuTEdyYXBoLnByb3RvdHlwZS5nZXRJbmNsdXNpb25UcmVlRGVwdGggPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzID09IHRoaXMuZ3JhcGhNYW5hZ2VyLmdldFJvb3QoKSkge1xuICAgIHJldHVybiAxO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLnBhcmVudC5nZXRJbmNsdXNpb25UcmVlRGVwdGgoKTtcbiAgfVxufTtcblxuTEdyYXBoLnByb3RvdHlwZS5nZXRFc3RpbWF0ZWRTaXplID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5lc3RpbWF0ZWRTaXplID09IEludGVnZXIuTUlOX1ZBTFVFKSB7XG4gICAgdGhyb3cgXCJhc3NlcnQgZmFpbGVkXCI7XG4gIH1cbiAgcmV0dXJuIHRoaXMuZXN0aW1hdGVkU2l6ZTtcbn07XG5cbkxHcmFwaC5wcm90b3R5cGUuY2FsY0VzdGltYXRlZFNpemUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzaXplID0gMDtcbiAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcztcbiAgdmFyIHMgPSBub2Rlcy5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICB2YXIgbE5vZGUgPSBub2Rlc1tpXTtcbiAgICBzaXplICs9IGxOb2RlLmNhbGNFc3RpbWF0ZWRTaXplKCk7XG4gIH1cblxuICBpZiAoc2l6ZSA9PSAwKSB7XG4gICAgdGhpcy5lc3RpbWF0ZWRTaXplID0gTGF5b3V0Q29uc3RhbnRzLkVNUFRZX0NPTVBPVU5EX05PREVfU0laRTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmVzdGltYXRlZFNpemUgPSBzaXplIC8gTWF0aC5zcXJ0KHRoaXMubm9kZXMubGVuZ3RoKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmVzdGltYXRlZFNpemU7XG59O1xuXG5MR3JhcGgucHJvdG90eXBlLnVwZGF0ZUNvbm5lY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAodGhpcy5ub2Rlcy5sZW5ndGggPT0gMCkge1xuICAgIHRoaXMuaXNDb25uZWN0ZWQgPSB0cnVlO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBxdWV1ZSA9IG5ldyBMaW5rZWRMaXN0KCk7XG4gIHZhciB2aXNpdGVkID0gbmV3IFNldCgpO1xuICB2YXIgY3VycmVudE5vZGUgPSB0aGlzLm5vZGVzWzBdO1xuICB2YXIgbmVpZ2hib3JFZGdlcztcbiAgdmFyIGN1cnJlbnROZWlnaGJvcjtcbiAgdmFyIGNoaWxkcmVuT2ZOb2RlID0gY3VycmVudE5vZGUud2l0aENoaWxkcmVuKCk7XG4gIGNoaWxkcmVuT2ZOb2RlLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBxdWV1ZS5wdXNoKG5vZGUpO1xuICAgIHZpc2l0ZWQuYWRkKG5vZGUpO1xuICB9KTtcblxuICB3aGlsZSAocXVldWUubGVuZ3RoICE9PSAwKSB7XG4gICAgY3VycmVudE5vZGUgPSBxdWV1ZS5zaGlmdCgpO1xuXG4gICAgLy8gVHJhdmVyc2UgYWxsIG5laWdoYm9ycyBvZiB0aGlzIG5vZGVcbiAgICBuZWlnaGJvckVkZ2VzID0gY3VycmVudE5vZGUuZ2V0RWRnZXMoKTtcbiAgICB2YXIgc2l6ZSA9IG5laWdoYm9yRWRnZXMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICB2YXIgbmVpZ2hib3JFZGdlID0gbmVpZ2hib3JFZGdlc1tpXTtcbiAgICAgIGN1cnJlbnROZWlnaGJvciA9IG5laWdoYm9yRWRnZS5nZXRPdGhlckVuZEluR3JhcGgoY3VycmVudE5vZGUsIHRoaXMpO1xuXG4gICAgICAvLyBBZGQgdW52aXNpdGVkIG5laWdoYm9ycyB0byB0aGUgbGlzdCB0byB2aXNpdFxuICAgICAgaWYgKGN1cnJlbnROZWlnaGJvciAhPSBudWxsICYmICF2aXNpdGVkLmhhcyhjdXJyZW50TmVpZ2hib3IpKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbk9mTmVpZ2hib3IgPSBjdXJyZW50TmVpZ2hib3Iud2l0aENoaWxkcmVuKCk7XG5cbiAgICAgICAgY2hpbGRyZW5PZk5laWdoYm9yLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICBxdWV1ZS5wdXNoKG5vZGUpO1xuICAgICAgICAgIHZpc2l0ZWQuYWRkKG5vZGUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0aGlzLmlzQ29ubmVjdGVkID0gZmFsc2U7XG5cbiAgaWYgKHZpc2l0ZWQuc2l6ZSA+PSB0aGlzLm5vZGVzLmxlbmd0aCkge1xuICAgIHZhciBub09mVmlzaXRlZEluVGhpc0dyYXBoID0gMDtcblxuICAgIHZpc2l0ZWQuZm9yRWFjaChmdW5jdGlvbiAodmlzaXRlZE5vZGUpIHtcbiAgICAgIGlmICh2aXNpdGVkTm9kZS5vd25lciA9PSBzZWxmKSB7XG4gICAgICAgIG5vT2ZWaXNpdGVkSW5UaGlzR3JhcGgrKztcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChub09mVmlzaXRlZEluVGhpc0dyYXBoID09IHRoaXMubm9kZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmlzQ29ubmVjdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTEdyYXBoO1xuXG4vKioqLyB9KSxcbi8qIDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIExHcmFwaDtcbnZhciBMRWRnZSA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbmZ1bmN0aW9uIExHcmFwaE1hbmFnZXIobGF5b3V0KSB7XG4gIExHcmFwaCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7IC8vIEl0IG1heSBiZSBiZXR0ZXIgdG8gaW5pdGlsaXplIHRoaXMgb3V0IG9mIHRoaXMgZnVuY3Rpb24gYnV0IGl0IGdpdmVzIGFuIGVycm9yIChSaWdodC1oYW5kIHNpZGUgb2YgJ2luc3RhbmNlb2YnIGlzIG5vdCBjYWxsYWJsZSkgbm93LlxuICB0aGlzLmxheW91dCA9IGxheW91dDtcblxuICB0aGlzLmdyYXBocyA9IFtdO1xuICB0aGlzLmVkZ2VzID0gW107XG59XG5cbkxHcmFwaE1hbmFnZXIucHJvdG90eXBlLmFkZFJvb3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBuZ3JhcGggPSB0aGlzLmxheW91dC5uZXdHcmFwaCgpO1xuICB2YXIgbm5vZGUgPSB0aGlzLmxheW91dC5uZXdOb2RlKG51bGwpO1xuICB2YXIgcm9vdCA9IHRoaXMuYWRkKG5ncmFwaCwgbm5vZGUpO1xuICB0aGlzLnNldFJvb3RHcmFwaChyb290KTtcbiAgcmV0dXJuIHRoaXMucm9vdEdyYXBoO1xufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKG5ld0dyYXBoLCBwYXJlbnROb2RlLCBuZXdFZGdlLCBzb3VyY2VOb2RlLCB0YXJnZXROb2RlKSB7XG4gIC8vdGhlcmUgYXJlIGp1c3QgMiBwYXJhbWV0ZXJzIGFyZSBwYXNzZWQgdGhlbiBpdCBhZGRzIGFuIExHcmFwaCBlbHNlIGl0IGFkZHMgYW4gTEVkZ2VcbiAgaWYgKG5ld0VkZ2UgPT0gbnVsbCAmJiBzb3VyY2VOb2RlID09IG51bGwgJiYgdGFyZ2V0Tm9kZSA9PSBudWxsKSB7XG4gICAgaWYgKG5ld0dyYXBoID09IG51bGwpIHtcbiAgICAgIHRocm93IFwiR3JhcGggaXMgbnVsbCFcIjtcbiAgICB9XG4gICAgaWYgKHBhcmVudE5vZGUgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgXCJQYXJlbnQgbm9kZSBpcyBudWxsIVwiO1xuICAgIH1cbiAgICBpZiAodGhpcy5ncmFwaHMuaW5kZXhPZihuZXdHcmFwaCkgPiAtMSkge1xuICAgICAgdGhyb3cgXCJHcmFwaCBhbHJlYWR5IGluIHRoaXMgZ3JhcGggbWdyIVwiO1xuICAgIH1cblxuICAgIHRoaXMuZ3JhcGhzLnB1c2gobmV3R3JhcGgpO1xuXG4gICAgaWYgKG5ld0dyYXBoLnBhcmVudCAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBcIkFscmVhZHkgaGFzIGEgcGFyZW50IVwiO1xuICAgIH1cbiAgICBpZiAocGFyZW50Tm9kZS5jaGlsZCAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBcIkFscmVhZHkgaGFzIGEgY2hpbGQhXCI7XG4gICAgfVxuXG4gICAgbmV3R3JhcGgucGFyZW50ID0gcGFyZW50Tm9kZTtcbiAgICBwYXJlbnROb2RlLmNoaWxkID0gbmV3R3JhcGg7XG5cbiAgICByZXR1cm4gbmV3R3JhcGg7XG4gIH0gZWxzZSB7XG4gICAgLy9jaGFuZ2UgdGhlIG9yZGVyIG9mIHRoZSBwYXJhbWV0ZXJzXG4gICAgdGFyZ2V0Tm9kZSA9IG5ld0VkZ2U7XG4gICAgc291cmNlTm9kZSA9IHBhcmVudE5vZGU7XG4gICAgbmV3RWRnZSA9IG5ld0dyYXBoO1xuICAgIHZhciBzb3VyY2VHcmFwaCA9IHNvdXJjZU5vZGUuZ2V0T3duZXIoKTtcbiAgICB2YXIgdGFyZ2V0R3JhcGggPSB0YXJnZXROb2RlLmdldE93bmVyKCk7XG5cbiAgICBpZiAoIShzb3VyY2VHcmFwaCAhPSBudWxsICYmIHNvdXJjZUdyYXBoLmdldEdyYXBoTWFuYWdlcigpID09IHRoaXMpKSB7XG4gICAgICB0aHJvdyBcIlNvdXJjZSBub3QgaW4gdGhpcyBncmFwaCBtZ3IhXCI7XG4gICAgfVxuICAgIGlmICghKHRhcmdldEdyYXBoICE9IG51bGwgJiYgdGFyZ2V0R3JhcGguZ2V0R3JhcGhNYW5hZ2VyKCkgPT0gdGhpcykpIHtcbiAgICAgIHRocm93IFwiVGFyZ2V0IG5vdCBpbiB0aGlzIGdyYXBoIG1nciFcIjtcbiAgICB9XG5cbiAgICBpZiAoc291cmNlR3JhcGggPT0gdGFyZ2V0R3JhcGgpIHtcbiAgICAgIG5ld0VkZ2UuaXNJbnRlckdyYXBoID0gZmFsc2U7XG4gICAgICByZXR1cm4gc291cmNlR3JhcGguYWRkKG5ld0VkZ2UsIHNvdXJjZU5vZGUsIHRhcmdldE5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdFZGdlLmlzSW50ZXJHcmFwaCA9IHRydWU7XG5cbiAgICAgIC8vIHNldCBzb3VyY2UgYW5kIHRhcmdldFxuICAgICAgbmV3RWRnZS5zb3VyY2UgPSBzb3VyY2VOb2RlO1xuICAgICAgbmV3RWRnZS50YXJnZXQgPSB0YXJnZXROb2RlO1xuXG4gICAgICAvLyBhZGQgZWRnZSB0byBpbnRlci1ncmFwaCBlZGdlIGxpc3RcbiAgICAgIGlmICh0aGlzLmVkZ2VzLmluZGV4T2YobmV3RWRnZSkgPiAtMSkge1xuICAgICAgICB0aHJvdyBcIkVkZ2UgYWxyZWFkeSBpbiBpbnRlci1ncmFwaCBlZGdlIGxpc3QhXCI7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZWRnZXMucHVzaChuZXdFZGdlKTtcblxuICAgICAgLy8gYWRkIGVkZ2UgdG8gc291cmNlIGFuZCB0YXJnZXQgaW5jaWRlbmN5IGxpc3RzXG4gICAgICBpZiAoIShuZXdFZGdlLnNvdXJjZSAhPSBudWxsICYmIG5ld0VkZ2UudGFyZ2V0ICE9IG51bGwpKSB7XG4gICAgICAgIHRocm93IFwiRWRnZSBzb3VyY2UgYW5kL29yIHRhcmdldCBpcyBudWxsIVwiO1xuICAgICAgfVxuXG4gICAgICBpZiAoIShuZXdFZGdlLnNvdXJjZS5lZGdlcy5pbmRleE9mKG5ld0VkZ2UpID09IC0xICYmIG5ld0VkZ2UudGFyZ2V0LmVkZ2VzLmluZGV4T2YobmV3RWRnZSkgPT0gLTEpKSB7XG4gICAgICAgIHRocm93IFwiRWRnZSBhbHJlYWR5IGluIHNvdXJjZSBhbmQvb3IgdGFyZ2V0IGluY2lkZW5jeSBsaXN0IVwiO1xuICAgICAgfVxuXG4gICAgICBuZXdFZGdlLnNvdXJjZS5lZGdlcy5wdXNoKG5ld0VkZ2UpO1xuICAgICAgbmV3RWRnZS50YXJnZXQuZWRnZXMucHVzaChuZXdFZGdlKTtcblxuICAgICAgcmV0dXJuIG5ld0VkZ2U7XG4gICAgfVxuICB9XG59O1xuXG5MR3JhcGhNYW5hZ2VyLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAobE9iaikge1xuICBpZiAobE9iaiBpbnN0YW5jZW9mIExHcmFwaCkge1xuICAgIHZhciBncmFwaCA9IGxPYmo7XG4gICAgaWYgKGdyYXBoLmdldEdyYXBoTWFuYWdlcigpICE9IHRoaXMpIHtcbiAgICAgIHRocm93IFwiR3JhcGggbm90IGluIHRoaXMgZ3JhcGggbWdyXCI7XG4gICAgfVxuICAgIGlmICghKGdyYXBoID09IHRoaXMucm9vdEdyYXBoIHx8IGdyYXBoLnBhcmVudCAhPSBudWxsICYmIGdyYXBoLnBhcmVudC5ncmFwaE1hbmFnZXIgPT0gdGhpcykpIHtcbiAgICAgIHRocm93IFwiSW52YWxpZCBwYXJlbnQgbm9kZSFcIjtcbiAgICB9XG5cbiAgICAvLyBmaXJzdCB0aGUgZWRnZXMgKG1ha2UgYSBjb3B5IHRvIGRvIGl0IHNhZmVseSlcbiAgICB2YXIgZWRnZXNUb0JlUmVtb3ZlZCA9IFtdO1xuXG4gICAgZWRnZXNUb0JlUmVtb3ZlZCA9IGVkZ2VzVG9CZVJlbW92ZWQuY29uY2F0KGdyYXBoLmdldEVkZ2VzKCkpO1xuXG4gICAgdmFyIGVkZ2U7XG4gICAgdmFyIHMgPSBlZGdlc1RvQmVSZW1vdmVkLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKykge1xuICAgICAgZWRnZSA9IGVkZ2VzVG9CZVJlbW92ZWRbaV07XG4gICAgICBncmFwaC5yZW1vdmUoZWRnZSk7XG4gICAgfVxuXG4gICAgLy8gdGhlbiB0aGUgbm9kZXMgKG1ha2UgYSBjb3B5IHRvIGRvIGl0IHNhZmVseSlcbiAgICB2YXIgbm9kZXNUb0JlUmVtb3ZlZCA9IFtdO1xuXG4gICAgbm9kZXNUb0JlUmVtb3ZlZCA9IG5vZGVzVG9CZVJlbW92ZWQuY29uY2F0KGdyYXBoLmdldE5vZGVzKCkpO1xuXG4gICAgdmFyIG5vZGU7XG4gICAgcyA9IG5vZGVzVG9CZVJlbW92ZWQubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgICBub2RlID0gbm9kZXNUb0JlUmVtb3ZlZFtpXTtcbiAgICAgIGdyYXBoLnJlbW92ZShub2RlKTtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBpZiBncmFwaCBpcyB0aGUgcm9vdFxuICAgIGlmIChncmFwaCA9PSB0aGlzLnJvb3RHcmFwaCkge1xuICAgICAgdGhpcy5zZXRSb290R3JhcGgobnVsbCk7XG4gICAgfVxuXG4gICAgLy8gbm93IHJlbW92ZSB0aGUgZ3JhcGggaXRzZWxmXG4gICAgdmFyIGluZGV4ID0gdGhpcy5ncmFwaHMuaW5kZXhPZihncmFwaCk7XG4gICAgdGhpcy5ncmFwaHMuc3BsaWNlKGluZGV4LCAxKTtcblxuICAgIC8vIGFsc28gcmVzZXQgdGhlIHBhcmVudCBvZiB0aGUgZ3JhcGhcbiAgICBncmFwaC5wYXJlbnQgPSBudWxsO1xuICB9IGVsc2UgaWYgKGxPYmogaW5zdGFuY2VvZiBMRWRnZSkge1xuICAgIGVkZ2UgPSBsT2JqO1xuICAgIGlmIChlZGdlID09IG51bGwpIHtcbiAgICAgIHRocm93IFwiRWRnZSBpcyBudWxsIVwiO1xuICAgIH1cbiAgICBpZiAoIWVkZ2UuaXNJbnRlckdyYXBoKSB7XG4gICAgICB0aHJvdyBcIk5vdCBhbiBpbnRlci1ncmFwaCBlZGdlIVwiO1xuICAgIH1cbiAgICBpZiAoIShlZGdlLnNvdXJjZSAhPSBudWxsICYmIGVkZ2UudGFyZ2V0ICE9IG51bGwpKSB7XG4gICAgICB0aHJvdyBcIlNvdXJjZSBhbmQvb3IgdGFyZ2V0IGlzIG51bGwhXCI7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGVkZ2UgZnJvbSBzb3VyY2UgYW5kIHRhcmdldCBub2RlcycgaW5jaWRlbmN5IGxpc3RzXG5cbiAgICBpZiAoIShlZGdlLnNvdXJjZS5lZGdlcy5pbmRleE9mKGVkZ2UpICE9IC0xICYmIGVkZ2UudGFyZ2V0LmVkZ2VzLmluZGV4T2YoZWRnZSkgIT0gLTEpKSB7XG4gICAgICB0aHJvdyBcIlNvdXJjZSBhbmQvb3IgdGFyZ2V0IGRvZXNuJ3Qga25vdyB0aGlzIGVkZ2UhXCI7XG4gICAgfVxuXG4gICAgdmFyIGluZGV4ID0gZWRnZS5zb3VyY2UuZWRnZXMuaW5kZXhPZihlZGdlKTtcbiAgICBlZGdlLnNvdXJjZS5lZGdlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIGluZGV4ID0gZWRnZS50YXJnZXQuZWRnZXMuaW5kZXhPZihlZGdlKTtcbiAgICBlZGdlLnRhcmdldC5lZGdlcy5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgLy8gcmVtb3ZlIGVkZ2UgZnJvbSBvd25lciBncmFwaCBtYW5hZ2VyJ3MgaW50ZXItZ3JhcGggZWRnZSBsaXN0XG5cbiAgICBpZiAoIShlZGdlLnNvdXJjZS5vd25lciAhPSBudWxsICYmIGVkZ2Uuc291cmNlLm93bmVyLmdldEdyYXBoTWFuYWdlcigpICE9IG51bGwpKSB7XG4gICAgICB0aHJvdyBcIkVkZ2Ugb3duZXIgZ3JhcGggb3Igb3duZXIgZ3JhcGggbWFuYWdlciBpcyBudWxsIVwiO1xuICAgIH1cbiAgICBpZiAoZWRnZS5zb3VyY2Uub3duZXIuZ2V0R3JhcGhNYW5hZ2VyKCkuZWRnZXMuaW5kZXhPZihlZGdlKSA9PSAtMSkge1xuICAgICAgdGhyb3cgXCJOb3QgaW4gb3duZXIgZ3JhcGggbWFuYWdlcidzIGVkZ2UgbGlzdCFcIjtcbiAgICB9XG5cbiAgICB2YXIgaW5kZXggPSBlZGdlLnNvdXJjZS5vd25lci5nZXRHcmFwaE1hbmFnZXIoKS5lZGdlcy5pbmRleE9mKGVkZ2UpO1xuICAgIGVkZ2Uuc291cmNlLm93bmVyLmdldEdyYXBoTWFuYWdlcigpLmVkZ2VzLnNwbGljZShpbmRleCwgMSk7XG4gIH1cbn07XG5cbkxHcmFwaE1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZUJvdW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5yb290R3JhcGgudXBkYXRlQm91bmRzKHRydWUpO1xufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUuZ2V0R3JhcGhzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ncmFwaHM7XG59O1xuXG5MR3JhcGhNYW5hZ2VyLnByb3RvdHlwZS5nZXRBbGxOb2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuYWxsTm9kZXMgPT0gbnVsbCkge1xuICAgIHZhciBub2RlTGlzdCA9IFtdO1xuICAgIHZhciBncmFwaHMgPSB0aGlzLmdldEdyYXBocygpO1xuICAgIHZhciBzID0gZ3JhcGhzLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKykge1xuICAgICAgbm9kZUxpc3QgPSBub2RlTGlzdC5jb25jYXQoZ3JhcGhzW2ldLmdldE5vZGVzKCkpO1xuICAgIH1cbiAgICB0aGlzLmFsbE5vZGVzID0gbm9kZUxpc3Q7XG4gIH1cbiAgcmV0dXJuIHRoaXMuYWxsTm9kZXM7XG59O1xuXG5MR3JhcGhNYW5hZ2VyLnByb3RvdHlwZS5yZXNldEFsbE5vZGVzID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmFsbE5vZGVzID0gbnVsbDtcbn07XG5cbkxHcmFwaE1hbmFnZXIucHJvdG90eXBlLnJlc2V0QWxsRWRnZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuYWxsRWRnZXMgPSBudWxsO1xufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUucmVzZXRBbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5hbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbiA9IG51bGw7XG59O1xuXG5MR3JhcGhNYW5hZ2VyLnByb3RvdHlwZS5nZXRBbGxFZGdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuYWxsRWRnZXMgPT0gbnVsbCkge1xuICAgIHZhciBlZGdlTGlzdCA9IFtdO1xuICAgIHZhciBncmFwaHMgPSB0aGlzLmdldEdyYXBocygpO1xuICAgIHZhciBzID0gZ3JhcGhzLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyYXBocy5sZW5ndGg7IGkrKykge1xuICAgICAgZWRnZUxpc3QgPSBlZGdlTGlzdC5jb25jYXQoZ3JhcGhzW2ldLmdldEVkZ2VzKCkpO1xuICAgIH1cblxuICAgIGVkZ2VMaXN0ID0gZWRnZUxpc3QuY29uY2F0KHRoaXMuZWRnZXMpO1xuXG4gICAgdGhpcy5hbGxFZGdlcyA9IGVkZ2VMaXN0O1xuICB9XG4gIHJldHVybiB0aGlzLmFsbEVkZ2VzO1xufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUuZ2V0QWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmFsbE5vZGVzVG9BcHBseUdyYXZpdGF0aW9uO1xufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUuc2V0QWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24gPSBmdW5jdGlvbiAobm9kZUxpc3QpIHtcbiAgaWYgKHRoaXMuYWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24gIT0gbnVsbCkge1xuICAgIHRocm93IFwiYXNzZXJ0IGZhaWxlZFwiO1xuICB9XG5cbiAgdGhpcy5hbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbiA9IG5vZGVMaXN0O1xufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUuZ2V0Um9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucm9vdEdyYXBoO1xufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUuc2V0Um9vdEdyYXBoID0gZnVuY3Rpb24gKGdyYXBoKSB7XG4gIGlmIChncmFwaC5nZXRHcmFwaE1hbmFnZXIoKSAhPSB0aGlzKSB7XG4gICAgdGhyb3cgXCJSb290IG5vdCBpbiB0aGlzIGdyYXBoIG1nciFcIjtcbiAgfVxuXG4gIHRoaXMucm9vdEdyYXBoID0gZ3JhcGg7XG4gIC8vIHJvb3QgZ3JhcGggbXVzdCBoYXZlIGEgcm9vdCBub2RlIGFzc29jaWF0ZWQgd2l0aCBpdCBmb3IgY29udmVuaWVuY2VcbiAgaWYgKGdyYXBoLnBhcmVudCA9PSBudWxsKSB7XG4gICAgZ3JhcGgucGFyZW50ID0gdGhpcy5sYXlvdXQubmV3Tm9kZShcIlJvb3Qgbm9kZVwiKTtcbiAgfVxufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUuZ2V0TGF5b3V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sYXlvdXQ7XG59O1xuXG5MR3JhcGhNYW5hZ2VyLnByb3RvdHlwZS5pc09uZUFuY2VzdG9yT2ZPdGhlciA9IGZ1bmN0aW9uIChmaXJzdE5vZGUsIHNlY29uZE5vZGUpIHtcbiAgaWYgKCEoZmlyc3ROb2RlICE9IG51bGwgJiYgc2Vjb25kTm9kZSAhPSBudWxsKSkge1xuICAgIHRocm93IFwiYXNzZXJ0IGZhaWxlZFwiO1xuICB9XG5cbiAgaWYgKGZpcnN0Tm9kZSA9PSBzZWNvbmROb2RlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLy8gSXMgc2Vjb25kIG5vZGUgYW4gYW5jZXN0b3Igb2YgdGhlIGZpcnN0IG9uZT9cbiAgdmFyIG93bmVyR3JhcGggPSBmaXJzdE5vZGUuZ2V0T3duZXIoKTtcbiAgdmFyIHBhcmVudE5vZGU7XG5cbiAgZG8ge1xuICAgIHBhcmVudE5vZGUgPSBvd25lckdyYXBoLmdldFBhcmVudCgpO1xuXG4gICAgaWYgKHBhcmVudE5vZGUgPT0gbnVsbCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHBhcmVudE5vZGUgPT0gc2Vjb25kTm9kZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgb3duZXJHcmFwaCA9IHBhcmVudE5vZGUuZ2V0T3duZXIoKTtcbiAgICBpZiAob3duZXJHcmFwaCA9PSBudWxsKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH0gd2hpbGUgKHRydWUpO1xuICAvLyBJcyBmaXJzdCBub2RlIGFuIGFuY2VzdG9yIG9mIHRoZSBzZWNvbmQgb25lP1xuICBvd25lckdyYXBoID0gc2Vjb25kTm9kZS5nZXRPd25lcigpO1xuXG4gIGRvIHtcbiAgICBwYXJlbnROb2RlID0gb3duZXJHcmFwaC5nZXRQYXJlbnQoKTtcblxuICAgIGlmIChwYXJlbnROb2RlID09IG51bGwpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChwYXJlbnROb2RlID09IGZpcnN0Tm9kZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgb3duZXJHcmFwaCA9IHBhcmVudE5vZGUuZ2V0T3duZXIoKTtcbiAgICBpZiAob3duZXJHcmFwaCA9PSBudWxsKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH0gd2hpbGUgKHRydWUpO1xuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbkxHcmFwaE1hbmFnZXIucHJvdG90eXBlLmNhbGNMb3dlc3RDb21tb25BbmNlc3RvcnMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBlZGdlO1xuICB2YXIgc291cmNlTm9kZTtcbiAgdmFyIHRhcmdldE5vZGU7XG4gIHZhciBzb3VyY2VBbmNlc3RvckdyYXBoO1xuICB2YXIgdGFyZ2V0QW5jZXN0b3JHcmFwaDtcblxuICB2YXIgZWRnZXMgPSB0aGlzLmdldEFsbEVkZ2VzKCk7XG4gIHZhciBzID0gZWRnZXMubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKykge1xuICAgIGVkZ2UgPSBlZGdlc1tpXTtcblxuICAgIHNvdXJjZU5vZGUgPSBlZGdlLnNvdXJjZTtcbiAgICB0YXJnZXROb2RlID0gZWRnZS50YXJnZXQ7XG4gICAgZWRnZS5sY2EgPSBudWxsO1xuICAgIGVkZ2Uuc291cmNlSW5MY2EgPSBzb3VyY2VOb2RlO1xuICAgIGVkZ2UudGFyZ2V0SW5MY2EgPSB0YXJnZXROb2RlO1xuXG4gICAgaWYgKHNvdXJjZU5vZGUgPT0gdGFyZ2V0Tm9kZSkge1xuICAgICAgZWRnZS5sY2EgPSBzb3VyY2VOb2RlLmdldE93bmVyKCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBzb3VyY2VBbmNlc3RvckdyYXBoID0gc291cmNlTm9kZS5nZXRPd25lcigpO1xuXG4gICAgd2hpbGUgKGVkZ2UubGNhID09IG51bGwpIHtcbiAgICAgIGVkZ2UudGFyZ2V0SW5MY2EgPSB0YXJnZXROb2RlO1xuICAgICAgdGFyZ2V0QW5jZXN0b3JHcmFwaCA9IHRhcmdldE5vZGUuZ2V0T3duZXIoKTtcblxuICAgICAgd2hpbGUgKGVkZ2UubGNhID09IG51bGwpIHtcbiAgICAgICAgaWYgKHRhcmdldEFuY2VzdG9yR3JhcGggPT0gc291cmNlQW5jZXN0b3JHcmFwaCkge1xuICAgICAgICAgIGVkZ2UubGNhID0gdGFyZ2V0QW5jZXN0b3JHcmFwaDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0YXJnZXRBbmNlc3RvckdyYXBoID09IHRoaXMucm9vdEdyYXBoKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZWRnZS5sY2EgIT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IFwiYXNzZXJ0IGZhaWxlZFwiO1xuICAgICAgICB9XG4gICAgICAgIGVkZ2UudGFyZ2V0SW5MY2EgPSB0YXJnZXRBbmNlc3RvckdyYXBoLmdldFBhcmVudCgpO1xuICAgICAgICB0YXJnZXRBbmNlc3RvckdyYXBoID0gZWRnZS50YXJnZXRJbkxjYS5nZXRPd25lcigpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc291cmNlQW5jZXN0b3JHcmFwaCA9PSB0aGlzLnJvb3RHcmFwaCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKGVkZ2UubGNhID09IG51bGwpIHtcbiAgICAgICAgZWRnZS5zb3VyY2VJbkxjYSA9IHNvdXJjZUFuY2VzdG9yR3JhcGguZ2V0UGFyZW50KCk7XG4gICAgICAgIHNvdXJjZUFuY2VzdG9yR3JhcGggPSBlZGdlLnNvdXJjZUluTGNhLmdldE93bmVyKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVkZ2UubGNhID09IG51bGwpIHtcbiAgICAgIHRocm93IFwiYXNzZXJ0IGZhaWxlZFwiO1xuICAgIH1cbiAgfVxufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUuY2FsY0xvd2VzdENvbW1vbkFuY2VzdG9yID0gZnVuY3Rpb24gKGZpcnN0Tm9kZSwgc2Vjb25kTm9kZSkge1xuICBpZiAoZmlyc3ROb2RlID09IHNlY29uZE5vZGUpIHtcbiAgICByZXR1cm4gZmlyc3ROb2RlLmdldE93bmVyKCk7XG4gIH1cbiAgdmFyIGZpcnN0T3duZXJHcmFwaCA9IGZpcnN0Tm9kZS5nZXRPd25lcigpO1xuXG4gIGRvIHtcbiAgICBpZiAoZmlyc3RPd25lckdyYXBoID09IG51bGwpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB2YXIgc2Vjb25kT3duZXJHcmFwaCA9IHNlY29uZE5vZGUuZ2V0T3duZXIoKTtcblxuICAgIGRvIHtcbiAgICAgIGlmIChzZWNvbmRPd25lckdyYXBoID09IG51bGwpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWNvbmRPd25lckdyYXBoID09IGZpcnN0T3duZXJHcmFwaCkge1xuICAgICAgICByZXR1cm4gc2Vjb25kT3duZXJHcmFwaDtcbiAgICAgIH1cbiAgICAgIHNlY29uZE93bmVyR3JhcGggPSBzZWNvbmRPd25lckdyYXBoLmdldFBhcmVudCgpLmdldE93bmVyKCk7XG4gICAgfSB3aGlsZSAodHJ1ZSk7XG5cbiAgICBmaXJzdE93bmVyR3JhcGggPSBmaXJzdE93bmVyR3JhcGguZ2V0UGFyZW50KCkuZ2V0T3duZXIoKTtcbiAgfSB3aGlsZSAodHJ1ZSk7XG5cbiAgcmV0dXJuIGZpcnN0T3duZXJHcmFwaDtcbn07XG5cbkxHcmFwaE1hbmFnZXIucHJvdG90eXBlLmNhbGNJbmNsdXNpb25UcmVlRGVwdGhzID0gZnVuY3Rpb24gKGdyYXBoLCBkZXB0aCkge1xuICBpZiAoZ3JhcGggPT0gbnVsbCAmJiBkZXB0aCA9PSBudWxsKSB7XG4gICAgZ3JhcGggPSB0aGlzLnJvb3RHcmFwaDtcbiAgICBkZXB0aCA9IDE7XG4gIH1cbiAgdmFyIG5vZGU7XG5cbiAgdmFyIG5vZGVzID0gZ3JhcGguZ2V0Tm9kZXMoKTtcbiAgdmFyIHMgPSBub2Rlcy5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgbm9kZSA9IG5vZGVzW2ldO1xuICAgIG5vZGUuaW5jbHVzaW9uVHJlZURlcHRoID0gZGVwdGg7XG5cbiAgICBpZiAobm9kZS5jaGlsZCAhPSBudWxsKSB7XG4gICAgICB0aGlzLmNhbGNJbmNsdXNpb25UcmVlRGVwdGhzKG5vZGUuY2hpbGQsIGRlcHRoICsgMSk7XG4gICAgfVxuICB9XG59O1xuXG5MR3JhcGhNYW5hZ2VyLnByb3RvdHlwZS5pbmNsdWRlc0ludmFsaWRFZGdlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZWRnZTtcblxuICB2YXIgcyA9IHRoaXMuZWRnZXMubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKykge1xuICAgIGVkZ2UgPSB0aGlzLmVkZ2VzW2ldO1xuXG4gICAgaWYgKHRoaXMuaXNPbmVBbmNlc3Rvck9mT3RoZXIoZWRnZS5zb3VyY2UsIGVkZ2UudGFyZ2V0KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTEdyYXBoTWFuYWdlcjtcblxuLyoqKi8gfSksXG4vKiA3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBMYXlvdXRDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5mdW5jdGlvbiBGRExheW91dENvbnN0YW50cygpIHt9XG5cbi8vRkRMYXlvdXRDb25zdGFudHMgaW5oZXJpdHMgc3RhdGljIHByb3BzIGluIExheW91dENvbnN0YW50c1xuZm9yICh2YXIgcHJvcCBpbiBMYXlvdXRDb25zdGFudHMpIHtcbiAgRkRMYXlvdXRDb25zdGFudHNbcHJvcF0gPSBMYXlvdXRDb25zdGFudHNbcHJvcF07XG59XG5cbkZETGF5b3V0Q29uc3RhbnRzLk1BWF9JVEVSQVRJT05TID0gMjUwMDtcblxuRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSCA9IDUwO1xuRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9TUFJJTkdfU1RSRU5HVEggPSAwLjQ1O1xuRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9SRVBVTFNJT05fU1RSRU5HVEggPSA0NTAwLjA7XG5GRExheW91dENvbnN0YW50cy5ERUZBVUxUX0dSQVZJVFlfU1RSRU5HVEggPSAwLjQ7XG5GRExheW91dENvbnN0YW50cy5ERUZBVUxUX0NPTVBPVU5EX0dSQVZJVFlfU1RSRU5HVEggPSAxLjA7XG5GRExheW91dENvbnN0YW50cy5ERUZBVUxUX0dSQVZJVFlfUkFOR0VfRkFDVE9SID0gMy44O1xuRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9DT01QT1VORF9HUkFWSVRZX1JBTkdFX0ZBQ1RPUiA9IDEuNTtcbkZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfVVNFX1NNQVJUX0lERUFMX0VER0VfTEVOR1RIX0NBTENVTEFUSU9OID0gdHJ1ZTtcbkZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfVVNFX1NNQVJUX1JFUFVMU0lPTl9SQU5HRV9DQUxDVUxBVElPTiA9IHRydWU7XG5GRExheW91dENvbnN0YW50cy5ERUZBVUxUX0NPT0xJTkdfRkFDVE9SX0lOQ1JFTUVOVEFMID0gMC4zO1xuRkRMYXlvdXRDb25zdGFudHMuQ09PTElOR19BREFQVEFUSU9OX0ZBQ1RPUiA9IDAuMzM7XG5GRExheW91dENvbnN0YW50cy5BREFQVEFUSU9OX0xPV0VSX05PREVfTElNSVQgPSAxMDAwO1xuRkRMYXlvdXRDb25zdGFudHMuQURBUFRBVElPTl9VUFBFUl9OT0RFX0xJTUlUID0gNTAwMDtcbkZETGF5b3V0Q29uc3RhbnRzLk1BWF9OT0RFX0RJU1BMQUNFTUVOVF9JTkNSRU1FTlRBTCA9IDEwMC4wO1xuRkRMYXlvdXRDb25zdGFudHMuTUFYX05PREVfRElTUExBQ0VNRU5UID0gRkRMYXlvdXRDb25zdGFudHMuTUFYX05PREVfRElTUExBQ0VNRU5UX0lOQ1JFTUVOVEFMICogMztcbkZETGF5b3V0Q29uc3RhbnRzLk1JTl9SRVBVTFNJT05fRElTVCA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggLyAxMC4wO1xuRkRMYXlvdXRDb25zdGFudHMuQ09OVkVSR0VOQ0VfQ0hFQ0tfUEVSSU9EID0gMTAwO1xuRkRMYXlvdXRDb25zdGFudHMuUEVSX0xFVkVMX0lERUFMX0VER0VfTEVOR1RIX0ZBQ1RPUiA9IDAuMTtcbkZETGF5b3V0Q29uc3RhbnRzLk1JTl9FREdFX0xFTkdUSCA9IDE7XG5GRExheW91dENvbnN0YW50cy5HUklEX0NBTENVTEFUSU9OX0NIRUNLX1BFUklPRCA9IDEwO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZETGF5b3V0Q29uc3RhbnRzO1xuXG4vKioqLyB9KSxcbi8qIDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLyoqXG4gKiBUaGlzIGNsYXNzIG1haW50YWlucyBhIGxpc3Qgb2Ygc3RhdGljIGdlb21ldHJ5IHJlbGF0ZWQgdXRpbGl0eSBtZXRob2RzLlxuICpcbiAqXG4gKiBDb3B5cmlnaHQ6IGktVmlzIFJlc2VhcmNoIEdyb3VwLCBCaWxrZW50IFVuaXZlcnNpdHksIDIwMDcgLSBwcmVzZW50XG4gKi9cblxudmFyIFBvaW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG5cbmZ1bmN0aW9uIElHZW9tZXRyeSgpIHt9XG5cbi8qKlxuICogVGhpcyBtZXRob2QgY2FsY3VsYXRlcyAqaGFsZiogdGhlIGFtb3VudCBpbiB4IGFuZCB5IGRpcmVjdGlvbnMgb2YgdGhlIHR3b1xuICogaW5wdXQgcmVjdGFuZ2xlcyBuZWVkZWQgdG8gc2VwYXJhdGUgdGhlbSBrZWVwaW5nIHRoZWlyIHJlc3BlY3RpdmVcbiAqIHBvc2l0aW9uaW5nLCBhbmQgcmV0dXJucyB0aGUgcmVzdWx0IGluIHRoZSBpbnB1dCBhcnJheS4gQW4gaW5wdXRcbiAqIHNlcGFyYXRpb24gYnVmZmVyIGFkZGVkIHRvIHRoZSBhbW91bnQgaW4gYm90aCBkaXJlY3Rpb25zLiBXZSBhc3N1bWUgdGhhdFxuICogdGhlIHR3byByZWN0YW5nbGVzIGRvIGludGVyc2VjdC5cbiAqL1xuSUdlb21ldHJ5LmNhbGNTZXBhcmF0aW9uQW1vdW50ID0gZnVuY3Rpb24gKHJlY3RBLCByZWN0Qiwgb3ZlcmxhcEFtb3VudCwgc2VwYXJhdGlvbkJ1ZmZlcikge1xuICBpZiAoIXJlY3RBLmludGVyc2VjdHMocmVjdEIpKSB7XG4gICAgdGhyb3cgXCJhc3NlcnQgZmFpbGVkXCI7XG4gIH1cblxuICB2YXIgZGlyZWN0aW9ucyA9IG5ldyBBcnJheSgyKTtcblxuICB0aGlzLmRlY2lkZURpcmVjdGlvbnNGb3JPdmVybGFwcGluZ05vZGVzKHJlY3RBLCByZWN0QiwgZGlyZWN0aW9ucyk7XG5cbiAgb3ZlcmxhcEFtb3VudFswXSA9IE1hdGgubWluKHJlY3RBLmdldFJpZ2h0KCksIHJlY3RCLmdldFJpZ2h0KCkpIC0gTWF0aC5tYXgocmVjdEEueCwgcmVjdEIueCk7XG4gIG92ZXJsYXBBbW91bnRbMV0gPSBNYXRoLm1pbihyZWN0QS5nZXRCb3R0b20oKSwgcmVjdEIuZ2V0Qm90dG9tKCkpIC0gTWF0aC5tYXgocmVjdEEueSwgcmVjdEIueSk7XG5cbiAgLy8gdXBkYXRlIHRoZSBvdmVybGFwcGluZyBhbW91bnRzIGZvciB0aGUgZm9sbG93aW5nIGNhc2VzOlxuICBpZiAocmVjdEEuZ2V0WCgpIDw9IHJlY3RCLmdldFgoKSAmJiByZWN0QS5nZXRSaWdodCgpID49IHJlY3RCLmdldFJpZ2h0KCkpIHtcbiAgICAvKiBDYXNlIHguMTpcbiAgICAqXG4gICAgKiByZWN0QVxuICAgICogXHR8ICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgKiBcdHwgICAgICAgIF9fX19fX19fXyAgICAgIHxcbiAgICAqIFx0fCAgICAgICAgfCAgICAgICB8ICAgICAgfFxuICAgICogXHR8X19fX19fX198X19fX19fX3xfX19fX198XG4gICAgKiBcdFx0XHQgfCAgICAgICB8XG4gICAgKiAgICAgICAgICAgfCAgICAgICB8XG4gICAgKiAgICAgICAgcmVjdEJcbiAgICAqL1xuICAgIG92ZXJsYXBBbW91bnRbMF0gKz0gTWF0aC5taW4ocmVjdEIuZ2V0WCgpIC0gcmVjdEEuZ2V0WCgpLCByZWN0QS5nZXRSaWdodCgpIC0gcmVjdEIuZ2V0UmlnaHQoKSk7XG4gIH0gZWxzZSBpZiAocmVjdEIuZ2V0WCgpIDw9IHJlY3RBLmdldFgoKSAmJiByZWN0Qi5nZXRSaWdodCgpID49IHJlY3RBLmdldFJpZ2h0KCkpIHtcbiAgICAvKiBDYXNlIHguMjpcbiAgICAqXG4gICAgKiByZWN0QlxuICAgICogXHR8ICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgKiBcdHwgICAgICAgIF9fX19fX19fXyAgICAgIHxcbiAgICAqIFx0fCAgICAgICAgfCAgICAgICB8ICAgICAgfFxuICAgICogXHR8X19fX19fX198X19fX19fX3xfX19fX198XG4gICAgKiBcdFx0XHQgfCAgICAgICB8XG4gICAgKiAgICAgICAgICAgfCAgICAgICB8XG4gICAgKiAgICAgICAgcmVjdEFcbiAgICAqL1xuICAgIG92ZXJsYXBBbW91bnRbMF0gKz0gTWF0aC5taW4ocmVjdEEuZ2V0WCgpIC0gcmVjdEIuZ2V0WCgpLCByZWN0Qi5nZXRSaWdodCgpIC0gcmVjdEEuZ2V0UmlnaHQoKSk7XG4gIH1cbiAgaWYgKHJlY3RBLmdldFkoKSA8PSByZWN0Qi5nZXRZKCkgJiYgcmVjdEEuZ2V0Qm90dG9tKCkgPj0gcmVjdEIuZ2V0Qm90dG9tKCkpIHtcbiAgICAvKiBDYXNlIHkuMTpcbiAgICAgKiAgICAgICAgICBfX19fX19fXyByZWN0QVxuICAgICAqICAgICAgICAgfFxuICAgICAqICAgICAgICAgfFxuICAgICAqICAgX19fX19ffF9fX18gIHJlY3RCXG4gICAgICogICAgICAgICB8ICAgIHxcbiAgICAgKiAgICAgICAgIHwgICAgfFxuICAgICAqICAgX19fX19ffF9fX198XG4gICAgICogICAgICAgICB8XG4gICAgICogICAgICAgICB8XG4gICAgICogICAgICAgICB8X19fX19fX19cbiAgICAgKlxuICAgICAqL1xuICAgIG92ZXJsYXBBbW91bnRbMV0gKz0gTWF0aC5taW4ocmVjdEIuZ2V0WSgpIC0gcmVjdEEuZ2V0WSgpLCByZWN0QS5nZXRCb3R0b20oKSAtIHJlY3RCLmdldEJvdHRvbSgpKTtcbiAgfSBlbHNlIGlmIChyZWN0Qi5nZXRZKCkgPD0gcmVjdEEuZ2V0WSgpICYmIHJlY3RCLmdldEJvdHRvbSgpID49IHJlY3RBLmdldEJvdHRvbSgpKSB7XG4gICAgLyogQ2FzZSB5LjI6XG4gICAgKiAgICAgICAgICBfX19fX19fXyByZWN0QlxuICAgICogICAgICAgICB8XG4gICAgKiAgICAgICAgIHxcbiAgICAqICAgX19fX19ffF9fX18gIHJlY3RBXG4gICAgKiAgICAgICAgIHwgICAgfFxuICAgICogICAgICAgICB8ICAgIHxcbiAgICAqICAgX19fX19ffF9fX198XG4gICAgKiAgICAgICAgIHxcbiAgICAqICAgICAgICAgfFxuICAgICogICAgICAgICB8X19fX19fX19cbiAgICAqXG4gICAgKi9cbiAgICBvdmVybGFwQW1vdW50WzFdICs9IE1hdGgubWluKHJlY3RBLmdldFkoKSAtIHJlY3RCLmdldFkoKSwgcmVjdEIuZ2V0Qm90dG9tKCkgLSByZWN0QS5nZXRCb3R0b20oKSk7XG4gIH1cblxuICAvLyBmaW5kIHNsb3BlIG9mIHRoZSBsaW5lIHBhc3NlcyB0d28gY2VudGVyc1xuICB2YXIgc2xvcGUgPSBNYXRoLmFicygocmVjdEIuZ2V0Q2VudGVyWSgpIC0gcmVjdEEuZ2V0Q2VudGVyWSgpKSAvIChyZWN0Qi5nZXRDZW50ZXJYKCkgLSByZWN0QS5nZXRDZW50ZXJYKCkpKTtcbiAgLy8gaWYgY2VudGVycyBhcmUgb3ZlcmxhcHBlZFxuICBpZiAocmVjdEIuZ2V0Q2VudGVyWSgpID09PSByZWN0QS5nZXRDZW50ZXJZKCkgJiYgcmVjdEIuZ2V0Q2VudGVyWCgpID09PSByZWN0QS5nZXRDZW50ZXJYKCkpIHtcbiAgICAvLyBhc3N1bWUgdGhlIHNsb3BlIGlzIDEgKDQ1IGRlZ3JlZSlcbiAgICBzbG9wZSA9IDEuMDtcbiAgfVxuXG4gIHZhciBtb3ZlQnlZID0gc2xvcGUgKiBvdmVybGFwQW1vdW50WzBdO1xuICB2YXIgbW92ZUJ5WCA9IG92ZXJsYXBBbW91bnRbMV0gLyBzbG9wZTtcbiAgaWYgKG92ZXJsYXBBbW91bnRbMF0gPCBtb3ZlQnlYKSB7XG4gICAgbW92ZUJ5WCA9IG92ZXJsYXBBbW91bnRbMF07XG4gIH0gZWxzZSB7XG4gICAgbW92ZUJ5WSA9IG92ZXJsYXBBbW91bnRbMV07XG4gIH1cbiAgLy8gcmV0dXJuIGhhbGYgdGhlIGFtb3VudCBzbyB0aGF0IGlmIGVhY2ggcmVjdGFuZ2xlIGlzIG1vdmVkIGJ5IHRoZXNlXG4gIC8vIGFtb3VudHMgaW4gb3Bwb3NpdGUgZGlyZWN0aW9ucywgb3ZlcmxhcCB3aWxsIGJlIHJlc29sdmVkXG4gIG92ZXJsYXBBbW91bnRbMF0gPSAtMSAqIGRpcmVjdGlvbnNbMF0gKiAobW92ZUJ5WCAvIDIgKyBzZXBhcmF0aW9uQnVmZmVyKTtcbiAgb3ZlcmxhcEFtb3VudFsxXSA9IC0xICogZGlyZWN0aW9uc1sxXSAqIChtb3ZlQnlZIC8gMiArIHNlcGFyYXRpb25CdWZmZXIpO1xufTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBkZWNpZGVzIHRoZSBzZXBhcmF0aW9uIGRpcmVjdGlvbiBvZiBvdmVybGFwcGluZyBub2Rlc1xuICpcbiAqIGlmIGRpcmVjdGlvbnNbMF0gPSAtMSwgdGhlbiByZWN0QSBnb2VzIGxlZnRcbiAqIGlmIGRpcmVjdGlvbnNbMF0gPSAxLCAgdGhlbiByZWN0QSBnb2VzIHJpZ2h0XG4gKiBpZiBkaXJlY3Rpb25zWzFdID0gLTEsIHRoZW4gcmVjdEEgZ29lcyB1cFxuICogaWYgZGlyZWN0aW9uc1sxXSA9IDEsICB0aGVuIHJlY3RBIGdvZXMgZG93blxuICovXG5JR2VvbWV0cnkuZGVjaWRlRGlyZWN0aW9uc0Zvck92ZXJsYXBwaW5nTm9kZXMgPSBmdW5jdGlvbiAocmVjdEEsIHJlY3RCLCBkaXJlY3Rpb25zKSB7XG4gIGlmIChyZWN0QS5nZXRDZW50ZXJYKCkgPCByZWN0Qi5nZXRDZW50ZXJYKCkpIHtcbiAgICBkaXJlY3Rpb25zWzBdID0gLTE7XG4gIH0gZWxzZSB7XG4gICAgZGlyZWN0aW9uc1swXSA9IDE7XG4gIH1cblxuICBpZiAocmVjdEEuZ2V0Q2VudGVyWSgpIDwgcmVjdEIuZ2V0Q2VudGVyWSgpKSB7XG4gICAgZGlyZWN0aW9uc1sxXSA9IC0xO1xuICB9IGVsc2Uge1xuICAgIGRpcmVjdGlvbnNbMV0gPSAxO1xuICB9XG59O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGNhbGN1bGF0ZXMgdGhlIGludGVyc2VjdGlvbiAoY2xpcHBpbmcpIHBvaW50cyBvZiB0aGUgdHdvXG4gKiBpbnB1dCByZWN0YW5nbGVzIHdpdGggbGluZSBzZWdtZW50IGRlZmluZWQgYnkgdGhlIGNlbnRlcnMgb2YgdGhlc2UgdHdvXG4gKiByZWN0YW5nbGVzLiBUaGUgY2xpcHBpbmcgcG9pbnRzIGFyZSBzYXZlZCBpbiB0aGUgaW5wdXQgZG91YmxlIGFycmF5IGFuZFxuICogd2hldGhlciBvciBub3QgdGhlIHR3byByZWN0YW5nbGVzIG92ZXJsYXAgaXMgcmV0dXJuZWQuXG4gKi9cbklHZW9tZXRyeS5nZXRJbnRlcnNlY3Rpb24yID0gZnVuY3Rpb24gKHJlY3RBLCByZWN0QiwgcmVzdWx0KSB7XG4gIC8vcmVzdWx0WzAtMV0gd2lsbCBjb250YWluIGNsaXBQb2ludCBvZiByZWN0QSwgcmVzdWx0WzItM10gd2lsbCBjb250YWluIGNsaXBQb2ludCBvZiByZWN0QlxuICB2YXIgcDF4ID0gcmVjdEEuZ2V0Q2VudGVyWCgpO1xuICB2YXIgcDF5ID0gcmVjdEEuZ2V0Q2VudGVyWSgpO1xuICB2YXIgcDJ4ID0gcmVjdEIuZ2V0Q2VudGVyWCgpO1xuICB2YXIgcDJ5ID0gcmVjdEIuZ2V0Q2VudGVyWSgpO1xuXG4gIC8vaWYgdHdvIHJlY3RhbmdsZXMgaW50ZXJzZWN0LCB0aGVuIGNsaXBwaW5nIHBvaW50cyBhcmUgY2VudGVyc1xuICBpZiAocmVjdEEuaW50ZXJzZWN0cyhyZWN0QikpIHtcbiAgICByZXN1bHRbMF0gPSBwMXg7XG4gICAgcmVzdWx0WzFdID0gcDF5O1xuICAgIHJlc3VsdFsyXSA9IHAyeDtcbiAgICByZXN1bHRbM10gPSBwMnk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLy92YXJpYWJsZXMgZm9yIHJlY3RBXG4gIHZhciB0b3BMZWZ0QXggPSByZWN0QS5nZXRYKCk7XG4gIHZhciB0b3BMZWZ0QXkgPSByZWN0QS5nZXRZKCk7XG4gIHZhciB0b3BSaWdodEF4ID0gcmVjdEEuZ2V0UmlnaHQoKTtcbiAgdmFyIGJvdHRvbUxlZnRBeCA9IHJlY3RBLmdldFgoKTtcbiAgdmFyIGJvdHRvbUxlZnRBeSA9IHJlY3RBLmdldEJvdHRvbSgpO1xuICB2YXIgYm90dG9tUmlnaHRBeCA9IHJlY3RBLmdldFJpZ2h0KCk7XG4gIHZhciBoYWxmV2lkdGhBID0gcmVjdEEuZ2V0V2lkdGhIYWxmKCk7XG4gIHZhciBoYWxmSGVpZ2h0QSA9IHJlY3RBLmdldEhlaWdodEhhbGYoKTtcbiAgLy92YXJpYWJsZXMgZm9yIHJlY3RCXG4gIHZhciB0b3BMZWZ0QnggPSByZWN0Qi5nZXRYKCk7XG4gIHZhciB0b3BMZWZ0QnkgPSByZWN0Qi5nZXRZKCk7XG4gIHZhciB0b3BSaWdodEJ4ID0gcmVjdEIuZ2V0UmlnaHQoKTtcbiAgdmFyIGJvdHRvbUxlZnRCeCA9IHJlY3RCLmdldFgoKTtcbiAgdmFyIGJvdHRvbUxlZnRCeSA9IHJlY3RCLmdldEJvdHRvbSgpO1xuICB2YXIgYm90dG9tUmlnaHRCeCA9IHJlY3RCLmdldFJpZ2h0KCk7XG4gIHZhciBoYWxmV2lkdGhCID0gcmVjdEIuZ2V0V2lkdGhIYWxmKCk7XG4gIHZhciBoYWxmSGVpZ2h0QiA9IHJlY3RCLmdldEhlaWdodEhhbGYoKTtcblxuICAvL2ZsYWcgd2hldGhlciBjbGlwcGluZyBwb2ludHMgYXJlIGZvdW5kXG4gIHZhciBjbGlwUG9pbnRBRm91bmQgPSBmYWxzZTtcbiAgdmFyIGNsaXBQb2ludEJGb3VuZCA9IGZhbHNlO1xuXG4gIC8vIGxpbmUgaXMgdmVydGljYWxcbiAgaWYgKHAxeCA9PT0gcDJ4KSB7XG4gICAgaWYgKHAxeSA+IHAyeSkge1xuICAgICAgcmVzdWx0WzBdID0gcDF4O1xuICAgICAgcmVzdWx0WzFdID0gdG9wTGVmdEF5O1xuICAgICAgcmVzdWx0WzJdID0gcDJ4O1xuICAgICAgcmVzdWx0WzNdID0gYm90dG9tTGVmdEJ5O1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAocDF5IDwgcDJ5KSB7XG4gICAgICByZXN1bHRbMF0gPSBwMXg7XG4gICAgICByZXN1bHRbMV0gPSBib3R0b21MZWZ0QXk7XG4gICAgICByZXN1bHRbMl0gPSBwMng7XG4gICAgICByZXN1bHRbM10gPSB0b3BMZWZ0Qnk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vbm90IGxpbmUsIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICAvLyBsaW5lIGlzIGhvcml6b250YWxcbiAgZWxzZSBpZiAocDF5ID09PSBwMnkpIHtcbiAgICAgIGlmIChwMXggPiBwMngpIHtcbiAgICAgICAgcmVzdWx0WzBdID0gdG9wTGVmdEF4O1xuICAgICAgICByZXN1bHRbMV0gPSBwMXk7XG4gICAgICAgIHJlc3VsdFsyXSA9IHRvcFJpZ2h0Qng7XG4gICAgICAgIHJlc3VsdFszXSA9IHAyeTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChwMXggPCBwMngpIHtcbiAgICAgICAgcmVzdWx0WzBdID0gdG9wUmlnaHRBeDtcbiAgICAgICAgcmVzdWx0WzFdID0gcDF5O1xuICAgICAgICByZXN1bHRbMl0gPSB0b3BMZWZ0Qng7XG4gICAgICAgIHJlc3VsdFszXSA9IHAyeTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy9ub3QgdmFsaWQgbGluZSwgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vc2xvcGVzIG9mIHJlY3RBJ3MgYW5kIHJlY3RCJ3MgZGlhZ29uYWxzXG4gICAgICB2YXIgc2xvcGVBID0gcmVjdEEuaGVpZ2h0IC8gcmVjdEEud2lkdGg7XG4gICAgICB2YXIgc2xvcGVCID0gcmVjdEIuaGVpZ2h0IC8gcmVjdEIud2lkdGg7XG5cbiAgICAgIC8vc2xvcGUgb2YgbGluZSBiZXR3ZWVuIGNlbnRlciBvZiByZWN0QSBhbmQgY2VudGVyIG9mIHJlY3RCXG4gICAgICB2YXIgc2xvcGVQcmltZSA9IChwMnkgLSBwMXkpIC8gKHAyeCAtIHAxeCk7XG4gICAgICB2YXIgY2FyZGluYWxEaXJlY3Rpb25BID0gdm9pZCAwO1xuICAgICAgdmFyIGNhcmRpbmFsRGlyZWN0aW9uQiA9IHZvaWQgMDtcbiAgICAgIHZhciB0ZW1wUG9pbnRBeCA9IHZvaWQgMDtcbiAgICAgIHZhciB0ZW1wUG9pbnRBeSA9IHZvaWQgMDtcbiAgICAgIHZhciB0ZW1wUG9pbnRCeCA9IHZvaWQgMDtcbiAgICAgIHZhciB0ZW1wUG9pbnRCeSA9IHZvaWQgMDtcblxuICAgICAgLy9kZXRlcm1pbmUgd2hldGhlciBjbGlwcGluZyBwb2ludCBpcyB0aGUgY29ybmVyIG9mIG5vZGVBXG4gICAgICBpZiAoLXNsb3BlQSA9PT0gc2xvcGVQcmltZSkge1xuICAgICAgICBpZiAocDF4ID4gcDJ4KSB7XG4gICAgICAgICAgcmVzdWx0WzBdID0gYm90dG9tTGVmdEF4O1xuICAgICAgICAgIHJlc3VsdFsxXSA9IGJvdHRvbUxlZnRBeTtcbiAgICAgICAgICBjbGlwUG9pbnRBRm91bmQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdFswXSA9IHRvcFJpZ2h0QXg7XG4gICAgICAgICAgcmVzdWx0WzFdID0gdG9wTGVmdEF5O1xuICAgICAgICAgIGNsaXBQb2ludEFGb3VuZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc2xvcGVBID09PSBzbG9wZVByaW1lKSB7XG4gICAgICAgIGlmIChwMXggPiBwMngpIHtcbiAgICAgICAgICByZXN1bHRbMF0gPSB0b3BMZWZ0QXg7XG4gICAgICAgICAgcmVzdWx0WzFdID0gdG9wTGVmdEF5O1xuICAgICAgICAgIGNsaXBQb2ludEFGb3VuZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0WzBdID0gYm90dG9tUmlnaHRBeDtcbiAgICAgICAgICByZXN1bHRbMV0gPSBib3R0b21MZWZ0QXk7XG4gICAgICAgICAgY2xpcFBvaW50QUZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvL2RldGVybWluZSB3aGV0aGVyIGNsaXBwaW5nIHBvaW50IGlzIHRoZSBjb3JuZXIgb2Ygbm9kZUJcbiAgICAgIGlmICgtc2xvcGVCID09PSBzbG9wZVByaW1lKSB7XG4gICAgICAgIGlmIChwMnggPiBwMXgpIHtcbiAgICAgICAgICByZXN1bHRbMl0gPSBib3R0b21MZWZ0Qng7XG4gICAgICAgICAgcmVzdWx0WzNdID0gYm90dG9tTGVmdEJ5O1xuICAgICAgICAgIGNsaXBQb2ludEJGb3VuZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0WzJdID0gdG9wUmlnaHRCeDtcbiAgICAgICAgICByZXN1bHRbM10gPSB0b3BMZWZ0Qnk7XG4gICAgICAgICAgY2xpcFBvaW50QkZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzbG9wZUIgPT09IHNsb3BlUHJpbWUpIHtcbiAgICAgICAgaWYgKHAyeCA+IHAxeCkge1xuICAgICAgICAgIHJlc3VsdFsyXSA9IHRvcExlZnRCeDtcbiAgICAgICAgICByZXN1bHRbM10gPSB0b3BMZWZ0Qnk7XG4gICAgICAgICAgY2xpcFBvaW50QkZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHRbMl0gPSBib3R0b21SaWdodEJ4O1xuICAgICAgICAgIHJlc3VsdFszXSA9IGJvdHRvbUxlZnRCeTtcbiAgICAgICAgICBjbGlwUG9pbnRCRm91bmQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vaWYgYm90aCBjbGlwcGluZyBwb2ludHMgYXJlIGNvcm5lcnNcbiAgICAgIGlmIChjbGlwUG9pbnRBRm91bmQgJiYgY2xpcFBvaW50QkZvdW5kKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy9kZXRlcm1pbmUgQ2FyZGluYWwgRGlyZWN0aW9uIG9mIHJlY3RhbmdsZXNcbiAgICAgIGlmIChwMXggPiBwMngpIHtcbiAgICAgICAgaWYgKHAxeSA+IHAyeSkge1xuICAgICAgICAgIGNhcmRpbmFsRGlyZWN0aW9uQSA9IHRoaXMuZ2V0Q2FyZGluYWxEaXJlY3Rpb24oc2xvcGVBLCBzbG9wZVByaW1lLCA0KTtcbiAgICAgICAgICBjYXJkaW5hbERpcmVjdGlvbkIgPSB0aGlzLmdldENhcmRpbmFsRGlyZWN0aW9uKHNsb3BlQiwgc2xvcGVQcmltZSwgMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FyZGluYWxEaXJlY3Rpb25BID0gdGhpcy5nZXRDYXJkaW5hbERpcmVjdGlvbigtc2xvcGVBLCBzbG9wZVByaW1lLCAzKTtcbiAgICAgICAgICBjYXJkaW5hbERpcmVjdGlvbkIgPSB0aGlzLmdldENhcmRpbmFsRGlyZWN0aW9uKC1zbG9wZUIsIHNsb3BlUHJpbWUsIDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocDF5ID4gcDJ5KSB7XG4gICAgICAgICAgY2FyZGluYWxEaXJlY3Rpb25BID0gdGhpcy5nZXRDYXJkaW5hbERpcmVjdGlvbigtc2xvcGVBLCBzbG9wZVByaW1lLCAxKTtcbiAgICAgICAgICBjYXJkaW5hbERpcmVjdGlvbkIgPSB0aGlzLmdldENhcmRpbmFsRGlyZWN0aW9uKC1zbG9wZUIsIHNsb3BlUHJpbWUsIDMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhcmRpbmFsRGlyZWN0aW9uQSA9IHRoaXMuZ2V0Q2FyZGluYWxEaXJlY3Rpb24oc2xvcGVBLCBzbG9wZVByaW1lLCAyKTtcbiAgICAgICAgICBjYXJkaW5hbERpcmVjdGlvbkIgPSB0aGlzLmdldENhcmRpbmFsRGlyZWN0aW9uKHNsb3BlQiwgc2xvcGVQcmltZSwgNCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vY2FsY3VsYXRlIGNsaXBwaW5nIFBvaW50IGlmIGl0IGlzIG5vdCBmb3VuZCBiZWZvcmVcbiAgICAgIGlmICghY2xpcFBvaW50QUZvdW5kKSB7XG4gICAgICAgIHN3aXRjaCAoY2FyZGluYWxEaXJlY3Rpb25BKSB7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgdGVtcFBvaW50QXkgPSB0b3BMZWZ0QXk7XG4gICAgICAgICAgICB0ZW1wUG9pbnRBeCA9IHAxeCArIC1oYWxmSGVpZ2h0QSAvIHNsb3BlUHJpbWU7XG4gICAgICAgICAgICByZXN1bHRbMF0gPSB0ZW1wUG9pbnRBeDtcbiAgICAgICAgICAgIHJlc3VsdFsxXSA9IHRlbXBQb2ludEF5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgdGVtcFBvaW50QXggPSBib3R0b21SaWdodEF4O1xuICAgICAgICAgICAgdGVtcFBvaW50QXkgPSBwMXkgKyBoYWxmV2lkdGhBICogc2xvcGVQcmltZTtcbiAgICAgICAgICAgIHJlc3VsdFswXSA9IHRlbXBQb2ludEF4O1xuICAgICAgICAgICAgcmVzdWx0WzFdID0gdGVtcFBvaW50QXk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICB0ZW1wUG9pbnRBeSA9IGJvdHRvbUxlZnRBeTtcbiAgICAgICAgICAgIHRlbXBQb2ludEF4ID0gcDF4ICsgaGFsZkhlaWdodEEgLyBzbG9wZVByaW1lO1xuICAgICAgICAgICAgcmVzdWx0WzBdID0gdGVtcFBvaW50QXg7XG4gICAgICAgICAgICByZXN1bHRbMV0gPSB0ZW1wUG9pbnRBeTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHRlbXBQb2ludEF4ID0gYm90dG9tTGVmdEF4O1xuICAgICAgICAgICAgdGVtcFBvaW50QXkgPSBwMXkgKyAtaGFsZldpZHRoQSAqIHNsb3BlUHJpbWU7XG4gICAgICAgICAgICByZXN1bHRbMF0gPSB0ZW1wUG9pbnRBeDtcbiAgICAgICAgICAgIHJlc3VsdFsxXSA9IHRlbXBQb2ludEF5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghY2xpcFBvaW50QkZvdW5kKSB7XG4gICAgICAgIHN3aXRjaCAoY2FyZGluYWxEaXJlY3Rpb25CKSB7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgdGVtcFBvaW50QnkgPSB0b3BMZWZ0Qnk7XG4gICAgICAgICAgICB0ZW1wUG9pbnRCeCA9IHAyeCArIC1oYWxmSGVpZ2h0QiAvIHNsb3BlUHJpbWU7XG4gICAgICAgICAgICByZXN1bHRbMl0gPSB0ZW1wUG9pbnRCeDtcbiAgICAgICAgICAgIHJlc3VsdFszXSA9IHRlbXBQb2ludEJ5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgdGVtcFBvaW50QnggPSBib3R0b21SaWdodEJ4O1xuICAgICAgICAgICAgdGVtcFBvaW50QnkgPSBwMnkgKyBoYWxmV2lkdGhCICogc2xvcGVQcmltZTtcbiAgICAgICAgICAgIHJlc3VsdFsyXSA9IHRlbXBQb2ludEJ4O1xuICAgICAgICAgICAgcmVzdWx0WzNdID0gdGVtcFBvaW50Qnk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICB0ZW1wUG9pbnRCeSA9IGJvdHRvbUxlZnRCeTtcbiAgICAgICAgICAgIHRlbXBQb2ludEJ4ID0gcDJ4ICsgaGFsZkhlaWdodEIgLyBzbG9wZVByaW1lO1xuICAgICAgICAgICAgcmVzdWx0WzJdID0gdGVtcFBvaW50Qng7XG4gICAgICAgICAgICByZXN1bHRbM10gPSB0ZW1wUG9pbnRCeTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHRlbXBQb2ludEJ4ID0gYm90dG9tTGVmdEJ4O1xuICAgICAgICAgICAgdGVtcFBvaW50QnkgPSBwMnkgKyAtaGFsZldpZHRoQiAqIHNsb3BlUHJpbWU7XG4gICAgICAgICAgICByZXN1bHRbMl0gPSB0ZW1wUG9pbnRCeDtcbiAgICAgICAgICAgIHJlc3VsdFszXSA9IHRlbXBQb2ludEJ5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBpbiB3aGljaCBjYXJkaW5hbCBkaXJlY3Rpb24gZG9lcyBpbnB1dCBwb2ludCBzdGF5c1xuICogMTogTm9ydGhcbiAqIDI6IEVhc3RcbiAqIDM6IFNvdXRoXG4gKiA0OiBXZXN0XG4gKi9cbklHZW9tZXRyeS5nZXRDYXJkaW5hbERpcmVjdGlvbiA9IGZ1bmN0aW9uIChzbG9wZSwgc2xvcGVQcmltZSwgbGluZSkge1xuICBpZiAoc2xvcGUgPiBzbG9wZVByaW1lKSB7XG4gICAgcmV0dXJuIGxpbmU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDEgKyBsaW5lICUgNDtcbiAgfVxufTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBjYWxjdWxhdGVzIHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhlIHR3byBsaW5lcyBkZWZpbmVkIGJ5XG4gKiBwb2ludCBwYWlycyAoczEsczIpIGFuZCAoZjEsZjIpLlxuICovXG5JR2VvbWV0cnkuZ2V0SW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gKHMxLCBzMiwgZjEsIGYyKSB7XG4gIGlmIChmMiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW50ZXJzZWN0aW9uMihzMSwgczIsIGYxKTtcbiAgfVxuXG4gIHZhciB4MSA9IHMxLng7XG4gIHZhciB5MSA9IHMxLnk7XG4gIHZhciB4MiA9IHMyLng7XG4gIHZhciB5MiA9IHMyLnk7XG4gIHZhciB4MyA9IGYxLng7XG4gIHZhciB5MyA9IGYxLnk7XG4gIHZhciB4NCA9IGYyLng7XG4gIHZhciB5NCA9IGYyLnk7XG4gIHZhciB4ID0gdm9pZCAwLFxuICAgICAgeSA9IHZvaWQgMDsgLy8gaW50ZXJzZWN0aW9uIHBvaW50XG4gIHZhciBhMSA9IHZvaWQgMCxcbiAgICAgIGEyID0gdm9pZCAwLFxuICAgICAgYjEgPSB2b2lkIDAsXG4gICAgICBiMiA9IHZvaWQgMCxcbiAgICAgIGMxID0gdm9pZCAwLFxuICAgICAgYzIgPSB2b2lkIDA7IC8vIGNvZWZmaWNpZW50cyBvZiBsaW5lIGVxbnMuXG4gIHZhciBkZW5vbSA9IHZvaWQgMDtcblxuICBhMSA9IHkyIC0geTE7XG4gIGIxID0geDEgLSB4MjtcbiAgYzEgPSB4MiAqIHkxIC0geDEgKiB5MjsgLy8geyBhMSp4ICsgYjEqeSArIGMxID0gMCBpcyBsaW5lIDEgfVxuXG4gIGEyID0geTQgLSB5MztcbiAgYjIgPSB4MyAtIHg0O1xuICBjMiA9IHg0ICogeTMgLSB4MyAqIHk0OyAvLyB7IGEyKnggKyBiMip5ICsgYzIgPSAwIGlzIGxpbmUgMiB9XG5cbiAgZGVub20gPSBhMSAqIGIyIC0gYTIgKiBiMTtcblxuICBpZiAoZGVub20gPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHggPSAoYjEgKiBjMiAtIGIyICogYzEpIC8gZGVub207XG4gIHkgPSAoYTIgKiBjMSAtIGExICogYzIpIC8gZGVub207XG5cbiAgcmV0dXJuIG5ldyBQb2ludCh4LCB5KTtcbn07XG5cbi8qKlxuICogVGhpcyBtZXRob2QgZmluZHMgYW5kIHJldHVybnMgdGhlIGFuZ2xlIG9mIHRoZSB2ZWN0b3IgZnJvbSB0aGUgKyB4LWF4aXNcbiAqIGluIGNsb2Nrd2lzZSBkaXJlY3Rpb24gKGNvbXBhdGlibGUgdy8gSmF2YSBjb29yZGluYXRlIHN5c3RlbSEpLlxuICovXG5JR2VvbWV0cnkuYW5nbGVPZlZlY3RvciA9IGZ1bmN0aW9uIChDeCwgQ3ksIE54LCBOeSkge1xuICB2YXIgQ19hbmdsZSA9IHZvaWQgMDtcblxuICBpZiAoQ3ggIT09IE54KSB7XG4gICAgQ19hbmdsZSA9IE1hdGguYXRhbigoTnkgLSBDeSkgLyAoTnggLSBDeCkpO1xuXG4gICAgaWYgKE54IDwgQ3gpIHtcbiAgICAgIENfYW5nbGUgKz0gTWF0aC5QSTtcbiAgICB9IGVsc2UgaWYgKE55IDwgQ3kpIHtcbiAgICAgIENfYW5nbGUgKz0gdGhpcy5UV09fUEk7XG4gICAgfVxuICB9IGVsc2UgaWYgKE55IDwgQ3kpIHtcbiAgICBDX2FuZ2xlID0gdGhpcy5PTkVfQU5EX0hBTEZfUEk7IC8vIDI3MCBkZWdyZWVzXG4gIH0gZWxzZSB7XG4gICAgQ19hbmdsZSA9IHRoaXMuSEFMRl9QSTsgLy8gOTAgZGVncmVlc1xuICB9XG5cbiAgcmV0dXJuIENfYW5nbGU7XG59O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGNoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiB0d28gbGluZSBzZWdtZW50cyAob25lIHdpdGggcG9pbnRcbiAqIHAxIGFuZCBwMiwgdGhlIG90aGVyIHdpdGggcG9pbnQgcDMgYW5kIHA0KSBpbnRlcnNlY3QgYXQgYSBwb2ludCBvdGhlclxuICogdGhhbiB0aGVzZSBwb2ludHMuXG4gKi9cbklHZW9tZXRyeS5kb0ludGVyc2VjdCA9IGZ1bmN0aW9uIChwMSwgcDIsIHAzLCBwNCkge1xuICB2YXIgYSA9IHAxLng7XG4gIHZhciBiID0gcDEueTtcbiAgdmFyIGMgPSBwMi54O1xuICB2YXIgZCA9IHAyLnk7XG4gIHZhciBwID0gcDMueDtcbiAgdmFyIHEgPSBwMy55O1xuICB2YXIgciA9IHA0Lng7XG4gIHZhciBzID0gcDQueTtcbiAgdmFyIGRldCA9IChjIC0gYSkgKiAocyAtIHEpIC0gKHIgLSBwKSAqIChkIC0gYik7XG5cbiAgaWYgKGRldCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGFtYmRhID0gKChzIC0gcSkgKiAociAtIGEpICsgKHAgLSByKSAqIChzIC0gYikpIC8gZGV0O1xuICAgIHZhciBnYW1tYSA9ICgoYiAtIGQpICogKHIgLSBhKSArIChjIC0gYSkgKiAocyAtIGIpKSAvIGRldDtcbiAgICByZXR1cm4gMCA8IGxhbWJkYSAmJiBsYW1iZGEgPCAxICYmIDAgPCBnYW1tYSAmJiBnYW1tYSA8IDE7XG4gIH1cbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBTZWN0aW9uOiBDbGFzcyBDb25zdGFudHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vKipcbiAqIFNvbWUgdXNlZnVsIHByZS1jYWxjdWxhdGVkIGNvbnN0YW50c1xuICovXG5JR2VvbWV0cnkuSEFMRl9QSSA9IDAuNSAqIE1hdGguUEk7XG5JR2VvbWV0cnkuT05FX0FORF9IQUxGX1BJID0gMS41ICogTWF0aC5QSTtcbklHZW9tZXRyeS5UV09fUEkgPSAyLjAgKiBNYXRoLlBJO1xuSUdlb21ldHJ5LlRIUkVFX1BJID0gMy4wICogTWF0aC5QSTtcblxubW9kdWxlLmV4cG9ydHMgPSBJR2VvbWV0cnk7XG5cbi8qKiovIH0pLFxuLyogOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBJTWF0aCgpIHt9XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgc2lnbiBvZiB0aGUgaW5wdXQgdmFsdWUuXG4gKi9cbklNYXRoLnNpZ24gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgaWYgKHZhbHVlID4gMCkge1xuICAgIHJldHVybiAxO1xuICB9IGVsc2UgaWYgKHZhbHVlIDwgMCkge1xuICAgIHJldHVybiAtMTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMDtcbiAgfVxufTtcblxuSU1hdGguZmxvb3IgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIDwgMCA/IE1hdGguY2VpbCh2YWx1ZSkgOiBNYXRoLmZsb29yKHZhbHVlKTtcbn07XG5cbklNYXRoLmNlaWwgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIDwgMCA/IE1hdGguZmxvb3IodmFsdWUpIDogTWF0aC5jZWlsKHZhbHVlKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSU1hdGg7XG5cbi8qKiovIH0pLFxuLyogMTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gSW50ZWdlcigpIHt9XG5cbkludGVnZXIuTUFYX1ZBTFVFID0gMjE0NzQ4MzY0NztcbkludGVnZXIuTUlOX1ZBTFVFID0gLTIxNDc0ODM2NDg7XG5cbm1vZHVsZS5leHBvcnRzID0gSW50ZWdlcjtcblxuLyoqKi8gfSksXG4vKiAxMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgbm9kZUZyb20gPSBmdW5jdGlvbiBub2RlRnJvbSh2YWx1ZSkge1xuICByZXR1cm4geyB2YWx1ZTogdmFsdWUsIG5leHQ6IG51bGwsIHByZXY6IG51bGwgfTtcbn07XG5cbnZhciBhZGQgPSBmdW5jdGlvbiBhZGQocHJldiwgbm9kZSwgbmV4dCwgbGlzdCkge1xuICBpZiAocHJldiAhPT0gbnVsbCkge1xuICAgIHByZXYubmV4dCA9IG5vZGU7XG4gIH0gZWxzZSB7XG4gICAgbGlzdC5oZWFkID0gbm9kZTtcbiAgfVxuXG4gIGlmIChuZXh0ICE9PSBudWxsKSB7XG4gICAgbmV4dC5wcmV2ID0gbm9kZTtcbiAgfSBlbHNlIHtcbiAgICBsaXN0LnRhaWwgPSBub2RlO1xuICB9XG5cbiAgbm9kZS5wcmV2ID0gcHJldjtcbiAgbm9kZS5uZXh0ID0gbmV4dDtcblxuICBsaXN0Lmxlbmd0aCsrO1xuXG4gIHJldHVybiBub2RlO1xufTtcblxudmFyIF9yZW1vdmUgPSBmdW5jdGlvbiBfcmVtb3ZlKG5vZGUsIGxpc3QpIHtcbiAgdmFyIHByZXYgPSBub2RlLnByZXYsXG4gICAgICBuZXh0ID0gbm9kZS5uZXh0O1xuXG5cbiAgaWYgKHByZXYgIT09IG51bGwpIHtcbiAgICBwcmV2Lm5leHQgPSBuZXh0O1xuICB9IGVsc2Uge1xuICAgIGxpc3QuaGVhZCA9IG5leHQ7XG4gIH1cblxuICBpZiAobmV4dCAhPT0gbnVsbCkge1xuICAgIG5leHQucHJldiA9IHByZXY7XG4gIH0gZWxzZSB7XG4gICAgbGlzdC50YWlsID0gcHJldjtcbiAgfVxuXG4gIG5vZGUucHJldiA9IG5vZGUubmV4dCA9IG51bGw7XG5cbiAgbGlzdC5sZW5ndGgtLTtcblxuICByZXR1cm4gbm9kZTtcbn07XG5cbnZhciBMaW5rZWRMaXN0ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBMaW5rZWRMaXN0KHZhbHMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExpbmtlZExpc3QpO1xuXG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuaGVhZCA9IG51bGw7XG4gICAgdGhpcy50YWlsID0gbnVsbDtcblxuICAgIGlmICh2YWxzICE9IG51bGwpIHtcbiAgICAgIHZhbHMuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gX3RoaXMucHVzaCh2KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhMaW5rZWRMaXN0LCBbe1xuICAgIGtleTogXCJzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNpemUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5sZW5ndGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluc2VydEJlZm9yZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnNlcnRCZWZvcmUodmFsLCBvdGhlck5vZGUpIHtcbiAgICAgIHJldHVybiBhZGQob3RoZXJOb2RlLnByZXYsIG5vZGVGcm9tKHZhbCksIG90aGVyTm9kZSwgdGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluc2VydEFmdGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydEFmdGVyKHZhbCwgb3RoZXJOb2RlKSB7XG4gICAgICByZXR1cm4gYWRkKG90aGVyTm9kZSwgbm9kZUZyb20odmFsKSwgb3RoZXJOb2RlLm5leHQsIHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnNlcnROb2RlQmVmb3JlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydE5vZGVCZWZvcmUobmV3Tm9kZSwgb3RoZXJOb2RlKSB7XG4gICAgICByZXR1cm4gYWRkKG90aGVyTm9kZS5wcmV2LCBuZXdOb2RlLCBvdGhlck5vZGUsIHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnNlcnROb2RlQWZ0ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0Tm9kZUFmdGVyKG5ld05vZGUsIG90aGVyTm9kZSkge1xuICAgICAgcmV0dXJuIGFkZChvdGhlck5vZGUsIG5ld05vZGUsIG90aGVyTm9kZS5uZXh0LCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHVzaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwdXNoKHZhbCkge1xuICAgICAgcmV0dXJuIGFkZCh0aGlzLnRhaWwsIG5vZGVGcm9tKHZhbCksIG51bGwsIHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1bnNoaWZ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVuc2hpZnQodmFsKSB7XG4gICAgICByZXR1cm4gYWRkKG51bGwsIG5vZGVGcm9tKHZhbCksIHRoaXMuaGVhZCwgdGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmUobm9kZSkge1xuICAgICAgcmV0dXJuIF9yZW1vdmUobm9kZSwgdGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBvcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwb3AoKSB7XG4gICAgICByZXR1cm4gX3JlbW92ZSh0aGlzLnRhaWwsIHRoaXMpLnZhbHVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwb3BOb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBvcE5vZGUoKSB7XG4gICAgICByZXR1cm4gX3JlbW92ZSh0aGlzLnRhaWwsIHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzaGlmdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaGlmdCgpIHtcbiAgICAgIHJldHVybiBfcmVtb3ZlKHRoaXMuaGVhZCwgdGhpcykudmFsdWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNoaWZ0Tm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaGlmdE5vZGUoKSB7XG4gICAgICByZXR1cm4gX3JlbW92ZSh0aGlzLmhlYWQsIHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRfb2JqZWN0X2F0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldF9vYmplY3RfYXQoaW5kZXgpIHtcbiAgICAgIGlmIChpbmRleCA8PSB0aGlzLmxlbmd0aCgpKSB7XG4gICAgICAgIHZhciBpID0gMTtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmhlYWQ7XG4gICAgICAgIHdoaWxlIChpIDwgaW5kZXgpIHtcbiAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3VycmVudC52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0X29iamVjdF9hdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRfb2JqZWN0X2F0KGluZGV4LCB2YWx1ZSkge1xuICAgICAgaWYgKGluZGV4IDw9IHRoaXMubGVuZ3RoKCkpIHtcbiAgICAgICAgdmFyIGkgPSAxO1xuICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuaGVhZDtcbiAgICAgICAgd2hpbGUgKGkgPCBpbmRleCkge1xuICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQudmFsdWUgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTGlua2VkTGlzdDtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBMaW5rZWRMaXN0O1xuXG4vKioqLyB9KSxcbi8qIDEyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qXHJcbiAqVGhpcyBjbGFzcyBpcyB0aGUgamF2YXNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgUG9pbnQuamF2YSBjbGFzcyBpbiBqZGtcclxuICovXG5mdW5jdGlvbiBQb2ludCh4LCB5LCBwKSB7XG4gIHRoaXMueCA9IG51bGw7XG4gIHRoaXMueSA9IG51bGw7XG4gIGlmICh4ID09IG51bGwgJiYgeSA9PSBudWxsICYmIHAgPT0gbnVsbCkge1xuICAgIHRoaXMueCA9IDA7XG4gICAgdGhpcy55ID0gMDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgeCA9PSAnbnVtYmVyJyAmJiB0eXBlb2YgeSA9PSAnbnVtYmVyJyAmJiBwID09IG51bGwpIHtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gIH0gZWxzZSBpZiAoeC5jb25zdHJ1Y3Rvci5uYW1lID09ICdQb2ludCcgJiYgeSA9PSBudWxsICYmIHAgPT0gbnVsbCkge1xuICAgIHAgPSB4O1xuICAgIHRoaXMueCA9IHAueDtcbiAgICB0aGlzLnkgPSBwLnk7XG4gIH1cbn1cblxuUG9pbnQucHJvdG90eXBlLmdldFggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLng7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZ2V0WSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMueTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5nZXRMb2NhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLngsIHRoaXMueSk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuc2V0TG9jYXRpb24gPSBmdW5jdGlvbiAoeCwgeSwgcCkge1xuICBpZiAoeC5jb25zdHJ1Y3Rvci5uYW1lID09ICdQb2ludCcgJiYgeSA9PSBudWxsICYmIHAgPT0gbnVsbCkge1xuICAgIHAgPSB4O1xuICAgIHRoaXMuc2V0TG9jYXRpb24ocC54LCBwLnkpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB4ID09ICdudW1iZXInICYmIHR5cGVvZiB5ID09ICdudW1iZXInICYmIHAgPT0gbnVsbCkge1xuICAgIC8vaWYgYm90aCBwYXJhbWV0ZXJzIGFyZSBpbnRlZ2VyIGp1c3QgbW92ZSAoeCx5KSBsb2NhdGlvblxuICAgIGlmIChwYXJzZUludCh4KSA9PSB4ICYmIHBhcnNlSW50KHkpID09IHkpIHtcbiAgICAgIHRoaXMubW92ZSh4LCB5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy54ID0gTWF0aC5mbG9vcih4ICsgMC41KTtcbiAgICAgIHRoaXMueSA9IE1hdGguZmxvb3IoeSArIDAuNSk7XG4gICAgfVxuICB9XG59O1xuXG5Qb2ludC5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gIHRoaXMueCA9IHg7XG4gIHRoaXMueSA9IHk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUudHJhbnNsYXRlID0gZnVuY3Rpb24gKGR4LCBkeSkge1xuICB0aGlzLnggKz0gZHg7XG4gIHRoaXMueSArPSBkeTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAob2JqKSB7XG4gIGlmIChvYmouY29uc3RydWN0b3IubmFtZSA9PSBcIlBvaW50XCIpIHtcbiAgICB2YXIgcHQgPSBvYmo7XG4gICAgcmV0dXJuIHRoaXMueCA9PSBwdC54ICYmIHRoaXMueSA9PSBwdC55O1xuICB9XG4gIHJldHVybiB0aGlzID09IG9iajtcbn07XG5cblBvaW50LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBQb2ludCgpLmNvbnN0cnVjdG9yLm5hbWUgKyBcIlt4PVwiICsgdGhpcy54ICsgXCIseT1cIiArIHRoaXMueSArIFwiXVwiO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQb2ludDtcblxuLyoqKi8gfSksXG4vKiAxMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBSZWN0YW5nbGVEKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgdGhpcy54ID0gMDtcbiAgdGhpcy55ID0gMDtcbiAgdGhpcy53aWR0aCA9IDA7XG4gIHRoaXMuaGVpZ2h0ID0gMDtcblxuICBpZiAoeCAhPSBudWxsICYmIHkgIT0gbnVsbCAmJiB3aWR0aCAhPSBudWxsICYmIGhlaWdodCAhPSBudWxsKSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgfVxufVxuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5nZXRYID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy54O1xufTtcblxuUmVjdGFuZ2xlRC5wcm90b3R5cGUuc2V0WCA9IGZ1bmN0aW9uICh4KSB7XG4gIHRoaXMueCA9IHg7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5nZXRZID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy55O1xufTtcblxuUmVjdGFuZ2xlRC5wcm90b3R5cGUuc2V0WSA9IGZ1bmN0aW9uICh5KSB7XG4gIHRoaXMueSA9IHk7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5nZXRXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMud2lkdGg7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5zZXRXaWR0aCA9IGZ1bmN0aW9uICh3aWR0aCkge1xuICB0aGlzLndpZHRoID0gd2lkdGg7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5nZXRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmhlaWdodDtcbn07XG5cblJlY3RhbmdsZUQucHJvdG90eXBlLnNldEhlaWdodCA9IGZ1bmN0aW9uIChoZWlnaHQpIHtcbiAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5nZXRSaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMueCArIHRoaXMud2lkdGg7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5nZXRCb3R0b20gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnkgKyB0aGlzLmhlaWdodDtcbn07XG5cblJlY3RhbmdsZUQucHJvdG90eXBlLmludGVyc2VjdHMgPSBmdW5jdGlvbiAoYSkge1xuICBpZiAodGhpcy5nZXRSaWdodCgpIDwgYS54KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHRoaXMuZ2V0Qm90dG9tKCkgPCBhLnkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoYS5nZXRSaWdodCgpIDwgdGhpcy54KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGEuZ2V0Qm90dG9tKCkgPCB0aGlzLnkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblJlY3RhbmdsZUQucHJvdG90eXBlLmdldENlbnRlclggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnggKyB0aGlzLndpZHRoIC8gMjtcbn07XG5cblJlY3RhbmdsZUQucHJvdG90eXBlLmdldE1pblggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmdldFgoKTtcbn07XG5cblJlY3RhbmdsZUQucHJvdG90eXBlLmdldE1heFggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmdldFgoKSArIHRoaXMud2lkdGg7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5nZXRDZW50ZXJZID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy55ICsgdGhpcy5oZWlnaHQgLyAyO1xufTtcblxuUmVjdGFuZ2xlRC5wcm90b3R5cGUuZ2V0TWluWSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZ2V0WSgpO1xufTtcblxuUmVjdGFuZ2xlRC5wcm90b3R5cGUuZ2V0TWF4WSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZ2V0WSgpICsgdGhpcy5oZWlnaHQ7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5nZXRXaWR0aEhhbGYgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLndpZHRoIC8gMjtcbn07XG5cblJlY3RhbmdsZUQucHJvdG90eXBlLmdldEhlaWdodEhhbGYgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmhlaWdodCAvIDI7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlY3RhbmdsZUQ7XG5cbi8qKiovIH0pLFxuLyogMTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5mdW5jdGlvbiBVbmlxdWVJREdlbmVyZXRvcigpIHt9XG5cblVuaXF1ZUlER2VuZXJldG9yLmxhc3RJRCA9IDA7XG5cblVuaXF1ZUlER2VuZXJldG9yLmNyZWF0ZUlEID0gZnVuY3Rpb24gKG9iaikge1xuICBpZiAoVW5pcXVlSURHZW5lcmV0b3IuaXNQcmltaXRpdmUob2JqKSkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cbiAgaWYgKG9iai51bmlxdWVJRCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIG9iai51bmlxdWVJRDtcbiAgfVxuICBvYmoudW5pcXVlSUQgPSBVbmlxdWVJREdlbmVyZXRvci5nZXRTdHJpbmcoKTtcbiAgVW5pcXVlSURHZW5lcmV0b3IubGFzdElEKys7XG4gIHJldHVybiBvYmoudW5pcXVlSUQ7XG59O1xuXG5VbmlxdWVJREdlbmVyZXRvci5nZXRTdHJpbmcgPSBmdW5jdGlvbiAoaWQpIHtcbiAgaWYgKGlkID09IG51bGwpIGlkID0gVW5pcXVlSURHZW5lcmV0b3IubGFzdElEO1xuICByZXR1cm4gXCJPYmplY3QjXCIgKyBpZCArIFwiXCI7XG59O1xuXG5VbmlxdWVJREdlbmVyZXRvci5pc1ByaW1pdGl2ZSA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgYXJnID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoYXJnKTtcbiAgcmV0dXJuIGFyZyA9PSBudWxsIHx8IHR5cGUgIT0gXCJvYmplY3RcIiAmJiB0eXBlICE9IFwiZnVuY3Rpb25cIjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVW5pcXVlSURHZW5lcmV0b3I7XG5cbi8qKiovIH0pLFxuLyogMTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfSBlbHNlIHsgcmV0dXJuIEFycmF5LmZyb20oYXJyKTsgfSB9XG5cbnZhciBMYXlvdXRDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIExHcmFwaE1hbmFnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xudmFyIExOb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbnZhciBMRWRnZSA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG52YXIgTEdyYXBoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBQb2ludEQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xudmFyIFRyYW5zZm9ybSA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xudmFyIEVtaXR0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3KTtcblxuZnVuY3Rpb24gTGF5b3V0KGlzUmVtb3RlVXNlKSB7XG4gIEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICAvL0xheW91dCBRdWFsaXR5OiAwOmRyYWZ0LCAxOmRlZmF1bHQsIDI6cHJvb2ZcbiAgdGhpcy5sYXlvdXRRdWFsaXR5ID0gTGF5b3V0Q29uc3RhbnRzLlFVQUxJVFk7XG4gIC8vV2hldGhlciBsYXlvdXQgc2hvdWxkIGNyZWF0ZSBiZW5kcG9pbnRzIGFzIG5lZWRlZCBvciBub3RcbiAgdGhpcy5jcmVhdGVCZW5kc0FzTmVlZGVkID0gTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQ1JFQVRFX0JFTkRTX0FTX05FRURFRDtcbiAgLy9XaGV0aGVyIGxheW91dCBzaG91bGQgYmUgaW5jcmVtZW50YWwgb3Igbm90XG4gIHRoaXMuaW5jcmVtZW50YWwgPSBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9JTkNSRU1FTlRBTDtcbiAgLy9XaGV0aGVyIHdlIGFuaW1hdGUgZnJvbSBiZWZvcmUgdG8gYWZ0ZXIgbGF5b3V0IG5vZGUgcG9zaXRpb25zXG4gIHRoaXMuYW5pbWF0aW9uT25MYXlvdXQgPSBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9BTklNQVRJT05fT05fTEFZT1VUO1xuICAvL1doZXRoZXIgd2UgYW5pbWF0ZSB0aGUgbGF5b3V0IHByb2Nlc3Mgb3Igbm90XG4gIHRoaXMuYW5pbWF0aW9uRHVyaW5nTGF5b3V0ID0gTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQU5JTUFUSU9OX0RVUklOR19MQVlPVVQ7XG4gIC8vTnVtYmVyIGl0ZXJhdGlvbnMgdGhhdCBzaG91bGQgYmUgZG9uZSBiZXR3ZWVuIHR3byBzdWNjZXNzaXZlIGFuaW1hdGlvbnNcbiAgdGhpcy5hbmltYXRpb25QZXJpb2QgPSBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9BTklNQVRJT05fUEVSSU9EO1xuICAvKipcclxuICAgKiBXaGV0aGVyIG9yIG5vdCBsZWFmIG5vZGVzIChub24tY29tcG91bmQgbm9kZXMpIGFyZSBvZiB1bmlmb3JtIHNpemVzLiBXaGVuXHJcbiAgICogdGhleSBhcmUsIGJvdGggc3ByaW5nIGFuZCByZXB1bHNpb24gZm9yY2VzIGJldHdlZW4gdHdvIGxlYWYgbm9kZXMgY2FuIGJlXHJcbiAgICogY2FsY3VsYXRlZCB3aXRob3V0IHRoZSBleHBlbnNpdmUgY2xpcHBpbmcgcG9pbnQgY2FsY3VsYXRpb25zLCByZXN1bHRpbmdcclxuICAgKiBpbiBtYWpvciBzcGVlZC11cC5cclxuICAgKi9cbiAgdGhpcy51bmlmb3JtTGVhZk5vZGVTaXplcyA9IExheW91dENvbnN0YW50cy5ERUZBVUxUX1VOSUZPUk1fTEVBRl9OT0RFX1NJWkVTO1xuICAvKipcclxuICAgKiBUaGlzIGlzIHVzZWQgZm9yIGNyZWF0aW9uIG9mIGJlbmRwb2ludHMgYnkgdXNpbmcgZHVtbXkgbm9kZXMgYW5kIGVkZ2VzLlxyXG4gICAqIE1hcHMgYW4gTEVkZ2UgdG8gaXRzIGR1bW15IGJlbmRwb2ludCBwYXRoLlxyXG4gICAqL1xuICB0aGlzLmVkZ2VUb0R1bW15Tm9kZXMgPSBuZXcgTWFwKCk7XG4gIHRoaXMuZ3JhcGhNYW5hZ2VyID0gbmV3IExHcmFwaE1hbmFnZXIodGhpcyk7XG4gIHRoaXMuaXNMYXlvdXRGaW5pc2hlZCA9IGZhbHNlO1xuICB0aGlzLmlzU3ViTGF5b3V0ID0gZmFsc2U7XG4gIHRoaXMuaXNSZW1vdGVVc2UgPSBmYWxzZTtcblxuICBpZiAoaXNSZW1vdGVVc2UgIT0gbnVsbCkge1xuICAgIHRoaXMuaXNSZW1vdGVVc2UgPSBpc1JlbW90ZVVzZTtcbiAgfVxufVxuXG5MYXlvdXQuUkFORE9NX1NFRUQgPSAxO1xuXG5MYXlvdXQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFbWl0dGVyLnByb3RvdHlwZSk7XG5cbkxheW91dC5wcm90b3R5cGUuZ2V0R3JhcGhNYW5hZ2VyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ncmFwaE1hbmFnZXI7XG59O1xuXG5MYXlvdXQucHJvdG90eXBlLmdldEFsbE5vZGVzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ncmFwaE1hbmFnZXIuZ2V0QWxsTm9kZXMoKTtcbn07XG5cbkxheW91dC5wcm90b3R5cGUuZ2V0QWxsRWRnZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmdyYXBoTWFuYWdlci5nZXRBbGxFZGdlcygpO1xufTtcblxuTGF5b3V0LnByb3RvdHlwZS5nZXRBbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZ3JhcGhNYW5hZ2VyLmdldEFsbE5vZGVzVG9BcHBseUdyYXZpdGF0aW9uKCk7XG59O1xuXG5MYXlvdXQucHJvdG90eXBlLm5ld0dyYXBoTWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGdtID0gbmV3IExHcmFwaE1hbmFnZXIodGhpcyk7XG4gIHRoaXMuZ3JhcGhNYW5hZ2VyID0gZ207XG4gIHJldHVybiBnbTtcbn07XG5cbkxheW91dC5wcm90b3R5cGUubmV3R3JhcGggPSBmdW5jdGlvbiAodkdyYXBoKSB7XG4gIHJldHVybiBuZXcgTEdyYXBoKG51bGwsIHRoaXMuZ3JhcGhNYW5hZ2VyLCB2R3JhcGgpO1xufTtcblxuTGF5b3V0LnByb3RvdHlwZS5uZXdOb2RlID0gZnVuY3Rpb24gKHZOb2RlKSB7XG4gIHJldHVybiBuZXcgTE5vZGUodGhpcy5ncmFwaE1hbmFnZXIsIHZOb2RlKTtcbn07XG5cbkxheW91dC5wcm90b3R5cGUubmV3RWRnZSA9IGZ1bmN0aW9uICh2RWRnZSkge1xuICByZXR1cm4gbmV3IExFZGdlKG51bGwsIG51bGwsIHZFZGdlKTtcbn07XG5cbkxheW91dC5wcm90b3R5cGUuY2hlY2tMYXlvdXRTdWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ncmFwaE1hbmFnZXIuZ2V0Um9vdCgpID09IG51bGwgfHwgdGhpcy5ncmFwaE1hbmFnZXIuZ2V0Um9vdCgpLmdldE5vZGVzKCkubGVuZ3RoID09IDAgfHwgdGhpcy5ncmFwaE1hbmFnZXIuaW5jbHVkZXNJbnZhbGlkRWRnZSgpO1xufTtcblxuTGF5b3V0LnByb3RvdHlwZS5ydW5MYXlvdXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuaXNMYXlvdXRGaW5pc2hlZCA9IGZhbHNlO1xuXG4gIGlmICh0aGlzLnRpbGluZ1ByZUxheW91dCkge1xuICAgIHRoaXMudGlsaW5nUHJlTGF5b3V0KCk7XG4gIH1cblxuICB0aGlzLmluaXRQYXJhbWV0ZXJzKCk7XG4gIHZhciBpc0xheW91dFN1Y2Nlc3NmdWxsO1xuXG4gIGlmICh0aGlzLmNoZWNrTGF5b3V0U3VjY2VzcygpKSB7XG4gICAgaXNMYXlvdXRTdWNjZXNzZnVsbCA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIGlzTGF5b3V0U3VjY2Vzc2Z1bGwgPSB0aGlzLmxheW91dCgpO1xuICB9XG5cbiAgaWYgKExheW91dENvbnN0YW50cy5BTklNQVRFID09PSAnZHVyaW5nJykge1xuICAgIC8vIElmIHRoaXMgaXMgYSAnZHVyaW5nJyBsYXlvdXQgYW5pbWF0aW9uLiBMYXlvdXQgaXMgbm90IGZpbmlzaGVkIHlldC4gXG4gICAgLy8gV2UgbmVlZCB0byBwZXJmb3JtIHRoZXNlIGluIGluZGV4LmpzIHdoZW4gbGF5b3V0IGlzIHJlYWxseSBmaW5pc2hlZC5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoaXNMYXlvdXRTdWNjZXNzZnVsbCkge1xuICAgIGlmICghdGhpcy5pc1N1YkxheW91dCkge1xuICAgICAgdGhpcy5kb1Bvc3RMYXlvdXQoKTtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy50aWxpbmdQb3N0TGF5b3V0KSB7XG4gICAgdGhpcy50aWxpbmdQb3N0TGF5b3V0KCk7XG4gIH1cblxuICB0aGlzLmlzTGF5b3V0RmluaXNoZWQgPSB0cnVlO1xuXG4gIHJldHVybiBpc0xheW91dFN1Y2Nlc3NmdWxsO1xufTtcblxuLyoqXHJcbiAqIFRoaXMgbWV0aG9kIHBlcmZvcm1zIHRoZSBvcGVyYXRpb25zIHJlcXVpcmVkIGFmdGVyIGxheW91dC5cclxuICovXG5MYXlvdXQucHJvdG90eXBlLmRvUG9zdExheW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgLy9hc3NlcnQgIWlzU3ViTGF5b3V0IDogXCJTaG91bGQgbm90IGJlIGNhbGxlZCBvbiBzdWItbGF5b3V0IVwiO1xuICAvLyBQcm9wYWdhdGUgZ2VvbWV0cmljIGNoYW5nZXMgdG8gdi1sZXZlbCBvYmplY3RzXG4gIGlmICghdGhpcy5pbmNyZW1lbnRhbCkge1xuICAgIHRoaXMudHJhbnNmb3JtKCk7XG4gIH1cbiAgdGhpcy51cGRhdGUoKTtcbn07XG5cbi8qKlxyXG4gKiBUaGlzIG1ldGhvZCB1cGRhdGVzIHRoZSBnZW9tZXRyeSBvZiB0aGUgdGFyZ2V0IGdyYXBoIGFjY29yZGluZyB0b1xyXG4gKiBjYWxjdWxhdGVkIGxheW91dC5cclxuICovXG5MYXlvdXQucHJvdG90eXBlLnVwZGF0ZTIgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIHVwZGF0ZSBiZW5kIHBvaW50c1xuICBpZiAodGhpcy5jcmVhdGVCZW5kc0FzTmVlZGVkKSB7XG4gICAgdGhpcy5jcmVhdGVCZW5kcG9pbnRzRnJvbUR1bW15Tm9kZXMoKTtcblxuICAgIC8vIHJlc2V0IGFsbCBlZGdlcywgc2luY2UgdGhlIHRvcG9sb2d5IGhhcyBjaGFuZ2VkXG4gICAgdGhpcy5ncmFwaE1hbmFnZXIucmVzZXRBbGxFZGdlcygpO1xuICB9XG5cbiAgLy8gcGVyZm9ybSBlZGdlLCBub2RlIGFuZCByb290IHVwZGF0ZXMgaWYgbGF5b3V0IGlzIG5vdCBjYWxsZWRcbiAgLy8gcmVtb3RlbHlcbiAgaWYgKCF0aGlzLmlzUmVtb3RlVXNlKSB7XG4gICAgLy8gdXBkYXRlIGFsbCBlZGdlc1xuICAgIHZhciBlZGdlO1xuICAgIHZhciBhbGxFZGdlcyA9IHRoaXMuZ3JhcGhNYW5hZ2VyLmdldEFsbEVkZ2VzKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxFZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgZWRnZSA9IGFsbEVkZ2VzW2ldO1xuICAgICAgLy8gICAgICB0aGlzLnVwZGF0ZShlZGdlKTtcbiAgICB9XG5cbiAgICAvLyByZWN1cnNpdmVseSB1cGRhdGUgbm9kZXNcbiAgICB2YXIgbm9kZTtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLmdyYXBoTWFuYWdlci5nZXRSb290KCkuZ2V0Tm9kZXMoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBub2RlID0gbm9kZXNbaV07XG4gICAgICAvLyAgICAgIHRoaXMudXBkYXRlKG5vZGUpO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSByb290IGdyYXBoXG4gICAgdGhpcy51cGRhdGUodGhpcy5ncmFwaE1hbmFnZXIuZ2V0Um9vdCgpKTtcbiAgfVxufTtcblxuTGF5b3V0LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAob2JqKSB7XG4gIGlmIChvYmogPT0gbnVsbCkge1xuICAgIHRoaXMudXBkYXRlMigpO1xuICB9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIExOb2RlKSB7XG4gICAgdmFyIG5vZGUgPSBvYmo7XG4gICAgaWYgKG5vZGUuZ2V0Q2hpbGQoKSAhPSBudWxsKSB7XG4gICAgICAvLyBzaW5jZSBub2RlIGlzIGNvbXBvdW5kLCByZWN1cnNpdmVseSB1cGRhdGUgY2hpbGQgbm9kZXNcbiAgICAgIHZhciBub2RlcyA9IG5vZGUuZ2V0Q2hpbGQoKS5nZXROb2RlcygpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB1cGRhdGUobm9kZXNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIHRoZSBsLWxldmVsIG5vZGUgaXMgYXNzb2NpYXRlZCB3aXRoIGEgdi1sZXZlbCBncmFwaCBvYmplY3QsXG4gICAgLy8gdGhlbiBpdCBpcyBhc3N1bWVkIHRoYXQgdGhlIHYtbGV2ZWwgbm9kZSBpbXBsZW1lbnRzIHRoZVxuICAgIC8vIGludGVyZmFjZSBVcGRhdGFibGUuXG4gICAgaWYgKG5vZGUudkdyYXBoT2JqZWN0ICE9IG51bGwpIHtcbiAgICAgIC8vIGNhc3QgdG8gVXBkYXRhYmxlIHdpdGhvdXQgYW55IHR5cGUgY2hlY2tcbiAgICAgIHZhciB2Tm9kZSA9IG5vZGUudkdyYXBoT2JqZWN0O1xuXG4gICAgICAvLyBjYWxsIHRoZSB1cGRhdGUgbWV0aG9kIG9mIHRoZSBpbnRlcmZhY2VcbiAgICAgIHZOb2RlLnVwZGF0ZShub2RlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgTEVkZ2UpIHtcbiAgICB2YXIgZWRnZSA9IG9iajtcbiAgICAvLyBpZiB0aGUgbC1sZXZlbCBlZGdlIGlzIGFzc29jaWF0ZWQgd2l0aCBhIHYtbGV2ZWwgZ3JhcGggb2JqZWN0LFxuICAgIC8vIHRoZW4gaXQgaXMgYXNzdW1lZCB0aGF0IHRoZSB2LWxldmVsIGVkZ2UgaW1wbGVtZW50cyB0aGVcbiAgICAvLyBpbnRlcmZhY2UgVXBkYXRhYmxlLlxuXG4gICAgaWYgKGVkZ2UudkdyYXBoT2JqZWN0ICE9IG51bGwpIHtcbiAgICAgIC8vIGNhc3QgdG8gVXBkYXRhYmxlIHdpdGhvdXQgYW55IHR5cGUgY2hlY2tcbiAgICAgIHZhciB2RWRnZSA9IGVkZ2UudkdyYXBoT2JqZWN0O1xuXG4gICAgICAvLyBjYWxsIHRoZSB1cGRhdGUgbWV0aG9kIG9mIHRoZSBpbnRlcmZhY2VcbiAgICAgIHZFZGdlLnVwZGF0ZShlZGdlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgTEdyYXBoKSB7XG4gICAgdmFyIGdyYXBoID0gb2JqO1xuICAgIC8vIGlmIHRoZSBsLWxldmVsIGdyYXBoIGlzIGFzc29jaWF0ZWQgd2l0aCBhIHYtbGV2ZWwgZ3JhcGggb2JqZWN0LFxuICAgIC8vIHRoZW4gaXQgaXMgYXNzdW1lZCB0aGF0IHRoZSB2LWxldmVsIG9iamVjdCBpbXBsZW1lbnRzIHRoZVxuICAgIC8vIGludGVyZmFjZSBVcGRhdGFibGUuXG5cbiAgICBpZiAoZ3JhcGgudkdyYXBoT2JqZWN0ICE9IG51bGwpIHtcbiAgICAgIC8vIGNhc3QgdG8gVXBkYXRhYmxlIHdpdGhvdXQgYW55IHR5cGUgY2hlY2tcbiAgICAgIHZhciB2R3JhcGggPSBncmFwaC52R3JhcGhPYmplY3Q7XG5cbiAgICAgIC8vIGNhbGwgdGhlIHVwZGF0ZSBtZXRob2Qgb2YgdGhlIGludGVyZmFjZVxuICAgICAgdkdyYXBoLnVwZGF0ZShncmFwaCk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcclxuICogVGhpcyBtZXRob2QgaXMgdXNlZCB0byBzZXQgYWxsIGxheW91dCBwYXJhbWV0ZXJzIHRvIGRlZmF1bHQgdmFsdWVzXHJcbiAqIGRldGVybWluZWQgYXQgY29tcGlsZSB0aW1lLlxyXG4gKi9cbkxheW91dC5wcm90b3R5cGUuaW5pdFBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5pc1N1YkxheW91dCkge1xuICAgIHRoaXMubGF5b3V0UXVhbGl0eSA9IExheW91dENvbnN0YW50cy5RVUFMSVRZO1xuICAgIHRoaXMuYW5pbWF0aW9uRHVyaW5nTGF5b3V0ID0gTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQU5JTUFUSU9OX0RVUklOR19MQVlPVVQ7XG4gICAgdGhpcy5hbmltYXRpb25QZXJpb2QgPSBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9BTklNQVRJT05fUEVSSU9EO1xuICAgIHRoaXMuYW5pbWF0aW9uT25MYXlvdXQgPSBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9BTklNQVRJT05fT05fTEFZT1VUO1xuICAgIHRoaXMuaW5jcmVtZW50YWwgPSBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9JTkNSRU1FTlRBTDtcbiAgICB0aGlzLmNyZWF0ZUJlbmRzQXNOZWVkZWQgPSBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9DUkVBVEVfQkVORFNfQVNfTkVFREVEO1xuICAgIHRoaXMudW5pZm9ybUxlYWZOb2RlU2l6ZXMgPSBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9VTklGT1JNX0xFQUZfTk9ERV9TSVpFUztcbiAgfVxuXG4gIGlmICh0aGlzLmFuaW1hdGlvbkR1cmluZ0xheW91dCkge1xuICAgIHRoaXMuYW5pbWF0aW9uT25MYXlvdXQgPSBmYWxzZTtcbiAgfVxufTtcblxuTGF5b3V0LnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAobmV3TGVmdFRvcCkge1xuICBpZiAobmV3TGVmdFRvcCA9PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLnRyYW5zZm9ybShuZXcgUG9pbnREKDAsIDApKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBjcmVhdGUgYSB0cmFuc2Zvcm1hdGlvbiBvYmplY3QgKGZyb20gRWNsaXBzZSB0byBsYXlvdXQpLiBXaGVuIGFuXG4gICAgLy8gaW52ZXJzZSB0cmFuc2Zvcm0gaXMgYXBwbGllZCwgd2UgZ2V0IHVwcGVyLWxlZnQgY29vcmRpbmF0ZSBvZiB0aGVcbiAgICAvLyBkcmF3aW5nIG9yIHRoZSByb290IGdyYXBoIGF0IGdpdmVuIGlucHV0IGNvb3JkaW5hdGUgKHNvbWUgbWFyZ2luc1xuICAgIC8vIGFscmVhZHkgaW5jbHVkZWQgaW4gY2FsY3VsYXRpb24gb2YgbGVmdC10b3ApLlxuXG4gICAgdmFyIHRyYW5zID0gbmV3IFRyYW5zZm9ybSgpO1xuICAgIHZhciBsZWZ0VG9wID0gdGhpcy5ncmFwaE1hbmFnZXIuZ2V0Um9vdCgpLnVwZGF0ZUxlZnRUb3AoKTtcblxuICAgIGlmIChsZWZ0VG9wICE9IG51bGwpIHtcbiAgICAgIHRyYW5zLnNldFdvcmxkT3JnWChuZXdMZWZ0VG9wLngpO1xuICAgICAgdHJhbnMuc2V0V29ybGRPcmdZKG5ld0xlZnRUb3AueSk7XG5cbiAgICAgIHRyYW5zLnNldERldmljZU9yZ1gobGVmdFRvcC54KTtcbiAgICAgIHRyYW5zLnNldERldmljZU9yZ1kobGVmdFRvcC55KTtcblxuICAgICAgdmFyIG5vZGVzID0gdGhpcy5nZXRBbGxOb2RlcygpO1xuICAgICAgdmFyIG5vZGU7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBub2RlLnRyYW5zZm9ybSh0cmFucyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5MYXlvdXQucHJvdG90eXBlLnBvc2l0aW9uTm9kZXNSYW5kb21seSA9IGZ1bmN0aW9uIChncmFwaCkge1xuXG4gIGlmIChncmFwaCA9PSB1bmRlZmluZWQpIHtcbiAgICAvL2Fzc2VydCAhdGhpcy5pbmNyZW1lbnRhbDtcbiAgICB0aGlzLnBvc2l0aW9uTm9kZXNSYW5kb21seSh0aGlzLmdldEdyYXBoTWFuYWdlcigpLmdldFJvb3QoKSk7XG4gICAgdGhpcy5nZXRHcmFwaE1hbmFnZXIoKS5nZXRSb290KCkudXBkYXRlQm91bmRzKHRydWUpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsTm9kZTtcbiAgICB2YXIgY2hpbGRHcmFwaDtcblxuICAgIHZhciBub2RlcyA9IGdyYXBoLmdldE5vZGVzKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgbE5vZGUgPSBub2Rlc1tpXTtcbiAgICAgIGNoaWxkR3JhcGggPSBsTm9kZS5nZXRDaGlsZCgpO1xuXG4gICAgICBpZiAoY2hpbGRHcmFwaCA9PSBudWxsKSB7XG4gICAgICAgIGxOb2RlLnNjYXR0ZXIoKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hpbGRHcmFwaC5nZXROb2RlcygpLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIGxOb2RlLnNjYXR0ZXIoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucG9zaXRpb25Ob2Rlc1JhbmRvbWx5KGNoaWxkR3JhcGgpO1xuICAgICAgICBsTm9kZS51cGRhdGVCb3VuZHMoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxyXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbGlzdCBvZiB0cmVlcyB3aGVyZSBlYWNoIHRyZWUgaXMgcmVwcmVzZW50ZWQgYXMgYVxyXG4gKiBsaXN0IG9mIGwtbm9kZXMuIFRoZSBtZXRob2QgcmV0dXJucyBhIGxpc3Qgb2Ygc2l6ZSAwIHdoZW46XHJcbiAqIC0gVGhlIGdyYXBoIGlzIG5vdCBmbGF0IG9yXHJcbiAqIC0gT25lIG9mIHRoZSBjb21wb25lbnQocykgb2YgdGhlIGdyYXBoIGlzIG5vdCBhIHRyZWUuXHJcbiAqL1xuTGF5b3V0LnByb3RvdHlwZS5nZXRGbGF0Rm9yZXN0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZmxhdEZvcmVzdCA9IFtdO1xuICB2YXIgaXNGb3Jlc3QgPSB0cnVlO1xuXG4gIC8vIFF1aWNrIHJlZmVyZW5jZSBmb3IgYWxsIG5vZGVzIGluIHRoZSBncmFwaCBtYW5hZ2VyIGFzc29jaWF0ZWQgd2l0aFxuICAvLyB0aGlzIGxheW91dC4gVGhlIGxpc3Qgc2hvdWxkIG5vdCBiZSBjaGFuZ2VkLlxuICB2YXIgYWxsTm9kZXMgPSB0aGlzLmdyYXBoTWFuYWdlci5nZXRSb290KCkuZ2V0Tm9kZXMoKTtcblxuICAvLyBGaXJzdCBiZSBzdXJlIHRoYXQgdGhlIGdyYXBoIGlzIGZsYXRcbiAgdmFyIGlzRmxhdCA9IHRydWU7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhbGxOb2Rlc1tpXS5nZXRDaGlsZCgpICE9IG51bGwpIHtcbiAgICAgIGlzRmxhdCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJldHVybiBlbXB0eSBmb3Jlc3QgaWYgdGhlIGdyYXBoIGlzIG5vdCBmbGF0LlxuICBpZiAoIWlzRmxhdCkge1xuICAgIHJldHVybiBmbGF0Rm9yZXN0O1xuICB9XG5cbiAgLy8gUnVuIEJGUyBmb3IgZWFjaCBjb21wb25lbnQgb2YgdGhlIGdyYXBoLlxuXG4gIHZhciB2aXNpdGVkID0gbmV3IFNldCgpO1xuICB2YXIgdG9CZVZpc2l0ZWQgPSBbXTtcbiAgdmFyIHBhcmVudHMgPSBuZXcgTWFwKCk7XG4gIHZhciB1blByb2Nlc3NlZE5vZGVzID0gW107XG5cbiAgdW5Qcm9jZXNzZWROb2RlcyA9IHVuUHJvY2Vzc2VkTm9kZXMuY29uY2F0KGFsbE5vZGVzKTtcblxuICAvLyBFYWNoIGl0ZXJhdGlvbiBvZiB0aGlzIGxvb3AgZmluZHMgYSBjb21wb25lbnQgb2YgdGhlIGdyYXBoIGFuZFxuICAvLyBkZWNpZGVzIHdoZXRoZXIgaXQgaXMgYSB0cmVlIG9yIG5vdC4gSWYgaXQgaXMgYSB0cmVlLCBhZGRzIGl0IHRvIHRoZVxuICAvLyBmb3Jlc3QgYW5kIGNvbnRpbnVlZCB3aXRoIHRoZSBuZXh0IGNvbXBvbmVudC5cblxuICB3aGlsZSAodW5Qcm9jZXNzZWROb2Rlcy5sZW5ndGggPiAwICYmIGlzRm9yZXN0KSB7XG4gICAgdG9CZVZpc2l0ZWQucHVzaCh1blByb2Nlc3NlZE5vZGVzWzBdKTtcblxuICAgIC8vIFN0YXJ0IHRoZSBCRlMuIEVhY2ggaXRlcmF0aW9uIG9mIHRoaXMgbG9vcCB2aXNpdHMgYSBub2RlIGluIGFcbiAgICAvLyBCRlMgbWFubmVyLlxuICAgIHdoaWxlICh0b0JlVmlzaXRlZC5sZW5ndGggPiAwICYmIGlzRm9yZXN0KSB7XG4gICAgICAvL3Bvb2wgb3BlcmF0aW9uXG4gICAgICB2YXIgY3VycmVudE5vZGUgPSB0b0JlVmlzaXRlZFswXTtcbiAgICAgIHRvQmVWaXNpdGVkLnNwbGljZSgwLCAxKTtcbiAgICAgIHZpc2l0ZWQuYWRkKGN1cnJlbnROb2RlKTtcblxuICAgICAgLy8gVHJhdmVyc2UgYWxsIG5laWdoYm9ycyBvZiB0aGlzIG5vZGVcbiAgICAgIHZhciBuZWlnaGJvckVkZ2VzID0gY3VycmVudE5vZGUuZ2V0RWRnZXMoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZWlnaGJvckVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjdXJyZW50TmVpZ2hib3IgPSBuZWlnaGJvckVkZ2VzW2ldLmdldE90aGVyRW5kKGN1cnJlbnROb2RlKTtcblxuICAgICAgICAvLyBJZiBCRlMgaXMgbm90IGdyb3dpbmcgZnJvbSB0aGlzIG5laWdoYm9yLlxuICAgICAgICBpZiAocGFyZW50cy5nZXQoY3VycmVudE5vZGUpICE9IGN1cnJlbnROZWlnaGJvcikge1xuICAgICAgICAgIC8vIFdlIGhhdmVuJ3QgcHJldmlvdXNseSB2aXNpdGVkIHRoaXMgbmVpZ2hib3IuXG4gICAgICAgICAgaWYgKCF2aXNpdGVkLmhhcyhjdXJyZW50TmVpZ2hib3IpKSB7XG4gICAgICAgICAgICB0b0JlVmlzaXRlZC5wdXNoKGN1cnJlbnROZWlnaGJvcik7XG4gICAgICAgICAgICBwYXJlbnRzLnNldChjdXJyZW50TmVpZ2hib3IsIGN1cnJlbnROb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gU2luY2Ugd2UgaGF2ZSBwcmV2aW91c2x5IHZpc2l0ZWQgdGhpcyBuZWlnaGJvciBhbmRcbiAgICAgICAgICAvLyB0aGlzIG5laWdoYm9yIGlzIG5vdCBwYXJlbnQgb2YgY3VycmVudE5vZGUsIGdpdmVuXG4gICAgICAgICAgLy8gZ3JhcGggY29udGFpbnMgYSBjb21wb25lbnQgdGhhdCBpcyBub3QgdHJlZSwgaGVuY2VcbiAgICAgICAgICAvLyBpdCBpcyBub3QgYSBmb3Jlc3QuXG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGlzRm9yZXN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGhlIGdyYXBoIGNvbnRhaW5zIGEgY29tcG9uZW50IHRoYXQgaXMgbm90IGEgdHJlZS4gRW1wdHlcbiAgICAvLyBwcmV2aW91c2x5IGZvdW5kIHRyZWVzLiBUaGUgbWV0aG9kIHdpbGwgZW5kLlxuICAgIGlmICghaXNGb3Jlc3QpIHtcbiAgICAgIGZsYXRGb3Jlc3QgPSBbXTtcbiAgICB9XG4gICAgLy8gU2F2ZSBjdXJyZW50bHkgdmlzaXRlZCBub2RlcyBhcyBhIHRyZWUgaW4gb3VyIGZvcmVzdC4gUmVzZXRcbiAgICAvLyB2aXNpdGVkIGFuZCBwYXJlbnRzIGxpc3RzLiBDb250aW51ZSB3aXRoIHRoZSBuZXh0IGNvbXBvbmVudCBvZlxuICAgIC8vIHRoZSBncmFwaCwgaWYgYW55LlxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgdGVtcCA9IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkodmlzaXRlZCkpO1xuICAgICAgICBmbGF0Rm9yZXN0LnB1c2godGVtcCk7XG4gICAgICAgIC8vZmxhdEZvcmVzdCA9IGZsYXRGb3Jlc3QuY29uY2F0KHRlbXApO1xuICAgICAgICAvL3VuUHJvY2Vzc2VkTm9kZXMucmVtb3ZlQWxsKHZpc2l0ZWQpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRlbXAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSB0ZW1wW2ldO1xuICAgICAgICAgIHZhciBpbmRleCA9IHVuUHJvY2Vzc2VkTm9kZXMuaW5kZXhPZih2YWx1ZSk7XG4gICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIHVuUHJvY2Vzc2VkTm9kZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmlzaXRlZCA9IG5ldyBTZXQoKTtcbiAgICAgICAgcGFyZW50cyA9IG5ldyBNYXAoKTtcbiAgICAgIH1cbiAgfVxuXG4gIHJldHVybiBmbGF0Rm9yZXN0O1xufTtcblxuLyoqXHJcbiAqIFRoaXMgbWV0aG9kIGNyZWF0ZXMgZHVtbXkgbm9kZXMgKGFuIGwtbGV2ZWwgbm9kZSB3aXRoIG1pbmltYWwgZGltZW5zaW9ucylcclxuICogZm9yIHRoZSBnaXZlbiBlZGdlIChvbmUgcGVyIGJlbmRwb2ludCkuIFRoZSBleGlzdGluZyBsLWxldmVsIHN0cnVjdHVyZVxyXG4gKiBpcyB1cGRhdGVkIGFjY29yZGluZ2x5LlxyXG4gKi9cbkxheW91dC5wcm90b3R5cGUuY3JlYXRlRHVtbXlOb2Rlc0ZvckJlbmRwb2ludHMgPSBmdW5jdGlvbiAoZWRnZSkge1xuICB2YXIgZHVtbXlOb2RlcyA9IFtdO1xuICB2YXIgcHJldiA9IGVkZ2Uuc291cmNlO1xuXG4gIHZhciBncmFwaCA9IHRoaXMuZ3JhcGhNYW5hZ2VyLmNhbGNMb3dlc3RDb21tb25BbmNlc3RvcihlZGdlLnNvdXJjZSwgZWRnZS50YXJnZXQpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZS5iZW5kcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gY3JlYXRlIG5ldyBkdW1teSBub2RlXG4gICAgdmFyIGR1bW15Tm9kZSA9IHRoaXMubmV3Tm9kZShudWxsKTtcbiAgICBkdW1teU5vZGUuc2V0UmVjdChuZXcgUG9pbnQoMCwgMCksIG5ldyBEaW1lbnNpb24oMSwgMSkpO1xuXG4gICAgZ3JhcGguYWRkKGR1bW15Tm9kZSk7XG5cbiAgICAvLyBjcmVhdGUgbmV3IGR1bW15IGVkZ2UgYmV0d2VlbiBwcmV2IGFuZCBkdW1teSBub2RlXG4gICAgdmFyIGR1bW15RWRnZSA9IHRoaXMubmV3RWRnZShudWxsKTtcbiAgICB0aGlzLmdyYXBoTWFuYWdlci5hZGQoZHVtbXlFZGdlLCBwcmV2LCBkdW1teU5vZGUpO1xuXG4gICAgZHVtbXlOb2Rlcy5hZGQoZHVtbXlOb2RlKTtcbiAgICBwcmV2ID0gZHVtbXlOb2RlO1xuICB9XG5cbiAgdmFyIGR1bW15RWRnZSA9IHRoaXMubmV3RWRnZShudWxsKTtcbiAgdGhpcy5ncmFwaE1hbmFnZXIuYWRkKGR1bW15RWRnZSwgcHJldiwgZWRnZS50YXJnZXQpO1xuXG4gIHRoaXMuZWRnZVRvRHVtbXlOb2Rlcy5zZXQoZWRnZSwgZHVtbXlOb2Rlcyk7XG5cbiAgLy8gcmVtb3ZlIHJlYWwgZWRnZSBmcm9tIGdyYXBoIG1hbmFnZXIgaWYgaXQgaXMgaW50ZXItZ3JhcGhcbiAgaWYgKGVkZ2UuaXNJbnRlckdyYXBoKCkpIHtcbiAgICB0aGlzLmdyYXBoTWFuYWdlci5yZW1vdmUoZWRnZSk7XG4gIH1cbiAgLy8gZWxzZSwgcmVtb3ZlIHRoZSBlZGdlIGZyb20gdGhlIGN1cnJlbnQgZ3JhcGhcbiAgZWxzZSB7XG4gICAgICBncmFwaC5yZW1vdmUoZWRnZSk7XG4gICAgfVxuXG4gIHJldHVybiBkdW1teU5vZGVzO1xufTtcblxuLyoqXHJcbiAqIFRoaXMgbWV0aG9kIGNyZWF0ZXMgYmVuZHBvaW50cyBmb3IgZWRnZXMgZnJvbSB0aGUgZHVtbXkgbm9kZXNcclxuICogYXQgbC1sZXZlbC5cclxuICovXG5MYXlvdXQucHJvdG90eXBlLmNyZWF0ZUJlbmRwb2ludHNGcm9tRHVtbXlOb2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVkZ2VzID0gW107XG4gIGVkZ2VzID0gZWRnZXMuY29uY2F0KHRoaXMuZ3JhcGhNYW5hZ2VyLmdldEFsbEVkZ2VzKCkpO1xuICBlZGdlcyA9IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkodGhpcy5lZGdlVG9EdW1teU5vZGVzLmtleXMoKSkpLmNvbmNhdChlZGdlcyk7XG5cbiAgZm9yICh2YXIgayA9IDA7IGsgPCBlZGdlcy5sZW5ndGg7IGsrKykge1xuICAgIHZhciBsRWRnZSA9IGVkZ2VzW2tdO1xuXG4gICAgaWYgKGxFZGdlLmJlbmRwb2ludHMubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIHBhdGggPSB0aGlzLmVkZ2VUb0R1bW15Tm9kZXMuZ2V0KGxFZGdlKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBkdW1teU5vZGUgPSBwYXRoW2ldO1xuICAgICAgICB2YXIgcCA9IG5ldyBQb2ludEQoZHVtbXlOb2RlLmdldENlbnRlclgoKSwgZHVtbXlOb2RlLmdldENlbnRlclkoKSk7XG5cbiAgICAgICAgLy8gdXBkYXRlIGJlbmRwb2ludCdzIGxvY2F0aW9uIGFjY29yZGluZyB0byBkdW1teSBub2RlXG4gICAgICAgIHZhciBlYnAgPSBsRWRnZS5iZW5kcG9pbnRzLmdldChpKTtcbiAgICAgICAgZWJwLnggPSBwLng7XG4gICAgICAgIGVicC55ID0gcC55O1xuXG4gICAgICAgIC8vIHJlbW92ZSB0aGUgZHVtbXkgbm9kZSwgZHVtbXkgZWRnZXMgaW5jaWRlbnQgd2l0aCB0aGlzXG4gICAgICAgIC8vIGR1bW15IG5vZGUgaXMgYWxzbyByZW1vdmVkICh3aXRoaW4gdGhlIHJlbW92ZSBtZXRob2QpXG4gICAgICAgIGR1bW15Tm9kZS5nZXRPd25lcigpLnJlbW92ZShkdW1teU5vZGUpO1xuICAgICAgfVxuXG4gICAgICAvLyBhZGQgdGhlIHJlYWwgZWRnZSB0byBncmFwaFxuICAgICAgdGhpcy5ncmFwaE1hbmFnZXIuYWRkKGxFZGdlLCBsRWRnZS5zb3VyY2UsIGxFZGdlLnRhcmdldCk7XG4gICAgfVxuICB9XG59O1xuXG5MYXlvdXQudHJhbnNmb3JtID0gZnVuY3Rpb24gKHNsaWRlclZhbHVlLCBkZWZhdWx0VmFsdWUsIG1pbkRpdiwgbWF4TXVsKSB7XG4gIGlmIChtaW5EaXYgIT0gdW5kZWZpbmVkICYmIG1heE11bCAhPSB1bmRlZmluZWQpIHtcbiAgICB2YXIgdmFsdWUgPSBkZWZhdWx0VmFsdWU7XG5cbiAgICBpZiAoc2xpZGVyVmFsdWUgPD0gNTApIHtcbiAgICAgIHZhciBtaW5WYWx1ZSA9IGRlZmF1bHRWYWx1ZSAvIG1pbkRpdjtcbiAgICAgIHZhbHVlIC09IChkZWZhdWx0VmFsdWUgLSBtaW5WYWx1ZSkgLyA1MCAqICg1MCAtIHNsaWRlclZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG1heFZhbHVlID0gZGVmYXVsdFZhbHVlICogbWF4TXVsO1xuICAgICAgdmFsdWUgKz0gKG1heFZhbHVlIC0gZGVmYXVsdFZhbHVlKSAvIDUwICogKHNsaWRlclZhbHVlIC0gNTApO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgYSwgYjtcblxuICAgIGlmIChzbGlkZXJWYWx1ZSA8PSA1MCkge1xuICAgICAgYSA9IDkuMCAqIGRlZmF1bHRWYWx1ZSAvIDUwMC4wO1xuICAgICAgYiA9IGRlZmF1bHRWYWx1ZSAvIDEwLjA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSA5LjAgKiBkZWZhdWx0VmFsdWUgLyA1MC4wO1xuICAgICAgYiA9IC04ICogZGVmYXVsdFZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBhICogc2xpZGVyVmFsdWUgKyBiO1xuICB9XG59O1xuXG4vKipcclxuICogVGhpcyBtZXRob2QgZmluZHMgYW5kIHJldHVybnMgdGhlIGNlbnRlciBvZiB0aGUgZ2l2ZW4gbm9kZXMsIGFzc3VtaW5nXHJcbiAqIHRoYXQgdGhlIGdpdmVuIG5vZGVzIGZvcm0gYSB0cmVlIGluIHRoZW1zZWx2ZXMuXHJcbiAqL1xuTGF5b3V0LmZpbmRDZW50ZXJPZlRyZWUgPSBmdW5jdGlvbiAobm9kZXMpIHtcbiAgdmFyIGxpc3QgPSBbXTtcbiAgbGlzdCA9IGxpc3QuY29uY2F0KG5vZGVzKTtcblxuICB2YXIgcmVtb3ZlZE5vZGVzID0gW107XG4gIHZhciByZW1haW5pbmdEZWdyZWVzID0gbmV3IE1hcCgpO1xuICB2YXIgZm91bmRDZW50ZXIgPSBmYWxzZTtcbiAgdmFyIGNlbnRlck5vZGUgPSBudWxsO1xuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PSAxIHx8IGxpc3QubGVuZ3RoID09IDIpIHtcbiAgICBmb3VuZENlbnRlciA9IHRydWU7XG4gICAgY2VudGVyTm9kZSA9IGxpc3RbMF07XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbm9kZSA9IGxpc3RbaV07XG4gICAgdmFyIGRlZ3JlZSA9IG5vZGUuZ2V0TmVpZ2hib3JzTGlzdCgpLnNpemU7XG4gICAgcmVtYWluaW5nRGVncmVlcy5zZXQobm9kZSwgbm9kZS5nZXROZWlnaGJvcnNMaXN0KCkuc2l6ZSk7XG5cbiAgICBpZiAoZGVncmVlID09IDEpIHtcbiAgICAgIHJlbW92ZWROb2Rlcy5wdXNoKG5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciB0ZW1wTGlzdCA9IFtdO1xuICB0ZW1wTGlzdCA9IHRlbXBMaXN0LmNvbmNhdChyZW1vdmVkTm9kZXMpO1xuXG4gIHdoaWxlICghZm91bmRDZW50ZXIpIHtcbiAgICB2YXIgdGVtcExpc3QyID0gW107XG4gICAgdGVtcExpc3QyID0gdGVtcExpc3QyLmNvbmNhdCh0ZW1wTGlzdCk7XG4gICAgdGVtcExpc3QgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5vZGUgPSBsaXN0W2ldO1xuXG4gICAgICB2YXIgaW5kZXggPSBsaXN0LmluZGV4T2Yobm9kZSk7XG4gICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICBsaXN0LnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBuZWlnaGJvdXJzID0gbm9kZS5nZXROZWlnaGJvcnNMaXN0KCk7XG5cbiAgICAgIG5laWdoYm91cnMuZm9yRWFjaChmdW5jdGlvbiAobmVpZ2hib3VyKSB7XG4gICAgICAgIGlmIChyZW1vdmVkTm9kZXMuaW5kZXhPZihuZWlnaGJvdXIpIDwgMCkge1xuICAgICAgICAgIHZhciBvdGhlckRlZ3JlZSA9IHJlbWFpbmluZ0RlZ3JlZXMuZ2V0KG5laWdoYm91cik7XG4gICAgICAgICAgdmFyIG5ld0RlZ3JlZSA9IG90aGVyRGVncmVlIC0gMTtcblxuICAgICAgICAgIGlmIChuZXdEZWdyZWUgPT0gMSkge1xuICAgICAgICAgICAgdGVtcExpc3QucHVzaChuZWlnaGJvdXIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlbWFpbmluZ0RlZ3JlZXMuc2V0KG5laWdoYm91ciwgbmV3RGVncmVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVtb3ZlZE5vZGVzID0gcmVtb3ZlZE5vZGVzLmNvbmNhdCh0ZW1wTGlzdCk7XG5cbiAgICBpZiAobGlzdC5sZW5ndGggPT0gMSB8fCBsaXN0Lmxlbmd0aCA9PSAyKSB7XG4gICAgICBmb3VuZENlbnRlciA9IHRydWU7XG4gICAgICBjZW50ZXJOb2RlID0gbGlzdFswXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2VudGVyTm9kZTtcbn07XG5cbi8qKlxyXG4gKiBEdXJpbmcgdGhlIGNvYXJzZW5pbmcgcHJvY2VzcywgdGhpcyBsYXlvdXQgbWF5IGJlIHJlZmVyZW5jZWQgYnkgdHdvIGdyYXBoIG1hbmFnZXJzXHJcbiAqIHRoaXMgc2V0dGVyIGZ1bmN0aW9uIGdyYW50cyBhY2Nlc3MgdG8gY2hhbmdlIHRoZSBjdXJyZW50bHkgYmVpbmcgdXNlZCBncmFwaCBtYW5hZ2VyXHJcbiAqL1xuTGF5b3V0LnByb3RvdHlwZS5zZXRHcmFwaE1hbmFnZXIgPSBmdW5jdGlvbiAoZ20pIHtcbiAgdGhpcy5ncmFwaE1hbmFnZXIgPSBnbTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTGF5b3V0O1xuXG4vKioqLyB9KSxcbi8qIDE2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIFJhbmRvbVNlZWQoKSB7fVxuLy8gYWRhcHRlZCBmcm9tOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTkzMDM3MjVcblJhbmRvbVNlZWQuc2VlZCA9IDE7XG5SYW5kb21TZWVkLnggPSAwO1xuXG5SYW5kb21TZWVkLm5leHREb3VibGUgPSBmdW5jdGlvbiAoKSB7XG4gIFJhbmRvbVNlZWQueCA9IE1hdGguc2luKFJhbmRvbVNlZWQuc2VlZCsrKSAqIDEwMDAwO1xuICByZXR1cm4gUmFuZG9tU2VlZC54IC0gTWF0aC5mbG9vcihSYW5kb21TZWVkLngpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSYW5kb21TZWVkO1xuXG4vKioqLyB9KSxcbi8qIDE3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBQb2ludEQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG5mdW5jdGlvbiBUcmFuc2Zvcm0oeCwgeSkge1xuICB0aGlzLmx3b3JsZE9yZ1ggPSAwLjA7XG4gIHRoaXMubHdvcmxkT3JnWSA9IDAuMDtcbiAgdGhpcy5sZGV2aWNlT3JnWCA9IDAuMDtcbiAgdGhpcy5sZGV2aWNlT3JnWSA9IDAuMDtcbiAgdGhpcy5sd29ybGRFeHRYID0gMS4wO1xuICB0aGlzLmx3b3JsZEV4dFkgPSAxLjA7XG4gIHRoaXMubGRldmljZUV4dFggPSAxLjA7XG4gIHRoaXMubGRldmljZUV4dFkgPSAxLjA7XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuZ2V0V29ybGRPcmdYID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sd29ybGRPcmdYO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5zZXRXb3JsZE9yZ1ggPSBmdW5jdGlvbiAod294KSB7XG4gIHRoaXMubHdvcmxkT3JnWCA9IHdveDtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuZ2V0V29ybGRPcmdZID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sd29ybGRPcmdZO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5zZXRXb3JsZE9yZ1kgPSBmdW5jdGlvbiAod295KSB7XG4gIHRoaXMubHdvcmxkT3JnWSA9IHdveTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuZ2V0V29ybGRFeHRYID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sd29ybGRFeHRYO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5zZXRXb3JsZEV4dFggPSBmdW5jdGlvbiAod2V4KSB7XG4gIHRoaXMubHdvcmxkRXh0WCA9IHdleDtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuZ2V0V29ybGRFeHRZID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sd29ybGRFeHRZO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5zZXRXb3JsZEV4dFkgPSBmdW5jdGlvbiAod2V5KSB7XG4gIHRoaXMubHdvcmxkRXh0WSA9IHdleTtcbn07XG5cbi8qIERldmljZSByZWxhdGVkICovXG5cblRyYW5zZm9ybS5wcm90b3R5cGUuZ2V0RGV2aWNlT3JnWCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubGRldmljZU9yZ1g7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnNldERldmljZU9yZ1ggPSBmdW5jdGlvbiAoZG94KSB7XG4gIHRoaXMubGRldmljZU9yZ1ggPSBkb3g7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLmdldERldmljZU9yZ1kgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmxkZXZpY2VPcmdZO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5zZXREZXZpY2VPcmdZID0gZnVuY3Rpb24gKGRveSkge1xuICB0aGlzLmxkZXZpY2VPcmdZID0gZG95O1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5nZXREZXZpY2VFeHRYID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sZGV2aWNlRXh0WDtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuc2V0RGV2aWNlRXh0WCA9IGZ1bmN0aW9uIChkZXgpIHtcbiAgdGhpcy5sZGV2aWNlRXh0WCA9IGRleDtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuZ2V0RGV2aWNlRXh0WSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubGRldmljZUV4dFk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnNldERldmljZUV4dFkgPSBmdW5jdGlvbiAoZGV5KSB7XG4gIHRoaXMubGRldmljZUV4dFkgPSBkZXk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnRyYW5zZm9ybVggPSBmdW5jdGlvbiAoeCkge1xuICB2YXIgeERldmljZSA9IDAuMDtcbiAgdmFyIHdvcmxkRXh0WCA9IHRoaXMubHdvcmxkRXh0WDtcbiAgaWYgKHdvcmxkRXh0WCAhPSAwLjApIHtcbiAgICB4RGV2aWNlID0gdGhpcy5sZGV2aWNlT3JnWCArICh4IC0gdGhpcy5sd29ybGRPcmdYKSAqIHRoaXMubGRldmljZUV4dFggLyB3b3JsZEV4dFg7XG4gIH1cblxuICByZXR1cm4geERldmljZTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUudHJhbnNmb3JtWSA9IGZ1bmN0aW9uICh5KSB7XG4gIHZhciB5RGV2aWNlID0gMC4wO1xuICB2YXIgd29ybGRFeHRZID0gdGhpcy5sd29ybGRFeHRZO1xuICBpZiAod29ybGRFeHRZICE9IDAuMCkge1xuICAgIHlEZXZpY2UgPSB0aGlzLmxkZXZpY2VPcmdZICsgKHkgLSB0aGlzLmx3b3JsZE9yZ1kpICogdGhpcy5sZGV2aWNlRXh0WSAvIHdvcmxkRXh0WTtcbiAgfVxuXG4gIHJldHVybiB5RGV2aWNlO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5pbnZlcnNlVHJhbnNmb3JtWCA9IGZ1bmN0aW9uICh4KSB7XG4gIHZhciB4V29ybGQgPSAwLjA7XG4gIHZhciBkZXZpY2VFeHRYID0gdGhpcy5sZGV2aWNlRXh0WDtcbiAgaWYgKGRldmljZUV4dFggIT0gMC4wKSB7XG4gICAgeFdvcmxkID0gdGhpcy5sd29ybGRPcmdYICsgKHggLSB0aGlzLmxkZXZpY2VPcmdYKSAqIHRoaXMubHdvcmxkRXh0WCAvIGRldmljZUV4dFg7XG4gIH1cblxuICByZXR1cm4geFdvcmxkO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5pbnZlcnNlVHJhbnNmb3JtWSA9IGZ1bmN0aW9uICh5KSB7XG4gIHZhciB5V29ybGQgPSAwLjA7XG4gIHZhciBkZXZpY2VFeHRZID0gdGhpcy5sZGV2aWNlRXh0WTtcbiAgaWYgKGRldmljZUV4dFkgIT0gMC4wKSB7XG4gICAgeVdvcmxkID0gdGhpcy5sd29ybGRPcmdZICsgKHkgLSB0aGlzLmxkZXZpY2VPcmdZKSAqIHRoaXMubHdvcmxkRXh0WSAvIGRldmljZUV4dFk7XG4gIH1cbiAgcmV0dXJuIHlXb3JsZDtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuaW52ZXJzZVRyYW5zZm9ybVBvaW50ID0gZnVuY3Rpb24gKGluUG9pbnQpIHtcbiAgdmFyIG91dFBvaW50ID0gbmV3IFBvaW50RCh0aGlzLmludmVyc2VUcmFuc2Zvcm1YKGluUG9pbnQueCksIHRoaXMuaW52ZXJzZVRyYW5zZm9ybVkoaW5Qb2ludC55KSk7XG4gIHJldHVybiBvdXRQb2ludDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xuXG4vKioqLyB9KSxcbi8qIDE4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH0gZWxzZSB7IHJldHVybiBBcnJheS5mcm9tKGFycik7IH0gfVxuXG52YXIgTGF5b3V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG52YXIgRkRMYXlvdXRDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xudmFyIExheW91dENvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgSUdlb21ldHJ5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcbnZhciBJTWF0aCA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbmZ1bmN0aW9uIEZETGF5b3V0KCkge1xuICBMYXlvdXQuY2FsbCh0aGlzKTtcblxuICB0aGlzLnVzZVNtYXJ0SWRlYWxFZGdlTGVuZ3RoQ2FsY3VsYXRpb24gPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX1VTRV9TTUFSVF9JREVBTF9FREdFX0xFTkdUSF9DQUxDVUxBVElPTjtcbiAgdGhpcy5pZGVhbEVkZ2VMZW5ndGggPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIO1xuICB0aGlzLnNwcmluZ0NvbnN0YW50ID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9TUFJJTkdfU1RSRU5HVEg7XG4gIHRoaXMucmVwdWxzaW9uQ29uc3RhbnQgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX1JFUFVMU0lPTl9TVFJFTkdUSDtcbiAgdGhpcy5ncmF2aXR5Q29uc3RhbnQgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0dSQVZJVFlfU1RSRU5HVEg7XG4gIHRoaXMuY29tcG91bmRHcmF2aXR5Q29uc3RhbnQgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0NPTVBPVU5EX0dSQVZJVFlfU1RSRU5HVEg7XG4gIHRoaXMuZ3Jhdml0eVJhbmdlRmFjdG9yID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9HUkFWSVRZX1JBTkdFX0ZBQ1RPUjtcbiAgdGhpcy5jb21wb3VuZEdyYXZpdHlSYW5nZUZhY3RvciA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQ09NUE9VTkRfR1JBVklUWV9SQU5HRV9GQUNUT1I7XG4gIHRoaXMuZGlzcGxhY2VtZW50VGhyZXNob2xkUGVyTm9kZSA9IDMuMCAqIEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggLyAxMDA7XG4gIHRoaXMuY29vbGluZ0ZhY3RvciA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQ09PTElOR19GQUNUT1JfSU5DUkVNRU5UQUw7XG4gIHRoaXMuaW5pdGlhbENvb2xpbmdGYWN0b3IgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0NPT0xJTkdfRkFDVE9SX0lOQ1JFTUVOVEFMO1xuICB0aGlzLnRvdGFsRGlzcGxhY2VtZW50ID0gMC4wO1xuICB0aGlzLm9sZFRvdGFsRGlzcGxhY2VtZW50ID0gMC4wO1xuICB0aGlzLm1heEl0ZXJhdGlvbnMgPSBGRExheW91dENvbnN0YW50cy5NQVhfSVRFUkFUSU9OUztcbn1cblxuRkRMYXlvdXQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShMYXlvdXQucHJvdG90eXBlKTtcblxuZm9yICh2YXIgcHJvcCBpbiBMYXlvdXQpIHtcbiAgRkRMYXlvdXRbcHJvcF0gPSBMYXlvdXRbcHJvcF07XG59XG5cbkZETGF5b3V0LnByb3RvdHlwZS5pbml0UGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgTGF5b3V0LnByb3RvdHlwZS5pbml0UGFyYW1ldGVycy5jYWxsKHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgdGhpcy50b3RhbEl0ZXJhdGlvbnMgPSAwO1xuICB0aGlzLm5vdEFuaW1hdGVkSXRlcmF0aW9ucyA9IDA7XG5cbiAgdGhpcy51c2VGUkdyaWRWYXJpYW50ID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9VU0VfU01BUlRfUkVQVUxTSU9OX1JBTkdFX0NBTENVTEFUSU9OO1xuXG4gIHRoaXMuZ3JpZCA9IFtdO1xufTtcblxuRkRMYXlvdXQucHJvdG90eXBlLmNhbGNJZGVhbEVkZ2VMZW5ndGhzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZWRnZTtcbiAgdmFyIGxjYURlcHRoO1xuICB2YXIgc291cmNlO1xuICB2YXIgdGFyZ2V0O1xuICB2YXIgc2l6ZU9mU291cmNlSW5MY2E7XG4gIHZhciBzaXplT2ZUYXJnZXRJbkxjYTtcblxuICB2YXIgYWxsRWRnZXMgPSB0aGlzLmdldEdyYXBoTWFuYWdlcigpLmdldEFsbEVkZ2VzKCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsRWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICBlZGdlID0gYWxsRWRnZXNbaV07XG5cbiAgICBlZGdlLmlkZWFsTGVuZ3RoID0gdGhpcy5pZGVhbEVkZ2VMZW5ndGg7XG5cbiAgICBpZiAoZWRnZS5pc0ludGVyR3JhcGgpIHtcbiAgICAgIHNvdXJjZSA9IGVkZ2UuZ2V0U291cmNlKCk7XG4gICAgICB0YXJnZXQgPSBlZGdlLmdldFRhcmdldCgpO1xuXG4gICAgICBzaXplT2ZTb3VyY2VJbkxjYSA9IGVkZ2UuZ2V0U291cmNlSW5MY2EoKS5nZXRFc3RpbWF0ZWRTaXplKCk7XG4gICAgICBzaXplT2ZUYXJnZXRJbkxjYSA9IGVkZ2UuZ2V0VGFyZ2V0SW5MY2EoKS5nZXRFc3RpbWF0ZWRTaXplKCk7XG5cbiAgICAgIGlmICh0aGlzLnVzZVNtYXJ0SWRlYWxFZGdlTGVuZ3RoQ2FsY3VsYXRpb24pIHtcbiAgICAgICAgZWRnZS5pZGVhbExlbmd0aCArPSBzaXplT2ZTb3VyY2VJbkxjYSArIHNpemVPZlRhcmdldEluTGNhIC0gMiAqIExheW91dENvbnN0YW50cy5TSU1QTEVfTk9ERV9TSVpFO1xuICAgICAgfVxuXG4gICAgICBsY2FEZXB0aCA9IGVkZ2UuZ2V0TGNhKCkuZ2V0SW5jbHVzaW9uVHJlZURlcHRoKCk7XG5cbiAgICAgIGVkZ2UuaWRlYWxMZW5ndGggKz0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSCAqIEZETGF5b3V0Q29uc3RhbnRzLlBFUl9MRVZFTF9JREVBTF9FREdFX0xFTkdUSF9GQUNUT1IgKiAoc291cmNlLmdldEluY2x1c2lvblRyZWVEZXB0aCgpICsgdGFyZ2V0LmdldEluY2x1c2lvblRyZWVEZXB0aCgpIC0gMiAqIGxjYURlcHRoKTtcbiAgICB9XG4gIH1cbn07XG5cbkZETGF5b3V0LnByb3RvdHlwZS5pbml0U3ByaW5nRW1iZWRkZXIgPSBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIHMgPSB0aGlzLmdldEFsbE5vZGVzKCkubGVuZ3RoO1xuICBpZiAodGhpcy5pbmNyZW1lbnRhbCkge1xuICAgIGlmIChzID4gRkRMYXlvdXRDb25zdGFudHMuQURBUFRBVElPTl9MT1dFUl9OT0RFX0xJTUlUKSB7XG4gICAgICB0aGlzLmNvb2xpbmdGYWN0b3IgPSBNYXRoLm1heCh0aGlzLmNvb2xpbmdGYWN0b3IgKiBGRExheW91dENvbnN0YW50cy5DT09MSU5HX0FEQVBUQVRJT05fRkFDVE9SLCB0aGlzLmNvb2xpbmdGYWN0b3IgLSAocyAtIEZETGF5b3V0Q29uc3RhbnRzLkFEQVBUQVRJT05fTE9XRVJfTk9ERV9MSU1JVCkgLyAoRkRMYXlvdXRDb25zdGFudHMuQURBUFRBVElPTl9VUFBFUl9OT0RFX0xJTUlUIC0gRkRMYXlvdXRDb25zdGFudHMuQURBUFRBVElPTl9MT1dFUl9OT0RFX0xJTUlUKSAqIHRoaXMuY29vbGluZ0ZhY3RvciAqICgxIC0gRkRMYXlvdXRDb25zdGFudHMuQ09PTElOR19BREFQVEFUSU9OX0ZBQ1RPUikpO1xuICAgIH1cbiAgICB0aGlzLm1heE5vZGVEaXNwbGFjZW1lbnQgPSBGRExheW91dENvbnN0YW50cy5NQVhfTk9ERV9ESVNQTEFDRU1FTlRfSU5DUkVNRU5UQUw7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHMgPiBGRExheW91dENvbnN0YW50cy5BREFQVEFUSU9OX0xPV0VSX05PREVfTElNSVQpIHtcbiAgICAgIHRoaXMuY29vbGluZ0ZhY3RvciA9IE1hdGgubWF4KEZETGF5b3V0Q29uc3RhbnRzLkNPT0xJTkdfQURBUFRBVElPTl9GQUNUT1IsIDEuMCAtIChzIC0gRkRMYXlvdXRDb25zdGFudHMuQURBUFRBVElPTl9MT1dFUl9OT0RFX0xJTUlUKSAvIChGRExheW91dENvbnN0YW50cy5BREFQVEFUSU9OX1VQUEVSX05PREVfTElNSVQgLSBGRExheW91dENvbnN0YW50cy5BREFQVEFUSU9OX0xPV0VSX05PREVfTElNSVQpICogKDEgLSBGRExheW91dENvbnN0YW50cy5DT09MSU5HX0FEQVBUQVRJT05fRkFDVE9SKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29vbGluZ0ZhY3RvciA9IDEuMDtcbiAgICB9XG4gICAgdGhpcy5pbml0aWFsQ29vbGluZ0ZhY3RvciA9IHRoaXMuY29vbGluZ0ZhY3RvcjtcbiAgICB0aGlzLm1heE5vZGVEaXNwbGFjZW1lbnQgPSBGRExheW91dENvbnN0YW50cy5NQVhfTk9ERV9ESVNQTEFDRU1FTlQ7XG4gIH1cblxuICB0aGlzLm1heEl0ZXJhdGlvbnMgPSBNYXRoLm1heCh0aGlzLmdldEFsbE5vZGVzKCkubGVuZ3RoICogNSwgdGhpcy5tYXhJdGVyYXRpb25zKTtcblxuICB0aGlzLnRvdGFsRGlzcGxhY2VtZW50VGhyZXNob2xkID0gdGhpcy5kaXNwbGFjZW1lbnRUaHJlc2hvbGRQZXJOb2RlICogdGhpcy5nZXRBbGxOb2RlcygpLmxlbmd0aDtcblxuICB0aGlzLnJlcHVsc2lvblJhbmdlID0gdGhpcy5jYWxjUmVwdWxzaW9uUmFuZ2UoKTtcbn07XG5cbkZETGF5b3V0LnByb3RvdHlwZS5jYWxjU3ByaW5nRm9yY2VzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbEVkZ2VzID0gdGhpcy5nZXRBbGxFZGdlcygpO1xuICB2YXIgZWRnZTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxFZGdlcy5sZW5ndGg7IGkrKykge1xuICAgIGVkZ2UgPSBsRWRnZXNbaV07XG5cbiAgICB0aGlzLmNhbGNTcHJpbmdGb3JjZShlZGdlLCBlZGdlLmlkZWFsTGVuZ3RoKTtcbiAgfVxufTtcblxuRkRMYXlvdXQucHJvdG90eXBlLmNhbGNSZXB1bHNpb25Gb3JjZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBncmlkVXBkYXRlQWxsb3dlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdHJ1ZTtcbiAgdmFyIGZvcmNlVG9Ob2RlU3Vycm91bmRpbmdVcGRhdGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gIHZhciBpLCBqO1xuICB2YXIgbm9kZUEsIG5vZGVCO1xuICB2YXIgbE5vZGVzID0gdGhpcy5nZXRBbGxOb2RlcygpO1xuICB2YXIgcHJvY2Vzc2VkTm9kZVNldDtcblxuICBpZiAodGhpcy51c2VGUkdyaWRWYXJpYW50KSB7XG4gICAgaWYgKHRoaXMudG90YWxJdGVyYXRpb25zICUgRkRMYXlvdXRDb25zdGFudHMuR1JJRF9DQUxDVUxBVElPTl9DSEVDS19QRVJJT0QgPT0gMSAmJiBncmlkVXBkYXRlQWxsb3dlZCkge1xuICAgICAgdGhpcy51cGRhdGVHcmlkKCk7XG4gICAgfVxuXG4gICAgcHJvY2Vzc2VkTm9kZVNldCA9IG5ldyBTZXQoKTtcblxuICAgIC8vIGNhbGN1bGF0ZSByZXB1bHNpb24gZm9yY2VzIGJldHdlZW4gZWFjaCBub2RlcyBhbmQgaXRzIHN1cnJvdW5kaW5nXG4gICAgZm9yIChpID0gMDsgaSA8IGxOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgbm9kZUEgPSBsTm9kZXNbaV07XG4gICAgICB0aGlzLmNhbGN1bGF0ZVJlcHVsc2lvbkZvcmNlT2ZBTm9kZShub2RlQSwgcHJvY2Vzc2VkTm9kZVNldCwgZ3JpZFVwZGF0ZUFsbG93ZWQsIGZvcmNlVG9Ob2RlU3Vycm91bmRpbmdVcGRhdGUpO1xuICAgICAgcHJvY2Vzc2VkTm9kZVNldC5hZGQobm9kZUEpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBub2RlQSA9IGxOb2Rlc1tpXTtcblxuICAgICAgZm9yIChqID0gaSArIDE7IGogPCBsTm9kZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgbm9kZUIgPSBsTm9kZXNbal07XG5cbiAgICAgICAgLy8gSWYgYm90aCBub2RlcyBhcmUgbm90IG1lbWJlcnMgb2YgdGhlIHNhbWUgZ3JhcGgsIHNraXAuXG4gICAgICAgIGlmIChub2RlQS5nZXRPd25lcigpICE9IG5vZGVCLmdldE93bmVyKCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FsY1JlcHVsc2lvbkZvcmNlKG5vZGVBLCBub2RlQik7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5GRExheW91dC5wcm90b3R5cGUuY2FsY0dyYXZpdGF0aW9uYWxGb3JjZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBub2RlO1xuICB2YXIgbE5vZGVzID0gdGhpcy5nZXRBbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbigpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgbm9kZSA9IGxOb2Rlc1tpXTtcbiAgICB0aGlzLmNhbGNHcmF2aXRhdGlvbmFsRm9yY2Uobm9kZSk7XG4gIH1cbn07XG5cbkZETGF5b3V0LnByb3RvdHlwZS5tb3ZlTm9kZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsTm9kZXMgPSB0aGlzLmdldEFsbE5vZGVzKCk7XG4gIHZhciBub2RlO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgbm9kZSA9IGxOb2Rlc1tpXTtcbiAgICBub2RlLm1vdmUoKTtcbiAgfVxufTtcblxuRkRMYXlvdXQucHJvdG90eXBlLmNhbGNTcHJpbmdGb3JjZSA9IGZ1bmN0aW9uIChlZGdlLCBpZGVhbExlbmd0aCkge1xuICB2YXIgc291cmNlTm9kZSA9IGVkZ2UuZ2V0U291cmNlKCk7XG4gIHZhciB0YXJnZXROb2RlID0gZWRnZS5nZXRUYXJnZXQoKTtcblxuICB2YXIgbGVuZ3RoO1xuICB2YXIgc3ByaW5nRm9yY2U7XG4gIHZhciBzcHJpbmdGb3JjZVg7XG4gIHZhciBzcHJpbmdGb3JjZVk7XG5cbiAgLy8gVXBkYXRlIGVkZ2UgbGVuZ3RoXG4gIGlmICh0aGlzLnVuaWZvcm1MZWFmTm9kZVNpemVzICYmIHNvdXJjZU5vZGUuZ2V0Q2hpbGQoKSA9PSBudWxsICYmIHRhcmdldE5vZGUuZ2V0Q2hpbGQoKSA9PSBudWxsKSB7XG4gICAgZWRnZS51cGRhdGVMZW5ndGhTaW1wbGUoKTtcbiAgfSBlbHNlIHtcbiAgICBlZGdlLnVwZGF0ZUxlbmd0aCgpO1xuXG4gICAgaWYgKGVkZ2UuaXNPdmVybGFwaW5nU291cmNlQW5kVGFyZ2V0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgbGVuZ3RoID0gZWRnZS5nZXRMZW5ndGgoKTtcblxuICBpZiAobGVuZ3RoID09IDApIHJldHVybjtcblxuICAvLyBDYWxjdWxhdGUgc3ByaW5nIGZvcmNlc1xuICBzcHJpbmdGb3JjZSA9IHRoaXMuc3ByaW5nQ29uc3RhbnQgKiAobGVuZ3RoIC0gaWRlYWxMZW5ndGgpO1xuXG4gIC8vIFByb2plY3QgZm9yY2Ugb250byB4IGFuZCB5IGF4ZXNcbiAgc3ByaW5nRm9yY2VYID0gc3ByaW5nRm9yY2UgKiAoZWRnZS5sZW5ndGhYIC8gbGVuZ3RoKTtcbiAgc3ByaW5nRm9yY2VZID0gc3ByaW5nRm9yY2UgKiAoZWRnZS5sZW5ndGhZIC8gbGVuZ3RoKTtcblxuICAvLyBBcHBseSBmb3JjZXMgb24gdGhlIGVuZCBub2Rlc1xuICBzb3VyY2VOb2RlLnNwcmluZ0ZvcmNlWCArPSBzcHJpbmdGb3JjZVg7XG4gIHNvdXJjZU5vZGUuc3ByaW5nRm9yY2VZICs9IHNwcmluZ0ZvcmNlWTtcbiAgdGFyZ2V0Tm9kZS5zcHJpbmdGb3JjZVggLT0gc3ByaW5nRm9yY2VYO1xuICB0YXJnZXROb2RlLnNwcmluZ0ZvcmNlWSAtPSBzcHJpbmdGb3JjZVk7XG59O1xuXG5GRExheW91dC5wcm90b3R5cGUuY2FsY1JlcHVsc2lvbkZvcmNlID0gZnVuY3Rpb24gKG5vZGVBLCBub2RlQikge1xuICB2YXIgcmVjdEEgPSBub2RlQS5nZXRSZWN0KCk7XG4gIHZhciByZWN0QiA9IG5vZGVCLmdldFJlY3QoKTtcbiAgdmFyIG92ZXJsYXBBbW91bnQgPSBuZXcgQXJyYXkoMik7XG4gIHZhciBjbGlwUG9pbnRzID0gbmV3IEFycmF5KDQpO1xuICB2YXIgZGlzdGFuY2VYO1xuICB2YXIgZGlzdGFuY2VZO1xuICB2YXIgZGlzdGFuY2VTcXVhcmVkO1xuICB2YXIgZGlzdGFuY2U7XG4gIHZhciByZXB1bHNpb25Gb3JjZTtcbiAgdmFyIHJlcHVsc2lvbkZvcmNlWDtcbiAgdmFyIHJlcHVsc2lvbkZvcmNlWTtcblxuICBpZiAocmVjdEEuaW50ZXJzZWN0cyhyZWN0QikpIC8vIHR3byBub2RlcyBvdmVybGFwXG4gICAge1xuICAgICAgLy8gY2FsY3VsYXRlIHNlcGFyYXRpb24gYW1vdW50IGluIHggYW5kIHkgZGlyZWN0aW9uc1xuICAgICAgSUdlb21ldHJ5LmNhbGNTZXBhcmF0aW9uQW1vdW50KHJlY3RBLCByZWN0Qiwgb3ZlcmxhcEFtb3VudCwgRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSCAvIDIuMCk7XG5cbiAgICAgIHJlcHVsc2lvbkZvcmNlWCA9IDIgKiBvdmVybGFwQW1vdW50WzBdO1xuICAgICAgcmVwdWxzaW9uRm9yY2VZID0gMiAqIG92ZXJsYXBBbW91bnRbMV07XG5cbiAgICAgIHZhciBjaGlsZHJlbkNvbnN0YW50ID0gbm9kZUEubm9PZkNoaWxkcmVuICogbm9kZUIubm9PZkNoaWxkcmVuIC8gKG5vZGVBLm5vT2ZDaGlsZHJlbiArIG5vZGVCLm5vT2ZDaGlsZHJlbik7XG5cbiAgICAgIC8vIEFwcGx5IGZvcmNlcyBvbiB0aGUgdHdvIG5vZGVzXG4gICAgICBub2RlQS5yZXB1bHNpb25Gb3JjZVggLT0gY2hpbGRyZW5Db25zdGFudCAqIHJlcHVsc2lvbkZvcmNlWDtcbiAgICAgIG5vZGVBLnJlcHVsc2lvbkZvcmNlWSAtPSBjaGlsZHJlbkNvbnN0YW50ICogcmVwdWxzaW9uRm9yY2VZO1xuICAgICAgbm9kZUIucmVwdWxzaW9uRm9yY2VYICs9IGNoaWxkcmVuQ29uc3RhbnQgKiByZXB1bHNpb25Gb3JjZVg7XG4gICAgICBub2RlQi5yZXB1bHNpb25Gb3JjZVkgKz0gY2hpbGRyZW5Db25zdGFudCAqIHJlcHVsc2lvbkZvcmNlWTtcbiAgICB9IGVsc2UgLy8gbm8gb3ZlcmxhcFxuICAgIHtcbiAgICAgIC8vIGNhbGN1bGF0ZSBkaXN0YW5jZVxuXG4gICAgICBpZiAodGhpcy51bmlmb3JtTGVhZk5vZGVTaXplcyAmJiBub2RlQS5nZXRDaGlsZCgpID09IG51bGwgJiYgbm9kZUIuZ2V0Q2hpbGQoKSA9PSBudWxsKSAvLyBzaW1wbHkgYmFzZSByZXB1bHNpb24gb24gZGlzdGFuY2Ugb2Ygbm9kZSBjZW50ZXJzXG4gICAgICAgIHtcbiAgICAgICAgICBkaXN0YW5jZVggPSByZWN0Qi5nZXRDZW50ZXJYKCkgLSByZWN0QS5nZXRDZW50ZXJYKCk7XG4gICAgICAgICAgZGlzdGFuY2VZID0gcmVjdEIuZ2V0Q2VudGVyWSgpIC0gcmVjdEEuZ2V0Q2VudGVyWSgpO1xuICAgICAgICB9IGVsc2UgLy8gdXNlIGNsaXBwaW5nIHBvaW50c1xuICAgICAgICB7XG4gICAgICAgICAgSUdlb21ldHJ5LmdldEludGVyc2VjdGlvbihyZWN0QSwgcmVjdEIsIGNsaXBQb2ludHMpO1xuXG4gICAgICAgICAgZGlzdGFuY2VYID0gY2xpcFBvaW50c1syXSAtIGNsaXBQb2ludHNbMF07XG4gICAgICAgICAgZGlzdGFuY2VZID0gY2xpcFBvaW50c1szXSAtIGNsaXBQb2ludHNbMV07XG4gICAgICAgIH1cblxuICAgICAgLy8gTm8gcmVwdWxzaW9uIHJhbmdlLiBGUiBncmlkIHZhcmlhbnQgc2hvdWxkIHRha2UgY2FyZSBvZiB0aGlzLlxuICAgICAgaWYgKE1hdGguYWJzKGRpc3RhbmNlWCkgPCBGRExheW91dENvbnN0YW50cy5NSU5fUkVQVUxTSU9OX0RJU1QpIHtcbiAgICAgICAgZGlzdGFuY2VYID0gSU1hdGguc2lnbihkaXN0YW5jZVgpICogRkRMYXlvdXRDb25zdGFudHMuTUlOX1JFUFVMU0lPTl9ESVNUO1xuICAgICAgfVxuXG4gICAgICBpZiAoTWF0aC5hYnMoZGlzdGFuY2VZKSA8IEZETGF5b3V0Q29uc3RhbnRzLk1JTl9SRVBVTFNJT05fRElTVCkge1xuICAgICAgICBkaXN0YW5jZVkgPSBJTWF0aC5zaWduKGRpc3RhbmNlWSkgKiBGRExheW91dENvbnN0YW50cy5NSU5fUkVQVUxTSU9OX0RJU1Q7XG4gICAgICB9XG5cbiAgICAgIGRpc3RhbmNlU3F1YXJlZCA9IGRpc3RhbmNlWCAqIGRpc3RhbmNlWCArIGRpc3RhbmNlWSAqIGRpc3RhbmNlWTtcbiAgICAgIGRpc3RhbmNlID0gTWF0aC5zcXJ0KGRpc3RhbmNlU3F1YXJlZCk7XG5cbiAgICAgIHJlcHVsc2lvbkZvcmNlID0gdGhpcy5yZXB1bHNpb25Db25zdGFudCAqIG5vZGVBLm5vT2ZDaGlsZHJlbiAqIG5vZGVCLm5vT2ZDaGlsZHJlbiAvIGRpc3RhbmNlU3F1YXJlZDtcblxuICAgICAgLy8gUHJvamVjdCBmb3JjZSBvbnRvIHggYW5kIHkgYXhlc1xuICAgICAgcmVwdWxzaW9uRm9yY2VYID0gcmVwdWxzaW9uRm9yY2UgKiBkaXN0YW5jZVggLyBkaXN0YW5jZTtcbiAgICAgIHJlcHVsc2lvbkZvcmNlWSA9IHJlcHVsc2lvbkZvcmNlICogZGlzdGFuY2VZIC8gZGlzdGFuY2U7XG5cbiAgICAgIC8vIEFwcGx5IGZvcmNlcyBvbiB0aGUgdHdvIG5vZGVzICAgIFxuICAgICAgbm9kZUEucmVwdWxzaW9uRm9yY2VYIC09IHJlcHVsc2lvbkZvcmNlWDtcbiAgICAgIG5vZGVBLnJlcHVsc2lvbkZvcmNlWSAtPSByZXB1bHNpb25Gb3JjZVk7XG4gICAgICBub2RlQi5yZXB1bHNpb25Gb3JjZVggKz0gcmVwdWxzaW9uRm9yY2VYO1xuICAgICAgbm9kZUIucmVwdWxzaW9uRm9yY2VZICs9IHJlcHVsc2lvbkZvcmNlWTtcbiAgICB9XG59O1xuXG5GRExheW91dC5wcm90b3R5cGUuY2FsY0dyYXZpdGF0aW9uYWxGb3JjZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHZhciBvd25lckdyYXBoO1xuICB2YXIgb3duZXJDZW50ZXJYO1xuICB2YXIgb3duZXJDZW50ZXJZO1xuICB2YXIgZGlzdGFuY2VYO1xuICB2YXIgZGlzdGFuY2VZO1xuICB2YXIgYWJzRGlzdGFuY2VYO1xuICB2YXIgYWJzRGlzdGFuY2VZO1xuICB2YXIgZXN0aW1hdGVkU2l6ZTtcbiAgb3duZXJHcmFwaCA9IG5vZGUuZ2V0T3duZXIoKTtcblxuICBvd25lckNlbnRlclggPSAob3duZXJHcmFwaC5nZXRSaWdodCgpICsgb3duZXJHcmFwaC5nZXRMZWZ0KCkpIC8gMjtcbiAgb3duZXJDZW50ZXJZID0gKG93bmVyR3JhcGguZ2V0VG9wKCkgKyBvd25lckdyYXBoLmdldEJvdHRvbSgpKSAvIDI7XG4gIGRpc3RhbmNlWCA9IG5vZGUuZ2V0Q2VudGVyWCgpIC0gb3duZXJDZW50ZXJYO1xuICBkaXN0YW5jZVkgPSBub2RlLmdldENlbnRlclkoKSAtIG93bmVyQ2VudGVyWTtcbiAgYWJzRGlzdGFuY2VYID0gTWF0aC5hYnMoZGlzdGFuY2VYKSArIG5vZGUuZ2V0V2lkdGgoKSAvIDI7XG4gIGFic0Rpc3RhbmNlWSA9IE1hdGguYWJzKGRpc3RhbmNlWSkgKyBub2RlLmdldEhlaWdodCgpIC8gMjtcblxuICBpZiAobm9kZS5nZXRPd25lcigpID09IHRoaXMuZ3JhcGhNYW5hZ2VyLmdldFJvb3QoKSkgLy8gaW4gdGhlIHJvb3QgZ3JhcGhcbiAgICB7XG4gICAgICBlc3RpbWF0ZWRTaXplID0gb3duZXJHcmFwaC5nZXRFc3RpbWF0ZWRTaXplKCkgKiB0aGlzLmdyYXZpdHlSYW5nZUZhY3RvcjtcblxuICAgICAgaWYgKGFic0Rpc3RhbmNlWCA+IGVzdGltYXRlZFNpemUgfHwgYWJzRGlzdGFuY2VZID4gZXN0aW1hdGVkU2l6ZSkge1xuICAgICAgICBub2RlLmdyYXZpdGF0aW9uRm9yY2VYID0gLXRoaXMuZ3Jhdml0eUNvbnN0YW50ICogZGlzdGFuY2VYO1xuICAgICAgICBub2RlLmdyYXZpdGF0aW9uRm9yY2VZID0gLXRoaXMuZ3Jhdml0eUNvbnN0YW50ICogZGlzdGFuY2VZO1xuICAgICAgfVxuICAgIH0gZWxzZSAvLyBpbnNpZGUgYSBjb21wb3VuZFxuICAgIHtcbiAgICAgIGVzdGltYXRlZFNpemUgPSBvd25lckdyYXBoLmdldEVzdGltYXRlZFNpemUoKSAqIHRoaXMuY29tcG91bmRHcmF2aXR5UmFuZ2VGYWN0b3I7XG5cbiAgICAgIGlmIChhYnNEaXN0YW5jZVggPiBlc3RpbWF0ZWRTaXplIHx8IGFic0Rpc3RhbmNlWSA+IGVzdGltYXRlZFNpemUpIHtcbiAgICAgICAgbm9kZS5ncmF2aXRhdGlvbkZvcmNlWCA9IC10aGlzLmdyYXZpdHlDb25zdGFudCAqIGRpc3RhbmNlWCAqIHRoaXMuY29tcG91bmRHcmF2aXR5Q29uc3RhbnQ7XG4gICAgICAgIG5vZGUuZ3Jhdml0YXRpb25Gb3JjZVkgPSAtdGhpcy5ncmF2aXR5Q29uc3RhbnQgKiBkaXN0YW5jZVkgKiB0aGlzLmNvbXBvdW5kR3Jhdml0eUNvbnN0YW50O1xuICAgICAgfVxuICAgIH1cbn07XG5cbkZETGF5b3V0LnByb3RvdHlwZS5pc0NvbnZlcmdlZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNvbnZlcmdlZDtcbiAgdmFyIG9zY2lsYXRpbmcgPSBmYWxzZTtcblxuICBpZiAodGhpcy50b3RhbEl0ZXJhdGlvbnMgPiB0aGlzLm1heEl0ZXJhdGlvbnMgLyAzKSB7XG4gICAgb3NjaWxhdGluZyA9IE1hdGguYWJzKHRoaXMudG90YWxEaXNwbGFjZW1lbnQgLSB0aGlzLm9sZFRvdGFsRGlzcGxhY2VtZW50KSA8IDI7XG4gIH1cblxuICBjb252ZXJnZWQgPSB0aGlzLnRvdGFsRGlzcGxhY2VtZW50IDwgdGhpcy50b3RhbERpc3BsYWNlbWVudFRocmVzaG9sZDtcblxuICB0aGlzLm9sZFRvdGFsRGlzcGxhY2VtZW50ID0gdGhpcy50b3RhbERpc3BsYWNlbWVudDtcblxuICByZXR1cm4gY29udmVyZ2VkIHx8IG9zY2lsYXRpbmc7XG59O1xuXG5GRExheW91dC5wcm90b3R5cGUuYW5pbWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuYW5pbWF0aW9uRHVyaW5nTGF5b3V0ICYmICF0aGlzLmlzU3ViTGF5b3V0KSB7XG4gICAgaWYgKHRoaXMubm90QW5pbWF0ZWRJdGVyYXRpb25zID09IHRoaXMuYW5pbWF0aW9uUGVyaW9kKSB7XG4gICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgdGhpcy5ub3RBbmltYXRlZEl0ZXJhdGlvbnMgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm5vdEFuaW1hdGVkSXRlcmF0aW9ucysrO1xuICAgIH1cbiAgfVxufTtcblxuLy9UaGlzIG1ldGhvZCBjYWxjdWxhdGVzIHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gKHdlaWdodCkgZm9yIGFsbCBub2Rlc1xuRkRMYXlvdXQucHJvdG90eXBlLmNhbGNOb09mQ2hpbGRyZW5Gb3JBbGxOb2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vZGU7XG4gIHZhciBhbGxOb2RlcyA9IHRoaXMuZ3JhcGhNYW5hZ2VyLmdldEFsbE5vZGVzKCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIG5vZGUgPSBhbGxOb2Rlc1tpXTtcbiAgICBub2RlLm5vT2ZDaGlsZHJlbiA9IG5vZGUuZ2V0Tm9PZkNoaWxkcmVuKCk7XG4gIH1cbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBTZWN0aW9uOiBGUi1HcmlkIFZhcmlhbnQgUmVwdWxzaW9uIEZvcmNlIENhbGN1bGF0aW9uXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5GRExheW91dC5wcm90b3R5cGUuY2FsY0dyaWQgPSBmdW5jdGlvbiAoZ3JhcGgpIHtcblxuICB2YXIgc2l6ZVggPSAwO1xuICB2YXIgc2l6ZVkgPSAwO1xuXG4gIHNpemVYID0gcGFyc2VJbnQoTWF0aC5jZWlsKChncmFwaC5nZXRSaWdodCgpIC0gZ3JhcGguZ2V0TGVmdCgpKSAvIHRoaXMucmVwdWxzaW9uUmFuZ2UpKTtcbiAgc2l6ZVkgPSBwYXJzZUludChNYXRoLmNlaWwoKGdyYXBoLmdldEJvdHRvbSgpIC0gZ3JhcGguZ2V0VG9wKCkpIC8gdGhpcy5yZXB1bHNpb25SYW5nZSkpO1xuXG4gIHZhciBncmlkID0gbmV3IEFycmF5KHNpemVYKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemVYOyBpKyspIHtcbiAgICBncmlkW2ldID0gbmV3IEFycmF5KHNpemVZKTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZVg7IGkrKykge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2l6ZVk7IGorKykge1xuICAgICAgZ3JpZFtpXVtqXSA9IG5ldyBBcnJheSgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBncmlkO1xufTtcblxuRkRMYXlvdXQucHJvdG90eXBlLmFkZE5vZGVUb0dyaWQgPSBmdW5jdGlvbiAodiwgbGVmdCwgdG9wKSB7XG5cbiAgdmFyIHN0YXJ0WCA9IDA7XG4gIHZhciBmaW5pc2hYID0gMDtcbiAgdmFyIHN0YXJ0WSA9IDA7XG4gIHZhciBmaW5pc2hZID0gMDtcblxuICBzdGFydFggPSBwYXJzZUludChNYXRoLmZsb29yKCh2LmdldFJlY3QoKS54IC0gbGVmdCkgLyB0aGlzLnJlcHVsc2lvblJhbmdlKSk7XG4gIGZpbmlzaFggPSBwYXJzZUludChNYXRoLmZsb29yKCh2LmdldFJlY3QoKS53aWR0aCArIHYuZ2V0UmVjdCgpLnggLSBsZWZ0KSAvIHRoaXMucmVwdWxzaW9uUmFuZ2UpKTtcbiAgc3RhcnRZID0gcGFyc2VJbnQoTWF0aC5mbG9vcigodi5nZXRSZWN0KCkueSAtIHRvcCkgLyB0aGlzLnJlcHVsc2lvblJhbmdlKSk7XG4gIGZpbmlzaFkgPSBwYXJzZUludChNYXRoLmZsb29yKCh2LmdldFJlY3QoKS5oZWlnaHQgKyB2LmdldFJlY3QoKS55IC0gdG9wKSAvIHRoaXMucmVwdWxzaW9uUmFuZ2UpKTtcblxuICBmb3IgKHZhciBpID0gc3RhcnRYOyBpIDw9IGZpbmlzaFg7IGkrKykge1xuICAgIGZvciAodmFyIGogPSBzdGFydFk7IGogPD0gZmluaXNoWTsgaisrKSB7XG4gICAgICB0aGlzLmdyaWRbaV1bal0ucHVzaCh2KTtcbiAgICAgIHYuc2V0R3JpZENvb3JkaW5hdGVzKHN0YXJ0WCwgZmluaXNoWCwgc3RhcnRZLCBmaW5pc2hZKTtcbiAgICB9XG4gIH1cbn07XG5cbkZETGF5b3V0LnByb3RvdHlwZS51cGRhdGVHcmlkID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaTtcbiAgdmFyIG5vZGVBO1xuICB2YXIgbE5vZGVzID0gdGhpcy5nZXRBbGxOb2RlcygpO1xuXG4gIHRoaXMuZ3JpZCA9IHRoaXMuY2FsY0dyaWQodGhpcy5ncmFwaE1hbmFnZXIuZ2V0Um9vdCgpKTtcblxuICAvLyBwdXQgYWxsIG5vZGVzIHRvIHByb3BlciBncmlkIGNlbGxzXG4gIGZvciAoaSA9IDA7IGkgPCBsTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBub2RlQSA9IGxOb2Rlc1tpXTtcbiAgICB0aGlzLmFkZE5vZGVUb0dyaWQobm9kZUEsIHRoaXMuZ3JhcGhNYW5hZ2VyLmdldFJvb3QoKS5nZXRMZWZ0KCksIHRoaXMuZ3JhcGhNYW5hZ2VyLmdldFJvb3QoKS5nZXRUb3AoKSk7XG4gIH1cbn07XG5cbkZETGF5b3V0LnByb3RvdHlwZS5jYWxjdWxhdGVSZXB1bHNpb25Gb3JjZU9mQU5vZGUgPSBmdW5jdGlvbiAobm9kZUEsIHByb2Nlc3NlZE5vZGVTZXQsIGdyaWRVcGRhdGVBbGxvd2VkLCBmb3JjZVRvTm9kZVN1cnJvdW5kaW5nVXBkYXRlKSB7XG5cbiAgaWYgKHRoaXMudG90YWxJdGVyYXRpb25zICUgRkRMYXlvdXRDb25zdGFudHMuR1JJRF9DQUxDVUxBVElPTl9DSEVDS19QRVJJT0QgPT0gMSAmJiBncmlkVXBkYXRlQWxsb3dlZCB8fCBmb3JjZVRvTm9kZVN1cnJvdW5kaW5nVXBkYXRlKSB7XG4gICAgdmFyIHN1cnJvdW5kaW5nID0gbmV3IFNldCgpO1xuICAgIG5vZGVBLnN1cnJvdW5kaW5nID0gbmV3IEFycmF5KCk7XG4gICAgdmFyIG5vZGVCO1xuICAgIHZhciBncmlkID0gdGhpcy5ncmlkO1xuXG4gICAgZm9yICh2YXIgaSA9IG5vZGVBLnN0YXJ0WCAtIDE7IGkgPCBub2RlQS5maW5pc2hYICsgMjsgaSsrKSB7XG4gICAgICBmb3IgKHZhciBqID0gbm9kZUEuc3RhcnRZIC0gMTsgaiA8IG5vZGVBLmZpbmlzaFkgKyAyOyBqKyspIHtcbiAgICAgICAgaWYgKCEoaSA8IDAgfHwgaiA8IDAgfHwgaSA+PSBncmlkLmxlbmd0aCB8fCBqID49IGdyaWRbMF0ubGVuZ3RoKSkge1xuICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgZ3JpZFtpXVtqXS5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgbm9kZUIgPSBncmlkW2ldW2pdW2tdO1xuXG4gICAgICAgICAgICAvLyBJZiBib3RoIG5vZGVzIGFyZSBub3QgbWVtYmVycyBvZiB0aGUgc2FtZSBncmFwaCwgXG4gICAgICAgICAgICAvLyBvciBib3RoIG5vZGVzIGFyZSB0aGUgc2FtZSwgc2tpcC5cbiAgICAgICAgICAgIGlmIChub2RlQS5nZXRPd25lcigpICE9IG5vZGVCLmdldE93bmVyKCkgfHwgbm9kZUEgPT0gbm9kZUIpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSByZXB1bHNpb24gZm9yY2UgYmV0d2VlblxuICAgICAgICAgICAgLy8gbm9kZUEgYW5kIG5vZGVCIGhhcyBhbHJlYWR5IGJlZW4gY2FsY3VsYXRlZFxuICAgICAgICAgICAgaWYgKCFwcm9jZXNzZWROb2RlU2V0Lmhhcyhub2RlQikgJiYgIXN1cnJvdW5kaW5nLmhhcyhub2RlQikpIHtcbiAgICAgICAgICAgICAgdmFyIGRpc3RhbmNlWCA9IE1hdGguYWJzKG5vZGVBLmdldENlbnRlclgoKSAtIG5vZGVCLmdldENlbnRlclgoKSkgLSAobm9kZUEuZ2V0V2lkdGgoKSAvIDIgKyBub2RlQi5nZXRXaWR0aCgpIC8gMik7XG4gICAgICAgICAgICAgIHZhciBkaXN0YW5jZVkgPSBNYXRoLmFicyhub2RlQS5nZXRDZW50ZXJZKCkgLSBub2RlQi5nZXRDZW50ZXJZKCkpIC0gKG5vZGVBLmdldEhlaWdodCgpIC8gMiArIG5vZGVCLmdldEhlaWdodCgpIC8gMik7XG5cbiAgICAgICAgICAgICAgLy8gaWYgdGhlIGRpc3RhbmNlIGJldHdlZW4gbm9kZUEgYW5kIG5vZGVCIFxuICAgICAgICAgICAgICAvLyBpcyBsZXNzIHRoZW4gY2FsY3VsYXRpb24gcmFuZ2VcbiAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlWCA8PSB0aGlzLnJlcHVsc2lvblJhbmdlICYmIGRpc3RhbmNlWSA8PSB0aGlzLnJlcHVsc2lvblJhbmdlKSB7XG4gICAgICAgICAgICAgICAgLy90aGVuIGFkZCBub2RlQiB0byBzdXJyb3VuZGluZyBvZiBub2RlQVxuICAgICAgICAgICAgICAgIHN1cnJvdW5kaW5nLmFkZChub2RlQik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBub2RlQS5zdXJyb3VuZGluZyA9IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoc3Vycm91bmRpbmcpKTtcbiAgfVxuICBmb3IgKGkgPSAwOyBpIDwgbm9kZUEuc3Vycm91bmRpbmcubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLmNhbGNSZXB1bHNpb25Gb3JjZShub2RlQSwgbm9kZUEuc3Vycm91bmRpbmdbaV0pO1xuICB9XG59O1xuXG5GRExheW91dC5wcm90b3R5cGUuY2FsY1JlcHVsc2lvblJhbmdlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gMC4wO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGRExheW91dDtcblxuLyoqKi8gfSksXG4vKiAxOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgTEVkZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xudmFyIEZETGF5b3V0Q29uc3RhbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblxuZnVuY3Rpb24gRkRMYXlvdXRFZGdlKHNvdXJjZSwgdGFyZ2V0LCB2RWRnZSkge1xuICBMRWRnZS5jYWxsKHRoaXMsIHNvdXJjZSwgdGFyZ2V0LCB2RWRnZSk7XG4gIHRoaXMuaWRlYWxMZW5ndGggPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIO1xufVxuXG5GRExheW91dEVkZ2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShMRWRnZS5wcm90b3R5cGUpO1xuXG5mb3IgKHZhciBwcm9wIGluIExFZGdlKSB7XG4gIEZETGF5b3V0RWRnZVtwcm9wXSA9IExFZGdlW3Byb3BdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEZETGF5b3V0RWRnZTtcblxuLyoqKi8gfSksXG4vKiAyMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgTE5vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG5mdW5jdGlvbiBGRExheW91dE5vZGUoZ20sIGxvYywgc2l6ZSwgdk5vZGUpIHtcbiAgLy8gYWx0ZXJuYXRpdmUgY29uc3RydWN0b3IgaXMgaGFuZGxlZCBpbnNpZGUgTE5vZGVcbiAgTE5vZGUuY2FsbCh0aGlzLCBnbSwgbG9jLCBzaXplLCB2Tm9kZSk7XG4gIC8vU3ByaW5nLCByZXB1bHNpb24gYW5kIGdyYXZpdGF0aW9uYWwgZm9yY2VzIGFjdGluZyBvbiB0aGlzIG5vZGVcbiAgdGhpcy5zcHJpbmdGb3JjZVggPSAwO1xuICB0aGlzLnNwcmluZ0ZvcmNlWSA9IDA7XG4gIHRoaXMucmVwdWxzaW9uRm9yY2VYID0gMDtcbiAgdGhpcy5yZXB1bHNpb25Gb3JjZVkgPSAwO1xuICB0aGlzLmdyYXZpdGF0aW9uRm9yY2VYID0gMDtcbiAgdGhpcy5ncmF2aXRhdGlvbkZvcmNlWSA9IDA7XG4gIC8vQW1vdW50IGJ5IHdoaWNoIHRoaXMgbm9kZSBpcyB0byBiZSBtb3ZlZCBpbiB0aGlzIGl0ZXJhdGlvblxuICB0aGlzLmRpc3BsYWNlbWVudFggPSAwO1xuICB0aGlzLmRpc3BsYWNlbWVudFkgPSAwO1xuXG4gIC8vU3RhcnQgYW5kIGZpbmlzaCBncmlkIGNvb3JkaW5hdGVzIHRoYXQgdGhpcyBub2RlIGlzIGZhbGxlbiBpbnRvXG4gIHRoaXMuc3RhcnRYID0gMDtcbiAgdGhpcy5maW5pc2hYID0gMDtcbiAgdGhpcy5zdGFydFkgPSAwO1xuICB0aGlzLmZpbmlzaFkgPSAwO1xuXG4gIC8vR2VvbWV0cmljIG5laWdoYm9ycyBvZiB0aGlzIG5vZGVcbiAgdGhpcy5zdXJyb3VuZGluZyA9IFtdO1xufVxuXG5GRExheW91dE5vZGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShMTm9kZS5wcm90b3R5cGUpO1xuXG5mb3IgKHZhciBwcm9wIGluIExOb2RlKSB7XG4gIEZETGF5b3V0Tm9kZVtwcm9wXSA9IExOb2RlW3Byb3BdO1xufVxuXG5GRExheW91dE5vZGUucHJvdG90eXBlLnNldEdyaWRDb29yZGluYXRlcyA9IGZ1bmN0aW9uIChfc3RhcnRYLCBfZmluaXNoWCwgX3N0YXJ0WSwgX2ZpbmlzaFkpIHtcbiAgdGhpcy5zdGFydFggPSBfc3RhcnRYO1xuICB0aGlzLmZpbmlzaFggPSBfZmluaXNoWDtcbiAgdGhpcy5zdGFydFkgPSBfc3RhcnRZO1xuICB0aGlzLmZpbmlzaFkgPSBfZmluaXNoWTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRkRMYXlvdXROb2RlO1xuXG4vKioqLyB9KSxcbi8qIDIxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIERpbWVuc2lvbkQod2lkdGgsIGhlaWdodCkge1xuICB0aGlzLndpZHRoID0gMDtcbiAgdGhpcy5oZWlnaHQgPSAwO1xuICBpZiAod2lkdGggIT09IG51bGwgJiYgaGVpZ2h0ICE9PSBudWxsKSB7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICB9XG59XG5cbkRpbWVuc2lvbkQucHJvdG90eXBlLmdldFdpZHRoID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy53aWR0aDtcbn07XG5cbkRpbWVuc2lvbkQucHJvdG90eXBlLnNldFdpZHRoID0gZnVuY3Rpb24gKHdpZHRoKSB7XG4gIHRoaXMud2lkdGggPSB3aWR0aDtcbn07XG5cbkRpbWVuc2lvbkQucHJvdG90eXBlLmdldEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuaGVpZ2h0O1xufTtcblxuRGltZW5zaW9uRC5wcm90b3R5cGUuc2V0SGVpZ2h0ID0gZnVuY3Rpb24gKGhlaWdodCkge1xuICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRGltZW5zaW9uRDtcblxuLyoqKi8gfSksXG4vKiAyMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgVW5pcXVlSURHZW5lcmV0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcblxuZnVuY3Rpb24gSGFzaE1hcCgpIHtcbiAgdGhpcy5tYXAgPSB7fTtcbiAgdGhpcy5rZXlzID0gW107XG59XG5cbkhhc2hNYXAucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHZhciB0aGVJZCA9IFVuaXF1ZUlER2VuZXJldG9yLmNyZWF0ZUlEKGtleSk7XG4gIGlmICghdGhpcy5jb250YWlucyh0aGVJZCkpIHtcbiAgICB0aGlzLm1hcFt0aGVJZF0gPSB2YWx1ZTtcbiAgICB0aGlzLmtleXMucHVzaChrZXkpO1xuICB9XG59O1xuXG5IYXNoTWFwLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgdmFyIHRoZUlkID0gVW5pcXVlSURHZW5lcmV0b3IuY3JlYXRlSUQoa2V5KTtcbiAgcmV0dXJuIHRoaXMubWFwW2tleV0gIT0gbnVsbDtcbn07XG5cbkhhc2hNYXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgdmFyIHRoZUlkID0gVW5pcXVlSURHZW5lcmV0b3IuY3JlYXRlSUQoa2V5KTtcbiAgcmV0dXJuIHRoaXMubWFwW3RoZUlkXTtcbn07XG5cbkhhc2hNYXAucHJvdG90eXBlLmtleVNldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMua2V5cztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSGFzaE1hcDtcblxuLyoqKi8gfSksXG4vKiAyMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgVW5pcXVlSURHZW5lcmV0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcblxuZnVuY3Rpb24gSGFzaFNldCgpIHtcbiAgdGhpcy5zZXQgPSB7fTtcbn1cbjtcblxuSGFzaFNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKG9iaikge1xuICB2YXIgdGhlSWQgPSBVbmlxdWVJREdlbmVyZXRvci5jcmVhdGVJRChvYmopO1xuICBpZiAoIXRoaXMuY29udGFpbnModGhlSWQpKSB0aGlzLnNldFt0aGVJZF0gPSBvYmo7XG59O1xuXG5IYXNoU2V0LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAob2JqKSB7XG4gIGRlbGV0ZSB0aGlzLnNldFtVbmlxdWVJREdlbmVyZXRvci5jcmVhdGVJRChvYmopXTtcbn07XG5cbkhhc2hTZXQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnNldCA9IHt9O1xufTtcblxuSGFzaFNldC5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB0aGlzLnNldFtVbmlxdWVJREdlbmVyZXRvci5jcmVhdGVJRChvYmopXSA9PSBvYmo7XG59O1xuXG5IYXNoU2V0LnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5zaXplKCkgPT09IDA7XG59O1xuXG5IYXNoU2V0LnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5zZXQpLmxlbmd0aDtcbn07XG5cbi8vY29uY2F0cyB0aGlzLnNldCB0byB0aGUgZ2l2ZW4gbGlzdFxuSGFzaFNldC5wcm90b3R5cGUuYWRkQWxsVG8gPSBmdW5jdGlvbiAobGlzdCkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuc2V0KTtcbiAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgbGlzdC5wdXNoKHRoaXMuc2V0W2tleXNbaV1dKTtcbiAgfVxufTtcblxuSGFzaFNldC5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuc2V0KS5sZW5ndGg7XG59O1xuXG5IYXNoU2V0LnByb3RvdHlwZS5hZGRBbGwgPSBmdW5jdGlvbiAobGlzdCkge1xuICB2YXIgcyA9IGxpc3QubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKykge1xuICAgIHZhciB2ID0gbGlzdFtpXTtcbiAgICB0aGlzLmFkZCh2KTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBIYXNoU2V0O1xuXG4vKioqLyB9KSxcbi8qIDI0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogQSBjbGFzc2ljIFF1aWNrc29ydCBhbGdvcml0aG0gd2l0aCBIb2FyZSdzIHBhcnRpdGlvblxuICogLSBXb3JrcyBhbHNvIG9uIExpbmtlZExpc3Qgb2JqZWN0c1xuICpcbiAqIENvcHlyaWdodDogaS1WaXMgUmVzZWFyY2ggR3JvdXAsIEJpbGtlbnQgVW5pdmVyc2l0eSwgMjAwNyAtIHByZXNlbnRcbiAqL1xuXG52YXIgTGlua2VkTGlzdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXG52YXIgUXVpY2tzb3J0ID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFF1aWNrc29ydChBLCBjb21wYXJlRnVuY3Rpb24pIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFF1aWNrc29ydCk7XG5cbiAgICAgICAgaWYgKGNvbXBhcmVGdW5jdGlvbiAhPT0gbnVsbCB8fCBjb21wYXJlRnVuY3Rpb24gIT09IHVuZGVmaW5lZCkgdGhpcy5jb21wYXJlRnVuY3Rpb24gPSB0aGlzLl9kZWZhdWx0Q29tcGFyZUZ1bmN0aW9uO1xuXG4gICAgICAgIHZhciBsZW5ndGggPSB2b2lkIDA7XG4gICAgICAgIGlmIChBIGluc3RhbmNlb2YgTGlua2VkTGlzdCkgbGVuZ3RoID0gQS5zaXplKCk7ZWxzZSBsZW5ndGggPSBBLmxlbmd0aDtcblxuICAgICAgICB0aGlzLl9xdWlja3NvcnQoQSwgMCwgbGVuZ3RoIC0gMSk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKFF1aWNrc29ydCwgW3tcbiAgICAgICAga2V5OiAnX3F1aWNrc29ydCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcXVpY2tzb3J0KEEsIHAsIHIpIHtcbiAgICAgICAgICAgIGlmIChwIDwgcikge1xuICAgICAgICAgICAgICAgIHZhciBxID0gdGhpcy5fcGFydGl0aW9uKEEsIHAsIHIpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3F1aWNrc29ydChBLCBwLCBxKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9xdWlja3NvcnQoQSwgcSArIDEsIHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdfcGFydGl0aW9uJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9wYXJ0aXRpb24oQSwgcCwgcikge1xuICAgICAgICAgICAgdmFyIHggPSB0aGlzLl9nZXQoQSwgcCk7XG4gICAgICAgICAgICB2YXIgaSA9IHA7XG4gICAgICAgICAgICB2YXIgaiA9IHI7XG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLmNvbXBhcmVGdW5jdGlvbih4LCB0aGlzLl9nZXQoQSwgaikpKSB7XG4gICAgICAgICAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgICAgICB9d2hpbGUgKHRoaXMuY29tcGFyZUZ1bmN0aW9uKHRoaXMuX2dldChBLCBpKSwgeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIH1pZiAoaSA8IGopIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3dhcChBLCBpLCBqKTtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICBqLS07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHJldHVybiBqO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdfZ2V0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXQob2JqZWN0LCBpbmRleCkge1xuICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIExpbmtlZExpc3QpIHJldHVybiBvYmplY3QuZ2V0X29iamVjdF9hdChpbmRleCk7ZWxzZSByZXR1cm4gb2JqZWN0W2luZGV4XTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX3NldCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0KG9iamVjdCwgaW5kZXgsIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgTGlua2VkTGlzdCkgb2JqZWN0LnNldF9vYmplY3RfYXQoaW5kZXgsIHZhbHVlKTtlbHNlIG9iamVjdFtpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX3N3YXAnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3N3YXAoQSwgaSwgaikge1xuICAgICAgICAgICAgdmFyIHRlbXAgPSB0aGlzLl9nZXQoQSwgaSk7XG4gICAgICAgICAgICB0aGlzLl9zZXQoQSwgaSwgdGhpcy5fZ2V0KEEsIGopKTtcbiAgICAgICAgICAgIHRoaXMuX3NldChBLCBqLCB0ZW1wKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX2RlZmF1bHRDb21wYXJlRnVuY3Rpb24nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2RlZmF1bHRDb21wYXJlRnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGIgPiBhO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFF1aWNrc29ydDtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBRdWlja3NvcnQ7XG5cbi8qKiovIH0pLFxuLyogMjUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLyoqXG4gKiAgIE5lZWRsZW1hbi1XdW5zY2ggYWxnb3JpdGhtIGlzIGFuIHByb2NlZHVyZSB0byBjb21wdXRlIHRoZSBvcHRpbWFsIGdsb2JhbCBhbGlnbm1lbnQgb2YgdHdvIHN0cmluZ1xuICogICBzZXF1ZW5jZXMgYnkgUy5CLk5lZWRsZW1hbiBhbmQgQy5ELld1bnNjaCAoMTk3MCkuXG4gKlxuICogICBBc2lkZSBmcm9tIHRoZSBpbnB1dHMsIHlvdSBjYW4gYXNzaWduIHRoZSBzY29yZXMgZm9yLFxuICogICAtIE1hdGNoOiBUaGUgdHdvIGNoYXJhY3RlcnMgYXQgdGhlIGN1cnJlbnQgaW5kZXggYXJlIHNhbWUuXG4gKiAgIC0gTWlzbWF0Y2g6IFRoZSB0d28gY2hhcmFjdGVycyBhdCB0aGUgY3VycmVudCBpbmRleCBhcmUgZGlmZmVyZW50LlxuICogICAtIEluc2VydGlvbi9EZWxldGlvbihnYXBzKTogVGhlIGJlc3QgYWxpZ25tZW50IGludm9sdmVzIG9uZSBsZXR0ZXIgYWxpZ25pbmcgdG8gYSBnYXAgaW4gdGhlIG90aGVyIHN0cmluZy5cbiAqL1xuXG52YXIgTmVlZGxlbWFuV3Vuc2NoID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5lZWRsZW1hbld1bnNjaChzZXF1ZW5jZTEsIHNlcXVlbmNlMikge1xuICAgICAgICB2YXIgbWF0Y2hfc2NvcmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDE7XG4gICAgICAgIHZhciBtaXNtYXRjaF9wZW5hbHR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAtMTtcbiAgICAgICAgdmFyIGdhcF9wZW5hbHR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiAtMTtcblxuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTmVlZGxlbWFuV3Vuc2NoKTtcblxuICAgICAgICB0aGlzLnNlcXVlbmNlMSA9IHNlcXVlbmNlMTtcbiAgICAgICAgdGhpcy5zZXF1ZW5jZTIgPSBzZXF1ZW5jZTI7XG4gICAgICAgIHRoaXMubWF0Y2hfc2NvcmUgPSBtYXRjaF9zY29yZTtcbiAgICAgICAgdGhpcy5taXNtYXRjaF9wZW5hbHR5ID0gbWlzbWF0Y2hfcGVuYWx0eTtcbiAgICAgICAgdGhpcy5nYXBfcGVuYWx0eSA9IGdhcF9wZW5hbHR5O1xuXG4gICAgICAgIC8vIEp1c3QgdGhlIHJlbW92ZSByZWR1bmRhbmN5XG4gICAgICAgIHRoaXMuaU1heCA9IHNlcXVlbmNlMS5sZW5ndGggKyAxO1xuICAgICAgICB0aGlzLmpNYXggPSBzZXF1ZW5jZTIubGVuZ3RoICsgMTtcblxuICAgICAgICAvLyBHcmlkIG1hdHJpeCBvZiBzY29yZXNcbiAgICAgICAgdGhpcy5ncmlkID0gbmV3IEFycmF5KHRoaXMuaU1heCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pTWF4OyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuZ3JpZFtpXSA9IG5ldyBBcnJheSh0aGlzLmpNYXgpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuak1heDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncmlkW2ldW2pdID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRyYWNlYmFjayBtYXRyaXggKDJEIGFycmF5LCBlYWNoIGNlbGwgaXMgYW4gYXJyYXkgb2YgYm9vbGVhbiB2YWx1ZXMgZm9yIFtgRGlhZ2AsIGBVcGAsIGBMZWZ0YF0gcG9zaXRpb25zKVxuICAgICAgICB0aGlzLnRyYWNlYmFja0dyaWQgPSBuZXcgQXJyYXkodGhpcy5pTWF4KTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHRoaXMuaU1heDsgX2krKykge1xuICAgICAgICAgICAgdGhpcy50cmFjZWJhY2tHcmlkW19pXSA9IG5ldyBBcnJheSh0aGlzLmpNYXgpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBfaiA9IDA7IF9qIDwgdGhpcy5qTWF4OyBfaisrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZWJhY2tHcmlkW19pXVtfal0gPSBbbnVsbCwgbnVsbCwgbnVsbF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgYWxpZ25lZCBzZXF1ZW5jZXMgKHJldHVybiBtdWx0aXBsZSBwb3NzaWJpbGl0aWVzKVxuICAgICAgICB0aGlzLmFsaWdubWVudHMgPSBbXTtcblxuICAgICAgICAvLyBGaW5hbCBhbGlnbm1lbnQgc2NvcmVcbiAgICAgICAgdGhpcy5zY29yZSA9IC0xO1xuXG4gICAgICAgIC8vIENhbGN1bGF0ZSBzY29yZXMgYW5kIHRyYWNlYmFja3NcbiAgICAgICAgdGhpcy5jb21wdXRlR3JpZHMoKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoTmVlZGxlbWFuV3Vuc2NoLCBbe1xuICAgICAgICBrZXk6IFwiZ2V0U2NvcmVcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNjb3JlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NvcmU7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJnZXRBbGlnbm1lbnRzXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBbGlnbm1lbnRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWxpZ25tZW50cztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1haW4gZHluYW1pYyBwcm9ncmFtbWluZyBwcm9jZWR1cmVcblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImNvbXB1dGVHcmlkc1wiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY29tcHV0ZUdyaWRzKCkge1xuICAgICAgICAgICAgLy8gRmlsbCBpbiB0aGUgZmlyc3Qgcm93XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMTsgaiA8IHRoaXMuak1heDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncmlkWzBdW2pdID0gdGhpcy5ncmlkWzBdW2ogLSAxXSArIHRoaXMuZ2FwX3BlbmFsdHk7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZWJhY2tHcmlkWzBdW2pdID0gW2ZhbHNlLCBmYWxzZSwgdHJ1ZV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZpbGwgaW4gdGhlIGZpcnN0IGNvbHVtblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLmlNYXg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JpZFtpXVswXSA9IHRoaXMuZ3JpZFtpIC0gMV1bMF0gKyB0aGlzLmdhcF9wZW5hbHR5O1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2ViYWNrR3JpZFtpXVswXSA9IFtmYWxzZSwgdHJ1ZSwgZmFsc2VdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGaWxsIHRoZSByZXN0IG9mIHRoZSBncmlkXG4gICAgICAgICAgICBmb3IgKHZhciBfaTIgPSAxOyBfaTIgPCB0aGlzLmlNYXg7IF9pMisrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2oyID0gMTsgX2oyIDwgdGhpcy5qTWF4OyBfajIrKykge1xuICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSBtYXggc2NvcmUocykgYW1vbmcgW2BEaWFnYCwgYFVwYCwgYExlZnRgXVxuICAgICAgICAgICAgICAgICAgICB2YXIgZGlhZyA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VxdWVuY2UxW19pMiAtIDFdID09PSB0aGlzLnNlcXVlbmNlMltfajIgLSAxXSkgZGlhZyA9IHRoaXMuZ3JpZFtfaTIgLSAxXVtfajIgLSAxXSArIHRoaXMubWF0Y2hfc2NvcmU7ZWxzZSBkaWFnID0gdGhpcy5ncmlkW19pMiAtIDFdW19qMiAtIDFdICsgdGhpcy5taXNtYXRjaF9wZW5hbHR5O1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciB1cCA9IHRoaXMuZ3JpZFtfaTIgLSAxXVtfajJdICsgdGhpcy5nYXBfcGVuYWx0eTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlZnQgPSB0aGlzLmdyaWRbX2kyXVtfajIgLSAxXSArIHRoaXMuZ2FwX3BlbmFsdHk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgZXhpc3RzIG11bHRpcGxlIG1heCB2YWx1ZXMsIGNhcHR1cmUgdGhlbSBmb3IgbXVsdGlwbGUgcGF0aHNcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1heE9mID0gW2RpYWcsIHVwLCBsZWZ0XTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGljZXMgPSB0aGlzLmFycmF5QWxsTWF4SW5kZXhlcyhtYXhPZik7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIEdyaWRzXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JpZFtfaTJdW19qMl0gPSBtYXhPZltpbmRpY2VzWzBdXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZWJhY2tHcmlkW19pMl1bX2oyXSA9IFtpbmRpY2VzLmluY2x1ZGVzKDApLCBpbmRpY2VzLmluY2x1ZGVzKDEpLCBpbmRpY2VzLmluY2x1ZGVzKDIpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSBhbGlnbm1lbnQgc2NvcmVcbiAgICAgICAgICAgIHRoaXMuc2NvcmUgPSB0aGlzLmdyaWRbdGhpcy5pTWF4IC0gMV1bdGhpcy5qTWF4IC0gMV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZXRzIGFsbCBwb3NzaWJsZSB2YWxpZCBzZXF1ZW5jZSBjb21iaW5hdGlvbnNcblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImFsaWdubWVudFRyYWNlYmFja1wiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYWxpZ25tZW50VHJhY2ViYWNrKCkge1xuICAgICAgICAgICAgdmFyIGluUHJvY2Vzc0FsaWdubWVudHMgPSBbXTtcblxuICAgICAgICAgICAgaW5Qcm9jZXNzQWxpZ25tZW50cy5wdXNoKHsgcG9zOiBbdGhpcy5zZXF1ZW5jZTEubGVuZ3RoLCB0aGlzLnNlcXVlbmNlMi5sZW5ndGhdLFxuICAgICAgICAgICAgICAgIHNlcTE6IFwiXCIsXG4gICAgICAgICAgICAgICAgc2VxMjogXCJcIlxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHdoaWxlIChpblByb2Nlc3NBbGlnbm1lbnRzWzBdKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSBpblByb2Nlc3NBbGlnbm1lbnRzWzBdO1xuICAgICAgICAgICAgICAgIHZhciBkaXJlY3Rpb25zID0gdGhpcy50cmFjZWJhY2tHcmlkW2N1cnJlbnQucG9zWzBdXVtjdXJyZW50LnBvc1sxXV07XG5cbiAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uc1swXSkge1xuICAgICAgICAgICAgICAgICAgICBpblByb2Nlc3NBbGlnbm1lbnRzLnB1c2goeyBwb3M6IFtjdXJyZW50LnBvc1swXSAtIDEsIGN1cnJlbnQucG9zWzFdIC0gMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXExOiB0aGlzLnNlcXVlbmNlMVtjdXJyZW50LnBvc1swXSAtIDFdICsgY3VycmVudC5zZXExLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VxMjogdGhpcy5zZXF1ZW5jZTJbY3VycmVudC5wb3NbMV0gLSAxXSArIGN1cnJlbnQuc2VxMlxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbnNbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgaW5Qcm9jZXNzQWxpZ25tZW50cy5wdXNoKHsgcG9zOiBbY3VycmVudC5wb3NbMF0gLSAxLCBjdXJyZW50LnBvc1sxXV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXExOiB0aGlzLnNlcXVlbmNlMVtjdXJyZW50LnBvc1swXSAtIDFdICsgY3VycmVudC5zZXExLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VxMjogJy0nICsgY3VycmVudC5zZXEyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uc1syXSkge1xuICAgICAgICAgICAgICAgICAgICBpblByb2Nlc3NBbGlnbm1lbnRzLnB1c2goeyBwb3M6IFtjdXJyZW50LnBvc1swXSwgY3VycmVudC5wb3NbMV0gLSAxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcTE6ICctJyArIGN1cnJlbnQuc2VxMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcTI6IHRoaXMuc2VxdWVuY2UyW2N1cnJlbnQucG9zWzFdIC0gMV0gKyBjdXJyZW50LnNlcTJcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQucG9zWzBdID09PSAwICYmIGN1cnJlbnQucG9zWzFdID09PSAwKSB0aGlzLmFsaWdubWVudHMucHVzaCh7IHNlcXVlbmNlMTogY3VycmVudC5zZXExLFxuICAgICAgICAgICAgICAgICAgICBzZXF1ZW5jZTI6IGN1cnJlbnQuc2VxMlxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaW5Qcm9jZXNzQWxpZ25tZW50cy5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hbGlnbm1lbnRzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGVscGVyIEZ1bmN0aW9uc1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiZ2V0QWxsSW5kZXhlc1wiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QWxsSW5kZXhlcyhhcnIsIHZhbCkge1xuICAgICAgICAgICAgdmFyIGluZGV4ZXMgPSBbXSxcbiAgICAgICAgICAgICAgICBpID0gLTE7XG4gICAgICAgICAgICB3aGlsZSAoKGkgPSBhcnIuaW5kZXhPZih2YWwsIGkgKyAxKSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaW5kZXhlcy5wdXNoKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGluZGV4ZXM7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJhcnJheUFsbE1heEluZGV4ZXNcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFycmF5QWxsTWF4SW5kZXhlcyhhcnJheSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWxsSW5kZXhlcyhhcnJheSwgTWF0aC5tYXguYXBwbHkobnVsbCwgYXJyYXkpKTtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBOZWVkbGVtYW5XdW5zY2g7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gTmVlZGxlbWFuV3Vuc2NoO1xuXG4vKioqLyB9KSxcbi8qIDI2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBsYXlvdXRCYXNlID0gZnVuY3Rpb24gbGF5b3V0QmFzZSgpIHtcbiAgcmV0dXJuO1xufTtcblxubGF5b3V0QmFzZS5GRExheW91dCA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xubGF5b3V0QmFzZS5GRExheW91dENvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5sYXlvdXRCYXNlLkZETGF5b3V0RWRnZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xubGF5b3V0QmFzZS5GRExheW91dE5vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKTtcbmxheW91dEJhc2UuRGltZW5zaW9uRCA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xubGF5b3V0QmFzZS5IYXNoTWFwID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMik7XG5sYXlvdXRCYXNlLkhhc2hTZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKTtcbmxheW91dEJhc2UuSUdlb21ldHJ5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcbmxheW91dEJhc2UuSU1hdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xubGF5b3V0QmFzZS5JbnRlZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG5sYXlvdXRCYXNlLlBvaW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG5sYXlvdXRCYXNlLlBvaW50RCA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5sYXlvdXRCYXNlLlJhbmRvbVNlZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcbmxheW91dEJhc2UuUmVjdGFuZ2xlRCA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xubGF5b3V0QmFzZS5UcmFuc2Zvcm0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KTtcbmxheW91dEJhc2UuVW5pcXVlSURHZW5lcmV0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcbmxheW91dEJhc2UuUXVpY2tzb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNCk7XG5sYXlvdXRCYXNlLkxpbmtlZExpc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcbmxheW91dEJhc2UuTEdyYXBoT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbmxheW91dEJhc2UuTEdyYXBoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbmxheW91dEJhc2UuTEVkZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xubGF5b3V0QmFzZS5MR3JhcGhNYW5hZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcbmxheW91dEJhc2UuTE5vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xubGF5b3V0QmFzZS5MYXlvdXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcbmxheW91dEJhc2UuTGF5b3V0Q29uc3RhbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbmxheW91dEJhc2UuTmVlZGxlbWFuV3Vuc2NoID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNSk7XG5cbm1vZHVsZS5leHBvcnRzID0gbGF5b3V0QmFzZTtcblxuLyoqKi8gfSksXG4vKiAyNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBFbWl0dGVyKCkge1xuICB0aGlzLmxpc3RlbmVycyA9IFtdO1xufVxuXG52YXIgcCA9IEVtaXR0ZXIucHJvdG90eXBlO1xuXG5wLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50LCBjYWxsYmFjaykge1xuICB0aGlzLmxpc3RlbmVycy5wdXNoKHtcbiAgICBldmVudDogZXZlbnQsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxucC5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudCwgY2FsbGJhY2spIHtcbiAgZm9yICh2YXIgaSA9IHRoaXMubGlzdGVuZXJzLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgbCA9IHRoaXMubGlzdGVuZXJzW2ldO1xuXG4gICAgaWYgKGwuZXZlbnQgPT09IGV2ZW50ICYmIGwuY2FsbGJhY2sgPT09IGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLmxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG4gICAgfVxuICB9XG59O1xuXG5wLmVtaXQgPSBmdW5jdGlvbiAoZXZlbnQsIGRhdGEpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBsID0gdGhpcy5saXN0ZW5lcnNbaV07XG5cbiAgICBpZiAoZXZlbnQgPT09IGwuZXZlbnQpIHtcbiAgICAgIGwuY2FsbGJhY2soZGF0YSk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVtaXR0ZXI7XG5cbi8qKiovIH0pXG4vKioqKioqLyBdKTtcbn0pOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/layout-base/layout-base.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/mermaid/dist/createText-aebacdfe.js":
/*!**********************************************************!*\
  !*** ./node_modules/mermaid/dist/createText-aebacdfe.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a: () => (/* binding */ createText),\n/* harmony export */   c: () => (/* binding */ computeDimensionOfText)\n/* harmony export */ });\n/* harmony import */ var _mermaid_934d9bea_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mermaid-934d9bea.js */ \"(sc_client)/./node_modules/mermaid/dist/mermaid-934d9bea.js\");\n/* harmony import */ var mdast_util_from_markdown__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! mdast-util-from-markdown */ \"(sc_client)/./node_modules/mdast-util-from-markdown/dev/lib/index.js\");\n/* harmony import */ var ts_dedent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ts-dedent */ \"(sc_client)/./node_modules/ts-dedent/dist/index.js\");\n\n\n\nfunction preprocessMarkdown(markdown) {\n  const withoutMultipleNewlines = markdown.replace(/\\n{2,}/g, \"\\n\");\n  const withoutExtraSpaces = (0,ts_dedent__WEBPACK_IMPORTED_MODULE_0__.dedent)(withoutMultipleNewlines);\n  return withoutExtraSpaces;\n}\nfunction markdownToLines(markdown) {\n  const preprocessedMarkdown = preprocessMarkdown(markdown);\n  const { children } = (0,mdast_util_from_markdown__WEBPACK_IMPORTED_MODULE_1__.fromMarkdown)(preprocessedMarkdown);\n  const lines = [[]];\n  let currentLine = 0;\n  function processNode(node, parentType = \"normal\") {\n    if (node.type === \"text\") {\n      const textLines = node.value.split(\"\\n\");\n      textLines.forEach((textLine, index) => {\n        if (index !== 0) {\n          currentLine++;\n          lines.push([]);\n        }\n        textLine.split(\" \").forEach((word) => {\n          if (word) {\n            lines[currentLine].push({ content: word, type: parentType });\n          }\n        });\n      });\n    } else if (node.type === \"strong\" || node.type === \"emphasis\") {\n      node.children.forEach((contentNode) => {\n        processNode(contentNode, node.type);\n      });\n    }\n  }\n  children.forEach((treeNode) => {\n    if (treeNode.type === \"paragraph\") {\n      treeNode.children.forEach((contentNode) => {\n        processNode(contentNode);\n      });\n    }\n  });\n  return lines;\n}\nfunction markdownToHTML(markdown) {\n  const { children } = (0,mdast_util_from_markdown__WEBPACK_IMPORTED_MODULE_1__.fromMarkdown)(markdown);\n  function output(node) {\n    if (node.type === \"text\") {\n      return node.value.replace(/\\n/g, \"<br/>\");\n    } else if (node.type === \"strong\") {\n      return `<strong>${node.children.map(output).join(\"\")}</strong>`;\n    } else if (node.type === \"emphasis\") {\n      return `<em>${node.children.map(output).join(\"\")}</em>`;\n    } else if (node.type === \"paragraph\") {\n      return `<p>${node.children.map(output).join(\"\")}</p>`;\n    }\n    return `Unsupported markdown: ${node.type}`;\n  }\n  return children.map(output).join(\"\");\n}\nfunction splitTextToChars(text) {\n  if (Intl.Segmenter) {\n    return [...new Intl.Segmenter().segment(text)].map((s) => s.segment);\n  }\n  return [...text];\n}\nfunction splitWordToFitWidth(checkFit, word) {\n  const characters = splitTextToChars(word.content);\n  return splitWordToFitWidthRecursion(checkFit, [], characters, word.type);\n}\nfunction splitWordToFitWidthRecursion(checkFit, usedChars, remainingChars, type) {\n  if (remainingChars.length === 0) {\n    return [\n      { content: usedChars.join(\"\"), type },\n      { content: \"\", type }\n    ];\n  }\n  const [nextChar, ...rest] = remainingChars;\n  const newWord = [...usedChars, nextChar];\n  if (checkFit([{ content: newWord.join(\"\"), type }])) {\n    return splitWordToFitWidthRecursion(checkFit, newWord, rest, type);\n  }\n  if (usedChars.length === 0 && nextChar) {\n    usedChars.push(nextChar);\n    remainingChars.shift();\n  }\n  return [\n    { content: usedChars.join(\"\"), type },\n    { content: remainingChars.join(\"\"), type }\n  ];\n}\nfunction splitLineToFitWidth(line, checkFit) {\n  if (line.some(({ content }) => content.includes(\"\\n\"))) {\n    throw new Error(\"splitLineToFitWidth does not support newlines in the line\");\n  }\n  return splitLineToFitWidthRecursion(line, checkFit);\n}\nfunction splitLineToFitWidthRecursion(words, checkFit, lines = [], newLine = []) {\n  if (words.length === 0) {\n    if (newLine.length > 0) {\n      lines.push(newLine);\n    }\n    return lines.length > 0 ? lines : [];\n  }\n  let joiner = \"\";\n  if (words[0].content === \" \") {\n    joiner = \" \";\n    words.shift();\n  }\n  const nextWord = words.shift() ?? { content: \" \", type: \"normal\" };\n  const lineWithNextWord = [...newLine];\n  if (joiner !== \"\") {\n    lineWithNextWord.push({ content: joiner, type: \"normal\" });\n  }\n  lineWithNextWord.push(nextWord);\n  if (checkFit(lineWithNextWord)) {\n    return splitLineToFitWidthRecursion(words, checkFit, lines, lineWithNextWord);\n  }\n  if (newLine.length > 0) {\n    lines.push(newLine);\n    words.unshift(nextWord);\n  } else if (nextWord.content) {\n    const [line, rest] = splitWordToFitWidth(checkFit, nextWord);\n    lines.push([line]);\n    if (rest.content) {\n      words.unshift(rest);\n    }\n  }\n  return splitLineToFitWidthRecursion(words, checkFit, lines);\n}\nfunction applyStyle(dom, styleFn) {\n  if (styleFn) {\n    dom.attr(\"style\", styleFn);\n  }\n}\nfunction addHtmlSpan(element, node, width, classes, addBackground = false) {\n  const fo = element.append(\"foreignObject\");\n  const div = fo.append(\"xhtml:div\");\n  const label = node.label;\n  const labelClass = node.isNode ? \"nodeLabel\" : \"edgeLabel\";\n  div.html(\n    `\n    <span class=\"${labelClass} ${classes}\" ` + (node.labelStyle ? 'style=\"' + node.labelStyle + '\"' : \"\") + \">\" + label + \"</span>\"\n  );\n  applyStyle(div, node.labelStyle);\n  div.style(\"display\", \"table-cell\");\n  div.style(\"white-space\", \"nowrap\");\n  div.style(\"max-width\", width + \"px\");\n  div.attr(\"xmlns\", \"http://www.w3.org/1999/xhtml\");\n  if (addBackground) {\n    div.attr(\"class\", \"labelBkg\");\n  }\n  let bbox = div.node().getBoundingClientRect();\n  if (bbox.width === width) {\n    div.style(\"display\", \"table\");\n    div.style(\"white-space\", \"break-spaces\");\n    div.style(\"width\", width + \"px\");\n    bbox = div.node().getBoundingClientRect();\n  }\n  fo.style(\"width\", bbox.width);\n  fo.style(\"height\", bbox.height);\n  return fo.node();\n}\nfunction createTspan(textElement, lineIndex, lineHeight) {\n  return textElement.append(\"tspan\").attr(\"class\", \"text-outer-tspan\").attr(\"x\", 0).attr(\"y\", lineIndex * lineHeight - 0.1 + \"em\").attr(\"dy\", lineHeight + \"em\");\n}\nfunction computeWidthOfText(parentNode, lineHeight, line) {\n  const testElement = parentNode.append(\"text\");\n  const testSpan = createTspan(testElement, 1, lineHeight);\n  updateTextContentAndStyles(testSpan, line);\n  const textLength = testSpan.node().getComputedTextLength();\n  testElement.remove();\n  return textLength;\n}\nfunction computeDimensionOfText(parentNode, lineHeight, text) {\n  var _a;\n  const testElement = parentNode.append(\"text\");\n  const testSpan = createTspan(testElement, 1, lineHeight);\n  updateTextContentAndStyles(testSpan, [{ content: text, type: \"normal\" }]);\n  const textDimension = (_a = testSpan.node()) == null ? void 0 : _a.getBoundingClientRect();\n  if (textDimension) {\n    testElement.remove();\n  }\n  return textDimension;\n}\nfunction createFormattedText(width, g, structuredText, addBackground = false) {\n  const lineHeight = 1.1;\n  const labelGroup = g.append(\"g\");\n  const bkg = labelGroup.insert(\"rect\").attr(\"class\", \"background\");\n  const textElement = labelGroup.append(\"text\").attr(\"y\", \"-10.1\");\n  let lineIndex = 0;\n  for (const line of structuredText) {\n    const checkWidth = (line2) => computeWidthOfText(labelGroup, lineHeight, line2) <= width;\n    const linesUnderWidth = checkWidth(line) ? [line] : splitLineToFitWidth(line, checkWidth);\n    for (const preparedLine of linesUnderWidth) {\n      const tspan = createTspan(textElement, lineIndex, lineHeight);\n      updateTextContentAndStyles(tspan, preparedLine);\n      lineIndex++;\n    }\n  }\n  if (addBackground) {\n    const bbox = textElement.node().getBBox();\n    const padding = 2;\n    bkg.attr(\"x\", -padding).attr(\"y\", -padding).attr(\"width\", bbox.width + 2 * padding).attr(\"height\", bbox.height + 2 * padding);\n    return labelGroup.node();\n  } else {\n    return textElement.node();\n  }\n}\nfunction updateTextContentAndStyles(tspan, wrappedLine) {\n  tspan.text(\"\");\n  wrappedLine.forEach((word, index) => {\n    const innerTspan = tspan.append(\"tspan\").attr(\"font-style\", word.type === \"emphasis\" ? \"italic\" : \"normal\").attr(\"class\", \"text-inner-tspan\").attr(\"font-weight\", word.type === \"strong\" ? \"bold\" : \"normal\");\n    if (index === 0) {\n      innerTspan.text(word.content);\n    } else {\n      innerTspan.text(\" \" + word.content);\n    }\n  });\n}\nconst createText = (el, text = \"\", {\n  style = \"\",\n  isTitle = false,\n  classes = \"\",\n  useHtmlLabels = true,\n  isNode = true,\n  width = 200,\n  addSvgBackground = false\n} = {}) => {\n  _mermaid_934d9bea_js__WEBPACK_IMPORTED_MODULE_2__.l.info(\"createText\", text, style, isTitle, classes, useHtmlLabels, isNode, addSvgBackground);\n  if (useHtmlLabels) {\n    const htmlText = markdownToHTML(text);\n    const node = {\n      isNode,\n      label: (0,_mermaid_934d9bea_js__WEBPACK_IMPORTED_MODULE_2__.J)(htmlText).replace(\n        /fa[blrs]?:fa-[\\w-]+/g,\n        (s) => `<i class='${s.replace(\":\", \" \")}'></i>`\n      ),\n      labelStyle: style.replace(\"fill:\", \"color:\")\n    };\n    const vertexNode = addHtmlSpan(el, node, width, classes, addSvgBackground);\n    return vertexNode;\n  } else {\n    const structuredText = markdownToLines(text);\n    const svgLabel = createFormattedText(width, el, structuredText, addSvgBackground);\n    return svgLabel;\n  }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbWVybWFpZC9kaXN0L2NyZWF0ZVRleHQtYWViYWNkZmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBc0U7QUFDZDtBQUNyQjtBQUNuQztBQUNBLHVEQUF1RCxHQUFHO0FBQzFELDZCQUE2QixpREFBTTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsV0FBVyxFQUFFLHNFQUFZO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxpQ0FBaUM7QUFDdkU7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxVQUFVLFdBQVcsRUFBRSxzRUFBWTtBQUNuQztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sd0JBQXdCLG1DQUFtQztBQUMzRCxNQUFNO0FBQ04sb0JBQW9CLG1DQUFtQztBQUN2RCxNQUFNO0FBQ04sbUJBQW1CLG1DQUFtQztBQUN0RDtBQUNBLG9DQUFvQyxVQUFVO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxtQ0FBbUM7QUFDM0MsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlDQUFpQztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sbUNBQW1DO0FBQ3pDLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0EsNEJBQTRCLGlDQUFpQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsWUFBWSxFQUFFLFFBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQywrQkFBK0I7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUk7QUFDTixFQUFFLG1EQUFHO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHVEQUFjO0FBQzNCO0FBQ0EsNEJBQTRCLG9CQUFvQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJRSIsInNvdXJjZXMiOlsid2VicGFjazovL2NoYXRncHQtbmV4dC13ZWIvLi9ub2RlX21vZHVsZXMvbWVybWFpZC9kaXN0L2NyZWF0ZVRleHQtYWViYWNkZmUuanM/MTg1MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBsIGFzIGxvZywgSiBhcyBkZWNvZGVFbnRpdGllcyB9IGZyb20gXCIuL21lcm1haWQtOTM0ZDliZWEuanNcIjtcbmltcG9ydCB7IGZyb21NYXJrZG93biB9IGZyb20gXCJtZGFzdC11dGlsLWZyb20tbWFya2Rvd25cIjtcbmltcG9ydCB7IGRlZGVudCB9IGZyb20gXCJ0cy1kZWRlbnRcIjtcbmZ1bmN0aW9uIHByZXByb2Nlc3NNYXJrZG93bihtYXJrZG93bikge1xuICBjb25zdCB3aXRob3V0TXVsdGlwbGVOZXdsaW5lcyA9IG1hcmtkb3duLnJlcGxhY2UoL1xcbnsyLH0vZywgXCJcXG5cIik7XG4gIGNvbnN0IHdpdGhvdXRFeHRyYVNwYWNlcyA9IGRlZGVudCh3aXRob3V0TXVsdGlwbGVOZXdsaW5lcyk7XG4gIHJldHVybiB3aXRob3V0RXh0cmFTcGFjZXM7XG59XG5mdW5jdGlvbiBtYXJrZG93blRvTGluZXMobWFya2Rvd24pIHtcbiAgY29uc3QgcHJlcHJvY2Vzc2VkTWFya2Rvd24gPSBwcmVwcm9jZXNzTWFya2Rvd24obWFya2Rvd24pO1xuICBjb25zdCB7IGNoaWxkcmVuIH0gPSBmcm9tTWFya2Rvd24ocHJlcHJvY2Vzc2VkTWFya2Rvd24pO1xuICBjb25zdCBsaW5lcyA9IFtbXV07XG4gIGxldCBjdXJyZW50TGluZSA9IDA7XG4gIGZ1bmN0aW9uIHByb2Nlc3NOb2RlKG5vZGUsIHBhcmVudFR5cGUgPSBcIm5vcm1hbFwiKSB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgIGNvbnN0IHRleHRMaW5lcyA9IG5vZGUudmFsdWUuc3BsaXQoXCJcXG5cIik7XG4gICAgICB0ZXh0TGluZXMuZm9yRWFjaCgodGV4dExpbmUsIGluZGV4KSA9PiB7XG4gICAgICAgIGlmIChpbmRleCAhPT0gMCkge1xuICAgICAgICAgIGN1cnJlbnRMaW5lKys7XG4gICAgICAgICAgbGluZXMucHVzaChbXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGV4dExpbmUuc3BsaXQoXCIgXCIpLmZvckVhY2goKHdvcmQpID0+IHtcbiAgICAgICAgICBpZiAod29yZCkge1xuICAgICAgICAgICAgbGluZXNbY3VycmVudExpbmVdLnB1c2goeyBjb250ZW50OiB3b3JkLCB0eXBlOiBwYXJlbnRUeXBlIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gXCJzdHJvbmdcIiB8fCBub2RlLnR5cGUgPT09IFwiZW1waGFzaXNcIikge1xuICAgICAgbm9kZS5jaGlsZHJlbi5mb3JFYWNoKChjb250ZW50Tm9kZSkgPT4ge1xuICAgICAgICBwcm9jZXNzTm9kZShjb250ZW50Tm9kZSwgbm9kZS50eXBlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBjaGlsZHJlbi5mb3JFYWNoKCh0cmVlTm9kZSkgPT4ge1xuICAgIGlmICh0cmVlTm9kZS50eXBlID09PSBcInBhcmFncmFwaFwiKSB7XG4gICAgICB0cmVlTm9kZS5jaGlsZHJlbi5mb3JFYWNoKChjb250ZW50Tm9kZSkgPT4ge1xuICAgICAgICBwcm9jZXNzTm9kZShjb250ZW50Tm9kZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbGluZXM7XG59XG5mdW5jdGlvbiBtYXJrZG93blRvSFRNTChtYXJrZG93bikge1xuICBjb25zdCB7IGNoaWxkcmVuIH0gPSBmcm9tTWFya2Rvd24obWFya2Rvd24pO1xuICBmdW5jdGlvbiBvdXRwdXQobm9kZSkge1xuICAgIGlmIChub2RlLnR5cGUgPT09IFwidGV4dFwiKSB7XG4gICAgICByZXR1cm4gbm9kZS52YWx1ZS5yZXBsYWNlKC9cXG4vZywgXCI8YnIvPlwiKTtcbiAgICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gXCJzdHJvbmdcIikge1xuICAgICAgcmV0dXJuIGA8c3Ryb25nPiR7bm9kZS5jaGlsZHJlbi5tYXAob3V0cHV0KS5qb2luKFwiXCIpfTwvc3Ryb25nPmA7XG4gICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IFwiZW1waGFzaXNcIikge1xuICAgICAgcmV0dXJuIGA8ZW0+JHtub2RlLmNoaWxkcmVuLm1hcChvdXRwdXQpLmpvaW4oXCJcIil9PC9lbT5gO1xuICAgIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSBcInBhcmFncmFwaFwiKSB7XG4gICAgICByZXR1cm4gYDxwPiR7bm9kZS5jaGlsZHJlbi5tYXAob3V0cHV0KS5qb2luKFwiXCIpfTwvcD5gO1xuICAgIH1cbiAgICByZXR1cm4gYFVuc3VwcG9ydGVkIG1hcmtkb3duOiAke25vZGUudHlwZX1gO1xuICB9XG4gIHJldHVybiBjaGlsZHJlbi5tYXAob3V0cHV0KS5qb2luKFwiXCIpO1xufVxuZnVuY3Rpb24gc3BsaXRUZXh0VG9DaGFycyh0ZXh0KSB7XG4gIGlmIChJbnRsLlNlZ21lbnRlcikge1xuICAgIHJldHVybiBbLi4ubmV3IEludGwuU2VnbWVudGVyKCkuc2VnbWVudCh0ZXh0KV0ubWFwKChzKSA9PiBzLnNlZ21lbnQpO1xuICB9XG4gIHJldHVybiBbLi4udGV4dF07XG59XG5mdW5jdGlvbiBzcGxpdFdvcmRUb0ZpdFdpZHRoKGNoZWNrRml0LCB3b3JkKSB7XG4gIGNvbnN0IGNoYXJhY3RlcnMgPSBzcGxpdFRleHRUb0NoYXJzKHdvcmQuY29udGVudCk7XG4gIHJldHVybiBzcGxpdFdvcmRUb0ZpdFdpZHRoUmVjdXJzaW9uKGNoZWNrRml0LCBbXSwgY2hhcmFjdGVycywgd29yZC50eXBlKTtcbn1cbmZ1bmN0aW9uIHNwbGl0V29yZFRvRml0V2lkdGhSZWN1cnNpb24oY2hlY2tGaXQsIHVzZWRDaGFycywgcmVtYWluaW5nQ2hhcnMsIHR5cGUpIHtcbiAgaWYgKHJlbWFpbmluZ0NoYXJzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBbXG4gICAgICB7IGNvbnRlbnQ6IHVzZWRDaGFycy5qb2luKFwiXCIpLCB0eXBlIH0sXG4gICAgICB7IGNvbnRlbnQ6IFwiXCIsIHR5cGUgfVxuICAgIF07XG4gIH1cbiAgY29uc3QgW25leHRDaGFyLCAuLi5yZXN0XSA9IHJlbWFpbmluZ0NoYXJzO1xuICBjb25zdCBuZXdXb3JkID0gWy4uLnVzZWRDaGFycywgbmV4dENoYXJdO1xuICBpZiAoY2hlY2tGaXQoW3sgY29udGVudDogbmV3V29yZC5qb2luKFwiXCIpLCB0eXBlIH1dKSkge1xuICAgIHJldHVybiBzcGxpdFdvcmRUb0ZpdFdpZHRoUmVjdXJzaW9uKGNoZWNrRml0LCBuZXdXb3JkLCByZXN0LCB0eXBlKTtcbiAgfVxuICBpZiAodXNlZENoYXJzLmxlbmd0aCA9PT0gMCAmJiBuZXh0Q2hhcikge1xuICAgIHVzZWRDaGFycy5wdXNoKG5leHRDaGFyKTtcbiAgICByZW1haW5pbmdDaGFycy5zaGlmdCgpO1xuICB9XG4gIHJldHVybiBbXG4gICAgeyBjb250ZW50OiB1c2VkQ2hhcnMuam9pbihcIlwiKSwgdHlwZSB9LFxuICAgIHsgY29udGVudDogcmVtYWluaW5nQ2hhcnMuam9pbihcIlwiKSwgdHlwZSB9XG4gIF07XG59XG5mdW5jdGlvbiBzcGxpdExpbmVUb0ZpdFdpZHRoKGxpbmUsIGNoZWNrRml0KSB7XG4gIGlmIChsaW5lLnNvbWUoKHsgY29udGVudCB9KSA9PiBjb250ZW50LmluY2x1ZGVzKFwiXFxuXCIpKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInNwbGl0TGluZVRvRml0V2lkdGggZG9lcyBub3Qgc3VwcG9ydCBuZXdsaW5lcyBpbiB0aGUgbGluZVwiKTtcbiAgfVxuICByZXR1cm4gc3BsaXRMaW5lVG9GaXRXaWR0aFJlY3Vyc2lvbihsaW5lLCBjaGVja0ZpdCk7XG59XG5mdW5jdGlvbiBzcGxpdExpbmVUb0ZpdFdpZHRoUmVjdXJzaW9uKHdvcmRzLCBjaGVja0ZpdCwgbGluZXMgPSBbXSwgbmV3TGluZSA9IFtdKSB7XG4gIGlmICh3b3Jkcy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAobmV3TGluZS5sZW5ndGggPiAwKSB7XG4gICAgICBsaW5lcy5wdXNoKG5ld0xpbmUpO1xuICAgIH1cbiAgICByZXR1cm4gbGluZXMubGVuZ3RoID4gMCA/IGxpbmVzIDogW107XG4gIH1cbiAgbGV0IGpvaW5lciA9IFwiXCI7XG4gIGlmICh3b3Jkc1swXS5jb250ZW50ID09PSBcIiBcIikge1xuICAgIGpvaW5lciA9IFwiIFwiO1xuICAgIHdvcmRzLnNoaWZ0KCk7XG4gIH1cbiAgY29uc3QgbmV4dFdvcmQgPSB3b3Jkcy5zaGlmdCgpID8/IHsgY29udGVudDogXCIgXCIsIHR5cGU6IFwibm9ybWFsXCIgfTtcbiAgY29uc3QgbGluZVdpdGhOZXh0V29yZCA9IFsuLi5uZXdMaW5lXTtcbiAgaWYgKGpvaW5lciAhPT0gXCJcIikge1xuICAgIGxpbmVXaXRoTmV4dFdvcmQucHVzaCh7IGNvbnRlbnQ6IGpvaW5lciwgdHlwZTogXCJub3JtYWxcIiB9KTtcbiAgfVxuICBsaW5lV2l0aE5leHRXb3JkLnB1c2gobmV4dFdvcmQpO1xuICBpZiAoY2hlY2tGaXQobGluZVdpdGhOZXh0V29yZCkpIHtcbiAgICByZXR1cm4gc3BsaXRMaW5lVG9GaXRXaWR0aFJlY3Vyc2lvbih3b3JkcywgY2hlY2tGaXQsIGxpbmVzLCBsaW5lV2l0aE5leHRXb3JkKTtcbiAgfVxuICBpZiAobmV3TGluZS5sZW5ndGggPiAwKSB7XG4gICAgbGluZXMucHVzaChuZXdMaW5lKTtcbiAgICB3b3Jkcy51bnNoaWZ0KG5leHRXb3JkKTtcbiAgfSBlbHNlIGlmIChuZXh0V29yZC5jb250ZW50KSB7XG4gICAgY29uc3QgW2xpbmUsIHJlc3RdID0gc3BsaXRXb3JkVG9GaXRXaWR0aChjaGVja0ZpdCwgbmV4dFdvcmQpO1xuICAgIGxpbmVzLnB1c2goW2xpbmVdKTtcbiAgICBpZiAocmVzdC5jb250ZW50KSB7XG4gICAgICB3b3Jkcy51bnNoaWZ0KHJlc3QpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3BsaXRMaW5lVG9GaXRXaWR0aFJlY3Vyc2lvbih3b3JkcywgY2hlY2tGaXQsIGxpbmVzKTtcbn1cbmZ1bmN0aW9uIGFwcGx5U3R5bGUoZG9tLCBzdHlsZUZuKSB7XG4gIGlmIChzdHlsZUZuKSB7XG4gICAgZG9tLmF0dHIoXCJzdHlsZVwiLCBzdHlsZUZuKTtcbiAgfVxufVxuZnVuY3Rpb24gYWRkSHRtbFNwYW4oZWxlbWVudCwgbm9kZSwgd2lkdGgsIGNsYXNzZXMsIGFkZEJhY2tncm91bmQgPSBmYWxzZSkge1xuICBjb25zdCBmbyA9IGVsZW1lbnQuYXBwZW5kKFwiZm9yZWlnbk9iamVjdFwiKTtcbiAgY29uc3QgZGl2ID0gZm8uYXBwZW5kKFwieGh0bWw6ZGl2XCIpO1xuICBjb25zdCBsYWJlbCA9IG5vZGUubGFiZWw7XG4gIGNvbnN0IGxhYmVsQ2xhc3MgPSBub2RlLmlzTm9kZSA/IFwibm9kZUxhYmVsXCIgOiBcImVkZ2VMYWJlbFwiO1xuICBkaXYuaHRtbChcbiAgICBgXG4gICAgPHNwYW4gY2xhc3M9XCIke2xhYmVsQ2xhc3N9ICR7Y2xhc3Nlc31cIiBgICsgKG5vZGUubGFiZWxTdHlsZSA/ICdzdHlsZT1cIicgKyBub2RlLmxhYmVsU3R5bGUgKyAnXCInIDogXCJcIikgKyBcIj5cIiArIGxhYmVsICsgXCI8L3NwYW4+XCJcbiAgKTtcbiAgYXBwbHlTdHlsZShkaXYsIG5vZGUubGFiZWxTdHlsZSk7XG4gIGRpdi5zdHlsZShcImRpc3BsYXlcIiwgXCJ0YWJsZS1jZWxsXCIpO1xuICBkaXYuc3R5bGUoXCJ3aGl0ZS1zcGFjZVwiLCBcIm5vd3JhcFwiKTtcbiAgZGl2LnN0eWxlKFwibWF4LXdpZHRoXCIsIHdpZHRoICsgXCJweFwiKTtcbiAgZGl2LmF0dHIoXCJ4bWxuc1wiLCBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIik7XG4gIGlmIChhZGRCYWNrZ3JvdW5kKSB7XG4gICAgZGl2LmF0dHIoXCJjbGFzc1wiLCBcImxhYmVsQmtnXCIpO1xuICB9XG4gIGxldCBiYm94ID0gZGl2Lm5vZGUoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgaWYgKGJib3gud2lkdGggPT09IHdpZHRoKSB7XG4gICAgZGl2LnN0eWxlKFwiZGlzcGxheVwiLCBcInRhYmxlXCIpO1xuICAgIGRpdi5zdHlsZShcIndoaXRlLXNwYWNlXCIsIFwiYnJlYWstc3BhY2VzXCIpO1xuICAgIGRpdi5zdHlsZShcIndpZHRoXCIsIHdpZHRoICsgXCJweFwiKTtcbiAgICBiYm94ID0gZGl2Lm5vZGUoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgfVxuICBmby5zdHlsZShcIndpZHRoXCIsIGJib3gud2lkdGgpO1xuICBmby5zdHlsZShcImhlaWdodFwiLCBiYm94LmhlaWdodCk7XG4gIHJldHVybiBmby5ub2RlKCk7XG59XG5mdW5jdGlvbiBjcmVhdGVUc3Bhbih0ZXh0RWxlbWVudCwgbGluZUluZGV4LCBsaW5lSGVpZ2h0KSB7XG4gIHJldHVybiB0ZXh0RWxlbWVudC5hcHBlbmQoXCJ0c3BhblwiKS5hdHRyKFwiY2xhc3NcIiwgXCJ0ZXh0LW91dGVyLXRzcGFuXCIpLmF0dHIoXCJ4XCIsIDApLmF0dHIoXCJ5XCIsIGxpbmVJbmRleCAqIGxpbmVIZWlnaHQgLSAwLjEgKyBcImVtXCIpLmF0dHIoXCJkeVwiLCBsaW5lSGVpZ2h0ICsgXCJlbVwiKTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVXaWR0aE9mVGV4dChwYXJlbnROb2RlLCBsaW5lSGVpZ2h0LCBsaW5lKSB7XG4gIGNvbnN0IHRlc3RFbGVtZW50ID0gcGFyZW50Tm9kZS5hcHBlbmQoXCJ0ZXh0XCIpO1xuICBjb25zdCB0ZXN0U3BhbiA9IGNyZWF0ZVRzcGFuKHRlc3RFbGVtZW50LCAxLCBsaW5lSGVpZ2h0KTtcbiAgdXBkYXRlVGV4dENvbnRlbnRBbmRTdHlsZXModGVzdFNwYW4sIGxpbmUpO1xuICBjb25zdCB0ZXh0TGVuZ3RoID0gdGVzdFNwYW4ubm9kZSgpLmdldENvbXB1dGVkVGV4dExlbmd0aCgpO1xuICB0ZXN0RWxlbWVudC5yZW1vdmUoKTtcbiAgcmV0dXJuIHRleHRMZW5ndGg7XG59XG5mdW5jdGlvbiBjb21wdXRlRGltZW5zaW9uT2ZUZXh0KHBhcmVudE5vZGUsIGxpbmVIZWlnaHQsIHRleHQpIHtcbiAgdmFyIF9hO1xuICBjb25zdCB0ZXN0RWxlbWVudCA9IHBhcmVudE5vZGUuYXBwZW5kKFwidGV4dFwiKTtcbiAgY29uc3QgdGVzdFNwYW4gPSBjcmVhdGVUc3Bhbih0ZXN0RWxlbWVudCwgMSwgbGluZUhlaWdodCk7XG4gIHVwZGF0ZVRleHRDb250ZW50QW5kU3R5bGVzKHRlc3RTcGFuLCBbeyBjb250ZW50OiB0ZXh0LCB0eXBlOiBcIm5vcm1hbFwiIH1dKTtcbiAgY29uc3QgdGV4dERpbWVuc2lvbiA9IChfYSA9IHRlc3RTcGFuLm5vZGUoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBpZiAodGV4dERpbWVuc2lvbikge1xuICAgIHRlc3RFbGVtZW50LnJlbW92ZSgpO1xuICB9XG4gIHJldHVybiB0ZXh0RGltZW5zaW9uO1xufVxuZnVuY3Rpb24gY3JlYXRlRm9ybWF0dGVkVGV4dCh3aWR0aCwgZywgc3RydWN0dXJlZFRleHQsIGFkZEJhY2tncm91bmQgPSBmYWxzZSkge1xuICBjb25zdCBsaW5lSGVpZ2h0ID0gMS4xO1xuICBjb25zdCBsYWJlbEdyb3VwID0gZy5hcHBlbmQoXCJnXCIpO1xuICBjb25zdCBia2cgPSBsYWJlbEdyb3VwLmluc2VydChcInJlY3RcIikuYXR0cihcImNsYXNzXCIsIFwiYmFja2dyb3VuZFwiKTtcbiAgY29uc3QgdGV4dEVsZW1lbnQgPSBsYWJlbEdyb3VwLmFwcGVuZChcInRleHRcIikuYXR0cihcInlcIiwgXCItMTAuMVwiKTtcbiAgbGV0IGxpbmVJbmRleCA9IDA7XG4gIGZvciAoY29uc3QgbGluZSBvZiBzdHJ1Y3R1cmVkVGV4dCkge1xuICAgIGNvbnN0IGNoZWNrV2lkdGggPSAobGluZTIpID0+IGNvbXB1dGVXaWR0aE9mVGV4dChsYWJlbEdyb3VwLCBsaW5lSGVpZ2h0LCBsaW5lMikgPD0gd2lkdGg7XG4gICAgY29uc3QgbGluZXNVbmRlcldpZHRoID0gY2hlY2tXaWR0aChsaW5lKSA/IFtsaW5lXSA6IHNwbGl0TGluZVRvRml0V2lkdGgobGluZSwgY2hlY2tXaWR0aCk7XG4gICAgZm9yIChjb25zdCBwcmVwYXJlZExpbmUgb2YgbGluZXNVbmRlcldpZHRoKSB7XG4gICAgICBjb25zdCB0c3BhbiA9IGNyZWF0ZVRzcGFuKHRleHRFbGVtZW50LCBsaW5lSW5kZXgsIGxpbmVIZWlnaHQpO1xuICAgICAgdXBkYXRlVGV4dENvbnRlbnRBbmRTdHlsZXModHNwYW4sIHByZXBhcmVkTGluZSk7XG4gICAgICBsaW5lSW5kZXgrKztcbiAgICB9XG4gIH1cbiAgaWYgKGFkZEJhY2tncm91bmQpIHtcbiAgICBjb25zdCBiYm94ID0gdGV4dEVsZW1lbnQubm9kZSgpLmdldEJCb3goKTtcbiAgICBjb25zdCBwYWRkaW5nID0gMjtcbiAgICBia2cuYXR0cihcInhcIiwgLXBhZGRpbmcpLmF0dHIoXCJ5XCIsIC1wYWRkaW5nKS5hdHRyKFwid2lkdGhcIiwgYmJveC53aWR0aCArIDIgKiBwYWRkaW5nKS5hdHRyKFwiaGVpZ2h0XCIsIGJib3guaGVpZ2h0ICsgMiAqIHBhZGRpbmcpO1xuICAgIHJldHVybiBsYWJlbEdyb3VwLm5vZGUoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGV4dEVsZW1lbnQubm9kZSgpO1xuICB9XG59XG5mdW5jdGlvbiB1cGRhdGVUZXh0Q29udGVudEFuZFN0eWxlcyh0c3Bhbiwgd3JhcHBlZExpbmUpIHtcbiAgdHNwYW4udGV4dChcIlwiKTtcbiAgd3JhcHBlZExpbmUuZm9yRWFjaCgod29yZCwgaW5kZXgpID0+IHtcbiAgICBjb25zdCBpbm5lclRzcGFuID0gdHNwYW4uYXBwZW5kKFwidHNwYW5cIikuYXR0cihcImZvbnQtc3R5bGVcIiwgd29yZC50eXBlID09PSBcImVtcGhhc2lzXCIgPyBcIml0YWxpY1wiIDogXCJub3JtYWxcIikuYXR0cihcImNsYXNzXCIsIFwidGV4dC1pbm5lci10c3BhblwiKS5hdHRyKFwiZm9udC13ZWlnaHRcIiwgd29yZC50eXBlID09PSBcInN0cm9uZ1wiID8gXCJib2xkXCIgOiBcIm5vcm1hbFwiKTtcbiAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgIGlubmVyVHNwYW4udGV4dCh3b3JkLmNvbnRlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbm5lclRzcGFuLnRleHQoXCIgXCIgKyB3b3JkLmNvbnRlbnQpO1xuICAgIH1cbiAgfSk7XG59XG5jb25zdCBjcmVhdGVUZXh0ID0gKGVsLCB0ZXh0ID0gXCJcIiwge1xuICBzdHlsZSA9IFwiXCIsXG4gIGlzVGl0bGUgPSBmYWxzZSxcbiAgY2xhc3NlcyA9IFwiXCIsXG4gIHVzZUh0bWxMYWJlbHMgPSB0cnVlLFxuICBpc05vZGUgPSB0cnVlLFxuICB3aWR0aCA9IDIwMCxcbiAgYWRkU3ZnQmFja2dyb3VuZCA9IGZhbHNlXG59ID0ge30pID0+IHtcbiAgbG9nLmluZm8oXCJjcmVhdGVUZXh0XCIsIHRleHQsIHN0eWxlLCBpc1RpdGxlLCBjbGFzc2VzLCB1c2VIdG1sTGFiZWxzLCBpc05vZGUsIGFkZFN2Z0JhY2tncm91bmQpO1xuICBpZiAodXNlSHRtbExhYmVscykge1xuICAgIGNvbnN0IGh0bWxUZXh0ID0gbWFya2Rvd25Ub0hUTUwodGV4dCk7XG4gICAgY29uc3Qgbm9kZSA9IHtcbiAgICAgIGlzTm9kZSxcbiAgICAgIGxhYmVsOiBkZWNvZGVFbnRpdGllcyhodG1sVGV4dCkucmVwbGFjZShcbiAgICAgICAgL2ZhW2JscnNdPzpmYS1bXFx3LV0rL2csXG4gICAgICAgIChzKSA9PiBgPGkgY2xhc3M9JyR7cy5yZXBsYWNlKFwiOlwiLCBcIiBcIil9Jz48L2k+YFxuICAgICAgKSxcbiAgICAgIGxhYmVsU3R5bGU6IHN0eWxlLnJlcGxhY2UoXCJmaWxsOlwiLCBcImNvbG9yOlwiKVxuICAgIH07XG4gICAgY29uc3QgdmVydGV4Tm9kZSA9IGFkZEh0bWxTcGFuKGVsLCBub2RlLCB3aWR0aCwgY2xhc3NlcywgYWRkU3ZnQmFja2dyb3VuZCk7XG4gICAgcmV0dXJuIHZlcnRleE5vZGU7XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgc3RydWN0dXJlZFRleHQgPSBtYXJrZG93blRvTGluZXModGV4dCk7XG4gICAgY29uc3Qgc3ZnTGFiZWwgPSBjcmVhdGVGb3JtYXR0ZWRUZXh0KHdpZHRoLCBlbCwgc3RydWN0dXJlZFRleHQsIGFkZFN2Z0JhY2tncm91bmQpO1xuICAgIHJldHVybiBzdmdMYWJlbDtcbiAgfVxufTtcbmV4cG9ydCB7XG4gIGNyZWF0ZVRleHQgYXMgYSxcbiAgY29tcHV0ZURpbWVuc2lvbk9mVGV4dCBhcyBjXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/mermaid/dist/createText-aebacdfe.js\n");

/***/ }),

/***/ "(sc_client)/./node_modules/mermaid/dist/mindmap-definition-617cf8dd.js":
/*!******************************************************************!*\
  !*** ./node_modules/mermaid/dist/mindmap-definition-617cf8dd.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   diagram: () => (/* binding */ diagram)\n/* harmony export */ });\n/* harmony import */ var _mermaid_934d9bea_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./mermaid-934d9bea.js */ \"(sc_client)/./node_modules/mermaid/dist/mermaid-934d9bea.js\");\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"(sc_client)/./node_modules/d3/src/index.js\");\n/* harmony import */ var _createText_aebacdfe_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./createText-aebacdfe.js */ \"(sc_client)/./node_modules/mermaid/dist/createText-aebacdfe.js\");\n/* harmony import */ var cytoscape_dist_cytoscape_umd_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cytoscape/dist/cytoscape.umd.js */ \"(sc_client)/./node_modules/cytoscape/dist/cytoscape.umd.js\");\n/* harmony import */ var cytoscape_cose_bilkent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cytoscape-cose-bilkent */ \"(sc_client)/./node_modules/cytoscape-cose-bilkent/cytoscape-cose-bilkent.js\");\n/* harmony import */ var khroma__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! khroma */ \"(sc_client)/./node_modules/khroma/dist/methods/is_dark.js\");\n/* harmony import */ var khroma__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! khroma */ \"(sc_client)/./node_modules/khroma/dist/methods/lighten.js\");\n/* harmony import */ var khroma__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! khroma */ \"(sc_client)/./node_modules/khroma/dist/methods/darken.js\");\n/* harmony import */ var ts_dedent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ts-dedent */ \"(sc_client)/./node_modules/ts-dedent/dist/index.js\");\n/* harmony import */ var dayjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! dayjs */ \"(sc_client)/./node_modules/dayjs/dayjs.min.js\");\n/* harmony import */ var _braintree_sanitize_url__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @braintree/sanitize-url */ \"(sc_client)/./node_modules/@braintree/sanitize-url/dist/index.js\");\n/* harmony import */ var dompurify__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! dompurify */ \"(sc_client)/./node_modules/dompurify/dist/purify.cjs.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar parser = function() {\n  var o = function(k, v, o2, l) {\n    for (o2 = o2 || {}, l = k.length; l--; o2[k[l]] = v)\n      ;\n    return o2;\n  }, $V0 = [1, 4], $V1 = [1, 13], $V2 = [1, 12], $V3 = [1, 15], $V4 = [1, 16], $V5 = [1, 20], $V6 = [1, 19], $V7 = [6, 7, 8], $V8 = [1, 26], $V9 = [1, 24], $Va = [1, 25], $Vb = [6, 7, 11], $Vc = [1, 6, 13, 15, 16, 19, 22], $Vd = [1, 33], $Ve = [1, 34], $Vf = [1, 6, 7, 11, 13, 15, 16, 19, 22];\n  var parser2 = {\n    trace: function trace() {\n    },\n    yy: {},\n    symbols_: { \"error\": 2, \"start\": 3, \"mindMap\": 4, \"spaceLines\": 5, \"SPACELINE\": 6, \"NL\": 7, \"MINDMAP\": 8, \"document\": 9, \"stop\": 10, \"EOF\": 11, \"statement\": 12, \"SPACELIST\": 13, \"node\": 14, \"ICON\": 15, \"CLASS\": 16, \"nodeWithId\": 17, \"nodeWithoutId\": 18, \"NODE_DSTART\": 19, \"NODE_DESCR\": 20, \"NODE_DEND\": 21, \"NODE_ID\": 22, \"$accept\": 0, \"$end\": 1 },\n    terminals_: { 2: \"error\", 6: \"SPACELINE\", 7: \"NL\", 8: \"MINDMAP\", 11: \"EOF\", 13: \"SPACELIST\", 15: \"ICON\", 16: \"CLASS\", 19: \"NODE_DSTART\", 20: \"NODE_DESCR\", 21: \"NODE_DEND\", 22: \"NODE_ID\" },\n    productions_: [0, [3, 1], [3, 2], [5, 1], [5, 2], [5, 2], [4, 2], [4, 3], [10, 1], [10, 1], [10, 1], [10, 2], [10, 2], [9, 3], [9, 2], [12, 2], [12, 2], [12, 2], [12, 1], [12, 1], [12, 1], [12, 1], [12, 1], [14, 1], [14, 1], [18, 3], [17, 1], [17, 4]],\n    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {\n      var $0 = $$.length - 1;\n      switch (yystate) {\n        case 6:\n        case 7:\n          return yy;\n        case 8:\n          yy.getLogger().trace(\"Stop NL \");\n          break;\n        case 9:\n          yy.getLogger().trace(\"Stop EOF \");\n          break;\n        case 11:\n          yy.getLogger().trace(\"Stop NL2 \");\n          break;\n        case 12:\n          yy.getLogger().trace(\"Stop EOF2 \");\n          break;\n        case 15:\n          yy.getLogger().info(\"Node: \", $$[$0].id);\n          yy.addNode($$[$0 - 1].length, $$[$0].id, $$[$0].descr, $$[$0].type);\n          break;\n        case 16:\n          yy.getLogger().trace(\"Icon: \", $$[$0]);\n          yy.decorateNode({ icon: $$[$0] });\n          break;\n        case 17:\n        case 21:\n          yy.decorateNode({ class: $$[$0] });\n          break;\n        case 18:\n          yy.getLogger().trace(\"SPACELIST\");\n          break;\n        case 19:\n          yy.getLogger().trace(\"Node: \", $$[$0].id);\n          yy.addNode(0, $$[$0].id, $$[$0].descr, $$[$0].type);\n          break;\n        case 20:\n          yy.decorateNode({ icon: $$[$0] });\n          break;\n        case 25:\n          yy.getLogger().trace(\"node found ..\", $$[$0 - 2]);\n          this.$ = { id: $$[$0 - 1], descr: $$[$0 - 1], type: yy.getType($$[$0 - 2], $$[$0]) };\n          break;\n        case 26:\n          this.$ = { id: $$[$0], descr: $$[$0], type: yy.nodeType.DEFAULT };\n          break;\n        case 27:\n          yy.getLogger().trace(\"node found ..\", $$[$0 - 3]);\n          this.$ = { id: $$[$0 - 3], descr: $$[$0 - 1], type: yy.getType($$[$0 - 2], $$[$0]) };\n          break;\n      }\n    },\n    table: [{ 3: 1, 4: 2, 5: 3, 6: [1, 5], 8: $V0 }, { 1: [3] }, { 1: [2, 1] }, { 4: 6, 6: [1, 7], 7: [1, 8], 8: $V0 }, { 6: $V1, 7: [1, 10], 9: 9, 12: 11, 13: $V2, 14: 14, 15: $V3, 16: $V4, 17: 17, 18: 18, 19: $V5, 22: $V6 }, o($V7, [2, 3]), { 1: [2, 2] }, o($V7, [2, 4]), o($V7, [2, 5]), { 1: [2, 6], 6: $V1, 12: 21, 13: $V2, 14: 14, 15: $V3, 16: $V4, 17: 17, 18: 18, 19: $V5, 22: $V6 }, { 6: $V1, 9: 22, 12: 11, 13: $V2, 14: 14, 15: $V3, 16: $V4, 17: 17, 18: 18, 19: $V5, 22: $V6 }, { 6: $V8, 7: $V9, 10: 23, 11: $Va }, o($Vb, [2, 22], { 17: 17, 18: 18, 14: 27, 15: [1, 28], 16: [1, 29], 19: $V5, 22: $V6 }), o($Vb, [2, 18]), o($Vb, [2, 19]), o($Vb, [2, 20]), o($Vb, [2, 21]), o($Vb, [2, 23]), o($Vb, [2, 24]), o($Vb, [2, 26], { 19: [1, 30] }), { 20: [1, 31] }, { 6: $V8, 7: $V9, 10: 32, 11: $Va }, { 1: [2, 7], 6: $V1, 12: 21, 13: $V2, 14: 14, 15: $V3, 16: $V4, 17: 17, 18: 18, 19: $V5, 22: $V6 }, o($Vc, [2, 14], { 7: $Vd, 11: $Ve }), o($Vf, [2, 8]), o($Vf, [2, 9]), o($Vf, [2, 10]), o($Vb, [2, 15]), o($Vb, [2, 16]), o($Vb, [2, 17]), { 20: [1, 35] }, { 21: [1, 36] }, o($Vc, [2, 13], { 7: $Vd, 11: $Ve }), o($Vf, [2, 11]), o($Vf, [2, 12]), { 21: [1, 37] }, o($Vb, [2, 25]), o($Vb, [2, 27])],\n    defaultActions: { 2: [2, 1], 6: [2, 2] },\n    parseError: function parseError2(str, hash) {\n      if (hash.recoverable) {\n        this.trace(str);\n      } else {\n        var error = new Error(str);\n        error.hash = hash;\n        throw error;\n      }\n    },\n    parse: function parse(input) {\n      var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = \"\", yylineno = 0, yyleng = 0, TERROR = 2, EOF = 1;\n      var args = lstack.slice.call(arguments, 1);\n      var lexer2 = Object.create(this.lexer);\n      var sharedState = { yy: {} };\n      for (var k in this.yy) {\n        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {\n          sharedState.yy[k] = this.yy[k];\n        }\n      }\n      lexer2.setInput(input, sharedState.yy);\n      sharedState.yy.lexer = lexer2;\n      sharedState.yy.parser = this;\n      if (typeof lexer2.yylloc == \"undefined\") {\n        lexer2.yylloc = {};\n      }\n      var yyloc = lexer2.yylloc;\n      lstack.push(yyloc);\n      var ranges = lexer2.options && lexer2.options.ranges;\n      if (typeof sharedState.yy.parseError === \"function\") {\n        this.parseError = sharedState.yy.parseError;\n      } else {\n        this.parseError = Object.getPrototypeOf(this).parseError;\n      }\n      function lex() {\n        var token;\n        token = tstack.pop() || lexer2.lex() || EOF;\n        if (typeof token !== \"number\") {\n          if (token instanceof Array) {\n            tstack = token;\n            token = tstack.pop();\n          }\n          token = self.symbols_[token] || token;\n        }\n        return token;\n      }\n      var symbol, state, action, r, yyval = {}, p, len, newState, expected;\n      while (true) {\n        state = stack[stack.length - 1];\n        if (this.defaultActions[state]) {\n          action = this.defaultActions[state];\n        } else {\n          if (symbol === null || typeof symbol == \"undefined\") {\n            symbol = lex();\n          }\n          action = table[state] && table[state][symbol];\n        }\n        if (typeof action === \"undefined\" || !action.length || !action[0]) {\n          var errStr = \"\";\n          expected = [];\n          for (p in table[state]) {\n            if (this.terminals_[p] && p > TERROR) {\n              expected.push(\"'\" + this.terminals_[p] + \"'\");\n            }\n          }\n          if (lexer2.showPosition) {\n            errStr = \"Parse error on line \" + (yylineno + 1) + \":\\n\" + lexer2.showPosition() + \"\\nExpecting \" + expected.join(\", \") + \", got '\" + (this.terminals_[symbol] || symbol) + \"'\";\n          } else {\n            errStr = \"Parse error on line \" + (yylineno + 1) + \": Unexpected \" + (symbol == EOF ? \"end of input\" : \"'\" + (this.terminals_[symbol] || symbol) + \"'\");\n          }\n          this.parseError(errStr, {\n            text: lexer2.match,\n            token: this.terminals_[symbol] || symbol,\n            line: lexer2.yylineno,\n            loc: yyloc,\n            expected\n          });\n        }\n        if (action[0] instanceof Array && action.length > 1) {\n          throw new Error(\"Parse Error: multiple actions possible at state: \" + state + \", token: \" + symbol);\n        }\n        switch (action[0]) {\n          case 1:\n            stack.push(symbol);\n            vstack.push(lexer2.yytext);\n            lstack.push(lexer2.yylloc);\n            stack.push(action[1]);\n            symbol = null;\n            {\n              yyleng = lexer2.yyleng;\n              yytext = lexer2.yytext;\n              yylineno = lexer2.yylineno;\n              yyloc = lexer2.yylloc;\n            }\n            break;\n          case 2:\n            len = this.productions_[action[1]][1];\n            yyval.$ = vstack[vstack.length - len];\n            yyval._$ = {\n              first_line: lstack[lstack.length - (len || 1)].first_line,\n              last_line: lstack[lstack.length - 1].last_line,\n              first_column: lstack[lstack.length - (len || 1)].first_column,\n              last_column: lstack[lstack.length - 1].last_column\n            };\n            if (ranges) {\n              yyval._$.range = [\n                lstack[lstack.length - (len || 1)].range[0],\n                lstack[lstack.length - 1].range[1]\n              ];\n            }\n            r = this.performAction.apply(yyval, [\n              yytext,\n              yyleng,\n              yylineno,\n              sharedState.yy,\n              action[1],\n              vstack,\n              lstack\n            ].concat(args));\n            if (typeof r !== \"undefined\") {\n              return r;\n            }\n            if (len) {\n              stack = stack.slice(0, -1 * len * 2);\n              vstack = vstack.slice(0, -1 * len);\n              lstack = lstack.slice(0, -1 * len);\n            }\n            stack.push(this.productions_[action[1]][0]);\n            vstack.push(yyval.$);\n            lstack.push(yyval._$);\n            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];\n            stack.push(newState);\n            break;\n          case 3:\n            return true;\n        }\n      }\n      return true;\n    }\n  };\n  var lexer = function() {\n    var lexer2 = {\n      EOF: 1,\n      parseError: function parseError2(str, hash) {\n        if (this.yy.parser) {\n          this.yy.parser.parseError(str, hash);\n        } else {\n          throw new Error(str);\n        }\n      },\n      // resets the lexer, sets new input\n      setInput: function(input, yy) {\n        this.yy = yy || this.yy || {};\n        this._input = input;\n        this._more = this._backtrack = this.done = false;\n        this.yylineno = this.yyleng = 0;\n        this.yytext = this.matched = this.match = \"\";\n        this.conditionStack = [\"INITIAL\"];\n        this.yylloc = {\n          first_line: 1,\n          first_column: 0,\n          last_line: 1,\n          last_column: 0\n        };\n        if (this.options.ranges) {\n          this.yylloc.range = [0, 0];\n        }\n        this.offset = 0;\n        return this;\n      },\n      // consumes and returns one char from the input\n      input: function() {\n        var ch = this._input[0];\n        this.yytext += ch;\n        this.yyleng++;\n        this.offset++;\n        this.match += ch;\n        this.matched += ch;\n        var lines = ch.match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n          this.yylineno++;\n          this.yylloc.last_line++;\n        } else {\n          this.yylloc.last_column++;\n        }\n        if (this.options.ranges) {\n          this.yylloc.range[1]++;\n        }\n        this._input = this._input.slice(1);\n        return ch;\n      },\n      // unshifts one char (or a string) into the input\n      unput: function(ch) {\n        var len = ch.length;\n        var lines = ch.split(/(?:\\r\\n?|\\n)/g);\n        this._input = ch + this._input;\n        this.yytext = this.yytext.substr(0, this.yytext.length - len);\n        this.offset -= len;\n        var oldLines = this.match.split(/(?:\\r\\n?|\\n)/g);\n        this.match = this.match.substr(0, this.match.length - 1);\n        this.matched = this.matched.substr(0, this.matched.length - 1);\n        if (lines.length - 1) {\n          this.yylineno -= lines.length - 1;\n        }\n        var r = this.yylloc.range;\n        this.yylloc = {\n          first_line: this.yylloc.first_line,\n          last_line: this.yylineno + 1,\n          first_column: this.yylloc.first_column,\n          last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len\n        };\n        if (this.options.ranges) {\n          this.yylloc.range = [r[0], r[0] + this.yyleng - len];\n        }\n        this.yyleng = this.yytext.length;\n        return this;\n      },\n      // When called from action, caches matched text and appends it on next action\n      more: function() {\n        this._more = true;\n        return this;\n      },\n      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.\n      reject: function() {\n        if (this.options.backtrack_lexer) {\n          this._backtrack = true;\n        } else {\n          return this.parseError(\"Lexical error on line \" + (this.yylineno + 1) + \". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\\n\" + this.showPosition(), {\n            text: \"\",\n            token: null,\n            line: this.yylineno\n          });\n        }\n        return this;\n      },\n      // retain first n characters of the match\n      less: function(n) {\n        this.unput(this.match.slice(n));\n      },\n      // displays already matched input, i.e. for error messages\n      pastInput: function() {\n        var past = this.matched.substr(0, this.matched.length - this.match.length);\n        return (past.length > 20 ? \"...\" : \"\") + past.substr(-20).replace(/\\n/g, \"\");\n      },\n      // displays upcoming input, i.e. for error messages\n      upcomingInput: function() {\n        var next = this.match;\n        if (next.length < 20) {\n          next += this._input.substr(0, 20 - next.length);\n        }\n        return (next.substr(0, 20) + (next.length > 20 ? \"...\" : \"\")).replace(/\\n/g, \"\");\n      },\n      // displays the character position where the lexing error occurred, i.e. for error messages\n      showPosition: function() {\n        var pre = this.pastInput();\n        var c = new Array(pre.length + 1).join(\"-\");\n        return pre + this.upcomingInput() + \"\\n\" + c + \"^\";\n      },\n      // test the lexed token: return FALSE when not a match, otherwise return token\n      test_match: function(match, indexed_rule) {\n        var token, lines, backup;\n        if (this.options.backtrack_lexer) {\n          backup = {\n            yylineno: this.yylineno,\n            yylloc: {\n              first_line: this.yylloc.first_line,\n              last_line: this.last_line,\n              first_column: this.yylloc.first_column,\n              last_column: this.yylloc.last_column\n            },\n            yytext: this.yytext,\n            match: this.match,\n            matches: this.matches,\n            matched: this.matched,\n            yyleng: this.yyleng,\n            offset: this.offset,\n            _more: this._more,\n            _input: this._input,\n            yy: this.yy,\n            conditionStack: this.conditionStack.slice(0),\n            done: this.done\n          };\n          if (this.options.ranges) {\n            backup.yylloc.range = this.yylloc.range.slice(0);\n          }\n        }\n        lines = match[0].match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n          this.yylineno += lines.length;\n        }\n        this.yylloc = {\n          first_line: this.yylloc.last_line,\n          last_line: this.yylineno + 1,\n          first_column: this.yylloc.last_column,\n          last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\\r?\\n?/)[0].length : this.yylloc.last_column + match[0].length\n        };\n        this.yytext += match[0];\n        this.match += match[0];\n        this.matches = match;\n        this.yyleng = this.yytext.length;\n        if (this.options.ranges) {\n          this.yylloc.range = [this.offset, this.offset += this.yyleng];\n        }\n        this._more = false;\n        this._backtrack = false;\n        this._input = this._input.slice(match[0].length);\n        this.matched += match[0];\n        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);\n        if (this.done && this._input) {\n          this.done = false;\n        }\n        if (token) {\n          return token;\n        } else if (this._backtrack) {\n          for (var k in backup) {\n            this[k] = backup[k];\n          }\n          return false;\n        }\n        return false;\n      },\n      // return next match in input\n      next: function() {\n        if (this.done) {\n          return this.EOF;\n        }\n        if (!this._input) {\n          this.done = true;\n        }\n        var token, match, tempMatch, index;\n        if (!this._more) {\n          this.yytext = \"\";\n          this.match = \"\";\n        }\n        var rules = this._currentRules();\n        for (var i = 0; i < rules.length; i++) {\n          tempMatch = this._input.match(this.rules[rules[i]]);\n          if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\n            match = tempMatch;\n            index = i;\n            if (this.options.backtrack_lexer) {\n              token = this.test_match(tempMatch, rules[i]);\n              if (token !== false) {\n                return token;\n              } else if (this._backtrack) {\n                match = false;\n                continue;\n              } else {\n                return false;\n              }\n            } else if (!this.options.flex) {\n              break;\n            }\n          }\n        }\n        if (match) {\n          token = this.test_match(match, rules[index]);\n          if (token !== false) {\n            return token;\n          }\n          return false;\n        }\n        if (this._input === \"\") {\n          return this.EOF;\n        } else {\n          return this.parseError(\"Lexical error on line \" + (this.yylineno + 1) + \". Unrecognized text.\\n\" + this.showPosition(), {\n            text: \"\",\n            token: null,\n            line: this.yylineno\n          });\n        }\n      },\n      // return next match that has a token\n      lex: function lex() {\n        var r = this.next();\n        if (r) {\n          return r;\n        } else {\n          return this.lex();\n        }\n      },\n      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)\n      begin: function begin(condition) {\n        this.conditionStack.push(condition);\n      },\n      // pop the previously active lexer condition state off the condition stack\n      popState: function popState() {\n        var n = this.conditionStack.length - 1;\n        if (n > 0) {\n          return this.conditionStack.pop();\n        } else {\n          return this.conditionStack[0];\n        }\n      },\n      // produce the lexer rule set which is active for the currently active lexer condition state\n      _currentRules: function _currentRules() {\n        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {\n          return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;\n        } else {\n          return this.conditions[\"INITIAL\"].rules;\n        }\n      },\n      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available\n      topState: function topState(n) {\n        n = this.conditionStack.length - 1 - Math.abs(n || 0);\n        if (n >= 0) {\n          return this.conditionStack[n];\n        } else {\n          return \"INITIAL\";\n        }\n      },\n      // alias for begin(condition)\n      pushState: function pushState(condition) {\n        this.begin(condition);\n      },\n      // return the number of states currently on the stack\n      stateStackSize: function stateStackSize() {\n        return this.conditionStack.length;\n      },\n      options: { \"case-insensitive\": true },\n      performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {\n        switch ($avoiding_name_collisions) {\n          case 0:\n            yy.getLogger().trace(\"Found comment\", yy_.yytext);\n            return 6;\n          case 1:\n            return 8;\n          case 2:\n            this.begin(\"CLASS\");\n            break;\n          case 3:\n            this.popState();\n            return 16;\n          case 4:\n            this.popState();\n            break;\n          case 5:\n            yy.getLogger().trace(\"Begin icon\");\n            this.begin(\"ICON\");\n            break;\n          case 6:\n            yy.getLogger().trace(\"SPACELINE\");\n            return 6;\n          case 7:\n            return 7;\n          case 8:\n            return 15;\n          case 9:\n            yy.getLogger().trace(\"end icon\");\n            this.popState();\n            break;\n          case 10:\n            yy.getLogger().trace(\"Exploding node\");\n            this.begin(\"NODE\");\n            return 19;\n          case 11:\n            yy.getLogger().trace(\"Cloud\");\n            this.begin(\"NODE\");\n            return 19;\n          case 12:\n            yy.getLogger().trace(\"Explosion Bang\");\n            this.begin(\"NODE\");\n            return 19;\n          case 13:\n            yy.getLogger().trace(\"Cloud Bang\");\n            this.begin(\"NODE\");\n            return 19;\n          case 14:\n            this.begin(\"NODE\");\n            return 19;\n          case 15:\n            this.begin(\"NODE\");\n            return 19;\n          case 16:\n            this.begin(\"NODE\");\n            return 19;\n          case 17:\n            this.begin(\"NODE\");\n            return 19;\n          case 18:\n            return 13;\n          case 19:\n            return 22;\n          case 20:\n            return 11;\n          case 21:\n            this.begin(\"NSTR2\");\n            break;\n          case 22:\n            return \"NODE_DESCR\";\n          case 23:\n            this.popState();\n            break;\n          case 24:\n            yy.getLogger().trace(\"Starting NSTR\");\n            this.begin(\"NSTR\");\n            break;\n          case 25:\n            yy.getLogger().trace(\"description:\", yy_.yytext);\n            return \"NODE_DESCR\";\n          case 26:\n            this.popState();\n            break;\n          case 27:\n            this.popState();\n            yy.getLogger().trace(\"node end ))\");\n            return \"NODE_DEND\";\n          case 28:\n            this.popState();\n            yy.getLogger().trace(\"node end )\");\n            return \"NODE_DEND\";\n          case 29:\n            this.popState();\n            yy.getLogger().trace(\"node end ...\", yy_.yytext);\n            return \"NODE_DEND\";\n          case 30:\n            this.popState();\n            yy.getLogger().trace(\"node end ((\");\n            return \"NODE_DEND\";\n          case 31:\n            this.popState();\n            yy.getLogger().trace(\"node end (-\");\n            return \"NODE_DEND\";\n          case 32:\n            this.popState();\n            yy.getLogger().trace(\"node end (-\");\n            return \"NODE_DEND\";\n          case 33:\n            this.popState();\n            yy.getLogger().trace(\"node end ((\");\n            return \"NODE_DEND\";\n          case 34:\n            this.popState();\n            yy.getLogger().trace(\"node end ((\");\n            return \"NODE_DEND\";\n          case 35:\n            yy.getLogger().trace(\"Long description:\", yy_.yytext);\n            return 20;\n          case 36:\n            yy.getLogger().trace(\"Long description:\", yy_.yytext);\n            return 20;\n        }\n      },\n      rules: [/^(?:\\s*%%.*)/i, /^(?:mindmap\\b)/i, /^(?::::)/i, /^(?:.+)/i, /^(?:\\n)/i, /^(?:::icon\\()/i, /^(?:[\\s]+[\\n])/i, /^(?:[\\n]+)/i, /^(?:[^\\)]+)/i, /^(?:\\))/i, /^(?:-\\))/i, /^(?:\\(-)/i, /^(?:\\)\\))/i, /^(?:\\))/i, /^(?:\\(\\()/i, /^(?:\\{\\{)/i, /^(?:\\()/i, /^(?:\\[)/i, /^(?:[\\s]+)/i, /^(?:[^\\(\\[\\n\\)\\{\\}]+)/i, /^(?:$)/i, /^(?:[\"][`])/i, /^(?:[^`\"]+)/i, /^(?:[`][\"])/i, /^(?:[\"])/i, /^(?:[^\"]+)/i, /^(?:[\"])/i, /^(?:[\\)]\\))/i, /^(?:[\\)])/i, /^(?:[\\]])/i, /^(?:\\}\\})/i, /^(?:\\(-)/i, /^(?:-\\))/i, /^(?:\\(\\()/i, /^(?:\\()/i, /^(?:[^\\)\\]\\(\\}]+)/i, /^(?:.+(?!\\(\\())/i],\n      conditions: { \"CLASS\": { \"rules\": [3, 4], \"inclusive\": false }, \"ICON\": { \"rules\": [8, 9], \"inclusive\": false }, \"NSTR2\": { \"rules\": [22, 23], \"inclusive\": false }, \"NSTR\": { \"rules\": [25, 26], \"inclusive\": false }, \"NODE\": { \"rules\": [21, 24, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36], \"inclusive\": false }, \"INITIAL\": { \"rules\": [0, 1, 2, 5, 6, 7, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20], \"inclusive\": true } }\n    };\n    return lexer2;\n  }();\n  parser2.lexer = lexer;\n  function Parser() {\n    this.yy = {};\n  }\n  Parser.prototype = parser2;\n  parser2.Parser = Parser;\n  return new Parser();\n}();\nparser.parser = parser;\nconst mindmapParser = parser;\nconst sanitizeText = (text) => (0,_mermaid_934d9bea_js__WEBPACK_IMPORTED_MODULE_7__.d)(text, (0,_mermaid_934d9bea_js__WEBPACK_IMPORTED_MODULE_7__.c)());\nlet nodes = [];\nlet cnt = 0;\nlet elements = {};\nconst clear = () => {\n  nodes = [];\n  cnt = 0;\n  elements = {};\n};\nconst getParent = function(level) {\n  for (let i = nodes.length - 1; i >= 0; i--) {\n    if (nodes[i].level < level) {\n      return nodes[i];\n    }\n  }\n  return null;\n};\nconst getMindmap = () => {\n  return nodes.length > 0 ? nodes[0] : null;\n};\nconst addNode = (level, id, descr, type) => {\n  _mermaid_934d9bea_js__WEBPACK_IMPORTED_MODULE_7__.l.info(\"addNode\", level, id, descr, type);\n  const conf = (0,_mermaid_934d9bea_js__WEBPACK_IMPORTED_MODULE_7__.c)();\n  const node = {\n    id: cnt++,\n    nodeId: sanitizeText(id),\n    level,\n    descr: sanitizeText(descr),\n    type,\n    children: [],\n    width: (0,_mermaid_934d9bea_js__WEBPACK_IMPORTED_MODULE_7__.c)().mindmap.maxNodeWidth\n  };\n  switch (node.type) {\n    case nodeType.ROUNDED_RECT:\n      node.padding = 2 * conf.mindmap.padding;\n      break;\n    case nodeType.RECT:\n      node.padding = 2 * conf.mindmap.padding;\n      break;\n    case nodeType.HEXAGON:\n      node.padding = 2 * conf.mindmap.padding;\n      break;\n    default:\n      node.padding = conf.mindmap.padding;\n  }\n  const parent = getParent(level);\n  if (parent) {\n    parent.children.push(node);\n    nodes.push(node);\n  } else {\n    if (nodes.length === 0) {\n      nodes.push(node);\n    } else {\n      let error = new Error(\n        'There can be only one root. No parent could be found for (\"' + node.descr + '\")'\n      );\n      error.hash = {\n        text: \"branch \" + name,\n        token: \"branch \" + name,\n        line: \"1\",\n        loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },\n        expected: ['\"checkout ' + name + '\"']\n      };\n      throw error;\n    }\n  }\n};\nconst nodeType = {\n  DEFAULT: 0,\n  NO_BORDER: 0,\n  ROUNDED_RECT: 1,\n  RECT: 2,\n  CIRCLE: 3,\n  CLOUD: 4,\n  BANG: 5,\n  HEXAGON: 6\n};\nconst getType = (startStr, endStr) => {\n  _mermaid_934d9bea_js__WEBPACK_IMPORTED_MODULE_7__.l.debug(\"In get type\", startStr, endStr);\n  switch (startStr) {\n    case \"[\":\n      return nodeType.RECT;\n    case \"(\":\n      return endStr === \")\" ? nodeType.ROUNDED_RECT : nodeType.CLOUD;\n    case \"((\":\n      return nodeType.CIRCLE;\n    case \")\":\n      return nodeType.CLOUD;\n    case \"))\":\n      return nodeType.BANG;\n    case \"{{\":\n      return nodeType.HEXAGON;\n    default:\n      return nodeType.DEFAULT;\n  }\n};\nconst setElementForId = (id, element) => {\n  elements[id] = element;\n};\nconst decorateNode = (decoration) => {\n  const node = nodes[nodes.length - 1];\n  if (decoration && decoration.icon) {\n    node.icon = sanitizeText(decoration.icon);\n  }\n  if (decoration && decoration.class) {\n    node.class = sanitizeText(decoration.class);\n  }\n};\nconst type2Str = (type) => {\n  switch (type) {\n    case nodeType.DEFAULT:\n      return \"no-border\";\n    case nodeType.RECT:\n      return \"rect\";\n    case nodeType.ROUNDED_RECT:\n      return \"rounded-rect\";\n    case nodeType.CIRCLE:\n      return \"circle\";\n    case nodeType.CLOUD:\n      return \"cloud\";\n    case nodeType.BANG:\n      return \"bang\";\n    case nodeType.HEXAGON:\n      return \"hexgon\";\n    default:\n      return \"no-border\";\n  }\n};\nlet parseError;\nconst setErrorHandler = (handler) => {\n  parseError = handler;\n};\nconst getLogger = () => _mermaid_934d9bea_js__WEBPACK_IMPORTED_MODULE_7__.l;\nconst getNodeById = (id) => nodes[id];\nconst getElementById = (id) => elements[id];\nconst mindmapDb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  addNode,\n  clear,\n  decorateNode,\n  getElementById,\n  getLogger,\n  getMindmap,\n  getNodeById,\n  getType,\n  nodeType,\n  get parseError() {\n    return parseError;\n  },\n  sanitizeText,\n  setElementForId,\n  setErrorHandler,\n  type2Str\n}, Symbol.toStringTag, { value: \"Module\" }));\nconst MAX_SECTIONS = 12;\nconst defaultBkg = function(elem, node, section) {\n  const rd = 5;\n  elem.append(\"path\").attr(\"id\", \"node-\" + node.id).attr(\"class\", \"node-bkg node-\" + type2Str(node.type)).attr(\n    \"d\",\n    `M0 ${node.height - rd} v${-node.height + 2 * rd} q0,-5 5,-5 h${node.width - 2 * rd} q5,0 5,5 v${node.height - rd} H0 Z`\n  );\n  elem.append(\"line\").attr(\"class\", \"node-line-\" + section).attr(\"x1\", 0).attr(\"y1\", node.height).attr(\"x2\", node.width).attr(\"y2\", node.height);\n};\nconst rectBkg = function(elem, node) {\n  elem.append(\"rect\").attr(\"id\", \"node-\" + node.id).attr(\"class\", \"node-bkg node-\" + type2Str(node.type)).attr(\"height\", node.height).attr(\"width\", node.width);\n};\nconst cloudBkg = function(elem, node) {\n  const w = node.width;\n  const h = node.height;\n  const r1 = 0.15 * w;\n  const r2 = 0.25 * w;\n  const r3 = 0.35 * w;\n  const r4 = 0.2 * w;\n  elem.append(\"path\").attr(\"id\", \"node-\" + node.id).attr(\"class\", \"node-bkg node-\" + type2Str(node.type)).attr(\n    \"d\",\n    `M0 0 a${r1},${r1} 0 0,1 ${w * 0.25},${-1 * w * 0.1}\n      a${r3},${r3} 1 0,1 ${w * 0.4},${-1 * w * 0.1}\n      a${r2},${r2} 1 0,1 ${w * 0.35},${1 * w * 0.2}\n\n      a${r1},${r1} 1 0,1 ${w * 0.15},${1 * h * 0.35}\n      a${r4},${r4} 1 0,1 ${-1 * w * 0.15},${1 * h * 0.65}\n\n      a${r2},${r1} 1 0,1 ${-1 * w * 0.25},${w * 0.15}\n      a${r3},${r3} 1 0,1 ${-1 * w * 0.5},${0}\n      a${r1},${r1} 1 0,1 ${-1 * w * 0.25},${-1 * w * 0.15}\n\n      a${r1},${r1} 1 0,1 ${-1 * w * 0.1},${-1 * h * 0.35}\n      a${r4},${r4} 1 0,1 ${w * 0.1},${-1 * h * 0.65}\n\n    H0 V0 Z`\n  );\n};\nconst bangBkg = function(elem, node) {\n  const w = node.width;\n  const h = node.height;\n  const r = 0.15 * w;\n  elem.append(\"path\").attr(\"id\", \"node-\" + node.id).attr(\"class\", \"node-bkg node-\" + type2Str(node.type)).attr(\n    \"d\",\n    `M0 0 a${r},${r} 1 0,0 ${w * 0.25},${-1 * h * 0.1}\n      a${r},${r} 1 0,0 ${w * 0.25},${0}\n      a${r},${r} 1 0,0 ${w * 0.25},${0}\n      a${r},${r} 1 0,0 ${w * 0.25},${1 * h * 0.1}\n\n      a${r},${r} 1 0,0 ${w * 0.15},${1 * h * 0.33}\n      a${r * 0.8},${r * 0.8} 1 0,0 ${0},${1 * h * 0.34}\n      a${r},${r} 1 0,0 ${-1 * w * 0.15},${1 * h * 0.33}\n\n      a${r},${r} 1 0,0 ${-1 * w * 0.25},${h * 0.15}\n      a${r},${r} 1 0,0 ${-1 * w * 0.25},${0}\n      a${r},${r} 1 0,0 ${-1 * w * 0.25},${0}\n      a${r},${r} 1 0,0 ${-1 * w * 0.25},${-1 * h * 0.15}\n\n      a${r},${r} 1 0,0 ${-1 * w * 0.1},${-1 * h * 0.33}\n      a${r * 0.8},${r * 0.8} 1 0,0 ${0},${-1 * h * 0.34}\n      a${r},${r} 1 0,0 ${w * 0.1},${-1 * h * 0.33}\n\n    H0 V0 Z`\n  );\n};\nconst circleBkg = function(elem, node) {\n  elem.append(\"circle\").attr(\"id\", \"node-\" + node.id).attr(\"class\", \"node-bkg node-\" + type2Str(node.type)).attr(\"r\", node.width / 2);\n};\nfunction insertPolygonShape(parent, w, h, points, node) {\n  return parent.insert(\"polygon\", \":first-child\").attr(\n    \"points\",\n    points.map(function(d) {\n      return d.x + \",\" + d.y;\n    }).join(\" \")\n  ).attr(\"transform\", \"translate(\" + (node.width - w) / 2 + \", \" + h + \")\");\n}\nconst hexagonBkg = function(elem, node) {\n  const h = node.height;\n  const f = 4;\n  const m = h / f;\n  const w = node.width - node.padding + 2 * m;\n  const points = [\n    { x: m, y: 0 },\n    { x: w - m, y: 0 },\n    { x: w, y: -h / 2 },\n    { x: w - m, y: -h },\n    { x: m, y: -h },\n    { x: 0, y: -h / 2 }\n  ];\n  insertPolygonShape(elem, w, h, points, node);\n};\nconst roundedRectBkg = function(elem, node) {\n  elem.append(\"rect\").attr(\"id\", \"node-\" + node.id).attr(\"class\", \"node-bkg node-\" + type2Str(node.type)).attr(\"height\", node.height).attr(\"rx\", node.padding).attr(\"ry\", node.padding).attr(\"width\", node.width);\n};\nconst drawNode = function(elem, node, fullSection, conf) {\n  const htmlLabels = conf.htmlLabels;\n  const section = fullSection % (MAX_SECTIONS - 1);\n  const nodeElem = elem.append(\"g\");\n  node.section = section;\n  let sectionClass = \"section-\" + section;\n  if (section < 0) {\n    sectionClass += \" section-root\";\n  }\n  nodeElem.attr(\"class\", (node.class ? node.class + \" \" : \"\") + \"mindmap-node \" + sectionClass);\n  const bkgElem = nodeElem.append(\"g\");\n  const textElem = nodeElem.append(\"g\");\n  const description = node.descr.replace(/(<br\\/*>)/g, \"\\n\");\n  (0,_createText_aebacdfe_js__WEBPACK_IMPORTED_MODULE_8__.a)(textElem, description, {\n    useHtmlLabels: htmlLabels,\n    width: node.width,\n    classes: \"mindmap-node-label\"\n  });\n  if (!htmlLabels) {\n    textElem.attr(\"dy\", \"1em\").attr(\"alignment-baseline\", \"middle\").attr(\"dominant-baseline\", \"middle\").attr(\"text-anchor\", \"middle\");\n  }\n  const bbox = textElem.node().getBBox();\n  const fontSize = conf.fontSize.replace ? conf.fontSize.replace(\"px\", \"\") : conf.fontSize;\n  node.height = bbox.height + fontSize * 1.1 * 0.5 + node.padding;\n  node.width = bbox.width + 2 * node.padding;\n  if (node.icon) {\n    if (node.type === nodeType.CIRCLE) {\n      node.height += 50;\n      node.width += 50;\n      const icon = nodeElem.append(\"foreignObject\").attr(\"height\", \"50px\").attr(\"width\", node.width).attr(\"style\", \"text-align: center;\");\n      icon.append(\"div\").attr(\"class\", \"icon-container\").append(\"i\").attr(\"class\", \"node-icon-\" + section + \" \" + node.icon);\n      textElem.attr(\n        \"transform\",\n        \"translate(\" + node.width / 2 + \", \" + (node.height / 2 - 1.5 * node.padding) + \")\"\n      );\n    } else {\n      node.width += 50;\n      const orgHeight = node.height;\n      node.height = Math.max(orgHeight, 60);\n      const heightDiff = Math.abs(node.height - orgHeight);\n      const icon = nodeElem.append(\"foreignObject\").attr(\"width\", \"60px\").attr(\"height\", node.height).attr(\"style\", \"text-align: center;margin-top:\" + heightDiff / 2 + \"px;\");\n      icon.append(\"div\").attr(\"class\", \"icon-container\").append(\"i\").attr(\"class\", \"node-icon-\" + section + \" \" + node.icon);\n      textElem.attr(\n        \"transform\",\n        \"translate(\" + (25 + node.width / 2) + \", \" + (heightDiff / 2 + node.padding / 2) + \")\"\n      );\n    }\n  } else {\n    if (!htmlLabels) {\n      const dx = node.width / 2;\n      const dy = node.padding / 2;\n      textElem.attr(\"transform\", \"translate(\" + dx + \", \" + dy + \")\");\n    } else {\n      const dx = (node.width - bbox.width) / 2;\n      const dy = (node.height - bbox.height) / 2;\n      textElem.attr(\"transform\", \"translate(\" + dx + \", \" + dy + \")\");\n    }\n  }\n  switch (node.type) {\n    case nodeType.DEFAULT:\n      defaultBkg(bkgElem, node, section);\n      break;\n    case nodeType.ROUNDED_RECT:\n      roundedRectBkg(bkgElem, node);\n      break;\n    case nodeType.RECT:\n      rectBkg(bkgElem, node);\n      break;\n    case nodeType.CIRCLE:\n      bkgElem.attr(\"transform\", \"translate(\" + node.width / 2 + \", \" + +node.height / 2 + \")\");\n      circleBkg(bkgElem, node);\n      break;\n    case nodeType.CLOUD:\n      cloudBkg(bkgElem, node);\n      break;\n    case nodeType.BANG:\n      bangBkg(bkgElem, node);\n      break;\n    case nodeType.HEXAGON:\n      hexagonBkg(bkgElem, node);\n      break;\n  }\n  setElementForId(node.id, nodeElem);\n  return node.height;\n};\nconst drawEdge = function drawEdge2(edgesElem, mindmap, parent, depth, fullSection) {\n  const section = fullSection % (MAX_SECTIONS - 1);\n  const sx = parent.x + parent.width / 2;\n  const sy = parent.y + parent.height / 2;\n  const ex = mindmap.x + mindmap.width / 2;\n  const ey = mindmap.y + mindmap.height / 2;\n  const mx = ex > sx ? sx + Math.abs(sx - ex) / 2 : sx - Math.abs(sx - ex) / 2;\n  const my = ey > sy ? sy + Math.abs(sy - ey) / 2 : sy - Math.abs(sy - ey) / 2;\n  const qx = ex > sx ? Math.abs(sx - mx) / 2 + sx : -Math.abs(sx - mx) / 2 + sx;\n  const qy = ey > sy ? Math.abs(sy - my) / 2 + sy : -Math.abs(sy - my) / 2 + sy;\n  edgesElem.append(\"path\").attr(\n    \"d\",\n    parent.direction === \"TB\" || parent.direction === \"BT\" ? `M${sx},${sy} Q${sx},${qy} ${mx},${my} T${ex},${ey}` : `M${sx},${sy} Q${qx},${sy} ${mx},${my} T${ex},${ey}`\n  ).attr(\"class\", \"edge section-edge-\" + section + \" edge-depth-\" + depth);\n};\nconst positionNode = function(node) {\n  const nodeElem = getElementById(node.id);\n  const x = node.x || 0;\n  const y = node.y || 0;\n  nodeElem.attr(\"transform\", \"translate(\" + x + \",\" + y + \")\");\n};\nconst svgDraw = { drawNode, positionNode, drawEdge };\ncytoscape_dist_cytoscape_umd_js__WEBPACK_IMPORTED_MODULE_1__.use(cytoscape_cose_bilkent__WEBPACK_IMPORTED_MODULE_2__);\nfunction drawNodes(svg, mindmap, section, conf) {\n  svgDraw.drawNode(svg, mindmap, section, conf);\n  if (mindmap.children) {\n    mindmap.children.forEach((child, index) => {\n      drawNodes(svg, child, section < 0 ? index : section, conf);\n    });\n  }\n}\nfunction drawEdges(edgesEl, cy) {\n  cy.edges().map((edge, id) => {\n    const data = edge.data();\n    if (edge[0]._private.bodyBounds) {\n      const bounds = edge[0]._private.rscratch;\n      _mermaid_934d9bea_js__WEBPACK_IMPORTED_MODULE_7__.l.trace(\"Edge: \", id, data);\n      edgesEl.insert(\"path\").attr(\n        \"d\",\n        `M ${bounds.startX},${bounds.startY} L ${bounds.midX},${bounds.midY} L${bounds.endX},${bounds.endY} `\n      ).attr(\"class\", \"edge section-edge-\" + data.section + \" edge-depth-\" + data.depth);\n    }\n  });\n}\nfunction addNodes(mindmap, cy, conf, level) {\n  cy.add({\n    group: \"nodes\",\n    data: {\n      id: mindmap.id,\n      labelText: mindmap.descr,\n      height: mindmap.height,\n      width: mindmap.width,\n      level,\n      nodeId: mindmap.id,\n      padding: mindmap.padding,\n      type: mindmap.type\n    },\n    position: {\n      x: mindmap.x,\n      y: mindmap.y\n    }\n  });\n  if (mindmap.children) {\n    mindmap.children.forEach((child) => {\n      addNodes(child, cy, conf, level + 1);\n      cy.add({\n        group: \"edges\",\n        data: {\n          id: `${mindmap.id}_${child.id}`,\n          source: mindmap.id,\n          target: child.id,\n          depth: level,\n          section: child.section\n        }\n      });\n    });\n  }\n}\nfunction layoutMindmap(node, conf) {\n  return new Promise((resolve) => {\n    const renderEl = (0,d3__WEBPACK_IMPORTED_MODULE_0__.select)(\"body\").append(\"div\").attr(\"id\", \"cy\").attr(\"style\", \"display:none\");\n    const cy = cytoscape_dist_cytoscape_umd_js__WEBPACK_IMPORTED_MODULE_1__({\n      container: document.getElementById(\"cy\"),\n      // container to render in\n      style: [\n        {\n          selector: \"edge\",\n          style: {\n            \"curve-style\": \"bezier\"\n          }\n        }\n      ]\n    });\n    renderEl.remove();\n    addNodes(node, cy, conf, 0);\n    cy.nodes().forEach(function(n) {\n      n.layoutDimensions = () => {\n        const data = n.data();\n        return { w: data.width, h: data.height };\n      };\n    });\n    cy.layout({\n      name: \"cose-bilkent\",\n      quality: \"proof\",\n      // headless: true,\n      styleEnabled: false,\n      animate: false\n    }).run();\n    cy.ready((e) => {\n      _mermaid_934d9bea_js__WEBPACK_IMPORTED_MODULE_7__.l.info(\"Ready\", e);\n      resolve(cy);\n    });\n  });\n}\nfunction positionNodes(cy) {\n  cy.nodes().map((node, id) => {\n    const data = node.data();\n    data.x = node.position().x;\n    data.y = node.position().y;\n    svgDraw.positionNode(data);\n    const el = getElementById(data.nodeId);\n    _mermaid_934d9bea_js__WEBPACK_IMPORTED_MODULE_7__.l.info(\"Id:\", id, \"Position: (\", node.position().x, \", \", node.position().y, \")\", data);\n    el.attr(\n      \"transform\",\n      `translate(${node.position().x - data.width / 2}, ${node.position().y - data.height / 2})`\n    );\n    el.attr(\"attr\", `apa-${id})`);\n  });\n}\nconst draw = async (text, id, version, diagObj) => {\n  const conf = (0,_mermaid_934d9bea_js__WEBPACK_IMPORTED_MODULE_7__.c)();\n  conf.htmlLabels = false;\n  _mermaid_934d9bea_js__WEBPACK_IMPORTED_MODULE_7__.l.debug(\"Rendering mindmap diagram\\n\" + text, diagObj.parser);\n  const securityLevel = (0,_mermaid_934d9bea_js__WEBPACK_IMPORTED_MODULE_7__.c)().securityLevel;\n  let sandboxElement;\n  if (securityLevel === \"sandbox\") {\n    sandboxElement = (0,d3__WEBPACK_IMPORTED_MODULE_0__.select)(\"#i\" + id);\n  }\n  const root = securityLevel === \"sandbox\" ? (0,d3__WEBPACK_IMPORTED_MODULE_0__.select)(sandboxElement.nodes()[0].contentDocument.body) : (0,d3__WEBPACK_IMPORTED_MODULE_0__.select)(\"body\");\n  const svg = root.select(\"#\" + id);\n  svg.append(\"g\");\n  const mm = diagObj.db.getMindmap();\n  const edgesElem = svg.append(\"g\");\n  edgesElem.attr(\"class\", \"mindmap-edges\");\n  const nodesElem = svg.append(\"g\");\n  nodesElem.attr(\"class\", \"mindmap-nodes\");\n  drawNodes(nodesElem, mm, -1, conf);\n  const cy = await layoutMindmap(mm, conf);\n  drawEdges(edgesElem, cy);\n  positionNodes(cy);\n  (0,_mermaid_934d9bea_js__WEBPACK_IMPORTED_MODULE_7__.o)(void 0, svg, conf.mindmap.padding, conf.mindmap.useMaxWidth);\n};\nconst mindmapRenderer = {\n  draw\n};\nconst genSections = (options) => {\n  let sections = \"\";\n  for (let i = 0; i < options.THEME_COLOR_LIMIT; i++) {\n    options[\"lineColor\" + i] = options[\"lineColor\" + i] || options[\"cScaleInv\" + i];\n    if ((0,khroma__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(options[\"lineColor\" + i])) {\n      options[\"lineColor\" + i] = (0,khroma__WEBPACK_IMPORTED_MODULE_10__[\"default\"])(options[\"lineColor\" + i], 20);\n    } else {\n      options[\"lineColor\" + i] = (0,khroma__WEBPACK_IMPORTED_MODULE_11__[\"default\"])(options[\"lineColor\" + i], 20);\n    }\n  }\n  for (let i = 0; i < options.THEME_COLOR_LIMIT; i++) {\n    const sw = \"\" + (17 - 3 * i);\n    sections += `\n    .section-${i - 1} rect, .section-${i - 1} path, .section-${i - 1} circle, .section-${i - 1} polygon, .section-${i - 1} path  {\n      fill: ${options[\"cScale\" + i]};\n    }\n    .section-${i - 1} text {\n     fill: ${options[\"cScaleLabel\" + i]};\n    }\n    .node-icon-${i - 1} {\n      font-size: 40px;\n      color: ${options[\"cScaleLabel\" + i]};\n    }\n    .section-edge-${i - 1}{\n      stroke: ${options[\"cScale\" + i]};\n    }\n    .edge-depth-${i - 1}{\n      stroke-width: ${sw};\n    }\n    .section-${i - 1} line {\n      stroke: ${options[\"cScaleInv\" + i]} ;\n      stroke-width: 3;\n    }\n\n    .disabled, .disabled circle, .disabled text {\n      fill: lightgray;\n    }\n    .disabled text {\n      fill: #efefef;\n    }\n    `;\n  }\n  return sections;\n};\nconst getStyles = (options) => `\n  .edge {\n    stroke-width: 3;\n  }\n  ${genSections(options)}\n  .section-root rect, .section-root path, .section-root circle, .section-root polygon  {\n    fill: ${options.git0};\n  }\n  .section-root text {\n    fill: ${options.gitBranchLabel0};\n  }\n  .icon-container {\n    height:100%;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n  }\n  .edge {\n    fill: none;\n  }\n  .mindmap-node-label {\n    dy: 1em;\n    alignment-baseline: middle;\n    text-anchor: middle;\n    dominant-baseline: middle;\n    text-align: center;\n  }\n`;\nconst mindmapStyles = getStyles;\nconst diagram = {\n  db: mindmapDb,\n  renderer: mindmapRenderer,\n  parser: mindmapParser,\n  styles: mindmapStyles\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNjX2NsaWVudCkvLi9ub2RlX21vZHVsZXMvbWVybWFpZC9kaXN0L21pbmRtYXAtZGVmaW5pdGlvbi02MTdjZjhkZC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQThHO0FBQ2xGO0FBQytCO0FBQ0g7QUFDUDtBQUNBO0FBQzlCO0FBQ0o7QUFDa0I7QUFDZDtBQUNXO0FBQ0Y7QUFDWjtBQUNjO0FBQ0k7QUFDbEM7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0IsS0FBSztBQUMzQztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsVUFBVTtBQUNWLGdCQUFnQixnVkFBZ1Y7QUFDaFcsa0JBQWtCLDZLQUE2SztBQUMvTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixjQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixjQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsS0FBSztBQUNMLGNBQWMscUNBQXFDLElBQUksUUFBUSxJQUFJLFdBQVcsSUFBSSxvQ0FBb0MsSUFBSSx1R0FBdUcsb0JBQW9CLFdBQVcsb0NBQW9DLGdHQUFnRyxJQUFJLDRGQUE0RixJQUFJLGlDQUFpQyxvQkFBb0Isb0VBQW9FLDJIQUEySCxhQUFhLEtBQUssYUFBYSxJQUFJLGlDQUFpQyxJQUFJLGdHQUFnRyxvQkFBb0IsaUJBQWlCLHlHQUF5RyxhQUFhLElBQUksYUFBYSxvQkFBb0IsaUJBQWlCLHVDQUF1QyxhQUFhO0FBQ3pvQyxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxpQkFBaUIsMEJBQTBCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsZ1BBQWdQLEVBQUUsNkRBQTZELEVBQUUsOEpBQThKLEVBQUUsd0VBQXdFO0FBQ3poQixvQkFBb0IsV0FBVyxxQ0FBcUMsWUFBWSxxQ0FBcUMsYUFBYSx1Q0FBdUMsWUFBWSx1Q0FBdUMsWUFBWSwrRUFBK0UsZUFBZTtBQUN0VTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSwrQkFBK0IsdURBQWMsT0FBTyx1REFBUztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsUUFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsbURBQUc7QUFDTCxlQUFlLHVEQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1REFBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsOERBQThEO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLG1EQUFHO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1EQUFHO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCLGlCQUFpQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxrQkFBa0IsR0FBRyx1QkFBdUIsY0FBYyxxQkFBcUIsWUFBWSxrQkFBa0I7QUFDdkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxHQUFHLEdBQUcsSUFBSSxRQUFRLFNBQVMsR0FBRztBQUMzQyxTQUFTLEdBQUcsR0FBRyxJQUFJLFFBQVEsUUFBUSxHQUFHO0FBQ3RDLFNBQVMsR0FBRyxHQUFHLElBQUksUUFBUSxTQUFTLEdBQUc7O0FBRXZDLFNBQVMsR0FBRyxHQUFHLElBQUksUUFBUSxTQUFTLEdBQUc7QUFDdkMsU0FBUyxHQUFHLEdBQUcsSUFBSSxRQUFRLGNBQWMsR0FBRzs7QUFFNUMsU0FBUyxHQUFHLEdBQUcsSUFBSSxRQUFRLGNBQWMsR0FBRztBQUM1QyxTQUFTLEdBQUcsR0FBRyxJQUFJLFFBQVEsYUFBYSxHQUFHO0FBQzNDLFNBQVMsR0FBRyxHQUFHLElBQUksUUFBUSxjQUFjLEdBQUc7O0FBRTVDLFNBQVMsR0FBRyxHQUFHLElBQUksUUFBUSxhQUFhLEdBQUc7QUFDM0MsU0FBUyxHQUFHLEdBQUcsSUFBSSxRQUFRLFFBQVEsR0FBRzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxFQUFFLEdBQUcsR0FBRyxRQUFRLFNBQVMsR0FBRztBQUN6QyxTQUFTLEVBQUUsR0FBRyxHQUFHLFFBQVEsU0FBUyxHQUFHO0FBQ3JDLFNBQVMsRUFBRSxHQUFHLEdBQUcsUUFBUSxTQUFTLEdBQUc7QUFDckMsU0FBUyxFQUFFLEdBQUcsR0FBRyxRQUFRLFNBQVMsR0FBRzs7QUFFckMsU0FBUyxFQUFFLEdBQUcsR0FBRyxRQUFRLFNBQVMsR0FBRztBQUNyQyxTQUFTLFFBQVEsR0FBRyxTQUFTLFFBQVEsRUFBRSxHQUFHO0FBQzFDLFNBQVMsRUFBRSxHQUFHLEdBQUcsUUFBUSxjQUFjLEdBQUc7O0FBRTFDLFNBQVMsRUFBRSxHQUFHLEdBQUcsUUFBUSxjQUFjLEdBQUc7QUFDMUMsU0FBUyxFQUFFLEdBQUcsR0FBRyxRQUFRLGNBQWMsR0FBRztBQUMxQyxTQUFTLEVBQUUsR0FBRyxHQUFHLFFBQVEsY0FBYyxHQUFHO0FBQzFDLFNBQVMsRUFBRSxHQUFHLEdBQUcsUUFBUSxjQUFjLEdBQUc7O0FBRTFDLFNBQVMsRUFBRSxHQUFHLEdBQUcsUUFBUSxhQUFhLEdBQUc7QUFDekMsU0FBUyxRQUFRLEdBQUcsU0FBUyxRQUFRLEVBQUUsR0FBRztBQUMxQyxTQUFTLEVBQUUsR0FBRyxHQUFHLFFBQVEsUUFBUSxHQUFHOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0EsNkNBQTZDLDBDQUFNLG1EQUFtRCwwQ0FBTTtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSx1REFBaUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLCtCQUErQjtBQUNqRDtBQUNBLFFBQVEsa0RBQU07QUFDZCxpQ0FBaUMsbURBQU87QUFDeEMsTUFBTTtBQUNOLGlDQUFpQyxtREFBTTtBQUN2QztBQUNBO0FBQ0Esa0JBQWtCLCtCQUErQjtBQUNqRDtBQUNBO0FBQ0EsZUFBZSxPQUFPLGlCQUFpQixPQUFPLGlCQUFpQixPQUFPLG1CQUFtQixPQUFPLG9CQUFvQixPQUFPO0FBQzNILGNBQWM7QUFDZDtBQUNBLGVBQWUsT0FBTztBQUN0QixhQUFhO0FBQ2I7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxvQkFBb0I7QUFDcEIsZ0JBQWdCO0FBQ2hCO0FBQ0Esa0JBQWtCO0FBQ2xCLHNCQUFzQjtBQUN0QjtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL2NoYXRncHQtbmV4dC13ZWIvLi9ub2RlX21vZHVsZXMvbWVybWFpZC9kaXN0L21pbmRtYXAtZGVmaW5pdGlvbi02MTdjZjhkZC5qcz82YWI2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGQgYXMgc2FuaXRpemVUZXh0JDEsIGMgYXMgZ2V0Q29uZmlnLCBsIGFzIGxvZywgbyBhcyBzZXR1cEdyYXBoVmlld2JveCB9IGZyb20gXCIuL21lcm1haWQtOTM0ZDliZWEuanNcIjtcbmltcG9ydCB7IHNlbGVjdCB9IGZyb20gXCJkM1wiO1xuaW1wb3J0IHsgYSBhcyBjcmVhdGVUZXh0IH0gZnJvbSBcIi4vY3JlYXRlVGV4dC1hZWJhY2RmZS5qc1wiO1xuaW1wb3J0IGN5dG9zY2FwZSBmcm9tIFwiY3l0b3NjYXBlL2Rpc3QvY3l0b3NjYXBlLnVtZC5qc1wiO1xuaW1wb3J0IGNvc2VCaWxrZW50IGZyb20gXCJjeXRvc2NhcGUtY29zZS1iaWxrZW50XCI7XG5pbXBvcnQgeyBpc0RhcmssIGxpZ2h0ZW4sIGRhcmtlbiB9IGZyb20gXCJraHJvbWFcIjtcbmltcG9ydCBcInRzLWRlZGVudFwiO1xuaW1wb3J0IFwiZGF5anNcIjtcbmltcG9ydCBcIkBicmFpbnRyZWUvc2FuaXRpemUtdXJsXCI7XG5pbXBvcnQgXCJkb21wdXJpZnlcIjtcbmltcG9ydCBcImxvZGFzaC1lcy9tZW1vaXplLmpzXCI7XG5pbXBvcnQgXCJsb2Rhc2gtZXMvbWVyZ2UuanNcIjtcbmltcG9ydCBcInN0eWxpc1wiO1xuaW1wb3J0IFwibG9kYXNoLWVzL2lzRW1wdHkuanNcIjtcbmltcG9ydCBcIm1kYXN0LXV0aWwtZnJvbS1tYXJrZG93blwiO1xudmFyIHBhcnNlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbyA9IGZ1bmN0aW9uKGssIHYsIG8yLCBsKSB7XG4gICAgZm9yIChvMiA9IG8yIHx8IHt9LCBsID0gay5sZW5ndGg7IGwtLTsgbzJba1tsXV0gPSB2KVxuICAgICAgO1xuICAgIHJldHVybiBvMjtcbiAgfSwgJFYwID0gWzEsIDRdLCAkVjEgPSBbMSwgMTNdLCAkVjIgPSBbMSwgMTJdLCAkVjMgPSBbMSwgMTVdLCAkVjQgPSBbMSwgMTZdLCAkVjUgPSBbMSwgMjBdLCAkVjYgPSBbMSwgMTldLCAkVjcgPSBbNiwgNywgOF0sICRWOCA9IFsxLCAyNl0sICRWOSA9IFsxLCAyNF0sICRWYSA9IFsxLCAyNV0sICRWYiA9IFs2LCA3LCAxMV0sICRWYyA9IFsxLCA2LCAxMywgMTUsIDE2LCAxOSwgMjJdLCAkVmQgPSBbMSwgMzNdLCAkVmUgPSBbMSwgMzRdLCAkVmYgPSBbMSwgNiwgNywgMTEsIDEzLCAxNSwgMTYsIDE5LCAyMl07XG4gIHZhciBwYXJzZXIyID0ge1xuICAgIHRyYWNlOiBmdW5jdGlvbiB0cmFjZSgpIHtcbiAgICB9LFxuICAgIHl5OiB7fSxcbiAgICBzeW1ib2xzXzogeyBcImVycm9yXCI6IDIsIFwic3RhcnRcIjogMywgXCJtaW5kTWFwXCI6IDQsIFwic3BhY2VMaW5lc1wiOiA1LCBcIlNQQUNFTElORVwiOiA2LCBcIk5MXCI6IDcsIFwiTUlORE1BUFwiOiA4LCBcImRvY3VtZW50XCI6IDksIFwic3RvcFwiOiAxMCwgXCJFT0ZcIjogMTEsIFwic3RhdGVtZW50XCI6IDEyLCBcIlNQQUNFTElTVFwiOiAxMywgXCJub2RlXCI6IDE0LCBcIklDT05cIjogMTUsIFwiQ0xBU1NcIjogMTYsIFwibm9kZVdpdGhJZFwiOiAxNywgXCJub2RlV2l0aG91dElkXCI6IDE4LCBcIk5PREVfRFNUQVJUXCI6IDE5LCBcIk5PREVfREVTQ1JcIjogMjAsIFwiTk9ERV9ERU5EXCI6IDIxLCBcIk5PREVfSURcIjogMjIsIFwiJGFjY2VwdFwiOiAwLCBcIiRlbmRcIjogMSB9LFxuICAgIHRlcm1pbmFsc186IHsgMjogXCJlcnJvclwiLCA2OiBcIlNQQUNFTElORVwiLCA3OiBcIk5MXCIsIDg6IFwiTUlORE1BUFwiLCAxMTogXCJFT0ZcIiwgMTM6IFwiU1BBQ0VMSVNUXCIsIDE1OiBcIklDT05cIiwgMTY6IFwiQ0xBU1NcIiwgMTk6IFwiTk9ERV9EU1RBUlRcIiwgMjA6IFwiTk9ERV9ERVNDUlwiLCAyMTogXCJOT0RFX0RFTkRcIiwgMjI6IFwiTk9ERV9JRFwiIH0sXG4gICAgcHJvZHVjdGlvbnNfOiBbMCwgWzMsIDFdLCBbMywgMl0sIFs1LCAxXSwgWzUsIDJdLCBbNSwgMl0sIFs0LCAyXSwgWzQsIDNdLCBbMTAsIDFdLCBbMTAsIDFdLCBbMTAsIDFdLCBbMTAsIDJdLCBbMTAsIDJdLCBbOSwgM10sIFs5LCAyXSwgWzEyLCAyXSwgWzEyLCAyXSwgWzEyLCAyXSwgWzEyLCAxXSwgWzEyLCAxXSwgWzEyLCAxXSwgWzEyLCAxXSwgWzEyLCAxXSwgWzE0LCAxXSwgWzE0LCAxXSwgWzE4LCAzXSwgWzE3LCAxXSwgWzE3LCA0XV0sXG4gICAgcGVyZm9ybUFjdGlvbjogZnVuY3Rpb24gYW5vbnltb3VzKHl5dGV4dCwgeXlsZW5nLCB5eWxpbmVubywgeXksIHl5c3RhdGUsICQkLCBfJCkge1xuICAgICAgdmFyICQwID0gJCQubGVuZ3RoIC0gMTtcbiAgICAgIHN3aXRjaCAoeXlzdGF0ZSkge1xuICAgICAgICBjYXNlIDY6XG4gICAgICAgIGNhc2UgNzpcbiAgICAgICAgICByZXR1cm4geXk7XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICB5eS5nZXRMb2dnZXIoKS50cmFjZShcIlN0b3AgTkwgXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgeXkuZ2V0TG9nZ2VyKCkudHJhY2UoXCJTdG9wIEVPRiBcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgeXkuZ2V0TG9nZ2VyKCkudHJhY2UoXCJTdG9wIE5MMiBcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgeXkuZ2V0TG9nZ2VyKCkudHJhY2UoXCJTdG9wIEVPRjIgXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgIHl5LmdldExvZ2dlcigpLmluZm8oXCJOb2RlOiBcIiwgJCRbJDBdLmlkKTtcbiAgICAgICAgICB5eS5hZGROb2RlKCQkWyQwIC0gMV0ubGVuZ3RoLCAkJFskMF0uaWQsICQkWyQwXS5kZXNjciwgJCRbJDBdLnR5cGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgIHl5LmdldExvZ2dlcigpLnRyYWNlKFwiSWNvbjogXCIsICQkWyQwXSk7XG4gICAgICAgICAgeXkuZGVjb3JhdGVOb2RlKHsgaWNvbjogJCRbJDBdIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE3OlxuICAgICAgICBjYXNlIDIxOlxuICAgICAgICAgIHl5LmRlY29yYXRlTm9kZSh7IGNsYXNzOiAkJFskMF0gfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgeXkuZ2V0TG9nZ2VyKCkudHJhY2UoXCJTUEFDRUxJU1RcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgeXkuZ2V0TG9nZ2VyKCkudHJhY2UoXCJOb2RlOiBcIiwgJCRbJDBdLmlkKTtcbiAgICAgICAgICB5eS5hZGROb2RlKDAsICQkWyQwXS5pZCwgJCRbJDBdLmRlc2NyLCAkJFskMF0udHlwZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgeXkuZGVjb3JhdGVOb2RlKHsgaWNvbjogJCRbJDBdIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI1OlxuICAgICAgICAgIHl5LmdldExvZ2dlcigpLnRyYWNlKFwibm9kZSBmb3VuZCAuLlwiLCAkJFskMCAtIDJdKTtcbiAgICAgICAgICB0aGlzLiQgPSB7IGlkOiAkJFskMCAtIDFdLCBkZXNjcjogJCRbJDAgLSAxXSwgdHlwZTogeXkuZ2V0VHlwZSgkJFskMCAtIDJdLCAkJFskMF0pIH07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjY6XG4gICAgICAgICAgdGhpcy4kID0geyBpZDogJCRbJDBdLCBkZXNjcjogJCRbJDBdLCB0eXBlOiB5eS5ub2RlVHlwZS5ERUZBVUxUIH07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgeXkuZ2V0TG9nZ2VyKCkudHJhY2UoXCJub2RlIGZvdW5kIC4uXCIsICQkWyQwIC0gM10pO1xuICAgICAgICAgIHRoaXMuJCA9IHsgaWQ6ICQkWyQwIC0gM10sIGRlc2NyOiAkJFskMCAtIDFdLCB0eXBlOiB5eS5nZXRUeXBlKCQkWyQwIC0gMl0sICQkWyQwXSkgfTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9LFxuICAgIHRhYmxlOiBbeyAzOiAxLCA0OiAyLCA1OiAzLCA2OiBbMSwgNV0sIDg6ICRWMCB9LCB7IDE6IFszXSB9LCB7IDE6IFsyLCAxXSB9LCB7IDQ6IDYsIDY6IFsxLCA3XSwgNzogWzEsIDhdLCA4OiAkVjAgfSwgeyA2OiAkVjEsIDc6IFsxLCAxMF0sIDk6IDksIDEyOiAxMSwgMTM6ICRWMiwgMTQ6IDE0LCAxNTogJFYzLCAxNjogJFY0LCAxNzogMTcsIDE4OiAxOCwgMTk6ICRWNSwgMjI6ICRWNiB9LCBvKCRWNywgWzIsIDNdKSwgeyAxOiBbMiwgMl0gfSwgbygkVjcsIFsyLCA0XSksIG8oJFY3LCBbMiwgNV0pLCB7IDE6IFsyLCA2XSwgNjogJFYxLCAxMjogMjEsIDEzOiAkVjIsIDE0OiAxNCwgMTU6ICRWMywgMTY6ICRWNCwgMTc6IDE3LCAxODogMTgsIDE5OiAkVjUsIDIyOiAkVjYgfSwgeyA2OiAkVjEsIDk6IDIyLCAxMjogMTEsIDEzOiAkVjIsIDE0OiAxNCwgMTU6ICRWMywgMTY6ICRWNCwgMTc6IDE3LCAxODogMTgsIDE5OiAkVjUsIDIyOiAkVjYgfSwgeyA2OiAkVjgsIDc6ICRWOSwgMTA6IDIzLCAxMTogJFZhIH0sIG8oJFZiLCBbMiwgMjJdLCB7IDE3OiAxNywgMTg6IDE4LCAxNDogMjcsIDE1OiBbMSwgMjhdLCAxNjogWzEsIDI5XSwgMTk6ICRWNSwgMjI6ICRWNiB9KSwgbygkVmIsIFsyLCAxOF0pLCBvKCRWYiwgWzIsIDE5XSksIG8oJFZiLCBbMiwgMjBdKSwgbygkVmIsIFsyLCAyMV0pLCBvKCRWYiwgWzIsIDIzXSksIG8oJFZiLCBbMiwgMjRdKSwgbygkVmIsIFsyLCAyNl0sIHsgMTk6IFsxLCAzMF0gfSksIHsgMjA6IFsxLCAzMV0gfSwgeyA2OiAkVjgsIDc6ICRWOSwgMTA6IDMyLCAxMTogJFZhIH0sIHsgMTogWzIsIDddLCA2OiAkVjEsIDEyOiAyMSwgMTM6ICRWMiwgMTQ6IDE0LCAxNTogJFYzLCAxNjogJFY0LCAxNzogMTcsIDE4OiAxOCwgMTk6ICRWNSwgMjI6ICRWNiB9LCBvKCRWYywgWzIsIDE0XSwgeyA3OiAkVmQsIDExOiAkVmUgfSksIG8oJFZmLCBbMiwgOF0pLCBvKCRWZiwgWzIsIDldKSwgbygkVmYsIFsyLCAxMF0pLCBvKCRWYiwgWzIsIDE1XSksIG8oJFZiLCBbMiwgMTZdKSwgbygkVmIsIFsyLCAxN10pLCB7IDIwOiBbMSwgMzVdIH0sIHsgMjE6IFsxLCAzNl0gfSwgbygkVmMsIFsyLCAxM10sIHsgNzogJFZkLCAxMTogJFZlIH0pLCBvKCRWZiwgWzIsIDExXSksIG8oJFZmLCBbMiwgMTJdKSwgeyAyMTogWzEsIDM3XSB9LCBvKCRWYiwgWzIsIDI1XSksIG8oJFZiLCBbMiwgMjddKV0sXG4gICAgZGVmYXVsdEFjdGlvbnM6IHsgMjogWzIsIDFdLCA2OiBbMiwgMl0gfSxcbiAgICBwYXJzZUVycm9yOiBmdW5jdGlvbiBwYXJzZUVycm9yMihzdHIsIGhhc2gpIHtcbiAgICAgIGlmIChoYXNoLnJlY292ZXJhYmxlKSB7XG4gICAgICAgIHRoaXMudHJhY2Uoc3RyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihzdHIpO1xuICAgICAgICBlcnJvci5oYXNoID0gaGFzaDtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfSxcbiAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2UoaW5wdXQpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcywgc3RhY2sgPSBbMF0sIHRzdGFjayA9IFtdLCB2c3RhY2sgPSBbbnVsbF0sIGxzdGFjayA9IFtdLCB0YWJsZSA9IHRoaXMudGFibGUsIHl5dGV4dCA9IFwiXCIsIHl5bGluZW5vID0gMCwgeXlsZW5nID0gMCwgVEVSUk9SID0gMiwgRU9GID0gMTtcbiAgICAgIHZhciBhcmdzID0gbHN0YWNrLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgIHZhciBsZXhlcjIgPSBPYmplY3QuY3JlYXRlKHRoaXMubGV4ZXIpO1xuICAgICAgdmFyIHNoYXJlZFN0YXRlID0geyB5eToge30gfTtcbiAgICAgIGZvciAodmFyIGsgaW4gdGhpcy55eSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMueXksIGspKSB7XG4gICAgICAgICAgc2hhcmVkU3RhdGUueXlba10gPSB0aGlzLnl5W2tdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXhlcjIuc2V0SW5wdXQoaW5wdXQsIHNoYXJlZFN0YXRlLnl5KTtcbiAgICAgIHNoYXJlZFN0YXRlLnl5LmxleGVyID0gbGV4ZXIyO1xuICAgICAgc2hhcmVkU3RhdGUueXkucGFyc2VyID0gdGhpcztcbiAgICAgIGlmICh0eXBlb2YgbGV4ZXIyLnl5bGxvYyA9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGxleGVyMi55eWxsb2MgPSB7fTtcbiAgICAgIH1cbiAgICAgIHZhciB5eWxvYyA9IGxleGVyMi55eWxsb2M7XG4gICAgICBsc3RhY2sucHVzaCh5eWxvYyk7XG4gICAgICB2YXIgcmFuZ2VzID0gbGV4ZXIyLm9wdGlvbnMgJiYgbGV4ZXIyLm9wdGlvbnMucmFuZ2VzO1xuICAgICAgaWYgKHR5cGVvZiBzaGFyZWRTdGF0ZS55eS5wYXJzZUVycm9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhpcy5wYXJzZUVycm9yID0gc2hhcmVkU3RhdGUueXkucGFyc2VFcnJvcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucGFyc2VFcnJvciA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5wYXJzZUVycm9yO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gbGV4KCkge1xuICAgICAgICB2YXIgdG9rZW47XG4gICAgICAgIHRva2VuID0gdHN0YWNrLnBvcCgpIHx8IGxleGVyMi5sZXgoKSB8fCBFT0Y7XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICBpZiAodG9rZW4gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgdHN0YWNrID0gdG9rZW47XG4gICAgICAgICAgICB0b2tlbiA9IHRzdGFjay5wb3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdG9rZW4gPSBzZWxmLnN5bWJvbHNfW3Rva2VuXSB8fCB0b2tlbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICB9XG4gICAgICB2YXIgc3ltYm9sLCBzdGF0ZSwgYWN0aW9uLCByLCB5eXZhbCA9IHt9LCBwLCBsZW4sIG5ld1N0YXRlLCBleHBlY3RlZDtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHN0YXRlID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgIGlmICh0aGlzLmRlZmF1bHRBY3Rpb25zW3N0YXRlXSkge1xuICAgICAgICAgIGFjdGlvbiA9IHRoaXMuZGVmYXVsdEFjdGlvbnNbc3RhdGVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChzeW1ib2wgPT09IG51bGwgfHwgdHlwZW9mIHN5bWJvbCA9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBzeW1ib2wgPSBsZXgoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYWN0aW9uID0gdGFibGVbc3RhdGVdICYmIHRhYmxlW3N0YXRlXVtzeW1ib2xdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgYWN0aW9uID09PSBcInVuZGVmaW5lZFwiIHx8ICFhY3Rpb24ubGVuZ3RoIHx8ICFhY3Rpb25bMF0pIHtcbiAgICAgICAgICB2YXIgZXJyU3RyID0gXCJcIjtcbiAgICAgICAgICBleHBlY3RlZCA9IFtdO1xuICAgICAgICAgIGZvciAocCBpbiB0YWJsZVtzdGF0ZV0pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRlcm1pbmFsc19bcF0gJiYgcCA+IFRFUlJPUikge1xuICAgICAgICAgICAgICBleHBlY3RlZC5wdXNoKFwiJ1wiICsgdGhpcy50ZXJtaW5hbHNfW3BdICsgXCInXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobGV4ZXIyLnNob3dQb3NpdGlvbikge1xuICAgICAgICAgICAgZXJyU3RyID0gXCJQYXJzZSBlcnJvciBvbiBsaW5lIFwiICsgKHl5bGluZW5vICsgMSkgKyBcIjpcXG5cIiArIGxleGVyMi5zaG93UG9zaXRpb24oKSArIFwiXFxuRXhwZWN0aW5nIFwiICsgZXhwZWN0ZWQuam9pbihcIiwgXCIpICsgXCIsIGdvdCAnXCIgKyAodGhpcy50ZXJtaW5hbHNfW3N5bWJvbF0gfHwgc3ltYm9sKSArIFwiJ1wiO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJTdHIgPSBcIlBhcnNlIGVycm9yIG9uIGxpbmUgXCIgKyAoeXlsaW5lbm8gKyAxKSArIFwiOiBVbmV4cGVjdGVkIFwiICsgKHN5bWJvbCA9PSBFT0YgPyBcImVuZCBvZiBpbnB1dFwiIDogXCInXCIgKyAodGhpcy50ZXJtaW5hbHNfW3N5bWJvbF0gfHwgc3ltYm9sKSArIFwiJ1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5wYXJzZUVycm9yKGVyclN0ciwge1xuICAgICAgICAgICAgdGV4dDogbGV4ZXIyLm1hdGNoLFxuICAgICAgICAgICAgdG9rZW46IHRoaXMudGVybWluYWxzX1tzeW1ib2xdIHx8IHN5bWJvbCxcbiAgICAgICAgICAgIGxpbmU6IGxleGVyMi55eWxpbmVubyxcbiAgICAgICAgICAgIGxvYzogeXlsb2MsXG4gICAgICAgICAgICBleHBlY3RlZFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhY3Rpb25bMF0gaW5zdGFuY2VvZiBBcnJheSAmJiBhY3Rpb24ubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhcnNlIEVycm9yOiBtdWx0aXBsZSBhY3Rpb25zIHBvc3NpYmxlIGF0IHN0YXRlOiBcIiArIHN0YXRlICsgXCIsIHRva2VuOiBcIiArIHN5bWJvbCk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChhY3Rpb25bMF0pIHtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBzdGFjay5wdXNoKHN5bWJvbCk7XG4gICAgICAgICAgICB2c3RhY2sucHVzaChsZXhlcjIueXl0ZXh0KTtcbiAgICAgICAgICAgIGxzdGFjay5wdXNoKGxleGVyMi55eWxsb2MpO1xuICAgICAgICAgICAgc3RhY2sucHVzaChhY3Rpb25bMV0pO1xuICAgICAgICAgICAgc3ltYm9sID0gbnVsbDtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgeXlsZW5nID0gbGV4ZXIyLnl5bGVuZztcbiAgICAgICAgICAgICAgeXl0ZXh0ID0gbGV4ZXIyLnl5dGV4dDtcbiAgICAgICAgICAgICAgeXlsaW5lbm8gPSBsZXhlcjIueXlsaW5lbm87XG4gICAgICAgICAgICAgIHl5bG9jID0gbGV4ZXIyLnl5bGxvYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGxlbiA9IHRoaXMucHJvZHVjdGlvbnNfW2FjdGlvblsxXV1bMV07XG4gICAgICAgICAgICB5eXZhbC4kID0gdnN0YWNrW3ZzdGFjay5sZW5ndGggLSBsZW5dO1xuICAgICAgICAgICAgeXl2YWwuXyQgPSB7XG4gICAgICAgICAgICAgIGZpcnN0X2xpbmU6IGxzdGFja1tsc3RhY2subGVuZ3RoIC0gKGxlbiB8fCAxKV0uZmlyc3RfbGluZSxcbiAgICAgICAgICAgICAgbGFzdF9saW5lOiBsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIDFdLmxhc3RfbGluZSxcbiAgICAgICAgICAgICAgZmlyc3RfY29sdW1uOiBsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIChsZW4gfHwgMSldLmZpcnN0X2NvbHVtbixcbiAgICAgICAgICAgICAgbGFzdF9jb2x1bW46IGxzdGFja1tsc3RhY2subGVuZ3RoIC0gMV0ubGFzdF9jb2x1bW5cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAocmFuZ2VzKSB7XG4gICAgICAgICAgICAgIHl5dmFsLl8kLnJhbmdlID0gW1xuICAgICAgICAgICAgICAgIGxzdGFja1tsc3RhY2subGVuZ3RoIC0gKGxlbiB8fCAxKV0ucmFuZ2VbMF0sXG4gICAgICAgICAgICAgICAgbHN0YWNrW2xzdGFjay5sZW5ndGggLSAxXS5yYW5nZVsxXVxuICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgciA9IHRoaXMucGVyZm9ybUFjdGlvbi5hcHBseSh5eXZhbCwgW1xuICAgICAgICAgICAgICB5eXRleHQsXG4gICAgICAgICAgICAgIHl5bGVuZyxcbiAgICAgICAgICAgICAgeXlsaW5lbm8sXG4gICAgICAgICAgICAgIHNoYXJlZFN0YXRlLnl5LFxuICAgICAgICAgICAgICBhY3Rpb25bMV0sXG4gICAgICAgICAgICAgIHZzdGFjayxcbiAgICAgICAgICAgICAgbHN0YWNrXG4gICAgICAgICAgICBdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGVuKSB7XG4gICAgICAgICAgICAgIHN0YWNrID0gc3RhY2suc2xpY2UoMCwgLTEgKiBsZW4gKiAyKTtcbiAgICAgICAgICAgICAgdnN0YWNrID0gdnN0YWNrLnNsaWNlKDAsIC0xICogbGVuKTtcbiAgICAgICAgICAgICAgbHN0YWNrID0gbHN0YWNrLnNsaWNlKDAsIC0xICogbGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YWNrLnB1c2godGhpcy5wcm9kdWN0aW9uc19bYWN0aW9uWzFdXVswXSk7XG4gICAgICAgICAgICB2c3RhY2sucHVzaCh5eXZhbC4kKTtcbiAgICAgICAgICAgIGxzdGFjay5wdXNoKHl5dmFsLl8kKTtcbiAgICAgICAgICAgIG5ld1N0YXRlID0gdGFibGVbc3RhY2tbc3RhY2subGVuZ3RoIC0gMl1dW3N0YWNrW3N0YWNrLmxlbmd0aCAtIDFdXTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2gobmV3U3RhdGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfTtcbiAgdmFyIGxleGVyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGxleGVyMiA9IHtcbiAgICAgIEVPRjogMSxcbiAgICAgIHBhcnNlRXJyb3I6IGZ1bmN0aW9uIHBhcnNlRXJyb3IyKHN0ciwgaGFzaCkge1xuICAgICAgICBpZiAodGhpcy55eS5wYXJzZXIpIHtcbiAgICAgICAgICB0aGlzLnl5LnBhcnNlci5wYXJzZUVycm9yKHN0ciwgaGFzaCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHN0cik7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyByZXNldHMgdGhlIGxleGVyLCBzZXRzIG5ldyBpbnB1dFxuICAgICAgc2V0SW5wdXQ6IGZ1bmN0aW9uKGlucHV0LCB5eSkge1xuICAgICAgICB0aGlzLnl5ID0geXkgfHwgdGhpcy55eSB8fCB7fTtcbiAgICAgICAgdGhpcy5faW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5fbW9yZSA9IHRoaXMuX2JhY2t0cmFjayA9IHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnl5bGluZW5vID0gdGhpcy55eWxlbmcgPSAwO1xuICAgICAgICB0aGlzLnl5dGV4dCA9IHRoaXMubWF0Y2hlZCA9IHRoaXMubWF0Y2ggPSBcIlwiO1xuICAgICAgICB0aGlzLmNvbmRpdGlvblN0YWNrID0gW1wiSU5JVElBTFwiXTtcbiAgICAgICAgdGhpcy55eWxsb2MgPSB7XG4gICAgICAgICAgZmlyc3RfbGluZTogMSxcbiAgICAgICAgICBmaXJzdF9jb2x1bW46IDAsXG4gICAgICAgICAgbGFzdF9saW5lOiAxLFxuICAgICAgICAgIGxhc3RfY29sdW1uOiAwXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKSB7XG4gICAgICAgICAgdGhpcy55eWxsb2MucmFuZ2UgPSBbMCwgMF07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vZmZzZXQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICAvLyBjb25zdW1lcyBhbmQgcmV0dXJucyBvbmUgY2hhciBmcm9tIHRoZSBpbnB1dFxuICAgICAgaW5wdXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY2ggPSB0aGlzLl9pbnB1dFswXTtcbiAgICAgICAgdGhpcy55eXRleHQgKz0gY2g7XG4gICAgICAgIHRoaXMueXlsZW5nKys7XG4gICAgICAgIHRoaXMub2Zmc2V0Kys7XG4gICAgICAgIHRoaXMubWF0Y2ggKz0gY2g7XG4gICAgICAgIHRoaXMubWF0Y2hlZCArPSBjaDtcbiAgICAgICAgdmFyIGxpbmVzID0gY2gubWF0Y2goLyg/Olxcclxcbj98XFxuKS4qL2cpO1xuICAgICAgICBpZiAobGluZXMpIHtcbiAgICAgICAgICB0aGlzLnl5bGluZW5vKys7XG4gICAgICAgICAgdGhpcy55eWxsb2MubGFzdF9saW5lKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy55eWxsb2MubGFzdF9jb2x1bW4rKztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJhbmdlcykge1xuICAgICAgICAgIHRoaXMueXlsbG9jLnJhbmdlWzFdKys7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faW5wdXQgPSB0aGlzLl9pbnB1dC5zbGljZSgxKTtcbiAgICAgICAgcmV0dXJuIGNoO1xuICAgICAgfSxcbiAgICAgIC8vIHVuc2hpZnRzIG9uZSBjaGFyIChvciBhIHN0cmluZykgaW50byB0aGUgaW5wdXRcbiAgICAgIHVucHV0OiBmdW5jdGlvbihjaCkge1xuICAgICAgICB2YXIgbGVuID0gY2gubGVuZ3RoO1xuICAgICAgICB2YXIgbGluZXMgPSBjaC5zcGxpdCgvKD86XFxyXFxuP3xcXG4pL2cpO1xuICAgICAgICB0aGlzLl9pbnB1dCA9IGNoICsgdGhpcy5faW5wdXQ7XG4gICAgICAgIHRoaXMueXl0ZXh0ID0gdGhpcy55eXRleHQuc3Vic3RyKDAsIHRoaXMueXl0ZXh0Lmxlbmd0aCAtIGxlbik7XG4gICAgICAgIHRoaXMub2Zmc2V0IC09IGxlbjtcbiAgICAgICAgdmFyIG9sZExpbmVzID0gdGhpcy5tYXRjaC5zcGxpdCgvKD86XFxyXFxuP3xcXG4pL2cpO1xuICAgICAgICB0aGlzLm1hdGNoID0gdGhpcy5tYXRjaC5zdWJzdHIoMCwgdGhpcy5tYXRjaC5sZW5ndGggLSAxKTtcbiAgICAgICAgdGhpcy5tYXRjaGVkID0gdGhpcy5tYXRjaGVkLnN1YnN0cigwLCB0aGlzLm1hdGNoZWQubGVuZ3RoIC0gMSk7XG4gICAgICAgIGlmIChsaW5lcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgdGhpcy55eWxpbmVubyAtPSBsaW5lcy5sZW5ndGggLSAxO1xuICAgICAgICB9XG4gICAgICAgIHZhciByID0gdGhpcy55eWxsb2MucmFuZ2U7XG4gICAgICAgIHRoaXMueXlsbG9jID0ge1xuICAgICAgICAgIGZpcnN0X2xpbmU6IHRoaXMueXlsbG9jLmZpcnN0X2xpbmUsXG4gICAgICAgICAgbGFzdF9saW5lOiB0aGlzLnl5bGluZW5vICsgMSxcbiAgICAgICAgICBmaXJzdF9jb2x1bW46IHRoaXMueXlsbG9jLmZpcnN0X2NvbHVtbixcbiAgICAgICAgICBsYXN0X2NvbHVtbjogbGluZXMgPyAobGluZXMubGVuZ3RoID09PSBvbGRMaW5lcy5sZW5ndGggPyB0aGlzLnl5bGxvYy5maXJzdF9jb2x1bW4gOiAwKSArIG9sZExpbmVzW29sZExpbmVzLmxlbmd0aCAtIGxpbmVzLmxlbmd0aF0ubGVuZ3RoIC0gbGluZXNbMF0ubGVuZ3RoIDogdGhpcy55eWxsb2MuZmlyc3RfY29sdW1uIC0gbGVuXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKSB7XG4gICAgICAgICAgdGhpcy55eWxsb2MucmFuZ2UgPSBbclswXSwgclswXSArIHRoaXMueXlsZW5nIC0gbGVuXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnl5bGVuZyA9IHRoaXMueXl0ZXh0Lmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgLy8gV2hlbiBjYWxsZWQgZnJvbSBhY3Rpb24sIGNhY2hlcyBtYXRjaGVkIHRleHQgYW5kIGFwcGVuZHMgaXQgb24gbmV4dCBhY3Rpb25cbiAgICAgIG1vcmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9tb3JlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgLy8gV2hlbiBjYWxsZWQgZnJvbSBhY3Rpb24sIHNpZ25hbHMgdGhlIGxleGVyIHRoYXQgdGhpcyBydWxlIGZhaWxzIHRvIG1hdGNoIHRoZSBpbnB1dCwgc28gdGhlIG5leHQgbWF0Y2hpbmcgcnVsZSAocmVnZXgpIHNob3VsZCBiZSB0ZXN0ZWQgaW5zdGVhZC5cbiAgICAgIHJlamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYmFja3RyYWNrX2xleGVyKSB7XG4gICAgICAgICAgdGhpcy5fYmFja3RyYWNrID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUVycm9yKFwiTGV4aWNhbCBlcnJvciBvbiBsaW5lIFwiICsgKHRoaXMueXlsaW5lbm8gKyAxKSArIFwiLiBZb3UgY2FuIG9ubHkgaW52b2tlIHJlamVjdCgpIGluIHRoZSBsZXhlciB3aGVuIHRoZSBsZXhlciBpcyBvZiB0aGUgYmFja3RyYWNraW5nIHBlcnN1YXNpb24gKG9wdGlvbnMuYmFja3RyYWNrX2xleGVyID0gdHJ1ZSkuXFxuXCIgKyB0aGlzLnNob3dQb3NpdGlvbigpLCB7XG4gICAgICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICAgICAgdG9rZW46IG51bGwsXG4gICAgICAgICAgICBsaW5lOiB0aGlzLnl5bGluZW5vXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgLy8gcmV0YWluIGZpcnN0IG4gY2hhcmFjdGVycyBvZiB0aGUgbWF0Y2hcbiAgICAgIGxlc3M6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgdGhpcy51bnB1dCh0aGlzLm1hdGNoLnNsaWNlKG4pKTtcbiAgICAgIH0sXG4gICAgICAvLyBkaXNwbGF5cyBhbHJlYWR5IG1hdGNoZWQgaW5wdXQsIGkuZS4gZm9yIGVycm9yIG1lc3NhZ2VzXG4gICAgICBwYXN0SW5wdXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGFzdCA9IHRoaXMubWF0Y2hlZC5zdWJzdHIoMCwgdGhpcy5tYXRjaGVkLmxlbmd0aCAtIHRoaXMubWF0Y2gubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIChwYXN0Lmxlbmd0aCA+IDIwID8gXCIuLi5cIiA6IFwiXCIpICsgcGFzdC5zdWJzdHIoLTIwKS5yZXBsYWNlKC9cXG4vZywgXCJcIik7XG4gICAgICB9LFxuICAgICAgLy8gZGlzcGxheXMgdXBjb21pbmcgaW5wdXQsIGkuZS4gZm9yIGVycm9yIG1lc3NhZ2VzXG4gICAgICB1cGNvbWluZ0lucHV0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG5leHQgPSB0aGlzLm1hdGNoO1xuICAgICAgICBpZiAobmV4dC5sZW5ndGggPCAyMCkge1xuICAgICAgICAgIG5leHQgKz0gdGhpcy5faW5wdXQuc3Vic3RyKDAsIDIwIC0gbmV4dC5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAobmV4dC5zdWJzdHIoMCwgMjApICsgKG5leHQubGVuZ3RoID4gMjAgPyBcIi4uLlwiIDogXCJcIikpLnJlcGxhY2UoL1xcbi9nLCBcIlwiKTtcbiAgICAgIH0sXG4gICAgICAvLyBkaXNwbGF5cyB0aGUgY2hhcmFjdGVyIHBvc2l0aW9uIHdoZXJlIHRoZSBsZXhpbmcgZXJyb3Igb2NjdXJyZWQsIGkuZS4gZm9yIGVycm9yIG1lc3NhZ2VzXG4gICAgICBzaG93UG9zaXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcHJlID0gdGhpcy5wYXN0SW5wdXQoKTtcbiAgICAgICAgdmFyIGMgPSBuZXcgQXJyYXkocHJlLmxlbmd0aCArIDEpLmpvaW4oXCItXCIpO1xuICAgICAgICByZXR1cm4gcHJlICsgdGhpcy51cGNvbWluZ0lucHV0KCkgKyBcIlxcblwiICsgYyArIFwiXlwiO1xuICAgICAgfSxcbiAgICAgIC8vIHRlc3QgdGhlIGxleGVkIHRva2VuOiByZXR1cm4gRkFMU0Ugd2hlbiBub3QgYSBtYXRjaCwgb3RoZXJ3aXNlIHJldHVybiB0b2tlblxuICAgICAgdGVzdF9tYXRjaDogZnVuY3Rpb24obWF0Y2gsIGluZGV4ZWRfcnVsZSkge1xuICAgICAgICB2YXIgdG9rZW4sIGxpbmVzLCBiYWNrdXA7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYmFja3RyYWNrX2xleGVyKSB7XG4gICAgICAgICAgYmFja3VwID0ge1xuICAgICAgICAgICAgeXlsaW5lbm86IHRoaXMueXlsaW5lbm8sXG4gICAgICAgICAgICB5eWxsb2M6IHtcbiAgICAgICAgICAgICAgZmlyc3RfbGluZTogdGhpcy55eWxsb2MuZmlyc3RfbGluZSxcbiAgICAgICAgICAgICAgbGFzdF9saW5lOiB0aGlzLmxhc3RfbGluZSxcbiAgICAgICAgICAgICAgZmlyc3RfY29sdW1uOiB0aGlzLnl5bGxvYy5maXJzdF9jb2x1bW4sXG4gICAgICAgICAgICAgIGxhc3RfY29sdW1uOiB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHl5dGV4dDogdGhpcy55eXRleHQsXG4gICAgICAgICAgICBtYXRjaDogdGhpcy5tYXRjaCxcbiAgICAgICAgICAgIG1hdGNoZXM6IHRoaXMubWF0Y2hlcyxcbiAgICAgICAgICAgIG1hdGNoZWQ6IHRoaXMubWF0Y2hlZCxcbiAgICAgICAgICAgIHl5bGVuZzogdGhpcy55eWxlbmcsXG4gICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgX21vcmU6IHRoaXMuX21vcmUsXG4gICAgICAgICAgICBfaW5wdXQ6IHRoaXMuX2lucHV0LFxuICAgICAgICAgICAgeXk6IHRoaXMueXksXG4gICAgICAgICAgICBjb25kaXRpb25TdGFjazogdGhpcy5jb25kaXRpb25TdGFjay5zbGljZSgwKSxcbiAgICAgICAgICAgIGRvbmU6IHRoaXMuZG9uZVxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yYW5nZXMpIHtcbiAgICAgICAgICAgIGJhY2t1cC55eWxsb2MucmFuZ2UgPSB0aGlzLnl5bGxvYy5yYW5nZS5zbGljZSgwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGluZXMgPSBtYXRjaFswXS5tYXRjaCgvKD86XFxyXFxuP3xcXG4pLiovZyk7XG4gICAgICAgIGlmIChsaW5lcykge1xuICAgICAgICAgIHRoaXMueXlsaW5lbm8gKz0gbGluZXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMueXlsbG9jID0ge1xuICAgICAgICAgIGZpcnN0X2xpbmU6IHRoaXMueXlsbG9jLmxhc3RfbGluZSxcbiAgICAgICAgICBsYXN0X2xpbmU6IHRoaXMueXlsaW5lbm8gKyAxLFxuICAgICAgICAgIGZpcnN0X2NvbHVtbjogdGhpcy55eWxsb2MubGFzdF9jb2x1bW4sXG4gICAgICAgICAgbGFzdF9jb2x1bW46IGxpbmVzID8gbGluZXNbbGluZXMubGVuZ3RoIC0gMV0ubGVuZ3RoIC0gbGluZXNbbGluZXMubGVuZ3RoIC0gMV0ubWF0Y2goL1xccj9cXG4/LylbMF0ubGVuZ3RoIDogdGhpcy55eWxsb2MubGFzdF9jb2x1bW4gKyBtYXRjaFswXS5sZW5ndGhcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy55eXRleHQgKz0gbWF0Y2hbMF07XG4gICAgICAgIHRoaXMubWF0Y2ggKz0gbWF0Y2hbMF07XG4gICAgICAgIHRoaXMubWF0Y2hlcyA9IG1hdGNoO1xuICAgICAgICB0aGlzLnl5bGVuZyA9IHRoaXMueXl0ZXh0Lmxlbmd0aDtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yYW5nZXMpIHtcbiAgICAgICAgICB0aGlzLnl5bGxvYy5yYW5nZSA9IFt0aGlzLm9mZnNldCwgdGhpcy5vZmZzZXQgKz0gdGhpcy55eWxlbmddO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21vcmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fYmFja3RyYWNrID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lucHV0ID0gdGhpcy5faW5wdXQuc2xpY2UobWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgdGhpcy5tYXRjaGVkICs9IG1hdGNoWzBdO1xuICAgICAgICB0b2tlbiA9IHRoaXMucGVyZm9ybUFjdGlvbi5jYWxsKHRoaXMsIHRoaXMueXksIHRoaXMsIGluZGV4ZWRfcnVsZSwgdGhpcy5jb25kaXRpb25TdGFja1t0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgaWYgKHRoaXMuZG9uZSAmJiB0aGlzLl9pbnB1dCkge1xuICAgICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9iYWNrdHJhY2spIHtcbiAgICAgICAgICBmb3IgKHZhciBrIGluIGJhY2t1cCkge1xuICAgICAgICAgICAgdGhpc1trXSA9IGJhY2t1cFtrXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0sXG4gICAgICAvLyByZXR1cm4gbmV4dCBtYXRjaCBpbiBpbnB1dFxuICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5FT0Y7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9pbnB1dCkge1xuICAgICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRva2VuLCBtYXRjaCwgdGVtcE1hdGNoLCBpbmRleDtcbiAgICAgICAgaWYgKCF0aGlzLl9tb3JlKSB7XG4gICAgICAgICAgdGhpcy55eXRleHQgPSBcIlwiO1xuICAgICAgICAgIHRoaXMubWF0Y2ggPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciBydWxlcyA9IHRoaXMuX2N1cnJlbnRSdWxlcygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGVtcE1hdGNoID0gdGhpcy5faW5wdXQubWF0Y2godGhpcy5ydWxlc1tydWxlc1tpXV0pO1xuICAgICAgICAgIGlmICh0ZW1wTWF0Y2ggJiYgKCFtYXRjaCB8fCB0ZW1wTWF0Y2hbMF0ubGVuZ3RoID4gbWF0Y2hbMF0ubGVuZ3RoKSkge1xuICAgICAgICAgICAgbWF0Y2ggPSB0ZW1wTWF0Y2g7XG4gICAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJhY2t0cmFja19sZXhlcikge1xuICAgICAgICAgICAgICB0b2tlbiA9IHRoaXMudGVzdF9tYXRjaCh0ZW1wTWF0Y2gsIHJ1bGVzW2ldKTtcbiAgICAgICAgICAgICAgaWYgKHRva2VuICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9iYWNrdHJhY2spIHtcbiAgICAgICAgICAgICAgICBtYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5vcHRpb25zLmZsZXgpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgIHRva2VuID0gdGhpcy50ZXN0X21hdGNoKG1hdGNoLCBydWxlc1tpbmRleF0pO1xuICAgICAgICAgIGlmICh0b2tlbiAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9pbnB1dCA9PT0gXCJcIikge1xuICAgICAgICAgIHJldHVybiB0aGlzLkVPRjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUVycm9yKFwiTGV4aWNhbCBlcnJvciBvbiBsaW5lIFwiICsgKHRoaXMueXlsaW5lbm8gKyAxKSArIFwiLiBVbnJlY29nbml6ZWQgdGV4dC5cXG5cIiArIHRoaXMuc2hvd1Bvc2l0aW9uKCksIHtcbiAgICAgICAgICAgIHRleHQ6IFwiXCIsXG4gICAgICAgICAgICB0b2tlbjogbnVsbCxcbiAgICAgICAgICAgIGxpbmU6IHRoaXMueXlsaW5lbm9cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIHJldHVybiBuZXh0IG1hdGNoIHRoYXQgaGFzIGEgdG9rZW5cbiAgICAgIGxleDogZnVuY3Rpb24gbGV4KCkge1xuICAgICAgICB2YXIgciA9IHRoaXMubmV4dCgpO1xuICAgICAgICBpZiAocikge1xuICAgICAgICAgIHJldHVybiByO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLmxleCgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gYWN0aXZhdGVzIGEgbmV3IGxleGVyIGNvbmRpdGlvbiBzdGF0ZSAocHVzaGVzIHRoZSBuZXcgbGV4ZXIgY29uZGl0aW9uIHN0YXRlIG9udG8gdGhlIGNvbmRpdGlvbiBzdGFjaylcbiAgICAgIGJlZ2luOiBmdW5jdGlvbiBiZWdpbihjb25kaXRpb24pIHtcbiAgICAgICAgdGhpcy5jb25kaXRpb25TdGFjay5wdXNoKGNvbmRpdGlvbik7XG4gICAgICB9LFxuICAgICAgLy8gcG9wIHRoZSBwcmV2aW91c2x5IGFjdGl2ZSBsZXhlciBjb25kaXRpb24gc3RhdGUgb2ZmIHRoZSBjb25kaXRpb24gc3RhY2tcbiAgICAgIHBvcFN0YXRlOiBmdW5jdGlvbiBwb3BTdGF0ZSgpIHtcbiAgICAgICAgdmFyIG4gPSB0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChuID4gMCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvblN0YWNrLnBvcCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvblN0YWNrWzBdO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gcHJvZHVjZSB0aGUgbGV4ZXIgcnVsZSBzZXQgd2hpY2ggaXMgYWN0aXZlIGZvciB0aGUgY3VycmVudGx5IGFjdGl2ZSBsZXhlciBjb25kaXRpb24gc3RhdGVcbiAgICAgIF9jdXJyZW50UnVsZXM6IGZ1bmN0aW9uIF9jdXJyZW50UnVsZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAmJiB0aGlzLmNvbmRpdGlvblN0YWNrW3RoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25zW3RoaXMuY29uZGl0aW9uU3RhY2tbdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggLSAxXV0ucnVsZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uc1tcIklOSVRJQUxcIl0ucnVsZXM7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyByZXR1cm4gdGhlIGN1cnJlbnRseSBhY3RpdmUgbGV4ZXIgY29uZGl0aW9uIHN0YXRlOyB3aGVuIGFuIGluZGV4IGFyZ3VtZW50IGlzIHByb3ZpZGVkIGl0IHByb2R1Y2VzIHRoZSBOLXRoIHByZXZpb3VzIGNvbmRpdGlvbiBzdGF0ZSwgaWYgYXZhaWxhYmxlXG4gICAgICB0b3BTdGF0ZTogZnVuY3Rpb24gdG9wU3RhdGUobikge1xuICAgICAgICBuID0gdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggLSAxIC0gTWF0aC5hYnMobiB8fCAwKTtcbiAgICAgICAgaWYgKG4gPj0gMCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvblN0YWNrW25dO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBcIklOSVRJQUxcIjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIGFsaWFzIGZvciBiZWdpbihjb25kaXRpb24pXG4gICAgICBwdXNoU3RhdGU6IGZ1bmN0aW9uIHB1c2hTdGF0ZShjb25kaXRpb24pIHtcbiAgICAgICAgdGhpcy5iZWdpbihjb25kaXRpb24pO1xuICAgICAgfSxcbiAgICAgIC8vIHJldHVybiB0aGUgbnVtYmVyIG9mIHN0YXRlcyBjdXJyZW50bHkgb24gdGhlIHN0YWNrXG4gICAgICBzdGF0ZVN0YWNrU2l6ZTogZnVuY3Rpb24gc3RhdGVTdGFja1NpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aDtcbiAgICAgIH0sXG4gICAgICBvcHRpb25zOiB7IFwiY2FzZS1pbnNlbnNpdGl2ZVwiOiB0cnVlIH0sXG4gICAgICBwZXJmb3JtQWN0aW9uOiBmdW5jdGlvbiBhbm9ueW1vdXMoeXksIHl5XywgJGF2b2lkaW5nX25hbWVfY29sbGlzaW9ucywgWVlfU1RBUlQpIHtcbiAgICAgICAgc3dpdGNoICgkYXZvaWRpbmdfbmFtZV9jb2xsaXNpb25zKSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgeXkuZ2V0TG9nZ2VyKCkudHJhY2UoXCJGb3VuZCBjb21tZW50XCIsIHl5Xy55eXRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIDY7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcmV0dXJuIDg7XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgdGhpcy5iZWdpbihcIkNMQVNTXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgdGhpcy5wb3BTdGF0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIDE2O1xuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHRoaXMucG9wU3RhdGUoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHl5LmdldExvZ2dlcigpLnRyYWNlKFwiQmVnaW4gaWNvblwiKTtcbiAgICAgICAgICAgIHRoaXMuYmVnaW4oXCJJQ09OXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgeXkuZ2V0TG9nZ2VyKCkudHJhY2UoXCJTUEFDRUxJTkVcIik7XG4gICAgICAgICAgICByZXR1cm4gNjtcbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICByZXR1cm4gNztcbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICByZXR1cm4gMTU7XG4gICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgeXkuZ2V0TG9nZ2VyKCkudHJhY2UoXCJlbmQgaWNvblwiKTtcbiAgICAgICAgICAgIHRoaXMucG9wU3RhdGUoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICB5eS5nZXRMb2dnZXIoKS50cmFjZShcIkV4cGxvZGluZyBub2RlXCIpO1xuICAgICAgICAgICAgdGhpcy5iZWdpbihcIk5PREVcIik7XG4gICAgICAgICAgICByZXR1cm4gMTk7XG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIHl5LmdldExvZ2dlcigpLnRyYWNlKFwiQ2xvdWRcIik7XG4gICAgICAgICAgICB0aGlzLmJlZ2luKFwiTk9ERVwiKTtcbiAgICAgICAgICAgIHJldHVybiAxOTtcbiAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgeXkuZ2V0TG9nZ2VyKCkudHJhY2UoXCJFeHBsb3Npb24gQmFuZ1wiKTtcbiAgICAgICAgICAgIHRoaXMuYmVnaW4oXCJOT0RFXCIpO1xuICAgICAgICAgICAgcmV0dXJuIDE5O1xuICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICB5eS5nZXRMb2dnZXIoKS50cmFjZShcIkNsb3VkIEJhbmdcIik7XG4gICAgICAgICAgICB0aGlzLmJlZ2luKFwiTk9ERVwiKTtcbiAgICAgICAgICAgIHJldHVybiAxOTtcbiAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgdGhpcy5iZWdpbihcIk5PREVcIik7XG4gICAgICAgICAgICByZXR1cm4gMTk7XG4gICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgIHRoaXMuYmVnaW4oXCJOT0RFXCIpO1xuICAgICAgICAgICAgcmV0dXJuIDE5O1xuICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICB0aGlzLmJlZ2luKFwiTk9ERVwiKTtcbiAgICAgICAgICAgIHJldHVybiAxOTtcbiAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgdGhpcy5iZWdpbihcIk5PREVcIik7XG4gICAgICAgICAgICByZXR1cm4gMTk7XG4gICAgICAgICAgY2FzZSAxODpcbiAgICAgICAgICAgIHJldHVybiAxMztcbiAgICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgICAgcmV0dXJuIDIyO1xuICAgICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgICByZXR1cm4gMTE7XG4gICAgICAgICAgY2FzZSAyMTpcbiAgICAgICAgICAgIHRoaXMuYmVnaW4oXCJOU1RSMlwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgICByZXR1cm4gXCJOT0RFX0RFU0NSXCI7XG4gICAgICAgICAgY2FzZSAyMzpcbiAgICAgICAgICAgIHRoaXMucG9wU3RhdGUoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgICB5eS5nZXRMb2dnZXIoKS50cmFjZShcIlN0YXJ0aW5nIE5TVFJcIik7XG4gICAgICAgICAgICB0aGlzLmJlZ2luKFwiTlNUUlwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjU6XG4gICAgICAgICAgICB5eS5nZXRMb2dnZXIoKS50cmFjZShcImRlc2NyaXB0aW9uOlwiLCB5eV8ueXl0ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBcIk5PREVfREVTQ1JcIjtcbiAgICAgICAgICBjYXNlIDI2OlxuICAgICAgICAgICAgdGhpcy5wb3BTdGF0ZSgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICAgIHRoaXMucG9wU3RhdGUoKTtcbiAgICAgICAgICAgIHl5LmdldExvZ2dlcigpLnRyYWNlKFwibm9kZSBlbmQgKSlcIik7XG4gICAgICAgICAgICByZXR1cm4gXCJOT0RFX0RFTkRcIjtcbiAgICAgICAgICBjYXNlIDI4OlxuICAgICAgICAgICAgdGhpcy5wb3BTdGF0ZSgpO1xuICAgICAgICAgICAgeXkuZ2V0TG9nZ2VyKCkudHJhY2UoXCJub2RlIGVuZCApXCIpO1xuICAgICAgICAgICAgcmV0dXJuIFwiTk9ERV9ERU5EXCI7XG4gICAgICAgICAgY2FzZSAyOTpcbiAgICAgICAgICAgIHRoaXMucG9wU3RhdGUoKTtcbiAgICAgICAgICAgIHl5LmdldExvZ2dlcigpLnRyYWNlKFwibm9kZSBlbmQgLi4uXCIsIHl5Xy55eXRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIFwiTk9ERV9ERU5EXCI7XG4gICAgICAgICAgY2FzZSAzMDpcbiAgICAgICAgICAgIHRoaXMucG9wU3RhdGUoKTtcbiAgICAgICAgICAgIHl5LmdldExvZ2dlcigpLnRyYWNlKFwibm9kZSBlbmQgKChcIik7XG4gICAgICAgICAgICByZXR1cm4gXCJOT0RFX0RFTkRcIjtcbiAgICAgICAgICBjYXNlIDMxOlxuICAgICAgICAgICAgdGhpcy5wb3BTdGF0ZSgpO1xuICAgICAgICAgICAgeXkuZ2V0TG9nZ2VyKCkudHJhY2UoXCJub2RlIGVuZCAoLVwiKTtcbiAgICAgICAgICAgIHJldHVybiBcIk5PREVfREVORFwiO1xuICAgICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgICB0aGlzLnBvcFN0YXRlKCk7XG4gICAgICAgICAgICB5eS5nZXRMb2dnZXIoKS50cmFjZShcIm5vZGUgZW5kICgtXCIpO1xuICAgICAgICAgICAgcmV0dXJuIFwiTk9ERV9ERU5EXCI7XG4gICAgICAgICAgY2FzZSAzMzpcbiAgICAgICAgICAgIHRoaXMucG9wU3RhdGUoKTtcbiAgICAgICAgICAgIHl5LmdldExvZ2dlcigpLnRyYWNlKFwibm9kZSBlbmQgKChcIik7XG4gICAgICAgICAgICByZXR1cm4gXCJOT0RFX0RFTkRcIjtcbiAgICAgICAgICBjYXNlIDM0OlxuICAgICAgICAgICAgdGhpcy5wb3BTdGF0ZSgpO1xuICAgICAgICAgICAgeXkuZ2V0TG9nZ2VyKCkudHJhY2UoXCJub2RlIGVuZCAoKFwiKTtcbiAgICAgICAgICAgIHJldHVybiBcIk5PREVfREVORFwiO1xuICAgICAgICAgIGNhc2UgMzU6XG4gICAgICAgICAgICB5eS5nZXRMb2dnZXIoKS50cmFjZShcIkxvbmcgZGVzY3JpcHRpb246XCIsIHl5Xy55eXRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIDIwO1xuICAgICAgICAgIGNhc2UgMzY6XG4gICAgICAgICAgICB5eS5nZXRMb2dnZXIoKS50cmFjZShcIkxvbmcgZGVzY3JpcHRpb246XCIsIHl5Xy55eXRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIDIwO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcnVsZXM6IFsvXig/OlxccyolJS4qKS9pLCAvXig/Om1pbmRtYXBcXGIpL2ksIC9eKD86Ojo6KS9pLCAvXig/Oi4rKS9pLCAvXig/OlxcbikvaSwgL14oPzo6Omljb25cXCgpL2ksIC9eKD86W1xcc10rW1xcbl0pL2ksIC9eKD86W1xcbl0rKS9pLCAvXig/OlteXFwpXSspL2ksIC9eKD86XFwpKS9pLCAvXig/Oi1cXCkpL2ksIC9eKD86XFwoLSkvaSwgL14oPzpcXClcXCkpL2ksIC9eKD86XFwpKS9pLCAvXig/OlxcKFxcKCkvaSwgL14oPzpcXHtcXHspL2ksIC9eKD86XFwoKS9pLCAvXig/OlxcWykvaSwgL14oPzpbXFxzXSspL2ksIC9eKD86W15cXChcXFtcXG5cXClcXHtcXH1dKykvaSwgL14oPzokKS9pLCAvXig/OltcIl1bYF0pL2ksIC9eKD86W15gXCJdKykvaSwgL14oPzpbYF1bXCJdKS9pLCAvXig/OltcIl0pL2ksIC9eKD86W15cIl0rKS9pLCAvXig/OltcIl0pL2ksIC9eKD86W1xcKV1cXCkpL2ksIC9eKD86W1xcKV0pL2ksIC9eKD86W1xcXV0pL2ksIC9eKD86XFx9XFx9KS9pLCAvXig/OlxcKC0pL2ksIC9eKD86LVxcKSkvaSwgL14oPzpcXChcXCgpL2ksIC9eKD86XFwoKS9pLCAvXig/OlteXFwpXFxdXFwoXFx9XSspL2ksIC9eKD86LisoPyFcXChcXCgpKS9pXSxcbiAgICAgIGNvbmRpdGlvbnM6IHsgXCJDTEFTU1wiOiB7IFwicnVsZXNcIjogWzMsIDRdLCBcImluY2x1c2l2ZVwiOiBmYWxzZSB9LCBcIklDT05cIjogeyBcInJ1bGVzXCI6IFs4LCA5XSwgXCJpbmNsdXNpdmVcIjogZmFsc2UgfSwgXCJOU1RSMlwiOiB7IFwicnVsZXNcIjogWzIyLCAyM10sIFwiaW5jbHVzaXZlXCI6IGZhbHNlIH0sIFwiTlNUUlwiOiB7IFwicnVsZXNcIjogWzI1LCAyNl0sIFwiaW5jbHVzaXZlXCI6IGZhbHNlIH0sIFwiTk9ERVwiOiB7IFwicnVsZXNcIjogWzIxLCAyNCwgMjcsIDI4LCAyOSwgMzAsIDMxLCAzMiwgMzMsIDM0LCAzNSwgMzZdLCBcImluY2x1c2l2ZVwiOiBmYWxzZSB9LCBcIklOSVRJQUxcIjogeyBcInJ1bGVzXCI6IFswLCAxLCAyLCA1LCA2LCA3LCAxMCwgMTEsIDEyLCAxMywgMTQsIDE1LCAxNiwgMTcsIDE4LCAxOSwgMjBdLCBcImluY2x1c2l2ZVwiOiB0cnVlIH0gfVxuICAgIH07XG4gICAgcmV0dXJuIGxleGVyMjtcbiAgfSgpO1xuICBwYXJzZXIyLmxleGVyID0gbGV4ZXI7XG4gIGZ1bmN0aW9uIFBhcnNlcigpIHtcbiAgICB0aGlzLnl5ID0ge307XG4gIH1cbiAgUGFyc2VyLnByb3RvdHlwZSA9IHBhcnNlcjI7XG4gIHBhcnNlcjIuUGFyc2VyID0gUGFyc2VyO1xuICByZXR1cm4gbmV3IFBhcnNlcigpO1xufSgpO1xucGFyc2VyLnBhcnNlciA9IHBhcnNlcjtcbmNvbnN0IG1pbmRtYXBQYXJzZXIgPSBwYXJzZXI7XG5jb25zdCBzYW5pdGl6ZVRleHQgPSAodGV4dCkgPT4gc2FuaXRpemVUZXh0JDEodGV4dCwgZ2V0Q29uZmlnKCkpO1xubGV0IG5vZGVzID0gW107XG5sZXQgY250ID0gMDtcbmxldCBlbGVtZW50cyA9IHt9O1xuY29uc3QgY2xlYXIgPSAoKSA9PiB7XG4gIG5vZGVzID0gW107XG4gIGNudCA9IDA7XG4gIGVsZW1lbnRzID0ge307XG59O1xuY29uc3QgZ2V0UGFyZW50ID0gZnVuY3Rpb24obGV2ZWwpIHtcbiAgZm9yIChsZXQgaSA9IG5vZGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKG5vZGVzW2ldLmxldmVsIDwgbGV2ZWwpIHtcbiAgICAgIHJldHVybiBub2Rlc1tpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuY29uc3QgZ2V0TWluZG1hcCA9ICgpID0+IHtcbiAgcmV0dXJuIG5vZGVzLmxlbmd0aCA+IDAgPyBub2Rlc1swXSA6IG51bGw7XG59O1xuY29uc3QgYWRkTm9kZSA9IChsZXZlbCwgaWQsIGRlc2NyLCB0eXBlKSA9PiB7XG4gIGxvZy5pbmZvKFwiYWRkTm9kZVwiLCBsZXZlbCwgaWQsIGRlc2NyLCB0eXBlKTtcbiAgY29uc3QgY29uZiA9IGdldENvbmZpZygpO1xuICBjb25zdCBub2RlID0ge1xuICAgIGlkOiBjbnQrKyxcbiAgICBub2RlSWQ6IHNhbml0aXplVGV4dChpZCksXG4gICAgbGV2ZWwsXG4gICAgZGVzY3I6IHNhbml0aXplVGV4dChkZXNjciksXG4gICAgdHlwZSxcbiAgICBjaGlsZHJlbjogW10sXG4gICAgd2lkdGg6IGdldENvbmZpZygpLm1pbmRtYXAubWF4Tm9kZVdpZHRoXG4gIH07XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBub2RlVHlwZS5ST1VOREVEX1JFQ1Q6XG4gICAgICBub2RlLnBhZGRpbmcgPSAyICogY29uZi5taW5kbWFwLnBhZGRpbmc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIG5vZGVUeXBlLlJFQ1Q6XG4gICAgICBub2RlLnBhZGRpbmcgPSAyICogY29uZi5taW5kbWFwLnBhZGRpbmc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIG5vZGVUeXBlLkhFWEFHT046XG4gICAgICBub2RlLnBhZGRpbmcgPSAyICogY29uZi5taW5kbWFwLnBhZGRpbmc7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgbm9kZS5wYWRkaW5nID0gY29uZi5taW5kbWFwLnBhZGRpbmc7XG4gIH1cbiAgY29uc3QgcGFyZW50ID0gZ2V0UGFyZW50KGxldmVsKTtcbiAgaWYgKHBhcmVudCkge1xuICAgIHBhcmVudC5jaGlsZHJlbi5wdXNoKG5vZGUpO1xuICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKG5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgbm9kZXMucHVzaChub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAnVGhlcmUgY2FuIGJlIG9ubHkgb25lIHJvb3QuIE5vIHBhcmVudCBjb3VsZCBiZSBmb3VuZCBmb3IgKFwiJyArIG5vZGUuZGVzY3IgKyAnXCIpJ1xuICAgICAgKTtcbiAgICAgIGVycm9yLmhhc2ggPSB7XG4gICAgICAgIHRleHQ6IFwiYnJhbmNoIFwiICsgbmFtZSxcbiAgICAgICAgdG9rZW46IFwiYnJhbmNoIFwiICsgbmFtZSxcbiAgICAgICAgbGluZTogXCIxXCIsXG4gICAgICAgIGxvYzogeyBmaXJzdF9saW5lOiAxLCBsYXN0X2xpbmU6IDEsIGZpcnN0X2NvbHVtbjogMSwgbGFzdF9jb2x1bW46IDEgfSxcbiAgICAgICAgZXhwZWN0ZWQ6IFsnXCJjaGVja291dCAnICsgbmFtZSArICdcIiddXG4gICAgICB9O1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG59O1xuY29uc3Qgbm9kZVR5cGUgPSB7XG4gIERFRkFVTFQ6IDAsXG4gIE5PX0JPUkRFUjogMCxcbiAgUk9VTkRFRF9SRUNUOiAxLFxuICBSRUNUOiAyLFxuICBDSVJDTEU6IDMsXG4gIENMT1VEOiA0LFxuICBCQU5HOiA1LFxuICBIRVhBR09OOiA2XG59O1xuY29uc3QgZ2V0VHlwZSA9IChzdGFydFN0ciwgZW5kU3RyKSA9PiB7XG4gIGxvZy5kZWJ1ZyhcIkluIGdldCB0eXBlXCIsIHN0YXJ0U3RyLCBlbmRTdHIpO1xuICBzd2l0Y2ggKHN0YXJ0U3RyKSB7XG4gICAgY2FzZSBcIltcIjpcbiAgICAgIHJldHVybiBub2RlVHlwZS5SRUNUO1xuICAgIGNhc2UgXCIoXCI6XG4gICAgICByZXR1cm4gZW5kU3RyID09PSBcIilcIiA/IG5vZGVUeXBlLlJPVU5ERURfUkVDVCA6IG5vZGVUeXBlLkNMT1VEO1xuICAgIGNhc2UgXCIoKFwiOlxuICAgICAgcmV0dXJuIG5vZGVUeXBlLkNJUkNMRTtcbiAgICBjYXNlIFwiKVwiOlxuICAgICAgcmV0dXJuIG5vZGVUeXBlLkNMT1VEO1xuICAgIGNhc2UgXCIpKVwiOlxuICAgICAgcmV0dXJuIG5vZGVUeXBlLkJBTkc7XG4gICAgY2FzZSBcInt7XCI6XG4gICAgICByZXR1cm4gbm9kZVR5cGUuSEVYQUdPTjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG5vZGVUeXBlLkRFRkFVTFQ7XG4gIH1cbn07XG5jb25zdCBzZXRFbGVtZW50Rm9ySWQgPSAoaWQsIGVsZW1lbnQpID0+IHtcbiAgZWxlbWVudHNbaWRdID0gZWxlbWVudDtcbn07XG5jb25zdCBkZWNvcmF0ZU5vZGUgPSAoZGVjb3JhdGlvbikgPT4ge1xuICBjb25zdCBub2RlID0gbm9kZXNbbm9kZXMubGVuZ3RoIC0gMV07XG4gIGlmIChkZWNvcmF0aW9uICYmIGRlY29yYXRpb24uaWNvbikge1xuICAgIG5vZGUuaWNvbiA9IHNhbml0aXplVGV4dChkZWNvcmF0aW9uLmljb24pO1xuICB9XG4gIGlmIChkZWNvcmF0aW9uICYmIGRlY29yYXRpb24uY2xhc3MpIHtcbiAgICBub2RlLmNsYXNzID0gc2FuaXRpemVUZXh0KGRlY29yYXRpb24uY2xhc3MpO1xuICB9XG59O1xuY29uc3QgdHlwZTJTdHIgPSAodHlwZSkgPT4ge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIG5vZGVUeXBlLkRFRkFVTFQ6XG4gICAgICByZXR1cm4gXCJuby1ib3JkZXJcIjtcbiAgICBjYXNlIG5vZGVUeXBlLlJFQ1Q6XG4gICAgICByZXR1cm4gXCJyZWN0XCI7XG4gICAgY2FzZSBub2RlVHlwZS5ST1VOREVEX1JFQ1Q6XG4gICAgICByZXR1cm4gXCJyb3VuZGVkLXJlY3RcIjtcbiAgICBjYXNlIG5vZGVUeXBlLkNJUkNMRTpcbiAgICAgIHJldHVybiBcImNpcmNsZVwiO1xuICAgIGNhc2Ugbm9kZVR5cGUuQ0xPVUQ6XG4gICAgICByZXR1cm4gXCJjbG91ZFwiO1xuICAgIGNhc2Ugbm9kZVR5cGUuQkFORzpcbiAgICAgIHJldHVybiBcImJhbmdcIjtcbiAgICBjYXNlIG5vZGVUeXBlLkhFWEFHT046XG4gICAgICByZXR1cm4gXCJoZXhnb25cIjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFwibm8tYm9yZGVyXCI7XG4gIH1cbn07XG5sZXQgcGFyc2VFcnJvcjtcbmNvbnN0IHNldEVycm9ySGFuZGxlciA9IChoYW5kbGVyKSA9PiB7XG4gIHBhcnNlRXJyb3IgPSBoYW5kbGVyO1xufTtcbmNvbnN0IGdldExvZ2dlciA9ICgpID0+IGxvZztcbmNvbnN0IGdldE5vZGVCeUlkID0gKGlkKSA9PiBub2Rlc1tpZF07XG5jb25zdCBnZXRFbGVtZW50QnlJZCA9IChpZCkgPT4gZWxlbWVudHNbaWRdO1xuY29uc3QgbWluZG1hcERiID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoLyogQF9fUFVSRV9fICovIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgYWRkTm9kZSxcbiAgY2xlYXIsXG4gIGRlY29yYXRlTm9kZSxcbiAgZ2V0RWxlbWVudEJ5SWQsXG4gIGdldExvZ2dlcixcbiAgZ2V0TWluZG1hcCxcbiAgZ2V0Tm9kZUJ5SWQsXG4gIGdldFR5cGUsXG4gIG5vZGVUeXBlLFxuICBnZXQgcGFyc2VFcnJvcigpIHtcbiAgICByZXR1cm4gcGFyc2VFcnJvcjtcbiAgfSxcbiAgc2FuaXRpemVUZXh0LFxuICBzZXRFbGVtZW50Rm9ySWQsXG4gIHNldEVycm9ySGFuZGxlcixcbiAgdHlwZTJTdHJcbn0sIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KSk7XG5jb25zdCBNQVhfU0VDVElPTlMgPSAxMjtcbmNvbnN0IGRlZmF1bHRCa2cgPSBmdW5jdGlvbihlbGVtLCBub2RlLCBzZWN0aW9uKSB7XG4gIGNvbnN0IHJkID0gNTtcbiAgZWxlbS5hcHBlbmQoXCJwYXRoXCIpLmF0dHIoXCJpZFwiLCBcIm5vZGUtXCIgKyBub2RlLmlkKS5hdHRyKFwiY2xhc3NcIiwgXCJub2RlLWJrZyBub2RlLVwiICsgdHlwZTJTdHIobm9kZS50eXBlKSkuYXR0cihcbiAgICBcImRcIixcbiAgICBgTTAgJHtub2RlLmhlaWdodCAtIHJkfSB2JHstbm9kZS5oZWlnaHQgKyAyICogcmR9IHEwLC01IDUsLTUgaCR7bm9kZS53aWR0aCAtIDIgKiByZH0gcTUsMCA1LDUgdiR7bm9kZS5oZWlnaHQgLSByZH0gSDAgWmBcbiAgKTtcbiAgZWxlbS5hcHBlbmQoXCJsaW5lXCIpLmF0dHIoXCJjbGFzc1wiLCBcIm5vZGUtbGluZS1cIiArIHNlY3Rpb24pLmF0dHIoXCJ4MVwiLCAwKS5hdHRyKFwieTFcIiwgbm9kZS5oZWlnaHQpLmF0dHIoXCJ4MlwiLCBub2RlLndpZHRoKS5hdHRyKFwieTJcIiwgbm9kZS5oZWlnaHQpO1xufTtcbmNvbnN0IHJlY3RCa2cgPSBmdW5jdGlvbihlbGVtLCBub2RlKSB7XG4gIGVsZW0uYXBwZW5kKFwicmVjdFwiKS5hdHRyKFwiaWRcIiwgXCJub2RlLVwiICsgbm9kZS5pZCkuYXR0cihcImNsYXNzXCIsIFwibm9kZS1ia2cgbm9kZS1cIiArIHR5cGUyU3RyKG5vZGUudHlwZSkpLmF0dHIoXCJoZWlnaHRcIiwgbm9kZS5oZWlnaHQpLmF0dHIoXCJ3aWR0aFwiLCBub2RlLndpZHRoKTtcbn07XG5jb25zdCBjbG91ZEJrZyA9IGZ1bmN0aW9uKGVsZW0sIG5vZGUpIHtcbiAgY29uc3QgdyA9IG5vZGUud2lkdGg7XG4gIGNvbnN0IGggPSBub2RlLmhlaWdodDtcbiAgY29uc3QgcjEgPSAwLjE1ICogdztcbiAgY29uc3QgcjIgPSAwLjI1ICogdztcbiAgY29uc3QgcjMgPSAwLjM1ICogdztcbiAgY29uc3QgcjQgPSAwLjIgKiB3O1xuICBlbGVtLmFwcGVuZChcInBhdGhcIikuYXR0cihcImlkXCIsIFwibm9kZS1cIiArIG5vZGUuaWQpLmF0dHIoXCJjbGFzc1wiLCBcIm5vZGUtYmtnIG5vZGUtXCIgKyB0eXBlMlN0cihub2RlLnR5cGUpKS5hdHRyKFxuICAgIFwiZFwiLFxuICAgIGBNMCAwIGEke3IxfSwke3IxfSAwIDAsMSAke3cgKiAwLjI1fSwkey0xICogdyAqIDAuMX1cbiAgICAgIGEke3IzfSwke3IzfSAxIDAsMSAke3cgKiAwLjR9LCR7LTEgKiB3ICogMC4xfVxuICAgICAgYSR7cjJ9LCR7cjJ9IDEgMCwxICR7dyAqIDAuMzV9LCR7MSAqIHcgKiAwLjJ9XG5cbiAgICAgIGEke3IxfSwke3IxfSAxIDAsMSAke3cgKiAwLjE1fSwkezEgKiBoICogMC4zNX1cbiAgICAgIGEke3I0fSwke3I0fSAxIDAsMSAkey0xICogdyAqIDAuMTV9LCR7MSAqIGggKiAwLjY1fVxuXG4gICAgICBhJHtyMn0sJHtyMX0gMSAwLDEgJHstMSAqIHcgKiAwLjI1fSwke3cgKiAwLjE1fVxuICAgICAgYSR7cjN9LCR7cjN9IDEgMCwxICR7LTEgKiB3ICogMC41fSwkezB9XG4gICAgICBhJHtyMX0sJHtyMX0gMSAwLDEgJHstMSAqIHcgKiAwLjI1fSwkey0xICogdyAqIDAuMTV9XG5cbiAgICAgIGEke3IxfSwke3IxfSAxIDAsMSAkey0xICogdyAqIDAuMX0sJHstMSAqIGggKiAwLjM1fVxuICAgICAgYSR7cjR9LCR7cjR9IDEgMCwxICR7dyAqIDAuMX0sJHstMSAqIGggKiAwLjY1fVxuXG4gICAgSDAgVjAgWmBcbiAgKTtcbn07XG5jb25zdCBiYW5nQmtnID0gZnVuY3Rpb24oZWxlbSwgbm9kZSkge1xuICBjb25zdCB3ID0gbm9kZS53aWR0aDtcbiAgY29uc3QgaCA9IG5vZGUuaGVpZ2h0O1xuICBjb25zdCByID0gMC4xNSAqIHc7XG4gIGVsZW0uYXBwZW5kKFwicGF0aFwiKS5hdHRyKFwiaWRcIiwgXCJub2RlLVwiICsgbm9kZS5pZCkuYXR0cihcImNsYXNzXCIsIFwibm9kZS1ia2cgbm9kZS1cIiArIHR5cGUyU3RyKG5vZGUudHlwZSkpLmF0dHIoXG4gICAgXCJkXCIsXG4gICAgYE0wIDAgYSR7cn0sJHtyfSAxIDAsMCAke3cgKiAwLjI1fSwkey0xICogaCAqIDAuMX1cbiAgICAgIGEke3J9LCR7cn0gMSAwLDAgJHt3ICogMC4yNX0sJHswfVxuICAgICAgYSR7cn0sJHtyfSAxIDAsMCAke3cgKiAwLjI1fSwkezB9XG4gICAgICBhJHtyfSwke3J9IDEgMCwwICR7dyAqIDAuMjV9LCR7MSAqIGggKiAwLjF9XG5cbiAgICAgIGEke3J9LCR7cn0gMSAwLDAgJHt3ICogMC4xNX0sJHsxICogaCAqIDAuMzN9XG4gICAgICBhJHtyICogMC44fSwke3IgKiAwLjh9IDEgMCwwICR7MH0sJHsxICogaCAqIDAuMzR9XG4gICAgICBhJHtyfSwke3J9IDEgMCwwICR7LTEgKiB3ICogMC4xNX0sJHsxICogaCAqIDAuMzN9XG5cbiAgICAgIGEke3J9LCR7cn0gMSAwLDAgJHstMSAqIHcgKiAwLjI1fSwke2ggKiAwLjE1fVxuICAgICAgYSR7cn0sJHtyfSAxIDAsMCAkey0xICogdyAqIDAuMjV9LCR7MH1cbiAgICAgIGEke3J9LCR7cn0gMSAwLDAgJHstMSAqIHcgKiAwLjI1fSwkezB9XG4gICAgICBhJHtyfSwke3J9IDEgMCwwICR7LTEgKiB3ICogMC4yNX0sJHstMSAqIGggKiAwLjE1fVxuXG4gICAgICBhJHtyfSwke3J9IDEgMCwwICR7LTEgKiB3ICogMC4xfSwkey0xICogaCAqIDAuMzN9XG4gICAgICBhJHtyICogMC44fSwke3IgKiAwLjh9IDEgMCwwICR7MH0sJHstMSAqIGggKiAwLjM0fVxuICAgICAgYSR7cn0sJHtyfSAxIDAsMCAke3cgKiAwLjF9LCR7LTEgKiBoICogMC4zM31cblxuICAgIEgwIFYwIFpgXG4gICk7XG59O1xuY29uc3QgY2lyY2xlQmtnID0gZnVuY3Rpb24oZWxlbSwgbm9kZSkge1xuICBlbGVtLmFwcGVuZChcImNpcmNsZVwiKS5hdHRyKFwiaWRcIiwgXCJub2RlLVwiICsgbm9kZS5pZCkuYXR0cihcImNsYXNzXCIsIFwibm9kZS1ia2cgbm9kZS1cIiArIHR5cGUyU3RyKG5vZGUudHlwZSkpLmF0dHIoXCJyXCIsIG5vZGUud2lkdGggLyAyKTtcbn07XG5mdW5jdGlvbiBpbnNlcnRQb2x5Z29uU2hhcGUocGFyZW50LCB3LCBoLCBwb2ludHMsIG5vZGUpIHtcbiAgcmV0dXJuIHBhcmVudC5pbnNlcnQoXCJwb2x5Z29uXCIsIFwiOmZpcnN0LWNoaWxkXCIpLmF0dHIoXG4gICAgXCJwb2ludHNcIixcbiAgICBwb2ludHMubWFwKGZ1bmN0aW9uKGQpIHtcbiAgICAgIHJldHVybiBkLnggKyBcIixcIiArIGQueTtcbiAgICB9KS5qb2luKFwiIFwiKVxuICApLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyAobm9kZS53aWR0aCAtIHcpIC8gMiArIFwiLCBcIiArIGggKyBcIilcIik7XG59XG5jb25zdCBoZXhhZ29uQmtnID0gZnVuY3Rpb24oZWxlbSwgbm9kZSkge1xuICBjb25zdCBoID0gbm9kZS5oZWlnaHQ7XG4gIGNvbnN0IGYgPSA0O1xuICBjb25zdCBtID0gaCAvIGY7XG4gIGNvbnN0IHcgPSBub2RlLndpZHRoIC0gbm9kZS5wYWRkaW5nICsgMiAqIG07XG4gIGNvbnN0IHBvaW50cyA9IFtcbiAgICB7IHg6IG0sIHk6IDAgfSxcbiAgICB7IHg6IHcgLSBtLCB5OiAwIH0sXG4gICAgeyB4OiB3LCB5OiAtaCAvIDIgfSxcbiAgICB7IHg6IHcgLSBtLCB5OiAtaCB9LFxuICAgIHsgeDogbSwgeTogLWggfSxcbiAgICB7IHg6IDAsIHk6IC1oIC8gMiB9XG4gIF07XG4gIGluc2VydFBvbHlnb25TaGFwZShlbGVtLCB3LCBoLCBwb2ludHMsIG5vZGUpO1xufTtcbmNvbnN0IHJvdW5kZWRSZWN0QmtnID0gZnVuY3Rpb24oZWxlbSwgbm9kZSkge1xuICBlbGVtLmFwcGVuZChcInJlY3RcIikuYXR0cihcImlkXCIsIFwibm9kZS1cIiArIG5vZGUuaWQpLmF0dHIoXCJjbGFzc1wiLCBcIm5vZGUtYmtnIG5vZGUtXCIgKyB0eXBlMlN0cihub2RlLnR5cGUpKS5hdHRyKFwiaGVpZ2h0XCIsIG5vZGUuaGVpZ2h0KS5hdHRyKFwicnhcIiwgbm9kZS5wYWRkaW5nKS5hdHRyKFwicnlcIiwgbm9kZS5wYWRkaW5nKS5hdHRyKFwid2lkdGhcIiwgbm9kZS53aWR0aCk7XG59O1xuY29uc3QgZHJhd05vZGUgPSBmdW5jdGlvbihlbGVtLCBub2RlLCBmdWxsU2VjdGlvbiwgY29uZikge1xuICBjb25zdCBodG1sTGFiZWxzID0gY29uZi5odG1sTGFiZWxzO1xuICBjb25zdCBzZWN0aW9uID0gZnVsbFNlY3Rpb24gJSAoTUFYX1NFQ1RJT05TIC0gMSk7XG4gIGNvbnN0IG5vZGVFbGVtID0gZWxlbS5hcHBlbmQoXCJnXCIpO1xuICBub2RlLnNlY3Rpb24gPSBzZWN0aW9uO1xuICBsZXQgc2VjdGlvbkNsYXNzID0gXCJzZWN0aW9uLVwiICsgc2VjdGlvbjtcbiAgaWYgKHNlY3Rpb24gPCAwKSB7XG4gICAgc2VjdGlvbkNsYXNzICs9IFwiIHNlY3Rpb24tcm9vdFwiO1xuICB9XG4gIG5vZGVFbGVtLmF0dHIoXCJjbGFzc1wiLCAobm9kZS5jbGFzcyA/IG5vZGUuY2xhc3MgKyBcIiBcIiA6IFwiXCIpICsgXCJtaW5kbWFwLW5vZGUgXCIgKyBzZWN0aW9uQ2xhc3MpO1xuICBjb25zdCBia2dFbGVtID0gbm9kZUVsZW0uYXBwZW5kKFwiZ1wiKTtcbiAgY29uc3QgdGV4dEVsZW0gPSBub2RlRWxlbS5hcHBlbmQoXCJnXCIpO1xuICBjb25zdCBkZXNjcmlwdGlvbiA9IG5vZGUuZGVzY3IucmVwbGFjZSgvKDxiclxcLyo+KS9nLCBcIlxcblwiKTtcbiAgY3JlYXRlVGV4dCh0ZXh0RWxlbSwgZGVzY3JpcHRpb24sIHtcbiAgICB1c2VIdG1sTGFiZWxzOiBodG1sTGFiZWxzLFxuICAgIHdpZHRoOiBub2RlLndpZHRoLFxuICAgIGNsYXNzZXM6IFwibWluZG1hcC1ub2RlLWxhYmVsXCJcbiAgfSk7XG4gIGlmICghaHRtbExhYmVscykge1xuICAgIHRleHRFbGVtLmF0dHIoXCJkeVwiLCBcIjFlbVwiKS5hdHRyKFwiYWxpZ25tZW50LWJhc2VsaW5lXCIsIFwibWlkZGxlXCIpLmF0dHIoXCJkb21pbmFudC1iYXNlbGluZVwiLCBcIm1pZGRsZVwiKS5hdHRyKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIik7XG4gIH1cbiAgY29uc3QgYmJveCA9IHRleHRFbGVtLm5vZGUoKS5nZXRCQm94KCk7XG4gIGNvbnN0IGZvbnRTaXplID0gY29uZi5mb250U2l6ZS5yZXBsYWNlID8gY29uZi5mb250U2l6ZS5yZXBsYWNlKFwicHhcIiwgXCJcIikgOiBjb25mLmZvbnRTaXplO1xuICBub2RlLmhlaWdodCA9IGJib3guaGVpZ2h0ICsgZm9udFNpemUgKiAxLjEgKiAwLjUgKyBub2RlLnBhZGRpbmc7XG4gIG5vZGUud2lkdGggPSBiYm94LndpZHRoICsgMiAqIG5vZGUucGFkZGluZztcbiAgaWYgKG5vZGUuaWNvbikge1xuICAgIGlmIChub2RlLnR5cGUgPT09IG5vZGVUeXBlLkNJUkNMRSkge1xuICAgICAgbm9kZS5oZWlnaHQgKz0gNTA7XG4gICAgICBub2RlLndpZHRoICs9IDUwO1xuICAgICAgY29uc3QgaWNvbiA9IG5vZGVFbGVtLmFwcGVuZChcImZvcmVpZ25PYmplY3RcIikuYXR0cihcImhlaWdodFwiLCBcIjUwcHhcIikuYXR0cihcIndpZHRoXCIsIG5vZGUud2lkdGgpLmF0dHIoXCJzdHlsZVwiLCBcInRleHQtYWxpZ246IGNlbnRlcjtcIik7XG4gICAgICBpY29uLmFwcGVuZChcImRpdlwiKS5hdHRyKFwiY2xhc3NcIiwgXCJpY29uLWNvbnRhaW5lclwiKS5hcHBlbmQoXCJpXCIpLmF0dHIoXCJjbGFzc1wiLCBcIm5vZGUtaWNvbi1cIiArIHNlY3Rpb24gKyBcIiBcIiArIG5vZGUuaWNvbik7XG4gICAgICB0ZXh0RWxlbS5hdHRyKFxuICAgICAgICBcInRyYW5zZm9ybVwiLFxuICAgICAgICBcInRyYW5zbGF0ZShcIiArIG5vZGUud2lkdGggLyAyICsgXCIsIFwiICsgKG5vZGUuaGVpZ2h0IC8gMiAtIDEuNSAqIG5vZGUucGFkZGluZykgKyBcIilcIlxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS53aWR0aCArPSA1MDtcbiAgICAgIGNvbnN0IG9yZ0hlaWdodCA9IG5vZGUuaGVpZ2h0O1xuICAgICAgbm9kZS5oZWlnaHQgPSBNYXRoLm1heChvcmdIZWlnaHQsIDYwKTtcbiAgICAgIGNvbnN0IGhlaWdodERpZmYgPSBNYXRoLmFicyhub2RlLmhlaWdodCAtIG9yZ0hlaWdodCk7XG4gICAgICBjb25zdCBpY29uID0gbm9kZUVsZW0uYXBwZW5kKFwiZm9yZWlnbk9iamVjdFwiKS5hdHRyKFwid2lkdGhcIiwgXCI2MHB4XCIpLmF0dHIoXCJoZWlnaHRcIiwgbm9kZS5oZWlnaHQpLmF0dHIoXCJzdHlsZVwiLCBcInRleHQtYWxpZ246IGNlbnRlcjttYXJnaW4tdG9wOlwiICsgaGVpZ2h0RGlmZiAvIDIgKyBcInB4O1wiKTtcbiAgICAgIGljb24uYXBwZW5kKFwiZGl2XCIpLmF0dHIoXCJjbGFzc1wiLCBcImljb24tY29udGFpbmVyXCIpLmFwcGVuZChcImlcIikuYXR0cihcImNsYXNzXCIsIFwibm9kZS1pY29uLVwiICsgc2VjdGlvbiArIFwiIFwiICsgbm9kZS5pY29uKTtcbiAgICAgIHRleHRFbGVtLmF0dHIoXG4gICAgICAgIFwidHJhbnNmb3JtXCIsXG4gICAgICAgIFwidHJhbnNsYXRlKFwiICsgKDI1ICsgbm9kZS53aWR0aCAvIDIpICsgXCIsIFwiICsgKGhlaWdodERpZmYgLyAyICsgbm9kZS5wYWRkaW5nIC8gMikgKyBcIilcIlxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFodG1sTGFiZWxzKSB7XG4gICAgICBjb25zdCBkeCA9IG5vZGUud2lkdGggLyAyO1xuICAgICAgY29uc3QgZHkgPSBub2RlLnBhZGRpbmcgLyAyO1xuICAgICAgdGV4dEVsZW0uYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIGR4ICsgXCIsIFwiICsgZHkgKyBcIilcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGR4ID0gKG5vZGUud2lkdGggLSBiYm94LndpZHRoKSAvIDI7XG4gICAgICBjb25zdCBkeSA9IChub2RlLmhlaWdodCAtIGJib3guaGVpZ2h0KSAvIDI7XG4gICAgICB0ZXh0RWxlbS5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgZHggKyBcIiwgXCIgKyBkeSArIFwiKVwiKTtcbiAgICB9XG4gIH1cbiAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICBjYXNlIG5vZGVUeXBlLkRFRkFVTFQ6XG4gICAgICBkZWZhdWx0QmtnKGJrZ0VsZW0sIG5vZGUsIHNlY3Rpb24pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBub2RlVHlwZS5ST1VOREVEX1JFQ1Q6XG4gICAgICByb3VuZGVkUmVjdEJrZyhia2dFbGVtLCBub2RlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2Ugbm9kZVR5cGUuUkVDVDpcbiAgICAgIHJlY3RCa2coYmtnRWxlbSwgbm9kZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIG5vZGVUeXBlLkNJUkNMRTpcbiAgICAgIGJrZ0VsZW0uYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIG5vZGUud2lkdGggLyAyICsgXCIsIFwiICsgK25vZGUuaGVpZ2h0IC8gMiArIFwiKVwiKTtcbiAgICAgIGNpcmNsZUJrZyhia2dFbGVtLCBub2RlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2Ugbm9kZVR5cGUuQ0xPVUQ6XG4gICAgICBjbG91ZEJrZyhia2dFbGVtLCBub2RlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2Ugbm9kZVR5cGUuQkFORzpcbiAgICAgIGJhbmdCa2coYmtnRWxlbSwgbm9kZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIG5vZGVUeXBlLkhFWEFHT046XG4gICAgICBoZXhhZ29uQmtnKGJrZ0VsZW0sIG5vZGUpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgc2V0RWxlbWVudEZvcklkKG5vZGUuaWQsIG5vZGVFbGVtKTtcbiAgcmV0dXJuIG5vZGUuaGVpZ2h0O1xufTtcbmNvbnN0IGRyYXdFZGdlID0gZnVuY3Rpb24gZHJhd0VkZ2UyKGVkZ2VzRWxlbSwgbWluZG1hcCwgcGFyZW50LCBkZXB0aCwgZnVsbFNlY3Rpb24pIHtcbiAgY29uc3Qgc2VjdGlvbiA9IGZ1bGxTZWN0aW9uICUgKE1BWF9TRUNUSU9OUyAtIDEpO1xuICBjb25zdCBzeCA9IHBhcmVudC54ICsgcGFyZW50LndpZHRoIC8gMjtcbiAgY29uc3Qgc3kgPSBwYXJlbnQueSArIHBhcmVudC5oZWlnaHQgLyAyO1xuICBjb25zdCBleCA9IG1pbmRtYXAueCArIG1pbmRtYXAud2lkdGggLyAyO1xuICBjb25zdCBleSA9IG1pbmRtYXAueSArIG1pbmRtYXAuaGVpZ2h0IC8gMjtcbiAgY29uc3QgbXggPSBleCA+IHN4ID8gc3ggKyBNYXRoLmFicyhzeCAtIGV4KSAvIDIgOiBzeCAtIE1hdGguYWJzKHN4IC0gZXgpIC8gMjtcbiAgY29uc3QgbXkgPSBleSA+IHN5ID8gc3kgKyBNYXRoLmFicyhzeSAtIGV5KSAvIDIgOiBzeSAtIE1hdGguYWJzKHN5IC0gZXkpIC8gMjtcbiAgY29uc3QgcXggPSBleCA+IHN4ID8gTWF0aC5hYnMoc3ggLSBteCkgLyAyICsgc3ggOiAtTWF0aC5hYnMoc3ggLSBteCkgLyAyICsgc3g7XG4gIGNvbnN0IHF5ID0gZXkgPiBzeSA/IE1hdGguYWJzKHN5IC0gbXkpIC8gMiArIHN5IDogLU1hdGguYWJzKHN5IC0gbXkpIC8gMiArIHN5O1xuICBlZGdlc0VsZW0uYXBwZW5kKFwicGF0aFwiKS5hdHRyKFxuICAgIFwiZFwiLFxuICAgIHBhcmVudC5kaXJlY3Rpb24gPT09IFwiVEJcIiB8fCBwYXJlbnQuZGlyZWN0aW9uID09PSBcIkJUXCIgPyBgTSR7c3h9LCR7c3l9IFEke3N4fSwke3F5fSAke214fSwke215fSBUJHtleH0sJHtleX1gIDogYE0ke3N4fSwke3N5fSBRJHtxeH0sJHtzeX0gJHtteH0sJHtteX0gVCR7ZXh9LCR7ZXl9YFxuICApLmF0dHIoXCJjbGFzc1wiLCBcImVkZ2Ugc2VjdGlvbi1lZGdlLVwiICsgc2VjdGlvbiArIFwiIGVkZ2UtZGVwdGgtXCIgKyBkZXB0aCk7XG59O1xuY29uc3QgcG9zaXRpb25Ob2RlID0gZnVuY3Rpb24obm9kZSkge1xuICBjb25zdCBub2RlRWxlbSA9IGdldEVsZW1lbnRCeUlkKG5vZGUuaWQpO1xuICBjb25zdCB4ID0gbm9kZS54IHx8IDA7XG4gIGNvbnN0IHkgPSBub2RlLnkgfHwgMDtcbiAgbm9kZUVsZW0uYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIHggKyBcIixcIiArIHkgKyBcIilcIik7XG59O1xuY29uc3Qgc3ZnRHJhdyA9IHsgZHJhd05vZGUsIHBvc2l0aW9uTm9kZSwgZHJhd0VkZ2UgfTtcbmN5dG9zY2FwZS51c2UoY29zZUJpbGtlbnQpO1xuZnVuY3Rpb24gZHJhd05vZGVzKHN2ZywgbWluZG1hcCwgc2VjdGlvbiwgY29uZikge1xuICBzdmdEcmF3LmRyYXdOb2RlKHN2ZywgbWluZG1hcCwgc2VjdGlvbiwgY29uZik7XG4gIGlmIChtaW5kbWFwLmNoaWxkcmVuKSB7XG4gICAgbWluZG1hcC5jaGlsZHJlbi5mb3JFYWNoKChjaGlsZCwgaW5kZXgpID0+IHtcbiAgICAgIGRyYXdOb2RlcyhzdmcsIGNoaWxkLCBzZWN0aW9uIDwgMCA/IGluZGV4IDogc2VjdGlvbiwgY29uZik7XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRyYXdFZGdlcyhlZGdlc0VsLCBjeSkge1xuICBjeS5lZGdlcygpLm1hcCgoZWRnZSwgaWQpID0+IHtcbiAgICBjb25zdCBkYXRhID0gZWRnZS5kYXRhKCk7XG4gICAgaWYgKGVkZ2VbMF0uX3ByaXZhdGUuYm9keUJvdW5kcykge1xuICAgICAgY29uc3QgYm91bmRzID0gZWRnZVswXS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICAgIGxvZy50cmFjZShcIkVkZ2U6IFwiLCBpZCwgZGF0YSk7XG4gICAgICBlZGdlc0VsLmluc2VydChcInBhdGhcIikuYXR0cihcbiAgICAgICAgXCJkXCIsXG4gICAgICAgIGBNICR7Ym91bmRzLnN0YXJ0WH0sJHtib3VuZHMuc3RhcnRZfSBMICR7Ym91bmRzLm1pZFh9LCR7Ym91bmRzLm1pZFl9IEwke2JvdW5kcy5lbmRYfSwke2JvdW5kcy5lbmRZfSBgXG4gICAgICApLmF0dHIoXCJjbGFzc1wiLCBcImVkZ2Ugc2VjdGlvbi1lZGdlLVwiICsgZGF0YS5zZWN0aW9uICsgXCIgZWRnZS1kZXB0aC1cIiArIGRhdGEuZGVwdGgpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBhZGROb2RlcyhtaW5kbWFwLCBjeSwgY29uZiwgbGV2ZWwpIHtcbiAgY3kuYWRkKHtcbiAgICBncm91cDogXCJub2Rlc1wiLFxuICAgIGRhdGE6IHtcbiAgICAgIGlkOiBtaW5kbWFwLmlkLFxuICAgICAgbGFiZWxUZXh0OiBtaW5kbWFwLmRlc2NyLFxuICAgICAgaGVpZ2h0OiBtaW5kbWFwLmhlaWdodCxcbiAgICAgIHdpZHRoOiBtaW5kbWFwLndpZHRoLFxuICAgICAgbGV2ZWwsXG4gICAgICBub2RlSWQ6IG1pbmRtYXAuaWQsXG4gICAgICBwYWRkaW5nOiBtaW5kbWFwLnBhZGRpbmcsXG4gICAgICB0eXBlOiBtaW5kbWFwLnR5cGVcbiAgICB9LFxuICAgIHBvc2l0aW9uOiB7XG4gICAgICB4OiBtaW5kbWFwLngsXG4gICAgICB5OiBtaW5kbWFwLnlcbiAgICB9XG4gIH0pO1xuICBpZiAobWluZG1hcC5jaGlsZHJlbikge1xuICAgIG1pbmRtYXAuY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAgIGFkZE5vZGVzKGNoaWxkLCBjeSwgY29uZiwgbGV2ZWwgKyAxKTtcbiAgICAgIGN5LmFkZCh7XG4gICAgICAgIGdyb3VwOiBcImVkZ2VzXCIsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBpZDogYCR7bWluZG1hcC5pZH1fJHtjaGlsZC5pZH1gLFxuICAgICAgICAgIHNvdXJjZTogbWluZG1hcC5pZCxcbiAgICAgICAgICB0YXJnZXQ6IGNoaWxkLmlkLFxuICAgICAgICAgIGRlcHRoOiBsZXZlbCxcbiAgICAgICAgICBzZWN0aW9uOiBjaGlsZC5zZWN0aW9uXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBsYXlvdXRNaW5kbWFwKG5vZGUsIGNvbmYpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgY29uc3QgcmVuZGVyRWwgPSBzZWxlY3QoXCJib2R5XCIpLmFwcGVuZChcImRpdlwiKS5hdHRyKFwiaWRcIiwgXCJjeVwiKS5hdHRyKFwic3R5bGVcIiwgXCJkaXNwbGF5Om5vbmVcIik7XG4gICAgY29uc3QgY3kgPSBjeXRvc2NhcGUoe1xuICAgICAgY29udGFpbmVyOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImN5XCIpLFxuICAgICAgLy8gY29udGFpbmVyIHRvIHJlbmRlciBpblxuICAgICAgc3R5bGU6IFtcbiAgICAgICAge1xuICAgICAgICAgIHNlbGVjdG9yOiBcImVkZ2VcIixcbiAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgXCJjdXJ2ZS1zdHlsZVwiOiBcImJlemllclwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSk7XG4gICAgcmVuZGVyRWwucmVtb3ZlKCk7XG4gICAgYWRkTm9kZXMobm9kZSwgY3ksIGNvbmYsIDApO1xuICAgIGN5Lm5vZGVzKCkuZm9yRWFjaChmdW5jdGlvbihuKSB7XG4gICAgICBuLmxheW91dERpbWVuc2lvbnMgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBuLmRhdGEoKTtcbiAgICAgICAgcmV0dXJuIHsgdzogZGF0YS53aWR0aCwgaDogZGF0YS5oZWlnaHQgfTtcbiAgICAgIH07XG4gICAgfSk7XG4gICAgY3kubGF5b3V0KHtcbiAgICAgIG5hbWU6IFwiY29zZS1iaWxrZW50XCIsXG4gICAgICBxdWFsaXR5OiBcInByb29mXCIsXG4gICAgICAvLyBoZWFkbGVzczogdHJ1ZSxcbiAgICAgIHN0eWxlRW5hYmxlZDogZmFsc2UsXG4gICAgICBhbmltYXRlOiBmYWxzZVxuICAgIH0pLnJ1bigpO1xuICAgIGN5LnJlYWR5KChlKSA9PiB7XG4gICAgICBsb2cuaW5mbyhcIlJlYWR5XCIsIGUpO1xuICAgICAgcmVzb2x2ZShjeSk7XG4gICAgfSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gcG9zaXRpb25Ob2RlcyhjeSkge1xuICBjeS5ub2RlcygpLm1hcCgobm9kZSwgaWQpID0+IHtcbiAgICBjb25zdCBkYXRhID0gbm9kZS5kYXRhKCk7XG4gICAgZGF0YS54ID0gbm9kZS5wb3NpdGlvbigpLng7XG4gICAgZGF0YS55ID0gbm9kZS5wb3NpdGlvbigpLnk7XG4gICAgc3ZnRHJhdy5wb3NpdGlvbk5vZGUoZGF0YSk7XG4gICAgY29uc3QgZWwgPSBnZXRFbGVtZW50QnlJZChkYXRhLm5vZGVJZCk7XG4gICAgbG9nLmluZm8oXCJJZDpcIiwgaWQsIFwiUG9zaXRpb246IChcIiwgbm9kZS5wb3NpdGlvbigpLngsIFwiLCBcIiwgbm9kZS5wb3NpdGlvbigpLnksIFwiKVwiLCBkYXRhKTtcbiAgICBlbC5hdHRyKFxuICAgICAgXCJ0cmFuc2Zvcm1cIixcbiAgICAgIGB0cmFuc2xhdGUoJHtub2RlLnBvc2l0aW9uKCkueCAtIGRhdGEud2lkdGggLyAyfSwgJHtub2RlLnBvc2l0aW9uKCkueSAtIGRhdGEuaGVpZ2h0IC8gMn0pYFxuICAgICk7XG4gICAgZWwuYXR0cihcImF0dHJcIiwgYGFwYS0ke2lkfSlgKTtcbiAgfSk7XG59XG5jb25zdCBkcmF3ID0gYXN5bmMgKHRleHQsIGlkLCB2ZXJzaW9uLCBkaWFnT2JqKSA9PiB7XG4gIGNvbnN0IGNvbmYgPSBnZXRDb25maWcoKTtcbiAgY29uZi5odG1sTGFiZWxzID0gZmFsc2U7XG4gIGxvZy5kZWJ1ZyhcIlJlbmRlcmluZyBtaW5kbWFwIGRpYWdyYW1cXG5cIiArIHRleHQsIGRpYWdPYmoucGFyc2VyKTtcbiAgY29uc3Qgc2VjdXJpdHlMZXZlbCA9IGdldENvbmZpZygpLnNlY3VyaXR5TGV2ZWw7XG4gIGxldCBzYW5kYm94RWxlbWVudDtcbiAgaWYgKHNlY3VyaXR5TGV2ZWwgPT09IFwic2FuZGJveFwiKSB7XG4gICAgc2FuZGJveEVsZW1lbnQgPSBzZWxlY3QoXCIjaVwiICsgaWQpO1xuICB9XG4gIGNvbnN0IHJvb3QgPSBzZWN1cml0eUxldmVsID09PSBcInNhbmRib3hcIiA/IHNlbGVjdChzYW5kYm94RWxlbWVudC5ub2RlcygpWzBdLmNvbnRlbnREb2N1bWVudC5ib2R5KSA6IHNlbGVjdChcImJvZHlcIik7XG4gIGNvbnN0IHN2ZyA9IHJvb3Quc2VsZWN0KFwiI1wiICsgaWQpO1xuICBzdmcuYXBwZW5kKFwiZ1wiKTtcbiAgY29uc3QgbW0gPSBkaWFnT2JqLmRiLmdldE1pbmRtYXAoKTtcbiAgY29uc3QgZWRnZXNFbGVtID0gc3ZnLmFwcGVuZChcImdcIik7XG4gIGVkZ2VzRWxlbS5hdHRyKFwiY2xhc3NcIiwgXCJtaW5kbWFwLWVkZ2VzXCIpO1xuICBjb25zdCBub2Rlc0VsZW0gPSBzdmcuYXBwZW5kKFwiZ1wiKTtcbiAgbm9kZXNFbGVtLmF0dHIoXCJjbGFzc1wiLCBcIm1pbmRtYXAtbm9kZXNcIik7XG4gIGRyYXdOb2Rlcyhub2Rlc0VsZW0sIG1tLCAtMSwgY29uZik7XG4gIGNvbnN0IGN5ID0gYXdhaXQgbGF5b3V0TWluZG1hcChtbSwgY29uZik7XG4gIGRyYXdFZGdlcyhlZGdlc0VsZW0sIGN5KTtcbiAgcG9zaXRpb25Ob2RlcyhjeSk7XG4gIHNldHVwR3JhcGhWaWV3Ym94KHZvaWQgMCwgc3ZnLCBjb25mLm1pbmRtYXAucGFkZGluZywgY29uZi5taW5kbWFwLnVzZU1heFdpZHRoKTtcbn07XG5jb25zdCBtaW5kbWFwUmVuZGVyZXIgPSB7XG4gIGRyYXdcbn07XG5jb25zdCBnZW5TZWN0aW9ucyA9IChvcHRpb25zKSA9PiB7XG4gIGxldCBzZWN0aW9ucyA9IFwiXCI7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgb3B0aW9ucy5USEVNRV9DT0xPUl9MSU1JVDsgaSsrKSB7XG4gICAgb3B0aW9uc1tcImxpbmVDb2xvclwiICsgaV0gPSBvcHRpb25zW1wibGluZUNvbG9yXCIgKyBpXSB8fCBvcHRpb25zW1wiY1NjYWxlSW52XCIgKyBpXTtcbiAgICBpZiAoaXNEYXJrKG9wdGlvbnNbXCJsaW5lQ29sb3JcIiArIGldKSkge1xuICAgICAgb3B0aW9uc1tcImxpbmVDb2xvclwiICsgaV0gPSBsaWdodGVuKG9wdGlvbnNbXCJsaW5lQ29sb3JcIiArIGldLCAyMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnNbXCJsaW5lQ29sb3JcIiArIGldID0gZGFya2VuKG9wdGlvbnNbXCJsaW5lQ29sb3JcIiArIGldLCAyMCk7XG4gICAgfVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgb3B0aW9ucy5USEVNRV9DT0xPUl9MSU1JVDsgaSsrKSB7XG4gICAgY29uc3Qgc3cgPSBcIlwiICsgKDE3IC0gMyAqIGkpO1xuICAgIHNlY3Rpb25zICs9IGBcbiAgICAuc2VjdGlvbi0ke2kgLSAxfSByZWN0LCAuc2VjdGlvbi0ke2kgLSAxfSBwYXRoLCAuc2VjdGlvbi0ke2kgLSAxfSBjaXJjbGUsIC5zZWN0aW9uLSR7aSAtIDF9IHBvbHlnb24sIC5zZWN0aW9uLSR7aSAtIDF9IHBhdGggIHtcbiAgICAgIGZpbGw6ICR7b3B0aW9uc1tcImNTY2FsZVwiICsgaV19O1xuICAgIH1cbiAgICAuc2VjdGlvbi0ke2kgLSAxfSB0ZXh0IHtcbiAgICAgZmlsbDogJHtvcHRpb25zW1wiY1NjYWxlTGFiZWxcIiArIGldfTtcbiAgICB9XG4gICAgLm5vZGUtaWNvbi0ke2kgLSAxfSB7XG4gICAgICBmb250LXNpemU6IDQwcHg7XG4gICAgICBjb2xvcjogJHtvcHRpb25zW1wiY1NjYWxlTGFiZWxcIiArIGldfTtcbiAgICB9XG4gICAgLnNlY3Rpb24tZWRnZS0ke2kgLSAxfXtcbiAgICAgIHN0cm9rZTogJHtvcHRpb25zW1wiY1NjYWxlXCIgKyBpXX07XG4gICAgfVxuICAgIC5lZGdlLWRlcHRoLSR7aSAtIDF9e1xuICAgICAgc3Ryb2tlLXdpZHRoOiAke3N3fTtcbiAgICB9XG4gICAgLnNlY3Rpb24tJHtpIC0gMX0gbGluZSB7XG4gICAgICBzdHJva2U6ICR7b3B0aW9uc1tcImNTY2FsZUludlwiICsgaV19IDtcbiAgICAgIHN0cm9rZS13aWR0aDogMztcbiAgICB9XG5cbiAgICAuZGlzYWJsZWQsIC5kaXNhYmxlZCBjaXJjbGUsIC5kaXNhYmxlZCB0ZXh0IHtcbiAgICAgIGZpbGw6IGxpZ2h0Z3JheTtcbiAgICB9XG4gICAgLmRpc2FibGVkIHRleHQge1xuICAgICAgZmlsbDogI2VmZWZlZjtcbiAgICB9XG4gICAgYDtcbiAgfVxuICByZXR1cm4gc2VjdGlvbnM7XG59O1xuY29uc3QgZ2V0U3R5bGVzID0gKG9wdGlvbnMpID0+IGBcbiAgLmVkZ2Uge1xuICAgIHN0cm9rZS13aWR0aDogMztcbiAgfVxuICAke2dlblNlY3Rpb25zKG9wdGlvbnMpfVxuICAuc2VjdGlvbi1yb290IHJlY3QsIC5zZWN0aW9uLXJvb3QgcGF0aCwgLnNlY3Rpb24tcm9vdCBjaXJjbGUsIC5zZWN0aW9uLXJvb3QgcG9seWdvbiAge1xuICAgIGZpbGw6ICR7b3B0aW9ucy5naXQwfTtcbiAgfVxuICAuc2VjdGlvbi1yb290IHRleHQge1xuICAgIGZpbGw6ICR7b3B0aW9ucy5naXRCcmFuY2hMYWJlbDB9O1xuICB9XG4gIC5pY29uLWNvbnRhaW5lciB7XG4gICAgaGVpZ2h0OjEwMCU7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICB9XG4gIC5lZGdlIHtcbiAgICBmaWxsOiBub25lO1xuICB9XG4gIC5taW5kbWFwLW5vZGUtbGFiZWwge1xuICAgIGR5OiAxZW07XG4gICAgYWxpZ25tZW50LWJhc2VsaW5lOiBtaWRkbGU7XG4gICAgdGV4dC1hbmNob3I6IG1pZGRsZTtcbiAgICBkb21pbmFudC1iYXNlbGluZTogbWlkZGxlO1xuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgfVxuYDtcbmNvbnN0IG1pbmRtYXBTdHlsZXMgPSBnZXRTdHlsZXM7XG5jb25zdCBkaWFncmFtID0ge1xuICBkYjogbWluZG1hcERiLFxuICByZW5kZXJlcjogbWluZG1hcFJlbmRlcmVyLFxuICBwYXJzZXI6IG1pbmRtYXBQYXJzZXIsXG4gIHN0eWxlczogbWluZG1hcFN0eWxlc1xufTtcbmV4cG9ydCB7XG4gIGRpYWdyYW1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(sc_client)/./node_modules/mermaid/dist/mindmap-definition-617cf8dd.js\n");

/***/ })

};
;