"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-client)/./app/client/platforms/openai.ts":
/*!****************************************!*\
  !*** ./app/client/platforms/openai.ts ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChatGPTApi: function() { return /* binding */ ChatGPTApi; },\n/* harmony export */   OpenaiPath: function() { return /* reexport safe */ _app_constant__WEBPACK_IMPORTED_MODULE_0__.OpenaiPath; }\n/* harmony export */ });\n/* harmony import */ var _app_constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/app/constant */ \"(app-client)/./app/constant.ts\");\n/* harmony import */ var _app_store__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/app/store */ \"(app-client)/./app/store/index.ts\");\n/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../api */ \"(app-client)/./app/client/api.ts\");\n/* harmony import */ var _locales__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../locales */ \"(app-client)/./app/locales/index.ts\");\n/* harmony import */ var _fortaine_fetch_event_source__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @fortaine/fetch-event-source */ \"(app-client)/./node_modules/@fortaine/fetch-event-source/lib/esm/fetch.js\");\n/* harmony import */ var _app_utils_format__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/app/utils/format */ \"(app-client)/./app/utils/format.ts\");\n/* harmony import */ var _app_config_client__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/app/config/client */ \"(app-client)/./app/config/client.ts\");\n/* harmony import */ var _app_azure__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/app/azure */ \"(app-client)/./app/azure.ts\");\n\n\n\n\n\n\n\n\nclass ChatGPTApi {\n    path(path) {\n        const accessStore = _app_store__WEBPACK_IMPORTED_MODULE_1__.useAccessStore.getState();\n        const isAzure = accessStore.provider === _app_constant__WEBPACK_IMPORTED_MODULE_0__.ServiceProvider.Azure;\n        if (isAzure && !accessStore.isValidAzure()) {\n            throw Error(\"incomplete azure config, please check it in your settings page\");\n        }\n        let baseUrl = isAzure ? accessStore.azureUrl : accessStore.openaiUrl;\n        if (baseUrl.length === 0) {\n            var _getClientConfig;\n            const isApp = !!((_getClientConfig = (0,_app_config_client__WEBPACK_IMPORTED_MODULE_5__.getClientConfig)()) === null || _getClientConfig === void 0 ? void 0 : _getClientConfig.isApp);\n            baseUrl = isApp ? _app_constant__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_API_HOST : _app_constant__WEBPACK_IMPORTED_MODULE_0__.ApiPath.OpenAI;\n        }\n        if (baseUrl.endsWith(\"/\")) {\n            baseUrl = baseUrl.slice(0, baseUrl.length - 1);\n        }\n        if (!baseUrl.startsWith(\"http\") && !baseUrl.startsWith(_app_constant__WEBPACK_IMPORTED_MODULE_0__.ApiPath.OpenAI)) {\n            baseUrl = \"https://\" + baseUrl;\n        }\n        if (isAzure) {\n            path = (0,_app_azure__WEBPACK_IMPORTED_MODULE_6__.makeAzurePath)(path, accessStore.azureApiVersion);\n        }\n        return [\n            baseUrl,\n            path\n        ].join(\"/\");\n    }\n    extractMessage(res) {\n        var _res_choices_at_message, _res_choices_at, _res_choices;\n        var _res_choices_at_message_content;\n        return (_res_choices_at_message_content = (_res_choices = res.choices) === null || _res_choices === void 0 ? void 0 : (_res_choices_at = _res_choices.at(0)) === null || _res_choices_at === void 0 ? void 0 : (_res_choices_at_message = _res_choices_at.message) === null || _res_choices_at_message === void 0 ? void 0 : _res_choices_at_message.content) !== null && _res_choices_at_message_content !== void 0 ? _res_choices_at_message_content : \"\";\n    }\n    async chat(options) {\n        var _options_onController, _options;\n        const messages = options.messages.map((v)=>({\n                role: v.role,\n                content: v.content\n            }));\n        const modelConfig = {\n            ..._app_store__WEBPACK_IMPORTED_MODULE_1__.useAppConfig.getState().modelConfig,\n            ..._app_store__WEBPACK_IMPORTED_MODULE_1__.useChatStore.getState().currentSession().mask.modelConfig,\n            ...{\n                model: options.config.model\n            }\n        };\n        const requestPayload = {\n            messages,\n            stream: options.config.stream,\n            model: modelConfig.model,\n            temperature: modelConfig.temperature,\n            presence_penalty: modelConfig.presence_penalty,\n            frequency_penalty: modelConfig.frequency_penalty,\n            top_p: modelConfig.top_p\n        };\n        console.log(\"[Request] openai payload: \", requestPayload);\n        const shouldStream = !!options.config.stream;\n        const controller = new AbortController();\n        (_options_onController = (_options = options).onController) === null || _options_onController === void 0 ? void 0 : _options_onController.call(_options, controller);\n        try {\n            const chatPath = this.path(_app_constant__WEBPACK_IMPORTED_MODULE_0__.OpenaiPath.ChatPath);\n            const chatPayload = {\n                method: \"POST\",\n                body: JSON.stringify(requestPayload),\n                signal: controller.signal,\n                headers: (0,_api__WEBPACK_IMPORTED_MODULE_2__.getHeaders)()\n            };\n            // make a fetch request\n            const requestTimeoutId = setTimeout(()=>controller.abort(), _app_constant__WEBPACK_IMPORTED_MODULE_0__.REQUEST_TIMEOUT_MS);\n            if (shouldStream) {\n                let responseText = \"\";\n                let remainText = \"\";\n                let finished = false;\n                // animate response to make it looks smooth\n                function animateResponseText() {\n                    if (finished || controller.signal.aborted) {\n                        responseText += remainText;\n                        console.log(\"[Response Animation] finished\");\n                        return;\n                    }\n                    if (remainText.length > 0) {\n                        var _options_onUpdate, _options;\n                        const fetchCount = Math.max(1, Math.round(remainText.length / 60));\n                        const fetchText = remainText.slice(0, fetchCount);\n                        responseText += fetchText;\n                        remainText = remainText.slice(fetchCount);\n                        (_options_onUpdate = (_options = options).onUpdate) === null || _options_onUpdate === void 0 ? void 0 : _options_onUpdate.call(_options, responseText, fetchText);\n                    }\n                    requestAnimationFrame(animateResponseText);\n                }\n                // start animaion\n                animateResponseText();\n                const finish = ()=>{\n                    if (!finished) {\n                        finished = true;\n                        options.onFinish(responseText + remainText);\n                    }\n                };\n                controller.signal.onabort = finish;\n                (0,_fortaine_fetch_event_source__WEBPACK_IMPORTED_MODULE_7__.fetchEventSource)(chatPath, {\n                    ...chatPayload,\n                    async onopen (res) {\n                        var _contentType, _res_headers_get;\n                        clearTimeout(requestTimeoutId);\n                        const contentType = res.headers.get(\"content-type\");\n                        console.log(\"[OpenAI] request response content type: \", contentType);\n                        if ((_contentType = contentType) === null || _contentType === void 0 ? void 0 : _contentType.startsWith(\"text/plain\")) {\n                            responseText = await res.clone().text();\n                            return finish();\n                        }\n                        if (!res.ok || !((_res_headers_get = res.headers.get(\"content-type\")) === null || _res_headers_get === void 0 ? void 0 : _res_headers_get.startsWith(_fortaine_fetch_event_source__WEBPACK_IMPORTED_MODULE_7__.EventStreamContentType)) || res.status !== 200) {\n                            const responseTexts = [\n                                responseText\n                            ];\n                            let extraInfo = await res.clone().text();\n                            try {\n                                const resJson = await res.clone().json();\n                                extraInfo = (0,_app_utils_format__WEBPACK_IMPORTED_MODULE_4__.prettyObject)(resJson);\n                            } catch (e) {}\n                            if (res.status === 401) {\n                                responseTexts.push(_locales__WEBPACK_IMPORTED_MODULE_3__[\"default\"].Error.Unauthorized);\n                            }\n                            if (extraInfo) {\n                                responseTexts.push(extraInfo);\n                            }\n                            responseText = responseTexts.join(\"\\n\\n\");\n                            return finish();\n                        }\n                    },\n                    onmessage (msg) {\n                        if (msg.data === \"[DONE]\" || finished) {\n                            return finish();\n                        }\n                        const text = msg.data;\n                        try {\n                            var _json_choices__delta, _json_choices_;\n                            const json = JSON.parse(text);\n                            const delta = (_json_choices_ = json.choices[0]) === null || _json_choices_ === void 0 ? void 0 : (_json_choices__delta = _json_choices_.delta) === null || _json_choices__delta === void 0 ? void 0 : _json_choices__delta.content;\n                            if (delta) {\n                                remainText += delta;\n                            }\n                        } catch (e) {\n                            console.error(\"[Request] parse error\", text);\n                        }\n                    },\n                    onclose () {\n                        finish();\n                    },\n                    onerror (e) {\n                        var _options_onError, _options;\n                        (_options_onError = (_options = options).onError) === null || _options_onError === void 0 ? void 0 : _options_onError.call(_options, e);\n                        throw e;\n                    },\n                    openWhenHidden: true\n                });\n            } else {\n                const res = await fetch(chatPath, chatPayload);\n                clearTimeout(requestTimeoutId);\n                const resJson = await res.json();\n                const message = this.extractMessage(resJson);\n                options.onFinish(message);\n            }\n        } catch (e) {\n            var _options_onError, _options1;\n            console.log(\"[Request] failed to make a chat request\", e);\n            (_options_onError = (_options1 = options).onError) === null || _options_onError === void 0 ? void 0 : _options_onError.call(_options1, e);\n        }\n    }\n    async usage() {\n        const formatDate = (d)=>\"\".concat(d.getFullYear(), \"-\").concat((d.getMonth() + 1).toString().padStart(2, \"0\"), \"-\").concat(d.getDate().toString().padStart(2, \"0\"));\n        const ONE_DAY = 1 * 24 * 60 * 60 * 1000;\n        const now = new Date();\n        const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);\n        const startDate = formatDate(startOfMonth);\n        const endDate = formatDate(new Date(Date.now() + ONE_DAY));\n        const [used, subs] = await Promise.all([\n            fetch(this.path(\"\".concat(_app_constant__WEBPACK_IMPORTED_MODULE_0__.OpenaiPath.UsagePath, \"?start_date=\").concat(startDate, \"&end_date=\").concat(endDate)), {\n                method: \"GET\",\n                headers: (0,_api__WEBPACK_IMPORTED_MODULE_2__.getHeaders)()\n            }),\n            fetch(this.path(_app_constant__WEBPACK_IMPORTED_MODULE_0__.OpenaiPath.SubsPath), {\n                method: \"GET\",\n                headers: (0,_api__WEBPACK_IMPORTED_MODULE_2__.getHeaders)()\n            })\n        ]);\n        if (used.status === 401) {\n            throw new Error(_locales__WEBPACK_IMPORTED_MODULE_3__[\"default\"].Error.Unauthorized);\n        }\n        if (!used.ok || !subs.ok) {\n            throw new Error(\"Failed to query usage from openai\");\n        }\n        const response = await used.json();\n        const total = await subs.json();\n        if (response.error && response.error.type) {\n            throw Error(response.error.message);\n        }\n        if (response.total_usage) {\n            response.total_usage = Math.round(response.total_usage) / 100;\n        }\n        if (total.hard_limit_usd) {\n            total.hard_limit_usd = Math.round(total.hard_limit_usd * 100) / 100;\n        }\n        return {\n            used: response.total_usage,\n            total: total.hard_limit_usd\n        };\n    }\n    async models() {\n        var _resJson_data;\n        if (this.disableListModels) {\n            return _app_constant__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_MODELS.slice();\n        }\n        const res = await fetch(this.path(_app_constant__WEBPACK_IMPORTED_MODULE_0__.OpenaiPath.ListModelPath), {\n            method: \"GET\",\n            headers: {\n                ...(0,_api__WEBPACK_IMPORTED_MODULE_2__.getHeaders)()\n            }\n        });\n        const resJson = await res.json();\n        const chatModels = (_resJson_data = resJson.data) === null || _resJson_data === void 0 ? void 0 : _resJson_data.filter((m)=>m.id.startsWith(\"gpt-\"));\n        console.log(\"[Models]\", chatModels);\n        if (!chatModels) {\n            return [];\n        }\n        return chatModels.map((m)=>({\n                name: m.id,\n                available: true\n            }));\n    }\n    constructor(){\n        this.disableListModels = true;\n    }\n}\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vYXBwL2NsaWVudC9wbGF0Zm9ybXMvb3BlbmFpLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFPd0I7QUFDaUQ7QUFFSTtBQUMxQztBQUlHO0FBQ1k7QUFDSTtBQUNWO0FBV3JDLE1BQU1nQjtJQUdYQyxLQUFLQSxJQUFZLEVBQVU7UUFDekIsTUFBTUMsY0FBY1osc0RBQWNBLENBQUNhLFFBQVE7UUFFM0MsTUFBTUMsVUFBVUYsWUFBWUcsUUFBUSxLQUFLaEIsMERBQWVBLENBQUNpQixLQUFLO1FBRTlELElBQUlGLFdBQVcsQ0FBQ0YsWUFBWUssWUFBWSxJQUFJO1lBQzFDLE1BQU1DLE1BQ0o7UUFFSjtRQUVBLElBQUlDLFVBQVVMLFVBQVVGLFlBQVlRLFFBQVEsR0FBR1IsWUFBWVMsU0FBUztRQUVwRSxJQUFJRixRQUFRRyxNQUFNLEtBQUssR0FBRztnQkFDUmQ7WUFBaEIsTUFBTWUsUUFBUSxDQUFDLEdBQUNmLG1CQUFBQSxtRUFBZUEsZ0JBQWZBLHVDQUFBQSxpQkFBbUJlLEtBQUs7WUFDeENKLFVBQVVJLFFBQVE1QiwyREFBZ0JBLEdBQUdELGtEQUFPQSxDQUFDOEIsTUFBTTtRQUNyRDtRQUVBLElBQUlMLFFBQVFNLFFBQVEsQ0FBQyxNQUFNO1lBQ3pCTixVQUFVQSxRQUFRTyxLQUFLLENBQUMsR0FBR1AsUUFBUUcsTUFBTSxHQUFHO1FBQzlDO1FBQ0EsSUFBSSxDQUFDSCxRQUFRUSxVQUFVLENBQUMsV0FBVyxDQUFDUixRQUFRUSxVQUFVLENBQUNqQyxrREFBT0EsQ0FBQzhCLE1BQU0sR0FBRztZQUN0RUwsVUFBVSxhQUFhQTtRQUN6QjtRQUVBLElBQUlMLFNBQVM7WUFDWEgsT0FBT0YseURBQWFBLENBQUNFLE1BQU1DLFlBQVlnQixlQUFlO1FBQ3hEO1FBRUEsT0FBTztZQUFDVDtZQUFTUjtTQUFLLENBQUNrQixJQUFJLENBQUM7SUFDOUI7SUFFQUMsZUFBZUMsR0FBUSxFQUFFO1lBQ2hCQSx5QkFBQUEsaUJBQUFBO1lB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O2FBeFNRUCxvQkFBb0I7O0FBeVM5QjtBQUNzQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvY2xpZW50L3BsYXRmb3Jtcy9vcGVuYWkudHM/YWRmYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBBcGlQYXRoLFxuICBERUZBVUxUX0FQSV9IT1NULFxuICBERUZBVUxUX01PREVMUyxcbiAgT3BlbmFpUGF0aCxcbiAgUkVRVUVTVF9USU1FT1VUX01TLFxuICBTZXJ2aWNlUHJvdmlkZXIsXG59IGZyb20gXCJAL2FwcC9jb25zdGFudFwiO1xuaW1wb3J0IHsgdXNlQWNjZXNzU3RvcmUsIHVzZUFwcENvbmZpZywgdXNlQ2hhdFN0b3JlIH0gZnJvbSBcIkAvYXBwL3N0b3JlXCI7XG5cbmltcG9ydCB7IENoYXRPcHRpb25zLCBnZXRIZWFkZXJzLCBMTE1BcGksIExMTU1vZGVsLCBMTE1Vc2FnZSB9IGZyb20gXCIuLi9hcGlcIjtcbmltcG9ydCBMb2NhbGUgZnJvbSBcIi4uLy4uL2xvY2FsZXNcIjtcbmltcG9ydCB7XG4gIEV2ZW50U3RyZWFtQ29udGVudFR5cGUsXG4gIGZldGNoRXZlbnRTb3VyY2UsXG59IGZyb20gXCJAZm9ydGFpbmUvZmV0Y2gtZXZlbnQtc291cmNlXCI7XG5pbXBvcnQgeyBwcmV0dHlPYmplY3QgfSBmcm9tIFwiQC9hcHAvdXRpbHMvZm9ybWF0XCI7XG5pbXBvcnQgeyBnZXRDbGllbnRDb25maWcgfSBmcm9tIFwiQC9hcHAvY29uZmlnL2NsaWVudFwiO1xuaW1wb3J0IHsgbWFrZUF6dXJlUGF0aCB9IGZyb20gXCJAL2FwcC9henVyZVwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIE9wZW5BSUxpc3RNb2RlbFJlc3BvbnNlIHtcbiAgb2JqZWN0OiBzdHJpbmc7XG4gIGRhdGE6IEFycmF5PHtcbiAgICBpZDogc3RyaW5nO1xuICAgIG9iamVjdDogc3RyaW5nO1xuICAgIHJvb3Q6IHN0cmluZztcbiAgfT47XG59XG5cbmV4cG9ydCBjbGFzcyBDaGF0R1BUQXBpIGltcGxlbWVudHMgTExNQXBpIHtcbiAgcHJpdmF0ZSBkaXNhYmxlTGlzdE1vZGVscyA9IHRydWU7XG5cbiAgcGF0aChwYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IGFjY2Vzc1N0b3JlID0gdXNlQWNjZXNzU3RvcmUuZ2V0U3RhdGUoKTtcblxuICAgIGNvbnN0IGlzQXp1cmUgPSBhY2Nlc3NTdG9yZS5wcm92aWRlciA9PT0gU2VydmljZVByb3ZpZGVyLkF6dXJlO1xuXG4gICAgaWYgKGlzQXp1cmUgJiYgIWFjY2Vzc1N0b3JlLmlzVmFsaWRBenVyZSgpKSB7XG4gICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgXCJpbmNvbXBsZXRlIGF6dXJlIGNvbmZpZywgcGxlYXNlIGNoZWNrIGl0IGluIHlvdXIgc2V0dGluZ3MgcGFnZVwiLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBsZXQgYmFzZVVybCA9IGlzQXp1cmUgPyBhY2Nlc3NTdG9yZS5henVyZVVybCA6IGFjY2Vzc1N0b3JlLm9wZW5haVVybDtcblxuICAgIGlmIChiYXNlVXJsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29uc3QgaXNBcHAgPSAhIWdldENsaWVudENvbmZpZygpPy5pc0FwcDtcbiAgICAgIGJhc2VVcmwgPSBpc0FwcCA/IERFRkFVTFRfQVBJX0hPU1QgOiBBcGlQYXRoLk9wZW5BSTtcbiAgICB9XG5cbiAgICBpZiAoYmFzZVVybC5lbmRzV2l0aChcIi9cIikpIHtcbiAgICAgIGJhc2VVcmwgPSBiYXNlVXJsLnNsaWNlKDAsIGJhc2VVcmwubGVuZ3RoIC0gMSk7XG4gICAgfVxuICAgIGlmICghYmFzZVVybC5zdGFydHNXaXRoKFwiaHR0cFwiKSAmJiAhYmFzZVVybC5zdGFydHNXaXRoKEFwaVBhdGguT3BlbkFJKSkge1xuICAgICAgYmFzZVVybCA9IFwiaHR0cHM6Ly9cIiArIGJhc2VVcmw7XG4gICAgfVxuXG4gICAgaWYgKGlzQXp1cmUpIHtcbiAgICAgIHBhdGggPSBtYWtlQXp1cmVQYXRoKHBhdGgsIGFjY2Vzc1N0b3JlLmF6dXJlQXBpVmVyc2lvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtiYXNlVXJsLCBwYXRoXS5qb2luKFwiL1wiKTtcbiAgfVxuXG4gIGV4dHJhY3RNZXNzYWdlKHJlczogYW55KSB7XG4gICAgcmV0dXJuIHJlcy5jaG9pY2VzPy5hdCgwKT8ubWVzc2FnZT8uY29udGVudCA/PyBcIlwiO1xuICB9XG5cbiAgYXN5bmMgY2hhdChvcHRpb25zOiBDaGF0T3B0aW9ucykge1xuICAgIGNvbnN0IG1lc3NhZ2VzID0gb3B0aW9ucy5tZXNzYWdlcy5tYXAoKHYpID0+ICh7XG4gICAgICByb2xlOiB2LnJvbGUsXG4gICAgICBjb250ZW50OiB2LmNvbnRlbnQsXG4gICAgfSkpO1xuXG4gICAgY29uc3QgbW9kZWxDb25maWcgPSB7XG4gICAgICAuLi51c2VBcHBDb25maWcuZ2V0U3RhdGUoKS5tb2RlbENvbmZpZyxcbiAgICAgIC4uLnVzZUNoYXRTdG9yZS5nZXRTdGF0ZSgpLmN1cnJlbnRTZXNzaW9uKCkubWFzay5tb2RlbENvbmZpZyxcbiAgICAgIC4uLntcbiAgICAgICAgbW9kZWw6IG9wdGlvbnMuY29uZmlnLm1vZGVsLFxuICAgICAgfSxcbiAgICB9O1xuXG4gICAgY29uc3QgcmVxdWVzdFBheWxvYWQgPSB7XG4gICAgICBtZXNzYWdlcyxcbiAgICAgIHN0cmVhbTogb3B0aW9ucy5jb25maWcuc3RyZWFtLFxuICAgICAgbW9kZWw6IG1vZGVsQ29uZmlnLm1vZGVsLFxuICAgICAgdGVtcGVyYXR1cmU6IG1vZGVsQ29uZmlnLnRlbXBlcmF0dXJlLFxuICAgICAgcHJlc2VuY2VfcGVuYWx0eTogbW9kZWxDb25maWcucHJlc2VuY2VfcGVuYWx0eSxcbiAgICAgIGZyZXF1ZW5jeV9wZW5hbHR5OiBtb2RlbENvbmZpZy5mcmVxdWVuY3lfcGVuYWx0eSxcbiAgICAgIHRvcF9wOiBtb2RlbENvbmZpZy50b3BfcCxcbiAgICAgIC8vIG1heF90b2tlbnM6IE1hdGgubWF4KG1vZGVsQ29uZmlnLm1heF90b2tlbnMsIDEwMjQpLFxuICAgICAgLy8gUGxlYXNlIGRvIG5vdCBhc2sgbWUgd2h5IG5vdCBzZW5kIG1heF90b2tlbnMsIG5vIHJlYXNvbiwgdGhpcyBwYXJhbSBpcyBqdXN0IHNoaXQsIEkgZG9udCB3YW50IHRvIGV4cGxhaW4gYW55bW9yZS5cbiAgICB9O1xuXG4gICAgY29uc29sZS5sb2coXCJbUmVxdWVzdF0gb3BlbmFpIHBheWxvYWQ6IFwiLCByZXF1ZXN0UGF5bG9hZCk7XG5cbiAgICBjb25zdCBzaG91bGRTdHJlYW0gPSAhIW9wdGlvbnMuY29uZmlnLnN0cmVhbTtcbiAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIG9wdGlvbnMub25Db250cm9sbGVyPy4oY29udHJvbGxlcik7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgY2hhdFBhdGggPSB0aGlzLnBhdGgoT3BlbmFpUGF0aC5DaGF0UGF0aCk7XG4gICAgICBjb25zdCBjaGF0UGF5bG9hZCA9IHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocmVxdWVzdFBheWxvYWQpLFxuICAgICAgICBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgICBoZWFkZXJzOiBnZXRIZWFkZXJzKCksXG4gICAgICB9O1xuXG4gICAgICAvLyBtYWtlIGEgZmV0Y2ggcmVxdWVzdFxuICAgICAgY29uc3QgcmVxdWVzdFRpbWVvdXRJZCA9IHNldFRpbWVvdXQoXG4gICAgICAgICgpID0+IGNvbnRyb2xsZXIuYWJvcnQoKSxcbiAgICAgICAgUkVRVUVTVF9USU1FT1VUX01TLFxuICAgICAgKTtcblxuICAgICAgaWYgKHNob3VsZFN0cmVhbSkge1xuICAgICAgICBsZXQgcmVzcG9uc2VUZXh0ID0gXCJcIjtcbiAgICAgICAgbGV0IHJlbWFpblRleHQgPSBcIlwiO1xuICAgICAgICBsZXQgZmluaXNoZWQgPSBmYWxzZTtcblxuICAgICAgICAvLyBhbmltYXRlIHJlc3BvbnNlIHRvIG1ha2UgaXQgbG9va3Mgc21vb3RoXG4gICAgICAgIGZ1bmN0aW9uIGFuaW1hdGVSZXNwb25zZVRleHQoKSB7XG4gICAgICAgICAgaWYgKGZpbmlzaGVkIHx8IGNvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgIHJlc3BvbnNlVGV4dCArPSByZW1haW5UZXh0O1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJbUmVzcG9uc2UgQW5pbWF0aW9uXSBmaW5pc2hlZFwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocmVtYWluVGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBmZXRjaENvdW50ID0gTWF0aC5tYXgoMSwgTWF0aC5yb3VuZChyZW1haW5UZXh0Lmxlbmd0aCAvIDYwKSk7XG4gICAgICAgICAgICBjb25zdCBmZXRjaFRleHQgPSByZW1haW5UZXh0LnNsaWNlKDAsIGZldGNoQ291bnQpO1xuICAgICAgICAgICAgcmVzcG9uc2VUZXh0ICs9IGZldGNoVGV4dDtcbiAgICAgICAgICAgIHJlbWFpblRleHQgPSByZW1haW5UZXh0LnNsaWNlKGZldGNoQ291bnQpO1xuICAgICAgICAgICAgb3B0aW9ucy5vblVwZGF0ZT8uKHJlc3BvbnNlVGV4dCwgZmV0Y2hUZXh0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZVJlc3BvbnNlVGV4dCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzdGFydCBhbmltYWlvblxuICAgICAgICBhbmltYXRlUmVzcG9uc2VUZXh0KCk7XG5cbiAgICAgICAgY29uc3QgZmluaXNoID0gKCkgPT4ge1xuICAgICAgICAgIGlmICghZmluaXNoZWQpIHtcbiAgICAgICAgICAgIGZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIG9wdGlvbnMub25GaW5pc2gocmVzcG9uc2VUZXh0ICsgcmVtYWluVGV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnRyb2xsZXIuc2lnbmFsLm9uYWJvcnQgPSBmaW5pc2g7XG5cbiAgICAgICAgZmV0Y2hFdmVudFNvdXJjZShjaGF0UGF0aCwge1xuICAgICAgICAgIC4uLmNoYXRQYXlsb2FkLFxuICAgICAgICAgIGFzeW5jIG9ub3BlbihyZXMpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChyZXF1ZXN0VGltZW91dElkKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gcmVzLmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgIFwiW09wZW5BSV0gcmVxdWVzdCByZXNwb25zZSBjb250ZW50IHR5cGU6IFwiLFxuICAgICAgICAgICAgICBjb250ZW50VHlwZSxcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGlmIChjb250ZW50VHlwZT8uc3RhcnRzV2l0aChcInRleHQvcGxhaW5cIikpIHtcbiAgICAgICAgICAgICAgcmVzcG9uc2VUZXh0ID0gYXdhaXQgcmVzLmNsb25lKCkudGV4dCgpO1xuICAgICAgICAgICAgICByZXR1cm4gZmluaXNoKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgIXJlcy5vayB8fFxuICAgICAgICAgICAgICAhcmVzLmhlYWRlcnNcbiAgICAgICAgICAgICAgICAuZ2V0KFwiY29udGVudC10eXBlXCIpXG4gICAgICAgICAgICAgICAgPy5zdGFydHNXaXRoKEV2ZW50U3RyZWFtQ29udGVudFR5cGUpIHx8XG4gICAgICAgICAgICAgIHJlcy5zdGF0dXMgIT09IDIwMFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlVGV4dHMgPSBbcmVzcG9uc2VUZXh0XTtcbiAgICAgICAgICAgICAgbGV0IGV4dHJhSW5mbyA9IGF3YWl0IHJlcy5jbG9uZSgpLnRleHQoKTtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNKc29uID0gYXdhaXQgcmVzLmNsb25lKCkuanNvbigpO1xuICAgICAgICAgICAgICAgIGV4dHJhSW5mbyA9IHByZXR0eU9iamVjdChyZXNKc29uKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCB7fVxuXG4gICAgICAgICAgICAgIGlmIChyZXMuc3RhdHVzID09PSA0MDEpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZVRleHRzLnB1c2goTG9jYWxlLkVycm9yLlVuYXV0aG9yaXplZCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoZXh0cmFJbmZvKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VUZXh0cy5wdXNoKGV4dHJhSW5mbyk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXNwb25zZVRleHQgPSByZXNwb25zZVRleHRzLmpvaW4oXCJcXG5cXG5cIik7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIGZpbmlzaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgb25tZXNzYWdlKG1zZykge1xuICAgICAgICAgICAgaWYgKG1zZy5kYXRhID09PSBcIltET05FXVwiIHx8IGZpbmlzaGVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmaW5pc2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSBtc2cuZGF0YTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IGpzb24gPSBKU09OLnBhcnNlKHRleHQpIGFzIHtcbiAgICAgICAgICAgICAgICBjaG9pY2VzOiBBcnJheTx7XG4gICAgICAgICAgICAgICAgICBkZWx0YToge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBzdHJpbmc7XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0+O1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBjb25zdCBkZWx0YSA9IGpzb24uY2hvaWNlc1swXT8uZGVsdGE/LmNvbnRlbnQ7XG4gICAgICAgICAgICAgIGlmIChkZWx0YSkge1xuICAgICAgICAgICAgICAgIHJlbWFpblRleHQgKz0gZGVsdGE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIltSZXF1ZXN0XSBwYXJzZSBlcnJvclwiLCB0ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uY2xvc2UoKSB7XG4gICAgICAgICAgICBmaW5pc2goKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uZXJyb3IoZSkge1xuICAgICAgICAgICAgb3B0aW9ucy5vbkVycm9yPy4oZSk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgb3BlbldoZW5IaWRkZW46IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goY2hhdFBhdGgsIGNoYXRQYXlsb2FkKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHJlcXVlc3RUaW1lb3V0SWQpO1xuXG4gICAgICAgIGNvbnN0IHJlc0pzb24gPSBhd2FpdCByZXMuanNvbigpO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gdGhpcy5leHRyYWN0TWVzc2FnZShyZXNKc29uKTtcbiAgICAgICAgb3B0aW9ucy5vbkZpbmlzaChtZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIltSZXF1ZXN0XSBmYWlsZWQgdG8gbWFrZSBhIGNoYXQgcmVxdWVzdFwiLCBlKTtcbiAgICAgIG9wdGlvbnMub25FcnJvcj8uKGUgYXMgRXJyb3IpO1xuICAgIH1cbiAgfVxuICBhc3luYyB1c2FnZSgpIHtcbiAgICBjb25zdCBmb3JtYXREYXRlID0gKGQ6IERhdGUpID0+XG4gICAgICBgJHtkLmdldEZ1bGxZZWFyKCl9LSR7KGQuZ2V0TW9udGgoKSArIDEpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgXCIwXCIpfS0ke2RcbiAgICAgICAgLmdldERhdGUoKVxuICAgICAgICAudG9TdHJpbmcoKVxuICAgICAgICAucGFkU3RhcnQoMiwgXCIwXCIpfWA7XG4gICAgY29uc3QgT05FX0RBWSA9IDEgKiAyNCAqIDYwICogNjAgKiAxMDAwO1xuICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgY29uc3Qgc3RhcnRPZk1vbnRoID0gbmV3IERhdGUobm93LmdldEZ1bGxZZWFyKCksIG5vdy5nZXRNb250aCgpLCAxKTtcbiAgICBjb25zdCBzdGFydERhdGUgPSBmb3JtYXREYXRlKHN0YXJ0T2ZNb250aCk7XG4gICAgY29uc3QgZW5kRGF0ZSA9IGZvcm1hdERhdGUobmV3IERhdGUoRGF0ZS5ub3coKSArIE9ORV9EQVkpKTtcblxuICAgIGNvbnN0IFt1c2VkLCBzdWJzXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgIGZldGNoKFxuICAgICAgICB0aGlzLnBhdGgoXG4gICAgICAgICAgYCR7T3BlbmFpUGF0aC5Vc2FnZVBhdGh9P3N0YXJ0X2RhdGU9JHtzdGFydERhdGV9JmVuZF9kYXRlPSR7ZW5kRGF0ZX1gLFxuICAgICAgICApLFxuICAgICAgICB7XG4gICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgIGhlYWRlcnM6IGdldEhlYWRlcnMoKSxcbiAgICAgICAgfSxcbiAgICAgICksXG4gICAgICBmZXRjaCh0aGlzLnBhdGgoT3BlbmFpUGF0aC5TdWJzUGF0aCksIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICBoZWFkZXJzOiBnZXRIZWFkZXJzKCksXG4gICAgICB9KSxcbiAgICBdKTtcblxuICAgIGlmICh1c2VkLnN0YXR1cyA9PT0gNDAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoTG9jYWxlLkVycm9yLlVuYXV0aG9yaXplZCk7XG4gICAgfVxuXG4gICAgaWYgKCF1c2VkLm9rIHx8ICFzdWJzLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gcXVlcnkgdXNhZ2UgZnJvbSBvcGVuYWlcIik7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzcG9uc2UgPSAoYXdhaXQgdXNlZC5qc29uKCkpIGFzIHtcbiAgICAgIHRvdGFsX3VzYWdlPzogbnVtYmVyO1xuICAgICAgZXJyb3I/OiB7XG4gICAgICAgIHR5cGU6IHN0cmluZztcbiAgICAgICAgbWVzc2FnZTogc3RyaW5nO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgY29uc3QgdG90YWwgPSAoYXdhaXQgc3Vicy5qc29uKCkpIGFzIHtcbiAgICAgIGhhcmRfbGltaXRfdXNkPzogbnVtYmVyO1xuICAgIH07XG5cbiAgICBpZiAocmVzcG9uc2UuZXJyb3IgJiYgcmVzcG9uc2UuZXJyb3IudHlwZSkge1xuICAgICAgdGhyb3cgRXJyb3IocmVzcG9uc2UuZXJyb3IubWVzc2FnZSk7XG4gICAgfVxuXG4gICAgaWYgKHJlc3BvbnNlLnRvdGFsX3VzYWdlKSB7XG4gICAgICByZXNwb25zZS50b3RhbF91c2FnZSA9IE1hdGgucm91bmQocmVzcG9uc2UudG90YWxfdXNhZ2UpIC8gMTAwO1xuICAgIH1cblxuICAgIGlmICh0b3RhbC5oYXJkX2xpbWl0X3VzZCkge1xuICAgICAgdG90YWwuaGFyZF9saW1pdF91c2QgPSBNYXRoLnJvdW5kKHRvdGFsLmhhcmRfbGltaXRfdXNkICogMTAwKSAvIDEwMDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdXNlZDogcmVzcG9uc2UudG90YWxfdXNhZ2UsXG4gICAgICB0b3RhbDogdG90YWwuaGFyZF9saW1pdF91c2QsXG4gICAgfSBhcyBMTE1Vc2FnZTtcbiAgfVxuXG4gIGFzeW5jIG1vZGVscygpOiBQcm9taXNlPExMTU1vZGVsW10+IHtcbiAgICBpZiAodGhpcy5kaXNhYmxlTGlzdE1vZGVscykge1xuICAgICAgcmV0dXJuIERFRkFVTFRfTU9ERUxTLnNsaWNlKCk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2godGhpcy5wYXRoKE9wZW5haVBhdGguTGlzdE1vZGVsUGF0aCksIHtcbiAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgLi4uZ2V0SGVhZGVycygpLFxuICAgICAgfSxcbiAgICB9KTtcblxuICAgIGNvbnN0IHJlc0pzb24gPSAoYXdhaXQgcmVzLmpzb24oKSkgYXMgT3BlbkFJTGlzdE1vZGVsUmVzcG9uc2U7XG4gICAgY29uc3QgY2hhdE1vZGVscyA9IHJlc0pzb24uZGF0YT8uZmlsdGVyKChtKSA9PiBtLmlkLnN0YXJ0c1dpdGgoXCJncHQtXCIpKTtcbiAgICBjb25zb2xlLmxvZyhcIltNb2RlbHNdXCIsIGNoYXRNb2RlbHMpO1xuXG4gICAgaWYgKCFjaGF0TW9kZWxzKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoYXRNb2RlbHMubWFwKChtKSA9PiAoe1xuICAgICAgbmFtZTogbS5pZCxcbiAgICAgIGF2YWlsYWJsZTogdHJ1ZSxcbiAgICB9KSk7XG4gIH1cbn1cbmV4cG9ydCB7IE9wZW5haVBhdGggfTtcbiJdLCJuYW1lcyI6WyJBcGlQYXRoIiwiREVGQVVMVF9BUElfSE9TVCIsIkRFRkFVTFRfTU9ERUxTIiwiT3BlbmFpUGF0aCIsIlJFUVVFU1RfVElNRU9VVF9NUyIsIlNlcnZpY2VQcm92aWRlciIsInVzZUFjY2Vzc1N0b3JlIiwidXNlQXBwQ29uZmlnIiwidXNlQ2hhdFN0b3JlIiwiZ2V0SGVhZGVycyIsIkxvY2FsZSIsIkV2ZW50U3RyZWFtQ29udGVudFR5cGUiLCJmZXRjaEV2ZW50U291cmNlIiwicHJldHR5T2JqZWN0IiwiZ2V0Q2xpZW50Q29uZmlnIiwibWFrZUF6dXJlUGF0aCIsIkNoYXRHUFRBcGkiLCJwYXRoIiwiYWNjZXNzU3RvcmUiLCJnZXRTdGF0ZSIsImlzQXp1cmUiLCJwcm92aWRlciIsIkF6dXJlIiwiaXNWYWxpZEF6dXJlIiwiRXJyb3IiLCJiYXNlVXJsIiwiYXp1cmVVcmwiLCJvcGVuYWlVcmwiLCJsZW5ndGgiLCJpc0FwcCIsIk9wZW5BSSIsImVuZHNXaXRoIiwic2xpY2UiLCJzdGFydHNXaXRoIiwiYXp1cmVBcGlWZXJzaW9uIiwiam9pbiIsImV4dHJhY3RNZXNzYWdlIiwicmVzIiwiY2hvaWNlcyIsImF0IiwibWVzc2FnZSIsImNvbnRlbnQiLCJjaGF0Iiwib3B0aW9ucyIsIm1lc3NhZ2VzIiwibWFwIiwidiIsInJvbGUiLCJtb2RlbENvbmZpZyIsImN1cnJlbnRTZXNzaW9uIiwibWFzayIsIm1vZGVsIiwiY29uZmlnIiwicmVxdWVzdFBheWxvYWQiLCJzdHJlYW0iLCJ0ZW1wZXJhdHVyZSIsInByZXNlbmNlX3BlbmFsdHkiLCJmcmVxdWVuY3lfcGVuYWx0eSIsInRvcF9wIiwiY29uc29sZSIsImxvZyIsInNob3VsZFN0cmVhbSIsImNvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXIiLCJvbkNvbnRyb2xsZXIiLCJjaGF0UGF0aCIsIkNoYXRQYXRoIiwiY2hhdFBheWxvYWQiLCJtZXRob2QiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsInNpZ25hbCIsImhlYWRlcnMiLCJyZXF1ZXN0VGltZW91dElkIiwic2V0VGltZW91dCIsImFib3J0IiwicmVzcG9uc2VUZXh0IiwicmVtYWluVGV4dCIsImZpbmlzaGVkIiwiYW5pbWF0ZVJlc3BvbnNlVGV4dCIsImFib3J0ZWQiLCJmZXRjaENvdW50IiwiTWF0aCIsIm1heCIsInJvdW5kIiwiZmV0Y2hUZXh0Iiwib25VcGRhdGUiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJmaW5pc2giLCJvbkZpbmlzaCIsIm9uYWJvcnQiLCJvbm9wZW4iLCJjb250ZW50VHlwZSIsImNsZWFyVGltZW91dCIsImdldCIsImNsb25lIiwidGV4dCIsIm9rIiwic3RhdHVzIiwicmVzcG9uc2VUZXh0cyIsImV4dHJhSW5mbyIsInJlc0pzb24iLCJqc29uIiwicHVzaCIsIlVuYXV0aG9yaXplZCIsIm9ubWVzc2FnZSIsIm1zZyIsImRhdGEiLCJwYXJzZSIsImRlbHRhIiwiZSIsImVycm9yIiwib25jbG9zZSIsIm9uZXJyb3IiLCJvbkVycm9yIiwib3BlbldoZW5IaWRkZW4iLCJmZXRjaCIsInVzYWdlIiwiZm9ybWF0RGF0ZSIsImQiLCJnZXRGdWxsWWVhciIsImdldE1vbnRoIiwidG9TdHJpbmciLCJwYWRTdGFydCIsImdldERhdGUiLCJPTkVfREFZIiwibm93IiwiRGF0ZSIsInN0YXJ0T2ZNb250aCIsInN0YXJ0RGF0ZSIsImVuZERhdGUiLCJ1c2VkIiwic3VicyIsIlByb21pc2UiLCJhbGwiLCJVc2FnZVBhdGgiLCJTdWJzUGF0aCIsInJlc3BvbnNlIiwidG90YWwiLCJ0eXBlIiwidG90YWxfdXNhZ2UiLCJoYXJkX2xpbWl0X3VzZCIsIm1vZGVscyIsImRpc2FibGVMaXN0TW9kZWxzIiwiTGlzdE1vZGVsUGF0aCIsImNoYXRNb2RlbHMiLCJmaWx0ZXIiLCJtIiwiaWQiLCJuYW1lIiwiYXZhaWxhYmxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./app/client/platforms/openai.ts\n"));

/***/ })

});