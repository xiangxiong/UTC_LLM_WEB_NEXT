/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-client_node_modules_mermaid_dist_mindmap-definition-617cf8dd_js"],{

/***/ "(app-client)/./node_modules/cose-base/cose-base.js":
/*!*********************************************!*\
  !*** ./node_modules/cose-base/cose-base.js ***!
  \*********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory(__webpack_require__(/*! layout-base */ \"(app-client)/./node_modules/layout-base/layout-base.js\"));\n\telse {}\n})(this, function(__WEBPACK_EXTERNAL_MODULE_0__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_643__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_643__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__nested_webpack_require_643__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__nested_webpack_require_643__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__nested_webpack_require_643__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__nested_webpack_require_643__.d = function(exports, name, getter) {\n/******/ \t\tif(!__nested_webpack_require_643__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__nested_webpack_require_643__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__nested_webpack_require_643__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__nested_webpack_require_643__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__nested_webpack_require_643__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __nested_webpack_require_643__(__nested_webpack_require_643__.s = 7);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __nested_webpack_require_3185__) {\n\n\"use strict\";\n\n\nvar FDLayoutConstants = __nested_webpack_require_3185__(0).FDLayoutConstants;\n\nfunction CoSEConstants() {}\n\n//CoSEConstants inherits static props in FDLayoutConstants\nfor (var prop in FDLayoutConstants) {\n  CoSEConstants[prop] = FDLayoutConstants[prop];\n}\n\nCoSEConstants.DEFAULT_USE_MULTI_LEVEL_SCALING = false;\nCoSEConstants.DEFAULT_RADIAL_SEPARATION = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\nCoSEConstants.DEFAULT_COMPONENT_SEPERATION = 60;\nCoSEConstants.TILE = true;\nCoSEConstants.TILING_PADDING_VERTICAL = 10;\nCoSEConstants.TILING_PADDING_HORIZONTAL = 10;\nCoSEConstants.TREE_REDUCTION_ON_INCREMENTAL = false; // make this true when cose is used incrementally as a part of other non-incremental layout\n\nmodule.exports = CoSEConstants;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __nested_webpack_require_4002__) {\n\n\"use strict\";\n\n\nvar FDLayoutEdge = __nested_webpack_require_4002__(0).FDLayoutEdge;\n\nfunction CoSEEdge(source, target, vEdge) {\n  FDLayoutEdge.call(this, source, target, vEdge);\n}\n\nCoSEEdge.prototype = Object.create(FDLayoutEdge.prototype);\nfor (var prop in FDLayoutEdge) {\n  CoSEEdge[prop] = FDLayoutEdge[prop];\n}\n\nmodule.exports = CoSEEdge;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __nested_webpack_require_4409__) {\n\n\"use strict\";\n\n\nvar LGraph = __nested_webpack_require_4409__(0).LGraph;\n\nfunction CoSEGraph(parent, graphMgr, vGraph) {\n  LGraph.call(this, parent, graphMgr, vGraph);\n}\n\nCoSEGraph.prototype = Object.create(LGraph.prototype);\nfor (var prop in LGraph) {\n  CoSEGraph[prop] = LGraph[prop];\n}\n\nmodule.exports = CoSEGraph;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __nested_webpack_require_4790__) {\n\n\"use strict\";\n\n\nvar LGraphManager = __nested_webpack_require_4790__(0).LGraphManager;\n\nfunction CoSEGraphManager(layout) {\n  LGraphManager.call(this, layout);\n}\n\nCoSEGraphManager.prototype = Object.create(LGraphManager.prototype);\nfor (var prop in LGraphManager) {\n  CoSEGraphManager[prop] = LGraphManager[prop];\n}\n\nmodule.exports = CoSEGraphManager;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __nested_webpack_require_5205__) {\n\n\"use strict\";\n\n\nvar FDLayoutNode = __nested_webpack_require_5205__(0).FDLayoutNode;\nvar IMath = __nested_webpack_require_5205__(0).IMath;\n\nfunction CoSENode(gm, loc, size, vNode) {\n  FDLayoutNode.call(this, gm, loc, size, vNode);\n}\n\nCoSENode.prototype = Object.create(FDLayoutNode.prototype);\nfor (var prop in FDLayoutNode) {\n  CoSENode[prop] = FDLayoutNode[prop];\n}\n\nCoSENode.prototype.move = function () {\n  var layout = this.graphManager.getLayout();\n  this.displacementX = layout.coolingFactor * (this.springForceX + this.repulsionForceX + this.gravitationForceX) / this.noOfChildren;\n  this.displacementY = layout.coolingFactor * (this.springForceY + this.repulsionForceY + this.gravitationForceY) / this.noOfChildren;\n\n  if (Math.abs(this.displacementX) > layout.coolingFactor * layout.maxNodeDisplacement) {\n    this.displacementX = layout.coolingFactor * layout.maxNodeDisplacement * IMath.sign(this.displacementX);\n  }\n\n  if (Math.abs(this.displacementY) > layout.coolingFactor * layout.maxNodeDisplacement) {\n    this.displacementY = layout.coolingFactor * layout.maxNodeDisplacement * IMath.sign(this.displacementY);\n  }\n\n  // a simple node, just move it\n  if (this.child == null) {\n    this.moveBy(this.displacementX, this.displacementY);\n  }\n  // an empty compound node, again just move it\n  else if (this.child.getNodes().length == 0) {\n      this.moveBy(this.displacementX, this.displacementY);\n    }\n    // non-empty compound node, propogate movement to children as well\n    else {\n        this.propogateDisplacementToChildren(this.displacementX, this.displacementY);\n      }\n\n  layout.totalDisplacement += Math.abs(this.displacementX) + Math.abs(this.displacementY);\n\n  this.springForceX = 0;\n  this.springForceY = 0;\n  this.repulsionForceX = 0;\n  this.repulsionForceY = 0;\n  this.gravitationForceX = 0;\n  this.gravitationForceY = 0;\n  this.displacementX = 0;\n  this.displacementY = 0;\n};\n\nCoSENode.prototype.propogateDisplacementToChildren = function (dX, dY) {\n  var nodes = this.getChild().getNodes();\n  var node;\n  for (var i = 0; i < nodes.length; i++) {\n    node = nodes[i];\n    if (node.getChild() == null) {\n      node.moveBy(dX, dY);\n      node.displacementX += dX;\n      node.displacementY += dY;\n    } else {\n      node.propogateDisplacementToChildren(dX, dY);\n    }\n  }\n};\n\nCoSENode.prototype.setPred1 = function (pred1) {\n  this.pred1 = pred1;\n};\n\nCoSENode.prototype.getPred1 = function () {\n  return pred1;\n};\n\nCoSENode.prototype.getPred2 = function () {\n  return pred2;\n};\n\nCoSENode.prototype.setNext = function (next) {\n  this.next = next;\n};\n\nCoSENode.prototype.getNext = function () {\n  return next;\n};\n\nCoSENode.prototype.setProcessed = function (processed) {\n  this.processed = processed;\n};\n\nCoSENode.prototype.isProcessed = function () {\n  return processed;\n};\n\nmodule.exports = CoSENode;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __nested_webpack_require_8085__) {\n\n\"use strict\";\n\n\nvar FDLayout = __nested_webpack_require_8085__(0).FDLayout;\nvar CoSEGraphManager = __nested_webpack_require_8085__(4);\nvar CoSEGraph = __nested_webpack_require_8085__(3);\nvar CoSENode = __nested_webpack_require_8085__(5);\nvar CoSEEdge = __nested_webpack_require_8085__(2);\nvar CoSEConstants = __nested_webpack_require_8085__(1);\nvar FDLayoutConstants = __nested_webpack_require_8085__(0).FDLayoutConstants;\nvar LayoutConstants = __nested_webpack_require_8085__(0).LayoutConstants;\nvar Point = __nested_webpack_require_8085__(0).Point;\nvar PointD = __nested_webpack_require_8085__(0).PointD;\nvar Layout = __nested_webpack_require_8085__(0).Layout;\nvar Integer = __nested_webpack_require_8085__(0).Integer;\nvar IGeometry = __nested_webpack_require_8085__(0).IGeometry;\nvar LGraph = __nested_webpack_require_8085__(0).LGraph;\nvar Transform = __nested_webpack_require_8085__(0).Transform;\n\nfunction CoSELayout() {\n  FDLayout.call(this);\n\n  this.toBeTiled = {}; // Memorize if a node is to be tiled or is tiled\n}\n\nCoSELayout.prototype = Object.create(FDLayout.prototype);\n\nfor (var prop in FDLayout) {\n  CoSELayout[prop] = FDLayout[prop];\n}\n\nCoSELayout.prototype.newGraphManager = function () {\n  var gm = new CoSEGraphManager(this);\n  this.graphManager = gm;\n  return gm;\n};\n\nCoSELayout.prototype.newGraph = function (vGraph) {\n  return new CoSEGraph(null, this.graphManager, vGraph);\n};\n\nCoSELayout.prototype.newNode = function (vNode) {\n  return new CoSENode(this.graphManager, vNode);\n};\n\nCoSELayout.prototype.newEdge = function (vEdge) {\n  return new CoSEEdge(null, null, vEdge);\n};\n\nCoSELayout.prototype.initParameters = function () {\n  FDLayout.prototype.initParameters.call(this, arguments);\n  if (!this.isSubLayout) {\n    if (CoSEConstants.DEFAULT_EDGE_LENGTH < 10) {\n      this.idealEdgeLength = 10;\n    } else {\n      this.idealEdgeLength = CoSEConstants.DEFAULT_EDGE_LENGTH;\n    }\n\n    this.useSmartIdealEdgeLengthCalculation = CoSEConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION;\n    this.springConstant = FDLayoutConstants.DEFAULT_SPRING_STRENGTH;\n    this.repulsionConstant = FDLayoutConstants.DEFAULT_REPULSION_STRENGTH;\n    this.gravityConstant = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH;\n    this.compoundGravityConstant = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH;\n    this.gravityRangeFactor = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR;\n    this.compoundGravityRangeFactor = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR;\n\n    // variables for tree reduction support\n    this.prunedNodesAll = [];\n    this.growTreeIterations = 0;\n    this.afterGrowthIterations = 0;\n    this.isTreeGrowing = false;\n    this.isGrowthFinished = false;\n\n    // variables for cooling\n    this.coolingCycle = 0;\n    this.maxCoolingCycle = this.maxIterations / FDLayoutConstants.CONVERGENCE_CHECK_PERIOD;\n    this.finalTemperature = FDLayoutConstants.CONVERGENCE_CHECK_PERIOD / this.maxIterations;\n    this.coolingAdjuster = 1;\n  }\n};\n\nCoSELayout.prototype.layout = function () {\n  var createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\n  if (createBendsAsNeeded) {\n    this.createBendpoints();\n    this.graphManager.resetAllEdges();\n  }\n\n  this.level = 0;\n  return this.classicLayout();\n};\n\nCoSELayout.prototype.classicLayout = function () {\n  this.nodesWithGravity = this.calculateNodesToApplyGravitationTo();\n  this.graphManager.setAllNodesToApplyGravitation(this.nodesWithGravity);\n  this.calcNoOfChildrenForAllNodes();\n  this.graphManager.calcLowestCommonAncestors();\n  this.graphManager.calcInclusionTreeDepths();\n  this.graphManager.getRoot().calcEstimatedSize();\n  this.calcIdealEdgeLengths();\n\n  if (!this.incremental) {\n    var forest = this.getFlatForest();\n\n    // The graph associated with this layout is flat and a forest\n    if (forest.length > 0) {\n      this.positionNodesRadially(forest);\n    }\n    // The graph associated with this layout is not flat or a forest\n    else {\n        // Reduce the trees when incremental mode is not enabled and graph is not a forest \n        this.reduceTrees();\n        // Update nodes that gravity will be applied\n        this.graphManager.resetAllNodesToApplyGravitation();\n        var allNodes = new Set(this.getAllNodes());\n        var intersection = this.nodesWithGravity.filter(function (x) {\n          return allNodes.has(x);\n        });\n        this.graphManager.setAllNodesToApplyGravitation(intersection);\n\n        this.positionNodesRandomly();\n      }\n  } else {\n    if (CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL) {\n      // Reduce the trees in incremental mode if only this constant is set to true \n      this.reduceTrees();\n      // Update nodes that gravity will be applied\n      this.graphManager.resetAllNodesToApplyGravitation();\n      var allNodes = new Set(this.getAllNodes());\n      var intersection = this.nodesWithGravity.filter(function (x) {\n        return allNodes.has(x);\n      });\n      this.graphManager.setAllNodesToApplyGravitation(intersection);\n    }\n  }\n\n  this.initSpringEmbedder();\n  this.runSpringEmbedder();\n\n  return true;\n};\n\nCoSELayout.prototype.tick = function () {\n  this.totalIterations++;\n\n  if (this.totalIterations === this.maxIterations && !this.isTreeGrowing && !this.isGrowthFinished) {\n    if (this.prunedNodesAll.length > 0) {\n      this.isTreeGrowing = true;\n    } else {\n      return true;\n    }\n  }\n\n  if (this.totalIterations % FDLayoutConstants.CONVERGENCE_CHECK_PERIOD == 0 && !this.isTreeGrowing && !this.isGrowthFinished) {\n    if (this.isConverged()) {\n      if (this.prunedNodesAll.length > 0) {\n        this.isTreeGrowing = true;\n      } else {\n        return true;\n      }\n    }\n\n    this.coolingCycle++;\n\n    if (this.layoutQuality == 0) {\n      // quality - \"draft\"\n      this.coolingAdjuster = this.coolingCycle;\n    } else if (this.layoutQuality == 1) {\n      // quality - \"default\"\n      this.coolingAdjuster = this.coolingCycle / 3;\n    }\n\n    // cooling schedule is based on http://www.btluke.com/simanf1.html -> cooling schedule 3\n    this.coolingFactor = Math.max(this.initialCoolingFactor - Math.pow(this.coolingCycle, Math.log(100 * (this.initialCoolingFactor - this.finalTemperature)) / Math.log(this.maxCoolingCycle)) / 100 * this.coolingAdjuster, this.finalTemperature);\n    this.animationPeriod = Math.ceil(this.initialAnimationPeriod * Math.sqrt(this.coolingFactor));\n  }\n  // Operations while tree is growing again \n  if (this.isTreeGrowing) {\n    if (this.growTreeIterations % 10 == 0) {\n      if (this.prunedNodesAll.length > 0) {\n        this.graphManager.updateBounds();\n        this.updateGrid();\n        this.growTree(this.prunedNodesAll);\n        // Update nodes that gravity will be applied\n        this.graphManager.resetAllNodesToApplyGravitation();\n        var allNodes = new Set(this.getAllNodes());\n        var intersection = this.nodesWithGravity.filter(function (x) {\n          return allNodes.has(x);\n        });\n        this.graphManager.setAllNodesToApplyGravitation(intersection);\n\n        this.graphManager.updateBounds();\n        this.updateGrid();\n        this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;\n      } else {\n        this.isTreeGrowing = false;\n        this.isGrowthFinished = true;\n      }\n    }\n    this.growTreeIterations++;\n  }\n  // Operations after growth is finished\n  if (this.isGrowthFinished) {\n    if (this.isConverged()) {\n      return true;\n    }\n    if (this.afterGrowthIterations % 10 == 0) {\n      this.graphManager.updateBounds();\n      this.updateGrid();\n    }\n    this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL * ((100 - this.afterGrowthIterations) / 100);\n    this.afterGrowthIterations++;\n  }\n\n  var gridUpdateAllowed = !this.isTreeGrowing && !this.isGrowthFinished;\n  var forceToNodeSurroundingUpdate = this.growTreeIterations % 10 == 1 && this.isTreeGrowing || this.afterGrowthIterations % 10 == 1 && this.isGrowthFinished;\n\n  this.totalDisplacement = 0;\n  this.graphManager.updateBounds();\n  this.calcSpringForces();\n  this.calcRepulsionForces(gridUpdateAllowed, forceToNodeSurroundingUpdate);\n  this.calcGravitationalForces();\n  this.moveNodes();\n  this.animate();\n\n  return false; // Layout is not ended yet return false\n};\n\nCoSELayout.prototype.getPositionsData = function () {\n  var allNodes = this.graphManager.getAllNodes();\n  var pData = {};\n  for (var i = 0; i < allNodes.length; i++) {\n    var rect = allNodes[i].rect;\n    var id = allNodes[i].id;\n    pData[id] = {\n      id: id,\n      x: rect.getCenterX(),\n      y: rect.getCenterY(),\n      w: rect.width,\n      h: rect.height\n    };\n  }\n\n  return pData;\n};\n\nCoSELayout.prototype.runSpringEmbedder = function () {\n  this.initialAnimationPeriod = 25;\n  this.animationPeriod = this.initialAnimationPeriod;\n  var layoutEnded = false;\n\n  // If aminate option is 'during' signal that layout is supposed to start iterating\n  if (FDLayoutConstants.ANIMATE === 'during') {\n    this.emit('layoutstarted');\n  } else {\n    // If aminate option is 'during' tick() function will be called on index.js\n    while (!layoutEnded) {\n      layoutEnded = this.tick();\n    }\n\n    this.graphManager.updateBounds();\n  }\n};\n\nCoSELayout.prototype.calculateNodesToApplyGravitationTo = function () {\n  var nodeList = [];\n  var graph;\n\n  var graphs = this.graphManager.getGraphs();\n  var size = graphs.length;\n  var i;\n  for (i = 0; i < size; i++) {\n    graph = graphs[i];\n\n    graph.updateConnected();\n\n    if (!graph.isConnected) {\n      nodeList = nodeList.concat(graph.getNodes());\n    }\n  }\n\n  return nodeList;\n};\n\nCoSELayout.prototype.createBendpoints = function () {\n  var edges = [];\n  edges = edges.concat(this.graphManager.getAllEdges());\n  var visited = new Set();\n  var i;\n  for (i = 0; i < edges.length; i++) {\n    var edge = edges[i];\n\n    if (!visited.has(edge)) {\n      var source = edge.getSource();\n      var target = edge.getTarget();\n\n      if (source == target) {\n        edge.getBendpoints().push(new PointD());\n        edge.getBendpoints().push(new PointD());\n        this.createDummyNodesForBendpoints(edge);\n        visited.add(edge);\n      } else {\n        var edgeList = [];\n\n        edgeList = edgeList.concat(source.getEdgeListToNode(target));\n        edgeList = edgeList.concat(target.getEdgeListToNode(source));\n\n        if (!visited.has(edgeList[0])) {\n          if (edgeList.length > 1) {\n            var k;\n            for (k = 0; k < edgeList.length; k++) {\n              var multiEdge = edgeList[k];\n              multiEdge.getBendpoints().push(new PointD());\n              this.createDummyNodesForBendpoints(multiEdge);\n            }\n          }\n          edgeList.forEach(function (edge) {\n            visited.add(edge);\n          });\n        }\n      }\n    }\n\n    if (visited.size == edges.length) {\n      break;\n    }\n  }\n};\n\nCoSELayout.prototype.positionNodesRadially = function (forest) {\n  // We tile the trees to a grid row by row; first tree starts at (0,0)\n  var currentStartingPoint = new Point(0, 0);\n  var numberOfColumns = Math.ceil(Math.sqrt(forest.length));\n  var height = 0;\n  var currentY = 0;\n  var currentX = 0;\n  var point = new PointD(0, 0);\n\n  for (var i = 0; i < forest.length; i++) {\n    if (i % numberOfColumns == 0) {\n      // Start of a new row, make the x coordinate 0, increment the\n      // y coordinate with the max height of the previous row\n      currentX = 0;\n      currentY = height;\n\n      if (i != 0) {\n        currentY += CoSEConstants.DEFAULT_COMPONENT_SEPERATION;\n      }\n\n      height = 0;\n    }\n\n    var tree = forest[i];\n\n    // Find the center of the tree\n    var centerNode = Layout.findCenterOfTree(tree);\n\n    // Set the staring point of the next tree\n    currentStartingPoint.x = currentX;\n    currentStartingPoint.y = currentY;\n\n    // Do a radial layout starting with the center\n    point = CoSELayout.radialLayout(tree, centerNode, currentStartingPoint);\n\n    if (point.y > height) {\n      height = Math.floor(point.y);\n    }\n\n    currentX = Math.floor(point.x + CoSEConstants.DEFAULT_COMPONENT_SEPERATION);\n  }\n\n  this.transform(new PointD(LayoutConstants.WORLD_CENTER_X - point.x / 2, LayoutConstants.WORLD_CENTER_Y - point.y / 2));\n};\n\nCoSELayout.radialLayout = function (tree, centerNode, startingPoint) {\n  var radialSep = Math.max(this.maxDiagonalInTree(tree), CoSEConstants.DEFAULT_RADIAL_SEPARATION);\n  CoSELayout.branchRadialLayout(centerNode, null, 0, 359, 0, radialSep);\n  var bounds = LGraph.calculateBounds(tree);\n\n  var transform = new Transform();\n  transform.setDeviceOrgX(bounds.getMinX());\n  transform.setDeviceOrgY(bounds.getMinY());\n  transform.setWorldOrgX(startingPoint.x);\n  transform.setWorldOrgY(startingPoint.y);\n\n  for (var i = 0; i < tree.length; i++) {\n    var node = tree[i];\n    node.transform(transform);\n  }\n\n  var bottomRight = new PointD(bounds.getMaxX(), bounds.getMaxY());\n\n  return transform.inverseTransformPoint(bottomRight);\n};\n\nCoSELayout.branchRadialLayout = function (node, parentOfNode, startAngle, endAngle, distance, radialSeparation) {\n  // First, position this node by finding its angle.\n  var halfInterval = (endAngle - startAngle + 1) / 2;\n\n  if (halfInterval < 0) {\n    halfInterval += 180;\n  }\n\n  var nodeAngle = (halfInterval + startAngle) % 360;\n  var teta = nodeAngle * IGeometry.TWO_PI / 360;\n\n  // Make polar to java cordinate conversion.\n  var cos_teta = Math.cos(teta);\n  var x_ = distance * Math.cos(teta);\n  var y_ = distance * Math.sin(teta);\n\n  node.setCenter(x_, y_);\n\n  // Traverse all neighbors of this node and recursively call this\n  // function.\n  var neighborEdges = [];\n  neighborEdges = neighborEdges.concat(node.getEdges());\n  var childCount = neighborEdges.length;\n\n  if (parentOfNode != null) {\n    childCount--;\n  }\n\n  var branchCount = 0;\n\n  var incEdgesCount = neighborEdges.length;\n  var startIndex;\n\n  var edges = node.getEdgesBetween(parentOfNode);\n\n  // If there are multiple edges, prune them until there remains only one\n  // edge.\n  while (edges.length > 1) {\n    //neighborEdges.remove(edges.remove(0));\n    var temp = edges[0];\n    edges.splice(0, 1);\n    var index = neighborEdges.indexOf(temp);\n    if (index >= 0) {\n      neighborEdges.splice(index, 1);\n    }\n    incEdgesCount--;\n    childCount--;\n  }\n\n  if (parentOfNode != null) {\n    //assert edges.length == 1;\n    startIndex = (neighborEdges.indexOf(edges[0]) + 1) % incEdgesCount;\n  } else {\n    startIndex = 0;\n  }\n\n  var stepAngle = Math.abs(endAngle - startAngle) / childCount;\n\n  for (var i = startIndex; branchCount != childCount; i = ++i % incEdgesCount) {\n    var currentNeighbor = neighborEdges[i].getOtherEnd(node);\n\n    // Don't back traverse to root node in current tree.\n    if (currentNeighbor == parentOfNode) {\n      continue;\n    }\n\n    var childStartAngle = (startAngle + branchCount * stepAngle) % 360;\n    var childEndAngle = (childStartAngle + stepAngle) % 360;\n\n    CoSELayout.branchRadialLayout(currentNeighbor, node, childStartAngle, childEndAngle, distance + radialSeparation, radialSeparation);\n\n    branchCount++;\n  }\n};\n\nCoSELayout.maxDiagonalInTree = function (tree) {\n  var maxDiagonal = Integer.MIN_VALUE;\n\n  for (var i = 0; i < tree.length; i++) {\n    var node = tree[i];\n    var diagonal = node.getDiagonal();\n\n    if (diagonal > maxDiagonal) {\n      maxDiagonal = diagonal;\n    }\n  }\n\n  return maxDiagonal;\n};\n\nCoSELayout.prototype.calcRepulsionRange = function () {\n  // formula is 2 x (level + 1) x idealEdgeLength\n  return 2 * (this.level + 1) * this.idealEdgeLength;\n};\n\n// Tiling methods\n\n// Group zero degree members whose parents are not to be tiled, create dummy parents where needed and fill memberGroups by their dummp parent id's\nCoSELayout.prototype.groupZeroDegreeMembers = function () {\n  var self = this;\n  // array of [parent_id x oneDegreeNode_id]\n  var tempMemberGroups = {}; // A temporary map of parent node and its zero degree members\n  this.memberGroups = {}; // A map of dummy parent node and its zero degree members whose parents are not to be tiled\n  this.idToDummyNode = {}; // A map of id to dummy node \n\n  var zeroDegree = []; // List of zero degree nodes whose parents are not to be tiled\n  var allNodes = this.graphManager.getAllNodes();\n\n  // Fill zero degree list\n  for (var i = 0; i < allNodes.length; i++) {\n    var node = allNodes[i];\n    var parent = node.getParent();\n    // If a node has zero degree and its parent is not to be tiled if exists add that node to zeroDegres list\n    if (this.getNodeDegreeWithChildren(node) === 0 && (parent.id == undefined || !this.getToBeTiled(parent))) {\n      zeroDegree.push(node);\n    }\n  }\n\n  // Create a map of parent node and its zero degree members\n  for (var i = 0; i < zeroDegree.length; i++) {\n    var node = zeroDegree[i]; // Zero degree node itself\n    var p_id = node.getParent().id; // Parent id\n\n    if (typeof tempMemberGroups[p_id] === \"undefined\") tempMemberGroups[p_id] = [];\n\n    tempMemberGroups[p_id] = tempMemberGroups[p_id].concat(node); // Push node to the list belongs to its parent in tempMemberGroups\n  }\n\n  // If there are at least two nodes at a level, create a dummy compound for them\n  Object.keys(tempMemberGroups).forEach(function (p_id) {\n    if (tempMemberGroups[p_id].length > 1) {\n      var dummyCompoundId = \"DummyCompound_\" + p_id; // The id of dummy compound which will be created soon\n      self.memberGroups[dummyCompoundId] = tempMemberGroups[p_id]; // Add dummy compound to memberGroups\n\n      var parent = tempMemberGroups[p_id][0].getParent(); // The parent of zero degree nodes will be the parent of new dummy compound\n\n      // Create a dummy compound with calculated id\n      var dummyCompound = new CoSENode(self.graphManager);\n      dummyCompound.id = dummyCompoundId;\n      dummyCompound.paddingLeft = parent.paddingLeft || 0;\n      dummyCompound.paddingRight = parent.paddingRight || 0;\n      dummyCompound.paddingBottom = parent.paddingBottom || 0;\n      dummyCompound.paddingTop = parent.paddingTop || 0;\n\n      self.idToDummyNode[dummyCompoundId] = dummyCompound;\n\n      var dummyParentGraph = self.getGraphManager().add(self.newGraph(), dummyCompound);\n      var parentGraph = parent.getChild();\n\n      // Add dummy compound to parent the graph\n      parentGraph.add(dummyCompound);\n\n      // For each zero degree node in this level remove it from its parent graph and add it to the graph of dummy parent\n      for (var i = 0; i < tempMemberGroups[p_id].length; i++) {\n        var node = tempMemberGroups[p_id][i];\n\n        parentGraph.remove(node);\n        dummyParentGraph.add(node);\n      }\n    }\n  });\n};\n\nCoSELayout.prototype.clearCompounds = function () {\n  var childGraphMap = {};\n  var idToNode = {};\n\n  // Get compound ordering by finding the inner one first\n  this.performDFSOnCompounds();\n\n  for (var i = 0; i < this.compoundOrder.length; i++) {\n\n    idToNode[this.compoundOrder[i].id] = this.compoundOrder[i];\n    childGraphMap[this.compoundOrder[i].id] = [].concat(this.compoundOrder[i].getChild().getNodes());\n\n    // Remove children of compounds\n    this.graphManager.remove(this.compoundOrder[i].getChild());\n    this.compoundOrder[i].child = null;\n  }\n\n  this.graphManager.resetAllNodes();\n\n  // Tile the removed children\n  this.tileCompoundMembers(childGraphMap, idToNode);\n};\n\nCoSELayout.prototype.clearZeroDegreeMembers = function () {\n  var self = this;\n  var tiledZeroDegreePack = this.tiledZeroDegreePack = [];\n\n  Object.keys(this.memberGroups).forEach(function (id) {\n    var compoundNode = self.idToDummyNode[id]; // Get the dummy compound\n\n    tiledZeroDegreePack[id] = self.tileNodes(self.memberGroups[id], compoundNode.paddingLeft + compoundNode.paddingRight);\n\n    // Set the width and height of the dummy compound as calculated\n    compoundNode.rect.width = tiledZeroDegreePack[id].width;\n    compoundNode.rect.height = tiledZeroDegreePack[id].height;\n  });\n};\n\nCoSELayout.prototype.repopulateCompounds = function () {\n  for (var i = this.compoundOrder.length - 1; i >= 0; i--) {\n    var lCompoundNode = this.compoundOrder[i];\n    var id = lCompoundNode.id;\n    var horizontalMargin = lCompoundNode.paddingLeft;\n    var verticalMargin = lCompoundNode.paddingTop;\n\n    this.adjustLocations(this.tiledMemberPack[id], lCompoundNode.rect.x, lCompoundNode.rect.y, horizontalMargin, verticalMargin);\n  }\n};\n\nCoSELayout.prototype.repopulateZeroDegreeMembers = function () {\n  var self = this;\n  var tiledPack = this.tiledZeroDegreePack;\n\n  Object.keys(tiledPack).forEach(function (id) {\n    var compoundNode = self.idToDummyNode[id]; // Get the dummy compound by its id\n    var horizontalMargin = compoundNode.paddingLeft;\n    var verticalMargin = compoundNode.paddingTop;\n\n    // Adjust the positions of nodes wrt its compound\n    self.adjustLocations(tiledPack[id], compoundNode.rect.x, compoundNode.rect.y, horizontalMargin, verticalMargin);\n  });\n};\n\nCoSELayout.prototype.getToBeTiled = function (node) {\n  var id = node.id;\n  //firstly check the previous results\n  if (this.toBeTiled[id] != null) {\n    return this.toBeTiled[id];\n  }\n\n  //only compound nodes are to be tiled\n  var childGraph = node.getChild();\n  if (childGraph == null) {\n    this.toBeTiled[id] = false;\n    return false;\n  }\n\n  var children = childGraph.getNodes(); // Get the children nodes\n\n  //a compound node is not to be tiled if all of its compound children are not to be tiled\n  for (var i = 0; i < children.length; i++) {\n    var theChild = children[i];\n\n    if (this.getNodeDegree(theChild) > 0) {\n      this.toBeTiled[id] = false;\n      return false;\n    }\n\n    //pass the children not having the compound structure\n    if (theChild.getChild() == null) {\n      this.toBeTiled[theChild.id] = false;\n      continue;\n    }\n\n    if (!this.getToBeTiled(theChild)) {\n      this.toBeTiled[id] = false;\n      return false;\n    }\n  }\n  this.toBeTiled[id] = true;\n  return true;\n};\n\n// Get degree of a node depending of its edges and independent of its children\nCoSELayout.prototype.getNodeDegree = function (node) {\n  var id = node.id;\n  var edges = node.getEdges();\n  var degree = 0;\n\n  // For the edges connected\n  for (var i = 0; i < edges.length; i++) {\n    var edge = edges[i];\n    if (edge.getSource().id !== edge.getTarget().id) {\n      degree = degree + 1;\n    }\n  }\n  return degree;\n};\n\n// Get degree of a node with its children\nCoSELayout.prototype.getNodeDegreeWithChildren = function (node) {\n  var degree = this.getNodeDegree(node);\n  if (node.getChild() == null) {\n    return degree;\n  }\n  var children = node.getChild().getNodes();\n  for (var i = 0; i < children.length; i++) {\n    var child = children[i];\n    degree += this.getNodeDegreeWithChildren(child);\n  }\n  return degree;\n};\n\nCoSELayout.prototype.performDFSOnCompounds = function () {\n  this.compoundOrder = [];\n  this.fillCompexOrderByDFS(this.graphManager.getRoot().getNodes());\n};\n\nCoSELayout.prototype.fillCompexOrderByDFS = function (children) {\n  for (var i = 0; i < children.length; i++) {\n    var child = children[i];\n    if (child.getChild() != null) {\n      this.fillCompexOrderByDFS(child.getChild().getNodes());\n    }\n    if (this.getToBeTiled(child)) {\n      this.compoundOrder.push(child);\n    }\n  }\n};\n\n/**\n* This method places each zero degree member wrt given (x,y) coordinates (top left).\n*/\nCoSELayout.prototype.adjustLocations = function (organization, x, y, compoundHorizontalMargin, compoundVerticalMargin) {\n  x += compoundHorizontalMargin;\n  y += compoundVerticalMargin;\n\n  var left = x;\n\n  for (var i = 0; i < organization.rows.length; i++) {\n    var row = organization.rows[i];\n    x = left;\n    var maxHeight = 0;\n\n    for (var j = 0; j < row.length; j++) {\n      var lnode = row[j];\n\n      lnode.rect.x = x; // + lnode.rect.width / 2;\n      lnode.rect.y = y; // + lnode.rect.height / 2;\n\n      x += lnode.rect.width + organization.horizontalPadding;\n\n      if (lnode.rect.height > maxHeight) maxHeight = lnode.rect.height;\n    }\n\n    y += maxHeight + organization.verticalPadding;\n  }\n};\n\nCoSELayout.prototype.tileCompoundMembers = function (childGraphMap, idToNode) {\n  var self = this;\n  this.tiledMemberPack = [];\n\n  Object.keys(childGraphMap).forEach(function (id) {\n    // Get the compound node\n    var compoundNode = idToNode[id];\n\n    self.tiledMemberPack[id] = self.tileNodes(childGraphMap[id], compoundNode.paddingLeft + compoundNode.paddingRight);\n\n    compoundNode.rect.width = self.tiledMemberPack[id].width;\n    compoundNode.rect.height = self.tiledMemberPack[id].height;\n  });\n};\n\nCoSELayout.prototype.tileNodes = function (nodes, minWidth) {\n  var verticalPadding = CoSEConstants.TILING_PADDING_VERTICAL;\n  var horizontalPadding = CoSEConstants.TILING_PADDING_HORIZONTAL;\n  var organization = {\n    rows: [],\n    rowWidth: [],\n    rowHeight: [],\n    width: 0,\n    height: minWidth, // assume minHeight equals to minWidth\n    verticalPadding: verticalPadding,\n    horizontalPadding: horizontalPadding\n  };\n\n  // Sort the nodes in ascending order of their areas\n  nodes.sort(function (n1, n2) {\n    if (n1.rect.width * n1.rect.height > n2.rect.width * n2.rect.height) return -1;\n    if (n1.rect.width * n1.rect.height < n2.rect.width * n2.rect.height) return 1;\n    return 0;\n  });\n\n  // Create the organization -> tile members\n  for (var i = 0; i < nodes.length; i++) {\n    var lNode = nodes[i];\n\n    if (organization.rows.length == 0) {\n      this.insertNodeToRow(organization, lNode, 0, minWidth);\n    } else if (this.canAddHorizontal(organization, lNode.rect.width, lNode.rect.height)) {\n      this.insertNodeToRow(organization, lNode, this.getShortestRowIndex(organization), minWidth);\n    } else {\n      this.insertNodeToRow(organization, lNode, organization.rows.length, minWidth);\n    }\n\n    this.shiftToLastRow(organization);\n  }\n\n  return organization;\n};\n\nCoSELayout.prototype.insertNodeToRow = function (organization, node, rowIndex, minWidth) {\n  var minCompoundSize = minWidth;\n\n  // Add new row if needed\n  if (rowIndex == organization.rows.length) {\n    var secondDimension = [];\n\n    organization.rows.push(secondDimension);\n    organization.rowWidth.push(minCompoundSize);\n    organization.rowHeight.push(0);\n  }\n\n  // Update row width\n  var w = organization.rowWidth[rowIndex] + node.rect.width;\n\n  if (organization.rows[rowIndex].length > 0) {\n    w += organization.horizontalPadding;\n  }\n\n  organization.rowWidth[rowIndex] = w;\n  // Update compound width\n  if (organization.width < w) {\n    organization.width = w;\n  }\n\n  // Update height\n  var h = node.rect.height;\n  if (rowIndex > 0) h += organization.verticalPadding;\n\n  var extraHeight = 0;\n  if (h > organization.rowHeight[rowIndex]) {\n    extraHeight = organization.rowHeight[rowIndex];\n    organization.rowHeight[rowIndex] = h;\n    extraHeight = organization.rowHeight[rowIndex] - extraHeight;\n  }\n\n  organization.height += extraHeight;\n\n  // Insert node\n  organization.rows[rowIndex].push(node);\n};\n\n//Scans the rows of an organization and returns the one with the min width\nCoSELayout.prototype.getShortestRowIndex = function (organization) {\n  var r = -1;\n  var min = Number.MAX_VALUE;\n\n  for (var i = 0; i < organization.rows.length; i++) {\n    if (organization.rowWidth[i] < min) {\n      r = i;\n      min = organization.rowWidth[i];\n    }\n  }\n  return r;\n};\n\n//Scans the rows of an organization and returns the one with the max width\nCoSELayout.prototype.getLongestRowIndex = function (organization) {\n  var r = -1;\n  var max = Number.MIN_VALUE;\n\n  for (var i = 0; i < organization.rows.length; i++) {\n\n    if (organization.rowWidth[i] > max) {\n      r = i;\n      max = organization.rowWidth[i];\n    }\n  }\n\n  return r;\n};\n\n/**\n* This method checks whether adding extra width to the organization violates\n* the aspect ratio(1) or not.\n*/\nCoSELayout.prototype.canAddHorizontal = function (organization, extraWidth, extraHeight) {\n\n  var sri = this.getShortestRowIndex(organization);\n\n  if (sri < 0) {\n    return true;\n  }\n\n  var min = organization.rowWidth[sri];\n\n  if (min + organization.horizontalPadding + extraWidth <= organization.width) return true;\n\n  var hDiff = 0;\n\n  // Adding to an existing row\n  if (organization.rowHeight[sri] < extraHeight) {\n    if (sri > 0) hDiff = extraHeight + organization.verticalPadding - organization.rowHeight[sri];\n  }\n\n  var add_to_row_ratio;\n  if (organization.width - min >= extraWidth + organization.horizontalPadding) {\n    add_to_row_ratio = (organization.height + hDiff) / (min + extraWidth + organization.horizontalPadding);\n  } else {\n    add_to_row_ratio = (organization.height + hDiff) / organization.width;\n  }\n\n  // Adding a new row for this node\n  hDiff = extraHeight + organization.verticalPadding;\n  var add_new_row_ratio;\n  if (organization.width < extraWidth) {\n    add_new_row_ratio = (organization.height + hDiff) / extraWidth;\n  } else {\n    add_new_row_ratio = (organization.height + hDiff) / organization.width;\n  }\n\n  if (add_new_row_ratio < 1) add_new_row_ratio = 1 / add_new_row_ratio;\n\n  if (add_to_row_ratio < 1) add_to_row_ratio = 1 / add_to_row_ratio;\n\n  return add_to_row_ratio < add_new_row_ratio;\n};\n\n//If moving the last node from the longest row and adding it to the last\n//row makes the bounding box smaller, do it.\nCoSELayout.prototype.shiftToLastRow = function (organization) {\n  var longest = this.getLongestRowIndex(organization);\n  var last = organization.rowWidth.length - 1;\n  var row = organization.rows[longest];\n  var node = row[row.length - 1];\n\n  var diff = node.width + organization.horizontalPadding;\n\n  // Check if there is enough space on the last row\n  if (organization.width - organization.rowWidth[last] > diff && longest != last) {\n    // Remove the last element of the longest row\n    row.splice(-1, 1);\n\n    // Push it to the last row\n    organization.rows[last].push(node);\n\n    organization.rowWidth[longest] = organization.rowWidth[longest] - diff;\n    organization.rowWidth[last] = organization.rowWidth[last] + diff;\n    organization.width = organization.rowWidth[instance.getLongestRowIndex(organization)];\n\n    // Update heights of the organization\n    var maxHeight = Number.MIN_VALUE;\n    for (var i = 0; i < row.length; i++) {\n      if (row[i].height > maxHeight) maxHeight = row[i].height;\n    }\n    if (longest > 0) maxHeight += organization.verticalPadding;\n\n    var prevTotal = organization.rowHeight[longest] + organization.rowHeight[last];\n\n    organization.rowHeight[longest] = maxHeight;\n    if (organization.rowHeight[last] < node.height + organization.verticalPadding) organization.rowHeight[last] = node.height + organization.verticalPadding;\n\n    var finalTotal = organization.rowHeight[longest] + organization.rowHeight[last];\n    organization.height += finalTotal - prevTotal;\n\n    this.shiftToLastRow(organization);\n  }\n};\n\nCoSELayout.prototype.tilingPreLayout = function () {\n  if (CoSEConstants.TILE) {\n    // Find zero degree nodes and create a compound for each level\n    this.groupZeroDegreeMembers();\n    // Tile and clear children of each compound\n    this.clearCompounds();\n    // Separately tile and clear zero degree nodes for each level\n    this.clearZeroDegreeMembers();\n  }\n};\n\nCoSELayout.prototype.tilingPostLayout = function () {\n  if (CoSEConstants.TILE) {\n    this.repopulateZeroDegreeMembers();\n    this.repopulateCompounds();\n  }\n};\n\n// -----------------------------------------------------------------------------\n// Section: Tree Reduction methods\n// -----------------------------------------------------------------------------\n// Reduce trees \nCoSELayout.prototype.reduceTrees = function () {\n  var prunedNodesAll = [];\n  var containsLeaf = true;\n  var node;\n\n  while (containsLeaf) {\n    var allNodes = this.graphManager.getAllNodes();\n    var prunedNodesInStepTemp = [];\n    containsLeaf = false;\n\n    for (var i = 0; i < allNodes.length; i++) {\n      node = allNodes[i];\n      if (node.getEdges().length == 1 && !node.getEdges()[0].isInterGraph && node.getChild() == null) {\n        prunedNodesInStepTemp.push([node, node.getEdges()[0], node.getOwner()]);\n        containsLeaf = true;\n      }\n    }\n    if (containsLeaf == true) {\n      var prunedNodesInStep = [];\n      for (var j = 0; j < prunedNodesInStepTemp.length; j++) {\n        if (prunedNodesInStepTemp[j][0].getEdges().length == 1) {\n          prunedNodesInStep.push(prunedNodesInStepTemp[j]);\n          prunedNodesInStepTemp[j][0].getOwner().remove(prunedNodesInStepTemp[j][0]);\n        }\n      }\n      prunedNodesAll.push(prunedNodesInStep);\n      this.graphManager.resetAllNodes();\n      this.graphManager.resetAllEdges();\n    }\n  }\n  this.prunedNodesAll = prunedNodesAll;\n};\n\n// Grow tree one step \nCoSELayout.prototype.growTree = function (prunedNodesAll) {\n  var lengthOfPrunedNodesInStep = prunedNodesAll.length;\n  var prunedNodesInStep = prunedNodesAll[lengthOfPrunedNodesInStep - 1];\n\n  var nodeData;\n  for (var i = 0; i < prunedNodesInStep.length; i++) {\n    nodeData = prunedNodesInStep[i];\n\n    this.findPlaceforPrunedNode(nodeData);\n\n    nodeData[2].add(nodeData[0]);\n    nodeData[2].add(nodeData[1], nodeData[1].source, nodeData[1].target);\n  }\n\n  prunedNodesAll.splice(prunedNodesAll.length - 1, 1);\n  this.graphManager.resetAllNodes();\n  this.graphManager.resetAllEdges();\n};\n\n// Find an appropriate position to replace pruned node, this method can be improved\nCoSELayout.prototype.findPlaceforPrunedNode = function (nodeData) {\n\n  var gridForPrunedNode;\n  var nodeToConnect;\n  var prunedNode = nodeData[0];\n  if (prunedNode == nodeData[1].source) {\n    nodeToConnect = nodeData[1].target;\n  } else {\n    nodeToConnect = nodeData[1].source;\n  }\n  var startGridX = nodeToConnect.startX;\n  var finishGridX = nodeToConnect.finishX;\n  var startGridY = nodeToConnect.startY;\n  var finishGridY = nodeToConnect.finishY;\n\n  var upNodeCount = 0;\n  var downNodeCount = 0;\n  var rightNodeCount = 0;\n  var leftNodeCount = 0;\n  var controlRegions = [upNodeCount, rightNodeCount, downNodeCount, leftNodeCount];\n\n  if (startGridY > 0) {\n    for (var i = startGridX; i <= finishGridX; i++) {\n      controlRegions[0] += this.grid[i][startGridY - 1].length + this.grid[i][startGridY].length - 1;\n    }\n  }\n  if (finishGridX < this.grid.length - 1) {\n    for (var i = startGridY; i <= finishGridY; i++) {\n      controlRegions[1] += this.grid[finishGridX + 1][i].length + this.grid[finishGridX][i].length - 1;\n    }\n  }\n  if (finishGridY < this.grid[0].length - 1) {\n    for (var i = startGridX; i <= finishGridX; i++) {\n      controlRegions[2] += this.grid[i][finishGridY + 1].length + this.grid[i][finishGridY].length - 1;\n    }\n  }\n  if (startGridX > 0) {\n    for (var i = startGridY; i <= finishGridY; i++) {\n      controlRegions[3] += this.grid[startGridX - 1][i].length + this.grid[startGridX][i].length - 1;\n    }\n  }\n  var min = Integer.MAX_VALUE;\n  var minCount;\n  var minIndex;\n  for (var j = 0; j < controlRegions.length; j++) {\n    if (controlRegions[j] < min) {\n      min = controlRegions[j];\n      minCount = 1;\n      minIndex = j;\n    } else if (controlRegions[j] == min) {\n      minCount++;\n    }\n  }\n\n  if (minCount == 3 && min == 0) {\n    if (controlRegions[0] == 0 && controlRegions[1] == 0 && controlRegions[2] == 0) {\n      gridForPrunedNode = 1;\n    } else if (controlRegions[0] == 0 && controlRegions[1] == 0 && controlRegions[3] == 0) {\n      gridForPrunedNode = 0;\n    } else if (controlRegions[0] == 0 && controlRegions[2] == 0 && controlRegions[3] == 0) {\n      gridForPrunedNode = 3;\n    } else if (controlRegions[1] == 0 && controlRegions[2] == 0 && controlRegions[3] == 0) {\n      gridForPrunedNode = 2;\n    }\n  } else if (minCount == 2 && min == 0) {\n    var random = Math.floor(Math.random() * 2);\n    if (controlRegions[0] == 0 && controlRegions[1] == 0) {\n      ;\n      if (random == 0) {\n        gridForPrunedNode = 0;\n      } else {\n        gridForPrunedNode = 1;\n      }\n    } else if (controlRegions[0] == 0 && controlRegions[2] == 0) {\n      if (random == 0) {\n        gridForPrunedNode = 0;\n      } else {\n        gridForPrunedNode = 2;\n      }\n    } else if (controlRegions[0] == 0 && controlRegions[3] == 0) {\n      if (random == 0) {\n        gridForPrunedNode = 0;\n      } else {\n        gridForPrunedNode = 3;\n      }\n    } else if (controlRegions[1] == 0 && controlRegions[2] == 0) {\n      if (random == 0) {\n        gridForPrunedNode = 1;\n      } else {\n        gridForPrunedNode = 2;\n      }\n    } else if (controlRegions[1] == 0 && controlRegions[3] == 0) {\n      if (random == 0) {\n        gridForPrunedNode = 1;\n      } else {\n        gridForPrunedNode = 3;\n      }\n    } else {\n      if (random == 0) {\n        gridForPrunedNode = 2;\n      } else {\n        gridForPrunedNode = 3;\n      }\n    }\n  } else if (minCount == 4 && min == 0) {\n    var random = Math.floor(Math.random() * 4);\n    gridForPrunedNode = random;\n  } else {\n    gridForPrunedNode = minIndex;\n  }\n\n  if (gridForPrunedNode == 0) {\n    prunedNode.setCenter(nodeToConnect.getCenterX(), nodeToConnect.getCenterY() - nodeToConnect.getHeight() / 2 - FDLayoutConstants.DEFAULT_EDGE_LENGTH - prunedNode.getHeight() / 2);\n  } else if (gridForPrunedNode == 1) {\n    prunedNode.setCenter(nodeToConnect.getCenterX() + nodeToConnect.getWidth() / 2 + FDLayoutConstants.DEFAULT_EDGE_LENGTH + prunedNode.getWidth() / 2, nodeToConnect.getCenterY());\n  } else if (gridForPrunedNode == 2) {\n    prunedNode.setCenter(nodeToConnect.getCenterX(), nodeToConnect.getCenterY() + nodeToConnect.getHeight() / 2 + FDLayoutConstants.DEFAULT_EDGE_LENGTH + prunedNode.getHeight() / 2);\n  } else {\n    prunedNode.setCenter(nodeToConnect.getCenterX() - nodeToConnect.getWidth() / 2 - FDLayoutConstants.DEFAULT_EDGE_LENGTH - prunedNode.getWidth() / 2, nodeToConnect.getCenterY());\n  }\n};\n\nmodule.exports = CoSELayout;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __nested_webpack_require_45620__) {\n\n\"use strict\";\n\n\nvar coseBase = {};\n\ncoseBase.layoutBase = __nested_webpack_require_45620__(0);\ncoseBase.CoSEConstants = __nested_webpack_require_45620__(1);\ncoseBase.CoSEEdge = __nested_webpack_require_45620__(2);\ncoseBase.CoSEGraph = __nested_webpack_require_45620__(3);\ncoseBase.CoSEGraphManager = __nested_webpack_require_45620__(4);\ncoseBase.CoSELayout = __nested_webpack_require_45620__(6);\ncoseBase.CoSENode = __nested_webpack_require_45620__(5);\n\nmodule.exports = coseBase;\n\n/***/ })\n/******/ ]);\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL2Nvc2UtYmFzZS9jb3NlLWJhc2UuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxJQUFJLElBQXlEO0FBQzdELDJCQUEyQixtQkFBTyxDQUFDLDJFQUFhO0FBQ2hELE1BQU0sRUFLMkM7QUFDakQsQ0FBQztBQUNELHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw4QkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsOEJBQW1CO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7QUFDN0I7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQix1QkFBdUI7QUFDcEQ7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCLGVBQWUsOEJBQW1CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7QUFDN0I7QUFDQSxvQ0FBb0MsNEJBQTRCO0FBQ2hFLDBDQUEwQztBQUMxQyxXQUFXLDhCQUFtQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOEJBQW1CLGtDQUFrQztBQUMvRDtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7QUFDN0I7QUFDQTtBQUNBLGlCQUFpQiw4QkFBbUIsQ0FBQyw4QkFBbUI7QUFDeEQsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLE9BQU87QUFDUDtBQUNBLGlDQUFpQywrQkFBbUI7O0FBRXBEOzs7QUFHQSx3QkFBd0IsK0JBQW1COztBQUUzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7O0FBRXJEOztBQUVB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QUFDQSxrQkFBa0IsMkJBQTJCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsZ0NBQW1COztBQUVwRDs7O0FBR0E7O0FBRUEsc0JBQXNCLGdDQUFtQjtBQUN6Qyx5QkFBeUIsZ0NBQW1CO0FBQzVDLG9CQUFvQixnQ0FBbUI7QUFDdkMscUJBQXFCLGdDQUFtQjtBQUN4Qyw0QkFBNEIsZ0NBQW1CO0FBQy9DLHNCQUFzQixnQ0FBbUI7QUFDekMsb0JBQW9CLGdDQUFtQjs7QUFFdkM7O0FBRUEsT0FBTztBQUNQO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvY29zZS1iYXNlL2Nvc2UtYmFzZS5qcz9lZjU3Il0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcImxheW91dC1iYXNlXCIpKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtcImxheW91dC1iYXNlXCJdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcImNvc2VCYXNlXCJdID0gZmFjdG9yeShyZXF1aXJlKFwibGF5b3V0LWJhc2VcIikpO1xuXHRlbHNlXG5cdFx0cm9vdFtcImNvc2VCYXNlXCJdID0gZmFjdG9yeShyb290W1wibGF5b3V0QmFzZVwiXSk7XG59KSh0aGlzLCBmdW5jdGlvbihfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzBfXykge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBpZGVudGl0eSBmdW5jdGlvbiBmb3IgY2FsbGluZyBoYXJtb255IGltcG9ydHMgd2l0aCB0aGUgY29ycmVjdCBjb250ZXh0XG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uaSA9IGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuLyoqKioqKi8gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuLyoqKioqKi8gXHRcdFx0XHRnZXQ6IGdldHRlclxuLyoqKioqKi8gXHRcdFx0fSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDcpO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMF9fO1xuXG4vKioqLyB9KSxcbi8qIDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIEZETGF5b3V0Q29uc3RhbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKS5GRExheW91dENvbnN0YW50cztcblxuZnVuY3Rpb24gQ29TRUNvbnN0YW50cygpIHt9XG5cbi8vQ29TRUNvbnN0YW50cyBpbmhlcml0cyBzdGF0aWMgcHJvcHMgaW4gRkRMYXlvdXRDb25zdGFudHNcbmZvciAodmFyIHByb3AgaW4gRkRMYXlvdXRDb25zdGFudHMpIHtcbiAgQ29TRUNvbnN0YW50c1twcm9wXSA9IEZETGF5b3V0Q29uc3RhbnRzW3Byb3BdO1xufVxuXG5Db1NFQ29uc3RhbnRzLkRFRkFVTFRfVVNFX01VTFRJX0xFVkVMX1NDQUxJTkcgPSBmYWxzZTtcbkNvU0VDb25zdGFudHMuREVGQVVMVF9SQURJQUxfU0VQQVJBVElPTiA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEg7XG5Db1NFQ29uc3RhbnRzLkRFRkFVTFRfQ09NUE9ORU5UX1NFUEVSQVRJT04gPSA2MDtcbkNvU0VDb25zdGFudHMuVElMRSA9IHRydWU7XG5Db1NFQ29uc3RhbnRzLlRJTElOR19QQURESU5HX1ZFUlRJQ0FMID0gMTA7XG5Db1NFQ29uc3RhbnRzLlRJTElOR19QQURESU5HX0hPUklaT05UQUwgPSAxMDtcbkNvU0VDb25zdGFudHMuVFJFRV9SRURVQ1RJT05fT05fSU5DUkVNRU5UQUwgPSBmYWxzZTsgLy8gbWFrZSB0aGlzIHRydWUgd2hlbiBjb3NlIGlzIHVzZWQgaW5jcmVtZW50YWxseSBhcyBhIHBhcnQgb2Ygb3RoZXIgbm9uLWluY3JlbWVudGFsIGxheW91dFxuXG5tb2R1bGUuZXhwb3J0cyA9IENvU0VDb25zdGFudHM7XG5cbi8qKiovIH0pLFxuLyogMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgRkRMYXlvdXRFZGdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKS5GRExheW91dEVkZ2U7XG5cbmZ1bmN0aW9uIENvU0VFZGdlKHNvdXJjZSwgdGFyZ2V0LCB2RWRnZSkge1xuICBGRExheW91dEVkZ2UuY2FsbCh0aGlzLCBzb3VyY2UsIHRhcmdldCwgdkVkZ2UpO1xufVxuXG5Db1NFRWRnZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEZETGF5b3V0RWRnZS5wcm90b3R5cGUpO1xuZm9yICh2YXIgcHJvcCBpbiBGRExheW91dEVkZ2UpIHtcbiAgQ29TRUVkZ2VbcHJvcF0gPSBGRExheW91dEVkZ2VbcHJvcF07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ29TRUVkZ2U7XG5cbi8qKiovIH0pLFxuLyogMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgTEdyYXBoID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKS5MR3JhcGg7XG5cbmZ1bmN0aW9uIENvU0VHcmFwaChwYXJlbnQsIGdyYXBoTWdyLCB2R3JhcGgpIHtcbiAgTEdyYXBoLmNhbGwodGhpcywgcGFyZW50LCBncmFwaE1nciwgdkdyYXBoKTtcbn1cblxuQ29TRUdyYXBoLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTEdyYXBoLnByb3RvdHlwZSk7XG5mb3IgKHZhciBwcm9wIGluIExHcmFwaCkge1xuICBDb1NFR3JhcGhbcHJvcF0gPSBMR3JhcGhbcHJvcF07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ29TRUdyYXBoO1xuXG4vKioqLyB9KSxcbi8qIDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIExHcmFwaE1hbmFnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApLkxHcmFwaE1hbmFnZXI7XG5cbmZ1bmN0aW9uIENvU0VHcmFwaE1hbmFnZXIobGF5b3V0KSB7XG4gIExHcmFwaE1hbmFnZXIuY2FsbCh0aGlzLCBsYXlvdXQpO1xufVxuXG5Db1NFR3JhcGhNYW5hZ2VyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTEdyYXBoTWFuYWdlci5wcm90b3R5cGUpO1xuZm9yICh2YXIgcHJvcCBpbiBMR3JhcGhNYW5hZ2VyKSB7XG4gIENvU0VHcmFwaE1hbmFnZXJbcHJvcF0gPSBMR3JhcGhNYW5hZ2VyW3Byb3BdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvU0VHcmFwaE1hbmFnZXI7XG5cbi8qKiovIH0pLFxuLyogNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgRkRMYXlvdXROb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKS5GRExheW91dE5vZGU7XG52YXIgSU1hdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApLklNYXRoO1xuXG5mdW5jdGlvbiBDb1NFTm9kZShnbSwgbG9jLCBzaXplLCB2Tm9kZSkge1xuICBGRExheW91dE5vZGUuY2FsbCh0aGlzLCBnbSwgbG9jLCBzaXplLCB2Tm9kZSk7XG59XG5cbkNvU0VOb2RlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRkRMYXlvdXROb2RlLnByb3RvdHlwZSk7XG5mb3IgKHZhciBwcm9wIGluIEZETGF5b3V0Tm9kZSkge1xuICBDb1NFTm9kZVtwcm9wXSA9IEZETGF5b3V0Tm9kZVtwcm9wXTtcbn1cblxuQ29TRU5vZGUucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsYXlvdXQgPSB0aGlzLmdyYXBoTWFuYWdlci5nZXRMYXlvdXQoKTtcbiAgdGhpcy5kaXNwbGFjZW1lbnRYID0gbGF5b3V0LmNvb2xpbmdGYWN0b3IgKiAodGhpcy5zcHJpbmdGb3JjZVggKyB0aGlzLnJlcHVsc2lvbkZvcmNlWCArIHRoaXMuZ3Jhdml0YXRpb25Gb3JjZVgpIC8gdGhpcy5ub09mQ2hpbGRyZW47XG4gIHRoaXMuZGlzcGxhY2VtZW50WSA9IGxheW91dC5jb29saW5nRmFjdG9yICogKHRoaXMuc3ByaW5nRm9yY2VZICsgdGhpcy5yZXB1bHNpb25Gb3JjZVkgKyB0aGlzLmdyYXZpdGF0aW9uRm9yY2VZKSAvIHRoaXMubm9PZkNoaWxkcmVuO1xuXG4gIGlmIChNYXRoLmFicyh0aGlzLmRpc3BsYWNlbWVudFgpID4gbGF5b3V0LmNvb2xpbmdGYWN0b3IgKiBsYXlvdXQubWF4Tm9kZURpc3BsYWNlbWVudCkge1xuICAgIHRoaXMuZGlzcGxhY2VtZW50WCA9IGxheW91dC5jb29saW5nRmFjdG9yICogbGF5b3V0Lm1heE5vZGVEaXNwbGFjZW1lbnQgKiBJTWF0aC5zaWduKHRoaXMuZGlzcGxhY2VtZW50WCk7XG4gIH1cblxuICBpZiAoTWF0aC5hYnModGhpcy5kaXNwbGFjZW1lbnRZKSA+IGxheW91dC5jb29saW5nRmFjdG9yICogbGF5b3V0Lm1heE5vZGVEaXNwbGFjZW1lbnQpIHtcbiAgICB0aGlzLmRpc3BsYWNlbWVudFkgPSBsYXlvdXQuY29vbGluZ0ZhY3RvciAqIGxheW91dC5tYXhOb2RlRGlzcGxhY2VtZW50ICogSU1hdGguc2lnbih0aGlzLmRpc3BsYWNlbWVudFkpO1xuICB9XG5cbiAgLy8gYSBzaW1wbGUgbm9kZSwganVzdCBtb3ZlIGl0XG4gIGlmICh0aGlzLmNoaWxkID09IG51bGwpIHtcbiAgICB0aGlzLm1vdmVCeSh0aGlzLmRpc3BsYWNlbWVudFgsIHRoaXMuZGlzcGxhY2VtZW50WSk7XG4gIH1cbiAgLy8gYW4gZW1wdHkgY29tcG91bmQgbm9kZSwgYWdhaW4ganVzdCBtb3ZlIGl0XG4gIGVsc2UgaWYgKHRoaXMuY2hpbGQuZ2V0Tm9kZXMoKS5sZW5ndGggPT0gMCkge1xuICAgICAgdGhpcy5tb3ZlQnkodGhpcy5kaXNwbGFjZW1lbnRYLCB0aGlzLmRpc3BsYWNlbWVudFkpO1xuICAgIH1cbiAgICAvLyBub24tZW1wdHkgY29tcG91bmQgbm9kZSwgcHJvcG9nYXRlIG1vdmVtZW50IHRvIGNoaWxkcmVuIGFzIHdlbGxcbiAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5wcm9wb2dhdGVEaXNwbGFjZW1lbnRUb0NoaWxkcmVuKHRoaXMuZGlzcGxhY2VtZW50WCwgdGhpcy5kaXNwbGFjZW1lbnRZKTtcbiAgICAgIH1cblxuICBsYXlvdXQudG90YWxEaXNwbGFjZW1lbnQgKz0gTWF0aC5hYnModGhpcy5kaXNwbGFjZW1lbnRYKSArIE1hdGguYWJzKHRoaXMuZGlzcGxhY2VtZW50WSk7XG5cbiAgdGhpcy5zcHJpbmdGb3JjZVggPSAwO1xuICB0aGlzLnNwcmluZ0ZvcmNlWSA9IDA7XG4gIHRoaXMucmVwdWxzaW9uRm9yY2VYID0gMDtcbiAgdGhpcy5yZXB1bHNpb25Gb3JjZVkgPSAwO1xuICB0aGlzLmdyYXZpdGF0aW9uRm9yY2VYID0gMDtcbiAgdGhpcy5ncmF2aXRhdGlvbkZvcmNlWSA9IDA7XG4gIHRoaXMuZGlzcGxhY2VtZW50WCA9IDA7XG4gIHRoaXMuZGlzcGxhY2VtZW50WSA9IDA7XG59O1xuXG5Db1NFTm9kZS5wcm90b3R5cGUucHJvcG9nYXRlRGlzcGxhY2VtZW50VG9DaGlsZHJlbiA9IGZ1bmN0aW9uIChkWCwgZFkpIHtcbiAgdmFyIG5vZGVzID0gdGhpcy5nZXRDaGlsZCgpLmdldE5vZGVzKCk7XG4gIHZhciBub2RlO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgbm9kZSA9IG5vZGVzW2ldO1xuICAgIGlmIChub2RlLmdldENoaWxkKCkgPT0gbnVsbCkge1xuICAgICAgbm9kZS5tb3ZlQnkoZFgsIGRZKTtcbiAgICAgIG5vZGUuZGlzcGxhY2VtZW50WCArPSBkWDtcbiAgICAgIG5vZGUuZGlzcGxhY2VtZW50WSArPSBkWTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5wcm9wb2dhdGVEaXNwbGFjZW1lbnRUb0NoaWxkcmVuKGRYLCBkWSk7XG4gICAgfVxuICB9XG59O1xuXG5Db1NFTm9kZS5wcm90b3R5cGUuc2V0UHJlZDEgPSBmdW5jdGlvbiAocHJlZDEpIHtcbiAgdGhpcy5wcmVkMSA9IHByZWQxO1xufTtcblxuQ29TRU5vZGUucHJvdG90eXBlLmdldFByZWQxID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gcHJlZDE7XG59O1xuXG5Db1NFTm9kZS5wcm90b3R5cGUuZ2V0UHJlZDIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBwcmVkMjtcbn07XG5cbkNvU0VOb2RlLnByb3RvdHlwZS5zZXROZXh0ID0gZnVuY3Rpb24gKG5leHQpIHtcbiAgdGhpcy5uZXh0ID0gbmV4dDtcbn07XG5cbkNvU0VOb2RlLnByb3RvdHlwZS5nZXROZXh0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbmV4dDtcbn07XG5cbkNvU0VOb2RlLnByb3RvdHlwZS5zZXRQcm9jZXNzZWQgPSBmdW5jdGlvbiAocHJvY2Vzc2VkKSB7XG4gIHRoaXMucHJvY2Vzc2VkID0gcHJvY2Vzc2VkO1xufTtcblxuQ29TRU5vZGUucHJvdG90eXBlLmlzUHJvY2Vzc2VkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gcHJvY2Vzc2VkO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb1NFTm9kZTtcblxuLyoqKi8gfSksXG4vKiA2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBGRExheW91dCA9IF9fd2VicGFja19yZXF1aXJlX18oMCkuRkRMYXlvdXQ7XG52YXIgQ29TRUdyYXBoTWFuYWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG52YXIgQ29TRUdyYXBoID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbnZhciBDb1NFTm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgQ29TRUVkZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xudmFyIENvU0VDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xudmFyIEZETGF5b3V0Q29uc3RhbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKS5GRExheW91dENvbnN0YW50cztcbnZhciBMYXlvdXRDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApLkxheW91dENvbnN0YW50cztcbnZhciBQb2ludCA9IF9fd2VicGFja19yZXF1aXJlX18oMCkuUG9pbnQ7XG52YXIgUG9pbnREID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKS5Qb2ludEQ7XG52YXIgTGF5b3V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKS5MYXlvdXQ7XG52YXIgSW50ZWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oMCkuSW50ZWdlcjtcbnZhciBJR2VvbWV0cnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApLklHZW9tZXRyeTtcbnZhciBMR3JhcGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApLkxHcmFwaDtcbnZhciBUcmFuc2Zvcm0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApLlRyYW5zZm9ybTtcblxuZnVuY3Rpb24gQ29TRUxheW91dCgpIHtcbiAgRkRMYXlvdXQuY2FsbCh0aGlzKTtcblxuICB0aGlzLnRvQmVUaWxlZCA9IHt9OyAvLyBNZW1vcml6ZSBpZiBhIG5vZGUgaXMgdG8gYmUgdGlsZWQgb3IgaXMgdGlsZWRcbn1cblxuQ29TRUxheW91dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEZETGF5b3V0LnByb3RvdHlwZSk7XG5cbmZvciAodmFyIHByb3AgaW4gRkRMYXlvdXQpIHtcbiAgQ29TRUxheW91dFtwcm9wXSA9IEZETGF5b3V0W3Byb3BdO1xufVxuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5uZXdHcmFwaE1hbmFnZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBnbSA9IG5ldyBDb1NFR3JhcGhNYW5hZ2VyKHRoaXMpO1xuICB0aGlzLmdyYXBoTWFuYWdlciA9IGdtO1xuICByZXR1cm4gZ207XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5uZXdHcmFwaCA9IGZ1bmN0aW9uICh2R3JhcGgpIHtcbiAgcmV0dXJuIG5ldyBDb1NFR3JhcGgobnVsbCwgdGhpcy5ncmFwaE1hbmFnZXIsIHZHcmFwaCk7XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5uZXdOb2RlID0gZnVuY3Rpb24gKHZOb2RlKSB7XG4gIHJldHVybiBuZXcgQ29TRU5vZGUodGhpcy5ncmFwaE1hbmFnZXIsIHZOb2RlKTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLm5ld0VkZ2UgPSBmdW5jdGlvbiAodkVkZ2UpIHtcbiAgcmV0dXJuIG5ldyBDb1NFRWRnZShudWxsLCBudWxsLCB2RWRnZSk7XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5pbml0UGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgRkRMYXlvdXQucHJvdG90eXBlLmluaXRQYXJhbWV0ZXJzLmNhbGwodGhpcywgYXJndW1lbnRzKTtcbiAgaWYgKCF0aGlzLmlzU3ViTGF5b3V0KSB7XG4gICAgaWYgKENvU0VDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSCA8IDEwKSB7XG4gICAgICB0aGlzLmlkZWFsRWRnZUxlbmd0aCA9IDEwO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmlkZWFsRWRnZUxlbmd0aCA9IENvU0VDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSDtcbiAgICB9XG5cbiAgICB0aGlzLnVzZVNtYXJ0SWRlYWxFZGdlTGVuZ3RoQ2FsY3VsYXRpb24gPSBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfVVNFX1NNQVJUX0lERUFMX0VER0VfTEVOR1RIX0NBTENVTEFUSU9OO1xuICAgIHRoaXMuc3ByaW5nQ29uc3RhbnQgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX1NQUklOR19TVFJFTkdUSDtcbiAgICB0aGlzLnJlcHVsc2lvbkNvbnN0YW50ID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9SRVBVTFNJT05fU1RSRU5HVEg7XG4gICAgdGhpcy5ncmF2aXR5Q29uc3RhbnQgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0dSQVZJVFlfU1RSRU5HVEg7XG4gICAgdGhpcy5jb21wb3VuZEdyYXZpdHlDb25zdGFudCA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQ09NUE9VTkRfR1JBVklUWV9TVFJFTkdUSDtcbiAgICB0aGlzLmdyYXZpdHlSYW5nZUZhY3RvciA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfR1JBVklUWV9SQU5HRV9GQUNUT1I7XG4gICAgdGhpcy5jb21wb3VuZEdyYXZpdHlSYW5nZUZhY3RvciA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQ09NUE9VTkRfR1JBVklUWV9SQU5HRV9GQUNUT1I7XG5cbiAgICAvLyB2YXJpYWJsZXMgZm9yIHRyZWUgcmVkdWN0aW9uIHN1cHBvcnRcbiAgICB0aGlzLnBydW5lZE5vZGVzQWxsID0gW107XG4gICAgdGhpcy5ncm93VHJlZUl0ZXJhdGlvbnMgPSAwO1xuICAgIHRoaXMuYWZ0ZXJHcm93dGhJdGVyYXRpb25zID0gMDtcbiAgICB0aGlzLmlzVHJlZUdyb3dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmlzR3Jvd3RoRmluaXNoZWQgPSBmYWxzZTtcblxuICAgIC8vIHZhcmlhYmxlcyBmb3IgY29vbGluZ1xuICAgIHRoaXMuY29vbGluZ0N5Y2xlID0gMDtcbiAgICB0aGlzLm1heENvb2xpbmdDeWNsZSA9IHRoaXMubWF4SXRlcmF0aW9ucyAvIEZETGF5b3V0Q29uc3RhbnRzLkNPTlZFUkdFTkNFX0NIRUNLX1BFUklPRDtcbiAgICB0aGlzLmZpbmFsVGVtcGVyYXR1cmUgPSBGRExheW91dENvbnN0YW50cy5DT05WRVJHRU5DRV9DSEVDS19QRVJJT0QgLyB0aGlzLm1heEl0ZXJhdGlvbnM7XG4gICAgdGhpcy5jb29saW5nQWRqdXN0ZXIgPSAxO1xuICB9XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5sYXlvdXQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjcmVhdGVCZW5kc0FzTmVlZGVkID0gTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQ1JFQVRFX0JFTkRTX0FTX05FRURFRDtcbiAgaWYgKGNyZWF0ZUJlbmRzQXNOZWVkZWQpIHtcbiAgICB0aGlzLmNyZWF0ZUJlbmRwb2ludHMoKTtcbiAgICB0aGlzLmdyYXBoTWFuYWdlci5yZXNldEFsbEVkZ2VzKCk7XG4gIH1cblxuICB0aGlzLmxldmVsID0gMDtcbiAgcmV0dXJuIHRoaXMuY2xhc3NpY0xheW91dCgpO1xufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUuY2xhc3NpY0xheW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5ub2Rlc1dpdGhHcmF2aXR5ID0gdGhpcy5jYWxjdWxhdGVOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvblRvKCk7XG4gIHRoaXMuZ3JhcGhNYW5hZ2VyLnNldEFsbE5vZGVzVG9BcHBseUdyYXZpdGF0aW9uKHRoaXMubm9kZXNXaXRoR3Jhdml0eSk7XG4gIHRoaXMuY2FsY05vT2ZDaGlsZHJlbkZvckFsbE5vZGVzKCk7XG4gIHRoaXMuZ3JhcGhNYW5hZ2VyLmNhbGNMb3dlc3RDb21tb25BbmNlc3RvcnMoKTtcbiAgdGhpcy5ncmFwaE1hbmFnZXIuY2FsY0luY2x1c2lvblRyZWVEZXB0aHMoKTtcbiAgdGhpcy5ncmFwaE1hbmFnZXIuZ2V0Um9vdCgpLmNhbGNFc3RpbWF0ZWRTaXplKCk7XG4gIHRoaXMuY2FsY0lkZWFsRWRnZUxlbmd0aHMoKTtcblxuICBpZiAoIXRoaXMuaW5jcmVtZW50YWwpIHtcbiAgICB2YXIgZm9yZXN0ID0gdGhpcy5nZXRGbGF0Rm9yZXN0KCk7XG5cbiAgICAvLyBUaGUgZ3JhcGggYXNzb2NpYXRlZCB3aXRoIHRoaXMgbGF5b3V0IGlzIGZsYXQgYW5kIGEgZm9yZXN0XG4gICAgaWYgKGZvcmVzdC5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLnBvc2l0aW9uTm9kZXNSYWRpYWxseShmb3Jlc3QpO1xuICAgIH1cbiAgICAvLyBUaGUgZ3JhcGggYXNzb2NpYXRlZCB3aXRoIHRoaXMgbGF5b3V0IGlzIG5vdCBmbGF0IG9yIGEgZm9yZXN0XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFJlZHVjZSB0aGUgdHJlZXMgd2hlbiBpbmNyZW1lbnRhbCBtb2RlIGlzIG5vdCBlbmFibGVkIGFuZCBncmFwaCBpcyBub3QgYSBmb3Jlc3QgXG4gICAgICAgIHRoaXMucmVkdWNlVHJlZXMoKTtcbiAgICAgICAgLy8gVXBkYXRlIG5vZGVzIHRoYXQgZ3Jhdml0eSB3aWxsIGJlIGFwcGxpZWRcbiAgICAgICAgdGhpcy5ncmFwaE1hbmFnZXIucmVzZXRBbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbigpO1xuICAgICAgICB2YXIgYWxsTm9kZXMgPSBuZXcgU2V0KHRoaXMuZ2V0QWxsTm9kZXMoKSk7XG4gICAgICAgIHZhciBpbnRlcnNlY3Rpb24gPSB0aGlzLm5vZGVzV2l0aEdyYXZpdHkuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgcmV0dXJuIGFsbE5vZGVzLmhhcyh4KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnNldEFsbE5vZGVzVG9BcHBseUdyYXZpdGF0aW9uKGludGVyc2VjdGlvbik7XG5cbiAgICAgICAgdGhpcy5wb3NpdGlvbk5vZGVzUmFuZG9tbHkoKTtcbiAgICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoQ29TRUNvbnN0YW50cy5UUkVFX1JFRFVDVElPTl9PTl9JTkNSRU1FTlRBTCkge1xuICAgICAgLy8gUmVkdWNlIHRoZSB0cmVlcyBpbiBpbmNyZW1lbnRhbCBtb2RlIGlmIG9ubHkgdGhpcyBjb25zdGFudCBpcyBzZXQgdG8gdHJ1ZSBcbiAgICAgIHRoaXMucmVkdWNlVHJlZXMoKTtcbiAgICAgIC8vIFVwZGF0ZSBub2RlcyB0aGF0IGdyYXZpdHkgd2lsbCBiZSBhcHBsaWVkXG4gICAgICB0aGlzLmdyYXBoTWFuYWdlci5yZXNldEFsbE5vZGVzVG9BcHBseUdyYXZpdGF0aW9uKCk7XG4gICAgICB2YXIgYWxsTm9kZXMgPSBuZXcgU2V0KHRoaXMuZ2V0QWxsTm9kZXMoKSk7XG4gICAgICB2YXIgaW50ZXJzZWN0aW9uID0gdGhpcy5ub2Rlc1dpdGhHcmF2aXR5LmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gYWxsTm9kZXMuaGFzKHgpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmdyYXBoTWFuYWdlci5zZXRBbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbihpbnRlcnNlY3Rpb24pO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuaW5pdFNwcmluZ0VtYmVkZGVyKCk7XG4gIHRoaXMucnVuU3ByaW5nRW1iZWRkZXIoKTtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLnRpY2sgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMudG90YWxJdGVyYXRpb25zKys7XG5cbiAgaWYgKHRoaXMudG90YWxJdGVyYXRpb25zID09PSB0aGlzLm1heEl0ZXJhdGlvbnMgJiYgIXRoaXMuaXNUcmVlR3Jvd2luZyAmJiAhdGhpcy5pc0dyb3d0aEZpbmlzaGVkKSB7XG4gICAgaWYgKHRoaXMucHJ1bmVkTm9kZXNBbGwubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5pc1RyZWVHcm93aW5nID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMudG90YWxJdGVyYXRpb25zICUgRkRMYXlvdXRDb25zdGFudHMuQ09OVkVSR0VOQ0VfQ0hFQ0tfUEVSSU9EID09IDAgJiYgIXRoaXMuaXNUcmVlR3Jvd2luZyAmJiAhdGhpcy5pc0dyb3d0aEZpbmlzaGVkKSB7XG4gICAgaWYgKHRoaXMuaXNDb252ZXJnZWQoKSkge1xuICAgICAgaWYgKHRoaXMucHJ1bmVkTm9kZXNBbGwubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLmlzVHJlZUdyb3dpbmcgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5jb29saW5nQ3ljbGUrKztcblxuICAgIGlmICh0aGlzLmxheW91dFF1YWxpdHkgPT0gMCkge1xuICAgICAgLy8gcXVhbGl0eSAtIFwiZHJhZnRcIlxuICAgICAgdGhpcy5jb29saW5nQWRqdXN0ZXIgPSB0aGlzLmNvb2xpbmdDeWNsZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubGF5b3V0UXVhbGl0eSA9PSAxKSB7XG4gICAgICAvLyBxdWFsaXR5IC0gXCJkZWZhdWx0XCJcbiAgICAgIHRoaXMuY29vbGluZ0FkanVzdGVyID0gdGhpcy5jb29saW5nQ3ljbGUgLyAzO1xuICAgIH1cblxuICAgIC8vIGNvb2xpbmcgc2NoZWR1bGUgaXMgYmFzZWQgb24gaHR0cDovL3d3dy5idGx1a2UuY29tL3NpbWFuZjEuaHRtbCAtPiBjb29saW5nIHNjaGVkdWxlIDNcbiAgICB0aGlzLmNvb2xpbmdGYWN0b3IgPSBNYXRoLm1heCh0aGlzLmluaXRpYWxDb29saW5nRmFjdG9yIC0gTWF0aC5wb3codGhpcy5jb29saW5nQ3ljbGUsIE1hdGgubG9nKDEwMCAqICh0aGlzLmluaXRpYWxDb29saW5nRmFjdG9yIC0gdGhpcy5maW5hbFRlbXBlcmF0dXJlKSkgLyBNYXRoLmxvZyh0aGlzLm1heENvb2xpbmdDeWNsZSkpIC8gMTAwICogdGhpcy5jb29saW5nQWRqdXN0ZXIsIHRoaXMuZmluYWxUZW1wZXJhdHVyZSk7XG4gICAgdGhpcy5hbmltYXRpb25QZXJpb2QgPSBNYXRoLmNlaWwodGhpcy5pbml0aWFsQW5pbWF0aW9uUGVyaW9kICogTWF0aC5zcXJ0KHRoaXMuY29vbGluZ0ZhY3RvcikpO1xuICB9XG4gIC8vIE9wZXJhdGlvbnMgd2hpbGUgdHJlZSBpcyBncm93aW5nIGFnYWluIFxuICBpZiAodGhpcy5pc1RyZWVHcm93aW5nKSB7XG4gICAgaWYgKHRoaXMuZ3Jvd1RyZWVJdGVyYXRpb25zICUgMTAgPT0gMCkge1xuICAgICAgaWYgKHRoaXMucHJ1bmVkTm9kZXNBbGwubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLmdyYXBoTWFuYWdlci51cGRhdGVCb3VuZHMoKTtcbiAgICAgICAgdGhpcy51cGRhdGVHcmlkKCk7XG4gICAgICAgIHRoaXMuZ3Jvd1RyZWUodGhpcy5wcnVuZWROb2Rlc0FsbCk7XG4gICAgICAgIC8vIFVwZGF0ZSBub2RlcyB0aGF0IGdyYXZpdHkgd2lsbCBiZSBhcHBsaWVkXG4gICAgICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnJlc2V0QWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24oKTtcbiAgICAgICAgdmFyIGFsbE5vZGVzID0gbmV3IFNldCh0aGlzLmdldEFsbE5vZGVzKCkpO1xuICAgICAgICB2YXIgaW50ZXJzZWN0aW9uID0gdGhpcy5ub2Rlc1dpdGhHcmF2aXR5LmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgICAgIHJldHVybiBhbGxOb2Rlcy5oYXMoeCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmdyYXBoTWFuYWdlci5zZXRBbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbihpbnRlcnNlY3Rpb24pO1xuXG4gICAgICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnVwZGF0ZUJvdW5kcygpO1xuICAgICAgICB0aGlzLnVwZGF0ZUdyaWQoKTtcbiAgICAgICAgdGhpcy5jb29saW5nRmFjdG9yID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9DT09MSU5HX0ZBQ1RPUl9JTkNSRU1FTlRBTDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaXNUcmVlR3Jvd2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzR3Jvd3RoRmluaXNoZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmdyb3dUcmVlSXRlcmF0aW9ucysrO1xuICB9XG4gIC8vIE9wZXJhdGlvbnMgYWZ0ZXIgZ3Jvd3RoIGlzIGZpbmlzaGVkXG4gIGlmICh0aGlzLmlzR3Jvd3RoRmluaXNoZWQpIHtcbiAgICBpZiAodGhpcy5pc0NvbnZlcmdlZCgpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuYWZ0ZXJHcm93dGhJdGVyYXRpb25zICUgMTAgPT0gMCkge1xuICAgICAgdGhpcy5ncmFwaE1hbmFnZXIudXBkYXRlQm91bmRzKCk7XG4gICAgICB0aGlzLnVwZGF0ZUdyaWQoKTtcbiAgICB9XG4gICAgdGhpcy5jb29saW5nRmFjdG9yID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9DT09MSU5HX0ZBQ1RPUl9JTkNSRU1FTlRBTCAqICgoMTAwIC0gdGhpcy5hZnRlckdyb3d0aEl0ZXJhdGlvbnMpIC8gMTAwKTtcbiAgICB0aGlzLmFmdGVyR3Jvd3RoSXRlcmF0aW9ucysrO1xuICB9XG5cbiAgdmFyIGdyaWRVcGRhdGVBbGxvd2VkID0gIXRoaXMuaXNUcmVlR3Jvd2luZyAmJiAhdGhpcy5pc0dyb3d0aEZpbmlzaGVkO1xuICB2YXIgZm9yY2VUb05vZGVTdXJyb3VuZGluZ1VwZGF0ZSA9IHRoaXMuZ3Jvd1RyZWVJdGVyYXRpb25zICUgMTAgPT0gMSAmJiB0aGlzLmlzVHJlZUdyb3dpbmcgfHwgdGhpcy5hZnRlckdyb3d0aEl0ZXJhdGlvbnMgJSAxMCA9PSAxICYmIHRoaXMuaXNHcm93dGhGaW5pc2hlZDtcblxuICB0aGlzLnRvdGFsRGlzcGxhY2VtZW50ID0gMDtcbiAgdGhpcy5ncmFwaE1hbmFnZXIudXBkYXRlQm91bmRzKCk7XG4gIHRoaXMuY2FsY1NwcmluZ0ZvcmNlcygpO1xuICB0aGlzLmNhbGNSZXB1bHNpb25Gb3JjZXMoZ3JpZFVwZGF0ZUFsbG93ZWQsIGZvcmNlVG9Ob2RlU3Vycm91bmRpbmdVcGRhdGUpO1xuICB0aGlzLmNhbGNHcmF2aXRhdGlvbmFsRm9yY2VzKCk7XG4gIHRoaXMubW92ZU5vZGVzKCk7XG4gIHRoaXMuYW5pbWF0ZSgpO1xuXG4gIHJldHVybiBmYWxzZTsgLy8gTGF5b3V0IGlzIG5vdCBlbmRlZCB5ZXQgcmV0dXJuIGZhbHNlXG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5nZXRQb3NpdGlvbnNEYXRhID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYWxsTm9kZXMgPSB0aGlzLmdyYXBoTWFuYWdlci5nZXRBbGxOb2RlcygpO1xuICB2YXIgcERhdGEgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciByZWN0ID0gYWxsTm9kZXNbaV0ucmVjdDtcbiAgICB2YXIgaWQgPSBhbGxOb2Rlc1tpXS5pZDtcbiAgICBwRGF0YVtpZF0gPSB7XG4gICAgICBpZDogaWQsXG4gICAgICB4OiByZWN0LmdldENlbnRlclgoKSxcbiAgICAgIHk6IHJlY3QuZ2V0Q2VudGVyWSgpLFxuICAgICAgdzogcmVjdC53aWR0aCxcbiAgICAgIGg6IHJlY3QuaGVpZ2h0XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBwRGF0YTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLnJ1blNwcmluZ0VtYmVkZGVyID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmluaXRpYWxBbmltYXRpb25QZXJpb2QgPSAyNTtcbiAgdGhpcy5hbmltYXRpb25QZXJpb2QgPSB0aGlzLmluaXRpYWxBbmltYXRpb25QZXJpb2Q7XG4gIHZhciBsYXlvdXRFbmRlZCA9IGZhbHNlO1xuXG4gIC8vIElmIGFtaW5hdGUgb3B0aW9uIGlzICdkdXJpbmcnIHNpZ25hbCB0aGF0IGxheW91dCBpcyBzdXBwb3NlZCB0byBzdGFydCBpdGVyYXRpbmdcbiAgaWYgKEZETGF5b3V0Q29uc3RhbnRzLkFOSU1BVEUgPT09ICdkdXJpbmcnKSB7XG4gICAgdGhpcy5lbWl0KCdsYXlvdXRzdGFydGVkJyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgYW1pbmF0ZSBvcHRpb24gaXMgJ2R1cmluZycgdGljaygpIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIG9uIGluZGV4LmpzXG4gICAgd2hpbGUgKCFsYXlvdXRFbmRlZCkge1xuICAgICAgbGF5b3V0RW5kZWQgPSB0aGlzLnRpY2soKTtcbiAgICB9XG5cbiAgICB0aGlzLmdyYXBoTWFuYWdlci51cGRhdGVCb3VuZHMoKTtcbiAgfVxufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUuY2FsY3VsYXRlTm9kZXNUb0FwcGx5R3Jhdml0YXRpb25UbyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vZGVMaXN0ID0gW107XG4gIHZhciBncmFwaDtcblxuICB2YXIgZ3JhcGhzID0gdGhpcy5ncmFwaE1hbmFnZXIuZ2V0R3JhcGhzKCk7XG4gIHZhciBzaXplID0gZ3JhcGhzLmxlbmd0aDtcbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICBncmFwaCA9IGdyYXBoc1tpXTtcblxuICAgIGdyYXBoLnVwZGF0ZUNvbm5lY3RlZCgpO1xuXG4gICAgaWYgKCFncmFwaC5pc0Nvbm5lY3RlZCkge1xuICAgICAgbm9kZUxpc3QgPSBub2RlTGlzdC5jb25jYXQoZ3JhcGguZ2V0Tm9kZXMoKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5vZGVMaXN0O1xufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUuY3JlYXRlQmVuZHBvaW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVkZ2VzID0gW107XG4gIGVkZ2VzID0gZWRnZXMuY29uY2F0KHRoaXMuZ3JhcGhNYW5hZ2VyLmdldEFsbEVkZ2VzKCkpO1xuICB2YXIgdmlzaXRlZCA9IG5ldyBTZXQoKTtcbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlZGdlID0gZWRnZXNbaV07XG5cbiAgICBpZiAoIXZpc2l0ZWQuaGFzKGVkZ2UpKSB7XG4gICAgICB2YXIgc291cmNlID0gZWRnZS5nZXRTb3VyY2UoKTtcbiAgICAgIHZhciB0YXJnZXQgPSBlZGdlLmdldFRhcmdldCgpO1xuXG4gICAgICBpZiAoc291cmNlID09IHRhcmdldCkge1xuICAgICAgICBlZGdlLmdldEJlbmRwb2ludHMoKS5wdXNoKG5ldyBQb2ludEQoKSk7XG4gICAgICAgIGVkZ2UuZ2V0QmVuZHBvaW50cygpLnB1c2gobmV3IFBvaW50RCgpKTtcbiAgICAgICAgdGhpcy5jcmVhdGVEdW1teU5vZGVzRm9yQmVuZHBvaW50cyhlZGdlKTtcbiAgICAgICAgdmlzaXRlZC5hZGQoZWRnZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZWRnZUxpc3QgPSBbXTtcblxuICAgICAgICBlZGdlTGlzdCA9IGVkZ2VMaXN0LmNvbmNhdChzb3VyY2UuZ2V0RWRnZUxpc3RUb05vZGUodGFyZ2V0KSk7XG4gICAgICAgIGVkZ2VMaXN0ID0gZWRnZUxpc3QuY29uY2F0KHRhcmdldC5nZXRFZGdlTGlzdFRvTm9kZShzb3VyY2UpKTtcblxuICAgICAgICBpZiAoIXZpc2l0ZWQuaGFzKGVkZ2VMaXN0WzBdKSkge1xuICAgICAgICAgIGlmIChlZGdlTGlzdC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB2YXIgaztcbiAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBlZGdlTGlzdC5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICB2YXIgbXVsdGlFZGdlID0gZWRnZUxpc3Rba107XG4gICAgICAgICAgICAgIG11bHRpRWRnZS5nZXRCZW5kcG9pbnRzKCkucHVzaChuZXcgUG9pbnREKCkpO1xuICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUR1bW15Tm9kZXNGb3JCZW5kcG9pbnRzKG11bHRpRWRnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVkZ2VMaXN0LmZvckVhY2goZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgICAgICAgIHZpc2l0ZWQuYWRkKGVkZ2UpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHZpc2l0ZWQuc2l6ZSA9PSBlZGdlcy5sZW5ndGgpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUucG9zaXRpb25Ob2Rlc1JhZGlhbGx5ID0gZnVuY3Rpb24gKGZvcmVzdCkge1xuICAvLyBXZSB0aWxlIHRoZSB0cmVlcyB0byBhIGdyaWQgcm93IGJ5IHJvdzsgZmlyc3QgdHJlZSBzdGFydHMgYXQgKDAsMClcbiAgdmFyIGN1cnJlbnRTdGFydGluZ1BvaW50ID0gbmV3IFBvaW50KDAsIDApO1xuICB2YXIgbnVtYmVyT2ZDb2x1bW5zID0gTWF0aC5jZWlsKE1hdGguc3FydChmb3Jlc3QubGVuZ3RoKSk7XG4gIHZhciBoZWlnaHQgPSAwO1xuICB2YXIgY3VycmVudFkgPSAwO1xuICB2YXIgY3VycmVudFggPSAwO1xuICB2YXIgcG9pbnQgPSBuZXcgUG9pbnREKDAsIDApO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZm9yZXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGkgJSBudW1iZXJPZkNvbHVtbnMgPT0gMCkge1xuICAgICAgLy8gU3RhcnQgb2YgYSBuZXcgcm93LCBtYWtlIHRoZSB4IGNvb3JkaW5hdGUgMCwgaW5jcmVtZW50IHRoZVxuICAgICAgLy8geSBjb29yZGluYXRlIHdpdGggdGhlIG1heCBoZWlnaHQgb2YgdGhlIHByZXZpb3VzIHJvd1xuICAgICAgY3VycmVudFggPSAwO1xuICAgICAgY3VycmVudFkgPSBoZWlnaHQ7XG5cbiAgICAgIGlmIChpICE9IDApIHtcbiAgICAgICAgY3VycmVudFkgKz0gQ29TRUNvbnN0YW50cy5ERUZBVUxUX0NPTVBPTkVOVF9TRVBFUkFUSU9OO1xuICAgICAgfVxuXG4gICAgICBoZWlnaHQgPSAwO1xuICAgIH1cblxuICAgIHZhciB0cmVlID0gZm9yZXN0W2ldO1xuXG4gICAgLy8gRmluZCB0aGUgY2VudGVyIG9mIHRoZSB0cmVlXG4gICAgdmFyIGNlbnRlck5vZGUgPSBMYXlvdXQuZmluZENlbnRlck9mVHJlZSh0cmVlKTtcblxuICAgIC8vIFNldCB0aGUgc3RhcmluZyBwb2ludCBvZiB0aGUgbmV4dCB0cmVlXG4gICAgY3VycmVudFN0YXJ0aW5nUG9pbnQueCA9IGN1cnJlbnRYO1xuICAgIGN1cnJlbnRTdGFydGluZ1BvaW50LnkgPSBjdXJyZW50WTtcblxuICAgIC8vIERvIGEgcmFkaWFsIGxheW91dCBzdGFydGluZyB3aXRoIHRoZSBjZW50ZXJcbiAgICBwb2ludCA9IENvU0VMYXlvdXQucmFkaWFsTGF5b3V0KHRyZWUsIGNlbnRlck5vZGUsIGN1cnJlbnRTdGFydGluZ1BvaW50KTtcblxuICAgIGlmIChwb2ludC55ID4gaGVpZ2h0KSB7XG4gICAgICBoZWlnaHQgPSBNYXRoLmZsb29yKHBvaW50LnkpO1xuICAgIH1cblxuICAgIGN1cnJlbnRYID0gTWF0aC5mbG9vcihwb2ludC54ICsgQ29TRUNvbnN0YW50cy5ERUZBVUxUX0NPTVBPTkVOVF9TRVBFUkFUSU9OKTtcbiAgfVxuXG4gIHRoaXMudHJhbnNmb3JtKG5ldyBQb2ludEQoTGF5b3V0Q29uc3RhbnRzLldPUkxEX0NFTlRFUl9YIC0gcG9pbnQueCAvIDIsIExheW91dENvbnN0YW50cy5XT1JMRF9DRU5URVJfWSAtIHBvaW50LnkgLyAyKSk7XG59O1xuXG5Db1NFTGF5b3V0LnJhZGlhbExheW91dCA9IGZ1bmN0aW9uICh0cmVlLCBjZW50ZXJOb2RlLCBzdGFydGluZ1BvaW50KSB7XG4gIHZhciByYWRpYWxTZXAgPSBNYXRoLm1heCh0aGlzLm1heERpYWdvbmFsSW5UcmVlKHRyZWUpLCBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfUkFESUFMX1NFUEFSQVRJT04pO1xuICBDb1NFTGF5b3V0LmJyYW5jaFJhZGlhbExheW91dChjZW50ZXJOb2RlLCBudWxsLCAwLCAzNTksIDAsIHJhZGlhbFNlcCk7XG4gIHZhciBib3VuZHMgPSBMR3JhcGguY2FsY3VsYXRlQm91bmRzKHRyZWUpO1xuXG4gIHZhciB0cmFuc2Zvcm0gPSBuZXcgVHJhbnNmb3JtKCk7XG4gIHRyYW5zZm9ybS5zZXREZXZpY2VPcmdYKGJvdW5kcy5nZXRNaW5YKCkpO1xuICB0cmFuc2Zvcm0uc2V0RGV2aWNlT3JnWShib3VuZHMuZ2V0TWluWSgpKTtcbiAgdHJhbnNmb3JtLnNldFdvcmxkT3JnWChzdGFydGluZ1BvaW50LngpO1xuICB0cmFuc2Zvcm0uc2V0V29ybGRPcmdZKHN0YXJ0aW5nUG9pbnQueSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVlLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5vZGUgPSB0cmVlW2ldO1xuICAgIG5vZGUudHJhbnNmb3JtKHRyYW5zZm9ybSk7XG4gIH1cblxuICB2YXIgYm90dG9tUmlnaHQgPSBuZXcgUG9pbnREKGJvdW5kcy5nZXRNYXhYKCksIGJvdW5kcy5nZXRNYXhZKCkpO1xuXG4gIHJldHVybiB0cmFuc2Zvcm0uaW52ZXJzZVRyYW5zZm9ybVBvaW50KGJvdHRvbVJpZ2h0KTtcbn07XG5cbkNvU0VMYXlvdXQuYnJhbmNoUmFkaWFsTGF5b3V0ID0gZnVuY3Rpb24gKG5vZGUsIHBhcmVudE9mTm9kZSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGRpc3RhbmNlLCByYWRpYWxTZXBhcmF0aW9uKSB7XG4gIC8vIEZpcnN0LCBwb3NpdGlvbiB0aGlzIG5vZGUgYnkgZmluZGluZyBpdHMgYW5nbGUuXG4gIHZhciBoYWxmSW50ZXJ2YWwgPSAoZW5kQW5nbGUgLSBzdGFydEFuZ2xlICsgMSkgLyAyO1xuXG4gIGlmIChoYWxmSW50ZXJ2YWwgPCAwKSB7XG4gICAgaGFsZkludGVydmFsICs9IDE4MDtcbiAgfVxuXG4gIHZhciBub2RlQW5nbGUgPSAoaGFsZkludGVydmFsICsgc3RhcnRBbmdsZSkgJSAzNjA7XG4gIHZhciB0ZXRhID0gbm9kZUFuZ2xlICogSUdlb21ldHJ5LlRXT19QSSAvIDM2MDtcblxuICAvLyBNYWtlIHBvbGFyIHRvIGphdmEgY29yZGluYXRlIGNvbnZlcnNpb24uXG4gIHZhciBjb3NfdGV0YSA9IE1hdGguY29zKHRldGEpO1xuICB2YXIgeF8gPSBkaXN0YW5jZSAqIE1hdGguY29zKHRldGEpO1xuICB2YXIgeV8gPSBkaXN0YW5jZSAqIE1hdGguc2luKHRldGEpO1xuXG4gIG5vZGUuc2V0Q2VudGVyKHhfLCB5Xyk7XG5cbiAgLy8gVHJhdmVyc2UgYWxsIG5laWdoYm9ycyBvZiB0aGlzIG5vZGUgYW5kIHJlY3Vyc2l2ZWx5IGNhbGwgdGhpc1xuICAvLyBmdW5jdGlvbi5cbiAgdmFyIG5laWdoYm9yRWRnZXMgPSBbXTtcbiAgbmVpZ2hib3JFZGdlcyA9IG5laWdoYm9yRWRnZXMuY29uY2F0KG5vZGUuZ2V0RWRnZXMoKSk7XG4gIHZhciBjaGlsZENvdW50ID0gbmVpZ2hib3JFZGdlcy5sZW5ndGg7XG5cbiAgaWYgKHBhcmVudE9mTm9kZSAhPSBudWxsKSB7XG4gICAgY2hpbGRDb3VudC0tO1xuICB9XG5cbiAgdmFyIGJyYW5jaENvdW50ID0gMDtcblxuICB2YXIgaW5jRWRnZXNDb3VudCA9IG5laWdoYm9yRWRnZXMubGVuZ3RoO1xuICB2YXIgc3RhcnRJbmRleDtcblxuICB2YXIgZWRnZXMgPSBub2RlLmdldEVkZ2VzQmV0d2VlbihwYXJlbnRPZk5vZGUpO1xuXG4gIC8vIElmIHRoZXJlIGFyZSBtdWx0aXBsZSBlZGdlcywgcHJ1bmUgdGhlbSB1bnRpbCB0aGVyZSByZW1haW5zIG9ubHkgb25lXG4gIC8vIGVkZ2UuXG4gIHdoaWxlIChlZGdlcy5sZW5ndGggPiAxKSB7XG4gICAgLy9uZWlnaGJvckVkZ2VzLnJlbW92ZShlZGdlcy5yZW1vdmUoMCkpO1xuICAgIHZhciB0ZW1wID0gZWRnZXNbMF07XG4gICAgZWRnZXMuc3BsaWNlKDAsIDEpO1xuICAgIHZhciBpbmRleCA9IG5laWdoYm9yRWRnZXMuaW5kZXhPZih0ZW1wKTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgbmVpZ2hib3JFZGdlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgICBpbmNFZGdlc0NvdW50LS07XG4gICAgY2hpbGRDb3VudC0tO1xuICB9XG5cbiAgaWYgKHBhcmVudE9mTm9kZSAhPSBudWxsKSB7XG4gICAgLy9hc3NlcnQgZWRnZXMubGVuZ3RoID09IDE7XG4gICAgc3RhcnRJbmRleCA9IChuZWlnaGJvckVkZ2VzLmluZGV4T2YoZWRnZXNbMF0pICsgMSkgJSBpbmNFZGdlc0NvdW50O1xuICB9IGVsc2Uge1xuICAgIHN0YXJ0SW5kZXggPSAwO1xuICB9XG5cbiAgdmFyIHN0ZXBBbmdsZSA9IE1hdGguYWJzKGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSkgLyBjaGlsZENvdW50O1xuXG4gIGZvciAodmFyIGkgPSBzdGFydEluZGV4OyBicmFuY2hDb3VudCAhPSBjaGlsZENvdW50OyBpID0gKytpICUgaW5jRWRnZXNDb3VudCkge1xuICAgIHZhciBjdXJyZW50TmVpZ2hib3IgPSBuZWlnaGJvckVkZ2VzW2ldLmdldE90aGVyRW5kKG5vZGUpO1xuXG4gICAgLy8gRG9uJ3QgYmFjayB0cmF2ZXJzZSB0byByb290IG5vZGUgaW4gY3VycmVudCB0cmVlLlxuICAgIGlmIChjdXJyZW50TmVpZ2hib3IgPT0gcGFyZW50T2ZOb2RlKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgY2hpbGRTdGFydEFuZ2xlID0gKHN0YXJ0QW5nbGUgKyBicmFuY2hDb3VudCAqIHN0ZXBBbmdsZSkgJSAzNjA7XG4gICAgdmFyIGNoaWxkRW5kQW5nbGUgPSAoY2hpbGRTdGFydEFuZ2xlICsgc3RlcEFuZ2xlKSAlIDM2MDtcblxuICAgIENvU0VMYXlvdXQuYnJhbmNoUmFkaWFsTGF5b3V0KGN1cnJlbnROZWlnaGJvciwgbm9kZSwgY2hpbGRTdGFydEFuZ2xlLCBjaGlsZEVuZEFuZ2xlLCBkaXN0YW5jZSArIHJhZGlhbFNlcGFyYXRpb24sIHJhZGlhbFNlcGFyYXRpb24pO1xuXG4gICAgYnJhbmNoQ291bnQrKztcbiAgfVxufTtcblxuQ29TRUxheW91dC5tYXhEaWFnb25hbEluVHJlZSA9IGZ1bmN0aW9uICh0cmVlKSB7XG4gIHZhciBtYXhEaWFnb25hbCA9IEludGVnZXIuTUlOX1ZBTFVFO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdHJlZS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBub2RlID0gdHJlZVtpXTtcbiAgICB2YXIgZGlhZ29uYWwgPSBub2RlLmdldERpYWdvbmFsKCk7XG5cbiAgICBpZiAoZGlhZ29uYWwgPiBtYXhEaWFnb25hbCkge1xuICAgICAgbWF4RGlhZ29uYWwgPSBkaWFnb25hbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWF4RGlhZ29uYWw7XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5jYWxjUmVwdWxzaW9uUmFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIGZvcm11bGEgaXMgMiB4IChsZXZlbCArIDEpIHggaWRlYWxFZGdlTGVuZ3RoXG4gIHJldHVybiAyICogKHRoaXMubGV2ZWwgKyAxKSAqIHRoaXMuaWRlYWxFZGdlTGVuZ3RoO1xufTtcblxuLy8gVGlsaW5nIG1ldGhvZHNcblxuLy8gR3JvdXAgemVybyBkZWdyZWUgbWVtYmVycyB3aG9zZSBwYXJlbnRzIGFyZSBub3QgdG8gYmUgdGlsZWQsIGNyZWF0ZSBkdW1teSBwYXJlbnRzIHdoZXJlIG5lZWRlZCBhbmQgZmlsbCBtZW1iZXJHcm91cHMgYnkgdGhlaXIgZHVtbXAgcGFyZW50IGlkJ3NcbkNvU0VMYXlvdXQucHJvdG90eXBlLmdyb3VwWmVyb0RlZ3JlZU1lbWJlcnMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgLy8gYXJyYXkgb2YgW3BhcmVudF9pZCB4IG9uZURlZ3JlZU5vZGVfaWRdXG4gIHZhciB0ZW1wTWVtYmVyR3JvdXBzID0ge307IC8vIEEgdGVtcG9yYXJ5IG1hcCBvZiBwYXJlbnQgbm9kZSBhbmQgaXRzIHplcm8gZGVncmVlIG1lbWJlcnNcbiAgdGhpcy5tZW1iZXJHcm91cHMgPSB7fTsgLy8gQSBtYXAgb2YgZHVtbXkgcGFyZW50IG5vZGUgYW5kIGl0cyB6ZXJvIGRlZ3JlZSBtZW1iZXJzIHdob3NlIHBhcmVudHMgYXJlIG5vdCB0byBiZSB0aWxlZFxuICB0aGlzLmlkVG9EdW1teU5vZGUgPSB7fTsgLy8gQSBtYXAgb2YgaWQgdG8gZHVtbXkgbm9kZSBcblxuICB2YXIgemVyb0RlZ3JlZSA9IFtdOyAvLyBMaXN0IG9mIHplcm8gZGVncmVlIG5vZGVzIHdob3NlIHBhcmVudHMgYXJlIG5vdCB0byBiZSB0aWxlZFxuICB2YXIgYWxsTm9kZXMgPSB0aGlzLmdyYXBoTWFuYWdlci5nZXRBbGxOb2RlcygpO1xuXG4gIC8vIEZpbGwgemVybyBkZWdyZWUgbGlzdFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5vZGUgPSBhbGxOb2Rlc1tpXTtcbiAgICB2YXIgcGFyZW50ID0gbm9kZS5nZXRQYXJlbnQoKTtcbiAgICAvLyBJZiBhIG5vZGUgaGFzIHplcm8gZGVncmVlIGFuZCBpdHMgcGFyZW50IGlzIG5vdCB0byBiZSB0aWxlZCBpZiBleGlzdHMgYWRkIHRoYXQgbm9kZSB0byB6ZXJvRGVncmVzIGxpc3RcbiAgICBpZiAodGhpcy5nZXROb2RlRGVncmVlV2l0aENoaWxkcmVuKG5vZGUpID09PSAwICYmIChwYXJlbnQuaWQgPT0gdW5kZWZpbmVkIHx8ICF0aGlzLmdldFRvQmVUaWxlZChwYXJlbnQpKSkge1xuICAgICAgemVyb0RlZ3JlZS5wdXNoKG5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIENyZWF0ZSBhIG1hcCBvZiBwYXJlbnQgbm9kZSBhbmQgaXRzIHplcm8gZGVncmVlIG1lbWJlcnNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB6ZXJvRGVncmVlLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5vZGUgPSB6ZXJvRGVncmVlW2ldOyAvLyBaZXJvIGRlZ3JlZSBub2RlIGl0c2VsZlxuICAgIHZhciBwX2lkID0gbm9kZS5nZXRQYXJlbnQoKS5pZDsgLy8gUGFyZW50IGlkXG5cbiAgICBpZiAodHlwZW9mIHRlbXBNZW1iZXJHcm91cHNbcF9pZF0gPT09IFwidW5kZWZpbmVkXCIpIHRlbXBNZW1iZXJHcm91cHNbcF9pZF0gPSBbXTtcblxuICAgIHRlbXBNZW1iZXJHcm91cHNbcF9pZF0gPSB0ZW1wTWVtYmVyR3JvdXBzW3BfaWRdLmNvbmNhdChub2RlKTsgLy8gUHVzaCBub2RlIHRvIHRoZSBsaXN0IGJlbG9uZ3MgdG8gaXRzIHBhcmVudCBpbiB0ZW1wTWVtYmVyR3JvdXBzXG4gIH1cblxuICAvLyBJZiB0aGVyZSBhcmUgYXQgbGVhc3QgdHdvIG5vZGVzIGF0IGEgbGV2ZWwsIGNyZWF0ZSBhIGR1bW15IGNvbXBvdW5kIGZvciB0aGVtXG4gIE9iamVjdC5rZXlzKHRlbXBNZW1iZXJHcm91cHMpLmZvckVhY2goZnVuY3Rpb24gKHBfaWQpIHtcbiAgICBpZiAodGVtcE1lbWJlckdyb3Vwc1twX2lkXS5sZW5ndGggPiAxKSB7XG4gICAgICB2YXIgZHVtbXlDb21wb3VuZElkID0gXCJEdW1teUNvbXBvdW5kX1wiICsgcF9pZDsgLy8gVGhlIGlkIG9mIGR1bW15IGNvbXBvdW5kIHdoaWNoIHdpbGwgYmUgY3JlYXRlZCBzb29uXG4gICAgICBzZWxmLm1lbWJlckdyb3Vwc1tkdW1teUNvbXBvdW5kSWRdID0gdGVtcE1lbWJlckdyb3Vwc1twX2lkXTsgLy8gQWRkIGR1bW15IGNvbXBvdW5kIHRvIG1lbWJlckdyb3Vwc1xuXG4gICAgICB2YXIgcGFyZW50ID0gdGVtcE1lbWJlckdyb3Vwc1twX2lkXVswXS5nZXRQYXJlbnQoKTsgLy8gVGhlIHBhcmVudCBvZiB6ZXJvIGRlZ3JlZSBub2RlcyB3aWxsIGJlIHRoZSBwYXJlbnQgb2YgbmV3IGR1bW15IGNvbXBvdW5kXG5cbiAgICAgIC8vIENyZWF0ZSBhIGR1bW15IGNvbXBvdW5kIHdpdGggY2FsY3VsYXRlZCBpZFxuICAgICAgdmFyIGR1bW15Q29tcG91bmQgPSBuZXcgQ29TRU5vZGUoc2VsZi5ncmFwaE1hbmFnZXIpO1xuICAgICAgZHVtbXlDb21wb3VuZC5pZCA9IGR1bW15Q29tcG91bmRJZDtcbiAgICAgIGR1bW15Q29tcG91bmQucGFkZGluZ0xlZnQgPSBwYXJlbnQucGFkZGluZ0xlZnQgfHwgMDtcbiAgICAgIGR1bW15Q29tcG91bmQucGFkZGluZ1JpZ2h0ID0gcGFyZW50LnBhZGRpbmdSaWdodCB8fCAwO1xuICAgICAgZHVtbXlDb21wb3VuZC5wYWRkaW5nQm90dG9tID0gcGFyZW50LnBhZGRpbmdCb3R0b20gfHwgMDtcbiAgICAgIGR1bW15Q29tcG91bmQucGFkZGluZ1RvcCA9IHBhcmVudC5wYWRkaW5nVG9wIHx8IDA7XG5cbiAgICAgIHNlbGYuaWRUb0R1bW15Tm9kZVtkdW1teUNvbXBvdW5kSWRdID0gZHVtbXlDb21wb3VuZDtcblxuICAgICAgdmFyIGR1bW15UGFyZW50R3JhcGggPSBzZWxmLmdldEdyYXBoTWFuYWdlcigpLmFkZChzZWxmLm5ld0dyYXBoKCksIGR1bW15Q29tcG91bmQpO1xuICAgICAgdmFyIHBhcmVudEdyYXBoID0gcGFyZW50LmdldENoaWxkKCk7XG5cbiAgICAgIC8vIEFkZCBkdW1teSBjb21wb3VuZCB0byBwYXJlbnQgdGhlIGdyYXBoXG4gICAgICBwYXJlbnRHcmFwaC5hZGQoZHVtbXlDb21wb3VuZCk7XG5cbiAgICAgIC8vIEZvciBlYWNoIHplcm8gZGVncmVlIG5vZGUgaW4gdGhpcyBsZXZlbCByZW1vdmUgaXQgZnJvbSBpdHMgcGFyZW50IGdyYXBoIGFuZCBhZGQgaXQgdG8gdGhlIGdyYXBoIG9mIGR1bW15IHBhcmVudFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZW1wTWVtYmVyR3JvdXBzW3BfaWRdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gdGVtcE1lbWJlckdyb3Vwc1twX2lkXVtpXTtcblxuICAgICAgICBwYXJlbnRHcmFwaC5yZW1vdmUobm9kZSk7XG4gICAgICAgIGR1bW15UGFyZW50R3JhcGguYWRkKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5jbGVhckNvbXBvdW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNoaWxkR3JhcGhNYXAgPSB7fTtcbiAgdmFyIGlkVG9Ob2RlID0ge307XG5cbiAgLy8gR2V0IGNvbXBvdW5kIG9yZGVyaW5nIGJ5IGZpbmRpbmcgdGhlIGlubmVyIG9uZSBmaXJzdFxuICB0aGlzLnBlcmZvcm1ERlNPbkNvbXBvdW5kcygpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb21wb3VuZE9yZGVyLmxlbmd0aDsgaSsrKSB7XG5cbiAgICBpZFRvTm9kZVt0aGlzLmNvbXBvdW5kT3JkZXJbaV0uaWRdID0gdGhpcy5jb21wb3VuZE9yZGVyW2ldO1xuICAgIGNoaWxkR3JhcGhNYXBbdGhpcy5jb21wb3VuZE9yZGVyW2ldLmlkXSA9IFtdLmNvbmNhdCh0aGlzLmNvbXBvdW5kT3JkZXJbaV0uZ2V0Q2hpbGQoKS5nZXROb2RlcygpKTtcblxuICAgIC8vIFJlbW92ZSBjaGlsZHJlbiBvZiBjb21wb3VuZHNcbiAgICB0aGlzLmdyYXBoTWFuYWdlci5yZW1vdmUodGhpcy5jb21wb3VuZE9yZGVyW2ldLmdldENoaWxkKCkpO1xuICAgIHRoaXMuY29tcG91bmRPcmRlcltpXS5jaGlsZCA9IG51bGw7XG4gIH1cblxuICB0aGlzLmdyYXBoTWFuYWdlci5yZXNldEFsbE5vZGVzKCk7XG5cbiAgLy8gVGlsZSB0aGUgcmVtb3ZlZCBjaGlsZHJlblxuICB0aGlzLnRpbGVDb21wb3VuZE1lbWJlcnMoY2hpbGRHcmFwaE1hcCwgaWRUb05vZGUpO1xufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUuY2xlYXJaZXJvRGVncmVlTWVtYmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdGlsZWRaZXJvRGVncmVlUGFjayA9IHRoaXMudGlsZWRaZXJvRGVncmVlUGFjayA9IFtdO1xuXG4gIE9iamVjdC5rZXlzKHRoaXMubWVtYmVyR3JvdXBzKS5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBjb21wb3VuZE5vZGUgPSBzZWxmLmlkVG9EdW1teU5vZGVbaWRdOyAvLyBHZXQgdGhlIGR1bW15IGNvbXBvdW5kXG5cbiAgICB0aWxlZFplcm9EZWdyZWVQYWNrW2lkXSA9IHNlbGYudGlsZU5vZGVzKHNlbGYubWVtYmVyR3JvdXBzW2lkXSwgY29tcG91bmROb2RlLnBhZGRpbmdMZWZ0ICsgY29tcG91bmROb2RlLnBhZGRpbmdSaWdodCk7XG5cbiAgICAvLyBTZXQgdGhlIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIGR1bW15IGNvbXBvdW5kIGFzIGNhbGN1bGF0ZWRcbiAgICBjb21wb3VuZE5vZGUucmVjdC53aWR0aCA9IHRpbGVkWmVyb0RlZ3JlZVBhY2tbaWRdLndpZHRoO1xuICAgIGNvbXBvdW5kTm9kZS5yZWN0LmhlaWdodCA9IHRpbGVkWmVyb0RlZ3JlZVBhY2tbaWRdLmhlaWdodDtcbiAgfSk7XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5yZXBvcHVsYXRlQ29tcG91bmRzID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBpID0gdGhpcy5jb21wb3VuZE9yZGVyLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGxDb21wb3VuZE5vZGUgPSB0aGlzLmNvbXBvdW5kT3JkZXJbaV07XG4gICAgdmFyIGlkID0gbENvbXBvdW5kTm9kZS5pZDtcbiAgICB2YXIgaG9yaXpvbnRhbE1hcmdpbiA9IGxDb21wb3VuZE5vZGUucGFkZGluZ0xlZnQ7XG4gICAgdmFyIHZlcnRpY2FsTWFyZ2luID0gbENvbXBvdW5kTm9kZS5wYWRkaW5nVG9wO1xuXG4gICAgdGhpcy5hZGp1c3RMb2NhdGlvbnModGhpcy50aWxlZE1lbWJlclBhY2tbaWRdLCBsQ29tcG91bmROb2RlLnJlY3QueCwgbENvbXBvdW5kTm9kZS5yZWN0LnksIGhvcml6b250YWxNYXJnaW4sIHZlcnRpY2FsTWFyZ2luKTtcbiAgfVxufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUucmVwb3B1bGF0ZVplcm9EZWdyZWVNZW1iZXJzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB0aWxlZFBhY2sgPSB0aGlzLnRpbGVkWmVyb0RlZ3JlZVBhY2s7XG5cbiAgT2JqZWN0LmtleXModGlsZWRQYWNrKS5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBjb21wb3VuZE5vZGUgPSBzZWxmLmlkVG9EdW1teU5vZGVbaWRdOyAvLyBHZXQgdGhlIGR1bW15IGNvbXBvdW5kIGJ5IGl0cyBpZFxuICAgIHZhciBob3Jpem9udGFsTWFyZ2luID0gY29tcG91bmROb2RlLnBhZGRpbmdMZWZ0O1xuICAgIHZhciB2ZXJ0aWNhbE1hcmdpbiA9IGNvbXBvdW5kTm9kZS5wYWRkaW5nVG9wO1xuXG4gICAgLy8gQWRqdXN0IHRoZSBwb3NpdGlvbnMgb2Ygbm9kZXMgd3J0IGl0cyBjb21wb3VuZFxuICAgIHNlbGYuYWRqdXN0TG9jYXRpb25zKHRpbGVkUGFja1tpZF0sIGNvbXBvdW5kTm9kZS5yZWN0LngsIGNvbXBvdW5kTm9kZS5yZWN0LnksIGhvcml6b250YWxNYXJnaW4sIHZlcnRpY2FsTWFyZ2luKTtcbiAgfSk7XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5nZXRUb0JlVGlsZWQgPSBmdW5jdGlvbiAobm9kZSkge1xuICB2YXIgaWQgPSBub2RlLmlkO1xuICAvL2ZpcnN0bHkgY2hlY2sgdGhlIHByZXZpb3VzIHJlc3VsdHNcbiAgaWYgKHRoaXMudG9CZVRpbGVkW2lkXSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMudG9CZVRpbGVkW2lkXTtcbiAgfVxuXG4gIC8vb25seSBjb21wb3VuZCBub2RlcyBhcmUgdG8gYmUgdGlsZWRcbiAgdmFyIGNoaWxkR3JhcGggPSBub2RlLmdldENoaWxkKCk7XG4gIGlmIChjaGlsZEdyYXBoID09IG51bGwpIHtcbiAgICB0aGlzLnRvQmVUaWxlZFtpZF0gPSBmYWxzZTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgY2hpbGRyZW4gPSBjaGlsZEdyYXBoLmdldE5vZGVzKCk7IC8vIEdldCB0aGUgY2hpbGRyZW4gbm9kZXNcblxuICAvL2EgY29tcG91bmQgbm9kZSBpcyBub3QgdG8gYmUgdGlsZWQgaWYgYWxsIG9mIGl0cyBjb21wb3VuZCBjaGlsZHJlbiBhcmUgbm90IHRvIGJlIHRpbGVkXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdGhlQ2hpbGQgPSBjaGlsZHJlbltpXTtcblxuICAgIGlmICh0aGlzLmdldE5vZGVEZWdyZWUodGhlQ2hpbGQpID4gMCkge1xuICAgICAgdGhpcy50b0JlVGlsZWRbaWRdID0gZmFsc2U7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy9wYXNzIHRoZSBjaGlsZHJlbiBub3QgaGF2aW5nIHRoZSBjb21wb3VuZCBzdHJ1Y3R1cmVcbiAgICBpZiAodGhlQ2hpbGQuZ2V0Q2hpbGQoKSA9PSBudWxsKSB7XG4gICAgICB0aGlzLnRvQmVUaWxlZFt0aGVDaGlsZC5pZF0gPSBmYWxzZTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5nZXRUb0JlVGlsZWQodGhlQ2hpbGQpKSB7XG4gICAgICB0aGlzLnRvQmVUaWxlZFtpZF0gPSBmYWxzZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgdGhpcy50b0JlVGlsZWRbaWRdID0gdHJ1ZTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vLyBHZXQgZGVncmVlIG9mIGEgbm9kZSBkZXBlbmRpbmcgb2YgaXRzIGVkZ2VzIGFuZCBpbmRlcGVuZGVudCBvZiBpdHMgY2hpbGRyZW5cbkNvU0VMYXlvdXQucHJvdG90eXBlLmdldE5vZGVEZWdyZWUgPSBmdW5jdGlvbiAobm9kZSkge1xuICB2YXIgaWQgPSBub2RlLmlkO1xuICB2YXIgZWRnZXMgPSBub2RlLmdldEVkZ2VzKCk7XG4gIHZhciBkZWdyZWUgPSAwO1xuXG4gIC8vIEZvciB0aGUgZWRnZXMgY29ubmVjdGVkXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWRnZSA9IGVkZ2VzW2ldO1xuICAgIGlmIChlZGdlLmdldFNvdXJjZSgpLmlkICE9PSBlZGdlLmdldFRhcmdldCgpLmlkKSB7XG4gICAgICBkZWdyZWUgPSBkZWdyZWUgKyAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVncmVlO1xufTtcblxuLy8gR2V0IGRlZ3JlZSBvZiBhIG5vZGUgd2l0aCBpdHMgY2hpbGRyZW5cbkNvU0VMYXlvdXQucHJvdG90eXBlLmdldE5vZGVEZWdyZWVXaXRoQ2hpbGRyZW4gPSBmdW5jdGlvbiAobm9kZSkge1xuICB2YXIgZGVncmVlID0gdGhpcy5nZXROb2RlRGVncmVlKG5vZGUpO1xuICBpZiAobm9kZS5nZXRDaGlsZCgpID09IG51bGwpIHtcbiAgICByZXR1cm4gZGVncmVlO1xuICB9XG4gIHZhciBjaGlsZHJlbiA9IG5vZGUuZ2V0Q2hpbGQoKS5nZXROb2RlcygpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgZGVncmVlICs9IHRoaXMuZ2V0Tm9kZURlZ3JlZVdpdGhDaGlsZHJlbihjaGlsZCk7XG4gIH1cbiAgcmV0dXJuIGRlZ3JlZTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLnBlcmZvcm1ERlNPbkNvbXBvdW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5jb21wb3VuZE9yZGVyID0gW107XG4gIHRoaXMuZmlsbENvbXBleE9yZGVyQnlERlModGhpcy5ncmFwaE1hbmFnZXIuZ2V0Um9vdCgpLmdldE5vZGVzKCkpO1xufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUuZmlsbENvbXBleE9yZGVyQnlERlMgPSBmdW5jdGlvbiAoY2hpbGRyZW4pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgIGlmIChjaGlsZC5nZXRDaGlsZCgpICE9IG51bGwpIHtcbiAgICAgIHRoaXMuZmlsbENvbXBleE9yZGVyQnlERlMoY2hpbGQuZ2V0Q2hpbGQoKS5nZXROb2RlcygpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZ2V0VG9CZVRpbGVkKGNoaWxkKSkge1xuICAgICAgdGhpcy5jb21wb3VuZE9yZGVyLnB1c2goY2hpbGQpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4qIFRoaXMgbWV0aG9kIHBsYWNlcyBlYWNoIHplcm8gZGVncmVlIG1lbWJlciB3cnQgZ2l2ZW4gKHgseSkgY29vcmRpbmF0ZXMgKHRvcCBsZWZ0KS5cbiovXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5hZGp1c3RMb2NhdGlvbnMgPSBmdW5jdGlvbiAob3JnYW5pemF0aW9uLCB4LCB5LCBjb21wb3VuZEhvcml6b250YWxNYXJnaW4sIGNvbXBvdW5kVmVydGljYWxNYXJnaW4pIHtcbiAgeCArPSBjb21wb3VuZEhvcml6b250YWxNYXJnaW47XG4gIHkgKz0gY29tcG91bmRWZXJ0aWNhbE1hcmdpbjtcblxuICB2YXIgbGVmdCA9IHg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmdhbml6YXRpb24ucm93cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciByb3cgPSBvcmdhbml6YXRpb24ucm93c1tpXTtcbiAgICB4ID0gbGVmdDtcbiAgICB2YXIgbWF4SGVpZ2h0ID0gMDtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgcm93Lmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgbG5vZGUgPSByb3dbal07XG5cbiAgICAgIGxub2RlLnJlY3QueCA9IHg7IC8vICsgbG5vZGUucmVjdC53aWR0aCAvIDI7XG4gICAgICBsbm9kZS5yZWN0LnkgPSB5OyAvLyArIGxub2RlLnJlY3QuaGVpZ2h0IC8gMjtcblxuICAgICAgeCArPSBsbm9kZS5yZWN0LndpZHRoICsgb3JnYW5pemF0aW9uLmhvcml6b250YWxQYWRkaW5nO1xuXG4gICAgICBpZiAobG5vZGUucmVjdC5oZWlnaHQgPiBtYXhIZWlnaHQpIG1heEhlaWdodCA9IGxub2RlLnJlY3QuaGVpZ2h0O1xuICAgIH1cblxuICAgIHkgKz0gbWF4SGVpZ2h0ICsgb3JnYW5pemF0aW9uLnZlcnRpY2FsUGFkZGluZztcbiAgfVxufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUudGlsZUNvbXBvdW5kTWVtYmVycyA9IGZ1bmN0aW9uIChjaGlsZEdyYXBoTWFwLCBpZFRvTm9kZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMudGlsZWRNZW1iZXJQYWNrID0gW107XG5cbiAgT2JqZWN0LmtleXMoY2hpbGRHcmFwaE1hcCkuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICAvLyBHZXQgdGhlIGNvbXBvdW5kIG5vZGVcbiAgICB2YXIgY29tcG91bmROb2RlID0gaWRUb05vZGVbaWRdO1xuXG4gICAgc2VsZi50aWxlZE1lbWJlclBhY2tbaWRdID0gc2VsZi50aWxlTm9kZXMoY2hpbGRHcmFwaE1hcFtpZF0sIGNvbXBvdW5kTm9kZS5wYWRkaW5nTGVmdCArIGNvbXBvdW5kTm9kZS5wYWRkaW5nUmlnaHQpO1xuXG4gICAgY29tcG91bmROb2RlLnJlY3Qud2lkdGggPSBzZWxmLnRpbGVkTWVtYmVyUGFja1tpZF0ud2lkdGg7XG4gICAgY29tcG91bmROb2RlLnJlY3QuaGVpZ2h0ID0gc2VsZi50aWxlZE1lbWJlclBhY2tbaWRdLmhlaWdodDtcbiAgfSk7XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS50aWxlTm9kZXMgPSBmdW5jdGlvbiAobm9kZXMsIG1pbldpZHRoKSB7XG4gIHZhciB2ZXJ0aWNhbFBhZGRpbmcgPSBDb1NFQ29uc3RhbnRzLlRJTElOR19QQURESU5HX1ZFUlRJQ0FMO1xuICB2YXIgaG9yaXpvbnRhbFBhZGRpbmcgPSBDb1NFQ29uc3RhbnRzLlRJTElOR19QQURESU5HX0hPUklaT05UQUw7XG4gIHZhciBvcmdhbml6YXRpb24gPSB7XG4gICAgcm93czogW10sXG4gICAgcm93V2lkdGg6IFtdLFxuICAgIHJvd0hlaWdodDogW10sXG4gICAgd2lkdGg6IDAsXG4gICAgaGVpZ2h0OiBtaW5XaWR0aCwgLy8gYXNzdW1lIG1pbkhlaWdodCBlcXVhbHMgdG8gbWluV2lkdGhcbiAgICB2ZXJ0aWNhbFBhZGRpbmc6IHZlcnRpY2FsUGFkZGluZyxcbiAgICBob3Jpem9udGFsUGFkZGluZzogaG9yaXpvbnRhbFBhZGRpbmdcbiAgfTtcblxuICAvLyBTb3J0IHRoZSBub2RlcyBpbiBhc2NlbmRpbmcgb3JkZXIgb2YgdGhlaXIgYXJlYXNcbiAgbm9kZXMuc29ydChmdW5jdGlvbiAobjEsIG4yKSB7XG4gICAgaWYgKG4xLnJlY3Qud2lkdGggKiBuMS5yZWN0LmhlaWdodCA+IG4yLnJlY3Qud2lkdGggKiBuMi5yZWN0LmhlaWdodCkgcmV0dXJuIC0xO1xuICAgIGlmIChuMS5yZWN0LndpZHRoICogbjEucmVjdC5oZWlnaHQgPCBuMi5yZWN0LndpZHRoICogbjIucmVjdC5oZWlnaHQpIHJldHVybiAxO1xuICAgIHJldHVybiAwO1xuICB9KTtcblxuICAvLyBDcmVhdGUgdGhlIG9yZ2FuaXphdGlvbiAtPiB0aWxlIG1lbWJlcnNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBsTm9kZSA9IG5vZGVzW2ldO1xuXG4gICAgaWYgKG9yZ2FuaXphdGlvbi5yb3dzLmxlbmd0aCA9PSAwKSB7XG4gICAgICB0aGlzLmluc2VydE5vZGVUb1Jvdyhvcmdhbml6YXRpb24sIGxOb2RlLCAwLCBtaW5XaWR0aCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmNhbkFkZEhvcml6b250YWwob3JnYW5pemF0aW9uLCBsTm9kZS5yZWN0LndpZHRoLCBsTm9kZS5yZWN0LmhlaWdodCkpIHtcbiAgICAgIHRoaXMuaW5zZXJ0Tm9kZVRvUm93KG9yZ2FuaXphdGlvbiwgbE5vZGUsIHRoaXMuZ2V0U2hvcnRlc3RSb3dJbmRleChvcmdhbml6YXRpb24pLCBtaW5XaWR0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaW5zZXJ0Tm9kZVRvUm93KG9yZ2FuaXphdGlvbiwgbE5vZGUsIG9yZ2FuaXphdGlvbi5yb3dzLmxlbmd0aCwgbWluV2lkdGgpO1xuICAgIH1cblxuICAgIHRoaXMuc2hpZnRUb0xhc3RSb3cob3JnYW5pemF0aW9uKTtcbiAgfVxuXG4gIHJldHVybiBvcmdhbml6YXRpb247XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5pbnNlcnROb2RlVG9Sb3cgPSBmdW5jdGlvbiAob3JnYW5pemF0aW9uLCBub2RlLCByb3dJbmRleCwgbWluV2lkdGgpIHtcbiAgdmFyIG1pbkNvbXBvdW5kU2l6ZSA9IG1pbldpZHRoO1xuXG4gIC8vIEFkZCBuZXcgcm93IGlmIG5lZWRlZFxuICBpZiAocm93SW5kZXggPT0gb3JnYW5pemF0aW9uLnJvd3MubGVuZ3RoKSB7XG4gICAgdmFyIHNlY29uZERpbWVuc2lvbiA9IFtdO1xuXG4gICAgb3JnYW5pemF0aW9uLnJvd3MucHVzaChzZWNvbmREaW1lbnNpb24pO1xuICAgIG9yZ2FuaXphdGlvbi5yb3dXaWR0aC5wdXNoKG1pbkNvbXBvdW5kU2l6ZSk7XG4gICAgb3JnYW5pemF0aW9uLnJvd0hlaWdodC5wdXNoKDApO1xuICB9XG5cbiAgLy8gVXBkYXRlIHJvdyB3aWR0aFxuICB2YXIgdyA9IG9yZ2FuaXphdGlvbi5yb3dXaWR0aFtyb3dJbmRleF0gKyBub2RlLnJlY3Qud2lkdGg7XG5cbiAgaWYgKG9yZ2FuaXphdGlvbi5yb3dzW3Jvd0luZGV4XS5sZW5ndGggPiAwKSB7XG4gICAgdyArPSBvcmdhbml6YXRpb24uaG9yaXpvbnRhbFBhZGRpbmc7XG4gIH1cblxuICBvcmdhbml6YXRpb24ucm93V2lkdGhbcm93SW5kZXhdID0gdztcbiAgLy8gVXBkYXRlIGNvbXBvdW5kIHdpZHRoXG4gIGlmIChvcmdhbml6YXRpb24ud2lkdGggPCB3KSB7XG4gICAgb3JnYW5pemF0aW9uLndpZHRoID0gdztcbiAgfVxuXG4gIC8vIFVwZGF0ZSBoZWlnaHRcbiAgdmFyIGggPSBub2RlLnJlY3QuaGVpZ2h0O1xuICBpZiAocm93SW5kZXggPiAwKSBoICs9IG9yZ2FuaXphdGlvbi52ZXJ0aWNhbFBhZGRpbmc7XG5cbiAgdmFyIGV4dHJhSGVpZ2h0ID0gMDtcbiAgaWYgKGggPiBvcmdhbml6YXRpb24ucm93SGVpZ2h0W3Jvd0luZGV4XSkge1xuICAgIGV4dHJhSGVpZ2h0ID0gb3JnYW5pemF0aW9uLnJvd0hlaWdodFtyb3dJbmRleF07XG4gICAgb3JnYW5pemF0aW9uLnJvd0hlaWdodFtyb3dJbmRleF0gPSBoO1xuICAgIGV4dHJhSGVpZ2h0ID0gb3JnYW5pemF0aW9uLnJvd0hlaWdodFtyb3dJbmRleF0gLSBleHRyYUhlaWdodDtcbiAgfVxuXG4gIG9yZ2FuaXphdGlvbi5oZWlnaHQgKz0gZXh0cmFIZWlnaHQ7XG5cbiAgLy8gSW5zZXJ0IG5vZGVcbiAgb3JnYW5pemF0aW9uLnJvd3Nbcm93SW5kZXhdLnB1c2gobm9kZSk7XG59O1xuXG4vL1NjYW5zIHRoZSByb3dzIG9mIGFuIG9yZ2FuaXphdGlvbiBhbmQgcmV0dXJucyB0aGUgb25lIHdpdGggdGhlIG1pbiB3aWR0aFxuQ29TRUxheW91dC5wcm90b3R5cGUuZ2V0U2hvcnRlc3RSb3dJbmRleCA9IGZ1bmN0aW9uIChvcmdhbml6YXRpb24pIHtcbiAgdmFyIHIgPSAtMTtcbiAgdmFyIG1pbiA9IE51bWJlci5NQVhfVkFMVUU7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmdhbml6YXRpb24ucm93cy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChvcmdhbml6YXRpb24ucm93V2lkdGhbaV0gPCBtaW4pIHtcbiAgICAgIHIgPSBpO1xuICAgICAgbWluID0gb3JnYW5pemF0aW9uLnJvd1dpZHRoW2ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcjtcbn07XG5cbi8vU2NhbnMgdGhlIHJvd3Mgb2YgYW4gb3JnYW5pemF0aW9uIGFuZCByZXR1cm5zIHRoZSBvbmUgd2l0aCB0aGUgbWF4IHdpZHRoXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5nZXRMb25nZXN0Um93SW5kZXggPSBmdW5jdGlvbiAob3JnYW5pemF0aW9uKSB7XG4gIHZhciByID0gLTE7XG4gIHZhciBtYXggPSBOdW1iZXIuTUlOX1ZBTFVFO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3JnYW5pemF0aW9uLnJvd3MubGVuZ3RoOyBpKyspIHtcblxuICAgIGlmIChvcmdhbml6YXRpb24ucm93V2lkdGhbaV0gPiBtYXgpIHtcbiAgICAgIHIgPSBpO1xuICAgICAgbWF4ID0gb3JnYW5pemF0aW9uLnJvd1dpZHRoW2ldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByO1xufTtcblxuLyoqXG4qIFRoaXMgbWV0aG9kIGNoZWNrcyB3aGV0aGVyIGFkZGluZyBleHRyYSB3aWR0aCB0byB0aGUgb3JnYW5pemF0aW9uIHZpb2xhdGVzXG4qIHRoZSBhc3BlY3QgcmF0aW8oMSkgb3Igbm90LlxuKi9cbkNvU0VMYXlvdXQucHJvdG90eXBlLmNhbkFkZEhvcml6b250YWwgPSBmdW5jdGlvbiAob3JnYW5pemF0aW9uLCBleHRyYVdpZHRoLCBleHRyYUhlaWdodCkge1xuXG4gIHZhciBzcmkgPSB0aGlzLmdldFNob3J0ZXN0Um93SW5kZXgob3JnYW5pemF0aW9uKTtcblxuICBpZiAoc3JpIDwgMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIG1pbiA9IG9yZ2FuaXphdGlvbi5yb3dXaWR0aFtzcmldO1xuXG4gIGlmIChtaW4gKyBvcmdhbml6YXRpb24uaG9yaXpvbnRhbFBhZGRpbmcgKyBleHRyYVdpZHRoIDw9IG9yZ2FuaXphdGlvbi53aWR0aCkgcmV0dXJuIHRydWU7XG5cbiAgdmFyIGhEaWZmID0gMDtcblxuICAvLyBBZGRpbmcgdG8gYW4gZXhpc3Rpbmcgcm93XG4gIGlmIChvcmdhbml6YXRpb24ucm93SGVpZ2h0W3NyaV0gPCBleHRyYUhlaWdodCkge1xuICAgIGlmIChzcmkgPiAwKSBoRGlmZiA9IGV4dHJhSGVpZ2h0ICsgb3JnYW5pemF0aW9uLnZlcnRpY2FsUGFkZGluZyAtIG9yZ2FuaXphdGlvbi5yb3dIZWlnaHRbc3JpXTtcbiAgfVxuXG4gIHZhciBhZGRfdG9fcm93X3JhdGlvO1xuICBpZiAob3JnYW5pemF0aW9uLndpZHRoIC0gbWluID49IGV4dHJhV2lkdGggKyBvcmdhbml6YXRpb24uaG9yaXpvbnRhbFBhZGRpbmcpIHtcbiAgICBhZGRfdG9fcm93X3JhdGlvID0gKG9yZ2FuaXphdGlvbi5oZWlnaHQgKyBoRGlmZikgLyAobWluICsgZXh0cmFXaWR0aCArIG9yZ2FuaXphdGlvbi5ob3Jpem9udGFsUGFkZGluZyk7XG4gIH0gZWxzZSB7XG4gICAgYWRkX3RvX3Jvd19yYXRpbyA9IChvcmdhbml6YXRpb24uaGVpZ2h0ICsgaERpZmYpIC8gb3JnYW5pemF0aW9uLndpZHRoO1xuICB9XG5cbiAgLy8gQWRkaW5nIGEgbmV3IHJvdyBmb3IgdGhpcyBub2RlXG4gIGhEaWZmID0gZXh0cmFIZWlnaHQgKyBvcmdhbml6YXRpb24udmVydGljYWxQYWRkaW5nO1xuICB2YXIgYWRkX25ld19yb3dfcmF0aW87XG4gIGlmIChvcmdhbml6YXRpb24ud2lkdGggPCBleHRyYVdpZHRoKSB7XG4gICAgYWRkX25ld19yb3dfcmF0aW8gPSAob3JnYW5pemF0aW9uLmhlaWdodCArIGhEaWZmKSAvIGV4dHJhV2lkdGg7XG4gIH0gZWxzZSB7XG4gICAgYWRkX25ld19yb3dfcmF0aW8gPSAob3JnYW5pemF0aW9uLmhlaWdodCArIGhEaWZmKSAvIG9yZ2FuaXphdGlvbi53aWR0aDtcbiAgfVxuXG4gIGlmIChhZGRfbmV3X3Jvd19yYXRpbyA8IDEpIGFkZF9uZXdfcm93X3JhdGlvID0gMSAvIGFkZF9uZXdfcm93X3JhdGlvO1xuXG4gIGlmIChhZGRfdG9fcm93X3JhdGlvIDwgMSkgYWRkX3RvX3Jvd19yYXRpbyA9IDEgLyBhZGRfdG9fcm93X3JhdGlvO1xuXG4gIHJldHVybiBhZGRfdG9fcm93X3JhdGlvIDwgYWRkX25ld19yb3dfcmF0aW87XG59O1xuXG4vL0lmIG1vdmluZyB0aGUgbGFzdCBub2RlIGZyb20gdGhlIGxvbmdlc3Qgcm93IGFuZCBhZGRpbmcgaXQgdG8gdGhlIGxhc3Rcbi8vcm93IG1ha2VzIHRoZSBib3VuZGluZyBib3ggc21hbGxlciwgZG8gaXQuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5zaGlmdFRvTGFzdFJvdyA9IGZ1bmN0aW9uIChvcmdhbml6YXRpb24pIHtcbiAgdmFyIGxvbmdlc3QgPSB0aGlzLmdldExvbmdlc3RSb3dJbmRleChvcmdhbml6YXRpb24pO1xuICB2YXIgbGFzdCA9IG9yZ2FuaXphdGlvbi5yb3dXaWR0aC5sZW5ndGggLSAxO1xuICB2YXIgcm93ID0gb3JnYW5pemF0aW9uLnJvd3NbbG9uZ2VzdF07XG4gIHZhciBub2RlID0gcm93W3Jvdy5sZW5ndGggLSAxXTtcblxuICB2YXIgZGlmZiA9IG5vZGUud2lkdGggKyBvcmdhbml6YXRpb24uaG9yaXpvbnRhbFBhZGRpbmc7XG5cbiAgLy8gQ2hlY2sgaWYgdGhlcmUgaXMgZW5vdWdoIHNwYWNlIG9uIHRoZSBsYXN0IHJvd1xuICBpZiAob3JnYW5pemF0aW9uLndpZHRoIC0gb3JnYW5pemF0aW9uLnJvd1dpZHRoW2xhc3RdID4gZGlmZiAmJiBsb25nZXN0ICE9IGxhc3QpIHtcbiAgICAvLyBSZW1vdmUgdGhlIGxhc3QgZWxlbWVudCBvZiB0aGUgbG9uZ2VzdCByb3dcbiAgICByb3cuc3BsaWNlKC0xLCAxKTtcblxuICAgIC8vIFB1c2ggaXQgdG8gdGhlIGxhc3Qgcm93XG4gICAgb3JnYW5pemF0aW9uLnJvd3NbbGFzdF0ucHVzaChub2RlKTtcblxuICAgIG9yZ2FuaXphdGlvbi5yb3dXaWR0aFtsb25nZXN0XSA9IG9yZ2FuaXphdGlvbi5yb3dXaWR0aFtsb25nZXN0XSAtIGRpZmY7XG4gICAgb3JnYW5pemF0aW9uLnJvd1dpZHRoW2xhc3RdID0gb3JnYW5pemF0aW9uLnJvd1dpZHRoW2xhc3RdICsgZGlmZjtcbiAgICBvcmdhbml6YXRpb24ud2lkdGggPSBvcmdhbml6YXRpb24ucm93V2lkdGhbaW5zdGFuY2UuZ2V0TG9uZ2VzdFJvd0luZGV4KG9yZ2FuaXphdGlvbildO1xuXG4gICAgLy8gVXBkYXRlIGhlaWdodHMgb2YgdGhlIG9yZ2FuaXphdGlvblxuICAgIHZhciBtYXhIZWlnaHQgPSBOdW1iZXIuTUlOX1ZBTFVFO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm93Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocm93W2ldLmhlaWdodCA+IG1heEhlaWdodCkgbWF4SGVpZ2h0ID0gcm93W2ldLmhlaWdodDtcbiAgICB9XG4gICAgaWYgKGxvbmdlc3QgPiAwKSBtYXhIZWlnaHQgKz0gb3JnYW5pemF0aW9uLnZlcnRpY2FsUGFkZGluZztcblxuICAgIHZhciBwcmV2VG90YWwgPSBvcmdhbml6YXRpb24ucm93SGVpZ2h0W2xvbmdlc3RdICsgb3JnYW5pemF0aW9uLnJvd0hlaWdodFtsYXN0XTtcblxuICAgIG9yZ2FuaXphdGlvbi5yb3dIZWlnaHRbbG9uZ2VzdF0gPSBtYXhIZWlnaHQ7XG4gICAgaWYgKG9yZ2FuaXphdGlvbi5yb3dIZWlnaHRbbGFzdF0gPCBub2RlLmhlaWdodCArIG9yZ2FuaXphdGlvbi52ZXJ0aWNhbFBhZGRpbmcpIG9yZ2FuaXphdGlvbi5yb3dIZWlnaHRbbGFzdF0gPSBub2RlLmhlaWdodCArIG9yZ2FuaXphdGlvbi52ZXJ0aWNhbFBhZGRpbmc7XG5cbiAgICB2YXIgZmluYWxUb3RhbCA9IG9yZ2FuaXphdGlvbi5yb3dIZWlnaHRbbG9uZ2VzdF0gKyBvcmdhbml6YXRpb24ucm93SGVpZ2h0W2xhc3RdO1xuICAgIG9yZ2FuaXphdGlvbi5oZWlnaHQgKz0gZmluYWxUb3RhbCAtIHByZXZUb3RhbDtcblxuICAgIHRoaXMuc2hpZnRUb0xhc3RSb3cob3JnYW5pemF0aW9uKTtcbiAgfVxufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUudGlsaW5nUHJlTGF5b3V0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAoQ29TRUNvbnN0YW50cy5USUxFKSB7XG4gICAgLy8gRmluZCB6ZXJvIGRlZ3JlZSBub2RlcyBhbmQgY3JlYXRlIGEgY29tcG91bmQgZm9yIGVhY2ggbGV2ZWxcbiAgICB0aGlzLmdyb3VwWmVyb0RlZ3JlZU1lbWJlcnMoKTtcbiAgICAvLyBUaWxlIGFuZCBjbGVhciBjaGlsZHJlbiBvZiBlYWNoIGNvbXBvdW5kXG4gICAgdGhpcy5jbGVhckNvbXBvdW5kcygpO1xuICAgIC8vIFNlcGFyYXRlbHkgdGlsZSBhbmQgY2xlYXIgemVybyBkZWdyZWUgbm9kZXMgZm9yIGVhY2ggbGV2ZWxcbiAgICB0aGlzLmNsZWFyWmVyb0RlZ3JlZU1lbWJlcnMoKTtcbiAgfVxufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUudGlsaW5nUG9zdExheW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKENvU0VDb25zdGFudHMuVElMRSkge1xuICAgIHRoaXMucmVwb3B1bGF0ZVplcm9EZWdyZWVNZW1iZXJzKCk7XG4gICAgdGhpcy5yZXBvcHVsYXRlQ29tcG91bmRzKCk7XG4gIH1cbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBTZWN0aW9uOiBUcmVlIFJlZHVjdGlvbiBtZXRob2RzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUmVkdWNlIHRyZWVzIFxuQ29TRUxheW91dC5wcm90b3R5cGUucmVkdWNlVHJlZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBwcnVuZWROb2Rlc0FsbCA9IFtdO1xuICB2YXIgY29udGFpbnNMZWFmID0gdHJ1ZTtcbiAgdmFyIG5vZGU7XG5cbiAgd2hpbGUgKGNvbnRhaW5zTGVhZikge1xuICAgIHZhciBhbGxOb2RlcyA9IHRoaXMuZ3JhcGhNYW5hZ2VyLmdldEFsbE5vZGVzKCk7XG4gICAgdmFyIHBydW5lZE5vZGVzSW5TdGVwVGVtcCA9IFtdO1xuICAgIGNvbnRhaW5zTGVhZiA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgbm9kZSA9IGFsbE5vZGVzW2ldO1xuICAgICAgaWYgKG5vZGUuZ2V0RWRnZXMoKS5sZW5ndGggPT0gMSAmJiAhbm9kZS5nZXRFZGdlcygpWzBdLmlzSW50ZXJHcmFwaCAmJiBub2RlLmdldENoaWxkKCkgPT0gbnVsbCkge1xuICAgICAgICBwcnVuZWROb2Rlc0luU3RlcFRlbXAucHVzaChbbm9kZSwgbm9kZS5nZXRFZGdlcygpWzBdLCBub2RlLmdldE93bmVyKCldKTtcbiAgICAgICAgY29udGFpbnNMZWFmID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvbnRhaW5zTGVhZiA9PSB0cnVlKSB7XG4gICAgICB2YXIgcHJ1bmVkTm9kZXNJblN0ZXAgPSBbXTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcHJ1bmVkTm9kZXNJblN0ZXBUZW1wLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChwcnVuZWROb2Rlc0luU3RlcFRlbXBbal1bMF0uZ2V0RWRnZXMoKS5sZW5ndGggPT0gMSkge1xuICAgICAgICAgIHBydW5lZE5vZGVzSW5TdGVwLnB1c2gocHJ1bmVkTm9kZXNJblN0ZXBUZW1wW2pdKTtcbiAgICAgICAgICBwcnVuZWROb2Rlc0luU3RlcFRlbXBbal1bMF0uZ2V0T3duZXIoKS5yZW1vdmUocHJ1bmVkTm9kZXNJblN0ZXBUZW1wW2pdWzBdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcHJ1bmVkTm9kZXNBbGwucHVzaChwcnVuZWROb2Rlc0luU3RlcCk7XG4gICAgICB0aGlzLmdyYXBoTWFuYWdlci5yZXNldEFsbE5vZGVzKCk7XG4gICAgICB0aGlzLmdyYXBoTWFuYWdlci5yZXNldEFsbEVkZ2VzKCk7XG4gICAgfVxuICB9XG4gIHRoaXMucHJ1bmVkTm9kZXNBbGwgPSBwcnVuZWROb2Rlc0FsbDtcbn07XG5cbi8vIEdyb3cgdHJlZSBvbmUgc3RlcCBcbkNvU0VMYXlvdXQucHJvdG90eXBlLmdyb3dUcmVlID0gZnVuY3Rpb24gKHBydW5lZE5vZGVzQWxsKSB7XG4gIHZhciBsZW5ndGhPZlBydW5lZE5vZGVzSW5TdGVwID0gcHJ1bmVkTm9kZXNBbGwubGVuZ3RoO1xuICB2YXIgcHJ1bmVkTm9kZXNJblN0ZXAgPSBwcnVuZWROb2Rlc0FsbFtsZW5ndGhPZlBydW5lZE5vZGVzSW5TdGVwIC0gMV07XG5cbiAgdmFyIG5vZGVEYXRhO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBydW5lZE5vZGVzSW5TdGVwLmxlbmd0aDsgaSsrKSB7XG4gICAgbm9kZURhdGEgPSBwcnVuZWROb2Rlc0luU3RlcFtpXTtcblxuICAgIHRoaXMuZmluZFBsYWNlZm9yUHJ1bmVkTm9kZShub2RlRGF0YSk7XG5cbiAgICBub2RlRGF0YVsyXS5hZGQobm9kZURhdGFbMF0pO1xuICAgIG5vZGVEYXRhWzJdLmFkZChub2RlRGF0YVsxXSwgbm9kZURhdGFbMV0uc291cmNlLCBub2RlRGF0YVsxXS50YXJnZXQpO1xuICB9XG5cbiAgcHJ1bmVkTm9kZXNBbGwuc3BsaWNlKHBydW5lZE5vZGVzQWxsLmxlbmd0aCAtIDEsIDEpO1xuICB0aGlzLmdyYXBoTWFuYWdlci5yZXNldEFsbE5vZGVzKCk7XG4gIHRoaXMuZ3JhcGhNYW5hZ2VyLnJlc2V0QWxsRWRnZXMoKTtcbn07XG5cbi8vIEZpbmQgYW4gYXBwcm9wcmlhdGUgcG9zaXRpb24gdG8gcmVwbGFjZSBwcnVuZWQgbm9kZSwgdGhpcyBtZXRob2QgY2FuIGJlIGltcHJvdmVkXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5maW5kUGxhY2Vmb3JQcnVuZWROb2RlID0gZnVuY3Rpb24gKG5vZGVEYXRhKSB7XG5cbiAgdmFyIGdyaWRGb3JQcnVuZWROb2RlO1xuICB2YXIgbm9kZVRvQ29ubmVjdDtcbiAgdmFyIHBydW5lZE5vZGUgPSBub2RlRGF0YVswXTtcbiAgaWYgKHBydW5lZE5vZGUgPT0gbm9kZURhdGFbMV0uc291cmNlKSB7XG4gICAgbm9kZVRvQ29ubmVjdCA9IG5vZGVEYXRhWzFdLnRhcmdldDtcbiAgfSBlbHNlIHtcbiAgICBub2RlVG9Db25uZWN0ID0gbm9kZURhdGFbMV0uc291cmNlO1xuICB9XG4gIHZhciBzdGFydEdyaWRYID0gbm9kZVRvQ29ubmVjdC5zdGFydFg7XG4gIHZhciBmaW5pc2hHcmlkWCA9IG5vZGVUb0Nvbm5lY3QuZmluaXNoWDtcbiAgdmFyIHN0YXJ0R3JpZFkgPSBub2RlVG9Db25uZWN0LnN0YXJ0WTtcbiAgdmFyIGZpbmlzaEdyaWRZID0gbm9kZVRvQ29ubmVjdC5maW5pc2hZO1xuXG4gIHZhciB1cE5vZGVDb3VudCA9IDA7XG4gIHZhciBkb3duTm9kZUNvdW50ID0gMDtcbiAgdmFyIHJpZ2h0Tm9kZUNvdW50ID0gMDtcbiAgdmFyIGxlZnROb2RlQ291bnQgPSAwO1xuICB2YXIgY29udHJvbFJlZ2lvbnMgPSBbdXBOb2RlQ291bnQsIHJpZ2h0Tm9kZUNvdW50LCBkb3duTm9kZUNvdW50LCBsZWZ0Tm9kZUNvdW50XTtcblxuICBpZiAoc3RhcnRHcmlkWSA+IDApIHtcbiAgICBmb3IgKHZhciBpID0gc3RhcnRHcmlkWDsgaSA8PSBmaW5pc2hHcmlkWDsgaSsrKSB7XG4gICAgICBjb250cm9sUmVnaW9uc1swXSArPSB0aGlzLmdyaWRbaV1bc3RhcnRHcmlkWSAtIDFdLmxlbmd0aCArIHRoaXMuZ3JpZFtpXVtzdGFydEdyaWRZXS5sZW5ndGggLSAxO1xuICAgIH1cbiAgfVxuICBpZiAoZmluaXNoR3JpZFggPCB0aGlzLmdyaWQubGVuZ3RoIC0gMSkge1xuICAgIGZvciAodmFyIGkgPSBzdGFydEdyaWRZOyBpIDw9IGZpbmlzaEdyaWRZOyBpKyspIHtcbiAgICAgIGNvbnRyb2xSZWdpb25zWzFdICs9IHRoaXMuZ3JpZFtmaW5pc2hHcmlkWCArIDFdW2ldLmxlbmd0aCArIHRoaXMuZ3JpZFtmaW5pc2hHcmlkWF1baV0ubGVuZ3RoIC0gMTtcbiAgICB9XG4gIH1cbiAgaWYgKGZpbmlzaEdyaWRZIDwgdGhpcy5ncmlkWzBdLmxlbmd0aCAtIDEpIHtcbiAgICBmb3IgKHZhciBpID0gc3RhcnRHcmlkWDsgaSA8PSBmaW5pc2hHcmlkWDsgaSsrKSB7XG4gICAgICBjb250cm9sUmVnaW9uc1syXSArPSB0aGlzLmdyaWRbaV1bZmluaXNoR3JpZFkgKyAxXS5sZW5ndGggKyB0aGlzLmdyaWRbaV1bZmluaXNoR3JpZFldLmxlbmd0aCAtIDE7XG4gICAgfVxuICB9XG4gIGlmIChzdGFydEdyaWRYID4gMCkge1xuICAgIGZvciAodmFyIGkgPSBzdGFydEdyaWRZOyBpIDw9IGZpbmlzaEdyaWRZOyBpKyspIHtcbiAgICAgIGNvbnRyb2xSZWdpb25zWzNdICs9IHRoaXMuZ3JpZFtzdGFydEdyaWRYIC0gMV1baV0ubGVuZ3RoICsgdGhpcy5ncmlkW3N0YXJ0R3JpZFhdW2ldLmxlbmd0aCAtIDE7XG4gICAgfVxuICB9XG4gIHZhciBtaW4gPSBJbnRlZ2VyLk1BWF9WQUxVRTtcbiAgdmFyIG1pbkNvdW50O1xuICB2YXIgbWluSW5kZXg7XG4gIGZvciAodmFyIGogPSAwOyBqIDwgY29udHJvbFJlZ2lvbnMubGVuZ3RoOyBqKyspIHtcbiAgICBpZiAoY29udHJvbFJlZ2lvbnNbal0gPCBtaW4pIHtcbiAgICAgIG1pbiA9IGNvbnRyb2xSZWdpb25zW2pdO1xuICAgICAgbWluQ291bnQgPSAxO1xuICAgICAgbWluSW5kZXggPSBqO1xuICAgIH0gZWxzZSBpZiAoY29udHJvbFJlZ2lvbnNbal0gPT0gbWluKSB7XG4gICAgICBtaW5Db3VudCsrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChtaW5Db3VudCA9PSAzICYmIG1pbiA9PSAwKSB7XG4gICAgaWYgKGNvbnRyb2xSZWdpb25zWzBdID09IDAgJiYgY29udHJvbFJlZ2lvbnNbMV0gPT0gMCAmJiBjb250cm9sUmVnaW9uc1syXSA9PSAwKSB7XG4gICAgICBncmlkRm9yUHJ1bmVkTm9kZSA9IDE7XG4gICAgfSBlbHNlIGlmIChjb250cm9sUmVnaW9uc1swXSA9PSAwICYmIGNvbnRyb2xSZWdpb25zWzFdID09IDAgJiYgY29udHJvbFJlZ2lvbnNbM10gPT0gMCkge1xuICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAwO1xuICAgIH0gZWxzZSBpZiAoY29udHJvbFJlZ2lvbnNbMF0gPT0gMCAmJiBjb250cm9sUmVnaW9uc1syXSA9PSAwICYmIGNvbnRyb2xSZWdpb25zWzNdID09IDApIHtcbiAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gMztcbiAgICB9IGVsc2UgaWYgKGNvbnRyb2xSZWdpb25zWzFdID09IDAgJiYgY29udHJvbFJlZ2lvbnNbMl0gPT0gMCAmJiBjb250cm9sUmVnaW9uc1szXSA9PSAwKSB7XG4gICAgICBncmlkRm9yUHJ1bmVkTm9kZSA9IDI7XG4gICAgfVxuICB9IGVsc2UgaWYgKG1pbkNvdW50ID09IDIgJiYgbWluID09IDApIHtcbiAgICB2YXIgcmFuZG9tID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMik7XG4gICAgaWYgKGNvbnRyb2xSZWdpb25zWzBdID09IDAgJiYgY29udHJvbFJlZ2lvbnNbMV0gPT0gMCkge1xuICAgICAgO1xuICAgICAgaWYgKHJhbmRvbSA9PSAwKSB7XG4gICAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gMTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNvbnRyb2xSZWdpb25zWzBdID09IDAgJiYgY29udHJvbFJlZ2lvbnNbMl0gPT0gMCkge1xuICAgICAgaWYgKHJhbmRvbSA9PSAwKSB7XG4gICAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gMjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNvbnRyb2xSZWdpb25zWzBdID09IDAgJiYgY29udHJvbFJlZ2lvbnNbM10gPT0gMCkge1xuICAgICAgaWYgKHJhbmRvbSA9PSAwKSB7XG4gICAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gMztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNvbnRyb2xSZWdpb25zWzFdID09IDAgJiYgY29udHJvbFJlZ2lvbnNbMl0gPT0gMCkge1xuICAgICAgaWYgKHJhbmRvbSA9PSAwKSB7XG4gICAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gMjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNvbnRyb2xSZWdpb25zWzFdID09IDAgJiYgY29udHJvbFJlZ2lvbnNbM10gPT0gMCkge1xuICAgICAgaWYgKHJhbmRvbSA9PSAwKSB7XG4gICAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gMztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHJhbmRvbSA9PSAwKSB7XG4gICAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gMztcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAobWluQ291bnQgPT0gNCAmJiBtaW4gPT0gMCkge1xuICAgIHZhciByYW5kb20gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA0KTtcbiAgICBncmlkRm9yUHJ1bmVkTm9kZSA9IHJhbmRvbTtcbiAgfSBlbHNlIHtcbiAgICBncmlkRm9yUHJ1bmVkTm9kZSA9IG1pbkluZGV4O1xuICB9XG5cbiAgaWYgKGdyaWRGb3JQcnVuZWROb2RlID09IDApIHtcbiAgICBwcnVuZWROb2RlLnNldENlbnRlcihub2RlVG9Db25uZWN0LmdldENlbnRlclgoKSwgbm9kZVRvQ29ubmVjdC5nZXRDZW50ZXJZKCkgLSBub2RlVG9Db25uZWN0LmdldEhlaWdodCgpIC8gMiAtIEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggLSBwcnVuZWROb2RlLmdldEhlaWdodCgpIC8gMik7XG4gIH0gZWxzZSBpZiAoZ3JpZEZvclBydW5lZE5vZGUgPT0gMSkge1xuICAgIHBydW5lZE5vZGUuc2V0Q2VudGVyKG5vZGVUb0Nvbm5lY3QuZ2V0Q2VudGVyWCgpICsgbm9kZVRvQ29ubmVjdC5nZXRXaWR0aCgpIC8gMiArIEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggKyBwcnVuZWROb2RlLmdldFdpZHRoKCkgLyAyLCBub2RlVG9Db25uZWN0LmdldENlbnRlclkoKSk7XG4gIH0gZWxzZSBpZiAoZ3JpZEZvclBydW5lZE5vZGUgPT0gMikge1xuICAgIHBydW5lZE5vZGUuc2V0Q2VudGVyKG5vZGVUb0Nvbm5lY3QuZ2V0Q2VudGVyWCgpLCBub2RlVG9Db25uZWN0LmdldENlbnRlclkoKSArIG5vZGVUb0Nvbm5lY3QuZ2V0SGVpZ2h0KCkgLyAyICsgRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSCArIHBydW5lZE5vZGUuZ2V0SGVpZ2h0KCkgLyAyKTtcbiAgfSBlbHNlIHtcbiAgICBwcnVuZWROb2RlLnNldENlbnRlcihub2RlVG9Db25uZWN0LmdldENlbnRlclgoKSAtIG5vZGVUb0Nvbm5lY3QuZ2V0V2lkdGgoKSAvIDIgLSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIIC0gcHJ1bmVkTm9kZS5nZXRXaWR0aCgpIC8gMiwgbm9kZVRvQ29ubmVjdC5nZXRDZW50ZXJZKCkpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvU0VMYXlvdXQ7XG5cbi8qKiovIH0pLFxuLyogNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgY29zZUJhc2UgPSB7fTtcblxuY29zZUJhc2UubGF5b3V0QmFzZSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5jb3NlQmFzZS5Db1NFQ29uc3RhbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbmNvc2VCYXNlLkNvU0VFZGdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbmNvc2VCYXNlLkNvU0VHcmFwaCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5jb3NlQmFzZS5Db1NFR3JhcGhNYW5hZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcbmNvc2VCYXNlLkNvU0VMYXlvdXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuY29zZUJhc2UuQ29TRU5vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvc2VCYXNlO1xuXG4vKioqLyB9KVxuLyoqKioqKi8gXSk7XG59KTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/cose-base/cose-base.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/cytoscape-cose-bilkent/cytoscape-cose-bilkent.js":
/*!***********************************************************************!*\
  !*** ./node_modules/cytoscape-cose-bilkent/cytoscape-cose-bilkent.js ***!
  \***********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory(__webpack_require__(/*! cose-base */ \"(app-client)/./node_modules/cose-base/cose-base.js\"));\n\telse {}\n})(this, function(__WEBPACK_EXTERNAL_MODULE_0__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_659__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_659__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__nested_webpack_require_659__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__nested_webpack_require_659__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__nested_webpack_require_659__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__nested_webpack_require_659__.d = function(exports, name, getter) {\n/******/ \t\tif(!__nested_webpack_require_659__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__nested_webpack_require_659__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__nested_webpack_require_659__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__nested_webpack_require_659__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__nested_webpack_require_659__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __nested_webpack_require_659__(__nested_webpack_require_659__.s = 1);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __nested_webpack_require_3201__) {\n\n\"use strict\";\n\n\nvar LayoutConstants = __nested_webpack_require_3201__(0).layoutBase.LayoutConstants;\nvar FDLayoutConstants = __nested_webpack_require_3201__(0).layoutBase.FDLayoutConstants;\nvar CoSEConstants = __nested_webpack_require_3201__(0).CoSEConstants;\nvar CoSELayout = __nested_webpack_require_3201__(0).CoSELayout;\nvar CoSENode = __nested_webpack_require_3201__(0).CoSENode;\nvar PointD = __nested_webpack_require_3201__(0).layoutBase.PointD;\nvar DimensionD = __nested_webpack_require_3201__(0).layoutBase.DimensionD;\n\nvar defaults = {\n  // Called on `layoutready`\n  ready: function ready() {},\n  // Called on `layoutstop`\n  stop: function stop() {},\n  // 'draft', 'default' or 'proof\" \n  // - 'draft' fast cooling rate \n  // - 'default' moderate cooling rate \n  // - \"proof\" slow cooling rate\n  quality: 'default',\n  // include labels in node dimensions\n  nodeDimensionsIncludeLabels: false,\n  // number of ticks per frame; higher is faster but more jerky\n  refresh: 30,\n  // Whether to fit the network view after when done\n  fit: true,\n  // Padding on fit\n  padding: 10,\n  // Whether to enable incremental mode\n  randomize: true,\n  // Node repulsion (non overlapping) multiplier\n  nodeRepulsion: 4500,\n  // Ideal edge (non nested) length\n  idealEdgeLength: 50,\n  // Divisor to compute edge forces\n  edgeElasticity: 0.45,\n  // Nesting factor (multiplier) to compute ideal edge length for nested edges\n  nestingFactor: 0.1,\n  // Gravity force (constant)\n  gravity: 0.25,\n  // Maximum number of iterations to perform\n  numIter: 2500,\n  // For enabling tiling\n  tile: true,\n  // Type of layout animation. The option set is {'during', 'end', false}\n  animate: 'end',\n  // Duration for animate:end\n  animationDuration: 500,\n  // Represents the amount of the vertical space to put between the zero degree members during the tiling operation(can also be a function)\n  tilingPaddingVertical: 10,\n  // Represents the amount of the horizontal space to put between the zero degree members during the tiling operation(can also be a function)\n  tilingPaddingHorizontal: 10,\n  // Gravity range (constant) for compounds\n  gravityRangeCompound: 1.5,\n  // Gravity force (constant) for compounds\n  gravityCompound: 1.0,\n  // Gravity range (constant)\n  gravityRange: 3.8,\n  // Initial cooling factor for incremental layout\n  initialEnergyOnIncremental: 0.5\n};\n\nfunction extend(defaults, options) {\n  var obj = {};\n\n  for (var i in defaults) {\n    obj[i] = defaults[i];\n  }\n\n  for (var i in options) {\n    obj[i] = options[i];\n  }\n\n  return obj;\n};\n\nfunction _CoSELayout(_options) {\n  this.options = extend(defaults, _options);\n  getUserOptions(this.options);\n}\n\nvar getUserOptions = function getUserOptions(options) {\n  if (options.nodeRepulsion != null) CoSEConstants.DEFAULT_REPULSION_STRENGTH = FDLayoutConstants.DEFAULT_REPULSION_STRENGTH = options.nodeRepulsion;\n  if (options.idealEdgeLength != null) CoSEConstants.DEFAULT_EDGE_LENGTH = FDLayoutConstants.DEFAULT_EDGE_LENGTH = options.idealEdgeLength;\n  if (options.edgeElasticity != null) CoSEConstants.DEFAULT_SPRING_STRENGTH = FDLayoutConstants.DEFAULT_SPRING_STRENGTH = options.edgeElasticity;\n  if (options.nestingFactor != null) CoSEConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = options.nestingFactor;\n  if (options.gravity != null) CoSEConstants.DEFAULT_GRAVITY_STRENGTH = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH = options.gravity;\n  if (options.numIter != null) CoSEConstants.MAX_ITERATIONS = FDLayoutConstants.MAX_ITERATIONS = options.numIter;\n  if (options.gravityRange != null) CoSEConstants.DEFAULT_GRAVITY_RANGE_FACTOR = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR = options.gravityRange;\n  if (options.gravityCompound != null) CoSEConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = options.gravityCompound;\n  if (options.gravityRangeCompound != null) CoSEConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = options.gravityRangeCompound;\n  if (options.initialEnergyOnIncremental != null) CoSEConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = options.initialEnergyOnIncremental;\n\n  if (options.quality == 'draft') LayoutConstants.QUALITY = 0;else if (options.quality == 'proof') LayoutConstants.QUALITY = 2;else LayoutConstants.QUALITY = 1;\n\n  CoSEConstants.NODE_DIMENSIONS_INCLUDE_LABELS = FDLayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = LayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = options.nodeDimensionsIncludeLabels;\n  CoSEConstants.DEFAULT_INCREMENTAL = FDLayoutConstants.DEFAULT_INCREMENTAL = LayoutConstants.DEFAULT_INCREMENTAL = !options.randomize;\n  CoSEConstants.ANIMATE = FDLayoutConstants.ANIMATE = LayoutConstants.ANIMATE = options.animate;\n  CoSEConstants.TILE = options.tile;\n  CoSEConstants.TILING_PADDING_VERTICAL = typeof options.tilingPaddingVertical === 'function' ? options.tilingPaddingVertical.call() : options.tilingPaddingVertical;\n  CoSEConstants.TILING_PADDING_HORIZONTAL = typeof options.tilingPaddingHorizontal === 'function' ? options.tilingPaddingHorizontal.call() : options.tilingPaddingHorizontal;\n};\n\n_CoSELayout.prototype.run = function () {\n  var ready;\n  var frameId;\n  var options = this.options;\n  var idToLNode = this.idToLNode = {};\n  var layout = this.layout = new CoSELayout();\n  var self = this;\n\n  self.stopped = false;\n\n  this.cy = this.options.cy;\n\n  this.cy.trigger({ type: 'layoutstart', layout: this });\n\n  var gm = layout.newGraphManager();\n  this.gm = gm;\n\n  var nodes = this.options.eles.nodes();\n  var edges = this.options.eles.edges();\n\n  this.root = gm.addRoot();\n  this.processChildrenList(this.root, this.getTopMostNodes(nodes), layout);\n\n  for (var i = 0; i < edges.length; i++) {\n    var edge = edges[i];\n    var sourceNode = this.idToLNode[edge.data(\"source\")];\n    var targetNode = this.idToLNode[edge.data(\"target\")];\n    if (sourceNode !== targetNode && sourceNode.getEdgesBetween(targetNode).length == 0) {\n      var e1 = gm.add(layout.newEdge(), sourceNode, targetNode);\n      e1.id = edge.id();\n    }\n  }\n\n  var getPositions = function getPositions(ele, i) {\n    if (typeof ele === \"number\") {\n      ele = i;\n    }\n    var theId = ele.data('id');\n    var lNode = self.idToLNode[theId];\n\n    return {\n      x: lNode.getRect().getCenterX(),\n      y: lNode.getRect().getCenterY()\n    };\n  };\n\n  /*\n   * Reposition nodes in iterations animatedly\n   */\n  var iterateAnimated = function iterateAnimated() {\n    // Thigs to perform after nodes are repositioned on screen\n    var afterReposition = function afterReposition() {\n      if (options.fit) {\n        options.cy.fit(options.eles, options.padding);\n      }\n\n      if (!ready) {\n        ready = true;\n        self.cy.one('layoutready', options.ready);\n        self.cy.trigger({ type: 'layoutready', layout: self });\n      }\n    };\n\n    var ticksPerFrame = self.options.refresh;\n    var isDone;\n\n    for (var i = 0; i < ticksPerFrame && !isDone; i++) {\n      isDone = self.stopped || self.layout.tick();\n    }\n\n    // If layout is done\n    if (isDone) {\n      // If the layout is not a sublayout and it is successful perform post layout.\n      if (layout.checkLayoutSuccess() && !layout.isSubLayout) {\n        layout.doPostLayout();\n      }\n\n      // If layout has a tilingPostLayout function property call it.\n      if (layout.tilingPostLayout) {\n        layout.tilingPostLayout();\n      }\n\n      layout.isLayoutFinished = true;\n\n      self.options.eles.nodes().positions(getPositions);\n\n      afterReposition();\n\n      // trigger layoutstop when the layout stops (e.g. finishes)\n      self.cy.one('layoutstop', self.options.stop);\n      self.cy.trigger({ type: 'layoutstop', layout: self });\n\n      if (frameId) {\n        cancelAnimationFrame(frameId);\n      }\n\n      ready = false;\n      return;\n    }\n\n    var animationData = self.layout.getPositionsData(); // Get positions of layout nodes note that all nodes may not be layout nodes because of tiling\n\n    // Position nodes, for the nodes whose id does not included in data (because they are removed from their parents and included in dummy compounds)\n    // use position of their ancestors or dummy ancestors\n    options.eles.nodes().positions(function (ele, i) {\n      if (typeof ele === \"number\") {\n        ele = i;\n      }\n      // If ele is a compound node, then its position will be defined by its children\n      if (!ele.isParent()) {\n        var theId = ele.id();\n        var pNode = animationData[theId];\n        var temp = ele;\n        // If pNode is undefined search until finding position data of its first ancestor (It may be dummy as well)\n        while (pNode == null) {\n          pNode = animationData[temp.data('parent')] || animationData['DummyCompound_' + temp.data('parent')];\n          animationData[theId] = pNode;\n          temp = temp.parent()[0];\n          if (temp == undefined) {\n            break;\n          }\n        }\n        if (pNode != null) {\n          return {\n            x: pNode.x,\n            y: pNode.y\n          };\n        } else {\n          return {\n            x: ele.position('x'),\n            y: ele.position('y')\n          };\n        }\n      }\n    });\n\n    afterReposition();\n\n    frameId = requestAnimationFrame(iterateAnimated);\n  };\n\n  /*\n  * Listen 'layoutstarted' event and start animated iteration if animate option is 'during'\n  */\n  layout.addListener('layoutstarted', function () {\n    if (self.options.animate === 'during') {\n      frameId = requestAnimationFrame(iterateAnimated);\n    }\n  });\n\n  layout.runLayout(); // Run cose layout\n\n  /*\n   * If animate option is not 'during' ('end' or false) perform these here (If it is 'during' similar things are already performed)\n   */\n  if (this.options.animate !== \"during\") {\n    self.options.eles.nodes().not(\":parent\").layoutPositions(self, self.options, getPositions); // Use layout positions to reposition the nodes it considers the options parameter\n    ready = false;\n  }\n\n  return this; // chaining\n};\n\n//Get the top most ones of a list of nodes\n_CoSELayout.prototype.getTopMostNodes = function (nodes) {\n  var nodesMap = {};\n  for (var i = 0; i < nodes.length; i++) {\n    nodesMap[nodes[i].id()] = true;\n  }\n  var roots = nodes.filter(function (ele, i) {\n    if (typeof ele === \"number\") {\n      ele = i;\n    }\n    var parent = ele.parent()[0];\n    while (parent != null) {\n      if (nodesMap[parent.id()]) {\n        return false;\n      }\n      parent = parent.parent()[0];\n    }\n    return true;\n  });\n\n  return roots;\n};\n\n_CoSELayout.prototype.processChildrenList = function (parent, children, layout) {\n  var size = children.length;\n  for (var i = 0; i < size; i++) {\n    var theChild = children[i];\n    var children_of_children = theChild.children();\n    var theNode;\n\n    var dimensions = theChild.layoutDimensions({\n      nodeDimensionsIncludeLabels: this.options.nodeDimensionsIncludeLabels\n    });\n\n    if (theChild.outerWidth() != null && theChild.outerHeight() != null) {\n      theNode = parent.add(new CoSENode(layout.graphManager, new PointD(theChild.position('x') - dimensions.w / 2, theChild.position('y') - dimensions.h / 2), new DimensionD(parseFloat(dimensions.w), parseFloat(dimensions.h))));\n    } else {\n      theNode = parent.add(new CoSENode(this.graphManager));\n    }\n    // Attach id to the layout node\n    theNode.id = theChild.data(\"id\");\n    // Attach the paddings of cy node to layout node\n    theNode.paddingLeft = parseInt(theChild.css('padding'));\n    theNode.paddingTop = parseInt(theChild.css('padding'));\n    theNode.paddingRight = parseInt(theChild.css('padding'));\n    theNode.paddingBottom = parseInt(theChild.css('padding'));\n\n    //Attach the label properties to compound if labels will be included in node dimensions  \n    if (this.options.nodeDimensionsIncludeLabels) {\n      if (theChild.isParent()) {\n        var labelWidth = theChild.boundingBox({ includeLabels: true, includeNodes: false }).w;\n        var labelHeight = theChild.boundingBox({ includeLabels: true, includeNodes: false }).h;\n        var labelPos = theChild.css(\"text-halign\");\n        theNode.labelWidth = labelWidth;\n        theNode.labelHeight = labelHeight;\n        theNode.labelPos = labelPos;\n      }\n    }\n\n    // Map the layout node\n    this.idToLNode[theChild.data(\"id\")] = theNode;\n\n    if (isNaN(theNode.rect.x)) {\n      theNode.rect.x = 0;\n    }\n\n    if (isNaN(theNode.rect.y)) {\n      theNode.rect.y = 0;\n    }\n\n    if (children_of_children != null && children_of_children.length > 0) {\n      var theNewGraph;\n      theNewGraph = layout.getGraphManager().add(layout.newGraph(), theNode);\n      this.processChildrenList(theNewGraph, children_of_children, layout);\n    }\n  }\n};\n\n/**\n * @brief : called on continuous layouts to stop them before they finish\n */\n_CoSELayout.prototype.stop = function () {\n  this.stopped = true;\n\n  return this; // chaining\n};\n\nvar register = function register(cytoscape) {\n  //  var Layout = getLayout( cytoscape );\n\n  cytoscape('layout', 'cose-bilkent', _CoSELayout);\n};\n\n// auto reg for globals\nif (typeof cytoscape !== 'undefined') {\n  register(cytoscape);\n}\n\nmodule.exports = register;\n\n/***/ })\n/******/ ]);\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL2N5dG9zY2FwZS1jb3NlLWJpbGtlbnQvY3l0b3NjYXBlLWNvc2UtYmlsa2VudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLElBQUksSUFBeUQ7QUFDN0QsMkJBQTJCLG1CQUFPLENBQUMscUVBQVc7QUFDOUMsTUFBTSxFQUtxRDtBQUMzRCxDQUFDO0FBQ0QscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDhCQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSw4QkFBbUI7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QjtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7QUFDN0I7QUFDQTtBQUNBLFVBQVUsOEJBQW1CLHVCQUF1QjtBQUNwRDtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7QUFDN0IsZUFBZSw4QkFBbUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QjtBQUNBLG9DQUFvQyw0QkFBNEI7QUFDaEUsMENBQTBDO0FBQzFDLFdBQVcsOEJBQW1CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4QkFBbUIsa0NBQWtDO0FBQy9EO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QjtBQUNBO0FBQ0EsaUJBQWlCLDhCQUFtQixDQUFDLDhCQUFtQjtBQUN4RCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLCtCQUFtQjs7QUFFcEQ7OztBQUdBLHNCQUFzQiwrQkFBbUI7QUFDekMsd0JBQXdCLCtCQUFtQjtBQUMzQyxvQkFBb0IsK0JBQW1CO0FBQ3ZDLGlCQUFpQiwrQkFBbUI7QUFDcEMsZUFBZSwrQkFBbUI7QUFDbEMsYUFBYSwrQkFBbUI7QUFDaEMsaUJBQWlCLCtCQUFtQjs7QUFFcEM7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4REFBOEQsaUVBQWlFOztBQUUvSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxvQkFBb0IsbUNBQW1DOztBQUV2RDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixtQ0FBbUM7QUFDN0Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQiw4QkFBOEI7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixrQ0FBa0M7O0FBRTFEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0RBQXdEOztBQUV4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTs7QUFFQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsVUFBVTtBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELDBDQUEwQztBQUMxRixpREFBaUQsMENBQTBDO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLE9BQU87QUFDUDtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2N5dG9zY2FwZS1jb3NlLWJpbGtlbnQvY3l0b3NjYXBlLWNvc2UtYmlsa2VudC5qcz9jYTQ5Il0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcImNvc2UtYmFzZVwiKSk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXCJjb3NlLWJhc2VcIl0sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiY3l0b3NjYXBlQ29zZUJpbGtlbnRcIl0gPSBmYWN0b3J5KHJlcXVpcmUoXCJjb3NlLWJhc2VcIikpO1xuXHRlbHNlXG5cdFx0cm9vdFtcImN5dG9zY2FwZUNvc2VCaWxrZW50XCJdID0gZmFjdG9yeShyb290W1wiY29zZUJhc2VcIl0pO1xufSkodGhpcywgZnVuY3Rpb24oX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8wX18pIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gaWRlbnRpdHkgZnVuY3Rpb24gZm9yIGNhbGxpbmcgaGFybW9ueSBpbXBvcnRzIHdpdGggdGhlIGNvcnJlY3QgY29udGV4dFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmkgPSBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbi8qKioqKiovIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbi8qKioqKiovIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbi8qKioqKiovIFx0XHRcdH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAxKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzBfXztcblxuLyoqKi8gfSksXG4vKiAxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBMYXlvdXRDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApLmxheW91dEJhc2UuTGF5b3V0Q29uc3RhbnRzO1xudmFyIEZETGF5b3V0Q29uc3RhbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKS5sYXlvdXRCYXNlLkZETGF5b3V0Q29uc3RhbnRzO1xudmFyIENvU0VDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApLkNvU0VDb25zdGFudHM7XG52YXIgQ29TRUxheW91dCA9IF9fd2VicGFja19yZXF1aXJlX18oMCkuQ29TRUxheW91dDtcbnZhciBDb1NFTm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oMCkuQ29TRU5vZGU7XG52YXIgUG9pbnREID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKS5sYXlvdXRCYXNlLlBvaW50RDtcbnZhciBEaW1lbnNpb25EID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKS5sYXlvdXRCYXNlLkRpbWVuc2lvbkQ7XG5cbnZhciBkZWZhdWx0cyA9IHtcbiAgLy8gQ2FsbGVkIG9uIGBsYXlvdXRyZWFkeWBcbiAgcmVhZHk6IGZ1bmN0aW9uIHJlYWR5KCkge30sXG4gIC8vIENhbGxlZCBvbiBgbGF5b3V0c3RvcGBcbiAgc3RvcDogZnVuY3Rpb24gc3RvcCgpIHt9LFxuICAvLyAnZHJhZnQnLCAnZGVmYXVsdCcgb3IgJ3Byb29mXCIgXG4gIC8vIC0gJ2RyYWZ0JyBmYXN0IGNvb2xpbmcgcmF0ZSBcbiAgLy8gLSAnZGVmYXVsdCcgbW9kZXJhdGUgY29vbGluZyByYXRlIFxuICAvLyAtIFwicHJvb2ZcIiBzbG93IGNvb2xpbmcgcmF0ZVxuICBxdWFsaXR5OiAnZGVmYXVsdCcsXG4gIC8vIGluY2x1ZGUgbGFiZWxzIGluIG5vZGUgZGltZW5zaW9uc1xuICBub2RlRGltZW5zaW9uc0luY2x1ZGVMYWJlbHM6IGZhbHNlLFxuICAvLyBudW1iZXIgb2YgdGlja3MgcGVyIGZyYW1lOyBoaWdoZXIgaXMgZmFzdGVyIGJ1dCBtb3JlIGplcmt5XG4gIHJlZnJlc2g6IDMwLFxuICAvLyBXaGV0aGVyIHRvIGZpdCB0aGUgbmV0d29yayB2aWV3IGFmdGVyIHdoZW4gZG9uZVxuICBmaXQ6IHRydWUsXG4gIC8vIFBhZGRpbmcgb24gZml0XG4gIHBhZGRpbmc6IDEwLFxuICAvLyBXaGV0aGVyIHRvIGVuYWJsZSBpbmNyZW1lbnRhbCBtb2RlXG4gIHJhbmRvbWl6ZTogdHJ1ZSxcbiAgLy8gTm9kZSByZXB1bHNpb24gKG5vbiBvdmVybGFwcGluZykgbXVsdGlwbGllclxuICBub2RlUmVwdWxzaW9uOiA0NTAwLFxuICAvLyBJZGVhbCBlZGdlIChub24gbmVzdGVkKSBsZW5ndGhcbiAgaWRlYWxFZGdlTGVuZ3RoOiA1MCxcbiAgLy8gRGl2aXNvciB0byBjb21wdXRlIGVkZ2UgZm9yY2VzXG4gIGVkZ2VFbGFzdGljaXR5OiAwLjQ1LFxuICAvLyBOZXN0aW5nIGZhY3RvciAobXVsdGlwbGllcikgdG8gY29tcHV0ZSBpZGVhbCBlZGdlIGxlbmd0aCBmb3IgbmVzdGVkIGVkZ2VzXG4gIG5lc3RpbmdGYWN0b3I6IDAuMSxcbiAgLy8gR3Jhdml0eSBmb3JjZSAoY29uc3RhbnQpXG4gIGdyYXZpdHk6IDAuMjUsXG4gIC8vIE1heGltdW0gbnVtYmVyIG9mIGl0ZXJhdGlvbnMgdG8gcGVyZm9ybVxuICBudW1JdGVyOiAyNTAwLFxuICAvLyBGb3IgZW5hYmxpbmcgdGlsaW5nXG4gIHRpbGU6IHRydWUsXG4gIC8vIFR5cGUgb2YgbGF5b3V0IGFuaW1hdGlvbi4gVGhlIG9wdGlvbiBzZXQgaXMgeydkdXJpbmcnLCAnZW5kJywgZmFsc2V9XG4gIGFuaW1hdGU6ICdlbmQnLFxuICAvLyBEdXJhdGlvbiBmb3IgYW5pbWF0ZTplbmRcbiAgYW5pbWF0aW9uRHVyYXRpb246IDUwMCxcbiAgLy8gUmVwcmVzZW50cyB0aGUgYW1vdW50IG9mIHRoZSB2ZXJ0aWNhbCBzcGFjZSB0byBwdXQgYmV0d2VlbiB0aGUgemVybyBkZWdyZWUgbWVtYmVycyBkdXJpbmcgdGhlIHRpbGluZyBvcGVyYXRpb24oY2FuIGFsc28gYmUgYSBmdW5jdGlvbilcbiAgdGlsaW5nUGFkZGluZ1ZlcnRpY2FsOiAxMCxcbiAgLy8gUmVwcmVzZW50cyB0aGUgYW1vdW50IG9mIHRoZSBob3Jpem9udGFsIHNwYWNlIHRvIHB1dCBiZXR3ZWVuIHRoZSB6ZXJvIGRlZ3JlZSBtZW1iZXJzIGR1cmluZyB0aGUgdGlsaW5nIG9wZXJhdGlvbihjYW4gYWxzbyBiZSBhIGZ1bmN0aW9uKVxuICB0aWxpbmdQYWRkaW5nSG9yaXpvbnRhbDogMTAsXG4gIC8vIEdyYXZpdHkgcmFuZ2UgKGNvbnN0YW50KSBmb3IgY29tcG91bmRzXG4gIGdyYXZpdHlSYW5nZUNvbXBvdW5kOiAxLjUsXG4gIC8vIEdyYXZpdHkgZm9yY2UgKGNvbnN0YW50KSBmb3IgY29tcG91bmRzXG4gIGdyYXZpdHlDb21wb3VuZDogMS4wLFxuICAvLyBHcmF2aXR5IHJhbmdlIChjb25zdGFudClcbiAgZ3Jhdml0eVJhbmdlOiAzLjgsXG4gIC8vIEluaXRpYWwgY29vbGluZyBmYWN0b3IgZm9yIGluY3JlbWVudGFsIGxheW91dFxuICBpbml0aWFsRW5lcmd5T25JbmNyZW1lbnRhbDogMC41XG59O1xuXG5mdW5jdGlvbiBleHRlbmQoZGVmYXVsdHMsIG9wdGlvbnMpIHtcbiAgdmFyIG9iaiA9IHt9O1xuXG4gIGZvciAodmFyIGkgaW4gZGVmYXVsdHMpIHtcbiAgICBvYmpbaV0gPSBkZWZhdWx0c1tpXTtcbiAgfVxuXG4gIGZvciAodmFyIGkgaW4gb3B0aW9ucykge1xuICAgIG9ialtpXSA9IG9wdGlvbnNbaV07XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxuZnVuY3Rpb24gX0NvU0VMYXlvdXQoX29wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gZXh0ZW5kKGRlZmF1bHRzLCBfb3B0aW9ucyk7XG4gIGdldFVzZXJPcHRpb25zKHRoaXMub3B0aW9ucyk7XG59XG5cbnZhciBnZXRVc2VyT3B0aW9ucyA9IGZ1bmN0aW9uIGdldFVzZXJPcHRpb25zKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMubm9kZVJlcHVsc2lvbiAhPSBudWxsKSBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfUkVQVUxTSU9OX1NUUkVOR1RIID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9SRVBVTFNJT05fU1RSRU5HVEggPSBvcHRpb25zLm5vZGVSZXB1bHNpb247XG4gIGlmIChvcHRpb25zLmlkZWFsRWRnZUxlbmd0aCAhPSBudWxsKSBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIID0gb3B0aW9ucy5pZGVhbEVkZ2VMZW5ndGg7XG4gIGlmIChvcHRpb25zLmVkZ2VFbGFzdGljaXR5ICE9IG51bGwpIENvU0VDb25zdGFudHMuREVGQVVMVF9TUFJJTkdfU1RSRU5HVEggPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX1NQUklOR19TVFJFTkdUSCA9IG9wdGlvbnMuZWRnZUVsYXN0aWNpdHk7XG4gIGlmIChvcHRpb25zLm5lc3RpbmdGYWN0b3IgIT0gbnVsbCkgQ29TRUNvbnN0YW50cy5QRVJfTEVWRUxfSURFQUxfRURHRV9MRU5HVEhfRkFDVE9SID0gRkRMYXlvdXRDb25zdGFudHMuUEVSX0xFVkVMX0lERUFMX0VER0VfTEVOR1RIX0ZBQ1RPUiA9IG9wdGlvbnMubmVzdGluZ0ZhY3RvcjtcbiAgaWYgKG9wdGlvbnMuZ3Jhdml0eSAhPSBudWxsKSBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfR1JBVklUWV9TVFJFTkdUSCA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfR1JBVklUWV9TVFJFTkdUSCA9IG9wdGlvbnMuZ3Jhdml0eTtcbiAgaWYgKG9wdGlvbnMubnVtSXRlciAhPSBudWxsKSBDb1NFQ29uc3RhbnRzLk1BWF9JVEVSQVRJT05TID0gRkRMYXlvdXRDb25zdGFudHMuTUFYX0lURVJBVElPTlMgPSBvcHRpb25zLm51bUl0ZXI7XG4gIGlmIChvcHRpb25zLmdyYXZpdHlSYW5nZSAhPSBudWxsKSBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfR1JBVklUWV9SQU5HRV9GQUNUT1IgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0dSQVZJVFlfUkFOR0VfRkFDVE9SID0gb3B0aW9ucy5ncmF2aXR5UmFuZ2U7XG4gIGlmIChvcHRpb25zLmdyYXZpdHlDb21wb3VuZCAhPSBudWxsKSBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfQ09NUE9VTkRfR1JBVklUWV9TVFJFTkdUSCA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQ09NUE9VTkRfR1JBVklUWV9TVFJFTkdUSCA9IG9wdGlvbnMuZ3Jhdml0eUNvbXBvdW5kO1xuICBpZiAob3B0aW9ucy5ncmF2aXR5UmFuZ2VDb21wb3VuZCAhPSBudWxsKSBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfQ09NUE9VTkRfR1JBVklUWV9SQU5HRV9GQUNUT1IgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0NPTVBPVU5EX0dSQVZJVFlfUkFOR0VfRkFDVE9SID0gb3B0aW9ucy5ncmF2aXR5UmFuZ2VDb21wb3VuZDtcbiAgaWYgKG9wdGlvbnMuaW5pdGlhbEVuZXJneU9uSW5jcmVtZW50YWwgIT0gbnVsbCkgQ29TRUNvbnN0YW50cy5ERUZBVUxUX0NPT0xJTkdfRkFDVE9SX0lOQ1JFTUVOVEFMID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9DT09MSU5HX0ZBQ1RPUl9JTkNSRU1FTlRBTCA9IG9wdGlvbnMuaW5pdGlhbEVuZXJneU9uSW5jcmVtZW50YWw7XG5cbiAgaWYgKG9wdGlvbnMucXVhbGl0eSA9PSAnZHJhZnQnKSBMYXlvdXRDb25zdGFudHMuUVVBTElUWSA9IDA7ZWxzZSBpZiAob3B0aW9ucy5xdWFsaXR5ID09ICdwcm9vZicpIExheW91dENvbnN0YW50cy5RVUFMSVRZID0gMjtlbHNlIExheW91dENvbnN0YW50cy5RVUFMSVRZID0gMTtcblxuICBDb1NFQ29uc3RhbnRzLk5PREVfRElNRU5TSU9OU19JTkNMVURFX0xBQkVMUyA9IEZETGF5b3V0Q29uc3RhbnRzLk5PREVfRElNRU5TSU9OU19JTkNMVURFX0xBQkVMUyA9IExheW91dENvbnN0YW50cy5OT0RFX0RJTUVOU0lPTlNfSU5DTFVERV9MQUJFTFMgPSBvcHRpb25zLm5vZGVEaW1lbnNpb25zSW5jbHVkZUxhYmVscztcbiAgQ29TRUNvbnN0YW50cy5ERUZBVUxUX0lOQ1JFTUVOVEFMID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9JTkNSRU1FTlRBTCA9IExheW91dENvbnN0YW50cy5ERUZBVUxUX0lOQ1JFTUVOVEFMID0gIW9wdGlvbnMucmFuZG9taXplO1xuICBDb1NFQ29uc3RhbnRzLkFOSU1BVEUgPSBGRExheW91dENvbnN0YW50cy5BTklNQVRFID0gTGF5b3V0Q29uc3RhbnRzLkFOSU1BVEUgPSBvcHRpb25zLmFuaW1hdGU7XG4gIENvU0VDb25zdGFudHMuVElMRSA9IG9wdGlvbnMudGlsZTtcbiAgQ29TRUNvbnN0YW50cy5USUxJTkdfUEFERElOR19WRVJUSUNBTCA9IHR5cGVvZiBvcHRpb25zLnRpbGluZ1BhZGRpbmdWZXJ0aWNhbCA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMudGlsaW5nUGFkZGluZ1ZlcnRpY2FsLmNhbGwoKSA6IG9wdGlvbnMudGlsaW5nUGFkZGluZ1ZlcnRpY2FsO1xuICBDb1NFQ29uc3RhbnRzLlRJTElOR19QQURESU5HX0hPUklaT05UQUwgPSB0eXBlb2Ygb3B0aW9ucy50aWxpbmdQYWRkaW5nSG9yaXpvbnRhbCA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMudGlsaW5nUGFkZGluZ0hvcml6b250YWwuY2FsbCgpIDogb3B0aW9ucy50aWxpbmdQYWRkaW5nSG9yaXpvbnRhbDtcbn07XG5cbl9Db1NFTGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciByZWFkeTtcbiAgdmFyIGZyYW1lSWQ7XG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICB2YXIgaWRUb0xOb2RlID0gdGhpcy5pZFRvTE5vZGUgPSB7fTtcbiAgdmFyIGxheW91dCA9IHRoaXMubGF5b3V0ID0gbmV3IENvU0VMYXlvdXQoKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHNlbGYuc3RvcHBlZCA9IGZhbHNlO1xuXG4gIHRoaXMuY3kgPSB0aGlzLm9wdGlvbnMuY3k7XG5cbiAgdGhpcy5jeS50cmlnZ2VyKHsgdHlwZTogJ2xheW91dHN0YXJ0JywgbGF5b3V0OiB0aGlzIH0pO1xuXG4gIHZhciBnbSA9IGxheW91dC5uZXdHcmFwaE1hbmFnZXIoKTtcbiAgdGhpcy5nbSA9IGdtO1xuXG4gIHZhciBub2RlcyA9IHRoaXMub3B0aW9ucy5lbGVzLm5vZGVzKCk7XG4gIHZhciBlZGdlcyA9IHRoaXMub3B0aW9ucy5lbGVzLmVkZ2VzKCk7XG5cbiAgdGhpcy5yb290ID0gZ20uYWRkUm9vdCgpO1xuICB0aGlzLnByb2Nlc3NDaGlsZHJlbkxpc3QodGhpcy5yb290LCB0aGlzLmdldFRvcE1vc3ROb2Rlcyhub2RlcyksIGxheW91dCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlZGdlID0gZWRnZXNbaV07XG4gICAgdmFyIHNvdXJjZU5vZGUgPSB0aGlzLmlkVG9MTm9kZVtlZGdlLmRhdGEoXCJzb3VyY2VcIildO1xuICAgIHZhciB0YXJnZXROb2RlID0gdGhpcy5pZFRvTE5vZGVbZWRnZS5kYXRhKFwidGFyZ2V0XCIpXTtcbiAgICBpZiAoc291cmNlTm9kZSAhPT0gdGFyZ2V0Tm9kZSAmJiBzb3VyY2VOb2RlLmdldEVkZ2VzQmV0d2Vlbih0YXJnZXROb2RlKS5sZW5ndGggPT0gMCkge1xuICAgICAgdmFyIGUxID0gZ20uYWRkKGxheW91dC5uZXdFZGdlKCksIHNvdXJjZU5vZGUsIHRhcmdldE5vZGUpO1xuICAgICAgZTEuaWQgPSBlZGdlLmlkKCk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGdldFBvc2l0aW9ucyA9IGZ1bmN0aW9uIGdldFBvc2l0aW9ucyhlbGUsIGkpIHtcbiAgICBpZiAodHlwZW9mIGVsZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgZWxlID0gaTtcbiAgICB9XG4gICAgdmFyIHRoZUlkID0gZWxlLmRhdGEoJ2lkJyk7XG4gICAgdmFyIGxOb2RlID0gc2VsZi5pZFRvTE5vZGVbdGhlSWRdO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGxOb2RlLmdldFJlY3QoKS5nZXRDZW50ZXJYKCksXG4gICAgICB5OiBsTm9kZS5nZXRSZWN0KCkuZ2V0Q2VudGVyWSgpXG4gICAgfTtcbiAgfTtcblxuICAvKlxuICAgKiBSZXBvc2l0aW9uIG5vZGVzIGluIGl0ZXJhdGlvbnMgYW5pbWF0ZWRseVxuICAgKi9cbiAgdmFyIGl0ZXJhdGVBbmltYXRlZCA9IGZ1bmN0aW9uIGl0ZXJhdGVBbmltYXRlZCgpIHtcbiAgICAvLyBUaGlncyB0byBwZXJmb3JtIGFmdGVyIG5vZGVzIGFyZSByZXBvc2l0aW9uZWQgb24gc2NyZWVuXG4gICAgdmFyIGFmdGVyUmVwb3NpdGlvbiA9IGZ1bmN0aW9uIGFmdGVyUmVwb3NpdGlvbigpIHtcbiAgICAgIGlmIChvcHRpb25zLmZpdCkge1xuICAgICAgICBvcHRpb25zLmN5LmZpdChvcHRpb25zLmVsZXMsIG9wdGlvbnMucGFkZGluZyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghcmVhZHkpIHtcbiAgICAgICAgcmVhZHkgPSB0cnVlO1xuICAgICAgICBzZWxmLmN5Lm9uZSgnbGF5b3V0cmVhZHknLCBvcHRpb25zLnJlYWR5KTtcbiAgICAgICAgc2VsZi5jeS50cmlnZ2VyKHsgdHlwZTogJ2xheW91dHJlYWR5JywgbGF5b3V0OiBzZWxmIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgdGlja3NQZXJGcmFtZSA9IHNlbGYub3B0aW9ucy5yZWZyZXNoO1xuICAgIHZhciBpc0RvbmU7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRpY2tzUGVyRnJhbWUgJiYgIWlzRG9uZTsgaSsrKSB7XG4gICAgICBpc0RvbmUgPSBzZWxmLnN0b3BwZWQgfHwgc2VsZi5sYXlvdXQudGljaygpO1xuICAgIH1cblxuICAgIC8vIElmIGxheW91dCBpcyBkb25lXG4gICAgaWYgKGlzRG9uZSkge1xuICAgICAgLy8gSWYgdGhlIGxheW91dCBpcyBub3QgYSBzdWJsYXlvdXQgYW5kIGl0IGlzIHN1Y2Nlc3NmdWwgcGVyZm9ybSBwb3N0IGxheW91dC5cbiAgICAgIGlmIChsYXlvdXQuY2hlY2tMYXlvdXRTdWNjZXNzKCkgJiYgIWxheW91dC5pc1N1YkxheW91dCkge1xuICAgICAgICBsYXlvdXQuZG9Qb3N0TGF5b3V0KCk7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIGxheW91dCBoYXMgYSB0aWxpbmdQb3N0TGF5b3V0IGZ1bmN0aW9uIHByb3BlcnR5IGNhbGwgaXQuXG4gICAgICBpZiAobGF5b3V0LnRpbGluZ1Bvc3RMYXlvdXQpIHtcbiAgICAgICAgbGF5b3V0LnRpbGluZ1Bvc3RMYXlvdXQoKTtcbiAgICAgIH1cblxuICAgICAgbGF5b3V0LmlzTGF5b3V0RmluaXNoZWQgPSB0cnVlO1xuXG4gICAgICBzZWxmLm9wdGlvbnMuZWxlcy5ub2RlcygpLnBvc2l0aW9ucyhnZXRQb3NpdGlvbnMpO1xuXG4gICAgICBhZnRlclJlcG9zaXRpb24oKTtcblxuICAgICAgLy8gdHJpZ2dlciBsYXlvdXRzdG9wIHdoZW4gdGhlIGxheW91dCBzdG9wcyAoZS5nLiBmaW5pc2hlcylcbiAgICAgIHNlbGYuY3kub25lKCdsYXlvdXRzdG9wJywgc2VsZi5vcHRpb25zLnN0b3ApO1xuICAgICAgc2VsZi5jeS50cmlnZ2VyKHsgdHlwZTogJ2xheW91dHN0b3AnLCBsYXlvdXQ6IHNlbGYgfSk7XG5cbiAgICAgIGlmIChmcmFtZUlkKSB7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGZyYW1lSWQpO1xuICAgICAgfVxuXG4gICAgICByZWFkeSA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBhbmltYXRpb25EYXRhID0gc2VsZi5sYXlvdXQuZ2V0UG9zaXRpb25zRGF0YSgpOyAvLyBHZXQgcG9zaXRpb25zIG9mIGxheW91dCBub2RlcyBub3RlIHRoYXQgYWxsIG5vZGVzIG1heSBub3QgYmUgbGF5b3V0IG5vZGVzIGJlY2F1c2Ugb2YgdGlsaW5nXG5cbiAgICAvLyBQb3NpdGlvbiBub2RlcywgZm9yIHRoZSBub2RlcyB3aG9zZSBpZCBkb2VzIG5vdCBpbmNsdWRlZCBpbiBkYXRhIChiZWNhdXNlIHRoZXkgYXJlIHJlbW92ZWQgZnJvbSB0aGVpciBwYXJlbnRzIGFuZCBpbmNsdWRlZCBpbiBkdW1teSBjb21wb3VuZHMpXG4gICAgLy8gdXNlIHBvc2l0aW9uIG9mIHRoZWlyIGFuY2VzdG9ycyBvciBkdW1teSBhbmNlc3RvcnNcbiAgICBvcHRpb25zLmVsZXMubm9kZXMoKS5wb3NpdGlvbnMoZnVuY3Rpb24gKGVsZSwgaSkge1xuICAgICAgaWYgKHR5cGVvZiBlbGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgZWxlID0gaTtcbiAgICAgIH1cbiAgICAgIC8vIElmIGVsZSBpcyBhIGNvbXBvdW5kIG5vZGUsIHRoZW4gaXRzIHBvc2l0aW9uIHdpbGwgYmUgZGVmaW5lZCBieSBpdHMgY2hpbGRyZW5cbiAgICAgIGlmICghZWxlLmlzUGFyZW50KCkpIHtcbiAgICAgICAgdmFyIHRoZUlkID0gZWxlLmlkKCk7XG4gICAgICAgIHZhciBwTm9kZSA9IGFuaW1hdGlvbkRhdGFbdGhlSWRdO1xuICAgICAgICB2YXIgdGVtcCA9IGVsZTtcbiAgICAgICAgLy8gSWYgcE5vZGUgaXMgdW5kZWZpbmVkIHNlYXJjaCB1bnRpbCBmaW5kaW5nIHBvc2l0aW9uIGRhdGEgb2YgaXRzIGZpcnN0IGFuY2VzdG9yIChJdCBtYXkgYmUgZHVtbXkgYXMgd2VsbClcbiAgICAgICAgd2hpbGUgKHBOb2RlID09IG51bGwpIHtcbiAgICAgICAgICBwTm9kZSA9IGFuaW1hdGlvbkRhdGFbdGVtcC5kYXRhKCdwYXJlbnQnKV0gfHwgYW5pbWF0aW9uRGF0YVsnRHVtbXlDb21wb3VuZF8nICsgdGVtcC5kYXRhKCdwYXJlbnQnKV07XG4gICAgICAgICAgYW5pbWF0aW9uRGF0YVt0aGVJZF0gPSBwTm9kZTtcbiAgICAgICAgICB0ZW1wID0gdGVtcC5wYXJlbnQoKVswXTtcbiAgICAgICAgICBpZiAodGVtcCA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocE5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiBwTm9kZS54LFxuICAgICAgICAgICAgeTogcE5vZGUueVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IGVsZS5wb3NpdGlvbigneCcpLFxuICAgICAgICAgICAgeTogZWxlLnBvc2l0aW9uKCd5JylcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhZnRlclJlcG9zaXRpb24oKTtcblxuICAgIGZyYW1lSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoaXRlcmF0ZUFuaW1hdGVkKTtcbiAgfTtcblxuICAvKlxuICAqIExpc3RlbiAnbGF5b3V0c3RhcnRlZCcgZXZlbnQgYW5kIHN0YXJ0IGFuaW1hdGVkIGl0ZXJhdGlvbiBpZiBhbmltYXRlIG9wdGlvbiBpcyAnZHVyaW5nJ1xuICAqL1xuICBsYXlvdXQuYWRkTGlzdGVuZXIoJ2xheW91dHN0YXJ0ZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHNlbGYub3B0aW9ucy5hbmltYXRlID09PSAnZHVyaW5nJykge1xuICAgICAgZnJhbWVJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShpdGVyYXRlQW5pbWF0ZWQpO1xuICAgIH1cbiAgfSk7XG5cbiAgbGF5b3V0LnJ1bkxheW91dCgpOyAvLyBSdW4gY29zZSBsYXlvdXRcblxuICAvKlxuICAgKiBJZiBhbmltYXRlIG9wdGlvbiBpcyBub3QgJ2R1cmluZycgKCdlbmQnIG9yIGZhbHNlKSBwZXJmb3JtIHRoZXNlIGhlcmUgKElmIGl0IGlzICdkdXJpbmcnIHNpbWlsYXIgdGhpbmdzIGFyZSBhbHJlYWR5IHBlcmZvcm1lZClcbiAgICovXG4gIGlmICh0aGlzLm9wdGlvbnMuYW5pbWF0ZSAhPT0gXCJkdXJpbmdcIikge1xuICAgIHNlbGYub3B0aW9ucy5lbGVzLm5vZGVzKCkubm90KFwiOnBhcmVudFwiKS5sYXlvdXRQb3NpdGlvbnMoc2VsZiwgc2VsZi5vcHRpb25zLCBnZXRQb3NpdGlvbnMpOyAvLyBVc2UgbGF5b3V0IHBvc2l0aW9ucyB0byByZXBvc2l0aW9uIHRoZSBub2RlcyBpdCBjb25zaWRlcnMgdGhlIG9wdGlvbnMgcGFyYW1ldGVyXG4gICAgcmVhZHkgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxuLy9HZXQgdGhlIHRvcCBtb3N0IG9uZXMgb2YgYSBsaXN0IG9mIG5vZGVzXG5fQ29TRUxheW91dC5wcm90b3R5cGUuZ2V0VG9wTW9zdE5vZGVzID0gZnVuY3Rpb24gKG5vZGVzKSB7XG4gIHZhciBub2Rlc01hcCA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgbm9kZXNNYXBbbm9kZXNbaV0uaWQoKV0gPSB0cnVlO1xuICB9XG4gIHZhciByb290cyA9IG5vZGVzLmZpbHRlcihmdW5jdGlvbiAoZWxlLCBpKSB7XG4gICAgaWYgKHR5cGVvZiBlbGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGVsZSA9IGk7XG4gICAgfVxuICAgIHZhciBwYXJlbnQgPSBlbGUucGFyZW50KClbMF07XG4gICAgd2hpbGUgKHBhcmVudCAhPSBudWxsKSB7XG4gICAgICBpZiAobm9kZXNNYXBbcGFyZW50LmlkKCldKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQoKVswXTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiByb290cztcbn07XG5cbl9Db1NFTGF5b3V0LnByb3RvdHlwZS5wcm9jZXNzQ2hpbGRyZW5MaXN0ID0gZnVuY3Rpb24gKHBhcmVudCwgY2hpbGRyZW4sIGxheW91dCkge1xuICB2YXIgc2l6ZSA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICB2YXIgdGhlQ2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICB2YXIgY2hpbGRyZW5fb2ZfY2hpbGRyZW4gPSB0aGVDaGlsZC5jaGlsZHJlbigpO1xuICAgIHZhciB0aGVOb2RlO1xuXG4gICAgdmFyIGRpbWVuc2lvbnMgPSB0aGVDaGlsZC5sYXlvdXREaW1lbnNpb25zKHtcbiAgICAgIG5vZGVEaW1lbnNpb25zSW5jbHVkZUxhYmVsczogdGhpcy5vcHRpb25zLm5vZGVEaW1lbnNpb25zSW5jbHVkZUxhYmVsc1xuICAgIH0pO1xuXG4gICAgaWYgKHRoZUNoaWxkLm91dGVyV2lkdGgoKSAhPSBudWxsICYmIHRoZUNoaWxkLm91dGVySGVpZ2h0KCkgIT0gbnVsbCkge1xuICAgICAgdGhlTm9kZSA9IHBhcmVudC5hZGQobmV3IENvU0VOb2RlKGxheW91dC5ncmFwaE1hbmFnZXIsIG5ldyBQb2ludEQodGhlQ2hpbGQucG9zaXRpb24oJ3gnKSAtIGRpbWVuc2lvbnMudyAvIDIsIHRoZUNoaWxkLnBvc2l0aW9uKCd5JykgLSBkaW1lbnNpb25zLmggLyAyKSwgbmV3IERpbWVuc2lvbkQocGFyc2VGbG9hdChkaW1lbnNpb25zLncpLCBwYXJzZUZsb2F0KGRpbWVuc2lvbnMuaCkpKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoZU5vZGUgPSBwYXJlbnQuYWRkKG5ldyBDb1NFTm9kZSh0aGlzLmdyYXBoTWFuYWdlcikpO1xuICAgIH1cbiAgICAvLyBBdHRhY2ggaWQgdG8gdGhlIGxheW91dCBub2RlXG4gICAgdGhlTm9kZS5pZCA9IHRoZUNoaWxkLmRhdGEoXCJpZFwiKTtcbiAgICAvLyBBdHRhY2ggdGhlIHBhZGRpbmdzIG9mIGN5IG5vZGUgdG8gbGF5b3V0IG5vZGVcbiAgICB0aGVOb2RlLnBhZGRpbmdMZWZ0ID0gcGFyc2VJbnQodGhlQ2hpbGQuY3NzKCdwYWRkaW5nJykpO1xuICAgIHRoZU5vZGUucGFkZGluZ1RvcCA9IHBhcnNlSW50KHRoZUNoaWxkLmNzcygncGFkZGluZycpKTtcbiAgICB0aGVOb2RlLnBhZGRpbmdSaWdodCA9IHBhcnNlSW50KHRoZUNoaWxkLmNzcygncGFkZGluZycpKTtcbiAgICB0aGVOb2RlLnBhZGRpbmdCb3R0b20gPSBwYXJzZUludCh0aGVDaGlsZC5jc3MoJ3BhZGRpbmcnKSk7XG5cbiAgICAvL0F0dGFjaCB0aGUgbGFiZWwgcHJvcGVydGllcyB0byBjb21wb3VuZCBpZiBsYWJlbHMgd2lsbCBiZSBpbmNsdWRlZCBpbiBub2RlIGRpbWVuc2lvbnMgIFxuICAgIGlmICh0aGlzLm9wdGlvbnMubm9kZURpbWVuc2lvbnNJbmNsdWRlTGFiZWxzKSB7XG4gICAgICBpZiAodGhlQ2hpbGQuaXNQYXJlbnQoKSkge1xuICAgICAgICB2YXIgbGFiZWxXaWR0aCA9IHRoZUNoaWxkLmJvdW5kaW5nQm94KHsgaW5jbHVkZUxhYmVsczogdHJ1ZSwgaW5jbHVkZU5vZGVzOiBmYWxzZSB9KS53O1xuICAgICAgICB2YXIgbGFiZWxIZWlnaHQgPSB0aGVDaGlsZC5ib3VuZGluZ0JveCh7IGluY2x1ZGVMYWJlbHM6IHRydWUsIGluY2x1ZGVOb2RlczogZmFsc2UgfSkuaDtcbiAgICAgICAgdmFyIGxhYmVsUG9zID0gdGhlQ2hpbGQuY3NzKFwidGV4dC1oYWxpZ25cIik7XG4gICAgICAgIHRoZU5vZGUubGFiZWxXaWR0aCA9IGxhYmVsV2lkdGg7XG4gICAgICAgIHRoZU5vZGUubGFiZWxIZWlnaHQgPSBsYWJlbEhlaWdodDtcbiAgICAgICAgdGhlTm9kZS5sYWJlbFBvcyA9IGxhYmVsUG9zO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1hcCB0aGUgbGF5b3V0IG5vZGVcbiAgICB0aGlzLmlkVG9MTm9kZVt0aGVDaGlsZC5kYXRhKFwiaWRcIildID0gdGhlTm9kZTtcblxuICAgIGlmIChpc05hTih0aGVOb2RlLnJlY3QueCkpIHtcbiAgICAgIHRoZU5vZGUucmVjdC54ID0gMDtcbiAgICB9XG5cbiAgICBpZiAoaXNOYU4odGhlTm9kZS5yZWN0LnkpKSB7XG4gICAgICB0aGVOb2RlLnJlY3QueSA9IDA7XG4gICAgfVxuXG4gICAgaWYgKGNoaWxkcmVuX29mX2NoaWxkcmVuICE9IG51bGwgJiYgY2hpbGRyZW5fb2ZfY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIHRoZU5ld0dyYXBoO1xuICAgICAgdGhlTmV3R3JhcGggPSBsYXlvdXQuZ2V0R3JhcGhNYW5hZ2VyKCkuYWRkKGxheW91dC5uZXdHcmFwaCgpLCB0aGVOb2RlKTtcbiAgICAgIHRoaXMucHJvY2Vzc0NoaWxkcmVuTGlzdCh0aGVOZXdHcmFwaCwgY2hpbGRyZW5fb2ZfY2hpbGRyZW4sIGxheW91dCk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEBicmllZiA6IGNhbGxlZCBvbiBjb250aW51b3VzIGxheW91dHMgdG8gc3RvcCB0aGVtIGJlZm9yZSB0aGV5IGZpbmlzaFxuICovXG5fQ29TRUxheW91dC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zdG9wcGVkID0gdHJ1ZTtcblxuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5cbnZhciByZWdpc3RlciA9IGZ1bmN0aW9uIHJlZ2lzdGVyKGN5dG9zY2FwZSkge1xuICAvLyAgdmFyIExheW91dCA9IGdldExheW91dCggY3l0b3NjYXBlICk7XG5cbiAgY3l0b3NjYXBlKCdsYXlvdXQnLCAnY29zZS1iaWxrZW50JywgX0NvU0VMYXlvdXQpO1xufTtcblxuLy8gYXV0byByZWcgZm9yIGdsb2JhbHNcbmlmICh0eXBlb2YgY3l0b3NjYXBlICE9PSAndW5kZWZpbmVkJykge1xuICByZWdpc3RlcihjeXRvc2NhcGUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlZ2lzdGVyO1xuXG4vKioqLyB9KVxuLyoqKioqKi8gXSk7XG59KTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/cytoscape-cose-bilkent/cytoscape-cose-bilkent.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/cytoscape/dist/cytoscape.umd.js":
/*!******************************************************!*\
  !*** ./node_modules/cytoscape/dist/cytoscape.umd.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/**\n * Copyright (c) 2016-2023, The Cytoscape Consortium.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the “Software”), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n * of the Software, and to permit persons to whom the Software is furnished to do\n * so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n(function (global, factory) {\n   true ? module.exports = factory() :\n  0;\n})(this, (function () { 'use strict';\n\n  function _typeof(obj) {\n    \"@babel/helpers - typeof\";\n\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n      return typeof obj;\n    } : function (obj) {\n      return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    }, _typeof(obj);\n  }\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n      writable: false\n    });\n    return Constructor;\n  }\n\n  function _defineProperty$1(obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  function _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n  }\n\n  function _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n  }\n\n  function _iterableToArrayLimit(arr, i) {\n    var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n    if (_i == null) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n\n    var _s, _e;\n\n    try {\n      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  function _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n  }\n\n  function _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n\n    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n\n  function _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var window$1 = typeof window === 'undefined' ? null : window; // eslint-disable-line no-undef\n\n  var navigator = window$1 ? window$1.navigator : null;\n  window$1 ? window$1.document : null;\n\n  var typeofstr = _typeof('');\n\n  var typeofobj = _typeof({});\n\n  var typeoffn = _typeof(function () {});\n\n  var typeofhtmlele = typeof HTMLElement === \"undefined\" ? \"undefined\" : _typeof(HTMLElement);\n\n  var instanceStr = function instanceStr(obj) {\n    return obj && obj.instanceString && fn$6(obj.instanceString) ? obj.instanceString() : null;\n  };\n\n  var string = function string(obj) {\n    return obj != null && _typeof(obj) == typeofstr;\n  };\n  var fn$6 = function fn(obj) {\n    return obj != null && _typeof(obj) === typeoffn;\n  };\n  var array = function array(obj) {\n    return !elementOrCollection(obj) && (Array.isArray ? Array.isArray(obj) : obj != null && obj instanceof Array);\n  };\n  var plainObject = function plainObject(obj) {\n    return obj != null && _typeof(obj) === typeofobj && !array(obj) && obj.constructor === Object;\n  };\n  var object = function object(obj) {\n    return obj != null && _typeof(obj) === typeofobj;\n  };\n  var number$1 = function number(obj) {\n    return obj != null && _typeof(obj) === _typeof(1) && !isNaN(obj);\n  };\n  var integer = function integer(obj) {\n    return number$1(obj) && Math.floor(obj) === obj;\n  };\n  var htmlElement = function htmlElement(obj) {\n    if ('undefined' === typeofhtmlele) {\n      return undefined;\n    } else {\n      return null != obj && obj instanceof HTMLElement;\n    }\n  };\n  var elementOrCollection = function elementOrCollection(obj) {\n    return element(obj) || collection(obj);\n  };\n  var element = function element(obj) {\n    return instanceStr(obj) === 'collection' && obj._private.single;\n  };\n  var collection = function collection(obj) {\n    return instanceStr(obj) === 'collection' && !obj._private.single;\n  };\n  var core = function core(obj) {\n    return instanceStr(obj) === 'core';\n  };\n  var stylesheet = function stylesheet(obj) {\n    return instanceStr(obj) === 'stylesheet';\n  };\n  var event = function event(obj) {\n    return instanceStr(obj) === 'event';\n  };\n  var emptyString = function emptyString(obj) {\n    if (obj === undefined || obj === null) {\n      // null is empty\n      return true;\n    } else if (obj === '' || obj.match(/^\\s+$/)) {\n      return true; // empty string is empty\n    }\n\n    return false; // otherwise, we don't know what we've got\n  };\n  var domElement = function domElement(obj) {\n    if (typeof HTMLElement === 'undefined') {\n      return false; // we're not in a browser so it doesn't matter\n    } else {\n      return obj instanceof HTMLElement;\n    }\n  };\n  var boundingBox = function boundingBox(obj) {\n    return plainObject(obj) && number$1(obj.x1) && number$1(obj.x2) && number$1(obj.y1) && number$1(obj.y2);\n  };\n  var promise = function promise(obj) {\n    return object(obj) && fn$6(obj.then);\n  };\n  var ms = function ms() {\n    return navigator && navigator.userAgent.match(/msie|trident|edge/i);\n  }; // probably a better way to detect this...\n\n  var memoize$1 = function memoize(fn, keyFn) {\n    if (!keyFn) {\n      keyFn = function keyFn() {\n        if (arguments.length === 1) {\n          return arguments[0];\n        } else if (arguments.length === 0) {\n          return 'undefined';\n        }\n\n        var args = [];\n\n        for (var i = 0; i < arguments.length; i++) {\n          args.push(arguments[i]);\n        }\n\n        return args.join('$');\n      };\n    }\n\n    var memoizedFn = function memoizedFn() {\n      var self = this;\n      var args = arguments;\n      var ret;\n      var k = keyFn.apply(self, args);\n      var cache = memoizedFn.cache;\n\n      if (!(ret = cache[k])) {\n        ret = cache[k] = fn.apply(self, args);\n      }\n\n      return ret;\n    };\n\n    memoizedFn.cache = {};\n    return memoizedFn;\n  };\n\n  var camel2dash = memoize$1(function (str) {\n    return str.replace(/([A-Z])/g, function (v) {\n      return '-' + v.toLowerCase();\n    });\n  });\n  var dash2camel = memoize$1(function (str) {\n    return str.replace(/(-\\w)/g, function (v) {\n      return v[1].toUpperCase();\n    });\n  });\n  var prependCamel = memoize$1(function (prefix, str) {\n    return prefix + str[0].toUpperCase() + str.substring(1);\n  }, function (prefix, str) {\n    return prefix + '$' + str;\n  });\n  var capitalize = function capitalize(str) {\n    if (emptyString(str)) {\n      return str;\n    }\n\n    return str.charAt(0).toUpperCase() + str.substring(1);\n  };\n\n  var number = '(?:[-+]?(?:(?:\\\\d+|\\\\d*\\\\.\\\\d+)(?:[Ee][+-]?\\\\d+)?))';\n  var rgba = 'rgb[a]?\\\\((' + number + '[%]?)\\\\s*,\\\\s*(' + number + '[%]?)\\\\s*,\\\\s*(' + number + '[%]?)(?:\\\\s*,\\\\s*(' + number + '))?\\\\)';\n  var rgbaNoBackRefs = 'rgb[a]?\\\\((?:' + number + '[%]?)\\\\s*,\\\\s*(?:' + number + '[%]?)\\\\s*,\\\\s*(?:' + number + '[%]?)(?:\\\\s*,\\\\s*(?:' + number + '))?\\\\)';\n  var hsla = 'hsl[a]?\\\\((' + number + ')\\\\s*,\\\\s*(' + number + '[%])\\\\s*,\\\\s*(' + number + '[%])(?:\\\\s*,\\\\s*(' + number + '))?\\\\)';\n  var hslaNoBackRefs = 'hsl[a]?\\\\((?:' + number + ')\\\\s*,\\\\s*(?:' + number + '[%])\\\\s*,\\\\s*(?:' + number + '[%])(?:\\\\s*,\\\\s*(?:' + number + '))?\\\\)';\n  var hex3 = '\\\\#[0-9a-fA-F]{3}';\n  var hex6 = '\\\\#[0-9a-fA-F]{6}';\n\n  var ascending = function ascending(a, b) {\n    if (a < b) {\n      return -1;\n    } else if (a > b) {\n      return 1;\n    } else {\n      return 0;\n    }\n  };\n  var descending = function descending(a, b) {\n    return -1 * ascending(a, b);\n  };\n\n  var extend = Object.assign != null ? Object.assign.bind(Object) : function (tgt) {\n    var args = arguments;\n\n    for (var i = 1; i < args.length; i++) {\n      var obj = args[i];\n\n      if (obj == null) {\n        continue;\n      }\n\n      var keys = Object.keys(obj);\n\n      for (var j = 0; j < keys.length; j++) {\n        var k = keys[j];\n        tgt[k] = obj[k];\n      }\n    }\n\n    return tgt;\n  };\n\n  var hex2tuple = function hex2tuple(hex) {\n    if (!(hex.length === 4 || hex.length === 7) || hex[0] !== '#') {\n      return;\n    }\n\n    var shortHex = hex.length === 4;\n    var r, g, b;\n    var base = 16;\n\n    if (shortHex) {\n      r = parseInt(hex[1] + hex[1], base);\n      g = parseInt(hex[2] + hex[2], base);\n      b = parseInt(hex[3] + hex[3], base);\n    } else {\n      r = parseInt(hex[1] + hex[2], base);\n      g = parseInt(hex[3] + hex[4], base);\n      b = parseInt(hex[5] + hex[6], base);\n    }\n\n    return [r, g, b];\n  }; // get [r, g, b, a] from hsl(0, 0, 0) or hsla(0, 0, 0, 0)\n\n  var hsl2tuple = function hsl2tuple(hsl) {\n    var ret;\n    var h, s, l, a, r, g, b;\n\n    function hue2rgb(p, q, t) {\n      if (t < 0) t += 1;\n      if (t > 1) t -= 1;\n      if (t < 1 / 6) return p + (q - p) * 6 * t;\n      if (t < 1 / 2) return q;\n      if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n      return p;\n    }\n\n    var m = new RegExp('^' + hsla + '$').exec(hsl);\n\n    if (m) {\n      // get hue\n      h = parseInt(m[1]);\n\n      if (h < 0) {\n        h = (360 - -1 * h % 360) % 360;\n      } else if (h > 360) {\n        h = h % 360;\n      }\n\n      h /= 360; // normalise on [0, 1]\n\n      s = parseFloat(m[2]);\n\n      if (s < 0 || s > 100) {\n        return;\n      } // saturation is [0, 100]\n\n\n      s = s / 100; // normalise on [0, 1]\n\n      l = parseFloat(m[3]);\n\n      if (l < 0 || l > 100) {\n        return;\n      } // lightness is [0, 100]\n\n\n      l = l / 100; // normalise on [0, 1]\n\n      a = m[4];\n\n      if (a !== undefined) {\n        a = parseFloat(a);\n\n        if (a < 0 || a > 1) {\n          return;\n        } // alpha is [0, 1]\n\n      } // now, convert to rgb\n      // code from http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript\n\n\n      if (s === 0) {\n        r = g = b = Math.round(l * 255); // achromatic\n      } else {\n        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n        var p = 2 * l - q;\n        r = Math.round(255 * hue2rgb(p, q, h + 1 / 3));\n        g = Math.round(255 * hue2rgb(p, q, h));\n        b = Math.round(255 * hue2rgb(p, q, h - 1 / 3));\n      }\n\n      ret = [r, g, b, a];\n    }\n\n    return ret;\n  }; // get [r, g, b, a] from rgb(0, 0, 0) or rgba(0, 0, 0, 0)\n\n  var rgb2tuple = function rgb2tuple(rgb) {\n    var ret;\n    var m = new RegExp('^' + rgba + '$').exec(rgb);\n\n    if (m) {\n      ret = [];\n      var isPct = [];\n\n      for (var i = 1; i <= 3; i++) {\n        var channel = m[i];\n\n        if (channel[channel.length - 1] === '%') {\n          isPct[i] = true;\n        }\n\n        channel = parseFloat(channel);\n\n        if (isPct[i]) {\n          channel = channel / 100 * 255; // normalise to [0, 255]\n        }\n\n        if (channel < 0 || channel > 255) {\n          return;\n        } // invalid channel value\n\n\n        ret.push(Math.floor(channel));\n      }\n\n      var atLeastOneIsPct = isPct[1] || isPct[2] || isPct[3];\n      var allArePct = isPct[1] && isPct[2] && isPct[3];\n\n      if (atLeastOneIsPct && !allArePct) {\n        return;\n      } // must all be percent values if one is\n\n\n      var alpha = m[4];\n\n      if (alpha !== undefined) {\n        alpha = parseFloat(alpha);\n\n        if (alpha < 0 || alpha > 1) {\n          return;\n        } // invalid alpha value\n\n\n        ret.push(alpha);\n      }\n    }\n\n    return ret;\n  };\n  var colorname2tuple = function colorname2tuple(color) {\n    return colors[color.toLowerCase()];\n  };\n  var color2tuple = function color2tuple(color) {\n    return (array(color) ? color : null) || colorname2tuple(color) || hex2tuple(color) || rgb2tuple(color) || hsl2tuple(color);\n  };\n  var colors = {\n    // special colour names\n    transparent: [0, 0, 0, 0],\n    // NB alpha === 0\n    // regular colours\n    aliceblue: [240, 248, 255],\n    antiquewhite: [250, 235, 215],\n    aqua: [0, 255, 255],\n    aquamarine: [127, 255, 212],\n    azure: [240, 255, 255],\n    beige: [245, 245, 220],\n    bisque: [255, 228, 196],\n    black: [0, 0, 0],\n    blanchedalmond: [255, 235, 205],\n    blue: [0, 0, 255],\n    blueviolet: [138, 43, 226],\n    brown: [165, 42, 42],\n    burlywood: [222, 184, 135],\n    cadetblue: [95, 158, 160],\n    chartreuse: [127, 255, 0],\n    chocolate: [210, 105, 30],\n    coral: [255, 127, 80],\n    cornflowerblue: [100, 149, 237],\n    cornsilk: [255, 248, 220],\n    crimson: [220, 20, 60],\n    cyan: [0, 255, 255],\n    darkblue: [0, 0, 139],\n    darkcyan: [0, 139, 139],\n    darkgoldenrod: [184, 134, 11],\n    darkgray: [169, 169, 169],\n    darkgreen: [0, 100, 0],\n    darkgrey: [169, 169, 169],\n    darkkhaki: [189, 183, 107],\n    darkmagenta: [139, 0, 139],\n    darkolivegreen: [85, 107, 47],\n    darkorange: [255, 140, 0],\n    darkorchid: [153, 50, 204],\n    darkred: [139, 0, 0],\n    darksalmon: [233, 150, 122],\n    darkseagreen: [143, 188, 143],\n    darkslateblue: [72, 61, 139],\n    darkslategray: [47, 79, 79],\n    darkslategrey: [47, 79, 79],\n    darkturquoise: [0, 206, 209],\n    darkviolet: [148, 0, 211],\n    deeppink: [255, 20, 147],\n    deepskyblue: [0, 191, 255],\n    dimgray: [105, 105, 105],\n    dimgrey: [105, 105, 105],\n    dodgerblue: [30, 144, 255],\n    firebrick: [178, 34, 34],\n    floralwhite: [255, 250, 240],\n    forestgreen: [34, 139, 34],\n    fuchsia: [255, 0, 255],\n    gainsboro: [220, 220, 220],\n    ghostwhite: [248, 248, 255],\n    gold: [255, 215, 0],\n    goldenrod: [218, 165, 32],\n    gray: [128, 128, 128],\n    grey: [128, 128, 128],\n    green: [0, 128, 0],\n    greenyellow: [173, 255, 47],\n    honeydew: [240, 255, 240],\n    hotpink: [255, 105, 180],\n    indianred: [205, 92, 92],\n    indigo: [75, 0, 130],\n    ivory: [255, 255, 240],\n    khaki: [240, 230, 140],\n    lavender: [230, 230, 250],\n    lavenderblush: [255, 240, 245],\n    lawngreen: [124, 252, 0],\n    lemonchiffon: [255, 250, 205],\n    lightblue: [173, 216, 230],\n    lightcoral: [240, 128, 128],\n    lightcyan: [224, 255, 255],\n    lightgoldenrodyellow: [250, 250, 210],\n    lightgray: [211, 211, 211],\n    lightgreen: [144, 238, 144],\n    lightgrey: [211, 211, 211],\n    lightpink: [255, 182, 193],\n    lightsalmon: [255, 160, 122],\n    lightseagreen: [32, 178, 170],\n    lightskyblue: [135, 206, 250],\n    lightslategray: [119, 136, 153],\n    lightslategrey: [119, 136, 153],\n    lightsteelblue: [176, 196, 222],\n    lightyellow: [255, 255, 224],\n    lime: [0, 255, 0],\n    limegreen: [50, 205, 50],\n    linen: [250, 240, 230],\n    magenta: [255, 0, 255],\n    maroon: [128, 0, 0],\n    mediumaquamarine: [102, 205, 170],\n    mediumblue: [0, 0, 205],\n    mediumorchid: [186, 85, 211],\n    mediumpurple: [147, 112, 219],\n    mediumseagreen: [60, 179, 113],\n    mediumslateblue: [123, 104, 238],\n    mediumspringgreen: [0, 250, 154],\n    mediumturquoise: [72, 209, 204],\n    mediumvioletred: [199, 21, 133],\n    midnightblue: [25, 25, 112],\n    mintcream: [245, 255, 250],\n    mistyrose: [255, 228, 225],\n    moccasin: [255, 228, 181],\n    navajowhite: [255, 222, 173],\n    navy: [0, 0, 128],\n    oldlace: [253, 245, 230],\n    olive: [128, 128, 0],\n    olivedrab: [107, 142, 35],\n    orange: [255, 165, 0],\n    orangered: [255, 69, 0],\n    orchid: [218, 112, 214],\n    palegoldenrod: [238, 232, 170],\n    palegreen: [152, 251, 152],\n    paleturquoise: [175, 238, 238],\n    palevioletred: [219, 112, 147],\n    papayawhip: [255, 239, 213],\n    peachpuff: [255, 218, 185],\n    peru: [205, 133, 63],\n    pink: [255, 192, 203],\n    plum: [221, 160, 221],\n    powderblue: [176, 224, 230],\n    purple: [128, 0, 128],\n    red: [255, 0, 0],\n    rosybrown: [188, 143, 143],\n    royalblue: [65, 105, 225],\n    saddlebrown: [139, 69, 19],\n    salmon: [250, 128, 114],\n    sandybrown: [244, 164, 96],\n    seagreen: [46, 139, 87],\n    seashell: [255, 245, 238],\n    sienna: [160, 82, 45],\n    silver: [192, 192, 192],\n    skyblue: [135, 206, 235],\n    slateblue: [106, 90, 205],\n    slategray: [112, 128, 144],\n    slategrey: [112, 128, 144],\n    snow: [255, 250, 250],\n    springgreen: [0, 255, 127],\n    steelblue: [70, 130, 180],\n    tan: [210, 180, 140],\n    teal: [0, 128, 128],\n    thistle: [216, 191, 216],\n    tomato: [255, 99, 71],\n    turquoise: [64, 224, 208],\n    violet: [238, 130, 238],\n    wheat: [245, 222, 179],\n    white: [255, 255, 255],\n    whitesmoke: [245, 245, 245],\n    yellow: [255, 255, 0],\n    yellowgreen: [154, 205, 50]\n  };\n\n  var setMap = function setMap(options) {\n    var obj = options.map;\n    var keys = options.keys;\n    var l = keys.length;\n\n    for (var i = 0; i < l; i++) {\n      var key = keys[i];\n\n      if (plainObject(key)) {\n        throw Error('Tried to set map with object key');\n      }\n\n      if (i < keys.length - 1) {\n        // extend the map if necessary\n        if (obj[key] == null) {\n          obj[key] = {};\n        }\n\n        obj = obj[key];\n      } else {\n        // set the value\n        obj[key] = options.value;\n      }\n    }\n  }; // gets the value in a map even if it's not built in places\n\n  var getMap = function getMap(options) {\n    var obj = options.map;\n    var keys = options.keys;\n    var l = keys.length;\n\n    for (var i = 0; i < l; i++) {\n      var key = keys[i];\n\n      if (plainObject(key)) {\n        throw Error('Tried to get map with object key');\n      }\n\n      obj = obj[key];\n\n      if (obj == null) {\n        return obj;\n      }\n    }\n\n    return obj;\n  }; // deletes the entry in the map\n\n  /**\n   * Checks if `value` is the\n   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n   * @example\n   *\n   * _.isObject({});\n   * // => true\n   *\n   * _.isObject([1, 2, 3]);\n   * // => true\n   *\n   * _.isObject(_.noop);\n   * // => true\n   *\n   * _.isObject(null);\n   * // => false\n   */\n  function isObject(value) {\n    var type = typeof value;\n    return value != null && (type == 'object' || type == 'function');\n  }\n\n  var isObject_1 = isObject;\n\n  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : typeof self !== 'undefined' ? self : {};\n\n  function createCommonjsModule(fn, module) {\n  \treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n  }\n\n  /** Detect free variable `global` from Node.js. */\n  var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;\n\n  var _freeGlobal = freeGlobal;\n\n  /** Detect free variable `self`. */\n  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n  /** Used as a reference to the global object. */\n  var root = _freeGlobal || freeSelf || Function('return this')();\n\n  var _root = root;\n\n  /**\n   * Gets the timestamp of the number of milliseconds that have elapsed since\n   * the Unix epoch (1 January 1970 00:00:00 UTC).\n   *\n   * @static\n   * @memberOf _\n   * @since 2.4.0\n   * @category Date\n   * @returns {number} Returns the timestamp.\n   * @example\n   *\n   * _.defer(function(stamp) {\n   *   console.log(_.now() - stamp);\n   * }, _.now());\n   * // => Logs the number of milliseconds it took for the deferred invocation.\n   */\n  var now = function() {\n    return _root.Date.now();\n  };\n\n  var now_1 = now;\n\n  /** Used to match a single whitespace character. */\n  var reWhitespace = /\\s/;\n\n  /**\n   * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace\n   * character of `string`.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {number} Returns the index of the last non-whitespace character.\n   */\n  function trimmedEndIndex(string) {\n    var index = string.length;\n\n    while (index-- && reWhitespace.test(string.charAt(index))) {}\n    return index;\n  }\n\n  var _trimmedEndIndex = trimmedEndIndex;\n\n  /** Used to match leading whitespace. */\n  var reTrimStart = /^\\s+/;\n\n  /**\n   * The base implementation of `_.trim`.\n   *\n   * @private\n   * @param {string} string The string to trim.\n   * @returns {string} Returns the trimmed string.\n   */\n  function baseTrim(string) {\n    return string\n      ? string.slice(0, _trimmedEndIndex(string) + 1).replace(reTrimStart, '')\n      : string;\n  }\n\n  var _baseTrim = baseTrim;\n\n  /** Built-in value references. */\n  var Symbol$1 = _root.Symbol;\n\n  var _Symbol = Symbol$1;\n\n  /** Used for built-in method references. */\n  var objectProto$5 = Object.prototype;\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty$4 = objectProto$5.hasOwnProperty;\n\n  /**\n   * Used to resolve the\n   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n   * of values.\n   */\n  var nativeObjectToString$1 = objectProto$5.toString;\n\n  /** Built-in value references. */\n  var symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;\n\n  /**\n   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n   *\n   * @private\n   * @param {*} value The value to query.\n   * @returns {string} Returns the raw `toStringTag`.\n   */\n  function getRawTag(value) {\n    var isOwn = hasOwnProperty$4.call(value, symToStringTag$1),\n        tag = value[symToStringTag$1];\n\n    try {\n      value[symToStringTag$1] = undefined;\n      var unmasked = true;\n    } catch (e) {}\n\n    var result = nativeObjectToString$1.call(value);\n    if (unmasked) {\n      if (isOwn) {\n        value[symToStringTag$1] = tag;\n      } else {\n        delete value[symToStringTag$1];\n      }\n    }\n    return result;\n  }\n\n  var _getRawTag = getRawTag;\n\n  /** Used for built-in method references. */\n  var objectProto$4 = Object.prototype;\n\n  /**\n   * Used to resolve the\n   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n   * of values.\n   */\n  var nativeObjectToString = objectProto$4.toString;\n\n  /**\n   * Converts `value` to a string using `Object.prototype.toString`.\n   *\n   * @private\n   * @param {*} value The value to convert.\n   * @returns {string} Returns the converted string.\n   */\n  function objectToString(value) {\n    return nativeObjectToString.call(value);\n  }\n\n  var _objectToString = objectToString;\n\n  /** `Object#toString` result references. */\n  var nullTag = '[object Null]',\n      undefinedTag = '[object Undefined]';\n\n  /** Built-in value references. */\n  var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;\n\n  /**\n   * The base implementation of `getTag` without fallbacks for buggy environments.\n   *\n   * @private\n   * @param {*} value The value to query.\n   * @returns {string} Returns the `toStringTag`.\n   */\n  function baseGetTag(value) {\n    if (value == null) {\n      return value === undefined ? undefinedTag : nullTag;\n    }\n    return (symToStringTag && symToStringTag in Object(value))\n      ? _getRawTag(value)\n      : _objectToString(value);\n  }\n\n  var _baseGetTag = baseGetTag;\n\n  /**\n   * Checks if `value` is object-like. A value is object-like if it's not `null`\n   * and has a `typeof` result of \"object\".\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n   * @example\n   *\n   * _.isObjectLike({});\n   * // => true\n   *\n   * _.isObjectLike([1, 2, 3]);\n   * // => true\n   *\n   * _.isObjectLike(_.noop);\n   * // => false\n   *\n   * _.isObjectLike(null);\n   * // => false\n   */\n  function isObjectLike(value) {\n    return value != null && typeof value == 'object';\n  }\n\n  var isObjectLike_1 = isObjectLike;\n\n  /** `Object#toString` result references. */\n  var symbolTag = '[object Symbol]';\n\n  /**\n   * Checks if `value` is classified as a `Symbol` primitive or object.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n   * @example\n   *\n   * _.isSymbol(Symbol.iterator);\n   * // => true\n   *\n   * _.isSymbol('abc');\n   * // => false\n   */\n  function isSymbol(value) {\n    return typeof value == 'symbol' ||\n      (isObjectLike_1(value) && _baseGetTag(value) == symbolTag);\n  }\n\n  var isSymbol_1 = isSymbol;\n\n  /** Used as references for various `Number` constants. */\n  var NAN = 0 / 0;\n\n  /** Used to detect bad signed hexadecimal string values. */\n  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n  /** Used to detect binary string values. */\n  var reIsBinary = /^0b[01]+$/i;\n\n  /** Used to detect octal string values. */\n  var reIsOctal = /^0o[0-7]+$/i;\n\n  /** Built-in method references without a dependency on `root`. */\n  var freeParseInt = parseInt;\n\n  /**\n   * Converts `value` to a number.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to process.\n   * @returns {number} Returns the number.\n   * @example\n   *\n   * _.toNumber(3.2);\n   * // => 3.2\n   *\n   * _.toNumber(Number.MIN_VALUE);\n   * // => 5e-324\n   *\n   * _.toNumber(Infinity);\n   * // => Infinity\n   *\n   * _.toNumber('3.2');\n   * // => 3.2\n   */\n  function toNumber(value) {\n    if (typeof value == 'number') {\n      return value;\n    }\n    if (isSymbol_1(value)) {\n      return NAN;\n    }\n    if (isObject_1(value)) {\n      var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n      value = isObject_1(other) ? (other + '') : other;\n    }\n    if (typeof value != 'string') {\n      return value === 0 ? value : +value;\n    }\n    value = _baseTrim(value);\n    var isBinary = reIsBinary.test(value);\n    return (isBinary || reIsOctal.test(value))\n      ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n      : (reIsBadHex.test(value) ? NAN : +value);\n  }\n\n  var toNumber_1 = toNumber;\n\n  /** Error message constants. */\n  var FUNC_ERROR_TEXT$1 = 'Expected a function';\n\n  /* Built-in method references for those with the same name as other `lodash` methods. */\n  var nativeMax = Math.max,\n      nativeMin = Math.min;\n\n  /**\n   * Creates a debounced function that delays invoking `func` until after `wait`\n   * milliseconds have elapsed since the last time the debounced function was\n   * invoked. The debounced function comes with a `cancel` method to cancel\n   * delayed `func` invocations and a `flush` method to immediately invoke them.\n   * Provide `options` to indicate whether `func` should be invoked on the\n   * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n   * with the last arguments provided to the debounced function. Subsequent\n   * calls to the debounced function return the result of the last `func`\n   * invocation.\n   *\n   * **Note:** If `leading` and `trailing` options are `true`, `func` is\n   * invoked on the trailing edge of the timeout only if the debounced function\n   * is invoked more than once during the `wait` timeout.\n   *\n   * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n   * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n   *\n   * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n   * for details over the differences between `_.debounce` and `_.throttle`.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Function\n   * @param {Function} func The function to debounce.\n   * @param {number} [wait=0] The number of milliseconds to delay.\n   * @param {Object} [options={}] The options object.\n   * @param {boolean} [options.leading=false]\n   *  Specify invoking on the leading edge of the timeout.\n   * @param {number} [options.maxWait]\n   *  The maximum time `func` is allowed to be delayed before it's invoked.\n   * @param {boolean} [options.trailing=true]\n   *  Specify invoking on the trailing edge of the timeout.\n   * @returns {Function} Returns the new debounced function.\n   * @example\n   *\n   * // Avoid costly calculations while the window size is in flux.\n   * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n   *\n   * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n   * jQuery(element).on('click', _.debounce(sendMail, 300, {\n   *   'leading': true,\n   *   'trailing': false\n   * }));\n   *\n   * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n   * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n   * var source = new EventSource('/stream');\n   * jQuery(source).on('message', debounced);\n   *\n   * // Cancel the trailing debounced invocation.\n   * jQuery(window).on('popstate', debounced.cancel);\n   */\n  function debounce(func, wait, options) {\n    var lastArgs,\n        lastThis,\n        maxWait,\n        result,\n        timerId,\n        lastCallTime,\n        lastInvokeTime = 0,\n        leading = false,\n        maxing = false,\n        trailing = true;\n\n    if (typeof func != 'function') {\n      throw new TypeError(FUNC_ERROR_TEXT$1);\n    }\n    wait = toNumber_1(wait) || 0;\n    if (isObject_1(options)) {\n      leading = !!options.leading;\n      maxing = 'maxWait' in options;\n      maxWait = maxing ? nativeMax(toNumber_1(options.maxWait) || 0, wait) : maxWait;\n      trailing = 'trailing' in options ? !!options.trailing : trailing;\n    }\n\n    function invokeFunc(time) {\n      var args = lastArgs,\n          thisArg = lastThis;\n\n      lastArgs = lastThis = undefined;\n      lastInvokeTime = time;\n      result = func.apply(thisArg, args);\n      return result;\n    }\n\n    function leadingEdge(time) {\n      // Reset any `maxWait` timer.\n      lastInvokeTime = time;\n      // Start the timer for the trailing edge.\n      timerId = setTimeout(timerExpired, wait);\n      // Invoke the leading edge.\n      return leading ? invokeFunc(time) : result;\n    }\n\n    function remainingWait(time) {\n      var timeSinceLastCall = time - lastCallTime,\n          timeSinceLastInvoke = time - lastInvokeTime,\n          timeWaiting = wait - timeSinceLastCall;\n\n      return maxing\n        ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)\n        : timeWaiting;\n    }\n\n    function shouldInvoke(time) {\n      var timeSinceLastCall = time - lastCallTime,\n          timeSinceLastInvoke = time - lastInvokeTime;\n\n      // Either this is the first call, activity has stopped and we're at the\n      // trailing edge, the system time has gone backwards and we're treating\n      // it as the trailing edge, or we've hit the `maxWait` limit.\n      return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n        (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n    }\n\n    function timerExpired() {\n      var time = now_1();\n      if (shouldInvoke(time)) {\n        return trailingEdge(time);\n      }\n      // Restart the timer.\n      timerId = setTimeout(timerExpired, remainingWait(time));\n    }\n\n    function trailingEdge(time) {\n      timerId = undefined;\n\n      // Only invoke if we have `lastArgs` which means `func` has been\n      // debounced at least once.\n      if (trailing && lastArgs) {\n        return invokeFunc(time);\n      }\n      lastArgs = lastThis = undefined;\n      return result;\n    }\n\n    function cancel() {\n      if (timerId !== undefined) {\n        clearTimeout(timerId);\n      }\n      lastInvokeTime = 0;\n      lastArgs = lastCallTime = lastThis = timerId = undefined;\n    }\n\n    function flush() {\n      return timerId === undefined ? result : trailingEdge(now_1());\n    }\n\n    function debounced() {\n      var time = now_1(),\n          isInvoking = shouldInvoke(time);\n\n      lastArgs = arguments;\n      lastThis = this;\n      lastCallTime = time;\n\n      if (isInvoking) {\n        if (timerId === undefined) {\n          return leadingEdge(lastCallTime);\n        }\n        if (maxing) {\n          // Handle invocations in a tight loop.\n          clearTimeout(timerId);\n          timerId = setTimeout(timerExpired, wait);\n          return invokeFunc(lastCallTime);\n        }\n      }\n      if (timerId === undefined) {\n        timerId = setTimeout(timerExpired, wait);\n      }\n      return result;\n    }\n    debounced.cancel = cancel;\n    debounced.flush = flush;\n    return debounced;\n  }\n\n  var debounce_1 = debounce;\n\n  var performance = window$1 ? window$1.performance : null;\n  var pnow = performance && performance.now ? function () {\n    return performance.now();\n  } : function () {\n    return Date.now();\n  };\n\n  var raf = function () {\n    if (window$1) {\n      if (window$1.requestAnimationFrame) {\n        return function (fn) {\n          window$1.requestAnimationFrame(fn);\n        };\n      } else if (window$1.mozRequestAnimationFrame) {\n        return function (fn) {\n          window$1.mozRequestAnimationFrame(fn);\n        };\n      } else if (window$1.webkitRequestAnimationFrame) {\n        return function (fn) {\n          window$1.webkitRequestAnimationFrame(fn);\n        };\n      } else if (window$1.msRequestAnimationFrame) {\n        return function (fn) {\n          window$1.msRequestAnimationFrame(fn);\n        };\n      }\n    }\n\n    return function (fn) {\n      if (fn) {\n        setTimeout(function () {\n          fn(pnow());\n        }, 1000 / 60);\n      }\n    };\n  }();\n\n  var requestAnimationFrame = function requestAnimationFrame(fn) {\n    return raf(fn);\n  };\n  var performanceNow = pnow;\n\n  var DEFAULT_HASH_SEED = 9261;\n  var K = 65599; // 37 also works pretty well\n\n  var DEFAULT_HASH_SEED_ALT = 5381;\n  var hashIterableInts = function hashIterableInts(iterator) {\n    var seed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_HASH_SEED;\n    // sdbm/string-hash\n    var hash = seed;\n    var entry;\n\n    for (;;) {\n      entry = iterator.next();\n\n      if (entry.done) {\n        break;\n      }\n\n      hash = hash * K + entry.value | 0;\n    }\n\n    return hash;\n  };\n  var hashInt = function hashInt(num) {\n    var seed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_HASH_SEED;\n    // sdbm/string-hash\n    return seed * K + num | 0;\n  };\n  var hashIntAlt = function hashIntAlt(num) {\n    var seed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_HASH_SEED_ALT;\n    // djb2/string-hash\n    return (seed << 5) + seed + num | 0;\n  };\n  var combineHashes = function combineHashes(hash1, hash2) {\n    return hash1 * 0x200000 + hash2;\n  };\n  var combineHashesArray = function combineHashesArray(hashes) {\n    return hashes[0] * 0x200000 + hashes[1];\n  };\n  var hashArrays = function hashArrays(hashes1, hashes2) {\n    return [hashInt(hashes1[0], hashes2[0]), hashIntAlt(hashes1[1], hashes2[1])];\n  };\n  var hashIntsArray = function hashIntsArray(ints, seed) {\n    var entry = {\n      value: 0,\n      done: false\n    };\n    var i = 0;\n    var length = ints.length;\n    var iterator = {\n      next: function next() {\n        if (i < length) {\n          entry.value = ints[i++];\n        } else {\n          entry.done = true;\n        }\n\n        return entry;\n      }\n    };\n    return hashIterableInts(iterator, seed);\n  };\n  var hashString = function hashString(str, seed) {\n    var entry = {\n      value: 0,\n      done: false\n    };\n    var i = 0;\n    var length = str.length;\n    var iterator = {\n      next: function next() {\n        if (i < length) {\n          entry.value = str.charCodeAt(i++);\n        } else {\n          entry.done = true;\n        }\n\n        return entry;\n      }\n    };\n    return hashIterableInts(iterator, seed);\n  };\n  var hashStrings = function hashStrings() {\n    return hashStringsArray(arguments);\n  };\n  var hashStringsArray = function hashStringsArray(strs) {\n    var hash;\n\n    for (var i = 0; i < strs.length; i++) {\n      var str = strs[i];\n\n      if (i === 0) {\n        hash = hashString(str);\n      } else {\n        hash = hashString(str, hash);\n      }\n    }\n\n    return hash;\n  };\n\n  /*global console */\n  var warningsEnabled = true;\n  var warnSupported = console.warn != null; // eslint-disable-line no-console\n\n  var traceSupported = console.trace != null; // eslint-disable-line no-console\n\n  var MAX_INT$1 = Number.MAX_SAFE_INTEGER || 9007199254740991;\n  var trueify = function trueify() {\n    return true;\n  };\n  var falsify = function falsify() {\n    return false;\n  };\n  var zeroify = function zeroify() {\n    return 0;\n  };\n  var noop$1 = function noop() {};\n  var error = function error(msg) {\n    throw new Error(msg);\n  };\n  var warnings = function warnings(enabled) {\n    if (enabled !== undefined) {\n      warningsEnabled = !!enabled;\n    } else {\n      return warningsEnabled;\n    }\n  };\n  var warn = function warn(msg) {\n    /* eslint-disable no-console */\n    if (!warnings()) {\n      return;\n    }\n\n    if (warnSupported) {\n      console.warn(msg);\n    } else {\n      console.log(msg);\n\n      if (traceSupported) {\n        console.trace();\n      }\n    }\n  };\n  /* eslint-enable */\n\n  var clone = function clone(obj) {\n    return extend({}, obj);\n  }; // gets a shallow copy of the argument\n\n  var copy = function copy(obj) {\n    if (obj == null) {\n      return obj;\n    }\n\n    if (array(obj)) {\n      return obj.slice();\n    } else if (plainObject(obj)) {\n      return clone(obj);\n    } else {\n      return obj;\n    }\n  };\n  var copyArray$1 = function copyArray(arr) {\n    return arr.slice();\n  };\n  var uuid = function uuid(a, b\n  /* placeholders */\n  ) {\n    for ( // loop :)\n    b = a = ''; // b - result , a - numeric letiable\n    a++ < 36; //\n    b += a * 51 & 52 // if \"a\" is not 9 or 14 or 19 or 24\n    ? //  return a random number or 4\n    (a ^ 15 // if \"a\" is not 15\n    ? // generate a random number from 0 to 15\n    8 ^ Math.random() * (a ^ 20 ? 16 : 4) // unless \"a\" is 20, in which case a random number from 8 to 11\n    : 4 //  otherwise 4\n    ).toString(16) : '-' //  in other cases (if \"a\" is 9,14,19,24) insert \"-\"\n    ) {\n    }\n\n    return b;\n  };\n  var _staticEmptyObject = {};\n  var staticEmptyObject = function staticEmptyObject() {\n    return _staticEmptyObject;\n  };\n  var defaults$g = function defaults(_defaults) {\n    var keys = Object.keys(_defaults);\n    return function (opts) {\n      var filledOpts = {};\n\n      for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        var optVal = opts == null ? undefined : opts[key];\n        filledOpts[key] = optVal === undefined ? _defaults[key] : optVal;\n      }\n\n      return filledOpts;\n    };\n  };\n  var removeFromArray = function removeFromArray(arr, ele, oneCopy) {\n    for (var i = arr.length - 1; i >= 0; i--) {\n      if (arr[i] === ele) {\n        arr.splice(i, 1);\n\n        if (oneCopy) {\n          break;\n        }\n      }\n    }\n  };\n  var clearArray = function clearArray(arr) {\n    arr.splice(0, arr.length);\n  };\n  var push = function push(arr, otherArr) {\n    for (var i = 0; i < otherArr.length; i++) {\n      var el = otherArr[i];\n      arr.push(el);\n    }\n  };\n  var getPrefixedProperty = function getPrefixedProperty(obj, propName, prefix) {\n    if (prefix) {\n      propName = prependCamel(prefix, propName); // e.g. (labelWidth, source) => sourceLabelWidth\n    }\n\n    return obj[propName];\n  };\n  var setPrefixedProperty = function setPrefixedProperty(obj, propName, prefix, value) {\n    if (prefix) {\n      propName = prependCamel(prefix, propName); // e.g. (labelWidth, source) => sourceLabelWidth\n    }\n\n    obj[propName] = value;\n  };\n\n  /* global Map */\n  var ObjectMap = /*#__PURE__*/function () {\n    function ObjectMap() {\n      _classCallCheck(this, ObjectMap);\n\n      this._obj = {};\n    }\n\n    _createClass(ObjectMap, [{\n      key: \"set\",\n      value: function set(key, val) {\n        this._obj[key] = val;\n        return this;\n      }\n    }, {\n      key: \"delete\",\n      value: function _delete(key) {\n        this._obj[key] = undefined;\n        return this;\n      }\n    }, {\n      key: \"clear\",\n      value: function clear() {\n        this._obj = {};\n      }\n    }, {\n      key: \"has\",\n      value: function has(key) {\n        return this._obj[key] !== undefined;\n      }\n    }, {\n      key: \"get\",\n      value: function get(key) {\n        return this._obj[key];\n      }\n    }]);\n\n    return ObjectMap;\n  }();\n\n  var Map$2 = typeof Map !== 'undefined' ? Map : ObjectMap;\n\n  /* global Set */\n  var undef = \"undefined\" ;\n\n  var ObjectSet = /*#__PURE__*/function () {\n    function ObjectSet(arrayOrObjectSet) {\n      _classCallCheck(this, ObjectSet);\n\n      this._obj = Object.create(null);\n      this.size = 0;\n\n      if (arrayOrObjectSet != null) {\n        var arr;\n\n        if (arrayOrObjectSet.instanceString != null && arrayOrObjectSet.instanceString() === this.instanceString()) {\n          arr = arrayOrObjectSet.toArray();\n        } else {\n          arr = arrayOrObjectSet;\n        }\n\n        for (var i = 0; i < arr.length; i++) {\n          this.add(arr[i]);\n        }\n      }\n    }\n\n    _createClass(ObjectSet, [{\n      key: \"instanceString\",\n      value: function instanceString() {\n        return 'set';\n      }\n    }, {\n      key: \"add\",\n      value: function add(val) {\n        var o = this._obj;\n\n        if (o[val] !== 1) {\n          o[val] = 1;\n          this.size++;\n        }\n      }\n    }, {\n      key: \"delete\",\n      value: function _delete(val) {\n        var o = this._obj;\n\n        if (o[val] === 1) {\n          o[val] = 0;\n          this.size--;\n        }\n      }\n    }, {\n      key: \"clear\",\n      value: function clear() {\n        this._obj = Object.create(null);\n      }\n    }, {\n      key: \"has\",\n      value: function has(val) {\n        return this._obj[val] === 1;\n      }\n    }, {\n      key: \"toArray\",\n      value: function toArray() {\n        var _this = this;\n\n        return Object.keys(this._obj).filter(function (key) {\n          return _this.has(key);\n        });\n      }\n    }, {\n      key: \"forEach\",\n      value: function forEach(callback, thisArg) {\n        return this.toArray().forEach(callback, thisArg);\n      }\n    }]);\n\n    return ObjectSet;\n  }();\n\n  var Set$1 = (typeof Set === \"undefined\" ? \"undefined\" : _typeof(Set)) !== undef ? Set : ObjectSet;\n\n  var Element = function Element(cy, params) {\n    var restore = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n    if (cy === undefined || params === undefined || !core(cy)) {\n      error('An element must have a core reference and parameters set');\n      return;\n    }\n\n    var group = params.group; // try to automatically infer the group if unspecified\n\n    if (group == null) {\n      if (params.data && params.data.source != null && params.data.target != null) {\n        group = 'edges';\n      } else {\n        group = 'nodes';\n      }\n    } // validate group\n\n\n    if (group !== 'nodes' && group !== 'edges') {\n      error('An element must be of type `nodes` or `edges`; you specified `' + group + '`');\n      return;\n    } // make the element array-like, just like a collection\n\n\n    this.length = 1;\n    this[0] = this; // NOTE: when something is added here, add also to ele.json()\n\n    var _p = this._private = {\n      cy: cy,\n      single: true,\n      // indicates this is an element\n      data: params.data || {},\n      // data object\n      position: params.position || {\n        x: 0,\n        y: 0\n      },\n      // (x, y) position pair\n      autoWidth: undefined,\n      // width and height of nodes calculated by the renderer when set to special 'auto' value\n      autoHeight: undefined,\n      autoPadding: undefined,\n      compoundBoundsClean: false,\n      // whether the compound dimensions need to be recalculated the next time dimensions are read\n      listeners: [],\n      // array of bound listeners\n      group: group,\n      // string; 'nodes' or 'edges'\n      style: {},\n      // properties as set by the style\n      rstyle: {},\n      // properties for style sent from the renderer to the core\n      styleCxts: [],\n      // applied style contexts from the styler\n      styleKeys: {},\n      // per-group keys of style property values\n      removed: true,\n      // whether it's inside the vis; true if removed (set true here since we call restore)\n      selected: params.selected ? true : false,\n      // whether it's selected\n      selectable: params.selectable === undefined ? true : params.selectable ? true : false,\n      // whether it's selectable\n      locked: params.locked ? true : false,\n      // whether the element is locked (cannot be moved)\n      grabbed: false,\n      // whether the element is grabbed by the mouse; renderer sets this privately\n      grabbable: params.grabbable === undefined ? true : params.grabbable ? true : false,\n      // whether the element can be grabbed\n      pannable: params.pannable === undefined ? group === 'edges' ? true : false : params.pannable ? true : false,\n      // whether the element has passthrough panning enabled\n      active: false,\n      // whether the element is active from user interaction\n      classes: new Set$1(),\n      // map ( className => true )\n      animation: {\n        // object for currently-running animations\n        current: [],\n        queue: []\n      },\n      rscratch: {},\n      // object in which the renderer can store information\n      scratch: params.scratch || {},\n      // scratch objects\n      edges: [],\n      // array of connected edges\n      children: [],\n      // array of children\n      parent: params.parent && params.parent.isNode() ? params.parent : null,\n      // parent ref\n      traversalCache: {},\n      // cache of output of traversal functions\n      backgrounding: false,\n      // whether background images are loading\n      bbCache: null,\n      // cache of the current bounding box\n      bbCacheShift: {\n        x: 0,\n        y: 0\n      },\n      // shift applied to cached bb to be applied on next get\n      bodyBounds: null,\n      // bounds cache of element body, w/o overlay\n      overlayBounds: null,\n      // bounds cache of element body, including overlay\n      labelBounds: {\n        // bounds cache of labels\n        all: null,\n        source: null,\n        target: null,\n        main: null\n      },\n      arrowBounds: {\n        // bounds cache of edge arrows\n        source: null,\n        target: null,\n        'mid-source': null,\n        'mid-target': null\n      }\n    };\n\n    if (_p.position.x == null) {\n      _p.position.x = 0;\n    }\n\n    if (_p.position.y == null) {\n      _p.position.y = 0;\n    } // renderedPosition overrides if specified\n\n\n    if (params.renderedPosition) {\n      var rpos = params.renderedPosition;\n      var pan = cy.pan();\n      var zoom = cy.zoom();\n      _p.position = {\n        x: (rpos.x - pan.x) / zoom,\n        y: (rpos.y - pan.y) / zoom\n      };\n    }\n\n    var classes = [];\n\n    if (array(params.classes)) {\n      classes = params.classes;\n    } else if (string(params.classes)) {\n      classes = params.classes.split(/\\s+/);\n    }\n\n    for (var i = 0, l = classes.length; i < l; i++) {\n      var cls = classes[i];\n\n      if (!cls || cls === '') {\n        continue;\n      }\n\n      _p.classes.add(cls);\n    }\n\n    this.createEmitter();\n    var bypass = params.style || params.css;\n\n    if (bypass) {\n      warn('Setting a `style` bypass at element creation should be done only when absolutely necessary.  Try to use the stylesheet instead.');\n      this.style(bypass);\n    }\n\n    if (restore === undefined || restore) {\n      this.restore();\n    }\n  };\n\n  var defineSearch = function defineSearch(params) {\n    params = {\n      bfs: params.bfs || !params.dfs,\n      dfs: params.dfs || !params.bfs\n    }; // from pseudocode on wikipedia\n\n    return function searchFn(roots, fn, directed) {\n      var options;\n\n      if (plainObject(roots) && !elementOrCollection(roots)) {\n        options = roots;\n        roots = options.roots || options.root;\n        fn = options.visit;\n        directed = options.directed;\n      }\n\n      directed = arguments.length === 2 && !fn$6(fn) ? fn : directed;\n      fn = fn$6(fn) ? fn : function () {};\n      var cy = this._private.cy;\n      var v = roots = string(roots) ? this.filter(roots) : roots;\n      var Q = [];\n      var connectedNodes = [];\n      var connectedBy = {};\n      var id2depth = {};\n      var V = {};\n      var j = 0;\n      var found;\n\n      var _this$byGroup = this.byGroup(),\n          nodes = _this$byGroup.nodes,\n          edges = _this$byGroup.edges; // enqueue v\n\n\n      for (var i = 0; i < v.length; i++) {\n        var vi = v[i];\n        var viId = vi.id();\n\n        if (vi.isNode()) {\n          Q.unshift(vi);\n\n          if (params.bfs) {\n            V[viId] = true;\n            connectedNodes.push(vi);\n          }\n\n          id2depth[viId] = 0;\n        }\n      }\n\n      var _loop = function _loop() {\n        var v = params.bfs ? Q.shift() : Q.pop();\n        var vId = v.id();\n\n        if (params.dfs) {\n          if (V[vId]) {\n            return \"continue\";\n          }\n\n          V[vId] = true;\n          connectedNodes.push(v);\n        }\n\n        var depth = id2depth[vId];\n        var prevEdge = connectedBy[vId];\n        var src = prevEdge != null ? prevEdge.source() : null;\n        var tgt = prevEdge != null ? prevEdge.target() : null;\n        var prevNode = prevEdge == null ? undefined : v.same(src) ? tgt[0] : src[0];\n        var ret = void 0;\n        ret = fn(v, prevEdge, prevNode, j++, depth);\n\n        if (ret === true) {\n          found = v;\n          return \"break\";\n        }\n\n        if (ret === false) {\n          return \"break\";\n        }\n\n        var vwEdges = v.connectedEdges().filter(function (e) {\n          return (!directed || e.source().same(v)) && edges.has(e);\n        });\n\n        for (var _i2 = 0; _i2 < vwEdges.length; _i2++) {\n          var e = vwEdges[_i2];\n          var w = e.connectedNodes().filter(function (n) {\n            return !n.same(v) && nodes.has(n);\n          });\n          var wId = w.id();\n\n          if (w.length !== 0 && !V[wId]) {\n            w = w[0];\n            Q.push(w);\n\n            if (params.bfs) {\n              V[wId] = true;\n              connectedNodes.push(w);\n            }\n\n            connectedBy[wId] = e;\n            id2depth[wId] = id2depth[vId] + 1;\n          }\n        }\n      };\n\n      while (Q.length !== 0) {\n        var _ret = _loop();\n\n        if (_ret === \"continue\") continue;\n        if (_ret === \"break\") break;\n      }\n\n      var connectedEles = cy.collection();\n\n      for (var _i = 0; _i < connectedNodes.length; _i++) {\n        var node = connectedNodes[_i];\n        var edge = connectedBy[node.id()];\n\n        if (edge != null) {\n          connectedEles.push(edge);\n        }\n\n        connectedEles.push(node);\n      }\n\n      return {\n        path: cy.collection(connectedEles),\n        found: cy.collection(found)\n      };\n    };\n  }; // search, spanning trees, etc\n\n\n  var elesfn$v = {\n    breadthFirstSearch: defineSearch({\n      bfs: true\n    }),\n    depthFirstSearch: defineSearch({\n      dfs: true\n    })\n  }; // nice, short mathematical alias\n\n  elesfn$v.bfs = elesfn$v.breadthFirstSearch;\n  elesfn$v.dfs = elesfn$v.depthFirstSearch;\n\n  var heap$1 = createCommonjsModule(function (module, exports) {\n  // Generated by CoffeeScript 1.8.0\n  (function() {\n    var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;\n\n    floor = Math.floor, min = Math.min;\n\n\n    /*\n    Default comparison function to be used\n     */\n\n    defaultCmp = function(x, y) {\n      if (x < y) {\n        return -1;\n      }\n      if (x > y) {\n        return 1;\n      }\n      return 0;\n    };\n\n\n    /*\n    Insert item x in list a, and keep it sorted assuming a is sorted.\n    \n    If x is already in a, insert it to the right of the rightmost x.\n    \n    Optional args lo (default 0) and hi (default a.length) bound the slice\n    of a to be searched.\n     */\n\n    insort = function(a, x, lo, hi, cmp) {\n      var mid;\n      if (lo == null) {\n        lo = 0;\n      }\n      if (cmp == null) {\n        cmp = defaultCmp;\n      }\n      if (lo < 0) {\n        throw new Error('lo must be non-negative');\n      }\n      if (hi == null) {\n        hi = a.length;\n      }\n      while (lo < hi) {\n        mid = floor((lo + hi) / 2);\n        if (cmp(x, a[mid]) < 0) {\n          hi = mid;\n        } else {\n          lo = mid + 1;\n        }\n      }\n      return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);\n    };\n\n\n    /*\n    Push item onto heap, maintaining the heap invariant.\n     */\n\n    heappush = function(array, item, cmp) {\n      if (cmp == null) {\n        cmp = defaultCmp;\n      }\n      array.push(item);\n      return _siftdown(array, 0, array.length - 1, cmp);\n    };\n\n\n    /*\n    Pop the smallest item off the heap, maintaining the heap invariant.\n     */\n\n    heappop = function(array, cmp) {\n      var lastelt, returnitem;\n      if (cmp == null) {\n        cmp = defaultCmp;\n      }\n      lastelt = array.pop();\n      if (array.length) {\n        returnitem = array[0];\n        array[0] = lastelt;\n        _siftup(array, 0, cmp);\n      } else {\n        returnitem = lastelt;\n      }\n      return returnitem;\n    };\n\n\n    /*\n    Pop and return the current smallest value, and add the new item.\n    \n    This is more efficient than heappop() followed by heappush(), and can be\n    more appropriate when using a fixed size heap. Note that the value\n    returned may be larger than item! That constrains reasonable use of\n    this routine unless written as part of a conditional replacement:\n        if item > array[0]\n          item = heapreplace(array, item)\n     */\n\n    heapreplace = function(array, item, cmp) {\n      var returnitem;\n      if (cmp == null) {\n        cmp = defaultCmp;\n      }\n      returnitem = array[0];\n      array[0] = item;\n      _siftup(array, 0, cmp);\n      return returnitem;\n    };\n\n\n    /*\n    Fast version of a heappush followed by a heappop.\n     */\n\n    heappushpop = function(array, item, cmp) {\n      var _ref;\n      if (cmp == null) {\n        cmp = defaultCmp;\n      }\n      if (array.length && cmp(array[0], item) < 0) {\n        _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];\n        _siftup(array, 0, cmp);\n      }\n      return item;\n    };\n\n\n    /*\n    Transform list into a heap, in-place, in O(array.length) time.\n     */\n\n    heapify = function(array, cmp) {\n      var i, _i, _len, _ref1, _results, _results1;\n      if (cmp == null) {\n        cmp = defaultCmp;\n      }\n      _ref1 = (function() {\n        _results1 = [];\n        for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }\n        return _results1;\n      }).apply(this).reverse();\n      _results = [];\n      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n        i = _ref1[_i];\n        _results.push(_siftup(array, i, cmp));\n      }\n      return _results;\n    };\n\n\n    /*\n    Update the position of the given item in the heap.\n    This function should be called every time the item is being modified.\n     */\n\n    updateItem = function(array, item, cmp) {\n      var pos;\n      if (cmp == null) {\n        cmp = defaultCmp;\n      }\n      pos = array.indexOf(item);\n      if (pos === -1) {\n        return;\n      }\n      _siftdown(array, 0, pos, cmp);\n      return _siftup(array, pos, cmp);\n    };\n\n\n    /*\n    Find the n largest elements in a dataset.\n     */\n\n    nlargest = function(array, n, cmp) {\n      var elem, result, _i, _len, _ref;\n      if (cmp == null) {\n        cmp = defaultCmp;\n      }\n      result = array.slice(0, n);\n      if (!result.length) {\n        return result;\n      }\n      heapify(result, cmp);\n      _ref = array.slice(n);\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        elem = _ref[_i];\n        heappushpop(result, elem, cmp);\n      }\n      return result.sort(cmp).reverse();\n    };\n\n\n    /*\n    Find the n smallest elements in a dataset.\n     */\n\n    nsmallest = function(array, n, cmp) {\n      var elem, los, result, _i, _j, _len, _ref, _ref1, _results;\n      if (cmp == null) {\n        cmp = defaultCmp;\n      }\n      if (n * 10 <= array.length) {\n        result = array.slice(0, n).sort(cmp);\n        if (!result.length) {\n          return result;\n        }\n        los = result[result.length - 1];\n        _ref = array.slice(n);\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          elem = _ref[_i];\n          if (cmp(elem, los) < 0) {\n            insort(result, elem, 0, null, cmp);\n            result.pop();\n            los = result[result.length - 1];\n          }\n        }\n        return result;\n      }\n      heapify(array, cmp);\n      _results = [];\n      for (_j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; 0 <= _ref1 ? ++_j : --_j) {\n        _results.push(heappop(array, cmp));\n      }\n      return _results;\n    };\n\n    _siftdown = function(array, startpos, pos, cmp) {\n      var newitem, parent, parentpos;\n      if (cmp == null) {\n        cmp = defaultCmp;\n      }\n      newitem = array[pos];\n      while (pos > startpos) {\n        parentpos = (pos - 1) >> 1;\n        parent = array[parentpos];\n        if (cmp(newitem, parent) < 0) {\n          array[pos] = parent;\n          pos = parentpos;\n          continue;\n        }\n        break;\n      }\n      return array[pos] = newitem;\n    };\n\n    _siftup = function(array, pos, cmp) {\n      var childpos, endpos, newitem, rightpos, startpos;\n      if (cmp == null) {\n        cmp = defaultCmp;\n      }\n      endpos = array.length;\n      startpos = pos;\n      newitem = array[pos];\n      childpos = 2 * pos + 1;\n      while (childpos < endpos) {\n        rightpos = childpos + 1;\n        if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {\n          childpos = rightpos;\n        }\n        array[pos] = array[childpos];\n        pos = childpos;\n        childpos = 2 * pos + 1;\n      }\n      array[pos] = newitem;\n      return _siftdown(array, startpos, pos, cmp);\n    };\n\n    Heap = (function() {\n      Heap.push = heappush;\n\n      Heap.pop = heappop;\n\n      Heap.replace = heapreplace;\n\n      Heap.pushpop = heappushpop;\n\n      Heap.heapify = heapify;\n\n      Heap.updateItem = updateItem;\n\n      Heap.nlargest = nlargest;\n\n      Heap.nsmallest = nsmallest;\n\n      function Heap(cmp) {\n        this.cmp = cmp != null ? cmp : defaultCmp;\n        this.nodes = [];\n      }\n\n      Heap.prototype.push = function(x) {\n        return heappush(this.nodes, x, this.cmp);\n      };\n\n      Heap.prototype.pop = function() {\n        return heappop(this.nodes, this.cmp);\n      };\n\n      Heap.prototype.peek = function() {\n        return this.nodes[0];\n      };\n\n      Heap.prototype.contains = function(x) {\n        return this.nodes.indexOf(x) !== -1;\n      };\n\n      Heap.prototype.replace = function(x) {\n        return heapreplace(this.nodes, x, this.cmp);\n      };\n\n      Heap.prototype.pushpop = function(x) {\n        return heappushpop(this.nodes, x, this.cmp);\n      };\n\n      Heap.prototype.heapify = function() {\n        return heapify(this.nodes, this.cmp);\n      };\n\n      Heap.prototype.updateItem = function(x) {\n        return updateItem(this.nodes, x, this.cmp);\n      };\n\n      Heap.prototype.clear = function() {\n        return this.nodes = [];\n      };\n\n      Heap.prototype.empty = function() {\n        return this.nodes.length === 0;\n      };\n\n      Heap.prototype.size = function() {\n        return this.nodes.length;\n      };\n\n      Heap.prototype.clone = function() {\n        var heap;\n        heap = new Heap();\n        heap.nodes = this.nodes.slice(0);\n        return heap;\n      };\n\n      Heap.prototype.toArray = function() {\n        return this.nodes.slice(0);\n      };\n\n      Heap.prototype.insert = Heap.prototype.push;\n\n      Heap.prototype.top = Heap.prototype.peek;\n\n      Heap.prototype.front = Heap.prototype.peek;\n\n      Heap.prototype.has = Heap.prototype.contains;\n\n      Heap.prototype.copy = Heap.prototype.clone;\n\n      return Heap;\n\n    })();\n\n    (function(root, factory) {\n      {\n        return module.exports = factory();\n      }\n    })(this, function() {\n      return Heap;\n    });\n\n  }).call(commonjsGlobal);\n  });\n\n  var heap = heap$1;\n\n  var dijkstraDefaults = defaults$g({\n    root: null,\n    weight: function weight(edge) {\n      return 1;\n    },\n    directed: false\n  });\n  var elesfn$u = {\n    dijkstra: function dijkstra(options) {\n      if (!plainObject(options)) {\n        var args = arguments;\n        options = {\n          root: args[0],\n          weight: args[1],\n          directed: args[2]\n        };\n      }\n\n      var _dijkstraDefaults = dijkstraDefaults(options),\n          root = _dijkstraDefaults.root,\n          weight = _dijkstraDefaults.weight,\n          directed = _dijkstraDefaults.directed;\n\n      var eles = this;\n      var weightFn = weight;\n      var source = string(root) ? this.filter(root)[0] : root[0];\n      var dist = {};\n      var prev = {};\n      var knownDist = {};\n\n      var _this$byGroup = this.byGroup(),\n          nodes = _this$byGroup.nodes,\n          edges = _this$byGroup.edges;\n\n      edges.unmergeBy(function (ele) {\n        return ele.isLoop();\n      });\n\n      var getDist = function getDist(node) {\n        return dist[node.id()];\n      };\n\n      var setDist = function setDist(node, d) {\n        dist[node.id()] = d;\n        Q.updateItem(node);\n      };\n\n      var Q = new heap(function (a, b) {\n        return getDist(a) - getDist(b);\n      });\n\n      for (var i = 0; i < nodes.length; i++) {\n        var node = nodes[i];\n        dist[node.id()] = node.same(source) ? 0 : Infinity;\n        Q.push(node);\n      }\n\n      var distBetween = function distBetween(u, v) {\n        var uvs = (directed ? u.edgesTo(v) : u.edgesWith(v)).intersect(edges);\n        var smallestDistance = Infinity;\n        var smallestEdge;\n\n        for (var _i = 0; _i < uvs.length; _i++) {\n          var edge = uvs[_i];\n\n          var _weight = weightFn(edge);\n\n          if (_weight < smallestDistance || !smallestEdge) {\n            smallestDistance = _weight;\n            smallestEdge = edge;\n          }\n        }\n\n        return {\n          edge: smallestEdge,\n          dist: smallestDistance\n        };\n      };\n\n      while (Q.size() > 0) {\n        var u = Q.pop();\n        var smalletsDist = getDist(u);\n        var uid = u.id();\n        knownDist[uid] = smalletsDist;\n\n        if (smalletsDist === Infinity) {\n          continue;\n        }\n\n        var neighbors = u.neighborhood().intersect(nodes);\n\n        for (var _i2 = 0; _i2 < neighbors.length; _i2++) {\n          var v = neighbors[_i2];\n          var vid = v.id();\n          var vDist = distBetween(u, v);\n          var alt = smalletsDist + vDist.dist;\n\n          if (alt < getDist(v)) {\n            setDist(v, alt);\n            prev[vid] = {\n              node: u,\n              edge: vDist.edge\n            };\n          }\n        } // for\n\n      } // while\n\n\n      return {\n        distanceTo: function distanceTo(node) {\n          var target = string(node) ? nodes.filter(node)[0] : node[0];\n          return knownDist[target.id()];\n        },\n        pathTo: function pathTo(node) {\n          var target = string(node) ? nodes.filter(node)[0] : node[0];\n          var S = [];\n          var u = target;\n          var uid = u.id();\n\n          if (target.length > 0) {\n            S.unshift(target);\n\n            while (prev[uid]) {\n              var p = prev[uid];\n              S.unshift(p.edge);\n              S.unshift(p.node);\n              u = p.node;\n              uid = u.id();\n            }\n          }\n\n          return eles.spawn(S);\n        }\n      };\n    }\n  };\n\n  var elesfn$t = {\n    // kruskal's algorithm (finds min spanning tree, assuming undirected graph)\n    // implemented from pseudocode from wikipedia\n    kruskal: function kruskal(weightFn) {\n      weightFn = weightFn || function (edge) {\n        return 1;\n      };\n\n      var _this$byGroup = this.byGroup(),\n          nodes = _this$byGroup.nodes,\n          edges = _this$byGroup.edges;\n\n      var numNodes = nodes.length;\n      var forest = new Array(numNodes);\n      var A = nodes; // assumes byGroup() creates new collections that can be safely mutated\n\n      var findSetIndex = function findSetIndex(ele) {\n        for (var i = 0; i < forest.length; i++) {\n          var eles = forest[i];\n\n          if (eles.has(ele)) {\n            return i;\n          }\n        }\n      }; // start with one forest per node\n\n\n      for (var i = 0; i < numNodes; i++) {\n        forest[i] = this.spawn(nodes[i]);\n      }\n\n      var S = edges.sort(function (a, b) {\n        return weightFn(a) - weightFn(b);\n      });\n\n      for (var _i = 0; _i < S.length; _i++) {\n        var edge = S[_i];\n        var u = edge.source()[0];\n        var v = edge.target()[0];\n        var setUIndex = findSetIndex(u);\n        var setVIndex = findSetIndex(v);\n        var setU = forest[setUIndex];\n        var setV = forest[setVIndex];\n\n        if (setUIndex !== setVIndex) {\n          A.merge(edge); // combine forests for u and v\n\n          setU.merge(setV);\n          forest.splice(setVIndex, 1);\n        }\n      }\n\n      return A;\n    }\n  };\n\n  var aStarDefaults = defaults$g({\n    root: null,\n    goal: null,\n    weight: function weight(edge) {\n      return 1;\n    },\n    heuristic: function heuristic(edge) {\n      return 0;\n    },\n    directed: false\n  });\n  var elesfn$s = {\n    // Implemented from pseudocode from wikipedia\n    aStar: function aStar(options) {\n      var cy = this.cy();\n\n      var _aStarDefaults = aStarDefaults(options),\n          root = _aStarDefaults.root,\n          goal = _aStarDefaults.goal,\n          heuristic = _aStarDefaults.heuristic,\n          directed = _aStarDefaults.directed,\n          weight = _aStarDefaults.weight;\n\n      root = cy.collection(root)[0];\n      goal = cy.collection(goal)[0];\n      var sid = root.id();\n      var tid = goal.id();\n      var gScore = {};\n      var fScore = {};\n      var closedSetIds = {};\n      var openSet = new heap(function (a, b) {\n        return fScore[a.id()] - fScore[b.id()];\n      });\n      var openSetIds = new Set$1();\n      var cameFrom = {};\n      var cameFromEdge = {};\n\n      var addToOpenSet = function addToOpenSet(ele, id) {\n        openSet.push(ele);\n        openSetIds.add(id);\n      };\n\n      var cMin, cMinId;\n\n      var popFromOpenSet = function popFromOpenSet() {\n        cMin = openSet.pop();\n        cMinId = cMin.id();\n        openSetIds[\"delete\"](cMinId);\n      };\n\n      var isInOpenSet = function isInOpenSet(id) {\n        return openSetIds.has(id);\n      };\n\n      addToOpenSet(root, sid);\n      gScore[sid] = 0;\n      fScore[sid] = heuristic(root); // Counter\n\n      var steps = 0; // Main loop\n\n      while (openSet.size() > 0) {\n        popFromOpenSet();\n        steps++; // If we've found our goal, then we are done\n\n        if (cMinId === tid) {\n          var path = [];\n          var pathNode = goal;\n          var pathNodeId = tid;\n          var pathEdge = cameFromEdge[pathNodeId];\n\n          for (;;) {\n            path.unshift(pathNode);\n\n            if (pathEdge != null) {\n              path.unshift(pathEdge);\n            }\n\n            pathNode = cameFrom[pathNodeId];\n\n            if (pathNode == null) {\n              break;\n            }\n\n            pathNodeId = pathNode.id();\n            pathEdge = cameFromEdge[pathNodeId];\n          }\n\n          return {\n            found: true,\n            distance: gScore[cMinId],\n            path: this.spawn(path),\n            steps: steps\n          };\n        } // Add cMin to processed nodes\n\n\n        closedSetIds[cMinId] = true; // Update scores for neighbors of cMin\n        // Take into account if graph is directed or not\n\n        var vwEdges = cMin._private.edges;\n\n        for (var i = 0; i < vwEdges.length; i++) {\n          var e = vwEdges[i]; // edge must be in set of calling eles\n\n          if (!this.hasElementWithId(e.id())) {\n            continue;\n          } // cMin must be the source of edge if directed\n\n\n          if (directed && e.data('source') !== cMinId) {\n            continue;\n          }\n\n          var wSrc = e.source();\n          var wTgt = e.target();\n          var w = wSrc.id() !== cMinId ? wSrc : wTgt;\n          var wid = w.id(); // node must be in set of calling eles\n\n          if (!this.hasElementWithId(wid)) {\n            continue;\n          } // if node is in closedSet, ignore it\n\n\n          if (closedSetIds[wid]) {\n            continue;\n          } // New tentative score for node w\n\n\n          var tempScore = gScore[cMinId] + weight(e); // Update gScore for node w if:\n          //   w not present in openSet\n          // OR\n          //   tentative gScore is less than previous value\n          // w not in openSet\n\n          if (!isInOpenSet(wid)) {\n            gScore[wid] = tempScore;\n            fScore[wid] = tempScore + heuristic(w);\n            addToOpenSet(w, wid);\n            cameFrom[wid] = cMin;\n            cameFromEdge[wid] = e;\n            continue;\n          } // w already in openSet, but with greater gScore\n\n\n          if (tempScore < gScore[wid]) {\n            gScore[wid] = tempScore;\n            fScore[wid] = tempScore + heuristic(w);\n            cameFrom[wid] = cMin;\n            cameFromEdge[wid] = e;\n          }\n        } // End of neighbors update\n\n      } // End of main loop\n      // If we've reached here, then we've not reached our goal\n\n\n      return {\n        found: false,\n        distance: undefined,\n        path: undefined,\n        steps: steps\n      };\n    }\n  }; // elesfn\n\n  var floydWarshallDefaults = defaults$g({\n    weight: function weight(edge) {\n      return 1;\n    },\n    directed: false\n  });\n  var elesfn$r = {\n    // Implemented from pseudocode from wikipedia\n    floydWarshall: function floydWarshall(options) {\n      var cy = this.cy();\n\n      var _floydWarshallDefault = floydWarshallDefaults(options),\n          weight = _floydWarshallDefault.weight,\n          directed = _floydWarshallDefault.directed;\n\n      var weightFn = weight;\n\n      var _this$byGroup = this.byGroup(),\n          nodes = _this$byGroup.nodes,\n          edges = _this$byGroup.edges;\n\n      var N = nodes.length;\n      var Nsq = N * N;\n\n      var indexOf = function indexOf(node) {\n        return nodes.indexOf(node);\n      };\n\n      var atIndex = function atIndex(i) {\n        return nodes[i];\n      }; // Initialize distance matrix\n\n\n      var dist = new Array(Nsq);\n\n      for (var n = 0; n < Nsq; n++) {\n        var j = n % N;\n        var i = (n - j) / N;\n\n        if (i === j) {\n          dist[n] = 0;\n        } else {\n          dist[n] = Infinity;\n        }\n      } // Initialize matrix used for path reconstruction\n      // Initialize distance matrix\n\n\n      var next = new Array(Nsq);\n      var edgeNext = new Array(Nsq); // Process edges\n\n      for (var _i = 0; _i < edges.length; _i++) {\n        var edge = edges[_i];\n        var src = edge.source()[0];\n        var tgt = edge.target()[0];\n\n        if (src === tgt) {\n          continue;\n        } // exclude loops\n\n\n        var s = indexOf(src);\n        var t = indexOf(tgt);\n        var st = s * N + t; // source to target index\n\n        var _weight = weightFn(edge); // Check if already process another edge between same 2 nodes\n\n\n        if (dist[st] > _weight) {\n          dist[st] = _weight;\n          next[st] = t;\n          edgeNext[st] = edge;\n        } // If undirected graph, process 'reversed' edge\n\n\n        if (!directed) {\n          var ts = t * N + s; // target to source index\n\n          if (!directed && dist[ts] > _weight) {\n            dist[ts] = _weight;\n            next[ts] = s;\n            edgeNext[ts] = edge;\n          }\n        }\n      } // Main loop\n\n\n      for (var k = 0; k < N; k++) {\n        for (var _i2 = 0; _i2 < N; _i2++) {\n          var ik = _i2 * N + k;\n\n          for (var _j = 0; _j < N; _j++) {\n            var ij = _i2 * N + _j;\n            var kj = k * N + _j;\n\n            if (dist[ik] + dist[kj] < dist[ij]) {\n              dist[ij] = dist[ik] + dist[kj];\n              next[ij] = next[ik];\n            }\n          }\n        }\n      }\n\n      var getArgEle = function getArgEle(ele) {\n        return (string(ele) ? cy.filter(ele) : ele)[0];\n      };\n\n      var indexOfArgEle = function indexOfArgEle(ele) {\n        return indexOf(getArgEle(ele));\n      };\n\n      var res = {\n        distance: function distance(from, to) {\n          var i = indexOfArgEle(from);\n          var j = indexOfArgEle(to);\n          return dist[i * N + j];\n        },\n        path: function path(from, to) {\n          var i = indexOfArgEle(from);\n          var j = indexOfArgEle(to);\n          var fromNode = atIndex(i);\n\n          if (i === j) {\n            return fromNode.collection();\n          }\n\n          if (next[i * N + j] == null) {\n            return cy.collection();\n          }\n\n          var path = cy.collection();\n          var prev = i;\n          var edge;\n          path.merge(fromNode);\n\n          while (i !== j) {\n            prev = i;\n            i = next[i * N + j];\n            edge = edgeNext[prev * N + i];\n            path.merge(edge);\n            path.merge(atIndex(i));\n          }\n\n          return path;\n        }\n      };\n      return res;\n    } // floydWarshall\n\n  }; // elesfn\n\n  var bellmanFordDefaults = defaults$g({\n    weight: function weight(edge) {\n      return 1;\n    },\n    directed: false,\n    root: null\n  });\n  var elesfn$q = {\n    // Implemented from pseudocode from wikipedia\n    bellmanFord: function bellmanFord(options) {\n      var _this = this;\n\n      var _bellmanFordDefaults = bellmanFordDefaults(options),\n          weight = _bellmanFordDefaults.weight,\n          directed = _bellmanFordDefaults.directed,\n          root = _bellmanFordDefaults.root;\n\n      var weightFn = weight;\n      var eles = this;\n      var cy = this.cy();\n\n      var _this$byGroup = this.byGroup(),\n          edges = _this$byGroup.edges,\n          nodes = _this$byGroup.nodes;\n\n      var numNodes = nodes.length;\n      var infoMap = new Map$2();\n      var hasNegativeWeightCycle = false;\n      var negativeWeightCycles = [];\n      root = cy.collection(root)[0]; // in case selector passed\n\n      edges.unmergeBy(function (edge) {\n        return edge.isLoop();\n      });\n      var numEdges = edges.length;\n\n      var getInfo = function getInfo(node) {\n        var obj = infoMap.get(node.id());\n\n        if (!obj) {\n          obj = {};\n          infoMap.set(node.id(), obj);\n        }\n\n        return obj;\n      };\n\n      var getNodeFromTo = function getNodeFromTo(to) {\n        return (string(to) ? cy.$(to) : to)[0];\n      };\n\n      var distanceTo = function distanceTo(to) {\n        return getInfo(getNodeFromTo(to)).dist;\n      };\n\n      var pathTo = function pathTo(to) {\n        var thisStart = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : root;\n        var end = getNodeFromTo(to);\n        var path = [];\n        var node = end;\n\n        for (;;) {\n          if (node == null) {\n            return _this.spawn();\n          }\n\n          var _getInfo = getInfo(node),\n              edge = _getInfo.edge,\n              pred = _getInfo.pred;\n\n          path.unshift(node[0]);\n\n          if (node.same(thisStart) && path.length > 0) {\n            break;\n          }\n\n          if (edge != null) {\n            path.unshift(edge);\n          }\n\n          node = pred;\n        }\n\n        return eles.spawn(path);\n      }; // Initializations { dist, pred, edge }\n\n\n      for (var i = 0; i < numNodes; i++) {\n        var node = nodes[i];\n        var info = getInfo(node);\n\n        if (node.same(root)) {\n          info.dist = 0;\n        } else {\n          info.dist = Infinity;\n        }\n\n        info.pred = null;\n        info.edge = null;\n      } // Edges relaxation\n\n\n      var replacedEdge = false;\n\n      var checkForEdgeReplacement = function checkForEdgeReplacement(node1, node2, edge, info1, info2, weight) {\n        var dist = info1.dist + weight;\n\n        if (dist < info2.dist && !edge.same(info1.edge)) {\n          info2.dist = dist;\n          info2.pred = node1;\n          info2.edge = edge;\n          replacedEdge = true;\n        }\n      };\n\n      for (var _i = 1; _i < numNodes; _i++) {\n        replacedEdge = false;\n\n        for (var e = 0; e < numEdges; e++) {\n          var edge = edges[e];\n          var src = edge.source();\n          var tgt = edge.target();\n\n          var _weight = weightFn(edge);\n\n          var srcInfo = getInfo(src);\n          var tgtInfo = getInfo(tgt);\n          checkForEdgeReplacement(src, tgt, edge, srcInfo, tgtInfo, _weight); // If undirected graph, we need to take into account the 'reverse' edge\n\n          if (!directed) {\n            checkForEdgeReplacement(tgt, src, edge, tgtInfo, srcInfo, _weight);\n          }\n        }\n\n        if (!replacedEdge) {\n          break;\n        }\n      }\n\n      if (replacedEdge) {\n        // Check for negative weight cycles\n        var negativeWeightCycleIds = [];\n\n        for (var _e = 0; _e < numEdges; _e++) {\n          var _edge = edges[_e];\n\n          var _src = _edge.source();\n\n          var _tgt = _edge.target();\n\n          var _weight2 = weightFn(_edge);\n\n          var srcDist = getInfo(_src).dist;\n          var tgtDist = getInfo(_tgt).dist;\n\n          if (srcDist + _weight2 < tgtDist || !directed && tgtDist + _weight2 < srcDist) {\n            if (!hasNegativeWeightCycle) {\n              warn('Graph contains a negative weight cycle for Bellman-Ford');\n              hasNegativeWeightCycle = true;\n            }\n\n            if (options.findNegativeWeightCycles !== false) {\n              var negativeNodes = [];\n\n              if (srcDist + _weight2 < tgtDist) {\n                negativeNodes.push(_src);\n              }\n\n              if (!directed && tgtDist + _weight2 < srcDist) {\n                negativeNodes.push(_tgt);\n              }\n\n              var numNegativeNodes = negativeNodes.length;\n\n              for (var n = 0; n < numNegativeNodes; n++) {\n                var start = negativeNodes[n];\n                var cycle = [start];\n                cycle.push(getInfo(start).edge);\n                var _node = getInfo(start).pred;\n\n                while (cycle.indexOf(_node) === -1) {\n                  cycle.push(_node);\n                  cycle.push(getInfo(_node).edge);\n                  _node = getInfo(_node).pred;\n                }\n\n                cycle = cycle.slice(cycle.indexOf(_node));\n                var smallestId = cycle[0].id();\n                var smallestIndex = 0;\n\n                for (var c = 2; c < cycle.length; c += 2) {\n                  if (cycle[c].id() < smallestId) {\n                    smallestId = cycle[c].id();\n                    smallestIndex = c;\n                  }\n                }\n\n                cycle = cycle.slice(smallestIndex).concat(cycle.slice(0, smallestIndex));\n                cycle.push(cycle[0]);\n                var cycleId = cycle.map(function (el) {\n                  return el.id();\n                }).join(\",\");\n\n                if (negativeWeightCycleIds.indexOf(cycleId) === -1) {\n                  negativeWeightCycles.push(eles.spawn(cycle));\n                  negativeWeightCycleIds.push(cycleId);\n                }\n              }\n            } else {\n              break;\n            }\n          }\n        }\n      }\n\n      return {\n        distanceTo: distanceTo,\n        pathTo: pathTo,\n        hasNegativeWeightCycle: hasNegativeWeightCycle,\n        negativeWeightCycles: negativeWeightCycles\n      };\n    } // bellmanFord\n\n  }; // elesfn\n\n  var sqrt2 = Math.sqrt(2); // Function which colapses 2 (meta) nodes into one\n  // Updates the remaining edge lists\n  // Receives as a paramater the edge which causes the collapse\n\n  var collapse = function collapse(edgeIndex, nodeMap, remainingEdges) {\n    if (remainingEdges.length === 0) {\n      error(\"Karger-Stein must be run on a connected (sub)graph\");\n    }\n\n    var edgeInfo = remainingEdges[edgeIndex];\n    var sourceIn = edgeInfo[1];\n    var targetIn = edgeInfo[2];\n    var partition1 = nodeMap[sourceIn];\n    var partition2 = nodeMap[targetIn];\n    var newEdges = remainingEdges; // re-use array\n    // Delete all edges between partition1 and partition2\n\n    for (var i = newEdges.length - 1; i >= 0; i--) {\n      var edge = newEdges[i];\n      var src = edge[1];\n      var tgt = edge[2];\n\n      if (nodeMap[src] === partition1 && nodeMap[tgt] === partition2 || nodeMap[src] === partition2 && nodeMap[tgt] === partition1) {\n        newEdges.splice(i, 1);\n      }\n    } // All edges pointing to partition2 should now point to partition1\n\n\n    for (var _i = 0; _i < newEdges.length; _i++) {\n      var _edge = newEdges[_i];\n\n      if (_edge[1] === partition2) {\n        // Check source\n        newEdges[_i] = _edge.slice(); // copy\n\n        newEdges[_i][1] = partition1;\n      } else if (_edge[2] === partition2) {\n        // Check target\n        newEdges[_i] = _edge.slice(); // copy\n\n        newEdges[_i][2] = partition1;\n      }\n    } // Move all nodes from partition2 to partition1\n\n\n    for (var _i2 = 0; _i2 < nodeMap.length; _i2++) {\n      if (nodeMap[_i2] === partition2) {\n        nodeMap[_i2] = partition1;\n      }\n    }\n\n    return newEdges;\n  }; // Contracts a graph until we reach a certain number of meta nodes\n\n\n  var contractUntil = function contractUntil(metaNodeMap, remainingEdges, size, sizeLimit) {\n    while (size > sizeLimit) {\n      // Choose an edge randomly\n      var edgeIndex = Math.floor(Math.random() * remainingEdges.length); // Collapse graph based on edge\n\n      remainingEdges = collapse(edgeIndex, metaNodeMap, remainingEdges);\n      size--;\n    }\n\n    return remainingEdges;\n  };\n\n  var elesfn$p = {\n    // Computes the minimum cut of an undirected graph\n    // Returns the correct answer with high probability\n    kargerStein: function kargerStein() {\n      var _this = this;\n\n      var _this$byGroup = this.byGroup(),\n          nodes = _this$byGroup.nodes,\n          edges = _this$byGroup.edges;\n\n      edges.unmergeBy(function (edge) {\n        return edge.isLoop();\n      });\n      var numNodes = nodes.length;\n      var numEdges = edges.length;\n      var numIter = Math.ceil(Math.pow(Math.log(numNodes) / Math.LN2, 2));\n      var stopSize = Math.floor(numNodes / sqrt2);\n\n      if (numNodes < 2) {\n        error('At least 2 nodes are required for Karger-Stein algorithm');\n        return undefined;\n      } // Now store edge destination as indexes\n      // Format for each edge (edge index, source node index, target node index)\n\n\n      var edgeIndexes = [];\n\n      for (var i = 0; i < numEdges; i++) {\n        var e = edges[i];\n        edgeIndexes.push([i, nodes.indexOf(e.source()), nodes.indexOf(e.target())]);\n      } // We will store the best cut found here\n\n\n      var minCutSize = Infinity;\n      var minCutEdgeIndexes = [];\n      var minCutNodeMap = new Array(numNodes); // Initial meta node partition\n\n      var metaNodeMap = new Array(numNodes);\n      var metaNodeMap2 = new Array(numNodes);\n\n      var copyNodesMap = function copyNodesMap(from, to) {\n        for (var _i3 = 0; _i3 < numNodes; _i3++) {\n          to[_i3] = from[_i3];\n        }\n      }; // Main loop\n\n\n      for (var iter = 0; iter <= numIter; iter++) {\n        // Reset meta node partition\n        for (var _i4 = 0; _i4 < numNodes; _i4++) {\n          metaNodeMap[_i4] = _i4;\n        } // Contract until stop point (stopSize nodes)\n\n\n        var edgesState = contractUntil(metaNodeMap, edgeIndexes.slice(), numNodes, stopSize);\n        var edgesState2 = edgesState.slice(); // copy\n        // Create a copy of the colapsed nodes state\n\n        copyNodesMap(metaNodeMap, metaNodeMap2); // Run 2 iterations starting in the stop state\n\n        var res1 = contractUntil(metaNodeMap, edgesState, stopSize, 2);\n        var res2 = contractUntil(metaNodeMap2, edgesState2, stopSize, 2); // Is any of the 2 results the best cut so far?\n\n        if (res1.length <= res2.length && res1.length < minCutSize) {\n          minCutSize = res1.length;\n          minCutEdgeIndexes = res1;\n          copyNodesMap(metaNodeMap, minCutNodeMap);\n        } else if (res2.length <= res1.length && res2.length < minCutSize) {\n          minCutSize = res2.length;\n          minCutEdgeIndexes = res2;\n          copyNodesMap(metaNodeMap2, minCutNodeMap);\n        }\n      } // end of main loop\n      // Construct result\n\n\n      var cut = this.spawn(minCutEdgeIndexes.map(function (e) {\n        return edges[e[0]];\n      }));\n      var partition1 = this.spawn();\n      var partition2 = this.spawn(); // traverse metaNodeMap for best cut\n\n      var witnessNodePartition = minCutNodeMap[0];\n\n      for (var _i5 = 0; _i5 < minCutNodeMap.length; _i5++) {\n        var partitionId = minCutNodeMap[_i5];\n        var node = nodes[_i5];\n\n        if (partitionId === witnessNodePartition) {\n          partition1.merge(node);\n        } else {\n          partition2.merge(node);\n        }\n      } // construct components corresponding to each disjoint subset of nodes\n\n\n      var constructComponent = function constructComponent(subset) {\n        var component = _this.spawn();\n\n        subset.forEach(function (node) {\n          component.merge(node);\n          node.connectedEdges().forEach(function (edge) {\n            // ensure edge is within calling collection and edge is not in cut\n            if (_this.contains(edge) && !cut.contains(edge)) {\n              component.merge(edge);\n            }\n          });\n        });\n        return component;\n      };\n\n      var components = [constructComponent(partition1), constructComponent(partition2)];\n      var ret = {\n        cut: cut,\n        components: components,\n        // n.b. partitions are included to be compatible with the old api spec\n        // (could be removed in a future major version)\n        partition1: partition1,\n        partition2: partition2\n      };\n      return ret;\n    }\n  }; // elesfn\n\n  var copyPosition = function copyPosition(p) {\n    return {\n      x: p.x,\n      y: p.y\n    };\n  };\n  var modelToRenderedPosition = function modelToRenderedPosition(p, zoom, pan) {\n    return {\n      x: p.x * zoom + pan.x,\n      y: p.y * zoom + pan.y\n    };\n  };\n  var renderedToModelPosition = function renderedToModelPosition(p, zoom, pan) {\n    return {\n      x: (p.x - pan.x) / zoom,\n      y: (p.y - pan.y) / zoom\n    };\n  };\n  var array2point = function array2point(arr) {\n    return {\n      x: arr[0],\n      y: arr[1]\n    };\n  };\n  var min = function min(arr) {\n    var begin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : arr.length;\n    var min = Infinity;\n\n    for (var i = begin; i < end; i++) {\n      var val = arr[i];\n\n      if (isFinite(val)) {\n        min = Math.min(val, min);\n      }\n    }\n\n    return min;\n  };\n  var max = function max(arr) {\n    var begin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : arr.length;\n    var max = -Infinity;\n\n    for (var i = begin; i < end; i++) {\n      var val = arr[i];\n\n      if (isFinite(val)) {\n        max = Math.max(val, max);\n      }\n    }\n\n    return max;\n  };\n  var mean = function mean(arr) {\n    var begin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : arr.length;\n    var total = 0;\n    var n = 0;\n\n    for (var i = begin; i < end; i++) {\n      var val = arr[i];\n\n      if (isFinite(val)) {\n        total += val;\n        n++;\n      }\n    }\n\n    return total / n;\n  };\n  var median = function median(arr) {\n    var begin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : arr.length;\n    var copy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    var sort = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    var includeHoles = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n\n    if (copy) {\n      arr = arr.slice(begin, end);\n    } else {\n      if (end < arr.length) {\n        arr.splice(end, arr.length - end);\n      }\n\n      if (begin > 0) {\n        arr.splice(0, begin);\n      }\n    } // all non finite (e.g. Infinity, NaN) elements must be -Infinity so they go to the start\n\n\n    var off = 0; // offset from non-finite values\n\n    for (var i = arr.length - 1; i >= 0; i--) {\n      var v = arr[i];\n\n      if (includeHoles) {\n        if (!isFinite(v)) {\n          arr[i] = -Infinity;\n          off++;\n        }\n      } else {\n        // just remove it if we don't want to consider holes\n        arr.splice(i, 1);\n      }\n    }\n\n    if (sort) {\n      arr.sort(function (a, b) {\n        return a - b;\n      }); // requires copy = true if you don't want to change the orig\n    }\n\n    var len = arr.length;\n    var mid = Math.floor(len / 2);\n\n    if (len % 2 !== 0) {\n      return arr[mid + 1 + off];\n    } else {\n      return (arr[mid - 1 + off] + arr[mid + off]) / 2;\n    }\n  };\n  var deg2rad = function deg2rad(deg) {\n    return Math.PI * deg / 180;\n  };\n  var getAngleFromDisp = function getAngleFromDisp(dispX, dispY) {\n    return Math.atan2(dispY, dispX) - Math.PI / 2;\n  };\n  var log2 = Math.log2 || function (n) {\n    return Math.log(n) / Math.log(2);\n  };\n  var signum = function signum(x) {\n    if (x > 0) {\n      return 1;\n    } else if (x < 0) {\n      return -1;\n    } else {\n      return 0;\n    }\n  };\n  var dist = function dist(p1, p2) {\n    return Math.sqrt(sqdist(p1, p2));\n  };\n  var sqdist = function sqdist(p1, p2) {\n    var dx = p2.x - p1.x;\n    var dy = p2.y - p1.y;\n    return dx * dx + dy * dy;\n  };\n  var inPlaceSumNormalize = function inPlaceSumNormalize(v) {\n    var length = v.length; // First, get sum of all elements\n\n    var total = 0;\n\n    for (var i = 0; i < length; i++) {\n      total += v[i];\n    } // Now, divide each by the sum of all elements\n\n\n    for (var _i = 0; _i < length; _i++) {\n      v[_i] = v[_i] / total;\n    }\n\n    return v;\n  };\n\n  var qbezierAt = function qbezierAt(p0, p1, p2, t) {\n    return (1 - t) * (1 - t) * p0 + 2 * (1 - t) * t * p1 + t * t * p2;\n  };\n  var qbezierPtAt = function qbezierPtAt(p0, p1, p2, t) {\n    return {\n      x: qbezierAt(p0.x, p1.x, p2.x, t),\n      y: qbezierAt(p0.y, p1.y, p2.y, t)\n    };\n  };\n  var lineAt = function lineAt(p0, p1, t, d) {\n    var vec = {\n      x: p1.x - p0.x,\n      y: p1.y - p0.y\n    };\n    var vecDist = dist(p0, p1);\n    var normVec = {\n      x: vec.x / vecDist,\n      y: vec.y / vecDist\n    };\n    t = t == null ? 0 : t;\n    d = d != null ? d : t * vecDist;\n    return {\n      x: p0.x + normVec.x * d,\n      y: p0.y + normVec.y * d\n    };\n  };\n  var bound = function bound(min, val, max) {\n    return Math.max(min, Math.min(max, val));\n  }; // makes a full bb (x1, y1, x2, y2, w, h) from implicit params\n\n  var makeBoundingBox = function makeBoundingBox(bb) {\n    if (bb == null) {\n      return {\n        x1: Infinity,\n        y1: Infinity,\n        x2: -Infinity,\n        y2: -Infinity,\n        w: 0,\n        h: 0\n      };\n    } else if (bb.x1 != null && bb.y1 != null) {\n      if (bb.x2 != null && bb.y2 != null && bb.x2 >= bb.x1 && bb.y2 >= bb.y1) {\n        return {\n          x1: bb.x1,\n          y1: bb.y1,\n          x2: bb.x2,\n          y2: bb.y2,\n          w: bb.x2 - bb.x1,\n          h: bb.y2 - bb.y1\n        };\n      } else if (bb.w != null && bb.h != null && bb.w >= 0 && bb.h >= 0) {\n        return {\n          x1: bb.x1,\n          y1: bb.y1,\n          x2: bb.x1 + bb.w,\n          y2: bb.y1 + bb.h,\n          w: bb.w,\n          h: bb.h\n        };\n      }\n    }\n  };\n  var copyBoundingBox = function copyBoundingBox(bb) {\n    return {\n      x1: bb.x1,\n      x2: bb.x2,\n      w: bb.w,\n      y1: bb.y1,\n      y2: bb.y2,\n      h: bb.h\n    };\n  };\n  var clearBoundingBox = function clearBoundingBox(bb) {\n    bb.x1 = Infinity;\n    bb.y1 = Infinity;\n    bb.x2 = -Infinity;\n    bb.y2 = -Infinity;\n    bb.w = 0;\n    bb.h = 0;\n  };\n  var updateBoundingBox = function updateBoundingBox(bb1, bb2) {\n    // update bb1 with bb2 bounds\n    bb1.x1 = Math.min(bb1.x1, bb2.x1);\n    bb1.x2 = Math.max(bb1.x2, bb2.x2);\n    bb1.w = bb1.x2 - bb1.x1;\n    bb1.y1 = Math.min(bb1.y1, bb2.y1);\n    bb1.y2 = Math.max(bb1.y2, bb2.y2);\n    bb1.h = bb1.y2 - bb1.y1;\n  };\n  var expandBoundingBoxByPoint = function expandBoundingBoxByPoint(bb, x, y) {\n    bb.x1 = Math.min(bb.x1, x);\n    bb.x2 = Math.max(bb.x2, x);\n    bb.w = bb.x2 - bb.x1;\n    bb.y1 = Math.min(bb.y1, y);\n    bb.y2 = Math.max(bb.y2, y);\n    bb.h = bb.y2 - bb.y1;\n  };\n  var expandBoundingBox = function expandBoundingBox(bb) {\n    var padding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    bb.x1 -= padding;\n    bb.x2 += padding;\n    bb.y1 -= padding;\n    bb.y2 += padding;\n    bb.w = bb.x2 - bb.x1;\n    bb.h = bb.y2 - bb.y1;\n    return bb;\n  };\n  var expandBoundingBoxSides = function expandBoundingBoxSides(bb) {\n    var padding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0];\n    var top, right, bottom, left;\n\n    if (padding.length === 1) {\n      top = right = bottom = left = padding[0];\n    } else if (padding.length === 2) {\n      top = bottom = padding[0];\n      left = right = padding[1];\n    } else if (padding.length === 4) {\n      var _padding = _slicedToArray(padding, 4);\n\n      top = _padding[0];\n      right = _padding[1];\n      bottom = _padding[2];\n      left = _padding[3];\n    }\n\n    bb.x1 -= left;\n    bb.x2 += right;\n    bb.y1 -= top;\n    bb.y2 += bottom;\n    bb.w = bb.x2 - bb.x1;\n    bb.h = bb.y2 - bb.y1;\n    return bb;\n  };\n\n  var assignBoundingBox = function assignBoundingBox(bb1, bb2) {\n    bb1.x1 = bb2.x1;\n    bb1.y1 = bb2.y1;\n    bb1.x2 = bb2.x2;\n    bb1.y2 = bb2.y2;\n    bb1.w = bb1.x2 - bb1.x1;\n    bb1.h = bb1.y2 - bb1.y1;\n  };\n  var boundingBoxesIntersect = function boundingBoxesIntersect(bb1, bb2) {\n    // case: one bb to right of other\n    if (bb1.x1 > bb2.x2) {\n      return false;\n    }\n\n    if (bb2.x1 > bb1.x2) {\n      return false;\n    } // case: one bb to left of other\n\n\n    if (bb1.x2 < bb2.x1) {\n      return false;\n    }\n\n    if (bb2.x2 < bb1.x1) {\n      return false;\n    } // case: one bb above other\n\n\n    if (bb1.y2 < bb2.y1) {\n      return false;\n    }\n\n    if (bb2.y2 < bb1.y1) {\n      return false;\n    } // case: one bb below other\n\n\n    if (bb1.y1 > bb2.y2) {\n      return false;\n    }\n\n    if (bb2.y1 > bb1.y2) {\n      return false;\n    } // otherwise, must have some overlap\n\n\n    return true;\n  };\n  var inBoundingBox = function inBoundingBox(bb, x, y) {\n    return bb.x1 <= x && x <= bb.x2 && bb.y1 <= y && y <= bb.y2;\n  };\n  var pointInBoundingBox = function pointInBoundingBox(bb, pt) {\n    return inBoundingBox(bb, pt.x, pt.y);\n  };\n  var boundingBoxInBoundingBox = function boundingBoxInBoundingBox(bb1, bb2) {\n    return inBoundingBox(bb1, bb2.x1, bb2.y1) && inBoundingBox(bb1, bb2.x2, bb2.y2);\n  };\n  var roundRectangleIntersectLine = function roundRectangleIntersectLine(x, y, nodeX, nodeY, width, height, padding) {\n    var cornerRadius = getRoundRectangleRadius(width, height);\n    var halfWidth = width / 2;\n    var halfHeight = height / 2; // Check intersections with straight line segments\n\n    var straightLineIntersections; // Top segment, left to right\n\n    {\n      var topStartX = nodeX - halfWidth + cornerRadius - padding;\n      var topStartY = nodeY - halfHeight - padding;\n      var topEndX = nodeX + halfWidth - cornerRadius + padding;\n      var topEndY = topStartY;\n      straightLineIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, topStartX, topStartY, topEndX, topEndY, false);\n\n      if (straightLineIntersections.length > 0) {\n        return straightLineIntersections;\n      }\n    } // Right segment, top to bottom\n\n    {\n      var rightStartX = nodeX + halfWidth + padding;\n      var rightStartY = nodeY - halfHeight + cornerRadius - padding;\n      var rightEndX = rightStartX;\n      var rightEndY = nodeY + halfHeight - cornerRadius + padding;\n      straightLineIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, rightStartX, rightStartY, rightEndX, rightEndY, false);\n\n      if (straightLineIntersections.length > 0) {\n        return straightLineIntersections;\n      }\n    } // Bottom segment, left to right\n\n    {\n      var bottomStartX = nodeX - halfWidth + cornerRadius - padding;\n      var bottomStartY = nodeY + halfHeight + padding;\n      var bottomEndX = nodeX + halfWidth - cornerRadius + padding;\n      var bottomEndY = bottomStartY;\n      straightLineIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, bottomStartX, bottomStartY, bottomEndX, bottomEndY, false);\n\n      if (straightLineIntersections.length > 0) {\n        return straightLineIntersections;\n      }\n    } // Left segment, top to bottom\n\n    {\n      var leftStartX = nodeX - halfWidth - padding;\n      var leftStartY = nodeY - halfHeight + cornerRadius - padding;\n      var leftEndX = leftStartX;\n      var leftEndY = nodeY + halfHeight - cornerRadius + padding;\n      straightLineIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, leftStartX, leftStartY, leftEndX, leftEndY, false);\n\n      if (straightLineIntersections.length > 0) {\n        return straightLineIntersections;\n      }\n    } // Check intersections with arc segments\n\n    var arcIntersections; // Top Left\n\n    {\n      var topLeftCenterX = nodeX - halfWidth + cornerRadius;\n      var topLeftCenterY = nodeY - halfHeight + cornerRadius;\n      arcIntersections = intersectLineCircle(x, y, nodeX, nodeY, topLeftCenterX, topLeftCenterY, cornerRadius + padding); // Ensure the intersection is on the desired quarter of the circle\n\n      if (arcIntersections.length > 0 && arcIntersections[0] <= topLeftCenterX && arcIntersections[1] <= topLeftCenterY) {\n        return [arcIntersections[0], arcIntersections[1]];\n      }\n    } // Top Right\n\n    {\n      var topRightCenterX = nodeX + halfWidth - cornerRadius;\n      var topRightCenterY = nodeY - halfHeight + cornerRadius;\n      arcIntersections = intersectLineCircle(x, y, nodeX, nodeY, topRightCenterX, topRightCenterY, cornerRadius + padding); // Ensure the intersection is on the desired quarter of the circle\n\n      if (arcIntersections.length > 0 && arcIntersections[0] >= topRightCenterX && arcIntersections[1] <= topRightCenterY) {\n        return [arcIntersections[0], arcIntersections[1]];\n      }\n    } // Bottom Right\n\n    {\n      var bottomRightCenterX = nodeX + halfWidth - cornerRadius;\n      var bottomRightCenterY = nodeY + halfHeight - cornerRadius;\n      arcIntersections = intersectLineCircle(x, y, nodeX, nodeY, bottomRightCenterX, bottomRightCenterY, cornerRadius + padding); // Ensure the intersection is on the desired quarter of the circle\n\n      if (arcIntersections.length > 0 && arcIntersections[0] >= bottomRightCenterX && arcIntersections[1] >= bottomRightCenterY) {\n        return [arcIntersections[0], arcIntersections[1]];\n      }\n    } // Bottom Left\n\n    {\n      var bottomLeftCenterX = nodeX - halfWidth + cornerRadius;\n      var bottomLeftCenterY = nodeY + halfHeight - cornerRadius;\n      arcIntersections = intersectLineCircle(x, y, nodeX, nodeY, bottomLeftCenterX, bottomLeftCenterY, cornerRadius + padding); // Ensure the intersection is on the desired quarter of the circle\n\n      if (arcIntersections.length > 0 && arcIntersections[0] <= bottomLeftCenterX && arcIntersections[1] >= bottomLeftCenterY) {\n        return [arcIntersections[0], arcIntersections[1]];\n      }\n    }\n    return []; // if nothing\n  };\n  var inLineVicinity = function inLineVicinity(x, y, lx1, ly1, lx2, ly2, tolerance) {\n    var t = tolerance;\n    var x1 = Math.min(lx1, lx2);\n    var x2 = Math.max(lx1, lx2);\n    var y1 = Math.min(ly1, ly2);\n    var y2 = Math.max(ly1, ly2);\n    return x1 - t <= x && x <= x2 + t && y1 - t <= y && y <= y2 + t;\n  };\n  var inBezierVicinity = function inBezierVicinity(x, y, x1, y1, x2, y2, x3, y3, tolerance) {\n    var bb = {\n      x1: Math.min(x1, x3, x2) - tolerance,\n      x2: Math.max(x1, x3, x2) + tolerance,\n      y1: Math.min(y1, y3, y2) - tolerance,\n      y2: Math.max(y1, y3, y2) + tolerance\n    }; // if outside the rough bounding box for the bezier, then it can't be a hit\n\n    if (x < bb.x1 || x > bb.x2 || y < bb.y1 || y > bb.y2) {\n      // console.log('bezier out of rough bb')\n      return false;\n    } else {\n      // console.log('do more expensive check');\n      return true;\n    }\n  };\n  var solveQuadratic = function solveQuadratic(a, b, c, val) {\n    c -= val;\n    var r = b * b - 4 * a * c;\n\n    if (r < 0) {\n      return [];\n    }\n\n    var sqrtR = Math.sqrt(r);\n    var denom = 2 * a;\n    var root1 = (-b + sqrtR) / denom;\n    var root2 = (-b - sqrtR) / denom;\n    return [root1, root2];\n  };\n  var solveCubic = function solveCubic(a, b, c, d, result) {\n    // Solves a cubic function, returns root in form [r1, i1, r2, i2, r3, i3], where\n    // r is the real component, i is the imaginary component\n    // An implementation of the Cardano method from the year 1545\n    // http://en.wikipedia.org/wiki/Cubic_function#The_nature_of_the_roots\n    var epsilon = 0.00001; // avoid division by zero while keeping the overall expression close in value\n\n    if (a === 0) {\n      a = epsilon;\n    }\n\n    b /= a;\n    c /= a;\n    d /= a;\n    var discriminant, q, r, dum1, s, t, term1, r13;\n    q = (3.0 * c - b * b) / 9.0;\n    r = -(27.0 * d) + b * (9.0 * c - 2.0 * (b * b));\n    r /= 54.0;\n    discriminant = q * q * q + r * r;\n    result[1] = 0;\n    term1 = b / 3.0;\n\n    if (discriminant > 0) {\n      s = r + Math.sqrt(discriminant);\n      s = s < 0 ? -Math.pow(-s, 1.0 / 3.0) : Math.pow(s, 1.0 / 3.0);\n      t = r - Math.sqrt(discriminant);\n      t = t < 0 ? -Math.pow(-t, 1.0 / 3.0) : Math.pow(t, 1.0 / 3.0);\n      result[0] = -term1 + s + t;\n      term1 += (s + t) / 2.0;\n      result[4] = result[2] = -term1;\n      term1 = Math.sqrt(3.0) * (-t + s) / 2;\n      result[3] = term1;\n      result[5] = -term1;\n      return;\n    }\n\n    result[5] = result[3] = 0;\n\n    if (discriminant === 0) {\n      r13 = r < 0 ? -Math.pow(-r, 1.0 / 3.0) : Math.pow(r, 1.0 / 3.0);\n      result[0] = -term1 + 2.0 * r13;\n      result[4] = result[2] = -(r13 + term1);\n      return;\n    }\n\n    q = -q;\n    dum1 = q * q * q;\n    dum1 = Math.acos(r / Math.sqrt(dum1));\n    r13 = 2.0 * Math.sqrt(q);\n    result[0] = -term1 + r13 * Math.cos(dum1 / 3.0);\n    result[2] = -term1 + r13 * Math.cos((dum1 + 2.0 * Math.PI) / 3.0);\n    result[4] = -term1 + r13 * Math.cos((dum1 + 4.0 * Math.PI) / 3.0);\n    return;\n  };\n  var sqdistToQuadraticBezier = function sqdistToQuadraticBezier(x, y, x1, y1, x2, y2, x3, y3) {\n    // Find minimum distance by using the minimum of the distance\n    // function between the given point and the curve\n    // This gives the coefficients of the resulting cubic equation\n    // whose roots tell us where a possible minimum is\n    // (Coefficients are divided by 4)\n    var a = 1.0 * x1 * x1 - 4 * x1 * x2 + 2 * x1 * x3 + 4 * x2 * x2 - 4 * x2 * x3 + x3 * x3 + y1 * y1 - 4 * y1 * y2 + 2 * y1 * y3 + 4 * y2 * y2 - 4 * y2 * y3 + y3 * y3;\n    var b = 1.0 * 9 * x1 * x2 - 3 * x1 * x1 - 3 * x1 * x3 - 6 * x2 * x2 + 3 * x2 * x3 + 9 * y1 * y2 - 3 * y1 * y1 - 3 * y1 * y3 - 6 * y2 * y2 + 3 * y2 * y3;\n    var c = 1.0 * 3 * x1 * x1 - 6 * x1 * x2 + x1 * x3 - x1 * x + 2 * x2 * x2 + 2 * x2 * x - x3 * x + 3 * y1 * y1 - 6 * y1 * y2 + y1 * y3 - y1 * y + 2 * y2 * y2 + 2 * y2 * y - y3 * y;\n    var d = 1.0 * x1 * x2 - x1 * x1 + x1 * x - x2 * x + y1 * y2 - y1 * y1 + y1 * y - y2 * y; // debug(\"coefficients: \" + a / a + \", \" + b / a + \", \" + c / a + \", \" + d / a);\n\n    var roots = []; // Use the cubic solving algorithm\n\n    solveCubic(a, b, c, d, roots);\n    var zeroThreshold = 0.0000001;\n    var params = [];\n\n    for (var index = 0; index < 6; index += 2) {\n      if (Math.abs(roots[index + 1]) < zeroThreshold && roots[index] >= 0 && roots[index] <= 1.0) {\n        params.push(roots[index]);\n      }\n    }\n\n    params.push(1.0);\n    params.push(0.0);\n    var minDistanceSquared = -1;\n    var curX, curY, distSquared;\n\n    for (var i = 0; i < params.length; i++) {\n      curX = Math.pow(1.0 - params[i], 2.0) * x1 + 2.0 * (1 - params[i]) * params[i] * x2 + params[i] * params[i] * x3;\n      curY = Math.pow(1 - params[i], 2.0) * y1 + 2 * (1.0 - params[i]) * params[i] * y2 + params[i] * params[i] * y3;\n      distSquared = Math.pow(curX - x, 2) + Math.pow(curY - y, 2); // debug('distance for param ' + params[i] + \": \" + Math.sqrt(distSquared));\n\n      if (minDistanceSquared >= 0) {\n        if (distSquared < minDistanceSquared) {\n          minDistanceSquared = distSquared;\n        }\n      } else {\n        minDistanceSquared = distSquared;\n      }\n    }\n\n    return minDistanceSquared;\n  };\n  var sqdistToFiniteLine = function sqdistToFiniteLine(x, y, x1, y1, x2, y2) {\n    var offset = [x - x1, y - y1];\n    var line = [x2 - x1, y2 - y1];\n    var lineSq = line[0] * line[0] + line[1] * line[1];\n    var hypSq = offset[0] * offset[0] + offset[1] * offset[1];\n    var dotProduct = offset[0] * line[0] + offset[1] * line[1];\n    var adjSq = dotProduct * dotProduct / lineSq;\n\n    if (dotProduct < 0) {\n      return hypSq;\n    }\n\n    if (adjSq > lineSq) {\n      return (x - x2) * (x - x2) + (y - y2) * (y - y2);\n    }\n\n    return hypSq - adjSq;\n  };\n  var pointInsidePolygonPoints = function pointInsidePolygonPoints(x, y, points) {\n    var x1, y1, x2, y2;\n    var y3; // Intersect with vertical line through (x, y)\n\n    var up = 0; // let down = 0;\n\n    for (var i = 0; i < points.length / 2; i++) {\n      x1 = points[i * 2];\n      y1 = points[i * 2 + 1];\n\n      if (i + 1 < points.length / 2) {\n        x2 = points[(i + 1) * 2];\n        y2 = points[(i + 1) * 2 + 1];\n      } else {\n        x2 = points[(i + 1 - points.length / 2) * 2];\n        y2 = points[(i + 1 - points.length / 2) * 2 + 1];\n      }\n\n      if (x1 == x && x2 == x) ; else if (x1 >= x && x >= x2 || x1 <= x && x <= x2) {\n        y3 = (x - x1) / (x2 - x1) * (y2 - y1) + y1;\n\n        if (y3 > y) {\n          up++;\n        } // if( y3 < y ){\n        // down++;\n        // }\n\n      } else {\n        continue;\n      }\n    }\n\n    if (up % 2 === 0) {\n      return false;\n    } else {\n      return true;\n    }\n  };\n  var pointInsidePolygon = function pointInsidePolygon(x, y, basePoints, centerX, centerY, width, height, direction, padding) {\n    var transformedPoints = new Array(basePoints.length); // Gives negative angle\n\n    var angle;\n\n    if (direction[0] != null) {\n      angle = Math.atan(direction[1] / direction[0]);\n\n      if (direction[0] < 0) {\n        angle = angle + Math.PI / 2;\n      } else {\n        angle = -angle - Math.PI / 2;\n      }\n    } else {\n      angle = direction;\n    }\n\n    var cos = Math.cos(-angle);\n    var sin = Math.sin(-angle); //    console.log(\"base: \" + basePoints);\n\n    for (var i = 0; i < transformedPoints.length / 2; i++) {\n      transformedPoints[i * 2] = width / 2 * (basePoints[i * 2] * cos - basePoints[i * 2 + 1] * sin);\n      transformedPoints[i * 2 + 1] = height / 2 * (basePoints[i * 2 + 1] * cos + basePoints[i * 2] * sin);\n      transformedPoints[i * 2] += centerX;\n      transformedPoints[i * 2 + 1] += centerY;\n    }\n\n    var points;\n\n    if (padding > 0) {\n      var expandedLineSet = expandPolygon(transformedPoints, -padding);\n      points = joinLines(expandedLineSet);\n    } else {\n      points = transformedPoints;\n    }\n\n    return pointInsidePolygonPoints(x, y, points);\n  };\n  var pointInsideRoundPolygon = function pointInsideRoundPolygon(x, y, basePoints, centerX, centerY, width, height) {\n    var cutPolygonPoints = new Array(basePoints.length);\n    var halfW = width / 2;\n    var halfH = height / 2;\n    var cornerRadius = getRoundPolygonRadius(width, height);\n    var squaredCornerRadius = cornerRadius * cornerRadius;\n\n    for (var i = 0; i < basePoints.length / 4; i++) {\n      var sourceUv = void 0,\n          destUv = void 0;\n\n      if (i === 0) {\n        sourceUv = basePoints.length - 2;\n      } else {\n        sourceUv = i * 4 - 2;\n      }\n\n      destUv = i * 4 + 2;\n      var px = centerX + halfW * basePoints[i * 4];\n      var py = centerY + halfH * basePoints[i * 4 + 1];\n      var cosTheta = -basePoints[sourceUv] * basePoints[destUv] - basePoints[sourceUv + 1] * basePoints[destUv + 1];\n      var offset = cornerRadius / Math.tan(Math.acos(cosTheta) / 2);\n      var cp0x = px - offset * basePoints[sourceUv];\n      var cp0y = py - offset * basePoints[sourceUv + 1];\n      var cp1x = px + offset * basePoints[destUv];\n      var cp1y = py + offset * basePoints[destUv + 1];\n      cutPolygonPoints[i * 4] = cp0x;\n      cutPolygonPoints[i * 4 + 1] = cp0y;\n      cutPolygonPoints[i * 4 + 2] = cp1x;\n      cutPolygonPoints[i * 4 + 3] = cp1y;\n      var orthx = basePoints[sourceUv + 1];\n      var orthy = -basePoints[sourceUv];\n      var cosAlpha = orthx * basePoints[destUv] + orthy * basePoints[destUv + 1];\n\n      if (cosAlpha < 0) {\n        orthx *= -1;\n        orthy *= -1;\n      }\n\n      var cx = cp0x + orthx * cornerRadius;\n      var cy = cp0y + orthy * cornerRadius;\n      var squaredDistance = Math.pow(cx - x, 2) + Math.pow(cy - y, 2);\n\n      if (squaredDistance <= squaredCornerRadius) {\n        return true;\n      }\n    }\n\n    return pointInsidePolygonPoints(x, y, cutPolygonPoints);\n  };\n  var joinLines = function joinLines(lineSet) {\n    var vertices = new Array(lineSet.length / 2);\n    var currentLineStartX, currentLineStartY, currentLineEndX, currentLineEndY;\n    var nextLineStartX, nextLineStartY, nextLineEndX, nextLineEndY;\n\n    for (var i = 0; i < lineSet.length / 4; i++) {\n      currentLineStartX = lineSet[i * 4];\n      currentLineStartY = lineSet[i * 4 + 1];\n      currentLineEndX = lineSet[i * 4 + 2];\n      currentLineEndY = lineSet[i * 4 + 3];\n\n      if (i < lineSet.length / 4 - 1) {\n        nextLineStartX = lineSet[(i + 1) * 4];\n        nextLineStartY = lineSet[(i + 1) * 4 + 1];\n        nextLineEndX = lineSet[(i + 1) * 4 + 2];\n        nextLineEndY = lineSet[(i + 1) * 4 + 3];\n      } else {\n        nextLineStartX = lineSet[0];\n        nextLineStartY = lineSet[1];\n        nextLineEndX = lineSet[2];\n        nextLineEndY = lineSet[3];\n      }\n\n      var intersection = finiteLinesIntersect(currentLineStartX, currentLineStartY, currentLineEndX, currentLineEndY, nextLineStartX, nextLineStartY, nextLineEndX, nextLineEndY, true);\n      vertices[i * 2] = intersection[0];\n      vertices[i * 2 + 1] = intersection[1];\n    }\n\n    return vertices;\n  };\n  var expandPolygon = function expandPolygon(points, pad) {\n    var expandedLineSet = new Array(points.length * 2);\n    var currentPointX, currentPointY, nextPointX, nextPointY;\n\n    for (var i = 0; i < points.length / 2; i++) {\n      currentPointX = points[i * 2];\n      currentPointY = points[i * 2 + 1];\n\n      if (i < points.length / 2 - 1) {\n        nextPointX = points[(i + 1) * 2];\n        nextPointY = points[(i + 1) * 2 + 1];\n      } else {\n        nextPointX = points[0];\n        nextPointY = points[1];\n      } // Current line: [currentPointX, currentPointY] to [nextPointX, nextPointY]\n      // Assume CCW polygon winding\n\n\n      var offsetX = nextPointY - currentPointY;\n      var offsetY = -(nextPointX - currentPointX); // Normalize\n\n      var offsetLength = Math.sqrt(offsetX * offsetX + offsetY * offsetY);\n      var normalizedOffsetX = offsetX / offsetLength;\n      var normalizedOffsetY = offsetY / offsetLength;\n      expandedLineSet[i * 4] = currentPointX + normalizedOffsetX * pad;\n      expandedLineSet[i * 4 + 1] = currentPointY + normalizedOffsetY * pad;\n      expandedLineSet[i * 4 + 2] = nextPointX + normalizedOffsetX * pad;\n      expandedLineSet[i * 4 + 3] = nextPointY + normalizedOffsetY * pad;\n    }\n\n    return expandedLineSet;\n  };\n  var intersectLineEllipse = function intersectLineEllipse(x, y, centerX, centerY, ellipseWradius, ellipseHradius) {\n    var dispX = centerX - x;\n    var dispY = centerY - y;\n    dispX /= ellipseWradius;\n    dispY /= ellipseHradius;\n    var len = Math.sqrt(dispX * dispX + dispY * dispY);\n    var newLength = len - 1;\n\n    if (newLength < 0) {\n      return [];\n    }\n\n    var lenProportion = newLength / len;\n    return [(centerX - x) * lenProportion + x, (centerY - y) * lenProportion + y];\n  };\n  var checkInEllipse = function checkInEllipse(x, y, width, height, centerX, centerY, padding) {\n    x -= centerX;\n    y -= centerY;\n    x /= width / 2 + padding;\n    y /= height / 2 + padding;\n    return x * x + y * y <= 1;\n  }; // Returns intersections of increasing distance from line's start point\n\n  var intersectLineCircle = function intersectLineCircle(x1, y1, x2, y2, centerX, centerY, radius) {\n    // Calculate d, direction vector of line\n    var d = [x2 - x1, y2 - y1]; // Direction vector of line\n\n    var f = [x1 - centerX, y1 - centerY];\n    var a = d[0] * d[0] + d[1] * d[1];\n    var b = 2 * (f[0] * d[0] + f[1] * d[1]);\n    var c = f[0] * f[0] + f[1] * f[1] - radius * radius;\n    var discriminant = b * b - 4 * a * c;\n\n    if (discriminant < 0) {\n      return [];\n    }\n\n    var t1 = (-b + Math.sqrt(discriminant)) / (2 * a);\n    var t2 = (-b - Math.sqrt(discriminant)) / (2 * a);\n    var tMin = Math.min(t1, t2);\n    var tMax = Math.max(t1, t2);\n    var inRangeParams = [];\n\n    if (tMin >= 0 && tMin <= 1) {\n      inRangeParams.push(tMin);\n    }\n\n    if (tMax >= 0 && tMax <= 1) {\n      inRangeParams.push(tMax);\n    }\n\n    if (inRangeParams.length === 0) {\n      return [];\n    }\n\n    var nearIntersectionX = inRangeParams[0] * d[0] + x1;\n    var nearIntersectionY = inRangeParams[0] * d[1] + y1;\n\n    if (inRangeParams.length > 1) {\n      if (inRangeParams[0] == inRangeParams[1]) {\n        return [nearIntersectionX, nearIntersectionY];\n      } else {\n        var farIntersectionX = inRangeParams[1] * d[0] + x1;\n        var farIntersectionY = inRangeParams[1] * d[1] + y1;\n        return [nearIntersectionX, nearIntersectionY, farIntersectionX, farIntersectionY];\n      }\n    } else {\n      return [nearIntersectionX, nearIntersectionY];\n    }\n  };\n  var midOfThree = function midOfThree(a, b, c) {\n    if (b <= a && a <= c || c <= a && a <= b) {\n      return a;\n    } else if (a <= b && b <= c || c <= b && b <= a) {\n      return b;\n    } else {\n      return c;\n    }\n  }; // (x1,y1)=>(x2,y2) intersect with (x3,y3)=>(x4,y4)\n\n  var finiteLinesIntersect = function finiteLinesIntersect(x1, y1, x2, y2, x3, y3, x4, y4, infiniteLines) {\n    var dx13 = x1 - x3;\n    var dx21 = x2 - x1;\n    var dx43 = x4 - x3;\n    var dy13 = y1 - y3;\n    var dy21 = y2 - y1;\n    var dy43 = y4 - y3;\n    var ua_t = dx43 * dy13 - dy43 * dx13;\n    var ub_t = dx21 * dy13 - dy21 * dx13;\n    var u_b = dy43 * dx21 - dx43 * dy21;\n\n    if (u_b !== 0) {\n      var ua = ua_t / u_b;\n      var ub = ub_t / u_b;\n      var flptThreshold = 0.001;\n\n      var _min = 0 - flptThreshold;\n\n      var _max = 1 + flptThreshold;\n\n      if (_min <= ua && ua <= _max && _min <= ub && ub <= _max) {\n        return [x1 + ua * dx21, y1 + ua * dy21];\n      } else {\n        if (!infiniteLines) {\n          return [];\n        } else {\n          return [x1 + ua * dx21, y1 + ua * dy21];\n        }\n      }\n    } else {\n      if (ua_t === 0 || ub_t === 0) {\n        // Parallel, coincident lines. Check if overlap\n        // Check endpoint of second line\n        if (midOfThree(x1, x2, x4) === x4) {\n          return [x4, y4];\n        } // Check start point of second line\n\n\n        if (midOfThree(x1, x2, x3) === x3) {\n          return [x3, y3];\n        } // Endpoint of first line\n\n\n        if (midOfThree(x3, x4, x2) === x2) {\n          return [x2, y2];\n        }\n\n        return [];\n      } else {\n        // Parallel, non-coincident\n        return [];\n      }\n    }\n  }; // math.polygonIntersectLine( x, y, basePoints, centerX, centerY, width, height, padding )\n  // intersect a node polygon (pts transformed)\n  //\n  // math.polygonIntersectLine( x, y, basePoints, centerX, centerY )\n  // intersect the points (no transform)\n\n  var polygonIntersectLine = function polygonIntersectLine(x, y, basePoints, centerX, centerY, width, height, padding) {\n    var intersections = [];\n    var intersection;\n    var transformedPoints = new Array(basePoints.length);\n    var doTransform = true;\n\n    if (width == null) {\n      doTransform = false;\n    }\n\n    var points;\n\n    if (doTransform) {\n      for (var i = 0; i < transformedPoints.length / 2; i++) {\n        transformedPoints[i * 2] = basePoints[i * 2] * width + centerX;\n        transformedPoints[i * 2 + 1] = basePoints[i * 2 + 1] * height + centerY;\n      }\n\n      if (padding > 0) {\n        var expandedLineSet = expandPolygon(transformedPoints, -padding);\n        points = joinLines(expandedLineSet);\n      } else {\n        points = transformedPoints;\n      }\n    } else {\n      points = basePoints;\n    }\n\n    var currentX, currentY, nextX, nextY;\n\n    for (var _i2 = 0; _i2 < points.length / 2; _i2++) {\n      currentX = points[_i2 * 2];\n      currentY = points[_i2 * 2 + 1];\n\n      if (_i2 < points.length / 2 - 1) {\n        nextX = points[(_i2 + 1) * 2];\n        nextY = points[(_i2 + 1) * 2 + 1];\n      } else {\n        nextX = points[0];\n        nextY = points[1];\n      }\n\n      intersection = finiteLinesIntersect(x, y, centerX, centerY, currentX, currentY, nextX, nextY);\n\n      if (intersection.length !== 0) {\n        intersections.push(intersection[0], intersection[1]);\n      }\n    }\n\n    return intersections;\n  };\n  var roundPolygonIntersectLine = function roundPolygonIntersectLine(x, y, basePoints, centerX, centerY, width, height, padding) {\n    var intersections = [];\n    var intersection;\n    var lines = new Array(basePoints.length);\n    var halfW = width / 2;\n    var halfH = height / 2;\n    var cornerRadius = getRoundPolygonRadius(width, height);\n\n    for (var i = 0; i < basePoints.length / 4; i++) {\n      var sourceUv = void 0,\n          destUv = void 0;\n\n      if (i === 0) {\n        sourceUv = basePoints.length - 2;\n      } else {\n        sourceUv = i * 4 - 2;\n      }\n\n      destUv = i * 4 + 2;\n      var px = centerX + halfW * basePoints[i * 4];\n      var py = centerY + halfH * basePoints[i * 4 + 1];\n      var cosTheta = -basePoints[sourceUv] * basePoints[destUv] - basePoints[sourceUv + 1] * basePoints[destUv + 1];\n      var offset = cornerRadius / Math.tan(Math.acos(cosTheta) / 2);\n      var cp0x = px - offset * basePoints[sourceUv];\n      var cp0y = py - offset * basePoints[sourceUv + 1];\n      var cp1x = px + offset * basePoints[destUv];\n      var cp1y = py + offset * basePoints[destUv + 1];\n\n      if (i === 0) {\n        lines[basePoints.length - 2] = cp0x;\n        lines[basePoints.length - 1] = cp0y;\n      } else {\n        lines[i * 4 - 2] = cp0x;\n        lines[i * 4 - 1] = cp0y;\n      }\n\n      lines[i * 4] = cp1x;\n      lines[i * 4 + 1] = cp1y;\n      var orthx = basePoints[sourceUv + 1];\n      var orthy = -basePoints[sourceUv];\n      var cosAlpha = orthx * basePoints[destUv] + orthy * basePoints[destUv + 1];\n\n      if (cosAlpha < 0) {\n        orthx *= -1;\n        orthy *= -1;\n      }\n\n      var cx = cp0x + orthx * cornerRadius;\n      var cy = cp0y + orthy * cornerRadius;\n      intersection = intersectLineCircle(x, y, centerX, centerY, cx, cy, cornerRadius);\n\n      if (intersection.length !== 0) {\n        intersections.push(intersection[0], intersection[1]);\n      }\n    }\n\n    for (var _i3 = 0; _i3 < lines.length / 4; _i3++) {\n      intersection = finiteLinesIntersect(x, y, centerX, centerY, lines[_i3 * 4], lines[_i3 * 4 + 1], lines[_i3 * 4 + 2], lines[_i3 * 4 + 3], false);\n\n      if (intersection.length !== 0) {\n        intersections.push(intersection[0], intersection[1]);\n      }\n    }\n\n    if (intersections.length > 2) {\n      var lowestIntersection = [intersections[0], intersections[1]];\n      var lowestSquaredDistance = Math.pow(lowestIntersection[0] - x, 2) + Math.pow(lowestIntersection[1] - y, 2);\n\n      for (var _i4 = 1; _i4 < intersections.length / 2; _i4++) {\n        var squaredDistance = Math.pow(intersections[_i4 * 2] - x, 2) + Math.pow(intersections[_i4 * 2 + 1] - y, 2);\n\n        if (squaredDistance <= lowestSquaredDistance) {\n          lowestIntersection[0] = intersections[_i4 * 2];\n          lowestIntersection[1] = intersections[_i4 * 2 + 1];\n          lowestSquaredDistance = squaredDistance;\n        }\n      }\n\n      return lowestIntersection;\n    }\n\n    return intersections;\n  };\n  var shortenIntersection = function shortenIntersection(intersection, offset, amount) {\n    var disp = [intersection[0] - offset[0], intersection[1] - offset[1]];\n    var length = Math.sqrt(disp[0] * disp[0] + disp[1] * disp[1]);\n    var lenRatio = (length - amount) / length;\n\n    if (lenRatio < 0) {\n      lenRatio = 0.00001;\n    }\n\n    return [offset[0] + lenRatio * disp[0], offset[1] + lenRatio * disp[1]];\n  };\n  var generateUnitNgonPointsFitToSquare = function generateUnitNgonPointsFitToSquare(sides, rotationRadians) {\n    var points = generateUnitNgonPoints(sides, rotationRadians);\n    points = fitPolygonToSquare(points);\n    return points;\n  };\n  var fitPolygonToSquare = function fitPolygonToSquare(points) {\n    var x, y;\n    var sides = points.length / 2;\n    var minX = Infinity,\n        minY = Infinity,\n        maxX = -Infinity,\n        maxY = -Infinity;\n\n    for (var i = 0; i < sides; i++) {\n      x = points[2 * i];\n      y = points[2 * i + 1];\n      minX = Math.min(minX, x);\n      maxX = Math.max(maxX, x);\n      minY = Math.min(minY, y);\n      maxY = Math.max(maxY, y);\n    } // stretch factors\n\n\n    var sx = 2 / (maxX - minX);\n    var sy = 2 / (maxY - minY);\n\n    for (var _i5 = 0; _i5 < sides; _i5++) {\n      x = points[2 * _i5] = points[2 * _i5] * sx;\n      y = points[2 * _i5 + 1] = points[2 * _i5 + 1] * sy;\n      minX = Math.min(minX, x);\n      maxX = Math.max(maxX, x);\n      minY = Math.min(minY, y);\n      maxY = Math.max(maxY, y);\n    }\n\n    if (minY < -1) {\n      for (var _i6 = 0; _i6 < sides; _i6++) {\n        y = points[2 * _i6 + 1] = points[2 * _i6 + 1] + (-1 - minY);\n      }\n    }\n\n    return points;\n  };\n  var generateUnitNgonPoints = function generateUnitNgonPoints(sides, rotationRadians) {\n    var increment = 1.0 / sides * 2 * Math.PI;\n    var startAngle = sides % 2 === 0 ? Math.PI / 2.0 + increment / 2.0 : Math.PI / 2.0;\n    startAngle += rotationRadians;\n    var points = new Array(sides * 2);\n    var currentAngle;\n\n    for (var i = 0; i < sides; i++) {\n      currentAngle = i * increment + startAngle;\n      points[2 * i] = Math.cos(currentAngle); // x\n\n      points[2 * i + 1] = Math.sin(-currentAngle); // y\n    }\n\n    return points;\n  }; // Set the default radius, unless half of width or height is smaller than default\n\n  var getRoundRectangleRadius = function getRoundRectangleRadius(width, height) {\n    return Math.min(width / 4, height / 4, 8);\n  }; // Set the default radius\n\n  var getRoundPolygonRadius = function getRoundPolygonRadius(width, height) {\n    return Math.min(width / 10, height / 10, 8);\n  };\n  var getCutRectangleCornerLength = function getCutRectangleCornerLength() {\n    return 8;\n  };\n  var bezierPtsToQuadCoeff = function bezierPtsToQuadCoeff(p0, p1, p2) {\n    return [p0 - 2 * p1 + p2, 2 * (p1 - p0), p0];\n  }; // get curve width, height, and control point position offsets as a percentage of node height / width\n\n  var getBarrelCurveConstants = function getBarrelCurveConstants(width, height) {\n    return {\n      heightOffset: Math.min(15, 0.05 * height),\n      widthOffset: Math.min(100, 0.25 * width),\n      ctrlPtOffsetPct: 0.05\n    };\n  };\n\n  var pageRankDefaults = defaults$g({\n    dampingFactor: 0.8,\n    precision: 0.000001,\n    iterations: 200,\n    weight: function weight(edge) {\n      return 1;\n    }\n  });\n  var elesfn$o = {\n    pageRank: function pageRank(options) {\n      var _pageRankDefaults = pageRankDefaults(options),\n          dampingFactor = _pageRankDefaults.dampingFactor,\n          precision = _pageRankDefaults.precision,\n          iterations = _pageRankDefaults.iterations,\n          weight = _pageRankDefaults.weight;\n\n      var cy = this._private.cy;\n\n      var _this$byGroup = this.byGroup(),\n          nodes = _this$byGroup.nodes,\n          edges = _this$byGroup.edges;\n\n      var numNodes = nodes.length;\n      var numNodesSqd = numNodes * numNodes;\n      var numEdges = edges.length; // Construct transposed adjacency matrix\n      // First lets have a zeroed matrix of the right size\n      // We'll also keep track of the sum of each column\n\n      var matrix = new Array(numNodesSqd);\n      var columnSum = new Array(numNodes);\n      var additionalProb = (1 - dampingFactor) / numNodes; // Create null matrix\n\n      for (var i = 0; i < numNodes; i++) {\n        for (var j = 0; j < numNodes; j++) {\n          var n = i * numNodes + j;\n          matrix[n] = 0;\n        }\n\n        columnSum[i] = 0;\n      } // Now, process edges\n\n\n      for (var _i = 0; _i < numEdges; _i++) {\n        var edge = edges[_i];\n        var srcId = edge.data('source');\n        var tgtId = edge.data('target'); // Don't include loops in the matrix\n\n        if (srcId === tgtId) {\n          continue;\n        }\n\n        var s = nodes.indexOfId(srcId);\n        var t = nodes.indexOfId(tgtId);\n        var w = weight(edge);\n\n        var _n = t * numNodes + s; // Update matrix\n\n\n        matrix[_n] += w; // Update column sum\n\n        columnSum[s] += w;\n      } // Add additional probability based on damping factor\n      // Also, take into account columns that have sum = 0\n\n\n      var p = 1.0 / numNodes + additionalProb; // Shorthand\n      // Traverse matrix, column by column\n\n      for (var _j = 0; _j < numNodes; _j++) {\n        if (columnSum[_j] === 0) {\n          // No 'links' out from node jth, assume equal probability for each possible node\n          for (var _i2 = 0; _i2 < numNodes; _i2++) {\n            var _n2 = _i2 * numNodes + _j;\n\n            matrix[_n2] = p;\n          }\n        } else {\n          // Node jth has outgoing link, compute normalized probabilities\n          for (var _i3 = 0; _i3 < numNodes; _i3++) {\n            var _n3 = _i3 * numNodes + _j;\n\n            matrix[_n3] = matrix[_n3] / columnSum[_j] + additionalProb;\n          }\n        }\n      } // Compute dominant eigenvector using power method\n\n\n      var eigenvector = new Array(numNodes);\n      var temp = new Array(numNodes);\n      var previous; // Start with a vector of all 1's\n      // Also, initialize a null vector which will be used as shorthand\n\n      for (var _i4 = 0; _i4 < numNodes; _i4++) {\n        eigenvector[_i4] = 1;\n      }\n\n      for (var iter = 0; iter < iterations; iter++) {\n        // Temp array with all 0's\n        for (var _i5 = 0; _i5 < numNodes; _i5++) {\n          temp[_i5] = 0;\n        } // Multiply matrix with previous result\n\n\n        for (var _i6 = 0; _i6 < numNodes; _i6++) {\n          for (var _j2 = 0; _j2 < numNodes; _j2++) {\n            var _n4 = _i6 * numNodes + _j2;\n\n            temp[_i6] += matrix[_n4] * eigenvector[_j2];\n          }\n        }\n\n        inPlaceSumNormalize(temp);\n        previous = eigenvector;\n        eigenvector = temp;\n        temp = previous;\n        var diff = 0; // Compute difference (squared module) of both vectors\n\n        for (var _i7 = 0; _i7 < numNodes; _i7++) {\n          var delta = previous[_i7] - eigenvector[_i7];\n          diff += delta * delta;\n        } // If difference is less than the desired threshold, stop iterating\n\n\n        if (diff < precision) {\n          break;\n        }\n      } // Construct result\n\n\n      var res = {\n        rank: function rank(node) {\n          node = cy.collection(node)[0];\n          return eigenvector[nodes.indexOf(node)];\n        }\n      };\n      return res;\n    } // pageRank\n\n  }; // elesfn\n\n  var defaults$f = defaults$g({\n    root: null,\n    weight: function weight(edge) {\n      return 1;\n    },\n    directed: false,\n    alpha: 0\n  });\n  var elesfn$n = {\n    degreeCentralityNormalized: function degreeCentralityNormalized(options) {\n      options = defaults$f(options);\n      var cy = this.cy();\n      var nodes = this.nodes();\n      var numNodes = nodes.length;\n\n      if (!options.directed) {\n        var degrees = {};\n        var maxDegree = 0;\n\n        for (var i = 0; i < numNodes; i++) {\n          var node = nodes[i]; // add current node to the current options object and call degreeCentrality\n\n          options.root = node;\n          var currDegree = this.degreeCentrality(options);\n\n          if (maxDegree < currDegree.degree) {\n            maxDegree = currDegree.degree;\n          }\n\n          degrees[node.id()] = currDegree.degree;\n        }\n\n        return {\n          degree: function degree(node) {\n            if (maxDegree === 0) {\n              return 0;\n            }\n\n            if (string(node)) {\n              // from is a selector string\n              node = cy.filter(node);\n            }\n\n            return degrees[node.id()] / maxDegree;\n          }\n        };\n      } else {\n        var indegrees = {};\n        var outdegrees = {};\n        var maxIndegree = 0;\n        var maxOutdegree = 0;\n\n        for (var _i = 0; _i < numNodes; _i++) {\n          var _node = nodes[_i];\n\n          var id = _node.id(); // add current node to the current options object and call degreeCentrality\n\n\n          options.root = _node;\n\n          var _currDegree = this.degreeCentrality(options);\n\n          if (maxIndegree < _currDegree.indegree) maxIndegree = _currDegree.indegree;\n          if (maxOutdegree < _currDegree.outdegree) maxOutdegree = _currDegree.outdegree;\n          indegrees[id] = _currDegree.indegree;\n          outdegrees[id] = _currDegree.outdegree;\n        }\n\n        return {\n          indegree: function indegree(node) {\n            if (maxIndegree == 0) {\n              return 0;\n            }\n\n            if (string(node)) {\n              // from is a selector string\n              node = cy.filter(node);\n            }\n\n            return indegrees[node.id()] / maxIndegree;\n          },\n          outdegree: function outdegree(node) {\n            if (maxOutdegree === 0) {\n              return 0;\n            }\n\n            if (string(node)) {\n              // from is a selector string\n              node = cy.filter(node);\n            }\n\n            return outdegrees[node.id()] / maxOutdegree;\n          }\n        };\n      }\n    },\n    // degreeCentralityNormalized\n    // Implemented from the algorithm in Opsahl's paper\n    // \"Node centrality in weighted networks: Generalizing degree and shortest paths\"\n    // check the heading 2 \"Degree\"\n    degreeCentrality: function degreeCentrality(options) {\n      options = defaults$f(options);\n      var cy = this.cy();\n      var callingEles = this;\n      var _options = options,\n          root = _options.root,\n          weight = _options.weight,\n          directed = _options.directed,\n          alpha = _options.alpha;\n      root = cy.collection(root)[0];\n\n      if (!directed) {\n        var connEdges = root.connectedEdges().intersection(callingEles);\n        var k = connEdges.length;\n        var s = 0; // Now, sum edge weights\n\n        for (var i = 0; i < connEdges.length; i++) {\n          s += weight(connEdges[i]);\n        }\n\n        return {\n          degree: Math.pow(k, 1 - alpha) * Math.pow(s, alpha)\n        };\n      } else {\n        var edges = root.connectedEdges();\n        var incoming = edges.filter(function (edge) {\n          return edge.target().same(root) && callingEles.has(edge);\n        });\n        var outgoing = edges.filter(function (edge) {\n          return edge.source().same(root) && callingEles.has(edge);\n        });\n        var k_in = incoming.length;\n        var k_out = outgoing.length;\n        var s_in = 0;\n        var s_out = 0; // Now, sum incoming edge weights\n\n        for (var _i2 = 0; _i2 < incoming.length; _i2++) {\n          s_in += weight(incoming[_i2]);\n        } // Now, sum outgoing edge weights\n\n\n        for (var _i3 = 0; _i3 < outgoing.length; _i3++) {\n          s_out += weight(outgoing[_i3]);\n        }\n\n        return {\n          indegree: Math.pow(k_in, 1 - alpha) * Math.pow(s_in, alpha),\n          outdegree: Math.pow(k_out, 1 - alpha) * Math.pow(s_out, alpha)\n        };\n      }\n    } // degreeCentrality\n\n  }; // elesfn\n  // nice, short mathematical alias\n\n  elesfn$n.dc = elesfn$n.degreeCentrality;\n  elesfn$n.dcn = elesfn$n.degreeCentralityNormalised = elesfn$n.degreeCentralityNormalized;\n\n  var defaults$e = defaults$g({\n    harmonic: true,\n    weight: function weight() {\n      return 1;\n    },\n    directed: false,\n    root: null\n  });\n  var elesfn$m = {\n    closenessCentralityNormalized: function closenessCentralityNormalized(options) {\n      var _defaults = defaults$e(options),\n          harmonic = _defaults.harmonic,\n          weight = _defaults.weight,\n          directed = _defaults.directed;\n\n      var cy = this.cy();\n      var closenesses = {};\n      var maxCloseness = 0;\n      var nodes = this.nodes();\n      var fw = this.floydWarshall({\n        weight: weight,\n        directed: directed\n      }); // Compute closeness for every node and find the maximum closeness\n\n      for (var i = 0; i < nodes.length; i++) {\n        var currCloseness = 0;\n        var node_i = nodes[i];\n\n        for (var j = 0; j < nodes.length; j++) {\n          if (i !== j) {\n            var d = fw.distance(node_i, nodes[j]);\n\n            if (harmonic) {\n              currCloseness += 1 / d;\n            } else {\n              currCloseness += d;\n            }\n          }\n        }\n\n        if (!harmonic) {\n          currCloseness = 1 / currCloseness;\n        }\n\n        if (maxCloseness < currCloseness) {\n          maxCloseness = currCloseness;\n        }\n\n        closenesses[node_i.id()] = currCloseness;\n      }\n\n      return {\n        closeness: function closeness(node) {\n          if (maxCloseness == 0) {\n            return 0;\n          }\n\n          if (string(node)) {\n            // from is a selector string\n            node = cy.filter(node)[0].id();\n          } else {\n            // from is a node\n            node = node.id();\n          }\n\n          return closenesses[node] / maxCloseness;\n        }\n      };\n    },\n    // Implemented from pseudocode from wikipedia\n    closenessCentrality: function closenessCentrality(options) {\n      var _defaults2 = defaults$e(options),\n          root = _defaults2.root,\n          weight = _defaults2.weight,\n          directed = _defaults2.directed,\n          harmonic = _defaults2.harmonic;\n\n      root = this.filter(root)[0]; // we need distance from this node to every other node\n\n      var dijkstra = this.dijkstra({\n        root: root,\n        weight: weight,\n        directed: directed\n      });\n      var totalDistance = 0;\n      var nodes = this.nodes();\n\n      for (var i = 0; i < nodes.length; i++) {\n        var n = nodes[i];\n\n        if (!n.same(root)) {\n          var d = dijkstra.distanceTo(n);\n\n          if (harmonic) {\n            totalDistance += 1 / d;\n          } else {\n            totalDistance += d;\n          }\n        }\n      }\n\n      return harmonic ? totalDistance : 1 / totalDistance;\n    } // closenessCentrality\n\n  }; // elesfn\n  // nice, short mathematical alias\n\n  elesfn$m.cc = elesfn$m.closenessCentrality;\n  elesfn$m.ccn = elesfn$m.closenessCentralityNormalised = elesfn$m.closenessCentralityNormalized;\n\n  var defaults$d = defaults$g({\n    weight: null,\n    directed: false\n  });\n  var elesfn$l = {\n    // Implemented from the algorithm in the paper \"On Variants of Shortest-Path Betweenness Centrality and their Generic Computation\" by Ulrik Brandes\n    betweennessCentrality: function betweennessCentrality(options) {\n      var _defaults = defaults$d(options),\n          directed = _defaults.directed,\n          weight = _defaults.weight;\n\n      var weighted = weight != null;\n      var cy = this.cy(); // starting\n\n      var V = this.nodes();\n      var A = {};\n      var _C = {};\n      var max = 0;\n      var C = {\n        set: function set(key, val) {\n          _C[key] = val;\n\n          if (val > max) {\n            max = val;\n          }\n        },\n        get: function get(key) {\n          return _C[key];\n        }\n      }; // A contains the neighborhoods of every node\n\n      for (var i = 0; i < V.length; i++) {\n        var v = V[i];\n        var vid = v.id();\n\n        if (directed) {\n          A[vid] = v.outgoers().nodes(); // get outgoers of every node\n        } else {\n          A[vid] = v.openNeighborhood().nodes(); // get neighbors of every node\n        }\n\n        C.set(vid, 0);\n      }\n\n      var _loop = function _loop(s) {\n        var sid = V[s].id();\n        var S = []; // stack\n\n        var P = {};\n        var g = {};\n        var d = {};\n        var Q = new heap(function (a, b) {\n          return d[a] - d[b];\n        }); // queue\n        // init dictionaries\n\n        for (var _i = 0; _i < V.length; _i++) {\n          var _vid = V[_i].id();\n\n          P[_vid] = [];\n          g[_vid] = 0;\n          d[_vid] = Infinity;\n        }\n\n        g[sid] = 1; // sigma\n\n        d[sid] = 0; // distance to s\n\n        Q.push(sid);\n\n        while (!Q.empty()) {\n          var _v = Q.pop();\n\n          S.push(_v);\n\n          if (weighted) {\n            for (var j = 0; j < A[_v].length; j++) {\n              var w = A[_v][j];\n              var vEle = cy.getElementById(_v);\n              var edge = void 0;\n\n              if (vEle.edgesTo(w).length > 0) {\n                edge = vEle.edgesTo(w)[0];\n              } else {\n                edge = w.edgesTo(vEle)[0];\n              }\n\n              var edgeWeight = weight(edge);\n              w = w.id();\n\n              if (d[w] > d[_v] + edgeWeight) {\n                d[w] = d[_v] + edgeWeight;\n\n                if (Q.nodes.indexOf(w) < 0) {\n                  //if w is not in Q\n                  Q.push(w);\n                } else {\n                  // update position if w is in Q\n                  Q.updateItem(w);\n                }\n\n                g[w] = 0;\n                P[w] = [];\n              }\n\n              if (d[w] == d[_v] + edgeWeight) {\n                g[w] = g[w] + g[_v];\n                P[w].push(_v);\n              }\n            }\n          } else {\n            for (var _j = 0; _j < A[_v].length; _j++) {\n              var _w = A[_v][_j].id();\n\n              if (d[_w] == Infinity) {\n                Q.push(_w);\n                d[_w] = d[_v] + 1;\n              }\n\n              if (d[_w] == d[_v] + 1) {\n                g[_w] = g[_w] + g[_v];\n\n                P[_w].push(_v);\n              }\n            }\n          }\n        }\n\n        var e = {};\n\n        for (var _i2 = 0; _i2 < V.length; _i2++) {\n          e[V[_i2].id()] = 0;\n        }\n\n        while (S.length > 0) {\n          var _w2 = S.pop();\n\n          for (var _j2 = 0; _j2 < P[_w2].length; _j2++) {\n            var _v2 = P[_w2][_j2];\n            e[_v2] = e[_v2] + g[_v2] / g[_w2] * (1 + e[_w2]);\n          }\n\n          if (_w2 != V[s].id()) {\n            C.set(_w2, C.get(_w2) + e[_w2]);\n          }\n        }\n      };\n\n      for (var s = 0; s < V.length; s++) {\n        _loop(s);\n      }\n\n      var ret = {\n        betweenness: function betweenness(node) {\n          var id = cy.collection(node).id();\n          return C.get(id);\n        },\n        betweennessNormalized: function betweennessNormalized(node) {\n          if (max == 0) {\n            return 0;\n          }\n\n          var id = cy.collection(node).id();\n          return C.get(id) / max;\n        }\n      }; // alias\n\n      ret.betweennessNormalised = ret.betweennessNormalized;\n      return ret;\n    } // betweennessCentrality\n\n  }; // elesfn\n  // nice, short mathematical alias\n\n  elesfn$l.bc = elesfn$l.betweennessCentrality;\n\n  // Implemented by Zoe Xi @zoexi for GSOC 2016\n  /* eslint-disable no-unused-vars */\n\n  var defaults$c = defaults$g({\n    expandFactor: 2,\n    // affects time of computation and cluster granularity to some extent: M * M\n    inflateFactor: 2,\n    // affects cluster granularity (the greater the value, the more clusters): M(i,j) / E(j)\n    multFactor: 1,\n    // optional self loops for each node. Use a neutral value to improve cluster computations.\n    maxIterations: 20,\n    // maximum number of iterations of the MCL algorithm in a single run\n    attributes: [// attributes/features used to group nodes, ie. similarity values between nodes\n    function (edge) {\n      return 1;\n    }]\n  });\n  /* eslint-enable */\n\n  var setOptions$3 = function setOptions(options) {\n    return defaults$c(options);\n  };\n  /* eslint-enable */\n\n\n  var getSimilarity$1 = function getSimilarity(edge, attributes) {\n    var total = 0;\n\n    for (var i = 0; i < attributes.length; i++) {\n      total += attributes[i](edge);\n    }\n\n    return total;\n  };\n\n  var addLoops = function addLoops(M, n, val) {\n    for (var i = 0; i < n; i++) {\n      M[i * n + i] = val;\n    }\n  };\n\n  var normalize = function normalize(M, n) {\n    var sum;\n\n    for (var col = 0; col < n; col++) {\n      sum = 0;\n\n      for (var row = 0; row < n; row++) {\n        sum += M[row * n + col];\n      }\n\n      for (var _row = 0; _row < n; _row++) {\n        M[_row * n + col] = M[_row * n + col] / sum;\n      }\n    }\n  }; // TODO: blocked matrix multiplication?\n\n\n  var mmult = function mmult(A, B, n) {\n    var C = new Array(n * n);\n\n    for (var i = 0; i < n; i++) {\n      for (var j = 0; j < n; j++) {\n        C[i * n + j] = 0;\n      }\n\n      for (var k = 0; k < n; k++) {\n        for (var _j = 0; _j < n; _j++) {\n          C[i * n + _j] += A[i * n + k] * B[k * n + _j];\n        }\n      }\n    }\n\n    return C;\n  };\n\n  var expand = function expand(M, n, expandFactor\n  /** power **/\n  ) {\n    var _M = M.slice(0);\n\n    for (var p = 1; p < expandFactor; p++) {\n      M = mmult(M, _M, n);\n    }\n\n    return M;\n  };\n\n  var inflate = function inflate(M, n, inflateFactor\n  /** r **/\n  ) {\n    var _M = new Array(n * n); // M(i,j) ^ inflatePower\n\n\n    for (var i = 0; i < n * n; i++) {\n      _M[i] = Math.pow(M[i], inflateFactor);\n    }\n\n    normalize(_M, n);\n    return _M;\n  };\n\n  var hasConverged = function hasConverged(M, _M, n2, roundFactor) {\n    // Check that both matrices have the same elements (i,j)\n    for (var i = 0; i < n2; i++) {\n      var v1 = Math.round(M[i] * Math.pow(10, roundFactor)) / Math.pow(10, roundFactor); // truncate to 'roundFactor' decimal places\n\n      var v2 = Math.round(_M[i] * Math.pow(10, roundFactor)) / Math.pow(10, roundFactor);\n\n      if (v1 !== v2) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  var assign$2 = function assign(M, n, nodes, cy) {\n    var clusters = [];\n\n    for (var i = 0; i < n; i++) {\n      var cluster = [];\n\n      for (var j = 0; j < n; j++) {\n        // Row-wise attractors and elements that they attract belong in same cluster\n        if (Math.round(M[i * n + j] * 1000) / 1000 > 0) {\n          cluster.push(nodes[j]);\n        }\n      }\n\n      if (cluster.length !== 0) {\n        clusters.push(cy.collection(cluster));\n      }\n    }\n\n    return clusters;\n  };\n\n  var isDuplicate = function isDuplicate(c1, c2) {\n    for (var i = 0; i < c1.length; i++) {\n      if (!c2[i] || c1[i].id() !== c2[i].id()) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  var removeDuplicates = function removeDuplicates(clusters) {\n    for (var i = 0; i < clusters.length; i++) {\n      for (var j = 0; j < clusters.length; j++) {\n        if (i != j && isDuplicate(clusters[i], clusters[j])) {\n          clusters.splice(j, 1);\n        }\n      }\n    }\n\n    return clusters;\n  };\n\n  var markovClustering = function markovClustering(options) {\n    var nodes = this.nodes();\n    var edges = this.edges();\n    var cy = this.cy(); // Set parameters of algorithm:\n\n    var opts = setOptions$3(options); // Map each node to its position in node array\n\n    var id2position = {};\n\n    for (var i = 0; i < nodes.length; i++) {\n      id2position[nodes[i].id()] = i;\n    } // Generate stochastic matrix M from input graph G (should be symmetric/undirected)\n\n\n    var n = nodes.length,\n        n2 = n * n;\n\n    var M = new Array(n2),\n        _M;\n\n    for (var _i = 0; _i < n2; _i++) {\n      M[_i] = 0;\n    }\n\n    for (var e = 0; e < edges.length; e++) {\n      var edge = edges[e];\n      var _i2 = id2position[edge.source().id()];\n      var j = id2position[edge.target().id()];\n      var sim = getSimilarity$1(edge, opts.attributes);\n      M[_i2 * n + j] += sim; // G should be symmetric and undirected\n\n      M[j * n + _i2] += sim;\n    } // Begin Markov cluster algorithm\n    // Step 1: Add self loops to each node, ie. add multFactor to matrix diagonal\n\n\n    addLoops(M, n, opts.multFactor); // Step 2: M = normalize( M );\n\n    normalize(M, n);\n    var isStillMoving = true;\n    var iterations = 0;\n\n    while (isStillMoving && iterations < opts.maxIterations) {\n      isStillMoving = false; // Step 3:\n\n      _M = expand(M, n, opts.expandFactor); // Step 4:\n\n      M = inflate(_M, n, opts.inflateFactor); // Step 5: check to see if ~steady state has been reached\n\n      if (!hasConverged(M, _M, n2, 4)) {\n        isStillMoving = true;\n      }\n\n      iterations++;\n    } // Build clusters from matrix\n\n\n    var clusters = assign$2(M, n, nodes, cy); // Remove duplicate clusters due to symmetry of graph and M matrix\n\n    clusters = removeDuplicates(clusters);\n    return clusters;\n  };\n\n  var markovClustering$1 = {\n    markovClustering: markovClustering,\n    mcl: markovClustering\n  };\n\n  // Common distance metrics for clustering algorithms\n\n  var identity = function identity(x) {\n    return x;\n  };\n\n  var absDiff = function absDiff(p, q) {\n    return Math.abs(q - p);\n  };\n\n  var addAbsDiff = function addAbsDiff(total, p, q) {\n    return total + absDiff(p, q);\n  };\n\n  var addSquaredDiff = function addSquaredDiff(total, p, q) {\n    return total + Math.pow(q - p, 2);\n  };\n\n  var sqrt = function sqrt(x) {\n    return Math.sqrt(x);\n  };\n\n  var maxAbsDiff = function maxAbsDiff(currentMax, p, q) {\n    return Math.max(currentMax, absDiff(p, q));\n  };\n\n  var getDistance = function getDistance(length, getP, getQ, init, visit) {\n    var post = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : identity;\n    var ret = init;\n    var p, q;\n\n    for (var dim = 0; dim < length; dim++) {\n      p = getP(dim);\n      q = getQ(dim);\n      ret = visit(ret, p, q);\n    }\n\n    return post(ret);\n  };\n\n  var distances = {\n    euclidean: function euclidean(length, getP, getQ) {\n      if (length >= 2) {\n        return getDistance(length, getP, getQ, 0, addSquaredDiff, sqrt);\n      } else {\n        // for single attr case, more efficient to avoid sqrt\n        return getDistance(length, getP, getQ, 0, addAbsDiff);\n      }\n    },\n    squaredEuclidean: function squaredEuclidean(length, getP, getQ) {\n      return getDistance(length, getP, getQ, 0, addSquaredDiff);\n    },\n    manhattan: function manhattan(length, getP, getQ) {\n      return getDistance(length, getP, getQ, 0, addAbsDiff);\n    },\n    max: function max(length, getP, getQ) {\n      return getDistance(length, getP, getQ, -Infinity, maxAbsDiff);\n    }\n  }; // in case the user accidentally doesn't use camel case\n\n  distances['squared-euclidean'] = distances['squaredEuclidean'];\n  distances['squaredeuclidean'] = distances['squaredEuclidean'];\n  function clusteringDistance (method, length, getP, getQ, nodeP, nodeQ) {\n    var impl;\n\n    if (fn$6(method)) {\n      impl = method;\n    } else {\n      impl = distances[method] || distances.euclidean;\n    }\n\n    if (length === 0 && fn$6(method)) {\n      return impl(nodeP, nodeQ);\n    } else {\n      return impl(length, getP, getQ, nodeP, nodeQ);\n    }\n  }\n\n  var defaults$b = defaults$g({\n    k: 2,\n    m: 2,\n    sensitivityThreshold: 0.0001,\n    distance: 'euclidean',\n    maxIterations: 10,\n    attributes: [],\n    testMode: false,\n    testCentroids: null\n  });\n\n  var setOptions$2 = function setOptions(options) {\n    return defaults$b(options);\n  };\n  /* eslint-enable */\n\n\n  var getDist = function getDist(type, node, centroid, attributes, mode) {\n    var noNodeP = mode !== 'kMedoids';\n    var getP = noNodeP ? function (i) {\n      return centroid[i];\n    } : function (i) {\n      return attributes[i](centroid);\n    };\n\n    var getQ = function getQ(i) {\n      return attributes[i](node);\n    };\n\n    var nodeP = centroid;\n    var nodeQ = node;\n    return clusteringDistance(type, attributes.length, getP, getQ, nodeP, nodeQ);\n  };\n\n  var randomCentroids = function randomCentroids(nodes, k, attributes) {\n    var ndim = attributes.length;\n    var min = new Array(ndim);\n    var max = new Array(ndim);\n    var centroids = new Array(k);\n    var centroid = null; // Find min, max values for each attribute dimension\n\n    for (var i = 0; i < ndim; i++) {\n      min[i] = nodes.min(attributes[i]).value;\n      max[i] = nodes.max(attributes[i]).value;\n    } // Build k centroids, each represented as an n-dim feature vector\n\n\n    for (var c = 0; c < k; c++) {\n      centroid = [];\n\n      for (var _i = 0; _i < ndim; _i++) {\n        centroid[_i] = Math.random() * (max[_i] - min[_i]) + min[_i]; // random initial value\n      }\n\n      centroids[c] = centroid;\n    }\n\n    return centroids;\n  };\n\n  var classify = function classify(node, centroids, distance, attributes, type) {\n    var min = Infinity;\n    var index = 0;\n\n    for (var i = 0; i < centroids.length; i++) {\n      var dist = getDist(distance, node, centroids[i], attributes, type);\n\n      if (dist < min) {\n        min = dist;\n        index = i;\n      }\n    }\n\n    return index;\n  };\n\n  var buildCluster = function buildCluster(centroid, nodes, assignment) {\n    var cluster = [];\n    var node = null;\n\n    for (var n = 0; n < nodes.length; n++) {\n      node = nodes[n];\n\n      if (assignment[node.id()] === centroid) {\n        //console.log(\"Node \" + node.id() + \" is associated with medoid #: \" + m);\n        cluster.push(node);\n      }\n    }\n\n    return cluster;\n  };\n\n  var haveValuesConverged = function haveValuesConverged(v1, v2, sensitivityThreshold) {\n    return Math.abs(v2 - v1) <= sensitivityThreshold;\n  };\n\n  var haveMatricesConverged = function haveMatricesConverged(v1, v2, sensitivityThreshold) {\n    for (var i = 0; i < v1.length; i++) {\n      for (var j = 0; j < v1[i].length; j++) {\n        var diff = Math.abs(v1[i][j] - v2[i][j]);\n\n        if (diff > sensitivityThreshold) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  };\n\n  var seenBefore = function seenBefore(node, medoids, n) {\n    for (var i = 0; i < n; i++) {\n      if (node === medoids[i]) return true;\n    }\n\n    return false;\n  };\n\n  var randomMedoids = function randomMedoids(nodes, k) {\n    var medoids = new Array(k); // For small data sets, the probability of medoid conflict is greater,\n    // so we need to check to see if we've already seen or chose this node before.\n\n    if (nodes.length < 50) {\n      // Randomly select k medoids from the n nodes\n      for (var i = 0; i < k; i++) {\n        var node = nodes[Math.floor(Math.random() * nodes.length)]; // If we've already chosen this node to be a medoid, don't choose it again (for small data sets).\n        // Instead choose a different random node.\n\n        while (seenBefore(node, medoids, i)) {\n          node = nodes[Math.floor(Math.random() * nodes.length)];\n        }\n\n        medoids[i] = node;\n      }\n    } else {\n      // Relatively large data set, so pretty safe to not check and just select random nodes\n      for (var _i2 = 0; _i2 < k; _i2++) {\n        medoids[_i2] = nodes[Math.floor(Math.random() * nodes.length)];\n      }\n    }\n\n    return medoids;\n  };\n\n  var findCost = function findCost(potentialNewMedoid, cluster, attributes) {\n    var cost = 0;\n\n    for (var n = 0; n < cluster.length; n++) {\n      cost += getDist('manhattan', cluster[n], potentialNewMedoid, attributes, 'kMedoids');\n    }\n\n    return cost;\n  };\n\n  var kMeans = function kMeans(options) {\n    var cy = this.cy();\n    var nodes = this.nodes();\n    var node = null; // Set parameters of algorithm: # of clusters, distance metric, etc.\n\n    var opts = setOptions$2(options); // Begin k-means algorithm\n\n    var clusters = new Array(opts.k);\n    var assignment = {};\n    var centroids; // Step 1: Initialize centroid positions\n\n    if (opts.testMode) {\n      if (typeof opts.testCentroids === 'number') {\n        // TODO: implement a seeded random number generator.\n        opts.testCentroids;\n        centroids = randomCentroids(nodes, opts.k, opts.attributes);\n      } else if (_typeof(opts.testCentroids) === 'object') {\n        centroids = opts.testCentroids;\n      } else {\n        centroids = randomCentroids(nodes, opts.k, opts.attributes);\n      }\n    } else {\n      centroids = randomCentroids(nodes, opts.k, opts.attributes);\n    }\n\n    var isStillMoving = true;\n    var iterations = 0;\n\n    while (isStillMoving && iterations < opts.maxIterations) {\n      // Step 2: Assign nodes to the nearest centroid\n      for (var n = 0; n < nodes.length; n++) {\n        node = nodes[n]; // Determine which cluster this node belongs to: node id => cluster #\n\n        assignment[node.id()] = classify(node, centroids, opts.distance, opts.attributes, 'kMeans');\n      } // Step 3: For each of the k clusters, update its centroid\n\n\n      isStillMoving = false;\n\n      for (var c = 0; c < opts.k; c++) {\n        // Get all nodes that belong to this cluster\n        var cluster = buildCluster(c, nodes, assignment);\n\n        if (cluster.length === 0) {\n          // If cluster is empty, break out early & move to next cluster\n          continue;\n        } // Update centroids by calculating avg of all nodes within the cluster.\n\n\n        var ndim = opts.attributes.length;\n        var centroid = centroids[c]; // [ dim_1, dim_2, dim_3, ... , dim_n ]\n\n        var newCentroid = new Array(ndim);\n        var sum = new Array(ndim);\n\n        for (var d = 0; d < ndim; d++) {\n          sum[d] = 0.0;\n\n          for (var i = 0; i < cluster.length; i++) {\n            node = cluster[i];\n            sum[d] += opts.attributes[d](node);\n          }\n\n          newCentroid[d] = sum[d] / cluster.length; // Check to see if algorithm has converged, i.e. when centroids no longer change\n\n          if (!haveValuesConverged(newCentroid[d], centroid[d], opts.sensitivityThreshold)) {\n            isStillMoving = true;\n          }\n        }\n\n        centroids[c] = newCentroid;\n        clusters[c] = cy.collection(cluster);\n      }\n\n      iterations++;\n    }\n\n    return clusters;\n  };\n\n  var kMedoids = function kMedoids(options) {\n    var cy = this.cy();\n    var nodes = this.nodes();\n    var node = null;\n    var opts = setOptions$2(options); // Begin k-medoids algorithm\n\n    var clusters = new Array(opts.k);\n    var medoids;\n    var assignment = {};\n    var curCost;\n    var minCosts = new Array(opts.k); // minimum cost configuration for each cluster\n    // Step 1: Initialize k medoids\n\n    if (opts.testMode) {\n      if (typeof opts.testCentroids === 'number') ; else if (_typeof(opts.testCentroids) === 'object') {\n        medoids = opts.testCentroids;\n      } else {\n        medoids = randomMedoids(nodes, opts.k);\n      }\n    } else {\n      medoids = randomMedoids(nodes, opts.k);\n    }\n\n    var isStillMoving = true;\n    var iterations = 0;\n\n    while (isStillMoving && iterations < opts.maxIterations) {\n      // Step 2: Assign nodes to the nearest medoid\n      for (var n = 0; n < nodes.length; n++) {\n        node = nodes[n]; // Determine which cluster this node belongs to: node id => cluster #\n\n        assignment[node.id()] = classify(node, medoids, opts.distance, opts.attributes, 'kMedoids');\n      }\n\n      isStillMoving = false; // Step 3: For each medoid m, and for each node associated with mediod m,\n      // select the node with the lowest configuration cost as new medoid.\n\n      for (var m = 0; m < medoids.length; m++) {\n        // Get all nodes that belong to this medoid\n        var cluster = buildCluster(m, nodes, assignment);\n\n        if (cluster.length === 0) {\n          // If cluster is empty, break out early & move to next cluster\n          continue;\n        }\n\n        minCosts[m] = findCost(medoids[m], cluster, opts.attributes); // original cost\n        // Select different medoid if its configuration has the lowest cost\n\n        for (var _n = 0; _n < cluster.length; _n++) {\n          curCost = findCost(cluster[_n], cluster, opts.attributes);\n\n          if (curCost < minCosts[m]) {\n            minCosts[m] = curCost;\n            medoids[m] = cluster[_n];\n            isStillMoving = true;\n          }\n        }\n\n        clusters[m] = cy.collection(cluster);\n      }\n\n      iterations++;\n    }\n\n    return clusters;\n  };\n\n  var updateCentroids = function updateCentroids(centroids, nodes, U, weight, opts) {\n    var numerator, denominator;\n\n    for (var n = 0; n < nodes.length; n++) {\n      for (var c = 0; c < centroids.length; c++) {\n        weight[n][c] = Math.pow(U[n][c], opts.m);\n      }\n    }\n\n    for (var _c = 0; _c < centroids.length; _c++) {\n      for (var dim = 0; dim < opts.attributes.length; dim++) {\n        numerator = 0;\n        denominator = 0;\n\n        for (var _n2 = 0; _n2 < nodes.length; _n2++) {\n          numerator += weight[_n2][_c] * opts.attributes[dim](nodes[_n2]);\n          denominator += weight[_n2][_c];\n        }\n\n        centroids[_c][dim] = numerator / denominator;\n      }\n    }\n  };\n\n  var updateMembership = function updateMembership(U, _U, centroids, nodes, opts) {\n    // Save previous step\n    for (var i = 0; i < U.length; i++) {\n      _U[i] = U[i].slice();\n    }\n\n    var sum, numerator, denominator;\n    var pow = 2 / (opts.m - 1);\n\n    for (var c = 0; c < centroids.length; c++) {\n      for (var n = 0; n < nodes.length; n++) {\n        sum = 0;\n\n        for (var k = 0; k < centroids.length; k++) {\n          // against all other centroids\n          numerator = getDist(opts.distance, nodes[n], centroids[c], opts.attributes, 'cmeans');\n          denominator = getDist(opts.distance, nodes[n], centroids[k], opts.attributes, 'cmeans');\n          sum += Math.pow(numerator / denominator, pow);\n        }\n\n        U[n][c] = 1 / sum;\n      }\n    }\n  };\n\n  var assign$1 = function assign(nodes, U, opts, cy) {\n    var clusters = new Array(opts.k);\n\n    for (var c = 0; c < clusters.length; c++) {\n      clusters[c] = [];\n    }\n\n    var max;\n    var index;\n\n    for (var n = 0; n < U.length; n++) {\n      // for each node (U is N x C matrix)\n      max = -Infinity;\n      index = -1; // Determine which cluster the node is most likely to belong in\n\n      for (var _c2 = 0; _c2 < U[0].length; _c2++) {\n        if (U[n][_c2] > max) {\n          max = U[n][_c2];\n          index = _c2;\n        }\n      }\n\n      clusters[index].push(nodes[n]);\n    } // Turn every array into a collection of nodes\n\n\n    for (var _c3 = 0; _c3 < clusters.length; _c3++) {\n      clusters[_c3] = cy.collection(clusters[_c3]);\n    }\n\n    return clusters;\n  };\n\n  var fuzzyCMeans = function fuzzyCMeans(options) {\n    var cy = this.cy();\n    var nodes = this.nodes();\n    var opts = setOptions$2(options); // Begin fuzzy c-means algorithm\n\n    var clusters;\n    var centroids;\n    var U;\n\n    var _U;\n\n    var weight; // Step 1: Initialize letiables.\n\n    _U = new Array(nodes.length);\n\n    for (var i = 0; i < nodes.length; i++) {\n      // N x C matrix\n      _U[i] = new Array(opts.k);\n    }\n\n    U = new Array(nodes.length);\n\n    for (var _i3 = 0; _i3 < nodes.length; _i3++) {\n      // N x C matrix\n      U[_i3] = new Array(opts.k);\n    }\n\n    for (var _i4 = 0; _i4 < nodes.length; _i4++) {\n      var total = 0;\n\n      for (var j = 0; j < opts.k; j++) {\n        U[_i4][j] = Math.random();\n        total += U[_i4][j];\n      }\n\n      for (var _j = 0; _j < opts.k; _j++) {\n        U[_i4][_j] = U[_i4][_j] / total;\n      }\n    }\n\n    centroids = new Array(opts.k);\n\n    for (var _i5 = 0; _i5 < opts.k; _i5++) {\n      centroids[_i5] = new Array(opts.attributes.length);\n    }\n\n    weight = new Array(nodes.length);\n\n    for (var _i6 = 0; _i6 < nodes.length; _i6++) {\n      // N x C matrix\n      weight[_i6] = new Array(opts.k);\n    } // end init FCM\n\n\n    var isStillMoving = true;\n    var iterations = 0;\n\n    while (isStillMoving && iterations < opts.maxIterations) {\n      isStillMoving = false; // Step 2: Calculate the centroids for each step.\n\n      updateCentroids(centroids, nodes, U, weight, opts); // Step 3: Update the partition matrix U.\n\n      updateMembership(U, _U, centroids, nodes, opts); // Step 4: Check for convergence.\n\n      if (!haveMatricesConverged(U, _U, opts.sensitivityThreshold)) {\n        isStillMoving = true;\n      }\n\n      iterations++;\n    } // Assign nodes to clusters with highest probability.\n\n\n    clusters = assign$1(nodes, U, opts, cy);\n    return {\n      clusters: clusters,\n      degreeOfMembership: U\n    };\n  };\n\n  var kClustering = {\n    kMeans: kMeans,\n    kMedoids: kMedoids,\n    fuzzyCMeans: fuzzyCMeans,\n    fcm: fuzzyCMeans\n  };\n\n  // Implemented by Zoe Xi @zoexi for GSOC 2016\n  var defaults$a = defaults$g({\n    distance: 'euclidean',\n    // distance metric to compare nodes\n    linkage: 'min',\n    // linkage criterion : how to determine the distance between clusters of nodes\n    mode: 'threshold',\n    // mode:'threshold' => clusters must be threshold distance apart\n    threshold: Infinity,\n    // the distance threshold\n    // mode:'dendrogram' => the nodes are organised as leaves in a tree (siblings are close), merging makes clusters\n    addDendrogram: false,\n    // whether to add the dendrogram to the graph for viz\n    dendrogramDepth: 0,\n    // depth at which dendrogram branches are merged into the returned clusters\n    attributes: [] // array of attr functions\n\n  });\n  var linkageAliases = {\n    'single': 'min',\n    'complete': 'max'\n  };\n\n  var setOptions$1 = function setOptions(options) {\n    var opts = defaults$a(options);\n    var preferredAlias = linkageAliases[opts.linkage];\n\n    if (preferredAlias != null) {\n      opts.linkage = preferredAlias;\n    }\n\n    return opts;\n  };\n\n  var mergeClosest = function mergeClosest(clusters, index, dists, mins, opts) {\n    // Find two closest clusters from cached mins\n    var minKey = 0;\n    var min = Infinity;\n    var dist;\n    var attrs = opts.attributes;\n\n    var getDist = function getDist(n1, n2) {\n      return clusteringDistance(opts.distance, attrs.length, function (i) {\n        return attrs[i](n1);\n      }, function (i) {\n        return attrs[i](n2);\n      }, n1, n2);\n    };\n\n    for (var i = 0; i < clusters.length; i++) {\n      var key = clusters[i].key;\n      var _dist = dists[key][mins[key]];\n\n      if (_dist < min) {\n        minKey = key;\n        min = _dist;\n      }\n    }\n\n    if (opts.mode === 'threshold' && min >= opts.threshold || opts.mode === 'dendrogram' && clusters.length === 1) {\n      return false;\n    }\n\n    var c1 = index[minKey];\n    var c2 = index[mins[minKey]];\n    var merged; // Merge two closest clusters\n\n    if (opts.mode === 'dendrogram') {\n      merged = {\n        left: c1,\n        right: c2,\n        key: c1.key\n      };\n    } else {\n      merged = {\n        value: c1.value.concat(c2.value),\n        key: c1.key\n      };\n    }\n\n    clusters[c1.index] = merged;\n    clusters.splice(c2.index, 1);\n    index[c1.key] = merged; // Update distances with new merged cluster\n\n    for (var _i = 0; _i < clusters.length; _i++) {\n      var cur = clusters[_i];\n\n      if (c1.key === cur.key) {\n        dist = Infinity;\n      } else if (opts.linkage === 'min') {\n        dist = dists[c1.key][cur.key];\n\n        if (dists[c1.key][cur.key] > dists[c2.key][cur.key]) {\n          dist = dists[c2.key][cur.key];\n        }\n      } else if (opts.linkage === 'max') {\n        dist = dists[c1.key][cur.key];\n\n        if (dists[c1.key][cur.key] < dists[c2.key][cur.key]) {\n          dist = dists[c2.key][cur.key];\n        }\n      } else if (opts.linkage === 'mean') {\n        dist = (dists[c1.key][cur.key] * c1.size + dists[c2.key][cur.key] * c2.size) / (c1.size + c2.size);\n      } else {\n        if (opts.mode === 'dendrogram') dist = getDist(cur.value, c1.value);else dist = getDist(cur.value[0], c1.value[0]);\n      }\n\n      dists[c1.key][cur.key] = dists[cur.key][c1.key] = dist; // distance matrix is symmetric\n    } // Update cached mins\n\n\n    for (var _i2 = 0; _i2 < clusters.length; _i2++) {\n      var key1 = clusters[_i2].key;\n\n      if (mins[key1] === c1.key || mins[key1] === c2.key) {\n        var _min = key1;\n\n        for (var j = 0; j < clusters.length; j++) {\n          var key2 = clusters[j].key;\n\n          if (dists[key1][key2] < dists[key1][_min]) {\n            _min = key2;\n          }\n        }\n\n        mins[key1] = _min;\n      }\n\n      clusters[_i2].index = _i2;\n    } // Clean up meta data used for clustering\n\n\n    c1.key = c2.key = c1.index = c2.index = null;\n    return true;\n  };\n\n  var getAllChildren = function getAllChildren(root, arr, cy) {\n    if (!root) return;\n\n    if (root.value) {\n      arr.push(root.value);\n    } else {\n      if (root.left) getAllChildren(root.left, arr);\n      if (root.right) getAllChildren(root.right, arr);\n    }\n  };\n\n  var buildDendrogram = function buildDendrogram(root, cy) {\n    if (!root) return '';\n\n    if (root.left && root.right) {\n      var leftStr = buildDendrogram(root.left, cy);\n      var rightStr = buildDendrogram(root.right, cy);\n      var node = cy.add({\n        group: 'nodes',\n        data: {\n          id: leftStr + ',' + rightStr\n        }\n      });\n      cy.add({\n        group: 'edges',\n        data: {\n          source: leftStr,\n          target: node.id()\n        }\n      });\n      cy.add({\n        group: 'edges',\n        data: {\n          source: rightStr,\n          target: node.id()\n        }\n      });\n      return node.id();\n    } else if (root.value) {\n      return root.value.id();\n    }\n  };\n\n  var buildClustersFromTree = function buildClustersFromTree(root, k, cy) {\n    if (!root) return [];\n    var left = [],\n        right = [],\n        leaves = [];\n\n    if (k === 0) {\n      // don't cut tree, simply return all nodes as 1 single cluster\n      if (root.left) getAllChildren(root.left, left);\n      if (root.right) getAllChildren(root.right, right);\n      leaves = left.concat(right);\n      return [cy.collection(leaves)];\n    } else if (k === 1) {\n      // cut at root\n      if (root.value) {\n        // leaf node\n        return [cy.collection(root.value)];\n      } else {\n        if (root.left) getAllChildren(root.left, left);\n        if (root.right) getAllChildren(root.right, right);\n        return [cy.collection(left), cy.collection(right)];\n      }\n    } else {\n      if (root.value) {\n        return [cy.collection(root.value)];\n      } else {\n        if (root.left) left = buildClustersFromTree(root.left, k - 1, cy);\n        if (root.right) right = buildClustersFromTree(root.right, k - 1, cy);\n        return left.concat(right);\n      }\n    }\n  };\n  /* eslint-enable */\n\n\n  var hierarchicalClustering = function hierarchicalClustering(options) {\n    var cy = this.cy();\n    var nodes = this.nodes(); // Set parameters of algorithm: linkage type, distance metric, etc.\n\n    var opts = setOptions$1(options);\n    var attrs = opts.attributes;\n\n    var getDist = function getDist(n1, n2) {\n      return clusteringDistance(opts.distance, attrs.length, function (i) {\n        return attrs[i](n1);\n      }, function (i) {\n        return attrs[i](n2);\n      }, n1, n2);\n    }; // Begin hierarchical algorithm\n\n\n    var clusters = [];\n    var dists = []; // distances between each pair of clusters\n\n    var mins = []; // closest cluster for each cluster\n\n    var index = []; // hash of all clusters by key\n    // In agglomerative (bottom-up) clustering, each node starts as its own cluster\n\n    for (var n = 0; n < nodes.length; n++) {\n      var cluster = {\n        value: opts.mode === 'dendrogram' ? nodes[n] : [nodes[n]],\n        key: n,\n        index: n\n      };\n      clusters[n] = cluster;\n      index[n] = cluster;\n      dists[n] = [];\n      mins[n] = 0;\n    } // Calculate the distance between each pair of clusters\n\n\n    for (var i = 0; i < clusters.length; i++) {\n      for (var j = 0; j <= i; j++) {\n        var dist = void 0;\n\n        if (opts.mode === 'dendrogram') {\n          // modes store cluster values differently\n          dist = i === j ? Infinity : getDist(clusters[i].value, clusters[j].value);\n        } else {\n          dist = i === j ? Infinity : getDist(clusters[i].value[0], clusters[j].value[0]);\n        }\n\n        dists[i][j] = dist;\n        dists[j][i] = dist;\n\n        if (dist < dists[i][mins[i]]) {\n          mins[i] = j; // Cache mins: closest cluster to cluster i is cluster j\n        }\n      }\n    } // Find the closest pair of clusters and merge them into a single cluster.\n    // Update distances between new cluster and each of the old clusters, and loop until threshold reached.\n\n\n    var merged = mergeClosest(clusters, index, dists, mins, opts);\n\n    while (merged) {\n      merged = mergeClosest(clusters, index, dists, mins, opts);\n    }\n\n    var retClusters; // Dendrogram mode builds the hierarchy and adds intermediary nodes + edges\n    // in addition to returning the clusters.\n\n    if (opts.mode === 'dendrogram') {\n      retClusters = buildClustersFromTree(clusters[0], opts.dendrogramDepth, cy);\n      if (opts.addDendrogram) buildDendrogram(clusters[0], cy);\n    } else {\n      // Regular mode simply returns the clusters\n      retClusters = new Array(clusters.length);\n      clusters.forEach(function (cluster, i) {\n        // Clean up meta data used for clustering\n        cluster.key = cluster.index = null;\n        retClusters[i] = cy.collection(cluster.value);\n      });\n    }\n\n    return retClusters;\n  };\n\n  var hierarchicalClustering$1 = {\n    hierarchicalClustering: hierarchicalClustering,\n    hca: hierarchicalClustering\n  };\n\n  // Implemented by Zoe Xi @zoexi for GSOC 2016\n  var defaults$9 = defaults$g({\n    distance: 'euclidean',\n    // distance metric to compare attributes between two nodes\n    preference: 'median',\n    // suitability of a data point to serve as an exemplar\n    damping: 0.8,\n    // damping factor between [0.5, 1)\n    maxIterations: 1000,\n    // max number of iterations to run\n    minIterations: 100,\n    // min number of iterations to run in order for clustering to stop\n    attributes: [// functions to quantify the similarity between any two points\n      // e.g. node => node.data('weight')\n    ]\n  });\n\n  var setOptions = function setOptions(options) {\n    var dmp = options.damping;\n    var pref = options.preference;\n\n    if (!(0.5 <= dmp && dmp < 1)) {\n      error(\"Damping must range on [0.5, 1).  Got: \".concat(dmp));\n    }\n\n    var validPrefs = ['median', 'mean', 'min', 'max'];\n\n    if (!(validPrefs.some(function (v) {\n      return v === pref;\n    }) || number$1(pref))) {\n      error(\"Preference must be one of [\".concat(validPrefs.map(function (p) {\n        return \"'\".concat(p, \"'\");\n      }).join(', '), \"] or a number.  Got: \").concat(pref));\n    }\n\n    return defaults$9(options);\n  };\n  /* eslint-enable */\n\n\n  var getSimilarity = function getSimilarity(type, n1, n2, attributes) {\n    var attr = function attr(n, i) {\n      return attributes[i](n);\n    }; // nb negative because similarity should have an inverse relationship to distance\n\n\n    return -clusteringDistance(type, attributes.length, function (i) {\n      return attr(n1, i);\n    }, function (i) {\n      return attr(n2, i);\n    }, n1, n2);\n  };\n\n  var getPreference = function getPreference(S, preference) {\n    // larger preference = greater # of clusters\n    var p = null;\n\n    if (preference === 'median') {\n      p = median(S);\n    } else if (preference === 'mean') {\n      p = mean(S);\n    } else if (preference === 'min') {\n      p = min(S);\n    } else if (preference === 'max') {\n      p = max(S);\n    } else {\n      // Custom preference number, as set by user\n      p = preference;\n    }\n\n    return p;\n  };\n\n  var findExemplars = function findExemplars(n, R, A) {\n    var indices = [];\n\n    for (var i = 0; i < n; i++) {\n      if (R[i * n + i] + A[i * n + i] > 0) {\n        indices.push(i);\n      }\n    }\n\n    return indices;\n  };\n\n  var assignClusters = function assignClusters(n, S, exemplars) {\n    var clusters = [];\n\n    for (var i = 0; i < n; i++) {\n      var index = -1;\n      var max = -Infinity;\n\n      for (var ei = 0; ei < exemplars.length; ei++) {\n        var e = exemplars[ei];\n\n        if (S[i * n + e] > max) {\n          index = e;\n          max = S[i * n + e];\n        }\n      }\n\n      if (index > 0) {\n        clusters.push(index);\n      }\n    }\n\n    for (var _ei = 0; _ei < exemplars.length; _ei++) {\n      clusters[exemplars[_ei]] = exemplars[_ei];\n    }\n\n    return clusters;\n  };\n\n  var assign = function assign(n, S, exemplars) {\n    var clusters = assignClusters(n, S, exemplars);\n\n    for (var ei = 0; ei < exemplars.length; ei++) {\n      var ii = [];\n\n      for (var c = 0; c < clusters.length; c++) {\n        if (clusters[c] === exemplars[ei]) {\n          ii.push(c);\n        }\n      }\n\n      var maxI = -1;\n      var maxSum = -Infinity;\n\n      for (var i = 0; i < ii.length; i++) {\n        var sum = 0;\n\n        for (var j = 0; j < ii.length; j++) {\n          sum += S[ii[j] * n + ii[i]];\n        }\n\n        if (sum > maxSum) {\n          maxI = i;\n          maxSum = sum;\n        }\n      }\n\n      exemplars[ei] = ii[maxI];\n    }\n\n    clusters = assignClusters(n, S, exemplars);\n    return clusters;\n  };\n\n  var affinityPropagation = function affinityPropagation(options) {\n    var cy = this.cy();\n    var nodes = this.nodes();\n    var opts = setOptions(options); // Map each node to its position in node array\n\n    var id2position = {};\n\n    for (var i = 0; i < nodes.length; i++) {\n      id2position[nodes[i].id()] = i;\n    } // Begin affinity propagation algorithm\n\n\n    var n; // number of data points\n\n    var n2; // size of matrices\n\n    var S; // similarity matrix (1D array)\n\n    var p; // preference/suitability of a data point to serve as an exemplar\n\n    var R; // responsibility matrix (1D array)\n\n    var A; // availability matrix (1D array)\n\n    n = nodes.length;\n    n2 = n * n; // Initialize and build S similarity matrix\n\n    S = new Array(n2);\n\n    for (var _i = 0; _i < n2; _i++) {\n      S[_i] = -Infinity; // for cases where two data points shouldn't be linked together\n    }\n\n    for (var _i2 = 0; _i2 < n; _i2++) {\n      for (var j = 0; j < n; j++) {\n        if (_i2 !== j) {\n          S[_i2 * n + j] = getSimilarity(opts.distance, nodes[_i2], nodes[j], opts.attributes);\n        }\n      }\n    } // Place preferences on the diagonal of S\n\n\n    p = getPreference(S, opts.preference);\n\n    for (var _i3 = 0; _i3 < n; _i3++) {\n      S[_i3 * n + _i3] = p;\n    } // Initialize R responsibility matrix\n\n\n    R = new Array(n2);\n\n    for (var _i4 = 0; _i4 < n2; _i4++) {\n      R[_i4] = 0.0;\n    } // Initialize A availability matrix\n\n\n    A = new Array(n2);\n\n    for (var _i5 = 0; _i5 < n2; _i5++) {\n      A[_i5] = 0.0;\n    }\n\n    var old = new Array(n);\n    var Rp = new Array(n);\n    var se = new Array(n);\n\n    for (var _i6 = 0; _i6 < n; _i6++) {\n      old[_i6] = 0.0;\n      Rp[_i6] = 0.0;\n      se[_i6] = 0;\n    }\n\n    var e = new Array(n * opts.minIterations);\n\n    for (var _i7 = 0; _i7 < e.length; _i7++) {\n      e[_i7] = 0;\n    }\n\n    var iter;\n\n    for (iter = 0; iter < opts.maxIterations; iter++) {\n      // main algorithmic loop\n      // Update R responsibility matrix\n      for (var _i8 = 0; _i8 < n; _i8++) {\n        var max = -Infinity,\n            max2 = -Infinity,\n            maxI = -1,\n            AS = 0.0;\n\n        for (var _j = 0; _j < n; _j++) {\n          old[_j] = R[_i8 * n + _j];\n          AS = A[_i8 * n + _j] + S[_i8 * n + _j];\n\n          if (AS >= max) {\n            max2 = max;\n            max = AS;\n            maxI = _j;\n          } else if (AS > max2) {\n            max2 = AS;\n          }\n        }\n\n        for (var _j2 = 0; _j2 < n; _j2++) {\n          R[_i8 * n + _j2] = (1 - opts.damping) * (S[_i8 * n + _j2] - max) + opts.damping * old[_j2];\n        }\n\n        R[_i8 * n + maxI] = (1 - opts.damping) * (S[_i8 * n + maxI] - max2) + opts.damping * old[maxI];\n      } // Update A availability matrix\n\n\n      for (var _i9 = 0; _i9 < n; _i9++) {\n        var sum = 0;\n\n        for (var _j3 = 0; _j3 < n; _j3++) {\n          old[_j3] = A[_j3 * n + _i9];\n          Rp[_j3] = Math.max(0, R[_j3 * n + _i9]);\n          sum += Rp[_j3];\n        }\n\n        sum -= Rp[_i9];\n        Rp[_i9] = R[_i9 * n + _i9];\n        sum += Rp[_i9];\n\n        for (var _j4 = 0; _j4 < n; _j4++) {\n          A[_j4 * n + _i9] = (1 - opts.damping) * Math.min(0, sum - Rp[_j4]) + opts.damping * old[_j4];\n        }\n\n        A[_i9 * n + _i9] = (1 - opts.damping) * (sum - Rp[_i9]) + opts.damping * old[_i9];\n      } // Check for convergence\n\n\n      var K = 0;\n\n      for (var _i10 = 0; _i10 < n; _i10++) {\n        var E = A[_i10 * n + _i10] + R[_i10 * n + _i10] > 0 ? 1 : 0;\n        e[iter % opts.minIterations * n + _i10] = E;\n        K += E;\n      }\n\n      if (K > 0 && (iter >= opts.minIterations - 1 || iter == opts.maxIterations - 1)) {\n        var _sum = 0;\n\n        for (var _i11 = 0; _i11 < n; _i11++) {\n          se[_i11] = 0;\n\n          for (var _j5 = 0; _j5 < opts.minIterations; _j5++) {\n            se[_i11] += e[_j5 * n + _i11];\n          }\n\n          if (se[_i11] === 0 || se[_i11] === opts.minIterations) {\n            _sum++;\n          }\n        }\n\n        if (_sum === n) {\n          // then we have convergence\n          break;\n        }\n      }\n    } // Identify exemplars (cluster centers)\n\n\n    var exemplarsIndices = findExemplars(n, R, A); // Assign nodes to clusters\n\n    var clusterIndices = assign(n, S, exemplarsIndices);\n    var clusters = {};\n\n    for (var c = 0; c < exemplarsIndices.length; c++) {\n      clusters[exemplarsIndices[c]] = [];\n    }\n\n    for (var _i12 = 0; _i12 < nodes.length; _i12++) {\n      var pos = id2position[nodes[_i12].id()];\n\n      var clusterIndex = clusterIndices[pos];\n\n      if (clusterIndex != null) {\n        // the node may have not been assigned a cluster if no valid attributes were specified\n        clusters[clusterIndex].push(nodes[_i12]);\n      }\n    }\n\n    var retClusters = new Array(exemplarsIndices.length);\n\n    for (var _c = 0; _c < exemplarsIndices.length; _c++) {\n      retClusters[_c] = cy.collection(clusters[exemplarsIndices[_c]]);\n    }\n\n    return retClusters;\n  };\n\n  var affinityPropagation$1 = {\n    affinityPropagation: affinityPropagation,\n    ap: affinityPropagation\n  };\n\n  var hierholzerDefaults = defaults$g({\n    root: undefined,\n    directed: false\n  });\n  var elesfn$k = {\n    hierholzer: function hierholzer(options) {\n      if (!plainObject(options)) {\n        var args = arguments;\n        options = {\n          root: args[0],\n          directed: args[1]\n        };\n      }\n\n      var _hierholzerDefaults = hierholzerDefaults(options),\n          root = _hierholzerDefaults.root,\n          directed = _hierholzerDefaults.directed;\n\n      var eles = this;\n      var dflag = false;\n      var oddIn;\n      var oddOut;\n      var startVertex;\n      if (root) startVertex = string(root) ? this.filter(root)[0].id() : root[0].id();\n      var nodes = {};\n      var edges = {};\n\n      if (directed) {\n        eles.forEach(function (ele) {\n          var id = ele.id();\n\n          if (ele.isNode()) {\n            var ind = ele.indegree(true);\n            var outd = ele.outdegree(true);\n            var d1 = ind - outd;\n            var d2 = outd - ind;\n\n            if (d1 == 1) {\n              if (oddIn) dflag = true;else oddIn = id;\n            } else if (d2 == 1) {\n              if (oddOut) dflag = true;else oddOut = id;\n            } else if (d2 > 1 || d1 > 1) {\n              dflag = true;\n            }\n\n            nodes[id] = [];\n            ele.outgoers().forEach(function (e) {\n              if (e.isEdge()) nodes[id].push(e.id());\n            });\n          } else {\n            edges[id] = [undefined, ele.target().id()];\n          }\n        });\n      } else {\n        eles.forEach(function (ele) {\n          var id = ele.id();\n\n          if (ele.isNode()) {\n            var d = ele.degree(true);\n\n            if (d % 2) {\n              if (!oddIn) oddIn = id;else if (!oddOut) oddOut = id;else dflag = true;\n            }\n\n            nodes[id] = [];\n            ele.connectedEdges().forEach(function (e) {\n              return nodes[id].push(e.id());\n            });\n          } else {\n            edges[id] = [ele.source().id(), ele.target().id()];\n          }\n        });\n      }\n\n      var result = {\n        found: false,\n        trail: undefined\n      };\n      if (dflag) return result;else if (oddOut && oddIn) {\n        if (directed) {\n          if (startVertex && oddOut != startVertex) {\n            return result;\n          }\n\n          startVertex = oddOut;\n        } else {\n          if (startVertex && oddOut != startVertex && oddIn != startVertex) {\n            return result;\n          } else if (!startVertex) {\n            startVertex = oddOut;\n          }\n        }\n      } else {\n        if (!startVertex) startVertex = eles[0].id();\n      }\n\n      var walk = function walk(v) {\n        var currentNode = v;\n        var subtour = [v];\n        var adj, adjTail, adjHead;\n\n        while (nodes[currentNode].length) {\n          adj = nodes[currentNode].shift();\n          adjTail = edges[adj][0];\n          adjHead = edges[adj][1];\n\n          if (currentNode != adjHead) {\n            nodes[adjHead] = nodes[adjHead].filter(function (e) {\n              return e != adj;\n            });\n            currentNode = adjHead;\n          } else if (!directed && currentNode != adjTail) {\n            nodes[adjTail] = nodes[adjTail].filter(function (e) {\n              return e != adj;\n            });\n            currentNode = adjTail;\n          }\n\n          subtour.unshift(adj);\n          subtour.unshift(currentNode);\n        }\n\n        return subtour;\n      };\n\n      var trail = [];\n      var subtour = [];\n      subtour = walk(startVertex);\n\n      while (subtour.length != 1) {\n        if (nodes[subtour[0]].length == 0) {\n          trail.unshift(eles.getElementById(subtour.shift()));\n          trail.unshift(eles.getElementById(subtour.shift()));\n        } else {\n          subtour = walk(subtour.shift()).concat(subtour);\n        }\n      }\n\n      trail.unshift(eles.getElementById(subtour.shift())); // final node\n\n      for (var d in nodes) {\n        if (nodes[d].length) {\n          return result;\n        }\n      }\n\n      result.found = true;\n      result.trail = this.spawn(trail, true);\n      return result;\n    }\n  };\n\n  var hopcroftTarjanBiconnected = function hopcroftTarjanBiconnected() {\n    var eles = this;\n    var nodes = {};\n    var id = 0;\n    var edgeCount = 0;\n    var components = [];\n    var stack = [];\n    var visitedEdges = {};\n\n    var buildComponent = function buildComponent(x, y) {\n      var i = stack.length - 1;\n      var cutset = [];\n      var component = eles.spawn();\n\n      while (stack[i].x != x || stack[i].y != y) {\n        cutset.push(stack.pop().edge);\n        i--;\n      }\n\n      cutset.push(stack.pop().edge);\n      cutset.forEach(function (edge) {\n        var connectedNodes = edge.connectedNodes().intersection(eles);\n        component.merge(edge);\n        connectedNodes.forEach(function (node) {\n          var nodeId = node.id();\n          var connectedEdges = node.connectedEdges().intersection(eles);\n          component.merge(node);\n\n          if (!nodes[nodeId].cutVertex) {\n            component.merge(connectedEdges);\n          } else {\n            component.merge(connectedEdges.filter(function (edge) {\n              return edge.isLoop();\n            }));\n          }\n        });\n      });\n      components.push(component);\n    };\n\n    var biconnectedSearch = function biconnectedSearch(root, currentNode, parent) {\n      if (root === parent) edgeCount += 1;\n      nodes[currentNode] = {\n        id: id,\n        low: id++,\n        cutVertex: false\n      };\n      var edges = eles.getElementById(currentNode).connectedEdges().intersection(eles);\n\n      if (edges.size() === 0) {\n        components.push(eles.spawn(eles.getElementById(currentNode)));\n      } else {\n        var sourceId, targetId, otherNodeId, edgeId;\n        edges.forEach(function (edge) {\n          sourceId = edge.source().id();\n          targetId = edge.target().id();\n          otherNodeId = sourceId === currentNode ? targetId : sourceId;\n\n          if (otherNodeId !== parent) {\n            edgeId = edge.id();\n\n            if (!visitedEdges[edgeId]) {\n              visitedEdges[edgeId] = true;\n              stack.push({\n                x: currentNode,\n                y: otherNodeId,\n                edge: edge\n              });\n            }\n\n            if (!(otherNodeId in nodes)) {\n              biconnectedSearch(root, otherNodeId, currentNode);\n              nodes[currentNode].low = Math.min(nodes[currentNode].low, nodes[otherNodeId].low);\n\n              if (nodes[currentNode].id <= nodes[otherNodeId].low) {\n                nodes[currentNode].cutVertex = true;\n                buildComponent(currentNode, otherNodeId);\n              }\n            } else {\n              nodes[currentNode].low = Math.min(nodes[currentNode].low, nodes[otherNodeId].id);\n            }\n          }\n        });\n      }\n    };\n\n    eles.forEach(function (ele) {\n      if (ele.isNode()) {\n        var nodeId = ele.id();\n\n        if (!(nodeId in nodes)) {\n          edgeCount = 0;\n          biconnectedSearch(nodeId, nodeId);\n          nodes[nodeId].cutVertex = edgeCount > 1;\n        }\n      }\n    });\n    var cutVertices = Object.keys(nodes).filter(function (id) {\n      return nodes[id].cutVertex;\n    }).map(function (id) {\n      return eles.getElementById(id);\n    });\n    return {\n      cut: eles.spawn(cutVertices),\n      components: components\n    };\n  };\n\n  var hopcroftTarjanBiconnected$1 = {\n    hopcroftTarjanBiconnected: hopcroftTarjanBiconnected,\n    htbc: hopcroftTarjanBiconnected,\n    htb: hopcroftTarjanBiconnected,\n    hopcroftTarjanBiconnectedComponents: hopcroftTarjanBiconnected\n  };\n\n  var tarjanStronglyConnected = function tarjanStronglyConnected() {\n    var eles = this;\n    var nodes = {};\n    var index = 0;\n    var components = [];\n    var stack = [];\n    var cut = eles.spawn(eles);\n\n    var stronglyConnectedSearch = function stronglyConnectedSearch(sourceNodeId) {\n      stack.push(sourceNodeId);\n      nodes[sourceNodeId] = {\n        index: index,\n        low: index++,\n        explored: false\n      };\n      var connectedEdges = eles.getElementById(sourceNodeId).connectedEdges().intersection(eles);\n      connectedEdges.forEach(function (edge) {\n        var targetNodeId = edge.target().id();\n\n        if (targetNodeId !== sourceNodeId) {\n          if (!(targetNodeId in nodes)) {\n            stronglyConnectedSearch(targetNodeId);\n          }\n\n          if (!nodes[targetNodeId].explored) {\n            nodes[sourceNodeId].low = Math.min(nodes[sourceNodeId].low, nodes[targetNodeId].low);\n          }\n        }\n      });\n\n      if (nodes[sourceNodeId].index === nodes[sourceNodeId].low) {\n        var componentNodes = eles.spawn();\n\n        for (;;) {\n          var nodeId = stack.pop();\n          componentNodes.merge(eles.getElementById(nodeId));\n          nodes[nodeId].low = nodes[sourceNodeId].index;\n          nodes[nodeId].explored = true;\n\n          if (nodeId === sourceNodeId) {\n            break;\n          }\n        }\n\n        var componentEdges = componentNodes.edgesWith(componentNodes);\n        var component = componentNodes.merge(componentEdges);\n        components.push(component);\n        cut = cut.difference(component);\n      }\n    };\n\n    eles.forEach(function (ele) {\n      if (ele.isNode()) {\n        var nodeId = ele.id();\n\n        if (!(nodeId in nodes)) {\n          stronglyConnectedSearch(nodeId);\n        }\n      }\n    });\n    return {\n      cut: cut,\n      components: components\n    };\n  };\n\n  var tarjanStronglyConnected$1 = {\n    tarjanStronglyConnected: tarjanStronglyConnected,\n    tsc: tarjanStronglyConnected,\n    tscc: tarjanStronglyConnected,\n    tarjanStronglyConnectedComponents: tarjanStronglyConnected\n  };\n\n  var elesfn$j = {};\n  [elesfn$v, elesfn$u, elesfn$t, elesfn$s, elesfn$r, elesfn$q, elesfn$p, elesfn$o, elesfn$n, elesfn$m, elesfn$l, markovClustering$1, kClustering, hierarchicalClustering$1, affinityPropagation$1, elesfn$k, hopcroftTarjanBiconnected$1, tarjanStronglyConnected$1].forEach(function (props) {\n    extend(elesfn$j, props);\n  });\n\n  /*!\n  Embeddable Minimum Strictly-Compliant Promises/A+ 1.1.1 Thenable\n  Copyright (c) 2013-2014 Ralf S. Engelschall (http://engelschall.com)\n  Licensed under The MIT License (http://opensource.org/licenses/MIT)\n  */\n\n  /*  promise states [Promises/A+ 2.1]  */\n  var STATE_PENDING = 0;\n  /*  [Promises/A+ 2.1.1]  */\n\n  var STATE_FULFILLED = 1;\n  /*  [Promises/A+ 2.1.2]  */\n\n  var STATE_REJECTED = 2;\n  /*  [Promises/A+ 2.1.3]  */\n\n  /*  promise object constructor  */\n\n  var api = function api(executor) {\n    /*  optionally support non-constructor/plain-function call  */\n    if (!(this instanceof api)) return new api(executor);\n    /*  initialize object  */\n\n    this.id = 'Thenable/1.0.7';\n    this.state = STATE_PENDING;\n    /*  initial state  */\n\n    this.fulfillValue = undefined;\n    /*  initial value  */\n\n    /*  [Promises/A+ 1.3, 2.1.2.2]  */\n\n    this.rejectReason = undefined;\n    /*  initial reason */\n\n    /*  [Promises/A+ 1.5, 2.1.3.2]  */\n\n    this.onFulfilled = [];\n    /*  initial handlers  */\n\n    this.onRejected = [];\n    /*  initial handlers  */\n\n    /*  provide optional information-hiding proxy  */\n\n    this.proxy = {\n      then: this.then.bind(this)\n    };\n    /*  support optional executor function  */\n\n    if (typeof executor === 'function') executor.call(this, this.fulfill.bind(this), this.reject.bind(this));\n  };\n  /*  promise API methods  */\n\n\n  api.prototype = {\n    /*  promise resolving methods  */\n    fulfill: function fulfill(value) {\n      return deliver(this, STATE_FULFILLED, 'fulfillValue', value);\n    },\n    reject: function reject(value) {\n      return deliver(this, STATE_REJECTED, 'rejectReason', value);\n    },\n\n    /*  \"The then Method\" [Promises/A+ 1.1, 1.2, 2.2]  */\n    then: function then(onFulfilled, onRejected) {\n      var curr = this;\n      var next = new api();\n      /*  [Promises/A+ 2.2.7]  */\n\n      curr.onFulfilled.push(resolver(onFulfilled, next, 'fulfill'));\n      /*  [Promises/A+ 2.2.2/2.2.6]  */\n\n      curr.onRejected.push(resolver(onRejected, next, 'reject'));\n      /*  [Promises/A+ 2.2.3/2.2.6]  */\n\n      execute(curr);\n      return next.proxy;\n      /*  [Promises/A+ 2.2.7, 3.3]  */\n    }\n  };\n  /*  deliver an action  */\n\n  var deliver = function deliver(curr, state, name, value) {\n    if (curr.state === STATE_PENDING) {\n      curr.state = state;\n      /*  [Promises/A+ 2.1.2.1, 2.1.3.1]  */\n\n      curr[name] = value;\n      /*  [Promises/A+ 2.1.2.2, 2.1.3.2]  */\n\n      execute(curr);\n    }\n\n    return curr;\n  };\n  /*  execute all handlers  */\n\n\n  var execute = function execute(curr) {\n    if (curr.state === STATE_FULFILLED) execute_handlers(curr, 'onFulfilled', curr.fulfillValue);else if (curr.state === STATE_REJECTED) execute_handlers(curr, 'onRejected', curr.rejectReason);\n  };\n  /*  execute particular set of handlers  */\n\n\n  var execute_handlers = function execute_handlers(curr, name, value) {\n    /* global setImmediate: true */\n\n    /* global setTimeout: true */\n\n    /*  short-circuit processing  */\n    if (curr[name].length === 0) return;\n    /*  iterate over all handlers, exactly once  */\n\n    var handlers = curr[name];\n    curr[name] = [];\n    /*  [Promises/A+ 2.2.2.3, 2.2.3.3]  */\n\n    var func = function func() {\n      for (var i = 0; i < handlers.length; i++) {\n        handlers[i](value);\n      }\n      /*  [Promises/A+ 2.2.5]  */\n\n    };\n    /*  execute procedure asynchronously  */\n\n    /*  [Promises/A+ 2.2.4, 3.1]  */\n\n\n    if (typeof setImmediate === 'function') setImmediate(func);else setTimeout(func, 0);\n  };\n  /*  generate a resolver function  */\n\n\n  var resolver = function resolver(cb, next, method) {\n    return function (value) {\n      if (typeof cb !== 'function')\n        /*  [Promises/A+ 2.2.1, 2.2.7.3, 2.2.7.4]  */\n        next[method].call(next, value);\n        /*  [Promises/A+ 2.2.7.3, 2.2.7.4]  */\n      else {\n        var result;\n\n        try {\n          result = cb(value);\n        }\n        /*  [Promises/A+ 2.2.2.1, 2.2.3.1, 2.2.5, 3.2]  */\n        catch (e) {\n          next.reject(e);\n          /*  [Promises/A+ 2.2.7.2]  */\n\n          return;\n        }\n\n        resolve(next, result);\n        /*  [Promises/A+ 2.2.7.1]  */\n      }\n    };\n  };\n  /*  \"Promise Resolution Procedure\"  */\n\n  /*  [Promises/A+ 2.3]  */\n\n\n  var resolve = function resolve(promise, x) {\n    /*  sanity check arguments  */\n\n    /*  [Promises/A+ 2.3.1]  */\n    if (promise === x || promise.proxy === x) {\n      promise.reject(new TypeError('cannot resolve promise with itself'));\n      return;\n    }\n    /*  surgically check for a \"then\" method\n      (mainly to just call the \"getter\" of \"then\" only once)  */\n\n\n    var then;\n\n    if (_typeof(x) === 'object' && x !== null || typeof x === 'function') {\n      try {\n        then = x.then;\n      }\n      /*  [Promises/A+ 2.3.3.1, 3.5]  */\n      catch (e) {\n        promise.reject(e);\n        /*  [Promises/A+ 2.3.3.2]  */\n\n        return;\n      }\n    }\n    /*  handle own Thenables    [Promises/A+ 2.3.2]\n      and similar \"thenables\" [Promises/A+ 2.3.3]  */\n\n\n    if (typeof then === 'function') {\n      var resolved = false;\n\n      try {\n        /*  call retrieved \"then\" method */\n\n        /*  [Promises/A+ 2.3.3.3]  */\n        then.call(x,\n        /*  resolvePromise  */\n\n        /*  [Promises/A+ 2.3.3.3.1]  */\n        function (y) {\n          if (resolved) return;\n          resolved = true;\n          /*  [Promises/A+ 2.3.3.3.3]  */\n\n          if (y === x)\n            /*  [Promises/A+ 3.6]  */\n            promise.reject(new TypeError('circular thenable chain'));else resolve(promise, y);\n        },\n        /*  rejectPromise  */\n\n        /*  [Promises/A+ 2.3.3.3.2]  */\n        function (r) {\n          if (resolved) return;\n          resolved = true;\n          /*  [Promises/A+ 2.3.3.3.3]  */\n\n          promise.reject(r);\n        });\n      } catch (e) {\n        if (!resolved)\n          /*  [Promises/A+ 2.3.3.3.3]  */\n          promise.reject(e);\n        /*  [Promises/A+ 2.3.3.3.4]  */\n      }\n\n      return;\n    }\n    /*  handle other values  */\n\n\n    promise.fulfill(x);\n    /*  [Promises/A+ 2.3.4, 2.3.3.4]  */\n  }; // so we always have Promise.all()\n\n\n  api.all = function (ps) {\n    return new api(function (resolveAll, rejectAll) {\n      var vals = new Array(ps.length);\n      var doneCount = 0;\n\n      var fulfill = function fulfill(i, val) {\n        vals[i] = val;\n        doneCount++;\n\n        if (doneCount === ps.length) {\n          resolveAll(vals);\n        }\n      };\n\n      for (var i = 0; i < ps.length; i++) {\n        (function (i) {\n          var p = ps[i];\n          var isPromise = p != null && p.then != null;\n\n          if (isPromise) {\n            p.then(function (val) {\n              fulfill(i, val);\n            }, function (err) {\n              rejectAll(err);\n            });\n          } else {\n            var val = p;\n            fulfill(i, val);\n          }\n        })(i);\n      }\n    });\n  };\n\n  api.resolve = function (val) {\n    return new api(function (resolve, reject) {\n      resolve(val);\n    });\n  };\n\n  api.reject = function (val) {\n    return new api(function (resolve, reject) {\n      reject(val);\n    });\n  };\n\n  var Promise$1 = typeof Promise !== 'undefined' ? Promise : api; // eslint-disable-line no-undef\n\n  var Animation = function Animation(target, opts, opts2) {\n    var isCore = core(target);\n    var isEle = !isCore;\n\n    var _p = this._private = extend({\n      duration: 1000\n    }, opts, opts2);\n\n    _p.target = target;\n    _p.style = _p.style || _p.css;\n    _p.started = false;\n    _p.playing = false;\n    _p.hooked = false;\n    _p.applying = false;\n    _p.progress = 0;\n    _p.completes = [];\n    _p.frames = [];\n\n    if (_p.complete && fn$6(_p.complete)) {\n      _p.completes.push(_p.complete);\n    }\n\n    if (isEle) {\n      var pos = target.position();\n      _p.startPosition = _p.startPosition || {\n        x: pos.x,\n        y: pos.y\n      };\n      _p.startStyle = _p.startStyle || target.cy().style().getAnimationStartStyle(target, _p.style);\n    }\n\n    if (isCore) {\n      var pan = target.pan();\n      _p.startPan = {\n        x: pan.x,\n        y: pan.y\n      };\n      _p.startZoom = target.zoom();\n    } // for future timeline/animations impl\n\n\n    this.length = 1;\n    this[0] = this;\n  };\n\n  var anifn = Animation.prototype;\n  extend(anifn, {\n    instanceString: function instanceString() {\n      return 'animation';\n    },\n    hook: function hook() {\n      var _p = this._private;\n\n      if (!_p.hooked) {\n        // add to target's animation queue\n        var q;\n        var tAni = _p.target._private.animation;\n\n        if (_p.queue) {\n          q = tAni.queue;\n        } else {\n          q = tAni.current;\n        }\n\n        q.push(this); // add to the animation loop pool\n\n        if (elementOrCollection(_p.target)) {\n          _p.target.cy().addToAnimationPool(_p.target);\n        }\n\n        _p.hooked = true;\n      }\n\n      return this;\n    },\n    play: function play() {\n      var _p = this._private; // autorewind\n\n      if (_p.progress === 1) {\n        _p.progress = 0;\n      }\n\n      _p.playing = true;\n      _p.started = false; // needs to be started by animation loop\n\n      _p.stopped = false;\n      this.hook(); // the animation loop will start the animation...\n\n      return this;\n    },\n    playing: function playing() {\n      return this._private.playing;\n    },\n    apply: function apply() {\n      var _p = this._private;\n      _p.applying = true;\n      _p.started = false; // needs to be started by animation loop\n\n      _p.stopped = false;\n      this.hook(); // the animation loop will apply the animation at this progress\n\n      return this;\n    },\n    applying: function applying() {\n      return this._private.applying;\n    },\n    pause: function pause() {\n      var _p = this._private;\n      _p.playing = false;\n      _p.started = false;\n      return this;\n    },\n    stop: function stop() {\n      var _p = this._private;\n      _p.playing = false;\n      _p.started = false;\n      _p.stopped = true; // to be removed from animation queues\n\n      return this;\n    },\n    rewind: function rewind() {\n      return this.progress(0);\n    },\n    fastforward: function fastforward() {\n      return this.progress(1);\n    },\n    time: function time(t) {\n      var _p = this._private;\n\n      if (t === undefined) {\n        return _p.progress * _p.duration;\n      } else {\n        return this.progress(t / _p.duration);\n      }\n    },\n    progress: function progress(p) {\n      var _p = this._private;\n      var wasPlaying = _p.playing;\n\n      if (p === undefined) {\n        return _p.progress;\n      } else {\n        if (wasPlaying) {\n          this.pause();\n        }\n\n        _p.progress = p;\n        _p.started = false;\n\n        if (wasPlaying) {\n          this.play();\n        }\n      }\n\n      return this;\n    },\n    completed: function completed() {\n      return this._private.progress === 1;\n    },\n    reverse: function reverse() {\n      var _p = this._private;\n      var wasPlaying = _p.playing;\n\n      if (wasPlaying) {\n        this.pause();\n      }\n\n      _p.progress = 1 - _p.progress;\n      _p.started = false;\n\n      var swap = function swap(a, b) {\n        var _pa = _p[a];\n\n        if (_pa == null) {\n          return;\n        }\n\n        _p[a] = _p[b];\n        _p[b] = _pa;\n      };\n\n      swap('zoom', 'startZoom');\n      swap('pan', 'startPan');\n      swap('position', 'startPosition'); // swap styles\n\n      if (_p.style) {\n        for (var i = 0; i < _p.style.length; i++) {\n          var prop = _p.style[i];\n          var name = prop.name;\n          var startStyleProp = _p.startStyle[name];\n          _p.startStyle[name] = prop;\n          _p.style[i] = startStyleProp;\n        }\n      }\n\n      if (wasPlaying) {\n        this.play();\n      }\n\n      return this;\n    },\n    promise: function promise(type) {\n      var _p = this._private;\n      var arr;\n\n      switch (type) {\n        case 'frame':\n          arr = _p.frames;\n          break;\n\n        default:\n        case 'complete':\n        case 'completed':\n          arr = _p.completes;\n      }\n\n      return new Promise$1(function (resolve, reject) {\n        arr.push(function () {\n          resolve();\n        });\n      });\n    }\n  });\n  anifn.complete = anifn.completed;\n  anifn.run = anifn.play;\n  anifn.running = anifn.playing;\n\n  var define$3 = {\n    animated: function animated() {\n      return function animatedImpl() {\n        var self = this;\n        var selfIsArrayLike = self.length !== undefined;\n        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n\n        var cy = this._private.cy || this;\n\n        if (!cy.styleEnabled()) {\n          return false;\n        }\n\n        var ele = all[0];\n\n        if (ele) {\n          return ele._private.animation.current.length > 0;\n        }\n      };\n    },\n    // animated\n    clearQueue: function clearQueue() {\n      return function clearQueueImpl() {\n        var self = this;\n        var selfIsArrayLike = self.length !== undefined;\n        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n\n        var cy = this._private.cy || this;\n\n        if (!cy.styleEnabled()) {\n          return this;\n        }\n\n        for (var i = 0; i < all.length; i++) {\n          var ele = all[i];\n          ele._private.animation.queue = [];\n        }\n\n        return this;\n      };\n    },\n    // clearQueue\n    delay: function delay() {\n      return function delayImpl(time, complete) {\n        var cy = this._private.cy || this;\n\n        if (!cy.styleEnabled()) {\n          return this;\n        }\n\n        return this.animate({\n          delay: time,\n          duration: time,\n          complete: complete\n        });\n      };\n    },\n    // delay\n    delayAnimation: function delayAnimation() {\n      return function delayAnimationImpl(time, complete) {\n        var cy = this._private.cy || this;\n\n        if (!cy.styleEnabled()) {\n          return this;\n        }\n\n        return this.animation({\n          delay: time,\n          duration: time,\n          complete: complete\n        });\n      };\n    },\n    // delay\n    animation: function animation() {\n      return function animationImpl(properties, params) {\n        var self = this;\n        var selfIsArrayLike = self.length !== undefined;\n        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n\n        var cy = this._private.cy || this;\n        var isCore = !selfIsArrayLike;\n        var isEles = !isCore;\n\n        if (!cy.styleEnabled()) {\n          return this;\n        }\n\n        var style = cy.style();\n        properties = extend({}, properties, params);\n        var propertiesEmpty = Object.keys(properties).length === 0;\n\n        if (propertiesEmpty) {\n          return new Animation(all[0], properties); // nothing to animate\n        }\n\n        if (properties.duration === undefined) {\n          properties.duration = 400;\n        }\n\n        switch (properties.duration) {\n          case 'slow':\n            properties.duration = 600;\n            break;\n\n          case 'fast':\n            properties.duration = 200;\n            break;\n        }\n\n        if (isEles) {\n          properties.style = style.getPropsList(properties.style || properties.css);\n          properties.css = undefined;\n        }\n\n        if (isEles && properties.renderedPosition != null) {\n          var rpos = properties.renderedPosition;\n          var pan = cy.pan();\n          var zoom = cy.zoom();\n          properties.position = renderedToModelPosition(rpos, zoom, pan);\n        } // override pan w/ panBy if set\n\n\n        if (isCore && properties.panBy != null) {\n          var panBy = properties.panBy;\n          var cyPan = cy.pan();\n          properties.pan = {\n            x: cyPan.x + panBy.x,\n            y: cyPan.y + panBy.y\n          };\n        } // override pan w/ center if set\n\n\n        var center = properties.center || properties.centre;\n\n        if (isCore && center != null) {\n          var centerPan = cy.getCenterPan(center.eles, properties.zoom);\n\n          if (centerPan != null) {\n            properties.pan = centerPan;\n          }\n        } // override pan & zoom w/ fit if set\n\n\n        if (isCore && properties.fit != null) {\n          var fit = properties.fit;\n          var fitVp = cy.getFitViewport(fit.eles || fit.boundingBox, fit.padding);\n\n          if (fitVp != null) {\n            properties.pan = fitVp.pan;\n            properties.zoom = fitVp.zoom;\n          }\n        } // override zoom (& potentially pan) w/ zoom obj if set\n\n\n        if (isCore && plainObject(properties.zoom)) {\n          var vp = cy.getZoomedViewport(properties.zoom);\n\n          if (vp != null) {\n            if (vp.zoomed) {\n              properties.zoom = vp.zoom;\n            }\n\n            if (vp.panned) {\n              properties.pan = vp.pan;\n            }\n          } else {\n            properties.zoom = null; // an inavalid zoom (e.g. no delta) gets automatically destroyed\n          }\n        }\n\n        return new Animation(all[0], properties);\n      };\n    },\n    // animate\n    animate: function animate() {\n      return function animateImpl(properties, params) {\n        var self = this;\n        var selfIsArrayLike = self.length !== undefined;\n        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n\n        var cy = this._private.cy || this;\n\n        if (!cy.styleEnabled()) {\n          return this;\n        }\n\n        if (params) {\n          properties = extend({}, properties, params);\n        } // manually hook and run the animation\n\n\n        for (var i = 0; i < all.length; i++) {\n          var ele = all[i];\n          var queue = ele.animated() && (properties.queue === undefined || properties.queue);\n          var ani = ele.animation(properties, queue ? {\n            queue: true\n          } : undefined);\n          ani.play();\n        }\n\n        return this; // chaining\n      };\n    },\n    // animate\n    stop: function stop() {\n      return function stopImpl(clearQueue, jumpToEnd) {\n        var self = this;\n        var selfIsArrayLike = self.length !== undefined;\n        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n\n        var cy = this._private.cy || this;\n\n        if (!cy.styleEnabled()) {\n          return this;\n        }\n\n        for (var i = 0; i < all.length; i++) {\n          var ele = all[i];\n          var _p = ele._private;\n          var anis = _p.animation.current;\n\n          for (var j = 0; j < anis.length; j++) {\n            var ani = anis[j];\n            var ani_p = ani._private;\n\n            if (jumpToEnd) {\n              // next iteration of the animation loop, the animation\n              // will go straight to the end and be removed\n              ani_p.duration = 0;\n            }\n          } // clear the queue of future animations\n\n\n          if (clearQueue) {\n            _p.animation.queue = [];\n          }\n\n          if (!jumpToEnd) {\n            _p.animation.current = [];\n          }\n        } // we have to notify (the animation loop doesn't do it for us on `stop`)\n\n\n        cy.notify('draw');\n        return this;\n      };\n    } // stop\n\n  }; // define\n\n  /**\n   * Checks if `value` is classified as an `Array` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n   * @example\n   *\n   * _.isArray([1, 2, 3]);\n   * // => true\n   *\n   * _.isArray(document.body.children);\n   * // => false\n   *\n   * _.isArray('abc');\n   * // => false\n   *\n   * _.isArray(_.noop);\n   * // => false\n   */\n  var isArray = Array.isArray;\n\n  var isArray_1 = isArray;\n\n  /** Used to match property names within property paths. */\n  var reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n      reIsPlainProp = /^\\w*$/;\n\n  /**\n   * Checks if `value` is a property name and not a property path.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @param {Object} [object] The object to query keys on.\n   * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n   */\n  function isKey(value, object) {\n    if (isArray_1(value)) {\n      return false;\n    }\n    var type = typeof value;\n    if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n        value == null || isSymbol_1(value)) {\n      return true;\n    }\n    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n      (object != null && value in Object(object));\n  }\n\n  var _isKey = isKey;\n\n  /** `Object#toString` result references. */\n  var asyncTag = '[object AsyncFunction]',\n      funcTag = '[object Function]',\n      genTag = '[object GeneratorFunction]',\n      proxyTag = '[object Proxy]';\n\n  /**\n   * Checks if `value` is classified as a `Function` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n   * @example\n   *\n   * _.isFunction(_);\n   * // => true\n   *\n   * _.isFunction(/abc/);\n   * // => false\n   */\n  function isFunction(value) {\n    if (!isObject_1(value)) {\n      return false;\n    }\n    // The use of `Object#toString` avoids issues with the `typeof` operator\n    // in Safari 9 which returns 'object' for typed arrays and other constructors.\n    var tag = _baseGetTag(value);\n    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n  }\n\n  var isFunction_1 = isFunction;\n\n  /** Used to detect overreaching core-js shims. */\n  var coreJsData = _root['__core-js_shared__'];\n\n  var _coreJsData = coreJsData;\n\n  /** Used to detect methods masquerading as native. */\n  var maskSrcKey = (function() {\n    var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || '');\n    return uid ? ('Symbol(src)_1.' + uid) : '';\n  }());\n\n  /**\n   * Checks if `func` has its source masked.\n   *\n   * @private\n   * @param {Function} func The function to check.\n   * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n   */\n  function isMasked(func) {\n    return !!maskSrcKey && (maskSrcKey in func);\n  }\n\n  var _isMasked = isMasked;\n\n  /** Used for built-in method references. */\n  var funcProto$1 = Function.prototype;\n\n  /** Used to resolve the decompiled source of functions. */\n  var funcToString$1 = funcProto$1.toString;\n\n  /**\n   * Converts `func` to its source code.\n   *\n   * @private\n   * @param {Function} func The function to convert.\n   * @returns {string} Returns the source code.\n   */\n  function toSource(func) {\n    if (func != null) {\n      try {\n        return funcToString$1.call(func);\n      } catch (e) {}\n      try {\n        return (func + '');\n      } catch (e) {}\n    }\n    return '';\n  }\n\n  var _toSource = toSource;\n\n  /**\n   * Used to match `RegExp`\n   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n   */\n  var reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n  /** Used to detect host constructors (Safari). */\n  var reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n  /** Used for built-in method references. */\n  var funcProto = Function.prototype,\n      objectProto$3 = Object.prototype;\n\n  /** Used to resolve the decompiled source of functions. */\n  var funcToString = funcProto.toString;\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty$3 = objectProto$3.hasOwnProperty;\n\n  /** Used to detect if a method is native. */\n  var reIsNative = RegExp('^' +\n    funcToString.call(hasOwnProperty$3).replace(reRegExpChar, '\\\\$&')\n    .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n  );\n\n  /**\n   * The base implementation of `_.isNative` without bad shim checks.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a native function,\n   *  else `false`.\n   */\n  function baseIsNative(value) {\n    if (!isObject_1(value) || _isMasked(value)) {\n      return false;\n    }\n    var pattern = isFunction_1(value) ? reIsNative : reIsHostCtor;\n    return pattern.test(_toSource(value));\n  }\n\n  var _baseIsNative = baseIsNative;\n\n  /**\n   * Gets the value at `key` of `object`.\n   *\n   * @private\n   * @param {Object} [object] The object to query.\n   * @param {string} key The key of the property to get.\n   * @returns {*} Returns the property value.\n   */\n  function getValue$1(object, key) {\n    return object == null ? undefined : object[key];\n  }\n\n  var _getValue = getValue$1;\n\n  /**\n   * Gets the native function at `key` of `object`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {string} key The key of the method to get.\n   * @returns {*} Returns the function if it's native, else `undefined`.\n   */\n  function getNative(object, key) {\n    var value = _getValue(object, key);\n    return _baseIsNative(value) ? value : undefined;\n  }\n\n  var _getNative = getNative;\n\n  /* Built-in method references that are verified to be native. */\n  var nativeCreate = _getNative(Object, 'create');\n\n  var _nativeCreate = nativeCreate;\n\n  /**\n   * Removes all key-value entries from the hash.\n   *\n   * @private\n   * @name clear\n   * @memberOf Hash\n   */\n  function hashClear() {\n    this.__data__ = _nativeCreate ? _nativeCreate(null) : {};\n    this.size = 0;\n  }\n\n  var _hashClear = hashClear;\n\n  /**\n   * Removes `key` and its value from the hash.\n   *\n   * @private\n   * @name delete\n   * @memberOf Hash\n   * @param {Object} hash The hash to modify.\n   * @param {string} key The key of the value to remove.\n   * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n   */\n  function hashDelete(key) {\n    var result = this.has(key) && delete this.__data__[key];\n    this.size -= result ? 1 : 0;\n    return result;\n  }\n\n  var _hashDelete = hashDelete;\n\n  /** Used to stand-in for `undefined` hash values. */\n  var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';\n\n  /** Used for built-in method references. */\n  var objectProto$2 = Object.prototype;\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty$2 = objectProto$2.hasOwnProperty;\n\n  /**\n   * Gets the hash value for `key`.\n   *\n   * @private\n   * @name get\n   * @memberOf Hash\n   * @param {string} key The key of the value to get.\n   * @returns {*} Returns the entry value.\n   */\n  function hashGet(key) {\n    var data = this.__data__;\n    if (_nativeCreate) {\n      var result = data[key];\n      return result === HASH_UNDEFINED$1 ? undefined : result;\n    }\n    return hasOwnProperty$2.call(data, key) ? data[key] : undefined;\n  }\n\n  var _hashGet = hashGet;\n\n  /** Used for built-in method references. */\n  var objectProto$1 = Object.prototype;\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty$1 = objectProto$1.hasOwnProperty;\n\n  /**\n   * Checks if a hash value for `key` exists.\n   *\n   * @private\n   * @name has\n   * @memberOf Hash\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n  function hashHas(key) {\n    var data = this.__data__;\n    return _nativeCreate ? (data[key] !== undefined) : hasOwnProperty$1.call(data, key);\n  }\n\n  var _hashHas = hashHas;\n\n  /** Used to stand-in for `undefined` hash values. */\n  var HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n  /**\n   * Sets the hash `key` to `value`.\n   *\n   * @private\n   * @name set\n   * @memberOf Hash\n   * @param {string} key The key of the value to set.\n   * @param {*} value The value to set.\n   * @returns {Object} Returns the hash instance.\n   */\n  function hashSet(key, value) {\n    var data = this.__data__;\n    this.size += this.has(key) ? 0 : 1;\n    data[key] = (_nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n    return this;\n  }\n\n  var _hashSet = hashSet;\n\n  /**\n   * Creates a hash object.\n   *\n   * @private\n   * @constructor\n   * @param {Array} [entries] The key-value pairs to cache.\n   */\n  function Hash(entries) {\n    var index = -1,\n        length = entries == null ? 0 : entries.length;\n\n    this.clear();\n    while (++index < length) {\n      var entry = entries[index];\n      this.set(entry[0], entry[1]);\n    }\n  }\n\n  // Add methods to `Hash`.\n  Hash.prototype.clear = _hashClear;\n  Hash.prototype['delete'] = _hashDelete;\n  Hash.prototype.get = _hashGet;\n  Hash.prototype.has = _hashHas;\n  Hash.prototype.set = _hashSet;\n\n  var _Hash = Hash;\n\n  /**\n   * Removes all key-value entries from the list cache.\n   *\n   * @private\n   * @name clear\n   * @memberOf ListCache\n   */\n  function listCacheClear() {\n    this.__data__ = [];\n    this.size = 0;\n  }\n\n  var _listCacheClear = listCacheClear;\n\n  /**\n   * Performs a\n   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n   * comparison between two values to determine if they are equivalent.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to compare.\n   * @param {*} other The other value to compare.\n   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n   * @example\n   *\n   * var object = { 'a': 1 };\n   * var other = { 'a': 1 };\n   *\n   * _.eq(object, object);\n   * // => true\n   *\n   * _.eq(object, other);\n   * // => false\n   *\n   * _.eq('a', 'a');\n   * // => true\n   *\n   * _.eq('a', Object('a'));\n   * // => false\n   *\n   * _.eq(NaN, NaN);\n   * // => true\n   */\n  function eq(value, other) {\n    return value === other || (value !== value && other !== other);\n  }\n\n  var eq_1 = eq;\n\n  /**\n   * Gets the index at which the `key` is found in `array` of key-value pairs.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} key The key to search for.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function assocIndexOf(array, key) {\n    var length = array.length;\n    while (length--) {\n      if (eq_1(array[length][0], key)) {\n        return length;\n      }\n    }\n    return -1;\n  }\n\n  var _assocIndexOf = assocIndexOf;\n\n  /** Used for built-in method references. */\n  var arrayProto = Array.prototype;\n\n  /** Built-in value references. */\n  var splice = arrayProto.splice;\n\n  /**\n   * Removes `key` and its value from the list cache.\n   *\n   * @private\n   * @name delete\n   * @memberOf ListCache\n   * @param {string} key The key of the value to remove.\n   * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n   */\n  function listCacheDelete(key) {\n    var data = this.__data__,\n        index = _assocIndexOf(data, key);\n\n    if (index < 0) {\n      return false;\n    }\n    var lastIndex = data.length - 1;\n    if (index == lastIndex) {\n      data.pop();\n    } else {\n      splice.call(data, index, 1);\n    }\n    --this.size;\n    return true;\n  }\n\n  var _listCacheDelete = listCacheDelete;\n\n  /**\n   * Gets the list cache value for `key`.\n   *\n   * @private\n   * @name get\n   * @memberOf ListCache\n   * @param {string} key The key of the value to get.\n   * @returns {*} Returns the entry value.\n   */\n  function listCacheGet(key) {\n    var data = this.__data__,\n        index = _assocIndexOf(data, key);\n\n    return index < 0 ? undefined : data[index][1];\n  }\n\n  var _listCacheGet = listCacheGet;\n\n  /**\n   * Checks if a list cache value for `key` exists.\n   *\n   * @private\n   * @name has\n   * @memberOf ListCache\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n  function listCacheHas(key) {\n    return _assocIndexOf(this.__data__, key) > -1;\n  }\n\n  var _listCacheHas = listCacheHas;\n\n  /**\n   * Sets the list cache `key` to `value`.\n   *\n   * @private\n   * @name set\n   * @memberOf ListCache\n   * @param {string} key The key of the value to set.\n   * @param {*} value The value to set.\n   * @returns {Object} Returns the list cache instance.\n   */\n  function listCacheSet(key, value) {\n    var data = this.__data__,\n        index = _assocIndexOf(data, key);\n\n    if (index < 0) {\n      ++this.size;\n      data.push([key, value]);\n    } else {\n      data[index][1] = value;\n    }\n    return this;\n  }\n\n  var _listCacheSet = listCacheSet;\n\n  /**\n   * Creates an list cache object.\n   *\n   * @private\n   * @constructor\n   * @param {Array} [entries] The key-value pairs to cache.\n   */\n  function ListCache(entries) {\n    var index = -1,\n        length = entries == null ? 0 : entries.length;\n\n    this.clear();\n    while (++index < length) {\n      var entry = entries[index];\n      this.set(entry[0], entry[1]);\n    }\n  }\n\n  // Add methods to `ListCache`.\n  ListCache.prototype.clear = _listCacheClear;\n  ListCache.prototype['delete'] = _listCacheDelete;\n  ListCache.prototype.get = _listCacheGet;\n  ListCache.prototype.has = _listCacheHas;\n  ListCache.prototype.set = _listCacheSet;\n\n  var _ListCache = ListCache;\n\n  /* Built-in method references that are verified to be native. */\n  var Map$1 = _getNative(_root, 'Map');\n\n  var _Map = Map$1;\n\n  /**\n   * Removes all key-value entries from the map.\n   *\n   * @private\n   * @name clear\n   * @memberOf MapCache\n   */\n  function mapCacheClear() {\n    this.size = 0;\n    this.__data__ = {\n      'hash': new _Hash,\n      'map': new (_Map || _ListCache),\n      'string': new _Hash\n    };\n  }\n\n  var _mapCacheClear = mapCacheClear;\n\n  /**\n   * Checks if `value` is suitable for use as unique object key.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n   */\n  function isKeyable(value) {\n    var type = typeof value;\n    return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n      ? (value !== '__proto__')\n      : (value === null);\n  }\n\n  var _isKeyable = isKeyable;\n\n  /**\n   * Gets the data for `map`.\n   *\n   * @private\n   * @param {Object} map The map to query.\n   * @param {string} key The reference key.\n   * @returns {*} Returns the map data.\n   */\n  function getMapData(map, key) {\n    var data = map.__data__;\n    return _isKeyable(key)\n      ? data[typeof key == 'string' ? 'string' : 'hash']\n      : data.map;\n  }\n\n  var _getMapData = getMapData;\n\n  /**\n   * Removes `key` and its value from the map.\n   *\n   * @private\n   * @name delete\n   * @memberOf MapCache\n   * @param {string} key The key of the value to remove.\n   * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n   */\n  function mapCacheDelete(key) {\n    var result = _getMapData(this, key)['delete'](key);\n    this.size -= result ? 1 : 0;\n    return result;\n  }\n\n  var _mapCacheDelete = mapCacheDelete;\n\n  /**\n   * Gets the map value for `key`.\n   *\n   * @private\n   * @name get\n   * @memberOf MapCache\n   * @param {string} key The key of the value to get.\n   * @returns {*} Returns the entry value.\n   */\n  function mapCacheGet(key) {\n    return _getMapData(this, key).get(key);\n  }\n\n  var _mapCacheGet = mapCacheGet;\n\n  /**\n   * Checks if a map value for `key` exists.\n   *\n   * @private\n   * @name has\n   * @memberOf MapCache\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n  function mapCacheHas(key) {\n    return _getMapData(this, key).has(key);\n  }\n\n  var _mapCacheHas = mapCacheHas;\n\n  /**\n   * Sets the map `key` to `value`.\n   *\n   * @private\n   * @name set\n   * @memberOf MapCache\n   * @param {string} key The key of the value to set.\n   * @param {*} value The value to set.\n   * @returns {Object} Returns the map cache instance.\n   */\n  function mapCacheSet(key, value) {\n    var data = _getMapData(this, key),\n        size = data.size;\n\n    data.set(key, value);\n    this.size += data.size == size ? 0 : 1;\n    return this;\n  }\n\n  var _mapCacheSet = mapCacheSet;\n\n  /**\n   * Creates a map cache object to store key-value pairs.\n   *\n   * @private\n   * @constructor\n   * @param {Array} [entries] The key-value pairs to cache.\n   */\n  function MapCache(entries) {\n    var index = -1,\n        length = entries == null ? 0 : entries.length;\n\n    this.clear();\n    while (++index < length) {\n      var entry = entries[index];\n      this.set(entry[0], entry[1]);\n    }\n  }\n\n  // Add methods to `MapCache`.\n  MapCache.prototype.clear = _mapCacheClear;\n  MapCache.prototype['delete'] = _mapCacheDelete;\n  MapCache.prototype.get = _mapCacheGet;\n  MapCache.prototype.has = _mapCacheHas;\n  MapCache.prototype.set = _mapCacheSet;\n\n  var _MapCache = MapCache;\n\n  /** Error message constants. */\n  var FUNC_ERROR_TEXT = 'Expected a function';\n\n  /**\n   * Creates a function that memoizes the result of `func`. If `resolver` is\n   * provided, it determines the cache key for storing the result based on the\n   * arguments provided to the memoized function. By default, the first argument\n   * provided to the memoized function is used as the map cache key. The `func`\n   * is invoked with the `this` binding of the memoized function.\n   *\n   * **Note:** The cache is exposed as the `cache` property on the memoized\n   * function. Its creation may be customized by replacing the `_.memoize.Cache`\n   * constructor with one whose instances implement the\n   * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n   * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.1.0\n   * @category Function\n   * @param {Function} func The function to have its output memoized.\n   * @param {Function} [resolver] The function to resolve the cache key.\n   * @returns {Function} Returns the new memoized function.\n   * @example\n   *\n   * var object = { 'a': 1, 'b': 2 };\n   * var other = { 'c': 3, 'd': 4 };\n   *\n   * var values = _.memoize(_.values);\n   * values(object);\n   * // => [1, 2]\n   *\n   * values(other);\n   * // => [3, 4]\n   *\n   * object.a = 2;\n   * values(object);\n   * // => [1, 2]\n   *\n   * // Modify the result cache.\n   * values.cache.set(object, ['a', 'b']);\n   * values(object);\n   * // => ['a', 'b']\n   *\n   * // Replace `_.memoize.Cache`.\n   * _.memoize.Cache = WeakMap;\n   */\n  function memoize(func, resolver) {\n    if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n      throw new TypeError(FUNC_ERROR_TEXT);\n    }\n    var memoized = function() {\n      var args = arguments,\n          key = resolver ? resolver.apply(this, args) : args[0],\n          cache = memoized.cache;\n\n      if (cache.has(key)) {\n        return cache.get(key);\n      }\n      var result = func.apply(this, args);\n      memoized.cache = cache.set(key, result) || cache;\n      return result;\n    };\n    memoized.cache = new (memoize.Cache || _MapCache);\n    return memoized;\n  }\n\n  // Expose `MapCache`.\n  memoize.Cache = _MapCache;\n\n  var memoize_1 = memoize;\n\n  /** Used as the maximum memoize cache size. */\n  var MAX_MEMOIZE_SIZE = 500;\n\n  /**\n   * A specialized version of `_.memoize` which clears the memoized function's\n   * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n   *\n   * @private\n   * @param {Function} func The function to have its output memoized.\n   * @returns {Function} Returns the new memoized function.\n   */\n  function memoizeCapped(func) {\n    var result = memoize_1(func, function(key) {\n      if (cache.size === MAX_MEMOIZE_SIZE) {\n        cache.clear();\n      }\n      return key;\n    });\n\n    var cache = result.cache;\n    return result;\n  }\n\n  var _memoizeCapped = memoizeCapped;\n\n  /** Used to match property names within property paths. */\n  var rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n  /** Used to match backslashes in property paths. */\n  var reEscapeChar = /\\\\(\\\\)?/g;\n\n  /**\n   * Converts `string` to a property path array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the property path array.\n   */\n  var stringToPath = _memoizeCapped(function(string) {\n    var result = [];\n    if (string.charCodeAt(0) === 46 /* . */) {\n      result.push('');\n    }\n    string.replace(rePropName, function(match, number, quote, subString) {\n      result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n    });\n    return result;\n  });\n\n  var _stringToPath = stringToPath;\n\n  /**\n   * A specialized version of `_.map` for arrays without support for iteratee\n   * shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns the new mapped array.\n   */\n  function arrayMap(array, iteratee) {\n    var index = -1,\n        length = array == null ? 0 : array.length,\n        result = Array(length);\n\n    while (++index < length) {\n      result[index] = iteratee(array[index], index, array);\n    }\n    return result;\n  }\n\n  var _arrayMap = arrayMap;\n\n  /** Used as references for various `Number` constants. */\n  var INFINITY$1 = 1 / 0;\n\n  /** Used to convert symbols to primitives and strings. */\n  var symbolProto = _Symbol ? _Symbol.prototype : undefined,\n      symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n  /**\n   * The base implementation of `_.toString` which doesn't convert nullish\n   * values to empty strings.\n   *\n   * @private\n   * @param {*} value The value to process.\n   * @returns {string} Returns the string.\n   */\n  function baseToString(value) {\n    // Exit early for strings to avoid a performance hit in some environments.\n    if (typeof value == 'string') {\n      return value;\n    }\n    if (isArray_1(value)) {\n      // Recursively convert values (susceptible to call stack limits).\n      return _arrayMap(value, baseToString) + '';\n    }\n    if (isSymbol_1(value)) {\n      return symbolToString ? symbolToString.call(value) : '';\n    }\n    var result = (value + '');\n    return (result == '0' && (1 / value) == -INFINITY$1) ? '-0' : result;\n  }\n\n  var _baseToString = baseToString;\n\n  /**\n   * Converts `value` to a string. An empty string is returned for `null`\n   * and `undefined` values. The sign of `-0` is preserved.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to convert.\n   * @returns {string} Returns the converted string.\n   * @example\n   *\n   * _.toString(null);\n   * // => ''\n   *\n   * _.toString(-0);\n   * // => '-0'\n   *\n   * _.toString([1, 2, 3]);\n   * // => '1,2,3'\n   */\n  function toString$1(value) {\n    return value == null ? '' : _baseToString(value);\n  }\n\n  var toString_1 = toString$1;\n\n  /**\n   * Casts `value` to a path array if it's not one.\n   *\n   * @private\n   * @param {*} value The value to inspect.\n   * @param {Object} [object] The object to query keys on.\n   * @returns {Array} Returns the cast property path array.\n   */\n  function castPath(value, object) {\n    if (isArray_1(value)) {\n      return value;\n    }\n    return _isKey(value, object) ? [value] : _stringToPath(toString_1(value));\n  }\n\n  var _castPath = castPath;\n\n  /** Used as references for various `Number` constants. */\n  var INFINITY = 1 / 0;\n\n  /**\n   * Converts `value` to a string key if it's not a string or symbol.\n   *\n   * @private\n   * @param {*} value The value to inspect.\n   * @returns {string|symbol} Returns the key.\n   */\n  function toKey(value) {\n    if (typeof value == 'string' || isSymbol_1(value)) {\n      return value;\n    }\n    var result = (value + '');\n    return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n  }\n\n  var _toKey = toKey;\n\n  /**\n   * The base implementation of `_.get` without support for default values.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array|string} path The path of the property to get.\n   * @returns {*} Returns the resolved value.\n   */\n  function baseGet(object, path) {\n    path = _castPath(path, object);\n\n    var index = 0,\n        length = path.length;\n\n    while (object != null && index < length) {\n      object = object[_toKey(path[index++])];\n    }\n    return (index && index == length) ? object : undefined;\n  }\n\n  var _baseGet = baseGet;\n\n  /**\n   * Gets the value at `path` of `object`. If the resolved value is\n   * `undefined`, the `defaultValue` is returned in its place.\n   *\n   * @static\n   * @memberOf _\n   * @since 3.7.0\n   * @category Object\n   * @param {Object} object The object to query.\n   * @param {Array|string} path The path of the property to get.\n   * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n   * @returns {*} Returns the resolved value.\n   * @example\n   *\n   * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n   *\n   * _.get(object, 'a[0].b.c');\n   * // => 3\n   *\n   * _.get(object, ['a', '0', 'b', 'c']);\n   * // => 3\n   *\n   * _.get(object, 'a.b.c', 'default');\n   * // => 'default'\n   */\n  function get(object, path, defaultValue) {\n    var result = object == null ? undefined : _baseGet(object, path);\n    return result === undefined ? defaultValue : result;\n  }\n\n  var get_1 = get;\n\n  var defineProperty = (function() {\n    try {\n      var func = _getNative(Object, 'defineProperty');\n      func({}, '', {});\n      return func;\n    } catch (e) {}\n  }());\n\n  var _defineProperty = defineProperty;\n\n  /**\n   * The base implementation of `assignValue` and `assignMergeValue` without\n   * value checks.\n   *\n   * @private\n   * @param {Object} object The object to modify.\n   * @param {string} key The key of the property to assign.\n   * @param {*} value The value to assign.\n   */\n  function baseAssignValue(object, key, value) {\n    if (key == '__proto__' && _defineProperty) {\n      _defineProperty(object, key, {\n        'configurable': true,\n        'enumerable': true,\n        'value': value,\n        'writable': true\n      });\n    } else {\n      object[key] = value;\n    }\n  }\n\n  var _baseAssignValue = baseAssignValue;\n\n  /** Used for built-in method references. */\n  var objectProto = Object.prototype;\n\n  /** Used to check objects for own properties. */\n  var hasOwnProperty = objectProto.hasOwnProperty;\n\n  /**\n   * Assigns `value` to `key` of `object` if the existing value is not equivalent\n   * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n   * for equality comparisons.\n   *\n   * @private\n   * @param {Object} object The object to modify.\n   * @param {string} key The key of the property to assign.\n   * @param {*} value The value to assign.\n   */\n  function assignValue(object, key, value) {\n    var objValue = object[key];\n    if (!(hasOwnProperty.call(object, key) && eq_1(objValue, value)) ||\n        (value === undefined && !(key in object))) {\n      _baseAssignValue(object, key, value);\n    }\n  }\n\n  var _assignValue = assignValue;\n\n  /** Used as references for various `Number` constants. */\n  var MAX_SAFE_INTEGER = 9007199254740991;\n\n  /** Used to detect unsigned integer values. */\n  var reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n  /**\n   * Checks if `value` is a valid array-like index.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n   */\n  function isIndex(value, length) {\n    var type = typeof value;\n    length = length == null ? MAX_SAFE_INTEGER : length;\n\n    return !!length &&\n      (type == 'number' ||\n        (type != 'symbol' && reIsUint.test(value))) &&\n          (value > -1 && value % 1 == 0 && value < length);\n  }\n\n  var _isIndex = isIndex;\n\n  /**\n   * The base implementation of `_.set`.\n   *\n   * @private\n   * @param {Object} object The object to modify.\n   * @param {Array|string} path The path of the property to set.\n   * @param {*} value The value to set.\n   * @param {Function} [customizer] The function to customize path creation.\n   * @returns {Object} Returns `object`.\n   */\n  function baseSet(object, path, value, customizer) {\n    if (!isObject_1(object)) {\n      return object;\n    }\n    path = _castPath(path, object);\n\n    var index = -1,\n        length = path.length,\n        lastIndex = length - 1,\n        nested = object;\n\n    while (nested != null && ++index < length) {\n      var key = _toKey(path[index]),\n          newValue = value;\n\n      if (key === '__proto__' || key === 'constructor' || key === 'prototype') {\n        return object;\n      }\n\n      if (index != lastIndex) {\n        var objValue = nested[key];\n        newValue = customizer ? customizer(objValue, key, nested) : undefined;\n        if (newValue === undefined) {\n          newValue = isObject_1(objValue)\n            ? objValue\n            : (_isIndex(path[index + 1]) ? [] : {});\n        }\n      }\n      _assignValue(nested, key, newValue);\n      nested = nested[key];\n    }\n    return object;\n  }\n\n  var _baseSet = baseSet;\n\n  /**\n   * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,\n   * it's created. Arrays are created for missing index properties while objects\n   * are created for all other missing properties. Use `_.setWith` to customize\n   * `path` creation.\n   *\n   * **Note:** This method mutates `object`.\n   *\n   * @static\n   * @memberOf _\n   * @since 3.7.0\n   * @category Object\n   * @param {Object} object The object to modify.\n   * @param {Array|string} path The path of the property to set.\n   * @param {*} value The value to set.\n   * @returns {Object} Returns `object`.\n   * @example\n   *\n   * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n   *\n   * _.set(object, 'a[0].b.c', 4);\n   * console.log(object.a[0].b.c);\n   * // => 4\n   *\n   * _.set(object, ['x', '0', 'y', 'z'], 5);\n   * console.log(object.x[0].y.z);\n   * // => 5\n   */\n  function set(object, path, value) {\n    return object == null ? object : _baseSet(object, path, value);\n  }\n\n  var set_1 = set;\n\n  /**\n   * Copies the values of `source` to `array`.\n   *\n   * @private\n   * @param {Array} source The array to copy values from.\n   * @param {Array} [array=[]] The array to copy values to.\n   * @returns {Array} Returns `array`.\n   */\n  function copyArray(source, array) {\n    var index = -1,\n        length = source.length;\n\n    array || (array = Array(length));\n    while (++index < length) {\n      array[index] = source[index];\n    }\n    return array;\n  }\n\n  var _copyArray = copyArray;\n\n  /**\n   * Converts `value` to a property path array.\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Util\n   * @param {*} value The value to convert.\n   * @returns {Array} Returns the new property path array.\n   * @example\n   *\n   * _.toPath('a.b.c');\n   * // => ['a', 'b', 'c']\n   *\n   * _.toPath('a[0].b.c');\n   * // => ['a', '0', 'b', 'c']\n   */\n  function toPath(value) {\n    if (isArray_1(value)) {\n      return _arrayMap(value, _toKey);\n    }\n    return isSymbol_1(value) ? [value] : _copyArray(_stringToPath(toString_1(value)));\n  }\n\n  var toPath_1 = toPath;\n\n  var define$2 = {\n    // access data field\n    data: function data(params) {\n      var defaults = {\n        field: 'data',\n        bindingEvent: 'data',\n        allowBinding: false,\n        allowSetting: false,\n        allowGetting: false,\n        settingEvent: 'data',\n        settingTriggersEvent: false,\n        triggerFnName: 'trigger',\n        immutableKeys: {},\n        // key => true if immutable\n        updateStyle: false,\n        beforeGet: function beforeGet(self) {},\n        beforeSet: function beforeSet(self, obj) {},\n        onSet: function onSet(self) {},\n        canSet: function canSet(self) {\n          return true;\n        }\n      };\n      params = extend({}, defaults, params);\n      return function dataImpl(name, value) {\n        var p = params;\n        var self = this;\n        var selfIsArrayLike = self.length !== undefined;\n        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n\n        var single = selfIsArrayLike ? self[0] : self; // .data('foo', ...)\n\n        if (string(name)) {\n          // set or get property\n          var isPathLike = name.indexOf('.') !== -1; // there might be a normal field with a dot \n\n          var path = isPathLike && toPath_1(name); // .data('foo')\n\n          if (p.allowGetting && value === undefined) {\n            // get\n            var ret;\n\n            if (single) {\n              p.beforeGet(single); // check if it's path and a field with the same name doesn't exist\n\n              if (path && single._private[p.field][name] === undefined) {\n                ret = get_1(single._private[p.field], path);\n              } else {\n                ret = single._private[p.field][name];\n              }\n            }\n\n            return ret; // .data('foo', 'bar')\n          } else if (p.allowSetting && value !== undefined) {\n            // set\n            var valid = !p.immutableKeys[name];\n\n            if (valid) {\n              var change = _defineProperty$1({}, name, value);\n\n              p.beforeSet(self, change);\n\n              for (var i = 0, l = all.length; i < l; i++) {\n                var ele = all[i];\n\n                if (p.canSet(ele)) {\n                  if (path && single._private[p.field][name] === undefined) {\n                    set_1(ele._private[p.field], path, value);\n                  } else {\n                    ele._private[p.field][name] = value;\n                  }\n                }\n              } // update mappers if asked\n\n\n              if (p.updateStyle) {\n                self.updateStyle();\n              } // call onSet callback\n\n\n              p.onSet(self);\n\n              if (p.settingTriggersEvent) {\n                self[p.triggerFnName](p.settingEvent);\n              }\n            }\n          } // .data({ 'foo': 'bar' })\n\n        } else if (p.allowSetting && plainObject(name)) {\n          // extend\n          var obj = name;\n          var k, v;\n          var keys = Object.keys(obj);\n          p.beforeSet(self, obj);\n\n          for (var _i = 0; _i < keys.length; _i++) {\n            k = keys[_i];\n            v = obj[k];\n\n            var _valid = !p.immutableKeys[k];\n\n            if (_valid) {\n              for (var j = 0; j < all.length; j++) {\n                var _ele = all[j];\n\n                if (p.canSet(_ele)) {\n                  _ele._private[p.field][k] = v;\n                }\n              }\n            }\n          } // update mappers if asked\n\n\n          if (p.updateStyle) {\n            self.updateStyle();\n          } // call onSet callback\n\n\n          p.onSet(self);\n\n          if (p.settingTriggersEvent) {\n            self[p.triggerFnName](p.settingEvent);\n          } // .data(function(){ ... })\n\n        } else if (p.allowBinding && fn$6(name)) {\n          // bind to event\n          var fn = name;\n          self.on(p.bindingEvent, fn); // .data()\n        } else if (p.allowGetting && name === undefined) {\n          // get whole object\n          var _ret;\n\n          if (single) {\n            p.beforeGet(single);\n            _ret = single._private[p.field];\n          }\n\n          return _ret;\n        }\n\n        return self; // maintain chainability\n      }; // function\n    },\n    // data\n    // remove data field\n    removeData: function removeData(params) {\n      var defaults = {\n        field: 'data',\n        event: 'data',\n        triggerFnName: 'trigger',\n        triggerEvent: false,\n        immutableKeys: {} // key => true if immutable\n\n      };\n      params = extend({}, defaults, params);\n      return function removeDataImpl(names) {\n        var p = params;\n        var self = this;\n        var selfIsArrayLike = self.length !== undefined;\n        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like\n        // .removeData('foo bar')\n\n        if (string(names)) {\n          // then get the list of keys, and delete them\n          var keys = names.split(/\\s+/);\n          var l = keys.length;\n\n          for (var i = 0; i < l; i++) {\n            // delete each non-empty key\n            var key = keys[i];\n\n            if (emptyString(key)) {\n              continue;\n            }\n\n            var valid = !p.immutableKeys[key]; // not valid if immutable\n\n            if (valid) {\n              for (var i_a = 0, l_a = all.length; i_a < l_a; i_a++) {\n                all[i_a]._private[p.field][key] = undefined;\n              }\n            }\n          }\n\n          if (p.triggerEvent) {\n            self[p.triggerFnName](p.event);\n          } // .removeData()\n\n        } else if (names === undefined) {\n          // then delete all keys\n          for (var _i_a = 0, _l_a = all.length; _i_a < _l_a; _i_a++) {\n            var _privateFields = all[_i_a]._private[p.field];\n\n            var _keys = Object.keys(_privateFields);\n\n            for (var _i2 = 0; _i2 < _keys.length; _i2++) {\n              var _key = _keys[_i2];\n              var validKeyToDelete = !p.immutableKeys[_key];\n\n              if (validKeyToDelete) {\n                _privateFields[_key] = undefined;\n              }\n            }\n          }\n\n          if (p.triggerEvent) {\n            self[p.triggerFnName](p.event);\n          }\n        }\n\n        return self; // maintain chaining\n      }; // function\n    } // removeData\n\n  }; // define\n\n  var define$1 = {\n    eventAliasesOn: function eventAliasesOn(proto) {\n      var p = proto;\n      p.addListener = p.listen = p.bind = p.on;\n      p.unlisten = p.unbind = p.off = p.removeListener;\n      p.trigger = p.emit; // this is just a wrapper alias of .on()\n\n      p.pon = p.promiseOn = function (events, selector) {\n        var self = this;\n        var args = Array.prototype.slice.call(arguments, 0);\n        return new Promise$1(function (resolve, reject) {\n          var callback = function callback(e) {\n            self.off.apply(self, offArgs);\n            resolve(e);\n          };\n\n          var onArgs = args.concat([callback]);\n          var offArgs = onArgs.concat([]);\n          self.on.apply(self, onArgs);\n        });\n      };\n    }\n  }; // define\n\n  // use this module to cherry pick functions into your prototype\n  var define = {};\n  [define$3, define$2, define$1].forEach(function (m) {\n    extend(define, m);\n  });\n\n  var elesfn$i = {\n    animate: define.animate(),\n    animation: define.animation(),\n    animated: define.animated(),\n    clearQueue: define.clearQueue(),\n    delay: define.delay(),\n    delayAnimation: define.delayAnimation(),\n    stop: define.stop()\n  };\n\n  var elesfn$h = {\n    classes: function classes(_classes) {\n      var self = this;\n\n      if (_classes === undefined) {\n        var ret = [];\n\n        self[0]._private.classes.forEach(function (cls) {\n          return ret.push(cls);\n        });\n\n        return ret;\n      } else if (!array(_classes)) {\n        // extract classes from string\n        _classes = (_classes || '').match(/\\S+/g) || [];\n      }\n\n      var changed = [];\n      var classesSet = new Set$1(_classes); // check and update each ele\n\n      for (var j = 0; j < self.length; j++) {\n        var ele = self[j];\n        var _p = ele._private;\n        var eleClasses = _p.classes;\n        var changedEle = false; // check if ele has all of the passed classes\n\n        for (var i = 0; i < _classes.length; i++) {\n          var cls = _classes[i];\n          var eleHasClass = eleClasses.has(cls);\n\n          if (!eleHasClass) {\n            changedEle = true;\n            break;\n          }\n        } // check if ele has classes outside of those passed\n\n\n        if (!changedEle) {\n          changedEle = eleClasses.size !== _classes.length;\n        }\n\n        if (changedEle) {\n          _p.classes = classesSet;\n          changed.push(ele);\n        }\n      } // trigger update style on those eles that had class changes\n\n\n      if (changed.length > 0) {\n        this.spawn(changed).updateStyle().emit('class');\n      }\n\n      return self;\n    },\n    addClass: function addClass(classes) {\n      return this.toggleClass(classes, true);\n    },\n    hasClass: function hasClass(className) {\n      var ele = this[0];\n      return ele != null && ele._private.classes.has(className);\n    },\n    toggleClass: function toggleClass(classes, toggle) {\n      if (!array(classes)) {\n        // extract classes from string\n        classes = classes.match(/\\S+/g) || [];\n      }\n\n      var self = this;\n      var toggleUndefd = toggle === undefined;\n      var changed = []; // eles who had classes changed\n\n      for (var i = 0, il = self.length; i < il; i++) {\n        var ele = self[i];\n        var eleClasses = ele._private.classes;\n        var changedEle = false;\n\n        for (var j = 0; j < classes.length; j++) {\n          var cls = classes[j];\n          var hasClass = eleClasses.has(cls);\n          var changedNow = false;\n\n          if (toggle || toggleUndefd && !hasClass) {\n            eleClasses.add(cls);\n            changedNow = true;\n          } else if (!toggle || toggleUndefd && hasClass) {\n            eleClasses[\"delete\"](cls);\n            changedNow = true;\n          }\n\n          if (!changedEle && changedNow) {\n            changed.push(ele);\n            changedEle = true;\n          }\n        } // for j classes\n\n      } // for i eles\n      // trigger update style on those eles that had class changes\n\n\n      if (changed.length > 0) {\n        this.spawn(changed).updateStyle().emit('class');\n      }\n\n      return self;\n    },\n    removeClass: function removeClass(classes) {\n      return this.toggleClass(classes, false);\n    },\n    flashClass: function flashClass(classes, duration) {\n      var self = this;\n\n      if (duration == null) {\n        duration = 250;\n      } else if (duration === 0) {\n        return self; // nothing to do really\n      }\n\n      self.addClass(classes);\n      setTimeout(function () {\n        self.removeClass(classes);\n      }, duration);\n      return self;\n    }\n  };\n  elesfn$h.className = elesfn$h.classNames = elesfn$h.classes;\n\n  var tokens = {\n    metaChar: '[\\\\!\\\\\"\\\\#\\\\$\\\\%\\\\&\\\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\.\\\\/\\\\:\\\\;\\\\<\\\\=\\\\>\\\\?\\\\@\\\\[\\\\]\\\\^\\\\`\\\\{\\\\|\\\\}\\\\~]',\n    // chars we need to escape in let names, etc\n    comparatorOp: '=|\\\\!=|>|>=|<|<=|\\\\$=|\\\\^=|\\\\*=',\n    // binary comparison op (used in data selectors)\n    boolOp: '\\\\?|\\\\!|\\\\^',\n    // boolean (unary) operators (used in data selectors)\n    string: '\"(?:\\\\\\\\\"|[^\"])*\"' + '|' + \"'(?:\\\\\\\\'|[^'])*'\",\n    // string literals (used in data selectors) -- doublequotes | singlequotes\n    number: number,\n    // number literal (used in data selectors) --- e.g. 0.1234, 1234, 12e123\n    meta: 'degree|indegree|outdegree',\n    // allowed metadata fields (i.e. allowed functions to use from Collection)\n    separator: '\\\\s*,\\\\s*',\n    // queries are separated by commas, e.g. edge[foo = 'bar'], node.someClass\n    descendant: '\\\\s+',\n    child: '\\\\s+>\\\\s+',\n    subject: '\\\\$',\n    group: 'node|edge|\\\\*',\n    directedEdge: '\\\\s+->\\\\s+',\n    undirectedEdge: '\\\\s+<->\\\\s+'\n  };\n  tokens.variable = '(?:[\\\\w-.]|(?:\\\\\\\\' + tokens.metaChar + '))+'; // a variable name can have letters, numbers, dashes, and periods\n\n  tokens.className = '(?:[\\\\w-]|(?:\\\\\\\\' + tokens.metaChar + '))+'; // a class name has the same rules as a variable except it can't have a '.' in the name\n\n  tokens.value = tokens.string + '|' + tokens.number; // a value literal, either a string or number\n\n  tokens.id = tokens.variable; // an element id (follows variable conventions)\n\n  (function () {\n    var ops, op, i; // add @ variants to comparatorOp\n\n    ops = tokens.comparatorOp.split('|');\n\n    for (i = 0; i < ops.length; i++) {\n      op = ops[i];\n      tokens.comparatorOp += '|@' + op;\n    } // add ! variants to comparatorOp\n\n\n    ops = tokens.comparatorOp.split('|');\n\n    for (i = 0; i < ops.length; i++) {\n      op = ops[i];\n\n      if (op.indexOf('!') >= 0) {\n        continue;\n      } // skip ops that explicitly contain !\n\n\n      if (op === '=') {\n        continue;\n      } // skip = b/c != is explicitly defined\n\n\n      tokens.comparatorOp += '|\\\\!' + op;\n    }\n  })();\n\n  /**\n   * Make a new query object\n   *\n   * @prop type {Type} The type enum (int) of the query\n   * @prop checks List of checks to make against an ele to test for a match\n   */\n  var newQuery = function newQuery() {\n    return {\n      checks: []\n    };\n  };\n\n  /**\n   * A check type enum-like object.  Uses integer values for fast match() lookup.\n   * The ordering does not matter as long as the ints are unique.\n   */\n  var Type = {\n    /** E.g. node */\n    GROUP: 0,\n\n    /** A collection of elements */\n    COLLECTION: 1,\n\n    /** A filter(ele) function */\n    FILTER: 2,\n\n    /** E.g. [foo > 1] */\n    DATA_COMPARE: 3,\n\n    /** E.g. [foo] */\n    DATA_EXIST: 4,\n\n    /** E.g. [?foo] */\n    DATA_BOOL: 5,\n\n    /** E.g. [[degree > 2]] */\n    META_COMPARE: 6,\n\n    /** E.g. :selected */\n    STATE: 7,\n\n    /** E.g. #foo */\n    ID: 8,\n\n    /** E.g. .foo */\n    CLASS: 9,\n\n    /** E.g. #foo <-> #bar */\n    UNDIRECTED_EDGE: 10,\n\n    /** E.g. #foo -> #bar */\n    DIRECTED_EDGE: 11,\n\n    /** E.g. $#foo -> #bar */\n    NODE_SOURCE: 12,\n\n    /** E.g. #foo -> $#bar */\n    NODE_TARGET: 13,\n\n    /** E.g. $#foo <-> #bar */\n    NODE_NEIGHBOR: 14,\n\n    /** E.g. #foo > #bar */\n    CHILD: 15,\n\n    /** E.g. #foo #bar */\n    DESCENDANT: 16,\n\n    /** E.g. $#foo > #bar */\n    PARENT: 17,\n\n    /** E.g. $#foo #bar */\n    ANCESTOR: 18,\n\n    /** E.g. #foo > $bar > #baz */\n    COMPOUND_SPLIT: 19,\n\n    /** Always matches, useful placeholder for subject in `COMPOUND_SPLIT` */\n    TRUE: 20\n  };\n\n  var stateSelectors = [{\n    selector: ':selected',\n    matches: function matches(ele) {\n      return ele.selected();\n    }\n  }, {\n    selector: ':unselected',\n    matches: function matches(ele) {\n      return !ele.selected();\n    }\n  }, {\n    selector: ':selectable',\n    matches: function matches(ele) {\n      return ele.selectable();\n    }\n  }, {\n    selector: ':unselectable',\n    matches: function matches(ele) {\n      return !ele.selectable();\n    }\n  }, {\n    selector: ':locked',\n    matches: function matches(ele) {\n      return ele.locked();\n    }\n  }, {\n    selector: ':unlocked',\n    matches: function matches(ele) {\n      return !ele.locked();\n    }\n  }, {\n    selector: ':visible',\n    matches: function matches(ele) {\n      return ele.visible();\n    }\n  }, {\n    selector: ':hidden',\n    matches: function matches(ele) {\n      return !ele.visible();\n    }\n  }, {\n    selector: ':transparent',\n    matches: function matches(ele) {\n      return ele.transparent();\n    }\n  }, {\n    selector: ':grabbed',\n    matches: function matches(ele) {\n      return ele.grabbed();\n    }\n  }, {\n    selector: ':free',\n    matches: function matches(ele) {\n      return !ele.grabbed();\n    }\n  }, {\n    selector: ':removed',\n    matches: function matches(ele) {\n      return ele.removed();\n    }\n  }, {\n    selector: ':inside',\n    matches: function matches(ele) {\n      return !ele.removed();\n    }\n  }, {\n    selector: ':grabbable',\n    matches: function matches(ele) {\n      return ele.grabbable();\n    }\n  }, {\n    selector: ':ungrabbable',\n    matches: function matches(ele) {\n      return !ele.grabbable();\n    }\n  }, {\n    selector: ':animated',\n    matches: function matches(ele) {\n      return ele.animated();\n    }\n  }, {\n    selector: ':unanimated',\n    matches: function matches(ele) {\n      return !ele.animated();\n    }\n  }, {\n    selector: ':parent',\n    matches: function matches(ele) {\n      return ele.isParent();\n    }\n  }, {\n    selector: ':childless',\n    matches: function matches(ele) {\n      return ele.isChildless();\n    }\n  }, {\n    selector: ':child',\n    matches: function matches(ele) {\n      return ele.isChild();\n    }\n  }, {\n    selector: ':orphan',\n    matches: function matches(ele) {\n      return ele.isOrphan();\n    }\n  }, {\n    selector: ':nonorphan',\n    matches: function matches(ele) {\n      return ele.isChild();\n    }\n  }, {\n    selector: ':compound',\n    matches: function matches(ele) {\n      if (ele.isNode()) {\n        return ele.isParent();\n      } else {\n        return ele.source().isParent() || ele.target().isParent();\n      }\n    }\n  }, {\n    selector: ':loop',\n    matches: function matches(ele) {\n      return ele.isLoop();\n    }\n  }, {\n    selector: ':simple',\n    matches: function matches(ele) {\n      return ele.isSimple();\n    }\n  }, {\n    selector: ':active',\n    matches: function matches(ele) {\n      return ele.active();\n    }\n  }, {\n    selector: ':inactive',\n    matches: function matches(ele) {\n      return !ele.active();\n    }\n  }, {\n    selector: ':backgrounding',\n    matches: function matches(ele) {\n      return ele.backgrounding();\n    }\n  }, {\n    selector: ':nonbackgrounding',\n    matches: function matches(ele) {\n      return !ele.backgrounding();\n    }\n  }].sort(function (a, b) {\n    // n.b. selectors that are starting substrings of others must have the longer ones first\n    return descending(a.selector, b.selector);\n  });\n\n  var lookup = function () {\n    var selToFn = {};\n    var s;\n\n    for (var i = 0; i < stateSelectors.length; i++) {\n      s = stateSelectors[i];\n      selToFn[s.selector] = s.matches;\n    }\n\n    return selToFn;\n  }();\n\n  var stateSelectorMatches = function stateSelectorMatches(sel, ele) {\n    return lookup[sel](ele);\n  };\n  var stateSelectorRegex = '(' + stateSelectors.map(function (s) {\n    return s.selector;\n  }).join('|') + ')';\n\n  // so that values get compared properly in Selector.filter()\n\n  var cleanMetaChars = function cleanMetaChars(str) {\n    return str.replace(new RegExp('\\\\\\\\(' + tokens.metaChar + ')', 'g'), function (match, $1) {\n      return $1;\n    });\n  };\n\n  var replaceLastQuery = function replaceLastQuery(selector, examiningQuery, replacementQuery) {\n    selector[selector.length - 1] = replacementQuery;\n  }; // NOTE: add new expression syntax here to have it recognised by the parser;\n  // - a query contains all adjacent (i.e. no separator in between) expressions;\n  // - the current query is stored in selector[i]\n  // - you need to check the query objects in match() for it actually filter properly, but that's pretty straight forward\n\n\n  var exprs = [{\n    name: 'group',\n    // just used for identifying when debugging\n    query: true,\n    regex: '(' + tokens.group + ')',\n    populate: function populate(selector, query, _ref) {\n      var _ref2 = _slicedToArray(_ref, 1),\n          group = _ref2[0];\n\n      query.checks.push({\n        type: Type.GROUP,\n        value: group === '*' ? group : group + 's'\n      });\n    }\n  }, {\n    name: 'state',\n    query: true,\n    regex: stateSelectorRegex,\n    populate: function populate(selector, query, _ref3) {\n      var _ref4 = _slicedToArray(_ref3, 1),\n          state = _ref4[0];\n\n      query.checks.push({\n        type: Type.STATE,\n        value: state\n      });\n    }\n  }, {\n    name: 'id',\n    query: true,\n    regex: '\\\\#(' + tokens.id + ')',\n    populate: function populate(selector, query, _ref5) {\n      var _ref6 = _slicedToArray(_ref5, 1),\n          id = _ref6[0];\n\n      query.checks.push({\n        type: Type.ID,\n        value: cleanMetaChars(id)\n      });\n    }\n  }, {\n    name: 'className',\n    query: true,\n    regex: '\\\\.(' + tokens.className + ')',\n    populate: function populate(selector, query, _ref7) {\n      var _ref8 = _slicedToArray(_ref7, 1),\n          className = _ref8[0];\n\n      query.checks.push({\n        type: Type.CLASS,\n        value: cleanMetaChars(className)\n      });\n    }\n  }, {\n    name: 'dataExists',\n    query: true,\n    regex: '\\\\[\\\\s*(' + tokens.variable + ')\\\\s*\\\\]',\n    populate: function populate(selector, query, _ref9) {\n      var _ref10 = _slicedToArray(_ref9, 1),\n          variable = _ref10[0];\n\n      query.checks.push({\n        type: Type.DATA_EXIST,\n        field: cleanMetaChars(variable)\n      });\n    }\n  }, {\n    name: 'dataCompare',\n    query: true,\n    regex: '\\\\[\\\\s*(' + tokens.variable + ')\\\\s*(' + tokens.comparatorOp + ')\\\\s*(' + tokens.value + ')\\\\s*\\\\]',\n    populate: function populate(selector, query, _ref11) {\n      var _ref12 = _slicedToArray(_ref11, 3),\n          variable = _ref12[0],\n          comparatorOp = _ref12[1],\n          value = _ref12[2];\n\n      var valueIsString = new RegExp('^' + tokens.string + '$').exec(value) != null;\n\n      if (valueIsString) {\n        value = value.substring(1, value.length - 1);\n      } else {\n        value = parseFloat(value);\n      }\n\n      query.checks.push({\n        type: Type.DATA_COMPARE,\n        field: cleanMetaChars(variable),\n        operator: comparatorOp,\n        value: value\n      });\n    }\n  }, {\n    name: 'dataBool',\n    query: true,\n    regex: '\\\\[\\\\s*(' + tokens.boolOp + ')\\\\s*(' + tokens.variable + ')\\\\s*\\\\]',\n    populate: function populate(selector, query, _ref13) {\n      var _ref14 = _slicedToArray(_ref13, 2),\n          boolOp = _ref14[0],\n          variable = _ref14[1];\n\n      query.checks.push({\n        type: Type.DATA_BOOL,\n        field: cleanMetaChars(variable),\n        operator: boolOp\n      });\n    }\n  }, {\n    name: 'metaCompare',\n    query: true,\n    regex: '\\\\[\\\\[\\\\s*(' + tokens.meta + ')\\\\s*(' + tokens.comparatorOp + ')\\\\s*(' + tokens.number + ')\\\\s*\\\\]\\\\]',\n    populate: function populate(selector, query, _ref15) {\n      var _ref16 = _slicedToArray(_ref15, 3),\n          meta = _ref16[0],\n          comparatorOp = _ref16[1],\n          number = _ref16[2];\n\n      query.checks.push({\n        type: Type.META_COMPARE,\n        field: cleanMetaChars(meta),\n        operator: comparatorOp,\n        value: parseFloat(number)\n      });\n    }\n  }, {\n    name: 'nextQuery',\n    separator: true,\n    regex: tokens.separator,\n    populate: function populate(selector, query) {\n      var currentSubject = selector.currentSubject;\n      var edgeCount = selector.edgeCount;\n      var compoundCount = selector.compoundCount;\n      var lastQ = selector[selector.length - 1];\n\n      if (currentSubject != null) {\n        lastQ.subject = currentSubject;\n        selector.currentSubject = null;\n      }\n\n      lastQ.edgeCount = edgeCount;\n      lastQ.compoundCount = compoundCount;\n      selector.edgeCount = 0;\n      selector.compoundCount = 0; // go on to next query\n\n      var nextQuery = selector[selector.length++] = newQuery();\n      return nextQuery; // this is the new query to be filled by the following exprs\n    }\n  }, {\n    name: 'directedEdge',\n    separator: true,\n    regex: tokens.directedEdge,\n    populate: function populate(selector, query) {\n      if (selector.currentSubject == null) {\n        // undirected edge\n        var edgeQuery = newQuery();\n        var source = query;\n        var target = newQuery();\n        edgeQuery.checks.push({\n          type: Type.DIRECTED_EDGE,\n          source: source,\n          target: target\n        }); // the query in the selector should be the edge rather than the source\n\n        replaceLastQuery(selector, query, edgeQuery);\n        selector.edgeCount++; // we're now populating the target query with expressions that follow\n\n        return target;\n      } else {\n        // source/target\n        var srcTgtQ = newQuery();\n        var _source = query;\n\n        var _target = newQuery();\n\n        srcTgtQ.checks.push({\n          type: Type.NODE_SOURCE,\n          source: _source,\n          target: _target\n        }); // the query in the selector should be the neighbourhood rather than the node\n\n        replaceLastQuery(selector, query, srcTgtQ);\n        selector.edgeCount++;\n        return _target; // now populating the target with the following expressions\n      }\n    }\n  }, {\n    name: 'undirectedEdge',\n    separator: true,\n    regex: tokens.undirectedEdge,\n    populate: function populate(selector, query) {\n      if (selector.currentSubject == null) {\n        // undirected edge\n        var edgeQuery = newQuery();\n        var source = query;\n        var target = newQuery();\n        edgeQuery.checks.push({\n          type: Type.UNDIRECTED_EDGE,\n          nodes: [source, target]\n        }); // the query in the selector should be the edge rather than the source\n\n        replaceLastQuery(selector, query, edgeQuery);\n        selector.edgeCount++; // we're now populating the target query with expressions that follow\n\n        return target;\n      } else {\n        // neighbourhood\n        var nhoodQ = newQuery();\n        var node = query;\n        var neighbor = newQuery();\n        nhoodQ.checks.push({\n          type: Type.NODE_NEIGHBOR,\n          node: node,\n          neighbor: neighbor\n        }); // the query in the selector should be the neighbourhood rather than the node\n\n        replaceLastQuery(selector, query, nhoodQ);\n        return neighbor; // now populating the neighbor with following expressions\n      }\n    }\n  }, {\n    name: 'child',\n    separator: true,\n    regex: tokens.child,\n    populate: function populate(selector, query) {\n      if (selector.currentSubject == null) {\n        // default: child query\n        var parentChildQuery = newQuery();\n        var child = newQuery();\n        var parent = selector[selector.length - 1];\n        parentChildQuery.checks.push({\n          type: Type.CHILD,\n          parent: parent,\n          child: child\n        }); // the query in the selector should be the '>' itself\n\n        replaceLastQuery(selector, query, parentChildQuery);\n        selector.compoundCount++; // we're now populating the child query with expressions that follow\n\n        return child;\n      } else if (selector.currentSubject === query) {\n        // compound split query\n        var compound = newQuery();\n        var left = selector[selector.length - 1];\n        var right = newQuery();\n        var subject = newQuery();\n\n        var _child = newQuery();\n\n        var _parent = newQuery(); // set up the root compound q\n\n\n        compound.checks.push({\n          type: Type.COMPOUND_SPLIT,\n          left: left,\n          right: right,\n          subject: subject\n        }); // populate the subject and replace the q at the old spot (within left) with TRUE\n\n        subject.checks = query.checks; // take the checks from the left\n\n        query.checks = [{\n          type: Type.TRUE\n        }]; // checks under left refs the subject implicitly\n        // set up the right q\n\n        _parent.checks.push({\n          type: Type.TRUE\n        }); // parent implicitly refs the subject\n\n\n        right.checks.push({\n          type: Type.PARENT,\n          // type is swapped on right side queries\n          parent: _parent,\n          child: _child // empty for now\n\n        });\n        replaceLastQuery(selector, left, compound); // update the ref since we moved things around for `query`\n\n        selector.currentSubject = subject;\n        selector.compoundCount++;\n        return _child; // now populating the right side's child\n      } else {\n        // parent query\n        // info for parent query\n        var _parent2 = newQuery();\n\n        var _child2 = newQuery();\n\n        var pcQChecks = [{\n          type: Type.PARENT,\n          parent: _parent2,\n          child: _child2\n        }]; // the parent-child query takes the place of the query previously being populated\n\n        _parent2.checks = query.checks; // the previous query contains the checks for the parent\n\n        query.checks = pcQChecks; // pc query takes over\n\n        selector.compoundCount++;\n        return _child2; // we're now populating the child\n      }\n    }\n  }, {\n    name: 'descendant',\n    separator: true,\n    regex: tokens.descendant,\n    populate: function populate(selector, query) {\n      if (selector.currentSubject == null) {\n        // default: descendant query\n        var ancChQuery = newQuery();\n        var descendant = newQuery();\n        var ancestor = selector[selector.length - 1];\n        ancChQuery.checks.push({\n          type: Type.DESCENDANT,\n          ancestor: ancestor,\n          descendant: descendant\n        }); // the query in the selector should be the '>' itself\n\n        replaceLastQuery(selector, query, ancChQuery);\n        selector.compoundCount++; // we're now populating the descendant query with expressions that follow\n\n        return descendant;\n      } else if (selector.currentSubject === query) {\n        // compound split query\n        var compound = newQuery();\n        var left = selector[selector.length - 1];\n        var right = newQuery();\n        var subject = newQuery();\n\n        var _descendant = newQuery();\n\n        var _ancestor = newQuery(); // set up the root compound q\n\n\n        compound.checks.push({\n          type: Type.COMPOUND_SPLIT,\n          left: left,\n          right: right,\n          subject: subject\n        }); // populate the subject and replace the q at the old spot (within left) with TRUE\n\n        subject.checks = query.checks; // take the checks from the left\n\n        query.checks = [{\n          type: Type.TRUE\n        }]; // checks under left refs the subject implicitly\n        // set up the right q\n\n        _ancestor.checks.push({\n          type: Type.TRUE\n        }); // ancestor implicitly refs the subject\n\n\n        right.checks.push({\n          type: Type.ANCESTOR,\n          // type is swapped on right side queries\n          ancestor: _ancestor,\n          descendant: _descendant // empty for now\n\n        });\n        replaceLastQuery(selector, left, compound); // update the ref since we moved things around for `query`\n\n        selector.currentSubject = subject;\n        selector.compoundCount++;\n        return _descendant; // now populating the right side's descendant\n      } else {\n        // ancestor query\n        // info for parent query\n        var _ancestor2 = newQuery();\n\n        var _descendant2 = newQuery();\n\n        var adQChecks = [{\n          type: Type.ANCESTOR,\n          ancestor: _ancestor2,\n          descendant: _descendant2\n        }]; // the parent-child query takes the place of the query previously being populated\n\n        _ancestor2.checks = query.checks; // the previous query contains the checks for the parent\n\n        query.checks = adQChecks; // pc query takes over\n\n        selector.compoundCount++;\n        return _descendant2; // we're now populating the child\n      }\n    }\n  }, {\n    name: 'subject',\n    modifier: true,\n    regex: tokens.subject,\n    populate: function populate(selector, query) {\n      if (selector.currentSubject != null && selector.currentSubject !== query) {\n        warn('Redefinition of subject in selector `' + selector.toString() + '`');\n        return false;\n      }\n\n      selector.currentSubject = query;\n      var topQ = selector[selector.length - 1];\n      var topChk = topQ.checks[0];\n      var topType = topChk == null ? null : topChk.type;\n\n      if (topType === Type.DIRECTED_EDGE) {\n        // directed edge with subject on the target\n        // change to target node check\n        topChk.type = Type.NODE_TARGET;\n      } else if (topType === Type.UNDIRECTED_EDGE) {\n        // undirected edge with subject on the second node\n        // change to neighbor check\n        topChk.type = Type.NODE_NEIGHBOR;\n        topChk.node = topChk.nodes[1]; // second node is subject\n\n        topChk.neighbor = topChk.nodes[0]; // clean up unused fields for new type\n\n        topChk.nodes = null;\n      }\n    }\n  }];\n  exprs.forEach(function (e) {\n    return e.regexObj = new RegExp('^' + e.regex);\n  });\n\n  /**\n   * Of all the expressions, find the first match in the remaining text.\n   * @param {string} remaining The remaining text to parse\n   * @returns The matched expression and the newly remaining text `{ expr, match, name, remaining }`\n   */\n\n  var consumeExpr = function consumeExpr(remaining) {\n    var expr;\n    var match;\n    var name;\n\n    for (var j = 0; j < exprs.length; j++) {\n      var e = exprs[j];\n      var n = e.name;\n      var m = remaining.match(e.regexObj);\n\n      if (m != null) {\n        match = m;\n        expr = e;\n        name = n;\n        var consumed = m[0];\n        remaining = remaining.substring(consumed.length);\n        break; // we've consumed one expr, so we can return now\n      }\n    }\n\n    return {\n      expr: expr,\n      match: match,\n      name: name,\n      remaining: remaining\n    };\n  };\n  /**\n   * Consume all the leading whitespace\n   * @param {string} remaining The text to consume\n   * @returns The text with the leading whitespace removed\n   */\n\n\n  var consumeWhitespace = function consumeWhitespace(remaining) {\n    var match = remaining.match(/^\\s+/);\n\n    if (match) {\n      var consumed = match[0];\n      remaining = remaining.substring(consumed.length);\n    }\n\n    return remaining;\n  };\n  /**\n   * Parse the string and store the parsed representation in the Selector.\n   * @param {string} selector The selector string\n   * @returns `true` if the selector was successfully parsed, `false` otherwise\n   */\n\n\n  var parse = function parse(selector) {\n    var self = this;\n    var remaining = self.inputText = selector;\n    var currentQuery = self[0] = newQuery();\n    self.length = 1;\n    remaining = consumeWhitespace(remaining); // get rid of leading whitespace\n\n    for (;;) {\n      var exprInfo = consumeExpr(remaining);\n\n      if (exprInfo.expr == null) {\n        warn('The selector `' + selector + '`is invalid');\n        return false;\n      } else {\n        var args = exprInfo.match.slice(1); // let the token populate the selector object in currentQuery\n\n        var ret = exprInfo.expr.populate(self, currentQuery, args);\n\n        if (ret === false) {\n          return false; // exit if population failed\n        } else if (ret != null) {\n          currentQuery = ret; // change the current query to be filled if the expr specifies\n        }\n      }\n\n      remaining = exprInfo.remaining; // we're done when there's nothing left to parse\n\n      if (remaining.match(/^\\s*$/)) {\n        break;\n      }\n    }\n\n    var lastQ = self[self.length - 1];\n\n    if (self.currentSubject != null) {\n      lastQ.subject = self.currentSubject;\n    }\n\n    lastQ.edgeCount = self.edgeCount;\n    lastQ.compoundCount = self.compoundCount;\n\n    for (var i = 0; i < self.length; i++) {\n      var q = self[i]; // in future, this could potentially be allowed if there were operator precedence and detection of invalid combinations\n\n      if (q.compoundCount > 0 && q.edgeCount > 0) {\n        warn('The selector `' + selector + '` is invalid because it uses both a compound selector and an edge selector');\n        return false;\n      }\n\n      if (q.edgeCount > 1) {\n        warn('The selector `' + selector + '` is invalid because it uses multiple edge selectors');\n        return false;\n      } else if (q.edgeCount === 1) {\n        warn('The selector `' + selector + '` is deprecated.  Edge selectors do not take effect on changes to source and target nodes after an edge is added, for performance reasons.  Use a class or data selector on edges instead, updating the class or data of an edge when your app detects a change in source or target nodes.');\n      }\n    }\n\n    return true; // success\n  };\n  /**\n   * Get the selector represented as a string.  This value uses default formatting,\n   * so things like spacing may differ from the input text passed to the constructor.\n   * @returns {string} The selector string\n   */\n\n\n  var toString = function toString() {\n    if (this.toStringCache != null) {\n      return this.toStringCache;\n    }\n\n    var clean = function clean(obj) {\n      if (obj == null) {\n        return '';\n      } else {\n        return obj;\n      }\n    };\n\n    var cleanVal = function cleanVal(val) {\n      if (string(val)) {\n        return '\"' + val + '\"';\n      } else {\n        return clean(val);\n      }\n    };\n\n    var space = function space(val) {\n      return ' ' + val + ' ';\n    };\n\n    var checkToString = function checkToString(check, subject) {\n      var type = check.type,\n          value = check.value;\n\n      switch (type) {\n        case Type.GROUP:\n          {\n            var group = clean(value);\n            return group.substring(0, group.length - 1);\n          }\n\n        case Type.DATA_COMPARE:\n          {\n            var field = check.field,\n                operator = check.operator;\n            return '[' + field + space(clean(operator)) + cleanVal(value) + ']';\n          }\n\n        case Type.DATA_BOOL:\n          {\n            var _operator = check.operator,\n                _field = check.field;\n            return '[' + clean(_operator) + _field + ']';\n          }\n\n        case Type.DATA_EXIST:\n          {\n            var _field2 = check.field;\n            return '[' + _field2 + ']';\n          }\n\n        case Type.META_COMPARE:\n          {\n            var _operator2 = check.operator,\n                _field3 = check.field;\n            return '[[' + _field3 + space(clean(_operator2)) + cleanVal(value) + ']]';\n          }\n\n        case Type.STATE:\n          {\n            return value;\n          }\n\n        case Type.ID:\n          {\n            return '#' + value;\n          }\n\n        case Type.CLASS:\n          {\n            return '.' + value;\n          }\n\n        case Type.PARENT:\n        case Type.CHILD:\n          {\n            return queryToString(check.parent, subject) + space('>') + queryToString(check.child, subject);\n          }\n\n        case Type.ANCESTOR:\n        case Type.DESCENDANT:\n          {\n            return queryToString(check.ancestor, subject) + ' ' + queryToString(check.descendant, subject);\n          }\n\n        case Type.COMPOUND_SPLIT:\n          {\n            var lhs = queryToString(check.left, subject);\n            var sub = queryToString(check.subject, subject);\n            var rhs = queryToString(check.right, subject);\n            return lhs + (lhs.length > 0 ? ' ' : '') + sub + rhs;\n          }\n\n        case Type.TRUE:\n          {\n            return '';\n          }\n      }\n    };\n\n    var queryToString = function queryToString(query, subject) {\n      return query.checks.reduce(function (str, chk, i) {\n        return str + (subject === query && i === 0 ? '$' : '') + checkToString(chk, subject);\n      }, '');\n    };\n\n    var str = '';\n\n    for (var i = 0; i < this.length; i++) {\n      var query = this[i];\n      str += queryToString(query, query.subject);\n\n      if (this.length > 1 && i < this.length - 1) {\n        str += ', ';\n      }\n    }\n\n    this.toStringCache = str;\n    return str;\n  };\n  var parse$1 = {\n    parse: parse,\n    toString: toString\n  };\n\n  var valCmp = function valCmp(fieldVal, operator, value) {\n    var matches;\n    var isFieldStr = string(fieldVal);\n    var isFieldNum = number$1(fieldVal);\n    var isValStr = string(value);\n    var fieldStr, valStr;\n    var caseInsensitive = false;\n    var notExpr = false;\n    var isIneqCmp = false;\n\n    if (operator.indexOf('!') >= 0) {\n      operator = operator.replace('!', '');\n      notExpr = true;\n    }\n\n    if (operator.indexOf('@') >= 0) {\n      operator = operator.replace('@', '');\n      caseInsensitive = true;\n    }\n\n    if (isFieldStr || isValStr || caseInsensitive) {\n      fieldStr = !isFieldStr && !isFieldNum ? '' : '' + fieldVal;\n      valStr = '' + value;\n    } // if we're doing a case insensitive comparison, then we're using a STRING comparison\n    // even if we're comparing numbers\n\n\n    if (caseInsensitive) {\n      fieldVal = fieldStr = fieldStr.toLowerCase();\n      value = valStr = valStr.toLowerCase();\n    }\n\n    switch (operator) {\n      case '*=':\n        matches = fieldStr.indexOf(valStr) >= 0;\n        break;\n\n      case '$=':\n        matches = fieldStr.indexOf(valStr, fieldStr.length - valStr.length) >= 0;\n        break;\n\n      case '^=':\n        matches = fieldStr.indexOf(valStr) === 0;\n        break;\n\n      case '=':\n        matches = fieldVal === value;\n        break;\n\n      case '>':\n        isIneqCmp = true;\n        matches = fieldVal > value;\n        break;\n\n      case '>=':\n        isIneqCmp = true;\n        matches = fieldVal >= value;\n        break;\n\n      case '<':\n        isIneqCmp = true;\n        matches = fieldVal < value;\n        break;\n\n      case '<=':\n        isIneqCmp = true;\n        matches = fieldVal <= value;\n        break;\n\n      default:\n        matches = false;\n        break;\n    } // apply the not op, but null vals for inequalities should always stay non-matching\n\n\n    if (notExpr && (fieldVal != null || !isIneqCmp)) {\n      matches = !matches;\n    }\n\n    return matches;\n  };\n  var boolCmp = function boolCmp(fieldVal, operator) {\n    switch (operator) {\n      case '?':\n        return fieldVal ? true : false;\n\n      case '!':\n        return fieldVal ? false : true;\n\n      case '^':\n        return fieldVal === undefined;\n    }\n  };\n  var existCmp = function existCmp(fieldVal) {\n    return fieldVal !== undefined;\n  };\n  var data$1 = function data(ele, field) {\n    return ele.data(field);\n  };\n  var meta = function meta(ele, field) {\n    return ele[field]();\n  };\n\n  /** A lookup of `match(check, ele)` functions by `Type` int */\n\n  var match = [];\n  /**\n   * Returns whether the query matches for the element\n   * @param query The `{ type, value, ... }` query object\n   * @param ele The element to compare against\n  */\n\n  var matches$1 = function matches(query, ele) {\n    return query.checks.every(function (chk) {\n      return match[chk.type](chk, ele);\n    });\n  };\n\n  match[Type.GROUP] = function (check, ele) {\n    var group = check.value;\n    return group === '*' || group === ele.group();\n  };\n\n  match[Type.STATE] = function (check, ele) {\n    var stateSelector = check.value;\n    return stateSelectorMatches(stateSelector, ele);\n  };\n\n  match[Type.ID] = function (check, ele) {\n    var id = check.value;\n    return ele.id() === id;\n  };\n\n  match[Type.CLASS] = function (check, ele) {\n    var cls = check.value;\n    return ele.hasClass(cls);\n  };\n\n  match[Type.META_COMPARE] = function (check, ele) {\n    var field = check.field,\n        operator = check.operator,\n        value = check.value;\n    return valCmp(meta(ele, field), operator, value);\n  };\n\n  match[Type.DATA_COMPARE] = function (check, ele) {\n    var field = check.field,\n        operator = check.operator,\n        value = check.value;\n    return valCmp(data$1(ele, field), operator, value);\n  };\n\n  match[Type.DATA_BOOL] = function (check, ele) {\n    var field = check.field,\n        operator = check.operator;\n    return boolCmp(data$1(ele, field), operator);\n  };\n\n  match[Type.DATA_EXIST] = function (check, ele) {\n    var field = check.field;\n        check.operator;\n    return existCmp(data$1(ele, field));\n  };\n\n  match[Type.UNDIRECTED_EDGE] = function (check, ele) {\n    var qA = check.nodes[0];\n    var qB = check.nodes[1];\n    var src = ele.source();\n    var tgt = ele.target();\n    return matches$1(qA, src) && matches$1(qB, tgt) || matches$1(qB, src) && matches$1(qA, tgt);\n  };\n\n  match[Type.NODE_NEIGHBOR] = function (check, ele) {\n    return matches$1(check.node, ele) && ele.neighborhood().some(function (n) {\n      return n.isNode() && matches$1(check.neighbor, n);\n    });\n  };\n\n  match[Type.DIRECTED_EDGE] = function (check, ele) {\n    return matches$1(check.source, ele.source()) && matches$1(check.target, ele.target());\n  };\n\n  match[Type.NODE_SOURCE] = function (check, ele) {\n    return matches$1(check.source, ele) && ele.outgoers().some(function (n) {\n      return n.isNode() && matches$1(check.target, n);\n    });\n  };\n\n  match[Type.NODE_TARGET] = function (check, ele) {\n    return matches$1(check.target, ele) && ele.incomers().some(function (n) {\n      return n.isNode() && matches$1(check.source, n);\n    });\n  };\n\n  match[Type.CHILD] = function (check, ele) {\n    return matches$1(check.child, ele) && matches$1(check.parent, ele.parent());\n  };\n\n  match[Type.PARENT] = function (check, ele) {\n    return matches$1(check.parent, ele) && ele.children().some(function (c) {\n      return matches$1(check.child, c);\n    });\n  };\n\n  match[Type.DESCENDANT] = function (check, ele) {\n    return matches$1(check.descendant, ele) && ele.ancestors().some(function (a) {\n      return matches$1(check.ancestor, a);\n    });\n  };\n\n  match[Type.ANCESTOR] = function (check, ele) {\n    return matches$1(check.ancestor, ele) && ele.descendants().some(function (d) {\n      return matches$1(check.descendant, d);\n    });\n  };\n\n  match[Type.COMPOUND_SPLIT] = function (check, ele) {\n    return matches$1(check.subject, ele) && matches$1(check.left, ele) && matches$1(check.right, ele);\n  };\n\n  match[Type.TRUE] = function () {\n    return true;\n  };\n\n  match[Type.COLLECTION] = function (check, ele) {\n    var collection = check.value;\n    return collection.has(ele);\n  };\n\n  match[Type.FILTER] = function (check, ele) {\n    var filter = check.value;\n    return filter(ele);\n  };\n\n  var filter = function filter(collection) {\n    var self = this; // for 1 id #foo queries, just get the element\n\n    if (self.length === 1 && self[0].checks.length === 1 && self[0].checks[0].type === Type.ID) {\n      return collection.getElementById(self[0].checks[0].value).collection();\n    }\n\n    var selectorFunction = function selectorFunction(element) {\n      for (var j = 0; j < self.length; j++) {\n        var query = self[j];\n\n        if (matches$1(query, element)) {\n          return true;\n        }\n      }\n\n      return false;\n    };\n\n    if (self.text() == null) {\n      selectorFunction = function selectorFunction() {\n        return true;\n      };\n    }\n\n    return collection.filter(selectorFunction);\n  }; // filter\n  // does selector match a single element?\n\n\n  var matches = function matches(ele) {\n    var self = this;\n\n    for (var j = 0; j < self.length; j++) {\n      var query = self[j];\n\n      if (matches$1(query, ele)) {\n        return true;\n      }\n    }\n\n    return false;\n  }; // matches\n\n\n  var matching = {\n    matches: matches,\n    filter: filter\n  };\n\n  var Selector = function Selector(selector) {\n    this.inputText = selector;\n    this.currentSubject = null;\n    this.compoundCount = 0;\n    this.edgeCount = 0;\n    this.length = 0;\n\n    if (selector == null || string(selector) && selector.match(/^\\s*$/)) ; else if (elementOrCollection(selector)) {\n      this.addQuery({\n        checks: [{\n          type: Type.COLLECTION,\n          value: selector.collection()\n        }]\n      });\n    } else if (fn$6(selector)) {\n      this.addQuery({\n        checks: [{\n          type: Type.FILTER,\n          value: selector\n        }]\n      });\n    } else if (string(selector)) {\n      if (!this.parse(selector)) {\n        this.invalid = true;\n      }\n    } else {\n      error('A selector must be created from a string; found ');\n    }\n  };\n\n  var selfn = Selector.prototype;\n  [parse$1, matching].forEach(function (p) {\n    return extend(selfn, p);\n  });\n\n  selfn.text = function () {\n    return this.inputText;\n  };\n\n  selfn.size = function () {\n    return this.length;\n  };\n\n  selfn.eq = function (i) {\n    return this[i];\n  };\n\n  selfn.sameText = function (otherSel) {\n    return !this.invalid && !otherSel.invalid && this.text() === otherSel.text();\n  };\n\n  selfn.addQuery = function (q) {\n    this[this.length++] = q;\n  };\n\n  selfn.selector = selfn.toString;\n\n  var elesfn$g = {\n    allAre: function allAre(selector) {\n      var selObj = new Selector(selector);\n      return this.every(function (ele) {\n        return selObj.matches(ele);\n      });\n    },\n    is: function is(selector) {\n      var selObj = new Selector(selector);\n      return this.some(function (ele) {\n        return selObj.matches(ele);\n      });\n    },\n    some: function some(fn, thisArg) {\n      for (var i = 0; i < this.length; i++) {\n        var ret = !thisArg ? fn(this[i], i, this) : fn.apply(thisArg, [this[i], i, this]);\n\n        if (ret) {\n          return true;\n        }\n      }\n\n      return false;\n    },\n    every: function every(fn, thisArg) {\n      for (var i = 0; i < this.length; i++) {\n        var ret = !thisArg ? fn(this[i], i, this) : fn.apply(thisArg, [this[i], i, this]);\n\n        if (!ret) {\n          return false;\n        }\n      }\n\n      return true;\n    },\n    same: function same(collection) {\n      // cheap collection ref check\n      if (this === collection) {\n        return true;\n      }\n\n      collection = this.cy().collection(collection);\n      var thisLength = this.length;\n      var collectionLength = collection.length; // cheap length check\n\n      if (thisLength !== collectionLength) {\n        return false;\n      } // cheap element ref check\n\n\n      if (thisLength === 1) {\n        return this[0] === collection[0];\n      }\n\n      return this.every(function (ele) {\n        return collection.hasElementWithId(ele.id());\n      });\n    },\n    anySame: function anySame(collection) {\n      collection = this.cy().collection(collection);\n      return this.some(function (ele) {\n        return collection.hasElementWithId(ele.id());\n      });\n    },\n    allAreNeighbors: function allAreNeighbors(collection) {\n      collection = this.cy().collection(collection);\n      var nhood = this.neighborhood();\n      return collection.every(function (ele) {\n        return nhood.hasElementWithId(ele.id());\n      });\n    },\n    contains: function contains(collection) {\n      collection = this.cy().collection(collection);\n      var self = this;\n      return collection.every(function (ele) {\n        return self.hasElementWithId(ele.id());\n      });\n    }\n  };\n  elesfn$g.allAreNeighbours = elesfn$g.allAreNeighbors;\n  elesfn$g.has = elesfn$g.contains;\n  elesfn$g.equal = elesfn$g.equals = elesfn$g.same;\n\n  var cache = function cache(fn, name) {\n    return function traversalCache(arg1, arg2, arg3, arg4) {\n      var selectorOrEles = arg1;\n      var eles = this;\n      var key;\n\n      if (selectorOrEles == null) {\n        key = '';\n      } else if (elementOrCollection(selectorOrEles) && selectorOrEles.length === 1) {\n        key = selectorOrEles.id();\n      }\n\n      if (eles.length === 1 && key) {\n        var _p = eles[0]._private;\n        var tch = _p.traversalCache = _p.traversalCache || {};\n        var ch = tch[name] = tch[name] || [];\n        var hash = hashString(key);\n        var cacheHit = ch[hash];\n\n        if (cacheHit) {\n          return cacheHit;\n        } else {\n          return ch[hash] = fn.call(eles, arg1, arg2, arg3, arg4);\n        }\n      } else {\n        return fn.call(eles, arg1, arg2, arg3, arg4);\n      }\n    };\n  };\n\n  var elesfn$f = {\n    parent: function parent(selector) {\n      var parents = []; // optimisation for single ele call\n\n      if (this.length === 1) {\n        var parent = this[0]._private.parent;\n\n        if (parent) {\n          return parent;\n        }\n      }\n\n      for (var i = 0; i < this.length; i++) {\n        var ele = this[i];\n        var _parent = ele._private.parent;\n\n        if (_parent) {\n          parents.push(_parent);\n        }\n      }\n\n      return this.spawn(parents, true).filter(selector);\n    },\n    parents: function parents(selector) {\n      var parents = [];\n      var eles = this.parent();\n\n      while (eles.nonempty()) {\n        for (var i = 0; i < eles.length; i++) {\n          var ele = eles[i];\n          parents.push(ele);\n        }\n\n        eles = eles.parent();\n      }\n\n      return this.spawn(parents, true).filter(selector);\n    },\n    commonAncestors: function commonAncestors(selector) {\n      var ancestors;\n\n      for (var i = 0; i < this.length; i++) {\n        var ele = this[i];\n        var parents = ele.parents();\n        ancestors = ancestors || parents;\n        ancestors = ancestors.intersect(parents); // current list must be common with current ele parents set\n      }\n\n      return ancestors.filter(selector);\n    },\n    orphans: function orphans(selector) {\n      return this.stdFilter(function (ele) {\n        return ele.isOrphan();\n      }).filter(selector);\n    },\n    nonorphans: function nonorphans(selector) {\n      return this.stdFilter(function (ele) {\n        return ele.isChild();\n      }).filter(selector);\n    },\n    children: cache(function (selector) {\n      var children = [];\n\n      for (var i = 0; i < this.length; i++) {\n        var ele = this[i];\n        var eleChildren = ele._private.children;\n\n        for (var j = 0; j < eleChildren.length; j++) {\n          children.push(eleChildren[j]);\n        }\n      }\n\n      return this.spawn(children, true).filter(selector);\n    }, 'children'),\n    siblings: function siblings(selector) {\n      return this.parent().children().not(this).filter(selector);\n    },\n    isParent: function isParent() {\n      var ele = this[0];\n\n      if (ele) {\n        return ele.isNode() && ele._private.children.length !== 0;\n      }\n    },\n    isChildless: function isChildless() {\n      var ele = this[0];\n\n      if (ele) {\n        return ele.isNode() && ele._private.children.length === 0;\n      }\n    },\n    isChild: function isChild() {\n      var ele = this[0];\n\n      if (ele) {\n        return ele.isNode() && ele._private.parent != null;\n      }\n    },\n    isOrphan: function isOrphan() {\n      var ele = this[0];\n\n      if (ele) {\n        return ele.isNode() && ele._private.parent == null;\n      }\n    },\n    descendants: function descendants(selector) {\n      var elements = [];\n\n      function add(eles) {\n        for (var i = 0; i < eles.length; i++) {\n          var ele = eles[i];\n          elements.push(ele);\n\n          if (ele.children().nonempty()) {\n            add(ele.children());\n          }\n        }\n      }\n\n      add(this.children());\n      return this.spawn(elements, true).filter(selector);\n    }\n  };\n\n  function forEachCompound(eles, fn, includeSelf, recursiveStep) {\n    var q = [];\n    var did = new Set$1();\n    var cy = eles.cy();\n    var hasCompounds = cy.hasCompoundNodes();\n\n    for (var i = 0; i < eles.length; i++) {\n      var ele = eles[i];\n\n      if (includeSelf) {\n        q.push(ele);\n      } else if (hasCompounds) {\n        recursiveStep(q, did, ele);\n      }\n    }\n\n    while (q.length > 0) {\n      var _ele = q.shift();\n\n      fn(_ele);\n      did.add(_ele.id());\n\n      if (hasCompounds) {\n        recursiveStep(q, did, _ele);\n      }\n    }\n\n    return eles;\n  }\n\n  function addChildren(q, did, ele) {\n    if (ele.isParent()) {\n      var children = ele._private.children;\n\n      for (var i = 0; i < children.length; i++) {\n        var child = children[i];\n\n        if (!did.has(child.id())) {\n          q.push(child);\n        }\n      }\n    }\n  } // very efficient version of eles.add( eles.descendants() ).forEach()\n  // for internal use\n\n\n  elesfn$f.forEachDown = function (fn) {\n    var includeSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    return forEachCompound(this, fn, includeSelf, addChildren);\n  };\n\n  function addParent(q, did, ele) {\n    if (ele.isChild()) {\n      var parent = ele._private.parent;\n\n      if (!did.has(parent.id())) {\n        q.push(parent);\n      }\n    }\n  }\n\n  elesfn$f.forEachUp = function (fn) {\n    var includeSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    return forEachCompound(this, fn, includeSelf, addParent);\n  };\n\n  function addParentAndChildren(q, did, ele) {\n    addParent(q, did, ele);\n    addChildren(q, did, ele);\n  }\n\n  elesfn$f.forEachUpAndDown = function (fn) {\n    var includeSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    return forEachCompound(this, fn, includeSelf, addParentAndChildren);\n  }; // aliases\n\n\n  elesfn$f.ancestors = elesfn$f.parents;\n\n  var fn$5, elesfn$e;\n  fn$5 = elesfn$e = {\n    data: define.data({\n      field: 'data',\n      bindingEvent: 'data',\n      allowBinding: true,\n      allowSetting: true,\n      settingEvent: 'data',\n      settingTriggersEvent: true,\n      triggerFnName: 'trigger',\n      allowGetting: true,\n      immutableKeys: {\n        'id': true,\n        'source': true,\n        'target': true,\n        'parent': true\n      },\n      updateStyle: true\n    }),\n    removeData: define.removeData({\n      field: 'data',\n      event: 'data',\n      triggerFnName: 'trigger',\n      triggerEvent: true,\n      immutableKeys: {\n        'id': true,\n        'source': true,\n        'target': true,\n        'parent': true\n      },\n      updateStyle: true\n    }),\n    scratch: define.data({\n      field: 'scratch',\n      bindingEvent: 'scratch',\n      allowBinding: true,\n      allowSetting: true,\n      settingEvent: 'scratch',\n      settingTriggersEvent: true,\n      triggerFnName: 'trigger',\n      allowGetting: true,\n      updateStyle: true\n    }),\n    removeScratch: define.removeData({\n      field: 'scratch',\n      event: 'scratch',\n      triggerFnName: 'trigger',\n      triggerEvent: true,\n      updateStyle: true\n    }),\n    rscratch: define.data({\n      field: 'rscratch',\n      allowBinding: false,\n      allowSetting: true,\n      settingTriggersEvent: false,\n      allowGetting: true\n    }),\n    removeRscratch: define.removeData({\n      field: 'rscratch',\n      triggerEvent: false\n    }),\n    id: function id() {\n      var ele = this[0];\n\n      if (ele) {\n        return ele._private.data.id;\n      }\n    }\n  }; // aliases\n\n  fn$5.attr = fn$5.data;\n  fn$5.removeAttr = fn$5.removeData;\n  var data = elesfn$e;\n\n  var elesfn$d = {};\n\n  function defineDegreeFunction(callback) {\n    return function (includeLoops) {\n      var self = this;\n\n      if (includeLoops === undefined) {\n        includeLoops = true;\n      }\n\n      if (self.length === 0) {\n        return;\n      }\n\n      if (self.isNode() && !self.removed()) {\n        var degree = 0;\n        var node = self[0];\n        var connectedEdges = node._private.edges;\n\n        for (var i = 0; i < connectedEdges.length; i++) {\n          var edge = connectedEdges[i];\n\n          if (!includeLoops && edge.isLoop()) {\n            continue;\n          }\n\n          degree += callback(node, edge);\n        }\n\n        return degree;\n      } else {\n        return;\n      }\n    };\n  }\n\n  extend(elesfn$d, {\n    degree: defineDegreeFunction(function (node, edge) {\n      if (edge.source().same(edge.target())) {\n        return 2;\n      } else {\n        return 1;\n      }\n    }),\n    indegree: defineDegreeFunction(function (node, edge) {\n      if (edge.target().same(node)) {\n        return 1;\n      } else {\n        return 0;\n      }\n    }),\n    outdegree: defineDegreeFunction(function (node, edge) {\n      if (edge.source().same(node)) {\n        return 1;\n      } else {\n        return 0;\n      }\n    })\n  });\n\n  function defineDegreeBoundsFunction(degreeFn, callback) {\n    return function (includeLoops) {\n      var ret;\n      var nodes = this.nodes();\n\n      for (var i = 0; i < nodes.length; i++) {\n        var ele = nodes[i];\n        var degree = ele[degreeFn](includeLoops);\n\n        if (degree !== undefined && (ret === undefined || callback(degree, ret))) {\n          ret = degree;\n        }\n      }\n\n      return ret;\n    };\n  }\n\n  extend(elesfn$d, {\n    minDegree: defineDegreeBoundsFunction('degree', function (degree, min) {\n      return degree < min;\n    }),\n    maxDegree: defineDegreeBoundsFunction('degree', function (degree, max) {\n      return degree > max;\n    }),\n    minIndegree: defineDegreeBoundsFunction('indegree', function (degree, min) {\n      return degree < min;\n    }),\n    maxIndegree: defineDegreeBoundsFunction('indegree', function (degree, max) {\n      return degree > max;\n    }),\n    minOutdegree: defineDegreeBoundsFunction('outdegree', function (degree, min) {\n      return degree < min;\n    }),\n    maxOutdegree: defineDegreeBoundsFunction('outdegree', function (degree, max) {\n      return degree > max;\n    })\n  });\n  extend(elesfn$d, {\n    totalDegree: function totalDegree(includeLoops) {\n      var total = 0;\n      var nodes = this.nodes();\n\n      for (var i = 0; i < nodes.length; i++) {\n        total += nodes[i].degree(includeLoops);\n      }\n\n      return total;\n    }\n  });\n\n  var fn$4, elesfn$c;\n\n  var beforePositionSet = function beforePositionSet(eles, newPos, silent) {\n    for (var i = 0; i < eles.length; i++) {\n      var ele = eles[i];\n\n      if (!ele.locked()) {\n        var oldPos = ele._private.position;\n        var delta = {\n          x: newPos.x != null ? newPos.x - oldPos.x : 0,\n          y: newPos.y != null ? newPos.y - oldPos.y : 0\n        };\n\n        if (ele.isParent() && !(delta.x === 0 && delta.y === 0)) {\n          ele.children().shift(delta, silent);\n        }\n\n        ele.dirtyBoundingBoxCache();\n      }\n    }\n  };\n\n  var positionDef = {\n    field: 'position',\n    bindingEvent: 'position',\n    allowBinding: true,\n    allowSetting: true,\n    settingEvent: 'position',\n    settingTriggersEvent: true,\n    triggerFnName: 'emitAndNotify',\n    allowGetting: true,\n    validKeys: ['x', 'y'],\n    beforeGet: function beforeGet(ele) {\n      ele.updateCompoundBounds();\n    },\n    beforeSet: function beforeSet(eles, newPos) {\n      beforePositionSet(eles, newPos, false);\n    },\n    onSet: function onSet(eles) {\n      eles.dirtyCompoundBoundsCache();\n    },\n    canSet: function canSet(ele) {\n      return !ele.locked();\n    }\n  };\n  fn$4 = elesfn$c = {\n    position: define.data(positionDef),\n    // position but no notification to renderer\n    silentPosition: define.data(extend({}, positionDef, {\n      allowBinding: false,\n      allowSetting: true,\n      settingTriggersEvent: false,\n      allowGetting: false,\n      beforeSet: function beforeSet(eles, newPos) {\n        beforePositionSet(eles, newPos, true);\n      },\n      onSet: function onSet(eles) {\n        eles.dirtyCompoundBoundsCache();\n      }\n    })),\n    positions: function positions(pos, silent) {\n      if (plainObject(pos)) {\n        if (silent) {\n          this.silentPosition(pos);\n        } else {\n          this.position(pos);\n        }\n      } else if (fn$6(pos)) {\n        var _fn = pos;\n        var cy = this.cy();\n        cy.startBatch();\n\n        for (var i = 0; i < this.length; i++) {\n          var ele = this[i];\n\n          var _pos = void 0;\n\n          if (_pos = _fn(ele, i)) {\n            if (silent) {\n              ele.silentPosition(_pos);\n            } else {\n              ele.position(_pos);\n            }\n          }\n        }\n\n        cy.endBatch();\n      }\n\n      return this; // chaining\n    },\n    silentPositions: function silentPositions(pos) {\n      return this.positions(pos, true);\n    },\n    shift: function shift(dim, val, silent) {\n      var delta;\n\n      if (plainObject(dim)) {\n        delta = {\n          x: number$1(dim.x) ? dim.x : 0,\n          y: number$1(dim.y) ? dim.y : 0\n        };\n        silent = val;\n      } else if (string(dim) && number$1(val)) {\n        delta = {\n          x: 0,\n          y: 0\n        };\n        delta[dim] = val;\n      }\n\n      if (delta != null) {\n        var cy = this.cy();\n        cy.startBatch();\n\n        for (var i = 0; i < this.length; i++) {\n          var ele = this[i]; // exclude any node that is a descendant of the calling collection\n\n          if (cy.hasCompoundNodes() && ele.isChild() && ele.ancestors().anySame(this)) {\n            continue;\n          }\n\n          var pos = ele.position();\n          var newPos = {\n            x: pos.x + delta.x,\n            y: pos.y + delta.y\n          };\n\n          if (silent) {\n            ele.silentPosition(newPos);\n          } else {\n            ele.position(newPos);\n          }\n        }\n\n        cy.endBatch();\n      }\n\n      return this;\n    },\n    silentShift: function silentShift(dim, val) {\n      if (plainObject(dim)) {\n        this.shift(dim, true);\n      } else if (string(dim) && number$1(val)) {\n        this.shift(dim, val, true);\n      }\n\n      return this;\n    },\n    // get/set the rendered (i.e. on screen) positon of the element\n    renderedPosition: function renderedPosition(dim, val) {\n      var ele = this[0];\n      var cy = this.cy();\n      var zoom = cy.zoom();\n      var pan = cy.pan();\n      var rpos = plainObject(dim) ? dim : undefined;\n      var setting = rpos !== undefined || val !== undefined && string(dim);\n\n      if (ele && ele.isNode()) {\n        // must have an element and must be a node to return position\n        if (setting) {\n          for (var i = 0; i < this.length; i++) {\n            var _ele = this[i];\n\n            if (val !== undefined) {\n              // set one dimension\n              _ele.position(dim, (val - pan[dim]) / zoom);\n            } else if (rpos !== undefined) {\n              // set whole position\n              _ele.position(renderedToModelPosition(rpos, zoom, pan));\n            }\n          }\n        } else {\n          // getting\n          var pos = ele.position();\n          rpos = modelToRenderedPosition(pos, zoom, pan);\n\n          if (dim === undefined) {\n            // then return the whole rendered position\n            return rpos;\n          } else {\n            // then return the specified dimension\n            return rpos[dim];\n          }\n        }\n      } else if (!setting) {\n        return undefined; // for empty collection case\n      }\n\n      return this; // chaining\n    },\n    // get/set the position relative to the parent\n    relativePosition: function relativePosition(dim, val) {\n      var ele = this[0];\n      var cy = this.cy();\n      var ppos = plainObject(dim) ? dim : undefined;\n      var setting = ppos !== undefined || val !== undefined && string(dim);\n      var hasCompoundNodes = cy.hasCompoundNodes();\n\n      if (ele && ele.isNode()) {\n        // must have an element and must be a node to return position\n        if (setting) {\n          for (var i = 0; i < this.length; i++) {\n            var _ele2 = this[i];\n            var parent = hasCompoundNodes ? _ele2.parent() : null;\n            var hasParent = parent && parent.length > 0;\n            var relativeToParent = hasParent;\n\n            if (hasParent) {\n              parent = parent[0];\n            }\n\n            var origin = relativeToParent ? parent.position() : {\n              x: 0,\n              y: 0\n            };\n\n            if (val !== undefined) {\n              // set one dimension\n              _ele2.position(dim, val + origin[dim]);\n            } else if (ppos !== undefined) {\n              // set whole position\n              _ele2.position({\n                x: ppos.x + origin.x,\n                y: ppos.y + origin.y\n              });\n            }\n          }\n        } else {\n          // getting\n          var pos = ele.position();\n\n          var _parent = hasCompoundNodes ? ele.parent() : null;\n\n          var _hasParent = _parent && _parent.length > 0;\n\n          var _relativeToParent = _hasParent;\n\n          if (_hasParent) {\n            _parent = _parent[0];\n          }\n\n          var _origin = _relativeToParent ? _parent.position() : {\n            x: 0,\n            y: 0\n          };\n\n          ppos = {\n            x: pos.x - _origin.x,\n            y: pos.y - _origin.y\n          };\n\n          if (dim === undefined) {\n            // then return the whole rendered position\n            return ppos;\n          } else {\n            // then return the specified dimension\n            return ppos[dim];\n          }\n        }\n      } else if (!setting) {\n        return undefined; // for empty collection case\n      }\n\n      return this; // chaining\n    }\n  }; // aliases\n\n  fn$4.modelPosition = fn$4.point = fn$4.position;\n  fn$4.modelPositions = fn$4.points = fn$4.positions;\n  fn$4.renderedPoint = fn$4.renderedPosition;\n  fn$4.relativePoint = fn$4.relativePosition;\n  var position = elesfn$c;\n\n  var fn$3, elesfn$b;\n  fn$3 = elesfn$b = {};\n\n  elesfn$b.renderedBoundingBox = function (options) {\n    var bb = this.boundingBox(options);\n    var cy = this.cy();\n    var zoom = cy.zoom();\n    var pan = cy.pan();\n    var x1 = bb.x1 * zoom + pan.x;\n    var x2 = bb.x2 * zoom + pan.x;\n    var y1 = bb.y1 * zoom + pan.y;\n    var y2 = bb.y2 * zoom + pan.y;\n    return {\n      x1: x1,\n      x2: x2,\n      y1: y1,\n      y2: y2,\n      w: x2 - x1,\n      h: y2 - y1\n    };\n  };\n\n  elesfn$b.dirtyCompoundBoundsCache = function () {\n    var silent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var cy = this.cy();\n\n    if (!cy.styleEnabled() || !cy.hasCompoundNodes()) {\n      return this;\n    }\n\n    this.forEachUp(function (ele) {\n      if (ele.isParent()) {\n        var _p = ele._private;\n        _p.compoundBoundsClean = false;\n        _p.bbCache = null;\n\n        if (!silent) {\n          ele.emitAndNotify('bounds');\n        }\n      }\n    });\n    return this;\n  };\n\n  elesfn$b.updateCompoundBounds = function () {\n    var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var cy = this.cy(); // not possible to do on non-compound graphs or with the style disabled\n\n    if (!cy.styleEnabled() || !cy.hasCompoundNodes()) {\n      return this;\n    } // save cycles when batching -- but bounds will be stale (or not exist yet)\n\n\n    if (!force && cy.batching()) {\n      return this;\n    }\n\n    function update(parent) {\n      if (!parent.isParent()) {\n        return;\n      }\n\n      var _p = parent._private;\n      var children = parent.children();\n      var includeLabels = parent.pstyle('compound-sizing-wrt-labels').value === 'include';\n      var min = {\n        width: {\n          val: parent.pstyle('min-width').pfValue,\n          left: parent.pstyle('min-width-bias-left'),\n          right: parent.pstyle('min-width-bias-right')\n        },\n        height: {\n          val: parent.pstyle('min-height').pfValue,\n          top: parent.pstyle('min-height-bias-top'),\n          bottom: parent.pstyle('min-height-bias-bottom')\n        }\n      };\n      var bb = children.boundingBox({\n        includeLabels: includeLabels,\n        includeOverlays: false,\n        // updating the compound bounds happens outside of the regular\n        // cache cycle (i.e. before fired events)\n        useCache: false\n      });\n      var pos = _p.position; // if children take up zero area then keep position and fall back on stylesheet w/h\n\n      if (bb.w === 0 || bb.h === 0) {\n        bb = {\n          w: parent.pstyle('width').pfValue,\n          h: parent.pstyle('height').pfValue\n        };\n        bb.x1 = pos.x - bb.w / 2;\n        bb.x2 = pos.x + bb.w / 2;\n        bb.y1 = pos.y - bb.h / 2;\n        bb.y2 = pos.y + bb.h / 2;\n      }\n\n      function computeBiasValues(propDiff, propBias, propBiasComplement) {\n        var biasDiff = 0;\n        var biasComplementDiff = 0;\n        var biasTotal = propBias + propBiasComplement;\n\n        if (propDiff > 0 && biasTotal > 0) {\n          biasDiff = propBias / biasTotal * propDiff;\n          biasComplementDiff = propBiasComplement / biasTotal * propDiff;\n        }\n\n        return {\n          biasDiff: biasDiff,\n          biasComplementDiff: biasComplementDiff\n        };\n      }\n\n      function computePaddingValues(width, height, paddingObject, relativeTo) {\n        // Assuming percentage is number from 0 to 1\n        if (paddingObject.units === '%') {\n          switch (relativeTo) {\n            case 'width':\n              return width > 0 ? paddingObject.pfValue * width : 0;\n\n            case 'height':\n              return height > 0 ? paddingObject.pfValue * height : 0;\n\n            case 'average':\n              return width > 0 && height > 0 ? paddingObject.pfValue * (width + height) / 2 : 0;\n\n            case 'min':\n              return width > 0 && height > 0 ? width > height ? paddingObject.pfValue * height : paddingObject.pfValue * width : 0;\n\n            case 'max':\n              return width > 0 && height > 0 ? width > height ? paddingObject.pfValue * width : paddingObject.pfValue * height : 0;\n\n            default:\n              return 0;\n          }\n        } else if (paddingObject.units === 'px') {\n          return paddingObject.pfValue;\n        } else {\n          return 0;\n        }\n      }\n\n      var leftVal = min.width.left.value;\n\n      if (min.width.left.units === 'px' && min.width.val > 0) {\n        leftVal = leftVal * 100 / min.width.val;\n      }\n\n      var rightVal = min.width.right.value;\n\n      if (min.width.right.units === 'px' && min.width.val > 0) {\n        rightVal = rightVal * 100 / min.width.val;\n      }\n\n      var topVal = min.height.top.value;\n\n      if (min.height.top.units === 'px' && min.height.val > 0) {\n        topVal = topVal * 100 / min.height.val;\n      }\n\n      var bottomVal = min.height.bottom.value;\n\n      if (min.height.bottom.units === 'px' && min.height.val > 0) {\n        bottomVal = bottomVal * 100 / min.height.val;\n      }\n\n      var widthBiasDiffs = computeBiasValues(min.width.val - bb.w, leftVal, rightVal);\n      var diffLeft = widthBiasDiffs.biasDiff;\n      var diffRight = widthBiasDiffs.biasComplementDiff;\n      var heightBiasDiffs = computeBiasValues(min.height.val - bb.h, topVal, bottomVal);\n      var diffTop = heightBiasDiffs.biasDiff;\n      var diffBottom = heightBiasDiffs.biasComplementDiff;\n      _p.autoPadding = computePaddingValues(bb.w, bb.h, parent.pstyle('padding'), parent.pstyle('padding-relative-to').value);\n      _p.autoWidth = Math.max(bb.w, min.width.val);\n      pos.x = (-diffLeft + bb.x1 + bb.x2 + diffRight) / 2;\n      _p.autoHeight = Math.max(bb.h, min.height.val);\n      pos.y = (-diffTop + bb.y1 + bb.y2 + diffBottom) / 2;\n    }\n\n    for (var i = 0; i < this.length; i++) {\n      var ele = this[i];\n      var _p = ele._private;\n\n      if (!_p.compoundBoundsClean || force) {\n        update(ele);\n\n        if (!cy.batching()) {\n          _p.compoundBoundsClean = true;\n        }\n      }\n    }\n\n    return this;\n  };\n\n  var noninf = function noninf(x) {\n    if (x === Infinity || x === -Infinity) {\n      return 0;\n    }\n\n    return x;\n  };\n\n  var updateBounds = function updateBounds(b, x1, y1, x2, y2) {\n    // don't update with zero area boxes\n    if (x2 - x1 === 0 || y2 - y1 === 0) {\n      return;\n    } // don't update with null dim\n\n\n    if (x1 == null || y1 == null || x2 == null || y2 == null) {\n      return;\n    }\n\n    b.x1 = x1 < b.x1 ? x1 : b.x1;\n    b.x2 = x2 > b.x2 ? x2 : b.x2;\n    b.y1 = y1 < b.y1 ? y1 : b.y1;\n    b.y2 = y2 > b.y2 ? y2 : b.y2;\n    b.w = b.x2 - b.x1;\n    b.h = b.y2 - b.y1;\n  };\n\n  var updateBoundsFromBox = function updateBoundsFromBox(b, b2) {\n    if (b2 == null) {\n      return b;\n    }\n\n    return updateBounds(b, b2.x1, b2.y1, b2.x2, b2.y2);\n  };\n\n  var prefixedProperty = function prefixedProperty(obj, field, prefix) {\n    return getPrefixedProperty(obj, field, prefix);\n  };\n\n  var updateBoundsFromArrow = function updateBoundsFromArrow(bounds, ele, prefix) {\n    if (ele.cy().headless()) {\n      return;\n    }\n\n    var _p = ele._private;\n    var rstyle = _p.rstyle;\n    var halfArW = rstyle.arrowWidth / 2;\n    var arrowType = ele.pstyle(prefix + '-arrow-shape').value;\n    var x;\n    var y;\n\n    if (arrowType !== 'none') {\n      if (prefix === 'source') {\n        x = rstyle.srcX;\n        y = rstyle.srcY;\n      } else if (prefix === 'target') {\n        x = rstyle.tgtX;\n        y = rstyle.tgtY;\n      } else {\n        x = rstyle.midX;\n        y = rstyle.midY;\n      } // always store the individual arrow bounds\n\n\n      var bbs = _p.arrowBounds = _p.arrowBounds || {};\n      var bb = bbs[prefix] = bbs[prefix] || {};\n      bb.x1 = x - halfArW;\n      bb.y1 = y - halfArW;\n      bb.x2 = x + halfArW;\n      bb.y2 = y + halfArW;\n      bb.w = bb.x2 - bb.x1;\n      bb.h = bb.y2 - bb.y1;\n      expandBoundingBox(bb, 1);\n      updateBounds(bounds, bb.x1, bb.y1, bb.x2, bb.y2);\n    }\n  };\n\n  var updateBoundsFromLabel = function updateBoundsFromLabel(bounds, ele, prefix) {\n    if (ele.cy().headless()) {\n      return;\n    }\n\n    var prefixDash;\n\n    if (prefix) {\n      prefixDash = prefix + '-';\n    } else {\n      prefixDash = '';\n    }\n\n    var _p = ele._private;\n    var rstyle = _p.rstyle;\n    var label = ele.pstyle(prefixDash + 'label').strValue;\n\n    if (label) {\n      var halign = ele.pstyle('text-halign');\n      var valign = ele.pstyle('text-valign');\n      var labelWidth = prefixedProperty(rstyle, 'labelWidth', prefix);\n      var labelHeight = prefixedProperty(rstyle, 'labelHeight', prefix);\n      var labelX = prefixedProperty(rstyle, 'labelX', prefix);\n      var labelY = prefixedProperty(rstyle, 'labelY', prefix);\n      var marginX = ele.pstyle(prefixDash + 'text-margin-x').pfValue;\n      var marginY = ele.pstyle(prefixDash + 'text-margin-y').pfValue;\n      var isEdge = ele.isEdge();\n      var rotation = ele.pstyle(prefixDash + 'text-rotation');\n      var outlineWidth = ele.pstyle('text-outline-width').pfValue;\n      var borderWidth = ele.pstyle('text-border-width').pfValue;\n      var halfBorderWidth = borderWidth / 2;\n      var padding = ele.pstyle('text-background-padding').pfValue;\n      var marginOfError = 2; // expand to work around browser dimension inaccuracies\n\n      var lh = labelHeight;\n      var lw = labelWidth;\n      var lw_2 = lw / 2;\n      var lh_2 = lh / 2;\n      var lx1, lx2, ly1, ly2;\n\n      if (isEdge) {\n        lx1 = labelX - lw_2;\n        lx2 = labelX + lw_2;\n        ly1 = labelY - lh_2;\n        ly2 = labelY + lh_2;\n      } else {\n        switch (halign.value) {\n          case 'left':\n            lx1 = labelX - lw;\n            lx2 = labelX;\n            break;\n\n          case 'center':\n            lx1 = labelX - lw_2;\n            lx2 = labelX + lw_2;\n            break;\n\n          case 'right':\n            lx1 = labelX;\n            lx2 = labelX + lw;\n            break;\n        }\n\n        switch (valign.value) {\n          case 'top':\n            ly1 = labelY - lh;\n            ly2 = labelY;\n            break;\n\n          case 'center':\n            ly1 = labelY - lh_2;\n            ly2 = labelY + lh_2;\n            break;\n\n          case 'bottom':\n            ly1 = labelY;\n            ly2 = labelY + lh;\n            break;\n        }\n      } // shift by margin and expand by outline and border\n\n\n      lx1 += marginX - Math.max(outlineWidth, halfBorderWidth) - padding - marginOfError;\n      lx2 += marginX + Math.max(outlineWidth, halfBorderWidth) + padding + marginOfError;\n      ly1 += marginY - Math.max(outlineWidth, halfBorderWidth) - padding - marginOfError;\n      ly2 += marginY + Math.max(outlineWidth, halfBorderWidth) + padding + marginOfError; // always store the unrotated label bounds separately\n\n      var bbPrefix = prefix || 'main';\n      var bbs = _p.labelBounds;\n      var bb = bbs[bbPrefix] = bbs[bbPrefix] || {};\n      bb.x1 = lx1;\n      bb.y1 = ly1;\n      bb.x2 = lx2;\n      bb.y2 = ly2;\n      bb.w = lx2 - lx1;\n      bb.h = ly2 - ly1;\n      var isAutorotate = isEdge && rotation.strValue === 'autorotate';\n      var isPfValue = rotation.pfValue != null && rotation.pfValue !== 0;\n\n      if (isAutorotate || isPfValue) {\n        var theta = isAutorotate ? prefixedProperty(_p.rstyle, 'labelAngle', prefix) : rotation.pfValue;\n        var cos = Math.cos(theta);\n        var sin = Math.sin(theta); // rotation point (default value for center-center)\n\n        var xo = (lx1 + lx2) / 2;\n        var yo = (ly1 + ly2) / 2;\n\n        if (!isEdge) {\n          switch (halign.value) {\n            case 'left':\n              xo = lx2;\n              break;\n\n            case 'right':\n              xo = lx1;\n              break;\n          }\n\n          switch (valign.value) {\n            case 'top':\n              yo = ly2;\n              break;\n\n            case 'bottom':\n              yo = ly1;\n              break;\n          }\n        }\n\n        var rotate = function rotate(x, y) {\n          x = x - xo;\n          y = y - yo;\n          return {\n            x: x * cos - y * sin + xo,\n            y: x * sin + y * cos + yo\n          };\n        };\n\n        var px1y1 = rotate(lx1, ly1);\n        var px1y2 = rotate(lx1, ly2);\n        var px2y1 = rotate(lx2, ly1);\n        var px2y2 = rotate(lx2, ly2);\n        lx1 = Math.min(px1y1.x, px1y2.x, px2y1.x, px2y2.x);\n        lx2 = Math.max(px1y1.x, px1y2.x, px2y1.x, px2y2.x);\n        ly1 = Math.min(px1y1.y, px1y2.y, px2y1.y, px2y2.y);\n        ly2 = Math.max(px1y1.y, px1y2.y, px2y1.y, px2y2.y);\n      }\n\n      var bbPrefixRot = bbPrefix + 'Rot';\n      var bbRot = bbs[bbPrefixRot] = bbs[bbPrefixRot] || {};\n      bbRot.x1 = lx1;\n      bbRot.y1 = ly1;\n      bbRot.x2 = lx2;\n      bbRot.y2 = ly2;\n      bbRot.w = lx2 - lx1;\n      bbRot.h = ly2 - ly1;\n      updateBounds(bounds, lx1, ly1, lx2, ly2);\n      updateBounds(_p.labelBounds.all, lx1, ly1, lx2, ly2);\n    }\n\n    return bounds;\n  }; // get the bounding box of the elements (in raw model position)\n\n\n  var boundingBoxImpl = function boundingBoxImpl(ele, options) {\n    var cy = ele._private.cy;\n    var styleEnabled = cy.styleEnabled();\n    var headless = cy.headless();\n    var bounds = makeBoundingBox();\n    var _p = ele._private;\n    var isNode = ele.isNode();\n    var isEdge = ele.isEdge();\n    var ex1, ex2, ey1, ey2; // extrema of body / lines\n\n    var x, y; // node pos\n\n    var rstyle = _p.rstyle;\n    var manualExpansion = isNode && styleEnabled ? ele.pstyle('bounds-expansion').pfValue : [0]; // must use `display` prop only, as reading `compound.width()` causes recursion\n    // (other factors like width values will be considered later in this function anyway)\n\n    var isDisplayed = function isDisplayed(ele) {\n      return ele.pstyle('display').value !== 'none';\n    };\n\n    var displayed = !styleEnabled || isDisplayed(ele) // must take into account connected nodes b/c of implicit edge hiding on display:none node\n    && (!isEdge || isDisplayed(ele.source()) && isDisplayed(ele.target()));\n\n    if (displayed) {\n      // displayed suffices, since we will find zero area eles anyway\n      var overlayOpacity = 0;\n      var overlayPadding = 0;\n\n      if (styleEnabled && options.includeOverlays) {\n        overlayOpacity = ele.pstyle('overlay-opacity').value;\n\n        if (overlayOpacity !== 0) {\n          overlayPadding = ele.pstyle('overlay-padding').value;\n        }\n      }\n\n      var underlayOpacity = 0;\n      var underlayPadding = 0;\n\n      if (styleEnabled && options.includeUnderlays) {\n        underlayOpacity = ele.pstyle('underlay-opacity').value;\n\n        if (underlayOpacity !== 0) {\n          underlayPadding = ele.pstyle('underlay-padding').value;\n        }\n      }\n\n      var padding = Math.max(overlayPadding, underlayPadding);\n      var w = 0;\n      var wHalf = 0;\n\n      if (styleEnabled) {\n        w = ele.pstyle('width').pfValue;\n        wHalf = w / 2;\n      }\n\n      if (isNode && options.includeNodes) {\n        var pos = ele.position();\n        x = pos.x;\n        y = pos.y;\n\n        var _w = ele.outerWidth();\n\n        var halfW = _w / 2;\n        var h = ele.outerHeight();\n        var halfH = h / 2; // handle node dimensions\n        /////////////////////////\n\n        ex1 = x - halfW;\n        ex2 = x + halfW;\n        ey1 = y - halfH;\n        ey2 = y + halfH;\n        updateBounds(bounds, ex1, ey1, ex2, ey2);\n      } else if (isEdge && options.includeEdges) {\n        if (styleEnabled && !headless) {\n          var curveStyle = ele.pstyle('curve-style').strValue; // handle edge dimensions (rough box estimate)\n          //////////////////////////////////////////////\n\n          ex1 = Math.min(rstyle.srcX, rstyle.midX, rstyle.tgtX);\n          ex2 = Math.max(rstyle.srcX, rstyle.midX, rstyle.tgtX);\n          ey1 = Math.min(rstyle.srcY, rstyle.midY, rstyle.tgtY);\n          ey2 = Math.max(rstyle.srcY, rstyle.midY, rstyle.tgtY); // take into account edge width\n\n          ex1 -= wHalf;\n          ex2 += wHalf;\n          ey1 -= wHalf;\n          ey2 += wHalf;\n          updateBounds(bounds, ex1, ey1, ex2, ey2); // precise edges\n          ////////////////\n\n          if (curveStyle === 'haystack') {\n            var hpts = rstyle.haystackPts;\n\n            if (hpts && hpts.length === 2) {\n              ex1 = hpts[0].x;\n              ey1 = hpts[0].y;\n              ex2 = hpts[1].x;\n              ey2 = hpts[1].y;\n\n              if (ex1 > ex2) {\n                var temp = ex1;\n                ex1 = ex2;\n                ex2 = temp;\n              }\n\n              if (ey1 > ey2) {\n                var _temp = ey1;\n                ey1 = ey2;\n                ey2 = _temp;\n              }\n\n              updateBounds(bounds, ex1 - wHalf, ey1 - wHalf, ex2 + wHalf, ey2 + wHalf);\n            }\n          } else if (curveStyle === 'bezier' || curveStyle === 'unbundled-bezier' || curveStyle === 'segments' || curveStyle === 'taxi') {\n            var pts;\n\n            switch (curveStyle) {\n              case 'bezier':\n              case 'unbundled-bezier':\n                pts = rstyle.bezierPts;\n                break;\n\n              case 'segments':\n              case 'taxi':\n                pts = rstyle.linePts;\n                break;\n            }\n\n            if (pts != null) {\n              for (var j = 0; j < pts.length; j++) {\n                var pt = pts[j];\n                ex1 = pt.x - wHalf;\n                ex2 = pt.x + wHalf;\n                ey1 = pt.y - wHalf;\n                ey2 = pt.y + wHalf;\n                updateBounds(bounds, ex1, ey1, ex2, ey2);\n              }\n            }\n          } // bezier-like or segment-like edge\n\n        } else {\n          // headless or style disabled\n          // fallback on source and target positions\n          //////////////////////////////////////////\n          var n1 = ele.source();\n          var n1pos = n1.position();\n          var n2 = ele.target();\n          var n2pos = n2.position();\n          ex1 = n1pos.x;\n          ex2 = n2pos.x;\n          ey1 = n1pos.y;\n          ey2 = n2pos.y;\n\n          if (ex1 > ex2) {\n            var _temp2 = ex1;\n            ex1 = ex2;\n            ex2 = _temp2;\n          }\n\n          if (ey1 > ey2) {\n            var _temp3 = ey1;\n            ey1 = ey2;\n            ey2 = _temp3;\n          } // take into account edge width\n\n\n          ex1 -= wHalf;\n          ex2 += wHalf;\n          ey1 -= wHalf;\n          ey2 += wHalf;\n          updateBounds(bounds, ex1, ey1, ex2, ey2);\n        } // headless or style disabled\n\n      } // edges\n      // handle edge arrow size\n      /////////////////////////\n\n\n      if (styleEnabled && options.includeEdges && isEdge) {\n        updateBoundsFromArrow(bounds, ele, 'mid-source');\n        updateBoundsFromArrow(bounds, ele, 'mid-target');\n        updateBoundsFromArrow(bounds, ele, 'source');\n        updateBoundsFromArrow(bounds, ele, 'target');\n      } // ghost\n      ////////\n\n\n      if (styleEnabled) {\n        var ghost = ele.pstyle('ghost').value === 'yes';\n\n        if (ghost) {\n          var gx = ele.pstyle('ghost-offset-x').pfValue;\n          var gy = ele.pstyle('ghost-offset-y').pfValue;\n          updateBounds(bounds, bounds.x1 + gx, bounds.y1 + gy, bounds.x2 + gx, bounds.y2 + gy);\n        }\n      } // always store the body bounds separately from the labels\n\n\n      var bbBody = _p.bodyBounds = _p.bodyBounds || {};\n      assignBoundingBox(bbBody, bounds);\n      expandBoundingBoxSides(bbBody, manualExpansion);\n      expandBoundingBox(bbBody, 1); // expand to work around browser dimension inaccuracies\n      // overlay\n      //////////\n\n      if (styleEnabled) {\n        ex1 = bounds.x1;\n        ex2 = bounds.x2;\n        ey1 = bounds.y1;\n        ey2 = bounds.y2;\n        updateBounds(bounds, ex1 - padding, ey1 - padding, ex2 + padding, ey2 + padding);\n      } // always store the body bounds separately from the labels\n\n\n      var bbOverlay = _p.overlayBounds = _p.overlayBounds || {};\n      assignBoundingBox(bbOverlay, bounds);\n      expandBoundingBoxSides(bbOverlay, manualExpansion);\n      expandBoundingBox(bbOverlay, 1); // expand to work around browser dimension inaccuracies\n      // handle label dimensions\n      //////////////////////////\n\n      var bbLabels = _p.labelBounds = _p.labelBounds || {};\n\n      if (bbLabels.all != null) {\n        clearBoundingBox(bbLabels.all);\n      } else {\n        bbLabels.all = makeBoundingBox();\n      }\n\n      if (styleEnabled && options.includeLabels) {\n        if (options.includeMainLabels) {\n          updateBoundsFromLabel(bounds, ele, null);\n        }\n\n        if (isEdge) {\n          if (options.includeSourceLabels) {\n            updateBoundsFromLabel(bounds, ele, 'source');\n          }\n\n          if (options.includeTargetLabels) {\n            updateBoundsFromLabel(bounds, ele, 'target');\n          }\n        }\n      } // style enabled for labels\n\n    } // if displayed\n\n\n    bounds.x1 = noninf(bounds.x1);\n    bounds.y1 = noninf(bounds.y1);\n    bounds.x2 = noninf(bounds.x2);\n    bounds.y2 = noninf(bounds.y2);\n    bounds.w = noninf(bounds.x2 - bounds.x1);\n    bounds.h = noninf(bounds.y2 - bounds.y1);\n\n    if (bounds.w > 0 && bounds.h > 0 && displayed) {\n      expandBoundingBoxSides(bounds, manualExpansion); // expand bounds by 1 because antialiasing can increase the visual/effective size by 1 on all sides\n\n      expandBoundingBox(bounds, 1);\n    }\n\n    return bounds;\n  };\n\n  var getKey = function getKey(opts) {\n    var i = 0;\n\n    var tf = function tf(val) {\n      return (val ? 1 : 0) << i++;\n    };\n\n    var key = 0;\n    key += tf(opts.incudeNodes);\n    key += tf(opts.includeEdges);\n    key += tf(opts.includeLabels);\n    key += tf(opts.includeMainLabels);\n    key += tf(opts.includeSourceLabels);\n    key += tf(opts.includeTargetLabels);\n    key += tf(opts.includeOverlays);\n    return key;\n  };\n\n  var getBoundingBoxPosKey = function getBoundingBoxPosKey(ele) {\n    if (ele.isEdge()) {\n      var p1 = ele.source().position();\n      var p2 = ele.target().position();\n\n      var r = function r(x) {\n        return Math.round(x);\n      };\n\n      return hashIntsArray([r(p1.x), r(p1.y), r(p2.x), r(p2.y)]);\n    } else {\n      return 0;\n    }\n  };\n\n  var cachedBoundingBoxImpl = function cachedBoundingBoxImpl(ele, opts) {\n    var _p = ele._private;\n    var bb;\n    var isEdge = ele.isEdge();\n    var key = opts == null ? defBbOptsKey : getKey(opts);\n    var usingDefOpts = key === defBbOptsKey;\n    var currPosKey = getBoundingBoxPosKey(ele);\n    var isPosKeySame = _p.bbCachePosKey === currPosKey;\n    var useCache = opts.useCache && isPosKeySame;\n\n    var isDirty = function isDirty(ele) {\n      return ele._private.bbCache == null || ele._private.styleDirty;\n    };\n\n    var needRecalc = !useCache || isDirty(ele) || isEdge && isDirty(ele.source()) || isDirty(ele.target());\n\n    if (needRecalc) {\n      if (!isPosKeySame) {\n        ele.recalculateRenderedStyle(useCache);\n      }\n\n      bb = boundingBoxImpl(ele, defBbOpts);\n      _p.bbCache = bb;\n      _p.bbCachePosKey = currPosKey;\n    } else {\n      bb = _p.bbCache;\n    } // not using def opts => need to build up bb from combination of sub bbs\n\n\n    if (!usingDefOpts) {\n      var isNode = ele.isNode();\n      bb = makeBoundingBox();\n\n      if (opts.includeNodes && isNode || opts.includeEdges && !isNode) {\n        if (opts.includeOverlays) {\n          updateBoundsFromBox(bb, _p.overlayBounds);\n        } else {\n          updateBoundsFromBox(bb, _p.bodyBounds);\n        }\n      }\n\n      if (opts.includeLabels) {\n        if (opts.includeMainLabels && (!isEdge || opts.includeSourceLabels && opts.includeTargetLabels)) {\n          updateBoundsFromBox(bb, _p.labelBounds.all);\n        } else {\n          if (opts.includeMainLabels) {\n            updateBoundsFromBox(bb, _p.labelBounds.mainRot);\n          }\n\n          if (opts.includeSourceLabels) {\n            updateBoundsFromBox(bb, _p.labelBounds.sourceRot);\n          }\n\n          if (opts.includeTargetLabels) {\n            updateBoundsFromBox(bb, _p.labelBounds.targetRot);\n          }\n        }\n      }\n\n      bb.w = bb.x2 - bb.x1;\n      bb.h = bb.y2 - bb.y1;\n    }\n\n    return bb;\n  };\n\n  var defBbOpts = {\n    includeNodes: true,\n    includeEdges: true,\n    includeLabels: true,\n    includeMainLabels: true,\n    includeSourceLabels: true,\n    includeTargetLabels: true,\n    includeOverlays: true,\n    includeUnderlays: true,\n    useCache: true\n  };\n  var defBbOptsKey = getKey(defBbOpts);\n  var filledBbOpts = defaults$g(defBbOpts);\n\n  elesfn$b.boundingBox = function (options) {\n    var bounds; // the main usecase is ele.boundingBox() for a single element with no/def options\n    // specified s.t. the cache is used, so check for this case to make it faster by\n    // avoiding the overhead of the rest of the function\n\n    if (this.length === 1 && this[0]._private.bbCache != null && !this[0]._private.styleDirty && (options === undefined || options.useCache === undefined || options.useCache === true)) {\n      if (options === undefined) {\n        options = defBbOpts;\n      } else {\n        options = filledBbOpts(options);\n      }\n\n      bounds = cachedBoundingBoxImpl(this[0], options);\n    } else {\n      bounds = makeBoundingBox();\n      options = options || defBbOpts;\n      var opts = filledBbOpts(options);\n      var eles = this;\n      var cy = eles.cy();\n      var styleEnabled = cy.styleEnabled();\n\n      if (styleEnabled) {\n        for (var i = 0; i < eles.length; i++) {\n          var ele = eles[i];\n          var _p = ele._private;\n          var currPosKey = getBoundingBoxPosKey(ele);\n          var isPosKeySame = _p.bbCachePosKey === currPosKey;\n          var useCache = opts.useCache && isPosKeySame && !_p.styleDirty;\n          ele.recalculateRenderedStyle(useCache);\n        }\n      }\n\n      this.updateCompoundBounds(!options.useCache);\n\n      for (var _i = 0; _i < eles.length; _i++) {\n        var _ele = eles[_i];\n        updateBoundsFromBox(bounds, cachedBoundingBoxImpl(_ele, opts));\n      }\n    }\n\n    bounds.x1 = noninf(bounds.x1);\n    bounds.y1 = noninf(bounds.y1);\n    bounds.x2 = noninf(bounds.x2);\n    bounds.y2 = noninf(bounds.y2);\n    bounds.w = noninf(bounds.x2 - bounds.x1);\n    bounds.h = noninf(bounds.y2 - bounds.y1);\n    return bounds;\n  };\n\n  elesfn$b.dirtyBoundingBoxCache = function () {\n    for (var i = 0; i < this.length; i++) {\n      var _p = this[i]._private;\n      _p.bbCache = null;\n      _p.bbCachePosKey = null;\n      _p.bodyBounds = null;\n      _p.overlayBounds = null;\n      _p.labelBounds.all = null;\n      _p.labelBounds.source = null;\n      _p.labelBounds.target = null;\n      _p.labelBounds.main = null;\n      _p.labelBounds.sourceRot = null;\n      _p.labelBounds.targetRot = null;\n      _p.labelBounds.mainRot = null;\n      _p.arrowBounds.source = null;\n      _p.arrowBounds.target = null;\n      _p.arrowBounds['mid-source'] = null;\n      _p.arrowBounds['mid-target'] = null;\n    }\n\n    this.emitAndNotify('bounds');\n    return this;\n  }; // private helper to get bounding box for custom node positions\n  // - good for perf in certain cases but currently requires dirtying the rendered style\n  // - would be better to not modify the nodes but the nodes are read directly everywhere in the renderer...\n  // - try to use for only things like discrete layouts where the node position would change anyway\n\n\n  elesfn$b.boundingBoxAt = function (fn) {\n    var nodes = this.nodes();\n    var cy = this.cy();\n    var hasCompoundNodes = cy.hasCompoundNodes();\n    var parents = cy.collection();\n\n    if (hasCompoundNodes) {\n      parents = nodes.filter(function (node) {\n        return node.isParent();\n      });\n      nodes = nodes.not(parents);\n    }\n\n    if (plainObject(fn)) {\n      var obj = fn;\n\n      fn = function fn() {\n        return obj;\n      };\n    }\n\n    var storeOldPos = function storeOldPos(node, i) {\n      return node._private.bbAtOldPos = fn(node, i);\n    };\n\n    var getOldPos = function getOldPos(node) {\n      return node._private.bbAtOldPos;\n    };\n\n    cy.startBatch();\n    nodes.forEach(storeOldPos).silentPositions(fn);\n\n    if (hasCompoundNodes) {\n      parents.dirtyCompoundBoundsCache();\n      parents.dirtyBoundingBoxCache();\n      parents.updateCompoundBounds(true); // force update b/c we're inside a batch cycle\n    }\n\n    var bb = copyBoundingBox(this.boundingBox({\n      useCache: false\n    }));\n    nodes.silentPositions(getOldPos);\n\n    if (hasCompoundNodes) {\n      parents.dirtyCompoundBoundsCache();\n      parents.dirtyBoundingBoxCache();\n      parents.updateCompoundBounds(true); // force update b/c we're inside a batch cycle\n    }\n\n    cy.endBatch();\n    return bb;\n  };\n\n  fn$3.boundingbox = fn$3.bb = fn$3.boundingBox;\n  fn$3.renderedBoundingbox = fn$3.renderedBoundingBox;\n  var bounds = elesfn$b;\n\n  var fn$2, elesfn$a;\n  fn$2 = elesfn$a = {};\n\n  var defineDimFns = function defineDimFns(opts) {\n    opts.uppercaseName = capitalize(opts.name);\n    opts.autoName = 'auto' + opts.uppercaseName;\n    opts.labelName = 'label' + opts.uppercaseName;\n    opts.outerName = 'outer' + opts.uppercaseName;\n    opts.uppercaseOuterName = capitalize(opts.outerName);\n\n    fn$2[opts.name] = function dimImpl() {\n      var ele = this[0];\n      var _p = ele._private;\n      var cy = _p.cy;\n      var styleEnabled = cy._private.styleEnabled;\n\n      if (ele) {\n        if (styleEnabled) {\n          if (ele.isParent()) {\n            ele.updateCompoundBounds();\n            return _p[opts.autoName] || 0;\n          }\n\n          var d = ele.pstyle(opts.name);\n\n          switch (d.strValue) {\n            case 'label':\n              ele.recalculateRenderedStyle();\n              return _p.rstyle[opts.labelName] || 0;\n\n            default:\n              return d.pfValue;\n          }\n        } else {\n          return 1;\n        }\n      }\n    };\n\n    fn$2['outer' + opts.uppercaseName] = function outerDimImpl() {\n      var ele = this[0];\n      var _p = ele._private;\n      var cy = _p.cy;\n      var styleEnabled = cy._private.styleEnabled;\n\n      if (ele) {\n        if (styleEnabled) {\n          var dim = ele[opts.name]();\n          var border = ele.pstyle('border-width').pfValue; // n.b. 1/2 each side\n\n          var padding = 2 * ele.padding();\n          return dim + border + padding;\n        } else {\n          return 1;\n        }\n      }\n    };\n\n    fn$2['rendered' + opts.uppercaseName] = function renderedDimImpl() {\n      var ele = this[0];\n\n      if (ele) {\n        var d = ele[opts.name]();\n        return d * this.cy().zoom();\n      }\n    };\n\n    fn$2['rendered' + opts.uppercaseOuterName] = function renderedOuterDimImpl() {\n      var ele = this[0];\n\n      if (ele) {\n        var od = ele[opts.outerName]();\n        return od * this.cy().zoom();\n      }\n    };\n  };\n\n  defineDimFns({\n    name: 'width'\n  });\n  defineDimFns({\n    name: 'height'\n  });\n\n  elesfn$a.padding = function () {\n    var ele = this[0];\n    var _p = ele._private;\n\n    if (ele.isParent()) {\n      ele.updateCompoundBounds();\n\n      if (_p.autoPadding !== undefined) {\n        return _p.autoPadding;\n      } else {\n        return ele.pstyle('padding').pfValue;\n      }\n    } else {\n      return ele.pstyle('padding').pfValue;\n    }\n  };\n\n  elesfn$a.paddedHeight = function () {\n    var ele = this[0];\n    return ele.height() + 2 * ele.padding();\n  };\n\n  elesfn$a.paddedWidth = function () {\n    var ele = this[0];\n    return ele.width() + 2 * ele.padding();\n  };\n\n  var widthHeight = elesfn$a;\n\n  var ifEdge = function ifEdge(ele, getValue) {\n    if (ele.isEdge()) {\n      return getValue(ele);\n    }\n  };\n\n  var ifEdgeRenderedPosition = function ifEdgeRenderedPosition(ele, getPoint) {\n    if (ele.isEdge()) {\n      var cy = ele.cy();\n      return modelToRenderedPosition(getPoint(ele), cy.zoom(), cy.pan());\n    }\n  };\n\n  var ifEdgeRenderedPositions = function ifEdgeRenderedPositions(ele, getPoints) {\n    if (ele.isEdge()) {\n      var cy = ele.cy();\n      var pan = cy.pan();\n      var zoom = cy.zoom();\n      return getPoints(ele).map(function (p) {\n        return modelToRenderedPosition(p, zoom, pan);\n      });\n    }\n  };\n\n  var controlPoints = function controlPoints(ele) {\n    return ele.renderer().getControlPoints(ele);\n  };\n\n  var segmentPoints = function segmentPoints(ele) {\n    return ele.renderer().getSegmentPoints(ele);\n  };\n\n  var sourceEndpoint = function sourceEndpoint(ele) {\n    return ele.renderer().getSourceEndpoint(ele);\n  };\n\n  var targetEndpoint = function targetEndpoint(ele) {\n    return ele.renderer().getTargetEndpoint(ele);\n  };\n\n  var midpoint = function midpoint(ele) {\n    return ele.renderer().getEdgeMidpoint(ele);\n  };\n\n  var pts = {\n    controlPoints: {\n      get: controlPoints,\n      mult: true\n    },\n    segmentPoints: {\n      get: segmentPoints,\n      mult: true\n    },\n    sourceEndpoint: {\n      get: sourceEndpoint\n    },\n    targetEndpoint: {\n      get: targetEndpoint\n    },\n    midpoint: {\n      get: midpoint\n    }\n  };\n\n  var renderedName = function renderedName(name) {\n    return 'rendered' + name[0].toUpperCase() + name.substr(1);\n  };\n\n  var edgePoints = Object.keys(pts).reduce(function (obj, name) {\n    var spec = pts[name];\n    var rName = renderedName(name);\n\n    obj[name] = function () {\n      return ifEdge(this, spec.get);\n    };\n\n    if (spec.mult) {\n      obj[rName] = function () {\n        return ifEdgeRenderedPositions(this, spec.get);\n      };\n    } else {\n      obj[rName] = function () {\n        return ifEdgeRenderedPosition(this, spec.get);\n      };\n    }\n\n    return obj;\n  }, {});\n\n  var dimensions = extend({}, position, bounds, widthHeight, edgePoints);\n\n  /*!\n  Event object based on jQuery events, MIT license\n\n  https://jquery.org/license/\n  https://tldrlegal.com/license/mit-license\n  https://github.com/jquery/jquery/blob/master/src/event.js\n  */\n  var Event = function Event(src, props) {\n    this.recycle(src, props);\n  };\n\n  function returnFalse() {\n    return false;\n  }\n\n  function returnTrue() {\n    return true;\n  } // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\n\n\n  Event.prototype = {\n    instanceString: function instanceString() {\n      return 'event';\n    },\n    recycle: function recycle(src, props) {\n      this.isImmediatePropagationStopped = this.isPropagationStopped = this.isDefaultPrevented = returnFalse;\n\n      if (src != null && src.preventDefault) {\n        // Browser Event object\n        this.type = src.type; // Events bubbling up the document may have been marked as prevented\n        // by a handler lower down the tree; reflect the correct value.\n\n        this.isDefaultPrevented = src.defaultPrevented ? returnTrue : returnFalse;\n      } else if (src != null && src.type) {\n        // Plain object containing all event details\n        props = src;\n      } else {\n        // Event string\n        this.type = src;\n      } // Put explicitly provided properties onto the event object\n\n\n      if (props != null) {\n        // more efficient to manually copy fields we use\n        this.originalEvent = props.originalEvent;\n        this.type = props.type != null ? props.type : this.type;\n        this.cy = props.cy;\n        this.target = props.target;\n        this.position = props.position;\n        this.renderedPosition = props.renderedPosition;\n        this.namespace = props.namespace;\n        this.layout = props.layout;\n      }\n\n      if (this.cy != null && this.position != null && this.renderedPosition == null) {\n        // create a rendered position based on the passed position\n        var pos = this.position;\n        var zoom = this.cy.zoom();\n        var pan = this.cy.pan();\n        this.renderedPosition = {\n          x: pos.x * zoom + pan.x,\n          y: pos.y * zoom + pan.y\n        };\n      } // Create a timestamp if incoming event doesn't have one\n\n\n      this.timeStamp = src && src.timeStamp || Date.now();\n    },\n    preventDefault: function preventDefault() {\n      this.isDefaultPrevented = returnTrue;\n      var e = this.originalEvent;\n\n      if (!e) {\n        return;\n      } // if preventDefault exists run it on the original event\n\n\n      if (e.preventDefault) {\n        e.preventDefault();\n      }\n    },\n    stopPropagation: function stopPropagation() {\n      this.isPropagationStopped = returnTrue;\n      var e = this.originalEvent;\n\n      if (!e) {\n        return;\n      } // if stopPropagation exists run it on the original event\n\n\n      if (e.stopPropagation) {\n        e.stopPropagation();\n      }\n    },\n    stopImmediatePropagation: function stopImmediatePropagation() {\n      this.isImmediatePropagationStopped = returnTrue;\n      this.stopPropagation();\n    },\n    isDefaultPrevented: returnFalse,\n    isPropagationStopped: returnFalse,\n    isImmediatePropagationStopped: returnFalse\n  };\n\n  var eventRegex = /^([^.]+)(\\.(?:[^.]+))?$/; // regex for matching event strings (e.g. \"click.namespace\")\n\n  var universalNamespace = '.*'; // matches as if no namespace specified and prevents users from unbinding accidentally\n\n  var defaults$8 = {\n    qualifierCompare: function qualifierCompare(q1, q2) {\n      return q1 === q2;\n    },\n    eventMatches: function\n      /*context, listener, eventObj*/\n    eventMatches() {\n      return true;\n    },\n    addEventFields: function\n      /*context, evt*/\n    addEventFields() {},\n    callbackContext: function callbackContext(context\n    /*, listener, eventObj*/\n    ) {\n      return context;\n    },\n    beforeEmit: function\n      /* context, listener, eventObj */\n    beforeEmit() {},\n    afterEmit: function\n      /* context, listener, eventObj */\n    afterEmit() {},\n    bubble: function\n      /*context*/\n    bubble() {\n      return false;\n    },\n    parent: function\n      /*context*/\n    parent() {\n      return null;\n    },\n    context: null\n  };\n  var defaultsKeys = Object.keys(defaults$8);\n  var emptyOpts = {};\n\n  function Emitter() {\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : emptyOpts;\n    var context = arguments.length > 1 ? arguments[1] : undefined;\n\n    // micro-optimisation vs Object.assign() -- reduces Element instantiation time\n    for (var i = 0; i < defaultsKeys.length; i++) {\n      var key = defaultsKeys[i];\n      this[key] = opts[key] || defaults$8[key];\n    }\n\n    this.context = context || this.context;\n    this.listeners = [];\n    this.emitting = 0;\n  }\n\n  var p = Emitter.prototype;\n\n  var forEachEvent = function forEachEvent(self, handler, events, qualifier, callback, conf, confOverrides) {\n    if (fn$6(qualifier)) {\n      callback = qualifier;\n      qualifier = null;\n    }\n\n    if (confOverrides) {\n      if (conf == null) {\n        conf = confOverrides;\n      } else {\n        conf = extend({}, conf, confOverrides);\n      }\n    }\n\n    var eventList = array(events) ? events : events.split(/\\s+/);\n\n    for (var i = 0; i < eventList.length; i++) {\n      var evt = eventList[i];\n\n      if (emptyString(evt)) {\n        continue;\n      }\n\n      var match = evt.match(eventRegex); // type[.namespace]\n\n      if (match) {\n        var type = match[1];\n        var namespace = match[2] ? match[2] : null;\n        var ret = handler(self, evt, type, namespace, qualifier, callback, conf);\n\n        if (ret === false) {\n          break;\n        } // allow exiting early\n\n      }\n    }\n  };\n\n  var makeEventObj = function makeEventObj(self, obj) {\n    self.addEventFields(self.context, obj);\n    return new Event(obj.type, obj);\n  };\n\n  var forEachEventObj = function forEachEventObj(self, handler, events) {\n    if (event(events)) {\n      handler(self, events);\n      return;\n    } else if (plainObject(events)) {\n      handler(self, makeEventObj(self, events));\n      return;\n    }\n\n    var eventList = array(events) ? events : events.split(/\\s+/);\n\n    for (var i = 0; i < eventList.length; i++) {\n      var evt = eventList[i];\n\n      if (emptyString(evt)) {\n        continue;\n      }\n\n      var match = evt.match(eventRegex); // type[.namespace]\n\n      if (match) {\n        var type = match[1];\n        var namespace = match[2] ? match[2] : null;\n        var eventObj = makeEventObj(self, {\n          type: type,\n          namespace: namespace,\n          target: self.context\n        });\n        handler(self, eventObj);\n      }\n    }\n  };\n\n  p.on = p.addListener = function (events, qualifier, callback, conf, confOverrides) {\n    forEachEvent(this, function (self, event, type, namespace, qualifier, callback, conf) {\n      if (fn$6(callback)) {\n        self.listeners.push({\n          event: event,\n          // full event string\n          callback: callback,\n          // callback to run\n          type: type,\n          // the event type (e.g. 'click')\n          namespace: namespace,\n          // the event namespace (e.g. \".foo\")\n          qualifier: qualifier,\n          // a restriction on whether to match this emitter\n          conf: conf // additional configuration\n\n        });\n      }\n    }, events, qualifier, callback, conf, confOverrides);\n    return this;\n  };\n\n  p.one = function (events, qualifier, callback, conf) {\n    return this.on(events, qualifier, callback, conf, {\n      one: true\n    });\n  };\n\n  p.removeListener = p.off = function (events, qualifier, callback, conf) {\n    var _this = this;\n\n    if (this.emitting !== 0) {\n      this.listeners = copyArray$1(this.listeners);\n    }\n\n    var listeners = this.listeners;\n\n    var _loop = function _loop(i) {\n      var listener = listeners[i];\n      forEachEvent(_this, function (self, event, type, namespace, qualifier, callback\n      /*, conf*/\n      ) {\n        if ((listener.type === type || events === '*') && (!namespace && listener.namespace !== '.*' || listener.namespace === namespace) && (!qualifier || self.qualifierCompare(listener.qualifier, qualifier)) && (!callback || listener.callback === callback)) {\n          listeners.splice(i, 1);\n          return false;\n        }\n      }, events, qualifier, callback, conf);\n    };\n\n    for (var i = listeners.length - 1; i >= 0; i--) {\n      _loop(i);\n    }\n\n    return this;\n  };\n\n  p.removeAllListeners = function () {\n    return this.removeListener('*');\n  };\n\n  p.emit = p.trigger = function (events, extraParams, manualCallback) {\n    var listeners = this.listeners;\n    var numListenersBeforeEmit = listeners.length;\n    this.emitting++;\n\n    if (!array(extraParams)) {\n      extraParams = [extraParams];\n    }\n\n    forEachEventObj(this, function (self, eventObj) {\n      if (manualCallback != null) {\n        listeners = [{\n          event: eventObj.event,\n          type: eventObj.type,\n          namespace: eventObj.namespace,\n          callback: manualCallback\n        }];\n        numListenersBeforeEmit = listeners.length;\n      }\n\n      var _loop2 = function _loop2(i) {\n        var listener = listeners[i];\n\n        if (listener.type === eventObj.type && (!listener.namespace || listener.namespace === eventObj.namespace || listener.namespace === universalNamespace) && self.eventMatches(self.context, listener, eventObj)) {\n          var args = [eventObj];\n\n          if (extraParams != null) {\n            push(args, extraParams);\n          }\n\n          self.beforeEmit(self.context, listener, eventObj);\n\n          if (listener.conf && listener.conf.one) {\n            self.listeners = self.listeners.filter(function (l) {\n              return l !== listener;\n            });\n          }\n\n          var context = self.callbackContext(self.context, listener, eventObj);\n          var ret = listener.callback.apply(context, args);\n          self.afterEmit(self.context, listener, eventObj);\n\n          if (ret === false) {\n            eventObj.stopPropagation();\n            eventObj.preventDefault();\n          }\n        } // if listener matches\n\n      };\n\n      for (var i = 0; i < numListenersBeforeEmit; i++) {\n        _loop2(i);\n      } // for listener\n\n\n      if (self.bubble(self.context) && !eventObj.isPropagationStopped()) {\n        self.parent(self.context).emit(eventObj, extraParams);\n      }\n    }, events);\n    this.emitting--;\n    return this;\n  };\n\n  var emitterOptions$1 = {\n    qualifierCompare: function qualifierCompare(selector1, selector2) {\n      if (selector1 == null || selector2 == null) {\n        return selector1 == null && selector2 == null;\n      } else {\n        return selector1.sameText(selector2);\n      }\n    },\n    eventMatches: function eventMatches(ele, listener, eventObj) {\n      var selector = listener.qualifier;\n\n      if (selector != null) {\n        return ele !== eventObj.target && element(eventObj.target) && selector.matches(eventObj.target);\n      }\n\n      return true;\n    },\n    addEventFields: function addEventFields(ele, evt) {\n      evt.cy = ele.cy();\n      evt.target = ele;\n    },\n    callbackContext: function callbackContext(ele, listener, eventObj) {\n      return listener.qualifier != null ? eventObj.target : ele;\n    },\n    beforeEmit: function beforeEmit(context, listener\n    /*, eventObj*/\n    ) {\n      if (listener.conf && listener.conf.once) {\n        listener.conf.onceCollection.removeListener(listener.event, listener.qualifier, listener.callback);\n      }\n    },\n    bubble: function bubble() {\n      return true;\n    },\n    parent: function parent(ele) {\n      return ele.isChild() ? ele.parent() : ele.cy();\n    }\n  };\n\n  var argSelector$1 = function argSelector(arg) {\n    if (string(arg)) {\n      return new Selector(arg);\n    } else {\n      return arg;\n    }\n  };\n\n  var elesfn$9 = {\n    createEmitter: function createEmitter() {\n      for (var i = 0; i < this.length; i++) {\n        var ele = this[i];\n        var _p = ele._private;\n\n        if (!_p.emitter) {\n          _p.emitter = new Emitter(emitterOptions$1, ele);\n        }\n      }\n\n      return this;\n    },\n    emitter: function emitter() {\n      return this._private.emitter;\n    },\n    on: function on(events, selector, callback) {\n      var argSel = argSelector$1(selector);\n\n      for (var i = 0; i < this.length; i++) {\n        var ele = this[i];\n        ele.emitter().on(events, argSel, callback);\n      }\n\n      return this;\n    },\n    removeListener: function removeListener(events, selector, callback) {\n      var argSel = argSelector$1(selector);\n\n      for (var i = 0; i < this.length; i++) {\n        var ele = this[i];\n        ele.emitter().removeListener(events, argSel, callback);\n      }\n\n      return this;\n    },\n    removeAllListeners: function removeAllListeners() {\n      for (var i = 0; i < this.length; i++) {\n        var ele = this[i];\n        ele.emitter().removeAllListeners();\n      }\n\n      return this;\n    },\n    one: function one(events, selector, callback) {\n      var argSel = argSelector$1(selector);\n\n      for (var i = 0; i < this.length; i++) {\n        var ele = this[i];\n        ele.emitter().one(events, argSel, callback);\n      }\n\n      return this;\n    },\n    once: function once(events, selector, callback) {\n      var argSel = argSelector$1(selector);\n\n      for (var i = 0; i < this.length; i++) {\n        var ele = this[i];\n        ele.emitter().on(events, argSel, callback, {\n          once: true,\n          onceCollection: this\n        });\n      }\n    },\n    emit: function emit(events, extraParams) {\n      for (var i = 0; i < this.length; i++) {\n        var ele = this[i];\n        ele.emitter().emit(events, extraParams);\n      }\n\n      return this;\n    },\n    emitAndNotify: function emitAndNotify(event, extraParams) {\n      // for internal use only\n      if (this.length === 0) {\n        return;\n      } // empty collections don't need to notify anything\n      // notify renderer\n\n\n      this.cy().notify(event, this);\n      this.emit(event, extraParams);\n      return this;\n    }\n  };\n  define.eventAliasesOn(elesfn$9);\n\n  var elesfn$8 = {\n    nodes: function nodes(selector) {\n      return this.filter(function (ele) {\n        return ele.isNode();\n      }).filter(selector);\n    },\n    edges: function edges(selector) {\n      return this.filter(function (ele) {\n        return ele.isEdge();\n      }).filter(selector);\n    },\n    // internal helper to get nodes and edges as separate collections with single iteration over elements\n    byGroup: function byGroup() {\n      var nodes = this.spawn();\n      var edges = this.spawn();\n\n      for (var i = 0; i < this.length; i++) {\n        var ele = this[i];\n\n        if (ele.isNode()) {\n          nodes.push(ele);\n        } else {\n          edges.push(ele);\n        }\n      }\n\n      return {\n        nodes: nodes,\n        edges: edges\n      };\n    },\n    filter: function filter(_filter, thisArg) {\n      if (_filter === undefined) {\n        // check this first b/c it's the most common/performant case\n        return this;\n      } else if (string(_filter) || elementOrCollection(_filter)) {\n        return new Selector(_filter).filter(this);\n      } else if (fn$6(_filter)) {\n        var filterEles = this.spawn();\n        var eles = this;\n\n        for (var i = 0; i < eles.length; i++) {\n          var ele = eles[i];\n          var include = thisArg ? _filter.apply(thisArg, [ele, i, eles]) : _filter(ele, i, eles);\n\n          if (include) {\n            filterEles.push(ele);\n          }\n        }\n\n        return filterEles;\n      }\n\n      return this.spawn(); // if not handled by above, give 'em an empty collection\n    },\n    not: function not(toRemove) {\n      if (!toRemove) {\n        return this;\n      } else {\n        if (string(toRemove)) {\n          toRemove = this.filter(toRemove);\n        }\n\n        var elements = this.spawn();\n\n        for (var i = 0; i < this.length; i++) {\n          var element = this[i];\n          var remove = toRemove.has(element);\n\n          if (!remove) {\n            elements.push(element);\n          }\n        }\n\n        return elements;\n      }\n    },\n    absoluteComplement: function absoluteComplement() {\n      var cy = this.cy();\n      return cy.mutableElements().not(this);\n    },\n    intersect: function intersect(other) {\n      // if a selector is specified, then filter by it instead\n      if (string(other)) {\n        var selector = other;\n        return this.filter(selector);\n      }\n\n      var elements = this.spawn();\n      var col1 = this;\n      var col2 = other;\n      var col1Smaller = this.length < other.length;\n      var colS = col1Smaller ? col1 : col2;\n      var colL = col1Smaller ? col2 : col1;\n\n      for (var i = 0; i < colS.length; i++) {\n        var ele = colS[i];\n\n        if (colL.has(ele)) {\n          elements.push(ele);\n        }\n      }\n\n      return elements;\n    },\n    xor: function xor(other) {\n      var cy = this._private.cy;\n\n      if (string(other)) {\n        other = cy.$(other);\n      }\n\n      var elements = this.spawn();\n      var col1 = this;\n      var col2 = other;\n\n      var add = function add(col, other) {\n        for (var i = 0; i < col.length; i++) {\n          var ele = col[i];\n          var id = ele._private.data.id;\n          var inOther = other.hasElementWithId(id);\n\n          if (!inOther) {\n            elements.push(ele);\n          }\n        }\n      };\n\n      add(col1, col2);\n      add(col2, col1);\n      return elements;\n    },\n    diff: function diff(other) {\n      var cy = this._private.cy;\n\n      if (string(other)) {\n        other = cy.$(other);\n      }\n\n      var left = this.spawn();\n      var right = this.spawn();\n      var both = this.spawn();\n      var col1 = this;\n      var col2 = other;\n\n      var add = function add(col, other, retEles) {\n        for (var i = 0; i < col.length; i++) {\n          var ele = col[i];\n          var id = ele._private.data.id;\n          var inOther = other.hasElementWithId(id);\n\n          if (inOther) {\n            both.merge(ele);\n          } else {\n            retEles.push(ele);\n          }\n        }\n      };\n\n      add(col1, col2, left);\n      add(col2, col1, right);\n      return {\n        left: left,\n        right: right,\n        both: both\n      };\n    },\n    add: function add(toAdd) {\n      var cy = this._private.cy;\n\n      if (!toAdd) {\n        return this;\n      }\n\n      if (string(toAdd)) {\n        var selector = toAdd;\n        toAdd = cy.mutableElements().filter(selector);\n      }\n\n      var elements = this.spawnSelf();\n\n      for (var i = 0; i < toAdd.length; i++) {\n        var ele = toAdd[i];\n        var add = !this.has(ele);\n\n        if (add) {\n          elements.push(ele);\n        }\n      }\n\n      return elements;\n    },\n    // in place merge on calling collection\n    merge: function merge(toAdd) {\n      var _p = this._private;\n      var cy = _p.cy;\n\n      if (!toAdd) {\n        return this;\n      }\n\n      if (toAdd && string(toAdd)) {\n        var selector = toAdd;\n        toAdd = cy.mutableElements().filter(selector);\n      }\n\n      var map = _p.map;\n\n      for (var i = 0; i < toAdd.length; i++) {\n        var toAddEle = toAdd[i];\n        var id = toAddEle._private.data.id;\n        var add = !map.has(id);\n\n        if (add) {\n          var index = this.length++;\n          this[index] = toAddEle;\n          map.set(id, {\n            ele: toAddEle,\n            index: index\n          });\n        }\n      }\n\n      return this; // chaining\n    },\n    unmergeAt: function unmergeAt(i) {\n      var ele = this[i];\n      var id = ele.id();\n      var _p = this._private;\n      var map = _p.map; // remove ele\n\n      this[i] = undefined;\n      map[\"delete\"](id);\n      var unmergedLastEle = i === this.length - 1; // replace empty spot with last ele in collection\n\n      if (this.length > 1 && !unmergedLastEle) {\n        var lastEleI = this.length - 1;\n        var lastEle = this[lastEleI];\n        var lastEleId = lastEle._private.data.id;\n        this[lastEleI] = undefined;\n        this[i] = lastEle;\n        map.set(lastEleId, {\n          ele: lastEle,\n          index: i\n        });\n      } // the collection is now 1 ele smaller\n\n\n      this.length--;\n      return this;\n    },\n    // remove single ele in place in calling collection\n    unmergeOne: function unmergeOne(ele) {\n      ele = ele[0];\n      var _p = this._private;\n      var id = ele._private.data.id;\n      var map = _p.map;\n      var entry = map.get(id);\n\n      if (!entry) {\n        return this; // no need to remove\n      }\n\n      var i = entry.index;\n      this.unmergeAt(i);\n      return this;\n    },\n    // remove eles in place on calling collection\n    unmerge: function unmerge(toRemove) {\n      var cy = this._private.cy;\n\n      if (!toRemove) {\n        return this;\n      }\n\n      if (toRemove && string(toRemove)) {\n        var selector = toRemove;\n        toRemove = cy.mutableElements().filter(selector);\n      }\n\n      for (var i = 0; i < toRemove.length; i++) {\n        this.unmergeOne(toRemove[i]);\n      }\n\n      return this; // chaining\n    },\n    unmergeBy: function unmergeBy(toRmFn) {\n      for (var i = this.length - 1; i >= 0; i--) {\n        var ele = this[i];\n\n        if (toRmFn(ele)) {\n          this.unmergeAt(i);\n        }\n      }\n\n      return this;\n    },\n    map: function map(mapFn, thisArg) {\n      var arr = [];\n      var eles = this;\n\n      for (var i = 0; i < eles.length; i++) {\n        var ele = eles[i];\n        var ret = thisArg ? mapFn.apply(thisArg, [ele, i, eles]) : mapFn(ele, i, eles);\n        arr.push(ret);\n      }\n\n      return arr;\n    },\n    reduce: function reduce(fn, initialValue) {\n      var val = initialValue;\n      var eles = this;\n\n      for (var i = 0; i < eles.length; i++) {\n        val = fn(val, eles[i], i, eles);\n      }\n\n      return val;\n    },\n    max: function max(valFn, thisArg) {\n      var max = -Infinity;\n      var maxEle;\n      var eles = this;\n\n      for (var i = 0; i < eles.length; i++) {\n        var ele = eles[i];\n        var val = thisArg ? valFn.apply(thisArg, [ele, i, eles]) : valFn(ele, i, eles);\n\n        if (val > max) {\n          max = val;\n          maxEle = ele;\n        }\n      }\n\n      return {\n        value: max,\n        ele: maxEle\n      };\n    },\n    min: function min(valFn, thisArg) {\n      var min = Infinity;\n      var minEle;\n      var eles = this;\n\n      for (var i = 0; i < eles.length; i++) {\n        var ele = eles[i];\n        var val = thisArg ? valFn.apply(thisArg, [ele, i, eles]) : valFn(ele, i, eles);\n\n        if (val < min) {\n          min = val;\n          minEle = ele;\n        }\n      }\n\n      return {\n        value: min,\n        ele: minEle\n      };\n    }\n  }; // aliases\n\n  var fn$1 = elesfn$8;\n  fn$1['u'] = fn$1['|'] = fn$1['+'] = fn$1.union = fn$1.or = fn$1.add;\n  fn$1['\\\\'] = fn$1['!'] = fn$1['-'] = fn$1.difference = fn$1.relativeComplement = fn$1.subtract = fn$1.not;\n  fn$1['n'] = fn$1['&'] = fn$1['.'] = fn$1.and = fn$1.intersection = fn$1.intersect;\n  fn$1['^'] = fn$1['(+)'] = fn$1['(-)'] = fn$1.symmetricDifference = fn$1.symdiff = fn$1.xor;\n  fn$1.fnFilter = fn$1.filterFn = fn$1.stdFilter = fn$1.filter;\n  fn$1.complement = fn$1.abscomp = fn$1.absoluteComplement;\n\n  var elesfn$7 = {\n    isNode: function isNode() {\n      return this.group() === 'nodes';\n    },\n    isEdge: function isEdge() {\n      return this.group() === 'edges';\n    },\n    isLoop: function isLoop() {\n      return this.isEdge() && this.source()[0] === this.target()[0];\n    },\n    isSimple: function isSimple() {\n      return this.isEdge() && this.source()[0] !== this.target()[0];\n    },\n    group: function group() {\n      var ele = this[0];\n\n      if (ele) {\n        return ele._private.group;\n      }\n    }\n  };\n\n  /**\n   *  Elements are drawn in a specific order based on compound depth (low to high), the element type (nodes above edges),\n   *  and z-index (low to high).  These styles affect how this applies:\n   *\n   *  z-compound-depth: May be `bottom | orphan | auto | top`.  The first drawn is `bottom`, then `orphan` which is the\n   *      same depth as the root of the compound graph, followed by the default value `auto` which draws in order from\n   *      root to leaves of the compound graph.  The last drawn is `top`.\n   *  z-index-compare: May be `auto | manual`.  The default value is `auto` which always draws edges under nodes.\n   *      `manual` ignores this convention and draws based on the `z-index` value setting.\n   *  z-index: An integer value that affects the relative draw order of elements.  In general, an element with a higher\n   *      `z-index` will be drawn on top of an element with a lower `z-index`.\n   */\n\n  var zIndexSort = function zIndexSort(a, b) {\n    var cy = a.cy();\n    var hasCompoundNodes = cy.hasCompoundNodes();\n\n    function getDepth(ele) {\n      var style = ele.pstyle('z-compound-depth');\n\n      if (style.value === 'auto') {\n        return hasCompoundNodes ? ele.zDepth() : 0;\n      } else if (style.value === 'bottom') {\n        return -1;\n      } else if (style.value === 'top') {\n        return MAX_INT$1;\n      } // 'orphan'\n\n\n      return 0;\n    }\n\n    var depthDiff = getDepth(a) - getDepth(b);\n\n    if (depthDiff !== 0) {\n      return depthDiff;\n    }\n\n    function getEleDepth(ele) {\n      var style = ele.pstyle('z-index-compare');\n\n      if (style.value === 'auto') {\n        return ele.isNode() ? 1 : 0;\n      } // 'manual'\n\n\n      return 0;\n    }\n\n    var eleDiff = getEleDepth(a) - getEleDepth(b);\n\n    if (eleDiff !== 0) {\n      return eleDiff;\n    }\n\n    var zDiff = a.pstyle('z-index').value - b.pstyle('z-index').value;\n\n    if (zDiff !== 0) {\n      return zDiff;\n    } // compare indices in the core (order added to graph w/ last on top)\n\n\n    return a.poolIndex() - b.poolIndex();\n  };\n\n  var elesfn$6 = {\n    forEach: function forEach(fn, thisArg) {\n      if (fn$6(fn)) {\n        var N = this.length;\n\n        for (var i = 0; i < N; i++) {\n          var ele = this[i];\n          var ret = thisArg ? fn.apply(thisArg, [ele, i, this]) : fn(ele, i, this);\n\n          if (ret === false) {\n            break;\n          } // exit each early on return false\n\n        }\n      }\n\n      return this;\n    },\n    toArray: function toArray() {\n      var array = [];\n\n      for (var i = 0; i < this.length; i++) {\n        array.push(this[i]);\n      }\n\n      return array;\n    },\n    slice: function slice(start, end) {\n      var array = [];\n      var thisSize = this.length;\n\n      if (end == null) {\n        end = thisSize;\n      }\n\n      if (start == null) {\n        start = 0;\n      }\n\n      if (start < 0) {\n        start = thisSize + start;\n      }\n\n      if (end < 0) {\n        end = thisSize + end;\n      }\n\n      for (var i = start; i >= 0 && i < end && i < thisSize; i++) {\n        array.push(this[i]);\n      }\n\n      return this.spawn(array);\n    },\n    size: function size() {\n      return this.length;\n    },\n    eq: function eq(i) {\n      return this[i] || this.spawn();\n    },\n    first: function first() {\n      return this[0] || this.spawn();\n    },\n    last: function last() {\n      return this[this.length - 1] || this.spawn();\n    },\n    empty: function empty() {\n      return this.length === 0;\n    },\n    nonempty: function nonempty() {\n      return !this.empty();\n    },\n    sort: function sort(sortFn) {\n      if (!fn$6(sortFn)) {\n        return this;\n      }\n\n      var sorted = this.toArray().sort(sortFn);\n      return this.spawn(sorted);\n    },\n    sortByZIndex: function sortByZIndex() {\n      return this.sort(zIndexSort);\n    },\n    zDepth: function zDepth() {\n      var ele = this[0];\n\n      if (!ele) {\n        return undefined;\n      } // let cy = ele.cy();\n\n\n      var _p = ele._private;\n      var group = _p.group;\n\n      if (group === 'nodes') {\n        var depth = _p.data.parent ? ele.parents().size() : 0;\n\n        if (!ele.isParent()) {\n          return MAX_INT$1 - 1; // childless nodes always on top\n        }\n\n        return depth;\n      } else {\n        var src = _p.source;\n        var tgt = _p.target;\n        var srcDepth = src.zDepth();\n        var tgtDepth = tgt.zDepth();\n        return Math.max(srcDepth, tgtDepth, 0); // depth of deepest parent\n      }\n    }\n  };\n  elesfn$6.each = elesfn$6.forEach;\n\n  var defineSymbolIterator = function defineSymbolIterator() {\n    var typeofUndef = \"undefined\" ;\n    var isIteratorSupported = (typeof Symbol === \"undefined\" ? \"undefined\" : _typeof(Symbol)) != typeofUndef && _typeof(Symbol.iterator) != typeofUndef; // eslint-disable-line no-undef\n\n    if (isIteratorSupported) {\n      elesfn$6[Symbol.iterator] = function () {\n        var _this = this;\n\n        // eslint-disable-line no-undef\n        var entry = {\n          value: undefined,\n          done: false\n        };\n        var i = 0;\n        var length = this.length;\n        return _defineProperty$1({\n          next: function next() {\n            if (i < length) {\n              entry.value = _this[i++];\n            } else {\n              entry.value = undefined;\n              entry.done = true;\n            }\n\n            return entry;\n          }\n        }, Symbol.iterator, function () {\n          // eslint-disable-line no-undef\n          return this;\n        });\n      };\n    }\n  };\n\n  defineSymbolIterator();\n\n  var getLayoutDimensionOptions = defaults$g({\n    nodeDimensionsIncludeLabels: false\n  });\n  var elesfn$5 = {\n    // Calculates and returns node dimensions { x, y } based on options given\n    layoutDimensions: function layoutDimensions(options) {\n      options = getLayoutDimensionOptions(options);\n      var dims;\n\n      if (!this.takesUpSpace()) {\n        dims = {\n          w: 0,\n          h: 0\n        };\n      } else if (options.nodeDimensionsIncludeLabels) {\n        var bbDim = this.boundingBox();\n        dims = {\n          w: bbDim.w,\n          h: bbDim.h\n        };\n      } else {\n        dims = {\n          w: this.outerWidth(),\n          h: this.outerHeight()\n        };\n      } // sanitise the dimensions for external layouts (avoid division by zero)\n\n\n      if (dims.w === 0 || dims.h === 0) {\n        dims.w = dims.h = 1;\n      }\n\n      return dims;\n    },\n    // using standard layout options, apply position function (w/ or w/o animation)\n    layoutPositions: function layoutPositions(layout, options, fn) {\n      var nodes = this.nodes().filter(function (n) {\n        return !n.isParent();\n      });\n      var cy = this.cy();\n      var layoutEles = options.eles; // nodes & edges\n\n      var getMemoizeKey = function getMemoizeKey(node) {\n        return node.id();\n      };\n\n      var fnMem = memoize$1(fn, getMemoizeKey); // memoized version of position function\n\n      layout.emit({\n        type: 'layoutstart',\n        layout: layout\n      });\n      layout.animations = [];\n\n      var calculateSpacing = function calculateSpacing(spacing, nodesBb, pos) {\n        var center = {\n          x: nodesBb.x1 + nodesBb.w / 2,\n          y: nodesBb.y1 + nodesBb.h / 2\n        };\n        var spacingVector = {\n          // scale from center of bounding box (not necessarily 0,0)\n          x: (pos.x - center.x) * spacing,\n          y: (pos.y - center.y) * spacing\n        };\n        return {\n          x: center.x + spacingVector.x,\n          y: center.y + spacingVector.y\n        };\n      };\n\n      var useSpacingFactor = options.spacingFactor && options.spacingFactor !== 1;\n\n      var spacingBb = function spacingBb() {\n        if (!useSpacingFactor) {\n          return null;\n        }\n\n        var bb = makeBoundingBox();\n\n        for (var i = 0; i < nodes.length; i++) {\n          var node = nodes[i];\n          var pos = fnMem(node, i);\n          expandBoundingBoxByPoint(bb, pos.x, pos.y);\n        }\n\n        return bb;\n      };\n\n      var bb = spacingBb();\n      var getFinalPos = memoize$1(function (node, i) {\n        var newPos = fnMem(node, i);\n\n        if (useSpacingFactor) {\n          var spacing = Math.abs(options.spacingFactor);\n          newPos = calculateSpacing(spacing, bb, newPos);\n        }\n\n        if (options.transform != null) {\n          newPos = options.transform(node, newPos);\n        }\n\n        return newPos;\n      }, getMemoizeKey);\n\n      if (options.animate) {\n        for (var i = 0; i < nodes.length; i++) {\n          var node = nodes[i];\n          var newPos = getFinalPos(node, i);\n          var animateNode = options.animateFilter == null || options.animateFilter(node, i);\n\n          if (animateNode) {\n            var ani = node.animation({\n              position: newPos,\n              duration: options.animationDuration,\n              easing: options.animationEasing\n            });\n            layout.animations.push(ani);\n          } else {\n            node.position(newPos);\n          }\n        }\n\n        if (options.fit) {\n          var fitAni = cy.animation({\n            fit: {\n              boundingBox: layoutEles.boundingBoxAt(getFinalPos),\n              padding: options.padding\n            },\n            duration: options.animationDuration,\n            easing: options.animationEasing\n          });\n          layout.animations.push(fitAni);\n        } else if (options.zoom !== undefined && options.pan !== undefined) {\n          var zoomPanAni = cy.animation({\n            zoom: options.zoom,\n            pan: options.pan,\n            duration: options.animationDuration,\n            easing: options.animationEasing\n          });\n          layout.animations.push(zoomPanAni);\n        }\n\n        layout.animations.forEach(function (ani) {\n          return ani.play();\n        });\n        layout.one('layoutready', options.ready);\n        layout.emit({\n          type: 'layoutready',\n          layout: layout\n        });\n        Promise$1.all(layout.animations.map(function (ani) {\n          return ani.promise();\n        })).then(function () {\n          layout.one('layoutstop', options.stop);\n          layout.emit({\n            type: 'layoutstop',\n            layout: layout\n          });\n        });\n      } else {\n        nodes.positions(getFinalPos);\n\n        if (options.fit) {\n          cy.fit(options.eles, options.padding);\n        }\n\n        if (options.zoom != null) {\n          cy.zoom(options.zoom);\n        }\n\n        if (options.pan) {\n          cy.pan(options.pan);\n        }\n\n        layout.one('layoutready', options.ready);\n        layout.emit({\n          type: 'layoutready',\n          layout: layout\n        });\n        layout.one('layoutstop', options.stop);\n        layout.emit({\n          type: 'layoutstop',\n          layout: layout\n        });\n      }\n\n      return this; // chaining\n    },\n    layout: function layout(options) {\n      var cy = this.cy();\n      return cy.makeLayout(extend({}, options, {\n        eles: this\n      }));\n    }\n  }; // aliases:\n\n  elesfn$5.createLayout = elesfn$5.makeLayout = elesfn$5.layout;\n\n  function styleCache(key, fn, ele) {\n    var _p = ele._private;\n    var cache = _p.styleCache = _p.styleCache || [];\n    var val;\n\n    if ((val = cache[key]) != null) {\n      return val;\n    } else {\n      val = cache[key] = fn(ele);\n      return val;\n    }\n  }\n\n  function cacheStyleFunction(key, fn) {\n    key = hashString(key);\n    return function cachedStyleFunction(ele) {\n      return styleCache(key, fn, ele);\n    };\n  }\n\n  function cachePrototypeStyleFunction(key, fn) {\n    key = hashString(key);\n\n    var selfFn = function selfFn(ele) {\n      return fn.call(ele);\n    };\n\n    return function cachedPrototypeStyleFunction() {\n      var ele = this[0];\n\n      if (ele) {\n        return styleCache(key, selfFn, ele);\n      }\n    };\n  }\n\n  var elesfn$4 = {\n    recalculateRenderedStyle: function recalculateRenderedStyle(useCache) {\n      var cy = this.cy();\n      var renderer = cy.renderer();\n      var styleEnabled = cy.styleEnabled();\n\n      if (renderer && styleEnabled) {\n        renderer.recalculateRenderedStyle(this, useCache);\n      }\n\n      return this;\n    },\n    dirtyStyleCache: function dirtyStyleCache() {\n      var cy = this.cy();\n\n      var dirty = function dirty(ele) {\n        return ele._private.styleCache = null;\n      };\n\n      if (cy.hasCompoundNodes()) {\n        var eles;\n        eles = this.spawnSelf().merge(this.descendants()).merge(this.parents());\n        eles.merge(eles.connectedEdges());\n        eles.forEach(dirty);\n      } else {\n        this.forEach(function (ele) {\n          dirty(ele);\n          ele.connectedEdges().forEach(dirty);\n        });\n      }\n\n      return this;\n    },\n    // fully updates (recalculates) the style for the elements\n    updateStyle: function updateStyle(notifyRenderer) {\n      var cy = this._private.cy;\n\n      if (!cy.styleEnabled()) {\n        return this;\n      }\n\n      if (cy.batching()) {\n        var bEles = cy._private.batchStyleEles;\n        bEles.merge(this);\n        return this; // chaining and exit early when batching\n      }\n\n      var hasCompounds = cy.hasCompoundNodes();\n      var updatedEles = this;\n      notifyRenderer = notifyRenderer || notifyRenderer === undefined ? true : false;\n\n      if (hasCompounds) {\n        // then add everything up and down for compound selector checks\n        updatedEles = this.spawnSelf().merge(this.descendants()).merge(this.parents());\n      } // let changedEles = style.apply( updatedEles );\n\n\n      var changedEles = updatedEles;\n\n      if (notifyRenderer) {\n        changedEles.emitAndNotify('style'); // let renderer know we changed style\n      } else {\n        changedEles.emit('style'); // just fire the event\n      }\n\n      updatedEles.forEach(function (ele) {\n        return ele._private.styleDirty = true;\n      });\n      return this; // chaining\n    },\n    // private: clears dirty flag and recalculates style\n    cleanStyle: function cleanStyle() {\n      var cy = this.cy();\n\n      if (!cy.styleEnabled()) {\n        return;\n      }\n\n      for (var i = 0; i < this.length; i++) {\n        var ele = this[i];\n\n        if (ele._private.styleDirty) {\n          // n.b. this flag should be set before apply() to avoid potential infinite recursion\n          ele._private.styleDirty = false;\n          cy.style().apply(ele);\n        }\n      }\n    },\n    // get the internal parsed style object for the specified property\n    parsedStyle: function parsedStyle(property) {\n      var includeNonDefault = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var ele = this[0];\n      var cy = ele.cy();\n\n      if (!cy.styleEnabled()) {\n        return;\n      }\n\n      if (ele) {\n        this.cleanStyle();\n        var overriddenStyle = ele._private.style[property];\n\n        if (overriddenStyle != null) {\n          return overriddenStyle;\n        } else if (includeNonDefault) {\n          return cy.style().getDefaultProperty(property);\n        } else {\n          return null;\n        }\n      }\n    },\n    numericStyle: function numericStyle(property) {\n      var ele = this[0];\n\n      if (!ele.cy().styleEnabled()) {\n        return;\n      }\n\n      if (ele) {\n        var pstyle = ele.pstyle(property);\n        return pstyle.pfValue !== undefined ? pstyle.pfValue : pstyle.value;\n      }\n    },\n    numericStyleUnits: function numericStyleUnits(property) {\n      var ele = this[0];\n\n      if (!ele.cy().styleEnabled()) {\n        return;\n      }\n\n      if (ele) {\n        return ele.pstyle(property).units;\n      }\n    },\n    // get the specified css property as a rendered value (i.e. on-screen value)\n    // or get the whole rendered style if no property specified (NB doesn't allow setting)\n    renderedStyle: function renderedStyle(property) {\n      var cy = this.cy();\n\n      if (!cy.styleEnabled()) {\n        return this;\n      }\n\n      var ele = this[0];\n\n      if (ele) {\n        return cy.style().getRenderedStyle(ele, property);\n      }\n    },\n    // read the calculated css style of the element or override the style (via a bypass)\n    style: function style(name, value) {\n      var cy = this.cy();\n\n      if (!cy.styleEnabled()) {\n        return this;\n      }\n\n      var updateTransitions = false;\n      var style = cy.style();\n\n      if (plainObject(name)) {\n        // then extend the bypass\n        var props = name;\n        style.applyBypass(this, props, updateTransitions);\n        this.emitAndNotify('style'); // let the renderer know we've updated style\n      } else if (string(name)) {\n        if (value === undefined) {\n          // then get the property from the style\n          var ele = this[0];\n\n          if (ele) {\n            return style.getStylePropertyValue(ele, name);\n          } else {\n            // empty collection => can't get any value\n            return;\n          }\n        } else {\n          // then set the bypass with the property value\n          style.applyBypass(this, name, value, updateTransitions);\n          this.emitAndNotify('style'); // let the renderer know we've updated style\n        }\n      } else if (name === undefined) {\n        var _ele = this[0];\n\n        if (_ele) {\n          return style.getRawStyle(_ele);\n        } else {\n          // empty collection => can't get any value\n          return;\n        }\n      }\n\n      return this; // chaining\n    },\n    removeStyle: function removeStyle(names) {\n      var cy = this.cy();\n\n      if (!cy.styleEnabled()) {\n        return this;\n      }\n\n      var updateTransitions = false;\n      var style = cy.style();\n      var eles = this;\n\n      if (names === undefined) {\n        for (var i = 0; i < eles.length; i++) {\n          var ele = eles[i];\n          style.removeAllBypasses(ele, updateTransitions);\n        }\n      } else {\n        names = names.split(/\\s+/);\n\n        for (var _i = 0; _i < eles.length; _i++) {\n          var _ele2 = eles[_i];\n          style.removeBypasses(_ele2, names, updateTransitions);\n        }\n      }\n\n      this.emitAndNotify('style'); // let the renderer know we've updated style\n\n      return this; // chaining\n    },\n    show: function show() {\n      this.css('display', 'element');\n      return this; // chaining\n    },\n    hide: function hide() {\n      this.css('display', 'none');\n      return this; // chaining\n    },\n    effectiveOpacity: function effectiveOpacity() {\n      var cy = this.cy();\n\n      if (!cy.styleEnabled()) {\n        return 1;\n      }\n\n      var hasCompoundNodes = cy.hasCompoundNodes();\n      var ele = this[0];\n\n      if (ele) {\n        var _p = ele._private;\n        var parentOpacity = ele.pstyle('opacity').value;\n\n        if (!hasCompoundNodes) {\n          return parentOpacity;\n        }\n\n        var parents = !_p.data.parent ? null : ele.parents();\n\n        if (parents) {\n          for (var i = 0; i < parents.length; i++) {\n            var parent = parents[i];\n            var opacity = parent.pstyle('opacity').value;\n            parentOpacity = opacity * parentOpacity;\n          }\n        }\n\n        return parentOpacity;\n      }\n    },\n    transparent: function transparent() {\n      var cy = this.cy();\n\n      if (!cy.styleEnabled()) {\n        return false;\n      }\n\n      var ele = this[0];\n      var hasCompoundNodes = ele.cy().hasCompoundNodes();\n\n      if (ele) {\n        if (!hasCompoundNodes) {\n          return ele.pstyle('opacity').value === 0;\n        } else {\n          return ele.effectiveOpacity() === 0;\n        }\n      }\n    },\n    backgrounding: function backgrounding() {\n      var cy = this.cy();\n\n      if (!cy.styleEnabled()) {\n        return false;\n      }\n\n      var ele = this[0];\n      return ele._private.backgrounding ? true : false;\n    }\n  };\n\n  function checkCompound(ele, parentOk) {\n    var _p = ele._private;\n    var parents = _p.data.parent ? ele.parents() : null;\n\n    if (parents) {\n      for (var i = 0; i < parents.length; i++) {\n        var parent = parents[i];\n\n        if (!parentOk(parent)) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  function defineDerivedStateFunction(specs) {\n    var ok = specs.ok;\n    var edgeOkViaNode = specs.edgeOkViaNode || specs.ok;\n    var parentOk = specs.parentOk || specs.ok;\n    return function () {\n      var cy = this.cy();\n\n      if (!cy.styleEnabled()) {\n        return true;\n      }\n\n      var ele = this[0];\n      var hasCompoundNodes = cy.hasCompoundNodes();\n\n      if (ele) {\n        var _p = ele._private;\n\n        if (!ok(ele)) {\n          return false;\n        }\n\n        if (ele.isNode()) {\n          return !hasCompoundNodes || checkCompound(ele, parentOk);\n        } else {\n          var src = _p.source;\n          var tgt = _p.target;\n          return edgeOkViaNode(src) && (!hasCompoundNodes || checkCompound(src, edgeOkViaNode)) && (src === tgt || edgeOkViaNode(tgt) && (!hasCompoundNodes || checkCompound(tgt, edgeOkViaNode)));\n        }\n      }\n    };\n  }\n\n  var eleTakesUpSpace = cacheStyleFunction('eleTakesUpSpace', function (ele) {\n    return ele.pstyle('display').value === 'element' && ele.width() !== 0 && (ele.isNode() ? ele.height() !== 0 : true);\n  });\n  elesfn$4.takesUpSpace = cachePrototypeStyleFunction('takesUpSpace', defineDerivedStateFunction({\n    ok: eleTakesUpSpace\n  }));\n  var eleInteractive = cacheStyleFunction('eleInteractive', function (ele) {\n    return ele.pstyle('events').value === 'yes' && ele.pstyle('visibility').value === 'visible' && eleTakesUpSpace(ele);\n  });\n  var parentInteractive = cacheStyleFunction('parentInteractive', function (parent) {\n    return parent.pstyle('visibility').value === 'visible' && eleTakesUpSpace(parent);\n  });\n  elesfn$4.interactive = cachePrototypeStyleFunction('interactive', defineDerivedStateFunction({\n    ok: eleInteractive,\n    parentOk: parentInteractive,\n    edgeOkViaNode: eleTakesUpSpace\n  }));\n\n  elesfn$4.noninteractive = function () {\n    var ele = this[0];\n\n    if (ele) {\n      return !ele.interactive();\n    }\n  };\n\n  var eleVisible = cacheStyleFunction('eleVisible', function (ele) {\n    return ele.pstyle('visibility').value === 'visible' && ele.pstyle('opacity').pfValue !== 0 && eleTakesUpSpace(ele);\n  });\n  var edgeVisibleViaNode = eleTakesUpSpace;\n  elesfn$4.visible = cachePrototypeStyleFunction('visible', defineDerivedStateFunction({\n    ok: eleVisible,\n    edgeOkViaNode: edgeVisibleViaNode\n  }));\n\n  elesfn$4.hidden = function () {\n    var ele = this[0];\n\n    if (ele) {\n      return !ele.visible();\n    }\n  };\n\n  elesfn$4.isBundledBezier = cachePrototypeStyleFunction('isBundledBezier', function () {\n    if (!this.cy().styleEnabled()) {\n      return false;\n    }\n\n    return !this.removed() && this.pstyle('curve-style').value === 'bezier' && this.takesUpSpace();\n  });\n  elesfn$4.bypass = elesfn$4.css = elesfn$4.style;\n  elesfn$4.renderedCss = elesfn$4.renderedStyle;\n  elesfn$4.removeBypass = elesfn$4.removeCss = elesfn$4.removeStyle;\n  elesfn$4.pstyle = elesfn$4.parsedStyle;\n\n  var elesfn$3 = {};\n\n  function defineSwitchFunction(params) {\n    return function () {\n      var args = arguments;\n      var changedEles = []; // e.g. cy.nodes().select( data, handler )\n\n      if (args.length === 2) {\n        var data = args[0];\n        var handler = args[1];\n        this.on(params.event, data, handler);\n      } // e.g. cy.nodes().select( handler )\n      else if (args.length === 1 && fn$6(args[0])) {\n        var _handler = args[0];\n        this.on(params.event, _handler);\n      } // e.g. cy.nodes().select()\n      // e.g. (private) cy.nodes().select(['tapselect'])\n      else if (args.length === 0 || args.length === 1 && array(args[0])) {\n        var addlEvents = args.length === 1 ? args[0] : null;\n\n        for (var i = 0; i < this.length; i++) {\n          var ele = this[i];\n          var able = !params.ableField || ele._private[params.ableField];\n          var changed = ele._private[params.field] != params.value;\n\n          if (params.overrideAble) {\n            var overrideAble = params.overrideAble(ele);\n\n            if (overrideAble !== undefined) {\n              able = overrideAble;\n\n              if (!overrideAble) {\n                return this;\n              } // to save cycles assume not able for all on override\n\n            }\n          }\n\n          if (able) {\n            ele._private[params.field] = params.value;\n\n            if (changed) {\n              changedEles.push(ele);\n            }\n          }\n        }\n\n        var changedColl = this.spawn(changedEles);\n        changedColl.updateStyle(); // change of state => possible change of style\n\n        changedColl.emit(params.event);\n\n        if (addlEvents) {\n          changedColl.emit(addlEvents);\n        }\n      }\n\n      return this;\n    };\n  }\n\n  function defineSwitchSet(params) {\n    elesfn$3[params.field] = function () {\n      var ele = this[0];\n\n      if (ele) {\n        if (params.overrideField) {\n          var val = params.overrideField(ele);\n\n          if (val !== undefined) {\n            return val;\n          }\n        }\n\n        return ele._private[params.field];\n      }\n    };\n\n    elesfn$3[params.on] = defineSwitchFunction({\n      event: params.on,\n      field: params.field,\n      ableField: params.ableField,\n      overrideAble: params.overrideAble,\n      value: true\n    });\n    elesfn$3[params.off] = defineSwitchFunction({\n      event: params.off,\n      field: params.field,\n      ableField: params.ableField,\n      overrideAble: params.overrideAble,\n      value: false\n    });\n  }\n\n  defineSwitchSet({\n    field: 'locked',\n    overrideField: function overrideField(ele) {\n      return ele.cy().autolock() ? true : undefined;\n    },\n    on: 'lock',\n    off: 'unlock'\n  });\n  defineSwitchSet({\n    field: 'grabbable',\n    overrideField: function overrideField(ele) {\n      return ele.cy().autoungrabify() || ele.pannable() ? false : undefined;\n    },\n    on: 'grabify',\n    off: 'ungrabify'\n  });\n  defineSwitchSet({\n    field: 'selected',\n    ableField: 'selectable',\n    overrideAble: function overrideAble(ele) {\n      return ele.cy().autounselectify() ? false : undefined;\n    },\n    on: 'select',\n    off: 'unselect'\n  });\n  defineSwitchSet({\n    field: 'selectable',\n    overrideField: function overrideField(ele) {\n      return ele.cy().autounselectify() ? false : undefined;\n    },\n    on: 'selectify',\n    off: 'unselectify'\n  });\n  elesfn$3.deselect = elesfn$3.unselect;\n\n  elesfn$3.grabbed = function () {\n    var ele = this[0];\n\n    if (ele) {\n      return ele._private.grabbed;\n    }\n  };\n\n  defineSwitchSet({\n    field: 'active',\n    on: 'activate',\n    off: 'unactivate'\n  });\n  defineSwitchSet({\n    field: 'pannable',\n    on: 'panify',\n    off: 'unpanify'\n  });\n\n  elesfn$3.inactive = function () {\n    var ele = this[0];\n\n    if (ele) {\n      return !ele._private.active;\n    }\n  };\n\n  var elesfn$2 = {}; // DAG functions\n  ////////////////\n\n  var defineDagExtremity = function defineDagExtremity(params) {\n    return function dagExtremityImpl(selector) {\n      var eles = this;\n      var ret = [];\n\n      for (var i = 0; i < eles.length; i++) {\n        var ele = eles[i];\n\n        if (!ele.isNode()) {\n          continue;\n        }\n\n        var disqualified = false;\n        var edges = ele.connectedEdges();\n\n        for (var j = 0; j < edges.length; j++) {\n          var edge = edges[j];\n          var src = edge.source();\n          var tgt = edge.target();\n\n          if (params.noIncomingEdges && tgt === ele && src !== ele || params.noOutgoingEdges && src === ele && tgt !== ele) {\n            disqualified = true;\n            break;\n          }\n        }\n\n        if (!disqualified) {\n          ret.push(ele);\n        }\n      }\n\n      return this.spawn(ret, true).filter(selector);\n    };\n  };\n\n  var defineDagOneHop = function defineDagOneHop(params) {\n    return function (selector) {\n      var eles = this;\n      var oEles = [];\n\n      for (var i = 0; i < eles.length; i++) {\n        var ele = eles[i];\n\n        if (!ele.isNode()) {\n          continue;\n        }\n\n        var edges = ele.connectedEdges();\n\n        for (var j = 0; j < edges.length; j++) {\n          var edge = edges[j];\n          var src = edge.source();\n          var tgt = edge.target();\n\n          if (params.outgoing && src === ele) {\n            oEles.push(edge);\n            oEles.push(tgt);\n          } else if (params.incoming && tgt === ele) {\n            oEles.push(edge);\n            oEles.push(src);\n          }\n        }\n      }\n\n      return this.spawn(oEles, true).filter(selector);\n    };\n  };\n\n  var defineDagAllHops = function defineDagAllHops(params) {\n    return function (selector) {\n      var eles = this;\n      var sEles = [];\n      var sElesIds = {};\n\n      for (;;) {\n        var next = params.outgoing ? eles.outgoers() : eles.incomers();\n\n        if (next.length === 0) {\n          break;\n        } // done if none left\n\n\n        var newNext = false;\n\n        for (var i = 0; i < next.length; i++) {\n          var n = next[i];\n          var nid = n.id();\n\n          if (!sElesIds[nid]) {\n            sElesIds[nid] = true;\n            sEles.push(n);\n            newNext = true;\n          }\n        }\n\n        if (!newNext) {\n          break;\n        } // done if touched all outgoers already\n\n\n        eles = next;\n      }\n\n      return this.spawn(sEles, true).filter(selector);\n    };\n  };\n\n  elesfn$2.clearTraversalCache = function () {\n    for (var i = 0; i < this.length; i++) {\n      this[i]._private.traversalCache = null;\n    }\n  };\n\n  extend(elesfn$2, {\n    // get the root nodes in the DAG\n    roots: defineDagExtremity({\n      noIncomingEdges: true\n    }),\n    // get the leaf nodes in the DAG\n    leaves: defineDagExtremity({\n      noOutgoingEdges: true\n    }),\n    // normally called children in graph theory\n    // these nodes =edges=> outgoing nodes\n    outgoers: cache(defineDagOneHop({\n      outgoing: true\n    }), 'outgoers'),\n    // aka DAG descendants\n    successors: defineDagAllHops({\n      outgoing: true\n    }),\n    // normally called parents in graph theory\n    // these nodes <=edges= incoming nodes\n    incomers: cache(defineDagOneHop({\n      incoming: true\n    }), 'incomers'),\n    // aka DAG ancestors\n    predecessors: defineDagAllHops({\n      incoming: true\n    })\n  }); // Neighbourhood functions\n  //////////////////////////\n\n  extend(elesfn$2, {\n    neighborhood: cache(function (selector) {\n      var elements = [];\n      var nodes = this.nodes();\n\n      for (var i = 0; i < nodes.length; i++) {\n        // for all nodes\n        var node = nodes[i];\n        var connectedEdges = node.connectedEdges(); // for each connected edge, add the edge and the other node\n\n        for (var j = 0; j < connectedEdges.length; j++) {\n          var edge = connectedEdges[j];\n          var src = edge.source();\n          var tgt = edge.target();\n          var otherNode = node === src ? tgt : src; // need check in case of loop\n\n          if (otherNode.length > 0) {\n            elements.push(otherNode[0]); // add node 1 hop away\n          } // add connected edge\n\n\n          elements.push(edge[0]);\n        }\n      }\n\n      return this.spawn(elements, true).filter(selector);\n    }, 'neighborhood'),\n    closedNeighborhood: function closedNeighborhood(selector) {\n      return this.neighborhood().add(this).filter(selector);\n    },\n    openNeighborhood: function openNeighborhood(selector) {\n      return this.neighborhood(selector);\n    }\n  }); // aliases\n\n  elesfn$2.neighbourhood = elesfn$2.neighborhood;\n  elesfn$2.closedNeighbourhood = elesfn$2.closedNeighborhood;\n  elesfn$2.openNeighbourhood = elesfn$2.openNeighborhood; // Edge functions\n  /////////////////\n\n  extend(elesfn$2, {\n    source: cache(function sourceImpl(selector) {\n      var ele = this[0];\n      var src;\n\n      if (ele) {\n        src = ele._private.source || ele.cy().collection();\n      }\n\n      return src && selector ? src.filter(selector) : src;\n    }, 'source'),\n    target: cache(function targetImpl(selector) {\n      var ele = this[0];\n      var tgt;\n\n      if (ele) {\n        tgt = ele._private.target || ele.cy().collection();\n      }\n\n      return tgt && selector ? tgt.filter(selector) : tgt;\n    }, 'target'),\n    sources: defineSourceFunction({\n      attr: 'source'\n    }),\n    targets: defineSourceFunction({\n      attr: 'target'\n    })\n  });\n\n  function defineSourceFunction(params) {\n    return function sourceImpl(selector) {\n      var sources = [];\n\n      for (var i = 0; i < this.length; i++) {\n        var ele = this[i];\n        var src = ele._private[params.attr];\n\n        if (src) {\n          sources.push(src);\n        }\n      }\n\n      return this.spawn(sources, true).filter(selector);\n    };\n  }\n\n  extend(elesfn$2, {\n    edgesWith: cache(defineEdgesWithFunction(), 'edgesWith'),\n    edgesTo: cache(defineEdgesWithFunction({\n      thisIsSrc: true\n    }), 'edgesTo')\n  });\n\n  function defineEdgesWithFunction(params) {\n    return function edgesWithImpl(otherNodes) {\n      var elements = [];\n      var cy = this._private.cy;\n      var p = params || {}; // get elements if a selector is specified\n\n      if (string(otherNodes)) {\n        otherNodes = cy.$(otherNodes);\n      }\n\n      for (var h = 0; h < otherNodes.length; h++) {\n        var edges = otherNodes[h]._private.edges;\n\n        for (var i = 0; i < edges.length; i++) {\n          var edge = edges[i];\n          var edgeData = edge._private.data;\n          var thisToOther = this.hasElementWithId(edgeData.source) && otherNodes.hasElementWithId(edgeData.target);\n          var otherToThis = otherNodes.hasElementWithId(edgeData.source) && this.hasElementWithId(edgeData.target);\n          var edgeConnectsThisAndOther = thisToOther || otherToThis;\n\n          if (!edgeConnectsThisAndOther) {\n            continue;\n          }\n\n          if (p.thisIsSrc || p.thisIsTgt) {\n            if (p.thisIsSrc && !thisToOther) {\n              continue;\n            }\n\n            if (p.thisIsTgt && !otherToThis) {\n              continue;\n            }\n          }\n\n          elements.push(edge);\n        }\n      }\n\n      return this.spawn(elements, true);\n    };\n  }\n\n  extend(elesfn$2, {\n    connectedEdges: cache(function (selector) {\n      var retEles = [];\n      var eles = this;\n\n      for (var i = 0; i < eles.length; i++) {\n        var node = eles[i];\n\n        if (!node.isNode()) {\n          continue;\n        }\n\n        var edges = node._private.edges;\n\n        for (var j = 0; j < edges.length; j++) {\n          var edge = edges[j];\n          retEles.push(edge);\n        }\n      }\n\n      return this.spawn(retEles, true).filter(selector);\n    }, 'connectedEdges'),\n    connectedNodes: cache(function (selector) {\n      var retEles = [];\n      var eles = this;\n\n      for (var i = 0; i < eles.length; i++) {\n        var edge = eles[i];\n\n        if (!edge.isEdge()) {\n          continue;\n        }\n\n        retEles.push(edge.source()[0]);\n        retEles.push(edge.target()[0]);\n      }\n\n      return this.spawn(retEles, true).filter(selector);\n    }, 'connectedNodes'),\n    parallelEdges: cache(defineParallelEdgesFunction(), 'parallelEdges'),\n    codirectedEdges: cache(defineParallelEdgesFunction({\n      codirected: true\n    }), 'codirectedEdges')\n  });\n\n  function defineParallelEdgesFunction(params) {\n    var defaults = {\n      codirected: false\n    };\n    params = extend({}, defaults, params);\n    return function parallelEdgesImpl(selector) {\n      // micro-optimised for renderer\n      var elements = [];\n      var edges = this.edges();\n      var p = params; // look at all the edges in the collection\n\n      for (var i = 0; i < edges.length; i++) {\n        var edge1 = edges[i];\n        var edge1_p = edge1._private;\n        var src1 = edge1_p.source;\n        var srcid1 = src1._private.data.id;\n        var tgtid1 = edge1_p.data.target;\n        var srcEdges1 = src1._private.edges; // look at edges connected to the src node of this edge\n\n        for (var j = 0; j < srcEdges1.length; j++) {\n          var edge2 = srcEdges1[j];\n          var edge2data = edge2._private.data;\n          var tgtid2 = edge2data.target;\n          var srcid2 = edge2data.source;\n          var codirected = tgtid2 === tgtid1 && srcid2 === srcid1;\n          var oppdirected = srcid1 === tgtid2 && tgtid1 === srcid2;\n\n          if (p.codirected && codirected || !p.codirected && (codirected || oppdirected)) {\n            elements.push(edge2);\n          }\n        }\n      }\n\n      return this.spawn(elements, true).filter(selector);\n    };\n  } // Misc functions\n  /////////////////\n\n\n  extend(elesfn$2, {\n    components: function components(root) {\n      var self = this;\n      var cy = self.cy();\n      var visited = cy.collection();\n      var unvisited = root == null ? self.nodes() : root.nodes();\n      var components = [];\n\n      if (root != null && unvisited.empty()) {\n        // root may contain only edges\n        unvisited = root.sources(); // doesn't matter which node to use (undirected), so just use the source sides\n      }\n\n      var visitInComponent = function visitInComponent(node, component) {\n        visited.merge(node);\n        unvisited.unmerge(node);\n        component.merge(node);\n      };\n\n      if (unvisited.empty()) {\n        return self.spawn();\n      }\n\n      var _loop = function _loop() {\n        // each iteration yields a component\n        var cmpt = cy.collection();\n        components.push(cmpt);\n        var root = unvisited[0];\n        visitInComponent(root, cmpt);\n        self.bfs({\n          directed: false,\n          roots: root,\n          visit: function visit(v) {\n            return visitInComponent(v, cmpt);\n          }\n        });\n        cmpt.forEach(function (node) {\n          node.connectedEdges().forEach(function (e) {\n            // connectedEdges() usually cached\n            if (self.has(e) && cmpt.has(e.source()) && cmpt.has(e.target())) {\n              // has() is cheap\n              cmpt.merge(e); // forEach() only considers nodes -- sets N at call time\n            }\n          });\n        });\n      };\n\n      do {\n        _loop();\n      } while (unvisited.length > 0);\n\n      return components;\n    },\n    component: function component() {\n      var ele = this[0];\n      return ele.cy().mutableElements().components(ele)[0];\n    }\n  });\n  elesfn$2.componentsOf = elesfn$2.components;\n\n  var Collection = function Collection(cy, elements) {\n    var unique = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var removed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n    if (cy === undefined) {\n      error('A collection must have a reference to the core');\n      return;\n    }\n\n    var map = new Map$2();\n    var createdElements = false;\n\n    if (!elements) {\n      elements = [];\n    } else if (elements.length > 0 && plainObject(elements[0]) && !element(elements[0])) {\n      createdElements = true; // make elements from json and restore all at once later\n\n      var eles = [];\n      var elesIds = new Set$1();\n\n      for (var i = 0, l = elements.length; i < l; i++) {\n        var json = elements[i];\n\n        if (json.data == null) {\n          json.data = {};\n        }\n\n        var _data = json.data; // make sure newly created elements have valid ids\n\n        if (_data.id == null) {\n          _data.id = uuid();\n        } else if (cy.hasElementWithId(_data.id) || elesIds.has(_data.id)) {\n          continue; // can't create element if prior id already exists\n        }\n\n        var ele = new Element(cy, json, false);\n        eles.push(ele);\n        elesIds.add(_data.id);\n      }\n\n      elements = eles;\n    }\n\n    this.length = 0;\n\n    for (var _i = 0, _l = elements.length; _i < _l; _i++) {\n      var element$1 = elements[_i][0]; // [0] in case elements is an array of collections, rather than array of elements\n\n      if (element$1 == null) {\n        continue;\n      }\n\n      var id = element$1._private.data.id;\n\n      if (!unique || !map.has(id)) {\n        if (unique) {\n          map.set(id, {\n            index: this.length,\n            ele: element$1\n          });\n        }\n\n        this[this.length] = element$1;\n        this.length++;\n      }\n    }\n\n    this._private = {\n      eles: this,\n      cy: cy,\n\n      get map() {\n        if (this.lazyMap == null) {\n          this.rebuildMap();\n        }\n\n        return this.lazyMap;\n      },\n\n      set map(m) {\n        this.lazyMap = m;\n      },\n\n      rebuildMap: function rebuildMap() {\n        var m = this.lazyMap = new Map$2();\n        var eles = this.eles;\n\n        for (var _i2 = 0; _i2 < eles.length; _i2++) {\n          var _ele = eles[_i2];\n          m.set(_ele.id(), {\n            index: _i2,\n            ele: _ele\n          });\n        }\n      }\n    };\n\n    if (unique) {\n      this._private.map = map;\n    } // restore the elements if we created them from json\n\n\n    if (createdElements && !removed) {\n      this.restore();\n    }\n  }; // Functions\n  ////////////////////////////////////////////////////////////////////////////////////////////////////\n  // keep the prototypes in sync (an element has the same functions as a collection)\n  // and use elefn and elesfn as shorthands to the prototypes\n\n\n  var elesfn$1 = Element.prototype = Collection.prototype = Object.create(Array.prototype);\n\n  elesfn$1.instanceString = function () {\n    return 'collection';\n  };\n\n  elesfn$1.spawn = function (eles, unique) {\n    return new Collection(this.cy(), eles, unique);\n  };\n\n  elesfn$1.spawnSelf = function () {\n    return this.spawn(this);\n  };\n\n  elesfn$1.cy = function () {\n    return this._private.cy;\n  };\n\n  elesfn$1.renderer = function () {\n    return this._private.cy.renderer();\n  };\n\n  elesfn$1.element = function () {\n    return this[0];\n  };\n\n  elesfn$1.collection = function () {\n    if (collection(this)) {\n      return this;\n    } else {\n      // an element\n      return new Collection(this._private.cy, [this]);\n    }\n  };\n\n  elesfn$1.unique = function () {\n    return new Collection(this._private.cy, this, true);\n  };\n\n  elesfn$1.hasElementWithId = function (id) {\n    id = '' + id; // id must be string\n\n    return this._private.map.has(id);\n  };\n\n  elesfn$1.getElementById = function (id) {\n    id = '' + id; // id must be string\n\n    var cy = this._private.cy;\n\n    var entry = this._private.map.get(id);\n\n    return entry ? entry.ele : new Collection(cy); // get ele or empty collection\n  };\n\n  elesfn$1.$id = elesfn$1.getElementById;\n\n  elesfn$1.poolIndex = function () {\n    var cy = this._private.cy;\n    var eles = cy._private.elements;\n    var id = this[0]._private.data.id;\n    return eles._private.map.get(id).index;\n  };\n\n  elesfn$1.indexOf = function (ele) {\n    var id = ele[0]._private.data.id;\n    return this._private.map.get(id).index;\n  };\n\n  elesfn$1.indexOfId = function (id) {\n    id = '' + id; // id must be string\n\n    return this._private.map.get(id).index;\n  };\n\n  elesfn$1.json = function (obj) {\n    var ele = this.element();\n    var cy = this.cy();\n\n    if (ele == null && obj) {\n      return this;\n    } // can't set to no eles\n\n\n    if (ele == null) {\n      return undefined;\n    } // can't get from no eles\n\n\n    var p = ele._private;\n\n    if (plainObject(obj)) {\n      // set\n      cy.startBatch();\n\n      if (obj.data) {\n        ele.data(obj.data);\n        var _data2 = p.data;\n\n        if (ele.isEdge()) {\n          // source and target are immutable via data()\n          var move = false;\n          var spec = {};\n          var src = obj.data.source;\n          var tgt = obj.data.target;\n\n          if (src != null && src != _data2.source) {\n            spec.source = '' + src; // id must be string\n\n            move = true;\n          }\n\n          if (tgt != null && tgt != _data2.target) {\n            spec.target = '' + tgt; // id must be string\n\n            move = true;\n          }\n\n          if (move) {\n            ele = ele.move(spec);\n          }\n        } else {\n          // parent is immutable via data()\n          var newParentValSpecd = ('parent' in obj.data);\n          var parent = obj.data.parent;\n\n          if (newParentValSpecd && (parent != null || _data2.parent != null) && parent != _data2.parent) {\n            if (parent === undefined) {\n              // can't set undefined imperatively, so use null\n              parent = null;\n            }\n\n            if (parent != null) {\n              parent = '' + parent; // id must be string\n            }\n\n            ele = ele.move({\n              parent: parent\n            });\n          }\n        }\n      }\n\n      if (obj.position) {\n        ele.position(obj.position);\n      } // ignore group -- immutable\n\n\n      var checkSwitch = function checkSwitch(k, trueFnName, falseFnName) {\n        var obj_k = obj[k];\n\n        if (obj_k != null && obj_k !== p[k]) {\n          if (obj_k) {\n            ele[trueFnName]();\n          } else {\n            ele[falseFnName]();\n          }\n        }\n      };\n\n      checkSwitch('removed', 'remove', 'restore');\n      checkSwitch('selected', 'select', 'unselect');\n      checkSwitch('selectable', 'selectify', 'unselectify');\n      checkSwitch('locked', 'lock', 'unlock');\n      checkSwitch('grabbable', 'grabify', 'ungrabify');\n      checkSwitch('pannable', 'panify', 'unpanify');\n\n      if (obj.classes != null) {\n        ele.classes(obj.classes);\n      }\n\n      cy.endBatch();\n      return this;\n    } else if (obj === undefined) {\n      // get\n      var json = {\n        data: copy(p.data),\n        position: copy(p.position),\n        group: p.group,\n        removed: p.removed,\n        selected: p.selected,\n        selectable: p.selectable,\n        locked: p.locked,\n        grabbable: p.grabbable,\n        pannable: p.pannable,\n        classes: null\n      };\n      json.classes = '';\n      var i = 0;\n      p.classes.forEach(function (cls) {\n        return json.classes += i++ === 0 ? cls : ' ' + cls;\n      });\n      return json;\n    }\n  };\n\n  elesfn$1.jsons = function () {\n    var jsons = [];\n\n    for (var i = 0; i < this.length; i++) {\n      var ele = this[i];\n      var json = ele.json();\n      jsons.push(json);\n    }\n\n    return jsons;\n  };\n\n  elesfn$1.clone = function () {\n    var cy = this.cy();\n    var elesArr = [];\n\n    for (var i = 0; i < this.length; i++) {\n      var ele = this[i];\n      var json = ele.json();\n      var clone = new Element(cy, json, false); // NB no restore\n\n      elesArr.push(clone);\n    }\n\n    return new Collection(cy, elesArr);\n  };\n\n  elesfn$1.copy = elesfn$1.clone;\n\n  elesfn$1.restore = function () {\n    var notifyRenderer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    var addToPool = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var self = this;\n    var cy = self.cy();\n    var cy_p = cy._private; // create arrays of nodes and edges, since we need to\n    // restore the nodes first\n\n    var nodes = [];\n    var edges = [];\n    var elements;\n\n    for (var _i3 = 0, l = self.length; _i3 < l; _i3++) {\n      var ele = self[_i3];\n\n      if (addToPool && !ele.removed()) {\n        // don't need to handle this ele\n        continue;\n      } // keep nodes first in the array and edges after\n\n\n      if (ele.isNode()) {\n        // put to front of array if node\n        nodes.push(ele);\n      } else {\n        // put to end of array if edge\n        edges.push(ele);\n      }\n    }\n\n    elements = nodes.concat(edges);\n    var i;\n\n    var removeFromElements = function removeFromElements() {\n      elements.splice(i, 1);\n      i--;\n    }; // now, restore each element\n\n\n    for (i = 0; i < elements.length; i++) {\n      var _ele2 = elements[i];\n      var _private = _ele2._private;\n      var _data3 = _private.data; // the traversal cache should start fresh when ele is added\n\n      _ele2.clearTraversalCache(); // set id and validate\n\n\n      if (!addToPool && !_private.removed) ; else if (_data3.id === undefined) {\n        _data3.id = uuid();\n      } else if (number$1(_data3.id)) {\n        _data3.id = '' + _data3.id; // now it's a string\n      } else if (emptyString(_data3.id) || !string(_data3.id)) {\n        error('Can not create element with invalid string ID `' + _data3.id + '`'); // can't create element if it has empty string as id or non-string id\n\n        removeFromElements();\n        continue;\n      } else if (cy.hasElementWithId(_data3.id)) {\n        error('Can not create second element with ID `' + _data3.id + '`'); // can't create element if one already has that id\n\n        removeFromElements();\n        continue;\n      }\n\n      var id = _data3.id; // id is finalised, now let's keep a ref\n\n      if (_ele2.isNode()) {\n        // extra checks for nodes\n        var pos = _private.position; // make sure the nodes have a defined position\n\n        if (pos.x == null) {\n          pos.x = 0;\n        }\n\n        if (pos.y == null) {\n          pos.y = 0;\n        }\n      }\n\n      if (_ele2.isEdge()) {\n        // extra checks for edges\n        var edge = _ele2;\n        var fields = ['source', 'target'];\n        var fieldsLength = fields.length;\n        var badSourceOrTarget = false;\n\n        for (var j = 0; j < fieldsLength; j++) {\n          var field = fields[j];\n          var val = _data3[field];\n\n          if (number$1(val)) {\n            val = _data3[field] = '' + _data3[field]; // now string\n          }\n\n          if (val == null || val === '') {\n            // can't create if source or target is not defined properly\n            error('Can not create edge `' + id + '` with unspecified ' + field);\n            badSourceOrTarget = true;\n          } else if (!cy.hasElementWithId(val)) {\n            // can't create edge if one of its nodes doesn't exist\n            error('Can not create edge `' + id + '` with nonexistant ' + field + ' `' + val + '`');\n            badSourceOrTarget = true;\n          }\n        }\n\n        if (badSourceOrTarget) {\n          removeFromElements();\n          continue;\n        } // can't create this\n\n\n        var src = cy.getElementById(_data3.source);\n        var tgt = cy.getElementById(_data3.target); // only one edge in node if loop\n\n        if (src.same(tgt)) {\n          src._private.edges.push(edge);\n        } else {\n          src._private.edges.push(edge);\n\n          tgt._private.edges.push(edge);\n        }\n\n        edge._private.source = src;\n        edge._private.target = tgt;\n      } // if is edge\n      // create mock ids / indexes maps for element so it can be used like collections\n\n\n      _private.map = new Map$2();\n\n      _private.map.set(id, {\n        ele: _ele2,\n        index: 0\n      });\n\n      _private.removed = false;\n\n      if (addToPool) {\n        cy.addToPool(_ele2);\n      }\n    } // for each element\n    // do compound node sanity checks\n\n\n    for (var _i4 = 0; _i4 < nodes.length; _i4++) {\n      // each node\n      var node = nodes[_i4];\n      var _data4 = node._private.data;\n\n      if (number$1(_data4.parent)) {\n        // then automake string\n        _data4.parent = '' + _data4.parent;\n      }\n\n      var parentId = _data4.parent;\n      var specifiedParent = parentId != null;\n\n      if (specifiedParent || node._private.parent) {\n        var parent = node._private.parent ? cy.collection().merge(node._private.parent) : cy.getElementById(parentId);\n\n        if (parent.empty()) {\n          // non-existant parent; just remove it\n          _data4.parent = undefined;\n        } else if (parent[0].removed()) {\n          warn('Node added with missing parent, reference to parent removed');\n          _data4.parent = undefined;\n          node._private.parent = null;\n        } else {\n          var selfAsParent = false;\n          var ancestor = parent;\n\n          while (!ancestor.empty()) {\n            if (node.same(ancestor)) {\n              // mark self as parent and remove from data\n              selfAsParent = true;\n              _data4.parent = undefined; // remove parent reference\n              // exit or we loop forever\n\n              break;\n            }\n\n            ancestor = ancestor.parent();\n          }\n\n          if (!selfAsParent) {\n            // connect with children\n            parent[0]._private.children.push(node);\n\n            node._private.parent = parent[0]; // let the core know we have a compound graph\n\n            cy_p.hasCompoundNodes = true;\n          }\n        } // else\n\n      } // if specified parent\n\n    } // for each node\n\n\n    if (elements.length > 0) {\n      var restored = elements.length === self.length ? self : new Collection(cy, elements);\n\n      for (var _i5 = 0; _i5 < restored.length; _i5++) {\n        var _ele3 = restored[_i5];\n\n        if (_ele3.isNode()) {\n          continue;\n        } // adding an edge invalidates the traversal caches for the parallel edges\n\n\n        _ele3.parallelEdges().clearTraversalCache(); // adding an edge invalidates the traversal cache for the connected nodes\n\n\n        _ele3.source().clearTraversalCache();\n\n        _ele3.target().clearTraversalCache();\n      }\n\n      var toUpdateStyle;\n\n      if (cy_p.hasCompoundNodes) {\n        toUpdateStyle = cy.collection().merge(restored).merge(restored.connectedNodes()).merge(restored.parent());\n      } else {\n        toUpdateStyle = restored;\n      }\n\n      toUpdateStyle.dirtyCompoundBoundsCache().dirtyBoundingBoxCache().updateStyle(notifyRenderer);\n\n      if (notifyRenderer) {\n        restored.emitAndNotify('add');\n      } else if (addToPool) {\n        restored.emit('add');\n      }\n    }\n\n    return self; // chainability\n  };\n\n  elesfn$1.removed = function () {\n    var ele = this[0];\n    return ele && ele._private.removed;\n  };\n\n  elesfn$1.inside = function () {\n    var ele = this[0];\n    return ele && !ele._private.removed;\n  };\n\n  elesfn$1.remove = function () {\n    var notifyRenderer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    var removeFromPool = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var self = this;\n    var elesToRemove = [];\n    var elesToRemoveIds = {};\n    var cy = self._private.cy; // add connected edges\n\n    function addConnectedEdges(node) {\n      var edges = node._private.edges;\n\n      for (var i = 0; i < edges.length; i++) {\n        add(edges[i]);\n      }\n    } // add descendant nodes\n\n\n    function addChildren(node) {\n      var children = node._private.children;\n\n      for (var i = 0; i < children.length; i++) {\n        add(children[i]);\n      }\n    }\n\n    function add(ele) {\n      var alreadyAdded = elesToRemoveIds[ele.id()];\n\n      if (removeFromPool && ele.removed() || alreadyAdded) {\n        return;\n      } else {\n        elesToRemoveIds[ele.id()] = true;\n      }\n\n      if (ele.isNode()) {\n        elesToRemove.push(ele); // nodes are removed last\n\n        addConnectedEdges(ele);\n        addChildren(ele);\n      } else {\n        elesToRemove.unshift(ele); // edges are removed first\n      }\n    } // make the list of elements to remove\n    // (may be removing more than specified due to connected edges etc)\n\n\n    for (var i = 0, l = self.length; i < l; i++) {\n      var ele = self[i];\n      add(ele);\n    }\n\n    function removeEdgeRef(node, edge) {\n      var connectedEdges = node._private.edges;\n      removeFromArray(connectedEdges, edge); // removing an edges invalidates the traversal cache for its nodes\n\n      node.clearTraversalCache();\n    }\n\n    function removeParallelRef(pllEdge) {\n      // removing an edge invalidates the traversal caches for the parallel edges\n      pllEdge.clearTraversalCache();\n    }\n\n    var alteredParents = [];\n    alteredParents.ids = {};\n\n    function removeChildRef(parent, ele) {\n      ele = ele[0];\n      parent = parent[0];\n      var children = parent._private.children;\n      var pid = parent.id();\n      removeFromArray(children, ele); // remove parent => child ref\n\n      ele._private.parent = null; // remove child => parent ref\n\n      if (!alteredParents.ids[pid]) {\n        alteredParents.ids[pid] = true;\n        alteredParents.push(parent);\n      }\n    }\n\n    self.dirtyCompoundBoundsCache();\n\n    if (removeFromPool) {\n      cy.removeFromPool(elesToRemove); // remove from core pool\n    }\n\n    for (var _i6 = 0; _i6 < elesToRemove.length; _i6++) {\n      var _ele4 = elesToRemove[_i6];\n\n      if (_ele4.isEdge()) {\n        // remove references to this edge in its connected nodes\n        var src = _ele4.source()[0];\n\n        var tgt = _ele4.target()[0];\n\n        removeEdgeRef(src, _ele4);\n        removeEdgeRef(tgt, _ele4);\n\n        var pllEdges = _ele4.parallelEdges();\n\n        for (var j = 0; j < pllEdges.length; j++) {\n          var pllEdge = pllEdges[j];\n          removeParallelRef(pllEdge);\n\n          if (pllEdge.isBundledBezier()) {\n            pllEdge.dirtyBoundingBoxCache();\n          }\n        }\n      } else {\n        // remove reference to parent\n        var parent = _ele4.parent();\n\n        if (parent.length !== 0) {\n          removeChildRef(parent, _ele4);\n        }\n      }\n\n      if (removeFromPool) {\n        // mark as removed\n        _ele4._private.removed = true;\n      }\n    } // check to see if we have a compound graph or not\n\n\n    var elesStillInside = cy._private.elements;\n    cy._private.hasCompoundNodes = false;\n\n    for (var _i7 = 0; _i7 < elesStillInside.length; _i7++) {\n      var _ele5 = elesStillInside[_i7];\n\n      if (_ele5.isParent()) {\n        cy._private.hasCompoundNodes = true;\n        break;\n      }\n    }\n\n    var removedElements = new Collection(this.cy(), elesToRemove);\n\n    if (removedElements.size() > 0) {\n      // must manually notify since trigger won't do this automatically once removed\n      if (notifyRenderer) {\n        removedElements.emitAndNotify('remove');\n      } else if (removeFromPool) {\n        removedElements.emit('remove');\n      }\n    } // the parents who were modified by the removal need their style updated\n\n\n    for (var _i8 = 0; _i8 < alteredParents.length; _i8++) {\n      var _ele6 = alteredParents[_i8];\n\n      if (!removeFromPool || !_ele6.removed()) {\n        _ele6.updateStyle();\n      }\n    }\n\n    return removedElements;\n  };\n\n  elesfn$1.move = function (struct) {\n    var cy = this._private.cy;\n    var eles = this; // just clean up refs, caches, etc. in the same way as when removing and then restoring\n    // (our calls to remove/restore do not remove from the graph or make events)\n\n    var notifyRenderer = false;\n    var modifyPool = false;\n\n    var toString = function toString(id) {\n      return id == null ? id : '' + id;\n    }; // id must be string\n\n\n    if (struct.source !== undefined || struct.target !== undefined) {\n      var srcId = toString(struct.source);\n      var tgtId = toString(struct.target);\n      var srcExists = srcId != null && cy.hasElementWithId(srcId);\n      var tgtExists = tgtId != null && cy.hasElementWithId(tgtId);\n\n      if (srcExists || tgtExists) {\n        cy.batch(function () {\n          // avoid duplicate style updates\n          eles.remove(notifyRenderer, modifyPool); // clean up refs etc.\n\n          eles.emitAndNotify('moveout');\n\n          for (var i = 0; i < eles.length; i++) {\n            var ele = eles[i];\n            var _data5 = ele._private.data;\n\n            if (ele.isEdge()) {\n              if (srcExists) {\n                _data5.source = srcId;\n              }\n\n              if (tgtExists) {\n                _data5.target = tgtId;\n              }\n            }\n          }\n\n          eles.restore(notifyRenderer, modifyPool); // make new refs, style, etc.\n        });\n        eles.emitAndNotify('move');\n      }\n    } else if (struct.parent !== undefined) {\n      // move node to new parent\n      var parentId = toString(struct.parent);\n      var parentExists = parentId === null || cy.hasElementWithId(parentId);\n\n      if (parentExists) {\n        var pidToAssign = parentId === null ? undefined : parentId;\n        cy.batch(function () {\n          // avoid duplicate style updates\n          var updated = eles.remove(notifyRenderer, modifyPool); // clean up refs etc.\n\n          updated.emitAndNotify('moveout');\n\n          for (var i = 0; i < eles.length; i++) {\n            var ele = eles[i];\n            var _data6 = ele._private.data;\n\n            if (ele.isNode()) {\n              _data6.parent = pidToAssign;\n            }\n          }\n\n          updated.restore(notifyRenderer, modifyPool); // make new refs, style, etc.\n        });\n        eles.emitAndNotify('move');\n      }\n    }\n\n    return this;\n  };\n\n  [elesfn$j, elesfn$i, elesfn$h, elesfn$g, elesfn$f, data, elesfn$d, dimensions, elesfn$9, elesfn$8, elesfn$7, elesfn$6, elesfn$5, elesfn$4, elesfn$3, elesfn$2].forEach(function (props) {\n    extend(elesfn$1, props);\n  });\n\n  var corefn$9 = {\n    add: function add(opts) {\n      var elements;\n      var cy = this; // add the elements\n\n      if (elementOrCollection(opts)) {\n        var eles = opts;\n\n        if (eles._private.cy === cy) {\n          // same instance => just restore\n          elements = eles.restore();\n        } else {\n          // otherwise, copy from json\n          var jsons = [];\n\n          for (var i = 0; i < eles.length; i++) {\n            var ele = eles[i];\n            jsons.push(ele.json());\n          }\n\n          elements = new Collection(cy, jsons);\n        }\n      } // specify an array of options\n      else if (array(opts)) {\n        var _jsons = opts;\n        elements = new Collection(cy, _jsons);\n      } // specify via opts.nodes and opts.edges\n      else if (plainObject(opts) && (array(opts.nodes) || array(opts.edges))) {\n        var elesByGroup = opts;\n        var _jsons2 = [];\n        var grs = ['nodes', 'edges'];\n\n        for (var _i = 0, il = grs.length; _i < il; _i++) {\n          var group = grs[_i];\n          var elesArray = elesByGroup[group];\n\n          if (array(elesArray)) {\n            for (var j = 0, jl = elesArray.length; j < jl; j++) {\n              var json = extend({\n                group: group\n              }, elesArray[j]);\n\n              _jsons2.push(json);\n            }\n          }\n        }\n\n        elements = new Collection(cy, _jsons2);\n      } // specify options for one element\n      else {\n        var _json = opts;\n        elements = new Element(cy, _json).collection();\n      }\n\n      return elements;\n    },\n    remove: function remove(collection) {\n      if (elementOrCollection(collection)) ; else if (string(collection)) {\n        var selector = collection;\n        collection = this.$(selector);\n      }\n\n      return collection.remove();\n    }\n  };\n\n  /* global Float32Array */\n\n  /*! Bezier curve function generator. Copyright Gaetan Renaudeau. MIT License: http://en.wikipedia.org/wiki/MIT_License */\n  function generateCubicBezier(mX1, mY1, mX2, mY2) {\n    var NEWTON_ITERATIONS = 4,\n        NEWTON_MIN_SLOPE = 0.001,\n        SUBDIVISION_PRECISION = 0.0000001,\n        SUBDIVISION_MAX_ITERATIONS = 10,\n        kSplineTableSize = 11,\n        kSampleStepSize = 1.0 / (kSplineTableSize - 1.0),\n        float32ArraySupported = typeof Float32Array !== 'undefined';\n    /* Must contain four arguments. */\n\n    if (arguments.length !== 4) {\n      return false;\n    }\n    /* Arguments must be numbers. */\n\n\n    for (var i = 0; i < 4; ++i) {\n      if (typeof arguments[i] !== \"number\" || isNaN(arguments[i]) || !isFinite(arguments[i])) {\n        return false;\n      }\n    }\n    /* X values must be in the [0, 1] range. */\n\n\n    mX1 = Math.min(mX1, 1);\n    mX2 = Math.min(mX2, 1);\n    mX1 = Math.max(mX1, 0);\n    mX2 = Math.max(mX2, 0);\n    var mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\n\n    function A(aA1, aA2) {\n      return 1.0 - 3.0 * aA2 + 3.0 * aA1;\n    }\n\n    function B(aA1, aA2) {\n      return 3.0 * aA2 - 6.0 * aA1;\n    }\n\n    function C(aA1) {\n      return 3.0 * aA1;\n    }\n\n    function calcBezier(aT, aA1, aA2) {\n      return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;\n    }\n\n    function getSlope(aT, aA1, aA2) {\n      return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\n    }\n\n    function newtonRaphsonIterate(aX, aGuessT) {\n      for (var _i = 0; _i < NEWTON_ITERATIONS; ++_i) {\n        var currentSlope = getSlope(aGuessT, mX1, mX2);\n\n        if (currentSlope === 0.0) {\n          return aGuessT;\n        }\n\n        var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n        aGuessT -= currentX / currentSlope;\n      }\n\n      return aGuessT;\n    }\n\n    function calcSampleValues() {\n      for (var _i2 = 0; _i2 < kSplineTableSize; ++_i2) {\n        mSampleValues[_i2] = calcBezier(_i2 * kSampleStepSize, mX1, mX2);\n      }\n    }\n\n    function binarySubdivide(aX, aA, aB) {\n      var currentX,\n          currentT,\n          i = 0;\n\n      do {\n        currentT = aA + (aB - aA) / 2.0;\n        currentX = calcBezier(currentT, mX1, mX2) - aX;\n\n        if (currentX > 0.0) {\n          aB = currentT;\n        } else {\n          aA = currentT;\n        }\n      } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n\n      return currentT;\n    }\n\n    function getTForX(aX) {\n      var intervalStart = 0.0,\n          currentSample = 1,\n          lastSample = kSplineTableSize - 1;\n\n      for (; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {\n        intervalStart += kSampleStepSize;\n      }\n\n      --currentSample;\n      var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample + 1] - mSampleValues[currentSample]),\n          guessForT = intervalStart + dist * kSampleStepSize,\n          initialSlope = getSlope(guessForT, mX1, mX2);\n\n      if (initialSlope >= NEWTON_MIN_SLOPE) {\n        return newtonRaphsonIterate(aX, guessForT);\n      } else if (initialSlope === 0.0) {\n        return guessForT;\n      } else {\n        return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize);\n      }\n    }\n\n    var _precomputed = false;\n\n    function precompute() {\n      _precomputed = true;\n\n      if (mX1 !== mY1 || mX2 !== mY2) {\n        calcSampleValues();\n      }\n    }\n\n    var f = function f(aX) {\n      if (!_precomputed) {\n        precompute();\n      }\n\n      if (mX1 === mY1 && mX2 === mY2) {\n        return aX;\n      }\n\n      if (aX === 0) {\n        return 0;\n      }\n\n      if (aX === 1) {\n        return 1;\n      }\n\n      return calcBezier(getTForX(aX), mY1, mY2);\n    };\n\n    f.getControlPoints = function () {\n      return [{\n        x: mX1,\n        y: mY1\n      }, {\n        x: mX2,\n        y: mY2\n      }];\n    };\n\n    var str = \"generateBezier(\" + [mX1, mY1, mX2, mY2] + \")\";\n\n    f.toString = function () {\n      return str;\n    };\n\n    return f;\n  }\n\n  /*! Runge-Kutta spring physics function generator. Adapted from Framer.js, copyright Koen Bok. MIT License: http://en.wikipedia.org/wiki/MIT_License */\n\n  /* Given a tension, friction, and duration, a simulation at 60FPS will first run without a defined duration in order to calculate the full path. A second pass\n     then adjusts the time delta -- using the relation between actual time and duration -- to calculate the path for the duration-constrained animation. */\n  var generateSpringRK4 = function () {\n    function springAccelerationForState(state) {\n      return -state.tension * state.x - state.friction * state.v;\n    }\n\n    function springEvaluateStateWithDerivative(initialState, dt, derivative) {\n      var state = {\n        x: initialState.x + derivative.dx * dt,\n        v: initialState.v + derivative.dv * dt,\n        tension: initialState.tension,\n        friction: initialState.friction\n      };\n      return {\n        dx: state.v,\n        dv: springAccelerationForState(state)\n      };\n    }\n\n    function springIntegrateState(state, dt) {\n      var a = {\n        dx: state.v,\n        dv: springAccelerationForState(state)\n      },\n          b = springEvaluateStateWithDerivative(state, dt * 0.5, a),\n          c = springEvaluateStateWithDerivative(state, dt * 0.5, b),\n          d = springEvaluateStateWithDerivative(state, dt, c),\n          dxdt = 1.0 / 6.0 * (a.dx + 2.0 * (b.dx + c.dx) + d.dx),\n          dvdt = 1.0 / 6.0 * (a.dv + 2.0 * (b.dv + c.dv) + d.dv);\n      state.x = state.x + dxdt * dt;\n      state.v = state.v + dvdt * dt;\n      return state;\n    }\n\n    return function springRK4Factory(tension, friction, duration) {\n      var initState = {\n        x: -1,\n        v: 0,\n        tension: null,\n        friction: null\n      },\n          path = [0],\n          time_lapsed = 0,\n          tolerance = 1 / 10000,\n          DT = 16 / 1000,\n          have_duration,\n          dt,\n          last_state;\n      tension = parseFloat(tension) || 500;\n      friction = parseFloat(friction) || 20;\n      duration = duration || null;\n      initState.tension = tension;\n      initState.friction = friction;\n      have_duration = duration !== null;\n      /* Calculate the actual time it takes for this animation to complete with the provided conditions. */\n\n      if (have_duration) {\n        /* Run the simulation without a duration. */\n        time_lapsed = springRK4Factory(tension, friction);\n        /* Compute the adjusted time delta. */\n\n        dt = time_lapsed / duration * DT;\n      } else {\n        dt = DT;\n      }\n\n      for (;;) {\n        /* Next/step function .*/\n        last_state = springIntegrateState(last_state || initState, dt);\n        /* Store the position. */\n\n        path.push(1 + last_state.x);\n        time_lapsed += 16;\n        /* If the change threshold is reached, break. */\n\n        if (!(Math.abs(last_state.x) > tolerance && Math.abs(last_state.v) > tolerance)) {\n          break;\n        }\n      }\n      /* If duration is not defined, return the actual time required for completing this animation. Otherwise, return a closure that holds the\n         computed path and returns a snapshot of the position according to a given percentComplete. */\n\n\n      return !have_duration ? time_lapsed : function (percentComplete) {\n        return path[percentComplete * (path.length - 1) | 0];\n      };\n    };\n  }();\n\n  var cubicBezier = function cubicBezier(t1, p1, t2, p2) {\n    var bezier = generateCubicBezier(t1, p1, t2, p2);\n    return function (start, end, percent) {\n      return start + (end - start) * bezier(percent);\n    };\n  };\n\n  var easings = {\n    'linear': function linear(start, end, percent) {\n      return start + (end - start) * percent;\n    },\n    // default easings\n    'ease': cubicBezier(0.25, 0.1, 0.25, 1),\n    'ease-in': cubicBezier(0.42, 0, 1, 1),\n    'ease-out': cubicBezier(0, 0, 0.58, 1),\n    'ease-in-out': cubicBezier(0.42, 0, 0.58, 1),\n    // sine\n    'ease-in-sine': cubicBezier(0.47, 0, 0.745, 0.715),\n    'ease-out-sine': cubicBezier(0.39, 0.575, 0.565, 1),\n    'ease-in-out-sine': cubicBezier(0.445, 0.05, 0.55, 0.95),\n    // quad\n    'ease-in-quad': cubicBezier(0.55, 0.085, 0.68, 0.53),\n    'ease-out-quad': cubicBezier(0.25, 0.46, 0.45, 0.94),\n    'ease-in-out-quad': cubicBezier(0.455, 0.03, 0.515, 0.955),\n    // cubic\n    'ease-in-cubic': cubicBezier(0.55, 0.055, 0.675, 0.19),\n    'ease-out-cubic': cubicBezier(0.215, 0.61, 0.355, 1),\n    'ease-in-out-cubic': cubicBezier(0.645, 0.045, 0.355, 1),\n    // quart\n    'ease-in-quart': cubicBezier(0.895, 0.03, 0.685, 0.22),\n    'ease-out-quart': cubicBezier(0.165, 0.84, 0.44, 1),\n    'ease-in-out-quart': cubicBezier(0.77, 0, 0.175, 1),\n    // quint\n    'ease-in-quint': cubicBezier(0.755, 0.05, 0.855, 0.06),\n    'ease-out-quint': cubicBezier(0.23, 1, 0.32, 1),\n    'ease-in-out-quint': cubicBezier(0.86, 0, 0.07, 1),\n    // expo\n    'ease-in-expo': cubicBezier(0.95, 0.05, 0.795, 0.035),\n    'ease-out-expo': cubicBezier(0.19, 1, 0.22, 1),\n    'ease-in-out-expo': cubicBezier(1, 0, 0, 1),\n    // circ\n    'ease-in-circ': cubicBezier(0.6, 0.04, 0.98, 0.335),\n    'ease-out-circ': cubicBezier(0.075, 0.82, 0.165, 1),\n    'ease-in-out-circ': cubicBezier(0.785, 0.135, 0.15, 0.86),\n    // user param easings...\n    'spring': function spring(tension, friction, duration) {\n      if (duration === 0) {\n        // can't get a spring w/ duration 0\n        return easings.linear; // duration 0 => jump to end so impl doesn't matter\n      }\n\n      var spring = generateSpringRK4(tension, friction, duration);\n      return function (start, end, percent) {\n        return start + (end - start) * spring(percent);\n      };\n    },\n    'cubic-bezier': cubicBezier\n  };\n\n  function getEasedValue(type, start, end, percent, easingFn) {\n    if (percent === 1) {\n      return end;\n    }\n\n    if (start === end) {\n      return end;\n    }\n\n    var val = easingFn(start, end, percent);\n\n    if (type == null) {\n      return val;\n    }\n\n    if (type.roundValue || type.color) {\n      val = Math.round(val);\n    }\n\n    if (type.min !== undefined) {\n      val = Math.max(val, type.min);\n    }\n\n    if (type.max !== undefined) {\n      val = Math.min(val, type.max);\n    }\n\n    return val;\n  }\n\n  function getValue(prop, spec) {\n    if (prop.pfValue != null || prop.value != null) {\n      if (prop.pfValue != null && (spec == null || spec.type.units !== '%')) {\n        return prop.pfValue;\n      } else {\n        return prop.value;\n      }\n    } else {\n      return prop;\n    }\n  }\n\n  function ease(startProp, endProp, percent, easingFn, propSpec) {\n    var type = propSpec != null ? propSpec.type : null;\n\n    if (percent < 0) {\n      percent = 0;\n    } else if (percent > 1) {\n      percent = 1;\n    }\n\n    var start = getValue(startProp, propSpec);\n    var end = getValue(endProp, propSpec);\n\n    if (number$1(start) && number$1(end)) {\n      return getEasedValue(type, start, end, percent, easingFn);\n    } else if (array(start) && array(end)) {\n      var easedArr = [];\n\n      for (var i = 0; i < end.length; i++) {\n        var si = start[i];\n        var ei = end[i];\n\n        if (si != null && ei != null) {\n          var val = getEasedValue(type, si, ei, percent, easingFn);\n          easedArr.push(val);\n        } else {\n          easedArr.push(ei);\n        }\n      }\n\n      return easedArr;\n    }\n\n    return undefined;\n  }\n\n  function step$1(self, ani, now, isCore) {\n    var isEles = !isCore;\n    var _p = self._private;\n    var ani_p = ani._private;\n    var pEasing = ani_p.easing;\n    var startTime = ani_p.startTime;\n    var cy = isCore ? self : self.cy();\n    var style = cy.style();\n\n    if (!ani_p.easingImpl) {\n      if (pEasing == null) {\n        // use default\n        ani_p.easingImpl = easings['linear'];\n      } else {\n        // then define w/ name\n        var easingVals;\n\n        if (string(pEasing)) {\n          var easingProp = style.parse('transition-timing-function', pEasing);\n          easingVals = easingProp.value;\n        } else {\n          // then assume preparsed array\n          easingVals = pEasing;\n        }\n\n        var name, args;\n\n        if (string(easingVals)) {\n          name = easingVals;\n          args = [];\n        } else {\n          name = easingVals[1];\n          args = easingVals.slice(2).map(function (n) {\n            return +n;\n          });\n        }\n\n        if (args.length > 0) {\n          // create with args\n          if (name === 'spring') {\n            args.push(ani_p.duration); // need duration to generate spring\n          }\n\n          ani_p.easingImpl = easings[name].apply(null, args);\n        } else {\n          // static impl by name\n          ani_p.easingImpl = easings[name];\n        }\n      }\n    }\n\n    var easing = ani_p.easingImpl;\n    var percent;\n\n    if (ani_p.duration === 0) {\n      percent = 1;\n    } else {\n      percent = (now - startTime) / ani_p.duration;\n    }\n\n    if (ani_p.applying) {\n      percent = ani_p.progress;\n    }\n\n    if (percent < 0) {\n      percent = 0;\n    } else if (percent > 1) {\n      percent = 1;\n    }\n\n    if (ani_p.delay == null) {\n      // then update\n      var startPos = ani_p.startPosition;\n      var endPos = ani_p.position;\n\n      if (endPos && isEles && !self.locked()) {\n        var newPos = {};\n\n        if (valid(startPos.x, endPos.x)) {\n          newPos.x = ease(startPos.x, endPos.x, percent, easing);\n        }\n\n        if (valid(startPos.y, endPos.y)) {\n          newPos.y = ease(startPos.y, endPos.y, percent, easing);\n        }\n\n        self.position(newPos);\n      }\n\n      var startPan = ani_p.startPan;\n      var endPan = ani_p.pan;\n      var pan = _p.pan;\n      var animatingPan = endPan != null && isCore;\n\n      if (animatingPan) {\n        if (valid(startPan.x, endPan.x)) {\n          pan.x = ease(startPan.x, endPan.x, percent, easing);\n        }\n\n        if (valid(startPan.y, endPan.y)) {\n          pan.y = ease(startPan.y, endPan.y, percent, easing);\n        }\n\n        self.emit('pan');\n      }\n\n      var startZoom = ani_p.startZoom;\n      var endZoom = ani_p.zoom;\n      var animatingZoom = endZoom != null && isCore;\n\n      if (animatingZoom) {\n        if (valid(startZoom, endZoom)) {\n          _p.zoom = bound(_p.minZoom, ease(startZoom, endZoom, percent, easing), _p.maxZoom);\n        }\n\n        self.emit('zoom');\n      }\n\n      if (animatingPan || animatingZoom) {\n        self.emit('viewport');\n      }\n\n      var props = ani_p.style;\n\n      if (props && props.length > 0 && isEles) {\n        for (var i = 0; i < props.length; i++) {\n          var prop = props[i];\n          var _name = prop.name;\n          var end = prop;\n          var start = ani_p.startStyle[_name];\n          var propSpec = style.properties[start.name];\n          var easedVal = ease(start, end, percent, easing, propSpec);\n          style.overrideBypass(self, _name, easedVal);\n        } // for props\n\n\n        self.emit('style');\n      } // if\n\n    }\n\n    ani_p.progress = percent;\n    return percent;\n  }\n\n  function valid(start, end) {\n    if (start == null || end == null) {\n      return false;\n    }\n\n    if (number$1(start) && number$1(end)) {\n      return true;\n    } else if (start && end) {\n      return true;\n    }\n\n    return false;\n  }\n\n  function startAnimation(self, ani, now, isCore) {\n    var ani_p = ani._private;\n    ani_p.started = true;\n    ani_p.startTime = now - ani_p.progress * ani_p.duration;\n  }\n\n  function stepAll(now, cy) {\n    var eles = cy._private.aniEles;\n    var doneEles = [];\n\n    function stepOne(ele, isCore) {\n      var _p = ele._private;\n      var current = _p.animation.current;\n      var queue = _p.animation.queue;\n      var ranAnis = false; // if nothing currently animating, get something from the queue\n\n      if (current.length === 0) {\n        var next = queue.shift();\n\n        if (next) {\n          current.push(next);\n        }\n      }\n\n      var callbacks = function callbacks(_callbacks) {\n        for (var j = _callbacks.length - 1; j >= 0; j--) {\n          var cb = _callbacks[j];\n          cb();\n        }\n\n        _callbacks.splice(0, _callbacks.length);\n      }; // step and remove if done\n\n\n      for (var i = current.length - 1; i >= 0; i--) {\n        var ani = current[i];\n        var ani_p = ani._private;\n\n        if (ani_p.stopped) {\n          current.splice(i, 1);\n          ani_p.hooked = false;\n          ani_p.playing = false;\n          ani_p.started = false;\n          callbacks(ani_p.frames);\n          continue;\n        }\n\n        if (!ani_p.playing && !ani_p.applying) {\n          continue;\n        } // an apply() while playing shouldn't do anything\n\n\n        if (ani_p.playing && ani_p.applying) {\n          ani_p.applying = false;\n        }\n\n        if (!ani_p.started) {\n          startAnimation(ele, ani, now);\n        }\n\n        step$1(ele, ani, now, isCore);\n\n        if (ani_p.applying) {\n          ani_p.applying = false;\n        }\n\n        callbacks(ani_p.frames);\n\n        if (ani_p.step != null) {\n          ani_p.step(now);\n        }\n\n        if (ani.completed()) {\n          current.splice(i, 1);\n          ani_p.hooked = false;\n          ani_p.playing = false;\n          ani_p.started = false;\n          callbacks(ani_p.completes);\n        }\n\n        ranAnis = true;\n      }\n\n      if (!isCore && current.length === 0 && queue.length === 0) {\n        doneEles.push(ele);\n      }\n\n      return ranAnis;\n    } // stepElement\n    // handle all eles\n\n\n    var ranEleAni = false;\n\n    for (var e = 0; e < eles.length; e++) {\n      var ele = eles[e];\n      var handledThisEle = stepOne(ele);\n      ranEleAni = ranEleAni || handledThisEle;\n    } // each element\n\n\n    var ranCoreAni = stepOne(cy, true); // notify renderer\n\n    if (ranEleAni || ranCoreAni) {\n      if (eles.length > 0) {\n        cy.notify('draw', eles);\n      } else {\n        cy.notify('draw');\n      }\n    } // remove elements from list of currently animating if its queues are empty\n\n\n    eles.unmerge(doneEles);\n    cy.emit('step');\n  } // stepAll\n\n  var corefn$8 = {\n    // pull in animation functions\n    animate: define.animate(),\n    animation: define.animation(),\n    animated: define.animated(),\n    clearQueue: define.clearQueue(),\n    delay: define.delay(),\n    delayAnimation: define.delayAnimation(),\n    stop: define.stop(),\n    addToAnimationPool: function addToAnimationPool(eles) {\n      var cy = this;\n\n      if (!cy.styleEnabled()) {\n        return;\n      } // save cycles when no style used\n\n\n      cy._private.aniEles.merge(eles);\n    },\n    stopAnimationLoop: function stopAnimationLoop() {\n      this._private.animationsRunning = false;\n    },\n    startAnimationLoop: function startAnimationLoop() {\n      var cy = this;\n      cy._private.animationsRunning = true;\n\n      if (!cy.styleEnabled()) {\n        return;\n      } // save cycles when no style used\n      // NB the animation loop will exec in headless environments if style enabled\n      // and explicit cy.destroy() is necessary to stop the loop\n\n\n      function headlessStep() {\n        if (!cy._private.animationsRunning) {\n          return;\n        }\n\n        requestAnimationFrame(function animationStep(now) {\n          stepAll(now, cy);\n          headlessStep();\n        });\n      }\n\n      var renderer = cy.renderer();\n\n      if (renderer && renderer.beforeRender) {\n        // let the renderer schedule animations\n        renderer.beforeRender(function rendererAnimationStep(willDraw, now) {\n          stepAll(now, cy);\n        }, renderer.beforeRenderPriorities.animations);\n      } else {\n        // manage the animation loop ourselves\n        headlessStep(); // first call\n      }\n    }\n  };\n\n  var emitterOptions = {\n    qualifierCompare: function qualifierCompare(selector1, selector2) {\n      if (selector1 == null || selector2 == null) {\n        return selector1 == null && selector2 == null;\n      } else {\n        return selector1.sameText(selector2);\n      }\n    },\n    eventMatches: function eventMatches(cy, listener, eventObj) {\n      var selector = listener.qualifier;\n\n      if (selector != null) {\n        return cy !== eventObj.target && element(eventObj.target) && selector.matches(eventObj.target);\n      }\n\n      return true;\n    },\n    addEventFields: function addEventFields(cy, evt) {\n      evt.cy = cy;\n      evt.target = cy;\n    },\n    callbackContext: function callbackContext(cy, listener, eventObj) {\n      return listener.qualifier != null ? eventObj.target : cy;\n    }\n  };\n\n  var argSelector = function argSelector(arg) {\n    if (string(arg)) {\n      return new Selector(arg);\n    } else {\n      return arg;\n    }\n  };\n\n  var elesfn = {\n    createEmitter: function createEmitter() {\n      var _p = this._private;\n\n      if (!_p.emitter) {\n        _p.emitter = new Emitter(emitterOptions, this);\n      }\n\n      return this;\n    },\n    emitter: function emitter() {\n      return this._private.emitter;\n    },\n    on: function on(events, selector, callback) {\n      this.emitter().on(events, argSelector(selector), callback);\n      return this;\n    },\n    removeListener: function removeListener(events, selector, callback) {\n      this.emitter().removeListener(events, argSelector(selector), callback);\n      return this;\n    },\n    removeAllListeners: function removeAllListeners() {\n      this.emitter().removeAllListeners();\n      return this;\n    },\n    one: function one(events, selector, callback) {\n      this.emitter().one(events, argSelector(selector), callback);\n      return this;\n    },\n    once: function once(events, selector, callback) {\n      this.emitter().one(events, argSelector(selector), callback);\n      return this;\n    },\n    emit: function emit(events, extraParams) {\n      this.emitter().emit(events, extraParams);\n      return this;\n    },\n    emitAndNotify: function emitAndNotify(event, eles) {\n      this.emit(event);\n      this.notify(event, eles);\n      return this;\n    }\n  };\n  define.eventAliasesOn(elesfn);\n\n  var corefn$7 = {\n    png: function png(options) {\n      var renderer = this._private.renderer;\n      options = options || {};\n      return renderer.png(options);\n    },\n    jpg: function jpg(options) {\n      var renderer = this._private.renderer;\n      options = options || {};\n      options.bg = options.bg || '#fff';\n      return renderer.jpg(options);\n    }\n  };\n  corefn$7.jpeg = corefn$7.jpg;\n\n  var corefn$6 = {\n    layout: function layout(options) {\n      var cy = this;\n\n      if (options == null) {\n        error('Layout options must be specified to make a layout');\n        return;\n      }\n\n      if (options.name == null) {\n        error('A `name` must be specified to make a layout');\n        return;\n      }\n\n      var name = options.name;\n      var Layout = cy.extension('layout', name);\n\n      if (Layout == null) {\n        error('No such layout `' + name + '` found.  Did you forget to import it and `cytoscape.use()` it?');\n        return;\n      }\n\n      var eles;\n\n      if (string(options.eles)) {\n        eles = cy.$(options.eles);\n      } else {\n        eles = options.eles != null ? options.eles : cy.$();\n      }\n\n      var layout = new Layout(extend({}, options, {\n        cy: cy,\n        eles: eles\n      }));\n      return layout;\n    }\n  };\n  corefn$6.createLayout = corefn$6.makeLayout = corefn$6.layout;\n\n  var corefn$5 = {\n    notify: function notify(eventName, eventEles) {\n      var _p = this._private;\n\n      if (this.batching()) {\n        _p.batchNotifications = _p.batchNotifications || {};\n        var eles = _p.batchNotifications[eventName] = _p.batchNotifications[eventName] || this.collection();\n\n        if (eventEles != null) {\n          eles.merge(eventEles);\n        }\n\n        return; // notifications are disabled during batching\n      }\n\n      if (!_p.notificationsEnabled) {\n        return;\n      } // exit on disabled\n\n\n      var renderer = this.renderer(); // exit if destroy() called on core or renderer in between frames #1499 #1528\n\n      if (this.destroyed() || !renderer) {\n        return;\n      }\n\n      renderer.notify(eventName, eventEles);\n    },\n    notifications: function notifications(bool) {\n      var p = this._private;\n\n      if (bool === undefined) {\n        return p.notificationsEnabled;\n      } else {\n        p.notificationsEnabled = bool ? true : false;\n      }\n\n      return this;\n    },\n    noNotifications: function noNotifications(callback) {\n      this.notifications(false);\n      callback();\n      this.notifications(true);\n    },\n    batching: function batching() {\n      return this._private.batchCount > 0;\n    },\n    startBatch: function startBatch() {\n      var _p = this._private;\n\n      if (_p.batchCount == null) {\n        _p.batchCount = 0;\n      }\n\n      if (_p.batchCount === 0) {\n        _p.batchStyleEles = this.collection();\n        _p.batchNotifications = {};\n      }\n\n      _p.batchCount++;\n      return this;\n    },\n    endBatch: function endBatch() {\n      var _p = this._private;\n\n      if (_p.batchCount === 0) {\n        return this;\n      }\n\n      _p.batchCount--;\n\n      if (_p.batchCount === 0) {\n        // update style for dirty eles\n        _p.batchStyleEles.updateStyle();\n\n        var renderer = this.renderer(); // notify the renderer of queued eles and event types\n\n        Object.keys(_p.batchNotifications).forEach(function (eventName) {\n          var eles = _p.batchNotifications[eventName];\n\n          if (eles.empty()) {\n            renderer.notify(eventName);\n          } else {\n            renderer.notify(eventName, eles);\n          }\n        });\n      }\n\n      return this;\n    },\n    batch: function batch(callback) {\n      this.startBatch();\n      callback();\n      this.endBatch();\n      return this;\n    },\n    // for backwards compatibility\n    batchData: function batchData(map) {\n      var cy = this;\n      return this.batch(function () {\n        var ids = Object.keys(map);\n\n        for (var i = 0; i < ids.length; i++) {\n          var id = ids[i];\n          var data = map[id];\n          var ele = cy.getElementById(id);\n          ele.data(data);\n        }\n      });\n    }\n  };\n\n  var rendererDefaults = defaults$g({\n    hideEdgesOnViewport: false,\n    textureOnViewport: false,\n    motionBlur: false,\n    motionBlurOpacity: 0.05,\n    pixelRatio: undefined,\n    desktopTapThreshold: 4,\n    touchTapThreshold: 8,\n    wheelSensitivity: 1,\n    debug: false,\n    showFps: false\n  });\n  var corefn$4 = {\n    renderTo: function renderTo(context, zoom, pan, pxRatio) {\n      var r = this._private.renderer;\n      r.renderTo(context, zoom, pan, pxRatio);\n      return this;\n    },\n    renderer: function renderer() {\n      return this._private.renderer;\n    },\n    forceRender: function forceRender() {\n      this.notify('draw');\n      return this;\n    },\n    resize: function resize() {\n      this.invalidateSize();\n      this.emitAndNotify('resize');\n      return this;\n    },\n    initRenderer: function initRenderer(options) {\n      var cy = this;\n      var RendererProto = cy.extension('renderer', options.name);\n\n      if (RendererProto == null) {\n        error(\"Can not initialise: No such renderer `\".concat(options.name, \"` found. Did you forget to import it and `cytoscape.use()` it?\"));\n        return;\n      }\n\n      if (options.wheelSensitivity !== undefined) {\n        warn(\"You have set a custom wheel sensitivity.  This will make your app zoom unnaturally when using mainstream mice.  You should change this value from the default only if you can guarantee that all your users will use the same hardware and OS configuration as your current machine.\");\n      }\n\n      var rOpts = rendererDefaults(options);\n      rOpts.cy = cy;\n      cy._private.renderer = new RendererProto(rOpts);\n      this.notify('init');\n    },\n    destroyRenderer: function destroyRenderer() {\n      var cy = this;\n      cy.notify('destroy'); // destroy the renderer\n\n      var domEle = cy.container();\n\n      if (domEle) {\n        domEle._cyreg = null;\n\n        while (domEle.childNodes.length > 0) {\n          domEle.removeChild(domEle.childNodes[0]);\n        }\n      }\n\n      cy._private.renderer = null; // to be extra safe, remove the ref\n\n      cy.mutableElements().forEach(function (ele) {\n        var _p = ele._private;\n        _p.rscratch = {};\n        _p.rstyle = {};\n        _p.animation.current = [];\n        _p.animation.queue = [];\n      });\n    },\n    onRender: function onRender(fn) {\n      return this.on('render', fn);\n    },\n    offRender: function offRender(fn) {\n      return this.off('render', fn);\n    }\n  };\n  corefn$4.invalidateDimensions = corefn$4.resize;\n\n  var corefn$3 = {\n    // get a collection\n    // - empty collection on no args\n    // - collection of elements in the graph on selector arg\n    // - guarantee a returned collection when elements or collection specified\n    collection: function collection(eles, opts) {\n      if (string(eles)) {\n        return this.$(eles);\n      } else if (elementOrCollection(eles)) {\n        return eles.collection();\n      } else if (array(eles)) {\n        if (!opts) {\n          opts = {};\n        }\n\n        return new Collection(this, eles, opts.unique, opts.removed);\n      }\n\n      return new Collection(this);\n    },\n    nodes: function nodes(selector) {\n      var nodes = this.$(function (ele) {\n        return ele.isNode();\n      });\n\n      if (selector) {\n        return nodes.filter(selector);\n      }\n\n      return nodes;\n    },\n    edges: function edges(selector) {\n      var edges = this.$(function (ele) {\n        return ele.isEdge();\n      });\n\n      if (selector) {\n        return edges.filter(selector);\n      }\n\n      return edges;\n    },\n    // search the graph like jQuery\n    $: function $(selector) {\n      var eles = this._private.elements;\n\n      if (selector) {\n        return eles.filter(selector);\n      } else {\n        return eles.spawnSelf();\n      }\n    },\n    mutableElements: function mutableElements() {\n      return this._private.elements;\n    }\n  }; // aliases\n\n  corefn$3.elements = corefn$3.filter = corefn$3.$;\n\n  var styfn$8 = {}; // keys for style blocks, e.g. ttfftt\n\n  var TRUE = 't';\n  var FALSE = 'f'; // (potentially expensive calculation)\n  // apply the style to the element based on\n  // - its bypass\n  // - what selectors match it\n\n  styfn$8.apply = function (eles) {\n    var self = this;\n    var _p = self._private;\n    var cy = _p.cy;\n    var updatedEles = cy.collection();\n\n    for (var ie = 0; ie < eles.length; ie++) {\n      var ele = eles[ie];\n      var cxtMeta = self.getContextMeta(ele);\n\n      if (cxtMeta.empty) {\n        continue;\n      }\n\n      var cxtStyle = self.getContextStyle(cxtMeta);\n      var app = self.applyContextStyle(cxtMeta, cxtStyle, ele);\n\n      if (ele._private.appliedInitStyle) {\n        self.updateTransitions(ele, app.diffProps);\n      } else {\n        ele._private.appliedInitStyle = true;\n      }\n\n      var hintsDiff = self.updateStyleHints(ele);\n\n      if (hintsDiff) {\n        updatedEles.push(ele);\n      }\n    } // for elements\n\n\n    return updatedEles;\n  };\n\n  styfn$8.getPropertiesDiff = function (oldCxtKey, newCxtKey) {\n    var self = this;\n    var cache = self._private.propDiffs = self._private.propDiffs || {};\n    var dualCxtKey = oldCxtKey + '-' + newCxtKey;\n    var cachedVal = cache[dualCxtKey];\n\n    if (cachedVal) {\n      return cachedVal;\n    }\n\n    var diffProps = [];\n    var addedProp = {};\n\n    for (var i = 0; i < self.length; i++) {\n      var cxt = self[i];\n      var oldHasCxt = oldCxtKey[i] === TRUE;\n      var newHasCxt = newCxtKey[i] === TRUE;\n      var cxtHasDiffed = oldHasCxt !== newHasCxt;\n      var cxtHasMappedProps = cxt.mappedProperties.length > 0;\n\n      if (cxtHasDiffed || newHasCxt && cxtHasMappedProps) {\n        var props = void 0;\n\n        if (cxtHasDiffed && cxtHasMappedProps) {\n          props = cxt.properties; // suffices b/c mappedProperties is a subset of properties\n        } else if (cxtHasDiffed) {\n          props = cxt.properties; // need to check them all\n        } else if (cxtHasMappedProps) {\n          props = cxt.mappedProperties; // only need to check mapped\n        }\n\n        for (var j = 0; j < props.length; j++) {\n          var prop = props[j];\n          var name = prop.name; // if a later context overrides this property, then the fact that this context has switched/diffed doesn't matter\n          // (semi expensive check since it makes this function O(n^2) on context length, but worth it since overall result\n          // is cached)\n\n          var laterCxtOverrides = false;\n\n          for (var k = i + 1; k < self.length; k++) {\n            var laterCxt = self[k];\n            var hasLaterCxt = newCxtKey[k] === TRUE;\n\n            if (!hasLaterCxt) {\n              continue;\n            } // can't override unless the context is active\n\n\n            laterCxtOverrides = laterCxt.properties[prop.name] != null;\n\n            if (laterCxtOverrides) {\n              break;\n            } // exit early as long as one later context overrides\n\n          }\n\n          if (!addedProp[name] && !laterCxtOverrides) {\n            addedProp[name] = true;\n            diffProps.push(name);\n          }\n        } // for props\n\n      } // if\n\n    } // for contexts\n\n\n    cache[dualCxtKey] = diffProps;\n    return diffProps;\n  };\n\n  styfn$8.getContextMeta = function (ele) {\n    var self = this;\n    var cxtKey = '';\n    var diffProps;\n    var prevKey = ele._private.styleCxtKey || ''; // get the cxt key\n\n    for (var i = 0; i < self.length; i++) {\n      var context = self[i];\n      var contextSelectorMatches = context.selector && context.selector.matches(ele); // NB: context.selector may be null for 'core'\n\n      if (contextSelectorMatches) {\n        cxtKey += TRUE;\n      } else {\n        cxtKey += FALSE;\n      }\n    } // for context\n\n\n    diffProps = self.getPropertiesDiff(prevKey, cxtKey);\n    ele._private.styleCxtKey = cxtKey;\n    return {\n      key: cxtKey,\n      diffPropNames: diffProps,\n      empty: diffProps.length === 0\n    };\n  }; // gets a computed ele style object based on matched contexts\n\n\n  styfn$8.getContextStyle = function (cxtMeta) {\n    var cxtKey = cxtMeta.key;\n    var self = this;\n    var cxtStyles = this._private.contextStyles = this._private.contextStyles || {}; // if already computed style, returned cached copy\n\n    if (cxtStyles[cxtKey]) {\n      return cxtStyles[cxtKey];\n    }\n\n    var style = {\n      _private: {\n        key: cxtKey\n      }\n    };\n\n    for (var i = 0; i < self.length; i++) {\n      var cxt = self[i];\n      var hasCxt = cxtKey[i] === TRUE;\n\n      if (!hasCxt) {\n        continue;\n      }\n\n      for (var j = 0; j < cxt.properties.length; j++) {\n        var prop = cxt.properties[j];\n        style[prop.name] = prop;\n      }\n    }\n\n    cxtStyles[cxtKey] = style;\n    return style;\n  };\n\n  styfn$8.applyContextStyle = function (cxtMeta, cxtStyle, ele) {\n    var self = this;\n    var diffProps = cxtMeta.diffPropNames;\n    var retDiffProps = {};\n    var types = self.types;\n\n    for (var i = 0; i < diffProps.length; i++) {\n      var diffPropName = diffProps[i];\n      var cxtProp = cxtStyle[diffPropName];\n      var eleProp = ele.pstyle(diffPropName);\n\n      if (!cxtProp) {\n        // no context prop means delete\n        if (!eleProp) {\n          continue; // no existing prop means nothing needs to be removed\n          // nb affects initial application on mapped values like control-point-distances\n        } else if (eleProp.bypass) {\n          cxtProp = {\n            name: diffPropName,\n            deleteBypassed: true\n          };\n        } else {\n          cxtProp = {\n            name: diffPropName,\n            \"delete\": true\n          };\n        }\n      } // save cycles when the context prop doesn't need to be applied\n\n\n      if (eleProp === cxtProp) {\n        continue;\n      } // save cycles when a mapped context prop doesn't need to be applied\n\n\n      if (cxtProp.mapped === types.fn // context prop is function mapper\n      && eleProp != null // some props can be null even by default (e.g. a prop that overrides another one)\n      && eleProp.mapping != null // ele prop is a concrete value from from a mapper\n      && eleProp.mapping.value === cxtProp.value // the current prop on the ele is a flat prop value for the function mapper\n      ) {\n        // NB don't write to cxtProp, as it's shared among eles (stored in stylesheet)\n        var mapping = eleProp.mapping; // can write to mapping, as it's a per-ele copy\n\n        var fnValue = mapping.fnValue = cxtProp.value(ele); // temporarily cache the value in case of a miss\n\n        if (fnValue === mapping.prevFnValue) {\n          continue;\n        }\n      }\n\n      var retDiffProp = retDiffProps[diffPropName] = {\n        prev: eleProp\n      };\n      self.applyParsedProperty(ele, cxtProp);\n      retDiffProp.next = ele.pstyle(diffPropName);\n\n      if (retDiffProp.next && retDiffProp.next.bypass) {\n        retDiffProp.next = retDiffProp.next.bypassed;\n      }\n    }\n\n    return {\n      diffProps: retDiffProps\n    };\n  };\n\n  styfn$8.updateStyleHints = function (ele) {\n    var _p = ele._private;\n    var self = this;\n    var propNames = self.propertyGroupNames;\n    var propGrKeys = self.propertyGroupKeys;\n\n    var propHash = function propHash(ele, propNames, seedKey) {\n      return self.getPropertiesHash(ele, propNames, seedKey);\n    };\n\n    var oldStyleKey = _p.styleKey;\n\n    if (ele.removed()) {\n      return false;\n    }\n\n    var isNode = _p.group === 'nodes'; // get the style key hashes per prop group\n    // but lazily -- only use non-default prop values to reduce the number of hashes\n    //\n\n    var overriddenStyles = ele._private.style;\n    propNames = Object.keys(overriddenStyles);\n\n    for (var i = 0; i < propGrKeys.length; i++) {\n      var grKey = propGrKeys[i];\n      _p.styleKeys[grKey] = [DEFAULT_HASH_SEED, DEFAULT_HASH_SEED_ALT];\n    }\n\n    var updateGrKey1 = function updateGrKey1(val, grKey) {\n      return _p.styleKeys[grKey][0] = hashInt(val, _p.styleKeys[grKey][0]);\n    };\n\n    var updateGrKey2 = function updateGrKey2(val, grKey) {\n      return _p.styleKeys[grKey][1] = hashIntAlt(val, _p.styleKeys[grKey][1]);\n    };\n\n    var updateGrKey = function updateGrKey(val, grKey) {\n      updateGrKey1(val, grKey);\n      updateGrKey2(val, grKey);\n    };\n\n    var updateGrKeyWStr = function updateGrKeyWStr(strVal, grKey) {\n      for (var j = 0; j < strVal.length; j++) {\n        var ch = strVal.charCodeAt(j);\n        updateGrKey1(ch, grKey);\n        updateGrKey2(ch, grKey);\n      }\n    }; // - hashing works on 32 bit ints b/c we use bitwise ops\n    // - small numbers get cut off (e.g. 0.123 is seen as 0 by the hashing function)\n    // - raise up small numbers so more significant digits are seen by hashing\n    // - make small numbers larger than a normal value to avoid collisions\n    // - works in practice and it's relatively cheap\n\n\n    var N = 2000000000;\n\n    var cleanNum = function cleanNum(val) {\n      return -128 < val && val < 128 && Math.floor(val) !== val ? N - (val * 1024 | 0) : val;\n    };\n\n    for (var _i = 0; _i < propNames.length; _i++) {\n      var name = propNames[_i];\n      var parsedProp = overriddenStyles[name];\n\n      if (parsedProp == null) {\n        continue;\n      }\n\n      var propInfo = this.properties[name];\n      var type = propInfo.type;\n      var _grKey = propInfo.groupKey;\n      var normalizedNumberVal = void 0;\n\n      if (propInfo.hashOverride != null) {\n        normalizedNumberVal = propInfo.hashOverride(ele, parsedProp);\n      } else if (parsedProp.pfValue != null) {\n        normalizedNumberVal = parsedProp.pfValue;\n      } // might not be a number if it allows enums\n\n\n      var numberVal = propInfo.enums == null ? parsedProp.value : null;\n      var haveNormNum = normalizedNumberVal != null;\n      var haveUnitedNum = numberVal != null;\n      var haveNum = haveNormNum || haveUnitedNum;\n      var units = parsedProp.units; // numbers are cheaper to hash than strings\n      // 1 hash op vs n hash ops (for length n string)\n\n      if (type.number && haveNum && !type.multiple) {\n        var v = haveNormNum ? normalizedNumberVal : numberVal;\n        updateGrKey(cleanNum(v), _grKey);\n\n        if (!haveNormNum && units != null) {\n          updateGrKeyWStr(units, _grKey);\n        }\n      } else {\n        updateGrKeyWStr(parsedProp.strValue, _grKey);\n      }\n    } // overall style key\n    //\n\n\n    var hash = [DEFAULT_HASH_SEED, DEFAULT_HASH_SEED_ALT];\n\n    for (var _i2 = 0; _i2 < propGrKeys.length; _i2++) {\n      var _grKey2 = propGrKeys[_i2];\n      var grHash = _p.styleKeys[_grKey2];\n      hash[0] = hashInt(grHash[0], hash[0]);\n      hash[1] = hashIntAlt(grHash[1], hash[1]);\n    }\n\n    _p.styleKey = combineHashes(hash[0], hash[1]); // label dims\n    //\n\n    var sk = _p.styleKeys;\n    _p.labelDimsKey = combineHashesArray(sk.labelDimensions);\n    var labelKeys = propHash(ele, ['label'], sk.labelDimensions);\n    _p.labelKey = combineHashesArray(labelKeys);\n    _p.labelStyleKey = combineHashesArray(hashArrays(sk.commonLabel, labelKeys));\n\n    if (!isNode) {\n      var sourceLabelKeys = propHash(ele, ['source-label'], sk.labelDimensions);\n      _p.sourceLabelKey = combineHashesArray(sourceLabelKeys);\n      _p.sourceLabelStyleKey = combineHashesArray(hashArrays(sk.commonLabel, sourceLabelKeys));\n      var targetLabelKeys = propHash(ele, ['target-label'], sk.labelDimensions);\n      _p.targetLabelKey = combineHashesArray(targetLabelKeys);\n      _p.targetLabelStyleKey = combineHashesArray(hashArrays(sk.commonLabel, targetLabelKeys));\n    } // node\n    //\n\n\n    if (isNode) {\n      var _p$styleKeys = _p.styleKeys,\n          nodeBody = _p$styleKeys.nodeBody,\n          nodeBorder = _p$styleKeys.nodeBorder,\n          backgroundImage = _p$styleKeys.backgroundImage,\n          compound = _p$styleKeys.compound,\n          pie = _p$styleKeys.pie;\n      var nodeKeys = [nodeBody, nodeBorder, backgroundImage, compound, pie].filter(function (k) {\n        return k != null;\n      }).reduce(hashArrays, [DEFAULT_HASH_SEED, DEFAULT_HASH_SEED_ALT]);\n      _p.nodeKey = combineHashesArray(nodeKeys);\n      _p.hasPie = pie != null && pie[0] !== DEFAULT_HASH_SEED && pie[1] !== DEFAULT_HASH_SEED_ALT;\n    }\n\n    return oldStyleKey !== _p.styleKey;\n  };\n\n  styfn$8.clearStyleHints = function (ele) {\n    var _p = ele._private;\n    _p.styleCxtKey = '';\n    _p.styleKeys = {};\n    _p.styleKey = null;\n    _p.labelKey = null;\n    _p.labelStyleKey = null;\n    _p.sourceLabelKey = null;\n    _p.sourceLabelStyleKey = null;\n    _p.targetLabelKey = null;\n    _p.targetLabelStyleKey = null;\n    _p.nodeKey = null;\n    _p.hasPie = null;\n  }; // apply a property to the style (for internal use)\n  // returns whether application was successful\n  //\n  // now, this function flattens the property, and here's how:\n  //\n  // for parsedProp:{ bypass: true, deleteBypass: true }\n  // no property is generated, instead the bypass property in the\n  // element's style is replaced by what's pointed to by the `bypassed`\n  // field in the bypass property (i.e. restoring the property the\n  // bypass was overriding)\n  //\n  // for parsedProp:{ mapped: truthy }\n  // the generated flattenedProp:{ mapping: prop }\n  //\n  // for parsedProp:{ bypass: true }\n  // the generated flattenedProp:{ bypassed: parsedProp }\n\n\n  styfn$8.applyParsedProperty = function (ele, parsedProp) {\n    var self = this;\n    var prop = parsedProp;\n    var style = ele._private.style;\n    var flatProp;\n    var types = self.types;\n    var type = self.properties[prop.name].type;\n    var propIsBypass = prop.bypass;\n    var origProp = style[prop.name];\n    var origPropIsBypass = origProp && origProp.bypass;\n    var _p = ele._private;\n    var flatPropMapping = 'mapping';\n\n    var getVal = function getVal(p) {\n      if (p == null) {\n        return null;\n      } else if (p.pfValue != null) {\n        return p.pfValue;\n      } else {\n        return p.value;\n      }\n    };\n\n    var checkTriggers = function checkTriggers() {\n      var fromVal = getVal(origProp);\n      var toVal = getVal(prop);\n      self.checkTriggers(ele, prop.name, fromVal, toVal);\n    };\n\n    if (prop && prop.name.substr(0, 3) === 'pie') {\n      warn('The pie style properties are deprecated.  Create charts using background images instead.');\n    } // edge sanity checks to prevent the client from making serious mistakes\n\n\n    if (parsedProp.name === 'curve-style' && ele.isEdge() && ( // loops must be bundled beziers\n    parsedProp.value !== 'bezier' && ele.isLoop() || // edges connected to compound nodes can not be haystacks\n    parsedProp.value === 'haystack' && (ele.source().isParent() || ele.target().isParent()))) {\n      prop = parsedProp = this.parse(parsedProp.name, 'bezier', propIsBypass);\n    }\n\n    if (prop[\"delete\"]) {\n      // delete the property and use the default value on falsey value\n      style[prop.name] = undefined;\n      checkTriggers();\n      return true;\n    }\n\n    if (prop.deleteBypassed) {\n      // delete the property that the\n      if (!origProp) {\n        checkTriggers();\n        return true; // can't delete if no prop\n      } else if (origProp.bypass) {\n        // delete bypassed\n        origProp.bypassed = undefined;\n        checkTriggers();\n        return true;\n      } else {\n        return false; // we're unsuccessful deleting the bypassed\n      }\n    } // check if we need to delete the current bypass\n\n\n    if (prop.deleteBypass) {\n      // then this property is just here to indicate we need to delete\n      if (!origProp) {\n        checkTriggers();\n        return true; // property is already not defined\n      } else if (origProp.bypass) {\n        // then replace the bypass property with the original\n        // because the bypassed property was already applied (and therefore parsed), we can just replace it (no reapplying necessary)\n        style[prop.name] = origProp.bypassed;\n        checkTriggers();\n        return true;\n      } else {\n        return false; // we're unsuccessful deleting the bypass\n      }\n    }\n\n    var printMappingErr = function printMappingErr() {\n      warn('Do not assign mappings to elements without corresponding data (i.e. ele `' + ele.id() + '` has no mapping for property `' + prop.name + '` with data field `' + prop.field + '`); try a `[' + prop.field + ']` selector to limit scope to elements with `' + prop.field + '` defined');\n    }; // put the property in the style objects\n\n\n    switch (prop.mapped) {\n      // flatten the property if mapped\n      case types.mapData:\n        {\n          // flatten the field (e.g. data.foo.bar)\n          var fields = prop.field.split('.');\n          var fieldVal = _p.data;\n\n          for (var i = 0; i < fields.length && fieldVal; i++) {\n            var field = fields[i];\n            fieldVal = fieldVal[field];\n          }\n\n          if (fieldVal == null) {\n            printMappingErr();\n            return false;\n          }\n\n          var percent;\n\n          if (!number$1(fieldVal)) {\n            // then don't apply and fall back on the existing style\n            warn('Do not use continuous mappers without specifying numeric data (i.e. `' + prop.field + ': ' + fieldVal + '` for `' + ele.id() + '` is non-numeric)');\n            return false;\n          } else {\n            var fieldWidth = prop.fieldMax - prop.fieldMin;\n\n            if (fieldWidth === 0) {\n              // safety check -- not strictly necessary as no props of zero range should be passed here\n              percent = 0;\n            } else {\n              percent = (fieldVal - prop.fieldMin) / fieldWidth;\n            }\n          } // make sure to bound percent value\n\n\n          if (percent < 0) {\n            percent = 0;\n          } else if (percent > 1) {\n            percent = 1;\n          }\n\n          if (type.color) {\n            var r1 = prop.valueMin[0];\n            var r2 = prop.valueMax[0];\n            var g1 = prop.valueMin[1];\n            var g2 = prop.valueMax[1];\n            var b1 = prop.valueMin[2];\n            var b2 = prop.valueMax[2];\n            var a1 = prop.valueMin[3] == null ? 1 : prop.valueMin[3];\n            var a2 = prop.valueMax[3] == null ? 1 : prop.valueMax[3];\n            var clr = [Math.round(r1 + (r2 - r1) * percent), Math.round(g1 + (g2 - g1) * percent), Math.round(b1 + (b2 - b1) * percent), Math.round(a1 + (a2 - a1) * percent)];\n            flatProp = {\n              // colours are simple, so just create the flat property instead of expensive string parsing\n              bypass: prop.bypass,\n              // we're a bypass if the mapping property is a bypass\n              name: prop.name,\n              value: clr,\n              strValue: 'rgb(' + clr[0] + ', ' + clr[1] + ', ' + clr[2] + ')'\n            };\n          } else if (type.number) {\n            var calcValue = prop.valueMin + (prop.valueMax - prop.valueMin) * percent;\n            flatProp = this.parse(prop.name, calcValue, prop.bypass, flatPropMapping);\n          } else {\n            return false; // can only map to colours and numbers\n          }\n\n          if (!flatProp) {\n            // if we can't flatten the property, then don't apply the property and fall back on the existing style\n            printMappingErr();\n            return false;\n          }\n\n          flatProp.mapping = prop; // keep a reference to the mapping\n\n          prop = flatProp; // the flattened (mapped) property is the one we want\n\n          break;\n        }\n      // direct mapping\n\n      case types.data:\n        {\n          // flatten the field (e.g. data.foo.bar)\n          var _fields = prop.field.split('.');\n\n          var _fieldVal = _p.data;\n\n          for (var _i3 = 0; _i3 < _fields.length && _fieldVal; _i3++) {\n            var _field = _fields[_i3];\n            _fieldVal = _fieldVal[_field];\n          }\n\n          if (_fieldVal != null) {\n            flatProp = this.parse(prop.name, _fieldVal, prop.bypass, flatPropMapping);\n          }\n\n          if (!flatProp) {\n            // if we can't flatten the property, then don't apply and fall back on the existing style\n            printMappingErr();\n            return false;\n          }\n\n          flatProp.mapping = prop; // keep a reference to the mapping\n\n          prop = flatProp; // the flattened (mapped) property is the one we want\n\n          break;\n        }\n\n      case types.fn:\n        {\n          var fn = prop.value;\n          var fnRetVal = prop.fnValue != null ? prop.fnValue : fn(ele); // check for cached value before calling function\n\n          prop.prevFnValue = fnRetVal;\n\n          if (fnRetVal == null) {\n            warn('Custom function mappers may not return null (i.e. `' + prop.name + '` for ele `' + ele.id() + '` is null)');\n            return false;\n          }\n\n          flatProp = this.parse(prop.name, fnRetVal, prop.bypass, flatPropMapping);\n\n          if (!flatProp) {\n            warn('Custom function mappers may not return invalid values for the property type (i.e. `' + prop.name + '` for ele `' + ele.id() + '` is invalid)');\n            return false;\n          }\n\n          flatProp.mapping = copy(prop); // keep a reference to the mapping\n\n          prop = flatProp; // the flattened (mapped) property is the one we want\n\n          break;\n        }\n\n      case undefined:\n        break;\n      // just set the property\n\n      default:\n        return false;\n      // not a valid mapping\n    } // if the property is a bypass property, then link the resultant property to the original one\n\n\n    if (propIsBypass) {\n      if (origPropIsBypass) {\n        // then this bypass overrides the existing one\n        prop.bypassed = origProp.bypassed; // steal bypassed prop from old bypass\n      } else {\n        // then link the orig prop to the new bypass\n        prop.bypassed = origProp;\n      }\n\n      style[prop.name] = prop; // and set\n    } else {\n      // prop is not bypass\n      if (origPropIsBypass) {\n        // then keep the orig prop (since it's a bypass) and link to the new prop\n        origProp.bypassed = prop;\n      } else {\n        // then just replace the old prop with the new one\n        style[prop.name] = prop;\n      }\n    }\n\n    checkTriggers();\n    return true;\n  };\n\n  styfn$8.cleanElements = function (eles, keepBypasses) {\n    for (var i = 0; i < eles.length; i++) {\n      var ele = eles[i];\n      this.clearStyleHints(ele);\n      ele.dirtyCompoundBoundsCache();\n      ele.dirtyBoundingBoxCache();\n\n      if (!keepBypasses) {\n        ele._private.style = {};\n      } else {\n        var style = ele._private.style;\n        var propNames = Object.keys(style);\n\n        for (var j = 0; j < propNames.length; j++) {\n          var propName = propNames[j];\n          var eleProp = style[propName];\n\n          if (eleProp != null) {\n            if (eleProp.bypass) {\n              eleProp.bypassed = null;\n            } else {\n              style[propName] = null;\n            }\n          }\n        }\n      }\n    }\n  }; // updates the visual style for all elements (useful for manual style modification after init)\n\n\n  styfn$8.update = function () {\n    var cy = this._private.cy;\n    var eles = cy.mutableElements();\n    eles.updateStyle();\n  }; // diffProps : { name => { prev, next } }\n\n\n  styfn$8.updateTransitions = function (ele, diffProps) {\n    var self = this;\n    var _p = ele._private;\n    var props = ele.pstyle('transition-property').value;\n    var duration = ele.pstyle('transition-duration').pfValue;\n    var delay = ele.pstyle('transition-delay').pfValue;\n\n    if (props.length > 0 && duration > 0) {\n      var style = {}; // build up the style to animate towards\n\n      var anyPrev = false;\n\n      for (var i = 0; i < props.length; i++) {\n        var prop = props[i];\n        var styProp = ele.pstyle(prop);\n        var diffProp = diffProps[prop];\n\n        if (!diffProp) {\n          continue;\n        }\n\n        var prevProp = diffProp.prev;\n        var fromProp = prevProp;\n        var toProp = diffProp.next != null ? diffProp.next : styProp;\n        var diff = false;\n        var initVal = void 0;\n        var initDt = 0.000001; // delta time % value for initVal (allows animating out of init zero opacity)\n\n        if (!fromProp) {\n          continue;\n        } // consider px values\n\n\n        if (number$1(fromProp.pfValue) && number$1(toProp.pfValue)) {\n          diff = toProp.pfValue - fromProp.pfValue; // nonzero is truthy\n\n          initVal = fromProp.pfValue + initDt * diff; // consider numerical values\n        } else if (number$1(fromProp.value) && number$1(toProp.value)) {\n          diff = toProp.value - fromProp.value; // nonzero is truthy\n\n          initVal = fromProp.value + initDt * diff; // consider colour values\n        } else if (array(fromProp.value) && array(toProp.value)) {\n          diff = fromProp.value[0] !== toProp.value[0] || fromProp.value[1] !== toProp.value[1] || fromProp.value[2] !== toProp.value[2];\n          initVal = fromProp.strValue;\n        } // the previous value is good for an animation only if it's different\n\n\n        if (diff) {\n          style[prop] = toProp.strValue; // to val\n\n          this.applyBypass(ele, prop, initVal); // from val\n\n          anyPrev = true;\n        }\n      } // end if props allow ani\n      // can't transition if there's nothing previous to transition from\n\n\n      if (!anyPrev) {\n        return;\n      }\n\n      _p.transitioning = true;\n      new Promise$1(function (resolve) {\n        if (delay > 0) {\n          ele.delayAnimation(delay).play().promise().then(resolve);\n        } else {\n          resolve();\n        }\n      }).then(function () {\n        return ele.animation({\n          style: style,\n          duration: duration,\n          easing: ele.pstyle('transition-timing-function').value,\n          queue: false\n        }).play().promise();\n      }).then(function () {\n        // if( !isBypass ){\n        self.removeBypasses(ele, props);\n        ele.emitAndNotify('style'); // }\n\n        _p.transitioning = false;\n      });\n    } else if (_p.transitioning) {\n      this.removeBypasses(ele, props);\n      ele.emitAndNotify('style');\n      _p.transitioning = false;\n    }\n  };\n\n  styfn$8.checkTrigger = function (ele, name, fromValue, toValue, getTrigger, onTrigger) {\n    var prop = this.properties[name];\n    var triggerCheck = getTrigger(prop);\n\n    if (triggerCheck != null && triggerCheck(fromValue, toValue)) {\n      onTrigger(prop);\n    }\n  };\n\n  styfn$8.checkZOrderTrigger = function (ele, name, fromValue, toValue) {\n    var _this = this;\n\n    this.checkTrigger(ele, name, fromValue, toValue, function (prop) {\n      return prop.triggersZOrder;\n    }, function () {\n      _this._private.cy.notify('zorder', ele);\n    });\n  };\n\n  styfn$8.checkBoundsTrigger = function (ele, name, fromValue, toValue) {\n    this.checkTrigger(ele, name, fromValue, toValue, function (prop) {\n      return prop.triggersBounds;\n    }, function (prop) {\n      ele.dirtyCompoundBoundsCache();\n      ele.dirtyBoundingBoxCache(); // if the prop change makes the bb of pll bezier edges invalid,\n      // then dirty the pll edge bb cache as well\n\n      if ( // only for beziers -- so performance of other edges isn't affected\n      prop.triggersBoundsOfParallelBeziers && (name === 'curve-style' && (fromValue === 'bezier' || toValue === 'bezier') || name === 'display' && (fromValue === 'none' || toValue === 'none'))) {\n        ele.parallelEdges().forEach(function (pllEdge) {\n          if (pllEdge.isBundledBezier()) {\n            pllEdge.dirtyBoundingBoxCache();\n          }\n        });\n      }\n    });\n  };\n\n  styfn$8.checkTriggers = function (ele, name, fromValue, toValue) {\n    ele.dirtyStyleCache();\n    this.checkZOrderTrigger(ele, name, fromValue, toValue);\n    this.checkBoundsTrigger(ele, name, fromValue, toValue);\n  };\n\n  var styfn$7 = {}; // bypasses are applied to an existing style on an element, and just tacked on temporarily\n  // returns true iff application was successful for at least 1 specified property\n\n  styfn$7.applyBypass = function (eles, name, value, updateTransitions) {\n    var self = this;\n    var props = [];\n    var isBypass = true; // put all the properties (can specify one or many) in an array after parsing them\n\n    if (name === '*' || name === '**') {\n      // apply to all property names\n      if (value !== undefined) {\n        for (var i = 0; i < self.properties.length; i++) {\n          var prop = self.properties[i];\n          var _name = prop.name;\n          var parsedProp = this.parse(_name, value, true);\n\n          if (parsedProp) {\n            props.push(parsedProp);\n          }\n        }\n      }\n    } else if (string(name)) {\n      // then parse the single property\n      var _parsedProp = this.parse(name, value, true);\n\n      if (_parsedProp) {\n        props.push(_parsedProp);\n      }\n    } else if (plainObject(name)) {\n      // then parse each property\n      var specifiedProps = name;\n      updateTransitions = value;\n      var names = Object.keys(specifiedProps);\n\n      for (var _i = 0; _i < names.length; _i++) {\n        var _name2 = names[_i];\n        var _value = specifiedProps[_name2];\n\n        if (_value === undefined) {\n          // try camel case name too\n          _value = specifiedProps[dash2camel(_name2)];\n        }\n\n        if (_value !== undefined) {\n          var _parsedProp2 = this.parse(_name2, _value, true);\n\n          if (_parsedProp2) {\n            props.push(_parsedProp2);\n          }\n        }\n      }\n    } else {\n      // can't do anything without well defined properties\n      return false;\n    } // we've failed if there are no valid properties\n\n\n    if (props.length === 0) {\n      return false;\n    } // now, apply the bypass properties on the elements\n\n\n    var ret = false; // return true if at least one succesful bypass applied\n\n    for (var _i2 = 0; _i2 < eles.length; _i2++) {\n      // for each ele\n      var ele = eles[_i2];\n      var diffProps = {};\n      var diffProp = void 0;\n\n      for (var j = 0; j < props.length; j++) {\n        // for each prop\n        var _prop = props[j];\n\n        if (updateTransitions) {\n          var prevProp = ele.pstyle(_prop.name);\n          diffProp = diffProps[_prop.name] = {\n            prev: prevProp\n          };\n        }\n\n        ret = this.applyParsedProperty(ele, copy(_prop)) || ret;\n\n        if (updateTransitions) {\n          diffProp.next = ele.pstyle(_prop.name);\n        }\n      } // for props\n\n\n      if (ret) {\n        this.updateStyleHints(ele);\n      }\n\n      if (updateTransitions) {\n        this.updateTransitions(ele, diffProps, isBypass);\n      }\n    } // for eles\n\n\n    return ret;\n  }; // only useful in specific cases like animation\n\n\n  styfn$7.overrideBypass = function (eles, name, value) {\n    name = camel2dash(name);\n\n    for (var i = 0; i < eles.length; i++) {\n      var ele = eles[i];\n      var prop = ele._private.style[name];\n      var type = this.properties[name].type;\n      var isColor = type.color;\n      var isMulti = type.mutiple;\n      var oldValue = !prop ? null : prop.pfValue != null ? prop.pfValue : prop.value;\n\n      if (!prop || !prop.bypass) {\n        // need a bypass if one doesn't exist\n        this.applyBypass(ele, name, value);\n      } else {\n        prop.value = value;\n\n        if (prop.pfValue != null) {\n          prop.pfValue = value;\n        }\n\n        if (isColor) {\n          prop.strValue = 'rgb(' + value.join(',') + ')';\n        } else if (isMulti) {\n          prop.strValue = value.join(' ');\n        } else {\n          prop.strValue = '' + value;\n        }\n\n        this.updateStyleHints(ele);\n      }\n\n      this.checkTriggers(ele, name, oldValue, value);\n    }\n  };\n\n  styfn$7.removeAllBypasses = function (eles, updateTransitions) {\n    return this.removeBypasses(eles, this.propertyNames, updateTransitions);\n  };\n\n  styfn$7.removeBypasses = function (eles, props, updateTransitions) {\n    var isBypass = true;\n\n    for (var j = 0; j < eles.length; j++) {\n      var ele = eles[j];\n      var diffProps = {};\n\n      for (var i = 0; i < props.length; i++) {\n        var name = props[i];\n        var prop = this.properties[name];\n        var prevProp = ele.pstyle(prop.name);\n\n        if (!prevProp || !prevProp.bypass) {\n          // if a bypass doesn't exist for the prop, nothing needs to be removed\n          continue;\n        }\n\n        var value = ''; // empty => remove bypass\n\n        var parsedProp = this.parse(name, value, true);\n        var diffProp = diffProps[prop.name] = {\n          prev: prevProp\n        };\n        this.applyParsedProperty(ele, parsedProp);\n        diffProp.next = ele.pstyle(prop.name);\n      } // for props\n\n\n      this.updateStyleHints(ele);\n\n      if (updateTransitions) {\n        this.updateTransitions(ele, diffProps, isBypass);\n      }\n    } // for eles\n\n  };\n\n  var styfn$6 = {}; // gets what an em size corresponds to in pixels relative to a dom element\n\n  styfn$6.getEmSizeInPixels = function () {\n    var px = this.containerCss('font-size');\n\n    if (px != null) {\n      return parseFloat(px);\n    } else {\n      return 1; // for headless\n    }\n  }; // gets css property from the core container\n\n\n  styfn$6.containerCss = function (propName) {\n    var cy = this._private.cy;\n    var domElement = cy.container();\n\n    if (window$1 && domElement && window$1.getComputedStyle) {\n      return window$1.getComputedStyle(domElement).getPropertyValue(propName);\n    }\n  };\n\n  var styfn$5 = {}; // gets the rendered style for an element\n\n  styfn$5.getRenderedStyle = function (ele, prop) {\n    if (prop) {\n      return this.getStylePropertyValue(ele, prop, true);\n    } else {\n      return this.getRawStyle(ele, true);\n    }\n  }; // gets the raw style for an element\n\n\n  styfn$5.getRawStyle = function (ele, isRenderedVal) {\n    var self = this;\n    ele = ele[0]; // insure it's an element\n\n    if (ele) {\n      var rstyle = {};\n\n      for (var i = 0; i < self.properties.length; i++) {\n        var prop = self.properties[i];\n        var val = self.getStylePropertyValue(ele, prop.name, isRenderedVal);\n\n        if (val != null) {\n          rstyle[prop.name] = val;\n          rstyle[dash2camel(prop.name)] = val;\n        }\n      }\n\n      return rstyle;\n    }\n  };\n\n  styfn$5.getIndexedStyle = function (ele, property, subproperty, index) {\n    var pstyle = ele.pstyle(property)[subproperty][index];\n    return pstyle != null ? pstyle : ele.cy().style().getDefaultProperty(property)[subproperty][0];\n  };\n\n  styfn$5.getStylePropertyValue = function (ele, propName, isRenderedVal) {\n    var self = this;\n    ele = ele[0]; // insure it's an element\n\n    if (ele) {\n      var prop = self.properties[propName];\n\n      if (prop.alias) {\n        prop = prop.pointsTo;\n      }\n\n      var type = prop.type;\n      var styleProp = ele.pstyle(prop.name);\n\n      if (styleProp) {\n        var value = styleProp.value,\n            units = styleProp.units,\n            strValue = styleProp.strValue;\n\n        if (isRenderedVal && type.number && value != null && number$1(value)) {\n          var zoom = ele.cy().zoom();\n\n          var getRenderedValue = function getRenderedValue(val) {\n            return val * zoom;\n          };\n\n          var getValueStringWithUnits = function getValueStringWithUnits(val, units) {\n            return getRenderedValue(val) + units;\n          };\n\n          var isArrayValue = array(value);\n          var haveUnits = isArrayValue ? units.every(function (u) {\n            return u != null;\n          }) : units != null;\n\n          if (haveUnits) {\n            if (isArrayValue) {\n              return value.map(function (v, i) {\n                return getValueStringWithUnits(v, units[i]);\n              }).join(' ');\n            } else {\n              return getValueStringWithUnits(value, units);\n            }\n          } else {\n            if (isArrayValue) {\n              return value.map(function (v) {\n                return string(v) ? v : '' + getRenderedValue(v);\n              }).join(' ');\n            } else {\n              return '' + getRenderedValue(value);\n            }\n          }\n        } else if (strValue != null) {\n          return strValue;\n        }\n      }\n\n      return null;\n    }\n  };\n\n  styfn$5.getAnimationStartStyle = function (ele, aniProps) {\n    var rstyle = {};\n\n    for (var i = 0; i < aniProps.length; i++) {\n      var aniProp = aniProps[i];\n      var name = aniProp.name;\n      var styleProp = ele.pstyle(name);\n\n      if (styleProp !== undefined) {\n        // then make a prop of it\n        if (plainObject(styleProp)) {\n          styleProp = this.parse(name, styleProp.strValue);\n        } else {\n          styleProp = this.parse(name, styleProp);\n        }\n      }\n\n      if (styleProp) {\n        rstyle[name] = styleProp;\n      }\n    }\n\n    return rstyle;\n  };\n\n  styfn$5.getPropsList = function (propsObj) {\n    var self = this;\n    var rstyle = [];\n    var style = propsObj;\n    var props = self.properties;\n\n    if (style) {\n      var names = Object.keys(style);\n\n      for (var i = 0; i < names.length; i++) {\n        var name = names[i];\n        var val = style[name];\n        var prop = props[name] || props[camel2dash(name)];\n        var styleProp = this.parse(prop.name, val);\n\n        if (styleProp) {\n          rstyle.push(styleProp);\n        }\n      }\n    }\n\n    return rstyle;\n  };\n\n  styfn$5.getNonDefaultPropertiesHash = function (ele, propNames, seed) {\n    var hash = seed.slice();\n    var name, val, strVal, chVal;\n    var i, j;\n\n    for (i = 0; i < propNames.length; i++) {\n      name = propNames[i];\n      val = ele.pstyle(name, false);\n\n      if (val == null) {\n        continue;\n      } else if (val.pfValue != null) {\n        hash[0] = hashInt(chVal, hash[0]);\n        hash[1] = hashIntAlt(chVal, hash[1]);\n      } else {\n        strVal = val.strValue;\n\n        for (j = 0; j < strVal.length; j++) {\n          chVal = strVal.charCodeAt(j);\n          hash[0] = hashInt(chVal, hash[0]);\n          hash[1] = hashIntAlt(chVal, hash[1]);\n        }\n      }\n    }\n\n    return hash;\n  };\n\n  styfn$5.getPropertiesHash = styfn$5.getNonDefaultPropertiesHash;\n\n  var styfn$4 = {};\n\n  styfn$4.appendFromJson = function (json) {\n    var style = this;\n\n    for (var i = 0; i < json.length; i++) {\n      var context = json[i];\n      var selector = context.selector;\n      var props = context.style || context.css;\n      var names = Object.keys(props);\n      style.selector(selector); // apply selector\n\n      for (var j = 0; j < names.length; j++) {\n        var name = names[j];\n        var value = props[name];\n        style.css(name, value); // apply property\n      }\n    }\n\n    return style;\n  }; // accessible cy.style() function\n\n\n  styfn$4.fromJson = function (json) {\n    var style = this;\n    style.resetToDefault();\n    style.appendFromJson(json);\n    return style;\n  }; // get json from cy.style() api\n\n\n  styfn$4.json = function () {\n    var json = [];\n\n    for (var i = this.defaultLength; i < this.length; i++) {\n      var cxt = this[i];\n      var selector = cxt.selector;\n      var props = cxt.properties;\n      var css = {};\n\n      for (var j = 0; j < props.length; j++) {\n        var prop = props[j];\n        css[prop.name] = prop.strValue;\n      }\n\n      json.push({\n        selector: !selector ? 'core' : selector.toString(),\n        style: css\n      });\n    }\n\n    return json;\n  };\n\n  var styfn$3 = {};\n\n  styfn$3.appendFromString = function (string) {\n    var self = this;\n    var style = this;\n    var remaining = '' + string;\n    var selAndBlockStr;\n    var blockRem;\n    var propAndValStr; // remove comments from the style string\n\n    remaining = remaining.replace(/[/][*](\\s|.)+?[*][/]/g, '');\n\n    function removeSelAndBlockFromRemaining() {\n      // remove the parsed selector and block from the remaining text to parse\n      if (remaining.length > selAndBlockStr.length) {\n        remaining = remaining.substr(selAndBlockStr.length);\n      } else {\n        remaining = '';\n      }\n    }\n\n    function removePropAndValFromRem() {\n      // remove the parsed property and value from the remaining block text to parse\n      if (blockRem.length > propAndValStr.length) {\n        blockRem = blockRem.substr(propAndValStr.length);\n      } else {\n        blockRem = '';\n      }\n    }\n\n    for (;;) {\n      var nothingLeftToParse = remaining.match(/^\\s*$/);\n\n      if (nothingLeftToParse) {\n        break;\n      }\n\n      var selAndBlock = remaining.match(/^\\s*((?:.|\\s)+?)\\s*\\{((?:.|\\s)+?)\\}/);\n\n      if (!selAndBlock) {\n        warn('Halting stylesheet parsing: String stylesheet contains more to parse but no selector and block found in: ' + remaining);\n        break;\n      }\n\n      selAndBlockStr = selAndBlock[0]; // parse the selector\n\n      var selectorStr = selAndBlock[1];\n\n      if (selectorStr !== 'core') {\n        var selector = new Selector(selectorStr);\n\n        if (selector.invalid) {\n          warn('Skipping parsing of block: Invalid selector found in string stylesheet: ' + selectorStr); // skip this selector and block\n\n          removeSelAndBlockFromRemaining();\n          continue;\n        }\n      } // parse the block of properties and values\n\n\n      var blockStr = selAndBlock[2];\n      var invalidBlock = false;\n      blockRem = blockStr;\n      var props = [];\n\n      for (;;) {\n        var _nothingLeftToParse = blockRem.match(/^\\s*$/);\n\n        if (_nothingLeftToParse) {\n          break;\n        }\n\n        var propAndVal = blockRem.match(/^\\s*(.+?)\\s*:\\s*(.+?)(?:\\s*;|\\s*$)/);\n\n        if (!propAndVal) {\n          warn('Skipping parsing of block: Invalid formatting of style property and value definitions found in:' + blockStr);\n          invalidBlock = true;\n          break;\n        }\n\n        propAndValStr = propAndVal[0];\n        var propStr = propAndVal[1];\n        var valStr = propAndVal[2];\n        var prop = self.properties[propStr];\n\n        if (!prop) {\n          warn('Skipping property: Invalid property name in: ' + propAndValStr); // skip this property in the block\n\n          removePropAndValFromRem();\n          continue;\n        }\n\n        var parsedProp = style.parse(propStr, valStr);\n\n        if (!parsedProp) {\n          warn('Skipping property: Invalid property definition in: ' + propAndValStr); // skip this property in the block\n\n          removePropAndValFromRem();\n          continue;\n        }\n\n        props.push({\n          name: propStr,\n          val: valStr\n        });\n        removePropAndValFromRem();\n      }\n\n      if (invalidBlock) {\n        removeSelAndBlockFromRemaining();\n        break;\n      } // put the parsed block in the style\n\n\n      style.selector(selectorStr);\n\n      for (var i = 0; i < props.length; i++) {\n        var _prop = props[i];\n        style.css(_prop.name, _prop.val);\n      }\n\n      removeSelAndBlockFromRemaining();\n    }\n\n    return style;\n  };\n\n  styfn$3.fromString = function (string) {\n    var style = this;\n    style.resetToDefault();\n    style.appendFromString(string);\n    return style;\n  };\n\n  var styfn$2 = {};\n\n  (function () {\n    var number$1 = number;\n    var rgba = rgbaNoBackRefs;\n    var hsla = hslaNoBackRefs;\n    var hex3$1 = hex3;\n    var hex6$1 = hex6;\n\n    var data = function data(prefix) {\n      return '^' + prefix + '\\\\s*\\\\(\\\\s*([\\\\w\\\\.]+)\\\\s*\\\\)$';\n    };\n\n    var mapData = function mapData(prefix) {\n      var mapArg = number$1 + '|\\\\w+|' + rgba + '|' + hsla + '|' + hex3$1 + '|' + hex6$1;\n      return '^' + prefix + '\\\\s*\\\\(([\\\\w\\\\.]+)\\\\s*\\\\,\\\\s*(' + number$1 + ')\\\\s*\\\\,\\\\s*(' + number$1 + ')\\\\s*,\\\\s*(' + mapArg + ')\\\\s*\\\\,\\\\s*(' + mapArg + ')\\\\)$';\n    };\n\n    var urlRegexes = ['^url\\\\s*\\\\(\\\\s*[\\'\"]?(.+?)[\\'\"]?\\\\s*\\\\)$', '^(none)$', '^(.+)$']; // each visual style property has a type and needs to be validated according to it\n\n    styfn$2.types = {\n      time: {\n        number: true,\n        min: 0,\n        units: 's|ms',\n        implicitUnits: 'ms'\n      },\n      percent: {\n        number: true,\n        min: 0,\n        max: 100,\n        units: '%',\n        implicitUnits: '%'\n      },\n      percentages: {\n        number: true,\n        min: 0,\n        max: 100,\n        units: '%',\n        implicitUnits: '%',\n        multiple: true\n      },\n      zeroOneNumber: {\n        number: true,\n        min: 0,\n        max: 1,\n        unitless: true\n      },\n      zeroOneNumbers: {\n        number: true,\n        min: 0,\n        max: 1,\n        unitless: true,\n        multiple: true\n      },\n      nOneOneNumber: {\n        number: true,\n        min: -1,\n        max: 1,\n        unitless: true\n      },\n      nonNegativeInt: {\n        number: true,\n        min: 0,\n        integer: true,\n        unitless: true\n      },\n      position: {\n        enums: ['parent', 'origin']\n      },\n      nodeSize: {\n        number: true,\n        min: 0,\n        enums: ['label']\n      },\n      number: {\n        number: true,\n        unitless: true\n      },\n      numbers: {\n        number: true,\n        unitless: true,\n        multiple: true\n      },\n      positiveNumber: {\n        number: true,\n        unitless: true,\n        min: 0,\n        strictMin: true\n      },\n      size: {\n        number: true,\n        min: 0\n      },\n      bidirectionalSize: {\n        number: true\n      },\n      // allows negative\n      bidirectionalSizeMaybePercent: {\n        number: true,\n        allowPercent: true\n      },\n      // allows negative\n      bidirectionalSizes: {\n        number: true,\n        multiple: true\n      },\n      // allows negative\n      sizeMaybePercent: {\n        number: true,\n        min: 0,\n        allowPercent: true\n      },\n      axisDirection: {\n        enums: ['horizontal', 'leftward', 'rightward', 'vertical', 'upward', 'downward', 'auto']\n      },\n      paddingRelativeTo: {\n        enums: ['width', 'height', 'average', 'min', 'max']\n      },\n      bgWH: {\n        number: true,\n        min: 0,\n        allowPercent: true,\n        enums: ['auto'],\n        multiple: true\n      },\n      bgPos: {\n        number: true,\n        allowPercent: true,\n        multiple: true\n      },\n      bgRelativeTo: {\n        enums: ['inner', 'include-padding'],\n        multiple: true\n      },\n      bgRepeat: {\n        enums: ['repeat', 'repeat-x', 'repeat-y', 'no-repeat'],\n        multiple: true\n      },\n      bgFit: {\n        enums: ['none', 'contain', 'cover'],\n        multiple: true\n      },\n      bgCrossOrigin: {\n        enums: ['anonymous', 'use-credentials', 'null'],\n        multiple: true\n      },\n      bgClip: {\n        enums: ['none', 'node'],\n        multiple: true\n      },\n      bgContainment: {\n        enums: ['inside', 'over'],\n        multiple: true\n      },\n      color: {\n        color: true\n      },\n      colors: {\n        color: true,\n        multiple: true\n      },\n      fill: {\n        enums: ['solid', 'linear-gradient', 'radial-gradient']\n      },\n      bool: {\n        enums: ['yes', 'no']\n      },\n      bools: {\n        enums: ['yes', 'no'],\n        multiple: true\n      },\n      lineStyle: {\n        enums: ['solid', 'dotted', 'dashed']\n      },\n      lineCap: {\n        enums: ['butt', 'round', 'square']\n      },\n      borderStyle: {\n        enums: ['solid', 'dotted', 'dashed', 'double']\n      },\n      curveStyle: {\n        enums: ['bezier', 'unbundled-bezier', 'haystack', 'segments', 'straight', 'straight-triangle', 'taxi']\n      },\n      fontFamily: {\n        regex: '^([\\\\w- \\\\\"]+(?:\\\\s*,\\\\s*[\\\\w- \\\\\"]+)*)$'\n      },\n      fontStyle: {\n        enums: ['italic', 'normal', 'oblique']\n      },\n      fontWeight: {\n        enums: ['normal', 'bold', 'bolder', 'lighter', '100', '200', '300', '400', '500', '600', '800', '900', 100, 200, 300, 400, 500, 600, 700, 800, 900]\n      },\n      textDecoration: {\n        enums: ['none', 'underline', 'overline', 'line-through']\n      },\n      textTransform: {\n        enums: ['none', 'uppercase', 'lowercase']\n      },\n      textWrap: {\n        enums: ['none', 'wrap', 'ellipsis']\n      },\n      textOverflowWrap: {\n        enums: ['whitespace', 'anywhere']\n      },\n      textBackgroundShape: {\n        enums: ['rectangle', 'roundrectangle', 'round-rectangle']\n      },\n      nodeShape: {\n        enums: ['rectangle', 'roundrectangle', 'round-rectangle', 'cutrectangle', 'cut-rectangle', 'bottomroundrectangle', 'bottom-round-rectangle', 'barrel', 'ellipse', 'triangle', 'round-triangle', 'square', 'pentagon', 'round-pentagon', 'hexagon', 'round-hexagon', 'concavehexagon', 'concave-hexagon', 'heptagon', 'round-heptagon', 'octagon', 'round-octagon', 'tag', 'round-tag', 'star', 'diamond', 'round-diamond', 'vee', 'rhomboid', 'polygon']\n      },\n      overlayShape: {\n        enums: ['roundrectangle', 'round-rectangle', 'ellipse']\n      },\n      compoundIncludeLabels: {\n        enums: ['include', 'exclude']\n      },\n      arrowShape: {\n        enums: ['tee', 'triangle', 'triangle-tee', 'circle-triangle', 'triangle-cross', 'triangle-backcurve', 'vee', 'square', 'circle', 'diamond', 'chevron', 'none']\n      },\n      arrowFill: {\n        enums: ['filled', 'hollow']\n      },\n      display: {\n        enums: ['element', 'none']\n      },\n      visibility: {\n        enums: ['hidden', 'visible']\n      },\n      zCompoundDepth: {\n        enums: ['bottom', 'orphan', 'auto', 'top']\n      },\n      zIndexCompare: {\n        enums: ['auto', 'manual']\n      },\n      valign: {\n        enums: ['top', 'center', 'bottom']\n      },\n      halign: {\n        enums: ['left', 'center', 'right']\n      },\n      justification: {\n        enums: ['left', 'center', 'right', 'auto']\n      },\n      text: {\n        string: true\n      },\n      data: {\n        mapping: true,\n        regex: data('data')\n      },\n      layoutData: {\n        mapping: true,\n        regex: data('layoutData')\n      },\n      scratch: {\n        mapping: true,\n        regex: data('scratch')\n      },\n      mapData: {\n        mapping: true,\n        regex: mapData('mapData')\n      },\n      mapLayoutData: {\n        mapping: true,\n        regex: mapData('mapLayoutData')\n      },\n      mapScratch: {\n        mapping: true,\n        regex: mapData('mapScratch')\n      },\n      fn: {\n        mapping: true,\n        fn: true\n      },\n      url: {\n        regexes: urlRegexes,\n        singleRegexMatchValue: true\n      },\n      urls: {\n        regexes: urlRegexes,\n        singleRegexMatchValue: true,\n        multiple: true\n      },\n      propList: {\n        propList: true\n      },\n      angle: {\n        number: true,\n        units: 'deg|rad',\n        implicitUnits: 'rad'\n      },\n      textRotation: {\n        number: true,\n        units: 'deg|rad',\n        implicitUnits: 'rad',\n        enums: ['none', 'autorotate']\n      },\n      polygonPointList: {\n        number: true,\n        multiple: true,\n        evenMultiple: true,\n        min: -1,\n        max: 1,\n        unitless: true\n      },\n      edgeDistances: {\n        enums: ['intersection', 'node-position']\n      },\n      edgeEndpoint: {\n        number: true,\n        multiple: true,\n        units: '%|px|em|deg|rad',\n        implicitUnits: 'px',\n        enums: ['inside-to-node', 'outside-to-node', 'outside-to-node-or-label', 'outside-to-line', 'outside-to-line-or-label'],\n        singleEnum: true,\n        validate: function validate(valArr, unitsArr) {\n          switch (valArr.length) {\n            case 2:\n              // can be % or px only\n              return unitsArr[0] !== 'deg' && unitsArr[0] !== 'rad' && unitsArr[1] !== 'deg' && unitsArr[1] !== 'rad';\n\n            case 1:\n              // can be enum, deg, or rad only\n              return string(valArr[0]) || unitsArr[0] === 'deg' || unitsArr[0] === 'rad';\n\n            default:\n              return false;\n          }\n        }\n      },\n      easing: {\n        regexes: ['^(spring)\\\\s*\\\\(\\\\s*(' + number$1 + ')\\\\s*,\\\\s*(' + number$1 + ')\\\\s*\\\\)$', '^(cubic-bezier)\\\\s*\\\\(\\\\s*(' + number$1 + ')\\\\s*,\\\\s*(' + number$1 + ')\\\\s*,\\\\s*(' + number$1 + ')\\\\s*,\\\\s*(' + number$1 + ')\\\\s*\\\\)$'],\n        enums: ['linear', 'ease', 'ease-in', 'ease-out', 'ease-in-out', 'ease-in-sine', 'ease-out-sine', 'ease-in-out-sine', 'ease-in-quad', 'ease-out-quad', 'ease-in-out-quad', 'ease-in-cubic', 'ease-out-cubic', 'ease-in-out-cubic', 'ease-in-quart', 'ease-out-quart', 'ease-in-out-quart', 'ease-in-quint', 'ease-out-quint', 'ease-in-out-quint', 'ease-in-expo', 'ease-out-expo', 'ease-in-out-expo', 'ease-in-circ', 'ease-out-circ', 'ease-in-out-circ']\n      },\n      gradientDirection: {\n        enums: ['to-bottom', 'to-top', 'to-left', 'to-right', 'to-bottom-right', 'to-bottom-left', 'to-top-right', 'to-top-left', 'to-right-bottom', 'to-left-bottom', 'to-right-top', 'to-left-top' // different order\n        ]\n      },\n      boundsExpansion: {\n        number: true,\n        multiple: true,\n        min: 0,\n        validate: function validate(valArr) {\n          var length = valArr.length;\n          return length === 1 || length === 2 || length === 4;\n        }\n      }\n    };\n    var diff = {\n      zeroNonZero: function zeroNonZero(val1, val2) {\n        if ((val1 == null || val2 == null) && val1 !== val2) {\n          return true; // null cases could represent any value\n        }\n\n        if (val1 == 0 && val2 != 0) {\n          return true;\n        } else if (val1 != 0 && val2 == 0) {\n          return true;\n        } else {\n          return false;\n        }\n      },\n      any: function any(val1, val2) {\n        return val1 != val2;\n      },\n      emptyNonEmpty: function emptyNonEmpty(str1, str2) {\n        var empty1 = emptyString(str1);\n        var empty2 = emptyString(str2);\n        return empty1 && !empty2 || !empty1 && empty2;\n      }\n    }; // define visual style properties\n    //\n    // - n.b. adding a new group of props may require updates to updateStyleHints()\n    // - adding new props to an existing group gets handled automatically\n\n    var t = styfn$2.types;\n    var mainLabel = [{\n      name: 'label',\n      type: t.text,\n      triggersBounds: diff.any,\n      triggersZOrder: diff.emptyNonEmpty\n    }, {\n      name: 'text-rotation',\n      type: t.textRotation,\n      triggersBounds: diff.any\n    }, {\n      name: 'text-margin-x',\n      type: t.bidirectionalSize,\n      triggersBounds: diff.any\n    }, {\n      name: 'text-margin-y',\n      type: t.bidirectionalSize,\n      triggersBounds: diff.any\n    }];\n    var sourceLabel = [{\n      name: 'source-label',\n      type: t.text,\n      triggersBounds: diff.any\n    }, {\n      name: 'source-text-rotation',\n      type: t.textRotation,\n      triggersBounds: diff.any\n    }, {\n      name: 'source-text-margin-x',\n      type: t.bidirectionalSize,\n      triggersBounds: diff.any\n    }, {\n      name: 'source-text-margin-y',\n      type: t.bidirectionalSize,\n      triggersBounds: diff.any\n    }, {\n      name: 'source-text-offset',\n      type: t.size,\n      triggersBounds: diff.any\n    }];\n    var targetLabel = [{\n      name: 'target-label',\n      type: t.text,\n      triggersBounds: diff.any\n    }, {\n      name: 'target-text-rotation',\n      type: t.textRotation,\n      triggersBounds: diff.any\n    }, {\n      name: 'target-text-margin-x',\n      type: t.bidirectionalSize,\n      triggersBounds: diff.any\n    }, {\n      name: 'target-text-margin-y',\n      type: t.bidirectionalSize,\n      triggersBounds: diff.any\n    }, {\n      name: 'target-text-offset',\n      type: t.size,\n      triggersBounds: diff.any\n    }];\n    var labelDimensions = [{\n      name: 'font-family',\n      type: t.fontFamily,\n      triggersBounds: diff.any\n    }, {\n      name: 'font-style',\n      type: t.fontStyle,\n      triggersBounds: diff.any\n    }, {\n      name: 'font-weight',\n      type: t.fontWeight,\n      triggersBounds: diff.any\n    }, {\n      name: 'font-size',\n      type: t.size,\n      triggersBounds: diff.any\n    }, {\n      name: 'text-transform',\n      type: t.textTransform,\n      triggersBounds: diff.any\n    }, {\n      name: 'text-wrap',\n      type: t.textWrap,\n      triggersBounds: diff.any\n    }, {\n      name: 'text-overflow-wrap',\n      type: t.textOverflowWrap,\n      triggersBounds: diff.any\n    }, {\n      name: 'text-max-width',\n      type: t.size,\n      triggersBounds: diff.any\n    }, {\n      name: 'text-outline-width',\n      type: t.size,\n      triggersBounds: diff.any\n    }, {\n      name: 'line-height',\n      type: t.positiveNumber,\n      triggersBounds: diff.any\n    }];\n    var commonLabel = [{\n      name: 'text-valign',\n      type: t.valign,\n      triggersBounds: diff.any\n    }, {\n      name: 'text-halign',\n      type: t.halign,\n      triggersBounds: diff.any\n    }, {\n      name: 'color',\n      type: t.color\n    }, {\n      name: 'text-outline-color',\n      type: t.color\n    }, {\n      name: 'text-outline-opacity',\n      type: t.zeroOneNumber\n    }, {\n      name: 'text-background-color',\n      type: t.color\n    }, {\n      name: 'text-background-opacity',\n      type: t.zeroOneNumber\n    }, {\n      name: 'text-background-padding',\n      type: t.size,\n      triggersBounds: diff.any\n    }, {\n      name: 'text-border-opacity',\n      type: t.zeroOneNumber\n    }, {\n      name: 'text-border-color',\n      type: t.color\n    }, {\n      name: 'text-border-width',\n      type: t.size,\n      triggersBounds: diff.any\n    }, {\n      name: 'text-border-style',\n      type: t.borderStyle,\n      triggersBounds: diff.any\n    }, {\n      name: 'text-background-shape',\n      type: t.textBackgroundShape,\n      triggersBounds: diff.any\n    }, {\n      name: 'text-justification',\n      type: t.justification\n    }];\n    var behavior = [{\n      name: 'events',\n      type: t.bool\n    }, {\n      name: 'text-events',\n      type: t.bool\n    }];\n    var visibility = [{\n      name: 'display',\n      type: t.display,\n      triggersZOrder: diff.any,\n      triggersBounds: diff.any,\n      triggersBoundsOfParallelBeziers: true\n    }, {\n      name: 'visibility',\n      type: t.visibility,\n      triggersZOrder: diff.any\n    }, {\n      name: 'opacity',\n      type: t.zeroOneNumber,\n      triggersZOrder: diff.zeroNonZero\n    }, {\n      name: 'text-opacity',\n      type: t.zeroOneNumber\n    }, {\n      name: 'min-zoomed-font-size',\n      type: t.size\n    }, {\n      name: 'z-compound-depth',\n      type: t.zCompoundDepth,\n      triggersZOrder: diff.any\n    }, {\n      name: 'z-index-compare',\n      type: t.zIndexCompare,\n      triggersZOrder: diff.any\n    }, {\n      name: 'z-index',\n      type: t.nonNegativeInt,\n      triggersZOrder: diff.any\n    }];\n    var overlay = [{\n      name: 'overlay-padding',\n      type: t.size,\n      triggersBounds: diff.any\n    }, {\n      name: 'overlay-color',\n      type: t.color\n    }, {\n      name: 'overlay-opacity',\n      type: t.zeroOneNumber,\n      triggersBounds: diff.zeroNonZero\n    }, {\n      name: 'overlay-shape',\n      type: t.overlayShape,\n      triggersBounds: diff.any\n    }];\n    var underlay = [{\n      name: 'underlay-padding',\n      type: t.size,\n      triggersBounds: diff.any\n    }, {\n      name: 'underlay-color',\n      type: t.color\n    }, {\n      name: 'underlay-opacity',\n      type: t.zeroOneNumber,\n      triggersBounds: diff.zeroNonZero\n    }, {\n      name: 'underlay-shape',\n      type: t.overlayShape,\n      triggersBounds: diff.any\n    }];\n    var transition = [{\n      name: 'transition-property',\n      type: t.propList\n    }, {\n      name: 'transition-duration',\n      type: t.time\n    }, {\n      name: 'transition-delay',\n      type: t.time\n    }, {\n      name: 'transition-timing-function',\n      type: t.easing\n    }];\n\n    var nodeSizeHashOverride = function nodeSizeHashOverride(ele, parsedProp) {\n      if (parsedProp.value === 'label') {\n        return -ele.poolIndex(); // no hash key hits is using label size (hitrate for perf probably low anyway)\n      } else {\n        return parsedProp.pfValue;\n      }\n    };\n\n    var nodeBody = [{\n      name: 'height',\n      type: t.nodeSize,\n      triggersBounds: diff.any,\n      hashOverride: nodeSizeHashOverride\n    }, {\n      name: 'width',\n      type: t.nodeSize,\n      triggersBounds: diff.any,\n      hashOverride: nodeSizeHashOverride\n    }, {\n      name: 'shape',\n      type: t.nodeShape,\n      triggersBounds: diff.any\n    }, {\n      name: 'shape-polygon-points',\n      type: t.polygonPointList,\n      triggersBounds: diff.any\n    }, {\n      name: 'background-color',\n      type: t.color\n    }, {\n      name: 'background-fill',\n      type: t.fill\n    }, {\n      name: 'background-opacity',\n      type: t.zeroOneNumber\n    }, {\n      name: 'background-blacken',\n      type: t.nOneOneNumber\n    }, {\n      name: 'background-gradient-stop-colors',\n      type: t.colors\n    }, {\n      name: 'background-gradient-stop-positions',\n      type: t.percentages\n    }, {\n      name: 'background-gradient-direction',\n      type: t.gradientDirection\n    }, {\n      name: 'padding',\n      type: t.sizeMaybePercent,\n      triggersBounds: diff.any\n    }, {\n      name: 'padding-relative-to',\n      type: t.paddingRelativeTo,\n      triggersBounds: diff.any\n    }, {\n      name: 'bounds-expansion',\n      type: t.boundsExpansion,\n      triggersBounds: diff.any\n    }];\n    var nodeBorder = [{\n      name: 'border-color',\n      type: t.color\n    }, {\n      name: 'border-opacity',\n      type: t.zeroOneNumber\n    }, {\n      name: 'border-width',\n      type: t.size,\n      triggersBounds: diff.any\n    }, {\n      name: 'border-style',\n      type: t.borderStyle\n    }];\n    var backgroundImage = [{\n      name: 'background-image',\n      type: t.urls\n    }, {\n      name: 'background-image-crossorigin',\n      type: t.bgCrossOrigin\n    }, {\n      name: 'background-image-opacity',\n      type: t.zeroOneNumbers\n    }, {\n      name: 'background-image-containment',\n      type: t.bgContainment\n    }, {\n      name: 'background-image-smoothing',\n      type: t.bools\n    }, {\n      name: 'background-position-x',\n      type: t.bgPos\n    }, {\n      name: 'background-position-y',\n      type: t.bgPos\n    }, {\n      name: 'background-width-relative-to',\n      type: t.bgRelativeTo\n    }, {\n      name: 'background-height-relative-to',\n      type: t.bgRelativeTo\n    }, {\n      name: 'background-repeat',\n      type: t.bgRepeat\n    }, {\n      name: 'background-fit',\n      type: t.bgFit\n    }, {\n      name: 'background-clip',\n      type: t.bgClip\n    }, {\n      name: 'background-width',\n      type: t.bgWH\n    }, {\n      name: 'background-height',\n      type: t.bgWH\n    }, {\n      name: 'background-offset-x',\n      type: t.bgPos\n    }, {\n      name: 'background-offset-y',\n      type: t.bgPos\n    }];\n    var compound = [{\n      name: 'position',\n      type: t.position,\n      triggersBounds: diff.any\n    }, {\n      name: 'compound-sizing-wrt-labels',\n      type: t.compoundIncludeLabels,\n      triggersBounds: diff.any\n    }, {\n      name: 'min-width',\n      type: t.size,\n      triggersBounds: diff.any\n    }, {\n      name: 'min-width-bias-left',\n      type: t.sizeMaybePercent,\n      triggersBounds: diff.any\n    }, {\n      name: 'min-width-bias-right',\n      type: t.sizeMaybePercent,\n      triggersBounds: diff.any\n    }, {\n      name: 'min-height',\n      type: t.size,\n      triggersBounds: diff.any\n    }, {\n      name: 'min-height-bias-top',\n      type: t.sizeMaybePercent,\n      triggersBounds: diff.any\n    }, {\n      name: 'min-height-bias-bottom',\n      type: t.sizeMaybePercent,\n      triggersBounds: diff.any\n    }];\n    var edgeLine = [{\n      name: 'line-style',\n      type: t.lineStyle\n    }, {\n      name: 'line-color',\n      type: t.color\n    }, {\n      name: 'line-fill',\n      type: t.fill\n    }, {\n      name: 'line-cap',\n      type: t.lineCap\n    }, {\n      name: 'line-opacity',\n      type: t.zeroOneNumber\n    }, {\n      name: 'line-dash-pattern',\n      type: t.numbers\n    }, {\n      name: 'line-dash-offset',\n      type: t.number\n    }, {\n      name: 'line-gradient-stop-colors',\n      type: t.colors\n    }, {\n      name: 'line-gradient-stop-positions',\n      type: t.percentages\n    }, {\n      name: 'curve-style',\n      type: t.curveStyle,\n      triggersBounds: diff.any,\n      triggersBoundsOfParallelBeziers: true\n    }, {\n      name: 'haystack-radius',\n      type: t.zeroOneNumber,\n      triggersBounds: diff.any\n    }, {\n      name: 'source-endpoint',\n      type: t.edgeEndpoint,\n      triggersBounds: diff.any\n    }, {\n      name: 'target-endpoint',\n      type: t.edgeEndpoint,\n      triggersBounds: diff.any\n    }, {\n      name: 'control-point-step-size',\n      type: t.size,\n      triggersBounds: diff.any\n    }, {\n      name: 'control-point-distances',\n      type: t.bidirectionalSizes,\n      triggersBounds: diff.any\n    }, {\n      name: 'control-point-weights',\n      type: t.numbers,\n      triggersBounds: diff.any\n    }, {\n      name: 'segment-distances',\n      type: t.bidirectionalSizes,\n      triggersBounds: diff.any\n    }, {\n      name: 'segment-weights',\n      type: t.numbers,\n      triggersBounds: diff.any\n    }, {\n      name: 'taxi-turn',\n      type: t.bidirectionalSizeMaybePercent,\n      triggersBounds: diff.any\n    }, {\n      name: 'taxi-turn-min-distance',\n      type: t.size,\n      triggersBounds: diff.any\n    }, {\n      name: 'taxi-direction',\n      type: t.axisDirection,\n      triggersBounds: diff.any\n    }, {\n      name: 'edge-distances',\n      type: t.edgeDistances,\n      triggersBounds: diff.any\n    }, {\n      name: 'arrow-scale',\n      type: t.positiveNumber,\n      triggersBounds: diff.any\n    }, {\n      name: 'loop-direction',\n      type: t.angle,\n      triggersBounds: diff.any\n    }, {\n      name: 'loop-sweep',\n      type: t.angle,\n      triggersBounds: diff.any\n    }, {\n      name: 'source-distance-from-node',\n      type: t.size,\n      triggersBounds: diff.any\n    }, {\n      name: 'target-distance-from-node',\n      type: t.size,\n      triggersBounds: diff.any\n    }];\n    var ghost = [{\n      name: 'ghost',\n      type: t.bool,\n      triggersBounds: diff.any\n    }, {\n      name: 'ghost-offset-x',\n      type: t.bidirectionalSize,\n      triggersBounds: diff.any\n    }, {\n      name: 'ghost-offset-y',\n      type: t.bidirectionalSize,\n      triggersBounds: diff.any\n    }, {\n      name: 'ghost-opacity',\n      type: t.zeroOneNumber\n    }];\n    var core = [{\n      name: 'selection-box-color',\n      type: t.color\n    }, {\n      name: 'selection-box-opacity',\n      type: t.zeroOneNumber\n    }, {\n      name: 'selection-box-border-color',\n      type: t.color\n    }, {\n      name: 'selection-box-border-width',\n      type: t.size\n    }, {\n      name: 'active-bg-color',\n      type: t.color\n    }, {\n      name: 'active-bg-opacity',\n      type: t.zeroOneNumber\n    }, {\n      name: 'active-bg-size',\n      type: t.size\n    }, {\n      name: 'outside-texture-bg-color',\n      type: t.color\n    }, {\n      name: 'outside-texture-bg-opacity',\n      type: t.zeroOneNumber\n    }]; // pie backgrounds for nodes\n\n    var pie = [];\n    styfn$2.pieBackgroundN = 16; // because the pie properties are numbered, give access to a constant N (for renderer use)\n\n    pie.push({\n      name: 'pie-size',\n      type: t.sizeMaybePercent\n    });\n\n    for (var i = 1; i <= styfn$2.pieBackgroundN; i++) {\n      pie.push({\n        name: 'pie-' + i + '-background-color',\n        type: t.color\n      });\n      pie.push({\n        name: 'pie-' + i + '-background-size',\n        type: t.percent\n      });\n      pie.push({\n        name: 'pie-' + i + '-background-opacity',\n        type: t.zeroOneNumber\n      });\n    } // edge arrows\n\n\n    var edgeArrow = [];\n    var arrowPrefixes = styfn$2.arrowPrefixes = ['source', 'mid-source', 'target', 'mid-target'];\n    [{\n      name: 'arrow-shape',\n      type: t.arrowShape,\n      triggersBounds: diff.any\n    }, {\n      name: 'arrow-color',\n      type: t.color\n    }, {\n      name: 'arrow-fill',\n      type: t.arrowFill\n    }].forEach(function (prop) {\n      arrowPrefixes.forEach(function (prefix) {\n        var name = prefix + '-' + prop.name;\n        var type = prop.type,\n            triggersBounds = prop.triggersBounds;\n        edgeArrow.push({\n          name: name,\n          type: type,\n          triggersBounds: triggersBounds\n        });\n      });\n    }, {});\n    var props = styfn$2.properties = [].concat(behavior, transition, visibility, overlay, underlay, ghost, commonLabel, labelDimensions, mainLabel, sourceLabel, targetLabel, nodeBody, nodeBorder, backgroundImage, pie, compound, edgeLine, edgeArrow, core);\n    var propGroups = styfn$2.propertyGroups = {\n      // common to all eles\n      behavior: behavior,\n      transition: transition,\n      visibility: visibility,\n      overlay: overlay,\n      underlay: underlay,\n      ghost: ghost,\n      // labels\n      commonLabel: commonLabel,\n      labelDimensions: labelDimensions,\n      mainLabel: mainLabel,\n      sourceLabel: sourceLabel,\n      targetLabel: targetLabel,\n      // node props\n      nodeBody: nodeBody,\n      nodeBorder: nodeBorder,\n      backgroundImage: backgroundImage,\n      pie: pie,\n      compound: compound,\n      // edge props\n      edgeLine: edgeLine,\n      edgeArrow: edgeArrow,\n      core: core\n    };\n    var propGroupNames = styfn$2.propertyGroupNames = {};\n    var propGroupKeys = styfn$2.propertyGroupKeys = Object.keys(propGroups);\n    propGroupKeys.forEach(function (key) {\n      propGroupNames[key] = propGroups[key].map(function (prop) {\n        return prop.name;\n      });\n      propGroups[key].forEach(function (prop) {\n        return prop.groupKey = key;\n      });\n    }); // define aliases\n\n    var aliases = styfn$2.aliases = [{\n      name: 'content',\n      pointsTo: 'label'\n    }, {\n      name: 'control-point-distance',\n      pointsTo: 'control-point-distances'\n    }, {\n      name: 'control-point-weight',\n      pointsTo: 'control-point-weights'\n    }, {\n      name: 'edge-text-rotation',\n      pointsTo: 'text-rotation'\n    }, {\n      name: 'padding-left',\n      pointsTo: 'padding'\n    }, {\n      name: 'padding-right',\n      pointsTo: 'padding'\n    }, {\n      name: 'padding-top',\n      pointsTo: 'padding'\n    }, {\n      name: 'padding-bottom',\n      pointsTo: 'padding'\n    }]; // list of property names\n\n    styfn$2.propertyNames = props.map(function (p) {\n      return p.name;\n    }); // allow access of properties by name ( e.g. style.properties.height )\n\n    for (var _i = 0; _i < props.length; _i++) {\n      var prop = props[_i];\n      props[prop.name] = prop; // allow lookup by name\n    } // map aliases\n\n\n    for (var _i2 = 0; _i2 < aliases.length; _i2++) {\n      var alias = aliases[_i2];\n      var pointsToProp = props[alias.pointsTo];\n      var aliasProp = {\n        name: alias.name,\n        alias: true,\n        pointsTo: pointsToProp\n      }; // add alias prop for parsing\n\n      props.push(aliasProp);\n      props[alias.name] = aliasProp; // allow lookup by name\n    }\n  })();\n\n  styfn$2.getDefaultProperty = function (name) {\n    return this.getDefaultProperties()[name];\n  };\n\n  styfn$2.getDefaultProperties = function () {\n    var _p = this._private;\n\n    if (_p.defaultProperties != null) {\n      return _p.defaultProperties;\n    }\n\n    var rawProps = extend({\n      // core props\n      'selection-box-color': '#ddd',\n      'selection-box-opacity': 0.65,\n      'selection-box-border-color': '#aaa',\n      'selection-box-border-width': 1,\n      'active-bg-color': 'black',\n      'active-bg-opacity': 0.15,\n      'active-bg-size': 30,\n      'outside-texture-bg-color': '#000',\n      'outside-texture-bg-opacity': 0.125,\n      // common node/edge props\n      'events': 'yes',\n      'text-events': 'no',\n      'text-valign': 'top',\n      'text-halign': 'center',\n      'text-justification': 'auto',\n      'line-height': 1,\n      'color': '#000',\n      'text-outline-color': '#000',\n      'text-outline-width': 0,\n      'text-outline-opacity': 1,\n      'text-opacity': 1,\n      'text-decoration': 'none',\n      'text-transform': 'none',\n      'text-wrap': 'none',\n      'text-overflow-wrap': 'whitespace',\n      'text-max-width': 9999,\n      'text-background-color': '#000',\n      'text-background-opacity': 0,\n      'text-background-shape': 'rectangle',\n      'text-background-padding': 0,\n      'text-border-opacity': 0,\n      'text-border-width': 0,\n      'text-border-style': 'solid',\n      'text-border-color': '#000',\n      'font-family': 'Helvetica Neue, Helvetica, sans-serif',\n      'font-style': 'normal',\n      'font-weight': 'normal',\n      'font-size': 16,\n      'min-zoomed-font-size': 0,\n      'text-rotation': 'none',\n      'source-text-rotation': 'none',\n      'target-text-rotation': 'none',\n      'visibility': 'visible',\n      'display': 'element',\n      'opacity': 1,\n      'z-compound-depth': 'auto',\n      'z-index-compare': 'auto',\n      'z-index': 0,\n      'label': '',\n      'text-margin-x': 0,\n      'text-margin-y': 0,\n      'source-label': '',\n      'source-text-offset': 0,\n      'source-text-margin-x': 0,\n      'source-text-margin-y': 0,\n      'target-label': '',\n      'target-text-offset': 0,\n      'target-text-margin-x': 0,\n      'target-text-margin-y': 0,\n      'overlay-opacity': 0,\n      'overlay-color': '#000',\n      'overlay-padding': 10,\n      'overlay-shape': 'round-rectangle',\n      'underlay-opacity': 0,\n      'underlay-color': '#000',\n      'underlay-padding': 10,\n      'underlay-shape': 'round-rectangle',\n      'transition-property': 'none',\n      'transition-duration': 0,\n      'transition-delay': 0,\n      'transition-timing-function': 'linear',\n      // node props\n      'background-blacken': 0,\n      'background-color': '#999',\n      'background-fill': 'solid',\n      'background-opacity': 1,\n      'background-image': 'none',\n      'background-image-crossorigin': 'anonymous',\n      'background-image-opacity': 1,\n      'background-image-containment': 'inside',\n      'background-image-smoothing': 'yes',\n      'background-position-x': '50%',\n      'background-position-y': '50%',\n      'background-offset-x': 0,\n      'background-offset-y': 0,\n      'background-width-relative-to': 'include-padding',\n      'background-height-relative-to': 'include-padding',\n      'background-repeat': 'no-repeat',\n      'background-fit': 'none',\n      'background-clip': 'node',\n      'background-width': 'auto',\n      'background-height': 'auto',\n      'border-color': '#000',\n      'border-opacity': 1,\n      'border-width': 0,\n      'border-style': 'solid',\n      'height': 30,\n      'width': 30,\n      'shape': 'ellipse',\n      'shape-polygon-points': '-1, -1,   1, -1,   1, 1,   -1, 1',\n      'bounds-expansion': 0,\n      // node gradient\n      'background-gradient-direction': 'to-bottom',\n      'background-gradient-stop-colors': '#999',\n      'background-gradient-stop-positions': '0%',\n      // ghost props\n      'ghost': 'no',\n      'ghost-offset-y': 0,\n      'ghost-offset-x': 0,\n      'ghost-opacity': 0,\n      // compound props\n      'padding': 0,\n      'padding-relative-to': 'width',\n      'position': 'origin',\n      'compound-sizing-wrt-labels': 'include',\n      'min-width': 0,\n      'min-width-bias-left': 0,\n      'min-width-bias-right': 0,\n      'min-height': 0,\n      'min-height-bias-top': 0,\n      'min-height-bias-bottom': 0\n    }, {\n      // node pie bg\n      'pie-size': '100%'\n    }, [{\n      name: 'pie-{{i}}-background-color',\n      value: 'black'\n    }, {\n      name: 'pie-{{i}}-background-size',\n      value: '0%'\n    }, {\n      name: 'pie-{{i}}-background-opacity',\n      value: 1\n    }].reduce(function (css, prop) {\n      for (var i = 1; i <= styfn$2.pieBackgroundN; i++) {\n        var name = prop.name.replace('{{i}}', i);\n        var val = prop.value;\n        css[name] = val;\n      }\n\n      return css;\n    }, {}), {\n      // edge props\n      'line-style': 'solid',\n      'line-color': '#999',\n      'line-fill': 'solid',\n      'line-cap': 'butt',\n      'line-opacity': 1,\n      'line-gradient-stop-colors': '#999',\n      'line-gradient-stop-positions': '0%',\n      'control-point-step-size': 40,\n      'control-point-weights': 0.5,\n      'segment-weights': 0.5,\n      'segment-distances': 20,\n      'taxi-turn': '50%',\n      'taxi-turn-min-distance': 10,\n      'taxi-direction': 'auto',\n      'edge-distances': 'intersection',\n      'curve-style': 'haystack',\n      'haystack-radius': 0,\n      'arrow-scale': 1,\n      'loop-direction': '-45deg',\n      'loop-sweep': '-90deg',\n      'source-distance-from-node': 0,\n      'target-distance-from-node': 0,\n      'source-endpoint': 'outside-to-node',\n      'target-endpoint': 'outside-to-node',\n      'line-dash-pattern': [6, 3],\n      'line-dash-offset': 0\n    }, [{\n      name: 'arrow-shape',\n      value: 'none'\n    }, {\n      name: 'arrow-color',\n      value: '#999'\n    }, {\n      name: 'arrow-fill',\n      value: 'filled'\n    }].reduce(function (css, prop) {\n      styfn$2.arrowPrefixes.forEach(function (prefix) {\n        var name = prefix + '-' + prop.name;\n        var val = prop.value;\n        css[name] = val;\n      });\n      return css;\n    }, {}));\n    var parsedProps = {};\n\n    for (var i = 0; i < this.properties.length; i++) {\n      var prop = this.properties[i];\n\n      if (prop.pointsTo) {\n        continue;\n      }\n\n      var name = prop.name;\n      var val = rawProps[name];\n      var parsedProp = this.parse(name, val);\n      parsedProps[name] = parsedProp;\n    }\n\n    _p.defaultProperties = parsedProps;\n    return _p.defaultProperties;\n  };\n\n  styfn$2.addDefaultStylesheet = function () {\n    this.selector(':parent').css({\n      'shape': 'rectangle',\n      'padding': 10,\n      'background-color': '#eee',\n      'border-color': '#ccc',\n      'border-width': 1\n    }).selector('edge').css({\n      'width': 3\n    }).selector(':loop').css({\n      'curve-style': 'bezier'\n    }).selector('edge:compound').css({\n      'curve-style': 'bezier',\n      'source-endpoint': 'outside-to-line',\n      'target-endpoint': 'outside-to-line'\n    }).selector(':selected').css({\n      'background-color': '#0169D9',\n      'line-color': '#0169D9',\n      'source-arrow-color': '#0169D9',\n      'target-arrow-color': '#0169D9',\n      'mid-source-arrow-color': '#0169D9',\n      'mid-target-arrow-color': '#0169D9'\n    }).selector(':parent:selected').css({\n      'background-color': '#CCE1F9',\n      'border-color': '#aec8e5'\n    }).selector(':active').css({\n      'overlay-color': 'black',\n      'overlay-padding': 10,\n      'overlay-opacity': 0.25\n    });\n    this.defaultLength = this.length;\n  };\n\n  var styfn$1 = {}; // a caching layer for property parsing\n\n  styfn$1.parse = function (name, value, propIsBypass, propIsFlat) {\n    var self = this; // function values can't be cached in all cases, and there isn't much benefit of caching them anyway\n\n    if (fn$6(value)) {\n      return self.parseImplWarn(name, value, propIsBypass, propIsFlat);\n    }\n\n    var flatKey = propIsFlat === 'mapping' || propIsFlat === true || propIsFlat === false || propIsFlat == null ? 'dontcare' : propIsFlat;\n    var bypassKey = propIsBypass ? 't' : 'f';\n    var valueKey = '' + value;\n    var argHash = hashStrings(name, valueKey, bypassKey, flatKey);\n    var propCache = self.propCache = self.propCache || [];\n    var ret;\n\n    if (!(ret = propCache[argHash])) {\n      ret = propCache[argHash] = self.parseImplWarn(name, value, propIsBypass, propIsFlat);\n    } // - bypasses can't be shared b/c the value can be changed by animations or otherwise overridden\n    // - mappings can't be shared b/c mappings are per-element\n\n\n    if (propIsBypass || propIsFlat === 'mapping') {\n      // need a copy since props are mutated later in their lifecycles\n      ret = copy(ret);\n\n      if (ret) {\n        ret.value = copy(ret.value); // because it could be an array, e.g. colour\n      }\n    }\n\n    return ret;\n  };\n\n  styfn$1.parseImplWarn = function (name, value, propIsBypass, propIsFlat) {\n    var prop = this.parseImpl(name, value, propIsBypass, propIsFlat);\n\n    if (!prop && value != null) {\n      warn(\"The style property `\".concat(name, \": \").concat(value, \"` is invalid\"));\n    }\n\n    if (prop && (prop.name === 'width' || prop.name === 'height') && value === 'label') {\n      warn('The style value of `label` is deprecated for `' + prop.name + '`');\n    }\n\n    return prop;\n  }; // parse a property; return null on invalid; return parsed property otherwise\n  // fields :\n  // - name : the name of the property\n  // - value : the parsed, native-typed value of the property\n  // - strValue : a string value that represents the property value in valid css\n  // - bypass : true iff the property is a bypass property\n\n\n  styfn$1.parseImpl = function (name, value, propIsBypass, propIsFlat) {\n    var self = this;\n    name = camel2dash(name); // make sure the property name is in dash form (e.g. 'property-name' not 'propertyName')\n\n    var property = self.properties[name];\n    var passedValue = value;\n    var types = self.types;\n\n    if (!property) {\n      return null;\n    } // return null on property of unknown name\n\n\n    if (value === undefined) {\n      return null;\n    } // can't assign undefined\n    // the property may be an alias\n\n\n    if (property.alias) {\n      property = property.pointsTo;\n      name = property.name;\n    }\n\n    var valueIsString = string(value);\n\n    if (valueIsString) {\n      // trim the value to make parsing easier\n      value = value.trim();\n    }\n\n    var type = property.type;\n\n    if (!type) {\n      return null;\n    } // no type, no luck\n    // check if bypass is null or empty string (i.e. indication to delete bypass property)\n\n\n    if (propIsBypass && (value === '' || value === null)) {\n      return {\n        name: name,\n        value: value,\n        bypass: true,\n        deleteBypass: true\n      };\n    } // check if value is a function used as a mapper\n\n\n    if (fn$6(value)) {\n      return {\n        name: name,\n        value: value,\n        strValue: 'fn',\n        mapped: types.fn,\n        bypass: propIsBypass\n      };\n    } // check if value is mapped\n\n\n    var data, mapData;\n\n    if (!valueIsString || propIsFlat || value.length < 7 || value[1] !== 'a') ; else if (value.length >= 7 && value[0] === 'd' && (data = new RegExp(types.data.regex).exec(value))) {\n      if (propIsBypass) {\n        return false;\n      } // mappers not allowed in bypass\n\n\n      var mapped = types.data;\n      return {\n        name: name,\n        value: data,\n        strValue: '' + value,\n        mapped: mapped,\n        field: data[1],\n        bypass: propIsBypass\n      };\n    } else if (value.length >= 10 && value[0] === 'm' && (mapData = new RegExp(types.mapData.regex).exec(value))) {\n      if (propIsBypass) {\n        return false;\n      } // mappers not allowed in bypass\n\n\n      if (type.multiple) {\n        return false;\n      } // impossible to map to num\n\n\n      var _mapped = types.mapData; // we can map only if the type is a colour or a number\n\n      if (!(type.color || type.number)) {\n        return false;\n      }\n\n      var valueMin = this.parse(name, mapData[4]); // parse to validate\n\n      if (!valueMin || valueMin.mapped) {\n        return false;\n      } // can't be invalid or mapped\n\n\n      var valueMax = this.parse(name, mapData[5]); // parse to validate\n\n      if (!valueMax || valueMax.mapped) {\n        return false;\n      } // can't be invalid or mapped\n      // check if valueMin and valueMax are the same\n\n\n      if (valueMin.pfValue === valueMax.pfValue || valueMin.strValue === valueMax.strValue) {\n        warn('`' + name + ': ' + value + '` is not a valid mapper because the output range is zero; converting to `' + name + ': ' + valueMin.strValue + '`');\n        return this.parse(name, valueMin.strValue); // can't make much of a mapper without a range\n      } else if (type.color) {\n        var c1 = valueMin.value;\n        var c2 = valueMax.value;\n        var same = c1[0] === c2[0] // red\n        && c1[1] === c2[1] // green\n        && c1[2] === c2[2] // blue\n        && ( // optional alpha\n        c1[3] === c2[3] // same alpha outright\n        || (c1[3] == null || c1[3] === 1 // full opacity for colour 1?\n        ) && (c2[3] == null || c2[3] === 1) // full opacity for colour 2?\n        );\n\n        if (same) {\n          return false;\n        } // can't make a mapper without a range\n\n      }\n\n      return {\n        name: name,\n        value: mapData,\n        strValue: '' + value,\n        mapped: _mapped,\n        field: mapData[1],\n        fieldMin: parseFloat(mapData[2]),\n        // min & max are numeric\n        fieldMax: parseFloat(mapData[3]),\n        valueMin: valueMin.value,\n        valueMax: valueMax.value,\n        bypass: propIsBypass\n      };\n    }\n\n    if (type.multiple && propIsFlat !== 'multiple') {\n      var vals;\n\n      if (valueIsString) {\n        vals = value.split(/\\s+/);\n      } else if (array(value)) {\n        vals = value;\n      } else {\n        vals = [value];\n      }\n\n      if (type.evenMultiple && vals.length % 2 !== 0) {\n        return null;\n      }\n\n      var valArr = [];\n      var unitsArr = [];\n      var pfValArr = [];\n      var strVal = '';\n      var hasEnum = false;\n\n      for (var i = 0; i < vals.length; i++) {\n        var p = self.parse(name, vals[i], propIsBypass, 'multiple');\n        hasEnum = hasEnum || string(p.value);\n        valArr.push(p.value);\n        pfValArr.push(p.pfValue != null ? p.pfValue : p.value);\n        unitsArr.push(p.units);\n        strVal += (i > 0 ? ' ' : '') + p.strValue;\n      }\n\n      if (type.validate && !type.validate(valArr, unitsArr)) {\n        return null;\n      }\n\n      if (type.singleEnum && hasEnum) {\n        if (valArr.length === 1 && string(valArr[0])) {\n          return {\n            name: name,\n            value: valArr[0],\n            strValue: valArr[0],\n            bypass: propIsBypass\n          };\n        } else {\n          return null;\n        }\n      }\n\n      return {\n        name: name,\n        value: valArr,\n        pfValue: pfValArr,\n        strValue: strVal,\n        bypass: propIsBypass,\n        units: unitsArr\n      };\n    } // several types also allow enums\n\n\n    var checkEnums = function checkEnums() {\n      for (var _i = 0; _i < type.enums.length; _i++) {\n        var en = type.enums[_i];\n\n        if (en === value) {\n          return {\n            name: name,\n            value: value,\n            strValue: '' + value,\n            bypass: propIsBypass\n          };\n        }\n      }\n\n      return null;\n    }; // check the type and return the appropriate object\n\n\n    if (type.number) {\n      var units;\n      var implicitUnits = 'px'; // not set => px\n\n      if (type.units) {\n        // use specified units if set\n        units = type.units;\n      }\n\n      if (type.implicitUnits) {\n        implicitUnits = type.implicitUnits;\n      }\n\n      if (!type.unitless) {\n        if (valueIsString) {\n          var unitsRegex = 'px|em' + (type.allowPercent ? '|\\\\%' : '');\n\n          if (units) {\n            unitsRegex = units;\n          } // only allow explicit units if so set\n\n\n          var match = value.match('^(' + number + ')(' + unitsRegex + ')?' + '$');\n\n          if (match) {\n            value = match[1];\n            units = match[2] || implicitUnits;\n          }\n        } else if (!units || type.implicitUnits) {\n          units = implicitUnits; // implicitly px if unspecified\n        }\n      }\n\n      value = parseFloat(value); // if not a number and enums not allowed, then the value is invalid\n\n      if (isNaN(value) && type.enums === undefined) {\n        return null;\n      } // check if this number type also accepts special keywords in place of numbers\n      // (i.e. `left`, `auto`, etc)\n\n\n      if (isNaN(value) && type.enums !== undefined) {\n        value = passedValue;\n        return checkEnums();\n      } // check if value must be an integer\n\n\n      if (type.integer && !integer(value)) {\n        return null;\n      } // check value is within range\n\n\n      if (type.min !== undefined && (value < type.min || type.strictMin && value === type.min) || type.max !== undefined && (value > type.max || type.strictMax && value === type.max)) {\n        return null;\n      }\n\n      var ret = {\n        name: name,\n        value: value,\n        strValue: '' + value + (units ? units : ''),\n        units: units,\n        bypass: propIsBypass\n      }; // normalise value in pixels\n\n      if (type.unitless || units !== 'px' && units !== 'em') {\n        ret.pfValue = value;\n      } else {\n        ret.pfValue = units === 'px' || !units ? value : this.getEmSizeInPixels() * value;\n      } // normalise value in ms\n\n\n      if (units === 'ms' || units === 's') {\n        ret.pfValue = units === 'ms' ? value : 1000 * value;\n      } // normalise value in rad\n\n\n      if (units === 'deg' || units === 'rad') {\n        ret.pfValue = units === 'rad' ? value : deg2rad(value);\n      } // normalize value in %\n\n\n      if (units === '%') {\n        ret.pfValue = value / 100;\n      }\n\n      return ret;\n    } else if (type.propList) {\n      var props = [];\n      var propsStr = '' + value;\n\n      if (propsStr === 'none') ; else {\n        // go over each prop\n        var propsSplit = propsStr.split(/\\s*,\\s*|\\s+/);\n\n        for (var _i2 = 0; _i2 < propsSplit.length; _i2++) {\n          var propName = propsSplit[_i2].trim();\n\n          if (self.properties[propName]) {\n            props.push(propName);\n          } else {\n            warn('`' + propName + '` is not a valid property name');\n          }\n        }\n\n        if (props.length === 0) {\n          return null;\n        }\n      }\n\n      return {\n        name: name,\n        value: props,\n        strValue: props.length === 0 ? 'none' : props.join(' '),\n        bypass: propIsBypass\n      };\n    } else if (type.color) {\n      var tuple = color2tuple(value);\n\n      if (!tuple) {\n        return null;\n      }\n\n      return {\n        name: name,\n        value: tuple,\n        pfValue: tuple,\n        strValue: 'rgb(' + tuple[0] + ',' + tuple[1] + ',' + tuple[2] + ')',\n        // n.b. no spaces b/c of multiple support\n        bypass: propIsBypass\n      };\n    } else if (type.regex || type.regexes) {\n      // first check enums\n      if (type.enums) {\n        var enumProp = checkEnums();\n\n        if (enumProp) {\n          return enumProp;\n        }\n      }\n\n      var regexes = type.regexes ? type.regexes : [type.regex];\n\n      for (var _i3 = 0; _i3 < regexes.length; _i3++) {\n        var regex = new RegExp(regexes[_i3]); // make a regex from the type string\n\n        var m = regex.exec(value);\n\n        if (m) {\n          // regex matches\n          return {\n            name: name,\n            value: type.singleRegexMatchValue ? m[1] : m,\n            strValue: '' + value,\n            bypass: propIsBypass\n          };\n        }\n      }\n\n      return null; // didn't match any\n    } else if (type.string) {\n      // just return\n      return {\n        name: name,\n        value: '' + value,\n        strValue: '' + value,\n        bypass: propIsBypass\n      };\n    } else if (type.enums) {\n      // check enums last because it's a combo type in others\n      return checkEnums();\n    } else {\n      return null; // not a type we can handle\n    }\n  };\n\n  var Style = function Style(cy) {\n    if (!(this instanceof Style)) {\n      return new Style(cy);\n    }\n\n    if (!core(cy)) {\n      error('A style must have a core reference');\n      return;\n    }\n\n    this._private = {\n      cy: cy,\n      coreStyle: {}\n    };\n    this.length = 0;\n    this.resetToDefault();\n  };\n\n  var styfn = Style.prototype;\n\n  styfn.instanceString = function () {\n    return 'style';\n  }; // remove all contexts\n\n\n  styfn.clear = function () {\n    var _p = this._private;\n    var cy = _p.cy;\n    var eles = cy.elements();\n\n    for (var i = 0; i < this.length; i++) {\n      this[i] = undefined;\n    }\n\n    this.length = 0;\n    _p.contextStyles = {};\n    _p.propDiffs = {};\n    this.cleanElements(eles, true);\n    eles.forEach(function (ele) {\n      var ele_p = ele[0]._private;\n      ele_p.styleDirty = true;\n      ele_p.appliedInitStyle = false;\n    });\n    return this; // chaining\n  };\n\n  styfn.resetToDefault = function () {\n    this.clear();\n    this.addDefaultStylesheet();\n    return this;\n  }; // builds a style object for the 'core' selector\n\n\n  styfn.core = function (propName) {\n    return this._private.coreStyle[propName] || this.getDefaultProperty(propName);\n  }; // create a new context from the specified selector string and switch to that context\n\n\n  styfn.selector = function (selectorStr) {\n    // 'core' is a special case and does not need a selector\n    var selector = selectorStr === 'core' ? null : new Selector(selectorStr);\n    var i = this.length++; // new context means new index\n\n    this[i] = {\n      selector: selector,\n      properties: [],\n      mappedProperties: [],\n      index: i\n    };\n    return this; // chaining\n  }; // add one or many css rules to the current context\n\n\n  styfn.css = function () {\n    var self = this;\n    var args = arguments;\n\n    if (args.length === 1) {\n      var map = args[0];\n\n      for (var i = 0; i < self.properties.length; i++) {\n        var prop = self.properties[i];\n        var mapVal = map[prop.name];\n\n        if (mapVal === undefined) {\n          mapVal = map[dash2camel(prop.name)];\n        }\n\n        if (mapVal !== undefined) {\n          this.cssRule(prop.name, mapVal);\n        }\n      }\n    } else if (args.length === 2) {\n      this.cssRule(args[0], args[1]);\n    } // do nothing if args are invalid\n\n\n    return this; // chaining\n  };\n\n  styfn.style = styfn.css; // add a single css rule to the current context\n\n  styfn.cssRule = function (name, value) {\n    // name-value pair\n    var property = this.parse(name, value); // add property to current context if valid\n\n    if (property) {\n      var i = this.length - 1;\n      this[i].properties.push(property);\n      this[i].properties[property.name] = property; // allow access by name as well\n\n      if (property.name.match(/pie-(\\d+)-background-size/) && property.value) {\n        this._private.hasPie = true;\n      }\n\n      if (property.mapped) {\n        this[i].mappedProperties.push(property);\n      } // add to core style if necessary\n\n\n      var currentSelectorIsCore = !this[i].selector;\n\n      if (currentSelectorIsCore) {\n        this._private.coreStyle[property.name] = property;\n      }\n    }\n\n    return this; // chaining\n  };\n\n  styfn.append = function (style) {\n    if (stylesheet(style)) {\n      style.appendToStyle(this);\n    } else if (array(style)) {\n      this.appendFromJson(style);\n    } else if (string(style)) {\n      this.appendFromString(style);\n    } // you probably wouldn't want to append a Style, since you'd duplicate the default parts\n\n\n    return this;\n  }; // static function\n\n\n  Style.fromJson = function (cy, json) {\n    var style = new Style(cy);\n    style.fromJson(json);\n    return style;\n  };\n\n  Style.fromString = function (cy, string) {\n    return new Style(cy).fromString(string);\n  };\n\n  [styfn$8, styfn$7, styfn$6, styfn$5, styfn$4, styfn$3, styfn$2, styfn$1].forEach(function (props) {\n    extend(styfn, props);\n  });\n  Style.types = styfn.types;\n  Style.properties = styfn.properties;\n  Style.propertyGroups = styfn.propertyGroups;\n  Style.propertyGroupNames = styfn.propertyGroupNames;\n  Style.propertyGroupKeys = styfn.propertyGroupKeys;\n\n  var corefn$2 = {\n    style: function style(newStyle) {\n      if (newStyle) {\n        var s = this.setStyle(newStyle);\n        s.update();\n      }\n\n      return this._private.style;\n    },\n    setStyle: function setStyle(style) {\n      var _p = this._private;\n\n      if (stylesheet(style)) {\n        _p.style = style.generateStyle(this);\n      } else if (array(style)) {\n        _p.style = Style.fromJson(this, style);\n      } else if (string(style)) {\n        _p.style = Style.fromString(this, style);\n      } else {\n        _p.style = Style(this);\n      }\n\n      return _p.style;\n    },\n    // e.g. cy.data() changed => recalc ele mappers\n    updateStyle: function updateStyle() {\n      this.mutableElements().updateStyle(); // just send to all eles\n    }\n  };\n\n  var defaultSelectionType = 'single';\n  var corefn$1 = {\n    autolock: function autolock(bool) {\n      if (bool !== undefined) {\n        this._private.autolock = bool ? true : false;\n      } else {\n        return this._private.autolock;\n      }\n\n      return this; // chaining\n    },\n    autoungrabify: function autoungrabify(bool) {\n      if (bool !== undefined) {\n        this._private.autoungrabify = bool ? true : false;\n      } else {\n        return this._private.autoungrabify;\n      }\n\n      return this; // chaining\n    },\n    autounselectify: function autounselectify(bool) {\n      if (bool !== undefined) {\n        this._private.autounselectify = bool ? true : false;\n      } else {\n        return this._private.autounselectify;\n      }\n\n      return this; // chaining\n    },\n    selectionType: function selectionType(selType) {\n      var _p = this._private;\n\n      if (_p.selectionType == null) {\n        _p.selectionType = defaultSelectionType;\n      }\n\n      if (selType !== undefined) {\n        if (selType === 'additive' || selType === 'single') {\n          _p.selectionType = selType;\n        }\n      } else {\n        return _p.selectionType;\n      }\n\n      return this;\n    },\n    panningEnabled: function panningEnabled(bool) {\n      if (bool !== undefined) {\n        this._private.panningEnabled = bool ? true : false;\n      } else {\n        return this._private.panningEnabled;\n      }\n\n      return this; // chaining\n    },\n    userPanningEnabled: function userPanningEnabled(bool) {\n      if (bool !== undefined) {\n        this._private.userPanningEnabled = bool ? true : false;\n      } else {\n        return this._private.userPanningEnabled;\n      }\n\n      return this; // chaining\n    },\n    zoomingEnabled: function zoomingEnabled(bool) {\n      if (bool !== undefined) {\n        this._private.zoomingEnabled = bool ? true : false;\n      } else {\n        return this._private.zoomingEnabled;\n      }\n\n      return this; // chaining\n    },\n    userZoomingEnabled: function userZoomingEnabled(bool) {\n      if (bool !== undefined) {\n        this._private.userZoomingEnabled = bool ? true : false;\n      } else {\n        return this._private.userZoomingEnabled;\n      }\n\n      return this; // chaining\n    },\n    boxSelectionEnabled: function boxSelectionEnabled(bool) {\n      if (bool !== undefined) {\n        this._private.boxSelectionEnabled = bool ? true : false;\n      } else {\n        return this._private.boxSelectionEnabled;\n      }\n\n      return this; // chaining\n    },\n    pan: function pan() {\n      var args = arguments;\n      var pan = this._private.pan;\n      var dim, val, dims, x, y;\n\n      switch (args.length) {\n        case 0:\n          // .pan()\n          return pan;\n\n        case 1:\n          if (string(args[0])) {\n            // .pan('x')\n            dim = args[0];\n            return pan[dim];\n          } else if (plainObject(args[0])) {\n            // .pan({ x: 0, y: 100 })\n            if (!this._private.panningEnabled) {\n              return this;\n            }\n\n            dims = args[0];\n            x = dims.x;\n            y = dims.y;\n\n            if (number$1(x)) {\n              pan.x = x;\n            }\n\n            if (number$1(y)) {\n              pan.y = y;\n            }\n\n            this.emit('pan viewport');\n          }\n\n          break;\n\n        case 2:\n          // .pan('x', 100)\n          if (!this._private.panningEnabled) {\n            return this;\n          }\n\n          dim = args[0];\n          val = args[1];\n\n          if ((dim === 'x' || dim === 'y') && number$1(val)) {\n            pan[dim] = val;\n          }\n\n          this.emit('pan viewport');\n          break;\n        // invalid\n      }\n\n      this.notify('viewport');\n      return this; // chaining\n    },\n    panBy: function panBy(arg0, arg1) {\n      var args = arguments;\n      var pan = this._private.pan;\n      var dim, val, dims, x, y;\n\n      if (!this._private.panningEnabled) {\n        return this;\n      }\n\n      switch (args.length) {\n        case 1:\n          if (plainObject(arg0)) {\n            // .panBy({ x: 0, y: 100 })\n            dims = args[0];\n            x = dims.x;\n            y = dims.y;\n\n            if (number$1(x)) {\n              pan.x += x;\n            }\n\n            if (number$1(y)) {\n              pan.y += y;\n            }\n\n            this.emit('pan viewport');\n          }\n\n          break;\n\n        case 2:\n          // .panBy('x', 100)\n          dim = arg0;\n          val = arg1;\n\n          if ((dim === 'x' || dim === 'y') && number$1(val)) {\n            pan[dim] += val;\n          }\n\n          this.emit('pan viewport');\n          break;\n        // invalid\n      }\n\n      this.notify('viewport');\n      return this; // chaining\n    },\n    fit: function fit(elements, padding) {\n      var viewportState = this.getFitViewport(elements, padding);\n\n      if (viewportState) {\n        var _p = this._private;\n        _p.zoom = viewportState.zoom;\n        _p.pan = viewportState.pan;\n        this.emit('pan zoom viewport');\n        this.notify('viewport');\n      }\n\n      return this; // chaining\n    },\n    getFitViewport: function getFitViewport(elements, padding) {\n      if (number$1(elements) && padding === undefined) {\n        // elements is optional\n        padding = elements;\n        elements = undefined;\n      }\n\n      if (!this._private.panningEnabled || !this._private.zoomingEnabled) {\n        return;\n      }\n\n      var bb;\n\n      if (string(elements)) {\n        var sel = elements;\n        elements = this.$(sel);\n      } else if (boundingBox(elements)) {\n        // assume bb\n        var bbe = elements;\n        bb = {\n          x1: bbe.x1,\n          y1: bbe.y1,\n          x2: bbe.x2,\n          y2: bbe.y2\n        };\n        bb.w = bb.x2 - bb.x1;\n        bb.h = bb.y2 - bb.y1;\n      } else if (!elementOrCollection(elements)) {\n        elements = this.mutableElements();\n      }\n\n      if (elementOrCollection(elements) && elements.empty()) {\n        return;\n      } // can't fit to nothing\n\n\n      bb = bb || elements.boundingBox();\n      var w = this.width();\n      var h = this.height();\n      var zoom;\n      padding = number$1(padding) ? padding : 0;\n\n      if (!isNaN(w) && !isNaN(h) && w > 0 && h > 0 && !isNaN(bb.w) && !isNaN(bb.h) && bb.w > 0 && bb.h > 0) {\n        zoom = Math.min((w - 2 * padding) / bb.w, (h - 2 * padding) / bb.h); // crop zoom\n\n        zoom = zoom > this._private.maxZoom ? this._private.maxZoom : zoom;\n        zoom = zoom < this._private.minZoom ? this._private.minZoom : zoom;\n        var pan = {\n          // now pan to middle\n          x: (w - zoom * (bb.x1 + bb.x2)) / 2,\n          y: (h - zoom * (bb.y1 + bb.y2)) / 2\n        };\n        return {\n          zoom: zoom,\n          pan: pan\n        };\n      }\n\n      return;\n    },\n    zoomRange: function zoomRange(min, max) {\n      var _p = this._private;\n\n      if (max == null) {\n        var opts = min;\n        min = opts.min;\n        max = opts.max;\n      }\n\n      if (number$1(min) && number$1(max) && min <= max) {\n        _p.minZoom = min;\n        _p.maxZoom = max;\n      } else if (number$1(min) && max === undefined && min <= _p.maxZoom) {\n        _p.minZoom = min;\n      } else if (number$1(max) && min === undefined && max >= _p.minZoom) {\n        _p.maxZoom = max;\n      }\n\n      return this;\n    },\n    minZoom: function minZoom(zoom) {\n      if (zoom === undefined) {\n        return this._private.minZoom;\n      } else {\n        return this.zoomRange({\n          min: zoom\n        });\n      }\n    },\n    maxZoom: function maxZoom(zoom) {\n      if (zoom === undefined) {\n        return this._private.maxZoom;\n      } else {\n        return this.zoomRange({\n          max: zoom\n        });\n      }\n    },\n    getZoomedViewport: function getZoomedViewport(params) {\n      var _p = this._private;\n      var currentPan = _p.pan;\n      var currentZoom = _p.zoom;\n      var pos; // in rendered px\n\n      var zoom;\n      var bail = false;\n\n      if (!_p.zoomingEnabled) {\n        // zooming disabled\n        bail = true;\n      }\n\n      if (number$1(params)) {\n        // then set the zoom\n        zoom = params;\n      } else if (plainObject(params)) {\n        // then zoom about a point\n        zoom = params.level;\n\n        if (params.position != null) {\n          pos = modelToRenderedPosition(params.position, currentZoom, currentPan);\n        } else if (params.renderedPosition != null) {\n          pos = params.renderedPosition;\n        }\n\n        if (pos != null && !_p.panningEnabled) {\n          // panning disabled\n          bail = true;\n        }\n      } // crop zoom\n\n\n      zoom = zoom > _p.maxZoom ? _p.maxZoom : zoom;\n      zoom = zoom < _p.minZoom ? _p.minZoom : zoom; // can't zoom with invalid params\n\n      if (bail || !number$1(zoom) || zoom === currentZoom || pos != null && (!number$1(pos.x) || !number$1(pos.y))) {\n        return null;\n      }\n\n      if (pos != null) {\n        // set zoom about position\n        var pan1 = currentPan;\n        var zoom1 = currentZoom;\n        var zoom2 = zoom;\n        var pan2 = {\n          x: -zoom2 / zoom1 * (pos.x - pan1.x) + pos.x,\n          y: -zoom2 / zoom1 * (pos.y - pan1.y) + pos.y\n        };\n        return {\n          zoomed: true,\n          panned: true,\n          zoom: zoom2,\n          pan: pan2\n        };\n      } else {\n        // just set the zoom\n        return {\n          zoomed: true,\n          panned: false,\n          zoom: zoom,\n          pan: currentPan\n        };\n      }\n    },\n    zoom: function zoom(params) {\n      if (params === undefined) {\n        // get\n        return this._private.zoom;\n      } else {\n        // set\n        var vp = this.getZoomedViewport(params);\n        var _p = this._private;\n\n        if (vp == null || !vp.zoomed) {\n          return this;\n        }\n\n        _p.zoom = vp.zoom;\n\n        if (vp.panned) {\n          _p.pan.x = vp.pan.x;\n          _p.pan.y = vp.pan.y;\n        }\n\n        this.emit('zoom' + (vp.panned ? ' pan' : '') + ' viewport');\n        this.notify('viewport');\n        return this; // chaining\n      }\n    },\n    viewport: function viewport(opts) {\n      var _p = this._private;\n      var zoomDefd = true;\n      var panDefd = true;\n      var events = []; // to trigger\n\n      var zoomFailed = false;\n      var panFailed = false;\n\n      if (!opts) {\n        return this;\n      }\n\n      if (!number$1(opts.zoom)) {\n        zoomDefd = false;\n      }\n\n      if (!plainObject(opts.pan)) {\n        panDefd = false;\n      }\n\n      if (!zoomDefd && !panDefd) {\n        return this;\n      }\n\n      if (zoomDefd) {\n        var z = opts.zoom;\n\n        if (z < _p.minZoom || z > _p.maxZoom || !_p.zoomingEnabled) {\n          zoomFailed = true;\n        } else {\n          _p.zoom = z;\n          events.push('zoom');\n        }\n      }\n\n      if (panDefd && (!zoomFailed || !opts.cancelOnFailedZoom) && _p.panningEnabled) {\n        var p = opts.pan;\n\n        if (number$1(p.x)) {\n          _p.pan.x = p.x;\n          panFailed = false;\n        }\n\n        if (number$1(p.y)) {\n          _p.pan.y = p.y;\n          panFailed = false;\n        }\n\n        if (!panFailed) {\n          events.push('pan');\n        }\n      }\n\n      if (events.length > 0) {\n        events.push('viewport');\n        this.emit(events.join(' '));\n        this.notify('viewport');\n      }\n\n      return this; // chaining\n    },\n    center: function center(elements) {\n      var pan = this.getCenterPan(elements);\n\n      if (pan) {\n        this._private.pan = pan;\n        this.emit('pan viewport');\n        this.notify('viewport');\n      }\n\n      return this; // chaining\n    },\n    getCenterPan: function getCenterPan(elements, zoom) {\n      if (!this._private.panningEnabled) {\n        return;\n      }\n\n      if (string(elements)) {\n        var selector = elements;\n        elements = this.mutableElements().filter(selector);\n      } else if (!elementOrCollection(elements)) {\n        elements = this.mutableElements();\n      }\n\n      if (elements.length === 0) {\n        return;\n      } // can't centre pan to nothing\n\n\n      var bb = elements.boundingBox();\n      var w = this.width();\n      var h = this.height();\n      zoom = zoom === undefined ? this._private.zoom : zoom;\n      var pan = {\n        // middle\n        x: (w - zoom * (bb.x1 + bb.x2)) / 2,\n        y: (h - zoom * (bb.y1 + bb.y2)) / 2\n      };\n      return pan;\n    },\n    reset: function reset() {\n      if (!this._private.panningEnabled || !this._private.zoomingEnabled) {\n        return this;\n      }\n\n      this.viewport({\n        pan: {\n          x: 0,\n          y: 0\n        },\n        zoom: 1\n      });\n      return this; // chaining\n    },\n    invalidateSize: function invalidateSize() {\n      this._private.sizeCache = null;\n    },\n    size: function size() {\n      var _p = this._private;\n      var container = _p.container;\n      return _p.sizeCache = _p.sizeCache || (container ? function () {\n        var style = window$1.getComputedStyle(container);\n\n        var val = function val(name) {\n          return parseFloat(style.getPropertyValue(name));\n        };\n\n        return {\n          width: container.clientWidth - val('padding-left') - val('padding-right'),\n          height: container.clientHeight - val('padding-top') - val('padding-bottom')\n        };\n      }() : {\n        // fallback if no container (not 0 b/c can be used for dividing etc)\n        width: 1,\n        height: 1\n      });\n    },\n    width: function width() {\n      return this.size().width;\n    },\n    height: function height() {\n      return this.size().height;\n    },\n    extent: function extent() {\n      var pan = this._private.pan;\n      var zoom = this._private.zoom;\n      var rb = this.renderedExtent();\n      var b = {\n        x1: (rb.x1 - pan.x) / zoom,\n        x2: (rb.x2 - pan.x) / zoom,\n        y1: (rb.y1 - pan.y) / zoom,\n        y2: (rb.y2 - pan.y) / zoom\n      };\n      b.w = b.x2 - b.x1;\n      b.h = b.y2 - b.y1;\n      return b;\n    },\n    renderedExtent: function renderedExtent() {\n      var width = this.width();\n      var height = this.height();\n      return {\n        x1: 0,\n        y1: 0,\n        x2: width,\n        y2: height,\n        w: width,\n        h: height\n      };\n    },\n    multiClickDebounceTime: function multiClickDebounceTime(_int) {\n      if (_int) this._private.multiClickDebounceTime = _int;else return this._private.multiClickDebounceTime;\n      return this; // chaining\n    }\n  }; // aliases\n\n  corefn$1.centre = corefn$1.center; // backwards compatibility\n\n  corefn$1.autolockNodes = corefn$1.autolock;\n  corefn$1.autoungrabifyNodes = corefn$1.autoungrabify;\n\n  var fn = {\n    data: define.data({\n      field: 'data',\n      bindingEvent: 'data',\n      allowBinding: true,\n      allowSetting: true,\n      settingEvent: 'data',\n      settingTriggersEvent: true,\n      triggerFnName: 'trigger',\n      allowGetting: true,\n      updateStyle: true\n    }),\n    removeData: define.removeData({\n      field: 'data',\n      event: 'data',\n      triggerFnName: 'trigger',\n      triggerEvent: true,\n      updateStyle: true\n    }),\n    scratch: define.data({\n      field: 'scratch',\n      bindingEvent: 'scratch',\n      allowBinding: true,\n      allowSetting: true,\n      settingEvent: 'scratch',\n      settingTriggersEvent: true,\n      triggerFnName: 'trigger',\n      allowGetting: true,\n      updateStyle: true\n    }),\n    removeScratch: define.removeData({\n      field: 'scratch',\n      event: 'scratch',\n      triggerFnName: 'trigger',\n      triggerEvent: true,\n      updateStyle: true\n    })\n  }; // aliases\n\n  fn.attr = fn.data;\n  fn.removeAttr = fn.removeData;\n\n  var Core = function Core(opts) {\n    var cy = this;\n    opts = extend({}, opts);\n    var container = opts.container; // allow for passing a wrapped jquery object\n    // e.g. cytoscape({ container: $('#cy') })\n\n    if (container && !htmlElement(container) && htmlElement(container[0])) {\n      container = container[0];\n    }\n\n    var reg = container ? container._cyreg : null; // e.g. already registered some info (e.g. readies) via jquery\n\n    reg = reg || {};\n\n    if (reg && reg.cy) {\n      reg.cy.destroy();\n      reg = {}; // old instance => replace reg completely\n    }\n\n    var readies = reg.readies = reg.readies || [];\n\n    if (container) {\n      container._cyreg = reg;\n    } // make sure container assoc'd reg points to this cy\n\n\n    reg.cy = cy;\n    var head = window$1 !== undefined && container !== undefined && !opts.headless;\n    var options = opts;\n    options.layout = extend({\n      name: head ? 'grid' : 'null'\n    }, options.layout);\n    options.renderer = extend({\n      name: head ? 'canvas' : 'null'\n    }, options.renderer);\n\n    var defVal = function defVal(def, val, altVal) {\n      if (val !== undefined) {\n        return val;\n      } else if (altVal !== undefined) {\n        return altVal;\n      } else {\n        return def;\n      }\n    };\n\n    var _p = this._private = {\n      container: container,\n      // html dom ele container\n      ready: false,\n      // whether ready has been triggered\n      options: options,\n      // cached options\n      elements: new Collection(this),\n      // elements in the graph\n      listeners: [],\n      // list of listeners\n      aniEles: new Collection(this),\n      // elements being animated\n      data: options.data || {},\n      // data for the core\n      scratch: {},\n      // scratch object for core\n      layout: null,\n      renderer: null,\n      destroyed: false,\n      // whether destroy was called\n      notificationsEnabled: true,\n      // whether notifications are sent to the renderer\n      minZoom: 1e-50,\n      maxZoom: 1e50,\n      zoomingEnabled: defVal(true, options.zoomingEnabled),\n      userZoomingEnabled: defVal(true, options.userZoomingEnabled),\n      panningEnabled: defVal(true, options.panningEnabled),\n      userPanningEnabled: defVal(true, options.userPanningEnabled),\n      boxSelectionEnabled: defVal(true, options.boxSelectionEnabled),\n      autolock: defVal(false, options.autolock, options.autolockNodes),\n      autoungrabify: defVal(false, options.autoungrabify, options.autoungrabifyNodes),\n      autounselectify: defVal(false, options.autounselectify),\n      styleEnabled: options.styleEnabled === undefined ? head : options.styleEnabled,\n      zoom: number$1(options.zoom) ? options.zoom : 1,\n      pan: {\n        x: plainObject(options.pan) && number$1(options.pan.x) ? options.pan.x : 0,\n        y: plainObject(options.pan) && number$1(options.pan.y) ? options.pan.y : 0\n      },\n      animation: {\n        // object for currently-running animations\n        current: [],\n        queue: []\n      },\n      hasCompoundNodes: false,\n      multiClickDebounceTime: defVal(250, options.multiClickDebounceTime)\n    };\n\n    this.createEmitter(); // set selection type\n\n    this.selectionType(options.selectionType); // init zoom bounds\n\n    this.zoomRange({\n      min: options.minZoom,\n      max: options.maxZoom\n    });\n\n    var loadExtData = function loadExtData(extData, next) {\n      var anyIsPromise = extData.some(promise);\n\n      if (anyIsPromise) {\n        return Promise$1.all(extData).then(next); // load all data asynchronously, then exec rest of init\n      } else {\n        next(extData); // exec synchronously for convenience\n      }\n    }; // start with the default stylesheet so we have something before loading an external stylesheet\n\n\n    if (_p.styleEnabled) {\n      cy.setStyle([]);\n    } // create the renderer\n\n\n    var rendererOptions = extend({}, options, options.renderer); // allow rendering hints in top level options\n\n    cy.initRenderer(rendererOptions);\n\n    var setElesAndLayout = function setElesAndLayout(elements, onload, ondone) {\n      cy.notifications(false); // remove old elements\n\n      var oldEles = cy.mutableElements();\n\n      if (oldEles.length > 0) {\n        oldEles.remove();\n      }\n\n      if (elements != null) {\n        if (plainObject(elements) || array(elements)) {\n          cy.add(elements);\n        }\n      }\n\n      cy.one('layoutready', function (e) {\n        cy.notifications(true);\n        cy.emit(e); // we missed this event by turning notifications off, so pass it on\n\n        cy.one('load', onload);\n        cy.emitAndNotify('load');\n      }).one('layoutstop', function () {\n        cy.one('done', ondone);\n        cy.emit('done');\n      });\n      var layoutOpts = extend({}, cy._private.options.layout);\n      layoutOpts.eles = cy.elements();\n      cy.layout(layoutOpts).run();\n    };\n\n    loadExtData([options.style, options.elements], function (thens) {\n      var initStyle = thens[0];\n      var initEles = thens[1]; // init style\n\n      if (_p.styleEnabled) {\n        cy.style().append(initStyle);\n      } // initial load\n\n\n      setElesAndLayout(initEles, function () {\n        // onready\n        cy.startAnimationLoop();\n        _p.ready = true; // if a ready callback is specified as an option, the bind it\n\n        if (fn$6(options.ready)) {\n          cy.on('ready', options.ready);\n        } // bind all the ready handlers registered before creating this instance\n\n\n        for (var i = 0; i < readies.length; i++) {\n          var fn = readies[i];\n          cy.on('ready', fn);\n        }\n\n        if (reg) {\n          reg.readies = [];\n        } // clear b/c we've bound them all and don't want to keep it around in case a new core uses the same div etc\n\n\n        cy.emit('ready');\n      }, options.done);\n    });\n  };\n\n  var corefn = Core.prototype; // short alias\n\n  extend(corefn, {\n    instanceString: function instanceString() {\n      return 'core';\n    },\n    isReady: function isReady() {\n      return this._private.ready;\n    },\n    destroyed: function destroyed() {\n      return this._private.destroyed;\n    },\n    ready: function ready(fn) {\n      if (this.isReady()) {\n        this.emitter().emit('ready', [], fn); // just calls fn as though triggered via ready event\n      } else {\n        this.on('ready', fn);\n      }\n\n      return this;\n    },\n    destroy: function destroy() {\n      var cy = this;\n      if (cy.destroyed()) return;\n      cy.stopAnimationLoop();\n      cy.destroyRenderer();\n      this.emit('destroy');\n      cy._private.destroyed = true;\n      return cy;\n    },\n    hasElementWithId: function hasElementWithId(id) {\n      return this._private.elements.hasElementWithId(id);\n    },\n    getElementById: function getElementById(id) {\n      return this._private.elements.getElementById(id);\n    },\n    hasCompoundNodes: function hasCompoundNodes() {\n      return this._private.hasCompoundNodes;\n    },\n    headless: function headless() {\n      return this._private.renderer.isHeadless();\n    },\n    styleEnabled: function styleEnabled() {\n      return this._private.styleEnabled;\n    },\n    addToPool: function addToPool(eles) {\n      this._private.elements.merge(eles);\n\n      return this; // chaining\n    },\n    removeFromPool: function removeFromPool(eles) {\n      this._private.elements.unmerge(eles);\n\n      return this;\n    },\n    container: function container() {\n      return this._private.container || null;\n    },\n    mount: function mount(container) {\n      if (container == null) {\n        return;\n      }\n\n      var cy = this;\n      var _p = cy._private;\n      var options = _p.options;\n\n      if (!htmlElement(container) && htmlElement(container[0])) {\n        container = container[0];\n      }\n\n      cy.stopAnimationLoop();\n      cy.destroyRenderer();\n      _p.container = container;\n      _p.styleEnabled = true;\n      cy.invalidateSize();\n      cy.initRenderer(extend({}, options, options.renderer, {\n        // allow custom renderer name to be re-used, otherwise use canvas\n        name: options.renderer.name === 'null' ? 'canvas' : options.renderer.name\n      }));\n      cy.startAnimationLoop();\n      cy.style(options.style);\n      cy.emit('mount');\n      return cy;\n    },\n    unmount: function unmount() {\n      var cy = this;\n      cy.stopAnimationLoop();\n      cy.destroyRenderer();\n      cy.initRenderer({\n        name: 'null'\n      });\n      cy.emit('unmount');\n      return cy;\n    },\n    options: function options() {\n      return copy(this._private.options);\n    },\n    json: function json(obj) {\n      var cy = this;\n      var _p = cy._private;\n      var eles = cy.mutableElements();\n\n      var getFreshRef = function getFreshRef(ele) {\n        return cy.getElementById(ele.id());\n      };\n\n      if (plainObject(obj)) {\n        // set\n        cy.startBatch();\n\n        if (obj.elements) {\n          var idInJson = {};\n\n          var updateEles = function updateEles(jsons, gr) {\n            var toAdd = [];\n            var toMod = [];\n\n            for (var i = 0; i < jsons.length; i++) {\n              var json = jsons[i];\n\n              if (!json.data.id) {\n                warn('cy.json() cannot handle elements without an ID attribute');\n                continue;\n              }\n\n              var id = '' + json.data.id; // id must be string\n\n              var ele = cy.getElementById(id);\n              idInJson[id] = true;\n\n              if (ele.length !== 0) {\n                // existing element should be updated\n                toMod.push({\n                  ele: ele,\n                  json: json\n                });\n              } else {\n                // otherwise should be added\n                if (gr) {\n                  json.group = gr;\n                  toAdd.push(json);\n                } else {\n                  toAdd.push(json);\n                }\n              }\n            }\n\n            cy.add(toAdd);\n\n            for (var _i = 0; _i < toMod.length; _i++) {\n              var _toMod$_i = toMod[_i],\n                  _ele = _toMod$_i.ele,\n                  _json = _toMod$_i.json;\n\n              _ele.json(_json);\n            }\n          };\n\n          if (array(obj.elements)) {\n            // elements: []\n            updateEles(obj.elements);\n          } else {\n            // elements: { nodes: [], edges: [] }\n            var grs = ['nodes', 'edges'];\n\n            for (var i = 0; i < grs.length; i++) {\n              var gr = grs[i];\n              var elements = obj.elements[gr];\n\n              if (array(elements)) {\n                updateEles(elements, gr);\n              }\n            }\n          }\n\n          var parentsToRemove = cy.collection();\n          eles.filter(function (ele) {\n            return !idInJson[ele.id()];\n          }).forEach(function (ele) {\n            if (ele.isParent()) {\n              parentsToRemove.merge(ele);\n            } else {\n              ele.remove();\n            }\n          }); // so that children are not removed w/parent\n\n          parentsToRemove.forEach(function (ele) {\n            return ele.children().move({\n              parent: null\n            });\n          }); // intermediate parents may be moved by prior line, so make sure we remove by fresh refs\n\n          parentsToRemove.forEach(function (ele) {\n            return getFreshRef(ele).remove();\n          });\n        }\n\n        if (obj.style) {\n          cy.style(obj.style);\n        }\n\n        if (obj.zoom != null && obj.zoom !== _p.zoom) {\n          cy.zoom(obj.zoom);\n        }\n\n        if (obj.pan) {\n          if (obj.pan.x !== _p.pan.x || obj.pan.y !== _p.pan.y) {\n            cy.pan(obj.pan);\n          }\n        }\n\n        if (obj.data) {\n          cy.data(obj.data);\n        }\n\n        var fields = ['minZoom', 'maxZoom', 'zoomingEnabled', 'userZoomingEnabled', 'panningEnabled', 'userPanningEnabled', 'boxSelectionEnabled', 'autolock', 'autoungrabify', 'autounselectify', 'multiClickDebounceTime'];\n\n        for (var _i2 = 0; _i2 < fields.length; _i2++) {\n          var f = fields[_i2];\n\n          if (obj[f] != null) {\n            cy[f](obj[f]);\n          }\n        }\n\n        cy.endBatch();\n        return this; // chaining\n      } else {\n        // get\n        var flat = !!obj;\n        var json = {};\n\n        if (flat) {\n          json.elements = this.elements().map(function (ele) {\n            return ele.json();\n          });\n        } else {\n          json.elements = {};\n          eles.forEach(function (ele) {\n            var group = ele.group();\n\n            if (!json.elements[group]) {\n              json.elements[group] = [];\n            }\n\n            json.elements[group].push(ele.json());\n          });\n        }\n\n        if (this._private.styleEnabled) {\n          json.style = cy.style().json();\n        }\n\n        json.data = copy(cy.data());\n        var options = _p.options;\n        json.zoomingEnabled = _p.zoomingEnabled;\n        json.userZoomingEnabled = _p.userZoomingEnabled;\n        json.zoom = _p.zoom;\n        json.minZoom = _p.minZoom;\n        json.maxZoom = _p.maxZoom;\n        json.panningEnabled = _p.panningEnabled;\n        json.userPanningEnabled = _p.userPanningEnabled;\n        json.pan = copy(_p.pan);\n        json.boxSelectionEnabled = _p.boxSelectionEnabled;\n        json.renderer = copy(options.renderer);\n        json.hideEdgesOnViewport = options.hideEdgesOnViewport;\n        json.textureOnViewport = options.textureOnViewport;\n        json.wheelSensitivity = options.wheelSensitivity;\n        json.motionBlur = options.motionBlur;\n        json.multiClickDebounceTime = options.multiClickDebounceTime;\n        return json;\n      }\n    }\n  });\n  corefn.$id = corefn.getElementById;\n  [corefn$9, corefn$8, elesfn, corefn$7, corefn$6, corefn$5, corefn$4, corefn$3, corefn$2, corefn$1, fn].forEach(function (props) {\n    extend(corefn, props);\n  });\n\n  /* eslint-disable no-unused-vars */\n\n  var defaults$7 = {\n    fit: true,\n    // whether to fit the viewport to the graph\n    directed: false,\n    // whether the tree is directed downwards (or edges can point in any direction if false)\n    padding: 30,\n    // padding on fit\n    circle: false,\n    // put depths in concentric circles if true, put depths top down if false\n    grid: false,\n    // whether to create an even grid into which the DAG is placed (circle:false only)\n    spacingFactor: 1.75,\n    // positive spacing factor, larger => more space between nodes (N.B. n/a if causes overlap)\n    boundingBox: undefined,\n    // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n    avoidOverlap: true,\n    // prevents node overlap, may overflow boundingBox if not enough space\n    nodeDimensionsIncludeLabels: false,\n    // Excludes the label when calculating node bounding boxes for the layout algorithm\n    roots: undefined,\n    // the roots of the trees\n    depthSort: undefined,\n    // a sorting function to order nodes at equal depth. e.g. function(a, b){ return a.data('weight') - b.data('weight') }\n    animate: false,\n    // whether to transition the node positions\n    animationDuration: 500,\n    // duration of animation in ms if enabled\n    animationEasing: undefined,\n    // easing of animation if enabled,\n    animateFilter: function animateFilter(node, i) {\n      return true;\n    },\n    // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts\n    ready: undefined,\n    // callback on layoutready\n    stop: undefined,\n    // callback on layoutstop\n    transform: function transform(node, position) {\n      return position;\n    } // transform a given node position. Useful for changing flow direction in discrete layouts\n\n  };\n  var deprecatedOptionDefaults = {\n    maximal: false,\n    // whether to shift nodes down their natural BFS depths in order to avoid upwards edges (DAGS only); setting acyclic to true sets maximal to true also\n    acyclic: false // whether the tree is acyclic and thus a node could be shifted (due to the maximal option) multiple times without causing an infinite loop; setting to true sets maximal to true also; if you are uncertain whether a tree is acyclic, set to false to avoid potential infinite loops\n\n  };\n  /* eslint-enable */\n\n  var getInfo = function getInfo(ele) {\n    return ele.scratch('breadthfirst');\n  };\n\n  var setInfo = function setInfo(ele, obj) {\n    return ele.scratch('breadthfirst', obj);\n  };\n\n  function BreadthFirstLayout(options) {\n    this.options = extend({}, defaults$7, deprecatedOptionDefaults, options);\n  }\n\n  BreadthFirstLayout.prototype.run = function () {\n    var params = this.options;\n    var options = params;\n    var cy = params.cy;\n    var eles = options.eles;\n    var nodes = eles.nodes().filter(function (n) {\n      return !n.isParent();\n    });\n    var graph = eles;\n    var directed = options.directed;\n    var maximal = options.acyclic || options.maximal || options.maximalAdjustments > 0; // maximalAdjustments for compat. w/ old code; also, setting acyclic to true sets maximal to true\n\n    var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {\n      x1: 0,\n      y1: 0,\n      w: cy.width(),\n      h: cy.height()\n    });\n    var roots;\n\n    if (elementOrCollection(options.roots)) {\n      roots = options.roots;\n    } else if (array(options.roots)) {\n      var rootsArray = [];\n\n      for (var i = 0; i < options.roots.length; i++) {\n        var id = options.roots[i];\n        var ele = cy.getElementById(id);\n        rootsArray.push(ele);\n      }\n\n      roots = cy.collection(rootsArray);\n    } else if (string(options.roots)) {\n      roots = cy.$(options.roots);\n    } else {\n      if (directed) {\n        roots = nodes.roots();\n      } else {\n        var components = eles.components();\n        roots = cy.collection();\n\n        var _loop = function _loop(_i) {\n          var comp = components[_i];\n          var maxDegree = comp.maxDegree(false);\n          var compRoots = comp.filter(function (ele) {\n            return ele.degree(false) === maxDegree;\n          });\n          roots = roots.add(compRoots);\n        };\n\n        for (var _i = 0; _i < components.length; _i++) {\n          _loop(_i);\n        }\n      }\n    }\n\n    var depths = [];\n    var foundByBfs = {};\n\n    var addToDepth = function addToDepth(ele, d) {\n      if (depths[d] == null) {\n        depths[d] = [];\n      }\n\n      var i = depths[d].length;\n      depths[d].push(ele);\n      setInfo(ele, {\n        index: i,\n        depth: d\n      });\n    };\n\n    var changeDepth = function changeDepth(ele, newDepth) {\n      var _getInfo = getInfo(ele),\n          depth = _getInfo.depth,\n          index = _getInfo.index;\n\n      depths[depth][index] = null;\n      addToDepth(ele, newDepth);\n    }; // find the depths of the nodes\n\n\n    graph.bfs({\n      roots: roots,\n      directed: options.directed,\n      visit: function visit(node, edge, pNode, i, depth) {\n        var ele = node[0];\n        var id = ele.id();\n        addToDepth(ele, depth);\n        foundByBfs[id] = true;\n      }\n    }); // check for nodes not found by bfs\n\n    var orphanNodes = [];\n\n    for (var _i2 = 0; _i2 < nodes.length; _i2++) {\n      var _ele = nodes[_i2];\n\n      if (foundByBfs[_ele.id()]) {\n        continue;\n      } else {\n        orphanNodes.push(_ele);\n      }\n    } // assign the nodes a depth and index\n\n\n    var assignDepthsAt = function assignDepthsAt(i) {\n      var eles = depths[i];\n\n      for (var j = 0; j < eles.length; j++) {\n        var _ele2 = eles[j];\n\n        if (_ele2 == null) {\n          eles.splice(j, 1);\n          j--;\n          continue;\n        }\n\n        setInfo(_ele2, {\n          depth: i,\n          index: j\n        });\n      }\n    };\n\n    var assignDepths = function assignDepths() {\n      for (var _i3 = 0; _i3 < depths.length; _i3++) {\n        assignDepthsAt(_i3);\n      }\n    };\n\n    var adjustMaximally = function adjustMaximally(ele, shifted) {\n      var eInfo = getInfo(ele);\n      var incomers = ele.incomers().filter(function (el) {\n        return el.isNode() && eles.has(el);\n      });\n      var maxDepth = -1;\n      var id = ele.id();\n\n      for (var k = 0; k < incomers.length; k++) {\n        var incmr = incomers[k];\n        var iInfo = getInfo(incmr);\n        maxDepth = Math.max(maxDepth, iInfo.depth);\n      }\n\n      if (eInfo.depth <= maxDepth) {\n        if (!options.acyclic && shifted[id]) {\n          return null;\n        }\n\n        var newDepth = maxDepth + 1;\n        changeDepth(ele, newDepth);\n        shifted[id] = newDepth;\n        return true;\n      }\n\n      return false;\n    }; // for the directed case, try to make the edges all go down (i.e. depth i => depth i + 1)\n\n\n    if (directed && maximal) {\n      var Q = [];\n      var shifted = {};\n\n      var enqueue = function enqueue(n) {\n        return Q.push(n);\n      };\n\n      var dequeue = function dequeue() {\n        return Q.shift();\n      };\n\n      nodes.forEach(function (n) {\n        return Q.push(n);\n      });\n\n      while (Q.length > 0) {\n        var _ele3 = dequeue();\n\n        var didShift = adjustMaximally(_ele3, shifted);\n\n        if (didShift) {\n          _ele3.outgoers().filter(function (el) {\n            return el.isNode() && eles.has(el);\n          }).forEach(enqueue);\n        } else if (didShift === null) {\n          warn('Detected double maximal shift for node `' + _ele3.id() + '`.  Bailing maximal adjustment due to cycle.  Use `options.maximal: true` only on DAGs.');\n          break; // exit on failure\n        }\n      }\n    }\n\n    assignDepths(); // clear holes\n    // find min distance we need to leave between nodes\n\n    var minDistance = 0;\n\n    if (options.avoidOverlap) {\n      for (var _i4 = 0; _i4 < nodes.length; _i4++) {\n        var n = nodes[_i4];\n        var nbb = n.layoutDimensions(options);\n        var w = nbb.w;\n        var h = nbb.h;\n        minDistance = Math.max(minDistance, w, h);\n      }\n    } // get the weighted percent for an element based on its connectivity to other levels\n\n\n    var cachedWeightedPercent = {};\n\n    var getWeightedPercent = function getWeightedPercent(ele) {\n      if (cachedWeightedPercent[ele.id()]) {\n        return cachedWeightedPercent[ele.id()];\n      }\n\n      var eleDepth = getInfo(ele).depth;\n      var neighbors = ele.neighborhood();\n      var percent = 0;\n      var samples = 0;\n\n      for (var _i5 = 0; _i5 < neighbors.length; _i5++) {\n        var neighbor = neighbors[_i5];\n\n        if (neighbor.isEdge() || neighbor.isParent() || !nodes.has(neighbor)) {\n          continue;\n        }\n\n        var bf = getInfo(neighbor);\n\n        if (bf == null) {\n          continue;\n        }\n\n        var index = bf.index;\n        var depth = bf.depth; // unassigned neighbours shouldn't affect the ordering\n\n        if (index == null || depth == null) {\n          continue;\n        }\n\n        var nDepth = depths[depth].length;\n\n        if (depth < eleDepth) {\n          // only get influenced by elements above\n          percent += index / nDepth;\n          samples++;\n        }\n      }\n\n      samples = Math.max(1, samples);\n      percent = percent / samples;\n\n      if (samples === 0) {\n        // put lone nodes at the start\n        percent = 0;\n      }\n\n      cachedWeightedPercent[ele.id()] = percent;\n      return percent;\n    }; // rearrange the indices in each depth level based on connectivity\n\n\n    var sortFn = function sortFn(a, b) {\n      var apct = getWeightedPercent(a);\n      var bpct = getWeightedPercent(b);\n      var diff = apct - bpct;\n\n      if (diff === 0) {\n        return ascending(a.id(), b.id()); // make sure sort doesn't have don't-care comparisons\n      } else {\n        return diff;\n      }\n    };\n\n    if (options.depthSort !== undefined) {\n      sortFn = options.depthSort;\n    } // sort each level to make connected nodes closer\n\n\n    for (var _i6 = 0; _i6 < depths.length; _i6++) {\n      depths[_i6].sort(sortFn);\n\n      assignDepthsAt(_i6);\n    } // assign orphan nodes to a new top-level depth\n\n\n    var orphanDepth = [];\n\n    for (var _i7 = 0; _i7 < orphanNodes.length; _i7++) {\n      orphanDepth.push(orphanNodes[_i7]);\n    }\n\n    depths.unshift(orphanDepth);\n    assignDepths();\n    var biggestDepthSize = 0;\n\n    for (var _i8 = 0; _i8 < depths.length; _i8++) {\n      biggestDepthSize = Math.max(depths[_i8].length, biggestDepthSize);\n    }\n\n    var center = {\n      x: bb.x1 + bb.w / 2,\n      y: bb.x1 + bb.h / 2\n    };\n    var maxDepthSize = depths.reduce(function (max, eles) {\n      return Math.max(max, eles.length);\n    }, 0);\n\n    var getPosition = function getPosition(ele) {\n      var _getInfo2 = getInfo(ele),\n          depth = _getInfo2.depth,\n          index = _getInfo2.index;\n\n      var depthSize = depths[depth].length;\n      var distanceX = Math.max(bb.w / ((options.grid ? maxDepthSize : depthSize) + 1), minDistance);\n      var distanceY = Math.max(bb.h / (depths.length + 1), minDistance);\n      var radiusStepSize = Math.min(bb.w / 2 / depths.length, bb.h / 2 / depths.length);\n      radiusStepSize = Math.max(radiusStepSize, minDistance);\n\n      if (!options.circle) {\n        var epos = {\n          x: center.x + (index + 1 - (depthSize + 1) / 2) * distanceX,\n          y: (depth + 1) * distanceY\n        };\n        return epos;\n      } else {\n        var radius = radiusStepSize * depth + radiusStepSize - (depths.length > 0 && depths[0].length <= 3 ? radiusStepSize / 2 : 0);\n        var theta = 2 * Math.PI / depths[depth].length * index;\n\n        if (depth === 0 && depths[0].length === 1) {\n          radius = 1;\n        }\n\n        return {\n          x: center.x + radius * Math.cos(theta),\n          y: center.y + radius * Math.sin(theta)\n        };\n      }\n    };\n\n    eles.nodes().layoutPositions(this, options, getPosition);\n    return this; // chaining\n  };\n\n  var defaults$6 = {\n    fit: true,\n    // whether to fit the viewport to the graph\n    padding: 30,\n    // the padding on fit\n    boundingBox: undefined,\n    // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n    avoidOverlap: true,\n    // prevents node overlap, may overflow boundingBox and radius if not enough space\n    nodeDimensionsIncludeLabels: false,\n    // Excludes the label when calculating node bounding boxes for the layout algorithm\n    spacingFactor: undefined,\n    // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up\n    radius: undefined,\n    // the radius of the circle\n    startAngle: 3 / 2 * Math.PI,\n    // where nodes start in radians\n    sweep: undefined,\n    // how many radians should be between the first and last node (defaults to full circle)\n    clockwise: true,\n    // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)\n    sort: undefined,\n    // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }\n    animate: false,\n    // whether to transition the node positions\n    animationDuration: 500,\n    // duration of animation in ms if enabled\n    animationEasing: undefined,\n    // easing of animation if enabled\n    animateFilter: function animateFilter(node, i) {\n      return true;\n    },\n    // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts\n    ready: undefined,\n    // callback on layoutready\n    stop: undefined,\n    // callback on layoutstop\n    transform: function transform(node, position) {\n      return position;\n    } // transform a given node position. Useful for changing flow direction in discrete layouts \n\n  };\n\n  function CircleLayout(options) {\n    this.options = extend({}, defaults$6, options);\n  }\n\n  CircleLayout.prototype.run = function () {\n    var params = this.options;\n    var options = params;\n    var cy = params.cy;\n    var eles = options.eles;\n    var clockwise = options.counterclockwise !== undefined ? !options.counterclockwise : options.clockwise;\n    var nodes = eles.nodes().not(':parent');\n\n    if (options.sort) {\n      nodes = nodes.sort(options.sort);\n    }\n\n    var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {\n      x1: 0,\n      y1: 0,\n      w: cy.width(),\n      h: cy.height()\n    });\n    var center = {\n      x: bb.x1 + bb.w / 2,\n      y: bb.y1 + bb.h / 2\n    };\n    var sweep = options.sweep === undefined ? 2 * Math.PI - 2 * Math.PI / nodes.length : options.sweep;\n    var dTheta = sweep / Math.max(1, nodes.length - 1);\n    var r;\n    var minDistance = 0;\n\n    for (var i = 0; i < nodes.length; i++) {\n      var n = nodes[i];\n      var nbb = n.layoutDimensions(options);\n      var w = nbb.w;\n      var h = nbb.h;\n      minDistance = Math.max(minDistance, w, h);\n    }\n\n    if (number$1(options.radius)) {\n      r = options.radius;\n    } else if (nodes.length <= 1) {\n      r = 0;\n    } else {\n      r = Math.min(bb.h, bb.w) / 2 - minDistance;\n    } // calculate the radius\n\n\n    if (nodes.length > 1 && options.avoidOverlap) {\n      // but only if more than one node (can't overlap)\n      minDistance *= 1.75; // just to have some nice spacing\n\n      var dcos = Math.cos(dTheta) - Math.cos(0);\n      var dsin = Math.sin(dTheta) - Math.sin(0);\n      var rMin = Math.sqrt(minDistance * minDistance / (dcos * dcos + dsin * dsin)); // s.t. no nodes overlapping\n\n      r = Math.max(rMin, r);\n    }\n\n    var getPos = function getPos(ele, i) {\n      var theta = options.startAngle + i * dTheta * (clockwise ? 1 : -1);\n      var rx = r * Math.cos(theta);\n      var ry = r * Math.sin(theta);\n      var pos = {\n        x: center.x + rx,\n        y: center.y + ry\n      };\n      return pos;\n    };\n\n    eles.nodes().layoutPositions(this, options, getPos);\n    return this; // chaining\n  };\n\n  var defaults$5 = {\n    fit: true,\n    // whether to fit the viewport to the graph\n    padding: 30,\n    // the padding on fit\n    startAngle: 3 / 2 * Math.PI,\n    // where nodes start in radians\n    sweep: undefined,\n    // how many radians should be between the first and last node (defaults to full circle)\n    clockwise: true,\n    // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)\n    equidistant: false,\n    // whether levels have an equal radial distance betwen them, may cause bounding box overflow\n    minNodeSpacing: 10,\n    // min spacing between outside of nodes (used for radius adjustment)\n    boundingBox: undefined,\n    // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n    avoidOverlap: true,\n    // prevents node overlap, may overflow boundingBox if not enough space\n    nodeDimensionsIncludeLabels: false,\n    // Excludes the label when calculating node bounding boxes for the layout algorithm\n    height: undefined,\n    // height of layout area (overrides container height)\n    width: undefined,\n    // width of layout area (overrides container width)\n    spacingFactor: undefined,\n    // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up\n    concentric: function concentric(node) {\n      // returns numeric value for each node, placing higher nodes in levels towards the centre\n      return node.degree();\n    },\n    levelWidth: function levelWidth(nodes) {\n      // the variation of concentric values in each level\n      return nodes.maxDegree() / 4;\n    },\n    animate: false,\n    // whether to transition the node positions\n    animationDuration: 500,\n    // duration of animation in ms if enabled\n    animationEasing: undefined,\n    // easing of animation if enabled\n    animateFilter: function animateFilter(node, i) {\n      return true;\n    },\n    // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts\n    ready: undefined,\n    // callback on layoutready\n    stop: undefined,\n    // callback on layoutstop\n    transform: function transform(node, position) {\n      return position;\n    } // transform a given node position. Useful for changing flow direction in discrete layouts\n\n  };\n\n  function ConcentricLayout(options) {\n    this.options = extend({}, defaults$5, options);\n  }\n\n  ConcentricLayout.prototype.run = function () {\n    var params = this.options;\n    var options = params;\n    var clockwise = options.counterclockwise !== undefined ? !options.counterclockwise : options.clockwise;\n    var cy = params.cy;\n    var eles = options.eles;\n    var nodes = eles.nodes().not(':parent');\n    var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {\n      x1: 0,\n      y1: 0,\n      w: cy.width(),\n      h: cy.height()\n    });\n    var center = {\n      x: bb.x1 + bb.w / 2,\n      y: bb.y1 + bb.h / 2\n    };\n    var nodeValues = []; // { node, value }\n\n    var maxNodeSize = 0;\n\n    for (var i = 0; i < nodes.length; i++) {\n      var node = nodes[i];\n      var value = void 0; // calculate the node value\n\n      value = options.concentric(node);\n      nodeValues.push({\n        value: value,\n        node: node\n      }); // for style mapping\n\n      node._private.scratch.concentric = value;\n    } // in case we used the `concentric` in style\n\n\n    nodes.updateStyle(); // calculate max size now based on potentially updated mappers\n\n    for (var _i = 0; _i < nodes.length; _i++) {\n      var _node = nodes[_i];\n\n      var nbb = _node.layoutDimensions(options);\n\n      maxNodeSize = Math.max(maxNodeSize, nbb.w, nbb.h);\n    } // sort node values in descreasing order\n\n\n    nodeValues.sort(function (a, b) {\n      return b.value - a.value;\n    });\n    var levelWidth = options.levelWidth(nodes); // put the values into levels\n\n    var levels = [[]];\n    var currentLevel = levels[0];\n\n    for (var _i2 = 0; _i2 < nodeValues.length; _i2++) {\n      var val = nodeValues[_i2];\n\n      if (currentLevel.length > 0) {\n        var diff = Math.abs(currentLevel[0].value - val.value);\n\n        if (diff >= levelWidth) {\n          currentLevel = [];\n          levels.push(currentLevel);\n        }\n      }\n\n      currentLevel.push(val);\n    } // create positions from levels\n\n\n    var minDist = maxNodeSize + options.minNodeSpacing; // min dist between nodes\n\n    if (!options.avoidOverlap) {\n      // then strictly constrain to bb\n      var firstLvlHasMulti = levels.length > 0 && levels[0].length > 1;\n      var maxR = Math.min(bb.w, bb.h) / 2 - minDist;\n      var rStep = maxR / (levels.length + firstLvlHasMulti ? 1 : 0);\n      minDist = Math.min(minDist, rStep);\n    } // find the metrics for each level\n\n\n    var r = 0;\n\n    for (var _i3 = 0; _i3 < levels.length; _i3++) {\n      var level = levels[_i3];\n      var sweep = options.sweep === undefined ? 2 * Math.PI - 2 * Math.PI / level.length : options.sweep;\n      var dTheta = level.dTheta = sweep / Math.max(1, level.length - 1); // calculate the radius\n\n      if (level.length > 1 && options.avoidOverlap) {\n        // but only if more than one node (can't overlap)\n        var dcos = Math.cos(dTheta) - Math.cos(0);\n        var dsin = Math.sin(dTheta) - Math.sin(0);\n        var rMin = Math.sqrt(minDist * minDist / (dcos * dcos + dsin * dsin)); // s.t. no nodes overlapping\n\n        r = Math.max(rMin, r);\n      }\n\n      level.r = r;\n      r += minDist;\n    }\n\n    if (options.equidistant) {\n      var rDeltaMax = 0;\n      var _r = 0;\n\n      for (var _i4 = 0; _i4 < levels.length; _i4++) {\n        var _level = levels[_i4];\n        var rDelta = _level.r - _r;\n        rDeltaMax = Math.max(rDeltaMax, rDelta);\n      }\n\n      _r = 0;\n\n      for (var _i5 = 0; _i5 < levels.length; _i5++) {\n        var _level2 = levels[_i5];\n\n        if (_i5 === 0) {\n          _r = _level2.r;\n        }\n\n        _level2.r = _r;\n        _r += rDeltaMax;\n      }\n    } // calculate the node positions\n\n\n    var pos = {}; // id => position\n\n    for (var _i6 = 0; _i6 < levels.length; _i6++) {\n      var _level3 = levels[_i6];\n      var _dTheta = _level3.dTheta;\n      var _r2 = _level3.r;\n\n      for (var j = 0; j < _level3.length; j++) {\n        var _val = _level3[j];\n        var theta = options.startAngle + (clockwise ? 1 : -1) * _dTheta * j;\n        var p = {\n          x: center.x + _r2 * Math.cos(theta),\n          y: center.y + _r2 * Math.sin(theta)\n        };\n        pos[_val.node.id()] = p;\n      }\n    } // position the nodes\n\n\n    eles.nodes().layoutPositions(this, options, function (ele) {\n      var id = ele.id();\n      return pos[id];\n    });\n    return this; // chaining\n  };\n\n  /*\n  The CoSE layout was written by Gerardo Huck.\n  https://www.linkedin.com/in/gerardohuck/\n\n  Based on the following article:\n  http://dl.acm.org/citation.cfm?id=1498047\n\n  Modifications tracked on Github.\n  */\n  var DEBUG;\n  /**\n   * @brief :  default layout options\n   */\n\n  var defaults$4 = {\n    // Called on `layoutready`\n    ready: function ready() {},\n    // Called on `layoutstop`\n    stop: function stop() {},\n    // Whether to animate while running the layout\n    // true : Animate continuously as the layout is running\n    // false : Just show the end result\n    // 'end' : Animate with the end result, from the initial positions to the end positions\n    animate: true,\n    // Easing of the animation for animate:'end'\n    animationEasing: undefined,\n    // The duration of the animation for animate:'end'\n    animationDuration: undefined,\n    // A function that determines whether the node should be animated\n    // All nodes animated by default on animate enabled\n    // Non-animated nodes are positioned immediately when the layout starts\n    animateFilter: function animateFilter(node, i) {\n      return true;\n    },\n    // The layout animates only after this many milliseconds for animate:true\n    // (prevents flashing on fast runs)\n    animationThreshold: 250,\n    // Number of iterations between consecutive screen positions update\n    refresh: 20,\n    // Whether to fit the network view after when done\n    fit: true,\n    // Padding on fit\n    padding: 30,\n    // Constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n    boundingBox: undefined,\n    // Excludes the label when calculating node bounding boxes for the layout algorithm\n    nodeDimensionsIncludeLabels: false,\n    // Randomize the initial positions of the nodes (true) or use existing positions (false)\n    randomize: false,\n    // Extra spacing between components in non-compound graphs\n    componentSpacing: 40,\n    // Node repulsion (non overlapping) multiplier\n    nodeRepulsion: function nodeRepulsion(node) {\n      return 2048;\n    },\n    // Node repulsion (overlapping) multiplier\n    nodeOverlap: 4,\n    // Ideal edge (non nested) length\n    idealEdgeLength: function idealEdgeLength(edge) {\n      return 32;\n    },\n    // Divisor to compute edge forces\n    edgeElasticity: function edgeElasticity(edge) {\n      return 32;\n    },\n    // Nesting factor (multiplier) to compute ideal edge length for nested edges\n    nestingFactor: 1.2,\n    // Gravity force (constant)\n    gravity: 1,\n    // Maximum number of iterations to perform\n    numIter: 1000,\n    // Initial temperature (maximum node displacement)\n    initialTemp: 1000,\n    // Cooling factor (how the temperature is reduced between consecutive iterations\n    coolingFactor: 0.99,\n    // Lower temperature threshold (below this point the layout will end)\n    minTemp: 1.0\n  };\n  /**\n   * @brief       : constructor\n   * @arg options : object containing layout options\n   */\n\n  function CoseLayout(options) {\n    this.options = extend({}, defaults$4, options);\n    this.options.layout = this;\n  }\n  /**\n   * @brief : runs the layout\n   */\n\n\n  CoseLayout.prototype.run = function () {\n    var options = this.options;\n    var cy = options.cy;\n    var layout = this;\n    layout.stopped = false;\n\n    if (options.animate === true || options.animate === false) {\n      layout.emit({\n        type: 'layoutstart',\n        layout: layout\n      });\n    } // Set DEBUG - Global variable\n\n\n    if (true === options.debug) {\n      DEBUG = true;\n    } else {\n      DEBUG = false;\n    } // Initialize layout info\n\n\n    var layoutInfo = createLayoutInfo(cy, layout, options); // Show LayoutInfo contents if debugging\n\n    if (DEBUG) {\n      printLayoutInfo(layoutInfo);\n    } // If required, randomize node positions\n\n\n    if (options.randomize) {\n      randomizePositions(layoutInfo);\n    }\n\n    var startTime = performanceNow();\n\n    var refresh = function refresh() {\n      refreshPositions(layoutInfo, cy, options); // Fit the graph if necessary\n\n      if (true === options.fit) {\n        cy.fit(options.padding);\n      }\n    };\n\n    var mainLoop = function mainLoop(i) {\n      if (layout.stopped || i >= options.numIter) {\n        // logDebug(\"Layout manually stopped. Stopping computation in step \" + i);\n        return false;\n      } // Do one step in the phisical simulation\n\n\n      step(layoutInfo, options); // Update temperature\n\n      layoutInfo.temperature = layoutInfo.temperature * options.coolingFactor; // logDebug(\"New temperature: \" + layoutInfo.temperature);\n\n      if (layoutInfo.temperature < options.minTemp) {\n        // logDebug(\"Temperature drop below minimum threshold. Stopping computation in step \" + i);\n        return false;\n      }\n\n      return true;\n    };\n\n    var done = function done() {\n      if (options.animate === true || options.animate === false) {\n        refresh(); // Layout has finished\n\n        layout.one('layoutstop', options.stop);\n        layout.emit({\n          type: 'layoutstop',\n          layout: layout\n        });\n      } else {\n        var nodes = options.eles.nodes();\n        var getScaledPos = getScaleInBoundsFn(layoutInfo, options, nodes);\n        nodes.layoutPositions(layout, options, getScaledPos);\n      }\n    };\n\n    var i = 0;\n    var loopRet = true;\n\n    if (options.animate === true) {\n      var frame = function frame() {\n        var f = 0;\n\n        while (loopRet && f < options.refresh) {\n          loopRet = mainLoop(i);\n          i++;\n          f++;\n        }\n\n        if (!loopRet) {\n          // it's done\n          separateComponents(layoutInfo, options);\n          done();\n        } else {\n          var now = performanceNow();\n\n          if (now - startTime >= options.animationThreshold) {\n            refresh();\n          }\n\n          requestAnimationFrame(frame);\n        }\n      };\n\n      frame();\n    } else {\n      while (loopRet) {\n        loopRet = mainLoop(i);\n        i++;\n      }\n\n      separateComponents(layoutInfo, options);\n      done();\n    }\n\n    return this; // chaining\n  };\n  /**\n   * @brief : called on continuous layouts to stop them before they finish\n   */\n\n\n  CoseLayout.prototype.stop = function () {\n    this.stopped = true;\n\n    if (this.thread) {\n      this.thread.stop();\n    }\n\n    this.emit('layoutstop');\n    return this; // chaining\n  };\n\n  CoseLayout.prototype.destroy = function () {\n    if (this.thread) {\n      this.thread.stop();\n    }\n\n    return this; // chaining\n  };\n  /**\n   * @brief     : Creates an object which is contains all the data\n   *              used in the layout process\n   * @arg cy    : cytoscape.js object\n   * @return    : layoutInfo object initialized\n   */\n\n\n  var createLayoutInfo = function createLayoutInfo(cy, layout, options) {\n    // Shortcut\n    var edges = options.eles.edges();\n    var nodes = options.eles.nodes();\n    var layoutInfo = {\n      isCompound: cy.hasCompoundNodes(),\n      layoutNodes: [],\n      idToIndex: {},\n      nodeSize: nodes.size(),\n      graphSet: [],\n      indexToGraph: [],\n      layoutEdges: [],\n      edgeSize: edges.size(),\n      temperature: options.initialTemp,\n      clientWidth: cy.width(),\n      clientHeight: cy.width(),\n      boundingBox: makeBoundingBox(options.boundingBox ? options.boundingBox : {\n        x1: 0,\n        y1: 0,\n        w: cy.width(),\n        h: cy.height()\n      })\n    };\n    var components = options.eles.components();\n    var id2cmptId = {};\n\n    for (var i = 0; i < components.length; i++) {\n      var component = components[i];\n\n      for (var j = 0; j < component.length; j++) {\n        var node = component[j];\n        id2cmptId[node.id()] = i;\n      }\n    } // Iterate over all nodes, creating layout nodes\n\n\n    for (var i = 0; i < layoutInfo.nodeSize; i++) {\n      var n = nodes[i];\n      var nbb = n.layoutDimensions(options);\n      var tempNode = {};\n      tempNode.isLocked = n.locked();\n      tempNode.id = n.data('id');\n      tempNode.parentId = n.data('parent');\n      tempNode.cmptId = id2cmptId[n.id()];\n      tempNode.children = [];\n      tempNode.positionX = n.position('x');\n      tempNode.positionY = n.position('y');\n      tempNode.offsetX = 0;\n      tempNode.offsetY = 0;\n      tempNode.height = nbb.w;\n      tempNode.width = nbb.h;\n      tempNode.maxX = tempNode.positionX + tempNode.width / 2;\n      tempNode.minX = tempNode.positionX - tempNode.width / 2;\n      tempNode.maxY = tempNode.positionY + tempNode.height / 2;\n      tempNode.minY = tempNode.positionY - tempNode.height / 2;\n      tempNode.padLeft = parseFloat(n.style('padding'));\n      tempNode.padRight = parseFloat(n.style('padding'));\n      tempNode.padTop = parseFloat(n.style('padding'));\n      tempNode.padBottom = parseFloat(n.style('padding')); // forces\n\n      tempNode.nodeRepulsion = fn$6(options.nodeRepulsion) ? options.nodeRepulsion(n) : options.nodeRepulsion; // Add new node\n\n      layoutInfo.layoutNodes.push(tempNode); // Add entry to id-index map\n\n      layoutInfo.idToIndex[tempNode.id] = i;\n    } // Inline implementation of a queue, used for traversing the graph in BFS order\n\n\n    var queue = [];\n    var start = 0; // Points to the start the queue\n\n    var end = -1; // Points to the end of the queue\n\n    var tempGraph = []; // Second pass to add child information and\n    // initialize queue for hierarchical traversal\n\n    for (var i = 0; i < layoutInfo.nodeSize; i++) {\n      var n = layoutInfo.layoutNodes[i];\n      var p_id = n.parentId; // Check if node n has a parent node\n\n      if (null != p_id) {\n        // Add node Id to parent's list of children\n        layoutInfo.layoutNodes[layoutInfo.idToIndex[p_id]].children.push(n.id);\n      } else {\n        // If a node doesn't have a parent, then it's in the root graph\n        queue[++end] = n.id;\n        tempGraph.push(n.id);\n      }\n    } // Add root graph to graphSet\n\n\n    layoutInfo.graphSet.push(tempGraph); // Traverse the graph, level by level,\n\n    while (start <= end) {\n      // Get the node to visit and remove it from queue\n      var node_id = queue[start++];\n      var node_ix = layoutInfo.idToIndex[node_id];\n      var node = layoutInfo.layoutNodes[node_ix];\n      var children = node.children;\n\n      if (children.length > 0) {\n        // Add children nodes as a new graph to graph set\n        layoutInfo.graphSet.push(children); // Add children to que queue to be visited\n\n        for (var i = 0; i < children.length; i++) {\n          queue[++end] = children[i];\n        }\n      }\n    } // Create indexToGraph map\n\n\n    for (var i = 0; i < layoutInfo.graphSet.length; i++) {\n      var graph = layoutInfo.graphSet[i];\n\n      for (var j = 0; j < graph.length; j++) {\n        var index = layoutInfo.idToIndex[graph[j]];\n        layoutInfo.indexToGraph[index] = i;\n      }\n    } // Iterate over all edges, creating Layout Edges\n\n\n    for (var i = 0; i < layoutInfo.edgeSize; i++) {\n      var e = edges[i];\n      var tempEdge = {};\n      tempEdge.id = e.data('id');\n      tempEdge.sourceId = e.data('source');\n      tempEdge.targetId = e.data('target'); // Compute ideal length\n\n      var idealLength = fn$6(options.idealEdgeLength) ? options.idealEdgeLength(e) : options.idealEdgeLength;\n      var elasticity = fn$6(options.edgeElasticity) ? options.edgeElasticity(e) : options.edgeElasticity; // Check if it's an inter graph edge\n\n      var sourceIx = layoutInfo.idToIndex[tempEdge.sourceId];\n      var targetIx = layoutInfo.idToIndex[tempEdge.targetId];\n      var sourceGraph = layoutInfo.indexToGraph[sourceIx];\n      var targetGraph = layoutInfo.indexToGraph[targetIx];\n\n      if (sourceGraph != targetGraph) {\n        // Find lowest common graph ancestor\n        var lca = findLCA(tempEdge.sourceId, tempEdge.targetId, layoutInfo); // Compute sum of node depths, relative to lca graph\n\n        var lcaGraph = layoutInfo.graphSet[lca];\n        var depth = 0; // Source depth\n\n        var tempNode = layoutInfo.layoutNodes[sourceIx];\n\n        while (-1 === lcaGraph.indexOf(tempNode.id)) {\n          tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];\n          depth++;\n        } // Target depth\n\n\n        tempNode = layoutInfo.layoutNodes[targetIx];\n\n        while (-1 === lcaGraph.indexOf(tempNode.id)) {\n          tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];\n          depth++;\n        } // logDebug('LCA of nodes ' + tempEdge.sourceId + ' and ' + tempEdge.targetId +\n        //  \". Index: \" + lca + \" Contents: \" + lcaGraph.toString() +\n        //  \". Depth: \" + depth);\n        // Update idealLength\n\n\n        idealLength *= depth * options.nestingFactor;\n      }\n\n      tempEdge.idealLength = idealLength;\n      tempEdge.elasticity = elasticity;\n      layoutInfo.layoutEdges.push(tempEdge);\n    } // Finally, return layoutInfo object\n\n\n    return layoutInfo;\n  };\n  /**\n   * @brief : This function finds the index of the lowest common\n   *          graph ancestor between 2 nodes in the subtree\n   *          (from the graph hierarchy induced tree) whose\n   *          root is graphIx\n   *\n   * @arg node1: node1's ID\n   * @arg node2: node2's ID\n   * @arg layoutInfo: layoutInfo object\n   *\n   */\n\n\n  var findLCA = function findLCA(node1, node2, layoutInfo) {\n    // Find their common ancester, starting from the root graph\n    var res = findLCA_aux(node1, node2, 0, layoutInfo);\n\n    if (2 > res.count) {\n      // If aux function couldn't find the common ancester,\n      // then it is the root graph\n      return 0;\n    } else {\n      return res.graph;\n    }\n  };\n  /**\n   * @brief          : Auxiliary function used for LCA computation\n   *\n   * @arg node1      : node1's ID\n   * @arg node2      : node2's ID\n   * @arg graphIx    : subgraph index\n   * @arg layoutInfo : layoutInfo object\n   *\n   * @return         : object of the form {count: X, graph: Y}, where:\n   *                   X is the number of ancestors (max: 2) found in\n   *                   graphIx (and it's subgraphs),\n   *                   Y is the graph index of the lowest graph containing\n   *                   all X nodes\n   */\n\n\n  var findLCA_aux = function findLCA_aux(node1, node2, graphIx, layoutInfo) {\n    var graph = layoutInfo.graphSet[graphIx]; // If both nodes belongs to graphIx\n\n    if (-1 < graph.indexOf(node1) && -1 < graph.indexOf(node2)) {\n      return {\n        count: 2,\n        graph: graphIx\n      };\n    } // Make recursive calls for all subgraphs\n\n\n    var c = 0;\n\n    for (var i = 0; i < graph.length; i++) {\n      var nodeId = graph[i];\n      var nodeIx = layoutInfo.idToIndex[nodeId];\n      var children = layoutInfo.layoutNodes[nodeIx].children; // If the node has no child, skip it\n\n      if (0 === children.length) {\n        continue;\n      }\n\n      var childGraphIx = layoutInfo.indexToGraph[layoutInfo.idToIndex[children[0]]];\n      var result = findLCA_aux(node1, node2, childGraphIx, layoutInfo);\n\n      if (0 === result.count) {\n        // Neither node1 nor node2 are present in this subgraph\n        continue;\n      } else if (1 === result.count) {\n        // One of (node1, node2) is present in this subgraph\n        c++;\n\n        if (2 === c) {\n          // We've already found both nodes, no need to keep searching\n          break;\n        }\n      } else {\n        // Both nodes are present in this subgraph\n        return result;\n      }\n    }\n\n    return {\n      count: c,\n      graph: graphIx\n    };\n  };\n  /**\n   * @brief: printsLayoutInfo into js console\n   *         Only used for debbuging\n   */\n\n\nvar printLayoutInfo; \n  /**\n   * @brief : Randomizes the position of all nodes\n   */\n\n\n  var randomizePositions = function randomizePositions(layoutInfo, cy) {\n    var width = layoutInfo.clientWidth;\n    var height = layoutInfo.clientHeight;\n\n    for (var i = 0; i < layoutInfo.nodeSize; i++) {\n      var n = layoutInfo.layoutNodes[i]; // No need to randomize compound nodes or locked nodes\n\n      if (0 === n.children.length && !n.isLocked) {\n        n.positionX = Math.random() * width;\n        n.positionY = Math.random() * height;\n      }\n    }\n  };\n\n  var getScaleInBoundsFn = function getScaleInBoundsFn(layoutInfo, options, nodes) {\n    var bb = layoutInfo.boundingBox;\n    var coseBB = {\n      x1: Infinity,\n      x2: -Infinity,\n      y1: Infinity,\n      y2: -Infinity\n    };\n\n    if (options.boundingBox) {\n      nodes.forEach(function (node) {\n        var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[node.data('id')]];\n        coseBB.x1 = Math.min(coseBB.x1, lnode.positionX);\n        coseBB.x2 = Math.max(coseBB.x2, lnode.positionX);\n        coseBB.y1 = Math.min(coseBB.y1, lnode.positionY);\n        coseBB.y2 = Math.max(coseBB.y2, lnode.positionY);\n      });\n      coseBB.w = coseBB.x2 - coseBB.x1;\n      coseBB.h = coseBB.y2 - coseBB.y1;\n    }\n\n    return function (ele, i) {\n      var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[ele.data('id')]];\n\n      if (options.boundingBox) {\n        // then add extra bounding box constraint\n        var pctX = (lnode.positionX - coseBB.x1) / coseBB.w;\n        var pctY = (lnode.positionY - coseBB.y1) / coseBB.h;\n        return {\n          x: bb.x1 + pctX * bb.w,\n          y: bb.y1 + pctY * bb.h\n        };\n      } else {\n        return {\n          x: lnode.positionX,\n          y: lnode.positionY\n        };\n      }\n    };\n  };\n  /**\n   * @brief          : Updates the positions of nodes in the network\n   * @arg layoutInfo : LayoutInfo object\n   * @arg cy         : Cytoscape object\n   * @arg options    : Layout options\n   */\n\n\n  var refreshPositions = function refreshPositions(layoutInfo, cy, options) {\n    // var s = 'Refreshing positions';\n    // logDebug(s);\n    var layout = options.layout;\n    var nodes = options.eles.nodes();\n    var getScaledPos = getScaleInBoundsFn(layoutInfo, options, nodes);\n    nodes.positions(getScaledPos); // Trigger layoutReady only on first call\n\n    if (true !== layoutInfo.ready) {\n      // s = 'Triggering layoutready';\n      // logDebug(s);\n      layoutInfo.ready = true;\n      layout.one('layoutready', options.ready);\n      layout.emit({\n        type: 'layoutready',\n        layout: this\n      });\n    }\n  };\n  /**\n   * @brief : Logs a debug message in JS console, if DEBUG is ON\n   */\n  // var logDebug = function(text) {\n  //   if (DEBUG) {\n  //     console.debug(text);\n  //   }\n  // };\n\n  /**\n   * @brief          : Performs one iteration of the physical simulation\n   * @arg layoutInfo : LayoutInfo object already initialized\n   * @arg cy         : Cytoscape object\n   * @arg options    : Layout options\n   */\n\n\n  var step = function step(layoutInfo, options, _step) {\n    // var s = \"\\n\\n###############################\";\n    // s += \"\\nSTEP: \" + step;\n    // s += \"\\n###############################\\n\";\n    // logDebug(s);\n    // Calculate node repulsions\n    calculateNodeForces(layoutInfo, options); // Calculate edge forces\n\n    calculateEdgeForces(layoutInfo); // Calculate gravity forces\n\n    calculateGravityForces(layoutInfo, options); // Propagate forces from parent to child\n\n    propagateForces(layoutInfo); // Update positions based on calculated forces\n\n    updatePositions(layoutInfo);\n  };\n  /**\n   * @brief : Computes the node repulsion forces\n   */\n\n\n  var calculateNodeForces = function calculateNodeForces(layoutInfo, options) {\n    // Go through each of the graphs in graphSet\n    // Nodes only repel each other if they belong to the same graph\n    // var s = 'calculateNodeForces';\n    // logDebug(s);\n    for (var i = 0; i < layoutInfo.graphSet.length; i++) {\n      var graph = layoutInfo.graphSet[i];\n      var numNodes = graph.length; // s = \"Set: \" + graph.toString();\n      // logDebug(s);\n      // Now get all the pairs of nodes\n      // Only get each pair once, (A, B) = (B, A)\n\n      for (var j = 0; j < numNodes; j++) {\n        var node1 = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[j]]];\n\n        for (var k = j + 1; k < numNodes; k++) {\n          var node2 = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[k]]];\n          nodeRepulsion(node1, node2, layoutInfo, options);\n        }\n      }\n    }\n  };\n\n  var randomDistance = function randomDistance(max) {\n    return -max + 2 * max * Math.random();\n  };\n  /**\n   * @brief : Compute the node repulsion forces between a pair of nodes\n   */\n\n\n  var nodeRepulsion = function nodeRepulsion(node1, node2, layoutInfo, options) {\n    // var s = \"Node repulsion. Node1: \" + node1.id + \" Node2: \" + node2.id;\n    var cmptId1 = node1.cmptId;\n    var cmptId2 = node2.cmptId;\n\n    if (cmptId1 !== cmptId2 && !layoutInfo.isCompound) {\n      return;\n    } // Get direction of line connecting both node centers\n\n\n    var directionX = node2.positionX - node1.positionX;\n    var directionY = node2.positionY - node1.positionY;\n    var maxRandDist = 1; // s += \"\\ndirectionX: \" + directionX + \", directionY: \" + directionY;\n    // If both centers are the same, apply a random force\n\n    if (0 === directionX && 0 === directionY) {\n      directionX = randomDistance(maxRandDist);\n      directionY = randomDistance(maxRandDist);\n    }\n\n    var overlap = nodesOverlap(node1, node2, directionX, directionY);\n\n    if (overlap > 0) {\n      // s += \"\\nNodes DO overlap.\";\n      // s += \"\\nOverlap: \" + overlap;\n      // If nodes overlap, repulsion force is proportional\n      // to the overlap\n      var force = options.nodeOverlap * overlap; // Compute the module and components of the force vector\n\n      var distance = Math.sqrt(directionX * directionX + directionY * directionY); // s += \"\\nDistance: \" + distance;\n\n      var forceX = force * directionX / distance;\n      var forceY = force * directionY / distance;\n    } else {\n      // s += \"\\nNodes do NOT overlap.\";\n      // If there's no overlap, force is inversely proportional\n      // to squared distance\n      // Get clipping points for both nodes\n      var point1 = findClippingPoint(node1, directionX, directionY);\n      var point2 = findClippingPoint(node2, -1 * directionX, -1 * directionY); // Use clipping points to compute distance\n\n      var distanceX = point2.x - point1.x;\n      var distanceY = point2.y - point1.y;\n      var distanceSqr = distanceX * distanceX + distanceY * distanceY;\n      var distance = Math.sqrt(distanceSqr); // s += \"\\nDistance: \" + distance;\n      // Compute the module and components of the force vector\n\n      var force = (node1.nodeRepulsion + node2.nodeRepulsion) / distanceSqr;\n      var forceX = force * distanceX / distance;\n      var forceY = force * distanceY / distance;\n    } // Apply force\n\n\n    if (!node1.isLocked) {\n      node1.offsetX -= forceX;\n      node1.offsetY -= forceY;\n    }\n\n    if (!node2.isLocked) {\n      node2.offsetX += forceX;\n      node2.offsetY += forceY;\n    } // s += \"\\nForceX: \" + forceX + \" ForceY: \" + forceY;\n    // logDebug(s);\n\n\n    return;\n  };\n  /**\n   * @brief  : Determines whether two nodes overlap or not\n   * @return : Amount of overlapping (0 => no overlap)\n   */\n\n\n  var nodesOverlap = function nodesOverlap(node1, node2, dX, dY) {\n    if (dX > 0) {\n      var overlapX = node1.maxX - node2.minX;\n    } else {\n      var overlapX = node2.maxX - node1.minX;\n    }\n\n    if (dY > 0) {\n      var overlapY = node1.maxY - node2.minY;\n    } else {\n      var overlapY = node2.maxY - node1.minY;\n    }\n\n    if (overlapX >= 0 && overlapY >= 0) {\n      return Math.sqrt(overlapX * overlapX + overlapY * overlapY);\n    } else {\n      return 0;\n    }\n  };\n  /**\n   * @brief : Finds the point in which an edge (direction dX, dY) intersects\n   *          the rectangular bounding box of it's source/target node\n   */\n\n\n  var findClippingPoint = function findClippingPoint(node, dX, dY) {\n    // Shorcuts\n    var X = node.positionX;\n    var Y = node.positionY;\n    var H = node.height || 1;\n    var W = node.width || 1;\n    var dirSlope = dY / dX;\n    var nodeSlope = H / W; // var s = 'Computing clipping point of node ' + node.id +\n    //   \" . Height:  \" + H + \", Width: \" + W +\n    //   \"\\nDirection \" + dX + \", \" + dY;\n    //\n    // Compute intersection\n\n    var res = {}; // Case: Vertical direction (up)\n\n    if (0 === dX && 0 < dY) {\n      res.x = X; // s += \"\\nUp direction\";\n\n      res.y = Y + H / 2;\n      return res;\n    } // Case: Vertical direction (down)\n\n\n    if (0 === dX && 0 > dY) {\n      res.x = X;\n      res.y = Y + H / 2; // s += \"\\nDown direction\";\n\n      return res;\n    } // Case: Intersects the right border\n\n\n    if (0 < dX && -1 * nodeSlope <= dirSlope && dirSlope <= nodeSlope) {\n      res.x = X + W / 2;\n      res.y = Y + W * dY / 2 / dX; // s += \"\\nRightborder\";\n\n      return res;\n    } // Case: Intersects the left border\n\n\n    if (0 > dX && -1 * nodeSlope <= dirSlope && dirSlope <= nodeSlope) {\n      res.x = X - W / 2;\n      res.y = Y - W * dY / 2 / dX; // s += \"\\nLeftborder\";\n\n      return res;\n    } // Case: Intersects the top border\n\n\n    if (0 < dY && (dirSlope <= -1 * nodeSlope || dirSlope >= nodeSlope)) {\n      res.x = X + H * dX / 2 / dY;\n      res.y = Y + H / 2; // s += \"\\nTop border\";\n\n      return res;\n    } // Case: Intersects the bottom border\n\n\n    if (0 > dY && (dirSlope <= -1 * nodeSlope || dirSlope >= nodeSlope)) {\n      res.x = X - H * dX / 2 / dY;\n      res.y = Y - H / 2; // s += \"\\nBottom border\";\n\n      return res;\n    } // s += \"\\nClipping point found at \" + res.x + \", \" + res.y;\n    // logDebug(s);\n\n\n    return res;\n  };\n  /**\n   * @brief : Calculates all edge forces\n   */\n\n\n  var calculateEdgeForces = function calculateEdgeForces(layoutInfo, options) {\n    // Iterate over all edges\n    for (var i = 0; i < layoutInfo.edgeSize; i++) {\n      // Get edge, source & target nodes\n      var edge = layoutInfo.layoutEdges[i];\n      var sourceIx = layoutInfo.idToIndex[edge.sourceId];\n      var source = layoutInfo.layoutNodes[sourceIx];\n      var targetIx = layoutInfo.idToIndex[edge.targetId];\n      var target = layoutInfo.layoutNodes[targetIx]; // Get direction of line connecting both node centers\n\n      var directionX = target.positionX - source.positionX;\n      var directionY = target.positionY - source.positionY; // If both centers are the same, do nothing.\n      // A random force has already been applied as node repulsion\n\n      if (0 === directionX && 0 === directionY) {\n        continue;\n      } // Get clipping points for both nodes\n\n\n      var point1 = findClippingPoint(source, directionX, directionY);\n      var point2 = findClippingPoint(target, -1 * directionX, -1 * directionY);\n      var lx = point2.x - point1.x;\n      var ly = point2.y - point1.y;\n      var l = Math.sqrt(lx * lx + ly * ly);\n      var force = Math.pow(edge.idealLength - l, 2) / edge.elasticity;\n\n      if (0 !== l) {\n        var forceX = force * lx / l;\n        var forceY = force * ly / l;\n      } else {\n        var forceX = 0;\n        var forceY = 0;\n      } // Add this force to target and source nodes\n\n\n      if (!source.isLocked) {\n        source.offsetX += forceX;\n        source.offsetY += forceY;\n      }\n\n      if (!target.isLocked) {\n        target.offsetX -= forceX;\n        target.offsetY -= forceY;\n      } // var s = 'Edge force between nodes ' + source.id + ' and ' + target.id;\n      // s += \"\\nDistance: \" + l + \" Force: (\" + forceX + \", \" + forceY + \")\";\n      // logDebug(s);\n\n    }\n  };\n  /**\n   * @brief : Computes gravity forces for all nodes\n   */\n\n\n  var calculateGravityForces = function calculateGravityForces(layoutInfo, options) {\n    if (options.gravity === 0) {\n      return;\n    }\n\n    var distThreshold = 1; // var s = 'calculateGravityForces';\n    // logDebug(s);\n\n    for (var i = 0; i < layoutInfo.graphSet.length; i++) {\n      var graph = layoutInfo.graphSet[i];\n      var numNodes = graph.length; // s = \"Set: \" + graph.toString();\n      // logDebug(s);\n      // Compute graph center\n\n      if (0 === i) {\n        var centerX = layoutInfo.clientHeight / 2;\n        var centerY = layoutInfo.clientWidth / 2;\n      } else {\n        // Get Parent node for this graph, and use its position as center\n        var temp = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[0]]];\n        var parent = layoutInfo.layoutNodes[layoutInfo.idToIndex[temp.parentId]];\n        var centerX = parent.positionX;\n        var centerY = parent.positionY;\n      } // s = \"Center found at: \" + centerX + \", \" + centerY;\n      // logDebug(s);\n      // Apply force to all nodes in graph\n\n\n      for (var j = 0; j < numNodes; j++) {\n        var node = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[j]]]; // s = \"Node: \" + node.id;\n\n        if (node.isLocked) {\n          continue;\n        }\n\n        var dx = centerX - node.positionX;\n        var dy = centerY - node.positionY;\n        var d = Math.sqrt(dx * dx + dy * dy);\n\n        if (d > distThreshold) {\n          var fx = options.gravity * dx / d;\n          var fy = options.gravity * dy / d;\n          node.offsetX += fx;\n          node.offsetY += fy; // s += \": Applied force: \" + fx + \", \" + fy;\n        } // logDebug(s);\n\n      }\n    }\n  };\n  /**\n   * @brief          : This function propagates the existing offsets from\n   *                   parent nodes to its descendents.\n   * @arg layoutInfo : layoutInfo Object\n   * @arg cy         : cytoscape Object\n   * @arg options    : Layout options\n   */\n\n\n  var propagateForces = function propagateForces(layoutInfo, options) {\n    // Inline implementation of a queue, used for traversing the graph in BFS order\n    var queue = [];\n    var start = 0; // Points to the start the queue\n\n    var end = -1; // Points to the end of the queue\n    // logDebug('propagateForces');\n    // Start by visiting the nodes in the root graph\n\n    queue.push.apply(queue, layoutInfo.graphSet[0]);\n    end += layoutInfo.graphSet[0].length; // Traverse the graph, level by level,\n\n    while (start <= end) {\n      // Get the node to visit and remove it from queue\n      var nodeId = queue[start++];\n      var nodeIndex = layoutInfo.idToIndex[nodeId];\n      var node = layoutInfo.layoutNodes[nodeIndex];\n      var children = node.children; // We only need to process the node if it's compound\n\n      if (0 < children.length && !node.isLocked) {\n        var offX = node.offsetX;\n        var offY = node.offsetY; // var s = \"Propagating offset from parent node : \" + node.id +\n        //   \". OffsetX: \" + offX + \". OffsetY: \" + offY;\n        // s += \"\\n Children: \" + children.toString();\n        // logDebug(s);\n\n        for (var i = 0; i < children.length; i++) {\n          var childNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[children[i]]]; // Propagate offset\n\n          childNode.offsetX += offX;\n          childNode.offsetY += offY; // Add children to queue to be visited\n\n          queue[++end] = children[i];\n        } // Reset parent offsets\n\n\n        node.offsetX = 0;\n        node.offsetY = 0;\n      }\n    }\n  };\n  /**\n   * @brief : Updates the layout model positions, based on\n   *          the accumulated forces\n   */\n\n\n  var updatePositions = function updatePositions(layoutInfo, options) {\n    // var s = 'Updating positions';\n    // logDebug(s);\n    // Reset boundaries for compound nodes\n    for (var i = 0; i < layoutInfo.nodeSize; i++) {\n      var n = layoutInfo.layoutNodes[i];\n\n      if (0 < n.children.length) {\n        // logDebug(\"Resetting boundaries of compound node: \" + n.id);\n        n.maxX = undefined;\n        n.minX = undefined;\n        n.maxY = undefined;\n        n.minY = undefined;\n      }\n    }\n\n    for (var i = 0; i < layoutInfo.nodeSize; i++) {\n      var n = layoutInfo.layoutNodes[i];\n\n      if (0 < n.children.length || n.isLocked) {\n        // No need to set compound or locked node position\n        // logDebug(\"Skipping position update of node: \" + n.id);\n        continue;\n      } // s = \"Node: \" + n.id + \" Previous position: (\" +\n      // n.positionX + \", \" + n.positionY + \").\";\n      // Limit displacement in order to improve stability\n\n\n      var tempForce = limitForce(n.offsetX, n.offsetY, layoutInfo.temperature);\n      n.positionX += tempForce.x;\n      n.positionY += tempForce.y;\n      n.offsetX = 0;\n      n.offsetY = 0;\n      n.minX = n.positionX - n.width;\n      n.maxX = n.positionX + n.width;\n      n.minY = n.positionY - n.height;\n      n.maxY = n.positionY + n.height; // s += \" New Position: (\" + n.positionX + \", \" + n.positionY + \").\";\n      // logDebug(s);\n      // Update ancestry boudaries\n\n      updateAncestryBoundaries(n, layoutInfo);\n    } // Update size, position of compund nodes\n\n\n    for (var i = 0; i < layoutInfo.nodeSize; i++) {\n      var n = layoutInfo.layoutNodes[i];\n\n      if (0 < n.children.length && !n.isLocked) {\n        n.positionX = (n.maxX + n.minX) / 2;\n        n.positionY = (n.maxY + n.minY) / 2;\n        n.width = n.maxX - n.minX;\n        n.height = n.maxY - n.minY; // s = \"Updating position, size of compound node \" + n.id;\n        // s += \"\\nPositionX: \" + n.positionX + \", PositionY: \" + n.positionY;\n        // s += \"\\nWidth: \" + n.width + \", Height: \" + n.height;\n        // logDebug(s);\n      }\n    }\n  };\n  /**\n   * @brief : Limits a force (forceX, forceY) to be not\n   *          greater (in modulo) than max.\n   8          Preserves force direction.\n    */\n\n\n  var limitForce = function limitForce(forceX, forceY, max) {\n    // var s = \"Limiting force: (\" + forceX + \", \" + forceY + \"). Max: \" + max;\n    var force = Math.sqrt(forceX * forceX + forceY * forceY);\n\n    if (force > max) {\n      var res = {\n        x: max * forceX / force,\n        y: max * forceY / force\n      };\n    } else {\n      var res = {\n        x: forceX,\n        y: forceY\n      };\n    } // s += \".\\nResult: (\" + res.x + \", \" + res.y + \")\";\n    // logDebug(s);\n\n\n    return res;\n  };\n  /**\n   * @brief : Function used for keeping track of compound node\n   *          sizes, since they should bound all their subnodes.\n   */\n\n\n  var updateAncestryBoundaries = function updateAncestryBoundaries(node, layoutInfo) {\n    // var s = \"Propagating new position/size of node \" + node.id;\n    var parentId = node.parentId;\n\n    if (null == parentId) {\n      // If there's no parent, we are done\n      // s += \". No parent node.\";\n      // logDebug(s);\n      return;\n    } // Get Parent Node\n\n\n    var p = layoutInfo.layoutNodes[layoutInfo.idToIndex[parentId]];\n    var flag = false; // MaxX\n\n    if (null == p.maxX || node.maxX + p.padRight > p.maxX) {\n      p.maxX = node.maxX + p.padRight;\n      flag = true; // s += \"\\nNew maxX for parent node \" + p.id + \": \" + p.maxX;\n    } // MinX\n\n\n    if (null == p.minX || node.minX - p.padLeft < p.minX) {\n      p.minX = node.minX - p.padLeft;\n      flag = true; // s += \"\\nNew minX for parent node \" + p.id + \": \" + p.minX;\n    } // MaxY\n\n\n    if (null == p.maxY || node.maxY + p.padBottom > p.maxY) {\n      p.maxY = node.maxY + p.padBottom;\n      flag = true; // s += \"\\nNew maxY for parent node \" + p.id + \": \" + p.maxY;\n    } // MinY\n\n\n    if (null == p.minY || node.minY - p.padTop < p.minY) {\n      p.minY = node.minY - p.padTop;\n      flag = true; // s += \"\\nNew minY for parent node \" + p.id + \": \" + p.minY;\n    } // If updated boundaries, propagate changes upward\n\n\n    if (flag) {\n      // logDebug(s);\n      return updateAncestryBoundaries(p, layoutInfo);\n    } // s += \". No changes in boundaries/position of parent node \" + p.id;\n    // logDebug(s);\n\n\n    return;\n  };\n\n  var separateComponents = function separateComponents(layoutInfo, options) {\n    var nodes = layoutInfo.layoutNodes;\n    var components = [];\n\n    for (var i = 0; i < nodes.length; i++) {\n      var node = nodes[i];\n      var cid = node.cmptId;\n      var component = components[cid] = components[cid] || [];\n      component.push(node);\n    }\n\n    var totalA = 0;\n\n    for (var i = 0; i < components.length; i++) {\n      var c = components[i];\n\n      if (!c) {\n        continue;\n      }\n\n      c.x1 = Infinity;\n      c.x2 = -Infinity;\n      c.y1 = Infinity;\n      c.y2 = -Infinity;\n\n      for (var j = 0; j < c.length; j++) {\n        var n = c[j];\n        c.x1 = Math.min(c.x1, n.positionX - n.width / 2);\n        c.x2 = Math.max(c.x2, n.positionX + n.width / 2);\n        c.y1 = Math.min(c.y1, n.positionY - n.height / 2);\n        c.y2 = Math.max(c.y2, n.positionY + n.height / 2);\n      }\n\n      c.w = c.x2 - c.x1;\n      c.h = c.y2 - c.y1;\n      totalA += c.w * c.h;\n    }\n\n    components.sort(function (c1, c2) {\n      return c2.w * c2.h - c1.w * c1.h;\n    });\n    var x = 0;\n    var y = 0;\n    var usedW = 0;\n    var rowH = 0;\n    var maxRowW = Math.sqrt(totalA) * layoutInfo.clientWidth / layoutInfo.clientHeight;\n\n    for (var i = 0; i < components.length; i++) {\n      var c = components[i];\n\n      if (!c) {\n        continue;\n      }\n\n      for (var j = 0; j < c.length; j++) {\n        var n = c[j];\n\n        if (!n.isLocked) {\n          n.positionX += x - c.x1;\n          n.positionY += y - c.y1;\n        }\n      }\n\n      x += c.w + options.componentSpacing;\n      usedW += c.w + options.componentSpacing;\n      rowH = Math.max(rowH, c.h);\n\n      if (usedW > maxRowW) {\n        y += rowH + options.componentSpacing;\n        x = 0;\n        usedW = 0;\n        rowH = 0;\n      }\n    }\n  };\n\n  var defaults$3 = {\n    fit: true,\n    // whether to fit the viewport to the graph\n    padding: 30,\n    // padding used on fit\n    boundingBox: undefined,\n    // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n    avoidOverlap: true,\n    // prevents node overlap, may overflow boundingBox if not enough space\n    avoidOverlapPadding: 10,\n    // extra spacing around nodes when avoidOverlap: true\n    nodeDimensionsIncludeLabels: false,\n    // Excludes the label when calculating node bounding boxes for the layout algorithm\n    spacingFactor: undefined,\n    // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up\n    condense: false,\n    // uses all available space on false, uses minimal space on true\n    rows: undefined,\n    // force num of rows in the grid\n    cols: undefined,\n    // force num of columns in the grid\n    position: function position(node) {},\n    // returns { row, col } for element\n    sort: undefined,\n    // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }\n    animate: false,\n    // whether to transition the node positions\n    animationDuration: 500,\n    // duration of animation in ms if enabled\n    animationEasing: undefined,\n    // easing of animation if enabled\n    animateFilter: function animateFilter(node, i) {\n      return true;\n    },\n    // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts\n    ready: undefined,\n    // callback on layoutready\n    stop: undefined,\n    // callback on layoutstop\n    transform: function transform(node, position) {\n      return position;\n    } // transform a given node position. Useful for changing flow direction in discrete layouts \n\n  };\n\n  function GridLayout(options) {\n    this.options = extend({}, defaults$3, options);\n  }\n\n  GridLayout.prototype.run = function () {\n    var params = this.options;\n    var options = params;\n    var cy = params.cy;\n    var eles = options.eles;\n    var nodes = eles.nodes().not(':parent');\n\n    if (options.sort) {\n      nodes = nodes.sort(options.sort);\n    }\n\n    var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {\n      x1: 0,\n      y1: 0,\n      w: cy.width(),\n      h: cy.height()\n    });\n\n    if (bb.h === 0 || bb.w === 0) {\n      eles.nodes().layoutPositions(this, options, function (ele) {\n        return {\n          x: bb.x1,\n          y: bb.y1\n        };\n      });\n    } else {\n      // width/height * splits^2 = cells where splits is number of times to split width\n      var cells = nodes.size();\n      var splits = Math.sqrt(cells * bb.h / bb.w);\n      var rows = Math.round(splits);\n      var cols = Math.round(bb.w / bb.h * splits);\n\n      var small = function small(val) {\n        if (val == null) {\n          return Math.min(rows, cols);\n        } else {\n          var min = Math.min(rows, cols);\n\n          if (min == rows) {\n            rows = val;\n          } else {\n            cols = val;\n          }\n        }\n      };\n\n      var large = function large(val) {\n        if (val == null) {\n          return Math.max(rows, cols);\n        } else {\n          var max = Math.max(rows, cols);\n\n          if (max == rows) {\n            rows = val;\n          } else {\n            cols = val;\n          }\n        }\n      };\n\n      var oRows = options.rows;\n      var oCols = options.cols != null ? options.cols : options.columns; // if rows or columns were set in options, use those values\n\n      if (oRows != null && oCols != null) {\n        rows = oRows;\n        cols = oCols;\n      } else if (oRows != null && oCols == null) {\n        rows = oRows;\n        cols = Math.ceil(cells / rows);\n      } else if (oRows == null && oCols != null) {\n        cols = oCols;\n        rows = Math.ceil(cells / cols);\n      } // otherwise use the automatic values and adjust accordingly\n      // if rounding was up, see if we can reduce rows or columns\n      else if (cols * rows > cells) {\n        var sm = small();\n        var lg = large(); // reducing the small side takes away the most cells, so try it first\n\n        if ((sm - 1) * lg >= cells) {\n          small(sm - 1);\n        } else if ((lg - 1) * sm >= cells) {\n          large(lg - 1);\n        }\n      } else {\n        // if rounding was too low, add rows or columns\n        while (cols * rows < cells) {\n          var _sm = small();\n\n          var _lg = large(); // try to add to larger side first (adds less in multiplication)\n\n\n          if ((_lg + 1) * _sm >= cells) {\n            large(_lg + 1);\n          } else {\n            small(_sm + 1);\n          }\n        }\n      }\n\n      var cellWidth = bb.w / cols;\n      var cellHeight = bb.h / rows;\n\n      if (options.condense) {\n        cellWidth = 0;\n        cellHeight = 0;\n      }\n\n      if (options.avoidOverlap) {\n        for (var i = 0; i < nodes.length; i++) {\n          var node = nodes[i];\n          var pos = node._private.position;\n\n          if (pos.x == null || pos.y == null) {\n            // for bb\n            pos.x = 0;\n            pos.y = 0;\n          }\n\n          var nbb = node.layoutDimensions(options);\n          var p = options.avoidOverlapPadding;\n          var w = nbb.w + p;\n          var h = nbb.h + p;\n          cellWidth = Math.max(cellWidth, w);\n          cellHeight = Math.max(cellHeight, h);\n        }\n      }\n\n      var cellUsed = {}; // e.g. 'c-0-2' => true\n\n      var used = function used(row, col) {\n        return cellUsed['c-' + row + '-' + col] ? true : false;\n      };\n\n      var use = function use(row, col) {\n        cellUsed['c-' + row + '-' + col] = true;\n      }; // to keep track of current cell position\n\n\n      var row = 0;\n      var col = 0;\n\n      var moveToNextCell = function moveToNextCell() {\n        col++;\n\n        if (col >= cols) {\n          col = 0;\n          row++;\n        }\n      }; // get a cache of all the manual positions\n\n\n      var id2manPos = {};\n\n      for (var _i = 0; _i < nodes.length; _i++) {\n        var _node = nodes[_i];\n        var rcPos = options.position(_node);\n\n        if (rcPos && (rcPos.row !== undefined || rcPos.col !== undefined)) {\n          // must have at least row or col def'd\n          var _pos = {\n            row: rcPos.row,\n            col: rcPos.col\n          };\n\n          if (_pos.col === undefined) {\n            // find unused col\n            _pos.col = 0;\n\n            while (used(_pos.row, _pos.col)) {\n              _pos.col++;\n            }\n          } else if (_pos.row === undefined) {\n            // find unused row\n            _pos.row = 0;\n\n            while (used(_pos.row, _pos.col)) {\n              _pos.row++;\n            }\n          }\n\n          id2manPos[_node.id()] = _pos;\n          use(_pos.row, _pos.col);\n        }\n      }\n\n      var getPos = function getPos(element, i) {\n        var x, y;\n\n        if (element.locked() || element.isParent()) {\n          return false;\n        } // see if we have a manual position set\n\n\n        var rcPos = id2manPos[element.id()];\n\n        if (rcPos) {\n          x = rcPos.col * cellWidth + cellWidth / 2 + bb.x1;\n          y = rcPos.row * cellHeight + cellHeight / 2 + bb.y1;\n        } else {\n          // otherwise set automatically\n          while (used(row, col)) {\n            moveToNextCell();\n          }\n\n          x = col * cellWidth + cellWidth / 2 + bb.x1;\n          y = row * cellHeight + cellHeight / 2 + bb.y1;\n          use(row, col);\n          moveToNextCell();\n        }\n\n        return {\n          x: x,\n          y: y\n        };\n      };\n\n      nodes.layoutPositions(this, options, getPos);\n    }\n\n    return this; // chaining\n  };\n\n  var defaults$2 = {\n    ready: function ready() {},\n    // on layoutready\n    stop: function stop() {} // on layoutstop\n\n  }; // constructor\n  // options : object containing layout options\n\n  function NullLayout(options) {\n    this.options = extend({}, defaults$2, options);\n  } // runs the layout\n\n\n  NullLayout.prototype.run = function () {\n    var options = this.options;\n    var eles = options.eles; // elements to consider in the layout\n\n    var layout = this; // cy is automatically populated for us in the constructor\n    // (disable eslint for next line as this serves as example layout code to external developers)\n    // eslint-disable-next-line no-unused-vars\n\n    options.cy;\n    layout.emit('layoutstart'); // puts all nodes at (0, 0)\n    // n.b. most layouts would use layoutPositions(), instead of positions() and manual events\n\n    eles.nodes().positions(function () {\n      return {\n        x: 0,\n        y: 0\n      };\n    }); // trigger layoutready when each node has had its position set at least once\n\n    layout.one('layoutready', options.ready);\n    layout.emit('layoutready'); // trigger layoutstop when the layout stops (e.g. finishes)\n\n    layout.one('layoutstop', options.stop);\n    layout.emit('layoutstop');\n    return this; // chaining\n  }; // called on continuous layouts to stop them before they finish\n\n\n  NullLayout.prototype.stop = function () {\n    return this; // chaining\n  };\n\n  var defaults$1 = {\n    positions: undefined,\n    // map of (node id) => (position obj); or function(node){ return somPos; }\n    zoom: undefined,\n    // the zoom level to set (prob want fit = false if set)\n    pan: undefined,\n    // the pan level to set (prob want fit = false if set)\n    fit: true,\n    // whether to fit to viewport\n    padding: 30,\n    // padding on fit\n    animate: false,\n    // whether to transition the node positions\n    animationDuration: 500,\n    // duration of animation in ms if enabled\n    animationEasing: undefined,\n    // easing of animation if enabled\n    animateFilter: function animateFilter(node, i) {\n      return true;\n    },\n    // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts\n    ready: undefined,\n    // callback on layoutready\n    stop: undefined,\n    // callback on layoutstop\n    transform: function transform(node, position) {\n      return position;\n    } // transform a given node position. Useful for changing flow direction in discrete layouts\n\n  };\n\n  function PresetLayout(options) {\n    this.options = extend({}, defaults$1, options);\n  }\n\n  PresetLayout.prototype.run = function () {\n    var options = this.options;\n    var eles = options.eles;\n    var nodes = eles.nodes();\n    var posIsFn = fn$6(options.positions);\n\n    function getPosition(node) {\n      if (options.positions == null) {\n        return copyPosition(node.position());\n      }\n\n      if (posIsFn) {\n        return options.positions(node);\n      }\n\n      var pos = options.positions[node._private.data.id];\n\n      if (pos == null) {\n        return null;\n      }\n\n      return pos;\n    }\n\n    nodes.layoutPositions(this, options, function (node, i) {\n      var position = getPosition(node);\n\n      if (node.locked() || position == null) {\n        return false;\n      }\n\n      return position;\n    });\n    return this; // chaining\n  };\n\n  var defaults = {\n    fit: true,\n    // whether to fit to viewport\n    padding: 30,\n    // fit padding\n    boundingBox: undefined,\n    // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n    animate: false,\n    // whether to transition the node positions\n    animationDuration: 500,\n    // duration of animation in ms if enabled\n    animationEasing: undefined,\n    // easing of animation if enabled\n    animateFilter: function animateFilter(node, i) {\n      return true;\n    },\n    // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts\n    ready: undefined,\n    // callback on layoutready\n    stop: undefined,\n    // callback on layoutstop\n    transform: function transform(node, position) {\n      return position;\n    } // transform a given node position. Useful for changing flow direction in discrete layouts \n\n  };\n\n  function RandomLayout(options) {\n    this.options = extend({}, defaults, options);\n  }\n\n  RandomLayout.prototype.run = function () {\n    var options = this.options;\n    var cy = options.cy;\n    var eles = options.eles;\n    var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {\n      x1: 0,\n      y1: 0,\n      w: cy.width(),\n      h: cy.height()\n    });\n\n    var getPos = function getPos(node, i) {\n      return {\n        x: bb.x1 + Math.round(Math.random() * bb.w),\n        y: bb.y1 + Math.round(Math.random() * bb.h)\n      };\n    };\n\n    eles.nodes().layoutPositions(this, options, getPos);\n    return this; // chaining\n  };\n\n  var layout = [{\n    name: 'breadthfirst',\n    impl: BreadthFirstLayout\n  }, {\n    name: 'circle',\n    impl: CircleLayout\n  }, {\n    name: 'concentric',\n    impl: ConcentricLayout\n  }, {\n    name: 'cose',\n    impl: CoseLayout\n  }, {\n    name: 'grid',\n    impl: GridLayout\n  }, {\n    name: 'null',\n    impl: NullLayout\n  }, {\n    name: 'preset',\n    impl: PresetLayout\n  }, {\n    name: 'random',\n    impl: RandomLayout\n  }];\n\n  function NullRenderer(options) {\n    this.options = options;\n    this.notifications = 0; // for testing\n  }\n\n  var noop = function noop() {};\n\n  var throwImgErr = function throwImgErr() {\n    throw new Error('A headless instance can not render images');\n  };\n\n  NullRenderer.prototype = {\n    recalculateRenderedStyle: noop,\n    notify: function notify() {\n      this.notifications++;\n    },\n    init: noop,\n    isHeadless: function isHeadless() {\n      return true;\n    },\n    png: throwImgErr,\n    jpg: throwImgErr\n  };\n\n  var BRp$f = {};\n  BRp$f.arrowShapeWidth = 0.3;\n\n  BRp$f.registerArrowShapes = function () {\n    var arrowShapes = this.arrowShapes = {};\n    var renderer = this; // Contract for arrow shapes:\n    // 0, 0 is arrow tip\n    // (0, 1) is direction towards node\n    // (1, 0) is right\n    //\n    // functional api:\n    // collide: check x, y in shape\n    // roughCollide: called before collide, no false negatives\n    // draw: draw\n    // spacing: dist(arrowTip, nodeBoundary)\n    // gap: dist(edgeTip, nodeBoundary), edgeTip may != arrowTip\n\n    var bbCollide = function bbCollide(x, y, size, angle, translation, edgeWidth, padding) {\n      var x1 = translation.x - size / 2 - padding;\n      var x2 = translation.x + size / 2 + padding;\n      var y1 = translation.y - size / 2 - padding;\n      var y2 = translation.y + size / 2 + padding;\n      var inside = x1 <= x && x <= x2 && y1 <= y && y <= y2;\n      return inside;\n    };\n\n    var transform = function transform(x, y, size, angle, translation) {\n      var xRotated = x * Math.cos(angle) - y * Math.sin(angle);\n      var yRotated = x * Math.sin(angle) + y * Math.cos(angle);\n      var xScaled = xRotated * size;\n      var yScaled = yRotated * size;\n      var xTranslated = xScaled + translation.x;\n      var yTranslated = yScaled + translation.y;\n      return {\n        x: xTranslated,\n        y: yTranslated\n      };\n    };\n\n    var transformPoints = function transformPoints(pts, size, angle, translation) {\n      var retPts = [];\n\n      for (var i = 0; i < pts.length; i += 2) {\n        var x = pts[i];\n        var y = pts[i + 1];\n        retPts.push(transform(x, y, size, angle, translation));\n      }\n\n      return retPts;\n    };\n\n    var pointsToArr = function pointsToArr(pts) {\n      var ret = [];\n\n      for (var i = 0; i < pts.length; i++) {\n        var p = pts[i];\n        ret.push(p.x, p.y);\n      }\n\n      return ret;\n    };\n\n    var standardGap = function standardGap(edge) {\n      return edge.pstyle('width').pfValue * edge.pstyle('arrow-scale').pfValue * 2;\n    };\n\n    var defineArrowShape = function defineArrowShape(name, defn) {\n      if (string(defn)) {\n        defn = arrowShapes[defn];\n      }\n\n      arrowShapes[name] = extend({\n        name: name,\n        points: [-0.15, -0.3, 0.15, -0.3, 0.15, 0.3, -0.15, 0.3],\n        collide: function collide(x, y, size, angle, translation, padding) {\n          var points = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));\n          var inside = pointInsidePolygonPoints(x, y, points);\n          return inside;\n        },\n        roughCollide: bbCollide,\n        draw: function draw(context, size, angle, translation) {\n          var points = transformPoints(this.points, size, angle, translation);\n          renderer.arrowShapeImpl('polygon')(context, points);\n        },\n        spacing: function spacing(edge) {\n          return 0;\n        },\n        gap: standardGap\n      }, defn);\n    };\n\n    defineArrowShape('none', {\n      collide: falsify,\n      roughCollide: falsify,\n      draw: noop$1,\n      spacing: zeroify,\n      gap: zeroify\n    });\n    defineArrowShape('triangle', {\n      points: [-0.15, -0.3, 0, 0, 0.15, -0.3]\n    });\n    defineArrowShape('arrow', 'triangle');\n    defineArrowShape('triangle-backcurve', {\n      points: arrowShapes['triangle'].points,\n      controlPoint: [0, -0.15],\n      roughCollide: bbCollide,\n      draw: function draw(context, size, angle, translation, edgeWidth) {\n        var ptsTrans = transformPoints(this.points, size, angle, translation);\n        var ctrlPt = this.controlPoint;\n        var ctrlPtTrans = transform(ctrlPt[0], ctrlPt[1], size, angle, translation);\n        renderer.arrowShapeImpl(this.name)(context, ptsTrans, ctrlPtTrans);\n      },\n      gap: function gap(edge) {\n        return standardGap(edge) * 0.8;\n      }\n    });\n    defineArrowShape('triangle-tee', {\n      points: [0, 0, 0.15, -0.3, -0.15, -0.3, 0, 0],\n      pointsTee: [-0.15, -0.4, -0.15, -0.5, 0.15, -0.5, 0.15, -0.4],\n      collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {\n        var triPts = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));\n        var teePts = pointsToArr(transformPoints(this.pointsTee, size + 2 * padding, angle, translation));\n        var inside = pointInsidePolygonPoints(x, y, triPts) || pointInsidePolygonPoints(x, y, teePts);\n        return inside;\n      },\n      draw: function draw(context, size, angle, translation, edgeWidth) {\n        var triPts = transformPoints(this.points, size, angle, translation);\n        var teePts = transformPoints(this.pointsTee, size, angle, translation);\n        renderer.arrowShapeImpl(this.name)(context, triPts, teePts);\n      }\n    });\n    defineArrowShape('circle-triangle', {\n      radius: 0.15,\n      pointsTr: [0, -0.15, 0.15, -0.45, -0.15, -0.45, 0, -0.15],\n      collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {\n        var t = translation;\n        var circleInside = Math.pow(t.x - x, 2) + Math.pow(t.y - y, 2) <= Math.pow((size + 2 * padding) * this.radius, 2);\n        var triPts = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));\n        return pointInsidePolygonPoints(x, y, triPts) || circleInside;\n      },\n      draw: function draw(context, size, angle, translation, edgeWidth) {\n        var triPts = transformPoints(this.pointsTr, size, angle, translation);\n        renderer.arrowShapeImpl(this.name)(context, triPts, translation.x, translation.y, this.radius * size);\n      },\n      spacing: function spacing(edge) {\n        return renderer.getArrowWidth(edge.pstyle('width').pfValue, edge.pstyle('arrow-scale').value) * this.radius;\n      }\n    });\n    defineArrowShape('triangle-cross', {\n      points: [0, 0, 0.15, -0.3, -0.15, -0.3, 0, 0],\n      baseCrossLinePts: [-0.15, -0.4, // first half of the rectangle\n      -0.15, -0.4, 0.15, -0.4, // second half of the rectangle\n      0.15, -0.4],\n      crossLinePts: function crossLinePts(size, edgeWidth) {\n        // shift points so that the distance between the cross points matches edge width\n        var p = this.baseCrossLinePts.slice();\n        var shiftFactor = edgeWidth / size;\n        var y0 = 3;\n        var y1 = 5;\n        p[y0] = p[y0] - shiftFactor;\n        p[y1] = p[y1] - shiftFactor;\n        return p;\n      },\n      collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {\n        var triPts = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));\n        var teePts = pointsToArr(transformPoints(this.crossLinePts(size, edgeWidth), size + 2 * padding, angle, translation));\n        var inside = pointInsidePolygonPoints(x, y, triPts) || pointInsidePolygonPoints(x, y, teePts);\n        return inside;\n      },\n      draw: function draw(context, size, angle, translation, edgeWidth) {\n        var triPts = transformPoints(this.points, size, angle, translation);\n        var crossLinePts = transformPoints(this.crossLinePts(size, edgeWidth), size, angle, translation);\n        renderer.arrowShapeImpl(this.name)(context, triPts, crossLinePts);\n      }\n    });\n    defineArrowShape('vee', {\n      points: [-0.15, -0.3, 0, 0, 0.15, -0.3, 0, -0.15],\n      gap: function gap(edge) {\n        return standardGap(edge) * 0.525;\n      }\n    });\n    defineArrowShape('circle', {\n      radius: 0.15,\n      collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {\n        var t = translation;\n        var inside = Math.pow(t.x - x, 2) + Math.pow(t.y - y, 2) <= Math.pow((size + 2 * padding) * this.radius, 2);\n        return inside;\n      },\n      draw: function draw(context, size, angle, translation, edgeWidth) {\n        renderer.arrowShapeImpl(this.name)(context, translation.x, translation.y, this.radius * size);\n      },\n      spacing: function spacing(edge) {\n        return renderer.getArrowWidth(edge.pstyle('width').pfValue, edge.pstyle('arrow-scale').value) * this.radius;\n      }\n    });\n    defineArrowShape('tee', {\n      points: [-0.15, 0, -0.15, -0.1, 0.15, -0.1, 0.15, 0],\n      spacing: function spacing(edge) {\n        return 1;\n      },\n      gap: function gap(edge) {\n        return 1;\n      }\n    });\n    defineArrowShape('square', {\n      points: [-0.15, 0.00, 0.15, 0.00, 0.15, -0.3, -0.15, -0.3]\n    });\n    defineArrowShape('diamond', {\n      points: [-0.15, -0.15, 0, -0.3, 0.15, -0.15, 0, 0],\n      gap: function gap(edge) {\n        return edge.pstyle('width').pfValue * edge.pstyle('arrow-scale').value;\n      }\n    });\n    defineArrowShape('chevron', {\n      points: [0, 0, -0.15, -0.15, -0.1, -0.2, 0, -0.1, 0.1, -0.2, 0.15, -0.15],\n      gap: function gap(edge) {\n        return 0.95 * edge.pstyle('width').pfValue * edge.pstyle('arrow-scale').value;\n      }\n    });\n  };\n\n  var BRp$e = {}; // Project mouse\n\n  BRp$e.projectIntoViewport = function (clientX, clientY) {\n    var cy = this.cy;\n    var offsets = this.findContainerClientCoords();\n    var offsetLeft = offsets[0];\n    var offsetTop = offsets[1];\n    var scale = offsets[4];\n    var pan = cy.pan();\n    var zoom = cy.zoom();\n    var x = ((clientX - offsetLeft) / scale - pan.x) / zoom;\n    var y = ((clientY - offsetTop) / scale - pan.y) / zoom;\n    return [x, y];\n  };\n\n  BRp$e.findContainerClientCoords = function () {\n    if (this.containerBB) {\n      return this.containerBB;\n    }\n\n    var container = this.container;\n    var rect = container.getBoundingClientRect();\n    var style = window$1.getComputedStyle(container);\n\n    var styleValue = function styleValue(name) {\n      return parseFloat(style.getPropertyValue(name));\n    };\n\n    var padding = {\n      left: styleValue('padding-left'),\n      right: styleValue('padding-right'),\n      top: styleValue('padding-top'),\n      bottom: styleValue('padding-bottom')\n    };\n    var border = {\n      left: styleValue('border-left-width'),\n      right: styleValue('border-right-width'),\n      top: styleValue('border-top-width'),\n      bottom: styleValue('border-bottom-width')\n    };\n    var clientWidth = container.clientWidth;\n    var clientHeight = container.clientHeight;\n    var paddingHor = padding.left + padding.right;\n    var paddingVer = padding.top + padding.bottom;\n    var borderHor = border.left + border.right;\n    var scale = rect.width / (clientWidth + borderHor);\n    var unscaledW = clientWidth - paddingHor;\n    var unscaledH = clientHeight - paddingVer;\n    var left = rect.left + padding.left + border.left;\n    var top = rect.top + padding.top + border.top;\n    return this.containerBB = [left, top, unscaledW, unscaledH, scale];\n  };\n\n  BRp$e.invalidateContainerClientCoordsCache = function () {\n    this.containerBB = null;\n  };\n\n  BRp$e.findNearestElement = function (x, y, interactiveElementsOnly, isTouch) {\n    return this.findNearestElements(x, y, interactiveElementsOnly, isTouch)[0];\n  };\n\n  BRp$e.findNearestElements = function (x, y, interactiveElementsOnly, isTouch) {\n    var self = this;\n    var r = this;\n    var eles = r.getCachedZSortedEles();\n    var near = []; // 1 node max, 1 edge max\n\n    var zoom = r.cy.zoom();\n    var hasCompounds = r.cy.hasCompoundNodes();\n    var edgeThreshold = (isTouch ? 24 : 8) / zoom;\n    var nodeThreshold = (isTouch ? 8 : 2) / zoom;\n    var labelThreshold = (isTouch ? 8 : 2) / zoom;\n    var minSqDist = Infinity;\n    var nearEdge;\n    var nearNode;\n\n    if (interactiveElementsOnly) {\n      eles = eles.interactive;\n    }\n\n    function addEle(ele, sqDist) {\n      if (ele.isNode()) {\n        if (nearNode) {\n          return; // can't replace node\n        } else {\n          nearNode = ele;\n          near.push(ele);\n        }\n      }\n\n      if (ele.isEdge() && (sqDist == null || sqDist < minSqDist)) {\n        if (nearEdge) {\n          // then replace existing edge\n          // can replace only if same z-index\n          if (nearEdge.pstyle('z-compound-depth').value === ele.pstyle('z-compound-depth').value && nearEdge.pstyle('z-compound-depth').value === ele.pstyle('z-compound-depth').value) {\n            for (var i = 0; i < near.length; i++) {\n              if (near[i].isEdge()) {\n                near[i] = ele;\n                nearEdge = ele;\n                minSqDist = sqDist != null ? sqDist : minSqDist;\n                break;\n              }\n            }\n          }\n        } else {\n          near.push(ele);\n          nearEdge = ele;\n          minSqDist = sqDist != null ? sqDist : minSqDist;\n        }\n      }\n    }\n\n    function checkNode(node) {\n      var width = node.outerWidth() + 2 * nodeThreshold;\n      var height = node.outerHeight() + 2 * nodeThreshold;\n      var hw = width / 2;\n      var hh = height / 2;\n      var pos = node.position();\n\n      if (pos.x - hw <= x && x <= pos.x + hw // bb check x\n      && pos.y - hh <= y && y <= pos.y + hh // bb check y\n      ) {\n        var shape = r.nodeShapes[self.getNodeShape(node)];\n\n        if (shape.checkPoint(x, y, 0, width, height, pos.x, pos.y)) {\n          addEle(node, 0);\n          return true;\n        }\n      }\n    }\n\n    function checkEdge(edge) {\n      var _p = edge._private;\n      var rs = _p.rscratch;\n      var styleWidth = edge.pstyle('width').pfValue;\n      var scale = edge.pstyle('arrow-scale').value;\n      var width = styleWidth / 2 + edgeThreshold; // more like a distance radius from centre\n\n      var widthSq = width * width;\n      var width2 = width * 2;\n      var src = _p.source;\n      var tgt = _p.target;\n      var sqDist;\n\n      if (rs.edgeType === 'segments' || rs.edgeType === 'straight' || rs.edgeType === 'haystack') {\n        var pts = rs.allpts;\n\n        for (var i = 0; i + 3 < pts.length; i += 2) {\n          if (inLineVicinity(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3], width2) && widthSq > (sqDist = sqdistToFiniteLine(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3]))) {\n            addEle(edge, sqDist);\n            return true;\n          }\n        }\n      } else if (rs.edgeType === 'bezier' || rs.edgeType === 'multibezier' || rs.edgeType === 'self' || rs.edgeType === 'compound') {\n        var pts = rs.allpts;\n\n        for (var i = 0; i + 5 < rs.allpts.length; i += 4) {\n          if (inBezierVicinity(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3], pts[i + 4], pts[i + 5], width2) && widthSq > (sqDist = sqdistToQuadraticBezier(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3], pts[i + 4], pts[i + 5]))) {\n            addEle(edge, sqDist);\n            return true;\n          }\n        }\n      } // if we're close to the edge but didn't hit it, maybe we hit its arrows\n\n\n      var src = src || _p.source;\n      var tgt = tgt || _p.target;\n      var arSize = self.getArrowWidth(styleWidth, scale);\n      var arrows = [{\n        name: 'source',\n        x: rs.arrowStartX,\n        y: rs.arrowStartY,\n        angle: rs.srcArrowAngle\n      }, {\n        name: 'target',\n        x: rs.arrowEndX,\n        y: rs.arrowEndY,\n        angle: rs.tgtArrowAngle\n      }, {\n        name: 'mid-source',\n        x: rs.midX,\n        y: rs.midY,\n        angle: rs.midsrcArrowAngle\n      }, {\n        name: 'mid-target',\n        x: rs.midX,\n        y: rs.midY,\n        angle: rs.midtgtArrowAngle\n      }];\n\n      for (var i = 0; i < arrows.length; i++) {\n        var ar = arrows[i];\n        var shape = r.arrowShapes[edge.pstyle(ar.name + '-arrow-shape').value];\n        var edgeWidth = edge.pstyle('width').pfValue;\n\n        if (shape.roughCollide(x, y, arSize, ar.angle, {\n          x: ar.x,\n          y: ar.y\n        }, edgeWidth, edgeThreshold) && shape.collide(x, y, arSize, ar.angle, {\n          x: ar.x,\n          y: ar.y\n        }, edgeWidth, edgeThreshold)) {\n          addEle(edge);\n          return true;\n        }\n      } // for compound graphs, hitting edge may actually want a connected node instead (b/c edge may have greater z-index precedence)\n\n\n      if (hasCompounds && near.length > 0) {\n        checkNode(src);\n        checkNode(tgt);\n      }\n    }\n\n    function preprop(obj, name, pre) {\n      return getPrefixedProperty(obj, name, pre);\n    }\n\n    function checkLabel(ele, prefix) {\n      var _p = ele._private;\n      var th = labelThreshold;\n      var prefixDash;\n\n      if (prefix) {\n        prefixDash = prefix + '-';\n      } else {\n        prefixDash = '';\n      }\n\n      ele.boundingBox();\n      var bb = _p.labelBounds[prefix || 'main'];\n      var text = ele.pstyle(prefixDash + 'label').value;\n      var eventsEnabled = ele.pstyle('text-events').strValue === 'yes';\n\n      if (!eventsEnabled || !text) {\n        return;\n      }\n\n      var lx = preprop(_p.rscratch, 'labelX', prefix);\n      var ly = preprop(_p.rscratch, 'labelY', prefix);\n      var theta = preprop(_p.rscratch, 'labelAngle', prefix);\n      var ox = ele.pstyle(prefixDash + 'text-margin-x').pfValue;\n      var oy = ele.pstyle(prefixDash + 'text-margin-y').pfValue;\n      var lx1 = bb.x1 - th - ox; // (-ox, -oy) as bb already includes margin\n\n      var lx2 = bb.x2 + th - ox; // and rotation is about (lx, ly)\n\n      var ly1 = bb.y1 - th - oy;\n      var ly2 = bb.y2 + th - oy;\n\n      if (theta) {\n        var cos = Math.cos(theta);\n        var sin = Math.sin(theta);\n\n        var rotate = function rotate(x, y) {\n          x = x - lx;\n          y = y - ly;\n          return {\n            x: x * cos - y * sin + lx,\n            y: x * sin + y * cos + ly\n          };\n        };\n\n        var px1y1 = rotate(lx1, ly1);\n        var px1y2 = rotate(lx1, ly2);\n        var px2y1 = rotate(lx2, ly1);\n        var px2y2 = rotate(lx2, ly2);\n        var points = [// with the margin added after the rotation is applied\n        px1y1.x + ox, px1y1.y + oy, px2y1.x + ox, px2y1.y + oy, px2y2.x + ox, px2y2.y + oy, px1y2.x + ox, px1y2.y + oy];\n\n        if (pointInsidePolygonPoints(x, y, points)) {\n          addEle(ele);\n          return true;\n        }\n      } else {\n        // do a cheaper bb check\n        if (inBoundingBox(bb, x, y)) {\n          addEle(ele);\n          return true;\n        }\n      }\n    }\n\n    for (var i = eles.length - 1; i >= 0; i--) {\n      // reverse order for precedence\n      var ele = eles[i];\n\n      if (ele.isNode()) {\n        checkNode(ele) || checkLabel(ele);\n      } else {\n        // then edge\n        checkEdge(ele) || checkLabel(ele) || checkLabel(ele, 'source') || checkLabel(ele, 'target');\n      }\n    }\n\n    return near;\n  }; // 'Give me everything from this box'\n\n\n  BRp$e.getAllInBox = function (x1, y1, x2, y2) {\n    var eles = this.getCachedZSortedEles().interactive;\n    var box = [];\n    var x1c = Math.min(x1, x2);\n    var x2c = Math.max(x1, x2);\n    var y1c = Math.min(y1, y2);\n    var y2c = Math.max(y1, y2);\n    x1 = x1c;\n    x2 = x2c;\n    y1 = y1c;\n    y2 = y2c;\n    var boxBb = makeBoundingBox({\n      x1: x1,\n      y1: y1,\n      x2: x2,\n      y2: y2\n    });\n\n    for (var e = 0; e < eles.length; e++) {\n      var ele = eles[e];\n\n      if (ele.isNode()) {\n        var node = ele;\n        var nodeBb = node.boundingBox({\n          includeNodes: true,\n          includeEdges: false,\n          includeLabels: false\n        });\n\n        if (boundingBoxesIntersect(boxBb, nodeBb) && !boundingBoxInBoundingBox(nodeBb, boxBb)) {\n          box.push(node);\n        }\n      } else {\n        var edge = ele;\n        var _p = edge._private;\n        var rs = _p.rscratch;\n\n        if (rs.startX != null && rs.startY != null && !inBoundingBox(boxBb, rs.startX, rs.startY)) {\n          continue;\n        }\n\n        if (rs.endX != null && rs.endY != null && !inBoundingBox(boxBb, rs.endX, rs.endY)) {\n          continue;\n        }\n\n        if (rs.edgeType === 'bezier' || rs.edgeType === 'multibezier' || rs.edgeType === 'self' || rs.edgeType === 'compound' || rs.edgeType === 'segments' || rs.edgeType === 'haystack') {\n          var pts = _p.rstyle.bezierPts || _p.rstyle.linePts || _p.rstyle.haystackPts;\n          var allInside = true;\n\n          for (var i = 0; i < pts.length; i++) {\n            if (!pointInBoundingBox(boxBb, pts[i])) {\n              allInside = false;\n              break;\n            }\n          }\n\n          if (allInside) {\n            box.push(edge);\n          }\n        } else if (rs.edgeType === 'haystack' || rs.edgeType === 'straight') {\n          box.push(edge);\n        }\n      }\n    }\n\n    return box;\n  };\n\n  var BRp$d = {};\n\n  BRp$d.calculateArrowAngles = function (edge) {\n    var rs = edge._private.rscratch;\n    var isHaystack = rs.edgeType === 'haystack';\n    var isBezier = rs.edgeType === 'bezier';\n    var isMultibezier = rs.edgeType === 'multibezier';\n    var isSegments = rs.edgeType === 'segments';\n    var isCompound = rs.edgeType === 'compound';\n    var isSelf = rs.edgeType === 'self'; // Displacement gives direction for arrowhead orientation\n\n    var dispX, dispY;\n    var startX, startY, endX, endY, midX, midY;\n\n    if (isHaystack) {\n      startX = rs.haystackPts[0];\n      startY = rs.haystackPts[1];\n      endX = rs.haystackPts[2];\n      endY = rs.haystackPts[3];\n    } else {\n      startX = rs.arrowStartX;\n      startY = rs.arrowStartY;\n      endX = rs.arrowEndX;\n      endY = rs.arrowEndY;\n    }\n\n    midX = rs.midX;\n    midY = rs.midY; // source\n    //\n\n    if (isSegments) {\n      dispX = startX - rs.segpts[0];\n      dispY = startY - rs.segpts[1];\n    } else if (isMultibezier || isCompound || isSelf || isBezier) {\n      var pts = rs.allpts;\n      var bX = qbezierAt(pts[0], pts[2], pts[4], 0.1);\n      var bY = qbezierAt(pts[1], pts[3], pts[5], 0.1);\n      dispX = startX - bX;\n      dispY = startY - bY;\n    } else {\n      dispX = startX - midX;\n      dispY = startY - midY;\n    }\n\n    rs.srcArrowAngle = getAngleFromDisp(dispX, dispY); // mid target\n    //\n\n    var midX = rs.midX;\n    var midY = rs.midY;\n\n    if (isHaystack) {\n      midX = (startX + endX) / 2;\n      midY = (startY + endY) / 2;\n    }\n\n    dispX = endX - startX;\n    dispY = endY - startY;\n\n    if (isSegments) {\n      var pts = rs.allpts;\n\n      if (pts.length / 2 % 2 === 0) {\n        var i2 = pts.length / 2;\n        var i1 = i2 - 2;\n        dispX = pts[i2] - pts[i1];\n        dispY = pts[i2 + 1] - pts[i1 + 1];\n      } else {\n        var i2 = pts.length / 2 - 1;\n        var i1 = i2 - 2;\n        var i3 = i2 + 2;\n        dispX = pts[i2] - pts[i1];\n        dispY = pts[i2 + 1] - pts[i1 + 1];\n      }\n    } else if (isMultibezier || isCompound || isSelf) {\n      var pts = rs.allpts;\n      var cpts = rs.ctrlpts;\n      var bp0x, bp0y;\n      var bp1x, bp1y;\n\n      if (cpts.length / 2 % 2 === 0) {\n        var p0 = pts.length / 2 - 1; // startpt\n\n        var ic = p0 + 2;\n        var p1 = ic + 2;\n        bp0x = qbezierAt(pts[p0], pts[ic], pts[p1], 0.0);\n        bp0y = qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.0);\n        bp1x = qbezierAt(pts[p0], pts[ic], pts[p1], 0.0001);\n        bp1y = qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.0001);\n      } else {\n        var ic = pts.length / 2 - 1; // ctrpt\n\n        var p0 = ic - 2; // startpt\n\n        var p1 = ic + 2; // endpt\n\n        bp0x = qbezierAt(pts[p0], pts[ic], pts[p1], 0.4999);\n        bp0y = qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.4999);\n        bp1x = qbezierAt(pts[p0], pts[ic], pts[p1], 0.5);\n        bp1y = qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.5);\n      }\n\n      dispX = bp1x - bp0x;\n      dispY = bp1y - bp0y;\n    }\n\n    rs.midtgtArrowAngle = getAngleFromDisp(dispX, dispY);\n    rs.midDispX = dispX;\n    rs.midDispY = dispY; // mid source\n    //\n\n    dispX *= -1;\n    dispY *= -1;\n\n    if (isSegments) {\n      var pts = rs.allpts;\n\n      if (pts.length / 2 % 2 === 0) ; else {\n        var i2 = pts.length / 2 - 1;\n        var i3 = i2 + 2;\n        dispX = -(pts[i3] - pts[i2]);\n        dispY = -(pts[i3 + 1] - pts[i2 + 1]);\n      }\n    }\n\n    rs.midsrcArrowAngle = getAngleFromDisp(dispX, dispY); // target\n    //\n\n    if (isSegments) {\n      dispX = endX - rs.segpts[rs.segpts.length - 2];\n      dispY = endY - rs.segpts[rs.segpts.length - 1];\n    } else if (isMultibezier || isCompound || isSelf || isBezier) {\n      var pts = rs.allpts;\n      var l = pts.length;\n      var bX = qbezierAt(pts[l - 6], pts[l - 4], pts[l - 2], 0.9);\n      var bY = qbezierAt(pts[l - 5], pts[l - 3], pts[l - 1], 0.9);\n      dispX = endX - bX;\n      dispY = endY - bY;\n    } else {\n      dispX = endX - midX;\n      dispY = endY - midY;\n    }\n\n    rs.tgtArrowAngle = getAngleFromDisp(dispX, dispY);\n  };\n\n  BRp$d.getArrowWidth = BRp$d.getArrowHeight = function (edgeWidth, scale) {\n    var cache = this.arrowWidthCache = this.arrowWidthCache || {};\n    var cachedVal = cache[edgeWidth + ', ' + scale];\n\n    if (cachedVal) {\n      return cachedVal;\n    }\n\n    cachedVal = Math.max(Math.pow(edgeWidth * 13.37, 0.9), 29) * scale;\n    cache[edgeWidth + ', ' + scale] = cachedVal;\n    return cachedVal;\n  };\n\n  var BRp$c = {};\n\n  BRp$c.findHaystackPoints = function (edges) {\n    for (var i = 0; i < edges.length; i++) {\n      var edge = edges[i];\n      var _p = edge._private;\n      var rs = _p.rscratch;\n\n      if (!rs.haystack) {\n        var angle = Math.random() * 2 * Math.PI;\n        rs.source = {\n          x: Math.cos(angle),\n          y: Math.sin(angle)\n        };\n        angle = Math.random() * 2 * Math.PI;\n        rs.target = {\n          x: Math.cos(angle),\n          y: Math.sin(angle)\n        };\n      }\n\n      var src = _p.source;\n      var tgt = _p.target;\n      var srcPos = src.position();\n      var tgtPos = tgt.position();\n      var srcW = src.width();\n      var tgtW = tgt.width();\n      var srcH = src.height();\n      var tgtH = tgt.height();\n      var radius = edge.pstyle('haystack-radius').value;\n      var halfRadius = radius / 2; // b/c have to half width/height\n\n      rs.haystackPts = rs.allpts = [rs.source.x * srcW * halfRadius + srcPos.x, rs.source.y * srcH * halfRadius + srcPos.y, rs.target.x * tgtW * halfRadius + tgtPos.x, rs.target.y * tgtH * halfRadius + tgtPos.y];\n      rs.midX = (rs.allpts[0] + rs.allpts[2]) / 2;\n      rs.midY = (rs.allpts[1] + rs.allpts[3]) / 2; // always override as haystack in case set to different type previously\n\n      rs.edgeType = 'haystack';\n      rs.haystack = true;\n      this.storeEdgeProjections(edge);\n      this.calculateArrowAngles(edge);\n      this.recalculateEdgeLabelProjections(edge);\n      this.calculateLabelAngles(edge);\n    }\n  };\n\n  BRp$c.findSegmentsPoints = function (edge, pairInfo) {\n    // Segments (multiple straight lines)\n    var rs = edge._private.rscratch;\n    var posPts = pairInfo.posPts,\n        intersectionPts = pairInfo.intersectionPts,\n        vectorNormInverse = pairInfo.vectorNormInverse;\n    var edgeDistances = edge.pstyle('edge-distances').value;\n    var segmentWs = edge.pstyle('segment-weights');\n    var segmentDs = edge.pstyle('segment-distances');\n    var segmentsN = Math.min(segmentWs.pfValue.length, segmentDs.pfValue.length);\n    rs.edgeType = 'segments';\n    rs.segpts = [];\n\n    for (var s = 0; s < segmentsN; s++) {\n      var w = segmentWs.pfValue[s];\n      var d = segmentDs.pfValue[s];\n      var w1 = 1 - w;\n      var w2 = w;\n      var midptPts = edgeDistances === 'node-position' ? posPts : intersectionPts;\n      var adjustedMidpt = {\n        x: midptPts.x1 * w1 + midptPts.x2 * w2,\n        y: midptPts.y1 * w1 + midptPts.y2 * w2\n      };\n      rs.segpts.push(adjustedMidpt.x + vectorNormInverse.x * d, adjustedMidpt.y + vectorNormInverse.y * d);\n    }\n  };\n\n  BRp$c.findLoopPoints = function (edge, pairInfo, i, edgeIsUnbundled) {\n    // Self-edge\n    var rs = edge._private.rscratch;\n    var dirCounts = pairInfo.dirCounts,\n        srcPos = pairInfo.srcPos;\n    var ctrlptDists = edge.pstyle('control-point-distances');\n    var ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[0] : undefined;\n    var loopDir = edge.pstyle('loop-direction').pfValue;\n    var loopSwp = edge.pstyle('loop-sweep').pfValue;\n    var stepSize = edge.pstyle('control-point-step-size').pfValue;\n    rs.edgeType = 'self';\n    var j = i;\n    var loopDist = stepSize;\n\n    if (edgeIsUnbundled) {\n      j = 0;\n      loopDist = ctrlptDist;\n    }\n\n    var loopAngle = loopDir - Math.PI / 2;\n    var outAngle = loopAngle - loopSwp / 2;\n    var inAngle = loopAngle + loopSwp / 2; // increase by step size for overlapping loops, keyed on direction and sweep values\n\n    var dc = String(loopDir + '_' + loopSwp);\n    j = dirCounts[dc] === undefined ? dirCounts[dc] = 0 : ++dirCounts[dc];\n    rs.ctrlpts = [srcPos.x + Math.cos(outAngle) * 1.4 * loopDist * (j / 3 + 1), srcPos.y + Math.sin(outAngle) * 1.4 * loopDist * (j / 3 + 1), srcPos.x + Math.cos(inAngle) * 1.4 * loopDist * (j / 3 + 1), srcPos.y + Math.sin(inAngle) * 1.4 * loopDist * (j / 3 + 1)];\n  };\n\n  BRp$c.findCompoundLoopPoints = function (edge, pairInfo, i, edgeIsUnbundled) {\n    // Compound edge\n    var rs = edge._private.rscratch;\n    rs.edgeType = 'compound';\n    var srcPos = pairInfo.srcPos,\n        tgtPos = pairInfo.tgtPos,\n        srcW = pairInfo.srcW,\n        srcH = pairInfo.srcH,\n        tgtW = pairInfo.tgtW,\n        tgtH = pairInfo.tgtH;\n    var stepSize = edge.pstyle('control-point-step-size').pfValue;\n    var ctrlptDists = edge.pstyle('control-point-distances');\n    var ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[0] : undefined;\n    var j = i;\n    var loopDist = stepSize;\n\n    if (edgeIsUnbundled) {\n      j = 0;\n      loopDist = ctrlptDist;\n    }\n\n    var loopW = 50;\n    var loopaPos = {\n      x: srcPos.x - srcW / 2,\n      y: srcPos.y - srcH / 2\n    };\n    var loopbPos = {\n      x: tgtPos.x - tgtW / 2,\n      y: tgtPos.y - tgtH / 2\n    };\n    var loopPos = {\n      x: Math.min(loopaPos.x, loopbPos.x),\n      y: Math.min(loopaPos.y, loopbPos.y)\n    }; // avoids cases with impossible beziers\n\n    var minCompoundStretch = 0.5;\n    var compoundStretchA = Math.max(minCompoundStretch, Math.log(srcW * 0.01));\n    var compoundStretchB = Math.max(minCompoundStretch, Math.log(tgtW * 0.01));\n    rs.ctrlpts = [loopPos.x, loopPos.y - (1 + Math.pow(loopW, 1.12) / 100) * loopDist * (j / 3 + 1) * compoundStretchA, loopPos.x - (1 + Math.pow(loopW, 1.12) / 100) * loopDist * (j / 3 + 1) * compoundStretchB, loopPos.y];\n  };\n\n  BRp$c.findStraightEdgePoints = function (edge) {\n    // Straight edge within bundle\n    edge._private.rscratch.edgeType = 'straight';\n  };\n\n  BRp$c.findBezierPoints = function (edge, pairInfo, i, edgeIsUnbundled, edgeIsSwapped) {\n    var rs = edge._private.rscratch;\n    var vectorNormInverse = pairInfo.vectorNormInverse,\n        posPts = pairInfo.posPts,\n        intersectionPts = pairInfo.intersectionPts;\n    var edgeDistances = edge.pstyle('edge-distances').value;\n    var stepSize = edge.pstyle('control-point-step-size').pfValue;\n    var ctrlptDists = edge.pstyle('control-point-distances');\n    var ctrlptWs = edge.pstyle('control-point-weights');\n    var bezierN = ctrlptDists && ctrlptWs ? Math.min(ctrlptDists.value.length, ctrlptWs.value.length) : 1;\n    var ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[0] : undefined;\n    var ctrlptWeight = ctrlptWs.value[0]; // (Multi)bezier\n\n    var multi = edgeIsUnbundled;\n    rs.edgeType = multi ? 'multibezier' : 'bezier';\n    rs.ctrlpts = [];\n\n    for (var b = 0; b < bezierN; b++) {\n      var normctrlptDist = (0.5 - pairInfo.eles.length / 2 + i) * stepSize * (edgeIsSwapped ? -1 : 1);\n      var manctrlptDist = void 0;\n      var sign = signum(normctrlptDist);\n\n      if (multi) {\n        ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[b] : stepSize; // fall back on step size\n\n        ctrlptWeight = ctrlptWs.value[b];\n      }\n\n      if (edgeIsUnbundled) {\n        // multi or single unbundled\n        manctrlptDist = ctrlptDist;\n      } else {\n        manctrlptDist = ctrlptDist !== undefined ? sign * ctrlptDist : undefined;\n      }\n\n      var distanceFromMidpoint = manctrlptDist !== undefined ? manctrlptDist : normctrlptDist;\n      var w1 = 1 - ctrlptWeight;\n      var w2 = ctrlptWeight;\n      var midptPts = edgeDistances === 'node-position' ? posPts : intersectionPts;\n      var adjustedMidpt = {\n        x: midptPts.x1 * w1 + midptPts.x2 * w2,\n        y: midptPts.y1 * w1 + midptPts.y2 * w2\n      };\n      rs.ctrlpts.push(adjustedMidpt.x + vectorNormInverse.x * distanceFromMidpoint, adjustedMidpt.y + vectorNormInverse.y * distanceFromMidpoint);\n    }\n  };\n\n  BRp$c.findTaxiPoints = function (edge, pairInfo) {\n    // Taxicab geometry with two turns maximum\n    var rs = edge._private.rscratch;\n    rs.edgeType = 'segments';\n    var VERTICAL = 'vertical';\n    var HORIZONTAL = 'horizontal';\n    var LEFTWARD = 'leftward';\n    var RIGHTWARD = 'rightward';\n    var DOWNWARD = 'downward';\n    var UPWARD = 'upward';\n    var AUTO = 'auto';\n    var posPts = pairInfo.posPts,\n        srcW = pairInfo.srcW,\n        srcH = pairInfo.srcH,\n        tgtW = pairInfo.tgtW,\n        tgtH = pairInfo.tgtH;\n    var edgeDistances = edge.pstyle('edge-distances').value;\n    var dIncludesNodeBody = edgeDistances !== 'node-position';\n    var taxiDir = edge.pstyle('taxi-direction').value;\n    var rawTaxiDir = taxiDir; // unprocessed value\n\n    var taxiTurn = edge.pstyle('taxi-turn');\n    var turnIsPercent = taxiTurn.units === '%';\n    var taxiTurnPfVal = taxiTurn.pfValue;\n    var turnIsNegative = taxiTurnPfVal < 0; // i.e. from target side\n\n    var minD = edge.pstyle('taxi-turn-min-distance').pfValue;\n    var dw = dIncludesNodeBody ? (srcW + tgtW) / 2 : 0;\n    var dh = dIncludesNodeBody ? (srcH + tgtH) / 2 : 0;\n    var pdx = posPts.x2 - posPts.x1;\n    var pdy = posPts.y2 - posPts.y1; // take away the effective w/h from the magnitude of the delta value\n\n    var subDWH = function subDWH(dxy, dwh) {\n      if (dxy > 0) {\n        return Math.max(dxy - dwh, 0);\n      } else {\n        return Math.min(dxy + dwh, 0);\n      }\n    };\n\n    var dx = subDWH(pdx, dw);\n    var dy = subDWH(pdy, dh);\n    var isExplicitDir = false;\n\n    if (rawTaxiDir === AUTO) {\n      taxiDir = Math.abs(dx) > Math.abs(dy) ? HORIZONTAL : VERTICAL;\n    } else if (rawTaxiDir === UPWARD || rawTaxiDir === DOWNWARD) {\n      taxiDir = VERTICAL;\n      isExplicitDir = true;\n    } else if (rawTaxiDir === LEFTWARD || rawTaxiDir === RIGHTWARD) {\n      taxiDir = HORIZONTAL;\n      isExplicitDir = true;\n    }\n\n    var isVert = taxiDir === VERTICAL;\n    var l = isVert ? dy : dx;\n    var pl = isVert ? pdy : pdx;\n    var sgnL = signum(pl);\n    var forcedDir = false;\n\n    if (!(isExplicitDir && (turnIsPercent || turnIsNegative)) // forcing in this case would cause weird growing in the opposite direction\n    && (rawTaxiDir === DOWNWARD && pl < 0 || rawTaxiDir === UPWARD && pl > 0 || rawTaxiDir === LEFTWARD && pl > 0 || rawTaxiDir === RIGHTWARD && pl < 0)) {\n      sgnL *= -1;\n      l = sgnL * Math.abs(l);\n      forcedDir = true;\n    }\n\n    var d;\n\n    if (turnIsPercent) {\n      var p = taxiTurnPfVal < 0 ? 1 + taxiTurnPfVal : taxiTurnPfVal;\n      d = p * l;\n    } else {\n      var k = taxiTurnPfVal < 0 ? l : 0;\n      d = k + taxiTurnPfVal * sgnL;\n    }\n\n    var getIsTooClose = function getIsTooClose(d) {\n      return Math.abs(d) < minD || Math.abs(d) >= Math.abs(l);\n    };\n\n    var isTooCloseSrc = getIsTooClose(d);\n    var isTooCloseTgt = getIsTooClose(Math.abs(l) - Math.abs(d));\n    var isTooClose = isTooCloseSrc || isTooCloseTgt;\n\n    if (isTooClose && !forcedDir) {\n      // non-ideal routing\n      if (isVert) {\n        // vertical fallbacks\n        var lShapeInsideSrc = Math.abs(pl) <= srcH / 2;\n        var lShapeInsideTgt = Math.abs(pdx) <= tgtW / 2;\n\n        if (lShapeInsideSrc) {\n          // horizontal Z-shape (direction not respected)\n          var x = (posPts.x1 + posPts.x2) / 2;\n          var y1 = posPts.y1,\n              y2 = posPts.y2;\n          rs.segpts = [x, y1, x, y2];\n        } else if (lShapeInsideTgt) {\n          // vertical Z-shape (distance not respected)\n          var y = (posPts.y1 + posPts.y2) / 2;\n          var x1 = posPts.x1,\n              x2 = posPts.x2;\n          rs.segpts = [x1, y, x2, y];\n        } else {\n          // L-shape fallback (turn distance not respected, but works well with tree siblings)\n          rs.segpts = [posPts.x1, posPts.y2];\n        }\n      } else {\n        // horizontal fallbacks\n        var _lShapeInsideSrc = Math.abs(pl) <= srcW / 2;\n\n        var _lShapeInsideTgt = Math.abs(pdy) <= tgtH / 2;\n\n        if (_lShapeInsideSrc) {\n          // vertical Z-shape (direction not respected)\n          var _y = (posPts.y1 + posPts.y2) / 2;\n\n          var _x = posPts.x1,\n              _x2 = posPts.x2;\n          rs.segpts = [_x, _y, _x2, _y];\n        } else if (_lShapeInsideTgt) {\n          // horizontal Z-shape (turn distance not respected)\n          var _x3 = (posPts.x1 + posPts.x2) / 2;\n\n          var _y2 = posPts.y1,\n              _y3 = posPts.y2;\n          rs.segpts = [_x3, _y2, _x3, _y3];\n        } else {\n          // L-shape (turn distance not respected, but works well for tree siblings)\n          rs.segpts = [posPts.x2, posPts.y1];\n        }\n      }\n    } else {\n      // ideal routing\n      if (isVert) {\n        var _y4 = posPts.y1 + d + (dIncludesNodeBody ? srcH / 2 * sgnL : 0);\n\n        var _x4 = posPts.x1,\n            _x5 = posPts.x2;\n        rs.segpts = [_x4, _y4, _x5, _y4];\n      } else {\n        // horizontal\n        var _x6 = posPts.x1 + d + (dIncludesNodeBody ? srcW / 2 * sgnL : 0);\n\n        var _y5 = posPts.y1,\n            _y6 = posPts.y2;\n        rs.segpts = [_x6, _y5, _x6, _y6];\n      }\n    }\n  };\n\n  BRp$c.tryToCorrectInvalidPoints = function (edge, pairInfo) {\n    var rs = edge._private.rscratch; // can only correct beziers for now...\n\n    if (rs.edgeType === 'bezier') {\n      var srcPos = pairInfo.srcPos,\n          tgtPos = pairInfo.tgtPos,\n          srcW = pairInfo.srcW,\n          srcH = pairInfo.srcH,\n          tgtW = pairInfo.tgtW,\n          tgtH = pairInfo.tgtH,\n          srcShape = pairInfo.srcShape,\n          tgtShape = pairInfo.tgtShape;\n      var badStart = !number$1(rs.startX) || !number$1(rs.startY);\n      var badAStart = !number$1(rs.arrowStartX) || !number$1(rs.arrowStartY);\n      var badEnd = !number$1(rs.endX) || !number$1(rs.endY);\n      var badAEnd = !number$1(rs.arrowEndX) || !number$1(rs.arrowEndY);\n      var minCpADistFactor = 3;\n      var arrowW = this.getArrowWidth(edge.pstyle('width').pfValue, edge.pstyle('arrow-scale').value) * this.arrowShapeWidth;\n      var minCpADist = minCpADistFactor * arrowW;\n      var startACpDist = dist({\n        x: rs.ctrlpts[0],\n        y: rs.ctrlpts[1]\n      }, {\n        x: rs.startX,\n        y: rs.startY\n      });\n      var closeStartACp = startACpDist < minCpADist;\n      var endACpDist = dist({\n        x: rs.ctrlpts[0],\n        y: rs.ctrlpts[1]\n      }, {\n        x: rs.endX,\n        y: rs.endY\n      });\n      var closeEndACp = endACpDist < minCpADist;\n      var overlapping = false;\n\n      if (badStart || badAStart || closeStartACp) {\n        overlapping = true; // project control point along line from src centre to outside the src shape\n        // (otherwise intersection will yield nothing)\n\n        var cpD = {\n          // delta\n          x: rs.ctrlpts[0] - srcPos.x,\n          y: rs.ctrlpts[1] - srcPos.y\n        };\n        var cpL = Math.sqrt(cpD.x * cpD.x + cpD.y * cpD.y); // length of line\n\n        var cpM = {\n          // normalised delta\n          x: cpD.x / cpL,\n          y: cpD.y / cpL\n        };\n        var radius = Math.max(srcW, srcH);\n        var cpProj = {\n          // *2 radius guarantees outside shape\n          x: rs.ctrlpts[0] + cpM.x * 2 * radius,\n          y: rs.ctrlpts[1] + cpM.y * 2 * radius\n        };\n        var srcCtrlPtIntn = srcShape.intersectLine(srcPos.x, srcPos.y, srcW, srcH, cpProj.x, cpProj.y, 0);\n\n        if (closeStartACp) {\n          rs.ctrlpts[0] = rs.ctrlpts[0] + cpM.x * (minCpADist - startACpDist);\n          rs.ctrlpts[1] = rs.ctrlpts[1] + cpM.y * (minCpADist - startACpDist);\n        } else {\n          rs.ctrlpts[0] = srcCtrlPtIntn[0] + cpM.x * minCpADist;\n          rs.ctrlpts[1] = srcCtrlPtIntn[1] + cpM.y * minCpADist;\n        }\n      }\n\n      if (badEnd || badAEnd || closeEndACp) {\n        overlapping = true; // project control point along line from tgt centre to outside the tgt shape\n        // (otherwise intersection will yield nothing)\n\n        var _cpD = {\n          // delta\n          x: rs.ctrlpts[0] - tgtPos.x,\n          y: rs.ctrlpts[1] - tgtPos.y\n        };\n\n        var _cpL = Math.sqrt(_cpD.x * _cpD.x + _cpD.y * _cpD.y); // length of line\n\n\n        var _cpM = {\n          // normalised delta\n          x: _cpD.x / _cpL,\n          y: _cpD.y / _cpL\n        };\n\n        var _radius = Math.max(srcW, srcH);\n\n        var _cpProj = {\n          // *2 radius guarantees outside shape\n          x: rs.ctrlpts[0] + _cpM.x * 2 * _radius,\n          y: rs.ctrlpts[1] + _cpM.y * 2 * _radius\n        };\n        var tgtCtrlPtIntn = tgtShape.intersectLine(tgtPos.x, tgtPos.y, tgtW, tgtH, _cpProj.x, _cpProj.y, 0);\n\n        if (closeEndACp) {\n          rs.ctrlpts[0] = rs.ctrlpts[0] + _cpM.x * (minCpADist - endACpDist);\n          rs.ctrlpts[1] = rs.ctrlpts[1] + _cpM.y * (minCpADist - endACpDist);\n        } else {\n          rs.ctrlpts[0] = tgtCtrlPtIntn[0] + _cpM.x * minCpADist;\n          rs.ctrlpts[1] = tgtCtrlPtIntn[1] + _cpM.y * minCpADist;\n        }\n      }\n\n      if (overlapping) {\n        // recalc endpts\n        this.findEndpoints(edge);\n      }\n    }\n  };\n\n  BRp$c.storeAllpts = function (edge) {\n    var rs = edge._private.rscratch;\n\n    if (rs.edgeType === 'multibezier' || rs.edgeType === 'bezier' || rs.edgeType === 'self' || rs.edgeType === 'compound') {\n      rs.allpts = [];\n      rs.allpts.push(rs.startX, rs.startY);\n\n      for (var b = 0; b + 1 < rs.ctrlpts.length; b += 2) {\n        // ctrl pt itself\n        rs.allpts.push(rs.ctrlpts[b], rs.ctrlpts[b + 1]); // the midpt between ctrlpts as intermediate destination pts\n\n        if (b + 3 < rs.ctrlpts.length) {\n          rs.allpts.push((rs.ctrlpts[b] + rs.ctrlpts[b + 2]) / 2, (rs.ctrlpts[b + 1] + rs.ctrlpts[b + 3]) / 2);\n        }\n      }\n\n      rs.allpts.push(rs.endX, rs.endY);\n      var m, mt;\n\n      if (rs.ctrlpts.length / 2 % 2 === 0) {\n        m = rs.allpts.length / 2 - 1;\n        rs.midX = rs.allpts[m];\n        rs.midY = rs.allpts[m + 1];\n      } else {\n        m = rs.allpts.length / 2 - 3;\n        mt = 0.5;\n        rs.midX = qbezierAt(rs.allpts[m], rs.allpts[m + 2], rs.allpts[m + 4], mt);\n        rs.midY = qbezierAt(rs.allpts[m + 1], rs.allpts[m + 3], rs.allpts[m + 5], mt);\n      }\n    } else if (rs.edgeType === 'straight') {\n      // need to calc these after endpts\n      rs.allpts = [rs.startX, rs.startY, rs.endX, rs.endY]; // default midpt for labels etc\n\n      rs.midX = (rs.startX + rs.endX + rs.arrowStartX + rs.arrowEndX) / 4;\n      rs.midY = (rs.startY + rs.endY + rs.arrowStartY + rs.arrowEndY) / 4;\n    } else if (rs.edgeType === 'segments') {\n      rs.allpts = [];\n      rs.allpts.push(rs.startX, rs.startY);\n      rs.allpts.push.apply(rs.allpts, rs.segpts);\n      rs.allpts.push(rs.endX, rs.endY);\n\n      if (rs.segpts.length % 4 === 0) {\n        var i2 = rs.segpts.length / 2;\n        var i1 = i2 - 2;\n        rs.midX = (rs.segpts[i1] + rs.segpts[i2]) / 2;\n        rs.midY = (rs.segpts[i1 + 1] + rs.segpts[i2 + 1]) / 2;\n      } else {\n        var _i = rs.segpts.length / 2 - 1;\n\n        rs.midX = rs.segpts[_i];\n        rs.midY = rs.segpts[_i + 1];\n      }\n    }\n  };\n\n  BRp$c.checkForInvalidEdgeWarning = function (edge) {\n    var rs = edge[0]._private.rscratch;\n\n    if (rs.nodesOverlap || number$1(rs.startX) && number$1(rs.startY) && number$1(rs.endX) && number$1(rs.endY)) {\n      rs.loggedErr = false;\n    } else {\n      if (!rs.loggedErr) {\n        rs.loggedErr = true;\n        warn('Edge `' + edge.id() + '` has invalid endpoints and so it is impossible to draw.  Adjust your edge style (e.g. control points) accordingly or use an alternative edge type.  This is expected behaviour when the source node and the target node overlap.');\n      }\n    }\n  };\n\n  BRp$c.findEdgeControlPoints = function (edges) {\n    var _this = this;\n\n    if (!edges || edges.length === 0) {\n      return;\n    }\n\n    var r = this;\n    var cy = r.cy;\n    var hasCompounds = cy.hasCompoundNodes();\n    var hashTable = {\n      map: new Map$2(),\n      get: function get(pairId) {\n        var map2 = this.map.get(pairId[0]);\n\n        if (map2 != null) {\n          return map2.get(pairId[1]);\n        } else {\n          return null;\n        }\n      },\n      set: function set(pairId, val) {\n        var map2 = this.map.get(pairId[0]);\n\n        if (map2 == null) {\n          map2 = new Map$2();\n          this.map.set(pairId[0], map2);\n        }\n\n        map2.set(pairId[1], val);\n      }\n    };\n    var pairIds = [];\n    var haystackEdges = []; // create a table of edge (src, tgt) => list of edges between them\n\n    for (var i = 0; i < edges.length; i++) {\n      var edge = edges[i];\n      var _p = edge._private;\n      var curveStyle = edge.pstyle('curve-style').value; // ignore edges who are not to be displayed\n      // they shouldn't take up space\n\n      if (edge.removed() || !edge.takesUpSpace()) {\n        continue;\n      }\n\n      if (curveStyle === 'haystack') {\n        haystackEdges.push(edge);\n        continue;\n      }\n\n      var edgeIsUnbundled = curveStyle === 'unbundled-bezier' || curveStyle === 'segments' || curveStyle === 'straight' || curveStyle === 'straight-triangle' || curveStyle === 'taxi';\n      var edgeIsBezier = curveStyle === 'unbundled-bezier' || curveStyle === 'bezier';\n      var src = _p.source;\n      var tgt = _p.target;\n      var srcIndex = src.poolIndex();\n      var tgtIndex = tgt.poolIndex();\n      var pairId = [srcIndex, tgtIndex].sort();\n      var tableEntry = hashTable.get(pairId);\n\n      if (tableEntry == null) {\n        tableEntry = {\n          eles: []\n        };\n        hashTable.set(pairId, tableEntry);\n        pairIds.push(pairId);\n      }\n\n      tableEntry.eles.push(edge);\n\n      if (edgeIsUnbundled) {\n        tableEntry.hasUnbundled = true;\n      }\n\n      if (edgeIsBezier) {\n        tableEntry.hasBezier = true;\n      }\n    } // for each pair (src, tgt), create the ctrl pts\n    // Nested for loop is OK; total number of iterations for both loops = edgeCount\n\n\n    var _loop = function _loop(p) {\n      var pairId = pairIds[p];\n      var pairInfo = hashTable.get(pairId);\n      var swappedpairInfo = void 0;\n\n      if (!pairInfo.hasUnbundled) {\n        var pllEdges = pairInfo.eles[0].parallelEdges().filter(function (e) {\n          return e.isBundledBezier();\n        });\n        clearArray(pairInfo.eles);\n        pllEdges.forEach(function (edge) {\n          return pairInfo.eles.push(edge);\n        }); // for each pair id, the edges should be sorted by index\n\n        pairInfo.eles.sort(function (edge1, edge2) {\n          return edge1.poolIndex() - edge2.poolIndex();\n        });\n      }\n\n      var firstEdge = pairInfo.eles[0];\n      var src = firstEdge.source();\n      var tgt = firstEdge.target(); // make sure src/tgt distinction is consistent w.r.t. pairId\n\n      if (src.poolIndex() > tgt.poolIndex()) {\n        var temp = src;\n        src = tgt;\n        tgt = temp;\n      }\n\n      var srcPos = pairInfo.srcPos = src.position();\n      var tgtPos = pairInfo.tgtPos = tgt.position();\n      var srcW = pairInfo.srcW = src.outerWidth();\n      var srcH = pairInfo.srcH = src.outerHeight();\n      var tgtW = pairInfo.tgtW = tgt.outerWidth();\n      var tgtH = pairInfo.tgtH = tgt.outerHeight();\n\n      var srcShape = pairInfo.srcShape = r.nodeShapes[_this.getNodeShape(src)];\n\n      var tgtShape = pairInfo.tgtShape = r.nodeShapes[_this.getNodeShape(tgt)];\n\n      pairInfo.dirCounts = {\n        'north': 0,\n        'west': 0,\n        'south': 0,\n        'east': 0,\n        'northwest': 0,\n        'southwest': 0,\n        'northeast': 0,\n        'southeast': 0\n      };\n\n      for (var _i2 = 0; _i2 < pairInfo.eles.length; _i2++) {\n        var _edge = pairInfo.eles[_i2];\n        var rs = _edge[0]._private.rscratch;\n\n        var _curveStyle = _edge.pstyle('curve-style').value;\n\n        var _edgeIsUnbundled = _curveStyle === 'unbundled-bezier' || _curveStyle === 'segments' || _curveStyle === 'taxi'; // whether the normalised pair order is the reverse of the edge's src-tgt order\n\n\n        var edgeIsSwapped = !src.same(_edge.source());\n\n        if (!pairInfo.calculatedIntersection && src !== tgt && (pairInfo.hasBezier || pairInfo.hasUnbundled)) {\n          pairInfo.calculatedIntersection = true; // pt outside src shape to calc distance/displacement from src to tgt\n\n          var srcOutside = srcShape.intersectLine(srcPos.x, srcPos.y, srcW, srcH, tgtPos.x, tgtPos.y, 0);\n          var srcIntn = pairInfo.srcIntn = srcOutside; // pt outside tgt shape to calc distance/displacement from src to tgt\n\n          var tgtOutside = tgtShape.intersectLine(tgtPos.x, tgtPos.y, tgtW, tgtH, srcPos.x, srcPos.y, 0);\n          var tgtIntn = pairInfo.tgtIntn = tgtOutside;\n          var intersectionPts = pairInfo.intersectionPts = {\n            x1: srcOutside[0],\n            x2: tgtOutside[0],\n            y1: srcOutside[1],\n            y2: tgtOutside[1]\n          };\n          var posPts = pairInfo.posPts = {\n            x1: srcPos.x,\n            x2: tgtPos.x,\n            y1: srcPos.y,\n            y2: tgtPos.y\n          };\n          var dy = tgtOutside[1] - srcOutside[1];\n          var dx = tgtOutside[0] - srcOutside[0];\n          var l = Math.sqrt(dx * dx + dy * dy);\n          var vector = pairInfo.vector = {\n            x: dx,\n            y: dy\n          };\n          var vectorNorm = pairInfo.vectorNorm = {\n            x: vector.x / l,\n            y: vector.y / l\n          };\n          var vectorNormInverse = {\n            x: -vectorNorm.y,\n            y: vectorNorm.x\n          }; // if node shapes overlap, then no ctrl pts to draw\n\n          pairInfo.nodesOverlap = !number$1(l) || tgtShape.checkPoint(srcOutside[0], srcOutside[1], 0, tgtW, tgtH, tgtPos.x, tgtPos.y) || srcShape.checkPoint(tgtOutside[0], tgtOutside[1], 0, srcW, srcH, srcPos.x, srcPos.y);\n          pairInfo.vectorNormInverse = vectorNormInverse;\n          swappedpairInfo = {\n            nodesOverlap: pairInfo.nodesOverlap,\n            dirCounts: pairInfo.dirCounts,\n            calculatedIntersection: true,\n            hasBezier: pairInfo.hasBezier,\n            hasUnbundled: pairInfo.hasUnbundled,\n            eles: pairInfo.eles,\n            srcPos: tgtPos,\n            tgtPos: srcPos,\n            srcW: tgtW,\n            srcH: tgtH,\n            tgtW: srcW,\n            tgtH: srcH,\n            srcIntn: tgtIntn,\n            tgtIntn: srcIntn,\n            srcShape: tgtShape,\n            tgtShape: srcShape,\n            posPts: {\n              x1: posPts.x2,\n              y1: posPts.y2,\n              x2: posPts.x1,\n              y2: posPts.y1\n            },\n            intersectionPts: {\n              x1: intersectionPts.x2,\n              y1: intersectionPts.y2,\n              x2: intersectionPts.x1,\n              y2: intersectionPts.y1\n            },\n            vector: {\n              x: -vector.x,\n              y: -vector.y\n            },\n            vectorNorm: {\n              x: -vectorNorm.x,\n              y: -vectorNorm.y\n            },\n            vectorNormInverse: {\n              x: -vectorNormInverse.x,\n              y: -vectorNormInverse.y\n            }\n          };\n        }\n\n        var passedPairInfo = edgeIsSwapped ? swappedpairInfo : pairInfo;\n        rs.nodesOverlap = passedPairInfo.nodesOverlap;\n        rs.srcIntn = passedPairInfo.srcIntn;\n        rs.tgtIntn = passedPairInfo.tgtIntn;\n\n        if (hasCompounds && (src.isParent() || src.isChild() || tgt.isParent() || tgt.isChild()) && (src.parents().anySame(tgt) || tgt.parents().anySame(src) || src.same(tgt) && src.isParent())) {\n          _this.findCompoundLoopPoints(_edge, passedPairInfo, _i2, _edgeIsUnbundled);\n        } else if (src === tgt) {\n          _this.findLoopPoints(_edge, passedPairInfo, _i2, _edgeIsUnbundled);\n        } else if (_curveStyle === 'segments') {\n          _this.findSegmentsPoints(_edge, passedPairInfo);\n        } else if (_curveStyle === 'taxi') {\n          _this.findTaxiPoints(_edge, passedPairInfo);\n        } else if (_curveStyle === 'straight' || !_edgeIsUnbundled && pairInfo.eles.length % 2 === 1 && _i2 === Math.floor(pairInfo.eles.length / 2)) {\n          _this.findStraightEdgePoints(_edge);\n        } else {\n          _this.findBezierPoints(_edge, passedPairInfo, _i2, _edgeIsUnbundled, edgeIsSwapped);\n        }\n\n        _this.findEndpoints(_edge);\n\n        _this.tryToCorrectInvalidPoints(_edge, passedPairInfo);\n\n        _this.checkForInvalidEdgeWarning(_edge);\n\n        _this.storeAllpts(_edge);\n\n        _this.storeEdgeProjections(_edge);\n\n        _this.calculateArrowAngles(_edge);\n\n        _this.recalculateEdgeLabelProjections(_edge);\n\n        _this.calculateLabelAngles(_edge);\n      } // for pair edges\n\n    };\n\n    for (var p = 0; p < pairIds.length; p++) {\n      _loop(p);\n    } // for pair ids\n    // haystacks avoid the expense of pairInfo stuff (intersections etc.)\n\n\n    this.findHaystackPoints(haystackEdges);\n  };\n\n  function getPts(pts) {\n    var retPts = [];\n\n    if (pts == null) {\n      return;\n    }\n\n    for (var i = 0; i < pts.length; i += 2) {\n      var x = pts[i];\n      var y = pts[i + 1];\n      retPts.push({\n        x: x,\n        y: y\n      });\n    }\n\n    return retPts;\n  }\n\n  BRp$c.getSegmentPoints = function (edge) {\n    var rs = edge[0]._private.rscratch;\n    var type = rs.edgeType;\n\n    if (type === 'segments') {\n      this.recalculateRenderedStyle(edge);\n      return getPts(rs.segpts);\n    }\n  };\n\n  BRp$c.getControlPoints = function (edge) {\n    var rs = edge[0]._private.rscratch;\n    var type = rs.edgeType;\n\n    if (type === 'bezier' || type === 'multibezier' || type === 'self' || type === 'compound') {\n      this.recalculateRenderedStyle(edge);\n      return getPts(rs.ctrlpts);\n    }\n  };\n\n  BRp$c.getEdgeMidpoint = function (edge) {\n    var rs = edge[0]._private.rscratch;\n    this.recalculateRenderedStyle(edge);\n    return {\n      x: rs.midX,\n      y: rs.midY\n    };\n  };\n\n  var BRp$b = {};\n\n  BRp$b.manualEndptToPx = function (node, prop) {\n    var r = this;\n    var npos = node.position();\n    var w = node.outerWidth();\n    var h = node.outerHeight();\n\n    if (prop.value.length === 2) {\n      var p = [prop.pfValue[0], prop.pfValue[1]];\n\n      if (prop.units[0] === '%') {\n        p[0] = p[0] * w;\n      }\n\n      if (prop.units[1] === '%') {\n        p[1] = p[1] * h;\n      }\n\n      p[0] += npos.x;\n      p[1] += npos.y;\n      return p;\n    } else {\n      var angle = prop.pfValue[0];\n      angle = -Math.PI / 2 + angle; // start at 12 o'clock\n\n      var l = 2 * Math.max(w, h);\n      var _p = [npos.x + Math.cos(angle) * l, npos.y + Math.sin(angle) * l];\n      return r.nodeShapes[this.getNodeShape(node)].intersectLine(npos.x, npos.y, w, h, _p[0], _p[1], 0);\n    }\n  };\n\n  BRp$b.findEndpoints = function (edge) {\n    var r = this;\n    var intersect;\n    var source = edge.source()[0];\n    var target = edge.target()[0];\n    var srcPos = source.position();\n    var tgtPos = target.position();\n    var tgtArShape = edge.pstyle('target-arrow-shape').value;\n    var srcArShape = edge.pstyle('source-arrow-shape').value;\n    var tgtDist = edge.pstyle('target-distance-from-node').pfValue;\n    var srcDist = edge.pstyle('source-distance-from-node').pfValue;\n    var curveStyle = edge.pstyle('curve-style').value;\n    var rs = edge._private.rscratch;\n    var et = rs.edgeType;\n    var taxi = curveStyle === 'taxi';\n    var self = et === 'self' || et === 'compound';\n    var bezier = et === 'bezier' || et === 'multibezier' || self;\n    var multi = et !== 'bezier';\n    var lines = et === 'straight' || et === 'segments';\n    var segments = et === 'segments';\n    var hasEndpts = bezier || multi || lines;\n    var overrideEndpts = self || taxi;\n    var srcManEndpt = edge.pstyle('source-endpoint');\n    var srcManEndptVal = overrideEndpts ? 'outside-to-node' : srcManEndpt.value;\n    var tgtManEndpt = edge.pstyle('target-endpoint');\n    var tgtManEndptVal = overrideEndpts ? 'outside-to-node' : tgtManEndpt.value;\n    rs.srcManEndpt = srcManEndpt;\n    rs.tgtManEndpt = tgtManEndpt;\n    var p1; // last known point of edge on target side\n\n    var p2; // last known point of edge on source side\n\n    var p1_i; // point to intersect with target shape\n\n    var p2_i; // point to intersect with source shape\n\n    if (bezier) {\n      var cpStart = [rs.ctrlpts[0], rs.ctrlpts[1]];\n      var cpEnd = multi ? [rs.ctrlpts[rs.ctrlpts.length - 2], rs.ctrlpts[rs.ctrlpts.length - 1]] : cpStart;\n      p1 = cpEnd;\n      p2 = cpStart;\n    } else if (lines) {\n      var srcArrowFromPt = !segments ? [tgtPos.x, tgtPos.y] : rs.segpts.slice(0, 2);\n      var tgtArrowFromPt = !segments ? [srcPos.x, srcPos.y] : rs.segpts.slice(rs.segpts.length - 2);\n      p1 = tgtArrowFromPt;\n      p2 = srcArrowFromPt;\n    }\n\n    if (tgtManEndptVal === 'inside-to-node') {\n      intersect = [tgtPos.x, tgtPos.y];\n    } else if (tgtManEndpt.units) {\n      intersect = this.manualEndptToPx(target, tgtManEndpt);\n    } else if (tgtManEndptVal === 'outside-to-line') {\n      intersect = rs.tgtIntn; // use cached value from ctrlpt calc\n    } else {\n      if (tgtManEndptVal === 'outside-to-node' || tgtManEndptVal === 'outside-to-node-or-label') {\n        p1_i = p1;\n      } else if (tgtManEndptVal === 'outside-to-line' || tgtManEndptVal === 'outside-to-line-or-label') {\n        p1_i = [srcPos.x, srcPos.y];\n      }\n\n      intersect = r.nodeShapes[this.getNodeShape(target)].intersectLine(tgtPos.x, tgtPos.y, target.outerWidth(), target.outerHeight(), p1_i[0], p1_i[1], 0);\n\n      if (tgtManEndptVal === 'outside-to-node-or-label' || tgtManEndptVal === 'outside-to-line-or-label') {\n        var trs = target._private.rscratch;\n        var lw = trs.labelWidth;\n        var lh = trs.labelHeight;\n        var lx = trs.labelX;\n        var ly = trs.labelY;\n        var lw2 = lw / 2;\n        var lh2 = lh / 2;\n        var va = target.pstyle('text-valign').value;\n\n        if (va === 'top') {\n          ly -= lh2;\n        } else if (va === 'bottom') {\n          ly += lh2;\n        }\n\n        var ha = target.pstyle('text-halign').value;\n\n        if (ha === 'left') {\n          lx -= lw2;\n        } else if (ha === 'right') {\n          lx += lw2;\n        }\n\n        var labelIntersect = polygonIntersectLine(p1_i[0], p1_i[1], [lx - lw2, ly - lh2, lx + lw2, ly - lh2, lx + lw2, ly + lh2, lx - lw2, ly + lh2], tgtPos.x, tgtPos.y);\n\n        if (labelIntersect.length > 0) {\n          var refPt = srcPos;\n          var intSqdist = sqdist(refPt, array2point(intersect));\n          var labIntSqdist = sqdist(refPt, array2point(labelIntersect));\n          var minSqDist = intSqdist;\n\n          if (labIntSqdist < intSqdist) {\n            intersect = labelIntersect;\n            minSqDist = labIntSqdist;\n          }\n\n          if (labelIntersect.length > 2) {\n            var labInt2SqDist = sqdist(refPt, {\n              x: labelIntersect[2],\n              y: labelIntersect[3]\n            });\n\n            if (labInt2SqDist < minSqDist) {\n              intersect = [labelIntersect[2], labelIntersect[3]];\n            }\n          }\n        }\n      }\n    }\n\n    var arrowEnd = shortenIntersection(intersect, p1, r.arrowShapes[tgtArShape].spacing(edge) + tgtDist);\n    var edgeEnd = shortenIntersection(intersect, p1, r.arrowShapes[tgtArShape].gap(edge) + tgtDist);\n    rs.endX = edgeEnd[0];\n    rs.endY = edgeEnd[1];\n    rs.arrowEndX = arrowEnd[0];\n    rs.arrowEndY = arrowEnd[1];\n\n    if (srcManEndptVal === 'inside-to-node') {\n      intersect = [srcPos.x, srcPos.y];\n    } else if (srcManEndpt.units) {\n      intersect = this.manualEndptToPx(source, srcManEndpt);\n    } else if (srcManEndptVal === 'outside-to-line') {\n      intersect = rs.srcIntn; // use cached value from ctrlpt calc\n    } else {\n      if (srcManEndptVal === 'outside-to-node' || srcManEndptVal === 'outside-to-node-or-label') {\n        p2_i = p2;\n      } else if (srcManEndptVal === 'outside-to-line' || srcManEndptVal === 'outside-to-line-or-label') {\n        p2_i = [tgtPos.x, tgtPos.y];\n      }\n\n      intersect = r.nodeShapes[this.getNodeShape(source)].intersectLine(srcPos.x, srcPos.y, source.outerWidth(), source.outerHeight(), p2_i[0], p2_i[1], 0);\n\n      if (srcManEndptVal === 'outside-to-node-or-label' || srcManEndptVal === 'outside-to-line-or-label') {\n        var srs = source._private.rscratch;\n        var _lw = srs.labelWidth;\n        var _lh = srs.labelHeight;\n        var _lx = srs.labelX;\n        var _ly = srs.labelY;\n\n        var _lw2 = _lw / 2;\n\n        var _lh2 = _lh / 2;\n\n        var _va = source.pstyle('text-valign').value;\n\n        if (_va === 'top') {\n          _ly -= _lh2;\n        } else if (_va === 'bottom') {\n          _ly += _lh2;\n        }\n\n        var _ha = source.pstyle('text-halign').value;\n\n        if (_ha === 'left') {\n          _lx -= _lw2;\n        } else if (_ha === 'right') {\n          _lx += _lw2;\n        }\n\n        var _labelIntersect = polygonIntersectLine(p2_i[0], p2_i[1], [_lx - _lw2, _ly - _lh2, _lx + _lw2, _ly - _lh2, _lx + _lw2, _ly + _lh2, _lx - _lw2, _ly + _lh2], srcPos.x, srcPos.y);\n\n        if (_labelIntersect.length > 0) {\n          var _refPt = tgtPos;\n\n          var _intSqdist = sqdist(_refPt, array2point(intersect));\n\n          var _labIntSqdist = sqdist(_refPt, array2point(_labelIntersect));\n\n          var _minSqDist = _intSqdist;\n\n          if (_labIntSqdist < _intSqdist) {\n            intersect = [_labelIntersect[0], _labelIntersect[1]];\n            _minSqDist = _labIntSqdist;\n          }\n\n          if (_labelIntersect.length > 2) {\n            var _labInt2SqDist = sqdist(_refPt, {\n              x: _labelIntersect[2],\n              y: _labelIntersect[3]\n            });\n\n            if (_labInt2SqDist < _minSqDist) {\n              intersect = [_labelIntersect[2], _labelIntersect[3]];\n            }\n          }\n        }\n      }\n    }\n\n    var arrowStart = shortenIntersection(intersect, p2, r.arrowShapes[srcArShape].spacing(edge) + srcDist);\n    var edgeStart = shortenIntersection(intersect, p2, r.arrowShapes[srcArShape].gap(edge) + srcDist);\n    rs.startX = edgeStart[0];\n    rs.startY = edgeStart[1];\n    rs.arrowStartX = arrowStart[0];\n    rs.arrowStartY = arrowStart[1];\n\n    if (hasEndpts) {\n      if (!number$1(rs.startX) || !number$1(rs.startY) || !number$1(rs.endX) || !number$1(rs.endY)) {\n        rs.badLine = true;\n      } else {\n        rs.badLine = false;\n      }\n    }\n  };\n\n  BRp$b.getSourceEndpoint = function (edge) {\n    var rs = edge[0]._private.rscratch;\n    this.recalculateRenderedStyle(edge);\n\n    switch (rs.edgeType) {\n      case 'haystack':\n        return {\n          x: rs.haystackPts[0],\n          y: rs.haystackPts[1]\n        };\n\n      default:\n        return {\n          x: rs.arrowStartX,\n          y: rs.arrowStartY\n        };\n    }\n  };\n\n  BRp$b.getTargetEndpoint = function (edge) {\n    var rs = edge[0]._private.rscratch;\n    this.recalculateRenderedStyle(edge);\n\n    switch (rs.edgeType) {\n      case 'haystack':\n        return {\n          x: rs.haystackPts[2],\n          y: rs.haystackPts[3]\n        };\n\n      default:\n        return {\n          x: rs.arrowEndX,\n          y: rs.arrowEndY\n        };\n    }\n  };\n\n  var BRp$a = {};\n\n  function pushBezierPts(r, edge, pts) {\n    var qbezierAt$1 = function qbezierAt$1(p1, p2, p3, t) {\n      return qbezierAt(p1, p2, p3, t);\n    };\n\n    var _p = edge._private;\n    var bpts = _p.rstyle.bezierPts;\n\n    for (var i = 0; i < r.bezierProjPcts.length; i++) {\n      var p = r.bezierProjPcts[i];\n      bpts.push({\n        x: qbezierAt$1(pts[0], pts[2], pts[4], p),\n        y: qbezierAt$1(pts[1], pts[3], pts[5], p)\n      });\n    }\n  }\n\n  BRp$a.storeEdgeProjections = function (edge) {\n    var _p = edge._private;\n    var rs = _p.rscratch;\n    var et = rs.edgeType; // clear the cached points state\n\n    _p.rstyle.bezierPts = null;\n    _p.rstyle.linePts = null;\n    _p.rstyle.haystackPts = null;\n\n    if (et === 'multibezier' || et === 'bezier' || et === 'self' || et === 'compound') {\n      _p.rstyle.bezierPts = [];\n\n      for (var i = 0; i + 5 < rs.allpts.length; i += 4) {\n        pushBezierPts(this, edge, rs.allpts.slice(i, i + 6));\n      }\n    } else if (et === 'segments') {\n      var lpts = _p.rstyle.linePts = [];\n\n      for (var i = 0; i + 1 < rs.allpts.length; i += 2) {\n        lpts.push({\n          x: rs.allpts[i],\n          y: rs.allpts[i + 1]\n        });\n      }\n    } else if (et === 'haystack') {\n      var hpts = rs.haystackPts;\n      _p.rstyle.haystackPts = [{\n        x: hpts[0],\n        y: hpts[1]\n      }, {\n        x: hpts[2],\n        y: hpts[3]\n      }];\n    }\n\n    _p.rstyle.arrowWidth = this.getArrowWidth(edge.pstyle('width').pfValue, edge.pstyle('arrow-scale').value) * this.arrowShapeWidth;\n  };\n\n  BRp$a.recalculateEdgeProjections = function (edges) {\n    this.findEdgeControlPoints(edges);\n  };\n\n  /* global document */\n\n  var BRp$9 = {};\n\n  BRp$9.recalculateNodeLabelProjection = function (node) {\n    var content = node.pstyle('label').strValue;\n\n    if (emptyString(content)) {\n      return;\n    }\n\n    var textX, textY;\n    var _p = node._private;\n    var nodeWidth = node.width();\n    var nodeHeight = node.height();\n    var padding = node.padding();\n    var nodePos = node.position();\n    var textHalign = node.pstyle('text-halign').strValue;\n    var textValign = node.pstyle('text-valign').strValue;\n    var rs = _p.rscratch;\n    var rstyle = _p.rstyle;\n\n    switch (textHalign) {\n      case 'left':\n        textX = nodePos.x - nodeWidth / 2 - padding;\n        break;\n\n      case 'right':\n        textX = nodePos.x + nodeWidth / 2 + padding;\n        break;\n\n      default:\n        // e.g. center\n        textX = nodePos.x;\n    }\n\n    switch (textValign) {\n      case 'top':\n        textY = nodePos.y - nodeHeight / 2 - padding;\n        break;\n\n      case 'bottom':\n        textY = nodePos.y + nodeHeight / 2 + padding;\n        break;\n\n      default:\n        // e.g. middle\n        textY = nodePos.y;\n    }\n\n    rs.labelX = textX;\n    rs.labelY = textY;\n    rstyle.labelX = textX;\n    rstyle.labelY = textY;\n    this.calculateLabelAngles(node);\n    this.applyLabelDimensions(node);\n  };\n\n  var lineAngleFromDelta = function lineAngleFromDelta(dx, dy) {\n    var angle = Math.atan(dy / dx);\n\n    if (dx === 0 && angle < 0) {\n      angle = angle * -1;\n    }\n\n    return angle;\n  };\n\n  var lineAngle = function lineAngle(p0, p1) {\n    var dx = p1.x - p0.x;\n    var dy = p1.y - p0.y;\n    return lineAngleFromDelta(dx, dy);\n  };\n\n  var bezierAngle = function bezierAngle(p0, p1, p2, t) {\n    var t0 = bound(0, t - 0.001, 1);\n    var t1 = bound(0, t + 0.001, 1);\n    var lp0 = qbezierPtAt(p0, p1, p2, t0);\n    var lp1 = qbezierPtAt(p0, p1, p2, t1);\n    return lineAngle(lp0, lp1);\n  };\n\n  BRp$9.recalculateEdgeLabelProjections = function (edge) {\n    var p;\n    var _p = edge._private;\n    var rs = _p.rscratch;\n    var r = this;\n    var content = {\n      mid: edge.pstyle('label').strValue,\n      source: edge.pstyle('source-label').strValue,\n      target: edge.pstyle('target-label').strValue\n    };\n\n    if (content.mid || content.source || content.target) ; else {\n      return; // no labels => no calcs\n    } // add center point to style so bounding box calculations can use it\n    //\n\n\n    p = {\n      x: rs.midX,\n      y: rs.midY\n    };\n\n    var setRs = function setRs(propName, prefix, value) {\n      setPrefixedProperty(_p.rscratch, propName, prefix, value);\n      setPrefixedProperty(_p.rstyle, propName, prefix, value);\n    };\n\n    setRs('labelX', null, p.x);\n    setRs('labelY', null, p.y);\n    var midAngle = lineAngleFromDelta(rs.midDispX, rs.midDispY);\n    setRs('labelAutoAngle', null, midAngle);\n\n    var createControlPointInfo = function createControlPointInfo() {\n      if (createControlPointInfo.cache) {\n        return createControlPointInfo.cache;\n      } // use cache so only 1x per edge\n\n\n      var ctrlpts = []; // store each ctrlpt info init\n\n      for (var i = 0; i + 5 < rs.allpts.length; i += 4) {\n        var p0 = {\n          x: rs.allpts[i],\n          y: rs.allpts[i + 1]\n        };\n        var p1 = {\n          x: rs.allpts[i + 2],\n          y: rs.allpts[i + 3]\n        }; // ctrlpt\n\n        var p2 = {\n          x: rs.allpts[i + 4],\n          y: rs.allpts[i + 5]\n        };\n        ctrlpts.push({\n          p0: p0,\n          p1: p1,\n          p2: p2,\n          startDist: 0,\n          length: 0,\n          segments: []\n        });\n      }\n\n      var bpts = _p.rstyle.bezierPts;\n      var nProjs = r.bezierProjPcts.length;\n\n      function addSegment(cp, p0, p1, t0, t1) {\n        var length = dist(p0, p1);\n        var prevSegment = cp.segments[cp.segments.length - 1];\n        var segment = {\n          p0: p0,\n          p1: p1,\n          t0: t0,\n          t1: t1,\n          startDist: prevSegment ? prevSegment.startDist + prevSegment.length : 0,\n          length: length\n        };\n        cp.segments.push(segment);\n        cp.length += length;\n      } // update each ctrlpt with segment info\n\n\n      for (var _i = 0; _i < ctrlpts.length; _i++) {\n        var cp = ctrlpts[_i];\n        var prevCp = ctrlpts[_i - 1];\n\n        if (prevCp) {\n          cp.startDist = prevCp.startDist + prevCp.length;\n        }\n\n        addSegment(cp, cp.p0, bpts[_i * nProjs], 0, r.bezierProjPcts[0]); // first\n\n        for (var j = 0; j < nProjs - 1; j++) {\n          addSegment(cp, bpts[_i * nProjs + j], bpts[_i * nProjs + j + 1], r.bezierProjPcts[j], r.bezierProjPcts[j + 1]);\n        }\n\n        addSegment(cp, bpts[_i * nProjs + nProjs - 1], cp.p2, r.bezierProjPcts[nProjs - 1], 1); // last\n      }\n\n      return createControlPointInfo.cache = ctrlpts;\n    };\n\n    var calculateEndProjection = function calculateEndProjection(prefix) {\n      var angle;\n      var isSrc = prefix === 'source';\n\n      if (!content[prefix]) {\n        return;\n      }\n\n      var offset = edge.pstyle(prefix + '-text-offset').pfValue;\n\n      switch (rs.edgeType) {\n        case 'self':\n        case 'compound':\n        case 'bezier':\n        case 'multibezier':\n          {\n            var cps = createControlPointInfo();\n            var selected;\n            var startDist = 0;\n            var totalDist = 0; // find the segment we're on\n\n            for (var i = 0; i < cps.length; i++) {\n              var _cp = cps[isSrc ? i : cps.length - 1 - i];\n\n              for (var j = 0; j < _cp.segments.length; j++) {\n                var _seg = _cp.segments[isSrc ? j : _cp.segments.length - 1 - j];\n                var lastSeg = i === cps.length - 1 && j === _cp.segments.length - 1;\n                startDist = totalDist;\n                totalDist += _seg.length;\n\n                if (totalDist >= offset || lastSeg) {\n                  selected = {\n                    cp: _cp,\n                    segment: _seg\n                  };\n                  break;\n                }\n              }\n\n              if (selected) {\n                break;\n              }\n            }\n\n            var cp = selected.cp;\n            var seg = selected.segment;\n            var tSegment = (offset - startDist) / seg.length;\n            var segDt = seg.t1 - seg.t0;\n            var t = isSrc ? seg.t0 + segDt * tSegment : seg.t1 - segDt * tSegment;\n            t = bound(0, t, 1);\n            p = qbezierPtAt(cp.p0, cp.p1, cp.p2, t);\n            angle = bezierAngle(cp.p0, cp.p1, cp.p2, t);\n            break;\n          }\n\n        case 'straight':\n        case 'segments':\n        case 'haystack':\n          {\n            var d = 0,\n                di,\n                d0;\n            var p0, p1;\n            var l = rs.allpts.length;\n\n            for (var _i2 = 0; _i2 + 3 < l; _i2 += 2) {\n              if (isSrc) {\n                p0 = {\n                  x: rs.allpts[_i2],\n                  y: rs.allpts[_i2 + 1]\n                };\n                p1 = {\n                  x: rs.allpts[_i2 + 2],\n                  y: rs.allpts[_i2 + 3]\n                };\n              } else {\n                p0 = {\n                  x: rs.allpts[l - 2 - _i2],\n                  y: rs.allpts[l - 1 - _i2]\n                };\n                p1 = {\n                  x: rs.allpts[l - 4 - _i2],\n                  y: rs.allpts[l - 3 - _i2]\n                };\n              }\n\n              di = dist(p0, p1);\n              d0 = d;\n              d += di;\n\n              if (d >= offset) {\n                break;\n              }\n            }\n\n            var pD = offset - d0;\n\n            var _t = pD / di;\n\n            _t = bound(0, _t, 1);\n            p = lineAt(p0, p1, _t);\n            angle = lineAngle(p0, p1);\n            break;\n          }\n      }\n\n      setRs('labelX', prefix, p.x);\n      setRs('labelY', prefix, p.y);\n      setRs('labelAutoAngle', prefix, angle);\n    };\n\n    calculateEndProjection('source');\n    calculateEndProjection('target');\n    this.applyLabelDimensions(edge);\n  };\n\n  BRp$9.applyLabelDimensions = function (ele) {\n    this.applyPrefixedLabelDimensions(ele);\n\n    if (ele.isEdge()) {\n      this.applyPrefixedLabelDimensions(ele, 'source');\n      this.applyPrefixedLabelDimensions(ele, 'target');\n    }\n  };\n\n  BRp$9.applyPrefixedLabelDimensions = function (ele, prefix) {\n    var _p = ele._private;\n    var text = this.getLabelText(ele, prefix);\n    var labelDims = this.calculateLabelDimensions(ele, text);\n    var lineHeight = ele.pstyle('line-height').pfValue;\n    var textWrap = ele.pstyle('text-wrap').strValue;\n    var lines = getPrefixedProperty(_p.rscratch, 'labelWrapCachedLines', prefix) || [];\n    var numLines = textWrap !== 'wrap' ? 1 : Math.max(lines.length, 1);\n    var normPerLineHeight = labelDims.height / numLines;\n    var labelLineHeight = normPerLineHeight * lineHeight;\n    var width = labelDims.width;\n    var height = labelDims.height + (numLines - 1) * (lineHeight - 1) * normPerLineHeight;\n    setPrefixedProperty(_p.rstyle, 'labelWidth', prefix, width);\n    setPrefixedProperty(_p.rscratch, 'labelWidth', prefix, width);\n    setPrefixedProperty(_p.rstyle, 'labelHeight', prefix, height);\n    setPrefixedProperty(_p.rscratch, 'labelHeight', prefix, height);\n    setPrefixedProperty(_p.rscratch, 'labelLineHeight', prefix, labelLineHeight);\n  };\n\n  BRp$9.getLabelText = function (ele, prefix) {\n    var _p = ele._private;\n    var pfd = prefix ? prefix + '-' : '';\n    var text = ele.pstyle(pfd + 'label').strValue;\n    var textTransform = ele.pstyle('text-transform').value;\n\n    var rscratch = function rscratch(propName, value) {\n      if (value) {\n        setPrefixedProperty(_p.rscratch, propName, prefix, value);\n        return value;\n      } else {\n        return getPrefixedProperty(_p.rscratch, propName, prefix);\n      }\n    }; // for empty text, skip all processing\n\n\n    if (!text) {\n      return '';\n    }\n\n    if (textTransform == 'none') ; else if (textTransform == 'uppercase') {\n      text = text.toUpperCase();\n    } else if (textTransform == 'lowercase') {\n      text = text.toLowerCase();\n    }\n\n    var wrapStyle = ele.pstyle('text-wrap').value;\n\n    if (wrapStyle === 'wrap') {\n      var labelKey = rscratch('labelKey'); // save recalc if the label is the same as before\n\n      if (labelKey != null && rscratch('labelWrapKey') === labelKey) {\n        return rscratch('labelWrapCachedText');\n      }\n\n      var zwsp = \"\\u200B\";\n      var lines = text.split('\\n');\n      var maxW = ele.pstyle('text-max-width').pfValue;\n      var overflow = ele.pstyle('text-overflow-wrap').value;\n      var overflowAny = overflow === 'anywhere';\n      var wrappedLines = [];\n      var wordsRegex = /[\\s\\u200b]+/;\n      var wordSeparator = overflowAny ? '' : ' ';\n\n      for (var l = 0; l < lines.length; l++) {\n        var line = lines[l];\n        var lineDims = this.calculateLabelDimensions(ele, line);\n        var lineW = lineDims.width;\n\n        if (overflowAny) {\n          var processedLine = line.split('').join(zwsp);\n          line = processedLine;\n        }\n\n        if (lineW > maxW) {\n          // line is too long\n          var words = line.split(wordsRegex);\n          var subline = '';\n\n          for (var w = 0; w < words.length; w++) {\n            var word = words[w];\n            var testLine = subline.length === 0 ? word : subline + wordSeparator + word;\n            var testDims = this.calculateLabelDimensions(ele, testLine);\n            var testW = testDims.width;\n\n            if (testW <= maxW) {\n              // word fits on current line\n              subline += word + wordSeparator;\n            } else {\n              // word starts new line\n              if (subline) {\n                wrappedLines.push(subline);\n              }\n\n              subline = word + wordSeparator;\n            }\n          } // if there's remaining text, put it in a wrapped line\n\n\n          if (!subline.match(/^[\\s\\u200b]+$/)) {\n            wrappedLines.push(subline);\n          }\n        } else {\n          // line is already short enough\n          wrappedLines.push(line);\n        }\n      } // for\n\n\n      rscratch('labelWrapCachedLines', wrappedLines);\n      text = rscratch('labelWrapCachedText', wrappedLines.join('\\n'));\n      rscratch('labelWrapKey', labelKey);\n    } else if (wrapStyle === 'ellipsis') {\n      var _maxW = ele.pstyle('text-max-width').pfValue;\n      var ellipsized = '';\n      var ellipsis = \"\\u2026\";\n      var incLastCh = false;\n\n      if (this.calculateLabelDimensions(ele, text).width < _maxW) {\n        // the label already fits\n        return text;\n      }\n\n      for (var i = 0; i < text.length; i++) {\n        var widthWithNextCh = this.calculateLabelDimensions(ele, ellipsized + text[i] + ellipsis).width;\n\n        if (widthWithNextCh > _maxW) {\n          break;\n        }\n\n        ellipsized += text[i];\n\n        if (i === text.length - 1) {\n          incLastCh = true;\n        }\n      }\n\n      if (!incLastCh) {\n        ellipsized += ellipsis;\n      }\n\n      return ellipsized;\n    } // if ellipsize\n\n\n    return text;\n  };\n\n  BRp$9.getLabelJustification = function (ele) {\n    var justification = ele.pstyle('text-justification').strValue;\n    var textHalign = ele.pstyle('text-halign').strValue;\n\n    if (justification === 'auto') {\n      if (ele.isNode()) {\n        switch (textHalign) {\n          case 'left':\n            return 'right';\n\n          case 'right':\n            return 'left';\n\n          default:\n            return 'center';\n        }\n      } else {\n        return 'center';\n      }\n    } else {\n      return justification;\n    }\n  };\n\n  BRp$9.calculateLabelDimensions = function (ele, text) {\n    var r = this;\n    var cacheKey = hashString(text, ele._private.labelDimsKey);\n    var cache = r.labelDimCache || (r.labelDimCache = []);\n    var existingVal = cache[cacheKey];\n\n    if (existingVal != null) {\n      return existingVal;\n    }\n\n    var padding = 0; // add padding around text dims, as the measurement isn't that accurate\n\n    var fStyle = ele.pstyle('font-style').strValue;\n    var size = ele.pstyle('font-size').pfValue;\n    var family = ele.pstyle('font-family').strValue;\n    var weight = ele.pstyle('font-weight').strValue;\n    var canvas = this.labelCalcCanvas;\n    var c2d = this.labelCalcCanvasContext;\n\n    if (!canvas) {\n      canvas = this.labelCalcCanvas = document.createElement('canvas');\n      c2d = this.labelCalcCanvasContext = canvas.getContext('2d');\n      var ds = canvas.style;\n      ds.position = 'absolute';\n      ds.left = '-9999px';\n      ds.top = '-9999px';\n      ds.zIndex = '-1';\n      ds.visibility = 'hidden';\n      ds.pointerEvents = 'none';\n    }\n\n    c2d.font = \"\".concat(fStyle, \" \").concat(weight, \" \").concat(size, \"px \").concat(family);\n    var width = 0;\n    var height = 0;\n    var lines = text.split('\\n');\n\n    for (var i = 0; i < lines.length; i++) {\n      var line = lines[i];\n      var metrics = c2d.measureText(line);\n      var w = Math.ceil(metrics.width);\n      var h = size;\n      width = Math.max(w, width);\n      height += h;\n    }\n\n    width += padding;\n    height += padding;\n    return cache[cacheKey] = {\n      width: width,\n      height: height\n    };\n  };\n\n  BRp$9.calculateLabelAngle = function (ele, prefix) {\n    var _p = ele._private;\n    var rs = _p.rscratch;\n    var isEdge = ele.isEdge();\n    var prefixDash = prefix ? prefix + '-' : '';\n    var rot = ele.pstyle(prefixDash + 'text-rotation');\n    var rotStr = rot.strValue;\n\n    if (rotStr === 'none') {\n      return 0;\n    } else if (isEdge && rotStr === 'autorotate') {\n      return rs.labelAutoAngle;\n    } else if (rotStr === 'autorotate') {\n      return 0;\n    } else {\n      return rot.pfValue;\n    }\n  };\n\n  BRp$9.calculateLabelAngles = function (ele) {\n    var r = this;\n    var isEdge = ele.isEdge();\n    var _p = ele._private;\n    var rs = _p.rscratch;\n    rs.labelAngle = r.calculateLabelAngle(ele);\n\n    if (isEdge) {\n      rs.sourceLabelAngle = r.calculateLabelAngle(ele, 'source');\n      rs.targetLabelAngle = r.calculateLabelAngle(ele, 'target');\n    }\n  };\n\n  var BRp$8 = {};\n  var TOO_SMALL_CUT_RECT = 28;\n  var warnedCutRect = false;\n\n  BRp$8.getNodeShape = function (node) {\n    var r = this;\n    var shape = node.pstyle('shape').value;\n\n    if (shape === 'cutrectangle' && (node.width() < TOO_SMALL_CUT_RECT || node.height() < TOO_SMALL_CUT_RECT)) {\n      if (!warnedCutRect) {\n        warn('The `cutrectangle` node shape can not be used at small sizes so `rectangle` is used instead');\n        warnedCutRect = true;\n      }\n\n      return 'rectangle';\n    }\n\n    if (node.isParent()) {\n      if (shape === 'rectangle' || shape === 'roundrectangle' || shape === 'round-rectangle' || shape === 'cutrectangle' || shape === 'cut-rectangle' || shape === 'barrel') {\n        return shape;\n      } else {\n        return 'rectangle';\n      }\n    }\n\n    if (shape === 'polygon') {\n      var points = node.pstyle('shape-polygon-points').value;\n      return r.nodeShapes.makePolygon(points).name;\n    }\n\n    return shape;\n  };\n\n  var BRp$7 = {};\n\n  BRp$7.registerCalculationListeners = function () {\n    var cy = this.cy;\n    var elesToUpdate = cy.collection();\n    var r = this;\n\n    var enqueue = function enqueue(eles) {\n      var dirtyStyleCaches = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      elesToUpdate.merge(eles);\n\n      if (dirtyStyleCaches) {\n        for (var i = 0; i < eles.length; i++) {\n          var ele = eles[i];\n          var _p = ele._private;\n          var rstyle = _p.rstyle;\n          rstyle.clean = false;\n          rstyle.cleanConnected = false;\n        }\n      }\n    };\n\n    r.binder(cy).on('bounds.* dirty.*', function onDirtyBounds(e) {\n      var ele = e.target;\n      enqueue(ele);\n    }).on('style.* background.*', function onDirtyStyle(e) {\n      var ele = e.target;\n      enqueue(ele, false);\n    });\n\n    var updateEleCalcs = function updateEleCalcs(willDraw) {\n      if (willDraw) {\n        var fns = r.onUpdateEleCalcsFns; // because we need to have up-to-date style (e.g. stylesheet mappers)\n        // before calculating rendered style (and pstyle might not be called yet)\n\n        elesToUpdate.cleanStyle();\n\n        for (var i = 0; i < elesToUpdate.length; i++) {\n          var ele = elesToUpdate[i];\n          var rstyle = ele._private.rstyle;\n\n          if (ele.isNode() && !rstyle.cleanConnected) {\n            enqueue(ele.connectedEdges());\n            rstyle.cleanConnected = true;\n          }\n        }\n\n        if (fns) {\n          for (var _i = 0; _i < fns.length; _i++) {\n            var fn = fns[_i];\n            fn(willDraw, elesToUpdate);\n          }\n        }\n\n        r.recalculateRenderedStyle(elesToUpdate);\n        elesToUpdate = cy.collection();\n      }\n    };\n\n    r.flushRenderedStyleQueue = function () {\n      updateEleCalcs(true);\n    };\n\n    r.beforeRender(updateEleCalcs, r.beforeRenderPriorities.eleCalcs);\n  };\n\n  BRp$7.onUpdateEleCalcs = function (fn) {\n    var fns = this.onUpdateEleCalcsFns = this.onUpdateEleCalcsFns || [];\n    fns.push(fn);\n  };\n\n  BRp$7.recalculateRenderedStyle = function (eles, useCache) {\n    var isCleanConnected = function isCleanConnected(ele) {\n      return ele._private.rstyle.cleanConnected;\n    };\n\n    var edges = [];\n    var nodes = []; // the renderer can't be used for calcs when destroyed, e.g. ele.boundingBox()\n\n    if (this.destroyed) {\n      return;\n    } // use cache by default for perf\n\n\n    if (useCache === undefined) {\n      useCache = true;\n    }\n\n    for (var i = 0; i < eles.length; i++) {\n      var ele = eles[i];\n      var _p = ele._private;\n      var rstyle = _p.rstyle; // an edge may be implicitly dirty b/c of one of its connected nodes\n      // (and a request for recalc may come in between frames)\n\n      if (ele.isEdge() && (!isCleanConnected(ele.source()) || !isCleanConnected(ele.target()))) {\n        rstyle.clean = false;\n      } // only update if dirty and in graph\n\n\n      if (useCache && rstyle.clean || ele.removed()) {\n        continue;\n      } // only update if not display: none\n\n\n      if (ele.pstyle('display').value === 'none') {\n        continue;\n      }\n\n      if (_p.group === 'nodes') {\n        nodes.push(ele);\n      } else {\n        // edges\n        edges.push(ele);\n      }\n\n      rstyle.clean = true;\n    } // update node data from projections\n\n\n    for (var _i2 = 0; _i2 < nodes.length; _i2++) {\n      var _ele = nodes[_i2];\n      var _p2 = _ele._private;\n      var _rstyle = _p2.rstyle;\n\n      var pos = _ele.position();\n\n      this.recalculateNodeLabelProjection(_ele);\n      _rstyle.nodeX = pos.x;\n      _rstyle.nodeY = pos.y;\n      _rstyle.nodeW = _ele.pstyle('width').pfValue;\n      _rstyle.nodeH = _ele.pstyle('height').pfValue;\n    }\n\n    this.recalculateEdgeProjections(edges); // update edge data from projections\n\n    for (var _i3 = 0; _i3 < edges.length; _i3++) {\n      var _ele2 = edges[_i3];\n      var _p3 = _ele2._private;\n      var _rstyle2 = _p3.rstyle;\n      var rs = _p3.rscratch; // update rstyle positions\n\n      _rstyle2.srcX = rs.arrowStartX;\n      _rstyle2.srcY = rs.arrowStartY;\n      _rstyle2.tgtX = rs.arrowEndX;\n      _rstyle2.tgtY = rs.arrowEndY;\n      _rstyle2.midX = rs.midX;\n      _rstyle2.midY = rs.midY;\n      _rstyle2.labelAngle = rs.labelAngle;\n      _rstyle2.sourceLabelAngle = rs.sourceLabelAngle;\n      _rstyle2.targetLabelAngle = rs.targetLabelAngle;\n    }\n  };\n\n  var BRp$6 = {};\n\n  BRp$6.updateCachedGrabbedEles = function () {\n    var eles = this.cachedZSortedEles;\n\n    if (!eles) {\n      // just let this be recalculated on the next z sort tick\n      return;\n    }\n\n    eles.drag = [];\n    eles.nondrag = [];\n    var grabTargets = [];\n\n    for (var i = 0; i < eles.length; i++) {\n      var ele = eles[i];\n      var rs = ele._private.rscratch;\n\n      if (ele.grabbed() && !ele.isParent()) {\n        grabTargets.push(ele);\n      } else if (rs.inDragLayer) {\n        eles.drag.push(ele);\n      } else {\n        eles.nondrag.push(ele);\n      }\n    } // put the grab target nodes last so it's on top of its neighbourhood\n\n\n    for (var i = 0; i < grabTargets.length; i++) {\n      var ele = grabTargets[i];\n      eles.drag.push(ele);\n    }\n  };\n\n  BRp$6.invalidateCachedZSortedEles = function () {\n    this.cachedZSortedEles = null;\n  };\n\n  BRp$6.getCachedZSortedEles = function (forceRecalc) {\n    if (forceRecalc || !this.cachedZSortedEles) {\n      var eles = this.cy.mutableElements().toArray();\n      eles.sort(zIndexSort);\n      eles.interactive = eles.filter(function (ele) {\n        return ele.interactive();\n      });\n      this.cachedZSortedEles = eles;\n      this.updateCachedGrabbedEles();\n    } else {\n      eles = this.cachedZSortedEles;\n    }\n\n    return eles;\n  };\n\n  var BRp$5 = {};\n  [BRp$e, BRp$d, BRp$c, BRp$b, BRp$a, BRp$9, BRp$8, BRp$7, BRp$6].forEach(function (props) {\n    extend(BRp$5, props);\n  });\n\n  var BRp$4 = {};\n\n  BRp$4.getCachedImage = function (url, crossOrigin, onLoad) {\n    var r = this;\n    var imageCache = r.imageCache = r.imageCache || {};\n    var cache = imageCache[url];\n\n    if (cache) {\n      if (!cache.image.complete) {\n        cache.image.addEventListener('load', onLoad);\n      }\n\n      return cache.image;\n    } else {\n      cache = imageCache[url] = imageCache[url] || {};\n      var image = cache.image = new Image(); // eslint-disable-line no-undef\n\n      image.addEventListener('load', onLoad);\n      image.addEventListener('error', function () {\n        image.error = true;\n      }); // #1582 safari doesn't load data uris with crossOrigin properly\n      // https://bugs.webkit.org/show_bug.cgi?id=123978\n\n      var dataUriPrefix = 'data:';\n      var isDataUri = url.substring(0, dataUriPrefix.length).toLowerCase() === dataUriPrefix;\n\n      if (!isDataUri) {\n        // if crossorigin is 'null'(stringified), then manually set it to null \n        crossOrigin = crossOrigin === 'null' ? null : crossOrigin;\n        image.crossOrigin = crossOrigin; // prevent tainted canvas\n      }\n\n      image.src = url;\n      return image;\n    }\n  };\n\n  var BRp$3 = {};\n  /* global document, window, ResizeObserver, MutationObserver */\n\n  BRp$3.registerBinding = function (target, event, handler, useCapture) {\n    // eslint-disable-line no-unused-vars\n    var args = Array.prototype.slice.apply(arguments, [1]); // copy\n\n    var b = this.binder(target);\n    return b.on.apply(b, args);\n  };\n\n  BRp$3.binder = function (tgt) {\n    var r = this;\n    var tgtIsDom = tgt === window || tgt === document || tgt === document.body || domElement(tgt);\n\n    if (r.supportsPassiveEvents == null) {\n      // from https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md#feature-detection\n      var supportsPassive = false;\n\n      try {\n        var opts = Object.defineProperty({}, 'passive', {\n          get: function get() {\n            supportsPassive = true;\n            return true;\n          }\n        });\n        window.addEventListener('test', null, opts);\n      } catch (err) {// not supported\n      }\n\n      r.supportsPassiveEvents = supportsPassive;\n    }\n\n    var on = function on(event, handler, useCapture) {\n      var args = Array.prototype.slice.call(arguments);\n\n      if (tgtIsDom && r.supportsPassiveEvents) {\n        // replace useCapture w/ opts obj\n        args[2] = {\n          capture: useCapture != null ? useCapture : false,\n          passive: false,\n          once: false\n        };\n      }\n\n      r.bindings.push({\n        target: tgt,\n        args: args\n      });\n      (tgt.addEventListener || tgt.on).apply(tgt, args);\n      return this;\n    };\n\n    return {\n      on: on,\n      addEventListener: on,\n      addListener: on,\n      bind: on\n    };\n  };\n\n  BRp$3.nodeIsDraggable = function (node) {\n    return node && node.isNode() && !node.locked() && node.grabbable();\n  };\n\n  BRp$3.nodeIsGrabbable = function (node) {\n    return this.nodeIsDraggable(node) && node.interactive();\n  };\n\n  BRp$3.load = function () {\n    var r = this;\n\n    var isSelected = function isSelected(ele) {\n      return ele.selected();\n    };\n\n    var triggerEvents = function triggerEvents(target, names, e, position) {\n      if (target == null) {\n        target = r.cy;\n      }\n\n      for (var i = 0; i < names.length; i++) {\n        var name = names[i];\n        target.emit({\n          originalEvent: e,\n          type: name,\n          position: position\n        });\n      }\n    };\n\n    var isMultSelKeyDown = function isMultSelKeyDown(e) {\n      return e.shiftKey || e.metaKey || e.ctrlKey; // maybe e.altKey\n    };\n\n    var allowPanningPassthrough = function allowPanningPassthrough(down, downs) {\n      var allowPassthrough = true;\n\n      if (r.cy.hasCompoundNodes() && down && down.pannable()) {\n        // a grabbable compound node below the ele => no passthrough panning\n        for (var i = 0; downs && i < downs.length; i++) {\n          var down = downs[i]; //if any parent node in event hierarchy isn't pannable, reject passthrough\n\n          if (down.isNode() && down.isParent() && !down.pannable()) {\n            allowPassthrough = false;\n            break;\n          }\n        }\n      } else {\n        allowPassthrough = true;\n      }\n\n      return allowPassthrough;\n    };\n\n    var setGrabbed = function setGrabbed(ele) {\n      ele[0]._private.grabbed = true;\n    };\n\n    var setFreed = function setFreed(ele) {\n      ele[0]._private.grabbed = false;\n    };\n\n    var setInDragLayer = function setInDragLayer(ele) {\n      ele[0]._private.rscratch.inDragLayer = true;\n    };\n\n    var setOutDragLayer = function setOutDragLayer(ele) {\n      ele[0]._private.rscratch.inDragLayer = false;\n    };\n\n    var setGrabTarget = function setGrabTarget(ele) {\n      ele[0]._private.rscratch.isGrabTarget = true;\n    };\n\n    var removeGrabTarget = function removeGrabTarget(ele) {\n      ele[0]._private.rscratch.isGrabTarget = false;\n    };\n\n    var addToDragList = function addToDragList(ele, opts) {\n      var list = opts.addToList;\n      var listHasEle = list.has(ele);\n\n      if (!listHasEle && ele.grabbable() && !ele.locked()) {\n        list.merge(ele);\n        setGrabbed(ele);\n      }\n    }; // helper function to determine which child nodes and inner edges\n    // of a compound node to be dragged as well as the grabbed and selected nodes\n\n\n    var addDescendantsToDrag = function addDescendantsToDrag(node, opts) {\n      if (!node.cy().hasCompoundNodes()) {\n        return;\n      }\n\n      if (opts.inDragLayer == null && opts.addToList == null) {\n        return;\n      } // nothing to do\n\n\n      var innerNodes = node.descendants();\n\n      if (opts.inDragLayer) {\n        innerNodes.forEach(setInDragLayer);\n        innerNodes.connectedEdges().forEach(setInDragLayer);\n      }\n\n      if (opts.addToList) {\n        addToDragList(innerNodes, opts);\n      }\n    }; // adds the given nodes and its neighbourhood to the drag layer\n\n\n    var addNodesToDrag = function addNodesToDrag(nodes, opts) {\n      opts = opts || {};\n      var hasCompoundNodes = nodes.cy().hasCompoundNodes();\n\n      if (opts.inDragLayer) {\n        nodes.forEach(setInDragLayer);\n        nodes.neighborhood().stdFilter(function (ele) {\n          return !hasCompoundNodes || ele.isEdge();\n        }).forEach(setInDragLayer);\n      }\n\n      if (opts.addToList) {\n        nodes.forEach(function (ele) {\n          addToDragList(ele, opts);\n        });\n      }\n\n      addDescendantsToDrag(nodes, opts); // always add to drag\n      // also add nodes and edges related to the topmost ancestor\n\n      updateAncestorsInDragLayer(nodes, {\n        inDragLayer: opts.inDragLayer\n      });\n      r.updateCachedGrabbedEles();\n    };\n\n    var addNodeToDrag = addNodesToDrag;\n\n    var freeDraggedElements = function freeDraggedElements(grabbedEles) {\n      if (!grabbedEles) {\n        return;\n      } // just go over all elements rather than doing a bunch of (possibly expensive) traversals\n\n\n      r.getCachedZSortedEles().forEach(function (ele) {\n        setFreed(ele);\n        setOutDragLayer(ele);\n        removeGrabTarget(ele);\n      });\n      r.updateCachedGrabbedEles();\n    }; // helper function to determine which ancestor nodes and edges should go\n    // to the drag layer (or should be removed from drag layer).\n\n\n    var updateAncestorsInDragLayer = function updateAncestorsInDragLayer(node, opts) {\n      if (opts.inDragLayer == null && opts.addToList == null) {\n        return;\n      } // nothing to do\n\n\n      if (!node.cy().hasCompoundNodes()) {\n        return;\n      } // find top-level parent\n\n\n      var parent = node.ancestors().orphans(); // no parent node: no nodes to add to the drag layer\n\n      if (parent.same(node)) {\n        return;\n      }\n\n      var nodes = parent.descendants().spawnSelf().merge(parent).unmerge(node).unmerge(node.descendants());\n      var edges = nodes.connectedEdges();\n\n      if (opts.inDragLayer) {\n        edges.forEach(setInDragLayer);\n        nodes.forEach(setInDragLayer);\n      }\n\n      if (opts.addToList) {\n        nodes.forEach(function (ele) {\n          addToDragList(ele, opts);\n        });\n      }\n    };\n\n    var blurActiveDomElement = function blurActiveDomElement() {\n      if (document.activeElement != null && document.activeElement.blur != null) {\n        document.activeElement.blur();\n      }\n    };\n\n    var haveMutationsApi = typeof MutationObserver !== 'undefined';\n    var haveResizeObserverApi = typeof ResizeObserver !== 'undefined'; // watch for when the cy container is removed from the dom\n\n    if (haveMutationsApi) {\n      r.removeObserver = new MutationObserver(function (mutns) {\n        // eslint-disable-line no-undef\n        for (var i = 0; i < mutns.length; i++) {\n          var mutn = mutns[i];\n          var rNodes = mutn.removedNodes;\n\n          if (rNodes) {\n            for (var j = 0; j < rNodes.length; j++) {\n              var rNode = rNodes[j];\n\n              if (rNode === r.container) {\n                r.destroy();\n                break;\n              }\n            }\n          }\n        }\n      });\n\n      if (r.container.parentNode) {\n        r.removeObserver.observe(r.container.parentNode, {\n          childList: true\n        });\n      }\n    } else {\n      r.registerBinding(r.container, 'DOMNodeRemoved', function (e) {\n        // eslint-disable-line no-unused-vars\n        r.destroy();\n      });\n    }\n\n    var onResize = debounce_1(function () {\n      r.cy.resize();\n    }, 100);\n\n    if (haveMutationsApi) {\n      r.styleObserver = new MutationObserver(onResize); // eslint-disable-line no-undef\n\n      r.styleObserver.observe(r.container, {\n        attributes: true\n      });\n    } // auto resize\n\n\n    r.registerBinding(window, 'resize', onResize); // eslint-disable-line no-undef\n\n    if (haveResizeObserverApi) {\n      r.resizeObserver = new ResizeObserver(onResize); // eslint-disable-line no-undef\n\n      r.resizeObserver.observe(r.container);\n    }\n\n    var forEachUp = function forEachUp(domEle, fn) {\n      while (domEle != null) {\n        fn(domEle);\n        domEle = domEle.parentNode;\n      }\n    };\n\n    var invalidateCoords = function invalidateCoords() {\n      r.invalidateContainerClientCoordsCache();\n    };\n\n    forEachUp(r.container, function (domEle) {\n      r.registerBinding(domEle, 'transitionend', invalidateCoords);\n      r.registerBinding(domEle, 'animationend', invalidateCoords);\n      r.registerBinding(domEle, 'scroll', invalidateCoords);\n    }); // stop right click menu from appearing on cy\n\n    r.registerBinding(r.container, 'contextmenu', function (e) {\n      e.preventDefault();\n    });\n\n    var inBoxSelection = function inBoxSelection() {\n      return r.selection[4] !== 0;\n    };\n\n    var eventInContainer = function eventInContainer(e) {\n      // save cycles if mouse events aren't to be captured\n      var containerPageCoords = r.findContainerClientCoords();\n      var x = containerPageCoords[0];\n      var y = containerPageCoords[1];\n      var width = containerPageCoords[2];\n      var height = containerPageCoords[3];\n      var positions = e.touches ? e.touches : [e];\n      var atLeastOnePosInside = false;\n\n      for (var i = 0; i < positions.length; i++) {\n        var p = positions[i];\n\n        if (x <= p.clientX && p.clientX <= x + width && y <= p.clientY && p.clientY <= y + height) {\n          atLeastOnePosInside = true;\n          break;\n        }\n      }\n\n      if (!atLeastOnePosInside) {\n        return false;\n      }\n\n      var container = r.container;\n      var target = e.target;\n      var tParent = target.parentNode;\n      var containerIsTarget = false;\n\n      while (tParent) {\n        if (tParent === container) {\n          containerIsTarget = true;\n          break;\n        }\n\n        tParent = tParent.parentNode;\n      }\n\n      if (!containerIsTarget) {\n        return false;\n      } // if target is outisde cy container, then this event is not for us\n\n\n      return true;\n    }; // Primary key\n\n\n    r.registerBinding(r.container, 'mousedown', function mousedownHandler(e) {\n      if (!eventInContainer(e)) {\n        return;\n      }\n\n      e.preventDefault();\n      blurActiveDomElement();\n      r.hoverData.capture = true;\n      r.hoverData.which = e.which;\n      var cy = r.cy;\n      var gpos = [e.clientX, e.clientY];\n      var pos = r.projectIntoViewport(gpos[0], gpos[1]);\n      var select = r.selection;\n      var nears = r.findNearestElements(pos[0], pos[1], true, false);\n      var near = nears[0];\n      var draggedElements = r.dragData.possibleDragElements;\n      r.hoverData.mdownPos = pos;\n      r.hoverData.mdownGPos = gpos;\n\n      var checkForTaphold = function checkForTaphold() {\n        r.hoverData.tapholdCancelled = false;\n        clearTimeout(r.hoverData.tapholdTimeout);\n        r.hoverData.tapholdTimeout = setTimeout(function () {\n          if (r.hoverData.tapholdCancelled) {\n            return;\n          } else {\n            var ele = r.hoverData.down;\n\n            if (ele) {\n              ele.emit({\n                originalEvent: e,\n                type: 'taphold',\n                position: {\n                  x: pos[0],\n                  y: pos[1]\n                }\n              });\n            } else {\n              cy.emit({\n                originalEvent: e,\n                type: 'taphold',\n                position: {\n                  x: pos[0],\n                  y: pos[1]\n                }\n              });\n            }\n          }\n        }, r.tapholdDuration);\n      }; // Right click button\n\n\n      if (e.which == 3) {\n        r.hoverData.cxtStarted = true;\n        var cxtEvt = {\n          originalEvent: e,\n          type: 'cxttapstart',\n          position: {\n            x: pos[0],\n            y: pos[1]\n          }\n        };\n\n        if (near) {\n          near.activate();\n          near.emit(cxtEvt);\n          r.hoverData.down = near;\n        } else {\n          cy.emit(cxtEvt);\n        }\n\n        r.hoverData.downTime = new Date().getTime();\n        r.hoverData.cxtDragged = false; // Primary button\n      } else if (e.which == 1) {\n        if (near) {\n          near.activate();\n        } // Element dragging\n\n\n        {\n          // If something is under the cursor and it is draggable, prepare to grab it\n          if (near != null) {\n            if (r.nodeIsGrabbable(near)) {\n              var makeEvent = function makeEvent(type) {\n                return {\n                  originalEvent: e,\n                  type: type,\n                  position: {\n                    x: pos[0],\n                    y: pos[1]\n                  }\n                };\n              };\n\n              var triggerGrab = function triggerGrab(ele) {\n                ele.emit(makeEvent('grab'));\n              };\n\n              setGrabTarget(near);\n\n              if (!near.selected()) {\n                draggedElements = r.dragData.possibleDragElements = cy.collection();\n                addNodeToDrag(near, {\n                  addToList: draggedElements\n                });\n                near.emit(makeEvent('grabon')).emit(makeEvent('grab'));\n              } else {\n                draggedElements = r.dragData.possibleDragElements = cy.collection();\n                var selectedNodes = cy.$(function (ele) {\n                  return ele.isNode() && ele.selected() && r.nodeIsGrabbable(ele);\n                });\n                addNodesToDrag(selectedNodes, {\n                  addToList: draggedElements\n                });\n                near.emit(makeEvent('grabon'));\n                selectedNodes.forEach(triggerGrab);\n              }\n\n              r.redrawHint('eles', true);\n              r.redrawHint('drag', true);\n            }\n          }\n\n          r.hoverData.down = near;\n          r.hoverData.downs = nears;\n          r.hoverData.downTime = new Date().getTime();\n        }\n        triggerEvents(near, ['mousedown', 'tapstart', 'vmousedown'], e, {\n          x: pos[0],\n          y: pos[1]\n        });\n\n        if (near == null) {\n          select[4] = 1;\n          r.data.bgActivePosistion = {\n            x: pos[0],\n            y: pos[1]\n          };\n          r.redrawHint('select', true);\n          r.redraw();\n        } else if (near.pannable()) {\n          select[4] = 1; // for future pan\n        }\n\n        checkForTaphold();\n      } // Initialize selection box coordinates\n\n\n      select[0] = select[2] = pos[0];\n      select[1] = select[3] = pos[1];\n    }, false);\n    r.registerBinding(window, 'mousemove', function mousemoveHandler(e) {\n      // eslint-disable-line no-undef\n      var capture = r.hoverData.capture;\n\n      if (!capture && !eventInContainer(e)) {\n        return;\n      }\n\n      var preventDefault = false;\n      var cy = r.cy;\n      var zoom = cy.zoom();\n      var gpos = [e.clientX, e.clientY];\n      var pos = r.projectIntoViewport(gpos[0], gpos[1]);\n      var mdownPos = r.hoverData.mdownPos;\n      var mdownGPos = r.hoverData.mdownGPos;\n      var select = r.selection;\n      var near = null;\n\n      if (!r.hoverData.draggingEles && !r.hoverData.dragging && !r.hoverData.selecting) {\n        near = r.findNearestElement(pos[0], pos[1], true, false);\n      }\n\n      var last = r.hoverData.last;\n      var down = r.hoverData.down;\n      var disp = [pos[0] - select[2], pos[1] - select[3]];\n      var draggedElements = r.dragData.possibleDragElements;\n      var isOverThresholdDrag;\n\n      if (mdownGPos) {\n        var dx = gpos[0] - mdownGPos[0];\n        var dx2 = dx * dx;\n        var dy = gpos[1] - mdownGPos[1];\n        var dy2 = dy * dy;\n        var dist2 = dx2 + dy2;\n        r.hoverData.isOverThresholdDrag = isOverThresholdDrag = dist2 >= r.desktopTapThreshold2;\n      }\n\n      var multSelKeyDown = isMultSelKeyDown(e);\n\n      if (isOverThresholdDrag) {\n        r.hoverData.tapholdCancelled = true;\n      }\n\n      var updateDragDelta = function updateDragDelta() {\n        var dragDelta = r.hoverData.dragDelta = r.hoverData.dragDelta || [];\n\n        if (dragDelta.length === 0) {\n          dragDelta.push(disp[0]);\n          dragDelta.push(disp[1]);\n        } else {\n          dragDelta[0] += disp[0];\n          dragDelta[1] += disp[1];\n        }\n      };\n\n      preventDefault = true;\n      triggerEvents(near, ['mousemove', 'vmousemove', 'tapdrag'], e, {\n        x: pos[0],\n        y: pos[1]\n      });\n\n      var goIntoBoxMode = function goIntoBoxMode() {\n        r.data.bgActivePosistion = undefined;\n\n        if (!r.hoverData.selecting) {\n          cy.emit({\n            originalEvent: e,\n            type: 'boxstart',\n            position: {\n              x: pos[0],\n              y: pos[1]\n            }\n          });\n        }\n\n        select[4] = 1;\n        r.hoverData.selecting = true;\n        r.redrawHint('select', true);\n        r.redraw();\n      }; // trigger context drag if rmouse down\n\n\n      if (r.hoverData.which === 3) {\n        // but only if over threshold\n        if (isOverThresholdDrag) {\n          var cxtEvt = {\n            originalEvent: e,\n            type: 'cxtdrag',\n            position: {\n              x: pos[0],\n              y: pos[1]\n            }\n          };\n\n          if (down) {\n            down.emit(cxtEvt);\n          } else {\n            cy.emit(cxtEvt);\n          }\n\n          r.hoverData.cxtDragged = true;\n\n          if (!r.hoverData.cxtOver || near !== r.hoverData.cxtOver) {\n            if (r.hoverData.cxtOver) {\n              r.hoverData.cxtOver.emit({\n                originalEvent: e,\n                type: 'cxtdragout',\n                position: {\n                  x: pos[0],\n                  y: pos[1]\n                }\n              });\n            }\n\n            r.hoverData.cxtOver = near;\n\n            if (near) {\n              near.emit({\n                originalEvent: e,\n                type: 'cxtdragover',\n                position: {\n                  x: pos[0],\n                  y: pos[1]\n                }\n              });\n            }\n          }\n        } // Check if we are drag panning the entire graph\n\n      } else if (r.hoverData.dragging) {\n        preventDefault = true;\n\n        if (cy.panningEnabled() && cy.userPanningEnabled()) {\n          var deltaP;\n\n          if (r.hoverData.justStartedPan) {\n            var mdPos = r.hoverData.mdownPos;\n            deltaP = {\n              x: (pos[0] - mdPos[0]) * zoom,\n              y: (pos[1] - mdPos[1]) * zoom\n            };\n            r.hoverData.justStartedPan = false;\n          } else {\n            deltaP = {\n              x: disp[0] * zoom,\n              y: disp[1] * zoom\n            };\n          }\n\n          cy.panBy(deltaP);\n          cy.emit('dragpan');\n          r.hoverData.dragged = true;\n        } // Needs reproject due to pan changing viewport\n\n\n        pos = r.projectIntoViewport(e.clientX, e.clientY); // Checks primary button down & out of time & mouse not moved much\n      } else if (select[4] == 1 && (down == null || down.pannable())) {\n        if (isOverThresholdDrag) {\n          if (!r.hoverData.dragging && cy.boxSelectionEnabled() && (multSelKeyDown || !cy.panningEnabled() || !cy.userPanningEnabled())) {\n            goIntoBoxMode();\n          } else if (!r.hoverData.selecting && cy.panningEnabled() && cy.userPanningEnabled()) {\n            var allowPassthrough = allowPanningPassthrough(down, r.hoverData.downs);\n\n            if (allowPassthrough) {\n              r.hoverData.dragging = true;\n              r.hoverData.justStartedPan = true;\n              select[4] = 0;\n              r.data.bgActivePosistion = array2point(mdownPos);\n              r.redrawHint('select', true);\n              r.redraw();\n            }\n          }\n\n          if (down && down.pannable() && down.active()) {\n            down.unactivate();\n          }\n        }\n      } else {\n        if (down && down.pannable() && down.active()) {\n          down.unactivate();\n        }\n\n        if ((!down || !down.grabbed()) && near != last) {\n          if (last) {\n            triggerEvents(last, ['mouseout', 'tapdragout'], e, {\n              x: pos[0],\n              y: pos[1]\n            });\n          }\n\n          if (near) {\n            triggerEvents(near, ['mouseover', 'tapdragover'], e, {\n              x: pos[0],\n              y: pos[1]\n            });\n          }\n\n          r.hoverData.last = near;\n        }\n\n        if (down) {\n          if (isOverThresholdDrag) {\n            // then we can take action\n            if (cy.boxSelectionEnabled() && multSelKeyDown) {\n              // then selection overrides\n              if (down && down.grabbed()) {\n                freeDraggedElements(draggedElements);\n                down.emit('freeon');\n                draggedElements.emit('free');\n\n                if (r.dragData.didDrag) {\n                  down.emit('dragfreeon');\n                  draggedElements.emit('dragfree');\n                }\n              }\n\n              goIntoBoxMode();\n            } else if (down && down.grabbed() && r.nodeIsDraggable(down)) {\n              // drag node\n              var justStartedDrag = !r.dragData.didDrag;\n\n              if (justStartedDrag) {\n                r.redrawHint('eles', true);\n              }\n\n              r.dragData.didDrag = true; // indicate that we actually did drag the node\n              // now, add the elements to the drag layer if not done already\n\n              if (!r.hoverData.draggingEles) {\n                addNodesToDrag(draggedElements, {\n                  inDragLayer: true\n                });\n              }\n\n              var totalShift = {\n                x: 0,\n                y: 0\n              };\n\n              if (number$1(disp[0]) && number$1(disp[1])) {\n                totalShift.x += disp[0];\n                totalShift.y += disp[1];\n\n                if (justStartedDrag) {\n                  var dragDelta = r.hoverData.dragDelta;\n\n                  if (dragDelta && number$1(dragDelta[0]) && number$1(dragDelta[1])) {\n                    totalShift.x += dragDelta[0];\n                    totalShift.y += dragDelta[1];\n                  }\n                }\n              }\n\n              r.hoverData.draggingEles = true;\n              draggedElements.silentShift(totalShift).emit('position drag');\n              r.redrawHint('drag', true);\n              r.redraw();\n            }\n          } else {\n            // otherwise save drag delta for when we actually start dragging so the relative grab pos is constant\n            updateDragDelta();\n          }\n        } // prevent the dragging from triggering text selection on the page\n\n\n        preventDefault = true;\n      }\n\n      select[2] = pos[0];\n      select[3] = pos[1];\n\n      if (preventDefault) {\n        if (e.stopPropagation) e.stopPropagation();\n        if (e.preventDefault) e.preventDefault();\n        return false;\n      }\n    }, false);\n    var clickTimeout, didDoubleClick, prevClickTimeStamp;\n    r.registerBinding(window, 'mouseup', function mouseupHandler(e) {\n      // eslint-disable-line no-undef\n      var capture = r.hoverData.capture;\n\n      if (!capture) {\n        return;\n      }\n\n      r.hoverData.capture = false;\n      var cy = r.cy;\n      var pos = r.projectIntoViewport(e.clientX, e.clientY);\n      var select = r.selection;\n      var near = r.findNearestElement(pos[0], pos[1], true, false);\n      var draggedElements = r.dragData.possibleDragElements;\n      var down = r.hoverData.down;\n      var multSelKeyDown = isMultSelKeyDown(e);\n\n      if (r.data.bgActivePosistion) {\n        r.redrawHint('select', true);\n        r.redraw();\n      }\n\n      r.hoverData.tapholdCancelled = true;\n      r.data.bgActivePosistion = undefined; // not active bg now\n\n      if (down) {\n        down.unactivate();\n      }\n\n      if (r.hoverData.which === 3) {\n        var cxtEvt = {\n          originalEvent: e,\n          type: 'cxttapend',\n          position: {\n            x: pos[0],\n            y: pos[1]\n          }\n        };\n\n        if (down) {\n          down.emit(cxtEvt);\n        } else {\n          cy.emit(cxtEvt);\n        }\n\n        if (!r.hoverData.cxtDragged) {\n          var cxtTap = {\n            originalEvent: e,\n            type: 'cxttap',\n            position: {\n              x: pos[0],\n              y: pos[1]\n            }\n          };\n\n          if (down) {\n            down.emit(cxtTap);\n          } else {\n            cy.emit(cxtTap);\n          }\n        }\n\n        r.hoverData.cxtDragged = false;\n        r.hoverData.which = null;\n      } else if (r.hoverData.which === 1) {\n        triggerEvents(near, ['mouseup', 'tapend', 'vmouseup'], e, {\n          x: pos[0],\n          y: pos[1]\n        });\n\n        if (!r.dragData.didDrag && // didn't move a node around\n        !r.hoverData.dragged && // didn't pan\n        !r.hoverData.selecting && // not box selection\n        !r.hoverData.isOverThresholdDrag // didn't move too much\n        ) {\n          triggerEvents(down, [\"click\", \"tap\", \"vclick\"], e, {\n            x: pos[0],\n            y: pos[1]\n          });\n          didDoubleClick = false;\n\n          if (e.timeStamp - prevClickTimeStamp <= cy.multiClickDebounceTime()) {\n            clickTimeout && clearTimeout(clickTimeout);\n            didDoubleClick = true;\n            prevClickTimeStamp = null;\n            triggerEvents(down, [\"dblclick\", \"dbltap\", \"vdblclick\"], e, {\n              x: pos[0],\n              y: pos[1]\n            });\n          } else {\n            clickTimeout = setTimeout(function () {\n              if (didDoubleClick) return;\n              triggerEvents(down, [\"oneclick\", \"onetap\", \"voneclick\"], e, {\n                x: pos[0],\n                y: pos[1]\n              });\n            }, cy.multiClickDebounceTime());\n            prevClickTimeStamp = e.timeStamp;\n          }\n        } // Deselect all elements if nothing is currently under the mouse cursor and we aren't dragging something\n\n\n        if (down == null // not mousedown on node\n        && !r.dragData.didDrag // didn't move the node around\n        && !r.hoverData.selecting // not box selection\n        && !r.hoverData.dragged // didn't pan\n        && !isMultSelKeyDown(e)) {\n          cy.$(isSelected).unselect(['tapunselect']);\n\n          if (draggedElements.length > 0) {\n            r.redrawHint('eles', true);\n          }\n\n          r.dragData.possibleDragElements = draggedElements = cy.collection();\n        } // Single selection\n\n\n        if (near == down && !r.dragData.didDrag && !r.hoverData.selecting) {\n          if (near != null && near._private.selectable) {\n            if (r.hoverData.dragging) ; else if (cy.selectionType() === 'additive' || multSelKeyDown) {\n              if (near.selected()) {\n                near.unselect(['tapunselect']);\n              } else {\n                near.select(['tapselect']);\n              }\n            } else {\n              if (!multSelKeyDown) {\n                cy.$(isSelected).unmerge(near).unselect(['tapunselect']);\n                near.select(['tapselect']);\n              }\n            }\n\n            r.redrawHint('eles', true);\n          }\n        }\n\n        if (r.hoverData.selecting) {\n          var box = cy.collection(r.getAllInBox(select[0], select[1], select[2], select[3]));\n          r.redrawHint('select', true);\n\n          if (box.length > 0) {\n            r.redrawHint('eles', true);\n          }\n\n          cy.emit({\n            type: 'boxend',\n            originalEvent: e,\n            position: {\n              x: pos[0],\n              y: pos[1]\n            }\n          });\n\n          var eleWouldBeSelected = function eleWouldBeSelected(ele) {\n            return ele.selectable() && !ele.selected();\n          };\n\n          if (cy.selectionType() === 'additive') {\n            box.emit('box').stdFilter(eleWouldBeSelected).select().emit('boxselect');\n          } else {\n            if (!multSelKeyDown) {\n              cy.$(isSelected).unmerge(box).unselect();\n            }\n\n            box.emit('box').stdFilter(eleWouldBeSelected).select().emit('boxselect');\n          } // always need redraw in case eles unselectable\n\n\n          r.redraw();\n        } // Cancel drag pan\n\n\n        if (r.hoverData.dragging) {\n          r.hoverData.dragging = false;\n          r.redrawHint('select', true);\n          r.redrawHint('eles', true);\n          r.redraw();\n        }\n\n        if (!select[4]) {\n          r.redrawHint('drag', true);\n          r.redrawHint('eles', true);\n          var downWasGrabbed = down && down.grabbed();\n          freeDraggedElements(draggedElements);\n\n          if (downWasGrabbed) {\n            down.emit('freeon');\n            draggedElements.emit('free');\n\n            if (r.dragData.didDrag) {\n              down.emit('dragfreeon');\n              draggedElements.emit('dragfree');\n            }\n          }\n        }\n      } // else not right mouse\n\n\n      select[4] = 0;\n      r.hoverData.down = null;\n      r.hoverData.cxtStarted = false;\n      r.hoverData.draggingEles = false;\n      r.hoverData.selecting = false;\n      r.hoverData.isOverThresholdDrag = false;\n      r.dragData.didDrag = false;\n      r.hoverData.dragged = false;\n      r.hoverData.dragDelta = [];\n      r.hoverData.mdownPos = null;\n      r.hoverData.mdownGPos = null;\n    }, false);\n\n    var wheelHandler = function wheelHandler(e) {\n      if (r.scrollingPage) {\n        return;\n      } // while scrolling, ignore wheel-to-zoom\n\n\n      var cy = r.cy;\n      var zoom = cy.zoom();\n      var pan = cy.pan();\n      var pos = r.projectIntoViewport(e.clientX, e.clientY);\n      var rpos = [pos[0] * zoom + pan.x, pos[1] * zoom + pan.y];\n\n      if (r.hoverData.draggingEles || r.hoverData.dragging || r.hoverData.cxtStarted || inBoxSelection()) {\n        // if pan dragging or cxt dragging, wheel movements make no zoom\n        e.preventDefault();\n        return;\n      }\n\n      if (cy.panningEnabled() && cy.userPanningEnabled() && cy.zoomingEnabled() && cy.userZoomingEnabled()) {\n        e.preventDefault();\n        r.data.wheelZooming = true;\n        clearTimeout(r.data.wheelTimeout);\n        r.data.wheelTimeout = setTimeout(function () {\n          r.data.wheelZooming = false;\n          r.redrawHint('eles', true);\n          r.redraw();\n        }, 150);\n        var diff;\n\n        if (e.deltaY != null) {\n          diff = e.deltaY / -250;\n        } else if (e.wheelDeltaY != null) {\n          diff = e.wheelDeltaY / 1000;\n        } else {\n          diff = e.wheelDelta / 1000;\n        }\n\n        diff = diff * r.wheelSensitivity;\n        var needsWheelFix = e.deltaMode === 1;\n\n        if (needsWheelFix) {\n          // fixes slow wheel events on ff/linux and ff/windows\n          diff *= 33;\n        }\n\n        var newZoom = cy.zoom() * Math.pow(10, diff);\n\n        if (e.type === 'gesturechange') {\n          newZoom = r.gestureStartZoom * e.scale;\n        }\n\n        cy.zoom({\n          level: newZoom,\n          renderedPosition: {\n            x: rpos[0],\n            y: rpos[1]\n          }\n        });\n        cy.emit(e.type === 'gesturechange' ? 'pinchzoom' : 'scrollzoom');\n      }\n    }; // Functions to help with whether mouse wheel should trigger zooming\n    // --\n\n\n    r.registerBinding(r.container, 'wheel', wheelHandler, true); // disable nonstandard wheel events\n    // r.registerBinding(r.container, 'mousewheel', wheelHandler, true);\n    // r.registerBinding(r.container, 'DOMMouseScroll', wheelHandler, true);\n    // r.registerBinding(r.container, 'MozMousePixelScroll', wheelHandler, true); // older firefox\n\n    r.registerBinding(window, 'scroll', function scrollHandler(e) {\n      // eslint-disable-line no-unused-vars\n      r.scrollingPage = true;\n      clearTimeout(r.scrollingPageTimeout);\n      r.scrollingPageTimeout = setTimeout(function () {\n        r.scrollingPage = false;\n      }, 250);\n    }, true); // desktop safari pinch to zoom start\n\n    r.registerBinding(r.container, 'gesturestart', function gestureStartHandler(e) {\n      r.gestureStartZoom = r.cy.zoom();\n\n      if (!r.hasTouchStarted) {\n        // don't affect touch devices like iphone\n        e.preventDefault();\n      }\n    }, true);\n    r.registerBinding(r.container, 'gesturechange', function (e) {\n      if (!r.hasTouchStarted) {\n        // don't affect touch devices like iphone\n        wheelHandler(e);\n      }\n    }, true); // Functions to help with handling mouseout/mouseover on the Cytoscape container\n    // Handle mouseout on Cytoscape container\n\n    r.registerBinding(r.container, 'mouseout', function mouseOutHandler(e) {\n      var pos = r.projectIntoViewport(e.clientX, e.clientY);\n      r.cy.emit({\n        originalEvent: e,\n        type: 'mouseout',\n        position: {\n          x: pos[0],\n          y: pos[1]\n        }\n      });\n    }, false);\n    r.registerBinding(r.container, 'mouseover', function mouseOverHandler(e) {\n      var pos = r.projectIntoViewport(e.clientX, e.clientY);\n      r.cy.emit({\n        originalEvent: e,\n        type: 'mouseover',\n        position: {\n          x: pos[0],\n          y: pos[1]\n        }\n      });\n    }, false);\n    var f1x1, f1y1, f2x1, f2y1; // starting points for pinch-to-zoom\n\n    var distance1, distance1Sq; // initial distance between finger 1 and finger 2 for pinch-to-zoom\n\n    var center1, modelCenter1; // center point on start pinch to zoom\n\n    var offsetLeft, offsetTop;\n    var containerWidth, containerHeight;\n    var twoFingersStartInside;\n\n    var distance = function distance(x1, y1, x2, y2) {\n      return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n    };\n\n    var distanceSq = function distanceSq(x1, y1, x2, y2) {\n      return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\n    };\n\n    var touchstartHandler;\n    r.registerBinding(r.container, 'touchstart', touchstartHandler = function touchstartHandler(e) {\n      r.hasTouchStarted = true;\n\n      if (!eventInContainer(e)) {\n        return;\n      }\n\n      blurActiveDomElement();\n      r.touchData.capture = true;\n      r.data.bgActivePosistion = undefined;\n      var cy = r.cy;\n      var now = r.touchData.now;\n      var earlier = r.touchData.earlier;\n\n      if (e.touches[0]) {\n        var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);\n        now[0] = pos[0];\n        now[1] = pos[1];\n      }\n\n      if (e.touches[1]) {\n        var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);\n        now[2] = pos[0];\n        now[3] = pos[1];\n      }\n\n      if (e.touches[2]) {\n        var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);\n        now[4] = pos[0];\n        now[5] = pos[1];\n      } // record starting points for pinch-to-zoom\n\n\n      if (e.touches[1]) {\n        r.touchData.singleTouchMoved = true;\n        freeDraggedElements(r.dragData.touchDragEles);\n        var offsets = r.findContainerClientCoords();\n        offsetLeft = offsets[0];\n        offsetTop = offsets[1];\n        containerWidth = offsets[2];\n        containerHeight = offsets[3];\n        f1x1 = e.touches[0].clientX - offsetLeft;\n        f1y1 = e.touches[0].clientY - offsetTop;\n        f2x1 = e.touches[1].clientX - offsetLeft;\n        f2y1 = e.touches[1].clientY - offsetTop;\n        twoFingersStartInside = 0 <= f1x1 && f1x1 <= containerWidth && 0 <= f2x1 && f2x1 <= containerWidth && 0 <= f1y1 && f1y1 <= containerHeight && 0 <= f2y1 && f2y1 <= containerHeight;\n        var pan = cy.pan();\n        var zoom = cy.zoom();\n        distance1 = distance(f1x1, f1y1, f2x1, f2y1);\n        distance1Sq = distanceSq(f1x1, f1y1, f2x1, f2y1);\n        center1 = [(f1x1 + f2x1) / 2, (f1y1 + f2y1) / 2];\n        modelCenter1 = [(center1[0] - pan.x) / zoom, (center1[1] - pan.y) / zoom]; // consider context tap\n\n        var cxtDistThreshold = 200;\n        var cxtDistThresholdSq = cxtDistThreshold * cxtDistThreshold;\n\n        if (distance1Sq < cxtDistThresholdSq && !e.touches[2]) {\n          var near1 = r.findNearestElement(now[0], now[1], true, true);\n          var near2 = r.findNearestElement(now[2], now[3], true, true);\n\n          if (near1 && near1.isNode()) {\n            near1.activate().emit({\n              originalEvent: e,\n              type: 'cxttapstart',\n              position: {\n                x: now[0],\n                y: now[1]\n              }\n            });\n            r.touchData.start = near1;\n          } else if (near2 && near2.isNode()) {\n            near2.activate().emit({\n              originalEvent: e,\n              type: 'cxttapstart',\n              position: {\n                x: now[0],\n                y: now[1]\n              }\n            });\n            r.touchData.start = near2;\n          } else {\n            cy.emit({\n              originalEvent: e,\n              type: 'cxttapstart',\n              position: {\n                x: now[0],\n                y: now[1]\n              }\n            });\n          }\n\n          if (r.touchData.start) {\n            r.touchData.start._private.grabbed = false;\n          }\n\n          r.touchData.cxt = true;\n          r.touchData.cxtDragged = false;\n          r.data.bgActivePosistion = undefined;\n          r.redraw();\n          return;\n        }\n      }\n\n      if (e.touches[2]) {\n        // ignore\n        // safari on ios pans the page otherwise (normally you should be able to preventdefault on touchmove...)\n        if (cy.boxSelectionEnabled()) {\n          e.preventDefault();\n        }\n      } else if (e.touches[1]) ; else if (e.touches[0]) {\n        var nears = r.findNearestElements(now[0], now[1], true, true);\n        var near = nears[0];\n\n        if (near != null) {\n          near.activate();\n          r.touchData.start = near;\n          r.touchData.starts = nears;\n\n          if (r.nodeIsGrabbable(near)) {\n            var draggedEles = r.dragData.touchDragEles = cy.collection();\n            var selectedNodes = null;\n            r.redrawHint('eles', true);\n            r.redrawHint('drag', true);\n\n            if (near.selected()) {\n              // reset drag elements, since near will be added again\n              selectedNodes = cy.$(function (ele) {\n                return ele.selected() && r.nodeIsGrabbable(ele);\n              });\n              addNodesToDrag(selectedNodes, {\n                addToList: draggedEles\n              });\n            } else {\n              addNodeToDrag(near, {\n                addToList: draggedEles\n              });\n            }\n\n            setGrabTarget(near);\n\n            var makeEvent = function makeEvent(type) {\n              return {\n                originalEvent: e,\n                type: type,\n                position: {\n                  x: now[0],\n                  y: now[1]\n                }\n              };\n            };\n\n            near.emit(makeEvent('grabon'));\n\n            if (selectedNodes) {\n              selectedNodes.forEach(function (n) {\n                n.emit(makeEvent('grab'));\n              });\n            } else {\n              near.emit(makeEvent('grab'));\n            }\n          }\n        }\n\n        triggerEvents(near, ['touchstart', 'tapstart', 'vmousedown'], e, {\n          x: now[0],\n          y: now[1]\n        });\n\n        if (near == null) {\n          r.data.bgActivePosistion = {\n            x: pos[0],\n            y: pos[1]\n          };\n          r.redrawHint('select', true);\n          r.redraw();\n        } // Tap, taphold\n        // -----\n\n\n        r.touchData.singleTouchMoved = false;\n        r.touchData.singleTouchStartTime = +new Date();\n        clearTimeout(r.touchData.tapholdTimeout);\n        r.touchData.tapholdTimeout = setTimeout(function () {\n          if (r.touchData.singleTouchMoved === false && !r.pinching // if pinching, then taphold unselect shouldn't take effect\n          && !r.touchData.selecting // box selection shouldn't allow taphold through\n          ) {\n            triggerEvents(r.touchData.start, ['taphold'], e, {\n              x: now[0],\n              y: now[1]\n            });\n          }\n        }, r.tapholdDuration);\n      }\n\n      if (e.touches.length >= 1) {\n        var sPos = r.touchData.startPosition = [];\n\n        for (var i = 0; i < now.length; i++) {\n          sPos[i] = earlier[i] = now[i];\n        }\n\n        var touch0 = e.touches[0];\n        r.touchData.startGPosition = [touch0.clientX, touch0.clientY];\n      }\n    }, false);\n    var touchmoveHandler;\n    r.registerBinding(window, 'touchmove', touchmoveHandler = function touchmoveHandler(e) {\n      // eslint-disable-line no-undef\n      var capture = r.touchData.capture;\n\n      if (!capture && !eventInContainer(e)) {\n        return;\n      }\n\n      var select = r.selection;\n      var cy = r.cy;\n      var now = r.touchData.now;\n      var earlier = r.touchData.earlier;\n      var zoom = cy.zoom();\n\n      if (e.touches[0]) {\n        var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);\n        now[0] = pos[0];\n        now[1] = pos[1];\n      }\n\n      if (e.touches[1]) {\n        var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);\n        now[2] = pos[0];\n        now[3] = pos[1];\n      }\n\n      if (e.touches[2]) {\n        var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);\n        now[4] = pos[0];\n        now[5] = pos[1];\n      }\n\n      var startGPos = r.touchData.startGPosition;\n      var isOverThresholdDrag;\n\n      if (capture && e.touches[0] && startGPos) {\n        var disp = [];\n\n        for (var j = 0; j < now.length; j++) {\n          disp[j] = now[j] - earlier[j];\n        }\n\n        var dx = e.touches[0].clientX - startGPos[0];\n        var dx2 = dx * dx;\n        var dy = e.touches[0].clientY - startGPos[1];\n        var dy2 = dy * dy;\n        var dist2 = dx2 + dy2;\n        isOverThresholdDrag = dist2 >= r.touchTapThreshold2;\n      } // context swipe cancelling\n\n\n      if (capture && r.touchData.cxt) {\n        e.preventDefault();\n        var f1x2 = e.touches[0].clientX - offsetLeft,\n            f1y2 = e.touches[0].clientY - offsetTop;\n        var f2x2 = e.touches[1].clientX - offsetLeft,\n            f2y2 = e.touches[1].clientY - offsetTop; // var distance2 = distance( f1x2, f1y2, f2x2, f2y2 );\n\n        var distance2Sq = distanceSq(f1x2, f1y2, f2x2, f2y2);\n        var factorSq = distance2Sq / distance1Sq;\n        var distThreshold = 150;\n        var distThresholdSq = distThreshold * distThreshold;\n        var factorThreshold = 1.5;\n        var factorThresholdSq = factorThreshold * factorThreshold; // cancel ctx gestures if the distance b/t the fingers increases\n\n        if (factorSq >= factorThresholdSq || distance2Sq >= distThresholdSq) {\n          r.touchData.cxt = false;\n          r.data.bgActivePosistion = undefined;\n          r.redrawHint('select', true);\n          var cxtEvt = {\n            originalEvent: e,\n            type: 'cxttapend',\n            position: {\n              x: now[0],\n              y: now[1]\n            }\n          };\n\n          if (r.touchData.start) {\n            r.touchData.start.unactivate().emit(cxtEvt);\n            r.touchData.start = null;\n          } else {\n            cy.emit(cxtEvt);\n          }\n        }\n      } // context swipe\n\n\n      if (capture && r.touchData.cxt) {\n        var cxtEvt = {\n          originalEvent: e,\n          type: 'cxtdrag',\n          position: {\n            x: now[0],\n            y: now[1]\n          }\n        };\n        r.data.bgActivePosistion = undefined;\n        r.redrawHint('select', true);\n\n        if (r.touchData.start) {\n          r.touchData.start.emit(cxtEvt);\n        } else {\n          cy.emit(cxtEvt);\n        }\n\n        if (r.touchData.start) {\n          r.touchData.start._private.grabbed = false;\n        }\n\n        r.touchData.cxtDragged = true;\n        var near = r.findNearestElement(now[0], now[1], true, true);\n\n        if (!r.touchData.cxtOver || near !== r.touchData.cxtOver) {\n          if (r.touchData.cxtOver) {\n            r.touchData.cxtOver.emit({\n              originalEvent: e,\n              type: 'cxtdragout',\n              position: {\n                x: now[0],\n                y: now[1]\n              }\n            });\n          }\n\n          r.touchData.cxtOver = near;\n\n          if (near) {\n            near.emit({\n              originalEvent: e,\n              type: 'cxtdragover',\n              position: {\n                x: now[0],\n                y: now[1]\n              }\n            });\n          }\n        } // box selection\n\n      } else if (capture && e.touches[2] && cy.boxSelectionEnabled()) {\n        e.preventDefault();\n        r.data.bgActivePosistion = undefined;\n        this.lastThreeTouch = +new Date();\n\n        if (!r.touchData.selecting) {\n          cy.emit({\n            originalEvent: e,\n            type: 'boxstart',\n            position: {\n              x: now[0],\n              y: now[1]\n            }\n          });\n        }\n\n        r.touchData.selecting = true;\n        r.touchData.didSelect = true;\n        select[4] = 1;\n\n        if (!select || select.length === 0 || select[0] === undefined) {\n          select[0] = (now[0] + now[2] + now[4]) / 3;\n          select[1] = (now[1] + now[3] + now[5]) / 3;\n          select[2] = (now[0] + now[2] + now[4]) / 3 + 1;\n          select[3] = (now[1] + now[3] + now[5]) / 3 + 1;\n        } else {\n          select[2] = (now[0] + now[2] + now[4]) / 3;\n          select[3] = (now[1] + now[3] + now[5]) / 3;\n        }\n\n        r.redrawHint('select', true);\n        r.redraw(); // pinch to zoom\n      } else if (capture && e.touches[1] && !r.touchData.didSelect // don't allow box selection to degrade to pinch-to-zoom\n      && cy.zoomingEnabled() && cy.panningEnabled() && cy.userZoomingEnabled() && cy.userPanningEnabled()) {\n        // two fingers => pinch to zoom\n        e.preventDefault();\n        r.data.bgActivePosistion = undefined;\n        r.redrawHint('select', true);\n        var draggedEles = r.dragData.touchDragEles;\n\n        if (draggedEles) {\n          r.redrawHint('drag', true);\n\n          for (var i = 0; i < draggedEles.length; i++) {\n            var de_p = draggedEles[i]._private;\n            de_p.grabbed = false;\n            de_p.rscratch.inDragLayer = false;\n          }\n        }\n\n        var _start = r.touchData.start; // (x2, y2) for fingers 1 and 2\n\n        var f1x2 = e.touches[0].clientX - offsetLeft,\n            f1y2 = e.touches[0].clientY - offsetTop;\n        var f2x2 = e.touches[1].clientX - offsetLeft,\n            f2y2 = e.touches[1].clientY - offsetTop;\n        var distance2 = distance(f1x2, f1y2, f2x2, f2y2); // var distance2Sq = distanceSq( f1x2, f1y2, f2x2, f2y2 );\n        // var factor = Math.sqrt( distance2Sq ) / Math.sqrt( distance1Sq );\n\n        var factor = distance2 / distance1;\n\n        if (twoFingersStartInside) {\n          // delta finger1\n          var df1x = f1x2 - f1x1;\n          var df1y = f1y2 - f1y1; // delta finger 2\n\n          var df2x = f2x2 - f2x1;\n          var df2y = f2y2 - f2y1; // translation is the normalised vector of the two fingers movement\n          // i.e. so pinching cancels out and moving together pans\n\n          var tx = (df1x + df2x) / 2;\n          var ty = (df1y + df2y) / 2; // now calculate the zoom\n\n          var zoom1 = cy.zoom();\n          var zoom2 = zoom1 * factor;\n          var pan1 = cy.pan(); // the model center point converted to the current rendered pos\n\n          var ctrx = modelCenter1[0] * zoom1 + pan1.x;\n          var ctry = modelCenter1[1] * zoom1 + pan1.y;\n          var pan2 = {\n            x: -zoom2 / zoom1 * (ctrx - pan1.x - tx) + ctrx,\n            y: -zoom2 / zoom1 * (ctry - pan1.y - ty) + ctry\n          }; // remove dragged eles\n\n          if (_start && _start.active()) {\n            var draggedEles = r.dragData.touchDragEles;\n            freeDraggedElements(draggedEles);\n            r.redrawHint('drag', true);\n            r.redrawHint('eles', true);\n\n            _start.unactivate().emit('freeon');\n\n            draggedEles.emit('free');\n\n            if (r.dragData.didDrag) {\n              _start.emit('dragfreeon');\n\n              draggedEles.emit('dragfree');\n            }\n          }\n\n          cy.viewport({\n            zoom: zoom2,\n            pan: pan2,\n            cancelOnFailedZoom: true\n          });\n          cy.emit('pinchzoom');\n          distance1 = distance2;\n          f1x1 = f1x2;\n          f1y1 = f1y2;\n          f2x1 = f2x2;\n          f2y1 = f2y2;\n          r.pinching = true;\n        } // Re-project\n\n\n        if (e.touches[0]) {\n          var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);\n          now[0] = pos[0];\n          now[1] = pos[1];\n        }\n\n        if (e.touches[1]) {\n          var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);\n          now[2] = pos[0];\n          now[3] = pos[1];\n        }\n\n        if (e.touches[2]) {\n          var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);\n          now[4] = pos[0];\n          now[5] = pos[1];\n        }\n      } else if (e.touches[0] && !r.touchData.didSelect // don't allow box selection to degrade to single finger events like panning\n      ) {\n        var start = r.touchData.start;\n        var last = r.touchData.last;\n        var near;\n\n        if (!r.hoverData.draggingEles && !r.swipePanning) {\n          near = r.findNearestElement(now[0], now[1], true, true);\n        }\n\n        if (capture && start != null) {\n          e.preventDefault();\n        } // dragging nodes\n\n\n        if (capture && start != null && r.nodeIsDraggable(start)) {\n          if (isOverThresholdDrag) {\n            // then dragging can happen\n            var draggedEles = r.dragData.touchDragEles;\n            var justStartedDrag = !r.dragData.didDrag;\n\n            if (justStartedDrag) {\n              addNodesToDrag(draggedEles, {\n                inDragLayer: true\n              });\n            }\n\n            r.dragData.didDrag = true;\n            var totalShift = {\n              x: 0,\n              y: 0\n            };\n\n            if (number$1(disp[0]) && number$1(disp[1])) {\n              totalShift.x += disp[0];\n              totalShift.y += disp[1];\n\n              if (justStartedDrag) {\n                r.redrawHint('eles', true);\n                var dragDelta = r.touchData.dragDelta;\n\n                if (dragDelta && number$1(dragDelta[0]) && number$1(dragDelta[1])) {\n                  totalShift.x += dragDelta[0];\n                  totalShift.y += dragDelta[1];\n                }\n              }\n            }\n\n            r.hoverData.draggingEles = true;\n            draggedEles.silentShift(totalShift).emit('position drag');\n            r.redrawHint('drag', true);\n\n            if (r.touchData.startPosition[0] == earlier[0] && r.touchData.startPosition[1] == earlier[1]) {\n              r.redrawHint('eles', true);\n            }\n\n            r.redraw();\n          } else {\n            // otherwise keep track of drag delta for later\n            var dragDelta = r.touchData.dragDelta = r.touchData.dragDelta || [];\n\n            if (dragDelta.length === 0) {\n              dragDelta.push(disp[0]);\n              dragDelta.push(disp[1]);\n            } else {\n              dragDelta[0] += disp[0];\n              dragDelta[1] += disp[1];\n            }\n          }\n        } // touchmove\n\n\n        {\n          triggerEvents(start || near, ['touchmove', 'tapdrag', 'vmousemove'], e, {\n            x: now[0],\n            y: now[1]\n          });\n\n          if ((!start || !start.grabbed()) && near != last) {\n            if (last) {\n              last.emit({\n                originalEvent: e,\n                type: 'tapdragout',\n                position: {\n                  x: now[0],\n                  y: now[1]\n                }\n              });\n            }\n\n            if (near) {\n              near.emit({\n                originalEvent: e,\n                type: 'tapdragover',\n                position: {\n                  x: now[0],\n                  y: now[1]\n                }\n              });\n            }\n          }\n\n          r.touchData.last = near;\n        } // check to cancel taphold\n\n        if (capture) {\n          for (var i = 0; i < now.length; i++) {\n            if (now[i] && r.touchData.startPosition[i] && isOverThresholdDrag) {\n              r.touchData.singleTouchMoved = true;\n            }\n          }\n        } // panning\n\n\n        if (capture && (start == null || start.pannable()) && cy.panningEnabled() && cy.userPanningEnabled()) {\n          var allowPassthrough = allowPanningPassthrough(start, r.touchData.starts);\n\n          if (allowPassthrough) {\n            e.preventDefault();\n\n            if (!r.data.bgActivePosistion) {\n              r.data.bgActivePosistion = array2point(r.touchData.startPosition);\n            }\n\n            if (r.swipePanning) {\n              cy.panBy({\n                x: disp[0] * zoom,\n                y: disp[1] * zoom\n              });\n              cy.emit('dragpan');\n            } else if (isOverThresholdDrag) {\n              r.swipePanning = true;\n              cy.panBy({\n                x: dx * zoom,\n                y: dy * zoom\n              });\n              cy.emit('dragpan');\n\n              if (start) {\n                start.unactivate();\n                r.redrawHint('select', true);\n                r.touchData.start = null;\n              }\n            }\n          } // Re-project\n\n\n          var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);\n          now[0] = pos[0];\n          now[1] = pos[1];\n        }\n      }\n\n      for (var j = 0; j < now.length; j++) {\n        earlier[j] = now[j];\n      } // the active bg indicator should be removed when making a swipe that is neither for dragging nodes or panning\n\n\n      if (capture && e.touches.length > 0 && !r.hoverData.draggingEles && !r.swipePanning && r.data.bgActivePosistion != null) {\n        r.data.bgActivePosistion = undefined;\n        r.redrawHint('select', true);\n        r.redraw();\n      }\n    }, false);\n    var touchcancelHandler;\n    r.registerBinding(window, 'touchcancel', touchcancelHandler = function touchcancelHandler(e) {\n      // eslint-disable-line no-unused-vars\n      var start = r.touchData.start;\n      r.touchData.capture = false;\n\n      if (start) {\n        start.unactivate();\n      }\n    });\n    var touchendHandler, didDoubleTouch, touchTimeout, prevTouchTimeStamp;\n    r.registerBinding(window, 'touchend', touchendHandler = function touchendHandler(e) {\n      // eslint-disable-line no-unused-vars\n      var start = r.touchData.start;\n      var capture = r.touchData.capture;\n\n      if (capture) {\n        if (e.touches.length === 0) {\n          r.touchData.capture = false;\n        }\n\n        e.preventDefault();\n      } else {\n        return;\n      }\n\n      var select = r.selection;\n      r.swipePanning = false;\n      r.hoverData.draggingEles = false;\n      var cy = r.cy;\n      var zoom = cy.zoom();\n      var now = r.touchData.now;\n      var earlier = r.touchData.earlier;\n\n      if (e.touches[0]) {\n        var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);\n        now[0] = pos[0];\n        now[1] = pos[1];\n      }\n\n      if (e.touches[1]) {\n        var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);\n        now[2] = pos[0];\n        now[3] = pos[1];\n      }\n\n      if (e.touches[2]) {\n        var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);\n        now[4] = pos[0];\n        now[5] = pos[1];\n      }\n\n      if (start) {\n        start.unactivate();\n      }\n\n      var ctxTapend;\n\n      if (r.touchData.cxt) {\n        ctxTapend = {\n          originalEvent: e,\n          type: 'cxttapend',\n          position: {\n            x: now[0],\n            y: now[1]\n          }\n        };\n\n        if (start) {\n          start.emit(ctxTapend);\n        } else {\n          cy.emit(ctxTapend);\n        }\n\n        if (!r.touchData.cxtDragged) {\n          var ctxTap = {\n            originalEvent: e,\n            type: 'cxttap',\n            position: {\n              x: now[0],\n              y: now[1]\n            }\n          };\n\n          if (start) {\n            start.emit(ctxTap);\n          } else {\n            cy.emit(ctxTap);\n          }\n        }\n\n        if (r.touchData.start) {\n          r.touchData.start._private.grabbed = false;\n        }\n\n        r.touchData.cxt = false;\n        r.touchData.start = null;\n        r.redraw();\n        return;\n      } // no more box selection if we don't have three fingers\n\n\n      if (!e.touches[2] && cy.boxSelectionEnabled() && r.touchData.selecting) {\n        r.touchData.selecting = false;\n        var box = cy.collection(r.getAllInBox(select[0], select[1], select[2], select[3]));\n        select[0] = undefined;\n        select[1] = undefined;\n        select[2] = undefined;\n        select[3] = undefined;\n        select[4] = 0;\n        r.redrawHint('select', true);\n        cy.emit({\n          type: 'boxend',\n          originalEvent: e,\n          position: {\n            x: now[0],\n            y: now[1]\n          }\n        });\n\n        var eleWouldBeSelected = function eleWouldBeSelected(ele) {\n          return ele.selectable() && !ele.selected();\n        };\n\n        box.emit('box').stdFilter(eleWouldBeSelected).select().emit('boxselect');\n\n        if (box.nonempty()) {\n          r.redrawHint('eles', true);\n        }\n\n        r.redraw();\n      }\n\n      if (start != null) {\n        start.unactivate();\n      }\n\n      if (e.touches[2]) {\n        r.data.bgActivePosistion = undefined;\n        r.redrawHint('select', true);\n      } else if (e.touches[1]) ; else if (e.touches[0]) ; else if (!e.touches[0]) {\n        r.data.bgActivePosistion = undefined;\n        r.redrawHint('select', true);\n        var draggedEles = r.dragData.touchDragEles;\n\n        if (start != null) {\n          var startWasGrabbed = start._private.grabbed;\n          freeDraggedElements(draggedEles);\n          r.redrawHint('drag', true);\n          r.redrawHint('eles', true);\n\n          if (startWasGrabbed) {\n            start.emit('freeon');\n            draggedEles.emit('free');\n\n            if (r.dragData.didDrag) {\n              start.emit('dragfreeon');\n              draggedEles.emit('dragfree');\n            }\n          }\n\n          triggerEvents(start, ['touchend', 'tapend', 'vmouseup', 'tapdragout'], e, {\n            x: now[0],\n            y: now[1]\n          });\n          start.unactivate();\n          r.touchData.start = null;\n        } else {\n          var near = r.findNearestElement(now[0], now[1], true, true);\n          triggerEvents(near, ['touchend', 'tapend', 'vmouseup', 'tapdragout'], e, {\n            x: now[0],\n            y: now[1]\n          });\n        }\n\n        var dx = r.touchData.startPosition[0] - now[0];\n        var dx2 = dx * dx;\n        var dy = r.touchData.startPosition[1] - now[1];\n        var dy2 = dy * dy;\n        var dist2 = dx2 + dy2;\n        var rdist2 = dist2 * zoom * zoom; // Tap event, roughly same as mouse click event for touch\n\n        if (!r.touchData.singleTouchMoved) {\n          if (!start) {\n            cy.$(':selected').unselect(['tapunselect']);\n          }\n\n          triggerEvents(start, ['tap', 'vclick'], e, {\n            x: now[0],\n            y: now[1]\n          });\n          didDoubleTouch = false;\n\n          if (e.timeStamp - prevTouchTimeStamp <= cy.multiClickDebounceTime()) {\n            touchTimeout && clearTimeout(touchTimeout);\n            didDoubleTouch = true;\n            prevTouchTimeStamp = null;\n            triggerEvents(start, ['dbltap', 'vdblclick'], e, {\n              x: now[0],\n              y: now[1]\n            });\n          } else {\n            touchTimeout = setTimeout(function () {\n              if (didDoubleTouch) return;\n              triggerEvents(start, ['onetap', 'voneclick'], e, {\n                x: now[0],\n                y: now[1]\n              });\n            }, cy.multiClickDebounceTime());\n            prevTouchTimeStamp = e.timeStamp;\n          }\n        } // Prepare to select the currently touched node, only if it hasn't been dragged past a certain distance\n\n\n        if (start != null && !r.dragData.didDrag // didn't drag nodes around\n        && start._private.selectable && rdist2 < r.touchTapThreshold2 && !r.pinching // pinch to zoom should not affect selection\n        ) {\n          if (cy.selectionType() === 'single') {\n            cy.$(isSelected).unmerge(start).unselect(['tapunselect']);\n            start.select(['tapselect']);\n          } else {\n            if (start.selected()) {\n              start.unselect(['tapunselect']);\n            } else {\n              start.select(['tapselect']);\n            }\n          }\n\n          r.redrawHint('eles', true);\n        }\n\n        r.touchData.singleTouchMoved = true;\n      }\n\n      for (var j = 0; j < now.length; j++) {\n        earlier[j] = now[j];\n      }\n\n      r.dragData.didDrag = false; // reset for next touchstart\n\n      if (e.touches.length === 0) {\n        r.touchData.dragDelta = [];\n        r.touchData.startPosition = null;\n        r.touchData.startGPosition = null;\n        r.touchData.didSelect = false;\n      }\n\n      if (e.touches.length < 2) {\n        if (e.touches.length === 1) {\n          // the old start global pos'n may not be the same finger that remains\n          r.touchData.startGPosition = [e.touches[0].clientX, e.touches[0].clientY];\n        }\n\n        r.pinching = false;\n        r.redrawHint('eles', true);\n        r.redraw();\n      } //r.redraw();\n\n    }, false); // fallback compatibility layer for ms pointer events\n\n    if (typeof TouchEvent === 'undefined') {\n      var pointers = [];\n\n      var makeTouch = function makeTouch(e) {\n        return {\n          clientX: e.clientX,\n          clientY: e.clientY,\n          force: 1,\n          identifier: e.pointerId,\n          pageX: e.pageX,\n          pageY: e.pageY,\n          radiusX: e.width / 2,\n          radiusY: e.height / 2,\n          screenX: e.screenX,\n          screenY: e.screenY,\n          target: e.target\n        };\n      };\n\n      var makePointer = function makePointer(e) {\n        return {\n          event: e,\n          touch: makeTouch(e)\n        };\n      };\n\n      var addPointer = function addPointer(e) {\n        pointers.push(makePointer(e));\n      };\n\n      var removePointer = function removePointer(e) {\n        for (var i = 0; i < pointers.length; i++) {\n          var p = pointers[i];\n\n          if (p.event.pointerId === e.pointerId) {\n            pointers.splice(i, 1);\n            return;\n          }\n        }\n      };\n\n      var updatePointer = function updatePointer(e) {\n        var p = pointers.filter(function (p) {\n          return p.event.pointerId === e.pointerId;\n        })[0];\n        p.event = e;\n        p.touch = makeTouch(e);\n      };\n\n      var addTouchesToEvent = function addTouchesToEvent(e) {\n        e.touches = pointers.map(function (p) {\n          return p.touch;\n        });\n      };\n\n      var pointerIsMouse = function pointerIsMouse(e) {\n        return e.pointerType === 'mouse' || e.pointerType === 4;\n      };\n\n      r.registerBinding(r.container, 'pointerdown', function (e) {\n        if (pointerIsMouse(e)) {\n          return;\n        } // mouse already handled\n\n\n        e.preventDefault();\n        addPointer(e);\n        addTouchesToEvent(e);\n        touchstartHandler(e);\n      });\n      r.registerBinding(r.container, 'pointerup', function (e) {\n        if (pointerIsMouse(e)) {\n          return;\n        } // mouse already handled\n\n\n        removePointer(e);\n        addTouchesToEvent(e);\n        touchendHandler(e);\n      });\n      r.registerBinding(r.container, 'pointercancel', function (e) {\n        if (pointerIsMouse(e)) {\n          return;\n        } // mouse already handled\n\n\n        removePointer(e);\n        addTouchesToEvent(e);\n        touchcancelHandler(e);\n      });\n      r.registerBinding(r.container, 'pointermove', function (e) {\n        if (pointerIsMouse(e)) {\n          return;\n        } // mouse already handled\n\n\n        e.preventDefault();\n        updatePointer(e);\n        addTouchesToEvent(e);\n        touchmoveHandler(e);\n      });\n    }\n  };\n\n  var BRp$2 = {};\n\n  BRp$2.generatePolygon = function (name, points) {\n    return this.nodeShapes[name] = {\n      renderer: this,\n      name: name,\n      points: points,\n      draw: function draw(context, centerX, centerY, width, height) {\n        this.renderer.nodeShapeImpl('polygon', context, centerX, centerY, width, height, this.points);\n      },\n      intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {\n        return polygonIntersectLine(x, y, this.points, nodeX, nodeY, width / 2, height / 2, padding);\n      },\n      checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {\n        return pointInsidePolygon(x, y, this.points, centerX, centerY, width, height, [0, -1], padding);\n      }\n    };\n  };\n\n  BRp$2.generateEllipse = function () {\n    return this.nodeShapes['ellipse'] = {\n      renderer: this,\n      name: 'ellipse',\n      draw: function draw(context, centerX, centerY, width, height) {\n        this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);\n      },\n      intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {\n        return intersectLineEllipse(x, y, nodeX, nodeY, width / 2 + padding, height / 2 + padding);\n      },\n      checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {\n        return checkInEllipse(x, y, width, height, centerX, centerY, padding);\n      }\n    };\n  };\n\n  BRp$2.generateRoundPolygon = function (name, points) {\n    // Pre-compute control points\n    // Since these points depend on the radius length (which in turns depend on the width/height of the node) we will only pre-compute\n    // the unit vectors.\n    // For simplicity the layout will be:\n    // [ p0, UnitVectorP0P1, p1, UniVectorP1P2, ..., pn, UnitVectorPnP0 ]\n    var allPoints = new Array(points.length * 2);\n\n    for (var i = 0; i < points.length / 2; i++) {\n      var sourceIndex = i * 2;\n      var destIndex = void 0;\n\n      if (i < points.length / 2 - 1) {\n        destIndex = (i + 1) * 2;\n      } else {\n        destIndex = 0;\n      }\n\n      allPoints[i * 4] = points[sourceIndex];\n      allPoints[i * 4 + 1] = points[sourceIndex + 1];\n      var xDest = points[destIndex] - points[sourceIndex];\n      var yDest = points[destIndex + 1] - points[sourceIndex + 1];\n      var norm = Math.sqrt(xDest * xDest + yDest * yDest);\n      allPoints[i * 4 + 2] = xDest / norm;\n      allPoints[i * 4 + 3] = yDest / norm;\n    }\n\n    return this.nodeShapes[name] = {\n      renderer: this,\n      name: name,\n      points: allPoints,\n      draw: function draw(context, centerX, centerY, width, height) {\n        this.renderer.nodeShapeImpl('round-polygon', context, centerX, centerY, width, height, this.points);\n      },\n      intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {\n        return roundPolygonIntersectLine(x, y, this.points, nodeX, nodeY, width, height);\n      },\n      checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {\n        return pointInsideRoundPolygon(x, y, this.points, centerX, centerY, width, height);\n      }\n    };\n  };\n\n  BRp$2.generateRoundRectangle = function () {\n    return this.nodeShapes['round-rectangle'] = this.nodeShapes['roundrectangle'] = {\n      renderer: this,\n      name: 'round-rectangle',\n      points: generateUnitNgonPointsFitToSquare(4, 0),\n      draw: function draw(context, centerX, centerY, width, height) {\n        this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);\n      },\n      intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {\n        return roundRectangleIntersectLine(x, y, nodeX, nodeY, width, height, padding);\n      },\n      checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {\n        var cornerRadius = getRoundRectangleRadius(width, height);\n        var diam = cornerRadius * 2; // Check hBox\n\n        if (pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - diam, [0, -1], padding)) {\n          return true;\n        } // Check vBox\n\n\n        if (pointInsidePolygon(x, y, this.points, centerX, centerY, width - diam, height, [0, -1], padding)) {\n          return true;\n        } // Check top left quarter circle\n\n\n        if (checkInEllipse(x, y, diam, diam, centerX - width / 2 + cornerRadius, centerY - height / 2 + cornerRadius, padding)) {\n          return true;\n        } // Check top right quarter circle\n\n\n        if (checkInEllipse(x, y, diam, diam, centerX + width / 2 - cornerRadius, centerY - height / 2 + cornerRadius, padding)) {\n          return true;\n        } // Check bottom right quarter circle\n\n\n        if (checkInEllipse(x, y, diam, diam, centerX + width / 2 - cornerRadius, centerY + height / 2 - cornerRadius, padding)) {\n          return true;\n        } // Check bottom left quarter circle\n\n\n        if (checkInEllipse(x, y, diam, diam, centerX - width / 2 + cornerRadius, centerY + height / 2 - cornerRadius, padding)) {\n          return true;\n        }\n\n        return false;\n      }\n    };\n  };\n\n  BRp$2.generateCutRectangle = function () {\n    return this.nodeShapes['cut-rectangle'] = this.nodeShapes['cutrectangle'] = {\n      renderer: this,\n      name: 'cut-rectangle',\n      cornerLength: getCutRectangleCornerLength(),\n      points: generateUnitNgonPointsFitToSquare(4, 0),\n      draw: function draw(context, centerX, centerY, width, height) {\n        this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);\n      },\n      generateCutTrianglePts: function generateCutTrianglePts(width, height, centerX, centerY) {\n        var cl = this.cornerLength;\n        var hh = height / 2;\n        var hw = width / 2;\n        var xBegin = centerX - hw;\n        var xEnd = centerX + hw;\n        var yBegin = centerY - hh;\n        var yEnd = centerY + hh; // points are in clockwise order, inner (imaginary) triangle pt on [4, 5]\n\n        return {\n          topLeft: [xBegin, yBegin + cl, xBegin + cl, yBegin, xBegin + cl, yBegin + cl],\n          topRight: [xEnd - cl, yBegin, xEnd, yBegin + cl, xEnd - cl, yBegin + cl],\n          bottomRight: [xEnd, yEnd - cl, xEnd - cl, yEnd, xEnd - cl, yEnd - cl],\n          bottomLeft: [xBegin + cl, yEnd, xBegin, yEnd - cl, xBegin + cl, yEnd - cl]\n        };\n      },\n      intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {\n        var cPts = this.generateCutTrianglePts(width + 2 * padding, height + 2 * padding, nodeX, nodeY);\n        var pts = [].concat.apply([], [cPts.topLeft.splice(0, 4), cPts.topRight.splice(0, 4), cPts.bottomRight.splice(0, 4), cPts.bottomLeft.splice(0, 4)]);\n        return polygonIntersectLine(x, y, pts, nodeX, nodeY);\n      },\n      checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {\n        // Check hBox\n        if (pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - 2 * this.cornerLength, [0, -1], padding)) {\n          return true;\n        } // Check vBox\n\n\n        if (pointInsidePolygon(x, y, this.points, centerX, centerY, width - 2 * this.cornerLength, height, [0, -1], padding)) {\n          return true;\n        }\n\n        var cutTrianglePts = this.generateCutTrianglePts(width, height, centerX, centerY);\n        return pointInsidePolygonPoints(x, y, cutTrianglePts.topLeft) || pointInsidePolygonPoints(x, y, cutTrianglePts.topRight) || pointInsidePolygonPoints(x, y, cutTrianglePts.bottomRight) || pointInsidePolygonPoints(x, y, cutTrianglePts.bottomLeft);\n      }\n    };\n  };\n\n  BRp$2.generateBarrel = function () {\n    return this.nodeShapes['barrel'] = {\n      renderer: this,\n      name: 'barrel',\n      points: generateUnitNgonPointsFitToSquare(4, 0),\n      draw: function draw(context, centerX, centerY, width, height) {\n        this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);\n      },\n      intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {\n        // use two fixed t values for the bezier curve approximation\n        var t0 = 0.15;\n        var t1 = 0.5;\n        var t2 = 0.85;\n        var bPts = this.generateBarrelBezierPts(width + 2 * padding, height + 2 * padding, nodeX, nodeY);\n\n        var approximateBarrelCurvePts = function approximateBarrelCurvePts(pts) {\n          // approximate curve pts based on the two t values\n          var m0 = qbezierPtAt({\n            x: pts[0],\n            y: pts[1]\n          }, {\n            x: pts[2],\n            y: pts[3]\n          }, {\n            x: pts[4],\n            y: pts[5]\n          }, t0);\n          var m1 = qbezierPtAt({\n            x: pts[0],\n            y: pts[1]\n          }, {\n            x: pts[2],\n            y: pts[3]\n          }, {\n            x: pts[4],\n            y: pts[5]\n          }, t1);\n          var m2 = qbezierPtAt({\n            x: pts[0],\n            y: pts[1]\n          }, {\n            x: pts[2],\n            y: pts[3]\n          }, {\n            x: pts[4],\n            y: pts[5]\n          }, t2);\n          return [pts[0], pts[1], m0.x, m0.y, m1.x, m1.y, m2.x, m2.y, pts[4], pts[5]];\n        };\n\n        var pts = [].concat(approximateBarrelCurvePts(bPts.topLeft), approximateBarrelCurvePts(bPts.topRight), approximateBarrelCurvePts(bPts.bottomRight), approximateBarrelCurvePts(bPts.bottomLeft));\n        return polygonIntersectLine(x, y, pts, nodeX, nodeY);\n      },\n      generateBarrelBezierPts: function generateBarrelBezierPts(width, height, centerX, centerY) {\n        var hh = height / 2;\n        var hw = width / 2;\n        var xBegin = centerX - hw;\n        var xEnd = centerX + hw;\n        var yBegin = centerY - hh;\n        var yEnd = centerY + hh;\n        var curveConstants = getBarrelCurveConstants(width, height);\n        var hOffset = curveConstants.heightOffset;\n        var wOffset = curveConstants.widthOffset;\n        var ctrlPtXOffset = curveConstants.ctrlPtOffsetPct * width; // points are in clockwise order, inner (imaginary) control pt on [4, 5]\n\n        var pts = {\n          topLeft: [xBegin, yBegin + hOffset, xBegin + ctrlPtXOffset, yBegin, xBegin + wOffset, yBegin],\n          topRight: [xEnd - wOffset, yBegin, xEnd - ctrlPtXOffset, yBegin, xEnd, yBegin + hOffset],\n          bottomRight: [xEnd, yEnd - hOffset, xEnd - ctrlPtXOffset, yEnd, xEnd - wOffset, yEnd],\n          bottomLeft: [xBegin + wOffset, yEnd, xBegin + ctrlPtXOffset, yEnd, xBegin, yEnd - hOffset]\n        };\n        pts.topLeft.isTop = true;\n        pts.topRight.isTop = true;\n        pts.bottomLeft.isBottom = true;\n        pts.bottomRight.isBottom = true;\n        return pts;\n      },\n      checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {\n        var curveConstants = getBarrelCurveConstants(width, height);\n        var hOffset = curveConstants.heightOffset;\n        var wOffset = curveConstants.widthOffset; // Check hBox\n\n        if (pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - 2 * hOffset, [0, -1], padding)) {\n          return true;\n        } // Check vBox\n\n\n        if (pointInsidePolygon(x, y, this.points, centerX, centerY, width - 2 * wOffset, height, [0, -1], padding)) {\n          return true;\n        }\n\n        var barrelCurvePts = this.generateBarrelBezierPts(width, height, centerX, centerY);\n\n        var getCurveT = function getCurveT(x, y, curvePts) {\n          var x0 = curvePts[4];\n          var x1 = curvePts[2];\n          var x2 = curvePts[0];\n          var y0 = curvePts[5]; // var y1 = curvePts[ 3 ];\n\n          var y2 = curvePts[1];\n          var xMin = Math.min(x0, x2);\n          var xMax = Math.max(x0, x2);\n          var yMin = Math.min(y0, y2);\n          var yMax = Math.max(y0, y2);\n\n          if (xMin <= x && x <= xMax && yMin <= y && y <= yMax) {\n            var coeff = bezierPtsToQuadCoeff(x0, x1, x2);\n            var roots = solveQuadratic(coeff[0], coeff[1], coeff[2], x);\n            var validRoots = roots.filter(function (r) {\n              return 0 <= r && r <= 1;\n            });\n\n            if (validRoots.length > 0) {\n              return validRoots[0];\n            }\n          }\n\n          return null;\n        };\n\n        var curveRegions = Object.keys(barrelCurvePts);\n\n        for (var i = 0; i < curveRegions.length; i++) {\n          var corner = curveRegions[i];\n          var cornerPts = barrelCurvePts[corner];\n          var t = getCurveT(x, y, cornerPts);\n\n          if (t == null) {\n            continue;\n          }\n\n          var y0 = cornerPts[5];\n          var y1 = cornerPts[3];\n          var y2 = cornerPts[1];\n          var bezY = qbezierAt(y0, y1, y2, t);\n\n          if (cornerPts.isTop && bezY <= y) {\n            return true;\n          }\n\n          if (cornerPts.isBottom && y <= bezY) {\n            return true;\n          }\n        }\n\n        return false;\n      }\n    };\n  };\n\n  BRp$2.generateBottomRoundrectangle = function () {\n    return this.nodeShapes['bottom-round-rectangle'] = this.nodeShapes['bottomroundrectangle'] = {\n      renderer: this,\n      name: 'bottom-round-rectangle',\n      points: generateUnitNgonPointsFitToSquare(4, 0),\n      draw: function draw(context, centerX, centerY, width, height) {\n        this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);\n      },\n      intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding) {\n        var topStartX = nodeX - (width / 2 + padding);\n        var topStartY = nodeY - (height / 2 + padding);\n        var topEndY = topStartY;\n        var topEndX = nodeX + (width / 2 + padding);\n        var topIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, topStartX, topStartY, topEndX, topEndY, false);\n\n        if (topIntersections.length > 0) {\n          return topIntersections;\n        }\n\n        return roundRectangleIntersectLine(x, y, nodeX, nodeY, width, height, padding);\n      },\n      checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY) {\n        var cornerRadius = getRoundRectangleRadius(width, height);\n        var diam = 2 * cornerRadius; // Check hBox\n\n        if (pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - diam, [0, -1], padding)) {\n          return true;\n        } // Check vBox\n\n\n        if (pointInsidePolygon(x, y, this.points, centerX, centerY, width - diam, height, [0, -1], padding)) {\n          return true;\n        } // check non-rounded top side\n\n\n        var outerWidth = width / 2 + 2 * padding;\n        var outerHeight = height / 2 + 2 * padding;\n        var points = [centerX - outerWidth, centerY - outerHeight, centerX - outerWidth, centerY, centerX + outerWidth, centerY, centerX + outerWidth, centerY - outerHeight];\n\n        if (pointInsidePolygonPoints(x, y, points)) {\n          return true;\n        } // Check bottom right quarter circle\n\n\n        if (checkInEllipse(x, y, diam, diam, centerX + width / 2 - cornerRadius, centerY + height / 2 - cornerRadius, padding)) {\n          return true;\n        } // Check bottom left quarter circle\n\n\n        if (checkInEllipse(x, y, diam, diam, centerX - width / 2 + cornerRadius, centerY + height / 2 - cornerRadius, padding)) {\n          return true;\n        }\n\n        return false;\n      }\n    };\n  };\n\n  BRp$2.registerNodeShapes = function () {\n    var nodeShapes = this.nodeShapes = {};\n    var renderer = this;\n    this.generateEllipse();\n    this.generatePolygon('triangle', generateUnitNgonPointsFitToSquare(3, 0));\n    this.generateRoundPolygon('round-triangle', generateUnitNgonPointsFitToSquare(3, 0));\n    this.generatePolygon('rectangle', generateUnitNgonPointsFitToSquare(4, 0));\n    nodeShapes['square'] = nodeShapes['rectangle'];\n    this.generateRoundRectangle();\n    this.generateCutRectangle();\n    this.generateBarrel();\n    this.generateBottomRoundrectangle();\n    {\n      var diamondPoints = [0, 1, 1, 0, 0, -1, -1, 0];\n      this.generatePolygon('diamond', diamondPoints);\n      this.generateRoundPolygon('round-diamond', diamondPoints);\n    }\n    this.generatePolygon('pentagon', generateUnitNgonPointsFitToSquare(5, 0));\n    this.generateRoundPolygon('round-pentagon', generateUnitNgonPointsFitToSquare(5, 0));\n    this.generatePolygon('hexagon', generateUnitNgonPointsFitToSquare(6, 0));\n    this.generateRoundPolygon('round-hexagon', generateUnitNgonPointsFitToSquare(6, 0));\n    this.generatePolygon('heptagon', generateUnitNgonPointsFitToSquare(7, 0));\n    this.generateRoundPolygon('round-heptagon', generateUnitNgonPointsFitToSquare(7, 0));\n    this.generatePolygon('octagon', generateUnitNgonPointsFitToSquare(8, 0));\n    this.generateRoundPolygon('round-octagon', generateUnitNgonPointsFitToSquare(8, 0));\n    var star5Points = new Array(20);\n    {\n      var outerPoints = generateUnitNgonPoints(5, 0);\n      var innerPoints = generateUnitNgonPoints(5, Math.PI / 5); // Outer radius is 1; inner radius of star is smaller\n\n      var innerRadius = 0.5 * (3 - Math.sqrt(5));\n      innerRadius *= 1.57;\n\n      for (var i = 0; i < innerPoints.length / 2; i++) {\n        innerPoints[i * 2] *= innerRadius;\n        innerPoints[i * 2 + 1] *= innerRadius;\n      }\n\n      for (var i = 0; i < 20 / 4; i++) {\n        star5Points[i * 4] = outerPoints[i * 2];\n        star5Points[i * 4 + 1] = outerPoints[i * 2 + 1];\n        star5Points[i * 4 + 2] = innerPoints[i * 2];\n        star5Points[i * 4 + 3] = innerPoints[i * 2 + 1];\n      }\n    }\n    star5Points = fitPolygonToSquare(star5Points);\n    this.generatePolygon('star', star5Points);\n    this.generatePolygon('vee', [-1, -1, 0, -0.333, 1, -1, 0, 1]);\n    this.generatePolygon('rhomboid', [-1, -1, 0.333, -1, 1, 1, -0.333, 1]);\n    this.nodeShapes['concavehexagon'] = this.generatePolygon('concave-hexagon', [-1, -0.95, -0.75, 0, -1, 0.95, 1, 0.95, 0.75, 0, 1, -0.95]);\n    {\n      var tagPoints = [-1, -1, 0.25, -1, 1, 0, 0.25, 1, -1, 1];\n      this.generatePolygon('tag', tagPoints);\n      this.generateRoundPolygon('round-tag', tagPoints);\n    }\n\n    nodeShapes.makePolygon = function (points) {\n      // use caching on user-specified polygons so they are as fast as native shapes\n      var key = points.join('$');\n      var name = 'polygon-' + key;\n      var shape;\n\n      if (shape = this[name]) {\n        // got cached shape\n        return shape;\n      } // create and cache new shape\n\n\n      return renderer.generatePolygon(name, points);\n    };\n  };\n\n  var BRp$1 = {};\n\n  BRp$1.timeToRender = function () {\n    return this.redrawTotalTime / this.redrawCount;\n  };\n\n  BRp$1.redraw = function (options) {\n    options = options || staticEmptyObject();\n    var r = this;\n\n    if (r.averageRedrawTime === undefined) {\n      r.averageRedrawTime = 0;\n    }\n\n    if (r.lastRedrawTime === undefined) {\n      r.lastRedrawTime = 0;\n    }\n\n    if (r.lastDrawTime === undefined) {\n      r.lastDrawTime = 0;\n    }\n\n    r.requestedFrame = true;\n    r.renderOptions = options;\n  };\n\n  BRp$1.beforeRender = function (fn, priority) {\n    // the renderer can't add tick callbacks when destroyed\n    if (this.destroyed) {\n      return;\n    }\n\n    if (priority == null) {\n      error('Priority is not optional for beforeRender');\n    }\n\n    var cbs = this.beforeRenderCallbacks;\n    cbs.push({\n      fn: fn,\n      priority: priority\n    }); // higher priority callbacks executed first\n\n    cbs.sort(function (a, b) {\n      return b.priority - a.priority;\n    });\n  };\n\n  var beforeRenderCallbacks = function beforeRenderCallbacks(r, willDraw, startTime) {\n    var cbs = r.beforeRenderCallbacks;\n\n    for (var i = 0; i < cbs.length; i++) {\n      cbs[i].fn(willDraw, startTime);\n    }\n  };\n\n  BRp$1.startRenderLoop = function () {\n    var r = this;\n    var cy = r.cy;\n\n    if (r.renderLoopStarted) {\n      return;\n    } else {\n      r.renderLoopStarted = true;\n    }\n\n    var renderFn = function renderFn(requestTime) {\n      if (r.destroyed) {\n        return;\n      }\n\n      if (cy.batching()) ; else if (r.requestedFrame && !r.skipFrame) {\n        beforeRenderCallbacks(r, true, requestTime);\n        var startTime = performanceNow();\n        r.render(r.renderOptions);\n        var endTime = r.lastDrawTime = performanceNow();\n\n        if (r.averageRedrawTime === undefined) {\n          r.averageRedrawTime = endTime - startTime;\n        }\n\n        if (r.redrawCount === undefined) {\n          r.redrawCount = 0;\n        }\n\n        r.redrawCount++;\n\n        if (r.redrawTotalTime === undefined) {\n          r.redrawTotalTime = 0;\n        }\n\n        var duration = endTime - startTime;\n        r.redrawTotalTime += duration;\n        r.lastRedrawTime = duration; // use a weighted average with a bias from the previous average so we don't spike so easily\n\n        r.averageRedrawTime = r.averageRedrawTime / 2 + duration / 2;\n        r.requestedFrame = false;\n      } else {\n        beforeRenderCallbacks(r, false, requestTime);\n      }\n\n      r.skipFrame = false;\n      requestAnimationFrame(renderFn);\n    };\n\n    requestAnimationFrame(renderFn);\n  };\n\n  var BaseRenderer = function BaseRenderer(options) {\n    this.init(options);\n  };\n\n  var BR = BaseRenderer;\n  var BRp = BR.prototype;\n  BRp.clientFunctions = ['redrawHint', 'render', 'renderTo', 'matchCanvasSize', 'nodeShapeImpl', 'arrowShapeImpl'];\n\n  BRp.init = function (options) {\n    var r = this;\n    r.options = options;\n    r.cy = options.cy;\n    var ctr = r.container = options.cy.container(); // prepend a stylesheet in the head such that\n\n    if (window$1) {\n      var document = window$1.document;\n      var head = document.head;\n      var stylesheetId = '__________cytoscape_stylesheet';\n      var className = '__________cytoscape_container';\n      var stylesheetAlreadyExists = document.getElementById(stylesheetId) != null;\n\n      if (ctr.className.indexOf(className) < 0) {\n        ctr.className = (ctr.className || '') + ' ' + className;\n      }\n\n      if (!stylesheetAlreadyExists) {\n        var stylesheet = document.createElement('style');\n        stylesheet.id = stylesheetId;\n        stylesheet.innerHTML = '.' + className + ' { position: relative; }';\n        head.insertBefore(stylesheet, head.children[0]); // first so lowest priority\n      }\n\n      var computedStyle = window$1.getComputedStyle(ctr);\n      var position = computedStyle.getPropertyValue('position');\n\n      if (position === 'static') {\n        warn('A Cytoscape container has style position:static and so can not use UI extensions properly');\n      }\n    }\n\n    r.selection = [undefined, undefined, undefined, undefined, 0]; // Coordinates for selection box, plus enabled flag\n\n    r.bezierProjPcts = [0.05, 0.225, 0.4, 0.5, 0.6, 0.775, 0.95]; //--Pointer-related data\n\n    r.hoverData = {\n      down: null,\n      last: null,\n      downTime: null,\n      triggerMode: null,\n      dragging: false,\n      initialPan: [null, null],\n      capture: false\n    };\n    r.dragData = {\n      possibleDragElements: []\n    };\n    r.touchData = {\n      start: null,\n      capture: false,\n      // These 3 fields related to tap, taphold events\n      startPosition: [null, null, null, null, null, null],\n      singleTouchStartTime: null,\n      singleTouchMoved: true,\n      now: [null, null, null, null, null, null],\n      earlier: [null, null, null, null, null, null]\n    };\n    r.redraws = 0;\n    r.showFps = options.showFps;\n    r.debug = options.debug;\n    r.hideEdgesOnViewport = options.hideEdgesOnViewport;\n    r.textureOnViewport = options.textureOnViewport;\n    r.wheelSensitivity = options.wheelSensitivity;\n    r.motionBlurEnabled = options.motionBlur; // on by default\n\n    r.forcedPixelRatio = number$1(options.pixelRatio) ? options.pixelRatio : null;\n    r.motionBlur = options.motionBlur; // for initial kick off\n\n    r.motionBlurOpacity = options.motionBlurOpacity;\n    r.motionBlurTransparency = 1 - r.motionBlurOpacity;\n    r.motionBlurPxRatio = 1;\n    r.mbPxRBlurry = 1; //0.8;\n\n    r.minMbLowQualFrames = 4;\n    r.fullQualityMb = false;\n    r.clearedForMotionBlur = [];\n    r.desktopTapThreshold = options.desktopTapThreshold;\n    r.desktopTapThreshold2 = options.desktopTapThreshold * options.desktopTapThreshold;\n    r.touchTapThreshold = options.touchTapThreshold;\n    r.touchTapThreshold2 = options.touchTapThreshold * options.touchTapThreshold;\n    r.tapholdDuration = 500;\n    r.bindings = [];\n    r.beforeRenderCallbacks = [];\n    r.beforeRenderPriorities = {\n      // higher priority execs before lower one\n      animations: 400,\n      eleCalcs: 300,\n      eleTxrDeq: 200,\n      lyrTxrDeq: 150,\n      lyrTxrSkip: 100\n    };\n    r.registerNodeShapes();\n    r.registerArrowShapes();\n    r.registerCalculationListeners();\n  };\n\n  BRp.notify = function (eventName, eles) {\n    var r = this;\n    var cy = r.cy; // the renderer can't be notified after it's destroyed\n\n    if (this.destroyed) {\n      return;\n    }\n\n    if (eventName === 'init') {\n      r.load();\n      return;\n    }\n\n    if (eventName === 'destroy') {\n      r.destroy();\n      return;\n    }\n\n    if (eventName === 'add' || eventName === 'remove' || eventName === 'move' && cy.hasCompoundNodes() || eventName === 'load' || eventName === 'zorder' || eventName === 'mount') {\n      r.invalidateCachedZSortedEles();\n    }\n\n    if (eventName === 'viewport') {\n      r.redrawHint('select', true);\n    }\n\n    if (eventName === 'load' || eventName === 'resize' || eventName === 'mount') {\n      r.invalidateContainerClientCoordsCache();\n      r.matchCanvasSize(r.container);\n    }\n\n    r.redrawHint('eles', true);\n    r.redrawHint('drag', true);\n    this.startRenderLoop();\n    this.redraw();\n  };\n\n  BRp.destroy = function () {\n    var r = this;\n    r.destroyed = true;\n    r.cy.stopAnimationLoop();\n\n    for (var i = 0; i < r.bindings.length; i++) {\n      var binding = r.bindings[i];\n      var b = binding;\n      var tgt = b.target;\n      (tgt.off || tgt.removeEventListener).apply(tgt, b.args);\n    }\n\n    r.bindings = [];\n    r.beforeRenderCallbacks = [];\n    r.onUpdateEleCalcsFns = [];\n\n    if (r.removeObserver) {\n      r.removeObserver.disconnect();\n    }\n\n    if (r.styleObserver) {\n      r.styleObserver.disconnect();\n    }\n\n    if (r.resizeObserver) {\n      r.resizeObserver.disconnect();\n    }\n\n    if (r.labelCalcDiv) {\n      try {\n        document.body.removeChild(r.labelCalcDiv); // eslint-disable-line no-undef\n      } catch (e) {// ie10 issue #1014\n      }\n    }\n  };\n\n  BRp.isHeadless = function () {\n    return false;\n  };\n\n  [BRp$f, BRp$5, BRp$4, BRp$3, BRp$2, BRp$1].forEach(function (props) {\n    extend(BRp, props);\n  });\n\n  var fullFpsTime = 1000 / 60; // assume 60 frames per second\n\n  var defs = {\n    setupDequeueing: function setupDequeueing(opts) {\n      return function setupDequeueingImpl() {\n        var self = this;\n        var r = this.renderer;\n\n        if (self.dequeueingSetup) {\n          return;\n        } else {\n          self.dequeueingSetup = true;\n        }\n\n        var queueRedraw = debounce_1(function () {\n          r.redrawHint('eles', true);\n          r.redrawHint('drag', true);\n          r.redraw();\n        }, opts.deqRedrawThreshold);\n\n        var dequeue = function dequeue(willDraw, frameStartTime) {\n          var startTime = performanceNow();\n          var avgRenderTime = r.averageRedrawTime;\n          var renderTime = r.lastRedrawTime;\n          var deqd = [];\n          var extent = r.cy.extent();\n          var pixelRatio = r.getPixelRatio(); // if we aren't in a tick that causes a draw, then the rendered style\n          // queue won't automatically be flushed before dequeueing starts\n\n          if (!willDraw) {\n            r.flushRenderedStyleQueue();\n          }\n\n          while (true) {\n            // eslint-disable-line no-constant-condition\n            var now = performanceNow();\n            var duration = now - startTime;\n            var frameDuration = now - frameStartTime;\n\n            if (renderTime < fullFpsTime) {\n              // if we're rendering faster than the ideal fps, then do dequeueing\n              // during all of the remaining frame time\n              var timeAvailable = fullFpsTime - (willDraw ? avgRenderTime : 0);\n\n              if (frameDuration >= opts.deqFastCost * timeAvailable) {\n                break;\n              }\n            } else {\n              if (willDraw) {\n                if (duration >= opts.deqCost * renderTime || duration >= opts.deqAvgCost * avgRenderTime) {\n                  break;\n                }\n              } else if (frameDuration >= opts.deqNoDrawCost * fullFpsTime) {\n                break;\n              }\n            }\n\n            var thisDeqd = opts.deq(self, pixelRatio, extent);\n\n            if (thisDeqd.length > 0) {\n              for (var i = 0; i < thisDeqd.length; i++) {\n                deqd.push(thisDeqd[i]);\n              }\n            } else {\n              break;\n            }\n          } // callbacks on dequeue\n\n\n          if (deqd.length > 0) {\n            opts.onDeqd(self, deqd);\n\n            if (!willDraw && opts.shouldRedraw(self, deqd, pixelRatio, extent)) {\n              queueRedraw();\n            }\n          }\n        };\n\n        var priority = opts.priority || noop$1;\n        r.beforeRender(dequeue, priority(self));\n      };\n    }\n  };\n\n  // Uses keys so elements may share the same cache.\n\n  var ElementTextureCacheLookup = /*#__PURE__*/function () {\n    function ElementTextureCacheLookup(getKey) {\n      var doesEleInvalidateKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : falsify;\n\n      _classCallCheck(this, ElementTextureCacheLookup);\n\n      this.idsByKey = new Map$2();\n      this.keyForId = new Map$2();\n      this.cachesByLvl = new Map$2();\n      this.lvls = [];\n      this.getKey = getKey;\n      this.doesEleInvalidateKey = doesEleInvalidateKey;\n    }\n\n    _createClass(ElementTextureCacheLookup, [{\n      key: \"getIdsFor\",\n      value: function getIdsFor(key) {\n        if (key == null) {\n          error(\"Can not get id list for null key\");\n        }\n\n        var idsByKey = this.idsByKey;\n        var ids = this.idsByKey.get(key);\n\n        if (!ids) {\n          ids = new Set$1();\n          idsByKey.set(key, ids);\n        }\n\n        return ids;\n      }\n    }, {\n      key: \"addIdForKey\",\n      value: function addIdForKey(key, id) {\n        if (key != null) {\n          this.getIdsFor(key).add(id);\n        }\n      }\n    }, {\n      key: \"deleteIdForKey\",\n      value: function deleteIdForKey(key, id) {\n        if (key != null) {\n          this.getIdsFor(key)[\"delete\"](id);\n        }\n      }\n    }, {\n      key: \"getNumberOfIdsForKey\",\n      value: function getNumberOfIdsForKey(key) {\n        if (key == null) {\n          return 0;\n        } else {\n          return this.getIdsFor(key).size;\n        }\n      }\n    }, {\n      key: \"updateKeyMappingFor\",\n      value: function updateKeyMappingFor(ele) {\n        var id = ele.id();\n        var prevKey = this.keyForId.get(id);\n        var currKey = this.getKey(ele);\n        this.deleteIdForKey(prevKey, id);\n        this.addIdForKey(currKey, id);\n        this.keyForId.set(id, currKey);\n      }\n    }, {\n      key: \"deleteKeyMappingFor\",\n      value: function deleteKeyMappingFor(ele) {\n        var id = ele.id();\n        var prevKey = this.keyForId.get(id);\n        this.deleteIdForKey(prevKey, id);\n        this.keyForId[\"delete\"](id);\n      }\n    }, {\n      key: \"keyHasChangedFor\",\n      value: function keyHasChangedFor(ele) {\n        var id = ele.id();\n        var prevKey = this.keyForId.get(id);\n        var newKey = this.getKey(ele);\n        return prevKey !== newKey;\n      }\n    }, {\n      key: \"isInvalid\",\n      value: function isInvalid(ele) {\n        return this.keyHasChangedFor(ele) || this.doesEleInvalidateKey(ele);\n      }\n    }, {\n      key: \"getCachesAt\",\n      value: function getCachesAt(lvl) {\n        var cachesByLvl = this.cachesByLvl,\n            lvls = this.lvls;\n        var caches = cachesByLvl.get(lvl);\n\n        if (!caches) {\n          caches = new Map$2();\n          cachesByLvl.set(lvl, caches);\n          lvls.push(lvl);\n        }\n\n        return caches;\n      }\n    }, {\n      key: \"getCache\",\n      value: function getCache(key, lvl) {\n        return this.getCachesAt(lvl).get(key);\n      }\n    }, {\n      key: \"get\",\n      value: function get(ele, lvl) {\n        var key = this.getKey(ele);\n        var cache = this.getCache(key, lvl); // getting for an element may need to add to the id list b/c eles can share keys\n\n        if (cache != null) {\n          this.updateKeyMappingFor(ele);\n        }\n\n        return cache;\n      }\n    }, {\n      key: \"getForCachedKey\",\n      value: function getForCachedKey(ele, lvl) {\n        var key = this.keyForId.get(ele.id()); // n.b. use cached key, not newly computed key\n\n        var cache = this.getCache(key, lvl);\n        return cache;\n      }\n    }, {\n      key: \"hasCache\",\n      value: function hasCache(key, lvl) {\n        return this.getCachesAt(lvl).has(key);\n      }\n    }, {\n      key: \"has\",\n      value: function has(ele, lvl) {\n        var key = this.getKey(ele);\n        return this.hasCache(key, lvl);\n      }\n    }, {\n      key: \"setCache\",\n      value: function setCache(key, lvl, cache) {\n        cache.key = key;\n        this.getCachesAt(lvl).set(key, cache);\n      }\n    }, {\n      key: \"set\",\n      value: function set(ele, lvl, cache) {\n        var key = this.getKey(ele);\n        this.setCache(key, lvl, cache);\n        this.updateKeyMappingFor(ele);\n      }\n    }, {\n      key: \"deleteCache\",\n      value: function deleteCache(key, lvl) {\n        this.getCachesAt(lvl)[\"delete\"](key);\n      }\n    }, {\n      key: \"delete\",\n      value: function _delete(ele, lvl) {\n        var key = this.getKey(ele);\n        this.deleteCache(key, lvl);\n      }\n    }, {\n      key: \"invalidateKey\",\n      value: function invalidateKey(key) {\n        var _this = this;\n\n        this.lvls.forEach(function (lvl) {\n          return _this.deleteCache(key, lvl);\n        });\n      } // returns true if no other eles reference the invalidated cache (n.b. other eles may need the cache with the same key)\n\n    }, {\n      key: \"invalidate\",\n      value: function invalidate(ele) {\n        var id = ele.id();\n        var key = this.keyForId.get(id); // n.b. use stored key rather than current (potential key)\n\n        this.deleteKeyMappingFor(ele);\n        var entireKeyInvalidated = this.doesEleInvalidateKey(ele);\n\n        if (entireKeyInvalidated) {\n          // clear mapping for current key\n          this.invalidateKey(key);\n        }\n\n        return entireKeyInvalidated || this.getNumberOfIdsForKey(key) === 0;\n      }\n    }]);\n\n    return ElementTextureCacheLookup;\n  }();\n\n  var minTxrH = 25; // the size of the texture cache for small height eles (special case)\n\n  var txrStepH = 50; // the min size of the regular cache, and the size it increases with each step up\n\n  var minLvl$1 = -4; // when scaling smaller than that we don't need to re-render\n\n  var maxLvl$1 = 3; // when larger than this scale just render directly (caching is not helpful)\n\n  var maxZoom$1 = 7.99; // beyond this zoom level, layered textures are not used\n\n  var eleTxrSpacing = 8; // spacing between elements on textures to avoid blitting overlaps\n\n  var defTxrWidth = 1024; // default/minimum texture width\n\n  var maxTxrW = 1024; // the maximum width of a texture\n\n  var maxTxrH = 1024; // the maximum height of a texture\n\n  var minUtility = 0.2; // if usage of texture is less than this, it is retired\n\n  var maxFullness = 0.8; // fullness of texture after which queue removal is checked\n\n  var maxFullnessChecks = 10; // dequeued after this many checks\n\n  var deqCost$1 = 0.15; // % of add'l rendering cost allowed for dequeuing ele caches each frame\n\n  var deqAvgCost$1 = 0.1; // % of add'l rendering cost compared to average overall redraw time\n\n  var deqNoDrawCost$1 = 0.9; // % of avg frame time that can be used for dequeueing when not drawing\n\n  var deqFastCost$1 = 0.9; // % of frame time to be used when >60fps\n\n  var deqRedrawThreshold$1 = 100; // time to batch redraws together from dequeueing to allow more dequeueing calcs to happen in the meanwhile\n\n  var maxDeqSize$1 = 1; // number of eles to dequeue and render at higher texture in each batch\n\n  var getTxrReasons = {\n    dequeue: 'dequeue',\n    downscale: 'downscale',\n    highQuality: 'highQuality'\n  };\n  var initDefaults = defaults$g({\n    getKey: null,\n    doesEleInvalidateKey: falsify,\n    drawElement: null,\n    getBoundingBox: null,\n    getRotationPoint: null,\n    getRotationOffset: null,\n    isVisible: trueify,\n    allowEdgeTxrCaching: true,\n    allowParentTxrCaching: true\n  });\n\n  var ElementTextureCache = function ElementTextureCache(renderer, initOptions) {\n    var self = this;\n    self.renderer = renderer;\n    self.onDequeues = [];\n    var opts = initDefaults(initOptions);\n    extend(self, opts);\n    self.lookup = new ElementTextureCacheLookup(opts.getKey, opts.doesEleInvalidateKey);\n    self.setupDequeueing();\n  };\n\n  var ETCp = ElementTextureCache.prototype;\n  ETCp.reasons = getTxrReasons; // the list of textures in which new subtextures for elements can be placed\n\n  ETCp.getTextureQueue = function (txrH) {\n    var self = this;\n    self.eleImgCaches = self.eleImgCaches || {};\n    return self.eleImgCaches[txrH] = self.eleImgCaches[txrH] || [];\n  }; // the list of usused textures which can be recycled (in use in texture queue)\n\n\n  ETCp.getRetiredTextureQueue = function (txrH) {\n    var self = this;\n    var rtxtrQs = self.eleImgCaches.retired = self.eleImgCaches.retired || {};\n    var rtxtrQ = rtxtrQs[txrH] = rtxtrQs[txrH] || [];\n    return rtxtrQ;\n  }; // queue of element draw requests at different scale levels\n\n\n  ETCp.getElementQueue = function () {\n    var self = this;\n    var q = self.eleCacheQueue = self.eleCacheQueue || new heap(function (a, b) {\n      return b.reqs - a.reqs;\n    });\n    return q;\n  }; // queue of element draw requests at different scale levels (element id lookup)\n\n\n  ETCp.getElementKeyToQueue = function () {\n    var self = this;\n    var k2q = self.eleKeyToCacheQueue = self.eleKeyToCacheQueue || {};\n    return k2q;\n  };\n\n  ETCp.getElement = function (ele, bb, pxRatio, lvl, reason) {\n    var self = this;\n    var r = this.renderer;\n    var zoom = r.cy.zoom();\n    var lookup = this.lookup;\n\n    if (!bb || bb.w === 0 || bb.h === 0 || isNaN(bb.w) || isNaN(bb.h) || !ele.visible() || ele.removed()) {\n      return null;\n    }\n\n    if (!self.allowEdgeTxrCaching && ele.isEdge() || !self.allowParentTxrCaching && ele.isParent()) {\n      return null;\n    }\n\n    if (lvl == null) {\n      lvl = Math.ceil(log2(zoom * pxRatio));\n    }\n\n    if (lvl < minLvl$1) {\n      lvl = minLvl$1;\n    } else if (zoom >= maxZoom$1 || lvl > maxLvl$1) {\n      return null;\n    }\n\n    var scale = Math.pow(2, lvl);\n    var eleScaledH = bb.h * scale;\n    var eleScaledW = bb.w * scale;\n    var scaledLabelShown = r.eleTextBiggerThanMin(ele, scale);\n\n    if (!this.isVisible(ele, scaledLabelShown)) {\n      return null;\n    }\n\n    var eleCache = lookup.get(ele, lvl); // if this get was on an unused/invalidated cache, then restore the texture usage metric\n\n    if (eleCache && eleCache.invalidated) {\n      eleCache.invalidated = false;\n      eleCache.texture.invalidatedWidth -= eleCache.width;\n    }\n\n    if (eleCache) {\n      return eleCache;\n    }\n\n    var txrH; // which texture height this ele belongs to\n\n    if (eleScaledH <= minTxrH) {\n      txrH = minTxrH;\n    } else if (eleScaledH <= txrStepH) {\n      txrH = txrStepH;\n    } else {\n      txrH = Math.ceil(eleScaledH / txrStepH) * txrStepH;\n    }\n\n    if (eleScaledH > maxTxrH || eleScaledW > maxTxrW) {\n      return null; // caching large elements is not efficient\n    }\n\n    var txrQ = self.getTextureQueue(txrH); // first try the second last one in case it has space at the end\n\n    var txr = txrQ[txrQ.length - 2];\n\n    var addNewTxr = function addNewTxr() {\n      return self.recycleTexture(txrH, eleScaledW) || self.addTexture(txrH, eleScaledW);\n    }; // try the last one if there is no second last one\n\n\n    if (!txr) {\n      txr = txrQ[txrQ.length - 1];\n    } // if the last one doesn't exist, we need a first one\n\n\n    if (!txr) {\n      txr = addNewTxr();\n    } // if there's no room in the current texture, we need a new one\n\n\n    if (txr.width - txr.usedWidth < eleScaledW) {\n      txr = addNewTxr();\n    }\n\n    var scalableFrom = function scalableFrom(otherCache) {\n      return otherCache && otherCache.scaledLabelShown === scaledLabelShown;\n    };\n\n    var deqing = reason && reason === getTxrReasons.dequeue;\n    var highQualityReq = reason && reason === getTxrReasons.highQuality;\n    var downscaleReq = reason && reason === getTxrReasons.downscale;\n    var higherCache; // the nearest cache with a higher level\n\n    for (var l = lvl + 1; l <= maxLvl$1; l++) {\n      var c = lookup.get(ele, l);\n\n      if (c) {\n        higherCache = c;\n        break;\n      }\n    }\n\n    var oneUpCache = higherCache && higherCache.level === lvl + 1 ? higherCache : null;\n\n    var downscale = function downscale() {\n      txr.context.drawImage(oneUpCache.texture.canvas, oneUpCache.x, 0, oneUpCache.width, oneUpCache.height, txr.usedWidth, 0, eleScaledW, eleScaledH);\n    }; // reset ele area in texture\n\n\n    txr.context.setTransform(1, 0, 0, 1, 0, 0);\n    txr.context.clearRect(txr.usedWidth, 0, eleScaledW, txrH);\n\n    if (scalableFrom(oneUpCache)) {\n      // then we can relatively cheaply rescale the existing image w/o rerendering\n      downscale();\n    } else if (scalableFrom(higherCache)) {\n      // then use the higher cache for now and queue the next level down\n      // to cheaply scale towards the smaller level\n      if (highQualityReq) {\n        for (var _l = higherCache.level; _l > lvl; _l--) {\n          oneUpCache = self.getElement(ele, bb, pxRatio, _l, getTxrReasons.downscale);\n        }\n\n        downscale();\n      } else {\n        self.queueElement(ele, higherCache.level - 1);\n        return higherCache;\n      }\n    } else {\n      var lowerCache; // the nearest cache with a lower level\n\n      if (!deqing && !highQualityReq && !downscaleReq) {\n        for (var _l2 = lvl - 1; _l2 >= minLvl$1; _l2--) {\n          var _c = lookup.get(ele, _l2);\n\n          if (_c) {\n            lowerCache = _c;\n            break;\n          }\n        }\n      }\n\n      if (scalableFrom(lowerCache)) {\n        // then use the lower quality cache for now and queue the better one for later\n        self.queueElement(ele, lvl);\n        return lowerCache;\n      }\n\n      txr.context.translate(txr.usedWidth, 0);\n      txr.context.scale(scale, scale);\n      this.drawElement(txr.context, ele, bb, scaledLabelShown, false);\n      txr.context.scale(1 / scale, 1 / scale);\n      txr.context.translate(-txr.usedWidth, 0);\n    }\n\n    eleCache = {\n      x: txr.usedWidth,\n      texture: txr,\n      level: lvl,\n      scale: scale,\n      width: eleScaledW,\n      height: eleScaledH,\n      scaledLabelShown: scaledLabelShown\n    };\n    txr.usedWidth += Math.ceil(eleScaledW + eleTxrSpacing);\n    txr.eleCaches.push(eleCache);\n    lookup.set(ele, lvl, eleCache);\n    self.checkTextureFullness(txr);\n    return eleCache;\n  };\n\n  ETCp.invalidateElements = function (eles) {\n    for (var i = 0; i < eles.length; i++) {\n      this.invalidateElement(eles[i]);\n    }\n  };\n\n  ETCp.invalidateElement = function (ele) {\n    var self = this;\n    var lookup = self.lookup;\n    var caches = [];\n    var invalid = lookup.isInvalid(ele);\n\n    if (!invalid) {\n      return; // override the invalidation request if the element key has not changed\n    }\n\n    for (var lvl = minLvl$1; lvl <= maxLvl$1; lvl++) {\n      var cache = lookup.getForCachedKey(ele, lvl);\n\n      if (cache) {\n        caches.push(cache);\n      }\n    }\n\n    var noOtherElesUseCache = lookup.invalidate(ele);\n\n    if (noOtherElesUseCache) {\n      for (var i = 0; i < caches.length; i++) {\n        var _cache = caches[i];\n        var txr = _cache.texture; // remove space from the texture it belongs to\n\n        txr.invalidatedWidth += _cache.width; // mark the cache as invalidated\n\n        _cache.invalidated = true; // retire the texture if its utility is low\n\n        self.checkTextureUtility(txr);\n      }\n    } // remove from queue since the old req was for the old state\n\n\n    self.removeFromQueue(ele);\n  };\n\n  ETCp.checkTextureUtility = function (txr) {\n    // invalidate all entries in the cache if the cache size is small\n    if (txr.invalidatedWidth >= minUtility * txr.width) {\n      this.retireTexture(txr);\n    }\n  };\n\n  ETCp.checkTextureFullness = function (txr) {\n    // if texture has been mostly filled and passed over several times, remove\n    // it from the queue so we don't need to waste time looking at it to put new things\n    var self = this;\n    var txrQ = self.getTextureQueue(txr.height);\n\n    if (txr.usedWidth / txr.width > maxFullness && txr.fullnessChecks >= maxFullnessChecks) {\n      removeFromArray(txrQ, txr);\n    } else {\n      txr.fullnessChecks++;\n    }\n  };\n\n  ETCp.retireTexture = function (txr) {\n    var self = this;\n    var txrH = txr.height;\n    var txrQ = self.getTextureQueue(txrH);\n    var lookup = this.lookup; // retire the texture from the active / searchable queue:\n\n    removeFromArray(txrQ, txr);\n    txr.retired = true; // remove the refs from the eles to the caches:\n\n    var eleCaches = txr.eleCaches;\n\n    for (var i = 0; i < eleCaches.length; i++) {\n      var eleCache = eleCaches[i];\n      lookup.deleteCache(eleCache.key, eleCache.level);\n    }\n\n    clearArray(eleCaches); // add the texture to a retired queue so it can be recycled in future:\n\n    var rtxtrQ = self.getRetiredTextureQueue(txrH);\n    rtxtrQ.push(txr);\n  };\n\n  ETCp.addTexture = function (txrH, minW) {\n    var self = this;\n    var txrQ = self.getTextureQueue(txrH);\n    var txr = {};\n    txrQ.push(txr);\n    txr.eleCaches = [];\n    txr.height = txrH;\n    txr.width = Math.max(defTxrWidth, minW);\n    txr.usedWidth = 0;\n    txr.invalidatedWidth = 0;\n    txr.fullnessChecks = 0;\n    txr.canvas = self.renderer.makeOffscreenCanvas(txr.width, txr.height);\n    txr.context = txr.canvas.getContext('2d');\n    return txr;\n  };\n\n  ETCp.recycleTexture = function (txrH, minW) {\n    var self = this;\n    var txrQ = self.getTextureQueue(txrH);\n    var rtxtrQ = self.getRetiredTextureQueue(txrH);\n\n    for (var i = 0; i < rtxtrQ.length; i++) {\n      var txr = rtxtrQ[i];\n\n      if (txr.width >= minW) {\n        txr.retired = false;\n        txr.usedWidth = 0;\n        txr.invalidatedWidth = 0;\n        txr.fullnessChecks = 0;\n        clearArray(txr.eleCaches);\n        txr.context.setTransform(1, 0, 0, 1, 0, 0);\n        txr.context.clearRect(0, 0, txr.width, txr.height);\n        removeFromArray(rtxtrQ, txr);\n        txrQ.push(txr);\n        return txr;\n      }\n    }\n  };\n\n  ETCp.queueElement = function (ele, lvl) {\n    var self = this;\n    var q = self.getElementQueue();\n    var k2q = self.getElementKeyToQueue();\n    var key = this.getKey(ele);\n    var existingReq = k2q[key];\n\n    if (existingReq) {\n      // use the max lvl b/c in between lvls are cheap to make\n      existingReq.level = Math.max(existingReq.level, lvl);\n      existingReq.eles.merge(ele);\n      existingReq.reqs++;\n      q.updateItem(existingReq);\n    } else {\n      var req = {\n        eles: ele.spawn().merge(ele),\n        level: lvl,\n        reqs: 1,\n        key: key\n      };\n      q.push(req);\n      k2q[key] = req;\n    }\n  };\n\n  ETCp.dequeue = function (pxRatio\n  /*, extent*/\n  ) {\n    var self = this;\n    var q = self.getElementQueue();\n    var k2q = self.getElementKeyToQueue();\n    var dequeued = [];\n    var lookup = self.lookup;\n\n    for (var i = 0; i < maxDeqSize$1; i++) {\n      if (q.size() > 0) {\n        var req = q.pop();\n        var key = req.key;\n        var ele = req.eles[0]; // all eles have the same key\n\n        var cacheExists = lookup.hasCache(ele, req.level); // clear out the key to req lookup\n\n        k2q[key] = null; // dequeueing isn't necessary with an existing cache\n\n        if (cacheExists) {\n          continue;\n        }\n\n        dequeued.push(req);\n        var bb = self.getBoundingBox(ele);\n        self.getElement(ele, bb, pxRatio, req.level, getTxrReasons.dequeue);\n      } else {\n        break;\n      }\n    }\n\n    return dequeued;\n  };\n\n  ETCp.removeFromQueue = function (ele) {\n    var self = this;\n    var q = self.getElementQueue();\n    var k2q = self.getElementKeyToQueue();\n    var key = this.getKey(ele);\n    var req = k2q[key];\n\n    if (req != null) {\n      if (req.eles.length === 1) {\n        // remove if last ele in the req\n        // bring to front of queue\n        req.reqs = MAX_INT$1;\n        q.updateItem(req);\n        q.pop(); // remove from queue\n\n        k2q[key] = null; // remove from lookup map\n      } else {\n        // otherwise just remove ele from req\n        req.eles.unmerge(ele);\n      }\n    }\n  };\n\n  ETCp.onDequeue = function (fn) {\n    this.onDequeues.push(fn);\n  };\n\n  ETCp.offDequeue = function (fn) {\n    removeFromArray(this.onDequeues, fn);\n  };\n\n  ETCp.setupDequeueing = defs.setupDequeueing({\n    deqRedrawThreshold: deqRedrawThreshold$1,\n    deqCost: deqCost$1,\n    deqAvgCost: deqAvgCost$1,\n    deqNoDrawCost: deqNoDrawCost$1,\n    deqFastCost: deqFastCost$1,\n    deq: function deq(self, pxRatio, extent) {\n      return self.dequeue(pxRatio, extent);\n    },\n    onDeqd: function onDeqd(self, deqd) {\n      for (var i = 0; i < self.onDequeues.length; i++) {\n        var fn = self.onDequeues[i];\n        fn(deqd);\n      }\n    },\n    shouldRedraw: function shouldRedraw(self, deqd, pxRatio, extent) {\n      for (var i = 0; i < deqd.length; i++) {\n        var eles = deqd[i].eles;\n\n        for (var j = 0; j < eles.length; j++) {\n          var bb = eles[j].boundingBox();\n\n          if (boundingBoxesIntersect(bb, extent)) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    },\n    priority: function priority(self) {\n      return self.renderer.beforeRenderPriorities.eleTxrDeq;\n    }\n  });\n\n  var defNumLayers = 1; // default number of layers to use\n\n  var minLvl = -4; // when scaling smaller than that we don't need to re-render\n\n  var maxLvl = 2; // when larger than this scale just render directly (caching is not helpful)\n\n  var maxZoom = 3.99; // beyond this zoom level, layered textures are not used\n\n  var deqRedrawThreshold = 50; // time to batch redraws together from dequeueing to allow more dequeueing calcs to happen in the meanwhile\n\n  var refineEleDebounceTime = 50; // time to debounce sharper ele texture updates\n\n  var deqCost = 0.15; // % of add'l rendering cost allowed for dequeuing ele caches each frame\n\n  var deqAvgCost = 0.1; // % of add'l rendering cost compared to average overall redraw time\n\n  var deqNoDrawCost = 0.9; // % of avg frame time that can be used for dequeueing when not drawing\n\n  var deqFastCost = 0.9; // % of frame time to be used when >60fps\n\n  var maxDeqSize = 1; // number of eles to dequeue and render at higher texture in each batch\n\n  var invalidThreshold = 250; // time threshold for disabling b/c of invalidations\n\n  var maxLayerArea = 4000 * 4000; // layers can't be bigger than this\n\n  var useHighQualityEleTxrReqs = true; // whether to use high quality ele txr requests (generally faster and cheaper in the longterm)\n  // var log = function(){ console.log.apply( console, arguments ); };\n\n  var LayeredTextureCache = function LayeredTextureCache(renderer) {\n    var self = this;\n    var r = self.renderer = renderer;\n    var cy = r.cy;\n    self.layersByLevel = {}; // e.g. 2 => [ layer1, layer2, ..., layerN ]\n\n    self.firstGet = true;\n    self.lastInvalidationTime = performanceNow() - 2 * invalidThreshold;\n    self.skipping = false;\n    self.eleTxrDeqs = cy.collection();\n    self.scheduleElementRefinement = debounce_1(function () {\n      self.refineElementTextures(self.eleTxrDeqs);\n      self.eleTxrDeqs.unmerge(self.eleTxrDeqs);\n    }, refineEleDebounceTime);\n    r.beforeRender(function (willDraw, now) {\n      if (now - self.lastInvalidationTime <= invalidThreshold) {\n        self.skipping = true;\n      } else {\n        self.skipping = false;\n      }\n    }, r.beforeRenderPriorities.lyrTxrSkip);\n\n    var qSort = function qSort(a, b) {\n      return b.reqs - a.reqs;\n    };\n\n    self.layersQueue = new heap(qSort);\n    self.setupDequeueing();\n  };\n\n  var LTCp = LayeredTextureCache.prototype;\n  var layerIdPool = 0;\n  var MAX_INT = Math.pow(2, 53) - 1;\n\n  LTCp.makeLayer = function (bb, lvl) {\n    var scale = Math.pow(2, lvl);\n    var w = Math.ceil(bb.w * scale);\n    var h = Math.ceil(bb.h * scale);\n    var canvas = this.renderer.makeOffscreenCanvas(w, h);\n    var layer = {\n      id: layerIdPool = ++layerIdPool % MAX_INT,\n      bb: bb,\n      level: lvl,\n      width: w,\n      height: h,\n      canvas: canvas,\n      context: canvas.getContext('2d'),\n      eles: [],\n      elesQueue: [],\n      reqs: 0\n    }; // log('make layer %s with w %s and h %s and lvl %s', layer.id, layer.width, layer.height, layer.level);\n\n    var cxt = layer.context;\n    var dx = -layer.bb.x1;\n    var dy = -layer.bb.y1; // do the transform on creation to save cycles (it's the same for all eles)\n\n    cxt.scale(scale, scale);\n    cxt.translate(dx, dy);\n    return layer;\n  };\n\n  LTCp.getLayers = function (eles, pxRatio, lvl) {\n    var self = this;\n    var r = self.renderer;\n    var cy = r.cy;\n    var zoom = cy.zoom();\n    var firstGet = self.firstGet;\n    self.firstGet = false; // log('--\\nget layers with %s eles', eles.length);\n    //log eles.map(function(ele){ return ele.id() }) );\n\n    if (lvl == null) {\n      lvl = Math.ceil(log2(zoom * pxRatio));\n\n      if (lvl < minLvl) {\n        lvl = minLvl;\n      } else if (zoom >= maxZoom || lvl > maxLvl) {\n        return null;\n      }\n    }\n\n    self.validateLayersElesOrdering(lvl, eles);\n    var layersByLvl = self.layersByLevel;\n    var scale = Math.pow(2, lvl);\n    var layers = layersByLvl[lvl] = layersByLvl[lvl] || [];\n    var bb;\n    var lvlComplete = self.levelIsComplete(lvl, eles);\n    var tmpLayers;\n\n    var checkTempLevels = function checkTempLevels() {\n      var canUseAsTmpLvl = function canUseAsTmpLvl(l) {\n        self.validateLayersElesOrdering(l, eles);\n\n        if (self.levelIsComplete(l, eles)) {\n          tmpLayers = layersByLvl[l];\n          return true;\n        }\n      };\n\n      var checkLvls = function checkLvls(dir) {\n        if (tmpLayers) {\n          return;\n        }\n\n        for (var l = lvl + dir; minLvl <= l && l <= maxLvl; l += dir) {\n          if (canUseAsTmpLvl(l)) {\n            break;\n          }\n        }\n      };\n\n      checkLvls(+1);\n      checkLvls(-1); // remove the invalid layers; they will be replaced as needed later in this function\n\n      for (var i = layers.length - 1; i >= 0; i--) {\n        var layer = layers[i];\n\n        if (layer.invalid) {\n          removeFromArray(layers, layer);\n        }\n      }\n    };\n\n    if (!lvlComplete) {\n      // if the current level is incomplete, then use the closest, best quality layerset temporarily\n      // and later queue the current layerset so we can get the proper quality level soon\n      checkTempLevels();\n    } else {\n      // log('level complete, using existing layers\\n--');\n      return layers;\n    }\n\n    var getBb = function getBb() {\n      if (!bb) {\n        bb = makeBoundingBox();\n\n        for (var i = 0; i < eles.length; i++) {\n          updateBoundingBox(bb, eles[i].boundingBox());\n        }\n      }\n\n      return bb;\n    };\n\n    var makeLayer = function makeLayer(opts) {\n      opts = opts || {};\n      var after = opts.after;\n      getBb();\n      var area = bb.w * scale * (bb.h * scale);\n\n      if (area > maxLayerArea) {\n        return null;\n      }\n\n      var layer = self.makeLayer(bb, lvl);\n\n      if (after != null) {\n        var index = layers.indexOf(after) + 1;\n        layers.splice(index, 0, layer);\n      } else if (opts.insert === undefined || opts.insert) {\n        // no after specified => first layer made so put at start\n        layers.unshift(layer);\n      } // if( tmpLayers ){\n      //self.queueLayer( layer );\n      // }\n\n\n      return layer;\n    };\n\n    if (self.skipping && !firstGet) {\n      // log('skip layers');\n      return null;\n    } // log('do layers');\n\n\n    var layer = null;\n    var maxElesPerLayer = eles.length / defNumLayers;\n    var allowLazyQueueing = !firstGet;\n\n    for (var i = 0; i < eles.length; i++) {\n      var ele = eles[i];\n      var rs = ele._private.rscratch;\n      var caches = rs.imgLayerCaches = rs.imgLayerCaches || {}; // log('look at ele', ele.id());\n\n      var existingLayer = caches[lvl];\n\n      if (existingLayer) {\n        // reuse layer for later eles\n        // log('reuse layer for', ele.id());\n        layer = existingLayer;\n        continue;\n      }\n\n      if (!layer || layer.eles.length >= maxElesPerLayer || !boundingBoxInBoundingBox(layer.bb, ele.boundingBox())) {\n        // log('make new layer for ele %s', ele.id());\n        layer = makeLayer({\n          insert: true,\n          after: layer\n        }); // if now layer can be built then we can't use layers at this level\n\n        if (!layer) {\n          return null;\n        } // log('new layer with id %s', layer.id);\n\n      }\n\n      if (tmpLayers || allowLazyQueueing) {\n        // log('queue ele %s in layer %s', ele.id(), layer.id);\n        self.queueLayer(layer, ele);\n      } else {\n        // log('draw ele %s in layer %s', ele.id(), layer.id);\n        self.drawEleInLayer(layer, ele, lvl, pxRatio);\n      }\n\n      layer.eles.push(ele);\n      caches[lvl] = layer;\n    } // log('--');\n\n\n    if (tmpLayers) {\n      // then we only queued the current layerset and can't draw it yet\n      return tmpLayers;\n    }\n\n    if (allowLazyQueueing) {\n      // log('lazy queue level', lvl);\n      return null;\n    }\n\n    return layers;\n  }; // a layer may want to use an ele cache of a higher level to avoid blurriness\n  // so the layer level might not equal the ele level\n\n\n  LTCp.getEleLevelForLayerLevel = function (lvl, pxRatio) {\n    return lvl;\n  };\n\n  LTCp.drawEleInLayer = function (layer, ele, lvl, pxRatio) {\n    var self = this;\n    var r = this.renderer;\n    var context = layer.context;\n    var bb = ele.boundingBox();\n\n    if (bb.w === 0 || bb.h === 0 || !ele.visible()) {\n      return;\n    }\n\n    lvl = self.getEleLevelForLayerLevel(lvl, pxRatio);\n\n    {\n      r.setImgSmoothing(context, false);\n    }\n\n    {\n      r.drawCachedElement(context, ele, null, null, lvl, useHighQualityEleTxrReqs);\n    }\n\n    {\n      r.setImgSmoothing(context, true);\n    }\n  };\n\n  LTCp.levelIsComplete = function (lvl, eles) {\n    var self = this;\n    var layers = self.layersByLevel[lvl];\n\n    if (!layers || layers.length === 0) {\n      return false;\n    }\n\n    var numElesInLayers = 0;\n\n    for (var i = 0; i < layers.length; i++) {\n      var layer = layers[i]; // if there are any eles needed to be drawn yet, the level is not complete\n\n      if (layer.reqs > 0) {\n        return false;\n      } // if the layer is invalid, the level is not complete\n\n\n      if (layer.invalid) {\n        return false;\n      }\n\n      numElesInLayers += layer.eles.length;\n    } // we should have exactly the number of eles passed in to be complete\n\n\n    if (numElesInLayers !== eles.length) {\n      return false;\n    }\n\n    return true;\n  };\n\n  LTCp.validateLayersElesOrdering = function (lvl, eles) {\n    var layers = this.layersByLevel[lvl];\n\n    if (!layers) {\n      return;\n    } // if in a layer the eles are not in the same order, then the layer is invalid\n    // (i.e. there is an ele in between the eles in the layer)\n\n\n    for (var i = 0; i < layers.length; i++) {\n      var layer = layers[i];\n      var offset = -1; // find the offset\n\n      for (var j = 0; j < eles.length; j++) {\n        if (layer.eles[0] === eles[j]) {\n          offset = j;\n          break;\n        }\n      }\n\n      if (offset < 0) {\n        // then the layer has nonexistent elements and is invalid\n        this.invalidateLayer(layer);\n        continue;\n      } // the eles in the layer must be in the same continuous order, else the layer is invalid\n\n\n      var o = offset;\n\n      for (var j = 0; j < layer.eles.length; j++) {\n        if (layer.eles[j] !== eles[o + j]) {\n          // log('invalidate based on ordering', layer.id);\n          this.invalidateLayer(layer);\n          break;\n        }\n      }\n    }\n  };\n\n  LTCp.updateElementsInLayers = function (eles, update) {\n    var self = this;\n    var isEles = element(eles[0]); // collect udpated elements (cascaded from the layers) and update each\n    // layer itself along the way\n\n    for (var i = 0; i < eles.length; i++) {\n      var req = isEles ? null : eles[i];\n      var ele = isEles ? eles[i] : eles[i].ele;\n      var rs = ele._private.rscratch;\n      var caches = rs.imgLayerCaches = rs.imgLayerCaches || {};\n\n      for (var l = minLvl; l <= maxLvl; l++) {\n        var layer = caches[l];\n\n        if (!layer) {\n          continue;\n        } // if update is a request from the ele cache, then it affects only\n        // the matching level\n\n\n        if (req && self.getEleLevelForLayerLevel(layer.level) !== req.level) {\n          continue;\n        }\n\n        update(layer, ele, req);\n      }\n    }\n  };\n\n  LTCp.haveLayers = function () {\n    var self = this;\n    var haveLayers = false;\n\n    for (var l = minLvl; l <= maxLvl; l++) {\n      var layers = self.layersByLevel[l];\n\n      if (layers && layers.length > 0) {\n        haveLayers = true;\n        break;\n      }\n    }\n\n    return haveLayers;\n  };\n\n  LTCp.invalidateElements = function (eles) {\n    var self = this;\n\n    if (eles.length === 0) {\n      return;\n    }\n\n    self.lastInvalidationTime = performanceNow(); // log('update invalidate layer time from eles');\n\n    if (eles.length === 0 || !self.haveLayers()) {\n      return;\n    }\n\n    self.updateElementsInLayers(eles, function invalAssocLayers(layer, ele, req) {\n      self.invalidateLayer(layer);\n    });\n  };\n\n  LTCp.invalidateLayer = function (layer) {\n    // log('update invalidate layer time');\n    this.lastInvalidationTime = performanceNow();\n\n    if (layer.invalid) {\n      return;\n    } // save cycles\n\n\n    var lvl = layer.level;\n    var eles = layer.eles;\n    var layers = this.layersByLevel[lvl]; // log('invalidate layer', layer.id );\n\n    removeFromArray(layers, layer); // layer.eles = [];\n\n    layer.elesQueue = [];\n    layer.invalid = true;\n\n    if (layer.replacement) {\n      layer.replacement.invalid = true;\n    }\n\n    for (var i = 0; i < eles.length; i++) {\n      var caches = eles[i]._private.rscratch.imgLayerCaches;\n\n      if (caches) {\n        caches[lvl] = null;\n      }\n    }\n  };\n\n  LTCp.refineElementTextures = function (eles) {\n    var self = this; // log('refine', eles.length);\n\n    self.updateElementsInLayers(eles, function refineEachEle(layer, ele, req) {\n      var rLyr = layer.replacement;\n\n      if (!rLyr) {\n        rLyr = layer.replacement = self.makeLayer(layer.bb, layer.level);\n        rLyr.replaces = layer;\n        rLyr.eles = layer.eles; // log('make replacement layer %s for %s with level %s', rLyr.id, layer.id, rLyr.level);\n      }\n\n      if (!rLyr.reqs) {\n        for (var i = 0; i < rLyr.eles.length; i++) {\n          self.queueLayer(rLyr, rLyr.eles[i]);\n        } // log('queue replacement layer refinement', rLyr.id);\n\n      }\n    });\n  };\n\n  LTCp.enqueueElementRefinement = function (ele) {\n\n    this.eleTxrDeqs.merge(ele);\n    this.scheduleElementRefinement();\n  };\n\n  LTCp.queueLayer = function (layer, ele) {\n    var self = this;\n    var q = self.layersQueue;\n    var elesQ = layer.elesQueue;\n    var hasId = elesQ.hasId = elesQ.hasId || {}; // if a layer is going to be replaced, queuing is a waste of time\n\n    if (layer.replacement) {\n      return;\n    }\n\n    if (ele) {\n      if (hasId[ele.id()]) {\n        return;\n      }\n\n      elesQ.push(ele);\n      hasId[ele.id()] = true;\n    }\n\n    if (layer.reqs) {\n      layer.reqs++;\n      q.updateItem(layer);\n    } else {\n      layer.reqs = 1;\n      q.push(layer);\n    }\n  };\n\n  LTCp.dequeue = function (pxRatio) {\n    var self = this;\n    var q = self.layersQueue;\n    var deqd = [];\n    var eleDeqs = 0;\n\n    while (eleDeqs < maxDeqSize) {\n      if (q.size() === 0) {\n        break;\n      }\n\n      var layer = q.peek(); // if a layer has been or will be replaced, then don't waste time with it\n\n      if (layer.replacement) {\n        // log('layer %s in queue skipped b/c it already has a replacement', layer.id);\n        q.pop();\n        continue;\n      } // if this is a replacement layer that has been superceded, then forget it\n\n\n      if (layer.replaces && layer !== layer.replaces.replacement) {\n        // log('layer is no longer the most uptodate replacement; dequeued', layer.id)\n        q.pop();\n        continue;\n      }\n\n      if (layer.invalid) {\n        // log('replacement layer %s is invalid; dequeued', layer.id);\n        q.pop();\n        continue;\n      }\n\n      var ele = layer.elesQueue.shift();\n\n      if (ele) {\n        // log('dequeue layer %s', layer.id);\n        self.drawEleInLayer(layer, ele, layer.level, pxRatio);\n        eleDeqs++;\n      }\n\n      if (deqd.length === 0) {\n        // we need only one entry in deqd to queue redrawing etc\n        deqd.push(true);\n      } // if the layer has all its eles done, then remove from the queue\n\n\n      if (layer.elesQueue.length === 0) {\n        q.pop();\n        layer.reqs = 0; // log('dequeue of layer %s complete', layer.id);\n        // when a replacement layer is dequeued, it replaces the old layer in the level\n\n        if (layer.replaces) {\n          self.applyLayerReplacement(layer);\n        }\n\n        self.requestRedraw();\n      }\n    }\n\n    return deqd;\n  };\n\n  LTCp.applyLayerReplacement = function (layer) {\n    var self = this;\n    var layersInLevel = self.layersByLevel[layer.level];\n    var replaced = layer.replaces;\n    var index = layersInLevel.indexOf(replaced); // if the replaced layer is not in the active list for the level, then replacing\n    // refs would be a mistake (i.e. overwriting the true active layer)\n\n    if (index < 0 || replaced.invalid) {\n      // log('replacement layer would have no effect', layer.id);\n      return;\n    }\n\n    layersInLevel[index] = layer; // replace level ref\n    // replace refs in eles\n\n    for (var i = 0; i < layer.eles.length; i++) {\n      var _p = layer.eles[i]._private;\n      var cache = _p.imgLayerCaches = _p.imgLayerCaches || {};\n\n      if (cache) {\n        cache[layer.level] = layer;\n      }\n    } // log('apply replacement layer %s over %s', layer.id, replaced.id);\n\n\n    self.requestRedraw();\n  };\n\n  LTCp.requestRedraw = debounce_1(function () {\n    var r = this.renderer;\n    r.redrawHint('eles', true);\n    r.redrawHint('drag', true);\n    r.redraw();\n  }, 100);\n  LTCp.setupDequeueing = defs.setupDequeueing({\n    deqRedrawThreshold: deqRedrawThreshold,\n    deqCost: deqCost,\n    deqAvgCost: deqAvgCost,\n    deqNoDrawCost: deqNoDrawCost,\n    deqFastCost: deqFastCost,\n    deq: function deq(self, pxRatio) {\n      return self.dequeue(pxRatio);\n    },\n    onDeqd: noop$1,\n    shouldRedraw: trueify,\n    priority: function priority(self) {\n      return self.renderer.beforeRenderPriorities.lyrTxrDeq;\n    }\n  });\n\n  var CRp$a = {};\n  var impl;\n\n  function polygon(context, points) {\n    for (var i = 0; i < points.length; i++) {\n      var pt = points[i];\n      context.lineTo(pt.x, pt.y);\n    }\n  }\n\n  function triangleBackcurve(context, points, controlPoint) {\n    var firstPt;\n\n    for (var i = 0; i < points.length; i++) {\n      var pt = points[i];\n\n      if (i === 0) {\n        firstPt = pt;\n      }\n\n      context.lineTo(pt.x, pt.y);\n    }\n\n    context.quadraticCurveTo(controlPoint.x, controlPoint.y, firstPt.x, firstPt.y);\n  }\n\n  function triangleTee(context, trianglePoints, teePoints) {\n    if (context.beginPath) {\n      context.beginPath();\n    }\n\n    var triPts = trianglePoints;\n\n    for (var i = 0; i < triPts.length; i++) {\n      var pt = triPts[i];\n      context.lineTo(pt.x, pt.y);\n    }\n\n    var teePts = teePoints;\n    var firstTeePt = teePoints[0];\n    context.moveTo(firstTeePt.x, firstTeePt.y);\n\n    for (var i = 1; i < teePts.length; i++) {\n      var pt = teePts[i];\n      context.lineTo(pt.x, pt.y);\n    }\n\n    if (context.closePath) {\n      context.closePath();\n    }\n  }\n\n  function circleTriangle(context, trianglePoints, rx, ry, r) {\n    if (context.beginPath) {\n      context.beginPath();\n    }\n\n    context.arc(rx, ry, r, 0, Math.PI * 2, false);\n    var triPts = trianglePoints;\n    var firstTrPt = triPts[0];\n    context.moveTo(firstTrPt.x, firstTrPt.y);\n\n    for (var i = 0; i < triPts.length; i++) {\n      var pt = triPts[i];\n      context.lineTo(pt.x, pt.y);\n    }\n\n    if (context.closePath) {\n      context.closePath();\n    }\n  }\n\n  function circle(context, rx, ry, r) {\n    context.arc(rx, ry, r, 0, Math.PI * 2, false);\n  }\n\n  CRp$a.arrowShapeImpl = function (name) {\n    return (impl || (impl = {\n      'polygon': polygon,\n      'triangle-backcurve': triangleBackcurve,\n      'triangle-tee': triangleTee,\n      'circle-triangle': circleTriangle,\n      'triangle-cross': triangleTee,\n      'circle': circle\n    }))[name];\n  };\n\n  var CRp$9 = {};\n\n  CRp$9.drawElement = function (context, ele, shiftToOriginWithBb, showLabel, showOverlay, showOpacity) {\n    var r = this;\n\n    if (ele.isNode()) {\n      r.drawNode(context, ele, shiftToOriginWithBb, showLabel, showOverlay, showOpacity);\n    } else {\n      r.drawEdge(context, ele, shiftToOriginWithBb, showLabel, showOverlay, showOpacity);\n    }\n  };\n\n  CRp$9.drawElementOverlay = function (context, ele) {\n    var r = this;\n\n    if (ele.isNode()) {\n      r.drawNodeOverlay(context, ele);\n    } else {\n      r.drawEdgeOverlay(context, ele);\n    }\n  };\n\n  CRp$9.drawElementUnderlay = function (context, ele) {\n    var r = this;\n\n    if (ele.isNode()) {\n      r.drawNodeUnderlay(context, ele);\n    } else {\n      r.drawEdgeUnderlay(context, ele);\n    }\n  };\n\n  CRp$9.drawCachedElementPortion = function (context, ele, eleTxrCache, pxRatio, lvl, reason, getRotation, getOpacity) {\n    var r = this;\n    var bb = eleTxrCache.getBoundingBox(ele);\n\n    if (bb.w === 0 || bb.h === 0) {\n      return;\n    } // ignore zero size case\n\n\n    var eleCache = eleTxrCache.getElement(ele, bb, pxRatio, lvl, reason);\n\n    if (eleCache != null) {\n      var opacity = getOpacity(r, ele);\n\n      if (opacity === 0) {\n        return;\n      }\n\n      var theta = getRotation(r, ele);\n      var x1 = bb.x1,\n          y1 = bb.y1,\n          w = bb.w,\n          h = bb.h;\n      var x, y, sx, sy, smooth;\n\n      if (theta !== 0) {\n        var rotPt = eleTxrCache.getRotationPoint(ele);\n        sx = rotPt.x;\n        sy = rotPt.y;\n        context.translate(sx, sy);\n        context.rotate(theta);\n        smooth = r.getImgSmoothing(context);\n\n        if (!smooth) {\n          r.setImgSmoothing(context, true);\n        }\n\n        var off = eleTxrCache.getRotationOffset(ele);\n        x = off.x;\n        y = off.y;\n      } else {\n        x = x1;\n        y = y1;\n      }\n\n      var oldGlobalAlpha;\n\n      if (opacity !== 1) {\n        oldGlobalAlpha = context.globalAlpha;\n        context.globalAlpha = oldGlobalAlpha * opacity;\n      }\n\n      context.drawImage(eleCache.texture.canvas, eleCache.x, 0, eleCache.width, eleCache.height, x, y, w, h);\n\n      if (opacity !== 1) {\n        context.globalAlpha = oldGlobalAlpha;\n      }\n\n      if (theta !== 0) {\n        context.rotate(-theta);\n        context.translate(-sx, -sy);\n\n        if (!smooth) {\n          r.setImgSmoothing(context, false);\n        }\n      }\n    } else {\n      eleTxrCache.drawElement(context, ele); // direct draw fallback\n    }\n  };\n\n  var getZeroRotation = function getZeroRotation() {\n    return 0;\n  };\n\n  var getLabelRotation = function getLabelRotation(r, ele) {\n    return r.getTextAngle(ele, null);\n  };\n\n  var getSourceLabelRotation = function getSourceLabelRotation(r, ele) {\n    return r.getTextAngle(ele, 'source');\n  };\n\n  var getTargetLabelRotation = function getTargetLabelRotation(r, ele) {\n    return r.getTextAngle(ele, 'target');\n  };\n\n  var getOpacity = function getOpacity(r, ele) {\n    return ele.effectiveOpacity();\n  };\n\n  var getTextOpacity = function getTextOpacity(e, ele) {\n    return ele.pstyle('text-opacity').pfValue * ele.effectiveOpacity();\n  };\n\n  CRp$9.drawCachedElement = function (context, ele, pxRatio, extent, lvl, requestHighQuality) {\n    var r = this;\n    var _r$data = r.data,\n        eleTxrCache = _r$data.eleTxrCache,\n        lblTxrCache = _r$data.lblTxrCache,\n        slbTxrCache = _r$data.slbTxrCache,\n        tlbTxrCache = _r$data.tlbTxrCache;\n    var bb = ele.boundingBox();\n    var reason = requestHighQuality === true ? eleTxrCache.reasons.highQuality : null;\n\n    if (bb.w === 0 || bb.h === 0 || !ele.visible()) {\n      return;\n    }\n\n    if (!extent || boundingBoxesIntersect(bb, extent)) {\n      var isEdge = ele.isEdge();\n\n      var badLine = ele.element()._private.rscratch.badLine;\n\n      r.drawElementUnderlay(context, ele);\n      r.drawCachedElementPortion(context, ele, eleTxrCache, pxRatio, lvl, reason, getZeroRotation, getOpacity);\n\n      if (!isEdge || !badLine) {\n        r.drawCachedElementPortion(context, ele, lblTxrCache, pxRatio, lvl, reason, getLabelRotation, getTextOpacity);\n      }\n\n      if (isEdge && !badLine) {\n        r.drawCachedElementPortion(context, ele, slbTxrCache, pxRatio, lvl, reason, getSourceLabelRotation, getTextOpacity);\n        r.drawCachedElementPortion(context, ele, tlbTxrCache, pxRatio, lvl, reason, getTargetLabelRotation, getTextOpacity);\n      }\n\n      r.drawElementOverlay(context, ele);\n    }\n  };\n\n  CRp$9.drawElements = function (context, eles) {\n    var r = this;\n\n    for (var i = 0; i < eles.length; i++) {\n      var ele = eles[i];\n      r.drawElement(context, ele);\n    }\n  };\n\n  CRp$9.drawCachedElements = function (context, eles, pxRatio, extent) {\n    var r = this;\n\n    for (var i = 0; i < eles.length; i++) {\n      var ele = eles[i];\n      r.drawCachedElement(context, ele, pxRatio, extent);\n    }\n  };\n\n  CRp$9.drawCachedNodes = function (context, eles, pxRatio, extent) {\n    var r = this;\n\n    for (var i = 0; i < eles.length; i++) {\n      var ele = eles[i];\n\n      if (!ele.isNode()) {\n        continue;\n      }\n\n      r.drawCachedElement(context, ele, pxRatio, extent);\n    }\n  };\n\n  CRp$9.drawLayeredElements = function (context, eles, pxRatio, extent) {\n    var r = this;\n    var layers = r.data.lyrTxrCache.getLayers(eles, pxRatio);\n\n    if (layers) {\n      for (var i = 0; i < layers.length; i++) {\n        var layer = layers[i];\n        var bb = layer.bb;\n\n        if (bb.w === 0 || bb.h === 0) {\n          continue;\n        }\n\n        context.drawImage(layer.canvas, bb.x1, bb.y1, bb.w, bb.h);\n      }\n    } else {\n      // fall back on plain caching if no layers\n      r.drawCachedElements(context, eles, pxRatio, extent);\n    }\n  };\n\n  /* global Path2D */\n  var CRp$8 = {};\n\n  CRp$8.drawEdge = function (context, edge, shiftToOriginWithBb) {\n    var drawLabel = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    var shouldDrawOverlay = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    var shouldDrawOpacity = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n    var r = this;\n    var rs = edge._private.rscratch;\n\n    if (shouldDrawOpacity && !edge.visible()) {\n      return;\n    } // if bezier ctrl pts can not be calculated, then die\n\n\n    if (rs.badLine || rs.allpts == null || isNaN(rs.allpts[0])) {\n      // isNaN in case edge is impossible and browser bugs (e.g. safari)\n      return;\n    }\n\n    var bb;\n\n    if (shiftToOriginWithBb) {\n      bb = shiftToOriginWithBb;\n      context.translate(-bb.x1, -bb.y1);\n    }\n\n    var opacity = shouldDrawOpacity ? edge.pstyle('opacity').value : 1;\n    var lineOpacity = shouldDrawOpacity ? edge.pstyle('line-opacity').value : 1;\n    var curveStyle = edge.pstyle('curve-style').value;\n    var lineStyle = edge.pstyle('line-style').value;\n    var edgeWidth = edge.pstyle('width').pfValue;\n    var lineCap = edge.pstyle('line-cap').value;\n    var effectiveLineOpacity = opacity * lineOpacity; // separate arrow opacity would require arrow-opacity property\n\n    var effectiveArrowOpacity = opacity * lineOpacity;\n\n    var drawLine = function drawLine() {\n      var strokeOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : effectiveLineOpacity;\n\n      if (curveStyle === 'straight-triangle') {\n        r.eleStrokeStyle(context, edge, strokeOpacity);\n        r.drawEdgeTrianglePath(edge, context, rs.allpts);\n      } else {\n        context.lineWidth = edgeWidth;\n        context.lineCap = lineCap;\n        r.eleStrokeStyle(context, edge, strokeOpacity);\n        r.drawEdgePath(edge, context, rs.allpts, lineStyle);\n        context.lineCap = 'butt'; // reset for other drawing functions\n      }\n    };\n\n    var drawOverlay = function drawOverlay() {\n      if (!shouldDrawOverlay) {\n        return;\n      }\n\n      r.drawEdgeOverlay(context, edge);\n    };\n\n    var drawUnderlay = function drawUnderlay() {\n      if (!shouldDrawOverlay) {\n        return;\n      }\n\n      r.drawEdgeUnderlay(context, edge);\n    };\n\n    var drawArrows = function drawArrows() {\n      var arrowOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : effectiveArrowOpacity;\n      r.drawArrowheads(context, edge, arrowOpacity);\n    };\n\n    var drawText = function drawText() {\n      r.drawElementText(context, edge, null, drawLabel);\n    };\n\n    context.lineJoin = 'round';\n    var ghost = edge.pstyle('ghost').value === 'yes';\n\n    if (ghost) {\n      var gx = edge.pstyle('ghost-offset-x').pfValue;\n      var gy = edge.pstyle('ghost-offset-y').pfValue;\n      var ghostOpacity = edge.pstyle('ghost-opacity').value;\n      var effectiveGhostOpacity = effectiveLineOpacity * ghostOpacity;\n      context.translate(gx, gy);\n      drawLine(effectiveGhostOpacity);\n      drawArrows(effectiveGhostOpacity);\n      context.translate(-gx, -gy);\n    }\n\n    drawUnderlay();\n    drawLine();\n    drawArrows();\n    drawOverlay();\n    drawText();\n\n    if (shiftToOriginWithBb) {\n      context.translate(bb.x1, bb.y1);\n    }\n  };\n\n  var drawEdgeOverlayUnderlay = function drawEdgeOverlayUnderlay(overlayOrUnderlay) {\n    if (!['overlay', 'underlay'].includes(overlayOrUnderlay)) {\n      throw new Error('Invalid state');\n    }\n\n    return function (context, edge) {\n      if (!edge.visible()) {\n        return;\n      }\n\n      var opacity = edge.pstyle(\"\".concat(overlayOrUnderlay, \"-opacity\")).value;\n\n      if (opacity === 0) {\n        return;\n      }\n\n      var r = this;\n      var usePaths = r.usePaths();\n      var rs = edge._private.rscratch;\n      var padding = edge.pstyle(\"\".concat(overlayOrUnderlay, \"-padding\")).pfValue;\n      var width = 2 * padding;\n      var color = edge.pstyle(\"\".concat(overlayOrUnderlay, \"-color\")).value;\n      context.lineWidth = width;\n\n      if (rs.edgeType === 'self' && !usePaths) {\n        context.lineCap = 'butt';\n      } else {\n        context.lineCap = 'round';\n      }\n\n      r.colorStrokeStyle(context, color[0], color[1], color[2], opacity);\n      r.drawEdgePath(edge, context, rs.allpts, 'solid');\n    };\n  };\n\n  CRp$8.drawEdgeOverlay = drawEdgeOverlayUnderlay('overlay');\n  CRp$8.drawEdgeUnderlay = drawEdgeOverlayUnderlay('underlay');\n\n  CRp$8.drawEdgePath = function (edge, context, pts, type) {\n    var rs = edge._private.rscratch;\n    var canvasCxt = context;\n    var path;\n    var pathCacheHit = false;\n    var usePaths = this.usePaths();\n    var lineDashPattern = edge.pstyle('line-dash-pattern').pfValue;\n    var lineDashOffset = edge.pstyle('line-dash-offset').pfValue;\n\n    if (usePaths) {\n      var pathCacheKey = pts.join('$');\n      var keyMatches = rs.pathCacheKey && rs.pathCacheKey === pathCacheKey;\n\n      if (keyMatches) {\n        path = context = rs.pathCache;\n        pathCacheHit = true;\n      } else {\n        path = context = new Path2D();\n        rs.pathCacheKey = pathCacheKey;\n        rs.pathCache = path;\n      }\n    }\n\n    if (canvasCxt.setLineDash) {\n      // for very outofdate browsers\n      switch (type) {\n        case 'dotted':\n          canvasCxt.setLineDash([1, 1]);\n          break;\n\n        case 'dashed':\n          canvasCxt.setLineDash(lineDashPattern);\n          canvasCxt.lineDashOffset = lineDashOffset;\n          break;\n\n        case 'solid':\n          canvasCxt.setLineDash([]);\n          break;\n      }\n    }\n\n    if (!pathCacheHit && !rs.badLine) {\n      if (context.beginPath) {\n        context.beginPath();\n      }\n\n      context.moveTo(pts[0], pts[1]);\n\n      switch (rs.edgeType) {\n        case 'bezier':\n        case 'self':\n        case 'compound':\n        case 'multibezier':\n          for (var i = 2; i + 3 < pts.length; i += 4) {\n            context.quadraticCurveTo(pts[i], pts[i + 1], pts[i + 2], pts[i + 3]);\n          }\n\n          break;\n\n        case 'straight':\n        case 'segments':\n        case 'haystack':\n          for (var _i = 2; _i + 1 < pts.length; _i += 2) {\n            context.lineTo(pts[_i], pts[_i + 1]);\n          }\n\n          break;\n      }\n    }\n\n    context = canvasCxt;\n\n    if (usePaths) {\n      context.stroke(path);\n    } else {\n      context.stroke();\n    } // reset any line dashes\n\n\n    if (context.setLineDash) {\n      // for very outofdate browsers\n      context.setLineDash([]);\n    }\n  };\n\n  CRp$8.drawEdgeTrianglePath = function (edge, context, pts) {\n    // use line stroke style for triangle fill style\n    context.fillStyle = context.strokeStyle;\n    var edgeWidth = edge.pstyle('width').pfValue;\n\n    for (var i = 0; i + 1 < pts.length; i += 2) {\n      var vector = [pts[i + 2] - pts[i], pts[i + 3] - pts[i + 1]];\n      var length = Math.sqrt(vector[0] * vector[0] + vector[1] * vector[1]);\n      var normal = [vector[1] / length, -vector[0] / length];\n      var triangleHead = [normal[0] * edgeWidth / 2, normal[1] * edgeWidth / 2];\n      context.beginPath();\n      context.moveTo(pts[i] - triangleHead[0], pts[i + 1] - triangleHead[1]);\n      context.lineTo(pts[i] + triangleHead[0], pts[i + 1] + triangleHead[1]);\n      context.lineTo(pts[i + 2], pts[i + 3]);\n      context.closePath();\n      context.fill();\n    }\n  };\n\n  CRp$8.drawArrowheads = function (context, edge, opacity) {\n    var rs = edge._private.rscratch;\n    var isHaystack = rs.edgeType === 'haystack';\n\n    if (!isHaystack) {\n      this.drawArrowhead(context, edge, 'source', rs.arrowStartX, rs.arrowStartY, rs.srcArrowAngle, opacity);\n    }\n\n    this.drawArrowhead(context, edge, 'mid-target', rs.midX, rs.midY, rs.midtgtArrowAngle, opacity);\n    this.drawArrowhead(context, edge, 'mid-source', rs.midX, rs.midY, rs.midsrcArrowAngle, opacity);\n\n    if (!isHaystack) {\n      this.drawArrowhead(context, edge, 'target', rs.arrowEndX, rs.arrowEndY, rs.tgtArrowAngle, opacity);\n    }\n  };\n\n  CRp$8.drawArrowhead = function (context, edge, prefix, x, y, angle, opacity) {\n    if (isNaN(x) || x == null || isNaN(y) || y == null || isNaN(angle) || angle == null) {\n      return;\n    }\n\n    var self = this;\n    var arrowShape = edge.pstyle(prefix + '-arrow-shape').value;\n\n    if (arrowShape === 'none') {\n      return;\n    }\n\n    var arrowClearFill = edge.pstyle(prefix + '-arrow-fill').value === 'hollow' ? 'both' : 'filled';\n    var arrowFill = edge.pstyle(prefix + '-arrow-fill').value;\n    var edgeWidth = edge.pstyle('width').pfValue;\n    var edgeOpacity = edge.pstyle('opacity').value;\n\n    if (opacity === undefined) {\n      opacity = edgeOpacity;\n    }\n\n    var gco = context.globalCompositeOperation;\n\n    if (opacity !== 1 || arrowFill === 'hollow') {\n      // then extra clear is needed\n      context.globalCompositeOperation = 'destination-out';\n      self.colorFillStyle(context, 255, 255, 255, 1);\n      self.colorStrokeStyle(context, 255, 255, 255, 1);\n      self.drawArrowShape(edge, context, arrowClearFill, edgeWidth, arrowShape, x, y, angle);\n      context.globalCompositeOperation = gco;\n    } // otherwise, the opaque arrow clears it for free :)\n\n\n    var color = edge.pstyle(prefix + '-arrow-color').value;\n    self.colorFillStyle(context, color[0], color[1], color[2], opacity);\n    self.colorStrokeStyle(context, color[0], color[1], color[2], opacity);\n    self.drawArrowShape(edge, context, arrowFill, edgeWidth, arrowShape, x, y, angle);\n  };\n\n  CRp$8.drawArrowShape = function (edge, context, fill, edgeWidth, shape, x, y, angle) {\n    var r = this;\n    var usePaths = this.usePaths() && shape !== 'triangle-cross';\n    var pathCacheHit = false;\n    var path;\n    var canvasContext = context;\n    var translation = {\n      x: x,\n      y: y\n    };\n    var scale = edge.pstyle('arrow-scale').value;\n    var size = this.getArrowWidth(edgeWidth, scale);\n    var shapeImpl = r.arrowShapes[shape];\n\n    if (usePaths) {\n      var cache = r.arrowPathCache = r.arrowPathCache || [];\n      var key = hashString(shape);\n      var cachedPath = cache[key];\n\n      if (cachedPath != null) {\n        path = context = cachedPath;\n        pathCacheHit = true;\n      } else {\n        path = context = new Path2D();\n        cache[key] = path;\n      }\n    }\n\n    if (!pathCacheHit) {\n      if (context.beginPath) {\n        context.beginPath();\n      }\n\n      if (usePaths) {\n        // store in the path cache with values easily manipulated later\n        shapeImpl.draw(context, 1, 0, {\n          x: 0,\n          y: 0\n        }, 1);\n      } else {\n        shapeImpl.draw(context, size, angle, translation, edgeWidth);\n      }\n\n      if (context.closePath) {\n        context.closePath();\n      }\n    }\n\n    context = canvasContext;\n\n    if (usePaths) {\n      // set transform to arrow position/orientation\n      context.translate(x, y);\n      context.rotate(angle);\n      context.scale(size, size);\n    }\n\n    if (fill === 'filled' || fill === 'both') {\n      if (usePaths) {\n        context.fill(path);\n      } else {\n        context.fill();\n      }\n    }\n\n    if (fill === 'hollow' || fill === 'both') {\n      context.lineWidth = (shapeImpl.matchEdgeWidth ? edgeWidth : 1) / (usePaths ? size : 1);\n      context.lineJoin = 'miter';\n\n      if (usePaths) {\n        context.stroke(path);\n      } else {\n        context.stroke();\n      }\n    }\n\n    if (usePaths) {\n      // reset transform by applying inverse\n      context.scale(1 / size, 1 / size);\n      context.rotate(-angle);\n      context.translate(-x, -y);\n    }\n  };\n\n  var CRp$7 = {};\n\n  CRp$7.safeDrawImage = function (context, img, ix, iy, iw, ih, x, y, w, h) {\n    // detect problematic cases for old browsers with bad images (cheaper than try-catch)\n    if (iw <= 0 || ih <= 0 || w <= 0 || h <= 0) {\n      return;\n    }\n\n    try {\n      context.drawImage(img, ix, iy, iw, ih, x, y, w, h);\n    } catch (e) {\n      warn(e);\n    }\n  };\n\n  CRp$7.drawInscribedImage = function (context, img, node, index, nodeOpacity) {\n    var r = this;\n    var pos = node.position();\n    var nodeX = pos.x;\n    var nodeY = pos.y;\n    var styleObj = node.cy().style();\n    var getIndexedStyle = styleObj.getIndexedStyle.bind(styleObj);\n    var fit = getIndexedStyle(node, 'background-fit', 'value', index);\n    var repeat = getIndexedStyle(node, 'background-repeat', 'value', index);\n    var nodeW = node.width();\n    var nodeH = node.height();\n    var paddingX2 = node.padding() * 2;\n    var nodeTW = nodeW + (getIndexedStyle(node, 'background-width-relative-to', 'value', index) === 'inner' ? 0 : paddingX2);\n    var nodeTH = nodeH + (getIndexedStyle(node, 'background-height-relative-to', 'value', index) === 'inner' ? 0 : paddingX2);\n    var rs = node._private.rscratch;\n    var clip = getIndexedStyle(node, 'background-clip', 'value', index);\n    var shouldClip = clip === 'node';\n    var imgOpacity = getIndexedStyle(node, 'background-image-opacity', 'value', index) * nodeOpacity;\n    var smooth = getIndexedStyle(node, 'background-image-smoothing', 'value', index);\n    var imgW = img.width || img.cachedW;\n    var imgH = img.height || img.cachedH; // workaround for broken browsers like ie\n\n    if (null == imgW || null == imgH) {\n      document.body.appendChild(img); // eslint-disable-line no-undef\n\n      imgW = img.cachedW = img.width || img.offsetWidth;\n      imgH = img.cachedH = img.height || img.offsetHeight;\n      document.body.removeChild(img); // eslint-disable-line no-undef\n    }\n\n    var w = imgW;\n    var h = imgH;\n\n    if (getIndexedStyle(node, 'background-width', 'value', index) !== 'auto') {\n      if (getIndexedStyle(node, 'background-width', 'units', index) === '%') {\n        w = getIndexedStyle(node, 'background-width', 'pfValue', index) * nodeTW;\n      } else {\n        w = getIndexedStyle(node, 'background-width', 'pfValue', index);\n      }\n    }\n\n    if (getIndexedStyle(node, 'background-height', 'value', index) !== 'auto') {\n      if (getIndexedStyle(node, 'background-height', 'units', index) === '%') {\n        h = getIndexedStyle(node, 'background-height', 'pfValue', index) * nodeTH;\n      } else {\n        h = getIndexedStyle(node, 'background-height', 'pfValue', index);\n      }\n    }\n\n    if (w === 0 || h === 0) {\n      return; // no point in drawing empty image (and chrome is broken in this case)\n    }\n\n    if (fit === 'contain') {\n      var scale = Math.min(nodeTW / w, nodeTH / h);\n      w *= scale;\n      h *= scale;\n    } else if (fit === 'cover') {\n      var scale = Math.max(nodeTW / w, nodeTH / h);\n      w *= scale;\n      h *= scale;\n    }\n\n    var x = nodeX - nodeTW / 2; // left\n\n    var posXUnits = getIndexedStyle(node, 'background-position-x', 'units', index);\n    var posXPfVal = getIndexedStyle(node, 'background-position-x', 'pfValue', index);\n\n    if (posXUnits === '%') {\n      x += (nodeTW - w) * posXPfVal;\n    } else {\n      x += posXPfVal;\n    }\n\n    var offXUnits = getIndexedStyle(node, 'background-offset-x', 'units', index);\n    var offXPfVal = getIndexedStyle(node, 'background-offset-x', 'pfValue', index);\n\n    if (offXUnits === '%') {\n      x += (nodeTW - w) * offXPfVal;\n    } else {\n      x += offXPfVal;\n    }\n\n    var y = nodeY - nodeTH / 2; // top\n\n    var posYUnits = getIndexedStyle(node, 'background-position-y', 'units', index);\n    var posYPfVal = getIndexedStyle(node, 'background-position-y', 'pfValue', index);\n\n    if (posYUnits === '%') {\n      y += (nodeTH - h) * posYPfVal;\n    } else {\n      y += posYPfVal;\n    }\n\n    var offYUnits = getIndexedStyle(node, 'background-offset-y', 'units', index);\n    var offYPfVal = getIndexedStyle(node, 'background-offset-y', 'pfValue', index);\n\n    if (offYUnits === '%') {\n      y += (nodeTH - h) * offYPfVal;\n    } else {\n      y += offYPfVal;\n    }\n\n    if (rs.pathCache) {\n      x -= nodeX;\n      y -= nodeY;\n      nodeX = 0;\n      nodeY = 0;\n    }\n\n    var gAlpha = context.globalAlpha;\n    context.globalAlpha = imgOpacity;\n    var smoothingEnabled = r.getImgSmoothing(context);\n    var isSmoothingSwitched = false;\n\n    if (smooth === 'no' && smoothingEnabled) {\n      r.setImgSmoothing(context, false);\n      isSmoothingSwitched = true;\n    } else if (smooth === 'yes' && !smoothingEnabled) {\n      r.setImgSmoothing(context, true);\n      isSmoothingSwitched = true;\n    }\n\n    if (repeat === 'no-repeat') {\n      if (shouldClip) {\n        context.save();\n\n        if (rs.pathCache) {\n          context.clip(rs.pathCache);\n        } else {\n          r.nodeShapes[r.getNodeShape(node)].draw(context, nodeX, nodeY, nodeTW, nodeTH);\n          context.clip();\n        }\n      }\n\n      r.safeDrawImage(context, img, 0, 0, imgW, imgH, x, y, w, h);\n\n      if (shouldClip) {\n        context.restore();\n      }\n    } else {\n      var pattern = context.createPattern(img, repeat);\n      context.fillStyle = pattern;\n      r.nodeShapes[r.getNodeShape(node)].draw(context, nodeX, nodeY, nodeTW, nodeTH);\n      context.translate(x, y);\n      context.fill();\n      context.translate(-x, -y);\n    }\n\n    context.globalAlpha = gAlpha;\n\n    if (isSmoothingSwitched) {\n      r.setImgSmoothing(context, smoothingEnabled);\n    }\n  };\n\n  var CRp$6 = {};\n\n  CRp$6.eleTextBiggerThanMin = function (ele, scale) {\n    if (!scale) {\n      var zoom = ele.cy().zoom();\n      var pxRatio = this.getPixelRatio();\n      var lvl = Math.ceil(log2(zoom * pxRatio)); // the effective texture level\n\n      scale = Math.pow(2, lvl);\n    }\n\n    var computedSize = ele.pstyle('font-size').pfValue * scale;\n    var minSize = ele.pstyle('min-zoomed-font-size').pfValue;\n\n    if (computedSize < minSize) {\n      return false;\n    }\n\n    return true;\n  };\n\n  CRp$6.drawElementText = function (context, ele, shiftToOriginWithBb, force, prefix) {\n    var useEleOpacity = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n    var r = this;\n\n    if (force == null) {\n      if (useEleOpacity && !r.eleTextBiggerThanMin(ele)) {\n        return;\n      }\n    } else if (force === false) {\n      return;\n    }\n\n    if (ele.isNode()) {\n      var label = ele.pstyle('label');\n\n      if (!label || !label.value) {\n        return;\n      }\n\n      var justification = r.getLabelJustification(ele);\n      context.textAlign = justification;\n      context.textBaseline = 'bottom';\n    } else {\n      var badLine = ele.element()._private.rscratch.badLine;\n\n      var _label = ele.pstyle('label');\n\n      var srcLabel = ele.pstyle('source-label');\n      var tgtLabel = ele.pstyle('target-label');\n\n      if (badLine || (!_label || !_label.value) && (!srcLabel || !srcLabel.value) && (!tgtLabel || !tgtLabel.value)) {\n        return;\n      }\n\n      context.textAlign = 'center';\n      context.textBaseline = 'bottom';\n    }\n\n    var applyRotation = !shiftToOriginWithBb;\n    var bb;\n\n    if (shiftToOriginWithBb) {\n      bb = shiftToOriginWithBb;\n      context.translate(-bb.x1, -bb.y1);\n    }\n\n    if (prefix == null) {\n      r.drawText(context, ele, null, applyRotation, useEleOpacity);\n\n      if (ele.isEdge()) {\n        r.drawText(context, ele, 'source', applyRotation, useEleOpacity);\n        r.drawText(context, ele, 'target', applyRotation, useEleOpacity);\n      }\n    } else {\n      r.drawText(context, ele, prefix, applyRotation, useEleOpacity);\n    }\n\n    if (shiftToOriginWithBb) {\n      context.translate(bb.x1, bb.y1);\n    }\n  };\n\n  CRp$6.getFontCache = function (context) {\n    var cache;\n    this.fontCaches = this.fontCaches || [];\n\n    for (var i = 0; i < this.fontCaches.length; i++) {\n      cache = this.fontCaches[i];\n\n      if (cache.context === context) {\n        return cache;\n      }\n    }\n\n    cache = {\n      context: context\n    };\n    this.fontCaches.push(cache);\n    return cache;\n  }; // set up canvas context with font\n  // returns transformed text string\n\n\n  CRp$6.setupTextStyle = function (context, ele) {\n    var useEleOpacity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    // Font style\n    var labelStyle = ele.pstyle('font-style').strValue;\n    var labelSize = ele.pstyle('font-size').pfValue + 'px';\n    var labelFamily = ele.pstyle('font-family').strValue;\n    var labelWeight = ele.pstyle('font-weight').strValue;\n    var opacity = useEleOpacity ? ele.effectiveOpacity() * ele.pstyle('text-opacity').value : 1;\n    var outlineOpacity = ele.pstyle('text-outline-opacity').value * opacity;\n    var color = ele.pstyle('color').value;\n    var outlineColor = ele.pstyle('text-outline-color').value;\n    context.font = labelStyle + ' ' + labelWeight + ' ' + labelSize + ' ' + labelFamily;\n    context.lineJoin = 'round'; // so text outlines aren't jagged\n\n    this.colorFillStyle(context, color[0], color[1], color[2], opacity);\n    this.colorStrokeStyle(context, outlineColor[0], outlineColor[1], outlineColor[2], outlineOpacity);\n  }; // TODO ensure re-used\n\n\n  function roundRect(ctx, x, y, width, height) {\n    var radius = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 5;\n    ctx.beginPath();\n    ctx.moveTo(x + radius, y);\n    ctx.lineTo(x + width - radius, y);\n    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);\n    ctx.lineTo(x + width, y + height - radius);\n    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n    ctx.lineTo(x + radius, y + height);\n    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);\n    ctx.lineTo(x, y + radius);\n    ctx.quadraticCurveTo(x, y, x + radius, y);\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  CRp$6.getTextAngle = function (ele, prefix) {\n    var theta;\n    var _p = ele._private;\n    var rscratch = _p.rscratch;\n    var pdash = prefix ? prefix + '-' : '';\n    var rotation = ele.pstyle(pdash + 'text-rotation');\n    var textAngle = getPrefixedProperty(rscratch, 'labelAngle', prefix);\n\n    if (rotation.strValue === 'autorotate') {\n      theta = ele.isEdge() ? textAngle : 0;\n    } else if (rotation.strValue === 'none') {\n      theta = 0;\n    } else {\n      theta = rotation.pfValue;\n    }\n\n    return theta;\n  };\n\n  CRp$6.drawText = function (context, ele, prefix) {\n    var applyRotation = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    var useEleOpacity = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    var _p = ele._private;\n    var rscratch = _p.rscratch;\n    var parentOpacity = useEleOpacity ? ele.effectiveOpacity() : 1;\n\n    if (useEleOpacity && (parentOpacity === 0 || ele.pstyle('text-opacity').value === 0)) {\n      return;\n    } // use 'main' as an alias for the main label (i.e. null prefix)\n\n\n    if (prefix === 'main') {\n      prefix = null;\n    }\n\n    var textX = getPrefixedProperty(rscratch, 'labelX', prefix);\n    var textY = getPrefixedProperty(rscratch, 'labelY', prefix);\n    var orgTextX, orgTextY; // used for rotation\n\n    var text = this.getLabelText(ele, prefix);\n\n    if (text != null && text !== '' && !isNaN(textX) && !isNaN(textY)) {\n      this.setupTextStyle(context, ele, useEleOpacity);\n      var pdash = prefix ? prefix + '-' : '';\n      var textW = getPrefixedProperty(rscratch, 'labelWidth', prefix);\n      var textH = getPrefixedProperty(rscratch, 'labelHeight', prefix);\n      var marginX = ele.pstyle(pdash + 'text-margin-x').pfValue;\n      var marginY = ele.pstyle(pdash + 'text-margin-y').pfValue;\n      var isEdge = ele.isEdge();\n      var halign = ele.pstyle('text-halign').value;\n      var valign = ele.pstyle('text-valign').value;\n\n      if (isEdge) {\n        halign = 'center';\n        valign = 'center';\n      }\n\n      textX += marginX;\n      textY += marginY;\n      var theta;\n\n      if (!applyRotation) {\n        theta = 0;\n      } else {\n        theta = this.getTextAngle(ele, prefix);\n      }\n\n      if (theta !== 0) {\n        orgTextX = textX;\n        orgTextY = textY;\n        context.translate(orgTextX, orgTextY);\n        context.rotate(theta);\n        textX = 0;\n        textY = 0;\n      }\n\n      switch (valign) {\n        case 'top':\n          break;\n\n        case 'center':\n          textY += textH / 2;\n          break;\n\n        case 'bottom':\n          textY += textH;\n          break;\n      }\n\n      var backgroundOpacity = ele.pstyle('text-background-opacity').value;\n      var borderOpacity = ele.pstyle('text-border-opacity').value;\n      var textBorderWidth = ele.pstyle('text-border-width').pfValue;\n      var backgroundPadding = ele.pstyle('text-background-padding').pfValue;\n\n      if (backgroundOpacity > 0 || textBorderWidth > 0 && borderOpacity > 0) {\n        var bgX = textX - backgroundPadding;\n\n        switch (halign) {\n          case 'left':\n            bgX -= textW;\n            break;\n\n          case 'center':\n            bgX -= textW / 2;\n            break;\n        }\n\n        var bgY = textY - textH - backgroundPadding;\n        var bgW = textW + 2 * backgroundPadding;\n        var bgH = textH + 2 * backgroundPadding;\n\n        if (backgroundOpacity > 0) {\n          var textFill = context.fillStyle;\n          var textBackgroundColor = ele.pstyle('text-background-color').value;\n          context.fillStyle = 'rgba(' + textBackgroundColor[0] + ',' + textBackgroundColor[1] + ',' + textBackgroundColor[2] + ',' + backgroundOpacity * parentOpacity + ')';\n          var styleShape = ele.pstyle('text-background-shape').strValue;\n\n          if (styleShape.indexOf('round') === 0) {\n            roundRect(context, bgX, bgY, bgW, bgH, 2);\n          } else {\n            context.fillRect(bgX, bgY, bgW, bgH);\n          }\n\n          context.fillStyle = textFill;\n        }\n\n        if (textBorderWidth > 0 && borderOpacity > 0) {\n          var textStroke = context.strokeStyle;\n          var textLineWidth = context.lineWidth;\n          var textBorderColor = ele.pstyle('text-border-color').value;\n          var textBorderStyle = ele.pstyle('text-border-style').value;\n          context.strokeStyle = 'rgba(' + textBorderColor[0] + ',' + textBorderColor[1] + ',' + textBorderColor[2] + ',' + borderOpacity * parentOpacity + ')';\n          context.lineWidth = textBorderWidth;\n\n          if (context.setLineDash) {\n            // for very outofdate browsers\n            switch (textBorderStyle) {\n              case 'dotted':\n                context.setLineDash([1, 1]);\n                break;\n\n              case 'dashed':\n                context.setLineDash([4, 2]);\n                break;\n\n              case 'double':\n                context.lineWidth = textBorderWidth / 4; // 50% reserved for white between the two borders\n\n                context.setLineDash([]);\n                break;\n\n              case 'solid':\n                context.setLineDash([]);\n                break;\n            }\n          }\n\n          context.strokeRect(bgX, bgY, bgW, bgH);\n\n          if (textBorderStyle === 'double') {\n            var whiteWidth = textBorderWidth / 2;\n            context.strokeRect(bgX + whiteWidth, bgY + whiteWidth, bgW - whiteWidth * 2, bgH - whiteWidth * 2);\n          }\n\n          if (context.setLineDash) {\n            // for very outofdate browsers\n            context.setLineDash([]);\n          }\n\n          context.lineWidth = textLineWidth;\n          context.strokeStyle = textStroke;\n        }\n      }\n\n      var lineWidth = 2 * ele.pstyle('text-outline-width').pfValue; // *2 b/c the stroke is drawn centred on the middle\n\n      if (lineWidth > 0) {\n        context.lineWidth = lineWidth;\n      }\n\n      if (ele.pstyle('text-wrap').value === 'wrap') {\n        var lines = getPrefixedProperty(rscratch, 'labelWrapCachedLines', prefix);\n        var lineHeight = getPrefixedProperty(rscratch, 'labelLineHeight', prefix);\n        var halfTextW = textW / 2;\n        var justification = this.getLabelJustification(ele);\n\n        if (justification === 'auto') ; else if (halign === 'left') {\n          // auto justification : right\n          if (justification === 'left') {\n            textX += -textW;\n          } else if (justification === 'center') {\n            textX += -halfTextW;\n          } // else same as auto\n\n        } else if (halign === 'center') {\n          // auto justfication : center\n          if (justification === 'left') {\n            textX += -halfTextW;\n          } else if (justification === 'right') {\n            textX += halfTextW;\n          } // else same as auto\n\n        } else if (halign === 'right') {\n          // auto justification : left\n          if (justification === 'center') {\n            textX += halfTextW;\n          } else if (justification === 'right') {\n            textX += textW;\n          } // else same as auto\n\n        }\n\n        switch (valign) {\n          case 'top':\n            textY -= (lines.length - 1) * lineHeight;\n            break;\n\n          case 'center':\n          case 'bottom':\n            textY -= (lines.length - 1) * lineHeight;\n            break;\n        }\n\n        for (var l = 0; l < lines.length; l++) {\n          if (lineWidth > 0) {\n            context.strokeText(lines[l], textX, textY);\n          }\n\n          context.fillText(lines[l], textX, textY);\n          textY += lineHeight;\n        }\n      } else {\n        if (lineWidth > 0) {\n          context.strokeText(text, textX, textY);\n        }\n\n        context.fillText(text, textX, textY);\n      }\n\n      if (theta !== 0) {\n        context.rotate(-theta);\n        context.translate(-orgTextX, -orgTextY);\n      }\n    }\n  };\n\n  /* global Path2D */\n  var CRp$5 = {};\n\n  CRp$5.drawNode = function (context, node, shiftToOriginWithBb) {\n    var drawLabel = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    var shouldDrawOverlay = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    var shouldDrawOpacity = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n    var r = this;\n    var nodeWidth, nodeHeight;\n    var _p = node._private;\n    var rs = _p.rscratch;\n    var pos = node.position();\n\n    if (!number$1(pos.x) || !number$1(pos.y)) {\n      return; // can't draw node with undefined position\n    }\n\n    if (shouldDrawOpacity && !node.visible()) {\n      return;\n    }\n\n    var eleOpacity = shouldDrawOpacity ? node.effectiveOpacity() : 1;\n    var usePaths = r.usePaths();\n    var path;\n    var pathCacheHit = false;\n    var padding = node.padding();\n    nodeWidth = node.width() + 2 * padding;\n    nodeHeight = node.height() + 2 * padding; //\n    // setup shift\n\n    var bb;\n\n    if (shiftToOriginWithBb) {\n      bb = shiftToOriginWithBb;\n      context.translate(-bb.x1, -bb.y1);\n    } //\n    // load bg image\n\n\n    var bgImgProp = node.pstyle('background-image');\n    var urls = bgImgProp.value;\n    var urlDefined = new Array(urls.length);\n    var image = new Array(urls.length);\n    var numImages = 0;\n\n    for (var i = 0; i < urls.length; i++) {\n      var url = urls[i];\n      var defd = urlDefined[i] = url != null && url !== 'none';\n\n      if (defd) {\n        var bgImgCrossOrigin = node.cy().style().getIndexedStyle(node, 'background-image-crossorigin', 'value', i);\n        numImages++; // get image, and if not loaded then ask to redraw when later loaded\n\n        image[i] = r.getCachedImage(url, bgImgCrossOrigin, function () {\n          _p.backgroundTimestamp = Date.now();\n          node.emitAndNotify('background');\n        });\n      }\n    } //\n    // setup styles\n\n\n    var darkness = node.pstyle('background-blacken').value;\n    var borderWidth = node.pstyle('border-width').pfValue;\n    var bgOpacity = node.pstyle('background-opacity').value * eleOpacity;\n    var borderColor = node.pstyle('border-color').value;\n    var borderStyle = node.pstyle('border-style').value;\n    var borderOpacity = node.pstyle('border-opacity').value * eleOpacity;\n    context.lineJoin = 'miter'; // so borders are square with the node shape\n\n    var setupShapeColor = function setupShapeColor() {\n      var bgOpy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : bgOpacity;\n      r.eleFillStyle(context, node, bgOpy);\n    };\n\n    var setupBorderColor = function setupBorderColor() {\n      var bdrOpy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : borderOpacity;\n      r.colorStrokeStyle(context, borderColor[0], borderColor[1], borderColor[2], bdrOpy);\n    }; //\n    // setup shape\n\n\n    var styleShape = node.pstyle('shape').strValue;\n    var shapePts = node.pstyle('shape-polygon-points').pfValue;\n\n    if (usePaths) {\n      context.translate(pos.x, pos.y);\n      var pathCache = r.nodePathCache = r.nodePathCache || [];\n      var key = hashStrings(styleShape === 'polygon' ? styleShape + ',' + shapePts.join(',') : styleShape, '' + nodeHeight, '' + nodeWidth);\n      var cachedPath = pathCache[key];\n\n      if (cachedPath != null) {\n        path = cachedPath;\n        pathCacheHit = true;\n        rs.pathCache = path;\n      } else {\n        path = new Path2D();\n        pathCache[key] = rs.pathCache = path;\n      }\n    }\n\n    var drawShape = function drawShape() {\n      if (!pathCacheHit) {\n        var npos = pos;\n\n        if (usePaths) {\n          npos = {\n            x: 0,\n            y: 0\n          };\n        }\n\n        r.nodeShapes[r.getNodeShape(node)].draw(path || context, npos.x, npos.y, nodeWidth, nodeHeight);\n      }\n\n      if (usePaths) {\n        context.fill(path);\n      } else {\n        context.fill();\n      }\n    };\n\n    var drawImages = function drawImages() {\n      var nodeOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : eleOpacity;\n      var inside = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var prevBging = _p.backgrounding;\n      var totalCompleted = 0;\n\n      for (var _i = 0; _i < image.length; _i++) {\n        var bgContainment = node.cy().style().getIndexedStyle(node, 'background-image-containment', 'value', _i);\n\n        if (inside && bgContainment === 'over' || !inside && bgContainment === 'inside') {\n          totalCompleted++;\n          continue;\n        }\n\n        if (urlDefined[_i] && image[_i].complete && !image[_i].error) {\n          totalCompleted++;\n          r.drawInscribedImage(context, image[_i], node, _i, nodeOpacity);\n        }\n      }\n\n      _p.backgrounding = !(totalCompleted === numImages);\n\n      if (prevBging !== _p.backgrounding) {\n        // update style b/c :backgrounding state changed\n        node.updateStyle(false);\n      }\n    };\n\n    var drawPie = function drawPie() {\n      var redrawShape = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var pieOpacity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : eleOpacity;\n\n      if (r.hasPie(node)) {\n        r.drawPie(context, node, pieOpacity); // redraw/restore path if steps after pie need it\n\n        if (redrawShape) {\n          if (!usePaths) {\n            r.nodeShapes[r.getNodeShape(node)].draw(context, pos.x, pos.y, nodeWidth, nodeHeight);\n          }\n        }\n      }\n    };\n\n    var darken = function darken() {\n      var darkenOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : eleOpacity;\n      var opacity = (darkness > 0 ? darkness : -darkness) * darkenOpacity;\n      var c = darkness > 0 ? 0 : 255;\n\n      if (darkness !== 0) {\n        r.colorFillStyle(context, c, c, c, opacity);\n\n        if (usePaths) {\n          context.fill(path);\n        } else {\n          context.fill();\n        }\n      }\n    };\n\n    var drawBorder = function drawBorder() {\n      if (borderWidth > 0) {\n        context.lineWidth = borderWidth;\n        context.lineCap = 'butt';\n\n        if (context.setLineDash) {\n          // for very outofdate browsers\n          switch (borderStyle) {\n            case 'dotted':\n              context.setLineDash([1, 1]);\n              break;\n\n            case 'dashed':\n              context.setLineDash([4, 2]);\n              break;\n\n            case 'solid':\n            case 'double':\n              context.setLineDash([]);\n              break;\n          }\n        }\n\n        if (usePaths) {\n          context.stroke(path);\n        } else {\n          context.stroke();\n        }\n\n        if (borderStyle === 'double') {\n          context.lineWidth = borderWidth / 3;\n          var gco = context.globalCompositeOperation;\n          context.globalCompositeOperation = 'destination-out';\n\n          if (usePaths) {\n            context.stroke(path);\n          } else {\n            context.stroke();\n          }\n\n          context.globalCompositeOperation = gco;\n        } // reset in case we changed the border style\n\n\n        if (context.setLineDash) {\n          // for very outofdate browsers\n          context.setLineDash([]);\n        }\n      }\n    };\n\n    var drawOverlay = function drawOverlay() {\n      if (shouldDrawOverlay) {\n        r.drawNodeOverlay(context, node, pos, nodeWidth, nodeHeight);\n      }\n    };\n\n    var drawUnderlay = function drawUnderlay() {\n      if (shouldDrawOverlay) {\n        r.drawNodeUnderlay(context, node, pos, nodeWidth, nodeHeight);\n      }\n    };\n\n    var drawText = function drawText() {\n      r.drawElementText(context, node, null, drawLabel);\n    };\n\n    var ghost = node.pstyle('ghost').value === 'yes';\n\n    if (ghost) {\n      var gx = node.pstyle('ghost-offset-x').pfValue;\n      var gy = node.pstyle('ghost-offset-y').pfValue;\n      var ghostOpacity = node.pstyle('ghost-opacity').value;\n      var effGhostOpacity = ghostOpacity * eleOpacity;\n      context.translate(gx, gy);\n      setupShapeColor(ghostOpacity * bgOpacity);\n      drawShape();\n      drawImages(effGhostOpacity, true);\n      setupBorderColor(ghostOpacity * borderOpacity);\n      drawBorder();\n      drawPie(darkness !== 0 || borderWidth !== 0);\n      drawImages(effGhostOpacity, false);\n      darken(effGhostOpacity);\n      context.translate(-gx, -gy);\n    }\n\n    if (usePaths) {\n      context.translate(-pos.x, -pos.y);\n    }\n\n    drawUnderlay();\n\n    if (usePaths) {\n      context.translate(pos.x, pos.y);\n    }\n\n    setupShapeColor();\n    drawShape();\n    drawImages(eleOpacity, true);\n    setupBorderColor();\n    drawBorder();\n    drawPie(darkness !== 0 || borderWidth !== 0);\n    drawImages(eleOpacity, false);\n    darken();\n\n    if (usePaths) {\n      context.translate(-pos.x, -pos.y);\n    }\n\n    drawText();\n    drawOverlay(); //\n    // clean up shift\n\n    if (shiftToOriginWithBb) {\n      context.translate(bb.x1, bb.y1);\n    }\n  };\n\n  var drawNodeOverlayUnderlay = function drawNodeOverlayUnderlay(overlayOrUnderlay) {\n    if (!['overlay', 'underlay'].includes(overlayOrUnderlay)) {\n      throw new Error('Invalid state');\n    }\n\n    return function (context, node, pos, nodeWidth, nodeHeight) {\n      var r = this;\n\n      if (!node.visible()) {\n        return;\n      }\n\n      var padding = node.pstyle(\"\".concat(overlayOrUnderlay, \"-padding\")).pfValue;\n      var opacity = node.pstyle(\"\".concat(overlayOrUnderlay, \"-opacity\")).value;\n      var color = node.pstyle(\"\".concat(overlayOrUnderlay, \"-color\")).value;\n      var shape = node.pstyle(\"\".concat(overlayOrUnderlay, \"-shape\")).value;\n\n      if (opacity > 0) {\n        pos = pos || node.position();\n\n        if (nodeWidth == null || nodeHeight == null) {\n          var _padding = node.padding();\n\n          nodeWidth = node.width() + 2 * _padding;\n          nodeHeight = node.height() + 2 * _padding;\n        }\n\n        r.colorFillStyle(context, color[0], color[1], color[2], opacity);\n        r.nodeShapes[shape].draw(context, pos.x, pos.y, nodeWidth + padding * 2, nodeHeight + padding * 2);\n        context.fill();\n      }\n    };\n  };\n\n  CRp$5.drawNodeOverlay = drawNodeOverlayUnderlay('overlay');\n  CRp$5.drawNodeUnderlay = drawNodeOverlayUnderlay('underlay'); // does the node have at least one pie piece?\n\n  CRp$5.hasPie = function (node) {\n    node = node[0]; // ensure ele ref\n\n    return node._private.hasPie;\n  };\n\n  CRp$5.drawPie = function (context, node, nodeOpacity, pos) {\n    node = node[0]; // ensure ele ref\n\n    pos = pos || node.position();\n    var cyStyle = node.cy().style();\n    var pieSize = node.pstyle('pie-size');\n    var x = pos.x;\n    var y = pos.y;\n    var nodeW = node.width();\n    var nodeH = node.height();\n    var radius = Math.min(nodeW, nodeH) / 2; // must fit in node\n\n    var lastPercent = 0; // what % to continue drawing pie slices from on [0, 1]\n\n    var usePaths = this.usePaths();\n\n    if (usePaths) {\n      x = 0;\n      y = 0;\n    }\n\n    if (pieSize.units === '%') {\n      radius = radius * pieSize.pfValue;\n    } else if (pieSize.pfValue !== undefined) {\n      radius = pieSize.pfValue / 2;\n    }\n\n    for (var i = 1; i <= cyStyle.pieBackgroundN; i++) {\n      // 1..N\n      var size = node.pstyle('pie-' + i + '-background-size').value;\n      var color = node.pstyle('pie-' + i + '-background-color').value;\n      var opacity = node.pstyle('pie-' + i + '-background-opacity').value * nodeOpacity;\n      var percent = size / 100; // map integer range [0, 100] to [0, 1]\n      // percent can't push beyond 1\n\n      if (percent + lastPercent > 1) {\n        percent = 1 - lastPercent;\n      }\n\n      var angleStart = 1.5 * Math.PI + 2 * Math.PI * lastPercent; // start at 12 o'clock and go clockwise\n\n      var angleDelta = 2 * Math.PI * percent;\n      var angleEnd = angleStart + angleDelta; // ignore if\n      // - zero size\n      // - we're already beyond the full circle\n      // - adding the current slice would go beyond the full circle\n\n      if (size === 0 || lastPercent >= 1 || lastPercent + percent > 1) {\n        continue;\n      }\n\n      context.beginPath();\n      context.moveTo(x, y);\n      context.arc(x, y, radius, angleStart, angleEnd);\n      context.closePath();\n      this.colorFillStyle(context, color[0], color[1], color[2], opacity);\n      context.fill();\n      lastPercent += percent;\n    }\n  };\n\n  var CRp$4 = {};\n  var motionBlurDelay = 100; // var isFirefox = typeof InstallTrigger !== 'undefined';\n\n  CRp$4.getPixelRatio = function () {\n    var context = this.data.contexts[0];\n\n    if (this.forcedPixelRatio != null) {\n      return this.forcedPixelRatio;\n    }\n\n    var backingStore = context.backingStorePixelRatio || context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;\n    return (window.devicePixelRatio || 1) / backingStore; // eslint-disable-line no-undef\n  };\n\n  CRp$4.paintCache = function (context) {\n    var caches = this.paintCaches = this.paintCaches || [];\n    var needToCreateCache = true;\n    var cache;\n\n    for (var i = 0; i < caches.length; i++) {\n      cache = caches[i];\n\n      if (cache.context === context) {\n        needToCreateCache = false;\n        break;\n      }\n    }\n\n    if (needToCreateCache) {\n      cache = {\n        context: context\n      };\n      caches.push(cache);\n    }\n\n    return cache;\n  };\n\n  CRp$4.createGradientStyleFor = function (context, shapeStyleName, ele, fill, opacity) {\n    var gradientStyle;\n    var usePaths = this.usePaths();\n    var colors = ele.pstyle(shapeStyleName + '-gradient-stop-colors').value,\n        positions = ele.pstyle(shapeStyleName + '-gradient-stop-positions').pfValue;\n\n    if (fill === 'radial-gradient') {\n      if (ele.isEdge()) {\n        var start = ele.sourceEndpoint(),\n            end = ele.targetEndpoint(),\n            mid = ele.midpoint();\n        var d1 = dist(start, mid);\n        var d2 = dist(end, mid);\n        gradientStyle = context.createRadialGradient(mid.x, mid.y, 0, mid.x, mid.y, Math.max(d1, d2));\n      } else {\n        var pos = usePaths ? {\n          x: 0,\n          y: 0\n        } : ele.position(),\n            width = ele.paddedWidth(),\n            height = ele.paddedHeight();\n        gradientStyle = context.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, Math.max(width, height));\n      }\n    } else {\n      if (ele.isEdge()) {\n        var _start = ele.sourceEndpoint(),\n            _end = ele.targetEndpoint();\n\n        gradientStyle = context.createLinearGradient(_start.x, _start.y, _end.x, _end.y);\n      } else {\n        var _pos = usePaths ? {\n          x: 0,\n          y: 0\n        } : ele.position(),\n            _width = ele.paddedWidth(),\n            _height = ele.paddedHeight(),\n            halfWidth = _width / 2,\n            halfHeight = _height / 2;\n\n        var direction = ele.pstyle('background-gradient-direction').value;\n\n        switch (direction) {\n          case 'to-bottom':\n            gradientStyle = context.createLinearGradient(_pos.x, _pos.y - halfHeight, _pos.x, _pos.y + halfHeight);\n            break;\n\n          case 'to-top':\n            gradientStyle = context.createLinearGradient(_pos.x, _pos.y + halfHeight, _pos.x, _pos.y - halfHeight);\n            break;\n\n          case 'to-left':\n            gradientStyle = context.createLinearGradient(_pos.x + halfWidth, _pos.y, _pos.x - halfWidth, _pos.y);\n            break;\n\n          case 'to-right':\n            gradientStyle = context.createLinearGradient(_pos.x - halfWidth, _pos.y, _pos.x + halfWidth, _pos.y);\n            break;\n\n          case 'to-bottom-right':\n          case 'to-right-bottom':\n            gradientStyle = context.createLinearGradient(_pos.x - halfWidth, _pos.y - halfHeight, _pos.x + halfWidth, _pos.y + halfHeight);\n            break;\n\n          case 'to-top-right':\n          case 'to-right-top':\n            gradientStyle = context.createLinearGradient(_pos.x - halfWidth, _pos.y + halfHeight, _pos.x + halfWidth, _pos.y - halfHeight);\n            break;\n\n          case 'to-bottom-left':\n          case 'to-left-bottom':\n            gradientStyle = context.createLinearGradient(_pos.x + halfWidth, _pos.y - halfHeight, _pos.x - halfWidth, _pos.y + halfHeight);\n            break;\n\n          case 'to-top-left':\n          case 'to-left-top':\n            gradientStyle = context.createLinearGradient(_pos.x + halfWidth, _pos.y + halfHeight, _pos.x - halfWidth, _pos.y - halfHeight);\n            break;\n        }\n      }\n    }\n\n    if (!gradientStyle) return null; // invalid gradient style\n\n    var hasPositions = positions.length === colors.length;\n    var length = colors.length;\n\n    for (var i = 0; i < length; i++) {\n      gradientStyle.addColorStop(hasPositions ? positions[i] : i / (length - 1), 'rgba(' + colors[i][0] + ',' + colors[i][1] + ',' + colors[i][2] + ',' + opacity + ')');\n    }\n\n    return gradientStyle;\n  };\n\n  CRp$4.gradientFillStyle = function (context, ele, fill, opacity) {\n    var gradientStyle = this.createGradientStyleFor(context, 'background', ele, fill, opacity);\n    if (!gradientStyle) return null; // error\n\n    context.fillStyle = gradientStyle;\n  };\n\n  CRp$4.colorFillStyle = function (context, r, g, b, a) {\n    context.fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')'; // turn off for now, seems context does its own caching\n    // var cache = this.paintCache(context);\n    // var fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n    // if( cache.fillStyle !== fillStyle ){\n    //   context.fillStyle = cache.fillStyle = fillStyle;\n    // }\n  };\n\n  CRp$4.eleFillStyle = function (context, ele, opacity) {\n    var backgroundFill = ele.pstyle('background-fill').value;\n\n    if (backgroundFill === 'linear-gradient' || backgroundFill === 'radial-gradient') {\n      this.gradientFillStyle(context, ele, backgroundFill, opacity);\n    } else {\n      var backgroundColor = ele.pstyle('background-color').value;\n      this.colorFillStyle(context, backgroundColor[0], backgroundColor[1], backgroundColor[2], opacity);\n    }\n  };\n\n  CRp$4.gradientStrokeStyle = function (context, ele, fill, opacity) {\n    var gradientStyle = this.createGradientStyleFor(context, 'line', ele, fill, opacity);\n    if (!gradientStyle) return null; // error\n\n    context.strokeStyle = gradientStyle;\n  };\n\n  CRp$4.colorStrokeStyle = function (context, r, g, b, a) {\n    context.strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')'; // turn off for now, seems context does its own caching\n    // var cache = this.paintCache(context);\n    // var strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n    // if( cache.strokeStyle !== strokeStyle ){\n    //   context.strokeStyle = cache.strokeStyle = strokeStyle;\n    // }\n  };\n\n  CRp$4.eleStrokeStyle = function (context, ele, opacity) {\n    var lineFill = ele.pstyle('line-fill').value;\n\n    if (lineFill === 'linear-gradient' || lineFill === 'radial-gradient') {\n      this.gradientStrokeStyle(context, ele, lineFill, opacity);\n    } else {\n      var lineColor = ele.pstyle('line-color').value;\n      this.colorStrokeStyle(context, lineColor[0], lineColor[1], lineColor[2], opacity);\n    }\n  }; // Resize canvas\n\n\n  CRp$4.matchCanvasSize = function (container) {\n    var r = this;\n    var data = r.data;\n    var bb = r.findContainerClientCoords();\n    var width = bb[2];\n    var height = bb[3];\n    var pixelRatio = r.getPixelRatio();\n    var mbPxRatio = r.motionBlurPxRatio;\n\n    if (container === r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_NODE] || container === r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_DRAG]) {\n      pixelRatio = mbPxRatio;\n    }\n\n    var canvasWidth = width * pixelRatio;\n    var canvasHeight = height * pixelRatio;\n    var canvas;\n\n    if (canvasWidth === r.canvasWidth && canvasHeight === r.canvasHeight) {\n      return; // save cycles if same\n    }\n\n    r.fontCaches = null; // resizing resets the style\n\n    var canvasContainer = data.canvasContainer;\n    canvasContainer.style.width = width + 'px';\n    canvasContainer.style.height = height + 'px';\n\n    for (var i = 0; i < r.CANVAS_LAYERS; i++) {\n      canvas = data.canvases[i];\n      canvas.width = canvasWidth;\n      canvas.height = canvasHeight;\n      canvas.style.width = width + 'px';\n      canvas.style.height = height + 'px';\n    }\n\n    for (var i = 0; i < r.BUFFER_COUNT; i++) {\n      canvas = data.bufferCanvases[i];\n      canvas.width = canvasWidth;\n      canvas.height = canvasHeight;\n      canvas.style.width = width + 'px';\n      canvas.style.height = height + 'px';\n    }\n\n    r.textureMult = 1;\n\n    if (pixelRatio <= 1) {\n      canvas = data.bufferCanvases[r.TEXTURE_BUFFER];\n      r.textureMult = 2;\n      canvas.width = canvasWidth * r.textureMult;\n      canvas.height = canvasHeight * r.textureMult;\n    }\n\n    r.canvasWidth = canvasWidth;\n    r.canvasHeight = canvasHeight;\n  };\n\n  CRp$4.renderTo = function (cxt, zoom, pan, pxRatio) {\n    this.render({\n      forcedContext: cxt,\n      forcedZoom: zoom,\n      forcedPan: pan,\n      drawAllLayers: true,\n      forcedPxRatio: pxRatio\n    });\n  };\n\n  CRp$4.render = function (options) {\n    options = options || staticEmptyObject();\n    var forcedContext = options.forcedContext;\n    var drawAllLayers = options.drawAllLayers;\n    var drawOnlyNodeLayer = options.drawOnlyNodeLayer;\n    var forcedZoom = options.forcedZoom;\n    var forcedPan = options.forcedPan;\n    var r = this;\n    var pixelRatio = options.forcedPxRatio === undefined ? this.getPixelRatio() : options.forcedPxRatio;\n    var cy = r.cy;\n    var data = r.data;\n    var needDraw = data.canvasNeedsRedraw;\n    var textureDraw = r.textureOnViewport && !forcedContext && (r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming);\n    var motionBlur = options.motionBlur !== undefined ? options.motionBlur : r.motionBlur;\n    var mbPxRatio = r.motionBlurPxRatio;\n    var hasCompoundNodes = cy.hasCompoundNodes();\n    var inNodeDragGesture = r.hoverData.draggingEles;\n    var inBoxSelection = r.hoverData.selecting || r.touchData.selecting ? true : false;\n    motionBlur = motionBlur && !forcedContext && r.motionBlurEnabled && !inBoxSelection;\n    var motionBlurFadeEffect = motionBlur;\n\n    if (!forcedContext) {\n      if (r.prevPxRatio !== pixelRatio) {\n        r.invalidateContainerClientCoordsCache();\n        r.matchCanvasSize(r.container);\n        r.redrawHint('eles', true);\n        r.redrawHint('drag', true);\n      }\n\n      r.prevPxRatio = pixelRatio;\n    }\n\n    if (!forcedContext && r.motionBlurTimeout) {\n      clearTimeout(r.motionBlurTimeout);\n    }\n\n    if (motionBlur) {\n      if (r.mbFrames == null) {\n        r.mbFrames = 0;\n      }\n\n      r.mbFrames++;\n\n      if (r.mbFrames < 3) {\n        // need several frames before even high quality motionblur\n        motionBlurFadeEffect = false;\n      } // go to lower quality blurry frames when several m/b frames have been rendered (avoids flashing)\n\n\n      if (r.mbFrames > r.minMbLowQualFrames) {\n        //r.fullQualityMb = false;\n        r.motionBlurPxRatio = r.mbPxRBlurry;\n      }\n    }\n\n    if (r.clearingMotionBlur) {\n      r.motionBlurPxRatio = 1;\n    } // b/c drawToContext() may be async w.r.t. redraw(), keep track of last texture frame\n    // because a rogue async texture frame would clear needDraw\n\n\n    if (r.textureDrawLastFrame && !textureDraw) {\n      needDraw[r.NODE] = true;\n      needDraw[r.SELECT_BOX] = true;\n    }\n\n    var style = cy.style();\n    var zoom = cy.zoom();\n    var effectiveZoom = forcedZoom !== undefined ? forcedZoom : zoom;\n    var pan = cy.pan();\n    var effectivePan = {\n      x: pan.x,\n      y: pan.y\n    };\n    var vp = {\n      zoom: zoom,\n      pan: {\n        x: pan.x,\n        y: pan.y\n      }\n    };\n    var prevVp = r.prevViewport;\n    var viewportIsDiff = prevVp === undefined || vp.zoom !== prevVp.zoom || vp.pan.x !== prevVp.pan.x || vp.pan.y !== prevVp.pan.y; // we want the low quality motionblur only when the viewport is being manipulated etc (where it's not noticed)\n\n    if (!viewportIsDiff && !(inNodeDragGesture && !hasCompoundNodes)) {\n      r.motionBlurPxRatio = 1;\n    }\n\n    if (forcedPan) {\n      effectivePan = forcedPan;\n    } // apply pixel ratio\n\n\n    effectiveZoom *= pixelRatio;\n    effectivePan.x *= pixelRatio;\n    effectivePan.y *= pixelRatio;\n    var eles = r.getCachedZSortedEles();\n\n    function mbclear(context, x, y, w, h) {\n      var gco = context.globalCompositeOperation;\n      context.globalCompositeOperation = 'destination-out';\n      r.colorFillStyle(context, 255, 255, 255, r.motionBlurTransparency);\n      context.fillRect(x, y, w, h);\n      context.globalCompositeOperation = gco;\n    }\n\n    function setContextTransform(context, clear) {\n      var ePan, eZoom, w, h;\n\n      if (!r.clearingMotionBlur && (context === data.bufferContexts[r.MOTIONBLUR_BUFFER_NODE] || context === data.bufferContexts[r.MOTIONBLUR_BUFFER_DRAG])) {\n        ePan = {\n          x: pan.x * mbPxRatio,\n          y: pan.y * mbPxRatio\n        };\n        eZoom = zoom * mbPxRatio;\n        w = r.canvasWidth * mbPxRatio;\n        h = r.canvasHeight * mbPxRatio;\n      } else {\n        ePan = effectivePan;\n        eZoom = effectiveZoom;\n        w = r.canvasWidth;\n        h = r.canvasHeight;\n      }\n\n      context.setTransform(1, 0, 0, 1, 0, 0);\n\n      if (clear === 'motionBlur') {\n        mbclear(context, 0, 0, w, h);\n      } else if (!forcedContext && (clear === undefined || clear)) {\n        context.clearRect(0, 0, w, h);\n      }\n\n      if (!drawAllLayers) {\n        context.translate(ePan.x, ePan.y);\n        context.scale(eZoom, eZoom);\n      }\n\n      if (forcedPan) {\n        context.translate(forcedPan.x, forcedPan.y);\n      }\n\n      if (forcedZoom) {\n        context.scale(forcedZoom, forcedZoom);\n      }\n    }\n\n    if (!textureDraw) {\n      r.textureDrawLastFrame = false;\n    }\n\n    if (textureDraw) {\n      r.textureDrawLastFrame = true;\n\n      if (!r.textureCache) {\n        r.textureCache = {};\n        r.textureCache.bb = cy.mutableElements().boundingBox();\n        r.textureCache.texture = r.data.bufferCanvases[r.TEXTURE_BUFFER];\n        var cxt = r.data.bufferContexts[r.TEXTURE_BUFFER];\n        cxt.setTransform(1, 0, 0, 1, 0, 0);\n        cxt.clearRect(0, 0, r.canvasWidth * r.textureMult, r.canvasHeight * r.textureMult);\n        r.render({\n          forcedContext: cxt,\n          drawOnlyNodeLayer: true,\n          forcedPxRatio: pixelRatio * r.textureMult\n        });\n        var vp = r.textureCache.viewport = {\n          zoom: cy.zoom(),\n          pan: cy.pan(),\n          width: r.canvasWidth,\n          height: r.canvasHeight\n        };\n        vp.mpan = {\n          x: (0 - vp.pan.x) / vp.zoom,\n          y: (0 - vp.pan.y) / vp.zoom\n        };\n      }\n\n      needDraw[r.DRAG] = false;\n      needDraw[r.NODE] = false;\n      var context = data.contexts[r.NODE];\n      var texture = r.textureCache.texture;\n      var vp = r.textureCache.viewport;\n      context.setTransform(1, 0, 0, 1, 0, 0);\n\n      if (motionBlur) {\n        mbclear(context, 0, 0, vp.width, vp.height);\n      } else {\n        context.clearRect(0, 0, vp.width, vp.height);\n      }\n\n      var outsideBgColor = style.core('outside-texture-bg-color').value;\n      var outsideBgOpacity = style.core('outside-texture-bg-opacity').value;\n      r.colorFillStyle(context, outsideBgColor[0], outsideBgColor[1], outsideBgColor[2], outsideBgOpacity);\n      context.fillRect(0, 0, vp.width, vp.height);\n      var zoom = cy.zoom();\n      setContextTransform(context, false);\n      context.clearRect(vp.mpan.x, vp.mpan.y, vp.width / vp.zoom / pixelRatio, vp.height / vp.zoom / pixelRatio);\n      context.drawImage(texture, vp.mpan.x, vp.mpan.y, vp.width / vp.zoom / pixelRatio, vp.height / vp.zoom / pixelRatio);\n    } else if (r.textureOnViewport && !forcedContext) {\n      // clear the cache since we don't need it\n      r.textureCache = null;\n    }\n\n    var extent = cy.extent();\n    var vpManip = r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming || r.hoverData.draggingEles || r.cy.animated();\n    var hideEdges = r.hideEdgesOnViewport && vpManip;\n    var needMbClear = [];\n    needMbClear[r.NODE] = !needDraw[r.NODE] && motionBlur && !r.clearedForMotionBlur[r.NODE] || r.clearingMotionBlur;\n\n    if (needMbClear[r.NODE]) {\n      r.clearedForMotionBlur[r.NODE] = true;\n    }\n\n    needMbClear[r.DRAG] = !needDraw[r.DRAG] && motionBlur && !r.clearedForMotionBlur[r.DRAG] || r.clearingMotionBlur;\n\n    if (needMbClear[r.DRAG]) {\n      r.clearedForMotionBlur[r.DRAG] = true;\n    }\n\n    if (needDraw[r.NODE] || drawAllLayers || drawOnlyNodeLayer || needMbClear[r.NODE]) {\n      var useBuffer = motionBlur && !needMbClear[r.NODE] && mbPxRatio !== 1;\n      var context = forcedContext || (useBuffer ? r.data.bufferContexts[r.MOTIONBLUR_BUFFER_NODE] : data.contexts[r.NODE]);\n      var clear = motionBlur && !useBuffer ? 'motionBlur' : undefined;\n      setContextTransform(context, clear);\n\n      if (hideEdges) {\n        r.drawCachedNodes(context, eles.nondrag, pixelRatio, extent);\n      } else {\n        r.drawLayeredElements(context, eles.nondrag, pixelRatio, extent);\n      }\n\n      if (r.debug) {\n        r.drawDebugPoints(context, eles.nondrag);\n      }\n\n      if (!drawAllLayers && !motionBlur) {\n        needDraw[r.NODE] = false;\n      }\n    }\n\n    if (!drawOnlyNodeLayer && (needDraw[r.DRAG] || drawAllLayers || needMbClear[r.DRAG])) {\n      var useBuffer = motionBlur && !needMbClear[r.DRAG] && mbPxRatio !== 1;\n      var context = forcedContext || (useBuffer ? r.data.bufferContexts[r.MOTIONBLUR_BUFFER_DRAG] : data.contexts[r.DRAG]);\n      setContextTransform(context, motionBlur && !useBuffer ? 'motionBlur' : undefined);\n\n      if (hideEdges) {\n        r.drawCachedNodes(context, eles.drag, pixelRatio, extent);\n      } else {\n        r.drawCachedElements(context, eles.drag, pixelRatio, extent);\n      }\n\n      if (r.debug) {\n        r.drawDebugPoints(context, eles.drag);\n      }\n\n      if (!drawAllLayers && !motionBlur) {\n        needDraw[r.DRAG] = false;\n      }\n    }\n\n    if (r.showFps || !drawOnlyNodeLayer && needDraw[r.SELECT_BOX] && !drawAllLayers) {\n      var context = forcedContext || data.contexts[r.SELECT_BOX];\n      setContextTransform(context);\n\n      if (r.selection[4] == 1 && (r.hoverData.selecting || r.touchData.selecting)) {\n        var zoom = r.cy.zoom();\n        var borderWidth = style.core('selection-box-border-width').value / zoom;\n        context.lineWidth = borderWidth;\n        context.fillStyle = 'rgba(' + style.core('selection-box-color').value[0] + ',' + style.core('selection-box-color').value[1] + ',' + style.core('selection-box-color').value[2] + ',' + style.core('selection-box-opacity').value + ')';\n        context.fillRect(r.selection[0], r.selection[1], r.selection[2] - r.selection[0], r.selection[3] - r.selection[1]);\n\n        if (borderWidth > 0) {\n          context.strokeStyle = 'rgba(' + style.core('selection-box-border-color').value[0] + ',' + style.core('selection-box-border-color').value[1] + ',' + style.core('selection-box-border-color').value[2] + ',' + style.core('selection-box-opacity').value + ')';\n          context.strokeRect(r.selection[0], r.selection[1], r.selection[2] - r.selection[0], r.selection[3] - r.selection[1]);\n        }\n      }\n\n      if (data.bgActivePosistion && !r.hoverData.selecting) {\n        var zoom = r.cy.zoom();\n        var pos = data.bgActivePosistion;\n        context.fillStyle = 'rgba(' + style.core('active-bg-color').value[0] + ',' + style.core('active-bg-color').value[1] + ',' + style.core('active-bg-color').value[2] + ',' + style.core('active-bg-opacity').value + ')';\n        context.beginPath();\n        context.arc(pos.x, pos.y, style.core('active-bg-size').pfValue / zoom, 0, 2 * Math.PI);\n        context.fill();\n      }\n\n      var timeToRender = r.lastRedrawTime;\n\n      if (r.showFps && timeToRender) {\n        timeToRender = Math.round(timeToRender);\n        var fps = Math.round(1000 / timeToRender);\n        context.setTransform(1, 0, 0, 1, 0, 0);\n        context.fillStyle = 'rgba(255, 0, 0, 0.75)';\n        context.strokeStyle = 'rgba(255, 0, 0, 0.75)';\n        context.lineWidth = 1;\n        context.fillText('1 frame = ' + timeToRender + ' ms = ' + fps + ' fps', 0, 20);\n        var maxFps = 60;\n        context.strokeRect(0, 30, 250, 20);\n        context.fillRect(0, 30, 250 * Math.min(fps / maxFps, 1), 20);\n      }\n\n      if (!drawAllLayers) {\n        needDraw[r.SELECT_BOX] = false;\n      }\n    } // motionblur: blit rendered blurry frames\n\n\n    if (motionBlur && mbPxRatio !== 1) {\n      var cxtNode = data.contexts[r.NODE];\n      var txtNode = r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_NODE];\n      var cxtDrag = data.contexts[r.DRAG];\n      var txtDrag = r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_DRAG];\n\n      var drawMotionBlur = function drawMotionBlur(cxt, txt, needClear) {\n        cxt.setTransform(1, 0, 0, 1, 0, 0);\n\n        if (needClear || !motionBlurFadeEffect) {\n          cxt.clearRect(0, 0, r.canvasWidth, r.canvasHeight);\n        } else {\n          mbclear(cxt, 0, 0, r.canvasWidth, r.canvasHeight);\n        }\n\n        var pxr = mbPxRatio;\n        cxt.drawImage(txt, // img\n        0, 0, // sx, sy\n        r.canvasWidth * pxr, r.canvasHeight * pxr, // sw, sh\n        0, 0, // x, y\n        r.canvasWidth, r.canvasHeight // w, h\n        );\n      };\n\n      if (needDraw[r.NODE] || needMbClear[r.NODE]) {\n        drawMotionBlur(cxtNode, txtNode, needMbClear[r.NODE]);\n        needDraw[r.NODE] = false;\n      }\n\n      if (needDraw[r.DRAG] || needMbClear[r.DRAG]) {\n        drawMotionBlur(cxtDrag, txtDrag, needMbClear[r.DRAG]);\n        needDraw[r.DRAG] = false;\n      }\n    }\n\n    r.prevViewport = vp;\n\n    if (r.clearingMotionBlur) {\n      r.clearingMotionBlur = false;\n      r.motionBlurCleared = true;\n      r.motionBlur = true;\n    }\n\n    if (motionBlur) {\n      r.motionBlurTimeout = setTimeout(function () {\n        r.motionBlurTimeout = null;\n        r.clearedForMotionBlur[r.NODE] = false;\n        r.clearedForMotionBlur[r.DRAG] = false;\n        r.motionBlur = false;\n        r.clearingMotionBlur = !textureDraw;\n        r.mbFrames = 0;\n        needDraw[r.NODE] = true;\n        needDraw[r.DRAG] = true;\n        r.redraw();\n      }, motionBlurDelay);\n    }\n\n    if (!forcedContext) {\n      cy.emit('render');\n    }\n  };\n\n  var CRp$3 = {}; // @O Polygon drawing\n\n  CRp$3.drawPolygonPath = function (context, x, y, width, height, points) {\n    var halfW = width / 2;\n    var halfH = height / 2;\n\n    if (context.beginPath) {\n      context.beginPath();\n    }\n\n    context.moveTo(x + halfW * points[0], y + halfH * points[1]);\n\n    for (var i = 1; i < points.length / 2; i++) {\n      context.lineTo(x + halfW * points[i * 2], y + halfH * points[i * 2 + 1]);\n    }\n\n    context.closePath();\n  };\n\n  CRp$3.drawRoundPolygonPath = function (context, x, y, width, height, points) {\n    var halfW = width / 2;\n    var halfH = height / 2;\n    var cornerRadius = getRoundPolygonRadius(width, height);\n\n    if (context.beginPath) {\n      context.beginPath();\n    }\n\n    for (var _i = 0; _i < points.length / 4; _i++) {\n      var sourceUv = void 0,\n          destUv = void 0;\n\n      if (_i === 0) {\n        sourceUv = points.length - 2;\n      } else {\n        sourceUv = _i * 4 - 2;\n      }\n\n      destUv = _i * 4 + 2;\n      var px = x + halfW * points[_i * 4];\n      var py = y + halfH * points[_i * 4 + 1];\n      var cosTheta = -points[sourceUv] * points[destUv] - points[sourceUv + 1] * points[destUv + 1];\n      var offset = cornerRadius / Math.tan(Math.acos(cosTheta) / 2);\n      var cp0x = px - offset * points[sourceUv];\n      var cp0y = py - offset * points[sourceUv + 1];\n      var cp1x = px + offset * points[destUv];\n      var cp1y = py + offset * points[destUv + 1];\n\n      if (_i === 0) {\n        context.moveTo(cp0x, cp0y);\n      } else {\n        context.lineTo(cp0x, cp0y);\n      }\n\n      context.arcTo(px, py, cp1x, cp1y, cornerRadius);\n    }\n\n    context.closePath();\n  }; // Round rectangle drawing\n\n\n  CRp$3.drawRoundRectanglePath = function (context, x, y, width, height) {\n    var halfWidth = width / 2;\n    var halfHeight = height / 2;\n    var cornerRadius = getRoundRectangleRadius(width, height);\n\n    if (context.beginPath) {\n      context.beginPath();\n    } // Start at top middle\n\n\n    context.moveTo(x, y - halfHeight); // Arc from middle top to right side\n\n    context.arcTo(x + halfWidth, y - halfHeight, x + halfWidth, y, cornerRadius); // Arc from right side to bottom\n\n    context.arcTo(x + halfWidth, y + halfHeight, x, y + halfHeight, cornerRadius); // Arc from bottom to left side\n\n    context.arcTo(x - halfWidth, y + halfHeight, x - halfWidth, y, cornerRadius); // Arc from left side to topBorder\n\n    context.arcTo(x - halfWidth, y - halfHeight, x, y - halfHeight, cornerRadius); // Join line\n\n    context.lineTo(x, y - halfHeight);\n    context.closePath();\n  };\n\n  CRp$3.drawBottomRoundRectanglePath = function (context, x, y, width, height) {\n    var halfWidth = width / 2;\n    var halfHeight = height / 2;\n    var cornerRadius = getRoundRectangleRadius(width, height);\n\n    if (context.beginPath) {\n      context.beginPath();\n    } // Start at top middle\n\n\n    context.moveTo(x, y - halfHeight);\n    context.lineTo(x + halfWidth, y - halfHeight);\n    context.lineTo(x + halfWidth, y);\n    context.arcTo(x + halfWidth, y + halfHeight, x, y + halfHeight, cornerRadius);\n    context.arcTo(x - halfWidth, y + halfHeight, x - halfWidth, y, cornerRadius);\n    context.lineTo(x - halfWidth, y - halfHeight);\n    context.lineTo(x, y - halfHeight);\n    context.closePath();\n  };\n\n  CRp$3.drawCutRectanglePath = function (context, x, y, width, height) {\n    var halfWidth = width / 2;\n    var halfHeight = height / 2;\n    var cornerLength = getCutRectangleCornerLength();\n\n    if (context.beginPath) {\n      context.beginPath();\n    }\n\n    context.moveTo(x - halfWidth + cornerLength, y - halfHeight);\n    context.lineTo(x + halfWidth - cornerLength, y - halfHeight);\n    context.lineTo(x + halfWidth, y - halfHeight + cornerLength);\n    context.lineTo(x + halfWidth, y + halfHeight - cornerLength);\n    context.lineTo(x + halfWidth - cornerLength, y + halfHeight);\n    context.lineTo(x - halfWidth + cornerLength, y + halfHeight);\n    context.lineTo(x - halfWidth, y + halfHeight - cornerLength);\n    context.lineTo(x - halfWidth, y - halfHeight + cornerLength);\n    context.closePath();\n  };\n\n  CRp$3.drawBarrelPath = function (context, x, y, width, height) {\n    var halfWidth = width / 2;\n    var halfHeight = height / 2;\n    var xBegin = x - halfWidth;\n    var xEnd = x + halfWidth;\n    var yBegin = y - halfHeight;\n    var yEnd = y + halfHeight;\n    var barrelCurveConstants = getBarrelCurveConstants(width, height);\n    var wOffset = barrelCurveConstants.widthOffset;\n    var hOffset = barrelCurveConstants.heightOffset;\n    var ctrlPtXOffset = barrelCurveConstants.ctrlPtOffsetPct * wOffset;\n\n    if (context.beginPath) {\n      context.beginPath();\n    }\n\n    context.moveTo(xBegin, yBegin + hOffset);\n    context.lineTo(xBegin, yEnd - hOffset);\n    context.quadraticCurveTo(xBegin + ctrlPtXOffset, yEnd, xBegin + wOffset, yEnd);\n    context.lineTo(xEnd - wOffset, yEnd);\n    context.quadraticCurveTo(xEnd - ctrlPtXOffset, yEnd, xEnd, yEnd - hOffset);\n    context.lineTo(xEnd, yBegin + hOffset);\n    context.quadraticCurveTo(xEnd - ctrlPtXOffset, yBegin, xEnd - wOffset, yBegin);\n    context.lineTo(xBegin + wOffset, yBegin);\n    context.quadraticCurveTo(xBegin + ctrlPtXOffset, yBegin, xBegin, yBegin + hOffset);\n    context.closePath();\n  };\n\n  var sin0 = Math.sin(0);\n  var cos0 = Math.cos(0);\n  var sin = {};\n  var cos = {};\n  var ellipseStepSize = Math.PI / 40;\n\n  for (var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize) {\n    sin[i] = Math.sin(i);\n    cos[i] = Math.cos(i);\n  }\n\n  CRp$3.drawEllipsePath = function (context, centerX, centerY, width, height) {\n    if (context.beginPath) {\n      context.beginPath();\n    }\n\n    if (context.ellipse) {\n      context.ellipse(centerX, centerY, width / 2, height / 2, 0, 0, 2 * Math.PI);\n    } else {\n      var xPos, yPos;\n      var rw = width / 2;\n      var rh = height / 2;\n\n      for (var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize) {\n        xPos = centerX - rw * sin[i] * sin0 + rw * cos[i] * cos0;\n        yPos = centerY + rh * cos[i] * sin0 + rh * sin[i] * cos0;\n\n        if (i === 0) {\n          context.moveTo(xPos, yPos);\n        } else {\n          context.lineTo(xPos, yPos);\n        }\n      }\n    }\n\n    context.closePath();\n  };\n\n  /* global atob, ArrayBuffer, Uint8Array, Blob */\n  var CRp$2 = {};\n\n  CRp$2.createBuffer = function (w, h) {\n    var buffer = document.createElement('canvas'); // eslint-disable-line no-undef\n\n    buffer.width = w;\n    buffer.height = h;\n    return [buffer, buffer.getContext('2d')];\n  };\n\n  CRp$2.bufferCanvasImage = function (options) {\n    var cy = this.cy;\n    var eles = cy.mutableElements();\n    var bb = eles.boundingBox();\n    var ctrRect = this.findContainerClientCoords();\n    var width = options.full ? Math.ceil(bb.w) : ctrRect[2];\n    var height = options.full ? Math.ceil(bb.h) : ctrRect[3];\n    var specdMaxDims = number$1(options.maxWidth) || number$1(options.maxHeight);\n    var pxRatio = this.getPixelRatio();\n    var scale = 1;\n\n    if (options.scale !== undefined) {\n      width *= options.scale;\n      height *= options.scale;\n      scale = options.scale;\n    } else if (specdMaxDims) {\n      var maxScaleW = Infinity;\n      var maxScaleH = Infinity;\n\n      if (number$1(options.maxWidth)) {\n        maxScaleW = scale * options.maxWidth / width;\n      }\n\n      if (number$1(options.maxHeight)) {\n        maxScaleH = scale * options.maxHeight / height;\n      }\n\n      scale = Math.min(maxScaleW, maxScaleH);\n      width *= scale;\n      height *= scale;\n    }\n\n    if (!specdMaxDims) {\n      width *= pxRatio;\n      height *= pxRatio;\n      scale *= pxRatio;\n    }\n\n    var buffCanvas = document.createElement('canvas'); // eslint-disable-line no-undef\n\n    buffCanvas.width = width;\n    buffCanvas.height = height;\n    buffCanvas.style.width = width + 'px';\n    buffCanvas.style.height = height + 'px';\n    var buffCxt = buffCanvas.getContext('2d'); // Rasterize the layers, but only if container has nonzero size\n\n    if (width > 0 && height > 0) {\n      buffCxt.clearRect(0, 0, width, height);\n      buffCxt.globalCompositeOperation = 'source-over';\n      var zsortedEles = this.getCachedZSortedEles();\n\n      if (options.full) {\n        // draw the full bounds of the graph\n        buffCxt.translate(-bb.x1 * scale, -bb.y1 * scale);\n        buffCxt.scale(scale, scale);\n        this.drawElements(buffCxt, zsortedEles);\n        buffCxt.scale(1 / scale, 1 / scale);\n        buffCxt.translate(bb.x1 * scale, bb.y1 * scale);\n      } else {\n        // draw the current view\n        var pan = cy.pan();\n        var translation = {\n          x: pan.x * scale,\n          y: pan.y * scale\n        };\n        scale *= cy.zoom();\n        buffCxt.translate(translation.x, translation.y);\n        buffCxt.scale(scale, scale);\n        this.drawElements(buffCxt, zsortedEles);\n        buffCxt.scale(1 / scale, 1 / scale);\n        buffCxt.translate(-translation.x, -translation.y);\n      } // need to fill bg at end like this in order to fill cleared transparent pixels in jpgs\n\n\n      if (options.bg) {\n        buffCxt.globalCompositeOperation = 'destination-over';\n        buffCxt.fillStyle = options.bg;\n        buffCxt.rect(0, 0, width, height);\n        buffCxt.fill();\n      }\n    }\n\n    return buffCanvas;\n  };\n\n  function b64ToBlob(b64, mimeType) {\n    var bytes = atob(b64);\n    var buff = new ArrayBuffer(bytes.length);\n    var buffUint8 = new Uint8Array(buff);\n\n    for (var i = 0; i < bytes.length; i++) {\n      buffUint8[i] = bytes.charCodeAt(i);\n    }\n\n    return new Blob([buff], {\n      type: mimeType\n    });\n  }\n\n  function b64UriToB64(b64uri) {\n    var i = b64uri.indexOf(',');\n    return b64uri.substr(i + 1);\n  }\n\n  function output(options, canvas, mimeType) {\n    var getB64Uri = function getB64Uri() {\n      return canvas.toDataURL(mimeType, options.quality);\n    };\n\n    switch (options.output) {\n      case 'blob-promise':\n        return new Promise$1(function (resolve, reject) {\n          try {\n            canvas.toBlob(function (blob) {\n              if (blob != null) {\n                resolve(blob);\n              } else {\n                reject(new Error('`canvas.toBlob()` sent a null value in its callback'));\n              }\n            }, mimeType, options.quality);\n          } catch (err) {\n            reject(err);\n          }\n        });\n\n      case 'blob':\n        return b64ToBlob(b64UriToB64(getB64Uri()), mimeType);\n\n      case 'base64':\n        return b64UriToB64(getB64Uri());\n\n      case 'base64uri':\n      default:\n        return getB64Uri();\n    }\n  }\n\n  CRp$2.png = function (options) {\n    return output(options, this.bufferCanvasImage(options), 'image/png');\n  };\n\n  CRp$2.jpg = function (options) {\n    return output(options, this.bufferCanvasImage(options), 'image/jpeg');\n  };\n\n  var CRp$1 = {};\n\n  CRp$1.nodeShapeImpl = function (name, context, centerX, centerY, width, height, points) {\n    switch (name) {\n      case 'ellipse':\n        return this.drawEllipsePath(context, centerX, centerY, width, height);\n\n      case 'polygon':\n        return this.drawPolygonPath(context, centerX, centerY, width, height, points);\n\n      case 'round-polygon':\n        return this.drawRoundPolygonPath(context, centerX, centerY, width, height, points);\n\n      case 'roundrectangle':\n      case 'round-rectangle':\n        return this.drawRoundRectanglePath(context, centerX, centerY, width, height);\n\n      case 'cutrectangle':\n      case 'cut-rectangle':\n        return this.drawCutRectanglePath(context, centerX, centerY, width, height);\n\n      case 'bottomroundrectangle':\n      case 'bottom-round-rectangle':\n        return this.drawBottomRoundRectanglePath(context, centerX, centerY, width, height);\n\n      case 'barrel':\n        return this.drawBarrelPath(context, centerX, centerY, width, height);\n    }\n  };\n\n  var CR = CanvasRenderer;\n  var CRp = CanvasRenderer.prototype;\n  CRp.CANVAS_LAYERS = 3; //\n\n  CRp.SELECT_BOX = 0;\n  CRp.DRAG = 1;\n  CRp.NODE = 2;\n  CRp.BUFFER_COUNT = 3; //\n\n  CRp.TEXTURE_BUFFER = 0;\n  CRp.MOTIONBLUR_BUFFER_NODE = 1;\n  CRp.MOTIONBLUR_BUFFER_DRAG = 2;\n\n  function CanvasRenderer(options) {\n    var r = this;\n    r.data = {\n      canvases: new Array(CRp.CANVAS_LAYERS),\n      contexts: new Array(CRp.CANVAS_LAYERS),\n      canvasNeedsRedraw: new Array(CRp.CANVAS_LAYERS),\n      bufferCanvases: new Array(CRp.BUFFER_COUNT),\n      bufferContexts: new Array(CRp.CANVAS_LAYERS)\n    };\n    var tapHlOffAttr = '-webkit-tap-highlight-color';\n    var tapHlOffStyle = 'rgba(0,0,0,0)';\n    r.data.canvasContainer = document.createElement('div'); // eslint-disable-line no-undef\n\n    var containerStyle = r.data.canvasContainer.style;\n    r.data.canvasContainer.style[tapHlOffAttr] = tapHlOffStyle;\n    containerStyle.position = 'relative';\n    containerStyle.zIndex = '0';\n    containerStyle.overflow = 'hidden';\n    var container = options.cy.container();\n    container.appendChild(r.data.canvasContainer);\n    container.style[tapHlOffAttr] = tapHlOffStyle;\n    var styleMap = {\n      '-webkit-user-select': 'none',\n      '-moz-user-select': '-moz-none',\n      'user-select': 'none',\n      '-webkit-tap-highlight-color': 'rgba(0,0,0,0)',\n      'outline-style': 'none'\n    };\n\n    if (ms()) {\n      styleMap['-ms-touch-action'] = 'none';\n      styleMap['touch-action'] = 'none';\n    }\n\n    for (var i = 0; i < CRp.CANVAS_LAYERS; i++) {\n      var canvas = r.data.canvases[i] = document.createElement('canvas'); // eslint-disable-line no-undef\n\n      r.data.contexts[i] = canvas.getContext('2d');\n      Object.keys(styleMap).forEach(function (k) {\n        canvas.style[k] = styleMap[k];\n      });\n      canvas.style.position = 'absolute';\n      canvas.setAttribute('data-id', 'layer' + i);\n      canvas.style.zIndex = String(CRp.CANVAS_LAYERS - i);\n      r.data.canvasContainer.appendChild(canvas);\n      r.data.canvasNeedsRedraw[i] = false;\n    }\n\n    r.data.topCanvas = r.data.canvases[0];\n    r.data.canvases[CRp.NODE].setAttribute('data-id', 'layer' + CRp.NODE + '-node');\n    r.data.canvases[CRp.SELECT_BOX].setAttribute('data-id', 'layer' + CRp.SELECT_BOX + '-selectbox');\n    r.data.canvases[CRp.DRAG].setAttribute('data-id', 'layer' + CRp.DRAG + '-drag');\n\n    for (var i = 0; i < CRp.BUFFER_COUNT; i++) {\n      r.data.bufferCanvases[i] = document.createElement('canvas'); // eslint-disable-line no-undef\n\n      r.data.bufferContexts[i] = r.data.bufferCanvases[i].getContext('2d');\n      r.data.bufferCanvases[i].style.position = 'absolute';\n      r.data.bufferCanvases[i].setAttribute('data-id', 'buffer' + i);\n      r.data.bufferCanvases[i].style.zIndex = String(-i - 1);\n      r.data.bufferCanvases[i].style.visibility = 'hidden'; //r.data.canvasContainer.appendChild(r.data.bufferCanvases[i]);\n    }\n\n    r.pathsEnabled = true;\n    var emptyBb = makeBoundingBox();\n\n    var getBoxCenter = function getBoxCenter(bb) {\n      return {\n        x: (bb.x1 + bb.x2) / 2,\n        y: (bb.y1 + bb.y2) / 2\n      };\n    };\n\n    var getCenterOffset = function getCenterOffset(bb) {\n      return {\n        x: -bb.w / 2,\n        y: -bb.h / 2\n      };\n    };\n\n    var backgroundTimestampHasChanged = function backgroundTimestampHasChanged(ele) {\n      var _p = ele[0]._private;\n      var same = _p.oldBackgroundTimestamp === _p.backgroundTimestamp;\n      return !same;\n    };\n\n    var getStyleKey = function getStyleKey(ele) {\n      return ele[0]._private.nodeKey;\n    };\n\n    var getLabelKey = function getLabelKey(ele) {\n      return ele[0]._private.labelStyleKey;\n    };\n\n    var getSourceLabelKey = function getSourceLabelKey(ele) {\n      return ele[0]._private.sourceLabelStyleKey;\n    };\n\n    var getTargetLabelKey = function getTargetLabelKey(ele) {\n      return ele[0]._private.targetLabelStyleKey;\n    };\n\n    var drawElement = function drawElement(context, ele, bb, scaledLabelShown, useEleOpacity) {\n      return r.drawElement(context, ele, bb, false, false, useEleOpacity);\n    };\n\n    var drawLabel = function drawLabel(context, ele, bb, scaledLabelShown, useEleOpacity) {\n      return r.drawElementText(context, ele, bb, scaledLabelShown, 'main', useEleOpacity);\n    };\n\n    var drawSourceLabel = function drawSourceLabel(context, ele, bb, scaledLabelShown, useEleOpacity) {\n      return r.drawElementText(context, ele, bb, scaledLabelShown, 'source', useEleOpacity);\n    };\n\n    var drawTargetLabel = function drawTargetLabel(context, ele, bb, scaledLabelShown, useEleOpacity) {\n      return r.drawElementText(context, ele, bb, scaledLabelShown, 'target', useEleOpacity);\n    };\n\n    var getElementBox = function getElementBox(ele) {\n      ele.boundingBox();\n      return ele[0]._private.bodyBounds;\n    };\n\n    var getLabelBox = function getLabelBox(ele) {\n      ele.boundingBox();\n      return ele[0]._private.labelBounds.main || emptyBb;\n    };\n\n    var getSourceLabelBox = function getSourceLabelBox(ele) {\n      ele.boundingBox();\n      return ele[0]._private.labelBounds.source || emptyBb;\n    };\n\n    var getTargetLabelBox = function getTargetLabelBox(ele) {\n      ele.boundingBox();\n      return ele[0]._private.labelBounds.target || emptyBb;\n    };\n\n    var isLabelVisibleAtScale = function isLabelVisibleAtScale(ele, scaledLabelShown) {\n      return scaledLabelShown;\n    };\n\n    var getElementRotationPoint = function getElementRotationPoint(ele) {\n      return getBoxCenter(getElementBox(ele));\n    };\n\n    var addTextMargin = function addTextMargin(prefix, pt, ele) {\n      var pre = prefix ? prefix + '-' : '';\n      return {\n        x: pt.x + ele.pstyle(pre + 'text-margin-x').pfValue,\n        y: pt.y + ele.pstyle(pre + 'text-margin-y').pfValue\n      };\n    };\n\n    var getRsPt = function getRsPt(ele, x, y) {\n      var rs = ele[0]._private.rscratch;\n      return {\n        x: rs[x],\n        y: rs[y]\n      };\n    };\n\n    var getLabelRotationPoint = function getLabelRotationPoint(ele) {\n      return addTextMargin('', getRsPt(ele, 'labelX', 'labelY'), ele);\n    };\n\n    var getSourceLabelRotationPoint = function getSourceLabelRotationPoint(ele) {\n      return addTextMargin('source', getRsPt(ele, 'sourceLabelX', 'sourceLabelY'), ele);\n    };\n\n    var getTargetLabelRotationPoint = function getTargetLabelRotationPoint(ele) {\n      return addTextMargin('target', getRsPt(ele, 'targetLabelX', 'targetLabelY'), ele);\n    };\n\n    var getElementRotationOffset = function getElementRotationOffset(ele) {\n      return getCenterOffset(getElementBox(ele));\n    };\n\n    var getSourceLabelRotationOffset = function getSourceLabelRotationOffset(ele) {\n      return getCenterOffset(getSourceLabelBox(ele));\n    };\n\n    var getTargetLabelRotationOffset = function getTargetLabelRotationOffset(ele) {\n      return getCenterOffset(getTargetLabelBox(ele));\n    };\n\n    var getLabelRotationOffset = function getLabelRotationOffset(ele) {\n      var bb = getLabelBox(ele);\n      var p = getCenterOffset(getLabelBox(ele));\n\n      if (ele.isNode()) {\n        switch (ele.pstyle('text-halign').value) {\n          case 'left':\n            p.x = -bb.w;\n            break;\n\n          case 'right':\n            p.x = 0;\n            break;\n        }\n\n        switch (ele.pstyle('text-valign').value) {\n          case 'top':\n            p.y = -bb.h;\n            break;\n\n          case 'bottom':\n            p.y = 0;\n            break;\n        }\n      }\n\n      return p;\n    };\n\n    var eleTxrCache = r.data.eleTxrCache = new ElementTextureCache(r, {\n      getKey: getStyleKey,\n      doesEleInvalidateKey: backgroundTimestampHasChanged,\n      drawElement: drawElement,\n      getBoundingBox: getElementBox,\n      getRotationPoint: getElementRotationPoint,\n      getRotationOffset: getElementRotationOffset,\n      allowEdgeTxrCaching: false,\n      allowParentTxrCaching: false\n    });\n    var lblTxrCache = r.data.lblTxrCache = new ElementTextureCache(r, {\n      getKey: getLabelKey,\n      drawElement: drawLabel,\n      getBoundingBox: getLabelBox,\n      getRotationPoint: getLabelRotationPoint,\n      getRotationOffset: getLabelRotationOffset,\n      isVisible: isLabelVisibleAtScale\n    });\n    var slbTxrCache = r.data.slbTxrCache = new ElementTextureCache(r, {\n      getKey: getSourceLabelKey,\n      drawElement: drawSourceLabel,\n      getBoundingBox: getSourceLabelBox,\n      getRotationPoint: getSourceLabelRotationPoint,\n      getRotationOffset: getSourceLabelRotationOffset,\n      isVisible: isLabelVisibleAtScale\n    });\n    var tlbTxrCache = r.data.tlbTxrCache = new ElementTextureCache(r, {\n      getKey: getTargetLabelKey,\n      drawElement: drawTargetLabel,\n      getBoundingBox: getTargetLabelBox,\n      getRotationPoint: getTargetLabelRotationPoint,\n      getRotationOffset: getTargetLabelRotationOffset,\n      isVisible: isLabelVisibleAtScale\n    });\n    var lyrTxrCache = r.data.lyrTxrCache = new LayeredTextureCache(r);\n    r.onUpdateEleCalcs(function invalidateTextureCaches(willDraw, eles) {\n      // each cache should check for sub-key diff to see that the update affects that cache particularly\n      eleTxrCache.invalidateElements(eles);\n      lblTxrCache.invalidateElements(eles);\n      slbTxrCache.invalidateElements(eles);\n      tlbTxrCache.invalidateElements(eles); // any change invalidates the layers\n\n      lyrTxrCache.invalidateElements(eles); // update the old bg timestamp so diffs can be done in the ele txr caches\n\n      for (var _i = 0; _i < eles.length; _i++) {\n        var _p = eles[_i]._private;\n        _p.oldBackgroundTimestamp = _p.backgroundTimestamp;\n      }\n    });\n\n    var refineInLayers = function refineInLayers(reqs) {\n      for (var i = 0; i < reqs.length; i++) {\n        lyrTxrCache.enqueueElementRefinement(reqs[i].ele);\n      }\n    };\n\n    eleTxrCache.onDequeue(refineInLayers);\n    lblTxrCache.onDequeue(refineInLayers);\n    slbTxrCache.onDequeue(refineInLayers);\n    tlbTxrCache.onDequeue(refineInLayers);\n  }\n\n  CRp.redrawHint = function (group, bool) {\n    var r = this;\n\n    switch (group) {\n      case 'eles':\n        r.data.canvasNeedsRedraw[CRp.NODE] = bool;\n        break;\n\n      case 'drag':\n        r.data.canvasNeedsRedraw[CRp.DRAG] = bool;\n        break;\n\n      case 'select':\n        r.data.canvasNeedsRedraw[CRp.SELECT_BOX] = bool;\n        break;\n    }\n  }; // whether to use Path2D caching for drawing\n\n\n  var pathsImpld = typeof Path2D !== 'undefined';\n\n  CRp.path2dEnabled = function (on) {\n    if (on === undefined) {\n      return this.pathsEnabled;\n    }\n\n    this.pathsEnabled = on ? true : false;\n  };\n\n  CRp.usePaths = function () {\n    return pathsImpld && this.pathsEnabled;\n  };\n\n  CRp.setImgSmoothing = function (context, bool) {\n    if (context.imageSmoothingEnabled != null) {\n      context.imageSmoothingEnabled = bool;\n    } else {\n      context.webkitImageSmoothingEnabled = bool;\n      context.mozImageSmoothingEnabled = bool;\n      context.msImageSmoothingEnabled = bool;\n    }\n  };\n\n  CRp.getImgSmoothing = function (context) {\n    if (context.imageSmoothingEnabled != null) {\n      return context.imageSmoothingEnabled;\n    } else {\n      return context.webkitImageSmoothingEnabled || context.mozImageSmoothingEnabled || context.msImageSmoothingEnabled;\n    }\n  };\n\n  CRp.makeOffscreenCanvas = function (width, height) {\n    var canvas;\n\n    if ((typeof OffscreenCanvas === \"undefined\" ? \"undefined\" : _typeof(OffscreenCanvas)) !== (\"undefined\" )) {\n      canvas = new OffscreenCanvas(width, height);\n    } else {\n      canvas = document.createElement('canvas'); // eslint-disable-line no-undef\n\n      canvas.width = width;\n      canvas.height = height;\n    }\n\n    return canvas;\n  };\n\n  [CRp$a, CRp$9, CRp$8, CRp$7, CRp$6, CRp$5, CRp$4, CRp$3, CRp$2, CRp$1].forEach(function (props) {\n    extend(CRp, props);\n  });\n\n  var renderer = [{\n    name: 'null',\n    impl: NullRenderer\n  }, {\n    name: 'base',\n    impl: BR\n  }, {\n    name: 'canvas',\n    impl: CR\n  }];\n\n  var incExts = [{\n    type: 'layout',\n    extensions: layout\n  }, {\n    type: 'renderer',\n    extensions: renderer\n  }];\n\n  var extensions = {}; // registered modules for extensions, indexed by name\n\n  var modules = {};\n\n  function setExtension(type, name, registrant) {\n    var ext = registrant;\n\n    var overrideErr = function overrideErr(field) {\n      warn('Can not register `' + name + '` for `' + type + '` since `' + field + '` already exists in the prototype and can not be overridden');\n    };\n\n    if (type === 'core') {\n      if (Core.prototype[name]) {\n        return overrideErr(name);\n      } else {\n        Core.prototype[name] = registrant;\n      }\n    } else if (type === 'collection') {\n      if (Collection.prototype[name]) {\n        return overrideErr(name);\n      } else {\n        Collection.prototype[name] = registrant;\n      }\n    } else if (type === 'layout') {\n      // fill in missing layout functions in the prototype\n      var Layout = function Layout(options) {\n        this.options = options;\n        registrant.call(this, options); // make sure layout has _private for use w/ std apis like .on()\n\n        if (!plainObject(this._private)) {\n          this._private = {};\n        }\n\n        this._private.cy = options.cy;\n        this._private.listeners = [];\n        this.createEmitter();\n      };\n\n      var layoutProto = Layout.prototype = Object.create(registrant.prototype);\n      var optLayoutFns = [];\n\n      for (var i = 0; i < optLayoutFns.length; i++) {\n        var fnName = optLayoutFns[i];\n\n        layoutProto[fnName] = layoutProto[fnName] || function () {\n          return this;\n        };\n      } // either .start() or .run() is defined, so autogen the other\n\n\n      if (layoutProto.start && !layoutProto.run) {\n        layoutProto.run = function () {\n          this.start();\n          return this;\n        };\n      } else if (!layoutProto.start && layoutProto.run) {\n        layoutProto.start = function () {\n          this.run();\n          return this;\n        };\n      }\n\n      var regStop = registrant.prototype.stop;\n\n      layoutProto.stop = function () {\n        var opts = this.options;\n\n        if (opts && opts.animate) {\n          var anis = this.animations;\n\n          if (anis) {\n            for (var _i = 0; _i < anis.length; _i++) {\n              anis[_i].stop();\n            }\n          }\n        }\n\n        if (regStop) {\n          regStop.call(this);\n        } else {\n          this.emit('layoutstop');\n        }\n\n        return this;\n      };\n\n      if (!layoutProto.destroy) {\n        layoutProto.destroy = function () {\n          return this;\n        };\n      }\n\n      layoutProto.cy = function () {\n        return this._private.cy;\n      };\n\n      var getCy = function getCy(layout) {\n        return layout._private.cy;\n      };\n\n      var emitterOpts = {\n        addEventFields: function addEventFields(layout, evt) {\n          evt.layout = layout;\n          evt.cy = getCy(layout);\n          evt.target = layout;\n        },\n        bubble: function bubble() {\n          return true;\n        },\n        parent: function parent(layout) {\n          return getCy(layout);\n        }\n      };\n      extend(layoutProto, {\n        createEmitter: function createEmitter() {\n          this._private.emitter = new Emitter(emitterOpts, this);\n          return this;\n        },\n        emitter: function emitter() {\n          return this._private.emitter;\n        },\n        on: function on(evt, cb) {\n          this.emitter().on(evt, cb);\n          return this;\n        },\n        one: function one(evt, cb) {\n          this.emitter().one(evt, cb);\n          return this;\n        },\n        once: function once(evt, cb) {\n          this.emitter().one(evt, cb);\n          return this;\n        },\n        removeListener: function removeListener(evt, cb) {\n          this.emitter().removeListener(evt, cb);\n          return this;\n        },\n        removeAllListeners: function removeAllListeners() {\n          this.emitter().removeAllListeners();\n          return this;\n        },\n        emit: function emit(evt, params) {\n          this.emitter().emit(evt, params);\n          return this;\n        }\n      });\n      define.eventAliasesOn(layoutProto);\n      ext = Layout; // replace with our wrapped layout\n    } else if (type === 'renderer' && name !== 'null' && name !== 'base') {\n      // user registered renderers inherit from base\n      var BaseRenderer = getExtension('renderer', 'base');\n      var bProto = BaseRenderer.prototype;\n      var RegistrantRenderer = registrant;\n      var rProto = registrant.prototype;\n\n      var Renderer = function Renderer() {\n        BaseRenderer.apply(this, arguments);\n        RegistrantRenderer.apply(this, arguments);\n      };\n\n      var proto = Renderer.prototype;\n\n      for (var pName in bProto) {\n        var pVal = bProto[pName];\n        var existsInR = rProto[pName] != null;\n\n        if (existsInR) {\n          return overrideErr(pName);\n        }\n\n        proto[pName] = pVal; // take impl from base\n      }\n\n      for (var _pName in rProto) {\n        proto[_pName] = rProto[_pName]; // take impl from registrant\n      }\n\n      bProto.clientFunctions.forEach(function (name) {\n        proto[name] = proto[name] || function () {\n          error('Renderer does not implement `renderer.' + name + '()` on its prototype');\n        };\n      });\n      ext = Renderer;\n    } else if (type === '__proto__' || type === 'constructor' || type === 'prototype') {\n      // to avoid potential prototype pollution\n      return error(type + ' is an illegal type to be registered, possibly lead to prototype pollutions');\n    }\n\n    return setMap({\n      map: extensions,\n      keys: [type, name],\n      value: ext\n    });\n  }\n\n  function getExtension(type, name) {\n    return getMap({\n      map: extensions,\n      keys: [type, name]\n    });\n  }\n\n  function setModule(type, name, moduleType, moduleName, registrant) {\n    return setMap({\n      map: modules,\n      keys: [type, name, moduleType, moduleName],\n      value: registrant\n    });\n  }\n\n  function getModule(type, name, moduleType, moduleName) {\n    return getMap({\n      map: modules,\n      keys: [type, name, moduleType, moduleName]\n    });\n  }\n\n  var extension = function extension() {\n    // e.g. extension('renderer', 'svg')\n    if (arguments.length === 2) {\n      return getExtension.apply(null, arguments);\n    } // e.g. extension('renderer', 'svg', { ... })\n    else if (arguments.length === 3) {\n      return setExtension.apply(null, arguments);\n    } // e.g. extension('renderer', 'svg', 'nodeShape', 'ellipse')\n    else if (arguments.length === 4) {\n      return getModule.apply(null, arguments);\n    } // e.g. extension('renderer', 'svg', 'nodeShape', 'ellipse', { ... })\n    else if (arguments.length === 5) {\n      return setModule.apply(null, arguments);\n    } else {\n      error('Invalid extension access syntax');\n    }\n  }; // allows a core instance to access extensions internally\n\n\n  Core.prototype.extension = extension; // included extensions\n\n  incExts.forEach(function (group) {\n    group.extensions.forEach(function (ext) {\n      setExtension(group.type, ext.name, ext.impl);\n    });\n  });\n\n  // (useful for init)\n\n  var Stylesheet = function Stylesheet() {\n    if (!(this instanceof Stylesheet)) {\n      return new Stylesheet();\n    }\n\n    this.length = 0;\n  };\n\n  var sheetfn = Stylesheet.prototype;\n\n  sheetfn.instanceString = function () {\n    return 'stylesheet';\n  }; // just store the selector to be parsed later\n\n\n  sheetfn.selector = function (selector) {\n    var i = this.length++;\n    this[i] = {\n      selector: selector,\n      properties: []\n    };\n    return this; // chaining\n  }; // just store the property to be parsed later\n\n\n  sheetfn.css = function (name, value) {\n    var i = this.length - 1;\n\n    if (string(name)) {\n      this[i].properties.push({\n        name: name,\n        value: value\n      });\n    } else if (plainObject(name)) {\n      var map = name;\n      var propNames = Object.keys(map);\n\n      for (var j = 0; j < propNames.length; j++) {\n        var key = propNames[j];\n        var mapVal = map[key];\n\n        if (mapVal == null) {\n          continue;\n        }\n\n        var prop = Style.properties[key] || Style.properties[dash2camel(key)];\n\n        if (prop == null) {\n          continue;\n        }\n\n        var _name = prop.name;\n        var _value = mapVal;\n        this[i].properties.push({\n          name: _name,\n          value: _value\n        });\n      }\n    }\n\n    return this; // chaining\n  };\n\n  sheetfn.style = sheetfn.css; // generate a real style object from the dummy stylesheet\n\n  sheetfn.generateStyle = function (cy) {\n    var style = new Style(cy);\n    return this.appendToStyle(style);\n  }; // append a dummy stylesheet object on a real style object\n\n\n  sheetfn.appendToStyle = function (style) {\n    for (var i = 0; i < this.length; i++) {\n      var context = this[i];\n      var selector = context.selector;\n      var props = context.properties;\n      style.selector(selector); // apply selector\n\n      for (var j = 0; j < props.length; j++) {\n        var prop = props[j];\n        style.css(prop.name, prop.value); // apply property\n      }\n    }\n\n    return style;\n  };\n\n  var version = \"3.24.0\";\n\n  var cytoscape = function cytoscape(options) {\n    // if no options specified, use default\n    if (options === undefined) {\n      options = {};\n    } // create instance\n\n\n    if (plainObject(options)) {\n      return new Core(options);\n    } // allow for registration of extensions\n    else if (string(options)) {\n      return extension.apply(extension, arguments);\n    }\n  }; // e.g. cytoscape.use( require('cytoscape-foo'), bar )\n\n\n  cytoscape.use = function (ext) {\n    var args = Array.prototype.slice.call(arguments, 1); // args to pass to ext\n\n    args.unshift(cytoscape); // cytoscape is first arg to ext\n\n    ext.apply(null, args);\n    return this;\n  };\n\n  cytoscape.warnings = function (bool) {\n    return warnings(bool);\n  }; // replaced by build system\n\n\n  cytoscape.version = version; // expose public apis (mostly for extensions)\n\n  cytoscape.stylesheet = cytoscape.Stylesheet = Stylesheet;\n\n  return cytoscape;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9kaXN0L2N5dG9zY2FwZS51bWQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRSxLQUE0RDtBQUM5RCxFQUFFLENBQ3dHO0FBQzFHLENBQUMsdUJBQXVCOztBQUV4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsOEJBQThCLCtCQUErQjtBQUM3RDs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMkNBQTJDLFNBQVM7O0FBRXBEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdFQUFnRTs7QUFFaEU7QUFDQTs7QUFFQTs7QUFFQSw0QkFBNEI7O0FBRTVCLHVDQUF1Qzs7QUFFdkM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsT0FBTztBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLE9BQU87QUFDM0I7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBLHdDQUF3QyxPQUFPO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVDQUF1Qzs7O0FBR3ZDLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQsMEJBQTBCLHNCQUFzQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsdUJBQXVCLDRCQUE0QjtBQUNuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxtQ0FBbUMsMEJBQTBCO0FBQ3RIO0FBQ0EsT0FBTztBQUNQO0FBQ0Esd0NBQXdDLFdBQVc7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxXQUFXO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsV0FBVztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHNDQUFzQztBQUN2RjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLOztBQUVMLEdBQUc7QUFDSCxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCLGlCQUFpQjtBQUMxQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMEJBQTBCLHdCQUF3QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVYsUUFBUTs7O0FBR1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7O0FBR1Qsc0JBQXNCLGNBQWM7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUCx1QkFBdUIsZUFBZTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUNBQXFDOztBQUVyQyxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7OztBQUdWLHFDQUFxQztBQUNyQzs7QUFFQTs7QUFFQSx3QkFBd0Isb0JBQW9CO0FBQzVDLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBLFlBQVk7OztBQUdaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQSxZQUFZOzs7QUFHWjtBQUNBO0FBQ0EsWUFBWTs7O0FBR1osc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTs7O0FBR1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVixRQUFRO0FBQ1I7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7O0FBR1Q7O0FBRUEsc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7OztBQUdBO0FBQ0EscUNBQXFDOztBQUVyQyx1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUIsc0NBQXNDOzs7QUFHdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1Isc0JBQXNCLE9BQU87QUFDN0IsMEJBQTBCLFNBQVM7QUFDbkM7O0FBRUEsMkJBQTJCLFFBQVE7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU4sS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDOztBQUVyQztBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsU0FBUyxxQkFBcUI7OztBQUc5QixzQkFBc0IsY0FBYztBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsZUFBZTtBQUN0Qzs7QUFFQSx3QkFBd0IsY0FBYztBQUN0QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDhFQUE4RTs7QUFFOUU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHlCQUF5QixlQUFlO0FBQ3hDOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsOEJBQThCLHNCQUFzQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0Msa0JBQWtCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOLEtBQUs7O0FBRUwsNEJBQTRCO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQzs7QUFFQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR04scUJBQXFCLHNCQUFzQjtBQUMzQzs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDOztBQUV0QztBQUNBLFFBQVE7QUFDUjtBQUNBLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBLE1BQU07OztBQUdOLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQSx5RUFBeUU7O0FBRXpFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOzs7QUFHQTs7QUFFQSxzQkFBc0IsY0FBYztBQUNwQztBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBLCtDQUErQzs7QUFFL0M7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQixnQkFBZ0I7QUFDMUM7QUFDQTtBQUNBLFNBQVM7OztBQUdULHlCQUF5QixpQkFBaUI7QUFDMUM7QUFDQSwwQkFBMEIsZ0JBQWdCO0FBQzFDO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQSw4Q0FBOEM7QUFDOUM7O0FBRUEsaURBQWlEOztBQUVqRDtBQUNBLDBFQUEwRTs7QUFFMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7OztBQUdBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxxQ0FBcUM7O0FBRXJDOztBQUVBLHdCQUF3Qiw0QkFBNEI7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixTQUFTO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsU0FBUztBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsU0FBUztBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR04saUJBQWlCOztBQUVqQixpQ0FBaUMsUUFBUTtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sR0FBRztBQUNWOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQjs7QUFFQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBLE1BQU07OztBQUdOLHFCQUFxQixhQUFhO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUEsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxpR0FBaUc7QUFDakc7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLHFCQUFxQjtBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7O0FBR0EsK0RBQStEO0FBQy9EO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7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Q0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVB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OztBQUVBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVIsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdURBQXVEOztBQUV2RDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsdUJBQXVCLGtCQUFrQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQzs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDs7QUFFM0Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRyxJQUFJOztBQUVQLDRCQUE0Qjs7QUFFNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsNkNBQTZDOztBQUU3QztBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEM7O0FBRTlDLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHdCQUF3QjtBQUN4QjtBQUNBOztBQUVBOztBQUVBLG9CQUFvQixzQkFBc0I7QUFDMUM7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHlDQUF5Qzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxvQkFBb0Isc0JBQXNCO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBeUM7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjs7QUFFQSxzQkFBc0IsNEJBQTRCO0FBQ2xEO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FB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QU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUEsc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQSxRQUFROztBQUVSOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7OztBQUdULHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOOzs7QUFHQTs7QUFFQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOLHdDQUF3Qzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUEsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUixzQ0FBc0M7O0FBRXRDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHdDQUF3Qzs7QUFFeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxvQkFBb0I7O0FBRXBCO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDO0FBQ2xDLFVBQVU7QUFDVixrQ0FBa0M7QUFDbEMsVUFBVTtBQUNWLHdDQUF3QztBQUN4Qzs7QUFFQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7O0FBRUE7O0FBRUEsOEJBQThCLGlCQUFpQjtBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjOzs7QUFHZDs7QUFFQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVYsUUFBUTs7QUFFUixNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7O0FBRWxELG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQSxzRkFBc0Y7O0FBRXRGO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0EscUZBQXFGOztBQUVyRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQiwyQkFBMkI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDOztBQUV2Qyw0REFBNEQ7O0FBRTVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVDQUF1QztBQUN2QztBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047OztBQUdBOztBQUVBLHNCQUFzQix5QkFBeUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtREFBbUQ7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsbUNBQW1DO0FBQ25DO0FBQ0Esc0JBQXNCO0FBQ3RCLG1DQUFtQzs7O0FBR25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixzQkFBc0I7QUFDdEI7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixzQkFBc0I7QUFDdEI7QUFDQTs7QUFFQTtBQUNBLDhMQUE4TDtBQUM5TCxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsK0JBQStCO0FBQ3pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFlBQVk7OztBQUdaO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVk7QUFDWiwwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUM7O0FBRW5DLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDRCQUE0QixtQ0FBbUM7QUFDL0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1DQUFtQzs7QUFFbkMsMkJBQTJCOztBQUUzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTs7QUFFeEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDOztBQUV6QywyQkFBMkI7O0FBRTNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQyxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBLCtCQUErQjtBQUMvQixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUEsd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssaUJBQWlCLFVBQVU7OztBQUdoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0I7O0FBRXRCOztBQUVBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQSxvREFBb0Q7O0FBRXBELHNEQUFzRDtBQUN0RCxVQUFVO0FBQ1YsZ0RBQWdEOztBQUVoRCxvREFBb0Q7QUFDcEQsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBLHlDQUF5Qzs7QUFFekMsZ0RBQWdEOztBQUVoRDtBQUNBO0FBQ0EsUUFBUTtBQUNSOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0Esb0NBQW9DOztBQUVwQztBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLG1DQUFtQztBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0I7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsNEJBQTRCO0FBQ3BEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTixxQkFBcUI7O0FBRXJCLHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQSxLQUFLOzs7QUFHTDtBQUNBOztBQUVBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTs7QUFFQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47O0FBRUEsb0JBQW9COztBQUVwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sZ0JBQWdCO0FBQ2hCO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0Esa0JBQWtCOztBQUVsQjtBQUNBOztBQUVBLHNCQUFzQiw0QkFBNEI7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCOztBQUVsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGNBQWM7QUFDZDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLHNCQUFzQjtBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQzs7QUFFaEMsc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTs7QUFFQSxxQ0FBcUMsaUJBQWlCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qjs7QUFFdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDhEQUE4RCxjQUFjOztBQUU1RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUM7O0FBRXZDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwwR0FBMEc7O0FBRTFHO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUVBQXFFOztBQUVyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUZBQWlGOztBQUVqRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx1RkFBdUY7O0FBRXZGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjs7QUFFQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUZBQXlGOztBQUV6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVI7QUFDQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwsb0JBQW9CLDZCQUE2QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUssSUFBSTtBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSyxHQUFHOztBQUVSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSyxHQUFHOztBQUVSO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVIscUJBQXFCLG1CQUFtQjtBQUN4QztBQUNBLCtCQUErQjtBQUMvQixNQUFNOzs7QUFHTixzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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S0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQixLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25CLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixzQkFBc0IsY0FBYztBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CO0FBQ25CLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGNBQWM7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUI7QUFDbkIsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25CLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkVBQTZFOztBQUU3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0Esb0RBQW9EOztBQUVwRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCOztBQUV2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQixLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQLG1CQUFtQjtBQUNuQixLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxL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Q0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFL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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQzs7QUFFbkM7QUFDQTtBQUNBLG1EQUFtRDs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkM7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNFQUFzRTs7QUFFdEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QjtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREOztBQUU1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWlFOzs7QUFHakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsMkJBQTJCO0FBQ2pEO0FBQ0EsMERBQTBEOztBQUUxRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSw0REFBNEQ7O0FBRTVEO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTs7QUFFWixZQUFZOztBQUVaLGNBQWM7O0FBRWQsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTiw4QkFBOEI7QUFDOUIsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTiw4QkFBOEI7QUFDOUIsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQiw2QkFBNkI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHNCQUFzQiwwQkFBMEI7QUFDaEQ7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQSxzQkFBc0IsMEJBQTBCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVB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OztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FB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QkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7OztBQUdUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxVQUFVOztBQUVWLFFBQVE7QUFDUjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7O0FBR1YsMkRBQTJEO0FBQzNELFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRDQUE0Qzs7QUFFNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGFBQWE7QUFDYjtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7OztBQUdaO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBLFVBQVU7O0FBRVY7QUFDQSwwQkFBMEIsZ0JBQWdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZOzs7QUFHWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUSx5QkFBeUIseUJBQXlCO0FBQzFEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixhQUFhO0FBQ2I7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBOztBQUVBLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUixLQUFLLFVBQVU7O0FBRWY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EscUNBQXFDOztBQUVyQztBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlD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QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDs7QUFFdEQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixvQkFBb0I7QUFDOUM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIscUJBQXFCO0FBQ2hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7O0FBRTFDO0FBQ0Esc0NBQXNDOztBQUV0QztBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQzs7QUFFaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUEsZ0NBQWdDOztBQUVoQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7O0FBRWpEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsNEJBQTRCO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCOztBQUU1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5REFBeUQ7O0FBRXpEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvRUFBb0U7O0FBRXBFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZOztBQUVaLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZOztBQUVaLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZOztBQUVaOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047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QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDOztBQUU1Qyw0Q0FBNEM7O0FBRTVDLHVCQUF1QixrQkFBa0I7QUFDekM7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7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QTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBOztBQUVBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakI7O0FBRUEsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDOztBQUVoQyxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQSx5REFBeUQ7O0FBRXpELDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTCwrQkFBK0I7O0FBRS9COztBQUVBOztBQUVBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9kaXN0L2N5dG9zY2FwZS51bWQuanM/MzVmNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDIzLCBUaGUgQ3l0b3NjYXBlIENvbnNvcnRpdW0uXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZlxuICogdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUg4oCcU29mdHdhcmXigJ0pLCB0byBkZWFsIGluXG4gKiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvXG4gKiB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllc1xuICogb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvXG4gKiBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCDigJxBUyBJU+KAnSwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICogU09GVFdBUkUuXG4gKi9cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAoZ2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IGdsb2JhbCB8fCBzZWxmLCBnbG9iYWwuY3l0b3NjYXBlID0gZmFjdG9yeSgpKTtcbn0pKHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICAgIHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfSwgX3R5cGVvZihvYmopO1xuICB9XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwge1xuICAgICAgd3JpdGFibGU6IGZhbHNlXG4gICAgfSk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9XG5cbiAgZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5JDEob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICBmdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgICByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG4gIH1cblxuICBmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7XG4gICAgdmFyIF9pID0gYXJyID09IG51bGwgPyBudWxsIDogdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBhcnJbU3ltYm9sLml0ZXJhdG9yXSB8fCBhcnJbXCJAQGl0ZXJhdG9yXCJdO1xuXG4gICAgaWYgKF9pID09IG51bGwpIHJldHVybjtcbiAgICB2YXIgX2FyciA9IFtdO1xuICAgIHZhciBfbiA9IHRydWU7XG4gICAgdmFyIF9kID0gZmFsc2U7XG5cbiAgICB2YXIgX3MsIF9lO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2kgPSBfaS5jYWxsKGFycik7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfZCA9IHRydWU7XG4gICAgICBfZSA9IGVycjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gX2FycjtcbiAgfVxuXG4gIGZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgICBpZiAoIW8pIHJldHVybjtcbiAgICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICAgIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICAgIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gICAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG5cbiAgICByZXR1cm4gYXJyMjtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbiAgfVxuXG4gIHZhciB3aW5kb3ckMSA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHdpbmRvdzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4gIHZhciBuYXZpZ2F0b3IgPSB3aW5kb3ckMSA/IHdpbmRvdyQxLm5hdmlnYXRvciA6IG51bGw7XG4gIHdpbmRvdyQxID8gd2luZG93JDEuZG9jdW1lbnQgOiBudWxsO1xuXG4gIHZhciB0eXBlb2ZzdHIgPSBfdHlwZW9mKCcnKTtcblxuICB2YXIgdHlwZW9mb2JqID0gX3R5cGVvZih7fSk7XG5cbiAgdmFyIHR5cGVvZmZuID0gX3R5cGVvZihmdW5jdGlvbiAoKSB7fSk7XG5cbiAgdmFyIHR5cGVvZmh0bWxlbGUgPSB0eXBlb2YgSFRNTEVsZW1lbnQgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihIVE1MRWxlbWVudCk7XG5cbiAgdmFyIGluc3RhbmNlU3RyID0gZnVuY3Rpb24gaW5zdGFuY2VTdHIob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouaW5zdGFuY2VTdHJpbmcgJiYgZm4kNihvYmouaW5zdGFuY2VTdHJpbmcpID8gb2JqLmluc3RhbmNlU3RyaW5nKCkgOiBudWxsO1xuICB9O1xuXG4gIHZhciBzdHJpbmcgPSBmdW5jdGlvbiBzdHJpbmcob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIF90eXBlb2Yob2JqKSA9PSB0eXBlb2ZzdHI7XG4gIH07XG4gIHZhciBmbiQ2ID0gZnVuY3Rpb24gZm4ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIF90eXBlb2Yob2JqKSA9PT0gdHlwZW9mZm47XG4gIH07XG4gIHZhciBhcnJheSA9IGZ1bmN0aW9uIGFycmF5KG9iaikge1xuICAgIHJldHVybiAhZWxlbWVudE9yQ29sbGVjdGlvbihvYmopICYmIChBcnJheS5pc0FycmF5ID8gQXJyYXkuaXNBcnJheShvYmopIDogb2JqICE9IG51bGwgJiYgb2JqIGluc3RhbmNlb2YgQXJyYXkpO1xuICB9O1xuICB2YXIgcGxhaW5PYmplY3QgPSBmdW5jdGlvbiBwbGFpbk9iamVjdChvYmopIHtcbiAgICByZXR1cm4gb2JqICE9IG51bGwgJiYgX3R5cGVvZihvYmopID09PSB0eXBlb2ZvYmogJiYgIWFycmF5KG9iaikgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XG4gIH07XG4gIHZhciBvYmplY3QgPSBmdW5jdGlvbiBvYmplY3Qob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIF90eXBlb2Yob2JqKSA9PT0gdHlwZW9mb2JqO1xuICB9O1xuICB2YXIgbnVtYmVyJDEgPSBmdW5jdGlvbiBudW1iZXIob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIF90eXBlb2Yob2JqKSA9PT0gX3R5cGVvZigxKSAmJiAhaXNOYU4ob2JqKTtcbiAgfTtcbiAgdmFyIGludGVnZXIgPSBmdW5jdGlvbiBpbnRlZ2VyKG9iaikge1xuICAgIHJldHVybiBudW1iZXIkMShvYmopICYmIE1hdGguZmxvb3Iob2JqKSA9PT0gb2JqO1xuICB9O1xuICB2YXIgaHRtbEVsZW1lbnQgPSBmdW5jdGlvbiBodG1sRWxlbWVudChvYmopIHtcbiAgICBpZiAoJ3VuZGVmaW5lZCcgPT09IHR5cGVvZmh0bWxlbGUpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsICE9IG9iaiAmJiBvYmogaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbiAgICB9XG4gIH07XG4gIHZhciBlbGVtZW50T3JDb2xsZWN0aW9uID0gZnVuY3Rpb24gZWxlbWVudE9yQ29sbGVjdGlvbihvYmopIHtcbiAgICByZXR1cm4gZWxlbWVudChvYmopIHx8IGNvbGxlY3Rpb24ob2JqKTtcbiAgfTtcbiAgdmFyIGVsZW1lbnQgPSBmdW5jdGlvbiBlbGVtZW50KG9iaikge1xuICAgIHJldHVybiBpbnN0YW5jZVN0cihvYmopID09PSAnY29sbGVjdGlvbicgJiYgb2JqLl9wcml2YXRlLnNpbmdsZTtcbiAgfTtcbiAgdmFyIGNvbGxlY3Rpb24gPSBmdW5jdGlvbiBjb2xsZWN0aW9uKG9iaikge1xuICAgIHJldHVybiBpbnN0YW5jZVN0cihvYmopID09PSAnY29sbGVjdGlvbicgJiYgIW9iai5fcHJpdmF0ZS5zaW5nbGU7XG4gIH07XG4gIHZhciBjb3JlID0gZnVuY3Rpb24gY29yZShvYmopIHtcbiAgICByZXR1cm4gaW5zdGFuY2VTdHIob2JqKSA9PT0gJ2NvcmUnO1xuICB9O1xuICB2YXIgc3R5bGVzaGVldCA9IGZ1bmN0aW9uIHN0eWxlc2hlZXQob2JqKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlU3RyKG9iaikgPT09ICdzdHlsZXNoZWV0JztcbiAgfTtcbiAgdmFyIGV2ZW50ID0gZnVuY3Rpb24gZXZlbnQob2JqKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlU3RyKG9iaikgPT09ICdldmVudCc7XG4gIH07XG4gIHZhciBlbXB0eVN0cmluZyA9IGZ1bmN0aW9uIGVtcHR5U3RyaW5nKG9iaikge1xuICAgIGlmIChvYmogPT09IHVuZGVmaW5lZCB8fCBvYmogPT09IG51bGwpIHtcbiAgICAgIC8vIG51bGwgaXMgZW1wdHlcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAob2JqID09PSAnJyB8fCBvYmoubWF0Y2goL15cXHMrJC8pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTsgLy8gZW1wdHkgc3RyaW5nIGlzIGVtcHR5XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlOyAvLyBvdGhlcndpc2UsIHdlIGRvbid0IGtub3cgd2hhdCB3ZSd2ZSBnb3RcbiAgfTtcbiAgdmFyIGRvbUVsZW1lbnQgPSBmdW5jdGlvbiBkb21FbGVtZW50KG9iaikge1xuICAgIGlmICh0eXBlb2YgSFRNTEVsZW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7IC8vIHdlJ3JlIG5vdCBpbiBhIGJyb3dzZXIgc28gaXQgZG9lc24ndCBtYXR0ZXJcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xuICAgIH1cbiAgfTtcbiAgdmFyIGJvdW5kaW5nQm94ID0gZnVuY3Rpb24gYm91bmRpbmdCb3gob2JqKSB7XG4gICAgcmV0dXJuIHBsYWluT2JqZWN0KG9iaikgJiYgbnVtYmVyJDEob2JqLngxKSAmJiBudW1iZXIkMShvYmoueDIpICYmIG51bWJlciQxKG9iai55MSkgJiYgbnVtYmVyJDEob2JqLnkyKTtcbiAgfTtcbiAgdmFyIHByb21pc2UgPSBmdW5jdGlvbiBwcm9taXNlKG9iaikge1xuICAgIHJldHVybiBvYmplY3Qob2JqKSAmJiBmbiQ2KG9iai50aGVuKTtcbiAgfTtcbiAgdmFyIG1zID0gZnVuY3Rpb24gbXMoKSB7XG4gICAgcmV0dXJuIG5hdmlnYXRvciAmJiBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9tc2llfHRyaWRlbnR8ZWRnZS9pKTtcbiAgfTsgLy8gcHJvYmFibHkgYSBiZXR0ZXIgd2F5IHRvIGRldGVjdCB0aGlzLi4uXG5cbiAgdmFyIG1lbW9pemUkMSA9IGZ1bmN0aW9uIG1lbW9pemUoZm4sIGtleUZuKSB7XG4gICAgaWYgKCFrZXlGbikge1xuICAgICAga2V5Rm4gPSBmdW5jdGlvbiBrZXlGbigpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICByZXR1cm4gYXJndW1lbnRzWzBdO1xuICAgICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gJ3VuZGVmaW5lZCc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYXJncyA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXJncy5qb2luKCckJyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBtZW1vaXplZEZuID0gZnVuY3Rpb24gbWVtb2l6ZWRGbigpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgdmFyIHJldDtcbiAgICAgIHZhciBrID0ga2V5Rm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICB2YXIgY2FjaGUgPSBtZW1vaXplZEZuLmNhY2hlO1xuXG4gICAgICBpZiAoIShyZXQgPSBjYWNoZVtrXSkpIHtcbiAgICAgICAgcmV0ID0gY2FjaGVba10gPSBmbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuXG4gICAgbWVtb2l6ZWRGbi5jYWNoZSA9IHt9O1xuICAgIHJldHVybiBtZW1vaXplZEZuO1xuICB9O1xuXG4gIHZhciBjYW1lbDJkYXNoID0gbWVtb2l6ZSQxKGZ1bmN0aW9uIChzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbQS1aXSkvZywgZnVuY3Rpb24gKHYpIHtcbiAgICAgIHJldHVybiAnLScgKyB2LnRvTG93ZXJDYXNlKCk7XG4gICAgfSk7XG4gIH0pO1xuICB2YXIgZGFzaDJjYW1lbCA9IG1lbW9pemUkMShmdW5jdGlvbiAoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oLVxcdykvZywgZnVuY3Rpb24gKHYpIHtcbiAgICAgIHJldHVybiB2WzFdLnRvVXBwZXJDYXNlKCk7XG4gICAgfSk7XG4gIH0pO1xuICB2YXIgcHJlcGVuZENhbWVsID0gbWVtb2l6ZSQxKGZ1bmN0aW9uIChwcmVmaXgsIHN0cikge1xuICAgIHJldHVybiBwcmVmaXggKyBzdHJbMF0udG9VcHBlckNhc2UoKSArIHN0ci5zdWJzdHJpbmcoMSk7XG4gIH0sIGZ1bmN0aW9uIChwcmVmaXgsIHN0cikge1xuICAgIHJldHVybiBwcmVmaXggKyAnJCcgKyBzdHI7XG4gIH0pO1xuICB2YXIgY2FwaXRhbGl6ZSA9IGZ1bmN0aW9uIGNhcGl0YWxpemUoc3RyKSB7XG4gICAgaWYgKGVtcHR5U3RyaW5nKHN0cikpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zdWJzdHJpbmcoMSk7XG4gIH07XG5cbiAgdmFyIG51bWJlciA9ICcoPzpbLStdPyg/Oig/OlxcXFxkK3xcXFxcZCpcXFxcLlxcXFxkKykoPzpbRWVdWystXT9cXFxcZCspPykpJztcbiAgdmFyIHJnYmEgPSAncmdiW2FdP1xcXFwoKCcgKyBudW1iZXIgKyAnWyVdPylcXFxccyosXFxcXHMqKCcgKyBudW1iZXIgKyAnWyVdPylcXFxccyosXFxcXHMqKCcgKyBudW1iZXIgKyAnWyVdPykoPzpcXFxccyosXFxcXHMqKCcgKyBudW1iZXIgKyAnKSk/XFxcXCknO1xuICB2YXIgcmdiYU5vQmFja1JlZnMgPSAncmdiW2FdP1xcXFwoKD86JyArIG51bWJlciArICdbJV0/KVxcXFxzKixcXFxccyooPzonICsgbnVtYmVyICsgJ1slXT8pXFxcXHMqLFxcXFxzKig/OicgKyBudW1iZXIgKyAnWyVdPykoPzpcXFxccyosXFxcXHMqKD86JyArIG51bWJlciArICcpKT9cXFxcKSc7XG4gIHZhciBoc2xhID0gJ2hzbFthXT9cXFxcKCgnICsgbnVtYmVyICsgJylcXFxccyosXFxcXHMqKCcgKyBudW1iZXIgKyAnWyVdKVxcXFxzKixcXFxccyooJyArIG51bWJlciArICdbJV0pKD86XFxcXHMqLFxcXFxzKignICsgbnVtYmVyICsgJykpP1xcXFwpJztcbiAgdmFyIGhzbGFOb0JhY2tSZWZzID0gJ2hzbFthXT9cXFxcKCg/OicgKyBudW1iZXIgKyAnKVxcXFxzKixcXFxccyooPzonICsgbnVtYmVyICsgJ1slXSlcXFxccyosXFxcXHMqKD86JyArIG51bWJlciArICdbJV0pKD86XFxcXHMqLFxcXFxzKig/OicgKyBudW1iZXIgKyAnKSk/XFxcXCknO1xuICB2YXIgaGV4MyA9ICdcXFxcI1swLTlhLWZBLUZdezN9JztcbiAgdmFyIGhleDYgPSAnXFxcXCNbMC05YS1mQS1GXXs2fSc7XG5cbiAgdmFyIGFzY2VuZGluZyA9IGZ1bmN0aW9uIGFzY2VuZGluZyhhLCBiKSB7XG4gICAgaWYgKGEgPCBiKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfSBlbHNlIGlmIChhID4gYikge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfTtcbiAgdmFyIGRlc2NlbmRpbmcgPSBmdW5jdGlvbiBkZXNjZW5kaW5nKGEsIGIpIHtcbiAgICByZXR1cm4gLTEgKiBhc2NlbmRpbmcoYSwgYik7XG4gIH07XG5cbiAgdmFyIGV4dGVuZCA9IE9iamVjdC5hc3NpZ24gIT0gbnVsbCA/IE9iamVjdC5hc3NpZ24uYmluZChPYmplY3QpIDogZnVuY3Rpb24gKHRndCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgb2JqID0gYXJnc1tpXTtcblxuICAgICAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwga2V5cy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgayA9IGtleXNbal07XG4gICAgICAgIHRndFtrXSA9IG9ialtrXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGd0O1xuICB9O1xuXG4gIHZhciBoZXgydHVwbGUgPSBmdW5jdGlvbiBoZXgydHVwbGUoaGV4KSB7XG4gICAgaWYgKCEoaGV4Lmxlbmd0aCA9PT0gNCB8fCBoZXgubGVuZ3RoID09PSA3KSB8fCBoZXhbMF0gIT09ICcjJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzaG9ydEhleCA9IGhleC5sZW5ndGggPT09IDQ7XG4gICAgdmFyIHIsIGcsIGI7XG4gICAgdmFyIGJhc2UgPSAxNjtcblxuICAgIGlmIChzaG9ydEhleCkge1xuICAgICAgciA9IHBhcnNlSW50KGhleFsxXSArIGhleFsxXSwgYmFzZSk7XG4gICAgICBnID0gcGFyc2VJbnQoaGV4WzJdICsgaGV4WzJdLCBiYXNlKTtcbiAgICAgIGIgPSBwYXJzZUludChoZXhbM10gKyBoZXhbM10sIGJhc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICByID0gcGFyc2VJbnQoaGV4WzFdICsgaGV4WzJdLCBiYXNlKTtcbiAgICAgIGcgPSBwYXJzZUludChoZXhbM10gKyBoZXhbNF0sIGJhc2UpO1xuICAgICAgYiA9IHBhcnNlSW50KGhleFs1XSArIGhleFs2XSwgYmFzZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtyLCBnLCBiXTtcbiAgfTsgLy8gZ2V0IFtyLCBnLCBiLCBhXSBmcm9tIGhzbCgwLCAwLCAwKSBvciBoc2xhKDAsIDAsIDAsIDApXG5cbiAgdmFyIGhzbDJ0dXBsZSA9IGZ1bmN0aW9uIGhzbDJ0dXBsZShoc2wpIHtcbiAgICB2YXIgcmV0O1xuICAgIHZhciBoLCBzLCBsLCBhLCByLCBnLCBiO1xuXG4gICAgZnVuY3Rpb24gaHVlMnJnYihwLCBxLCB0KSB7XG4gICAgICBpZiAodCA8IDApIHQgKz0gMTtcbiAgICAgIGlmICh0ID4gMSkgdCAtPSAxO1xuICAgICAgaWYgKHQgPCAxIC8gNikgcmV0dXJuIHAgKyAocSAtIHApICogNiAqIHQ7XG4gICAgICBpZiAodCA8IDEgLyAyKSByZXR1cm4gcTtcbiAgICAgIGlmICh0IDwgMiAvIDMpIHJldHVybiBwICsgKHEgLSBwKSAqICgyIC8gMyAtIHQpICogNjtcbiAgICAgIHJldHVybiBwO1xuICAgIH1cblxuICAgIHZhciBtID0gbmV3IFJlZ0V4cCgnXicgKyBoc2xhICsgJyQnKS5leGVjKGhzbCk7XG5cbiAgICBpZiAobSkge1xuICAgICAgLy8gZ2V0IGh1ZVxuICAgICAgaCA9IHBhcnNlSW50KG1bMV0pO1xuXG4gICAgICBpZiAoaCA8IDApIHtcbiAgICAgICAgaCA9ICgzNjAgLSAtMSAqIGggJSAzNjApICUgMzYwO1xuICAgICAgfSBlbHNlIGlmIChoID4gMzYwKSB7XG4gICAgICAgIGggPSBoICUgMzYwO1xuICAgICAgfVxuXG4gICAgICBoIC89IDM2MDsgLy8gbm9ybWFsaXNlIG9uIFswLCAxXVxuXG4gICAgICBzID0gcGFyc2VGbG9hdChtWzJdKTtcblxuICAgICAgaWYgKHMgPCAwIHx8IHMgPiAxMDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBzYXR1cmF0aW9uIGlzIFswLCAxMDBdXG5cblxuICAgICAgcyA9IHMgLyAxMDA7IC8vIG5vcm1hbGlzZSBvbiBbMCwgMV1cblxuICAgICAgbCA9IHBhcnNlRmxvYXQobVszXSk7XG5cbiAgICAgIGlmIChsIDwgMCB8fCBsID4gMTAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gbGlnaHRuZXNzIGlzIFswLCAxMDBdXG5cblxuICAgICAgbCA9IGwgLyAxMDA7IC8vIG5vcm1hbGlzZSBvbiBbMCwgMV1cblxuICAgICAgYSA9IG1bNF07XG5cbiAgICAgIGlmIChhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYSA9IHBhcnNlRmxvYXQoYSk7XG5cbiAgICAgICAgaWYgKGEgPCAwIHx8IGEgPiAxKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIGFscGhhIGlzIFswLCAxXVxuXG4gICAgICB9IC8vIG5vdywgY29udmVydCB0byByZ2JcbiAgICAgIC8vIGNvZGUgZnJvbSBodHRwOi8vbWppamFja3Nvbi5jb20vMjAwOC8wMi9yZ2ItdG8taHNsLWFuZC1yZ2ItdG8taHN2LWNvbG9yLW1vZGVsLWNvbnZlcnNpb24tYWxnb3JpdGhtcy1pbi1qYXZhc2NyaXB0XG5cblxuICAgICAgaWYgKHMgPT09IDApIHtcbiAgICAgICAgciA9IGcgPSBiID0gTWF0aC5yb3VuZChsICogMjU1KTsgLy8gYWNocm9tYXRpY1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHEgPSBsIDwgMC41ID8gbCAqICgxICsgcykgOiBsICsgcyAtIGwgKiBzO1xuICAgICAgICB2YXIgcCA9IDIgKiBsIC0gcTtcbiAgICAgICAgciA9IE1hdGgucm91bmQoMjU1ICogaHVlMnJnYihwLCBxLCBoICsgMSAvIDMpKTtcbiAgICAgICAgZyA9IE1hdGgucm91bmQoMjU1ICogaHVlMnJnYihwLCBxLCBoKSk7XG4gICAgICAgIGIgPSBNYXRoLnJvdW5kKDI1NSAqIGh1ZTJyZ2IocCwgcSwgaCAtIDEgLyAzKSk7XG4gICAgICB9XG5cbiAgICAgIHJldCA9IFtyLCBnLCBiLCBhXTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9OyAvLyBnZXQgW3IsIGcsIGIsIGFdIGZyb20gcmdiKDAsIDAsIDApIG9yIHJnYmEoMCwgMCwgMCwgMClcblxuICB2YXIgcmdiMnR1cGxlID0gZnVuY3Rpb24gcmdiMnR1cGxlKHJnYikge1xuICAgIHZhciByZXQ7XG4gICAgdmFyIG0gPSBuZXcgUmVnRXhwKCdeJyArIHJnYmEgKyAnJCcpLmV4ZWMocmdiKTtcblxuICAgIGlmIChtKSB7XG4gICAgICByZXQgPSBbXTtcbiAgICAgIHZhciBpc1BjdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSAzOyBpKyspIHtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSBtW2ldO1xuXG4gICAgICAgIGlmIChjaGFubmVsW2NoYW5uZWwubGVuZ3RoIC0gMV0gPT09ICclJykge1xuICAgICAgICAgIGlzUGN0W2ldID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoYW5uZWwgPSBwYXJzZUZsb2F0KGNoYW5uZWwpO1xuXG4gICAgICAgIGlmIChpc1BjdFtpXSkge1xuICAgICAgICAgIGNoYW5uZWwgPSBjaGFubmVsIC8gMTAwICogMjU1OyAvLyBub3JtYWxpc2UgdG8gWzAsIDI1NV1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaGFubmVsIDwgMCB8fCBjaGFubmVsID4gMjU1KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIGludmFsaWQgY2hhbm5lbCB2YWx1ZVxuXG5cbiAgICAgICAgcmV0LnB1c2goTWF0aC5mbG9vcihjaGFubmVsKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBhdExlYXN0T25lSXNQY3QgPSBpc1BjdFsxXSB8fCBpc1BjdFsyXSB8fCBpc1BjdFszXTtcbiAgICAgIHZhciBhbGxBcmVQY3QgPSBpc1BjdFsxXSAmJiBpc1BjdFsyXSAmJiBpc1BjdFszXTtcblxuICAgICAgaWYgKGF0TGVhc3RPbmVJc1BjdCAmJiAhYWxsQXJlUGN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gbXVzdCBhbGwgYmUgcGVyY2VudCB2YWx1ZXMgaWYgb25lIGlzXG5cblxuICAgICAgdmFyIGFscGhhID0gbVs0XTtcblxuICAgICAgaWYgKGFscGhhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYWxwaGEgPSBwYXJzZUZsb2F0KGFscGhhKTtcblxuICAgICAgICBpZiAoYWxwaGEgPCAwIHx8IGFscGhhID4gMSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBpbnZhbGlkIGFscGhhIHZhbHVlXG5cblxuICAgICAgICByZXQucHVzaChhbHBoYSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfTtcbiAgdmFyIGNvbG9ybmFtZTJ0dXBsZSA9IGZ1bmN0aW9uIGNvbG9ybmFtZTJ0dXBsZShjb2xvcikge1xuICAgIHJldHVybiBjb2xvcnNbY29sb3IudG9Mb3dlckNhc2UoKV07XG4gIH07XG4gIHZhciBjb2xvcjJ0dXBsZSA9IGZ1bmN0aW9uIGNvbG9yMnR1cGxlKGNvbG9yKSB7XG4gICAgcmV0dXJuIChhcnJheShjb2xvcikgPyBjb2xvciA6IG51bGwpIHx8IGNvbG9ybmFtZTJ0dXBsZShjb2xvcikgfHwgaGV4MnR1cGxlKGNvbG9yKSB8fCByZ2IydHVwbGUoY29sb3IpIHx8IGhzbDJ0dXBsZShjb2xvcik7XG4gIH07XG4gIHZhciBjb2xvcnMgPSB7XG4gICAgLy8gc3BlY2lhbCBjb2xvdXIgbmFtZXNcbiAgICB0cmFuc3BhcmVudDogWzAsIDAsIDAsIDBdLFxuICAgIC8vIE5CIGFscGhhID09PSAwXG4gICAgLy8gcmVndWxhciBjb2xvdXJzXG4gICAgYWxpY2VibHVlOiBbMjQwLCAyNDgsIDI1NV0sXG4gICAgYW50aXF1ZXdoaXRlOiBbMjUwLCAyMzUsIDIxNV0sXG4gICAgYXF1YTogWzAsIDI1NSwgMjU1XSxcbiAgICBhcXVhbWFyaW5lOiBbMTI3LCAyNTUsIDIxMl0sXG4gICAgYXp1cmU6IFsyNDAsIDI1NSwgMjU1XSxcbiAgICBiZWlnZTogWzI0NSwgMjQ1LCAyMjBdLFxuICAgIGJpc3F1ZTogWzI1NSwgMjI4LCAxOTZdLFxuICAgIGJsYWNrOiBbMCwgMCwgMF0sXG4gICAgYmxhbmNoZWRhbG1vbmQ6IFsyNTUsIDIzNSwgMjA1XSxcbiAgICBibHVlOiBbMCwgMCwgMjU1XSxcbiAgICBibHVldmlvbGV0OiBbMTM4LCA0MywgMjI2XSxcbiAgICBicm93bjogWzE2NSwgNDIsIDQyXSxcbiAgICBidXJseXdvb2Q6IFsyMjIsIDE4NCwgMTM1XSxcbiAgICBjYWRldGJsdWU6IFs5NSwgMTU4LCAxNjBdLFxuICAgIGNoYXJ0cmV1c2U6IFsxMjcsIDI1NSwgMF0sXG4gICAgY2hvY29sYXRlOiBbMjEwLCAxMDUsIDMwXSxcbiAgICBjb3JhbDogWzI1NSwgMTI3LCA4MF0sXG4gICAgY29ybmZsb3dlcmJsdWU6IFsxMDAsIDE0OSwgMjM3XSxcbiAgICBjb3Juc2lsazogWzI1NSwgMjQ4LCAyMjBdLFxuICAgIGNyaW1zb246IFsyMjAsIDIwLCA2MF0sXG4gICAgY3lhbjogWzAsIDI1NSwgMjU1XSxcbiAgICBkYXJrYmx1ZTogWzAsIDAsIDEzOV0sXG4gICAgZGFya2N5YW46IFswLCAxMzksIDEzOV0sXG4gICAgZGFya2dvbGRlbnJvZDogWzE4NCwgMTM0LCAxMV0sXG4gICAgZGFya2dyYXk6IFsxNjksIDE2OSwgMTY5XSxcbiAgICBkYXJrZ3JlZW46IFswLCAxMDAsIDBdLFxuICAgIGRhcmtncmV5OiBbMTY5LCAxNjksIDE2OV0sXG4gICAgZGFya2toYWtpOiBbMTg5LCAxODMsIDEwN10sXG4gICAgZGFya21hZ2VudGE6IFsxMzksIDAsIDEzOV0sXG4gICAgZGFya29saXZlZ3JlZW46IFs4NSwgMTA3LCA0N10sXG4gICAgZGFya29yYW5nZTogWzI1NSwgMTQwLCAwXSxcbiAgICBkYXJrb3JjaGlkOiBbMTUzLCA1MCwgMjA0XSxcbiAgICBkYXJrcmVkOiBbMTM5LCAwLCAwXSxcbiAgICBkYXJrc2FsbW9uOiBbMjMzLCAxNTAsIDEyMl0sXG4gICAgZGFya3NlYWdyZWVuOiBbMTQzLCAxODgsIDE0M10sXG4gICAgZGFya3NsYXRlYmx1ZTogWzcyLCA2MSwgMTM5XSxcbiAgICBkYXJrc2xhdGVncmF5OiBbNDcsIDc5LCA3OV0sXG4gICAgZGFya3NsYXRlZ3JleTogWzQ3LCA3OSwgNzldLFxuICAgIGRhcmt0dXJxdW9pc2U6IFswLCAyMDYsIDIwOV0sXG4gICAgZGFya3Zpb2xldDogWzE0OCwgMCwgMjExXSxcbiAgICBkZWVwcGluazogWzI1NSwgMjAsIDE0N10sXG4gICAgZGVlcHNreWJsdWU6IFswLCAxOTEsIDI1NV0sXG4gICAgZGltZ3JheTogWzEwNSwgMTA1LCAxMDVdLFxuICAgIGRpbWdyZXk6IFsxMDUsIDEwNSwgMTA1XSxcbiAgICBkb2RnZXJibHVlOiBbMzAsIDE0NCwgMjU1XSxcbiAgICBmaXJlYnJpY2s6IFsxNzgsIDM0LCAzNF0sXG4gICAgZmxvcmFsd2hpdGU6IFsyNTUsIDI1MCwgMjQwXSxcbiAgICBmb3Jlc3RncmVlbjogWzM0LCAxMzksIDM0XSxcbiAgICBmdWNoc2lhOiBbMjU1LCAwLCAyNTVdLFxuICAgIGdhaW5zYm9ybzogWzIyMCwgMjIwLCAyMjBdLFxuICAgIGdob3N0d2hpdGU6IFsyNDgsIDI0OCwgMjU1XSxcbiAgICBnb2xkOiBbMjU1LCAyMTUsIDBdLFxuICAgIGdvbGRlbnJvZDogWzIxOCwgMTY1LCAzMl0sXG4gICAgZ3JheTogWzEyOCwgMTI4LCAxMjhdLFxuICAgIGdyZXk6IFsxMjgsIDEyOCwgMTI4XSxcbiAgICBncmVlbjogWzAsIDEyOCwgMF0sXG4gICAgZ3JlZW55ZWxsb3c6IFsxNzMsIDI1NSwgNDddLFxuICAgIGhvbmV5ZGV3OiBbMjQwLCAyNTUsIDI0MF0sXG4gICAgaG90cGluazogWzI1NSwgMTA1LCAxODBdLFxuICAgIGluZGlhbnJlZDogWzIwNSwgOTIsIDkyXSxcbiAgICBpbmRpZ286IFs3NSwgMCwgMTMwXSxcbiAgICBpdm9yeTogWzI1NSwgMjU1LCAyNDBdLFxuICAgIGtoYWtpOiBbMjQwLCAyMzAsIDE0MF0sXG4gICAgbGF2ZW5kZXI6IFsyMzAsIDIzMCwgMjUwXSxcbiAgICBsYXZlbmRlcmJsdXNoOiBbMjU1LCAyNDAsIDI0NV0sXG4gICAgbGF3bmdyZWVuOiBbMTI0LCAyNTIsIDBdLFxuICAgIGxlbW9uY2hpZmZvbjogWzI1NSwgMjUwLCAyMDVdLFxuICAgIGxpZ2h0Ymx1ZTogWzE3MywgMjE2LCAyMzBdLFxuICAgIGxpZ2h0Y29yYWw6IFsyNDAsIDEyOCwgMTI4XSxcbiAgICBsaWdodGN5YW46IFsyMjQsIDI1NSwgMjU1XSxcbiAgICBsaWdodGdvbGRlbnJvZHllbGxvdzogWzI1MCwgMjUwLCAyMTBdLFxuICAgIGxpZ2h0Z3JheTogWzIxMSwgMjExLCAyMTFdLFxuICAgIGxpZ2h0Z3JlZW46IFsxNDQsIDIzOCwgMTQ0XSxcbiAgICBsaWdodGdyZXk6IFsyMTEsIDIxMSwgMjExXSxcbiAgICBsaWdodHBpbms6IFsyNTUsIDE4MiwgMTkzXSxcbiAgICBsaWdodHNhbG1vbjogWzI1NSwgMTYwLCAxMjJdLFxuICAgIGxpZ2h0c2VhZ3JlZW46IFszMiwgMTc4LCAxNzBdLFxuICAgIGxpZ2h0c2t5Ymx1ZTogWzEzNSwgMjA2LCAyNTBdLFxuICAgIGxpZ2h0c2xhdGVncmF5OiBbMTE5LCAxMzYsIDE1M10sXG4gICAgbGlnaHRzbGF0ZWdyZXk6IFsxMTksIDEzNiwgMTUzXSxcbiAgICBsaWdodHN0ZWVsYmx1ZTogWzE3NiwgMTk2LCAyMjJdLFxuICAgIGxpZ2h0eWVsbG93OiBbMjU1LCAyNTUsIDIyNF0sXG4gICAgbGltZTogWzAsIDI1NSwgMF0sXG4gICAgbGltZWdyZWVuOiBbNTAsIDIwNSwgNTBdLFxuICAgIGxpbmVuOiBbMjUwLCAyNDAsIDIzMF0sXG4gICAgbWFnZW50YTogWzI1NSwgMCwgMjU1XSxcbiAgICBtYXJvb246IFsxMjgsIDAsIDBdLFxuICAgIG1lZGl1bWFxdWFtYXJpbmU6IFsxMDIsIDIwNSwgMTcwXSxcbiAgICBtZWRpdW1ibHVlOiBbMCwgMCwgMjA1XSxcbiAgICBtZWRpdW1vcmNoaWQ6IFsxODYsIDg1LCAyMTFdLFxuICAgIG1lZGl1bXB1cnBsZTogWzE0NywgMTEyLCAyMTldLFxuICAgIG1lZGl1bXNlYWdyZWVuOiBbNjAsIDE3OSwgMTEzXSxcbiAgICBtZWRpdW1zbGF0ZWJsdWU6IFsxMjMsIDEwNCwgMjM4XSxcbiAgICBtZWRpdW1zcHJpbmdncmVlbjogWzAsIDI1MCwgMTU0XSxcbiAgICBtZWRpdW10dXJxdW9pc2U6IFs3MiwgMjA5LCAyMDRdLFxuICAgIG1lZGl1bXZpb2xldHJlZDogWzE5OSwgMjEsIDEzM10sXG4gICAgbWlkbmlnaHRibHVlOiBbMjUsIDI1LCAxMTJdLFxuICAgIG1pbnRjcmVhbTogWzI0NSwgMjU1LCAyNTBdLFxuICAgIG1pc3R5cm9zZTogWzI1NSwgMjI4LCAyMjVdLFxuICAgIG1vY2Nhc2luOiBbMjU1LCAyMjgsIDE4MV0sXG4gICAgbmF2YWpvd2hpdGU6IFsyNTUsIDIyMiwgMTczXSxcbiAgICBuYXZ5OiBbMCwgMCwgMTI4XSxcbiAgICBvbGRsYWNlOiBbMjUzLCAyNDUsIDIzMF0sXG4gICAgb2xpdmU6IFsxMjgsIDEyOCwgMF0sXG4gICAgb2xpdmVkcmFiOiBbMTA3LCAxNDIsIDM1XSxcbiAgICBvcmFuZ2U6IFsyNTUsIDE2NSwgMF0sXG4gICAgb3JhbmdlcmVkOiBbMjU1LCA2OSwgMF0sXG4gICAgb3JjaGlkOiBbMjE4LCAxMTIsIDIxNF0sXG4gICAgcGFsZWdvbGRlbnJvZDogWzIzOCwgMjMyLCAxNzBdLFxuICAgIHBhbGVncmVlbjogWzE1MiwgMjUxLCAxNTJdLFxuICAgIHBhbGV0dXJxdW9pc2U6IFsxNzUsIDIzOCwgMjM4XSxcbiAgICBwYWxldmlvbGV0cmVkOiBbMjE5LCAxMTIsIDE0N10sXG4gICAgcGFwYXlhd2hpcDogWzI1NSwgMjM5LCAyMTNdLFxuICAgIHBlYWNocHVmZjogWzI1NSwgMjE4LCAxODVdLFxuICAgIHBlcnU6IFsyMDUsIDEzMywgNjNdLFxuICAgIHBpbms6IFsyNTUsIDE5MiwgMjAzXSxcbiAgICBwbHVtOiBbMjIxLCAxNjAsIDIyMV0sXG4gICAgcG93ZGVyYmx1ZTogWzE3NiwgMjI0LCAyMzBdLFxuICAgIHB1cnBsZTogWzEyOCwgMCwgMTI4XSxcbiAgICByZWQ6IFsyNTUsIDAsIDBdLFxuICAgIHJvc3licm93bjogWzE4OCwgMTQzLCAxNDNdLFxuICAgIHJveWFsYmx1ZTogWzY1LCAxMDUsIDIyNV0sXG4gICAgc2FkZGxlYnJvd246IFsxMzksIDY5LCAxOV0sXG4gICAgc2FsbW9uOiBbMjUwLCAxMjgsIDExNF0sXG4gICAgc2FuZHlicm93bjogWzI0NCwgMTY0LCA5Nl0sXG4gICAgc2VhZ3JlZW46IFs0NiwgMTM5LCA4N10sXG4gICAgc2Vhc2hlbGw6IFsyNTUsIDI0NSwgMjM4XSxcbiAgICBzaWVubmE6IFsxNjAsIDgyLCA0NV0sXG4gICAgc2lsdmVyOiBbMTkyLCAxOTIsIDE5Ml0sXG4gICAgc2t5Ymx1ZTogWzEzNSwgMjA2LCAyMzVdLFxuICAgIHNsYXRlYmx1ZTogWzEwNiwgOTAsIDIwNV0sXG4gICAgc2xhdGVncmF5OiBbMTEyLCAxMjgsIDE0NF0sXG4gICAgc2xhdGVncmV5OiBbMTEyLCAxMjgsIDE0NF0sXG4gICAgc25vdzogWzI1NSwgMjUwLCAyNTBdLFxuICAgIHNwcmluZ2dyZWVuOiBbMCwgMjU1LCAxMjddLFxuICAgIHN0ZWVsYmx1ZTogWzcwLCAxMzAsIDE4MF0sXG4gICAgdGFuOiBbMjEwLCAxODAsIDE0MF0sXG4gICAgdGVhbDogWzAsIDEyOCwgMTI4XSxcbiAgICB0aGlzdGxlOiBbMjE2LCAxOTEsIDIxNl0sXG4gICAgdG9tYXRvOiBbMjU1LCA5OSwgNzFdLFxuICAgIHR1cnF1b2lzZTogWzY0LCAyMjQsIDIwOF0sXG4gICAgdmlvbGV0OiBbMjM4LCAxMzAsIDIzOF0sXG4gICAgd2hlYXQ6IFsyNDUsIDIyMiwgMTc5XSxcbiAgICB3aGl0ZTogWzI1NSwgMjU1LCAyNTVdLFxuICAgIHdoaXRlc21va2U6IFsyNDUsIDI0NSwgMjQ1XSxcbiAgICB5ZWxsb3c6IFsyNTUsIDI1NSwgMF0sXG4gICAgeWVsbG93Z3JlZW46IFsxNTQsIDIwNSwgNTBdXG4gIH07XG5cbiAgdmFyIHNldE1hcCA9IGZ1bmN0aW9uIHNldE1hcChvcHRpb25zKSB7XG4gICAgdmFyIG9iaiA9IG9wdGlvbnMubWFwO1xuICAgIHZhciBrZXlzID0gb3B0aW9ucy5rZXlzO1xuICAgIHZhciBsID0ga2V5cy5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmIChwbGFpbk9iamVjdChrZXkpKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdUcmllZCB0byBzZXQgbWFwIHdpdGggb2JqZWN0IGtleScpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaSA8IGtleXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAvLyBleHRlbmQgdGhlIG1hcCBpZiBuZWNlc3NhcnlcbiAgICAgICAgaWYgKG9ialtrZXldID09IG51bGwpIHtcbiAgICAgICAgICBvYmpba2V5XSA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqID0gb2JqW2tleV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzZXQgdGhlIHZhbHVlXG4gICAgICAgIG9ialtrZXldID0gb3B0aW9ucy52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH07IC8vIGdldHMgdGhlIHZhbHVlIGluIGEgbWFwIGV2ZW4gaWYgaXQncyBub3QgYnVpbHQgaW4gcGxhY2VzXG5cbiAgdmFyIGdldE1hcCA9IGZ1bmN0aW9uIGdldE1hcChvcHRpb25zKSB7XG4gICAgdmFyIG9iaiA9IG9wdGlvbnMubWFwO1xuICAgIHZhciBrZXlzID0gb3B0aW9ucy5rZXlzO1xuICAgIHZhciBsID0ga2V5cy5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmIChwbGFpbk9iamVjdChrZXkpKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdUcmllZCB0byBnZXQgbWFwIHdpdGggb2JqZWN0IGtleScpO1xuICAgICAgfVxuXG4gICAgICBvYmogPSBvYmpba2V5XTtcblxuICAgICAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbiAgfTsgLy8gZGVsZXRlcyB0aGUgZW50cnkgaW4gdGhlIG1hcFxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAgICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICAgKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDAuMS4wXG4gICAqIEBjYXRlZ29yeSBMYW5nXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5pc09iamVjdCh7fSk7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmlzT2JqZWN0KG51bGwpO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKi9cbiAgZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xuICB9XG5cbiAgdmFyIGlzT2JqZWN0XzEgPSBpc09iamVjdDtcblxuICB2YXIgY29tbW9uanNHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fTtcblxuICBmdW5jdGlvbiBjcmVhdGVDb21tb25qc01vZHVsZShmbiwgbW9kdWxlKSB7XG4gIFx0cmV0dXJuIG1vZHVsZSA9IHsgZXhwb3J0czoge30gfSwgZm4obW9kdWxlLCBtb2R1bGUuZXhwb3J0cyksIG1vZHVsZS5leHBvcnRzO1xuICB9XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbiAgdmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgY29tbW9uanNHbG9iYWwgPT0gJ29iamVjdCcgJiYgY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgY29tbW9uanNHbG9iYWw7XG5cbiAgdmFyIF9mcmVlR2xvYmFsID0gZnJlZUdsb2JhbDtcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xuICB2YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuICAvKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbiAgdmFyIHJvb3QgPSBfZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4gIHZhciBfcm9vdCA9IHJvb3Q7XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHRpbWVzdGFtcCBvZiB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IGhhdmUgZWxhcHNlZCBzaW5jZVxuICAgKiB0aGUgVW5peCBlcG9jaCAoMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgMi40LjBcbiAgICogQGNhdGVnb3J5IERhdGVcbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXN0YW1wLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLmRlZmVyKGZ1bmN0aW9uKHN0YW1wKSB7XG4gICAqICAgY29uc29sZS5sb2coXy5ub3coKSAtIHN0YW1wKTtcbiAgICogfSwgXy5ub3coKSk7XG4gICAqIC8vID0+IExvZ3MgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaXQgdG9vayBmb3IgdGhlIGRlZmVycmVkIGludm9jYXRpb24uXG4gICAqL1xuICB2YXIgbm93ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIF9yb290LkRhdGUubm93KCk7XG4gIH07XG5cbiAgdmFyIG5vd18xID0gbm93O1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGEgc2luZ2xlIHdoaXRlc3BhY2UgY2hhcmFjdGVyLiAqL1xuICB2YXIgcmVXaGl0ZXNwYWNlID0gL1xccy87XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8udHJpbWAgYW5kIGBfLnRyaW1FbmRgIHRvIGdldCB0aGUgaW5kZXggb2YgdGhlIGxhc3Qgbm9uLXdoaXRlc3BhY2VcbiAgICogY2hhcmFjdGVyIG9mIGBzdHJpbmdgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGxhc3Qgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVyLlxuICAgKi9cbiAgZnVuY3Rpb24gdHJpbW1lZEVuZEluZGV4KHN0cmluZykge1xuICAgIHZhciBpbmRleCA9IHN0cmluZy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaW5kZXgtLSAmJiByZVdoaXRlc3BhY2UudGVzdChzdHJpbmcuY2hhckF0KGluZGV4KSkpIHt9XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgdmFyIF90cmltbWVkRW5kSW5kZXggPSB0cmltbWVkRW5kSW5kZXg7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyB3aGl0ZXNwYWNlLiAqL1xuICB2YXIgcmVUcmltU3RhcnQgPSAvXlxccysvO1xuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50cmltYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIHRyaW0uXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRyaW1tZWQgc3RyaW5nLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVRyaW0oc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZ1xuICAgICAgPyBzdHJpbmcuc2xpY2UoMCwgX3RyaW1tZWRFbmRJbmRleChzdHJpbmcpICsgMSkucmVwbGFjZShyZVRyaW1TdGFydCwgJycpXG4gICAgICA6IHN0cmluZztcbiAgfVxuXG4gIHZhciBfYmFzZVRyaW0gPSBiYXNlVHJpbTtcblxuICAvKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbiAgdmFyIFN5bWJvbCQxID0gX3Jvb3QuU3ltYm9sO1xuXG4gIHZhciBfU3ltYm9sID0gU3ltYm9sJDE7XG5cbiAgLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuICB2YXIgb2JqZWN0UHJvdG8kNSA9IE9iamVjdC5wcm90b3R5cGU7XG5cbiAgLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG4gIHZhciBoYXNPd25Qcm9wZXJ0eSQ0ID0gb2JqZWN0UHJvdG8kNS5oYXNPd25Qcm9wZXJ0eTtcblxuICAvKipcbiAgICogVXNlZCB0byByZXNvbHZlIHRoZVxuICAgKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAgICogb2YgdmFsdWVzLlxuICAgKi9cbiAgdmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nJDEgPSBvYmplY3RQcm90byQ1LnRvU3RyaW5nO1xuXG4gIC8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xuICB2YXIgc3ltVG9TdHJpbmdUYWckMSA9IF9TeW1ib2wgPyBfU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eSQ0LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnJDEpLFxuICAgICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZyQxXTtcblxuICAgIHRyeSB7XG4gICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZyQxXSA9IHVuZGVmaW5lZDtcbiAgICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gICAgfSBjYXRjaCAoZSkge31cblxuICAgIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZyQxLmNhbGwodmFsdWUpO1xuICAgIGlmICh1bm1hc2tlZCkge1xuICAgICAgaWYgKGlzT3duKSB7XG4gICAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnJDFdID0gdGFnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnJDFdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIF9nZXRSYXdUYWcgPSBnZXRSYXdUYWc7XG5cbiAgLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuICB2YXIgb2JqZWN0UHJvdG8kNCA9IE9iamVjdC5wcm90b3R5cGU7XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAgICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gICAqIG9mIHZhbHVlcy5cbiAgICovXG4gIHZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvJDQudG9TdHJpbmc7XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICAgKi9cbiAgZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICB2YXIgX29iamVjdFRvU3RyaW5nID0gb2JqZWN0VG9TdHJpbmc7XG5cbiAgLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xuICB2YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nO1xuXG4gIC8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xuICB2YXIgc3ltVG9TdHJpbmdUYWcgPSBfU3ltYm9sID8gX1N5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgICB9XG4gICAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgICAgPyBfZ2V0UmF3VGFnKHZhbHVlKVxuICAgICAgOiBfb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xuICB9XG5cbiAgdmFyIF9iYXNlR2V0VGFnID0gYmFzZUdldFRhZztcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gICAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgNC4wLjBcbiAgICogQGNhdGVnb3J5IExhbmdcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqXG4gICAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKi9cbiAgZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xuICB9XG5cbiAgdmFyIGlzT2JqZWN0TGlrZV8xID0gaXNPYmplY3RMaWtlO1xuXG4gIC8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbiAgdmFyIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgNC4wLjBcbiAgICogQGNhdGVnb3J5IExhbmdcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICovXG4gIGZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgICAgKGlzT2JqZWN0TGlrZV8xKHZhbHVlKSAmJiBfYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbiAgfVxuXG4gIHZhciBpc1N5bWJvbF8xID0gaXNTeW1ib2w7XG5cbiAgLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG4gIHZhciBOQU4gPSAwIC8gMDtcblxuICAvKiogVXNlZCB0byBkZXRlY3QgYmFkIHNpZ25lZCBoZXhhZGVjaW1hbCBzdHJpbmcgdmFsdWVzLiAqL1xuICB2YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBiaW5hcnkgc3RyaW5nIHZhbHVlcy4gKi9cbiAgdmFyIHJlSXNCaW5hcnkgPSAvXjBiWzAxXSskL2k7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IG9jdGFsIHN0cmluZyB2YWx1ZXMuICovXG4gIHZhciByZUlzT2N0YWwgPSAvXjBvWzAtN10rJC9pO1xuXG4gIC8qKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB3aXRob3V0IGEgZGVwZW5kZW5jeSBvbiBgcm9vdGAuICovXG4gIHZhciBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDtcblxuICAvKipcbiAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgNC4wLjBcbiAgICogQGNhdGVnb3J5IExhbmdcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbnVtYmVyLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLnRvTnVtYmVyKDMuMik7XG4gICAqIC8vID0+IDMuMlxuICAgKlxuICAgKiBfLnRvTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xuICAgKiAvLyA9PiA1ZS0zMjRcbiAgICpcbiAgICogXy50b051bWJlcihJbmZpbml0eSk7XG4gICAqIC8vID0+IEluZmluaXR5XG4gICAqXG4gICAqIF8udG9OdW1iZXIoJzMuMicpO1xuICAgKiAvLyA9PiAzLjJcbiAgICovXG4gIGZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAoaXNTeW1ib2xfMSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBOQU47XG4gICAgfVxuICAgIGlmIChpc09iamVjdF8xKHZhbHVlKSkge1xuICAgICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuICAgICAgdmFsdWUgPSBpc09iamVjdF8xKG90aGVyKSA/IChvdGhlciArICcnKSA6IG90aGVyO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6ICt2YWx1ZTtcbiAgICB9XG4gICAgdmFsdWUgPSBfYmFzZVRyaW0odmFsdWUpO1xuICAgIHZhciBpc0JpbmFyeSA9IHJlSXNCaW5hcnkudGVzdCh2YWx1ZSk7XG4gICAgcmV0dXJuIChpc0JpbmFyeSB8fCByZUlzT2N0YWwudGVzdCh2YWx1ZSkpXG4gICAgICA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOClcbiAgICAgIDogKHJlSXNCYWRIZXgudGVzdCh2YWx1ZSkgPyBOQU4gOiArdmFsdWUpO1xuICB9XG5cbiAgdmFyIHRvTnVtYmVyXzEgPSB0b051bWJlcjtcblxuICAvKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG4gIHZhciBGVU5DX0VSUk9SX1RFWFQkMSA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuICAvKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG4gIHZhciBuYXRpdmVNYXggPSBNYXRoLm1heCxcbiAgICAgIG5hdGl2ZU1pbiA9IE1hdGgubWluO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZGVib3VuY2VkIGZ1bmN0aW9uIHRoYXQgZGVsYXlzIGludm9raW5nIGBmdW5jYCB1bnRpbCBhZnRlciBgd2FpdGBcbiAgICogbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gd2FzXG4gICAqIGludm9rZWQuIFRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgIG1ldGhvZCB0byBjYW5jZWxcbiAgICogZGVsYXllZCBgZnVuY2AgaW52b2NhdGlvbnMgYW5kIGEgYGZsdXNoYCBtZXRob2QgdG8gaW1tZWRpYXRlbHkgaW52b2tlIHRoZW0uXG4gICAqIFByb3ZpZGUgYG9wdGlvbnNgIHRvIGluZGljYXRlIHdoZXRoZXIgYGZ1bmNgIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZVxuICAgKiBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGAgdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkXG4gICAqIHdpdGggdGhlIGxhc3QgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24uIFN1YnNlcXVlbnRcbiAgICogY2FsbHMgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbiByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2BcbiAgICogaW52b2NhdGlvbi5cbiAgICpcbiAgICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpc1xuICAgKiBpbnZva2VkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIGRlYm91bmNlZCBmdW5jdGlvblxuICAgKiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gICAqXG4gICAqIElmIGB3YWl0YCBpcyBgMGAgYW5kIGBsZWFkaW5nYCBpcyBgZmFsc2VgLCBgZnVuY2AgaW52b2NhdGlvbiBpcyBkZWZlcnJlZFxuICAgKiB1bnRpbCB0byB0aGUgbmV4dCB0aWNrLCBzaW1pbGFyIHRvIGBzZXRUaW1lb3V0YCB3aXRoIGEgdGltZW91dCBvZiBgMGAuXG4gICAqXG4gICAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwczovL2Nzcy10cmlja3MuY29tL2RlYm91bmNpbmctdGhyb3R0bGluZy1leHBsYWluZWQtZXhhbXBsZXMvKVxuICAgKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLmRlYm91bmNlYCBhbmQgYF8udGhyb3R0bGVgLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSAwLjEuMFxuICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVib3VuY2UuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheS5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz1mYWxzZV1cbiAgICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heFdhaXRdXG4gICAqICBUaGUgbWF4aW11bSB0aW1lIGBmdW5jYCBpcyBhbGxvd2VkIHRvIGJlIGRlbGF5ZWQgYmVmb3JlIGl0J3MgaW52b2tlZC5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxuICAgKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZGVib3VuY2VkIGZ1bmN0aW9uLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAvLyBBdm9pZCBjb3N0bHkgY2FsY3VsYXRpb25zIHdoaWxlIHRoZSB3aW5kb3cgc2l6ZSBpcyBpbiBmbHV4LlxuICAgKiBqUXVlcnkod2luZG93KS5vbigncmVzaXplJywgXy5kZWJvdW5jZShjYWxjdWxhdGVMYXlvdXQsIDE1MCkpO1xuICAgKlxuICAgKiAvLyBJbnZva2UgYHNlbmRNYWlsYCB3aGVuIGNsaWNrZWQsIGRlYm91bmNpbmcgc3Vic2VxdWVudCBjYWxscy5cbiAgICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIF8uZGVib3VuY2Uoc2VuZE1haWwsIDMwMCwge1xuICAgKiAgICdsZWFkaW5nJzogdHJ1ZSxcbiAgICogICAndHJhaWxpbmcnOiBmYWxzZVxuICAgKiB9KSk7XG4gICAqXG4gICAqIC8vIEVuc3VyZSBgYmF0Y2hMb2dgIGlzIGludm9rZWQgb25jZSBhZnRlciAxIHNlY29uZCBvZiBkZWJvdW5jZWQgY2FsbHMuXG4gICAqIHZhciBkZWJvdW5jZWQgPSBfLmRlYm91bmNlKGJhdGNoTG9nLCAyNTAsIHsgJ21heFdhaXQnOiAxMDAwIH0pO1xuICAgKiB2YXIgc291cmNlID0gbmV3IEV2ZW50U291cmNlKCcvc3RyZWFtJyk7XG4gICAqIGpRdWVyeShzb3VyY2UpLm9uKCdtZXNzYWdlJywgZGVib3VuY2VkKTtcbiAgICpcbiAgICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyBkZWJvdW5jZWQgaW52b2NhdGlvbi5cbiAgICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgZGVib3VuY2VkLmNhbmNlbCk7XG4gICAqL1xuICBmdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gICAgdmFyIGxhc3RBcmdzLFxuICAgICAgICBsYXN0VGhpcyxcbiAgICAgICAgbWF4V2FpdCxcbiAgICAgICAgcmVzdWx0LFxuICAgICAgICB0aW1lcklkLFxuICAgICAgICBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIGxhc3RJbnZva2VUaW1lID0gMCxcbiAgICAgICAgbGVhZGluZyA9IGZhbHNlLFxuICAgICAgICBtYXhpbmcgPSBmYWxzZSxcbiAgICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUJDEpO1xuICAgIH1cbiAgICB3YWl0ID0gdG9OdW1iZXJfMSh3YWl0KSB8fCAwO1xuICAgIGlmIChpc09iamVjdF8xKG9wdGlvbnMpKSB7XG4gICAgICBsZWFkaW5nID0gISFvcHRpb25zLmxlYWRpbmc7XG4gICAgICBtYXhpbmcgPSAnbWF4V2FpdCcgaW4gb3B0aW9ucztcbiAgICAgIG1heFdhaXQgPSBtYXhpbmcgPyBuYXRpdmVNYXgodG9OdW1iZXJfMShvcHRpb25zLm1heFdhaXQpIHx8IDAsIHdhaXQpIDogbWF4V2FpdDtcbiAgICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW52b2tlRnVuYyh0aW1lKSB7XG4gICAgICB2YXIgYXJncyA9IGxhc3RBcmdzLFxuICAgICAgICAgIHRoaXNBcmcgPSBsYXN0VGhpcztcblxuICAgICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcbiAgICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxlYWRpbmdFZGdlKHRpbWUpIHtcbiAgICAgIC8vIFJlc2V0IGFueSBgbWF4V2FpdGAgdGltZXIuXG4gICAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgICAvLyBTdGFydCB0aGUgdGltZXIgZm9yIHRoZSB0cmFpbGluZyBlZGdlLlxuICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgIC8vIEludm9rZSB0aGUgbGVhZGluZyBlZGdlLlxuICAgICAgcmV0dXJuIGxlYWRpbmcgPyBpbnZva2VGdW5jKHRpbWUpIDogcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbWFpbmluZ1dhaXQodGltZSkge1xuICAgICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgICB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lLFxuICAgICAgICAgIHRpbWVXYWl0aW5nID0gd2FpdCAtIHRpbWVTaW5jZUxhc3RDYWxsO1xuXG4gICAgICByZXR1cm4gbWF4aW5nXG4gICAgICAgID8gbmF0aXZlTWluKHRpbWVXYWl0aW5nLCBtYXhXYWl0IC0gdGltZVNpbmNlTGFzdEludm9rZSlcbiAgICAgICAgOiB0aW1lV2FpdGluZztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzaG91bGRJbnZva2UodGltZSkge1xuICAgICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgICB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lO1xuXG4gICAgICAvLyBFaXRoZXIgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbCwgYWN0aXZpdHkgaGFzIHN0b3BwZWQgYW5kIHdlJ3JlIGF0IHRoZVxuICAgICAgLy8gdHJhaWxpbmcgZWRnZSwgdGhlIHN5c3RlbSB0aW1lIGhhcyBnb25lIGJhY2t3YXJkcyBhbmQgd2UncmUgdHJlYXRpbmdcbiAgICAgIC8vIGl0IGFzIHRoZSB0cmFpbGluZyBlZGdlLCBvciB3ZSd2ZSBoaXQgdGhlIGBtYXhXYWl0YCBsaW1pdC5cbiAgICAgIHJldHVybiAobGFzdENhbGxUaW1lID09PSB1bmRlZmluZWQgfHwgKHRpbWVTaW5jZUxhc3RDYWxsID49IHdhaXQpIHx8XG4gICAgICAgICh0aW1lU2luY2VMYXN0Q2FsbCA8IDApIHx8IChtYXhpbmcgJiYgdGltZVNpbmNlTGFzdEludm9rZSA+PSBtYXhXYWl0KSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdGltZXJFeHBpcmVkKCkge1xuICAgICAgdmFyIHRpbWUgPSBub3dfMSgpO1xuICAgICAgaWYgKHNob3VsZEludm9rZSh0aW1lKSkge1xuICAgICAgICByZXR1cm4gdHJhaWxpbmdFZGdlKHRpbWUpO1xuICAgICAgfVxuICAgICAgLy8gUmVzdGFydCB0aGUgdGltZXIuXG4gICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHJlbWFpbmluZ1dhaXQodGltZSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyYWlsaW5nRWRnZSh0aW1lKSB7XG4gICAgICB0aW1lcklkID0gdW5kZWZpbmVkO1xuXG4gICAgICAvLyBPbmx5IGludm9rZSBpZiB3ZSBoYXZlIGBsYXN0QXJnc2Agd2hpY2ggbWVhbnMgYGZ1bmNgIGhhcyBiZWVuXG4gICAgICAvLyBkZWJvdW5jZWQgYXQgbGVhc3Qgb25jZS5cbiAgICAgIGlmICh0cmFpbGluZyAmJiBsYXN0QXJncykge1xuICAgICAgICByZXR1cm4gaW52b2tlRnVuYyh0aW1lKTtcbiAgICAgIH1cbiAgICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICAgIGlmICh0aW1lcklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgICAgfVxuICAgICAgbGFzdEludm9rZVRpbWUgPSAwO1xuICAgICAgbGFzdEFyZ3MgPSBsYXN0Q2FsbFRpbWUgPSBsYXN0VGhpcyA9IHRpbWVySWQgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgICByZXR1cm4gdGltZXJJZCA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogdHJhaWxpbmdFZGdlKG5vd18xKCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICAgIHZhciB0aW1lID0gbm93XzEoKSxcbiAgICAgICAgICBpc0ludm9raW5nID0gc2hvdWxkSW52b2tlKHRpbWUpO1xuXG4gICAgICBsYXN0QXJncyA9IGFyZ3VtZW50cztcbiAgICAgIGxhc3RUaGlzID0gdGhpcztcbiAgICAgIGxhc3RDYWxsVGltZSA9IHRpbWU7XG5cbiAgICAgIGlmIChpc0ludm9raW5nKSB7XG4gICAgICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gbGVhZGluZ0VkZ2UobGFzdENhbGxUaW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF4aW5nKSB7XG4gICAgICAgICAgLy8gSGFuZGxlIGludm9jYXRpb25zIGluIGEgdGlnaHQgbG9vcC5cbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgICByZXR1cm4gaW52b2tlRnVuYyhsYXN0Q2FsbFRpbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xuICAgIGRlYm91bmNlZC5mbHVzaCA9IGZsdXNoO1xuICAgIHJldHVybiBkZWJvdW5jZWQ7XG4gIH1cblxuICB2YXIgZGVib3VuY2VfMSA9IGRlYm91bmNlO1xuXG4gIHZhciBwZXJmb3JtYW5jZSA9IHdpbmRvdyQxID8gd2luZG93JDEucGVyZm9ybWFuY2UgOiBudWxsO1xuICB2YXIgcG5vdyA9IHBlcmZvcm1hbmNlICYmIHBlcmZvcm1hbmNlLm5vdyA/IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7XG4gIH0gOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIERhdGUubm93KCk7XG4gIH07XG5cbiAgdmFyIHJhZiA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAod2luZG93JDEpIHtcbiAgICAgIGlmICh3aW5kb3ckMS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgIHdpbmRvdyQxLnJlcXVlc3RBbmltYXRpb25GcmFtZShmbik7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKHdpbmRvdyQxLm1velJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgd2luZG93JDEubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZuKTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAod2luZG93JDEud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICB3aW5kb3ckMS53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZm4pO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmICh3aW5kb3ckMS5tc1JlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgd2luZG93JDEubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZm4pO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgIGlmIChmbikge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBmbihwbm93KCkpO1xuICAgICAgICB9LCAxMDAwIC8gNjApO1xuICAgICAgfVxuICAgIH07XG4gIH0oKTtcblxuICB2YXIgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZuKSB7XG4gICAgcmV0dXJuIHJhZihmbik7XG4gIH07XG4gIHZhciBwZXJmb3JtYW5jZU5vdyA9IHBub3c7XG5cbiAgdmFyIERFRkFVTFRfSEFTSF9TRUVEID0gOTI2MTtcbiAgdmFyIEsgPSA2NTU5OTsgLy8gMzcgYWxzbyB3b3JrcyBwcmV0dHkgd2VsbFxuXG4gIHZhciBERUZBVUxUX0hBU0hfU0VFRF9BTFQgPSA1MzgxO1xuICB2YXIgaGFzaEl0ZXJhYmxlSW50cyA9IGZ1bmN0aW9uIGhhc2hJdGVyYWJsZUludHMoaXRlcmF0b3IpIHtcbiAgICB2YXIgc2VlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogREVGQVVMVF9IQVNIX1NFRUQ7XG4gICAgLy8gc2RibS9zdHJpbmctaGFzaFxuICAgIHZhciBoYXNoID0gc2VlZDtcbiAgICB2YXIgZW50cnk7XG5cbiAgICBmb3IgKDs7KSB7XG4gICAgICBlbnRyeSA9IGl0ZXJhdG9yLm5leHQoKTtcblxuICAgICAgaWYgKGVudHJ5LmRvbmUpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGhhc2ggPSBoYXNoICogSyArIGVudHJ5LnZhbHVlIHwgMDtcbiAgICB9XG5cbiAgICByZXR1cm4gaGFzaDtcbiAgfTtcbiAgdmFyIGhhc2hJbnQgPSBmdW5jdGlvbiBoYXNoSW50KG51bSkge1xuICAgIHZhciBzZWVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBERUZBVUxUX0hBU0hfU0VFRDtcbiAgICAvLyBzZGJtL3N0cmluZy1oYXNoXG4gICAgcmV0dXJuIHNlZWQgKiBLICsgbnVtIHwgMDtcbiAgfTtcbiAgdmFyIGhhc2hJbnRBbHQgPSBmdW5jdGlvbiBoYXNoSW50QWx0KG51bSkge1xuICAgIHZhciBzZWVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBERUZBVUxUX0hBU0hfU0VFRF9BTFQ7XG4gICAgLy8gZGpiMi9zdHJpbmctaGFzaFxuICAgIHJldHVybiAoc2VlZCA8PCA1KSArIHNlZWQgKyBudW0gfCAwO1xuICB9O1xuICB2YXIgY29tYmluZUhhc2hlcyA9IGZ1bmN0aW9uIGNvbWJpbmVIYXNoZXMoaGFzaDEsIGhhc2gyKSB7XG4gICAgcmV0dXJuIGhhc2gxICogMHgyMDAwMDAgKyBoYXNoMjtcbiAgfTtcbiAgdmFyIGNvbWJpbmVIYXNoZXNBcnJheSA9IGZ1bmN0aW9uIGNvbWJpbmVIYXNoZXNBcnJheShoYXNoZXMpIHtcbiAgICByZXR1cm4gaGFzaGVzWzBdICogMHgyMDAwMDAgKyBoYXNoZXNbMV07XG4gIH07XG4gIHZhciBoYXNoQXJyYXlzID0gZnVuY3Rpb24gaGFzaEFycmF5cyhoYXNoZXMxLCBoYXNoZXMyKSB7XG4gICAgcmV0dXJuIFtoYXNoSW50KGhhc2hlczFbMF0sIGhhc2hlczJbMF0pLCBoYXNoSW50QWx0KGhhc2hlczFbMV0sIGhhc2hlczJbMV0pXTtcbiAgfTtcbiAgdmFyIGhhc2hJbnRzQXJyYXkgPSBmdW5jdGlvbiBoYXNoSW50c0FycmF5KGludHMsIHNlZWQpIHtcbiAgICB2YXIgZW50cnkgPSB7XG4gICAgICB2YWx1ZTogMCxcbiAgICAgIGRvbmU6IGZhbHNlXG4gICAgfTtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxlbmd0aCA9IGludHMubGVuZ3RoO1xuICAgIHZhciBpdGVyYXRvciA9IHtcbiAgICAgIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgIGlmIChpIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgZW50cnkudmFsdWUgPSBpbnRzW2krK107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW50cnkuZG9uZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZW50cnk7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gaGFzaEl0ZXJhYmxlSW50cyhpdGVyYXRvciwgc2VlZCk7XG4gIH07XG4gIHZhciBoYXNoU3RyaW5nID0gZnVuY3Rpb24gaGFzaFN0cmluZyhzdHIsIHNlZWQpIHtcbiAgICB2YXIgZW50cnkgPSB7XG4gICAgICB2YWx1ZTogMCxcbiAgICAgIGRvbmU6IGZhbHNlXG4gICAgfTtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gICAgdmFyIGl0ZXJhdG9yID0ge1xuICAgICAgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgaWYgKGkgPCBsZW5ndGgpIHtcbiAgICAgICAgICBlbnRyeS52YWx1ZSA9IHN0ci5jaGFyQ29kZUF0KGkrKyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW50cnkuZG9uZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZW50cnk7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gaGFzaEl0ZXJhYmxlSW50cyhpdGVyYXRvciwgc2VlZCk7XG4gIH07XG4gIHZhciBoYXNoU3RyaW5ncyA9IGZ1bmN0aW9uIGhhc2hTdHJpbmdzKCkge1xuICAgIHJldHVybiBoYXNoU3RyaW5nc0FycmF5KGFyZ3VtZW50cyk7XG4gIH07XG4gIHZhciBoYXNoU3RyaW5nc0FycmF5ID0gZnVuY3Rpb24gaGFzaFN0cmluZ3NBcnJheShzdHJzKSB7XG4gICAgdmFyIGhhc2g7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzdHIgPSBzdHJzW2ldO1xuXG4gICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICBoYXNoID0gaGFzaFN0cmluZyhzdHIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFzaCA9IGhhc2hTdHJpbmcoc3RyLCBoYXNoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaGFzaDtcbiAgfTtcblxuICAvKmdsb2JhbCBjb25zb2xlICovXG4gIHZhciB3YXJuaW5nc0VuYWJsZWQgPSB0cnVlO1xuICB2YXIgd2FyblN1cHBvcnRlZCA9IGNvbnNvbGUud2FybiAhPSBudWxsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcblxuICB2YXIgdHJhY2VTdXBwb3J0ZWQgPSBjb25zb2xlLnRyYWNlICE9IG51bGw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuXG4gIHZhciBNQVhfSU5UJDEgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB8fCA5MDA3MTk5MjU0NzQwOTkxO1xuICB2YXIgdHJ1ZWlmeSA9IGZ1bmN0aW9uIHRydWVpZnkoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG4gIHZhciBmYWxzaWZ5ID0gZnVuY3Rpb24gZmFsc2lmeSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG4gIHZhciB6ZXJvaWZ5ID0gZnVuY3Rpb24gemVyb2lmeSgpIHtcbiAgICByZXR1cm4gMDtcbiAgfTtcbiAgdmFyIG5vb3AkMSA9IGZ1bmN0aW9uIG5vb3AoKSB7fTtcbiAgdmFyIGVycm9yID0gZnVuY3Rpb24gZXJyb3IobXNnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gIH07XG4gIHZhciB3YXJuaW5ncyA9IGZ1bmN0aW9uIHdhcm5pbmdzKGVuYWJsZWQpIHtcbiAgICBpZiAoZW5hYmxlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB3YXJuaW5nc0VuYWJsZWQgPSAhIWVuYWJsZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB3YXJuaW5nc0VuYWJsZWQ7XG4gICAgfVxuICB9O1xuICB2YXIgd2FybiA9IGZ1bmN0aW9uIHdhcm4obXNnKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuICAgIGlmICghd2FybmluZ3MoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh3YXJuU3VwcG9ydGVkKSB7XG4gICAgICBjb25zb2xlLndhcm4obXNnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5sb2cobXNnKTtcblxuICAgICAgaWYgKHRyYWNlU3VwcG9ydGVkKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8qIGVzbGludC1lbmFibGUgKi9cblxuICB2YXIgY2xvbmUgPSBmdW5jdGlvbiBjbG9uZShvYmopIHtcbiAgICByZXR1cm4gZXh0ZW5kKHt9LCBvYmopO1xuICB9OyAvLyBnZXRzIGEgc2hhbGxvdyBjb3B5IG9mIHRoZSBhcmd1bWVudFxuXG4gIHZhciBjb3B5ID0gZnVuY3Rpb24gY29weShvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgaWYgKGFycmF5KG9iaikpIHtcbiAgICAgIHJldHVybiBvYmouc2xpY2UoKTtcbiAgICB9IGVsc2UgaWYgKHBsYWluT2JqZWN0KG9iaikpIHtcbiAgICAgIHJldHVybiBjbG9uZShvYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgfTtcbiAgdmFyIGNvcHlBcnJheSQxID0gZnVuY3Rpb24gY29weUFycmF5KGFycikge1xuICAgIHJldHVybiBhcnIuc2xpY2UoKTtcbiAgfTtcbiAgdmFyIHV1aWQgPSBmdW5jdGlvbiB1dWlkKGEsIGJcbiAgLyogcGxhY2Vob2xkZXJzICovXG4gICkge1xuICAgIGZvciAoIC8vIGxvb3AgOilcbiAgICBiID0gYSA9ICcnOyAvLyBiIC0gcmVzdWx0ICwgYSAtIG51bWVyaWMgbGV0aWFibGVcbiAgICBhKysgPCAzNjsgLy9cbiAgICBiICs9IGEgKiA1MSAmIDUyIC8vIGlmIFwiYVwiIGlzIG5vdCA5IG9yIDE0IG9yIDE5IG9yIDI0XG4gICAgPyAvLyAgcmV0dXJuIGEgcmFuZG9tIG51bWJlciBvciA0XG4gICAgKGEgXiAxNSAvLyBpZiBcImFcIiBpcyBub3QgMTVcbiAgICA/IC8vIGdlbmVyYXRlIGEgcmFuZG9tIG51bWJlciBmcm9tIDAgdG8gMTVcbiAgICA4IF4gTWF0aC5yYW5kb20oKSAqIChhIF4gMjAgPyAxNiA6IDQpIC8vIHVubGVzcyBcImFcIiBpcyAyMCwgaW4gd2hpY2ggY2FzZSBhIHJhbmRvbSBudW1iZXIgZnJvbSA4IHRvIDExXG4gICAgOiA0IC8vICBvdGhlcndpc2UgNFxuICAgICkudG9TdHJpbmcoMTYpIDogJy0nIC8vICBpbiBvdGhlciBjYXNlcyAoaWYgXCJhXCIgaXMgOSwxNCwxOSwyNCkgaW5zZXJ0IFwiLVwiXG4gICAgKSB7XG4gICAgfVxuXG4gICAgcmV0dXJuIGI7XG4gIH07XG4gIHZhciBfc3RhdGljRW1wdHlPYmplY3QgPSB7fTtcbiAgdmFyIHN0YXRpY0VtcHR5T2JqZWN0ID0gZnVuY3Rpb24gc3RhdGljRW1wdHlPYmplY3QoKSB7XG4gICAgcmV0dXJuIF9zdGF0aWNFbXB0eU9iamVjdDtcbiAgfTtcbiAgdmFyIGRlZmF1bHRzJGcgPSBmdW5jdGlvbiBkZWZhdWx0cyhfZGVmYXVsdHMpIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKF9kZWZhdWx0cyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgICB2YXIgZmlsbGVkT3B0cyA9IHt9O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgIHZhciBvcHRWYWwgPSBvcHRzID09IG51bGwgPyB1bmRlZmluZWQgOiBvcHRzW2tleV07XG4gICAgICAgIGZpbGxlZE9wdHNba2V5XSA9IG9wdFZhbCA9PT0gdW5kZWZpbmVkID8gX2RlZmF1bHRzW2tleV0gOiBvcHRWYWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmaWxsZWRPcHRzO1xuICAgIH07XG4gIH07XG4gIHZhciByZW1vdmVGcm9tQXJyYXkgPSBmdW5jdGlvbiByZW1vdmVGcm9tQXJyYXkoYXJyLCBlbGUsIG9uZUNvcHkpIHtcbiAgICBmb3IgKHZhciBpID0gYXJyLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBpZiAoYXJyW2ldID09PSBlbGUpIHtcbiAgICAgICAgYXJyLnNwbGljZShpLCAxKTtcblxuICAgICAgICBpZiAob25lQ29weSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuICB2YXIgY2xlYXJBcnJheSA9IGZ1bmN0aW9uIGNsZWFyQXJyYXkoYXJyKSB7XG4gICAgYXJyLnNwbGljZSgwLCBhcnIubGVuZ3RoKTtcbiAgfTtcbiAgdmFyIHB1c2ggPSBmdW5jdGlvbiBwdXNoKGFyciwgb3RoZXJBcnIpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG90aGVyQXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWwgPSBvdGhlckFycltpXTtcbiAgICAgIGFyci5wdXNoKGVsKTtcbiAgICB9XG4gIH07XG4gIHZhciBnZXRQcmVmaXhlZFByb3BlcnR5ID0gZnVuY3Rpb24gZ2V0UHJlZml4ZWRQcm9wZXJ0eShvYmosIHByb3BOYW1lLCBwcmVmaXgpIHtcbiAgICBpZiAocHJlZml4KSB7XG4gICAgICBwcm9wTmFtZSA9IHByZXBlbmRDYW1lbChwcmVmaXgsIHByb3BOYW1lKTsgLy8gZS5nLiAobGFiZWxXaWR0aCwgc291cmNlKSA9PiBzb3VyY2VMYWJlbFdpZHRoXG4gICAgfVxuXG4gICAgcmV0dXJuIG9ialtwcm9wTmFtZV07XG4gIH07XG4gIHZhciBzZXRQcmVmaXhlZFByb3BlcnR5ID0gZnVuY3Rpb24gc2V0UHJlZml4ZWRQcm9wZXJ0eShvYmosIHByb3BOYW1lLCBwcmVmaXgsIHZhbHVlKSB7XG4gICAgaWYgKHByZWZpeCkge1xuICAgICAgcHJvcE5hbWUgPSBwcmVwZW5kQ2FtZWwocHJlZml4LCBwcm9wTmFtZSk7IC8vIGUuZy4gKGxhYmVsV2lkdGgsIHNvdXJjZSkgPT4gc291cmNlTGFiZWxXaWR0aFxuICAgIH1cblxuICAgIG9ialtwcm9wTmFtZV0gPSB2YWx1ZTtcbiAgfTtcblxuICAvKiBnbG9iYWwgTWFwICovXG4gIHZhciBPYmplY3RNYXAgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE9iamVjdE1hcCgpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBPYmplY3RNYXApO1xuXG4gICAgICB0aGlzLl9vYmogPSB7fTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoT2JqZWN0TWFwLCBbe1xuICAgICAga2V5OiBcInNldFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldChrZXksIHZhbCkge1xuICAgICAgICB0aGlzLl9vYmpba2V5XSA9IHZhbDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImRlbGV0ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9kZWxldGUoa2V5KSB7XG4gICAgICAgIHRoaXMuX29ialtrZXldID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY2xlYXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5fb2JqID0ge307XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImhhc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhcyhrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29ialtrZXldICE9PSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdldFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29ialtrZXldO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBPYmplY3RNYXA7XG4gIH0oKTtcblxuICB2YXIgTWFwJDIgPSB0eXBlb2YgTWFwICE9PSAndW5kZWZpbmVkJyA/IE1hcCA6IE9iamVjdE1hcDtcblxuICAvKiBnbG9iYWwgU2V0ICovXG4gIHZhciB1bmRlZiA9IFwidW5kZWZpbmVkXCIgO1xuXG4gIHZhciBPYmplY3RTZXQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE9iamVjdFNldChhcnJheU9yT2JqZWN0U2V0KSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgT2JqZWN0U2V0KTtcblxuICAgICAgdGhpcy5fb2JqID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHRoaXMuc2l6ZSA9IDA7XG5cbiAgICAgIGlmIChhcnJheU9yT2JqZWN0U2V0ICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGFycjtcblxuICAgICAgICBpZiAoYXJyYXlPck9iamVjdFNldC5pbnN0YW5jZVN0cmluZyAhPSBudWxsICYmIGFycmF5T3JPYmplY3RTZXQuaW5zdGFuY2VTdHJpbmcoKSA9PT0gdGhpcy5pbnN0YW5jZVN0cmluZygpKSB7XG4gICAgICAgICAgYXJyID0gYXJyYXlPck9iamVjdFNldC50b0FycmF5KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXJyID0gYXJyYXlPck9iamVjdFNldDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5hZGQoYXJyW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhPYmplY3RTZXQsIFt7XG4gICAgICBrZXk6IFwiaW5zdGFuY2VTdHJpbmdcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpbnN0YW5jZVN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuICdzZXQnO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJhZGRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQodmFsKSB7XG4gICAgICAgIHZhciBvID0gdGhpcy5fb2JqO1xuXG4gICAgICAgIGlmIChvW3ZhbF0gIT09IDEpIHtcbiAgICAgICAgICBvW3ZhbF0gPSAxO1xuICAgICAgICAgIHRoaXMuc2l6ZSsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImRlbGV0ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9kZWxldGUodmFsKSB7XG4gICAgICAgIHZhciBvID0gdGhpcy5fb2JqO1xuXG4gICAgICAgIGlmIChvW3ZhbF0gPT09IDEpIHtcbiAgICAgICAgICBvW3ZhbF0gPSAwO1xuICAgICAgICAgIHRoaXMuc2l6ZS0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImNsZWFyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICAgIHRoaXMuX29iaiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImhhc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhcyh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29ialt2YWxdID09PSAxO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJ0b0FycmF5XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdG9BcnJheSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fb2JqKS5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5oYXMoa2V5KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImZvckVhY2hcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5mb3JFYWNoKGNhbGxiYWNrLCB0aGlzQXJnKTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gT2JqZWN0U2V0O1xuICB9KCk7XG5cbiAgdmFyIFNldCQxID0gKHR5cGVvZiBTZXQgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihTZXQpKSAhPT0gdW5kZWYgPyBTZXQgOiBPYmplY3RTZXQ7XG5cbiAgdmFyIEVsZW1lbnQgPSBmdW5jdGlvbiBFbGVtZW50KGN5LCBwYXJhbXMpIHtcbiAgICB2YXIgcmVzdG9yZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdHJ1ZTtcblxuICAgIGlmIChjeSA9PT0gdW5kZWZpbmVkIHx8IHBhcmFtcyA9PT0gdW5kZWZpbmVkIHx8ICFjb3JlKGN5KSkge1xuICAgICAgZXJyb3IoJ0FuIGVsZW1lbnQgbXVzdCBoYXZlIGEgY29yZSByZWZlcmVuY2UgYW5kIHBhcmFtZXRlcnMgc2V0Jyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGdyb3VwID0gcGFyYW1zLmdyb3VwOyAvLyB0cnkgdG8gYXV0b21hdGljYWxseSBpbmZlciB0aGUgZ3JvdXAgaWYgdW5zcGVjaWZpZWRcblxuICAgIGlmIChncm91cCA9PSBudWxsKSB7XG4gICAgICBpZiAocGFyYW1zLmRhdGEgJiYgcGFyYW1zLmRhdGEuc291cmNlICE9IG51bGwgJiYgcGFyYW1zLmRhdGEudGFyZ2V0ICE9IG51bGwpIHtcbiAgICAgICAgZ3JvdXAgPSAnZWRnZXMnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ3JvdXAgPSAnbm9kZXMnO1xuICAgICAgfVxuICAgIH0gLy8gdmFsaWRhdGUgZ3JvdXBcblxuXG4gICAgaWYgKGdyb3VwICE9PSAnbm9kZXMnICYmIGdyb3VwICE9PSAnZWRnZXMnKSB7XG4gICAgICBlcnJvcignQW4gZWxlbWVudCBtdXN0IGJlIG9mIHR5cGUgYG5vZGVzYCBvciBgZWRnZXNgOyB5b3Ugc3BlY2lmaWVkIGAnICsgZ3JvdXAgKyAnYCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gbWFrZSB0aGUgZWxlbWVudCBhcnJheS1saWtlLCBqdXN0IGxpa2UgYSBjb2xsZWN0aW9uXG5cblxuICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICB0aGlzWzBdID0gdGhpczsgLy8gTk9URTogd2hlbiBzb21ldGhpbmcgaXMgYWRkZWQgaGVyZSwgYWRkIGFsc28gdG8gZWxlLmpzb24oKVxuXG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZSA9IHtcbiAgICAgIGN5OiBjeSxcbiAgICAgIHNpbmdsZTogdHJ1ZSxcbiAgICAgIC8vIGluZGljYXRlcyB0aGlzIGlzIGFuIGVsZW1lbnRcbiAgICAgIGRhdGE6IHBhcmFtcy5kYXRhIHx8IHt9LFxuICAgICAgLy8gZGF0YSBvYmplY3RcbiAgICAgIHBvc2l0aW9uOiBwYXJhbXMucG9zaXRpb24gfHwge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9LFxuICAgICAgLy8gKHgsIHkpIHBvc2l0aW9uIHBhaXJcbiAgICAgIGF1dG9XaWR0aDogdW5kZWZpbmVkLFxuICAgICAgLy8gd2lkdGggYW5kIGhlaWdodCBvZiBub2RlcyBjYWxjdWxhdGVkIGJ5IHRoZSByZW5kZXJlciB3aGVuIHNldCB0byBzcGVjaWFsICdhdXRvJyB2YWx1ZVxuICAgICAgYXV0b0hlaWdodDogdW5kZWZpbmVkLFxuICAgICAgYXV0b1BhZGRpbmc6IHVuZGVmaW5lZCxcbiAgICAgIGNvbXBvdW5kQm91bmRzQ2xlYW46IGZhbHNlLFxuICAgICAgLy8gd2hldGhlciB0aGUgY29tcG91bmQgZGltZW5zaW9ucyBuZWVkIHRvIGJlIHJlY2FsY3VsYXRlZCB0aGUgbmV4dCB0aW1lIGRpbWVuc2lvbnMgYXJlIHJlYWRcbiAgICAgIGxpc3RlbmVyczogW10sXG4gICAgICAvLyBhcnJheSBvZiBib3VuZCBsaXN0ZW5lcnNcbiAgICAgIGdyb3VwOiBncm91cCxcbiAgICAgIC8vIHN0cmluZzsgJ25vZGVzJyBvciAnZWRnZXMnXG4gICAgICBzdHlsZToge30sXG4gICAgICAvLyBwcm9wZXJ0aWVzIGFzIHNldCBieSB0aGUgc3R5bGVcbiAgICAgIHJzdHlsZToge30sXG4gICAgICAvLyBwcm9wZXJ0aWVzIGZvciBzdHlsZSBzZW50IGZyb20gdGhlIHJlbmRlcmVyIHRvIHRoZSBjb3JlXG4gICAgICBzdHlsZUN4dHM6IFtdLFxuICAgICAgLy8gYXBwbGllZCBzdHlsZSBjb250ZXh0cyBmcm9tIHRoZSBzdHlsZXJcbiAgICAgIHN0eWxlS2V5czoge30sXG4gICAgICAvLyBwZXItZ3JvdXAga2V5cyBvZiBzdHlsZSBwcm9wZXJ0eSB2YWx1ZXNcbiAgICAgIHJlbW92ZWQ6IHRydWUsXG4gICAgICAvLyB3aGV0aGVyIGl0J3MgaW5zaWRlIHRoZSB2aXM7IHRydWUgaWYgcmVtb3ZlZCAoc2V0IHRydWUgaGVyZSBzaW5jZSB3ZSBjYWxsIHJlc3RvcmUpXG4gICAgICBzZWxlY3RlZDogcGFyYW1zLnNlbGVjdGVkID8gdHJ1ZSA6IGZhbHNlLFxuICAgICAgLy8gd2hldGhlciBpdCdzIHNlbGVjdGVkXG4gICAgICBzZWxlY3RhYmxlOiBwYXJhbXMuc2VsZWN0YWJsZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IHBhcmFtcy5zZWxlY3RhYmxlID8gdHJ1ZSA6IGZhbHNlLFxuICAgICAgLy8gd2hldGhlciBpdCdzIHNlbGVjdGFibGVcbiAgICAgIGxvY2tlZDogcGFyYW1zLmxvY2tlZCA/IHRydWUgOiBmYWxzZSxcbiAgICAgIC8vIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgbG9ja2VkIChjYW5ub3QgYmUgbW92ZWQpXG4gICAgICBncmFiYmVkOiBmYWxzZSxcbiAgICAgIC8vIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgZ3JhYmJlZCBieSB0aGUgbW91c2U7IHJlbmRlcmVyIHNldHMgdGhpcyBwcml2YXRlbHlcbiAgICAgIGdyYWJiYWJsZTogcGFyYW1zLmdyYWJiYWJsZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IHBhcmFtcy5ncmFiYmFibGUgPyB0cnVlIDogZmFsc2UsXG4gICAgICAvLyB3aGV0aGVyIHRoZSBlbGVtZW50IGNhbiBiZSBncmFiYmVkXG4gICAgICBwYW5uYWJsZTogcGFyYW1zLnBhbm5hYmxlID09PSB1bmRlZmluZWQgPyBncm91cCA9PT0gJ2VkZ2VzJyA/IHRydWUgOiBmYWxzZSA6IHBhcmFtcy5wYW5uYWJsZSA/IHRydWUgOiBmYWxzZSxcbiAgICAgIC8vIHdoZXRoZXIgdGhlIGVsZW1lbnQgaGFzIHBhc3N0aHJvdWdoIHBhbm5pbmcgZW5hYmxlZFxuICAgICAgYWN0aXZlOiBmYWxzZSxcbiAgICAgIC8vIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgYWN0aXZlIGZyb20gdXNlciBpbnRlcmFjdGlvblxuICAgICAgY2xhc3NlczogbmV3IFNldCQxKCksXG4gICAgICAvLyBtYXAgKCBjbGFzc05hbWUgPT4gdHJ1ZSApXG4gICAgICBhbmltYXRpb246IHtcbiAgICAgICAgLy8gb2JqZWN0IGZvciBjdXJyZW50bHktcnVubmluZyBhbmltYXRpb25zXG4gICAgICAgIGN1cnJlbnQ6IFtdLFxuICAgICAgICBxdWV1ZTogW11cbiAgICAgIH0sXG4gICAgICByc2NyYXRjaDoge30sXG4gICAgICAvLyBvYmplY3QgaW4gd2hpY2ggdGhlIHJlbmRlcmVyIGNhbiBzdG9yZSBpbmZvcm1hdGlvblxuICAgICAgc2NyYXRjaDogcGFyYW1zLnNjcmF0Y2ggfHwge30sXG4gICAgICAvLyBzY3JhdGNoIG9iamVjdHNcbiAgICAgIGVkZ2VzOiBbXSxcbiAgICAgIC8vIGFycmF5IG9mIGNvbm5lY3RlZCBlZGdlc1xuICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgLy8gYXJyYXkgb2YgY2hpbGRyZW5cbiAgICAgIHBhcmVudDogcGFyYW1zLnBhcmVudCAmJiBwYXJhbXMucGFyZW50LmlzTm9kZSgpID8gcGFyYW1zLnBhcmVudCA6IG51bGwsXG4gICAgICAvLyBwYXJlbnQgcmVmXG4gICAgICB0cmF2ZXJzYWxDYWNoZToge30sXG4gICAgICAvLyBjYWNoZSBvZiBvdXRwdXQgb2YgdHJhdmVyc2FsIGZ1bmN0aW9uc1xuICAgICAgYmFja2dyb3VuZGluZzogZmFsc2UsXG4gICAgICAvLyB3aGV0aGVyIGJhY2tncm91bmQgaW1hZ2VzIGFyZSBsb2FkaW5nXG4gICAgICBiYkNhY2hlOiBudWxsLFxuICAgICAgLy8gY2FjaGUgb2YgdGhlIGN1cnJlbnQgYm91bmRpbmcgYm94XG4gICAgICBiYkNhY2hlU2hpZnQ6IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfSxcbiAgICAgIC8vIHNoaWZ0IGFwcGxpZWQgdG8gY2FjaGVkIGJiIHRvIGJlIGFwcGxpZWQgb24gbmV4dCBnZXRcbiAgICAgIGJvZHlCb3VuZHM6IG51bGwsXG4gICAgICAvLyBib3VuZHMgY2FjaGUgb2YgZWxlbWVudCBib2R5LCB3L28gb3ZlcmxheVxuICAgICAgb3ZlcmxheUJvdW5kczogbnVsbCxcbiAgICAgIC8vIGJvdW5kcyBjYWNoZSBvZiBlbGVtZW50IGJvZHksIGluY2x1ZGluZyBvdmVybGF5XG4gICAgICBsYWJlbEJvdW5kczoge1xuICAgICAgICAvLyBib3VuZHMgY2FjaGUgb2YgbGFiZWxzXG4gICAgICAgIGFsbDogbnVsbCxcbiAgICAgICAgc291cmNlOiBudWxsLFxuICAgICAgICB0YXJnZXQ6IG51bGwsXG4gICAgICAgIG1haW46IG51bGxcbiAgICAgIH0sXG4gICAgICBhcnJvd0JvdW5kczoge1xuICAgICAgICAvLyBib3VuZHMgY2FjaGUgb2YgZWRnZSBhcnJvd3NcbiAgICAgICAgc291cmNlOiBudWxsLFxuICAgICAgICB0YXJnZXQ6IG51bGwsXG4gICAgICAgICdtaWQtc291cmNlJzogbnVsbCxcbiAgICAgICAgJ21pZC10YXJnZXQnOiBudWxsXG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChfcC5wb3NpdGlvbi54ID09IG51bGwpIHtcbiAgICAgIF9wLnBvc2l0aW9uLnggPSAwO1xuICAgIH1cblxuICAgIGlmIChfcC5wb3NpdGlvbi55ID09IG51bGwpIHtcbiAgICAgIF9wLnBvc2l0aW9uLnkgPSAwO1xuICAgIH0gLy8gcmVuZGVyZWRQb3NpdGlvbiBvdmVycmlkZXMgaWYgc3BlY2lmaWVkXG5cblxuICAgIGlmIChwYXJhbXMucmVuZGVyZWRQb3NpdGlvbikge1xuICAgICAgdmFyIHJwb3MgPSBwYXJhbXMucmVuZGVyZWRQb3NpdGlvbjtcbiAgICAgIHZhciBwYW4gPSBjeS5wYW4oKTtcbiAgICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuICAgICAgX3AucG9zaXRpb24gPSB7XG4gICAgICAgIHg6IChycG9zLnggLSBwYW4ueCkgLyB6b29tLFxuICAgICAgICB5OiAocnBvcy55IC0gcGFuLnkpIC8gem9vbVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgY2xhc3NlcyA9IFtdO1xuXG4gICAgaWYgKGFycmF5KHBhcmFtcy5jbGFzc2VzKSkge1xuICAgICAgY2xhc3NlcyA9IHBhcmFtcy5jbGFzc2VzO1xuICAgIH0gZWxzZSBpZiAoc3RyaW5nKHBhcmFtcy5jbGFzc2VzKSkge1xuICAgICAgY2xhc3NlcyA9IHBhcmFtcy5jbGFzc2VzLnNwbGl0KC9cXHMrLyk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjbGFzc2VzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGNscyA9IGNsYXNzZXNbaV07XG5cbiAgICAgIGlmICghY2xzIHx8IGNscyA9PT0gJycpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIF9wLmNsYXNzZXMuYWRkKGNscyk7XG4gICAgfVxuXG4gICAgdGhpcy5jcmVhdGVFbWl0dGVyKCk7XG4gICAgdmFyIGJ5cGFzcyA9IHBhcmFtcy5zdHlsZSB8fCBwYXJhbXMuY3NzO1xuXG4gICAgaWYgKGJ5cGFzcykge1xuICAgICAgd2FybignU2V0dGluZyBhIGBzdHlsZWAgYnlwYXNzIGF0IGVsZW1lbnQgY3JlYXRpb24gc2hvdWxkIGJlIGRvbmUgb25seSB3aGVuIGFic29sdXRlbHkgbmVjZXNzYXJ5LiAgVHJ5IHRvIHVzZSB0aGUgc3R5bGVzaGVldCBpbnN0ZWFkLicpO1xuICAgICAgdGhpcy5zdHlsZShieXBhc3MpO1xuICAgIH1cblxuICAgIGlmIChyZXN0b3JlID09PSB1bmRlZmluZWQgfHwgcmVzdG9yZSkge1xuICAgICAgdGhpcy5yZXN0b3JlKCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBkZWZpbmVTZWFyY2ggPSBmdW5jdGlvbiBkZWZpbmVTZWFyY2gocGFyYW1zKSB7XG4gICAgcGFyYW1zID0ge1xuICAgICAgYmZzOiBwYXJhbXMuYmZzIHx8ICFwYXJhbXMuZGZzLFxuICAgICAgZGZzOiBwYXJhbXMuZGZzIHx8ICFwYXJhbXMuYmZzXG4gICAgfTsgLy8gZnJvbSBwc2V1ZG9jb2RlIG9uIHdpa2lwZWRpYVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHNlYXJjaEZuKHJvb3RzLCBmbiwgZGlyZWN0ZWQpIHtcbiAgICAgIHZhciBvcHRpb25zO1xuXG4gICAgICBpZiAocGxhaW5PYmplY3Qocm9vdHMpICYmICFlbGVtZW50T3JDb2xsZWN0aW9uKHJvb3RzKSkge1xuICAgICAgICBvcHRpb25zID0gcm9vdHM7XG4gICAgICAgIHJvb3RzID0gb3B0aW9ucy5yb290cyB8fCBvcHRpb25zLnJvb3Q7XG4gICAgICAgIGZuID0gb3B0aW9ucy52aXNpdDtcbiAgICAgICAgZGlyZWN0ZWQgPSBvcHRpb25zLmRpcmVjdGVkO1xuICAgICAgfVxuXG4gICAgICBkaXJlY3RlZCA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgIWZuJDYoZm4pID8gZm4gOiBkaXJlY3RlZDtcbiAgICAgIGZuID0gZm4kNihmbikgPyBmbiA6IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgICAgIHZhciB2ID0gcm9vdHMgPSBzdHJpbmcocm9vdHMpID8gdGhpcy5maWx0ZXIocm9vdHMpIDogcm9vdHM7XG4gICAgICB2YXIgUSA9IFtdO1xuICAgICAgdmFyIGNvbm5lY3RlZE5vZGVzID0gW107XG4gICAgICB2YXIgY29ubmVjdGVkQnkgPSB7fTtcbiAgICAgIHZhciBpZDJkZXB0aCA9IHt9O1xuICAgICAgdmFyIFYgPSB7fTtcbiAgICAgIHZhciBqID0gMDtcbiAgICAgIHZhciBmb3VuZDtcblxuICAgICAgdmFyIF90aGlzJGJ5R3JvdXAgPSB0aGlzLmJ5R3JvdXAoKSxcbiAgICAgICAgICBub2RlcyA9IF90aGlzJGJ5R3JvdXAubm9kZXMsXG4gICAgICAgICAgZWRnZXMgPSBfdGhpcyRieUdyb3VwLmVkZ2VzOyAvLyBlbnF1ZXVlIHZcblxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHZpID0gdltpXTtcbiAgICAgICAgdmFyIHZpSWQgPSB2aS5pZCgpO1xuXG4gICAgICAgIGlmICh2aS5pc05vZGUoKSkge1xuICAgICAgICAgIFEudW5zaGlmdCh2aSk7XG5cbiAgICAgICAgICBpZiAocGFyYW1zLmJmcykge1xuICAgICAgICAgICAgVlt2aUlkXSA9IHRydWU7XG4gICAgICAgICAgICBjb25uZWN0ZWROb2Rlcy5wdXNoKHZpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZDJkZXB0aFt2aUlkXSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoKSB7XG4gICAgICAgIHZhciB2ID0gcGFyYW1zLmJmcyA/IFEuc2hpZnQoKSA6IFEucG9wKCk7XG4gICAgICAgIHZhciB2SWQgPSB2LmlkKCk7XG5cbiAgICAgICAgaWYgKHBhcmFtcy5kZnMpIHtcbiAgICAgICAgICBpZiAoVlt2SWRdKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIFZbdklkXSA9IHRydWU7XG4gICAgICAgICAgY29ubmVjdGVkTm9kZXMucHVzaCh2KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkZXB0aCA9IGlkMmRlcHRoW3ZJZF07XG4gICAgICAgIHZhciBwcmV2RWRnZSA9IGNvbm5lY3RlZEJ5W3ZJZF07XG4gICAgICAgIHZhciBzcmMgPSBwcmV2RWRnZSAhPSBudWxsID8gcHJldkVkZ2Uuc291cmNlKCkgOiBudWxsO1xuICAgICAgICB2YXIgdGd0ID0gcHJldkVkZ2UgIT0gbnVsbCA/IHByZXZFZGdlLnRhcmdldCgpIDogbnVsbDtcbiAgICAgICAgdmFyIHByZXZOb2RlID0gcHJldkVkZ2UgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHYuc2FtZShzcmMpID8gdGd0WzBdIDogc3JjWzBdO1xuICAgICAgICB2YXIgcmV0ID0gdm9pZCAwO1xuICAgICAgICByZXQgPSBmbih2LCBwcmV2RWRnZSwgcHJldk5vZGUsIGorKywgZGVwdGgpO1xuXG4gICAgICAgIGlmIChyZXQgPT09IHRydWUpIHtcbiAgICAgICAgICBmb3VuZCA9IHY7XG4gICAgICAgICAgcmV0dXJuIFwiYnJlYWtcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIFwiYnJlYWtcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2d0VkZ2VzID0gdi5jb25uZWN0ZWRFZGdlcygpLmZpbHRlcihmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHJldHVybiAoIWRpcmVjdGVkIHx8IGUuc291cmNlKCkuc2FtZSh2KSkgJiYgZWRnZXMuaGFzKGUpO1xuICAgICAgICB9KTtcblxuICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCB2d0VkZ2VzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgICB2YXIgZSA9IHZ3RWRnZXNbX2kyXTtcbiAgICAgICAgICB2YXIgdyA9IGUuY29ubmVjdGVkTm9kZXMoKS5maWx0ZXIoZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgIHJldHVybiAhbi5zYW1lKHYpICYmIG5vZGVzLmhhcyhuKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgd0lkID0gdy5pZCgpO1xuXG4gICAgICAgICAgaWYgKHcubGVuZ3RoICE9PSAwICYmICFWW3dJZF0pIHtcbiAgICAgICAgICAgIHcgPSB3WzBdO1xuICAgICAgICAgICAgUS5wdXNoKHcpO1xuXG4gICAgICAgICAgICBpZiAocGFyYW1zLmJmcykge1xuICAgICAgICAgICAgICBWW3dJZF0gPSB0cnVlO1xuICAgICAgICAgICAgICBjb25uZWN0ZWROb2Rlcy5wdXNoKHcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25uZWN0ZWRCeVt3SWRdID0gZTtcbiAgICAgICAgICAgIGlkMmRlcHRoW3dJZF0gPSBpZDJkZXB0aFt2SWRdICsgMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHdoaWxlIChRLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICB2YXIgX3JldCA9IF9sb29wKCk7XG5cbiAgICAgICAgaWYgKF9yZXQgPT09IFwiY29udGludWVcIikgY29udGludWU7XG4gICAgICAgIGlmIChfcmV0ID09PSBcImJyZWFrXCIpIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29ubmVjdGVkRWxlcyA9IGN5LmNvbGxlY3Rpb24oKTtcblxuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGNvbm5lY3RlZE5vZGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgbm9kZSA9IGNvbm5lY3RlZE5vZGVzW19pXTtcbiAgICAgICAgdmFyIGVkZ2UgPSBjb25uZWN0ZWRCeVtub2RlLmlkKCldO1xuXG4gICAgICAgIGlmIChlZGdlICE9IG51bGwpIHtcbiAgICAgICAgICBjb25uZWN0ZWRFbGVzLnB1c2goZWRnZSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25uZWN0ZWRFbGVzLnB1c2gobm9kZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhdGg6IGN5LmNvbGxlY3Rpb24oY29ubmVjdGVkRWxlcyksXG4gICAgICAgIGZvdW5kOiBjeS5jb2xsZWN0aW9uKGZvdW5kKVxuICAgICAgfTtcbiAgICB9O1xuICB9OyAvLyBzZWFyY2gsIHNwYW5uaW5nIHRyZWVzLCBldGNcblxuXG4gIHZhciBlbGVzZm4kdiA9IHtcbiAgICBicmVhZHRoRmlyc3RTZWFyY2g6IGRlZmluZVNlYXJjaCh7XG4gICAgICBiZnM6IHRydWVcbiAgICB9KSxcbiAgICBkZXB0aEZpcnN0U2VhcmNoOiBkZWZpbmVTZWFyY2goe1xuICAgICAgZGZzOiB0cnVlXG4gICAgfSlcbiAgfTsgLy8gbmljZSwgc2hvcnQgbWF0aGVtYXRpY2FsIGFsaWFzXG5cbiAgZWxlc2ZuJHYuYmZzID0gZWxlc2ZuJHYuYnJlYWR0aEZpcnN0U2VhcmNoO1xuICBlbGVzZm4kdi5kZnMgPSBlbGVzZm4kdi5kZXB0aEZpcnN0U2VhcmNoO1xuXG4gIHZhciBoZWFwJDEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG4gIC8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS44LjBcbiAgKGZ1bmN0aW9uKCkge1xuICAgIHZhciBIZWFwLCBkZWZhdWx0Q21wLCBmbG9vciwgaGVhcGlmeSwgaGVhcHBvcCwgaGVhcHB1c2gsIGhlYXBwdXNocG9wLCBoZWFwcmVwbGFjZSwgaW5zb3J0LCBtaW4sIG5sYXJnZXN0LCBuc21hbGxlc3QsIHVwZGF0ZUl0ZW0sIF9zaWZ0ZG93biwgX3NpZnR1cDtcblxuICAgIGZsb29yID0gTWF0aC5mbG9vciwgbWluID0gTWF0aC5taW47XG5cblxuICAgIC8qXG4gICAgRGVmYXVsdCBjb21wYXJpc29uIGZ1bmN0aW9uIHRvIGJlIHVzZWRcbiAgICAgKi9cblxuICAgIGRlZmF1bHRDbXAgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICBpZiAoeCA8IHkpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgaWYgKHggPiB5KSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfTtcblxuXG4gICAgLypcbiAgICBJbnNlcnQgaXRlbSB4IGluIGxpc3QgYSwgYW5kIGtlZXAgaXQgc29ydGVkIGFzc3VtaW5nIGEgaXMgc29ydGVkLlxuICAgIFxuICAgIElmIHggaXMgYWxyZWFkeSBpbiBhLCBpbnNlcnQgaXQgdG8gdGhlIHJpZ2h0IG9mIHRoZSByaWdodG1vc3QgeC5cbiAgICBcbiAgICBPcHRpb25hbCBhcmdzIGxvIChkZWZhdWx0IDApIGFuZCBoaSAoZGVmYXVsdCBhLmxlbmd0aCkgYm91bmQgdGhlIHNsaWNlXG4gICAgb2YgYSB0byBiZSBzZWFyY2hlZC5cbiAgICAgKi9cblxuICAgIGluc29ydCA9IGZ1bmN0aW9uKGEsIHgsIGxvLCBoaSwgY21wKSB7XG4gICAgICB2YXIgbWlkO1xuICAgICAgaWYgKGxvID09IG51bGwpIHtcbiAgICAgICAgbG8gPSAwO1xuICAgICAgfVxuICAgICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgICB9XG4gICAgICBpZiAobG8gPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbG8gbXVzdCBiZSBub24tbmVnYXRpdmUnKTtcbiAgICAgIH1cbiAgICAgIGlmIChoaSA9PSBudWxsKSB7XG4gICAgICAgIGhpID0gYS5sZW5ndGg7XG4gICAgICB9XG4gICAgICB3aGlsZSAobG8gPCBoaSkge1xuICAgICAgICBtaWQgPSBmbG9vcigobG8gKyBoaSkgLyAyKTtcbiAgICAgICAgaWYgKGNtcCh4LCBhW21pZF0pIDwgMCkge1xuICAgICAgICAgIGhpID0gbWlkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvID0gbWlkICsgMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIChbXS5zcGxpY2UuYXBwbHkoYSwgW2xvLCBsbyAtIGxvXS5jb25jYXQoeCkpLCB4KTtcbiAgICB9O1xuXG5cbiAgICAvKlxuICAgIFB1c2ggaXRlbSBvbnRvIGhlYXAsIG1haW50YWluaW5nIHRoZSBoZWFwIGludmFyaWFudC5cbiAgICAgKi9cblxuICAgIGhlYXBwdXNoID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGNtcCkge1xuICAgICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgICB9XG4gICAgICBhcnJheS5wdXNoKGl0ZW0pO1xuICAgICAgcmV0dXJuIF9zaWZ0ZG93bihhcnJheSwgMCwgYXJyYXkubGVuZ3RoIC0gMSwgY21wKTtcbiAgICB9O1xuXG5cbiAgICAvKlxuICAgIFBvcCB0aGUgc21hbGxlc3QgaXRlbSBvZmYgdGhlIGhlYXAsIG1haW50YWluaW5nIHRoZSBoZWFwIGludmFyaWFudC5cbiAgICAgKi9cblxuICAgIGhlYXBwb3AgPSBmdW5jdGlvbihhcnJheSwgY21wKSB7XG4gICAgICB2YXIgbGFzdGVsdCwgcmV0dXJuaXRlbTtcbiAgICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgICAgfVxuICAgICAgbGFzdGVsdCA9IGFycmF5LnBvcCgpO1xuICAgICAgaWYgKGFycmF5Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm5pdGVtID0gYXJyYXlbMF07XG4gICAgICAgIGFycmF5WzBdID0gbGFzdGVsdDtcbiAgICAgICAgX3NpZnR1cChhcnJheSwgMCwgY21wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybml0ZW0gPSBsYXN0ZWx0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldHVybml0ZW07XG4gICAgfTtcblxuXG4gICAgLypcbiAgICBQb3AgYW5kIHJldHVybiB0aGUgY3VycmVudCBzbWFsbGVzdCB2YWx1ZSwgYW5kIGFkZCB0aGUgbmV3IGl0ZW0uXG4gICAgXG4gICAgVGhpcyBpcyBtb3JlIGVmZmljaWVudCB0aGFuIGhlYXBwb3AoKSBmb2xsb3dlZCBieSBoZWFwcHVzaCgpLCBhbmQgY2FuIGJlXG4gICAgbW9yZSBhcHByb3ByaWF0ZSB3aGVuIHVzaW5nIGEgZml4ZWQgc2l6ZSBoZWFwLiBOb3RlIHRoYXQgdGhlIHZhbHVlXG4gICAgcmV0dXJuZWQgbWF5IGJlIGxhcmdlciB0aGFuIGl0ZW0hIFRoYXQgY29uc3RyYWlucyByZWFzb25hYmxlIHVzZSBvZlxuICAgIHRoaXMgcm91dGluZSB1bmxlc3Mgd3JpdHRlbiBhcyBwYXJ0IG9mIGEgY29uZGl0aW9uYWwgcmVwbGFjZW1lbnQ6XG4gICAgICAgIGlmIGl0ZW0gPiBhcnJheVswXVxuICAgICAgICAgIGl0ZW0gPSBoZWFwcmVwbGFjZShhcnJheSwgaXRlbSlcbiAgICAgKi9cblxuICAgIGhlYXByZXBsYWNlID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGNtcCkge1xuICAgICAgdmFyIHJldHVybml0ZW07XG4gICAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICAgIH1cbiAgICAgIHJldHVybml0ZW0gPSBhcnJheVswXTtcbiAgICAgIGFycmF5WzBdID0gaXRlbTtcbiAgICAgIF9zaWZ0dXAoYXJyYXksIDAsIGNtcCk7XG4gICAgICByZXR1cm4gcmV0dXJuaXRlbTtcbiAgICB9O1xuXG5cbiAgICAvKlxuICAgIEZhc3QgdmVyc2lvbiBvZiBhIGhlYXBwdXNoIGZvbGxvd2VkIGJ5IGEgaGVhcHBvcC5cbiAgICAgKi9cblxuICAgIGhlYXBwdXNocG9wID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGNtcCkge1xuICAgICAgdmFyIF9yZWY7XG4gICAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICAgIH1cbiAgICAgIGlmIChhcnJheS5sZW5ndGggJiYgY21wKGFycmF5WzBdLCBpdGVtKSA8IDApIHtcbiAgICAgICAgX3JlZiA9IFthcnJheVswXSwgaXRlbV0sIGl0ZW0gPSBfcmVmWzBdLCBhcnJheVswXSA9IF9yZWZbMV07XG4gICAgICAgIF9zaWZ0dXAoYXJyYXksIDAsIGNtcCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlbTtcbiAgICB9O1xuXG5cbiAgICAvKlxuICAgIFRyYW5zZm9ybSBsaXN0IGludG8gYSBoZWFwLCBpbi1wbGFjZSwgaW4gTyhhcnJheS5sZW5ndGgpIHRpbWUuXG4gICAgICovXG5cbiAgICBoZWFwaWZ5ID0gZnVuY3Rpb24oYXJyYXksIGNtcCkge1xuICAgICAgdmFyIGksIF9pLCBfbGVuLCBfcmVmMSwgX3Jlc3VsdHMsIF9yZXN1bHRzMTtcbiAgICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgICAgfVxuICAgICAgX3JlZjEgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIF9yZXN1bHRzMSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaiA9IDAsIF9yZWYgPSBmbG9vcihhcnJheS5sZW5ndGggLyAyKTsgMCA8PSBfcmVmID8gX2ogPCBfcmVmIDogX2ogPiBfcmVmOyAwIDw9IF9yZWYgPyBfaisrIDogX2otLSl7IF9yZXN1bHRzMS5wdXNoKF9qKTsgfVxuICAgICAgICByZXR1cm4gX3Jlc3VsdHMxO1xuICAgICAgfSkuYXBwbHkodGhpcykucmV2ZXJzZSgpO1xuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjEubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgaSA9IF9yZWYxW19pXTtcbiAgICAgICAgX3Jlc3VsdHMucHVzaChfc2lmdHVwKGFycmF5LCBpLCBjbXApKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9O1xuXG5cbiAgICAvKlxuICAgIFVwZGF0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGdpdmVuIGl0ZW0gaW4gdGhlIGhlYXAuXG4gICAgVGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgY2FsbGVkIGV2ZXJ5IHRpbWUgdGhlIGl0ZW0gaXMgYmVpbmcgbW9kaWZpZWQuXG4gICAgICovXG5cbiAgICB1cGRhdGVJdGVtID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGNtcCkge1xuICAgICAgdmFyIHBvcztcbiAgICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgICAgfVxuICAgICAgcG9zID0gYXJyYXkuaW5kZXhPZihpdGVtKTtcbiAgICAgIGlmIChwb3MgPT09IC0xKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIF9zaWZ0ZG93bihhcnJheSwgMCwgcG9zLCBjbXApO1xuICAgICAgcmV0dXJuIF9zaWZ0dXAoYXJyYXksIHBvcywgY21wKTtcbiAgICB9O1xuXG5cbiAgICAvKlxuICAgIEZpbmQgdGhlIG4gbGFyZ2VzdCBlbGVtZW50cyBpbiBhIGRhdGFzZXQuXG4gICAgICovXG5cbiAgICBubGFyZ2VzdCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBjbXApIHtcbiAgICAgIHZhciBlbGVtLCByZXN1bHQsIF9pLCBfbGVuLCBfcmVmO1xuICAgICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBhcnJheS5zbGljZSgwLCBuKTtcbiAgICAgIGlmICghcmVzdWx0Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgaGVhcGlmeShyZXN1bHQsIGNtcCk7XG4gICAgICBfcmVmID0gYXJyYXkuc2xpY2Uobik7XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgZWxlbSA9IF9yZWZbX2ldO1xuICAgICAgICBoZWFwcHVzaHBvcChyZXN1bHQsIGVsZW0sIGNtcCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0LnNvcnQoY21wKS5yZXZlcnNlKCk7XG4gICAgfTtcblxuXG4gICAgLypcbiAgICBGaW5kIHRoZSBuIHNtYWxsZXN0IGVsZW1lbnRzIGluIGEgZGF0YXNldC5cbiAgICAgKi9cblxuICAgIG5zbWFsbGVzdCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBjbXApIHtcbiAgICAgIHZhciBlbGVtLCBsb3MsIHJlc3VsdCwgX2ksIF9qLCBfbGVuLCBfcmVmLCBfcmVmMSwgX3Jlc3VsdHM7XG4gICAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICAgIH1cbiAgICAgIGlmIChuICogMTAgPD0gYXJyYXkubGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdCA9IGFycmF5LnNsaWNlKDAsIG4pLnNvcnQoY21wKTtcbiAgICAgICAgaWYgKCFyZXN1bHQubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBsb3MgPSByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdO1xuICAgICAgICBfcmVmID0gYXJyYXkuc2xpY2Uobik7XG4gICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgIGVsZW0gPSBfcmVmW19pXTtcbiAgICAgICAgICBpZiAoY21wKGVsZW0sIGxvcykgPCAwKSB7XG4gICAgICAgICAgICBpbnNvcnQocmVzdWx0LCBlbGVtLCAwLCBudWxsLCBjbXApO1xuICAgICAgICAgICAgcmVzdWx0LnBvcCgpO1xuICAgICAgICAgICAgbG9zID0gcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGhlYXBpZnkoYXJyYXksIGNtcCk7XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChfaiA9IDAsIF9yZWYxID0gbWluKG4sIGFycmF5Lmxlbmd0aCk7IDAgPD0gX3JlZjEgPyBfaiA8IF9yZWYxIDogX2ogPiBfcmVmMTsgMCA8PSBfcmVmMSA/ICsrX2ogOiAtLV9qKSB7XG4gICAgICAgIF9yZXN1bHRzLnB1c2goaGVhcHBvcChhcnJheSwgY21wKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfTtcblxuICAgIF9zaWZ0ZG93biA9IGZ1bmN0aW9uKGFycmF5LCBzdGFydHBvcywgcG9zLCBjbXApIHtcbiAgICAgIHZhciBuZXdpdGVtLCBwYXJlbnQsIHBhcmVudHBvcztcbiAgICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgICAgfVxuICAgICAgbmV3aXRlbSA9IGFycmF5W3Bvc107XG4gICAgICB3aGlsZSAocG9zID4gc3RhcnRwb3MpIHtcbiAgICAgICAgcGFyZW50cG9zID0gKHBvcyAtIDEpID4+IDE7XG4gICAgICAgIHBhcmVudCA9IGFycmF5W3BhcmVudHBvc107XG4gICAgICAgIGlmIChjbXAobmV3aXRlbSwgcGFyZW50KSA8IDApIHtcbiAgICAgICAgICBhcnJheVtwb3NdID0gcGFyZW50O1xuICAgICAgICAgIHBvcyA9IHBhcmVudHBvcztcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheVtwb3NdID0gbmV3aXRlbTtcbiAgICB9O1xuXG4gICAgX3NpZnR1cCA9IGZ1bmN0aW9uKGFycmF5LCBwb3MsIGNtcCkge1xuICAgICAgdmFyIGNoaWxkcG9zLCBlbmRwb3MsIG5ld2l0ZW0sIHJpZ2h0cG9zLCBzdGFydHBvcztcbiAgICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgICAgfVxuICAgICAgZW5kcG9zID0gYXJyYXkubGVuZ3RoO1xuICAgICAgc3RhcnRwb3MgPSBwb3M7XG4gICAgICBuZXdpdGVtID0gYXJyYXlbcG9zXTtcbiAgICAgIGNoaWxkcG9zID0gMiAqIHBvcyArIDE7XG4gICAgICB3aGlsZSAoY2hpbGRwb3MgPCBlbmRwb3MpIHtcbiAgICAgICAgcmlnaHRwb3MgPSBjaGlsZHBvcyArIDE7XG4gICAgICAgIGlmIChyaWdodHBvcyA8IGVuZHBvcyAmJiAhKGNtcChhcnJheVtjaGlsZHBvc10sIGFycmF5W3JpZ2h0cG9zXSkgPCAwKSkge1xuICAgICAgICAgIGNoaWxkcG9zID0gcmlnaHRwb3M7XG4gICAgICAgIH1cbiAgICAgICAgYXJyYXlbcG9zXSA9IGFycmF5W2NoaWxkcG9zXTtcbiAgICAgICAgcG9zID0gY2hpbGRwb3M7XG4gICAgICAgIGNoaWxkcG9zID0gMiAqIHBvcyArIDE7XG4gICAgICB9XG4gICAgICBhcnJheVtwb3NdID0gbmV3aXRlbTtcbiAgICAgIHJldHVybiBfc2lmdGRvd24oYXJyYXksIHN0YXJ0cG9zLCBwb3MsIGNtcCk7XG4gICAgfTtcblxuICAgIEhlYXAgPSAoZnVuY3Rpb24oKSB7XG4gICAgICBIZWFwLnB1c2ggPSBoZWFwcHVzaDtcblxuICAgICAgSGVhcC5wb3AgPSBoZWFwcG9wO1xuXG4gICAgICBIZWFwLnJlcGxhY2UgPSBoZWFwcmVwbGFjZTtcblxuICAgICAgSGVhcC5wdXNocG9wID0gaGVhcHB1c2hwb3A7XG5cbiAgICAgIEhlYXAuaGVhcGlmeSA9IGhlYXBpZnk7XG5cbiAgICAgIEhlYXAudXBkYXRlSXRlbSA9IHVwZGF0ZUl0ZW07XG5cbiAgICAgIEhlYXAubmxhcmdlc3QgPSBubGFyZ2VzdDtcblxuICAgICAgSGVhcC5uc21hbGxlc3QgPSBuc21hbGxlc3Q7XG5cbiAgICAgIGZ1bmN0aW9uIEhlYXAoY21wKSB7XG4gICAgICAgIHRoaXMuY21wID0gY21wICE9IG51bGwgPyBjbXAgOiBkZWZhdWx0Q21wO1xuICAgICAgICB0aGlzLm5vZGVzID0gW107XG4gICAgICB9XG5cbiAgICAgIEhlYXAucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiBoZWFwcHVzaCh0aGlzLm5vZGVzLCB4LCB0aGlzLmNtcCk7XG4gICAgICB9O1xuXG4gICAgICBIZWFwLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGhlYXBwb3AodGhpcy5ub2RlcywgdGhpcy5jbXApO1xuICAgICAgfTtcblxuICAgICAgSGVhcC5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2Rlc1swXTtcbiAgICAgIH07XG5cbiAgICAgIEhlYXAucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2Rlcy5pbmRleE9mKHgpICE9PSAtMTtcbiAgICAgIH07XG5cbiAgICAgIEhlYXAucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiBoZWFwcmVwbGFjZSh0aGlzLm5vZGVzLCB4LCB0aGlzLmNtcCk7XG4gICAgICB9O1xuXG4gICAgICBIZWFwLnByb3RvdHlwZS5wdXNocG9wID0gZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gaGVhcHB1c2hwb3AodGhpcy5ub2RlcywgeCwgdGhpcy5jbXApO1xuICAgICAgfTtcblxuICAgICAgSGVhcC5wcm90b3R5cGUuaGVhcGlmeSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaGVhcGlmeSh0aGlzLm5vZGVzLCB0aGlzLmNtcCk7XG4gICAgICB9O1xuXG4gICAgICBIZWFwLnByb3RvdHlwZS51cGRhdGVJdGVtID0gZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gdXBkYXRlSXRlbSh0aGlzLm5vZGVzLCB4LCB0aGlzLmNtcCk7XG4gICAgICB9O1xuXG4gICAgICBIZWFwLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlcyA9IFtdO1xuICAgICAgfTtcblxuICAgICAgSGVhcC5wcm90b3R5cGUuZW1wdHkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZXMubGVuZ3RoID09PSAwO1xuICAgICAgfTtcblxuICAgICAgSGVhcC5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2Rlcy5sZW5ndGg7XG4gICAgICB9O1xuXG4gICAgICBIZWFwLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaGVhcDtcbiAgICAgICAgaGVhcCA9IG5ldyBIZWFwKCk7XG4gICAgICAgIGhlYXAubm9kZXMgPSB0aGlzLm5vZGVzLnNsaWNlKDApO1xuICAgICAgICByZXR1cm4gaGVhcDtcbiAgICAgIH07XG5cbiAgICAgIEhlYXAucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZXMuc2xpY2UoMCk7XG4gICAgICB9O1xuXG4gICAgICBIZWFwLnByb3RvdHlwZS5pbnNlcnQgPSBIZWFwLnByb3RvdHlwZS5wdXNoO1xuXG4gICAgICBIZWFwLnByb3RvdHlwZS50b3AgPSBIZWFwLnByb3RvdHlwZS5wZWVrO1xuXG4gICAgICBIZWFwLnByb3RvdHlwZS5mcm9udCA9IEhlYXAucHJvdG90eXBlLnBlZWs7XG5cbiAgICAgIEhlYXAucHJvdG90eXBlLmhhcyA9IEhlYXAucHJvdG90eXBlLmNvbnRhaW5zO1xuXG4gICAgICBIZWFwLnByb3RvdHlwZS5jb3B5ID0gSGVhcC5wcm90b3R5cGUuY2xvbmU7XG5cbiAgICAgIHJldHVybiBIZWFwO1xuXG4gICAgfSkoKTtcblxuICAgIChmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XG4gICAgICB7XG4gICAgICAgIHJldHVybiBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgICAgIH1cbiAgICB9KSh0aGlzLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBIZWFwO1xuICAgIH0pO1xuXG4gIH0pLmNhbGwoY29tbW9uanNHbG9iYWwpO1xuICB9KTtcblxuICB2YXIgaGVhcCA9IGhlYXAkMTtcblxuICB2YXIgZGlqa3N0cmFEZWZhdWx0cyA9IGRlZmF1bHRzJGcoe1xuICAgIHJvb3Q6IG51bGwsXG4gICAgd2VpZ2h0OiBmdW5jdGlvbiB3ZWlnaHQoZWRnZSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSxcbiAgICBkaXJlY3RlZDogZmFsc2VcbiAgfSk7XG4gIHZhciBlbGVzZm4kdSA9IHtcbiAgICBkaWprc3RyYTogZnVuY3Rpb24gZGlqa3N0cmEob3B0aW9ucykge1xuICAgICAgaWYgKCFwbGFpbk9iamVjdChvcHRpb25zKSkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICByb290OiBhcmdzWzBdLFxuICAgICAgICAgIHdlaWdodDogYXJnc1sxXSxcbiAgICAgICAgICBkaXJlY3RlZDogYXJnc1syXVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB2YXIgX2RpamtzdHJhRGVmYXVsdHMgPSBkaWprc3RyYURlZmF1bHRzKG9wdGlvbnMpLFxuICAgICAgICAgIHJvb3QgPSBfZGlqa3N0cmFEZWZhdWx0cy5yb290LFxuICAgICAgICAgIHdlaWdodCA9IF9kaWprc3RyYURlZmF1bHRzLndlaWdodCxcbiAgICAgICAgICBkaXJlY3RlZCA9IF9kaWprc3RyYURlZmF1bHRzLmRpcmVjdGVkO1xuXG4gICAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgICB2YXIgd2VpZ2h0Rm4gPSB3ZWlnaHQ7XG4gICAgICB2YXIgc291cmNlID0gc3RyaW5nKHJvb3QpID8gdGhpcy5maWx0ZXIocm9vdClbMF0gOiByb290WzBdO1xuICAgICAgdmFyIGRpc3QgPSB7fTtcbiAgICAgIHZhciBwcmV2ID0ge307XG4gICAgICB2YXIga25vd25EaXN0ID0ge307XG5cbiAgICAgIHZhciBfdGhpcyRieUdyb3VwID0gdGhpcy5ieUdyb3VwKCksXG4gICAgICAgICAgbm9kZXMgPSBfdGhpcyRieUdyb3VwLm5vZGVzLFxuICAgICAgICAgIGVkZ2VzID0gX3RoaXMkYnlHcm91cC5lZGdlcztcblxuICAgICAgZWRnZXMudW5tZXJnZUJ5KGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgcmV0dXJuIGVsZS5pc0xvb3AoKTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgZ2V0RGlzdCA9IGZ1bmN0aW9uIGdldERpc3Qobm9kZSkge1xuICAgICAgICByZXR1cm4gZGlzdFtub2RlLmlkKCldO1xuICAgICAgfTtcblxuICAgICAgdmFyIHNldERpc3QgPSBmdW5jdGlvbiBzZXREaXN0KG5vZGUsIGQpIHtcbiAgICAgICAgZGlzdFtub2RlLmlkKCldID0gZDtcbiAgICAgICAgUS51cGRhdGVJdGVtKG5vZGUpO1xuICAgICAgfTtcblxuICAgICAgdmFyIFEgPSBuZXcgaGVhcChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gZ2V0RGlzdChhKSAtIGdldERpc3QoYik7XG4gICAgICB9KTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBkaXN0W25vZGUuaWQoKV0gPSBub2RlLnNhbWUoc291cmNlKSA/IDAgOiBJbmZpbml0eTtcbiAgICAgICAgUS5wdXNoKG5vZGUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGlzdEJldHdlZW4gPSBmdW5jdGlvbiBkaXN0QmV0d2Vlbih1LCB2KSB7XG4gICAgICAgIHZhciB1dnMgPSAoZGlyZWN0ZWQgPyB1LmVkZ2VzVG8odikgOiB1LmVkZ2VzV2l0aCh2KSkuaW50ZXJzZWN0KGVkZ2VzKTtcbiAgICAgICAgdmFyIHNtYWxsZXN0RGlzdGFuY2UgPSBJbmZpbml0eTtcbiAgICAgICAgdmFyIHNtYWxsZXN0RWRnZTtcblxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdXZzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgIHZhciBlZGdlID0gdXZzW19pXTtcblxuICAgICAgICAgIHZhciBfd2VpZ2h0ID0gd2VpZ2h0Rm4oZWRnZSk7XG5cbiAgICAgICAgICBpZiAoX3dlaWdodCA8IHNtYWxsZXN0RGlzdGFuY2UgfHwgIXNtYWxsZXN0RWRnZSkge1xuICAgICAgICAgICAgc21hbGxlc3REaXN0YW5jZSA9IF93ZWlnaHQ7XG4gICAgICAgICAgICBzbWFsbGVzdEVkZ2UgPSBlZGdlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZWRnZTogc21hbGxlc3RFZGdlLFxuICAgICAgICAgIGRpc3Q6IHNtYWxsZXN0RGlzdGFuY2VcbiAgICAgICAgfTtcbiAgICAgIH07XG5cbiAgICAgIHdoaWxlIChRLnNpemUoKSA+IDApIHtcbiAgICAgICAgdmFyIHUgPSBRLnBvcCgpO1xuICAgICAgICB2YXIgc21hbGxldHNEaXN0ID0gZ2V0RGlzdCh1KTtcbiAgICAgICAgdmFyIHVpZCA9IHUuaWQoKTtcbiAgICAgICAga25vd25EaXN0W3VpZF0gPSBzbWFsbGV0c0Rpc3Q7XG5cbiAgICAgICAgaWYgKHNtYWxsZXRzRGlzdCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuZWlnaGJvcnMgPSB1Lm5laWdoYm9yaG9vZCgpLmludGVyc2VjdChub2Rlcyk7XG5cbiAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbmVpZ2hib3JzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgICB2YXIgdiA9IG5laWdoYm9yc1tfaTJdO1xuICAgICAgICAgIHZhciB2aWQgPSB2LmlkKCk7XG4gICAgICAgICAgdmFyIHZEaXN0ID0gZGlzdEJldHdlZW4odSwgdik7XG4gICAgICAgICAgdmFyIGFsdCA9IHNtYWxsZXRzRGlzdCArIHZEaXN0LmRpc3Q7XG5cbiAgICAgICAgICBpZiAoYWx0IDwgZ2V0RGlzdCh2KSkge1xuICAgICAgICAgICAgc2V0RGlzdCh2LCBhbHQpO1xuICAgICAgICAgICAgcHJldlt2aWRdID0ge1xuICAgICAgICAgICAgICBub2RlOiB1LFxuICAgICAgICAgICAgICBlZGdlOiB2RGlzdC5lZGdlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBmb3JcblxuICAgICAgfSAvLyB3aGlsZVxuXG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpc3RhbmNlVG86IGZ1bmN0aW9uIGRpc3RhbmNlVG8obm9kZSkge1xuICAgICAgICAgIHZhciB0YXJnZXQgPSBzdHJpbmcobm9kZSkgPyBub2Rlcy5maWx0ZXIobm9kZSlbMF0gOiBub2RlWzBdO1xuICAgICAgICAgIHJldHVybiBrbm93bkRpc3RbdGFyZ2V0LmlkKCldO1xuICAgICAgICB9LFxuICAgICAgICBwYXRoVG86IGZ1bmN0aW9uIHBhdGhUbyhub2RlKSB7XG4gICAgICAgICAgdmFyIHRhcmdldCA9IHN0cmluZyhub2RlKSA/IG5vZGVzLmZpbHRlcihub2RlKVswXSA6IG5vZGVbMF07XG4gICAgICAgICAgdmFyIFMgPSBbXTtcbiAgICAgICAgICB2YXIgdSA9IHRhcmdldDtcbiAgICAgICAgICB2YXIgdWlkID0gdS5pZCgpO1xuXG4gICAgICAgICAgaWYgKHRhcmdldC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBTLnVuc2hpZnQodGFyZ2V0KTtcblxuICAgICAgICAgICAgd2hpbGUgKHByZXZbdWlkXSkge1xuICAgICAgICAgICAgICB2YXIgcCA9IHByZXZbdWlkXTtcbiAgICAgICAgICAgICAgUy51bnNoaWZ0KHAuZWRnZSk7XG4gICAgICAgICAgICAgIFMudW5zaGlmdChwLm5vZGUpO1xuICAgICAgICAgICAgICB1ID0gcC5ub2RlO1xuICAgICAgICAgICAgICB1aWQgPSB1LmlkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGVsZXMuc3Bhd24oUyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9O1xuXG4gIHZhciBlbGVzZm4kdCA9IHtcbiAgICAvLyBrcnVza2FsJ3MgYWxnb3JpdGhtIChmaW5kcyBtaW4gc3Bhbm5pbmcgdHJlZSwgYXNzdW1pbmcgdW5kaXJlY3RlZCBncmFwaClcbiAgICAvLyBpbXBsZW1lbnRlZCBmcm9tIHBzZXVkb2NvZGUgZnJvbSB3aWtpcGVkaWFcbiAgICBrcnVza2FsOiBmdW5jdGlvbiBrcnVza2FsKHdlaWdodEZuKSB7XG4gICAgICB3ZWlnaHRGbiA9IHdlaWdodEZuIHx8IGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfTtcblxuICAgICAgdmFyIF90aGlzJGJ5R3JvdXAgPSB0aGlzLmJ5R3JvdXAoKSxcbiAgICAgICAgICBub2RlcyA9IF90aGlzJGJ5R3JvdXAubm9kZXMsXG4gICAgICAgICAgZWRnZXMgPSBfdGhpcyRieUdyb3VwLmVkZ2VzO1xuXG4gICAgICB2YXIgbnVtTm9kZXMgPSBub2Rlcy5sZW5ndGg7XG4gICAgICB2YXIgZm9yZXN0ID0gbmV3IEFycmF5KG51bU5vZGVzKTtcbiAgICAgIHZhciBBID0gbm9kZXM7IC8vIGFzc3VtZXMgYnlHcm91cCgpIGNyZWF0ZXMgbmV3IGNvbGxlY3Rpb25zIHRoYXQgY2FuIGJlIHNhZmVseSBtdXRhdGVkXG5cbiAgICAgIHZhciBmaW5kU2V0SW5kZXggPSBmdW5jdGlvbiBmaW5kU2V0SW5kZXgoZWxlKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm9yZXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVsZXMgPSBmb3Jlc3RbaV07XG5cbiAgICAgICAgICBpZiAoZWxlcy5oYXMoZWxlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9OyAvLyBzdGFydCB3aXRoIG9uZSBmb3Jlc3QgcGVyIG5vZGVcblxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKyspIHtcbiAgICAgICAgZm9yZXN0W2ldID0gdGhpcy5zcGF3bihub2Rlc1tpXSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBTID0gZWRnZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gd2VpZ2h0Rm4oYSkgLSB3ZWlnaHRGbihiKTtcbiAgICAgIH0pO1xuXG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgUy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBTW19pXTtcbiAgICAgICAgdmFyIHUgPSBlZGdlLnNvdXJjZSgpWzBdO1xuICAgICAgICB2YXIgdiA9IGVkZ2UudGFyZ2V0KClbMF07XG4gICAgICAgIHZhciBzZXRVSW5kZXggPSBmaW5kU2V0SW5kZXgodSk7XG4gICAgICAgIHZhciBzZXRWSW5kZXggPSBmaW5kU2V0SW5kZXgodik7XG4gICAgICAgIHZhciBzZXRVID0gZm9yZXN0W3NldFVJbmRleF07XG4gICAgICAgIHZhciBzZXRWID0gZm9yZXN0W3NldFZJbmRleF07XG5cbiAgICAgICAgaWYgKHNldFVJbmRleCAhPT0gc2V0VkluZGV4KSB7XG4gICAgICAgICAgQS5tZXJnZShlZGdlKTsgLy8gY29tYmluZSBmb3Jlc3RzIGZvciB1IGFuZCB2XG5cbiAgICAgICAgICBzZXRVLm1lcmdlKHNldFYpO1xuICAgICAgICAgIGZvcmVzdC5zcGxpY2Uoc2V0VkluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gQTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGFTdGFyRGVmYXVsdHMgPSBkZWZhdWx0cyRnKHtcbiAgICByb290OiBudWxsLFxuICAgIGdvYWw6IG51bGwsXG4gICAgd2VpZ2h0OiBmdW5jdGlvbiB3ZWlnaHQoZWRnZSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSxcbiAgICBoZXVyaXN0aWM6IGZ1bmN0aW9uIGhldXJpc3RpYyhlZGdlKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuICAgIGRpcmVjdGVkOiBmYWxzZVxuICB9KTtcbiAgdmFyIGVsZXNmbiRzID0ge1xuICAgIC8vIEltcGxlbWVudGVkIGZyb20gcHNldWRvY29kZSBmcm9tIHdpa2lwZWRpYVxuICAgIGFTdGFyOiBmdW5jdGlvbiBhU3RhcihvcHRpb25zKSB7XG4gICAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICAgIHZhciBfYVN0YXJEZWZhdWx0cyA9IGFTdGFyRGVmYXVsdHMob3B0aW9ucyksXG4gICAgICAgICAgcm9vdCA9IF9hU3RhckRlZmF1bHRzLnJvb3QsXG4gICAgICAgICAgZ29hbCA9IF9hU3RhckRlZmF1bHRzLmdvYWwsXG4gICAgICAgICAgaGV1cmlzdGljID0gX2FTdGFyRGVmYXVsdHMuaGV1cmlzdGljLFxuICAgICAgICAgIGRpcmVjdGVkID0gX2FTdGFyRGVmYXVsdHMuZGlyZWN0ZWQsXG4gICAgICAgICAgd2VpZ2h0ID0gX2FTdGFyRGVmYXVsdHMud2VpZ2h0O1xuXG4gICAgICByb290ID0gY3kuY29sbGVjdGlvbihyb290KVswXTtcbiAgICAgIGdvYWwgPSBjeS5jb2xsZWN0aW9uKGdvYWwpWzBdO1xuICAgICAgdmFyIHNpZCA9IHJvb3QuaWQoKTtcbiAgICAgIHZhciB0aWQgPSBnb2FsLmlkKCk7XG4gICAgICB2YXIgZ1Njb3JlID0ge307XG4gICAgICB2YXIgZlNjb3JlID0ge307XG4gICAgICB2YXIgY2xvc2VkU2V0SWRzID0ge307XG4gICAgICB2YXIgb3BlblNldCA9IG5ldyBoZWFwKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBmU2NvcmVbYS5pZCgpXSAtIGZTY29yZVtiLmlkKCldO1xuICAgICAgfSk7XG4gICAgICB2YXIgb3BlblNldElkcyA9IG5ldyBTZXQkMSgpO1xuICAgICAgdmFyIGNhbWVGcm9tID0ge307XG4gICAgICB2YXIgY2FtZUZyb21FZGdlID0ge307XG5cbiAgICAgIHZhciBhZGRUb09wZW5TZXQgPSBmdW5jdGlvbiBhZGRUb09wZW5TZXQoZWxlLCBpZCkge1xuICAgICAgICBvcGVuU2V0LnB1c2goZWxlKTtcbiAgICAgICAgb3BlblNldElkcy5hZGQoaWQpO1xuICAgICAgfTtcblxuICAgICAgdmFyIGNNaW4sIGNNaW5JZDtcblxuICAgICAgdmFyIHBvcEZyb21PcGVuU2V0ID0gZnVuY3Rpb24gcG9wRnJvbU9wZW5TZXQoKSB7XG4gICAgICAgIGNNaW4gPSBvcGVuU2V0LnBvcCgpO1xuICAgICAgICBjTWluSWQgPSBjTWluLmlkKCk7XG4gICAgICAgIG9wZW5TZXRJZHNbXCJkZWxldGVcIl0oY01pbklkKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBpc0luT3BlblNldCA9IGZ1bmN0aW9uIGlzSW5PcGVuU2V0KGlkKSB7XG4gICAgICAgIHJldHVybiBvcGVuU2V0SWRzLmhhcyhpZCk7XG4gICAgICB9O1xuXG4gICAgICBhZGRUb09wZW5TZXQocm9vdCwgc2lkKTtcbiAgICAgIGdTY29yZVtzaWRdID0gMDtcbiAgICAgIGZTY29yZVtzaWRdID0gaGV1cmlzdGljKHJvb3QpOyAvLyBDb3VudGVyXG5cbiAgICAgIHZhciBzdGVwcyA9IDA7IC8vIE1haW4gbG9vcFxuXG4gICAgICB3aGlsZSAob3BlblNldC5zaXplKCkgPiAwKSB7XG4gICAgICAgIHBvcEZyb21PcGVuU2V0KCk7XG4gICAgICAgIHN0ZXBzKys7IC8vIElmIHdlJ3ZlIGZvdW5kIG91ciBnb2FsLCB0aGVuIHdlIGFyZSBkb25lXG5cbiAgICAgICAgaWYgKGNNaW5JZCA9PT0gdGlkKSB7XG4gICAgICAgICAgdmFyIHBhdGggPSBbXTtcbiAgICAgICAgICB2YXIgcGF0aE5vZGUgPSBnb2FsO1xuICAgICAgICAgIHZhciBwYXRoTm9kZUlkID0gdGlkO1xuICAgICAgICAgIHZhciBwYXRoRWRnZSA9IGNhbWVGcm9tRWRnZVtwYXRoTm9kZUlkXTtcblxuICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIHBhdGgudW5zaGlmdChwYXRoTm9kZSk7XG5cbiAgICAgICAgICAgIGlmIChwYXRoRWRnZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHBhdGgudW5zaGlmdChwYXRoRWRnZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBhdGhOb2RlID0gY2FtZUZyb21bcGF0aE5vZGVJZF07XG5cbiAgICAgICAgICAgIGlmIChwYXRoTm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwYXRoTm9kZUlkID0gcGF0aE5vZGUuaWQoKTtcbiAgICAgICAgICAgIHBhdGhFZGdlID0gY2FtZUZyb21FZGdlW3BhdGhOb2RlSWRdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmb3VuZDogdHJ1ZSxcbiAgICAgICAgICAgIGRpc3RhbmNlOiBnU2NvcmVbY01pbklkXSxcbiAgICAgICAgICAgIHBhdGg6IHRoaXMuc3Bhd24ocGF0aCksXG4gICAgICAgICAgICBzdGVwczogc3RlcHNcbiAgICAgICAgICB9O1xuICAgICAgICB9IC8vIEFkZCBjTWluIHRvIHByb2Nlc3NlZCBub2Rlc1xuXG5cbiAgICAgICAgY2xvc2VkU2V0SWRzW2NNaW5JZF0gPSB0cnVlOyAvLyBVcGRhdGUgc2NvcmVzIGZvciBuZWlnaGJvcnMgb2YgY01pblxuICAgICAgICAvLyBUYWtlIGludG8gYWNjb3VudCBpZiBncmFwaCBpcyBkaXJlY3RlZCBvciBub3RcblxuICAgICAgICB2YXIgdndFZGdlcyA9IGNNaW4uX3ByaXZhdGUuZWRnZXM7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2d0VkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGUgPSB2d0VkZ2VzW2ldOyAvLyBlZGdlIG11c3QgYmUgaW4gc2V0IG9mIGNhbGxpbmcgZWxlc1xuXG4gICAgICAgICAgaWYgKCF0aGlzLmhhc0VsZW1lbnRXaXRoSWQoZS5pZCgpKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSAvLyBjTWluIG11c3QgYmUgdGhlIHNvdXJjZSBvZiBlZGdlIGlmIGRpcmVjdGVkXG5cblxuICAgICAgICAgIGlmIChkaXJlY3RlZCAmJiBlLmRhdGEoJ3NvdXJjZScpICE9PSBjTWluSWQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciB3U3JjID0gZS5zb3VyY2UoKTtcbiAgICAgICAgICB2YXIgd1RndCA9IGUudGFyZ2V0KCk7XG4gICAgICAgICAgdmFyIHcgPSB3U3JjLmlkKCkgIT09IGNNaW5JZCA/IHdTcmMgOiB3VGd0O1xuICAgICAgICAgIHZhciB3aWQgPSB3LmlkKCk7IC8vIG5vZGUgbXVzdCBiZSBpbiBzZXQgb2YgY2FsbGluZyBlbGVzXG5cbiAgICAgICAgICBpZiAoIXRoaXMuaGFzRWxlbWVudFdpdGhJZCh3aWQpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IC8vIGlmIG5vZGUgaXMgaW4gY2xvc2VkU2V0LCBpZ25vcmUgaXRcblxuXG4gICAgICAgICAgaWYgKGNsb3NlZFNldElkc1t3aWRdKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IC8vIE5ldyB0ZW50YXRpdmUgc2NvcmUgZm9yIG5vZGUgd1xuXG5cbiAgICAgICAgICB2YXIgdGVtcFNjb3JlID0gZ1Njb3JlW2NNaW5JZF0gKyB3ZWlnaHQoZSk7IC8vIFVwZGF0ZSBnU2NvcmUgZm9yIG5vZGUgdyBpZjpcbiAgICAgICAgICAvLyAgIHcgbm90IHByZXNlbnQgaW4gb3BlblNldFxuICAgICAgICAgIC8vIE9SXG4gICAgICAgICAgLy8gICB0ZW50YXRpdmUgZ1Njb3JlIGlzIGxlc3MgdGhhbiBwcmV2aW91cyB2YWx1ZVxuICAgICAgICAgIC8vIHcgbm90IGluIG9wZW5TZXRcblxuICAgICAgICAgIGlmICghaXNJbk9wZW5TZXQod2lkKSkge1xuICAgICAgICAgICAgZ1Njb3JlW3dpZF0gPSB0ZW1wU2NvcmU7XG4gICAgICAgICAgICBmU2NvcmVbd2lkXSA9IHRlbXBTY29yZSArIGhldXJpc3RpYyh3KTtcbiAgICAgICAgICAgIGFkZFRvT3BlblNldCh3LCB3aWQpO1xuICAgICAgICAgICAgY2FtZUZyb21bd2lkXSA9IGNNaW47XG4gICAgICAgICAgICBjYW1lRnJvbUVkZ2Vbd2lkXSA9IGU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IC8vIHcgYWxyZWFkeSBpbiBvcGVuU2V0LCBidXQgd2l0aCBncmVhdGVyIGdTY29yZVxuXG5cbiAgICAgICAgICBpZiAodGVtcFNjb3JlIDwgZ1Njb3JlW3dpZF0pIHtcbiAgICAgICAgICAgIGdTY29yZVt3aWRdID0gdGVtcFNjb3JlO1xuICAgICAgICAgICAgZlNjb3JlW3dpZF0gPSB0ZW1wU2NvcmUgKyBoZXVyaXN0aWModyk7XG4gICAgICAgICAgICBjYW1lRnJvbVt3aWRdID0gY01pbjtcbiAgICAgICAgICAgIGNhbWVGcm9tRWRnZVt3aWRdID0gZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gRW5kIG9mIG5laWdoYm9ycyB1cGRhdGVcblxuICAgICAgfSAvLyBFbmQgb2YgbWFpbiBsb29wXG4gICAgICAvLyBJZiB3ZSd2ZSByZWFjaGVkIGhlcmUsIHRoZW4gd2UndmUgbm90IHJlYWNoZWQgb3VyIGdvYWxcblxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBmb3VuZDogZmFsc2UsXG4gICAgICAgIGRpc3RhbmNlOiB1bmRlZmluZWQsXG4gICAgICAgIHBhdGg6IHVuZGVmaW5lZCxcbiAgICAgICAgc3RlcHM6IHN0ZXBzXG4gICAgICB9O1xuICAgIH1cbiAgfTsgLy8gZWxlc2ZuXG5cbiAgdmFyIGZsb3lkV2Fyc2hhbGxEZWZhdWx0cyA9IGRlZmF1bHRzJGcoe1xuICAgIHdlaWdodDogZnVuY3Rpb24gd2VpZ2h0KGVkZ2UpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0sXG4gICAgZGlyZWN0ZWQ6IGZhbHNlXG4gIH0pO1xuICB2YXIgZWxlc2ZuJHIgPSB7XG4gICAgLy8gSW1wbGVtZW50ZWQgZnJvbSBwc2V1ZG9jb2RlIGZyb20gd2lraXBlZGlhXG4gICAgZmxveWRXYXJzaGFsbDogZnVuY3Rpb24gZmxveWRXYXJzaGFsbChvcHRpb25zKSB7XG4gICAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICAgIHZhciBfZmxveWRXYXJzaGFsbERlZmF1bHQgPSBmbG95ZFdhcnNoYWxsRGVmYXVsdHMob3B0aW9ucyksXG4gICAgICAgICAgd2VpZ2h0ID0gX2Zsb3lkV2Fyc2hhbGxEZWZhdWx0LndlaWdodCxcbiAgICAgICAgICBkaXJlY3RlZCA9IF9mbG95ZFdhcnNoYWxsRGVmYXVsdC5kaXJlY3RlZDtcblxuICAgICAgdmFyIHdlaWdodEZuID0gd2VpZ2h0O1xuXG4gICAgICB2YXIgX3RoaXMkYnlHcm91cCA9IHRoaXMuYnlHcm91cCgpLFxuICAgICAgICAgIG5vZGVzID0gX3RoaXMkYnlHcm91cC5ub2RlcyxcbiAgICAgICAgICBlZGdlcyA9IF90aGlzJGJ5R3JvdXAuZWRnZXM7XG5cbiAgICAgIHZhciBOID0gbm9kZXMubGVuZ3RoO1xuICAgICAgdmFyIE5zcSA9IE4gKiBOO1xuXG4gICAgICB2YXIgaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2Yobm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZXMuaW5kZXhPZihub2RlKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBhdEluZGV4ID0gZnVuY3Rpb24gYXRJbmRleChpKSB7XG4gICAgICAgIHJldHVybiBub2Rlc1tpXTtcbiAgICAgIH07IC8vIEluaXRpYWxpemUgZGlzdGFuY2UgbWF0cml4XG5cblxuICAgICAgdmFyIGRpc3QgPSBuZXcgQXJyYXkoTnNxKTtcblxuICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBOc3E7IG4rKykge1xuICAgICAgICB2YXIgaiA9IG4gJSBOO1xuICAgICAgICB2YXIgaSA9IChuIC0gaikgLyBOO1xuXG4gICAgICAgIGlmIChpID09PSBqKSB7XG4gICAgICAgICAgZGlzdFtuXSA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGlzdFtuXSA9IEluZmluaXR5O1xuICAgICAgICB9XG4gICAgICB9IC8vIEluaXRpYWxpemUgbWF0cml4IHVzZWQgZm9yIHBhdGggcmVjb25zdHJ1Y3Rpb25cbiAgICAgIC8vIEluaXRpYWxpemUgZGlzdGFuY2UgbWF0cml4XG5cblxuICAgICAgdmFyIG5leHQgPSBuZXcgQXJyYXkoTnNxKTtcbiAgICAgIHZhciBlZGdlTmV4dCA9IG5ldyBBcnJheShOc3EpOyAvLyBQcm9jZXNzIGVkZ2VzXG5cbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBlZGdlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tfaV07XG4gICAgICAgIHZhciBzcmMgPSBlZGdlLnNvdXJjZSgpWzBdO1xuICAgICAgICB2YXIgdGd0ID0gZWRnZS50YXJnZXQoKVswXTtcblxuICAgICAgICBpZiAoc3JjID09PSB0Z3QpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBleGNsdWRlIGxvb3BzXG5cblxuICAgICAgICB2YXIgcyA9IGluZGV4T2Yoc3JjKTtcbiAgICAgICAgdmFyIHQgPSBpbmRleE9mKHRndCk7XG4gICAgICAgIHZhciBzdCA9IHMgKiBOICsgdDsgLy8gc291cmNlIHRvIHRhcmdldCBpbmRleFxuXG4gICAgICAgIHZhciBfd2VpZ2h0ID0gd2VpZ2h0Rm4oZWRnZSk7IC8vIENoZWNrIGlmIGFscmVhZHkgcHJvY2VzcyBhbm90aGVyIGVkZ2UgYmV0d2VlbiBzYW1lIDIgbm9kZXNcblxuXG4gICAgICAgIGlmIChkaXN0W3N0XSA+IF93ZWlnaHQpIHtcbiAgICAgICAgICBkaXN0W3N0XSA9IF93ZWlnaHQ7XG4gICAgICAgICAgbmV4dFtzdF0gPSB0O1xuICAgICAgICAgIGVkZ2VOZXh0W3N0XSA9IGVkZ2U7XG4gICAgICAgIH0gLy8gSWYgdW5kaXJlY3RlZCBncmFwaCwgcHJvY2VzcyAncmV2ZXJzZWQnIGVkZ2VcblxuXG4gICAgICAgIGlmICghZGlyZWN0ZWQpIHtcbiAgICAgICAgICB2YXIgdHMgPSB0ICogTiArIHM7IC8vIHRhcmdldCB0byBzb3VyY2UgaW5kZXhcblxuICAgICAgICAgIGlmICghZGlyZWN0ZWQgJiYgZGlzdFt0c10gPiBfd2VpZ2h0KSB7XG4gICAgICAgICAgICBkaXN0W3RzXSA9IF93ZWlnaHQ7XG4gICAgICAgICAgICBuZXh0W3RzXSA9IHM7XG4gICAgICAgICAgICBlZGdlTmV4dFt0c10gPSBlZGdlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBNYWluIGxvb3BcblxuXG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IE47IGsrKykge1xuICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBOOyBfaTIrKykge1xuICAgICAgICAgIHZhciBpayA9IF9pMiAqIE4gKyBrO1xuXG4gICAgICAgICAgZm9yICh2YXIgX2ogPSAwOyBfaiA8IE47IF9qKyspIHtcbiAgICAgICAgICAgIHZhciBpaiA9IF9pMiAqIE4gKyBfajtcbiAgICAgICAgICAgIHZhciBraiA9IGsgKiBOICsgX2o7XG5cbiAgICAgICAgICAgIGlmIChkaXN0W2lrXSArIGRpc3Rba2pdIDwgZGlzdFtpal0pIHtcbiAgICAgICAgICAgICAgZGlzdFtpal0gPSBkaXN0W2lrXSArIGRpc3Rba2pdO1xuICAgICAgICAgICAgICBuZXh0W2lqXSA9IG5leHRbaWtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZ2V0QXJnRWxlID0gZnVuY3Rpb24gZ2V0QXJnRWxlKGVsZSkge1xuICAgICAgICByZXR1cm4gKHN0cmluZyhlbGUpID8gY3kuZmlsdGVyKGVsZSkgOiBlbGUpWzBdO1xuICAgICAgfTtcblxuICAgICAgdmFyIGluZGV4T2ZBcmdFbGUgPSBmdW5jdGlvbiBpbmRleE9mQXJnRWxlKGVsZSkge1xuICAgICAgICByZXR1cm4gaW5kZXhPZihnZXRBcmdFbGUoZWxlKSk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgcmVzID0ge1xuICAgICAgICBkaXN0YW5jZTogZnVuY3Rpb24gZGlzdGFuY2UoZnJvbSwgdG8pIHtcbiAgICAgICAgICB2YXIgaSA9IGluZGV4T2ZBcmdFbGUoZnJvbSk7XG4gICAgICAgICAgdmFyIGogPSBpbmRleE9mQXJnRWxlKHRvKTtcbiAgICAgICAgICByZXR1cm4gZGlzdFtpICogTiArIGpdO1xuICAgICAgICB9LFxuICAgICAgICBwYXRoOiBmdW5jdGlvbiBwYXRoKGZyb20sIHRvKSB7XG4gICAgICAgICAgdmFyIGkgPSBpbmRleE9mQXJnRWxlKGZyb20pO1xuICAgICAgICAgIHZhciBqID0gaW5kZXhPZkFyZ0VsZSh0byk7XG4gICAgICAgICAgdmFyIGZyb21Ob2RlID0gYXRJbmRleChpKTtcblxuICAgICAgICAgIGlmIChpID09PSBqKSB7XG4gICAgICAgICAgICByZXR1cm4gZnJvbU5vZGUuY29sbGVjdGlvbigpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChuZXh0W2kgKiBOICsgal0gPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGN5LmNvbGxlY3Rpb24oKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcGF0aCA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICAgICAgICB2YXIgcHJldiA9IGk7XG4gICAgICAgICAgdmFyIGVkZ2U7XG4gICAgICAgICAgcGF0aC5tZXJnZShmcm9tTm9kZSk7XG5cbiAgICAgICAgICB3aGlsZSAoaSAhPT0gaikge1xuICAgICAgICAgICAgcHJldiA9IGk7XG4gICAgICAgICAgICBpID0gbmV4dFtpICogTiArIGpdO1xuICAgICAgICAgICAgZWRnZSA9IGVkZ2VOZXh0W3ByZXYgKiBOICsgaV07XG4gICAgICAgICAgICBwYXRoLm1lcmdlKGVkZ2UpO1xuICAgICAgICAgICAgcGF0aC5tZXJnZShhdEluZGV4KGkpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfSAvLyBmbG95ZFdhcnNoYWxsXG5cbiAgfTsgLy8gZWxlc2ZuXG5cbiAgdmFyIGJlbGxtYW5Gb3JkRGVmYXVsdHMgPSBkZWZhdWx0cyRnKHtcbiAgICB3ZWlnaHQ6IGZ1bmN0aW9uIHdlaWdodChlZGdlKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9LFxuICAgIGRpcmVjdGVkOiBmYWxzZSxcbiAgICByb290OiBudWxsXG4gIH0pO1xuICB2YXIgZWxlc2ZuJHEgPSB7XG4gICAgLy8gSW1wbGVtZW50ZWQgZnJvbSBwc2V1ZG9jb2RlIGZyb20gd2lraXBlZGlhXG4gICAgYmVsbG1hbkZvcmQ6IGZ1bmN0aW9uIGJlbGxtYW5Gb3JkKG9wdGlvbnMpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBfYmVsbG1hbkZvcmREZWZhdWx0cyA9IGJlbGxtYW5Gb3JkRGVmYXVsdHMob3B0aW9ucyksXG4gICAgICAgICAgd2VpZ2h0ID0gX2JlbGxtYW5Gb3JkRGVmYXVsdHMud2VpZ2h0LFxuICAgICAgICAgIGRpcmVjdGVkID0gX2JlbGxtYW5Gb3JkRGVmYXVsdHMuZGlyZWN0ZWQsXG4gICAgICAgICAgcm9vdCA9IF9iZWxsbWFuRm9yZERlZmF1bHRzLnJvb3Q7XG5cbiAgICAgIHZhciB3ZWlnaHRGbiA9IHdlaWdodDtcbiAgICAgIHZhciBlbGVzID0gdGhpcztcbiAgICAgIHZhciBjeSA9IHRoaXMuY3koKTtcblxuICAgICAgdmFyIF90aGlzJGJ5R3JvdXAgPSB0aGlzLmJ5R3JvdXAoKSxcbiAgICAgICAgICBlZGdlcyA9IF90aGlzJGJ5R3JvdXAuZWRnZXMsXG4gICAgICAgICAgbm9kZXMgPSBfdGhpcyRieUdyb3VwLm5vZGVzO1xuXG4gICAgICB2YXIgbnVtTm9kZXMgPSBub2Rlcy5sZW5ndGg7XG4gICAgICB2YXIgaW5mb01hcCA9IG5ldyBNYXAkMigpO1xuICAgICAgdmFyIGhhc05lZ2F0aXZlV2VpZ2h0Q3ljbGUgPSBmYWxzZTtcbiAgICAgIHZhciBuZWdhdGl2ZVdlaWdodEN5Y2xlcyA9IFtdO1xuICAgICAgcm9vdCA9IGN5LmNvbGxlY3Rpb24ocm9vdClbMF07IC8vIGluIGNhc2Ugc2VsZWN0b3IgcGFzc2VkXG5cbiAgICAgIGVkZ2VzLnVubWVyZ2VCeShmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICByZXR1cm4gZWRnZS5pc0xvb3AoKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIG51bUVkZ2VzID0gZWRnZXMubGVuZ3RoO1xuXG4gICAgICB2YXIgZ2V0SW5mbyA9IGZ1bmN0aW9uIGdldEluZm8obm9kZSkge1xuICAgICAgICB2YXIgb2JqID0gaW5mb01hcC5nZXQobm9kZS5pZCgpKTtcblxuICAgICAgICBpZiAoIW9iaikge1xuICAgICAgICAgIG9iaiA9IHt9O1xuICAgICAgICAgIGluZm9NYXAuc2V0KG5vZGUuaWQoKSwgb2JqKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgICB9O1xuXG4gICAgICB2YXIgZ2V0Tm9kZUZyb21UbyA9IGZ1bmN0aW9uIGdldE5vZGVGcm9tVG8odG8pIHtcbiAgICAgICAgcmV0dXJuIChzdHJpbmcodG8pID8gY3kuJCh0bykgOiB0bylbMF07XG4gICAgICB9O1xuXG4gICAgICB2YXIgZGlzdGFuY2VUbyA9IGZ1bmN0aW9uIGRpc3RhbmNlVG8odG8pIHtcbiAgICAgICAgcmV0dXJuIGdldEluZm8oZ2V0Tm9kZUZyb21Ubyh0bykpLmRpc3Q7XG4gICAgICB9O1xuXG4gICAgICB2YXIgcGF0aFRvID0gZnVuY3Rpb24gcGF0aFRvKHRvKSB7XG4gICAgICAgIHZhciB0aGlzU3RhcnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHJvb3Q7XG4gICAgICAgIHZhciBlbmQgPSBnZXROb2RlRnJvbVRvKHRvKTtcbiAgICAgICAgdmFyIHBhdGggPSBbXTtcbiAgICAgICAgdmFyIG5vZGUgPSBlbmQ7XG5cbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5zcGF3bigpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfZ2V0SW5mbyA9IGdldEluZm8obm9kZSksXG4gICAgICAgICAgICAgIGVkZ2UgPSBfZ2V0SW5mby5lZGdlLFxuICAgICAgICAgICAgICBwcmVkID0gX2dldEluZm8ucHJlZDtcblxuICAgICAgICAgIHBhdGgudW5zaGlmdChub2RlWzBdKTtcblxuICAgICAgICAgIGlmIChub2RlLnNhbWUodGhpc1N0YXJ0KSAmJiBwYXRoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChlZGdlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHBhdGgudW5zaGlmdChlZGdlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBub2RlID0gcHJlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlbGVzLnNwYXduKHBhdGgpO1xuICAgICAgfTsgLy8gSW5pdGlhbGl6YXRpb25zIHsgZGlzdCwgcHJlZCwgZWRnZSB9XG5cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIHZhciBpbmZvID0gZ2V0SW5mbyhub2RlKTtcblxuICAgICAgICBpZiAobm9kZS5zYW1lKHJvb3QpKSB7XG4gICAgICAgICAgaW5mby5kaXN0ID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbmZvLmRpc3QgPSBJbmZpbml0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIGluZm8ucHJlZCA9IG51bGw7XG4gICAgICAgIGluZm8uZWRnZSA9IG51bGw7XG4gICAgICB9IC8vIEVkZ2VzIHJlbGF4YXRpb25cblxuXG4gICAgICB2YXIgcmVwbGFjZWRFZGdlID0gZmFsc2U7XG5cbiAgICAgIHZhciBjaGVja0ZvckVkZ2VSZXBsYWNlbWVudCA9IGZ1bmN0aW9uIGNoZWNrRm9yRWRnZVJlcGxhY2VtZW50KG5vZGUxLCBub2RlMiwgZWRnZSwgaW5mbzEsIGluZm8yLCB3ZWlnaHQpIHtcbiAgICAgICAgdmFyIGRpc3QgPSBpbmZvMS5kaXN0ICsgd2VpZ2h0O1xuXG4gICAgICAgIGlmIChkaXN0IDwgaW5mbzIuZGlzdCAmJiAhZWRnZS5zYW1lKGluZm8xLmVkZ2UpKSB7XG4gICAgICAgICAgaW5mbzIuZGlzdCA9IGRpc3Q7XG4gICAgICAgICAgaW5mbzIucHJlZCA9IG5vZGUxO1xuICAgICAgICAgIGluZm8yLmVkZ2UgPSBlZGdlO1xuICAgICAgICAgIHJlcGxhY2VkRWRnZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBudW1Ob2RlczsgX2krKykge1xuICAgICAgICByZXBsYWNlZEVkZ2UgPSBmYWxzZTtcblxuICAgICAgICBmb3IgKHZhciBlID0gMDsgZSA8IG51bUVkZ2VzOyBlKyspIHtcbiAgICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2VdO1xuICAgICAgICAgIHZhciBzcmMgPSBlZGdlLnNvdXJjZSgpO1xuICAgICAgICAgIHZhciB0Z3QgPSBlZGdlLnRhcmdldCgpO1xuXG4gICAgICAgICAgdmFyIF93ZWlnaHQgPSB3ZWlnaHRGbihlZGdlKTtcblxuICAgICAgICAgIHZhciBzcmNJbmZvID0gZ2V0SW5mbyhzcmMpO1xuICAgICAgICAgIHZhciB0Z3RJbmZvID0gZ2V0SW5mbyh0Z3QpO1xuICAgICAgICAgIGNoZWNrRm9yRWRnZVJlcGxhY2VtZW50KHNyYywgdGd0LCBlZGdlLCBzcmNJbmZvLCB0Z3RJbmZvLCBfd2VpZ2h0KTsgLy8gSWYgdW5kaXJlY3RlZCBncmFwaCwgd2UgbmVlZCB0byB0YWtlIGludG8gYWNjb3VudCB0aGUgJ3JldmVyc2UnIGVkZ2VcblxuICAgICAgICAgIGlmICghZGlyZWN0ZWQpIHtcbiAgICAgICAgICAgIGNoZWNrRm9yRWRnZVJlcGxhY2VtZW50KHRndCwgc3JjLCBlZGdlLCB0Z3RJbmZvLCBzcmNJbmZvLCBfd2VpZ2h0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXJlcGxhY2VkRWRnZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXBsYWNlZEVkZ2UpIHtcbiAgICAgICAgLy8gQ2hlY2sgZm9yIG5lZ2F0aXZlIHdlaWdodCBjeWNsZXNcbiAgICAgICAgdmFyIG5lZ2F0aXZlV2VpZ2h0Q3ljbGVJZHMgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBfZSA9IDA7IF9lIDwgbnVtRWRnZXM7IF9lKyspIHtcbiAgICAgICAgICB2YXIgX2VkZ2UgPSBlZGdlc1tfZV07XG5cbiAgICAgICAgICB2YXIgX3NyYyA9IF9lZGdlLnNvdXJjZSgpO1xuXG4gICAgICAgICAgdmFyIF90Z3QgPSBfZWRnZS50YXJnZXQoKTtcblxuICAgICAgICAgIHZhciBfd2VpZ2h0MiA9IHdlaWdodEZuKF9lZGdlKTtcblxuICAgICAgICAgIHZhciBzcmNEaXN0ID0gZ2V0SW5mbyhfc3JjKS5kaXN0O1xuICAgICAgICAgIHZhciB0Z3REaXN0ID0gZ2V0SW5mbyhfdGd0KS5kaXN0O1xuXG4gICAgICAgICAgaWYgKHNyY0Rpc3QgKyBfd2VpZ2h0MiA8IHRndERpc3QgfHwgIWRpcmVjdGVkICYmIHRndERpc3QgKyBfd2VpZ2h0MiA8IHNyY0Rpc3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzTmVnYXRpdmVXZWlnaHRDeWNsZSkge1xuICAgICAgICAgICAgICB3YXJuKCdHcmFwaCBjb250YWlucyBhIG5lZ2F0aXZlIHdlaWdodCBjeWNsZSBmb3IgQmVsbG1hbi1Gb3JkJyk7XG4gICAgICAgICAgICAgIGhhc05lZ2F0aXZlV2VpZ2h0Q3ljbGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5maW5kTmVnYXRpdmVXZWlnaHRDeWNsZXMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIHZhciBuZWdhdGl2ZU5vZGVzID0gW107XG5cbiAgICAgICAgICAgICAgaWYgKHNyY0Rpc3QgKyBfd2VpZ2h0MiA8IHRndERpc3QpIHtcbiAgICAgICAgICAgICAgICBuZWdhdGl2ZU5vZGVzLnB1c2goX3NyYyk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIWRpcmVjdGVkICYmIHRndERpc3QgKyBfd2VpZ2h0MiA8IHNyY0Rpc3QpIHtcbiAgICAgICAgICAgICAgICBuZWdhdGl2ZU5vZGVzLnB1c2goX3RndCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgbnVtTmVnYXRpdmVOb2RlcyA9IG5lZ2F0aXZlTm9kZXMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgbnVtTmVnYXRpdmVOb2RlczsgbisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gbmVnYXRpdmVOb2Rlc1tuXTtcbiAgICAgICAgICAgICAgICB2YXIgY3ljbGUgPSBbc3RhcnRdO1xuICAgICAgICAgICAgICAgIGN5Y2xlLnB1c2goZ2V0SW5mbyhzdGFydCkuZWRnZSk7XG4gICAgICAgICAgICAgICAgdmFyIF9ub2RlID0gZ2V0SW5mbyhzdGFydCkucHJlZDtcblxuICAgICAgICAgICAgICAgIHdoaWxlIChjeWNsZS5pbmRleE9mKF9ub2RlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgIGN5Y2xlLnB1c2goX25vZGUpO1xuICAgICAgICAgICAgICAgICAgY3ljbGUucHVzaChnZXRJbmZvKF9ub2RlKS5lZGdlKTtcbiAgICAgICAgICAgICAgICAgIF9ub2RlID0gZ2V0SW5mbyhfbm9kZSkucHJlZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjeWNsZSA9IGN5Y2xlLnNsaWNlKGN5Y2xlLmluZGV4T2YoX25vZGUpKTtcbiAgICAgICAgICAgICAgICB2YXIgc21hbGxlc3RJZCA9IGN5Y2xlWzBdLmlkKCk7XG4gICAgICAgICAgICAgICAgdmFyIHNtYWxsZXN0SW5kZXggPSAwO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYyA9IDI7IGMgPCBjeWNsZS5sZW5ndGg7IGMgKz0gMikge1xuICAgICAgICAgICAgICAgICAgaWYgKGN5Y2xlW2NdLmlkKCkgPCBzbWFsbGVzdElkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNtYWxsZXN0SWQgPSBjeWNsZVtjXS5pZCgpO1xuICAgICAgICAgICAgICAgICAgICBzbWFsbGVzdEluZGV4ID0gYztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjeWNsZSA9IGN5Y2xlLnNsaWNlKHNtYWxsZXN0SW5kZXgpLmNvbmNhdChjeWNsZS5zbGljZSgwLCBzbWFsbGVzdEluZGV4KSk7XG4gICAgICAgICAgICAgICAgY3ljbGUucHVzaChjeWNsZVswXSk7XG4gICAgICAgICAgICAgICAgdmFyIGN5Y2xlSWQgPSBjeWNsZS5tYXAoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZWwuaWQoKTtcbiAgICAgICAgICAgICAgICB9KS5qb2luKFwiLFwiKTtcblxuICAgICAgICAgICAgICAgIGlmIChuZWdhdGl2ZVdlaWdodEN5Y2xlSWRzLmluZGV4T2YoY3ljbGVJZCkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICBuZWdhdGl2ZVdlaWdodEN5Y2xlcy5wdXNoKGVsZXMuc3Bhd24oY3ljbGUpKTtcbiAgICAgICAgICAgICAgICAgIG5lZ2F0aXZlV2VpZ2h0Q3ljbGVJZHMucHVzaChjeWNsZUlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXN0YW5jZVRvOiBkaXN0YW5jZVRvLFxuICAgICAgICBwYXRoVG86IHBhdGhUbyxcbiAgICAgICAgaGFzTmVnYXRpdmVXZWlnaHRDeWNsZTogaGFzTmVnYXRpdmVXZWlnaHRDeWNsZSxcbiAgICAgICAgbmVnYXRpdmVXZWlnaHRDeWNsZXM6IG5lZ2F0aXZlV2VpZ2h0Q3ljbGVzXG4gICAgICB9O1xuICAgIH0gLy8gYmVsbG1hbkZvcmRcblxuICB9OyAvLyBlbGVzZm5cblxuICB2YXIgc3FydDIgPSBNYXRoLnNxcnQoMik7IC8vIEZ1bmN0aW9uIHdoaWNoIGNvbGFwc2VzIDIgKG1ldGEpIG5vZGVzIGludG8gb25lXG4gIC8vIFVwZGF0ZXMgdGhlIHJlbWFpbmluZyBlZGdlIGxpc3RzXG4gIC8vIFJlY2VpdmVzIGFzIGEgcGFyYW1hdGVyIHRoZSBlZGdlIHdoaWNoIGNhdXNlcyB0aGUgY29sbGFwc2VcblxuICB2YXIgY29sbGFwc2UgPSBmdW5jdGlvbiBjb2xsYXBzZShlZGdlSW5kZXgsIG5vZGVNYXAsIHJlbWFpbmluZ0VkZ2VzKSB7XG4gICAgaWYgKHJlbWFpbmluZ0VkZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZXJyb3IoXCJLYXJnZXItU3RlaW4gbXVzdCBiZSBydW4gb24gYSBjb25uZWN0ZWQgKHN1YilncmFwaFwiKTtcbiAgICB9XG5cbiAgICB2YXIgZWRnZUluZm8gPSByZW1haW5pbmdFZGdlc1tlZGdlSW5kZXhdO1xuICAgIHZhciBzb3VyY2VJbiA9IGVkZ2VJbmZvWzFdO1xuICAgIHZhciB0YXJnZXRJbiA9IGVkZ2VJbmZvWzJdO1xuICAgIHZhciBwYXJ0aXRpb24xID0gbm9kZU1hcFtzb3VyY2VJbl07XG4gICAgdmFyIHBhcnRpdGlvbjIgPSBub2RlTWFwW3RhcmdldEluXTtcbiAgICB2YXIgbmV3RWRnZXMgPSByZW1haW5pbmdFZGdlczsgLy8gcmUtdXNlIGFycmF5XG4gICAgLy8gRGVsZXRlIGFsbCBlZGdlcyBiZXR3ZWVuIHBhcnRpdGlvbjEgYW5kIHBhcnRpdGlvbjJcblxuICAgIGZvciAodmFyIGkgPSBuZXdFZGdlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGVkZ2UgPSBuZXdFZGdlc1tpXTtcbiAgICAgIHZhciBzcmMgPSBlZGdlWzFdO1xuICAgICAgdmFyIHRndCA9IGVkZ2VbMl07XG5cbiAgICAgIGlmIChub2RlTWFwW3NyY10gPT09IHBhcnRpdGlvbjEgJiYgbm9kZU1hcFt0Z3RdID09PSBwYXJ0aXRpb24yIHx8IG5vZGVNYXBbc3JjXSA9PT0gcGFydGl0aW9uMiAmJiBub2RlTWFwW3RndF0gPT09IHBhcnRpdGlvbjEpIHtcbiAgICAgICAgbmV3RWRnZXMuc3BsaWNlKGksIDEpO1xuICAgICAgfVxuICAgIH0gLy8gQWxsIGVkZ2VzIHBvaW50aW5nIHRvIHBhcnRpdGlvbjIgc2hvdWxkIG5vdyBwb2ludCB0byBwYXJ0aXRpb24xXG5cblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBuZXdFZGdlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfZWRnZSA9IG5ld0VkZ2VzW19pXTtcblxuICAgICAgaWYgKF9lZGdlWzFdID09PSBwYXJ0aXRpb24yKSB7XG4gICAgICAgIC8vIENoZWNrIHNvdXJjZVxuICAgICAgICBuZXdFZGdlc1tfaV0gPSBfZWRnZS5zbGljZSgpOyAvLyBjb3B5XG5cbiAgICAgICAgbmV3RWRnZXNbX2ldWzFdID0gcGFydGl0aW9uMTtcbiAgICAgIH0gZWxzZSBpZiAoX2VkZ2VbMl0gPT09IHBhcnRpdGlvbjIpIHtcbiAgICAgICAgLy8gQ2hlY2sgdGFyZ2V0XG4gICAgICAgIG5ld0VkZ2VzW19pXSA9IF9lZGdlLnNsaWNlKCk7IC8vIGNvcHlcblxuICAgICAgICBuZXdFZGdlc1tfaV1bMl0gPSBwYXJ0aXRpb24xO1xuICAgICAgfVxuICAgIH0gLy8gTW92ZSBhbGwgbm9kZXMgZnJvbSBwYXJ0aXRpb24yIHRvIHBhcnRpdGlvbjFcblxuXG4gICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbm9kZU1hcC5sZW5ndGg7IF9pMisrKSB7XG4gICAgICBpZiAobm9kZU1hcFtfaTJdID09PSBwYXJ0aXRpb24yKSB7XG4gICAgICAgIG5vZGVNYXBbX2kyXSA9IHBhcnRpdGlvbjE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld0VkZ2VzO1xuICB9OyAvLyBDb250cmFjdHMgYSBncmFwaCB1bnRpbCB3ZSByZWFjaCBhIGNlcnRhaW4gbnVtYmVyIG9mIG1ldGEgbm9kZXNcblxuXG4gIHZhciBjb250cmFjdFVudGlsID0gZnVuY3Rpb24gY29udHJhY3RVbnRpbChtZXRhTm9kZU1hcCwgcmVtYWluaW5nRWRnZXMsIHNpemUsIHNpemVMaW1pdCkge1xuICAgIHdoaWxlIChzaXplID4gc2l6ZUxpbWl0KSB7XG4gICAgICAvLyBDaG9vc2UgYW4gZWRnZSByYW5kb21seVxuICAgICAgdmFyIGVkZ2VJbmRleCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHJlbWFpbmluZ0VkZ2VzLmxlbmd0aCk7IC8vIENvbGxhcHNlIGdyYXBoIGJhc2VkIG9uIGVkZ2VcblxuICAgICAgcmVtYWluaW5nRWRnZXMgPSBjb2xsYXBzZShlZGdlSW5kZXgsIG1ldGFOb2RlTWFwLCByZW1haW5pbmdFZGdlcyk7XG4gICAgICBzaXplLS07XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlbWFpbmluZ0VkZ2VzO1xuICB9O1xuXG4gIHZhciBlbGVzZm4kcCA9IHtcbiAgICAvLyBDb21wdXRlcyB0aGUgbWluaW11bSBjdXQgb2YgYW4gdW5kaXJlY3RlZCBncmFwaFxuICAgIC8vIFJldHVybnMgdGhlIGNvcnJlY3QgYW5zd2VyIHdpdGggaGlnaCBwcm9iYWJpbGl0eVxuICAgIGthcmdlclN0ZWluOiBmdW5jdGlvbiBrYXJnZXJTdGVpbigpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBfdGhpcyRieUdyb3VwID0gdGhpcy5ieUdyb3VwKCksXG4gICAgICAgICAgbm9kZXMgPSBfdGhpcyRieUdyb3VwLm5vZGVzLFxuICAgICAgICAgIGVkZ2VzID0gX3RoaXMkYnlHcm91cC5lZGdlcztcblxuICAgICAgZWRnZXMudW5tZXJnZUJ5KGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgIHJldHVybiBlZGdlLmlzTG9vcCgpO1xuICAgICAgfSk7XG4gICAgICB2YXIgbnVtTm9kZXMgPSBub2Rlcy5sZW5ndGg7XG4gICAgICB2YXIgbnVtRWRnZXMgPSBlZGdlcy5sZW5ndGg7XG4gICAgICB2YXIgbnVtSXRlciA9IE1hdGguY2VpbChNYXRoLnBvdyhNYXRoLmxvZyhudW1Ob2RlcykgLyBNYXRoLkxOMiwgMikpO1xuICAgICAgdmFyIHN0b3BTaXplID0gTWF0aC5mbG9vcihudW1Ob2RlcyAvIHNxcnQyKTtcblxuICAgICAgaWYgKG51bU5vZGVzIDwgMikge1xuICAgICAgICBlcnJvcignQXQgbGVhc3QgMiBub2RlcyBhcmUgcmVxdWlyZWQgZm9yIEthcmdlci1TdGVpbiBhbGdvcml0aG0nKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH0gLy8gTm93IHN0b3JlIGVkZ2UgZGVzdGluYXRpb24gYXMgaW5kZXhlc1xuICAgICAgLy8gRm9ybWF0IGZvciBlYWNoIGVkZ2UgKGVkZ2UgaW5kZXgsIHNvdXJjZSBub2RlIGluZGV4LCB0YXJnZXQgbm9kZSBpbmRleClcblxuXG4gICAgICB2YXIgZWRnZUluZGV4ZXMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1FZGdlczsgaSsrKSB7XG4gICAgICAgIHZhciBlID0gZWRnZXNbaV07XG4gICAgICAgIGVkZ2VJbmRleGVzLnB1c2goW2ksIG5vZGVzLmluZGV4T2YoZS5zb3VyY2UoKSksIG5vZGVzLmluZGV4T2YoZS50YXJnZXQoKSldKTtcbiAgICAgIH0gLy8gV2Ugd2lsbCBzdG9yZSB0aGUgYmVzdCBjdXQgZm91bmQgaGVyZVxuXG5cbiAgICAgIHZhciBtaW5DdXRTaXplID0gSW5maW5pdHk7XG4gICAgICB2YXIgbWluQ3V0RWRnZUluZGV4ZXMgPSBbXTtcbiAgICAgIHZhciBtaW5DdXROb2RlTWFwID0gbmV3IEFycmF5KG51bU5vZGVzKTsgLy8gSW5pdGlhbCBtZXRhIG5vZGUgcGFydGl0aW9uXG5cbiAgICAgIHZhciBtZXRhTm9kZU1hcCA9IG5ldyBBcnJheShudW1Ob2Rlcyk7XG4gICAgICB2YXIgbWV0YU5vZGVNYXAyID0gbmV3IEFycmF5KG51bU5vZGVzKTtcblxuICAgICAgdmFyIGNvcHlOb2Rlc01hcCA9IGZ1bmN0aW9uIGNvcHlOb2Rlc01hcChmcm9tLCB0bykge1xuICAgICAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBudW1Ob2RlczsgX2kzKyspIHtcbiAgICAgICAgICB0b1tfaTNdID0gZnJvbVtfaTNdO1xuICAgICAgICB9XG4gICAgICB9OyAvLyBNYWluIGxvb3BcblxuXG4gICAgICBmb3IgKHZhciBpdGVyID0gMDsgaXRlciA8PSBudW1JdGVyOyBpdGVyKyspIHtcbiAgICAgICAgLy8gUmVzZXQgbWV0YSBub2RlIHBhcnRpdGlvblxuICAgICAgICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBudW1Ob2RlczsgX2k0KyspIHtcbiAgICAgICAgICBtZXRhTm9kZU1hcFtfaTRdID0gX2k0O1xuICAgICAgICB9IC8vIENvbnRyYWN0IHVudGlsIHN0b3AgcG9pbnQgKHN0b3BTaXplIG5vZGVzKVxuXG5cbiAgICAgICAgdmFyIGVkZ2VzU3RhdGUgPSBjb250cmFjdFVudGlsKG1ldGFOb2RlTWFwLCBlZGdlSW5kZXhlcy5zbGljZSgpLCBudW1Ob2Rlcywgc3RvcFNpemUpO1xuICAgICAgICB2YXIgZWRnZXNTdGF0ZTIgPSBlZGdlc1N0YXRlLnNsaWNlKCk7IC8vIGNvcHlcbiAgICAgICAgLy8gQ3JlYXRlIGEgY29weSBvZiB0aGUgY29sYXBzZWQgbm9kZXMgc3RhdGVcblxuICAgICAgICBjb3B5Tm9kZXNNYXAobWV0YU5vZGVNYXAsIG1ldGFOb2RlTWFwMik7IC8vIFJ1biAyIGl0ZXJhdGlvbnMgc3RhcnRpbmcgaW4gdGhlIHN0b3Agc3RhdGVcblxuICAgICAgICB2YXIgcmVzMSA9IGNvbnRyYWN0VW50aWwobWV0YU5vZGVNYXAsIGVkZ2VzU3RhdGUsIHN0b3BTaXplLCAyKTtcbiAgICAgICAgdmFyIHJlczIgPSBjb250cmFjdFVudGlsKG1ldGFOb2RlTWFwMiwgZWRnZXNTdGF0ZTIsIHN0b3BTaXplLCAyKTsgLy8gSXMgYW55IG9mIHRoZSAyIHJlc3VsdHMgdGhlIGJlc3QgY3V0IHNvIGZhcj9cblxuICAgICAgICBpZiAocmVzMS5sZW5ndGggPD0gcmVzMi5sZW5ndGggJiYgcmVzMS5sZW5ndGggPCBtaW5DdXRTaXplKSB7XG4gICAgICAgICAgbWluQ3V0U2l6ZSA9IHJlczEubGVuZ3RoO1xuICAgICAgICAgIG1pbkN1dEVkZ2VJbmRleGVzID0gcmVzMTtcbiAgICAgICAgICBjb3B5Tm9kZXNNYXAobWV0YU5vZGVNYXAsIG1pbkN1dE5vZGVNYXApO1xuICAgICAgICB9IGVsc2UgaWYgKHJlczIubGVuZ3RoIDw9IHJlczEubGVuZ3RoICYmIHJlczIubGVuZ3RoIDwgbWluQ3V0U2l6ZSkge1xuICAgICAgICAgIG1pbkN1dFNpemUgPSByZXMyLmxlbmd0aDtcbiAgICAgICAgICBtaW5DdXRFZGdlSW5kZXhlcyA9IHJlczI7XG4gICAgICAgICAgY29weU5vZGVzTWFwKG1ldGFOb2RlTWFwMiwgbWluQ3V0Tm9kZU1hcCk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gZW5kIG9mIG1haW4gbG9vcFxuICAgICAgLy8gQ29uc3RydWN0IHJlc3VsdFxuXG5cbiAgICAgIHZhciBjdXQgPSB0aGlzLnNwYXduKG1pbkN1dEVkZ2VJbmRleGVzLm1hcChmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gZWRnZXNbZVswXV07XG4gICAgICB9KSk7XG4gICAgICB2YXIgcGFydGl0aW9uMSA9IHRoaXMuc3Bhd24oKTtcbiAgICAgIHZhciBwYXJ0aXRpb24yID0gdGhpcy5zcGF3bigpOyAvLyB0cmF2ZXJzZSBtZXRhTm9kZU1hcCBmb3IgYmVzdCBjdXRcblxuICAgICAgdmFyIHdpdG5lc3NOb2RlUGFydGl0aW9uID0gbWluQ3V0Tm9kZU1hcFswXTtcblxuICAgICAgZm9yICh2YXIgX2k1ID0gMDsgX2k1IDwgbWluQ3V0Tm9kZU1hcC5sZW5ndGg7IF9pNSsrKSB7XG4gICAgICAgIHZhciBwYXJ0aXRpb25JZCA9IG1pbkN1dE5vZGVNYXBbX2k1XTtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tfaTVdO1xuXG4gICAgICAgIGlmIChwYXJ0aXRpb25JZCA9PT0gd2l0bmVzc05vZGVQYXJ0aXRpb24pIHtcbiAgICAgICAgICBwYXJ0aXRpb24xLm1lcmdlKG5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcnRpdGlvbjIubWVyZ2Uobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gY29uc3RydWN0IGNvbXBvbmVudHMgY29ycmVzcG9uZGluZyB0byBlYWNoIGRpc2pvaW50IHN1YnNldCBvZiBub2Rlc1xuXG5cbiAgICAgIHZhciBjb25zdHJ1Y3RDb21wb25lbnQgPSBmdW5jdGlvbiBjb25zdHJ1Y3RDb21wb25lbnQoc3Vic2V0KSB7XG4gICAgICAgIHZhciBjb21wb25lbnQgPSBfdGhpcy5zcGF3bigpO1xuXG4gICAgICAgIHN1YnNldC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgY29tcG9uZW50Lm1lcmdlKG5vZGUpO1xuICAgICAgICAgIG5vZGUuY29ubmVjdGVkRWRnZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgICAgICAvLyBlbnN1cmUgZWRnZSBpcyB3aXRoaW4gY2FsbGluZyBjb2xsZWN0aW9uIGFuZCBlZGdlIGlzIG5vdCBpbiBjdXRcbiAgICAgICAgICAgIGlmIChfdGhpcy5jb250YWlucyhlZGdlKSAmJiAhY3V0LmNvbnRhaW5zKGVkZ2UpKSB7XG4gICAgICAgICAgICAgIGNvbXBvbmVudC5tZXJnZShlZGdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb21wb25lbnQ7XG4gICAgICB9O1xuXG4gICAgICB2YXIgY29tcG9uZW50cyA9IFtjb25zdHJ1Y3RDb21wb25lbnQocGFydGl0aW9uMSksIGNvbnN0cnVjdENvbXBvbmVudChwYXJ0aXRpb24yKV07XG4gICAgICB2YXIgcmV0ID0ge1xuICAgICAgICBjdXQ6IGN1dCxcbiAgICAgICAgY29tcG9uZW50czogY29tcG9uZW50cyxcbiAgICAgICAgLy8gbi5iLiBwYXJ0aXRpb25zIGFyZSBpbmNsdWRlZCB0byBiZSBjb21wYXRpYmxlIHdpdGggdGhlIG9sZCBhcGkgc3BlY1xuICAgICAgICAvLyAoY291bGQgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciB2ZXJzaW9uKVxuICAgICAgICBwYXJ0aXRpb24xOiBwYXJ0aXRpb24xLFxuICAgICAgICBwYXJ0aXRpb24yOiBwYXJ0aXRpb24yXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gIH07IC8vIGVsZXNmblxuXG4gIHZhciBjb3B5UG9zaXRpb24gPSBmdW5jdGlvbiBjb3B5UG9zaXRpb24ocCkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiBwLngsXG4gICAgICB5OiBwLnlcbiAgICB9O1xuICB9O1xuICB2YXIgbW9kZWxUb1JlbmRlcmVkUG9zaXRpb24gPSBmdW5jdGlvbiBtb2RlbFRvUmVuZGVyZWRQb3NpdGlvbihwLCB6b29tLCBwYW4pIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogcC54ICogem9vbSArIHBhbi54LFxuICAgICAgeTogcC55ICogem9vbSArIHBhbi55XG4gICAgfTtcbiAgfTtcbiAgdmFyIHJlbmRlcmVkVG9Nb2RlbFBvc2l0aW9uID0gZnVuY3Rpb24gcmVuZGVyZWRUb01vZGVsUG9zaXRpb24ocCwgem9vbSwgcGFuKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IChwLnggLSBwYW4ueCkgLyB6b29tLFxuICAgICAgeTogKHAueSAtIHBhbi55KSAvIHpvb21cbiAgICB9O1xuICB9O1xuICB2YXIgYXJyYXkycG9pbnQgPSBmdW5jdGlvbiBhcnJheTJwb2ludChhcnIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogYXJyWzBdLFxuICAgICAgeTogYXJyWzFdXG4gICAgfTtcbiAgfTtcbiAgdmFyIG1pbiA9IGZ1bmN0aW9uIG1pbihhcnIpIHtcbiAgICB2YXIgYmVnaW4gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gICAgdmFyIGVuZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogYXJyLmxlbmd0aDtcbiAgICB2YXIgbWluID0gSW5maW5pdHk7XG5cbiAgICBmb3IgKHZhciBpID0gYmVnaW47IGkgPCBlbmQ7IGkrKykge1xuICAgICAgdmFyIHZhbCA9IGFycltpXTtcblxuICAgICAgaWYgKGlzRmluaXRlKHZhbCkpIHtcbiAgICAgICAgbWluID0gTWF0aC5taW4odmFsLCBtaW4pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtaW47XG4gIH07XG4gIHZhciBtYXggPSBmdW5jdGlvbiBtYXgoYXJyKSB7XG4gICAgdmFyIGJlZ2luID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgIHZhciBlbmQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGFyci5sZW5ndGg7XG4gICAgdmFyIG1heCA9IC1JbmZpbml0eTtcblxuICAgIGZvciAodmFyIGkgPSBiZWdpbjsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB2YXIgdmFsID0gYXJyW2ldO1xuXG4gICAgICBpZiAoaXNGaW5pdGUodmFsKSkge1xuICAgICAgICBtYXggPSBNYXRoLm1heCh2YWwsIG1heCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1heDtcbiAgfTtcbiAgdmFyIG1lYW4gPSBmdW5jdGlvbiBtZWFuKGFycikge1xuICAgIHZhciBiZWdpbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgICB2YXIgZW5kID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBhcnIubGVuZ3RoO1xuICAgIHZhciB0b3RhbCA9IDA7XG4gICAgdmFyIG4gPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IGJlZ2luOyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHZhciB2YWwgPSBhcnJbaV07XG5cbiAgICAgIGlmIChpc0Zpbml0ZSh2YWwpKSB7XG4gICAgICAgIHRvdGFsICs9IHZhbDtcbiAgICAgICAgbisrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0b3RhbCAvIG47XG4gIH07XG4gIHZhciBtZWRpYW4gPSBmdW5jdGlvbiBtZWRpYW4oYXJyKSB7XG4gICAgdmFyIGJlZ2luID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgIHZhciBlbmQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGFyci5sZW5ndGg7XG4gICAgdmFyIGNvcHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHRydWU7XG4gICAgdmFyIHNvcnQgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IHRydWU7XG4gICAgdmFyIGluY2x1ZGVIb2xlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogdHJ1ZTtcblxuICAgIGlmIChjb3B5KSB7XG4gICAgICBhcnIgPSBhcnIuc2xpY2UoYmVnaW4sIGVuZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChlbmQgPCBhcnIubGVuZ3RoKSB7XG4gICAgICAgIGFyci5zcGxpY2UoZW5kLCBhcnIubGVuZ3RoIC0gZW5kKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJlZ2luID4gMCkge1xuICAgICAgICBhcnIuc3BsaWNlKDAsIGJlZ2luKTtcbiAgICAgIH1cbiAgICB9IC8vIGFsbCBub24gZmluaXRlIChlLmcuIEluZmluaXR5LCBOYU4pIGVsZW1lbnRzIG11c3QgYmUgLUluZmluaXR5IHNvIHRoZXkgZ28gdG8gdGhlIHN0YXJ0XG5cblxuICAgIHZhciBvZmYgPSAwOyAvLyBvZmZzZXQgZnJvbSBub24tZmluaXRlIHZhbHVlc1xuXG4gICAgZm9yICh2YXIgaSA9IGFyci5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIHYgPSBhcnJbaV07XG5cbiAgICAgIGlmIChpbmNsdWRlSG9sZXMpIHtcbiAgICAgICAgaWYgKCFpc0Zpbml0ZSh2KSkge1xuICAgICAgICAgIGFycltpXSA9IC1JbmZpbml0eTtcbiAgICAgICAgICBvZmYrKztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8ganVzdCByZW1vdmUgaXQgaWYgd2UgZG9uJ3Qgd2FudCB0byBjb25zaWRlciBob2xlc1xuICAgICAgICBhcnIuc3BsaWNlKGksIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzb3J0KSB7XG4gICAgICBhcnIuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYSAtIGI7XG4gICAgICB9KTsgLy8gcmVxdWlyZXMgY29weSA9IHRydWUgaWYgeW91IGRvbid0IHdhbnQgdG8gY2hhbmdlIHRoZSBvcmlnXG4gICAgfVxuXG4gICAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XG4gICAgdmFyIG1pZCA9IE1hdGguZmxvb3IobGVuIC8gMik7XG5cbiAgICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgICAgcmV0dXJuIGFyclttaWQgKyAxICsgb2ZmXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIChhcnJbbWlkIC0gMSArIG9mZl0gKyBhcnJbbWlkICsgb2ZmXSkgLyAyO1xuICAgIH1cbiAgfTtcbiAgdmFyIGRlZzJyYWQgPSBmdW5jdGlvbiBkZWcycmFkKGRlZykge1xuICAgIHJldHVybiBNYXRoLlBJICogZGVnIC8gMTgwO1xuICB9O1xuICB2YXIgZ2V0QW5nbGVGcm9tRGlzcCA9IGZ1bmN0aW9uIGdldEFuZ2xlRnJvbURpc3AoZGlzcFgsIGRpc3BZKSB7XG4gICAgcmV0dXJuIE1hdGguYXRhbjIoZGlzcFksIGRpc3BYKSAtIE1hdGguUEkgLyAyO1xuICB9O1xuICB2YXIgbG9nMiA9IE1hdGgubG9nMiB8fCBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBNYXRoLmxvZyhuKSAvIE1hdGgubG9nKDIpO1xuICB9O1xuICB2YXIgc2lnbnVtID0gZnVuY3Rpb24gc2lnbnVtKHgpIHtcbiAgICBpZiAoeCA+IDApIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoeCA8IDApIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9O1xuICB2YXIgZGlzdCA9IGZ1bmN0aW9uIGRpc3QocDEsIHAyKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydChzcWRpc3QocDEsIHAyKSk7XG4gIH07XG4gIHZhciBzcWRpc3QgPSBmdW5jdGlvbiBzcWRpc3QocDEsIHAyKSB7XG4gICAgdmFyIGR4ID0gcDIueCAtIHAxLng7XG4gICAgdmFyIGR5ID0gcDIueSAtIHAxLnk7XG4gICAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xuICB9O1xuICB2YXIgaW5QbGFjZVN1bU5vcm1hbGl6ZSA9IGZ1bmN0aW9uIGluUGxhY2VTdW1Ob3JtYWxpemUodikge1xuICAgIHZhciBsZW5ndGggPSB2Lmxlbmd0aDsgLy8gRmlyc3QsIGdldCBzdW0gb2YgYWxsIGVsZW1lbnRzXG5cbiAgICB2YXIgdG90YWwgPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdG90YWwgKz0gdltpXTtcbiAgICB9IC8vIE5vdywgZGl2aWRlIGVhY2ggYnkgdGhlIHN1bSBvZiBhbGwgZWxlbWVudHNcblxuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGxlbmd0aDsgX2krKykge1xuICAgICAgdltfaV0gPSB2W19pXSAvIHRvdGFsO1xuICAgIH1cblxuICAgIHJldHVybiB2O1xuICB9O1xuXG4gIHZhciBxYmV6aWVyQXQgPSBmdW5jdGlvbiBxYmV6aWVyQXQocDAsIHAxLCBwMiwgdCkge1xuICAgIHJldHVybiAoMSAtIHQpICogKDEgLSB0KSAqIHAwICsgMiAqICgxIC0gdCkgKiB0ICogcDEgKyB0ICogdCAqIHAyO1xuICB9O1xuICB2YXIgcWJlemllclB0QXQgPSBmdW5jdGlvbiBxYmV6aWVyUHRBdChwMCwgcDEsIHAyLCB0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHFiZXppZXJBdChwMC54LCBwMS54LCBwMi54LCB0KSxcbiAgICAgIHk6IHFiZXppZXJBdChwMC55LCBwMS55LCBwMi55LCB0KVxuICAgIH07XG4gIH07XG4gIHZhciBsaW5lQXQgPSBmdW5jdGlvbiBsaW5lQXQocDAsIHAxLCB0LCBkKSB7XG4gICAgdmFyIHZlYyA9IHtcbiAgICAgIHg6IHAxLnggLSBwMC54LFxuICAgICAgeTogcDEueSAtIHAwLnlcbiAgICB9O1xuICAgIHZhciB2ZWNEaXN0ID0gZGlzdChwMCwgcDEpO1xuICAgIHZhciBub3JtVmVjID0ge1xuICAgICAgeDogdmVjLnggLyB2ZWNEaXN0LFxuICAgICAgeTogdmVjLnkgLyB2ZWNEaXN0XG4gICAgfTtcbiAgICB0ID0gdCA9PSBudWxsID8gMCA6IHQ7XG4gICAgZCA9IGQgIT0gbnVsbCA/IGQgOiB0ICogdmVjRGlzdDtcbiAgICByZXR1cm4ge1xuICAgICAgeDogcDAueCArIG5vcm1WZWMueCAqIGQsXG4gICAgICB5OiBwMC55ICsgbm9ybVZlYy55ICogZFxuICAgIH07XG4gIH07XG4gIHZhciBib3VuZCA9IGZ1bmN0aW9uIGJvdW5kKG1pbiwgdmFsLCBtYXgpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHZhbCkpO1xuICB9OyAvLyBtYWtlcyBhIGZ1bGwgYmIgKHgxLCB5MSwgeDIsIHkyLCB3LCBoKSBmcm9tIGltcGxpY2l0IHBhcmFtc1xuXG4gIHZhciBtYWtlQm91bmRpbmdCb3ggPSBmdW5jdGlvbiBtYWtlQm91bmRpbmdCb3goYmIpIHtcbiAgICBpZiAoYmIgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDE6IEluZmluaXR5LFxuICAgICAgICB5MTogSW5maW5pdHksXG4gICAgICAgIHgyOiAtSW5maW5pdHksXG4gICAgICAgIHkyOiAtSW5maW5pdHksXG4gICAgICAgIHc6IDAsXG4gICAgICAgIGg6IDBcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChiYi54MSAhPSBudWxsICYmIGJiLnkxICE9IG51bGwpIHtcbiAgICAgIGlmIChiYi54MiAhPSBudWxsICYmIGJiLnkyICE9IG51bGwgJiYgYmIueDIgPj0gYmIueDEgJiYgYmIueTIgPj0gYmIueTEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4MTogYmIueDEsXG4gICAgICAgICAgeTE6IGJiLnkxLFxuICAgICAgICAgIHgyOiBiYi54MixcbiAgICAgICAgICB5MjogYmIueTIsXG4gICAgICAgICAgdzogYmIueDIgLSBiYi54MSxcbiAgICAgICAgICBoOiBiYi55MiAtIGJiLnkxXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKGJiLncgIT0gbnVsbCAmJiBiYi5oICE9IG51bGwgJiYgYmIudyA+PSAwICYmIGJiLmggPj0gMCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHgxOiBiYi54MSxcbiAgICAgICAgICB5MTogYmIueTEsXG4gICAgICAgICAgeDI6IGJiLngxICsgYmIudyxcbiAgICAgICAgICB5MjogYmIueTEgKyBiYi5oLFxuICAgICAgICAgIHc6IGJiLncsXG4gICAgICAgICAgaDogYmIuaFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgdmFyIGNvcHlCb3VuZGluZ0JveCA9IGZ1bmN0aW9uIGNvcHlCb3VuZGluZ0JveChiYikge1xuICAgIHJldHVybiB7XG4gICAgICB4MTogYmIueDEsXG4gICAgICB4MjogYmIueDIsXG4gICAgICB3OiBiYi53LFxuICAgICAgeTE6IGJiLnkxLFxuICAgICAgeTI6IGJiLnkyLFxuICAgICAgaDogYmIuaFxuICAgIH07XG4gIH07XG4gIHZhciBjbGVhckJvdW5kaW5nQm94ID0gZnVuY3Rpb24gY2xlYXJCb3VuZGluZ0JveChiYikge1xuICAgIGJiLngxID0gSW5maW5pdHk7XG4gICAgYmIueTEgPSBJbmZpbml0eTtcbiAgICBiYi54MiA9IC1JbmZpbml0eTtcbiAgICBiYi55MiA9IC1JbmZpbml0eTtcbiAgICBiYi53ID0gMDtcbiAgICBiYi5oID0gMDtcbiAgfTtcbiAgdmFyIHVwZGF0ZUJvdW5kaW5nQm94ID0gZnVuY3Rpb24gdXBkYXRlQm91bmRpbmdCb3goYmIxLCBiYjIpIHtcbiAgICAvLyB1cGRhdGUgYmIxIHdpdGggYmIyIGJvdW5kc1xuICAgIGJiMS54MSA9IE1hdGgubWluKGJiMS54MSwgYmIyLngxKTtcbiAgICBiYjEueDIgPSBNYXRoLm1heChiYjEueDIsIGJiMi54Mik7XG4gICAgYmIxLncgPSBiYjEueDIgLSBiYjEueDE7XG4gICAgYmIxLnkxID0gTWF0aC5taW4oYmIxLnkxLCBiYjIueTEpO1xuICAgIGJiMS55MiA9IE1hdGgubWF4KGJiMS55MiwgYmIyLnkyKTtcbiAgICBiYjEuaCA9IGJiMS55MiAtIGJiMS55MTtcbiAgfTtcbiAgdmFyIGV4cGFuZEJvdW5kaW5nQm94QnlQb2ludCA9IGZ1bmN0aW9uIGV4cGFuZEJvdW5kaW5nQm94QnlQb2ludChiYiwgeCwgeSkge1xuICAgIGJiLngxID0gTWF0aC5taW4oYmIueDEsIHgpO1xuICAgIGJiLngyID0gTWF0aC5tYXgoYmIueDIsIHgpO1xuICAgIGJiLncgPSBiYi54MiAtIGJiLngxO1xuICAgIGJiLnkxID0gTWF0aC5taW4oYmIueTEsIHkpO1xuICAgIGJiLnkyID0gTWF0aC5tYXgoYmIueTIsIHkpO1xuICAgIGJiLmggPSBiYi55MiAtIGJiLnkxO1xuICB9O1xuICB2YXIgZXhwYW5kQm91bmRpbmdCb3ggPSBmdW5jdGlvbiBleHBhbmRCb3VuZGluZ0JveChiYikge1xuICAgIHZhciBwYWRkaW5nID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgIGJiLngxIC09IHBhZGRpbmc7XG4gICAgYmIueDIgKz0gcGFkZGluZztcbiAgICBiYi55MSAtPSBwYWRkaW5nO1xuICAgIGJiLnkyICs9IHBhZGRpbmc7XG4gICAgYmIudyA9IGJiLngyIC0gYmIueDE7XG4gICAgYmIuaCA9IGJiLnkyIC0gYmIueTE7XG4gICAgcmV0dXJuIGJiO1xuICB9O1xuICB2YXIgZXhwYW5kQm91bmRpbmdCb3hTaWRlcyA9IGZ1bmN0aW9uIGV4cGFuZEJvdW5kaW5nQm94U2lkZXMoYmIpIHtcbiAgICB2YXIgcGFkZGluZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogWzBdO1xuICAgIHZhciB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQ7XG5cbiAgICBpZiAocGFkZGluZy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHRvcCA9IHJpZ2h0ID0gYm90dG9tID0gbGVmdCA9IHBhZGRpbmdbMF07XG4gICAgfSBlbHNlIGlmIChwYWRkaW5nLmxlbmd0aCA9PT0gMikge1xuICAgICAgdG9wID0gYm90dG9tID0gcGFkZGluZ1swXTtcbiAgICAgIGxlZnQgPSByaWdodCA9IHBhZGRpbmdbMV07XG4gICAgfSBlbHNlIGlmIChwYWRkaW5nLmxlbmd0aCA9PT0gNCkge1xuICAgICAgdmFyIF9wYWRkaW5nID0gX3NsaWNlZFRvQXJyYXkocGFkZGluZywgNCk7XG5cbiAgICAgIHRvcCA9IF9wYWRkaW5nWzBdO1xuICAgICAgcmlnaHQgPSBfcGFkZGluZ1sxXTtcbiAgICAgIGJvdHRvbSA9IF9wYWRkaW5nWzJdO1xuICAgICAgbGVmdCA9IF9wYWRkaW5nWzNdO1xuICAgIH1cblxuICAgIGJiLngxIC09IGxlZnQ7XG4gICAgYmIueDIgKz0gcmlnaHQ7XG4gICAgYmIueTEgLT0gdG9wO1xuICAgIGJiLnkyICs9IGJvdHRvbTtcbiAgICBiYi53ID0gYmIueDIgLSBiYi54MTtcbiAgICBiYi5oID0gYmIueTIgLSBiYi55MTtcbiAgICByZXR1cm4gYmI7XG4gIH07XG5cbiAgdmFyIGFzc2lnbkJvdW5kaW5nQm94ID0gZnVuY3Rpb24gYXNzaWduQm91bmRpbmdCb3goYmIxLCBiYjIpIHtcbiAgICBiYjEueDEgPSBiYjIueDE7XG4gICAgYmIxLnkxID0gYmIyLnkxO1xuICAgIGJiMS54MiA9IGJiMi54MjtcbiAgICBiYjEueTIgPSBiYjIueTI7XG4gICAgYmIxLncgPSBiYjEueDIgLSBiYjEueDE7XG4gICAgYmIxLmggPSBiYjEueTIgLSBiYjEueTE7XG4gIH07XG4gIHZhciBib3VuZGluZ0JveGVzSW50ZXJzZWN0ID0gZnVuY3Rpb24gYm91bmRpbmdCb3hlc0ludGVyc2VjdChiYjEsIGJiMikge1xuICAgIC8vIGNhc2U6IG9uZSBiYiB0byByaWdodCBvZiBvdGhlclxuICAgIGlmIChiYjEueDEgPiBiYjIueDIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoYmIyLngxID4gYmIxLngyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBjYXNlOiBvbmUgYmIgdG8gbGVmdCBvZiBvdGhlclxuXG5cbiAgICBpZiAoYmIxLngyIDwgYmIyLngxKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGJiMi54MiA8IGJiMS54MSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gY2FzZTogb25lIGJiIGFib3ZlIG90aGVyXG5cblxuICAgIGlmIChiYjEueTIgPCBiYjIueTEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoYmIyLnkyIDwgYmIxLnkxKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBjYXNlOiBvbmUgYmIgYmVsb3cgb3RoZXJcblxuXG4gICAgaWYgKGJiMS55MSA+IGJiMi55Mikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChiYjIueTEgPiBiYjEueTIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIG90aGVyd2lzZSwgbXVzdCBoYXZlIHNvbWUgb3ZlcmxhcFxuXG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgdmFyIGluQm91bmRpbmdCb3ggPSBmdW5jdGlvbiBpbkJvdW5kaW5nQm94KGJiLCB4LCB5KSB7XG4gICAgcmV0dXJuIGJiLngxIDw9IHggJiYgeCA8PSBiYi54MiAmJiBiYi55MSA8PSB5ICYmIHkgPD0gYmIueTI7XG4gIH07XG4gIHZhciBwb2ludEluQm91bmRpbmdCb3ggPSBmdW5jdGlvbiBwb2ludEluQm91bmRpbmdCb3goYmIsIHB0KSB7XG4gICAgcmV0dXJuIGluQm91bmRpbmdCb3goYmIsIHB0LngsIHB0LnkpO1xuICB9O1xuICB2YXIgYm91bmRpbmdCb3hJbkJvdW5kaW5nQm94ID0gZnVuY3Rpb24gYm91bmRpbmdCb3hJbkJvdW5kaW5nQm94KGJiMSwgYmIyKSB7XG4gICAgcmV0dXJuIGluQm91bmRpbmdCb3goYmIxLCBiYjIueDEsIGJiMi55MSkgJiYgaW5Cb3VuZGluZ0JveChiYjEsIGJiMi54MiwgYmIyLnkyKTtcbiAgfTtcbiAgdmFyIHJvdW5kUmVjdGFuZ2xlSW50ZXJzZWN0TGluZSA9IGZ1bmN0aW9uIHJvdW5kUmVjdGFuZ2xlSW50ZXJzZWN0TGluZSh4LCB5LCBub2RlWCwgbm9kZVksIHdpZHRoLCBoZWlnaHQsIHBhZGRpbmcpIHtcbiAgICB2YXIgY29ybmVyUmFkaXVzID0gZ2V0Um91bmRSZWN0YW5nbGVSYWRpdXMod2lkdGgsIGhlaWdodCk7XG4gICAgdmFyIGhhbGZXaWR0aCA9IHdpZHRoIC8gMjtcbiAgICB2YXIgaGFsZkhlaWdodCA9IGhlaWdodCAvIDI7IC8vIENoZWNrIGludGVyc2VjdGlvbnMgd2l0aCBzdHJhaWdodCBsaW5lIHNlZ21lbnRzXG5cbiAgICB2YXIgc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9uczsgLy8gVG9wIHNlZ21lbnQsIGxlZnQgdG8gcmlnaHRcblxuICAgIHtcbiAgICAgIHZhciB0b3BTdGFydFggPSBub2RlWCAtIGhhbGZXaWR0aCArIGNvcm5lclJhZGl1cyAtIHBhZGRpbmc7XG4gICAgICB2YXIgdG9wU3RhcnRZID0gbm9kZVkgLSBoYWxmSGVpZ2h0IC0gcGFkZGluZztcbiAgICAgIHZhciB0b3BFbmRYID0gbm9kZVggKyBoYWxmV2lkdGggLSBjb3JuZXJSYWRpdXMgKyBwYWRkaW5nO1xuICAgICAgdmFyIHRvcEVuZFkgPSB0b3BTdGFydFk7XG4gICAgICBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zID0gZmluaXRlTGluZXNJbnRlcnNlY3QoeCwgeSwgbm9kZVgsIG5vZGVZLCB0b3BTdGFydFgsIHRvcFN0YXJ0WSwgdG9wRW5kWCwgdG9wRW5kWSwgZmFsc2UpO1xuXG4gICAgICBpZiAoc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zO1xuICAgICAgfVxuICAgIH0gLy8gUmlnaHQgc2VnbWVudCwgdG9wIHRvIGJvdHRvbVxuXG4gICAge1xuICAgICAgdmFyIHJpZ2h0U3RhcnRYID0gbm9kZVggKyBoYWxmV2lkdGggKyBwYWRkaW5nO1xuICAgICAgdmFyIHJpZ2h0U3RhcnRZID0gbm9kZVkgLSBoYWxmSGVpZ2h0ICsgY29ybmVyUmFkaXVzIC0gcGFkZGluZztcbiAgICAgIHZhciByaWdodEVuZFggPSByaWdodFN0YXJ0WDtcbiAgICAgIHZhciByaWdodEVuZFkgPSBub2RlWSArIGhhbGZIZWlnaHQgLSBjb3JuZXJSYWRpdXMgKyBwYWRkaW5nO1xuICAgICAgc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucyA9IGZpbml0ZUxpbmVzSW50ZXJzZWN0KHgsIHksIG5vZGVYLCBub2RlWSwgcmlnaHRTdGFydFgsIHJpZ2h0U3RhcnRZLCByaWdodEVuZFgsIHJpZ2h0RW5kWSwgZmFsc2UpO1xuXG4gICAgICBpZiAoc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zO1xuICAgICAgfVxuICAgIH0gLy8gQm90dG9tIHNlZ21lbnQsIGxlZnQgdG8gcmlnaHRcblxuICAgIHtcbiAgICAgIHZhciBib3R0b21TdGFydFggPSBub2RlWCAtIGhhbGZXaWR0aCArIGNvcm5lclJhZGl1cyAtIHBhZGRpbmc7XG4gICAgICB2YXIgYm90dG9tU3RhcnRZID0gbm9kZVkgKyBoYWxmSGVpZ2h0ICsgcGFkZGluZztcbiAgICAgIHZhciBib3R0b21FbmRYID0gbm9kZVggKyBoYWxmV2lkdGggLSBjb3JuZXJSYWRpdXMgKyBwYWRkaW5nO1xuICAgICAgdmFyIGJvdHRvbUVuZFkgPSBib3R0b21TdGFydFk7XG4gICAgICBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zID0gZmluaXRlTGluZXNJbnRlcnNlY3QoeCwgeSwgbm9kZVgsIG5vZGVZLCBib3R0b21TdGFydFgsIGJvdHRvbVN0YXJ0WSwgYm90dG9tRW5kWCwgYm90dG9tRW5kWSwgZmFsc2UpO1xuXG4gICAgICBpZiAoc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zO1xuICAgICAgfVxuICAgIH0gLy8gTGVmdCBzZWdtZW50LCB0b3AgdG8gYm90dG9tXG5cbiAgICB7XG4gICAgICB2YXIgbGVmdFN0YXJ0WCA9IG5vZGVYIC0gaGFsZldpZHRoIC0gcGFkZGluZztcbiAgICAgIHZhciBsZWZ0U3RhcnRZID0gbm9kZVkgLSBoYWxmSGVpZ2h0ICsgY29ybmVyUmFkaXVzIC0gcGFkZGluZztcbiAgICAgIHZhciBsZWZ0RW5kWCA9IGxlZnRTdGFydFg7XG4gICAgICB2YXIgbGVmdEVuZFkgPSBub2RlWSArIGhhbGZIZWlnaHQgLSBjb3JuZXJSYWRpdXMgKyBwYWRkaW5nO1xuICAgICAgc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucyA9IGZpbml0ZUxpbmVzSW50ZXJzZWN0KHgsIHksIG5vZGVYLCBub2RlWSwgbGVmdFN0YXJ0WCwgbGVmdFN0YXJ0WSwgbGVmdEVuZFgsIGxlZnRFbmRZLCBmYWxzZSk7XG5cbiAgICAgIGlmIChzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnM7XG4gICAgICB9XG4gICAgfSAvLyBDaGVjayBpbnRlcnNlY3Rpb25zIHdpdGggYXJjIHNlZ21lbnRzXG5cbiAgICB2YXIgYXJjSW50ZXJzZWN0aW9uczsgLy8gVG9wIExlZnRcblxuICAgIHtcbiAgICAgIHZhciB0b3BMZWZ0Q2VudGVyWCA9IG5vZGVYIC0gaGFsZldpZHRoICsgY29ybmVyUmFkaXVzO1xuICAgICAgdmFyIHRvcExlZnRDZW50ZXJZID0gbm9kZVkgLSBoYWxmSGVpZ2h0ICsgY29ybmVyUmFkaXVzO1xuICAgICAgYXJjSW50ZXJzZWN0aW9ucyA9IGludGVyc2VjdExpbmVDaXJjbGUoeCwgeSwgbm9kZVgsIG5vZGVZLCB0b3BMZWZ0Q2VudGVyWCwgdG9wTGVmdENlbnRlclksIGNvcm5lclJhZGl1cyArIHBhZGRpbmcpOyAvLyBFbnN1cmUgdGhlIGludGVyc2VjdGlvbiBpcyBvbiB0aGUgZGVzaXJlZCBxdWFydGVyIG9mIHRoZSBjaXJjbGVcblxuICAgICAgaWYgKGFyY0ludGVyc2VjdGlvbnMubGVuZ3RoID4gMCAmJiBhcmNJbnRlcnNlY3Rpb25zWzBdIDw9IHRvcExlZnRDZW50ZXJYICYmIGFyY0ludGVyc2VjdGlvbnNbMV0gPD0gdG9wTGVmdENlbnRlclkpIHtcbiAgICAgICAgcmV0dXJuIFthcmNJbnRlcnNlY3Rpb25zWzBdLCBhcmNJbnRlcnNlY3Rpb25zWzFdXTtcbiAgICAgIH1cbiAgICB9IC8vIFRvcCBSaWdodFxuXG4gICAge1xuICAgICAgdmFyIHRvcFJpZ2h0Q2VudGVyWCA9IG5vZGVYICsgaGFsZldpZHRoIC0gY29ybmVyUmFkaXVzO1xuICAgICAgdmFyIHRvcFJpZ2h0Q2VudGVyWSA9IG5vZGVZIC0gaGFsZkhlaWdodCArIGNvcm5lclJhZGl1cztcbiAgICAgIGFyY0ludGVyc2VjdGlvbnMgPSBpbnRlcnNlY3RMaW5lQ2lyY2xlKHgsIHksIG5vZGVYLCBub2RlWSwgdG9wUmlnaHRDZW50ZXJYLCB0b3BSaWdodENlbnRlclksIGNvcm5lclJhZGl1cyArIHBhZGRpbmcpOyAvLyBFbnN1cmUgdGhlIGludGVyc2VjdGlvbiBpcyBvbiB0aGUgZGVzaXJlZCBxdWFydGVyIG9mIHRoZSBjaXJjbGVcblxuICAgICAgaWYgKGFyY0ludGVyc2VjdGlvbnMubGVuZ3RoID4gMCAmJiBhcmNJbnRlcnNlY3Rpb25zWzBdID49IHRvcFJpZ2h0Q2VudGVyWCAmJiBhcmNJbnRlcnNlY3Rpb25zWzFdIDw9IHRvcFJpZ2h0Q2VudGVyWSkge1xuICAgICAgICByZXR1cm4gW2FyY0ludGVyc2VjdGlvbnNbMF0sIGFyY0ludGVyc2VjdGlvbnNbMV1dO1xuICAgICAgfVxuICAgIH0gLy8gQm90dG9tIFJpZ2h0XG5cbiAgICB7XG4gICAgICB2YXIgYm90dG9tUmlnaHRDZW50ZXJYID0gbm9kZVggKyBoYWxmV2lkdGggLSBjb3JuZXJSYWRpdXM7XG4gICAgICB2YXIgYm90dG9tUmlnaHRDZW50ZXJZID0gbm9kZVkgKyBoYWxmSGVpZ2h0IC0gY29ybmVyUmFkaXVzO1xuICAgICAgYXJjSW50ZXJzZWN0aW9ucyA9IGludGVyc2VjdExpbmVDaXJjbGUoeCwgeSwgbm9kZVgsIG5vZGVZLCBib3R0b21SaWdodENlbnRlclgsIGJvdHRvbVJpZ2h0Q2VudGVyWSwgY29ybmVyUmFkaXVzICsgcGFkZGluZyk7IC8vIEVuc3VyZSB0aGUgaW50ZXJzZWN0aW9uIGlzIG9uIHRoZSBkZXNpcmVkIHF1YXJ0ZXIgb2YgdGhlIGNpcmNsZVxuXG4gICAgICBpZiAoYXJjSW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwICYmIGFyY0ludGVyc2VjdGlvbnNbMF0gPj0gYm90dG9tUmlnaHRDZW50ZXJYICYmIGFyY0ludGVyc2VjdGlvbnNbMV0gPj0gYm90dG9tUmlnaHRDZW50ZXJZKSB7XG4gICAgICAgIHJldHVybiBbYXJjSW50ZXJzZWN0aW9uc1swXSwgYXJjSW50ZXJzZWN0aW9uc1sxXV07XG4gICAgICB9XG4gICAgfSAvLyBCb3R0b20gTGVmdFxuXG4gICAge1xuICAgICAgdmFyIGJvdHRvbUxlZnRDZW50ZXJYID0gbm9kZVggLSBoYWxmV2lkdGggKyBjb3JuZXJSYWRpdXM7XG4gICAgICB2YXIgYm90dG9tTGVmdENlbnRlclkgPSBub2RlWSArIGhhbGZIZWlnaHQgLSBjb3JuZXJSYWRpdXM7XG4gICAgICBhcmNJbnRlcnNlY3Rpb25zID0gaW50ZXJzZWN0TGluZUNpcmNsZSh4LCB5LCBub2RlWCwgbm9kZVksIGJvdHRvbUxlZnRDZW50ZXJYLCBib3R0b21MZWZ0Q2VudGVyWSwgY29ybmVyUmFkaXVzICsgcGFkZGluZyk7IC8vIEVuc3VyZSB0aGUgaW50ZXJzZWN0aW9uIGlzIG9uIHRoZSBkZXNpcmVkIHF1YXJ0ZXIgb2YgdGhlIGNpcmNsZVxuXG4gICAgICBpZiAoYXJjSW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwICYmIGFyY0ludGVyc2VjdGlvbnNbMF0gPD0gYm90dG9tTGVmdENlbnRlclggJiYgYXJjSW50ZXJzZWN0aW9uc1sxXSA+PSBib3R0b21MZWZ0Q2VudGVyWSkge1xuICAgICAgICByZXR1cm4gW2FyY0ludGVyc2VjdGlvbnNbMF0sIGFyY0ludGVyc2VjdGlvbnNbMV1dO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW107IC8vIGlmIG5vdGhpbmdcbiAgfTtcbiAgdmFyIGluTGluZVZpY2luaXR5ID0gZnVuY3Rpb24gaW5MaW5lVmljaW5pdHkoeCwgeSwgbHgxLCBseTEsIGx4MiwgbHkyLCB0b2xlcmFuY2UpIHtcbiAgICB2YXIgdCA9IHRvbGVyYW5jZTtcbiAgICB2YXIgeDEgPSBNYXRoLm1pbihseDEsIGx4Mik7XG4gICAgdmFyIHgyID0gTWF0aC5tYXgobHgxLCBseDIpO1xuICAgIHZhciB5MSA9IE1hdGgubWluKGx5MSwgbHkyKTtcbiAgICB2YXIgeTIgPSBNYXRoLm1heChseTEsIGx5Mik7XG4gICAgcmV0dXJuIHgxIC0gdCA8PSB4ICYmIHggPD0geDIgKyB0ICYmIHkxIC0gdCA8PSB5ICYmIHkgPD0geTIgKyB0O1xuICB9O1xuICB2YXIgaW5CZXppZXJWaWNpbml0eSA9IGZ1bmN0aW9uIGluQmV6aWVyVmljaW5pdHkoeCwgeSwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgdG9sZXJhbmNlKSB7XG4gICAgdmFyIGJiID0ge1xuICAgICAgeDE6IE1hdGgubWluKHgxLCB4MywgeDIpIC0gdG9sZXJhbmNlLFxuICAgICAgeDI6IE1hdGgubWF4KHgxLCB4MywgeDIpICsgdG9sZXJhbmNlLFxuICAgICAgeTE6IE1hdGgubWluKHkxLCB5MywgeTIpIC0gdG9sZXJhbmNlLFxuICAgICAgeTI6IE1hdGgubWF4KHkxLCB5MywgeTIpICsgdG9sZXJhbmNlXG4gICAgfTsgLy8gaWYgb3V0c2lkZSB0aGUgcm91Z2ggYm91bmRpbmcgYm94IGZvciB0aGUgYmV6aWVyLCB0aGVuIGl0IGNhbid0IGJlIGEgaGl0XG5cbiAgICBpZiAoeCA8IGJiLngxIHx8IHggPiBiYi54MiB8fCB5IDwgYmIueTEgfHwgeSA+IGJiLnkyKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZygnYmV6aWVyIG91dCBvZiByb3VnaCBiYicpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdkbyBtb3JlIGV4cGVuc2l2ZSBjaGVjaycpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9O1xuICB2YXIgc29sdmVRdWFkcmF0aWMgPSBmdW5jdGlvbiBzb2x2ZVF1YWRyYXRpYyhhLCBiLCBjLCB2YWwpIHtcbiAgICBjIC09IHZhbDtcbiAgICB2YXIgciA9IGIgKiBiIC0gNCAqIGEgKiBjO1xuXG4gICAgaWYgKHIgPCAwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgdmFyIHNxcnRSID0gTWF0aC5zcXJ0KHIpO1xuICAgIHZhciBkZW5vbSA9IDIgKiBhO1xuICAgIHZhciByb290MSA9ICgtYiArIHNxcnRSKSAvIGRlbm9tO1xuICAgIHZhciByb290MiA9ICgtYiAtIHNxcnRSKSAvIGRlbm9tO1xuICAgIHJldHVybiBbcm9vdDEsIHJvb3QyXTtcbiAgfTtcbiAgdmFyIHNvbHZlQ3ViaWMgPSBmdW5jdGlvbiBzb2x2ZUN1YmljKGEsIGIsIGMsIGQsIHJlc3VsdCkge1xuICAgIC8vIFNvbHZlcyBhIGN1YmljIGZ1bmN0aW9uLCByZXR1cm5zIHJvb3QgaW4gZm9ybSBbcjEsIGkxLCByMiwgaTIsIHIzLCBpM10sIHdoZXJlXG4gICAgLy8gciBpcyB0aGUgcmVhbCBjb21wb25lbnQsIGkgaXMgdGhlIGltYWdpbmFyeSBjb21wb25lbnRcbiAgICAvLyBBbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgQ2FyZGFubyBtZXRob2QgZnJvbSB0aGUgeWVhciAxNTQ1XG4gICAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DdWJpY19mdW5jdGlvbiNUaGVfbmF0dXJlX29mX3RoZV9yb290c1xuICAgIHZhciBlcHNpbG9uID0gMC4wMDAwMTsgLy8gYXZvaWQgZGl2aXNpb24gYnkgemVybyB3aGlsZSBrZWVwaW5nIHRoZSBvdmVyYWxsIGV4cHJlc3Npb24gY2xvc2UgaW4gdmFsdWVcblxuICAgIGlmIChhID09PSAwKSB7XG4gICAgICBhID0gZXBzaWxvbjtcbiAgICB9XG5cbiAgICBiIC89IGE7XG4gICAgYyAvPSBhO1xuICAgIGQgLz0gYTtcbiAgICB2YXIgZGlzY3JpbWluYW50LCBxLCByLCBkdW0xLCBzLCB0LCB0ZXJtMSwgcjEzO1xuICAgIHEgPSAoMy4wICogYyAtIGIgKiBiKSAvIDkuMDtcbiAgICByID0gLSgyNy4wICogZCkgKyBiICogKDkuMCAqIGMgLSAyLjAgKiAoYiAqIGIpKTtcbiAgICByIC89IDU0LjA7XG4gICAgZGlzY3JpbWluYW50ID0gcSAqIHEgKiBxICsgciAqIHI7XG4gICAgcmVzdWx0WzFdID0gMDtcbiAgICB0ZXJtMSA9IGIgLyAzLjA7XG5cbiAgICBpZiAoZGlzY3JpbWluYW50ID4gMCkge1xuICAgICAgcyA9IHIgKyBNYXRoLnNxcnQoZGlzY3JpbWluYW50KTtcbiAgICAgIHMgPSBzIDwgMCA/IC1NYXRoLnBvdygtcywgMS4wIC8gMy4wKSA6IE1hdGgucG93KHMsIDEuMCAvIDMuMCk7XG4gICAgICB0ID0gciAtIE1hdGguc3FydChkaXNjcmltaW5hbnQpO1xuICAgICAgdCA9IHQgPCAwID8gLU1hdGgucG93KC10LCAxLjAgLyAzLjApIDogTWF0aC5wb3codCwgMS4wIC8gMy4wKTtcbiAgICAgIHJlc3VsdFswXSA9IC10ZXJtMSArIHMgKyB0O1xuICAgICAgdGVybTEgKz0gKHMgKyB0KSAvIDIuMDtcbiAgICAgIHJlc3VsdFs0XSA9IHJlc3VsdFsyXSA9IC10ZXJtMTtcbiAgICAgIHRlcm0xID0gTWF0aC5zcXJ0KDMuMCkgKiAoLXQgKyBzKSAvIDI7XG4gICAgICByZXN1bHRbM10gPSB0ZXJtMTtcbiAgICAgIHJlc3VsdFs1XSA9IC10ZXJtMTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXN1bHRbNV0gPSByZXN1bHRbM10gPSAwO1xuXG4gICAgaWYgKGRpc2NyaW1pbmFudCA9PT0gMCkge1xuICAgICAgcjEzID0gciA8IDAgPyAtTWF0aC5wb3coLXIsIDEuMCAvIDMuMCkgOiBNYXRoLnBvdyhyLCAxLjAgLyAzLjApO1xuICAgICAgcmVzdWx0WzBdID0gLXRlcm0xICsgMi4wICogcjEzO1xuICAgICAgcmVzdWx0WzRdID0gcmVzdWx0WzJdID0gLShyMTMgKyB0ZXJtMSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcSA9IC1xO1xuICAgIGR1bTEgPSBxICogcSAqIHE7XG4gICAgZHVtMSA9IE1hdGguYWNvcyhyIC8gTWF0aC5zcXJ0KGR1bTEpKTtcbiAgICByMTMgPSAyLjAgKiBNYXRoLnNxcnQocSk7XG4gICAgcmVzdWx0WzBdID0gLXRlcm0xICsgcjEzICogTWF0aC5jb3MoZHVtMSAvIDMuMCk7XG4gICAgcmVzdWx0WzJdID0gLXRlcm0xICsgcjEzICogTWF0aC5jb3MoKGR1bTEgKyAyLjAgKiBNYXRoLlBJKSAvIDMuMCk7XG4gICAgcmVzdWx0WzRdID0gLXRlcm0xICsgcjEzICogTWF0aC5jb3MoKGR1bTEgKyA0LjAgKiBNYXRoLlBJKSAvIDMuMCk7XG4gICAgcmV0dXJuO1xuICB9O1xuICB2YXIgc3FkaXN0VG9RdWFkcmF0aWNCZXppZXIgPSBmdW5jdGlvbiBzcWRpc3RUb1F1YWRyYXRpY0Jlemllcih4LCB5LCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgLy8gRmluZCBtaW5pbXVtIGRpc3RhbmNlIGJ5IHVzaW5nIHRoZSBtaW5pbXVtIG9mIHRoZSBkaXN0YW5jZVxuICAgIC8vIGZ1bmN0aW9uIGJldHdlZW4gdGhlIGdpdmVuIHBvaW50IGFuZCB0aGUgY3VydmVcbiAgICAvLyBUaGlzIGdpdmVzIHRoZSBjb2VmZmljaWVudHMgb2YgdGhlIHJlc3VsdGluZyBjdWJpYyBlcXVhdGlvblxuICAgIC8vIHdob3NlIHJvb3RzIHRlbGwgdXMgd2hlcmUgYSBwb3NzaWJsZSBtaW5pbXVtIGlzXG4gICAgLy8gKENvZWZmaWNpZW50cyBhcmUgZGl2aWRlZCBieSA0KVxuICAgIHZhciBhID0gMS4wICogeDEgKiB4MSAtIDQgKiB4MSAqIHgyICsgMiAqIHgxICogeDMgKyA0ICogeDIgKiB4MiAtIDQgKiB4MiAqIHgzICsgeDMgKiB4MyArIHkxICogeTEgLSA0ICogeTEgKiB5MiArIDIgKiB5MSAqIHkzICsgNCAqIHkyICogeTIgLSA0ICogeTIgKiB5MyArIHkzICogeTM7XG4gICAgdmFyIGIgPSAxLjAgKiA5ICogeDEgKiB4MiAtIDMgKiB4MSAqIHgxIC0gMyAqIHgxICogeDMgLSA2ICogeDIgKiB4MiArIDMgKiB4MiAqIHgzICsgOSAqIHkxICogeTIgLSAzICogeTEgKiB5MSAtIDMgKiB5MSAqIHkzIC0gNiAqIHkyICogeTIgKyAzICogeTIgKiB5MztcbiAgICB2YXIgYyA9IDEuMCAqIDMgKiB4MSAqIHgxIC0gNiAqIHgxICogeDIgKyB4MSAqIHgzIC0geDEgKiB4ICsgMiAqIHgyICogeDIgKyAyICogeDIgKiB4IC0geDMgKiB4ICsgMyAqIHkxICogeTEgLSA2ICogeTEgKiB5MiArIHkxICogeTMgLSB5MSAqIHkgKyAyICogeTIgKiB5MiArIDIgKiB5MiAqIHkgLSB5MyAqIHk7XG4gICAgdmFyIGQgPSAxLjAgKiB4MSAqIHgyIC0geDEgKiB4MSArIHgxICogeCAtIHgyICogeCArIHkxICogeTIgLSB5MSAqIHkxICsgeTEgKiB5IC0geTIgKiB5OyAvLyBkZWJ1ZyhcImNvZWZmaWNpZW50czogXCIgKyBhIC8gYSArIFwiLCBcIiArIGIgLyBhICsgXCIsIFwiICsgYyAvIGEgKyBcIiwgXCIgKyBkIC8gYSk7XG5cbiAgICB2YXIgcm9vdHMgPSBbXTsgLy8gVXNlIHRoZSBjdWJpYyBzb2x2aW5nIGFsZ29yaXRobVxuXG4gICAgc29sdmVDdWJpYyhhLCBiLCBjLCBkLCByb290cyk7XG4gICAgdmFyIHplcm9UaHJlc2hvbGQgPSAwLjAwMDAwMDE7XG4gICAgdmFyIHBhcmFtcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IDY7IGluZGV4ICs9IDIpIHtcbiAgICAgIGlmIChNYXRoLmFicyhyb290c1tpbmRleCArIDFdKSA8IHplcm9UaHJlc2hvbGQgJiYgcm9vdHNbaW5kZXhdID49IDAgJiYgcm9vdHNbaW5kZXhdIDw9IDEuMCkge1xuICAgICAgICBwYXJhbXMucHVzaChyb290c1tpbmRleF0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHBhcmFtcy5wdXNoKDEuMCk7XG4gICAgcGFyYW1zLnB1c2goMC4wKTtcbiAgICB2YXIgbWluRGlzdGFuY2VTcXVhcmVkID0gLTE7XG4gICAgdmFyIGN1clgsIGN1clksIGRpc3RTcXVhcmVkO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGN1clggPSBNYXRoLnBvdygxLjAgLSBwYXJhbXNbaV0sIDIuMCkgKiB4MSArIDIuMCAqICgxIC0gcGFyYW1zW2ldKSAqIHBhcmFtc1tpXSAqIHgyICsgcGFyYW1zW2ldICogcGFyYW1zW2ldICogeDM7XG4gICAgICBjdXJZID0gTWF0aC5wb3coMSAtIHBhcmFtc1tpXSwgMi4wKSAqIHkxICsgMiAqICgxLjAgLSBwYXJhbXNbaV0pICogcGFyYW1zW2ldICogeTIgKyBwYXJhbXNbaV0gKiBwYXJhbXNbaV0gKiB5MztcbiAgICAgIGRpc3RTcXVhcmVkID0gTWF0aC5wb3coY3VyWCAtIHgsIDIpICsgTWF0aC5wb3coY3VyWSAtIHksIDIpOyAvLyBkZWJ1ZygnZGlzdGFuY2UgZm9yIHBhcmFtICcgKyBwYXJhbXNbaV0gKyBcIjogXCIgKyBNYXRoLnNxcnQoZGlzdFNxdWFyZWQpKTtcblxuICAgICAgaWYgKG1pbkRpc3RhbmNlU3F1YXJlZCA+PSAwKSB7XG4gICAgICAgIGlmIChkaXN0U3F1YXJlZCA8IG1pbkRpc3RhbmNlU3F1YXJlZCkge1xuICAgICAgICAgIG1pbkRpc3RhbmNlU3F1YXJlZCA9IGRpc3RTcXVhcmVkO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtaW5EaXN0YW5jZVNxdWFyZWQgPSBkaXN0U3F1YXJlZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWluRGlzdGFuY2VTcXVhcmVkO1xuICB9O1xuICB2YXIgc3FkaXN0VG9GaW5pdGVMaW5lID0gZnVuY3Rpb24gc3FkaXN0VG9GaW5pdGVMaW5lKHgsIHksIHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgdmFyIG9mZnNldCA9IFt4IC0geDEsIHkgLSB5MV07XG4gICAgdmFyIGxpbmUgPSBbeDIgLSB4MSwgeTIgLSB5MV07XG4gICAgdmFyIGxpbmVTcSA9IGxpbmVbMF0gKiBsaW5lWzBdICsgbGluZVsxXSAqIGxpbmVbMV07XG4gICAgdmFyIGh5cFNxID0gb2Zmc2V0WzBdICogb2Zmc2V0WzBdICsgb2Zmc2V0WzFdICogb2Zmc2V0WzFdO1xuICAgIHZhciBkb3RQcm9kdWN0ID0gb2Zmc2V0WzBdICogbGluZVswXSArIG9mZnNldFsxXSAqIGxpbmVbMV07XG4gICAgdmFyIGFkalNxID0gZG90UHJvZHVjdCAqIGRvdFByb2R1Y3QgLyBsaW5lU3E7XG5cbiAgICBpZiAoZG90UHJvZHVjdCA8IDApIHtcbiAgICAgIHJldHVybiBoeXBTcTtcbiAgICB9XG5cbiAgICBpZiAoYWRqU3EgPiBsaW5lU3EpIHtcbiAgICAgIHJldHVybiAoeCAtIHgyKSAqICh4IC0geDIpICsgKHkgLSB5MikgKiAoeSAtIHkyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaHlwU3EgLSBhZGpTcTtcbiAgfTtcbiAgdmFyIHBvaW50SW5zaWRlUG9seWdvblBvaW50cyA9IGZ1bmN0aW9uIHBvaW50SW5zaWRlUG9seWdvblBvaW50cyh4LCB5LCBwb2ludHMpIHtcbiAgICB2YXIgeDEsIHkxLCB4MiwgeTI7XG4gICAgdmFyIHkzOyAvLyBJbnRlcnNlY3Qgd2l0aCB2ZXJ0aWNhbCBsaW5lIHRocm91Z2ggKHgsIHkpXG5cbiAgICB2YXIgdXAgPSAwOyAvLyBsZXQgZG93biA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgIHgxID0gcG9pbnRzW2kgKiAyXTtcbiAgICAgIHkxID0gcG9pbnRzW2kgKiAyICsgMV07XG5cbiAgICAgIGlmIChpICsgMSA8IHBvaW50cy5sZW5ndGggLyAyKSB7XG4gICAgICAgIHgyID0gcG9pbnRzWyhpICsgMSkgKiAyXTtcbiAgICAgICAgeTIgPSBwb2ludHNbKGkgKyAxKSAqIDIgKyAxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHgyID0gcG9pbnRzWyhpICsgMSAtIHBvaW50cy5sZW5ndGggLyAyKSAqIDJdO1xuICAgICAgICB5MiA9IHBvaW50c1soaSArIDEgLSBwb2ludHMubGVuZ3RoIC8gMikgKiAyICsgMV07XG4gICAgICB9XG5cbiAgICAgIGlmICh4MSA9PSB4ICYmIHgyID09IHgpIDsgZWxzZSBpZiAoeDEgPj0geCAmJiB4ID49IHgyIHx8IHgxIDw9IHggJiYgeCA8PSB4Mikge1xuICAgICAgICB5MyA9ICh4IC0geDEpIC8gKHgyIC0geDEpICogKHkyIC0geTEpICsgeTE7XG5cbiAgICAgICAgaWYgKHkzID4geSkge1xuICAgICAgICAgIHVwKys7XG4gICAgICAgIH0gLy8gaWYoIHkzIDwgeSApe1xuICAgICAgICAvLyBkb3duKys7XG4gICAgICAgIC8vIH1cblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHVwICUgMiA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH07XG4gIHZhciBwb2ludEluc2lkZVBvbHlnb24gPSBmdW5jdGlvbiBwb2ludEluc2lkZVBvbHlnb24oeCwgeSwgYmFzZVBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgZGlyZWN0aW9uLCBwYWRkaW5nKSB7XG4gICAgdmFyIHRyYW5zZm9ybWVkUG9pbnRzID0gbmV3IEFycmF5KGJhc2VQb2ludHMubGVuZ3RoKTsgLy8gR2l2ZXMgbmVnYXRpdmUgYW5nbGVcblxuICAgIHZhciBhbmdsZTtcblxuICAgIGlmIChkaXJlY3Rpb25bMF0gIT0gbnVsbCkge1xuICAgICAgYW5nbGUgPSBNYXRoLmF0YW4oZGlyZWN0aW9uWzFdIC8gZGlyZWN0aW9uWzBdKTtcblxuICAgICAgaWYgKGRpcmVjdGlvblswXSA8IDApIHtcbiAgICAgICAgYW5nbGUgPSBhbmdsZSArIE1hdGguUEkgLyAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYW5nbGUgPSAtYW5nbGUgLSBNYXRoLlBJIC8gMjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYW5nbGUgPSBkaXJlY3Rpb247XG4gICAgfVxuXG4gICAgdmFyIGNvcyA9IE1hdGguY29zKC1hbmdsZSk7XG4gICAgdmFyIHNpbiA9IE1hdGguc2luKC1hbmdsZSk7IC8vICAgIGNvbnNvbGUubG9nKFwiYmFzZTogXCIgKyBiYXNlUG9pbnRzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhbnNmb3JtZWRQb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgICB0cmFuc2Zvcm1lZFBvaW50c1tpICogMl0gPSB3aWR0aCAvIDIgKiAoYmFzZVBvaW50c1tpICogMl0gKiBjb3MgLSBiYXNlUG9pbnRzW2kgKiAyICsgMV0gKiBzaW4pO1xuICAgICAgdHJhbnNmb3JtZWRQb2ludHNbaSAqIDIgKyAxXSA9IGhlaWdodCAvIDIgKiAoYmFzZVBvaW50c1tpICogMiArIDFdICogY29zICsgYmFzZVBvaW50c1tpICogMl0gKiBzaW4pO1xuICAgICAgdHJhbnNmb3JtZWRQb2ludHNbaSAqIDJdICs9IGNlbnRlclg7XG4gICAgICB0cmFuc2Zvcm1lZFBvaW50c1tpICogMiArIDFdICs9IGNlbnRlclk7XG4gICAgfVxuXG4gICAgdmFyIHBvaW50cztcblxuICAgIGlmIChwYWRkaW5nID4gMCkge1xuICAgICAgdmFyIGV4cGFuZGVkTGluZVNldCA9IGV4cGFuZFBvbHlnb24odHJhbnNmb3JtZWRQb2ludHMsIC1wYWRkaW5nKTtcbiAgICAgIHBvaW50cyA9IGpvaW5MaW5lcyhleHBhbmRlZExpbmVTZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb2ludHMgPSB0cmFuc2Zvcm1lZFBvaW50cztcbiAgICB9XG5cbiAgICByZXR1cm4gcG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKHgsIHksIHBvaW50cyk7XG4gIH07XG4gIHZhciBwb2ludEluc2lkZVJvdW5kUG9seWdvbiA9IGZ1bmN0aW9uIHBvaW50SW5zaWRlUm91bmRQb2x5Z29uKHgsIHksIGJhc2VQb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICB2YXIgY3V0UG9seWdvblBvaW50cyA9IG5ldyBBcnJheShiYXNlUG9pbnRzLmxlbmd0aCk7XG4gICAgdmFyIGhhbGZXID0gd2lkdGggLyAyO1xuICAgIHZhciBoYWxmSCA9IGhlaWdodCAvIDI7XG4gICAgdmFyIGNvcm5lclJhZGl1cyA9IGdldFJvdW5kUG9seWdvblJhZGl1cyh3aWR0aCwgaGVpZ2h0KTtcbiAgICB2YXIgc3F1YXJlZENvcm5lclJhZGl1cyA9IGNvcm5lclJhZGl1cyAqIGNvcm5lclJhZGl1cztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmFzZVBvaW50cy5sZW5ndGggLyA0OyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2VVdiA9IHZvaWQgMCxcbiAgICAgICAgICBkZXN0VXYgPSB2b2lkIDA7XG5cbiAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgIHNvdXJjZVV2ID0gYmFzZVBvaW50cy5sZW5ndGggLSAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc291cmNlVXYgPSBpICogNCAtIDI7XG4gICAgICB9XG5cbiAgICAgIGRlc3RVdiA9IGkgKiA0ICsgMjtcbiAgICAgIHZhciBweCA9IGNlbnRlclggKyBoYWxmVyAqIGJhc2VQb2ludHNbaSAqIDRdO1xuICAgICAgdmFyIHB5ID0gY2VudGVyWSArIGhhbGZIICogYmFzZVBvaW50c1tpICogNCArIDFdO1xuICAgICAgdmFyIGNvc1RoZXRhID0gLWJhc2VQb2ludHNbc291cmNlVXZdICogYmFzZVBvaW50c1tkZXN0VXZdIC0gYmFzZVBvaW50c1tzb3VyY2VVdiArIDFdICogYmFzZVBvaW50c1tkZXN0VXYgKyAxXTtcbiAgICAgIHZhciBvZmZzZXQgPSBjb3JuZXJSYWRpdXMgLyBNYXRoLnRhbihNYXRoLmFjb3MoY29zVGhldGEpIC8gMik7XG4gICAgICB2YXIgY3AweCA9IHB4IC0gb2Zmc2V0ICogYmFzZVBvaW50c1tzb3VyY2VVdl07XG4gICAgICB2YXIgY3AweSA9IHB5IC0gb2Zmc2V0ICogYmFzZVBvaW50c1tzb3VyY2VVdiArIDFdO1xuICAgICAgdmFyIGNwMXggPSBweCArIG9mZnNldCAqIGJhc2VQb2ludHNbZGVzdFV2XTtcbiAgICAgIHZhciBjcDF5ID0gcHkgKyBvZmZzZXQgKiBiYXNlUG9pbnRzW2Rlc3RVdiArIDFdO1xuICAgICAgY3V0UG9seWdvblBvaW50c1tpICogNF0gPSBjcDB4O1xuICAgICAgY3V0UG9seWdvblBvaW50c1tpICogNCArIDFdID0gY3AweTtcbiAgICAgIGN1dFBvbHlnb25Qb2ludHNbaSAqIDQgKyAyXSA9IGNwMXg7XG4gICAgICBjdXRQb2x5Z29uUG9pbnRzW2kgKiA0ICsgM10gPSBjcDF5O1xuICAgICAgdmFyIG9ydGh4ID0gYmFzZVBvaW50c1tzb3VyY2VVdiArIDFdO1xuICAgICAgdmFyIG9ydGh5ID0gLWJhc2VQb2ludHNbc291cmNlVXZdO1xuICAgICAgdmFyIGNvc0FscGhhID0gb3J0aHggKiBiYXNlUG9pbnRzW2Rlc3RVdl0gKyBvcnRoeSAqIGJhc2VQb2ludHNbZGVzdFV2ICsgMV07XG5cbiAgICAgIGlmIChjb3NBbHBoYSA8IDApIHtcbiAgICAgICAgb3J0aHggKj0gLTE7XG4gICAgICAgIG9ydGh5ICo9IC0xO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3ggPSBjcDB4ICsgb3J0aHggKiBjb3JuZXJSYWRpdXM7XG4gICAgICB2YXIgY3kgPSBjcDB5ICsgb3J0aHkgKiBjb3JuZXJSYWRpdXM7XG4gICAgICB2YXIgc3F1YXJlZERpc3RhbmNlID0gTWF0aC5wb3coY3ggLSB4LCAyKSArIE1hdGgucG93KGN5IC0geSwgMik7XG5cbiAgICAgIGlmIChzcXVhcmVkRGlzdGFuY2UgPD0gc3F1YXJlZENvcm5lclJhZGl1cykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKHgsIHksIGN1dFBvbHlnb25Qb2ludHMpO1xuICB9O1xuICB2YXIgam9pbkxpbmVzID0gZnVuY3Rpb24gam9pbkxpbmVzKGxpbmVTZXQpIHtcbiAgICB2YXIgdmVydGljZXMgPSBuZXcgQXJyYXkobGluZVNldC5sZW5ndGggLyAyKTtcbiAgICB2YXIgY3VycmVudExpbmVTdGFydFgsIGN1cnJlbnRMaW5lU3RhcnRZLCBjdXJyZW50TGluZUVuZFgsIGN1cnJlbnRMaW5lRW5kWTtcbiAgICB2YXIgbmV4dExpbmVTdGFydFgsIG5leHRMaW5lU3RhcnRZLCBuZXh0TGluZUVuZFgsIG5leHRMaW5lRW5kWTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZVNldC5sZW5ndGggLyA0OyBpKyspIHtcbiAgICAgIGN1cnJlbnRMaW5lU3RhcnRYID0gbGluZVNldFtpICogNF07XG4gICAgICBjdXJyZW50TGluZVN0YXJ0WSA9IGxpbmVTZXRbaSAqIDQgKyAxXTtcbiAgICAgIGN1cnJlbnRMaW5lRW5kWCA9IGxpbmVTZXRbaSAqIDQgKyAyXTtcbiAgICAgIGN1cnJlbnRMaW5lRW5kWSA9IGxpbmVTZXRbaSAqIDQgKyAzXTtcblxuICAgICAgaWYgKGkgPCBsaW5lU2V0Lmxlbmd0aCAvIDQgLSAxKSB7XG4gICAgICAgIG5leHRMaW5lU3RhcnRYID0gbGluZVNldFsoaSArIDEpICogNF07XG4gICAgICAgIG5leHRMaW5lU3RhcnRZID0gbGluZVNldFsoaSArIDEpICogNCArIDFdO1xuICAgICAgICBuZXh0TGluZUVuZFggPSBsaW5lU2V0WyhpICsgMSkgKiA0ICsgMl07XG4gICAgICAgIG5leHRMaW5lRW5kWSA9IGxpbmVTZXRbKGkgKyAxKSAqIDQgKyAzXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRMaW5lU3RhcnRYID0gbGluZVNldFswXTtcbiAgICAgICAgbmV4dExpbmVTdGFydFkgPSBsaW5lU2V0WzFdO1xuICAgICAgICBuZXh0TGluZUVuZFggPSBsaW5lU2V0WzJdO1xuICAgICAgICBuZXh0TGluZUVuZFkgPSBsaW5lU2V0WzNdO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW50ZXJzZWN0aW9uID0gZmluaXRlTGluZXNJbnRlcnNlY3QoY3VycmVudExpbmVTdGFydFgsIGN1cnJlbnRMaW5lU3RhcnRZLCBjdXJyZW50TGluZUVuZFgsIGN1cnJlbnRMaW5lRW5kWSwgbmV4dExpbmVTdGFydFgsIG5leHRMaW5lU3RhcnRZLCBuZXh0TGluZUVuZFgsIG5leHRMaW5lRW5kWSwgdHJ1ZSk7XG4gICAgICB2ZXJ0aWNlc1tpICogMl0gPSBpbnRlcnNlY3Rpb25bMF07XG4gICAgICB2ZXJ0aWNlc1tpICogMiArIDFdID0gaW50ZXJzZWN0aW9uWzFdO1xuICAgIH1cblxuICAgIHJldHVybiB2ZXJ0aWNlcztcbiAgfTtcbiAgdmFyIGV4cGFuZFBvbHlnb24gPSBmdW5jdGlvbiBleHBhbmRQb2x5Z29uKHBvaW50cywgcGFkKSB7XG4gICAgdmFyIGV4cGFuZGVkTGluZVNldCA9IG5ldyBBcnJheShwb2ludHMubGVuZ3RoICogMik7XG4gICAgdmFyIGN1cnJlbnRQb2ludFgsIGN1cnJlbnRQb2ludFksIG5leHRQb2ludFgsIG5leHRQb2ludFk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgIGN1cnJlbnRQb2ludFggPSBwb2ludHNbaSAqIDJdO1xuICAgICAgY3VycmVudFBvaW50WSA9IHBvaW50c1tpICogMiArIDFdO1xuXG4gICAgICBpZiAoaSA8IHBvaW50cy5sZW5ndGggLyAyIC0gMSkge1xuICAgICAgICBuZXh0UG9pbnRYID0gcG9pbnRzWyhpICsgMSkgKiAyXTtcbiAgICAgICAgbmV4dFBvaW50WSA9IHBvaW50c1soaSArIDEpICogMiArIDFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dFBvaW50WCA9IHBvaW50c1swXTtcbiAgICAgICAgbmV4dFBvaW50WSA9IHBvaW50c1sxXTtcbiAgICAgIH0gLy8gQ3VycmVudCBsaW5lOiBbY3VycmVudFBvaW50WCwgY3VycmVudFBvaW50WV0gdG8gW25leHRQb2ludFgsIG5leHRQb2ludFldXG4gICAgICAvLyBBc3N1bWUgQ0NXIHBvbHlnb24gd2luZGluZ1xuXG5cbiAgICAgIHZhciBvZmZzZXRYID0gbmV4dFBvaW50WSAtIGN1cnJlbnRQb2ludFk7XG4gICAgICB2YXIgb2Zmc2V0WSA9IC0obmV4dFBvaW50WCAtIGN1cnJlbnRQb2ludFgpOyAvLyBOb3JtYWxpemVcblxuICAgICAgdmFyIG9mZnNldExlbmd0aCA9IE1hdGguc3FydChvZmZzZXRYICogb2Zmc2V0WCArIG9mZnNldFkgKiBvZmZzZXRZKTtcbiAgICAgIHZhciBub3JtYWxpemVkT2Zmc2V0WCA9IG9mZnNldFggLyBvZmZzZXRMZW5ndGg7XG4gICAgICB2YXIgbm9ybWFsaXplZE9mZnNldFkgPSBvZmZzZXRZIC8gb2Zmc2V0TGVuZ3RoO1xuICAgICAgZXhwYW5kZWRMaW5lU2V0W2kgKiA0XSA9IGN1cnJlbnRQb2ludFggKyBub3JtYWxpemVkT2Zmc2V0WCAqIHBhZDtcbiAgICAgIGV4cGFuZGVkTGluZVNldFtpICogNCArIDFdID0gY3VycmVudFBvaW50WSArIG5vcm1hbGl6ZWRPZmZzZXRZICogcGFkO1xuICAgICAgZXhwYW5kZWRMaW5lU2V0W2kgKiA0ICsgMl0gPSBuZXh0UG9pbnRYICsgbm9ybWFsaXplZE9mZnNldFggKiBwYWQ7XG4gICAgICBleHBhbmRlZExpbmVTZXRbaSAqIDQgKyAzXSA9IG5leHRQb2ludFkgKyBub3JtYWxpemVkT2Zmc2V0WSAqIHBhZDtcbiAgICB9XG5cbiAgICByZXR1cm4gZXhwYW5kZWRMaW5lU2V0O1xuICB9O1xuICB2YXIgaW50ZXJzZWN0TGluZUVsbGlwc2UgPSBmdW5jdGlvbiBpbnRlcnNlY3RMaW5lRWxsaXBzZSh4LCB5LCBjZW50ZXJYLCBjZW50ZXJZLCBlbGxpcHNlV3JhZGl1cywgZWxsaXBzZUhyYWRpdXMpIHtcbiAgICB2YXIgZGlzcFggPSBjZW50ZXJYIC0geDtcbiAgICB2YXIgZGlzcFkgPSBjZW50ZXJZIC0geTtcbiAgICBkaXNwWCAvPSBlbGxpcHNlV3JhZGl1cztcbiAgICBkaXNwWSAvPSBlbGxpcHNlSHJhZGl1cztcbiAgICB2YXIgbGVuID0gTWF0aC5zcXJ0KGRpc3BYICogZGlzcFggKyBkaXNwWSAqIGRpc3BZKTtcbiAgICB2YXIgbmV3TGVuZ3RoID0gbGVuIC0gMTtcblxuICAgIGlmIChuZXdMZW5ndGggPCAwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgdmFyIGxlblByb3BvcnRpb24gPSBuZXdMZW5ndGggLyBsZW47XG4gICAgcmV0dXJuIFsoY2VudGVyWCAtIHgpICogbGVuUHJvcG9ydGlvbiArIHgsIChjZW50ZXJZIC0geSkgKiBsZW5Qcm9wb3J0aW9uICsgeV07XG4gIH07XG4gIHZhciBjaGVja0luRWxsaXBzZSA9IGZ1bmN0aW9uIGNoZWNrSW5FbGxpcHNlKHgsIHksIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclksIHBhZGRpbmcpIHtcbiAgICB4IC09IGNlbnRlclg7XG4gICAgeSAtPSBjZW50ZXJZO1xuICAgIHggLz0gd2lkdGggLyAyICsgcGFkZGluZztcbiAgICB5IC89IGhlaWdodCAvIDIgKyBwYWRkaW5nO1xuICAgIHJldHVybiB4ICogeCArIHkgKiB5IDw9IDE7XG4gIH07IC8vIFJldHVybnMgaW50ZXJzZWN0aW9ucyBvZiBpbmNyZWFzaW5nIGRpc3RhbmNlIGZyb20gbGluZSdzIHN0YXJ0IHBvaW50XG5cbiAgdmFyIGludGVyc2VjdExpbmVDaXJjbGUgPSBmdW5jdGlvbiBpbnRlcnNlY3RMaW5lQ2lyY2xlKHgxLCB5MSwgeDIsIHkyLCBjZW50ZXJYLCBjZW50ZXJZLCByYWRpdXMpIHtcbiAgICAvLyBDYWxjdWxhdGUgZCwgZGlyZWN0aW9uIHZlY3RvciBvZiBsaW5lXG4gICAgdmFyIGQgPSBbeDIgLSB4MSwgeTIgLSB5MV07IC8vIERpcmVjdGlvbiB2ZWN0b3Igb2YgbGluZVxuXG4gICAgdmFyIGYgPSBbeDEgLSBjZW50ZXJYLCB5MSAtIGNlbnRlclldO1xuICAgIHZhciBhID0gZFswXSAqIGRbMF0gKyBkWzFdICogZFsxXTtcbiAgICB2YXIgYiA9IDIgKiAoZlswXSAqIGRbMF0gKyBmWzFdICogZFsxXSk7XG4gICAgdmFyIGMgPSBmWzBdICogZlswXSArIGZbMV0gKiBmWzFdIC0gcmFkaXVzICogcmFkaXVzO1xuICAgIHZhciBkaXNjcmltaW5hbnQgPSBiICogYiAtIDQgKiBhICogYztcblxuICAgIGlmIChkaXNjcmltaW5hbnQgPCAwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgdmFyIHQxID0gKC1iICsgTWF0aC5zcXJ0KGRpc2NyaW1pbmFudCkpIC8gKDIgKiBhKTtcbiAgICB2YXIgdDIgPSAoLWIgLSBNYXRoLnNxcnQoZGlzY3JpbWluYW50KSkgLyAoMiAqIGEpO1xuICAgIHZhciB0TWluID0gTWF0aC5taW4odDEsIHQyKTtcbiAgICB2YXIgdE1heCA9IE1hdGgubWF4KHQxLCB0Mik7XG4gICAgdmFyIGluUmFuZ2VQYXJhbXMgPSBbXTtcblxuICAgIGlmICh0TWluID49IDAgJiYgdE1pbiA8PSAxKSB7XG4gICAgICBpblJhbmdlUGFyYW1zLnB1c2godE1pbik7XG4gICAgfVxuXG4gICAgaWYgKHRNYXggPj0gMCAmJiB0TWF4IDw9IDEpIHtcbiAgICAgIGluUmFuZ2VQYXJhbXMucHVzaCh0TWF4KTtcbiAgICB9XG5cbiAgICBpZiAoaW5SYW5nZVBhcmFtcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICB2YXIgbmVhckludGVyc2VjdGlvblggPSBpblJhbmdlUGFyYW1zWzBdICogZFswXSArIHgxO1xuICAgIHZhciBuZWFySW50ZXJzZWN0aW9uWSA9IGluUmFuZ2VQYXJhbXNbMF0gKiBkWzFdICsgeTE7XG5cbiAgICBpZiAoaW5SYW5nZVBhcmFtcy5sZW5ndGggPiAxKSB7XG4gICAgICBpZiAoaW5SYW5nZVBhcmFtc1swXSA9PSBpblJhbmdlUGFyYW1zWzFdKSB7XG4gICAgICAgIHJldHVybiBbbmVhckludGVyc2VjdGlvblgsIG5lYXJJbnRlcnNlY3Rpb25ZXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBmYXJJbnRlcnNlY3Rpb25YID0gaW5SYW5nZVBhcmFtc1sxXSAqIGRbMF0gKyB4MTtcbiAgICAgICAgdmFyIGZhckludGVyc2VjdGlvblkgPSBpblJhbmdlUGFyYW1zWzFdICogZFsxXSArIHkxO1xuICAgICAgICByZXR1cm4gW25lYXJJbnRlcnNlY3Rpb25YLCBuZWFySW50ZXJzZWN0aW9uWSwgZmFySW50ZXJzZWN0aW9uWCwgZmFySW50ZXJzZWN0aW9uWV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbbmVhckludGVyc2VjdGlvblgsIG5lYXJJbnRlcnNlY3Rpb25ZXTtcbiAgICB9XG4gIH07XG4gIHZhciBtaWRPZlRocmVlID0gZnVuY3Rpb24gbWlkT2ZUaHJlZShhLCBiLCBjKSB7XG4gICAgaWYgKGIgPD0gYSAmJiBhIDw9IGMgfHwgYyA8PSBhICYmIGEgPD0gYikge1xuICAgICAgcmV0dXJuIGE7XG4gICAgfSBlbHNlIGlmIChhIDw9IGIgJiYgYiA8PSBjIHx8IGMgPD0gYiAmJiBiIDw9IGEpIHtcbiAgICAgIHJldHVybiBiO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYztcbiAgICB9XG4gIH07IC8vICh4MSx5MSk9Pih4Mix5MikgaW50ZXJzZWN0IHdpdGggKHgzLHkzKT0+KHg0LHk0KVxuXG4gIHZhciBmaW5pdGVMaW5lc0ludGVyc2VjdCA9IGZ1bmN0aW9uIGZpbml0ZUxpbmVzSW50ZXJzZWN0KHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHg0LCB5NCwgaW5maW5pdGVMaW5lcykge1xuICAgIHZhciBkeDEzID0geDEgLSB4MztcbiAgICB2YXIgZHgyMSA9IHgyIC0geDE7XG4gICAgdmFyIGR4NDMgPSB4NCAtIHgzO1xuICAgIHZhciBkeTEzID0geTEgLSB5MztcbiAgICB2YXIgZHkyMSA9IHkyIC0geTE7XG4gICAgdmFyIGR5NDMgPSB5NCAtIHkzO1xuICAgIHZhciB1YV90ID0gZHg0MyAqIGR5MTMgLSBkeTQzICogZHgxMztcbiAgICB2YXIgdWJfdCA9IGR4MjEgKiBkeTEzIC0gZHkyMSAqIGR4MTM7XG4gICAgdmFyIHVfYiA9IGR5NDMgKiBkeDIxIC0gZHg0MyAqIGR5MjE7XG5cbiAgICBpZiAodV9iICE9PSAwKSB7XG4gICAgICB2YXIgdWEgPSB1YV90IC8gdV9iO1xuICAgICAgdmFyIHViID0gdWJfdCAvIHVfYjtcbiAgICAgIHZhciBmbHB0VGhyZXNob2xkID0gMC4wMDE7XG5cbiAgICAgIHZhciBfbWluID0gMCAtIGZscHRUaHJlc2hvbGQ7XG5cbiAgICAgIHZhciBfbWF4ID0gMSArIGZscHRUaHJlc2hvbGQ7XG5cbiAgICAgIGlmIChfbWluIDw9IHVhICYmIHVhIDw9IF9tYXggJiYgX21pbiA8PSB1YiAmJiB1YiA8PSBfbWF4KSB7XG4gICAgICAgIHJldHVybiBbeDEgKyB1YSAqIGR4MjEsIHkxICsgdWEgKiBkeTIxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghaW5maW5pdGVMaW5lcykge1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gW3gxICsgdWEgKiBkeDIxLCB5MSArIHVhICogZHkyMV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHVhX3QgPT09IDAgfHwgdWJfdCA9PT0gMCkge1xuICAgICAgICAvLyBQYXJhbGxlbCwgY29pbmNpZGVudCBsaW5lcy4gQ2hlY2sgaWYgb3ZlcmxhcFxuICAgICAgICAvLyBDaGVjayBlbmRwb2ludCBvZiBzZWNvbmQgbGluZVxuICAgICAgICBpZiAobWlkT2ZUaHJlZSh4MSwgeDIsIHg0KSA9PT0geDQpIHtcbiAgICAgICAgICByZXR1cm4gW3g0LCB5NF07XG4gICAgICAgIH0gLy8gQ2hlY2sgc3RhcnQgcG9pbnQgb2Ygc2Vjb25kIGxpbmVcblxuXG4gICAgICAgIGlmIChtaWRPZlRocmVlKHgxLCB4MiwgeDMpID09PSB4Mykge1xuICAgICAgICAgIHJldHVybiBbeDMsIHkzXTtcbiAgICAgICAgfSAvLyBFbmRwb2ludCBvZiBmaXJzdCBsaW5lXG5cblxuICAgICAgICBpZiAobWlkT2ZUaHJlZSh4MywgeDQsIHgyKSA9PT0geDIpIHtcbiAgICAgICAgICByZXR1cm4gW3gyLCB5Ml07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBQYXJhbGxlbCwgbm9uLWNvaW5jaWRlbnRcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgIH1cbiAgfTsgLy8gbWF0aC5wb2x5Z29uSW50ZXJzZWN0TGluZSggeCwgeSwgYmFzZVBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgcGFkZGluZyApXG4gIC8vIGludGVyc2VjdCBhIG5vZGUgcG9seWdvbiAocHRzIHRyYW5zZm9ybWVkKVxuICAvL1xuICAvLyBtYXRoLnBvbHlnb25JbnRlcnNlY3RMaW5lKCB4LCB5LCBiYXNlUG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZIClcbiAgLy8gaW50ZXJzZWN0IHRoZSBwb2ludHMgKG5vIHRyYW5zZm9ybSlcblxuICB2YXIgcG9seWdvbkludGVyc2VjdExpbmUgPSBmdW5jdGlvbiBwb2x5Z29uSW50ZXJzZWN0TGluZSh4LCB5LCBiYXNlUG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBwYWRkaW5nKSB7XG4gICAgdmFyIGludGVyc2VjdGlvbnMgPSBbXTtcbiAgICB2YXIgaW50ZXJzZWN0aW9uO1xuICAgIHZhciB0cmFuc2Zvcm1lZFBvaW50cyA9IG5ldyBBcnJheShiYXNlUG9pbnRzLmxlbmd0aCk7XG4gICAgdmFyIGRvVHJhbnNmb3JtID0gdHJ1ZTtcblxuICAgIGlmICh3aWR0aCA9PSBudWxsKSB7XG4gICAgICBkb1RyYW5zZm9ybSA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBwb2ludHM7XG5cbiAgICBpZiAoZG9UcmFuc2Zvcm0pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhbnNmb3JtZWRQb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgICAgIHRyYW5zZm9ybWVkUG9pbnRzW2kgKiAyXSA9IGJhc2VQb2ludHNbaSAqIDJdICogd2lkdGggKyBjZW50ZXJYO1xuICAgICAgICB0cmFuc2Zvcm1lZFBvaW50c1tpICogMiArIDFdID0gYmFzZVBvaW50c1tpICogMiArIDFdICogaGVpZ2h0ICsgY2VudGVyWTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhZGRpbmcgPiAwKSB7XG4gICAgICAgIHZhciBleHBhbmRlZExpbmVTZXQgPSBleHBhbmRQb2x5Z29uKHRyYW5zZm9ybWVkUG9pbnRzLCAtcGFkZGluZyk7XG4gICAgICAgIHBvaW50cyA9IGpvaW5MaW5lcyhleHBhbmRlZExpbmVTZXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9pbnRzID0gdHJhbnNmb3JtZWRQb2ludHM7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvaW50cyA9IGJhc2VQb2ludHM7XG4gICAgfVxuXG4gICAgdmFyIGN1cnJlbnRYLCBjdXJyZW50WSwgbmV4dFgsIG5leHRZO1xuXG4gICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgcG9pbnRzLmxlbmd0aCAvIDI7IF9pMisrKSB7XG4gICAgICBjdXJyZW50WCA9IHBvaW50c1tfaTIgKiAyXTtcbiAgICAgIGN1cnJlbnRZID0gcG9pbnRzW19pMiAqIDIgKyAxXTtcblxuICAgICAgaWYgKF9pMiA8IHBvaW50cy5sZW5ndGggLyAyIC0gMSkge1xuICAgICAgICBuZXh0WCA9IHBvaW50c1soX2kyICsgMSkgKiAyXTtcbiAgICAgICAgbmV4dFkgPSBwb2ludHNbKF9pMiArIDEpICogMiArIDFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dFggPSBwb2ludHNbMF07XG4gICAgICAgIG5leHRZID0gcG9pbnRzWzFdO1xuICAgICAgfVxuXG4gICAgICBpbnRlcnNlY3Rpb24gPSBmaW5pdGVMaW5lc0ludGVyc2VjdCh4LCB5LCBjZW50ZXJYLCBjZW50ZXJZLCBjdXJyZW50WCwgY3VycmVudFksIG5leHRYLCBuZXh0WSk7XG5cbiAgICAgIGlmIChpbnRlcnNlY3Rpb24ubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIGludGVyc2VjdGlvbnMucHVzaChpbnRlcnNlY3Rpb25bMF0sIGludGVyc2VjdGlvblsxXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGludGVyc2VjdGlvbnM7XG4gIH07XG4gIHZhciByb3VuZFBvbHlnb25JbnRlcnNlY3RMaW5lID0gZnVuY3Rpb24gcm91bmRQb2x5Z29uSW50ZXJzZWN0TGluZSh4LCB5LCBiYXNlUG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBwYWRkaW5nKSB7XG4gICAgdmFyIGludGVyc2VjdGlvbnMgPSBbXTtcbiAgICB2YXIgaW50ZXJzZWN0aW9uO1xuICAgIHZhciBsaW5lcyA9IG5ldyBBcnJheShiYXNlUG9pbnRzLmxlbmd0aCk7XG4gICAgdmFyIGhhbGZXID0gd2lkdGggLyAyO1xuICAgIHZhciBoYWxmSCA9IGhlaWdodCAvIDI7XG4gICAgdmFyIGNvcm5lclJhZGl1cyA9IGdldFJvdW5kUG9seWdvblJhZGl1cyh3aWR0aCwgaGVpZ2h0KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmFzZVBvaW50cy5sZW5ndGggLyA0OyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2VVdiA9IHZvaWQgMCxcbiAgICAgICAgICBkZXN0VXYgPSB2b2lkIDA7XG5cbiAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgIHNvdXJjZVV2ID0gYmFzZVBvaW50cy5sZW5ndGggLSAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc291cmNlVXYgPSBpICogNCAtIDI7XG4gICAgICB9XG5cbiAgICAgIGRlc3RVdiA9IGkgKiA0ICsgMjtcbiAgICAgIHZhciBweCA9IGNlbnRlclggKyBoYWxmVyAqIGJhc2VQb2ludHNbaSAqIDRdO1xuICAgICAgdmFyIHB5ID0gY2VudGVyWSArIGhhbGZIICogYmFzZVBvaW50c1tpICogNCArIDFdO1xuICAgICAgdmFyIGNvc1RoZXRhID0gLWJhc2VQb2ludHNbc291cmNlVXZdICogYmFzZVBvaW50c1tkZXN0VXZdIC0gYmFzZVBvaW50c1tzb3VyY2VVdiArIDFdICogYmFzZVBvaW50c1tkZXN0VXYgKyAxXTtcbiAgICAgIHZhciBvZmZzZXQgPSBjb3JuZXJSYWRpdXMgLyBNYXRoLnRhbihNYXRoLmFjb3MoY29zVGhldGEpIC8gMik7XG4gICAgICB2YXIgY3AweCA9IHB4IC0gb2Zmc2V0ICogYmFzZVBvaW50c1tzb3VyY2VVdl07XG4gICAgICB2YXIgY3AweSA9IHB5IC0gb2Zmc2V0ICogYmFzZVBvaW50c1tzb3VyY2VVdiArIDFdO1xuICAgICAgdmFyIGNwMXggPSBweCArIG9mZnNldCAqIGJhc2VQb2ludHNbZGVzdFV2XTtcbiAgICAgIHZhciBjcDF5ID0gcHkgKyBvZmZzZXQgKiBiYXNlUG9pbnRzW2Rlc3RVdiArIDFdO1xuXG4gICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICBsaW5lc1tiYXNlUG9pbnRzLmxlbmd0aCAtIDJdID0gY3AweDtcbiAgICAgICAgbGluZXNbYmFzZVBvaW50cy5sZW5ndGggLSAxXSA9IGNwMHk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaW5lc1tpICogNCAtIDJdID0gY3AweDtcbiAgICAgICAgbGluZXNbaSAqIDQgLSAxXSA9IGNwMHk7XG4gICAgICB9XG5cbiAgICAgIGxpbmVzW2kgKiA0XSA9IGNwMXg7XG4gICAgICBsaW5lc1tpICogNCArIDFdID0gY3AxeTtcbiAgICAgIHZhciBvcnRoeCA9IGJhc2VQb2ludHNbc291cmNlVXYgKyAxXTtcbiAgICAgIHZhciBvcnRoeSA9IC1iYXNlUG9pbnRzW3NvdXJjZVV2XTtcbiAgICAgIHZhciBjb3NBbHBoYSA9IG9ydGh4ICogYmFzZVBvaW50c1tkZXN0VXZdICsgb3J0aHkgKiBiYXNlUG9pbnRzW2Rlc3RVdiArIDFdO1xuXG4gICAgICBpZiAoY29zQWxwaGEgPCAwKSB7XG4gICAgICAgIG9ydGh4ICo9IC0xO1xuICAgICAgICBvcnRoeSAqPSAtMTtcbiAgICAgIH1cblxuICAgICAgdmFyIGN4ID0gY3AweCArIG9ydGh4ICogY29ybmVyUmFkaXVzO1xuICAgICAgdmFyIGN5ID0gY3AweSArIG9ydGh5ICogY29ybmVyUmFkaXVzO1xuICAgICAgaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0TGluZUNpcmNsZSh4LCB5LCBjZW50ZXJYLCBjZW50ZXJZLCBjeCwgY3ksIGNvcm5lclJhZGl1cyk7XG5cbiAgICAgIGlmIChpbnRlcnNlY3Rpb24ubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIGludGVyc2VjdGlvbnMucHVzaChpbnRlcnNlY3Rpb25bMF0sIGludGVyc2VjdGlvblsxXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgbGluZXMubGVuZ3RoIC8gNDsgX2kzKyspIHtcbiAgICAgIGludGVyc2VjdGlvbiA9IGZpbml0ZUxpbmVzSW50ZXJzZWN0KHgsIHksIGNlbnRlclgsIGNlbnRlclksIGxpbmVzW19pMyAqIDRdLCBsaW5lc1tfaTMgKiA0ICsgMV0sIGxpbmVzW19pMyAqIDQgKyAyXSwgbGluZXNbX2kzICogNCArIDNdLCBmYWxzZSk7XG5cbiAgICAgIGlmIChpbnRlcnNlY3Rpb24ubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIGludGVyc2VjdGlvbnMucHVzaChpbnRlcnNlY3Rpb25bMF0sIGludGVyc2VjdGlvblsxXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGludGVyc2VjdGlvbnMubGVuZ3RoID4gMikge1xuICAgICAgdmFyIGxvd2VzdEludGVyc2VjdGlvbiA9IFtpbnRlcnNlY3Rpb25zWzBdLCBpbnRlcnNlY3Rpb25zWzFdXTtcbiAgICAgIHZhciBsb3dlc3RTcXVhcmVkRGlzdGFuY2UgPSBNYXRoLnBvdyhsb3dlc3RJbnRlcnNlY3Rpb25bMF0gLSB4LCAyKSArIE1hdGgucG93KGxvd2VzdEludGVyc2VjdGlvblsxXSAtIHksIDIpO1xuXG4gICAgICBmb3IgKHZhciBfaTQgPSAxOyBfaTQgPCBpbnRlcnNlY3Rpb25zLmxlbmd0aCAvIDI7IF9pNCsrKSB7XG4gICAgICAgIHZhciBzcXVhcmVkRGlzdGFuY2UgPSBNYXRoLnBvdyhpbnRlcnNlY3Rpb25zW19pNCAqIDJdIC0geCwgMikgKyBNYXRoLnBvdyhpbnRlcnNlY3Rpb25zW19pNCAqIDIgKyAxXSAtIHksIDIpO1xuXG4gICAgICAgIGlmIChzcXVhcmVkRGlzdGFuY2UgPD0gbG93ZXN0U3F1YXJlZERpc3RhbmNlKSB7XG4gICAgICAgICAgbG93ZXN0SW50ZXJzZWN0aW9uWzBdID0gaW50ZXJzZWN0aW9uc1tfaTQgKiAyXTtcbiAgICAgICAgICBsb3dlc3RJbnRlcnNlY3Rpb25bMV0gPSBpbnRlcnNlY3Rpb25zW19pNCAqIDIgKyAxXTtcbiAgICAgICAgICBsb3dlc3RTcXVhcmVkRGlzdGFuY2UgPSBzcXVhcmVkRGlzdGFuY2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxvd2VzdEludGVyc2VjdGlvbjtcbiAgICB9XG5cbiAgICByZXR1cm4gaW50ZXJzZWN0aW9ucztcbiAgfTtcbiAgdmFyIHNob3J0ZW5JbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiBzaG9ydGVuSW50ZXJzZWN0aW9uKGludGVyc2VjdGlvbiwgb2Zmc2V0LCBhbW91bnQpIHtcbiAgICB2YXIgZGlzcCA9IFtpbnRlcnNlY3Rpb25bMF0gLSBvZmZzZXRbMF0sIGludGVyc2VjdGlvblsxXSAtIG9mZnNldFsxXV07XG4gICAgdmFyIGxlbmd0aCA9IE1hdGguc3FydChkaXNwWzBdICogZGlzcFswXSArIGRpc3BbMV0gKiBkaXNwWzFdKTtcbiAgICB2YXIgbGVuUmF0aW8gPSAobGVuZ3RoIC0gYW1vdW50KSAvIGxlbmd0aDtcblxuICAgIGlmIChsZW5SYXRpbyA8IDApIHtcbiAgICAgIGxlblJhdGlvID0gMC4wMDAwMTtcbiAgICB9XG5cbiAgICByZXR1cm4gW29mZnNldFswXSArIGxlblJhdGlvICogZGlzcFswXSwgb2Zmc2V0WzFdICsgbGVuUmF0aW8gKiBkaXNwWzFdXTtcbiAgfTtcbiAgdmFyIGdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSA9IGZ1bmN0aW9uIGdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZShzaWRlcywgcm90YXRpb25SYWRpYW5zKSB7XG4gICAgdmFyIHBvaW50cyA9IGdlbmVyYXRlVW5pdE5nb25Qb2ludHMoc2lkZXMsIHJvdGF0aW9uUmFkaWFucyk7XG4gICAgcG9pbnRzID0gZml0UG9seWdvblRvU3F1YXJlKHBvaW50cyk7XG4gICAgcmV0dXJuIHBvaW50cztcbiAgfTtcbiAgdmFyIGZpdFBvbHlnb25Ub1NxdWFyZSA9IGZ1bmN0aW9uIGZpdFBvbHlnb25Ub1NxdWFyZShwb2ludHMpIHtcbiAgICB2YXIgeCwgeTtcbiAgICB2YXIgc2lkZXMgPSBwb2ludHMubGVuZ3RoIC8gMjtcbiAgICB2YXIgbWluWCA9IEluZmluaXR5LFxuICAgICAgICBtaW5ZID0gSW5maW5pdHksXG4gICAgICAgIG1heFggPSAtSW5maW5pdHksXG4gICAgICAgIG1heFkgPSAtSW5maW5pdHk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZGVzOyBpKyspIHtcbiAgICAgIHggPSBwb2ludHNbMiAqIGldO1xuICAgICAgeSA9IHBvaW50c1syICogaSArIDFdO1xuICAgICAgbWluWCA9IE1hdGgubWluKG1pblgsIHgpO1xuICAgICAgbWF4WCA9IE1hdGgubWF4KG1heFgsIHgpO1xuICAgICAgbWluWSA9IE1hdGgubWluKG1pblksIHkpO1xuICAgICAgbWF4WSA9IE1hdGgubWF4KG1heFksIHkpO1xuICAgIH0gLy8gc3RyZXRjaCBmYWN0b3JzXG5cblxuICAgIHZhciBzeCA9IDIgLyAobWF4WCAtIG1pblgpO1xuICAgIHZhciBzeSA9IDIgLyAobWF4WSAtIG1pblkpO1xuXG4gICAgZm9yICh2YXIgX2k1ID0gMDsgX2k1IDwgc2lkZXM7IF9pNSsrKSB7XG4gICAgICB4ID0gcG9pbnRzWzIgKiBfaTVdID0gcG9pbnRzWzIgKiBfaTVdICogc3g7XG4gICAgICB5ID0gcG9pbnRzWzIgKiBfaTUgKyAxXSA9IHBvaW50c1syICogX2k1ICsgMV0gKiBzeTtcbiAgICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCB4KTtcbiAgICAgIG1heFggPSBNYXRoLm1heChtYXhYLCB4KTtcbiAgICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCB5KTtcbiAgICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCB5KTtcbiAgICB9XG5cbiAgICBpZiAobWluWSA8IC0xKSB7XG4gICAgICBmb3IgKHZhciBfaTYgPSAwOyBfaTYgPCBzaWRlczsgX2k2KyspIHtcbiAgICAgICAgeSA9IHBvaW50c1syICogX2k2ICsgMV0gPSBwb2ludHNbMiAqIF9pNiArIDFdICsgKC0xIC0gbWluWSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvaW50cztcbiAgfTtcbiAgdmFyIGdlbmVyYXRlVW5pdE5nb25Qb2ludHMgPSBmdW5jdGlvbiBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzKHNpZGVzLCByb3RhdGlvblJhZGlhbnMpIHtcbiAgICB2YXIgaW5jcmVtZW50ID0gMS4wIC8gc2lkZXMgKiAyICogTWF0aC5QSTtcbiAgICB2YXIgc3RhcnRBbmdsZSA9IHNpZGVzICUgMiA9PT0gMCA/IE1hdGguUEkgLyAyLjAgKyBpbmNyZW1lbnQgLyAyLjAgOiBNYXRoLlBJIC8gMi4wO1xuICAgIHN0YXJ0QW5nbGUgKz0gcm90YXRpb25SYWRpYW5zO1xuICAgIHZhciBwb2ludHMgPSBuZXcgQXJyYXkoc2lkZXMgKiAyKTtcbiAgICB2YXIgY3VycmVudEFuZ2xlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWRlczsgaSsrKSB7XG4gICAgICBjdXJyZW50QW5nbGUgPSBpICogaW5jcmVtZW50ICsgc3RhcnRBbmdsZTtcbiAgICAgIHBvaW50c1syICogaV0gPSBNYXRoLmNvcyhjdXJyZW50QW5nbGUpOyAvLyB4XG5cbiAgICAgIHBvaW50c1syICogaSArIDFdID0gTWF0aC5zaW4oLWN1cnJlbnRBbmdsZSk7IC8vIHlcbiAgICB9XG5cbiAgICByZXR1cm4gcG9pbnRzO1xuICB9OyAvLyBTZXQgdGhlIGRlZmF1bHQgcmFkaXVzLCB1bmxlc3MgaGFsZiBvZiB3aWR0aCBvciBoZWlnaHQgaXMgc21hbGxlciB0aGFuIGRlZmF1bHRcblxuICB2YXIgZ2V0Um91bmRSZWN0YW5nbGVSYWRpdXMgPSBmdW5jdGlvbiBnZXRSb3VuZFJlY3RhbmdsZVJhZGl1cyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgcmV0dXJuIE1hdGgubWluKHdpZHRoIC8gNCwgaGVpZ2h0IC8gNCwgOCk7XG4gIH07IC8vIFNldCB0aGUgZGVmYXVsdCByYWRpdXNcblxuICB2YXIgZ2V0Um91bmRQb2x5Z29uUmFkaXVzID0gZnVuY3Rpb24gZ2V0Um91bmRQb2x5Z29uUmFkaXVzKHdpZHRoLCBoZWlnaHQpIHtcbiAgICByZXR1cm4gTWF0aC5taW4od2lkdGggLyAxMCwgaGVpZ2h0IC8gMTAsIDgpO1xuICB9O1xuICB2YXIgZ2V0Q3V0UmVjdGFuZ2xlQ29ybmVyTGVuZ3RoID0gZnVuY3Rpb24gZ2V0Q3V0UmVjdGFuZ2xlQ29ybmVyTGVuZ3RoKCkge1xuICAgIHJldHVybiA4O1xuICB9O1xuICB2YXIgYmV6aWVyUHRzVG9RdWFkQ29lZmYgPSBmdW5jdGlvbiBiZXppZXJQdHNUb1F1YWRDb2VmZihwMCwgcDEsIHAyKSB7XG4gICAgcmV0dXJuIFtwMCAtIDIgKiBwMSArIHAyLCAyICogKHAxIC0gcDApLCBwMF07XG4gIH07IC8vIGdldCBjdXJ2ZSB3aWR0aCwgaGVpZ2h0LCBhbmQgY29udHJvbCBwb2ludCBwb3NpdGlvbiBvZmZzZXRzIGFzIGEgcGVyY2VudGFnZSBvZiBub2RlIGhlaWdodCAvIHdpZHRoXG5cbiAgdmFyIGdldEJhcnJlbEN1cnZlQ29uc3RhbnRzID0gZnVuY3Rpb24gZ2V0QmFycmVsQ3VydmVDb25zdGFudHMod2lkdGgsIGhlaWdodCkge1xuICAgIHJldHVybiB7XG4gICAgICBoZWlnaHRPZmZzZXQ6IE1hdGgubWluKDE1LCAwLjA1ICogaGVpZ2h0KSxcbiAgICAgIHdpZHRoT2Zmc2V0OiBNYXRoLm1pbigxMDAsIDAuMjUgKiB3aWR0aCksXG4gICAgICBjdHJsUHRPZmZzZXRQY3Q6IDAuMDVcbiAgICB9O1xuICB9O1xuXG4gIHZhciBwYWdlUmFua0RlZmF1bHRzID0gZGVmYXVsdHMkZyh7XG4gICAgZGFtcGluZ0ZhY3RvcjogMC44LFxuICAgIHByZWNpc2lvbjogMC4wMDAwMDEsXG4gICAgaXRlcmF0aW9uczogMjAwLFxuICAgIHdlaWdodDogZnVuY3Rpb24gd2VpZ2h0KGVkZ2UpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgfSk7XG4gIHZhciBlbGVzZm4kbyA9IHtcbiAgICBwYWdlUmFuazogZnVuY3Rpb24gcGFnZVJhbmsob3B0aW9ucykge1xuICAgICAgdmFyIF9wYWdlUmFua0RlZmF1bHRzID0gcGFnZVJhbmtEZWZhdWx0cyhvcHRpb25zKSxcbiAgICAgICAgICBkYW1waW5nRmFjdG9yID0gX3BhZ2VSYW5rRGVmYXVsdHMuZGFtcGluZ0ZhY3RvcixcbiAgICAgICAgICBwcmVjaXNpb24gPSBfcGFnZVJhbmtEZWZhdWx0cy5wcmVjaXNpb24sXG4gICAgICAgICAgaXRlcmF0aW9ucyA9IF9wYWdlUmFua0RlZmF1bHRzLml0ZXJhdGlvbnMsXG4gICAgICAgICAgd2VpZ2h0ID0gX3BhZ2VSYW5rRGVmYXVsdHMud2VpZ2h0O1xuXG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuXG4gICAgICB2YXIgX3RoaXMkYnlHcm91cCA9IHRoaXMuYnlHcm91cCgpLFxuICAgICAgICAgIG5vZGVzID0gX3RoaXMkYnlHcm91cC5ub2RlcyxcbiAgICAgICAgICBlZGdlcyA9IF90aGlzJGJ5R3JvdXAuZWRnZXM7XG5cbiAgICAgIHZhciBudW1Ob2RlcyA9IG5vZGVzLmxlbmd0aDtcbiAgICAgIHZhciBudW1Ob2Rlc1NxZCA9IG51bU5vZGVzICogbnVtTm9kZXM7XG4gICAgICB2YXIgbnVtRWRnZXMgPSBlZGdlcy5sZW5ndGg7IC8vIENvbnN0cnVjdCB0cmFuc3Bvc2VkIGFkamFjZW5jeSBtYXRyaXhcbiAgICAgIC8vIEZpcnN0IGxldHMgaGF2ZSBhIHplcm9lZCBtYXRyaXggb2YgdGhlIHJpZ2h0IHNpemVcbiAgICAgIC8vIFdlJ2xsIGFsc28ga2VlcCB0cmFjayBvZiB0aGUgc3VtIG9mIGVhY2ggY29sdW1uXG5cbiAgICAgIHZhciBtYXRyaXggPSBuZXcgQXJyYXkobnVtTm9kZXNTcWQpO1xuICAgICAgdmFyIGNvbHVtblN1bSA9IG5ldyBBcnJheShudW1Ob2Rlcyk7XG4gICAgICB2YXIgYWRkaXRpb25hbFByb2IgPSAoMSAtIGRhbXBpbmdGYWN0b3IpIC8gbnVtTm9kZXM7IC8vIENyZWF0ZSBudWxsIG1hdHJpeFxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKyspIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1Ob2RlczsgaisrKSB7XG4gICAgICAgICAgdmFyIG4gPSBpICogbnVtTm9kZXMgKyBqO1xuICAgICAgICAgIG1hdHJpeFtuXSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBjb2x1bW5TdW1baV0gPSAwO1xuICAgICAgfSAvLyBOb3csIHByb2Nlc3MgZWRnZXNcblxuXG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbnVtRWRnZXM7IF9pKyspIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tfaV07XG4gICAgICAgIHZhciBzcmNJZCA9IGVkZ2UuZGF0YSgnc291cmNlJyk7XG4gICAgICAgIHZhciB0Z3RJZCA9IGVkZ2UuZGF0YSgndGFyZ2V0Jyk7IC8vIERvbid0IGluY2x1ZGUgbG9vcHMgaW4gdGhlIG1hdHJpeFxuXG4gICAgICAgIGlmIChzcmNJZCA9PT0gdGd0SWQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzID0gbm9kZXMuaW5kZXhPZklkKHNyY0lkKTtcbiAgICAgICAgdmFyIHQgPSBub2Rlcy5pbmRleE9mSWQodGd0SWQpO1xuICAgICAgICB2YXIgdyA9IHdlaWdodChlZGdlKTtcblxuICAgICAgICB2YXIgX24gPSB0ICogbnVtTm9kZXMgKyBzOyAvLyBVcGRhdGUgbWF0cml4XG5cblxuICAgICAgICBtYXRyaXhbX25dICs9IHc7IC8vIFVwZGF0ZSBjb2x1bW4gc3VtXG5cbiAgICAgICAgY29sdW1uU3VtW3NdICs9IHc7XG4gICAgICB9IC8vIEFkZCBhZGRpdGlvbmFsIHByb2JhYmlsaXR5IGJhc2VkIG9uIGRhbXBpbmcgZmFjdG9yXG4gICAgICAvLyBBbHNvLCB0YWtlIGludG8gYWNjb3VudCBjb2x1bW5zIHRoYXQgaGF2ZSBzdW0gPSAwXG5cblxuICAgICAgdmFyIHAgPSAxLjAgLyBudW1Ob2RlcyArIGFkZGl0aW9uYWxQcm9iOyAvLyBTaG9ydGhhbmRcbiAgICAgIC8vIFRyYXZlcnNlIG1hdHJpeCwgY29sdW1uIGJ5IGNvbHVtblxuXG4gICAgICBmb3IgKHZhciBfaiA9IDA7IF9qIDwgbnVtTm9kZXM7IF9qKyspIHtcbiAgICAgICAgaWYgKGNvbHVtblN1bVtfal0gPT09IDApIHtcbiAgICAgICAgICAvLyBObyAnbGlua3MnIG91dCBmcm9tIG5vZGUganRoLCBhc3N1bWUgZXF1YWwgcHJvYmFiaWxpdHkgZm9yIGVhY2ggcG9zc2libGUgbm9kZVxuICAgICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG51bU5vZGVzOyBfaTIrKykge1xuICAgICAgICAgICAgdmFyIF9uMiA9IF9pMiAqIG51bU5vZGVzICsgX2o7XG5cbiAgICAgICAgICAgIG1hdHJpeFtfbjJdID0gcDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTm9kZSBqdGggaGFzIG91dGdvaW5nIGxpbmssIGNvbXB1dGUgbm9ybWFsaXplZCBwcm9iYWJpbGl0aWVzXG4gICAgICAgICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgbnVtTm9kZXM7IF9pMysrKSB7XG4gICAgICAgICAgICB2YXIgX24zID0gX2kzICogbnVtTm9kZXMgKyBfajtcblxuICAgICAgICAgICAgbWF0cml4W19uM10gPSBtYXRyaXhbX24zXSAvIGNvbHVtblN1bVtfal0gKyBhZGRpdGlvbmFsUHJvYjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gQ29tcHV0ZSBkb21pbmFudCBlaWdlbnZlY3RvciB1c2luZyBwb3dlciBtZXRob2RcblxuXG4gICAgICB2YXIgZWlnZW52ZWN0b3IgPSBuZXcgQXJyYXkobnVtTm9kZXMpO1xuICAgICAgdmFyIHRlbXAgPSBuZXcgQXJyYXkobnVtTm9kZXMpO1xuICAgICAgdmFyIHByZXZpb3VzOyAvLyBTdGFydCB3aXRoIGEgdmVjdG9yIG9mIGFsbCAxJ3NcbiAgICAgIC8vIEFsc28sIGluaXRpYWxpemUgYSBudWxsIHZlY3RvciB3aGljaCB3aWxsIGJlIHVzZWQgYXMgc2hvcnRoYW5kXG5cbiAgICAgIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IG51bU5vZGVzOyBfaTQrKykge1xuICAgICAgICBlaWdlbnZlY3RvcltfaTRdID0gMTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaXRlciA9IDA7IGl0ZXIgPCBpdGVyYXRpb25zOyBpdGVyKyspIHtcbiAgICAgICAgLy8gVGVtcCBhcnJheSB3aXRoIGFsbCAwJ3NcbiAgICAgICAgZm9yICh2YXIgX2k1ID0gMDsgX2k1IDwgbnVtTm9kZXM7IF9pNSsrKSB7XG4gICAgICAgICAgdGVtcFtfaTVdID0gMDtcbiAgICAgICAgfSAvLyBNdWx0aXBseSBtYXRyaXggd2l0aCBwcmV2aW91cyByZXN1bHRcblxuXG4gICAgICAgIGZvciAodmFyIF9pNiA9IDA7IF9pNiA8IG51bU5vZGVzOyBfaTYrKykge1xuICAgICAgICAgIGZvciAodmFyIF9qMiA9IDA7IF9qMiA8IG51bU5vZGVzOyBfajIrKykge1xuICAgICAgICAgICAgdmFyIF9uNCA9IF9pNiAqIG51bU5vZGVzICsgX2oyO1xuXG4gICAgICAgICAgICB0ZW1wW19pNl0gKz0gbWF0cml4W19uNF0gKiBlaWdlbnZlY3RvcltfajJdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGluUGxhY2VTdW1Ob3JtYWxpemUodGVtcCk7XG4gICAgICAgIHByZXZpb3VzID0gZWlnZW52ZWN0b3I7XG4gICAgICAgIGVpZ2VudmVjdG9yID0gdGVtcDtcbiAgICAgICAgdGVtcCA9IHByZXZpb3VzO1xuICAgICAgICB2YXIgZGlmZiA9IDA7IC8vIENvbXB1dGUgZGlmZmVyZW5jZSAoc3F1YXJlZCBtb2R1bGUpIG9mIGJvdGggdmVjdG9yc1xuXG4gICAgICAgIGZvciAodmFyIF9pNyA9IDA7IF9pNyA8IG51bU5vZGVzOyBfaTcrKykge1xuICAgICAgICAgIHZhciBkZWx0YSA9IHByZXZpb3VzW19pN10gLSBlaWdlbnZlY3RvcltfaTddO1xuICAgICAgICAgIGRpZmYgKz0gZGVsdGEgKiBkZWx0YTtcbiAgICAgICAgfSAvLyBJZiBkaWZmZXJlbmNlIGlzIGxlc3MgdGhhbiB0aGUgZGVzaXJlZCB0aHJlc2hvbGQsIHN0b3AgaXRlcmF0aW5nXG5cblxuICAgICAgICBpZiAoZGlmZiA8IHByZWNpc2lvbikge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IC8vIENvbnN0cnVjdCByZXN1bHRcblxuXG4gICAgICB2YXIgcmVzID0ge1xuICAgICAgICByYW5rOiBmdW5jdGlvbiByYW5rKG5vZGUpIHtcbiAgICAgICAgICBub2RlID0gY3kuY29sbGVjdGlvbihub2RlKVswXTtcbiAgICAgICAgICByZXR1cm4gZWlnZW52ZWN0b3Jbbm9kZXMuaW5kZXhPZihub2RlKV07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0gLy8gcGFnZVJhbmtcblxuICB9OyAvLyBlbGVzZm5cblxuICB2YXIgZGVmYXVsdHMkZiA9IGRlZmF1bHRzJGcoe1xuICAgIHJvb3Q6IG51bGwsXG4gICAgd2VpZ2h0OiBmdW5jdGlvbiB3ZWlnaHQoZWRnZSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSxcbiAgICBkaXJlY3RlZDogZmFsc2UsXG4gICAgYWxwaGE6IDBcbiAgfSk7XG4gIHZhciBlbGVzZm4kbiA9IHtcbiAgICBkZWdyZWVDZW50cmFsaXR5Tm9ybWFsaXplZDogZnVuY3Rpb24gZGVncmVlQ2VudHJhbGl0eU5vcm1hbGl6ZWQob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IGRlZmF1bHRzJGYob3B0aW9ucyk7XG4gICAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gICAgICB2YXIgbnVtTm9kZXMgPSBub2Rlcy5sZW5ndGg7XG5cbiAgICAgIGlmICghb3B0aW9ucy5kaXJlY3RlZCkge1xuICAgICAgICB2YXIgZGVncmVlcyA9IHt9O1xuICAgICAgICB2YXIgbWF4RGVncmVlID0gMDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKyspIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldOyAvLyBhZGQgY3VycmVudCBub2RlIHRvIHRoZSBjdXJyZW50IG9wdGlvbnMgb2JqZWN0IGFuZCBjYWxsIGRlZ3JlZUNlbnRyYWxpdHlcblxuICAgICAgICAgIG9wdGlvbnMucm9vdCA9IG5vZGU7XG4gICAgICAgICAgdmFyIGN1cnJEZWdyZWUgPSB0aGlzLmRlZ3JlZUNlbnRyYWxpdHkob3B0aW9ucyk7XG5cbiAgICAgICAgICBpZiAobWF4RGVncmVlIDwgY3VyckRlZ3JlZS5kZWdyZWUpIHtcbiAgICAgICAgICAgIG1heERlZ3JlZSA9IGN1cnJEZWdyZWUuZGVncmVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRlZ3JlZXNbbm9kZS5pZCgpXSA9IGN1cnJEZWdyZWUuZGVncmVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkZWdyZWU6IGZ1bmN0aW9uIGRlZ3JlZShub2RlKSB7XG4gICAgICAgICAgICBpZiAobWF4RGVncmVlID09PSAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc3RyaW5nKG5vZGUpKSB7XG4gICAgICAgICAgICAgIC8vIGZyb20gaXMgYSBzZWxlY3RvciBzdHJpbmdcbiAgICAgICAgICAgICAgbm9kZSA9IGN5LmZpbHRlcihub2RlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGRlZ3JlZXNbbm9kZS5pZCgpXSAvIG1heERlZ3JlZTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaW5kZWdyZWVzID0ge307XG4gICAgICAgIHZhciBvdXRkZWdyZWVzID0ge307XG4gICAgICAgIHZhciBtYXhJbmRlZ3JlZSA9IDA7XG4gICAgICAgIHZhciBtYXhPdXRkZWdyZWUgPSAwO1xuXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBudW1Ob2RlczsgX2krKykge1xuICAgICAgICAgIHZhciBfbm9kZSA9IG5vZGVzW19pXTtcblxuICAgICAgICAgIHZhciBpZCA9IF9ub2RlLmlkKCk7IC8vIGFkZCBjdXJyZW50IG5vZGUgdG8gdGhlIGN1cnJlbnQgb3B0aW9ucyBvYmplY3QgYW5kIGNhbGwgZGVncmVlQ2VudHJhbGl0eVxuXG5cbiAgICAgICAgICBvcHRpb25zLnJvb3QgPSBfbm9kZTtcblxuICAgICAgICAgIHZhciBfY3VyckRlZ3JlZSA9IHRoaXMuZGVncmVlQ2VudHJhbGl0eShvcHRpb25zKTtcblxuICAgICAgICAgIGlmIChtYXhJbmRlZ3JlZSA8IF9jdXJyRGVncmVlLmluZGVncmVlKSBtYXhJbmRlZ3JlZSA9IF9jdXJyRGVncmVlLmluZGVncmVlO1xuICAgICAgICAgIGlmIChtYXhPdXRkZWdyZWUgPCBfY3VyckRlZ3JlZS5vdXRkZWdyZWUpIG1heE91dGRlZ3JlZSA9IF9jdXJyRGVncmVlLm91dGRlZ3JlZTtcbiAgICAgICAgICBpbmRlZ3JlZXNbaWRdID0gX2N1cnJEZWdyZWUuaW5kZWdyZWU7XG4gICAgICAgICAgb3V0ZGVncmVlc1tpZF0gPSBfY3VyckRlZ3JlZS5vdXRkZWdyZWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGluZGVncmVlOiBmdW5jdGlvbiBpbmRlZ3JlZShub2RlKSB7XG4gICAgICAgICAgICBpZiAobWF4SW5kZWdyZWUgPT0gMCkge1xuICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHN0cmluZyhub2RlKSkge1xuICAgICAgICAgICAgICAvLyBmcm9tIGlzIGEgc2VsZWN0b3Igc3RyaW5nXG4gICAgICAgICAgICAgIG5vZGUgPSBjeS5maWx0ZXIobm9kZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBpbmRlZ3JlZXNbbm9kZS5pZCgpXSAvIG1heEluZGVncmVlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgb3V0ZGVncmVlOiBmdW5jdGlvbiBvdXRkZWdyZWUobm9kZSkge1xuICAgICAgICAgICAgaWYgKG1heE91dGRlZ3JlZSA9PT0gMCkge1xuICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHN0cmluZyhub2RlKSkge1xuICAgICAgICAgICAgICAvLyBmcm9tIGlzIGEgc2VsZWN0b3Igc3RyaW5nXG4gICAgICAgICAgICAgIG5vZGUgPSBjeS5maWx0ZXIobm9kZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvdXRkZWdyZWVzW25vZGUuaWQoKV0gLyBtYXhPdXRkZWdyZWU7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gZGVncmVlQ2VudHJhbGl0eU5vcm1hbGl6ZWRcbiAgICAvLyBJbXBsZW1lbnRlZCBmcm9tIHRoZSBhbGdvcml0aG0gaW4gT3BzYWhsJ3MgcGFwZXJcbiAgICAvLyBcIk5vZGUgY2VudHJhbGl0eSBpbiB3ZWlnaHRlZCBuZXR3b3JrczogR2VuZXJhbGl6aW5nIGRlZ3JlZSBhbmQgc2hvcnRlc3QgcGF0aHNcIlxuICAgIC8vIGNoZWNrIHRoZSBoZWFkaW5nIDIgXCJEZWdyZWVcIlxuICAgIGRlZ3JlZUNlbnRyYWxpdHk6IGZ1bmN0aW9uIGRlZ3JlZUNlbnRyYWxpdHkob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IGRlZmF1bHRzJGYob3B0aW9ucyk7XG4gICAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgICB2YXIgY2FsbGluZ0VsZXMgPSB0aGlzO1xuICAgICAgdmFyIF9vcHRpb25zID0gb3B0aW9ucyxcbiAgICAgICAgICByb290ID0gX29wdGlvbnMucm9vdCxcbiAgICAgICAgICB3ZWlnaHQgPSBfb3B0aW9ucy53ZWlnaHQsXG4gICAgICAgICAgZGlyZWN0ZWQgPSBfb3B0aW9ucy5kaXJlY3RlZCxcbiAgICAgICAgICBhbHBoYSA9IF9vcHRpb25zLmFscGhhO1xuICAgICAgcm9vdCA9IGN5LmNvbGxlY3Rpb24ocm9vdClbMF07XG5cbiAgICAgIGlmICghZGlyZWN0ZWQpIHtcbiAgICAgICAgdmFyIGNvbm5FZGdlcyA9IHJvb3QuY29ubmVjdGVkRWRnZXMoKS5pbnRlcnNlY3Rpb24oY2FsbGluZ0VsZXMpO1xuICAgICAgICB2YXIgayA9IGNvbm5FZGdlcy5sZW5ndGg7XG4gICAgICAgIHZhciBzID0gMDsgLy8gTm93LCBzdW0gZWRnZSB3ZWlnaHRzXG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb25uRWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBzICs9IHdlaWdodChjb25uRWRnZXNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkZWdyZWU6IE1hdGgucG93KGssIDEgLSBhbHBoYSkgKiBNYXRoLnBvdyhzLCBhbHBoYSlcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBlZGdlcyA9IHJvb3QuY29ubmVjdGVkRWRnZXMoKTtcbiAgICAgICAgdmFyIGluY29taW5nID0gZWRnZXMuZmlsdGVyKGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgICAgcmV0dXJuIGVkZ2UudGFyZ2V0KCkuc2FtZShyb290KSAmJiBjYWxsaW5nRWxlcy5oYXMoZWRnZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgb3V0Z29pbmcgPSBlZGdlcy5maWx0ZXIoZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgICAgICByZXR1cm4gZWRnZS5zb3VyY2UoKS5zYW1lKHJvb3QpICYmIGNhbGxpbmdFbGVzLmhhcyhlZGdlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBrX2luID0gaW5jb21pbmcubGVuZ3RoO1xuICAgICAgICB2YXIga19vdXQgPSBvdXRnb2luZy5sZW5ndGg7XG4gICAgICAgIHZhciBzX2luID0gMDtcbiAgICAgICAgdmFyIHNfb3V0ID0gMDsgLy8gTm93LCBzdW0gaW5jb21pbmcgZWRnZSB3ZWlnaHRzXG5cbiAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgaW5jb21pbmcubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICAgIHNfaW4gKz0gd2VpZ2h0KGluY29taW5nW19pMl0pO1xuICAgICAgICB9IC8vIE5vdywgc3VtIG91dGdvaW5nIGVkZ2Ugd2VpZ2h0c1xuXG5cbiAgICAgICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgb3V0Z29pbmcubGVuZ3RoOyBfaTMrKykge1xuICAgICAgICAgIHNfb3V0ICs9IHdlaWdodChvdXRnb2luZ1tfaTNdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaW5kZWdyZWU6IE1hdGgucG93KGtfaW4sIDEgLSBhbHBoYSkgKiBNYXRoLnBvdyhzX2luLCBhbHBoYSksXG4gICAgICAgICAgb3V0ZGVncmVlOiBNYXRoLnBvdyhrX291dCwgMSAtIGFscGhhKSAqIE1hdGgucG93KHNfb3V0LCBhbHBoYSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IC8vIGRlZ3JlZUNlbnRyYWxpdHlcblxuICB9OyAvLyBlbGVzZm5cbiAgLy8gbmljZSwgc2hvcnQgbWF0aGVtYXRpY2FsIGFsaWFzXG5cbiAgZWxlc2ZuJG4uZGMgPSBlbGVzZm4kbi5kZWdyZWVDZW50cmFsaXR5O1xuICBlbGVzZm4kbi5kY24gPSBlbGVzZm4kbi5kZWdyZWVDZW50cmFsaXR5Tm9ybWFsaXNlZCA9IGVsZXNmbiRuLmRlZ3JlZUNlbnRyYWxpdHlOb3JtYWxpemVkO1xuXG4gIHZhciBkZWZhdWx0cyRlID0gZGVmYXVsdHMkZyh7XG4gICAgaGFybW9uaWM6IHRydWUsXG4gICAgd2VpZ2h0OiBmdW5jdGlvbiB3ZWlnaHQoKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9LFxuICAgIGRpcmVjdGVkOiBmYWxzZSxcbiAgICByb290OiBudWxsXG4gIH0pO1xuICB2YXIgZWxlc2ZuJG0gPSB7XG4gICAgY2xvc2VuZXNzQ2VudHJhbGl0eU5vcm1hbGl6ZWQ6IGZ1bmN0aW9uIGNsb3NlbmVzc0NlbnRyYWxpdHlOb3JtYWxpemVkKG9wdGlvbnMpIHtcbiAgICAgIHZhciBfZGVmYXVsdHMgPSBkZWZhdWx0cyRlKG9wdGlvbnMpLFxuICAgICAgICAgIGhhcm1vbmljID0gX2RlZmF1bHRzLmhhcm1vbmljLFxuICAgICAgICAgIHdlaWdodCA9IF9kZWZhdWx0cy53ZWlnaHQsXG4gICAgICAgICAgZGlyZWN0ZWQgPSBfZGVmYXVsdHMuZGlyZWN0ZWQ7XG5cbiAgICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICAgIHZhciBjbG9zZW5lc3NlcyA9IHt9O1xuICAgICAgdmFyIG1heENsb3NlbmVzcyA9IDA7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gICAgICB2YXIgZncgPSB0aGlzLmZsb3lkV2Fyc2hhbGwoe1xuICAgICAgICB3ZWlnaHQ6IHdlaWdodCxcbiAgICAgICAgZGlyZWN0ZWQ6IGRpcmVjdGVkXG4gICAgICB9KTsgLy8gQ29tcHV0ZSBjbG9zZW5lc3MgZm9yIGV2ZXJ5IG5vZGUgYW5kIGZpbmQgdGhlIG1heGltdW0gY2xvc2VuZXNzXG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGN1cnJDbG9zZW5lc3MgPSAwO1xuICAgICAgICB2YXIgbm9kZV9pID0gbm9kZXNbaV07XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBub2Rlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGlmIChpICE9PSBqKSB7XG4gICAgICAgICAgICB2YXIgZCA9IGZ3LmRpc3RhbmNlKG5vZGVfaSwgbm9kZXNbal0pO1xuXG4gICAgICAgICAgICBpZiAoaGFybW9uaWMpIHtcbiAgICAgICAgICAgICAgY3VyckNsb3NlbmVzcyArPSAxIC8gZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGN1cnJDbG9zZW5lc3MgKz0gZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWhhcm1vbmljKSB7XG4gICAgICAgICAgY3VyckNsb3NlbmVzcyA9IDEgLyBjdXJyQ2xvc2VuZXNzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1heENsb3NlbmVzcyA8IGN1cnJDbG9zZW5lc3MpIHtcbiAgICAgICAgICBtYXhDbG9zZW5lc3MgPSBjdXJyQ2xvc2VuZXNzO1xuICAgICAgICB9XG5cbiAgICAgICAgY2xvc2VuZXNzZXNbbm9kZV9pLmlkKCldID0gY3VyckNsb3NlbmVzcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2xvc2VuZXNzOiBmdW5jdGlvbiBjbG9zZW5lc3Mobm9kZSkge1xuICAgICAgICAgIGlmIChtYXhDbG9zZW5lc3MgPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHN0cmluZyhub2RlKSkge1xuICAgICAgICAgICAgLy8gZnJvbSBpcyBhIHNlbGVjdG9yIHN0cmluZ1xuICAgICAgICAgICAgbm9kZSA9IGN5LmZpbHRlcihub2RlKVswXS5pZCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBmcm9tIGlzIGEgbm9kZVxuICAgICAgICAgICAgbm9kZSA9IG5vZGUuaWQoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY2xvc2VuZXNzZXNbbm9kZV0gLyBtYXhDbG9zZW5lc3M7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSxcbiAgICAvLyBJbXBsZW1lbnRlZCBmcm9tIHBzZXVkb2NvZGUgZnJvbSB3aWtpcGVkaWFcbiAgICBjbG9zZW5lc3NDZW50cmFsaXR5OiBmdW5jdGlvbiBjbG9zZW5lc3NDZW50cmFsaXR5KG9wdGlvbnMpIHtcbiAgICAgIHZhciBfZGVmYXVsdHMyID0gZGVmYXVsdHMkZShvcHRpb25zKSxcbiAgICAgICAgICByb290ID0gX2RlZmF1bHRzMi5yb290LFxuICAgICAgICAgIHdlaWdodCA9IF9kZWZhdWx0czIud2VpZ2h0LFxuICAgICAgICAgIGRpcmVjdGVkID0gX2RlZmF1bHRzMi5kaXJlY3RlZCxcbiAgICAgICAgICBoYXJtb25pYyA9IF9kZWZhdWx0czIuaGFybW9uaWM7XG5cbiAgICAgIHJvb3QgPSB0aGlzLmZpbHRlcihyb290KVswXTsgLy8gd2UgbmVlZCBkaXN0YW5jZSBmcm9tIHRoaXMgbm9kZSB0byBldmVyeSBvdGhlciBub2RlXG5cbiAgICAgIHZhciBkaWprc3RyYSA9IHRoaXMuZGlqa3N0cmEoe1xuICAgICAgICByb290OiByb290LFxuICAgICAgICB3ZWlnaHQ6IHdlaWdodCxcbiAgICAgICAgZGlyZWN0ZWQ6IGRpcmVjdGVkXG4gICAgICB9KTtcbiAgICAgIHZhciB0b3RhbERpc3RhbmNlID0gMDtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbiA9IG5vZGVzW2ldO1xuXG4gICAgICAgIGlmICghbi5zYW1lKHJvb3QpKSB7XG4gICAgICAgICAgdmFyIGQgPSBkaWprc3RyYS5kaXN0YW5jZVRvKG4pO1xuXG4gICAgICAgICAgaWYgKGhhcm1vbmljKSB7XG4gICAgICAgICAgICB0b3RhbERpc3RhbmNlICs9IDEgLyBkO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b3RhbERpc3RhbmNlICs9IGQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoYXJtb25pYyA/IHRvdGFsRGlzdGFuY2UgOiAxIC8gdG90YWxEaXN0YW5jZTtcbiAgICB9IC8vIGNsb3NlbmVzc0NlbnRyYWxpdHlcblxuICB9OyAvLyBlbGVzZm5cbiAgLy8gbmljZSwgc2hvcnQgbWF0aGVtYXRpY2FsIGFsaWFzXG5cbiAgZWxlc2ZuJG0uY2MgPSBlbGVzZm4kbS5jbG9zZW5lc3NDZW50cmFsaXR5O1xuICBlbGVzZm4kbS5jY24gPSBlbGVzZm4kbS5jbG9zZW5lc3NDZW50cmFsaXR5Tm9ybWFsaXNlZCA9IGVsZXNmbiRtLmNsb3NlbmVzc0NlbnRyYWxpdHlOb3JtYWxpemVkO1xuXG4gIHZhciBkZWZhdWx0cyRkID0gZGVmYXVsdHMkZyh7XG4gICAgd2VpZ2h0OiBudWxsLFxuICAgIGRpcmVjdGVkOiBmYWxzZVxuICB9KTtcbiAgdmFyIGVsZXNmbiRsID0ge1xuICAgIC8vIEltcGxlbWVudGVkIGZyb20gdGhlIGFsZ29yaXRobSBpbiB0aGUgcGFwZXIgXCJPbiBWYXJpYW50cyBvZiBTaG9ydGVzdC1QYXRoIEJldHdlZW5uZXNzIENlbnRyYWxpdHkgYW5kIHRoZWlyIEdlbmVyaWMgQ29tcHV0YXRpb25cIiBieSBVbHJpayBCcmFuZGVzXG4gICAgYmV0d2Vlbm5lc3NDZW50cmFsaXR5OiBmdW5jdGlvbiBiZXR3ZWVubmVzc0NlbnRyYWxpdHkob3B0aW9ucykge1xuICAgICAgdmFyIF9kZWZhdWx0cyA9IGRlZmF1bHRzJGQob3B0aW9ucyksXG4gICAgICAgICAgZGlyZWN0ZWQgPSBfZGVmYXVsdHMuZGlyZWN0ZWQsXG4gICAgICAgICAgd2VpZ2h0ID0gX2RlZmF1bHRzLndlaWdodDtcblxuICAgICAgdmFyIHdlaWdodGVkID0gd2VpZ2h0ICE9IG51bGw7XG4gICAgICB2YXIgY3kgPSB0aGlzLmN5KCk7IC8vIHN0YXJ0aW5nXG5cbiAgICAgIHZhciBWID0gdGhpcy5ub2RlcygpO1xuICAgICAgdmFyIEEgPSB7fTtcbiAgICAgIHZhciBfQyA9IHt9O1xuICAgICAgdmFyIG1heCA9IDA7XG4gICAgICB2YXIgQyA9IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoa2V5LCB2YWwpIHtcbiAgICAgICAgICBfQ1trZXldID0gdmFsO1xuXG4gICAgICAgICAgaWYgKHZhbCA+IG1heCkge1xuICAgICAgICAgICAgbWF4ID0gdmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIF9DW2tleV07XG4gICAgICAgIH1cbiAgICAgIH07IC8vIEEgY29udGFpbnMgdGhlIG5laWdoYm9yaG9vZHMgb2YgZXZlcnkgbm9kZVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IFYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHYgPSBWW2ldO1xuICAgICAgICB2YXIgdmlkID0gdi5pZCgpO1xuXG4gICAgICAgIGlmIChkaXJlY3RlZCkge1xuICAgICAgICAgIEFbdmlkXSA9IHYub3V0Z29lcnMoKS5ub2RlcygpOyAvLyBnZXQgb3V0Z29lcnMgb2YgZXZlcnkgbm9kZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIEFbdmlkXSA9IHYub3Blbk5laWdoYm9yaG9vZCgpLm5vZGVzKCk7IC8vIGdldCBuZWlnaGJvcnMgb2YgZXZlcnkgbm9kZVxuICAgICAgICB9XG5cbiAgICAgICAgQy5zZXQodmlkLCAwKTtcbiAgICAgIH1cblxuICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3Aocykge1xuICAgICAgICB2YXIgc2lkID0gVltzXS5pZCgpO1xuICAgICAgICB2YXIgUyA9IFtdOyAvLyBzdGFja1xuXG4gICAgICAgIHZhciBQID0ge307XG4gICAgICAgIHZhciBnID0ge307XG4gICAgICAgIHZhciBkID0ge307XG4gICAgICAgIHZhciBRID0gbmV3IGhlYXAoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICByZXR1cm4gZFthXSAtIGRbYl07XG4gICAgICAgIH0pOyAvLyBxdWV1ZVxuICAgICAgICAvLyBpbml0IGRpY3Rpb25hcmllc1xuXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBWLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgIHZhciBfdmlkID0gVltfaV0uaWQoKTtcblxuICAgICAgICAgIFBbX3ZpZF0gPSBbXTtcbiAgICAgICAgICBnW192aWRdID0gMDtcbiAgICAgICAgICBkW192aWRdID0gSW5maW5pdHk7XG4gICAgICAgIH1cblxuICAgICAgICBnW3NpZF0gPSAxOyAvLyBzaWdtYVxuXG4gICAgICAgIGRbc2lkXSA9IDA7IC8vIGRpc3RhbmNlIHRvIHNcblxuICAgICAgICBRLnB1c2goc2lkKTtcblxuICAgICAgICB3aGlsZSAoIVEuZW1wdHkoKSkge1xuICAgICAgICAgIHZhciBfdiA9IFEucG9wKCk7XG5cbiAgICAgICAgICBTLnB1c2goX3YpO1xuXG4gICAgICAgICAgaWYgKHdlaWdodGVkKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IEFbX3ZdLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIHZhciB3ID0gQVtfdl1bal07XG4gICAgICAgICAgICAgIHZhciB2RWxlID0gY3kuZ2V0RWxlbWVudEJ5SWQoX3YpO1xuICAgICAgICAgICAgICB2YXIgZWRnZSA9IHZvaWQgMDtcblxuICAgICAgICAgICAgICBpZiAodkVsZS5lZGdlc1RvKHcpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBlZGdlID0gdkVsZS5lZGdlc1RvKHcpWzBdO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVkZ2UgPSB3LmVkZ2VzVG8odkVsZSlbMF07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgZWRnZVdlaWdodCA9IHdlaWdodChlZGdlKTtcbiAgICAgICAgICAgICAgdyA9IHcuaWQoKTtcblxuICAgICAgICAgICAgICBpZiAoZFt3XSA+IGRbX3ZdICsgZWRnZVdlaWdodCkge1xuICAgICAgICAgICAgICAgIGRbd10gPSBkW192XSArIGVkZ2VXZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoUS5ub2Rlcy5pbmRleE9mKHcpIDwgMCkge1xuICAgICAgICAgICAgICAgICAgLy9pZiB3IGlzIG5vdCBpbiBRXG4gICAgICAgICAgICAgICAgICBRLnB1c2godyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBwb3NpdGlvbiBpZiB3IGlzIGluIFFcbiAgICAgICAgICAgICAgICAgIFEudXBkYXRlSXRlbSh3KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBnW3ddID0gMDtcbiAgICAgICAgICAgICAgICBQW3ddID0gW107XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoZFt3XSA9PSBkW192XSArIGVkZ2VXZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBnW3ddID0gZ1t3XSArIGdbX3ZdO1xuICAgICAgICAgICAgICAgIFBbd10ucHVzaChfdik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgX2ogPSAwOyBfaiA8IEFbX3ZdLmxlbmd0aDsgX2orKykge1xuICAgICAgICAgICAgICB2YXIgX3cgPSBBW192XVtfal0uaWQoKTtcblxuICAgICAgICAgICAgICBpZiAoZFtfd10gPT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgICAgICBRLnB1c2goX3cpO1xuICAgICAgICAgICAgICAgIGRbX3ddID0gZFtfdl0gKyAxO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGRbX3ddID09IGRbX3ZdICsgMSkge1xuICAgICAgICAgICAgICAgIGdbX3ddID0gZ1tfd10gKyBnW192XTtcblxuICAgICAgICAgICAgICAgIFBbX3ddLnB1c2goX3YpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGUgPSB7fTtcblxuICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBWLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgICBlW1ZbX2kyXS5pZCgpXSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAoUy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIF93MiA9IFMucG9wKCk7XG5cbiAgICAgICAgICBmb3IgKHZhciBfajIgPSAwOyBfajIgPCBQW193Ml0ubGVuZ3RoOyBfajIrKykge1xuICAgICAgICAgICAgdmFyIF92MiA9IFBbX3cyXVtfajJdO1xuICAgICAgICAgICAgZVtfdjJdID0gZVtfdjJdICsgZ1tfdjJdIC8gZ1tfdzJdICogKDEgKyBlW193Ml0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChfdzIgIT0gVltzXS5pZCgpKSB7XG4gICAgICAgICAgICBDLnNldChfdzIsIEMuZ2V0KF93MikgKyBlW193Ml0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgcyA9IDA7IHMgPCBWLmxlbmd0aDsgcysrKSB7XG4gICAgICAgIF9sb29wKHMpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmV0ID0ge1xuICAgICAgICBiZXR3ZWVubmVzczogZnVuY3Rpb24gYmV0d2Vlbm5lc3Mobm9kZSkge1xuICAgICAgICAgIHZhciBpZCA9IGN5LmNvbGxlY3Rpb24obm9kZSkuaWQoKTtcbiAgICAgICAgICByZXR1cm4gQy5nZXQoaWQpO1xuICAgICAgICB9LFxuICAgICAgICBiZXR3ZWVubmVzc05vcm1hbGl6ZWQ6IGZ1bmN0aW9uIGJldHdlZW5uZXNzTm9ybWFsaXplZChub2RlKSB7XG4gICAgICAgICAgaWYgKG1heCA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgaWQgPSBjeS5jb2xsZWN0aW9uKG5vZGUpLmlkKCk7XG4gICAgICAgICAgcmV0dXJuIEMuZ2V0KGlkKSAvIG1heDtcbiAgICAgICAgfVxuICAgICAgfTsgLy8gYWxpYXNcblxuICAgICAgcmV0LmJldHdlZW5uZXNzTm9ybWFsaXNlZCA9IHJldC5iZXR3ZWVubmVzc05vcm1hbGl6ZWQ7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0gLy8gYmV0d2Vlbm5lc3NDZW50cmFsaXR5XG5cbiAgfTsgLy8gZWxlc2ZuXG4gIC8vIG5pY2UsIHNob3J0IG1hdGhlbWF0aWNhbCBhbGlhc1xuXG4gIGVsZXNmbiRsLmJjID0gZWxlc2ZuJGwuYmV0d2Vlbm5lc3NDZW50cmFsaXR5O1xuXG4gIC8vIEltcGxlbWVudGVkIGJ5IFpvZSBYaSBAem9leGkgZm9yIEdTT0MgMjAxNlxuICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXG4gIHZhciBkZWZhdWx0cyRjID0gZGVmYXVsdHMkZyh7XG4gICAgZXhwYW5kRmFjdG9yOiAyLFxuICAgIC8vIGFmZmVjdHMgdGltZSBvZiBjb21wdXRhdGlvbiBhbmQgY2x1c3RlciBncmFudWxhcml0eSB0byBzb21lIGV4dGVudDogTSAqIE1cbiAgICBpbmZsYXRlRmFjdG9yOiAyLFxuICAgIC8vIGFmZmVjdHMgY2x1c3RlciBncmFudWxhcml0eSAodGhlIGdyZWF0ZXIgdGhlIHZhbHVlLCB0aGUgbW9yZSBjbHVzdGVycyk6IE0oaSxqKSAvIEUoailcbiAgICBtdWx0RmFjdG9yOiAxLFxuICAgIC8vIG9wdGlvbmFsIHNlbGYgbG9vcHMgZm9yIGVhY2ggbm9kZS4gVXNlIGEgbmV1dHJhbCB2YWx1ZSB0byBpbXByb3ZlIGNsdXN0ZXIgY29tcHV0YXRpb25zLlxuICAgIG1heEl0ZXJhdGlvbnM6IDIwLFxuICAgIC8vIG1heGltdW0gbnVtYmVyIG9mIGl0ZXJhdGlvbnMgb2YgdGhlIE1DTCBhbGdvcml0aG0gaW4gYSBzaW5nbGUgcnVuXG4gICAgYXR0cmlidXRlczogWy8vIGF0dHJpYnV0ZXMvZmVhdHVyZXMgdXNlZCB0byBncm91cCBub2RlcywgaWUuIHNpbWlsYXJpdHkgdmFsdWVzIGJldHdlZW4gbm9kZXNcbiAgICBmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfV1cbiAgfSk7XG4gIC8qIGVzbGludC1lbmFibGUgKi9cblxuICB2YXIgc2V0T3B0aW9ucyQzID0gZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRzJGMob3B0aW9ucyk7XG4gIH07XG4gIC8qIGVzbGludC1lbmFibGUgKi9cblxuXG4gIHZhciBnZXRTaW1pbGFyaXR5JDEgPSBmdW5jdGlvbiBnZXRTaW1pbGFyaXR5KGVkZ2UsIGF0dHJpYnV0ZXMpIHtcbiAgICB2YXIgdG90YWwgPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0b3RhbCArPSBhdHRyaWJ1dGVzW2ldKGVkZ2UpO1xuICAgIH1cblxuICAgIHJldHVybiB0b3RhbDtcbiAgfTtcblxuICB2YXIgYWRkTG9vcHMgPSBmdW5jdGlvbiBhZGRMb29wcyhNLCBuLCB2YWwpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgTVtpICogbiArIGldID0gdmFsO1xuICAgIH1cbiAgfTtcblxuICB2YXIgbm9ybWFsaXplID0gZnVuY3Rpb24gbm9ybWFsaXplKE0sIG4pIHtcbiAgICB2YXIgc3VtO1xuXG4gICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgbjsgY29sKyspIHtcbiAgICAgIHN1bSA9IDA7XG5cbiAgICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IG47IHJvdysrKSB7XG4gICAgICAgIHN1bSArPSBNW3JvdyAqIG4gKyBjb2xdO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBfcm93ID0gMDsgX3JvdyA8IG47IF9yb3crKykge1xuICAgICAgICBNW19yb3cgKiBuICsgY29sXSA9IE1bX3JvdyAqIG4gKyBjb2xdIC8gc3VtO1xuICAgICAgfVxuICAgIH1cbiAgfTsgLy8gVE9ETzogYmxvY2tlZCBtYXRyaXggbXVsdGlwbGljYXRpb24/XG5cblxuICB2YXIgbW11bHQgPSBmdW5jdGlvbiBtbXVsdChBLCBCLCBuKSB7XG4gICAgdmFyIEMgPSBuZXcgQXJyYXkobiAqIG4pO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbjsgaisrKSB7XG4gICAgICAgIENbaSAqIG4gKyBqXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbjsgaysrKSB7XG4gICAgICAgIGZvciAodmFyIF9qID0gMDsgX2ogPCBuOyBfaisrKSB7XG4gICAgICAgICAgQ1tpICogbiArIF9qXSArPSBBW2kgKiBuICsga10gKiBCW2sgKiBuICsgX2pdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIEM7XG4gIH07XG5cbiAgdmFyIGV4cGFuZCA9IGZ1bmN0aW9uIGV4cGFuZChNLCBuLCBleHBhbmRGYWN0b3JcbiAgLyoqIHBvd2VyICoqL1xuICApIHtcbiAgICB2YXIgX00gPSBNLnNsaWNlKDApO1xuXG4gICAgZm9yICh2YXIgcCA9IDE7IHAgPCBleHBhbmRGYWN0b3I7IHArKykge1xuICAgICAgTSA9IG1tdWx0KE0sIF9NLCBuKTtcbiAgICB9XG5cbiAgICByZXR1cm4gTTtcbiAgfTtcblxuICB2YXIgaW5mbGF0ZSA9IGZ1bmN0aW9uIGluZmxhdGUoTSwgbiwgaW5mbGF0ZUZhY3RvclxuICAvKiogciAqKi9cbiAgKSB7XG4gICAgdmFyIF9NID0gbmV3IEFycmF5KG4gKiBuKTsgLy8gTShpLGopIF4gaW5mbGF0ZVBvd2VyXG5cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbiAqIG47IGkrKykge1xuICAgICAgX01baV0gPSBNYXRoLnBvdyhNW2ldLCBpbmZsYXRlRmFjdG9yKTtcbiAgICB9XG5cbiAgICBub3JtYWxpemUoX00sIG4pO1xuICAgIHJldHVybiBfTTtcbiAgfTtcblxuICB2YXIgaGFzQ29udmVyZ2VkID0gZnVuY3Rpb24gaGFzQ29udmVyZ2VkKE0sIF9NLCBuMiwgcm91bmRGYWN0b3IpIHtcbiAgICAvLyBDaGVjayB0aGF0IGJvdGggbWF0cmljZXMgaGF2ZSB0aGUgc2FtZSBlbGVtZW50cyAoaSxqKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjI7IGkrKykge1xuICAgICAgdmFyIHYxID0gTWF0aC5yb3VuZChNW2ldICogTWF0aC5wb3coMTAsIHJvdW5kRmFjdG9yKSkgLyBNYXRoLnBvdygxMCwgcm91bmRGYWN0b3IpOyAvLyB0cnVuY2F0ZSB0byAncm91bmRGYWN0b3InIGRlY2ltYWwgcGxhY2VzXG5cbiAgICAgIHZhciB2MiA9IE1hdGgucm91bmQoX01baV0gKiBNYXRoLnBvdygxMCwgcm91bmRGYWN0b3IpKSAvIE1hdGgucG93KDEwLCByb3VuZEZhY3Rvcik7XG5cbiAgICAgIGlmICh2MSAhPT0gdjIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIHZhciBhc3NpZ24kMiA9IGZ1bmN0aW9uIGFzc2lnbihNLCBuLCBub2RlcywgY3kpIHtcbiAgICB2YXIgY2x1c3RlcnMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICB2YXIgY2x1c3RlciA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG47IGorKykge1xuICAgICAgICAvLyBSb3ctd2lzZSBhdHRyYWN0b3JzIGFuZCBlbGVtZW50cyB0aGF0IHRoZXkgYXR0cmFjdCBiZWxvbmcgaW4gc2FtZSBjbHVzdGVyXG4gICAgICAgIGlmIChNYXRoLnJvdW5kKE1baSAqIG4gKyBqXSAqIDEwMDApIC8gMTAwMCA+IDApIHtcbiAgICAgICAgICBjbHVzdGVyLnB1c2gobm9kZXNbal0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjbHVzdGVyLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICBjbHVzdGVycy5wdXNoKGN5LmNvbGxlY3Rpb24oY2x1c3RlcikpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjbHVzdGVycztcbiAgfTtcblxuICB2YXIgaXNEdXBsaWNhdGUgPSBmdW5jdGlvbiBpc0R1cGxpY2F0ZShjMSwgYzIpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGMxLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIWMyW2ldIHx8IGMxW2ldLmlkKCkgIT09IGMyW2ldLmlkKCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIHZhciByZW1vdmVEdXBsaWNhdGVzID0gZnVuY3Rpb24gcmVtb3ZlRHVwbGljYXRlcyhjbHVzdGVycykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2x1c3RlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2x1c3RlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKGkgIT0gaiAmJiBpc0R1cGxpY2F0ZShjbHVzdGVyc1tpXSwgY2x1c3RlcnNbal0pKSB7XG4gICAgICAgICAgY2x1c3RlcnMuc3BsaWNlKGosIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsdXN0ZXJzO1xuICB9O1xuXG4gIHZhciBtYXJrb3ZDbHVzdGVyaW5nID0gZnVuY3Rpb24gbWFya292Q2x1c3RlcmluZyhvcHRpb25zKSB7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuICAgIHZhciBlZGdlcyA9IHRoaXMuZWRnZXMoKTtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7IC8vIFNldCBwYXJhbWV0ZXJzIG9mIGFsZ29yaXRobTpcblxuICAgIHZhciBvcHRzID0gc2V0T3B0aW9ucyQzKG9wdGlvbnMpOyAvLyBNYXAgZWFjaCBub2RlIHRvIGl0cyBwb3NpdGlvbiBpbiBub2RlIGFycmF5XG5cbiAgICB2YXIgaWQycG9zaXRpb24gPSB7fTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlkMnBvc2l0aW9uW25vZGVzW2ldLmlkKCldID0gaTtcbiAgICB9IC8vIEdlbmVyYXRlIHN0b2NoYXN0aWMgbWF0cml4IE0gZnJvbSBpbnB1dCBncmFwaCBHIChzaG91bGQgYmUgc3ltbWV0cmljL3VuZGlyZWN0ZWQpXG5cblxuICAgIHZhciBuID0gbm9kZXMubGVuZ3RoLFxuICAgICAgICBuMiA9IG4gKiBuO1xuXG4gICAgdmFyIE0gPSBuZXcgQXJyYXkobjIpLFxuICAgICAgICBfTTtcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBuMjsgX2krKykge1xuICAgICAgTVtfaV0gPSAwO1xuICAgIH1cblxuICAgIGZvciAodmFyIGUgPSAwOyBlIDwgZWRnZXMubGVuZ3RoOyBlKyspIHtcbiAgICAgIHZhciBlZGdlID0gZWRnZXNbZV07XG4gICAgICB2YXIgX2kyID0gaWQycG9zaXRpb25bZWRnZS5zb3VyY2UoKS5pZCgpXTtcbiAgICAgIHZhciBqID0gaWQycG9zaXRpb25bZWRnZS50YXJnZXQoKS5pZCgpXTtcbiAgICAgIHZhciBzaW0gPSBnZXRTaW1pbGFyaXR5JDEoZWRnZSwgb3B0cy5hdHRyaWJ1dGVzKTtcbiAgICAgIE1bX2kyICogbiArIGpdICs9IHNpbTsgLy8gRyBzaG91bGQgYmUgc3ltbWV0cmljIGFuZCB1bmRpcmVjdGVkXG5cbiAgICAgIE1baiAqIG4gKyBfaTJdICs9IHNpbTtcbiAgICB9IC8vIEJlZ2luIE1hcmtvdiBjbHVzdGVyIGFsZ29yaXRobVxuICAgIC8vIFN0ZXAgMTogQWRkIHNlbGYgbG9vcHMgdG8gZWFjaCBub2RlLCBpZS4gYWRkIG11bHRGYWN0b3IgdG8gbWF0cml4IGRpYWdvbmFsXG5cblxuICAgIGFkZExvb3BzKE0sIG4sIG9wdHMubXVsdEZhY3Rvcik7IC8vIFN0ZXAgMjogTSA9IG5vcm1hbGl6ZSggTSApO1xuXG4gICAgbm9ybWFsaXplKE0sIG4pO1xuICAgIHZhciBpc1N0aWxsTW92aW5nID0gdHJ1ZTtcbiAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG5cbiAgICB3aGlsZSAoaXNTdGlsbE1vdmluZyAmJiBpdGVyYXRpb25zIDwgb3B0cy5tYXhJdGVyYXRpb25zKSB7XG4gICAgICBpc1N0aWxsTW92aW5nID0gZmFsc2U7IC8vIFN0ZXAgMzpcblxuICAgICAgX00gPSBleHBhbmQoTSwgbiwgb3B0cy5leHBhbmRGYWN0b3IpOyAvLyBTdGVwIDQ6XG5cbiAgICAgIE0gPSBpbmZsYXRlKF9NLCBuLCBvcHRzLmluZmxhdGVGYWN0b3IpOyAvLyBTdGVwIDU6IGNoZWNrIHRvIHNlZSBpZiB+c3RlYWR5IHN0YXRlIGhhcyBiZWVuIHJlYWNoZWRcblxuICAgICAgaWYgKCFoYXNDb252ZXJnZWQoTSwgX00sIG4yLCA0KSkge1xuICAgICAgICBpc1N0aWxsTW92aW5nID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaXRlcmF0aW9ucysrO1xuICAgIH0gLy8gQnVpbGQgY2x1c3RlcnMgZnJvbSBtYXRyaXhcblxuXG4gICAgdmFyIGNsdXN0ZXJzID0gYXNzaWduJDIoTSwgbiwgbm9kZXMsIGN5KTsgLy8gUmVtb3ZlIGR1cGxpY2F0ZSBjbHVzdGVycyBkdWUgdG8gc3ltbWV0cnkgb2YgZ3JhcGggYW5kIE0gbWF0cml4XG5cbiAgICBjbHVzdGVycyA9IHJlbW92ZUR1cGxpY2F0ZXMoY2x1c3RlcnMpO1xuICAgIHJldHVybiBjbHVzdGVycztcbiAgfTtcblxuICB2YXIgbWFya292Q2x1c3RlcmluZyQxID0ge1xuICAgIG1hcmtvdkNsdXN0ZXJpbmc6IG1hcmtvdkNsdXN0ZXJpbmcsXG4gICAgbWNsOiBtYXJrb3ZDbHVzdGVyaW5nXG4gIH07XG5cbiAgLy8gQ29tbW9uIGRpc3RhbmNlIG1ldHJpY3MgZm9yIGNsdXN0ZXJpbmcgYWxnb3JpdGhtc1xuXG4gIHZhciBpZGVudGl0eSA9IGZ1bmN0aW9uIGlkZW50aXR5KHgpIHtcbiAgICByZXR1cm4geDtcbiAgfTtcblxuICB2YXIgYWJzRGlmZiA9IGZ1bmN0aW9uIGFic0RpZmYocCwgcSkge1xuICAgIHJldHVybiBNYXRoLmFicyhxIC0gcCk7XG4gIH07XG5cbiAgdmFyIGFkZEFic0RpZmYgPSBmdW5jdGlvbiBhZGRBYnNEaWZmKHRvdGFsLCBwLCBxKSB7XG4gICAgcmV0dXJuIHRvdGFsICsgYWJzRGlmZihwLCBxKTtcbiAgfTtcblxuICB2YXIgYWRkU3F1YXJlZERpZmYgPSBmdW5jdGlvbiBhZGRTcXVhcmVkRGlmZih0b3RhbCwgcCwgcSkge1xuICAgIHJldHVybiB0b3RhbCArIE1hdGgucG93KHEgLSBwLCAyKTtcbiAgfTtcblxuICB2YXIgc3FydCA9IGZ1bmN0aW9uIHNxcnQoeCkge1xuICAgIHJldHVybiBNYXRoLnNxcnQoeCk7XG4gIH07XG5cbiAgdmFyIG1heEFic0RpZmYgPSBmdW5jdGlvbiBtYXhBYnNEaWZmKGN1cnJlbnRNYXgsIHAsIHEpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoY3VycmVudE1heCwgYWJzRGlmZihwLCBxKSk7XG4gIH07XG5cbiAgdmFyIGdldERpc3RhbmNlID0gZnVuY3Rpb24gZ2V0RGlzdGFuY2UobGVuZ3RoLCBnZXRQLCBnZXRRLCBpbml0LCB2aXNpdCkge1xuICAgIHZhciBwb3N0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiBpZGVudGl0eTtcbiAgICB2YXIgcmV0ID0gaW5pdDtcbiAgICB2YXIgcCwgcTtcblxuICAgIGZvciAodmFyIGRpbSA9IDA7IGRpbSA8IGxlbmd0aDsgZGltKyspIHtcbiAgICAgIHAgPSBnZXRQKGRpbSk7XG4gICAgICBxID0gZ2V0UShkaW0pO1xuICAgICAgcmV0ID0gdmlzaXQocmV0LCBwLCBxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcG9zdChyZXQpO1xuICB9O1xuXG4gIHZhciBkaXN0YW5jZXMgPSB7XG4gICAgZXVjbGlkZWFuOiBmdW5jdGlvbiBldWNsaWRlYW4obGVuZ3RoLCBnZXRQLCBnZXRRKSB7XG4gICAgICBpZiAobGVuZ3RoID49IDIpIHtcbiAgICAgICAgcmV0dXJuIGdldERpc3RhbmNlKGxlbmd0aCwgZ2V0UCwgZ2V0USwgMCwgYWRkU3F1YXJlZERpZmYsIHNxcnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZm9yIHNpbmdsZSBhdHRyIGNhc2UsIG1vcmUgZWZmaWNpZW50IHRvIGF2b2lkIHNxcnRcbiAgICAgICAgcmV0dXJuIGdldERpc3RhbmNlKGxlbmd0aCwgZ2V0UCwgZ2V0USwgMCwgYWRkQWJzRGlmZik7XG4gICAgICB9XG4gICAgfSxcbiAgICBzcXVhcmVkRXVjbGlkZWFuOiBmdW5jdGlvbiBzcXVhcmVkRXVjbGlkZWFuKGxlbmd0aCwgZ2V0UCwgZ2V0USkge1xuICAgICAgcmV0dXJuIGdldERpc3RhbmNlKGxlbmd0aCwgZ2V0UCwgZ2V0USwgMCwgYWRkU3F1YXJlZERpZmYpO1xuICAgIH0sXG4gICAgbWFuaGF0dGFuOiBmdW5jdGlvbiBtYW5oYXR0YW4obGVuZ3RoLCBnZXRQLCBnZXRRKSB7XG4gICAgICByZXR1cm4gZ2V0RGlzdGFuY2UobGVuZ3RoLCBnZXRQLCBnZXRRLCAwLCBhZGRBYnNEaWZmKTtcbiAgICB9LFxuICAgIG1heDogZnVuY3Rpb24gbWF4KGxlbmd0aCwgZ2V0UCwgZ2V0USkge1xuICAgICAgcmV0dXJuIGdldERpc3RhbmNlKGxlbmd0aCwgZ2V0UCwgZ2V0USwgLUluZmluaXR5LCBtYXhBYnNEaWZmKTtcbiAgICB9XG4gIH07IC8vIGluIGNhc2UgdGhlIHVzZXIgYWNjaWRlbnRhbGx5IGRvZXNuJ3QgdXNlIGNhbWVsIGNhc2VcblxuICBkaXN0YW5jZXNbJ3NxdWFyZWQtZXVjbGlkZWFuJ10gPSBkaXN0YW5jZXNbJ3NxdWFyZWRFdWNsaWRlYW4nXTtcbiAgZGlzdGFuY2VzWydzcXVhcmVkZXVjbGlkZWFuJ10gPSBkaXN0YW5jZXNbJ3NxdWFyZWRFdWNsaWRlYW4nXTtcbiAgZnVuY3Rpb24gY2x1c3RlcmluZ0Rpc3RhbmNlIChtZXRob2QsIGxlbmd0aCwgZ2V0UCwgZ2V0USwgbm9kZVAsIG5vZGVRKSB7XG4gICAgdmFyIGltcGw7XG5cbiAgICBpZiAoZm4kNihtZXRob2QpKSB7XG4gICAgICBpbXBsID0gbWV0aG9kO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbXBsID0gZGlzdGFuY2VzW21ldGhvZF0gfHwgZGlzdGFuY2VzLmV1Y2xpZGVhbjtcbiAgICB9XG5cbiAgICBpZiAobGVuZ3RoID09PSAwICYmIGZuJDYobWV0aG9kKSkge1xuICAgICAgcmV0dXJuIGltcGwobm9kZVAsIG5vZGVRKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGltcGwobGVuZ3RoLCBnZXRQLCBnZXRRLCBub2RlUCwgbm9kZVEpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBkZWZhdWx0cyRiID0gZGVmYXVsdHMkZyh7XG4gICAgazogMixcbiAgICBtOiAyLFxuICAgIHNlbnNpdGl2aXR5VGhyZXNob2xkOiAwLjAwMDEsXG4gICAgZGlzdGFuY2U6ICdldWNsaWRlYW4nLFxuICAgIG1heEl0ZXJhdGlvbnM6IDEwLFxuICAgIGF0dHJpYnV0ZXM6IFtdLFxuICAgIHRlc3RNb2RlOiBmYWxzZSxcbiAgICB0ZXN0Q2VudHJvaWRzOiBudWxsXG4gIH0pO1xuXG4gIHZhciBzZXRPcHRpb25zJDIgPSBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZGVmYXVsdHMkYihvcHRpb25zKTtcbiAgfTtcbiAgLyogZXNsaW50LWVuYWJsZSAqL1xuXG5cbiAgdmFyIGdldERpc3QgPSBmdW5jdGlvbiBnZXREaXN0KHR5cGUsIG5vZGUsIGNlbnRyb2lkLCBhdHRyaWJ1dGVzLCBtb2RlKSB7XG4gICAgdmFyIG5vTm9kZVAgPSBtb2RlICE9PSAna01lZG9pZHMnO1xuICAgIHZhciBnZXRQID0gbm9Ob2RlUCA/IGZ1bmN0aW9uIChpKSB7XG4gICAgICByZXR1cm4gY2VudHJvaWRbaV07XG4gICAgfSA6IGZ1bmN0aW9uIChpKSB7XG4gICAgICByZXR1cm4gYXR0cmlidXRlc1tpXShjZW50cm9pZCk7XG4gICAgfTtcblxuICAgIHZhciBnZXRRID0gZnVuY3Rpb24gZ2V0UShpKSB7XG4gICAgICByZXR1cm4gYXR0cmlidXRlc1tpXShub2RlKTtcbiAgICB9O1xuXG4gICAgdmFyIG5vZGVQID0gY2VudHJvaWQ7XG4gICAgdmFyIG5vZGVRID0gbm9kZTtcbiAgICByZXR1cm4gY2x1c3RlcmluZ0Rpc3RhbmNlKHR5cGUsIGF0dHJpYnV0ZXMubGVuZ3RoLCBnZXRQLCBnZXRRLCBub2RlUCwgbm9kZVEpO1xuICB9O1xuXG4gIHZhciByYW5kb21DZW50cm9pZHMgPSBmdW5jdGlvbiByYW5kb21DZW50cm9pZHMobm9kZXMsIGssIGF0dHJpYnV0ZXMpIHtcbiAgICB2YXIgbmRpbSA9IGF0dHJpYnV0ZXMubGVuZ3RoO1xuICAgIHZhciBtaW4gPSBuZXcgQXJyYXkobmRpbSk7XG4gICAgdmFyIG1heCA9IG5ldyBBcnJheShuZGltKTtcbiAgICB2YXIgY2VudHJvaWRzID0gbmV3IEFycmF5KGspO1xuICAgIHZhciBjZW50cm9pZCA9IG51bGw7IC8vIEZpbmQgbWluLCBtYXggdmFsdWVzIGZvciBlYWNoIGF0dHJpYnV0ZSBkaW1lbnNpb25cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmRpbTsgaSsrKSB7XG4gICAgICBtaW5baV0gPSBub2Rlcy5taW4oYXR0cmlidXRlc1tpXSkudmFsdWU7XG4gICAgICBtYXhbaV0gPSBub2Rlcy5tYXgoYXR0cmlidXRlc1tpXSkudmFsdWU7XG4gICAgfSAvLyBCdWlsZCBrIGNlbnRyb2lkcywgZWFjaCByZXByZXNlbnRlZCBhcyBhbiBuLWRpbSBmZWF0dXJlIHZlY3RvclxuXG5cbiAgICBmb3IgKHZhciBjID0gMDsgYyA8IGs7IGMrKykge1xuICAgICAgY2VudHJvaWQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG5kaW07IF9pKyspIHtcbiAgICAgICAgY2VudHJvaWRbX2ldID0gTWF0aC5yYW5kb20oKSAqIChtYXhbX2ldIC0gbWluW19pXSkgKyBtaW5bX2ldOyAvLyByYW5kb20gaW5pdGlhbCB2YWx1ZVxuICAgICAgfVxuXG4gICAgICBjZW50cm9pZHNbY10gPSBjZW50cm9pZDtcbiAgICB9XG5cbiAgICByZXR1cm4gY2VudHJvaWRzO1xuICB9O1xuXG4gIHZhciBjbGFzc2lmeSA9IGZ1bmN0aW9uIGNsYXNzaWZ5KG5vZGUsIGNlbnRyb2lkcywgZGlzdGFuY2UsIGF0dHJpYnV0ZXMsIHR5cGUpIHtcbiAgICB2YXIgbWluID0gSW5maW5pdHk7XG4gICAgdmFyIGluZGV4ID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2VudHJvaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGlzdCA9IGdldERpc3QoZGlzdGFuY2UsIG5vZGUsIGNlbnRyb2lkc1tpXSwgYXR0cmlidXRlcywgdHlwZSk7XG5cbiAgICAgIGlmIChkaXN0IDwgbWluKSB7XG4gICAgICAgIG1pbiA9IGRpc3Q7XG4gICAgICAgIGluZGV4ID0gaTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5kZXg7XG4gIH07XG5cbiAgdmFyIGJ1aWxkQ2x1c3RlciA9IGZ1bmN0aW9uIGJ1aWxkQ2x1c3RlcihjZW50cm9pZCwgbm9kZXMsIGFzc2lnbm1lbnQpIHtcbiAgICB2YXIgY2x1c3RlciA9IFtdO1xuICAgIHZhciBub2RlID0gbnVsbDtcblxuICAgIGZvciAodmFyIG4gPSAwOyBuIDwgbm9kZXMubGVuZ3RoOyBuKyspIHtcbiAgICAgIG5vZGUgPSBub2Rlc1tuXTtcblxuICAgICAgaWYgKGFzc2lnbm1lbnRbbm9kZS5pZCgpXSA9PT0gY2VudHJvaWQpIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIk5vZGUgXCIgKyBub2RlLmlkKCkgKyBcIiBpcyBhc3NvY2lhdGVkIHdpdGggbWVkb2lkICM6IFwiICsgbSk7XG4gICAgICAgIGNsdXN0ZXIucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2x1c3RlcjtcbiAgfTtcblxuICB2YXIgaGF2ZVZhbHVlc0NvbnZlcmdlZCA9IGZ1bmN0aW9uIGhhdmVWYWx1ZXNDb252ZXJnZWQodjEsIHYyLCBzZW5zaXRpdml0eVRocmVzaG9sZCkge1xuICAgIHJldHVybiBNYXRoLmFicyh2MiAtIHYxKSA8PSBzZW5zaXRpdml0eVRocmVzaG9sZDtcbiAgfTtcblxuICB2YXIgaGF2ZU1hdHJpY2VzQ29udmVyZ2VkID0gZnVuY3Rpb24gaGF2ZU1hdHJpY2VzQ29udmVyZ2VkKHYxLCB2Miwgc2Vuc2l0aXZpdHlUaHJlc2hvbGQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHYxLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHYxW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBkaWZmID0gTWF0aC5hYnModjFbaV1bal0gLSB2MltpXVtqXSk7XG5cbiAgICAgICAgaWYgKGRpZmYgPiBzZW5zaXRpdml0eVRocmVzaG9sZCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIHZhciBzZWVuQmVmb3JlID0gZnVuY3Rpb24gc2VlbkJlZm9yZShub2RlLCBtZWRvaWRzLCBuKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgIGlmIChub2RlID09PSBtZWRvaWRzW2ldKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgdmFyIHJhbmRvbU1lZG9pZHMgPSBmdW5jdGlvbiByYW5kb21NZWRvaWRzKG5vZGVzLCBrKSB7XG4gICAgdmFyIG1lZG9pZHMgPSBuZXcgQXJyYXkoayk7IC8vIEZvciBzbWFsbCBkYXRhIHNldHMsIHRoZSBwcm9iYWJpbGl0eSBvZiBtZWRvaWQgY29uZmxpY3QgaXMgZ3JlYXRlcixcbiAgICAvLyBzbyB3ZSBuZWVkIHRvIGNoZWNrIHRvIHNlZSBpZiB3ZSd2ZSBhbHJlYWR5IHNlZW4gb3IgY2hvc2UgdGhpcyBub2RlIGJlZm9yZS5cblxuICAgIGlmIChub2Rlcy5sZW5ndGggPCA1MCkge1xuICAgICAgLy8gUmFuZG9tbHkgc2VsZWN0IGsgbWVkb2lkcyBmcm9tIHRoZSBuIG5vZGVzXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGs7IGkrKykge1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG5vZGVzLmxlbmd0aCldOyAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGNob3NlbiB0aGlzIG5vZGUgdG8gYmUgYSBtZWRvaWQsIGRvbid0IGNob29zZSBpdCBhZ2FpbiAoZm9yIHNtYWxsIGRhdGEgc2V0cykuXG4gICAgICAgIC8vIEluc3RlYWQgY2hvb3NlIGEgZGlmZmVyZW50IHJhbmRvbSBub2RlLlxuXG4gICAgICAgIHdoaWxlIChzZWVuQmVmb3JlKG5vZGUsIG1lZG9pZHMsIGkpKSB7XG4gICAgICAgICAgbm9kZSA9IG5vZGVzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG5vZGVzLmxlbmd0aCldO1xuICAgICAgICB9XG5cbiAgICAgICAgbWVkb2lkc1tpXSA9IG5vZGU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlbGF0aXZlbHkgbGFyZ2UgZGF0YSBzZXQsIHNvIHByZXR0eSBzYWZlIHRvIG5vdCBjaGVjayBhbmQganVzdCBzZWxlY3QgcmFuZG9tIG5vZGVzXG4gICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBrOyBfaTIrKykge1xuICAgICAgICBtZWRvaWRzW19pMl0gPSBub2Rlc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBub2Rlcy5sZW5ndGgpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWVkb2lkcztcbiAgfTtcblxuICB2YXIgZmluZENvc3QgPSBmdW5jdGlvbiBmaW5kQ29zdChwb3RlbnRpYWxOZXdNZWRvaWQsIGNsdXN0ZXIsIGF0dHJpYnV0ZXMpIHtcbiAgICB2YXIgY29zdCA9IDA7XG5cbiAgICBmb3IgKHZhciBuID0gMDsgbiA8IGNsdXN0ZXIubGVuZ3RoOyBuKyspIHtcbiAgICAgIGNvc3QgKz0gZ2V0RGlzdCgnbWFuaGF0dGFuJywgY2x1c3RlcltuXSwgcG90ZW50aWFsTmV3TWVkb2lkLCBhdHRyaWJ1dGVzLCAna01lZG9pZHMnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29zdDtcbiAgfTtcblxuICB2YXIga01lYW5zID0gZnVuY3Rpb24ga01lYW5zKG9wdGlvbnMpIHtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuICAgIHZhciBub2RlID0gbnVsbDsgLy8gU2V0IHBhcmFtZXRlcnMgb2YgYWxnb3JpdGhtOiAjIG9mIGNsdXN0ZXJzLCBkaXN0YW5jZSBtZXRyaWMsIGV0Yy5cblxuICAgIHZhciBvcHRzID0gc2V0T3B0aW9ucyQyKG9wdGlvbnMpOyAvLyBCZWdpbiBrLW1lYW5zIGFsZ29yaXRobVxuXG4gICAgdmFyIGNsdXN0ZXJzID0gbmV3IEFycmF5KG9wdHMuayk7XG4gICAgdmFyIGFzc2lnbm1lbnQgPSB7fTtcbiAgICB2YXIgY2VudHJvaWRzOyAvLyBTdGVwIDE6IEluaXRpYWxpemUgY2VudHJvaWQgcG9zaXRpb25zXG5cbiAgICBpZiAob3B0cy50ZXN0TW9kZSkge1xuICAgICAgaWYgKHR5cGVvZiBvcHRzLnRlc3RDZW50cm9pZHMgPT09ICdudW1iZXInKSB7XG4gICAgICAgIC8vIFRPRE86IGltcGxlbWVudCBhIHNlZWRlZCByYW5kb20gbnVtYmVyIGdlbmVyYXRvci5cbiAgICAgICAgb3B0cy50ZXN0Q2VudHJvaWRzO1xuICAgICAgICBjZW50cm9pZHMgPSByYW5kb21DZW50cm9pZHMobm9kZXMsIG9wdHMuaywgb3B0cy5hdHRyaWJ1dGVzKTtcbiAgICAgIH0gZWxzZSBpZiAoX3R5cGVvZihvcHRzLnRlc3RDZW50cm9pZHMpID09PSAnb2JqZWN0Jykge1xuICAgICAgICBjZW50cm9pZHMgPSBvcHRzLnRlc3RDZW50cm9pZHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjZW50cm9pZHMgPSByYW5kb21DZW50cm9pZHMobm9kZXMsIG9wdHMuaywgb3B0cy5hdHRyaWJ1dGVzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY2VudHJvaWRzID0gcmFuZG9tQ2VudHJvaWRzKG5vZGVzLCBvcHRzLmssIG9wdHMuYXR0cmlidXRlcyk7XG4gICAgfVxuXG4gICAgdmFyIGlzU3RpbGxNb3ZpbmcgPSB0cnVlO1xuICAgIHZhciBpdGVyYXRpb25zID0gMDtcblxuICAgIHdoaWxlIChpc1N0aWxsTW92aW5nICYmIGl0ZXJhdGlvbnMgPCBvcHRzLm1heEl0ZXJhdGlvbnMpIHtcbiAgICAgIC8vIFN0ZXAgMjogQXNzaWduIG5vZGVzIHRvIHRoZSBuZWFyZXN0IGNlbnRyb2lkXG4gICAgICBmb3IgKHZhciBuID0gMDsgbiA8IG5vZGVzLmxlbmd0aDsgbisrKSB7XG4gICAgICAgIG5vZGUgPSBub2Rlc1tuXTsgLy8gRGV0ZXJtaW5lIHdoaWNoIGNsdXN0ZXIgdGhpcyBub2RlIGJlbG9uZ3MgdG86IG5vZGUgaWQgPT4gY2x1c3RlciAjXG5cbiAgICAgICAgYXNzaWdubWVudFtub2RlLmlkKCldID0gY2xhc3NpZnkobm9kZSwgY2VudHJvaWRzLCBvcHRzLmRpc3RhbmNlLCBvcHRzLmF0dHJpYnV0ZXMsICdrTWVhbnMnKTtcbiAgICAgIH0gLy8gU3RlcCAzOiBGb3IgZWFjaCBvZiB0aGUgayBjbHVzdGVycywgdXBkYXRlIGl0cyBjZW50cm9pZFxuXG5cbiAgICAgIGlzU3RpbGxNb3ZpbmcgPSBmYWxzZTtcblxuICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBvcHRzLms7IGMrKykge1xuICAgICAgICAvLyBHZXQgYWxsIG5vZGVzIHRoYXQgYmVsb25nIHRvIHRoaXMgY2x1c3RlclxuICAgICAgICB2YXIgY2x1c3RlciA9IGJ1aWxkQ2x1c3RlcihjLCBub2RlcywgYXNzaWdubWVudCk7XG5cbiAgICAgICAgaWYgKGNsdXN0ZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgLy8gSWYgY2x1c3RlciBpcyBlbXB0eSwgYnJlYWsgb3V0IGVhcmx5ICYgbW92ZSB0byBuZXh0IGNsdXN0ZXJcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBVcGRhdGUgY2VudHJvaWRzIGJ5IGNhbGN1bGF0aW5nIGF2ZyBvZiBhbGwgbm9kZXMgd2l0aGluIHRoZSBjbHVzdGVyLlxuXG5cbiAgICAgICAgdmFyIG5kaW0gPSBvcHRzLmF0dHJpYnV0ZXMubGVuZ3RoO1xuICAgICAgICB2YXIgY2VudHJvaWQgPSBjZW50cm9pZHNbY107IC8vIFsgZGltXzEsIGRpbV8yLCBkaW1fMywgLi4uICwgZGltX24gXVxuXG4gICAgICAgIHZhciBuZXdDZW50cm9pZCA9IG5ldyBBcnJheShuZGltKTtcbiAgICAgICAgdmFyIHN1bSA9IG5ldyBBcnJheShuZGltKTtcblxuICAgICAgICBmb3IgKHZhciBkID0gMDsgZCA8IG5kaW07IGQrKykge1xuICAgICAgICAgIHN1bVtkXSA9IDAuMDtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2x1c3Rlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbm9kZSA9IGNsdXN0ZXJbaV07XG4gICAgICAgICAgICBzdW1bZF0gKz0gb3B0cy5hdHRyaWJ1dGVzW2RdKG5vZGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG5ld0NlbnRyb2lkW2RdID0gc3VtW2RdIC8gY2x1c3Rlci5sZW5ndGg7IC8vIENoZWNrIHRvIHNlZSBpZiBhbGdvcml0aG0gaGFzIGNvbnZlcmdlZCwgaS5lLiB3aGVuIGNlbnRyb2lkcyBubyBsb25nZXIgY2hhbmdlXG5cbiAgICAgICAgICBpZiAoIWhhdmVWYWx1ZXNDb252ZXJnZWQobmV3Q2VudHJvaWRbZF0sIGNlbnRyb2lkW2RdLCBvcHRzLnNlbnNpdGl2aXR5VGhyZXNob2xkKSkge1xuICAgICAgICAgICAgaXNTdGlsbE1vdmluZyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY2VudHJvaWRzW2NdID0gbmV3Q2VudHJvaWQ7XG4gICAgICAgIGNsdXN0ZXJzW2NdID0gY3kuY29sbGVjdGlvbihjbHVzdGVyKTtcbiAgICAgIH1cblxuICAgICAgaXRlcmF0aW9ucysrO1xuICAgIH1cblxuICAgIHJldHVybiBjbHVzdGVycztcbiAgfTtcblxuICB2YXIga01lZG9pZHMgPSBmdW5jdGlvbiBrTWVkb2lkcyhvcHRpb25zKSB7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgICB2YXIgbm9kZSA9IG51bGw7XG4gICAgdmFyIG9wdHMgPSBzZXRPcHRpb25zJDIob3B0aW9ucyk7IC8vIEJlZ2luIGstbWVkb2lkcyBhbGdvcml0aG1cblxuICAgIHZhciBjbHVzdGVycyA9IG5ldyBBcnJheShvcHRzLmspO1xuICAgIHZhciBtZWRvaWRzO1xuICAgIHZhciBhc3NpZ25tZW50ID0ge307XG4gICAgdmFyIGN1ckNvc3Q7XG4gICAgdmFyIG1pbkNvc3RzID0gbmV3IEFycmF5KG9wdHMuayk7IC8vIG1pbmltdW0gY29zdCBjb25maWd1cmF0aW9uIGZvciBlYWNoIGNsdXN0ZXJcbiAgICAvLyBTdGVwIDE6IEluaXRpYWxpemUgayBtZWRvaWRzXG5cbiAgICBpZiAob3B0cy50ZXN0TW9kZSkge1xuICAgICAgaWYgKHR5cGVvZiBvcHRzLnRlc3RDZW50cm9pZHMgPT09ICdudW1iZXInKSA7IGVsc2UgaWYgKF90eXBlb2Yob3B0cy50ZXN0Q2VudHJvaWRzKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgbWVkb2lkcyA9IG9wdHMudGVzdENlbnRyb2lkcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1lZG9pZHMgPSByYW5kb21NZWRvaWRzKG5vZGVzLCBvcHRzLmspO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtZWRvaWRzID0gcmFuZG9tTWVkb2lkcyhub2Rlcywgb3B0cy5rKTtcbiAgICB9XG5cbiAgICB2YXIgaXNTdGlsbE1vdmluZyA9IHRydWU7XG4gICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuXG4gICAgd2hpbGUgKGlzU3RpbGxNb3ZpbmcgJiYgaXRlcmF0aW9ucyA8IG9wdHMubWF4SXRlcmF0aW9ucykge1xuICAgICAgLy8gU3RlcCAyOiBBc3NpZ24gbm9kZXMgdG8gdGhlIG5lYXJlc3QgbWVkb2lkXG4gICAgICBmb3IgKHZhciBuID0gMDsgbiA8IG5vZGVzLmxlbmd0aDsgbisrKSB7XG4gICAgICAgIG5vZGUgPSBub2Rlc1tuXTsgLy8gRGV0ZXJtaW5lIHdoaWNoIGNsdXN0ZXIgdGhpcyBub2RlIGJlbG9uZ3MgdG86IG5vZGUgaWQgPT4gY2x1c3RlciAjXG5cbiAgICAgICAgYXNzaWdubWVudFtub2RlLmlkKCldID0gY2xhc3NpZnkobm9kZSwgbWVkb2lkcywgb3B0cy5kaXN0YW5jZSwgb3B0cy5hdHRyaWJ1dGVzLCAna01lZG9pZHMnKTtcbiAgICAgIH1cblxuICAgICAgaXNTdGlsbE1vdmluZyA9IGZhbHNlOyAvLyBTdGVwIDM6IEZvciBlYWNoIG1lZG9pZCBtLCBhbmQgZm9yIGVhY2ggbm9kZSBhc3NvY2lhdGVkIHdpdGggbWVkaW9kIG0sXG4gICAgICAvLyBzZWxlY3QgdGhlIG5vZGUgd2l0aCB0aGUgbG93ZXN0IGNvbmZpZ3VyYXRpb24gY29zdCBhcyBuZXcgbWVkb2lkLlxuXG4gICAgICBmb3IgKHZhciBtID0gMDsgbSA8IG1lZG9pZHMubGVuZ3RoOyBtKyspIHtcbiAgICAgICAgLy8gR2V0IGFsbCBub2RlcyB0aGF0IGJlbG9uZyB0byB0aGlzIG1lZG9pZFxuICAgICAgICB2YXIgY2x1c3RlciA9IGJ1aWxkQ2x1c3RlcihtLCBub2RlcywgYXNzaWdubWVudCk7XG5cbiAgICAgICAgaWYgKGNsdXN0ZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgLy8gSWYgY2x1c3RlciBpcyBlbXB0eSwgYnJlYWsgb3V0IGVhcmx5ICYgbW92ZSB0byBuZXh0IGNsdXN0ZXJcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1pbkNvc3RzW21dID0gZmluZENvc3QobWVkb2lkc1ttXSwgY2x1c3Rlciwgb3B0cy5hdHRyaWJ1dGVzKTsgLy8gb3JpZ2luYWwgY29zdFxuICAgICAgICAvLyBTZWxlY3QgZGlmZmVyZW50IG1lZG9pZCBpZiBpdHMgY29uZmlndXJhdGlvbiBoYXMgdGhlIGxvd2VzdCBjb3N0XG5cbiAgICAgICAgZm9yICh2YXIgX24gPSAwOyBfbiA8IGNsdXN0ZXIubGVuZ3RoOyBfbisrKSB7XG4gICAgICAgICAgY3VyQ29zdCA9IGZpbmRDb3N0KGNsdXN0ZXJbX25dLCBjbHVzdGVyLCBvcHRzLmF0dHJpYnV0ZXMpO1xuXG4gICAgICAgICAgaWYgKGN1ckNvc3QgPCBtaW5Db3N0c1ttXSkge1xuICAgICAgICAgICAgbWluQ29zdHNbbV0gPSBjdXJDb3N0O1xuICAgICAgICAgICAgbWVkb2lkc1ttXSA9IGNsdXN0ZXJbX25dO1xuICAgICAgICAgICAgaXNTdGlsbE1vdmluZyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY2x1c3RlcnNbbV0gPSBjeS5jb2xsZWN0aW9uKGNsdXN0ZXIpO1xuICAgICAgfVxuXG4gICAgICBpdGVyYXRpb25zKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsdXN0ZXJzO1xuICB9O1xuXG4gIHZhciB1cGRhdGVDZW50cm9pZHMgPSBmdW5jdGlvbiB1cGRhdGVDZW50cm9pZHMoY2VudHJvaWRzLCBub2RlcywgVSwgd2VpZ2h0LCBvcHRzKSB7XG4gICAgdmFyIG51bWVyYXRvciwgZGVub21pbmF0b3I7XG5cbiAgICBmb3IgKHZhciBuID0gMDsgbiA8IG5vZGVzLmxlbmd0aDsgbisrKSB7XG4gICAgICBmb3IgKHZhciBjID0gMDsgYyA8IGNlbnRyb2lkcy5sZW5ndGg7IGMrKykge1xuICAgICAgICB3ZWlnaHRbbl1bY10gPSBNYXRoLnBvdyhVW25dW2NdLCBvcHRzLm0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIF9jID0gMDsgX2MgPCBjZW50cm9pZHMubGVuZ3RoOyBfYysrKSB7XG4gICAgICBmb3IgKHZhciBkaW0gPSAwOyBkaW0gPCBvcHRzLmF0dHJpYnV0ZXMubGVuZ3RoOyBkaW0rKykge1xuICAgICAgICBudW1lcmF0b3IgPSAwO1xuICAgICAgICBkZW5vbWluYXRvciA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgX24yID0gMDsgX24yIDwgbm9kZXMubGVuZ3RoOyBfbjIrKykge1xuICAgICAgICAgIG51bWVyYXRvciArPSB3ZWlnaHRbX24yXVtfY10gKiBvcHRzLmF0dHJpYnV0ZXNbZGltXShub2Rlc1tfbjJdKTtcbiAgICAgICAgICBkZW5vbWluYXRvciArPSB3ZWlnaHRbX24yXVtfY107XG4gICAgICAgIH1cblxuICAgICAgICBjZW50cm9pZHNbX2NdW2RpbV0gPSBudW1lcmF0b3IgLyBkZW5vbWluYXRvcjtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIHVwZGF0ZU1lbWJlcnNoaXAgPSBmdW5jdGlvbiB1cGRhdGVNZW1iZXJzaGlwKFUsIF9VLCBjZW50cm9pZHMsIG5vZGVzLCBvcHRzKSB7XG4gICAgLy8gU2F2ZSBwcmV2aW91cyBzdGVwXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBVLmxlbmd0aDsgaSsrKSB7XG4gICAgICBfVVtpXSA9IFVbaV0uc2xpY2UoKTtcbiAgICB9XG5cbiAgICB2YXIgc3VtLCBudW1lcmF0b3IsIGRlbm9taW5hdG9yO1xuICAgIHZhciBwb3cgPSAyIC8gKG9wdHMubSAtIDEpO1xuXG4gICAgZm9yICh2YXIgYyA9IDA7IGMgPCBjZW50cm9pZHMubGVuZ3RoOyBjKyspIHtcbiAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgbm9kZXMubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgc3VtID0gMDtcblxuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGNlbnRyb2lkcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgIC8vIGFnYWluc3QgYWxsIG90aGVyIGNlbnRyb2lkc1xuICAgICAgICAgIG51bWVyYXRvciA9IGdldERpc3Qob3B0cy5kaXN0YW5jZSwgbm9kZXNbbl0sIGNlbnRyb2lkc1tjXSwgb3B0cy5hdHRyaWJ1dGVzLCAnY21lYW5zJyk7XG4gICAgICAgICAgZGVub21pbmF0b3IgPSBnZXREaXN0KG9wdHMuZGlzdGFuY2UsIG5vZGVzW25dLCBjZW50cm9pZHNba10sIG9wdHMuYXR0cmlidXRlcywgJ2NtZWFucycpO1xuICAgICAgICAgIHN1bSArPSBNYXRoLnBvdyhudW1lcmF0b3IgLyBkZW5vbWluYXRvciwgcG93KTtcbiAgICAgICAgfVxuXG4gICAgICAgIFVbbl1bY10gPSAxIC8gc3VtO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgYXNzaWduJDEgPSBmdW5jdGlvbiBhc3NpZ24obm9kZXMsIFUsIG9wdHMsIGN5KSB7XG4gICAgdmFyIGNsdXN0ZXJzID0gbmV3IEFycmF5KG9wdHMuayk7XG5cbiAgICBmb3IgKHZhciBjID0gMDsgYyA8IGNsdXN0ZXJzLmxlbmd0aDsgYysrKSB7XG4gICAgICBjbHVzdGVyc1tjXSA9IFtdO1xuICAgIH1cblxuICAgIHZhciBtYXg7XG4gICAgdmFyIGluZGV4O1xuXG4gICAgZm9yICh2YXIgbiA9IDA7IG4gPCBVLmxlbmd0aDsgbisrKSB7XG4gICAgICAvLyBmb3IgZWFjaCBub2RlIChVIGlzIE4geCBDIG1hdHJpeClcbiAgICAgIG1heCA9IC1JbmZpbml0eTtcbiAgICAgIGluZGV4ID0gLTE7IC8vIERldGVybWluZSB3aGljaCBjbHVzdGVyIHRoZSBub2RlIGlzIG1vc3QgbGlrZWx5IHRvIGJlbG9uZyBpblxuXG4gICAgICBmb3IgKHZhciBfYzIgPSAwOyBfYzIgPCBVWzBdLmxlbmd0aDsgX2MyKyspIHtcbiAgICAgICAgaWYgKFVbbl1bX2MyXSA+IG1heCkge1xuICAgICAgICAgIG1heCA9IFVbbl1bX2MyXTtcbiAgICAgICAgICBpbmRleCA9IF9jMjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjbHVzdGVyc1tpbmRleF0ucHVzaChub2Rlc1tuXSk7XG4gICAgfSAvLyBUdXJuIGV2ZXJ5IGFycmF5IGludG8gYSBjb2xsZWN0aW9uIG9mIG5vZGVzXG5cblxuICAgIGZvciAodmFyIF9jMyA9IDA7IF9jMyA8IGNsdXN0ZXJzLmxlbmd0aDsgX2MzKyspIHtcbiAgICAgIGNsdXN0ZXJzW19jM10gPSBjeS5jb2xsZWN0aW9uKGNsdXN0ZXJzW19jM10pO1xuICAgIH1cblxuICAgIHJldHVybiBjbHVzdGVycztcbiAgfTtcblxuICB2YXIgZnV6enlDTWVhbnMgPSBmdW5jdGlvbiBmdXp6eUNNZWFucyhvcHRpb25zKSB7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgICB2YXIgb3B0cyA9IHNldE9wdGlvbnMkMihvcHRpb25zKTsgLy8gQmVnaW4gZnV6enkgYy1tZWFucyBhbGdvcml0aG1cblxuICAgIHZhciBjbHVzdGVycztcbiAgICB2YXIgY2VudHJvaWRzO1xuICAgIHZhciBVO1xuXG4gICAgdmFyIF9VO1xuXG4gICAgdmFyIHdlaWdodDsgLy8gU3RlcCAxOiBJbml0aWFsaXplIGxldGlhYmxlcy5cblxuICAgIF9VID0gbmV3IEFycmF5KG5vZGVzLmxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBOIHggQyBtYXRyaXhcbiAgICAgIF9VW2ldID0gbmV3IEFycmF5KG9wdHMuayk7XG4gICAgfVxuXG4gICAgVSA9IG5ldyBBcnJheShub2Rlcy5sZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgbm9kZXMubGVuZ3RoOyBfaTMrKykge1xuICAgICAgLy8gTiB4IEMgbWF0cml4XG4gICAgICBVW19pM10gPSBuZXcgQXJyYXkob3B0cy5rKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBub2Rlcy5sZW5ndGg7IF9pNCsrKSB7XG4gICAgICB2YXIgdG90YWwgPSAwO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG9wdHMuazsgaisrKSB7XG4gICAgICAgIFVbX2k0XVtqXSA9IE1hdGgucmFuZG9tKCk7XG4gICAgICAgIHRvdGFsICs9IFVbX2k0XVtqXTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX2ogPSAwOyBfaiA8IG9wdHMuazsgX2orKykge1xuICAgICAgICBVW19pNF1bX2pdID0gVVtfaTRdW19qXSAvIHRvdGFsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNlbnRyb2lkcyA9IG5ldyBBcnJheShvcHRzLmspO1xuXG4gICAgZm9yICh2YXIgX2k1ID0gMDsgX2k1IDwgb3B0cy5rOyBfaTUrKykge1xuICAgICAgY2VudHJvaWRzW19pNV0gPSBuZXcgQXJyYXkob3B0cy5hdHRyaWJ1dGVzLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgd2VpZ2h0ID0gbmV3IEFycmF5KG5vZGVzLmxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBfaTYgPSAwOyBfaTYgPCBub2Rlcy5sZW5ndGg7IF9pNisrKSB7XG4gICAgICAvLyBOIHggQyBtYXRyaXhcbiAgICAgIHdlaWdodFtfaTZdID0gbmV3IEFycmF5KG9wdHMuayk7XG4gICAgfSAvLyBlbmQgaW5pdCBGQ01cblxuXG4gICAgdmFyIGlzU3RpbGxNb3ZpbmcgPSB0cnVlO1xuICAgIHZhciBpdGVyYXRpb25zID0gMDtcblxuICAgIHdoaWxlIChpc1N0aWxsTW92aW5nICYmIGl0ZXJhdGlvbnMgPCBvcHRzLm1heEl0ZXJhdGlvbnMpIHtcbiAgICAgIGlzU3RpbGxNb3ZpbmcgPSBmYWxzZTsgLy8gU3RlcCAyOiBDYWxjdWxhdGUgdGhlIGNlbnRyb2lkcyBmb3IgZWFjaCBzdGVwLlxuXG4gICAgICB1cGRhdGVDZW50cm9pZHMoY2VudHJvaWRzLCBub2RlcywgVSwgd2VpZ2h0LCBvcHRzKTsgLy8gU3RlcCAzOiBVcGRhdGUgdGhlIHBhcnRpdGlvbiBtYXRyaXggVS5cblxuICAgICAgdXBkYXRlTWVtYmVyc2hpcChVLCBfVSwgY2VudHJvaWRzLCBub2Rlcywgb3B0cyk7IC8vIFN0ZXAgNDogQ2hlY2sgZm9yIGNvbnZlcmdlbmNlLlxuXG4gICAgICBpZiAoIWhhdmVNYXRyaWNlc0NvbnZlcmdlZChVLCBfVSwgb3B0cy5zZW5zaXRpdml0eVRocmVzaG9sZCkpIHtcbiAgICAgICAgaXNTdGlsbE1vdmluZyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGl0ZXJhdGlvbnMrKztcbiAgICB9IC8vIEFzc2lnbiBub2RlcyB0byBjbHVzdGVycyB3aXRoIGhpZ2hlc3QgcHJvYmFiaWxpdHkuXG5cblxuICAgIGNsdXN0ZXJzID0gYXNzaWduJDEobm9kZXMsIFUsIG9wdHMsIGN5KTtcbiAgICByZXR1cm4ge1xuICAgICAgY2x1c3RlcnM6IGNsdXN0ZXJzLFxuICAgICAgZGVncmVlT2ZNZW1iZXJzaGlwOiBVXG4gICAgfTtcbiAgfTtcblxuICB2YXIga0NsdXN0ZXJpbmcgPSB7XG4gICAga01lYW5zOiBrTWVhbnMsXG4gICAga01lZG9pZHM6IGtNZWRvaWRzLFxuICAgIGZ1enp5Q01lYW5zOiBmdXp6eUNNZWFucyxcbiAgICBmY206IGZ1enp5Q01lYW5zXG4gIH07XG5cbiAgLy8gSW1wbGVtZW50ZWQgYnkgWm9lIFhpIEB6b2V4aSBmb3IgR1NPQyAyMDE2XG4gIHZhciBkZWZhdWx0cyRhID0gZGVmYXVsdHMkZyh7XG4gICAgZGlzdGFuY2U6ICdldWNsaWRlYW4nLFxuICAgIC8vIGRpc3RhbmNlIG1ldHJpYyB0byBjb21wYXJlIG5vZGVzXG4gICAgbGlua2FnZTogJ21pbicsXG4gICAgLy8gbGlua2FnZSBjcml0ZXJpb24gOiBob3cgdG8gZGV0ZXJtaW5lIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIGNsdXN0ZXJzIG9mIG5vZGVzXG4gICAgbW9kZTogJ3RocmVzaG9sZCcsXG4gICAgLy8gbW9kZTondGhyZXNob2xkJyA9PiBjbHVzdGVycyBtdXN0IGJlIHRocmVzaG9sZCBkaXN0YW5jZSBhcGFydFxuICAgIHRocmVzaG9sZDogSW5maW5pdHksXG4gICAgLy8gdGhlIGRpc3RhbmNlIHRocmVzaG9sZFxuICAgIC8vIG1vZGU6J2RlbmRyb2dyYW0nID0+IHRoZSBub2RlcyBhcmUgb3JnYW5pc2VkIGFzIGxlYXZlcyBpbiBhIHRyZWUgKHNpYmxpbmdzIGFyZSBjbG9zZSksIG1lcmdpbmcgbWFrZXMgY2x1c3RlcnNcbiAgICBhZGREZW5kcm9ncmFtOiBmYWxzZSxcbiAgICAvLyB3aGV0aGVyIHRvIGFkZCB0aGUgZGVuZHJvZ3JhbSB0byB0aGUgZ3JhcGggZm9yIHZpelxuICAgIGRlbmRyb2dyYW1EZXB0aDogMCxcbiAgICAvLyBkZXB0aCBhdCB3aGljaCBkZW5kcm9ncmFtIGJyYW5jaGVzIGFyZSBtZXJnZWQgaW50byB0aGUgcmV0dXJuZWQgY2x1c3RlcnNcbiAgICBhdHRyaWJ1dGVzOiBbXSAvLyBhcnJheSBvZiBhdHRyIGZ1bmN0aW9uc1xuXG4gIH0pO1xuICB2YXIgbGlua2FnZUFsaWFzZXMgPSB7XG4gICAgJ3NpbmdsZSc6ICdtaW4nLFxuICAgICdjb21wbGV0ZSc6ICdtYXgnXG4gIH07XG5cbiAgdmFyIHNldE9wdGlvbnMkMSA9IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgIHZhciBvcHRzID0gZGVmYXVsdHMkYShvcHRpb25zKTtcbiAgICB2YXIgcHJlZmVycmVkQWxpYXMgPSBsaW5rYWdlQWxpYXNlc1tvcHRzLmxpbmthZ2VdO1xuXG4gICAgaWYgKHByZWZlcnJlZEFsaWFzICE9IG51bGwpIHtcbiAgICAgIG9wdHMubGlua2FnZSA9IHByZWZlcnJlZEFsaWFzO1xuICAgIH1cblxuICAgIHJldHVybiBvcHRzO1xuICB9O1xuXG4gIHZhciBtZXJnZUNsb3Nlc3QgPSBmdW5jdGlvbiBtZXJnZUNsb3Nlc3QoY2x1c3RlcnMsIGluZGV4LCBkaXN0cywgbWlucywgb3B0cykge1xuICAgIC8vIEZpbmQgdHdvIGNsb3Nlc3QgY2x1c3RlcnMgZnJvbSBjYWNoZWQgbWluc1xuICAgIHZhciBtaW5LZXkgPSAwO1xuICAgIHZhciBtaW4gPSBJbmZpbml0eTtcbiAgICB2YXIgZGlzdDtcbiAgICB2YXIgYXR0cnMgPSBvcHRzLmF0dHJpYnV0ZXM7XG5cbiAgICB2YXIgZ2V0RGlzdCA9IGZ1bmN0aW9uIGdldERpc3QobjEsIG4yKSB7XG4gICAgICByZXR1cm4gY2x1c3RlcmluZ0Rpc3RhbmNlKG9wdHMuZGlzdGFuY2UsIGF0dHJzLmxlbmd0aCwgZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgcmV0dXJuIGF0dHJzW2ldKG4xKTtcbiAgICAgIH0sIGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHJldHVybiBhdHRyc1tpXShuMik7XG4gICAgICB9LCBuMSwgbjIpO1xuICAgIH07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsdXN0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0gY2x1c3RlcnNbaV0ua2V5O1xuICAgICAgdmFyIF9kaXN0ID0gZGlzdHNba2V5XVttaW5zW2tleV1dO1xuXG4gICAgICBpZiAoX2Rpc3QgPCBtaW4pIHtcbiAgICAgICAgbWluS2V5ID0ga2V5O1xuICAgICAgICBtaW4gPSBfZGlzdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3B0cy5tb2RlID09PSAndGhyZXNob2xkJyAmJiBtaW4gPj0gb3B0cy50aHJlc2hvbGQgfHwgb3B0cy5tb2RlID09PSAnZGVuZHJvZ3JhbScgJiYgY2x1c3RlcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGMxID0gaW5kZXhbbWluS2V5XTtcbiAgICB2YXIgYzIgPSBpbmRleFttaW5zW21pbktleV1dO1xuICAgIHZhciBtZXJnZWQ7IC8vIE1lcmdlIHR3byBjbG9zZXN0IGNsdXN0ZXJzXG5cbiAgICBpZiAob3B0cy5tb2RlID09PSAnZGVuZHJvZ3JhbScpIHtcbiAgICAgIG1lcmdlZCA9IHtcbiAgICAgICAgbGVmdDogYzEsXG4gICAgICAgIHJpZ2h0OiBjMixcbiAgICAgICAga2V5OiBjMS5rZXlcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lcmdlZCA9IHtcbiAgICAgICAgdmFsdWU6IGMxLnZhbHVlLmNvbmNhdChjMi52YWx1ZSksXG4gICAgICAgIGtleTogYzEua2V5XG4gICAgICB9O1xuICAgIH1cblxuICAgIGNsdXN0ZXJzW2MxLmluZGV4XSA9IG1lcmdlZDtcbiAgICBjbHVzdGVycy5zcGxpY2UoYzIuaW5kZXgsIDEpO1xuICAgIGluZGV4W2MxLmtleV0gPSBtZXJnZWQ7IC8vIFVwZGF0ZSBkaXN0YW5jZXMgd2l0aCBuZXcgbWVyZ2VkIGNsdXN0ZXJcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBjbHVzdGVycy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBjdXIgPSBjbHVzdGVyc1tfaV07XG5cbiAgICAgIGlmIChjMS5rZXkgPT09IGN1ci5rZXkpIHtcbiAgICAgICAgZGlzdCA9IEluZmluaXR5O1xuICAgICAgfSBlbHNlIGlmIChvcHRzLmxpbmthZ2UgPT09ICdtaW4nKSB7XG4gICAgICAgIGRpc3QgPSBkaXN0c1tjMS5rZXldW2N1ci5rZXldO1xuXG4gICAgICAgIGlmIChkaXN0c1tjMS5rZXldW2N1ci5rZXldID4gZGlzdHNbYzIua2V5XVtjdXIua2V5XSkge1xuICAgICAgICAgIGRpc3QgPSBkaXN0c1tjMi5rZXldW2N1ci5rZXldO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG9wdHMubGlua2FnZSA9PT0gJ21heCcpIHtcbiAgICAgICAgZGlzdCA9IGRpc3RzW2MxLmtleV1bY3VyLmtleV07XG5cbiAgICAgICAgaWYgKGRpc3RzW2MxLmtleV1bY3VyLmtleV0gPCBkaXN0c1tjMi5rZXldW2N1ci5rZXldKSB7XG4gICAgICAgICAgZGlzdCA9IGRpc3RzW2MyLmtleV1bY3VyLmtleV07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAob3B0cy5saW5rYWdlID09PSAnbWVhbicpIHtcbiAgICAgICAgZGlzdCA9IChkaXN0c1tjMS5rZXldW2N1ci5rZXldICogYzEuc2l6ZSArIGRpc3RzW2MyLmtleV1bY3VyLmtleV0gKiBjMi5zaXplKSAvIChjMS5zaXplICsgYzIuc2l6ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAob3B0cy5tb2RlID09PSAnZGVuZHJvZ3JhbScpIGRpc3QgPSBnZXREaXN0KGN1ci52YWx1ZSwgYzEudmFsdWUpO2Vsc2UgZGlzdCA9IGdldERpc3QoY3VyLnZhbHVlWzBdLCBjMS52YWx1ZVswXSk7XG4gICAgICB9XG5cbiAgICAgIGRpc3RzW2MxLmtleV1bY3VyLmtleV0gPSBkaXN0c1tjdXIua2V5XVtjMS5rZXldID0gZGlzdDsgLy8gZGlzdGFuY2UgbWF0cml4IGlzIHN5bW1ldHJpY1xuICAgIH0gLy8gVXBkYXRlIGNhY2hlZCBtaW5zXG5cblxuICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGNsdXN0ZXJzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgIHZhciBrZXkxID0gY2x1c3RlcnNbX2kyXS5rZXk7XG5cbiAgICAgIGlmIChtaW5zW2tleTFdID09PSBjMS5rZXkgfHwgbWluc1trZXkxXSA9PT0gYzIua2V5KSB7XG4gICAgICAgIHZhciBfbWluID0ga2V5MTtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNsdXN0ZXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdmFyIGtleTIgPSBjbHVzdGVyc1tqXS5rZXk7XG5cbiAgICAgICAgICBpZiAoZGlzdHNba2V5MV1ba2V5Ml0gPCBkaXN0c1trZXkxXVtfbWluXSkge1xuICAgICAgICAgICAgX21pbiA9IGtleTI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbWluc1trZXkxXSA9IF9taW47XG4gICAgICB9XG5cbiAgICAgIGNsdXN0ZXJzW19pMl0uaW5kZXggPSBfaTI7XG4gICAgfSAvLyBDbGVhbiB1cCBtZXRhIGRhdGEgdXNlZCBmb3IgY2x1c3RlcmluZ1xuXG5cbiAgICBjMS5rZXkgPSBjMi5rZXkgPSBjMS5pbmRleCA9IGMyLmluZGV4ID0gbnVsbDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICB2YXIgZ2V0QWxsQ2hpbGRyZW4gPSBmdW5jdGlvbiBnZXRBbGxDaGlsZHJlbihyb290LCBhcnIsIGN5KSB7XG4gICAgaWYgKCFyb290KSByZXR1cm47XG5cbiAgICBpZiAocm9vdC52YWx1ZSkge1xuICAgICAgYXJyLnB1c2gocm9vdC52YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChyb290LmxlZnQpIGdldEFsbENoaWxkcmVuKHJvb3QubGVmdCwgYXJyKTtcbiAgICAgIGlmIChyb290LnJpZ2h0KSBnZXRBbGxDaGlsZHJlbihyb290LnJpZ2h0LCBhcnIpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgYnVpbGREZW5kcm9ncmFtID0gZnVuY3Rpb24gYnVpbGREZW5kcm9ncmFtKHJvb3QsIGN5KSB7XG4gICAgaWYgKCFyb290KSByZXR1cm4gJyc7XG5cbiAgICBpZiAocm9vdC5sZWZ0ICYmIHJvb3QucmlnaHQpIHtcbiAgICAgIHZhciBsZWZ0U3RyID0gYnVpbGREZW5kcm9ncmFtKHJvb3QubGVmdCwgY3kpO1xuICAgICAgdmFyIHJpZ2h0U3RyID0gYnVpbGREZW5kcm9ncmFtKHJvb3QucmlnaHQsIGN5KTtcbiAgICAgIHZhciBub2RlID0gY3kuYWRkKHtcbiAgICAgICAgZ3JvdXA6ICdub2RlcycsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBpZDogbGVmdFN0ciArICcsJyArIHJpZ2h0U3RyXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY3kuYWRkKHtcbiAgICAgICAgZ3JvdXA6ICdlZGdlcycsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBzb3VyY2U6IGxlZnRTdHIsXG4gICAgICAgICAgdGFyZ2V0OiBub2RlLmlkKClcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjeS5hZGQoe1xuICAgICAgICBncm91cDogJ2VkZ2VzJyxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHNvdXJjZTogcmlnaHRTdHIsXG4gICAgICAgICAgdGFyZ2V0OiBub2RlLmlkKClcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbm9kZS5pZCgpO1xuICAgIH0gZWxzZSBpZiAocm9vdC52YWx1ZSkge1xuICAgICAgcmV0dXJuIHJvb3QudmFsdWUuaWQoKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGJ1aWxkQ2x1c3RlcnNGcm9tVHJlZSA9IGZ1bmN0aW9uIGJ1aWxkQ2x1c3RlcnNGcm9tVHJlZShyb290LCBrLCBjeSkge1xuICAgIGlmICghcm9vdCkgcmV0dXJuIFtdO1xuICAgIHZhciBsZWZ0ID0gW10sXG4gICAgICAgIHJpZ2h0ID0gW10sXG4gICAgICAgIGxlYXZlcyA9IFtdO1xuXG4gICAgaWYgKGsgPT09IDApIHtcbiAgICAgIC8vIGRvbid0IGN1dCB0cmVlLCBzaW1wbHkgcmV0dXJuIGFsbCBub2RlcyBhcyAxIHNpbmdsZSBjbHVzdGVyXG4gICAgICBpZiAocm9vdC5sZWZ0KSBnZXRBbGxDaGlsZHJlbihyb290LmxlZnQsIGxlZnQpO1xuICAgICAgaWYgKHJvb3QucmlnaHQpIGdldEFsbENoaWxkcmVuKHJvb3QucmlnaHQsIHJpZ2h0KTtcbiAgICAgIGxlYXZlcyA9IGxlZnQuY29uY2F0KHJpZ2h0KTtcbiAgICAgIHJldHVybiBbY3kuY29sbGVjdGlvbihsZWF2ZXMpXTtcbiAgICB9IGVsc2UgaWYgKGsgPT09IDEpIHtcbiAgICAgIC8vIGN1dCBhdCByb290XG4gICAgICBpZiAocm9vdC52YWx1ZSkge1xuICAgICAgICAvLyBsZWFmIG5vZGVcbiAgICAgICAgcmV0dXJuIFtjeS5jb2xsZWN0aW9uKHJvb3QudmFsdWUpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChyb290LmxlZnQpIGdldEFsbENoaWxkcmVuKHJvb3QubGVmdCwgbGVmdCk7XG4gICAgICAgIGlmIChyb290LnJpZ2h0KSBnZXRBbGxDaGlsZHJlbihyb290LnJpZ2h0LCByaWdodCk7XG4gICAgICAgIHJldHVybiBbY3kuY29sbGVjdGlvbihsZWZ0KSwgY3kuY29sbGVjdGlvbihyaWdodCldO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocm9vdC52YWx1ZSkge1xuICAgICAgICByZXR1cm4gW2N5LmNvbGxlY3Rpb24ocm9vdC52YWx1ZSldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHJvb3QubGVmdCkgbGVmdCA9IGJ1aWxkQ2x1c3RlcnNGcm9tVHJlZShyb290LmxlZnQsIGsgLSAxLCBjeSk7XG4gICAgICAgIGlmIChyb290LnJpZ2h0KSByaWdodCA9IGJ1aWxkQ2x1c3RlcnNGcm9tVHJlZShyb290LnJpZ2h0LCBrIC0gMSwgY3kpO1xuICAgICAgICByZXR1cm4gbGVmdC5jb25jYXQocmlnaHQpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLyogZXNsaW50LWVuYWJsZSAqL1xuXG5cbiAgdmFyIGhpZXJhcmNoaWNhbENsdXN0ZXJpbmcgPSBmdW5jdGlvbiBoaWVyYXJjaGljYWxDbHVzdGVyaW5nKG9wdGlvbnMpIHtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpOyAvLyBTZXQgcGFyYW1ldGVycyBvZiBhbGdvcml0aG06IGxpbmthZ2UgdHlwZSwgZGlzdGFuY2UgbWV0cmljLCBldGMuXG5cbiAgICB2YXIgb3B0cyA9IHNldE9wdGlvbnMkMShvcHRpb25zKTtcbiAgICB2YXIgYXR0cnMgPSBvcHRzLmF0dHJpYnV0ZXM7XG5cbiAgICB2YXIgZ2V0RGlzdCA9IGZ1bmN0aW9uIGdldERpc3QobjEsIG4yKSB7XG4gICAgICByZXR1cm4gY2x1c3RlcmluZ0Rpc3RhbmNlKG9wdHMuZGlzdGFuY2UsIGF0dHJzLmxlbmd0aCwgZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgcmV0dXJuIGF0dHJzW2ldKG4xKTtcbiAgICAgIH0sIGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHJldHVybiBhdHRyc1tpXShuMik7XG4gICAgICB9LCBuMSwgbjIpO1xuICAgIH07IC8vIEJlZ2luIGhpZXJhcmNoaWNhbCBhbGdvcml0aG1cblxuXG4gICAgdmFyIGNsdXN0ZXJzID0gW107XG4gICAgdmFyIGRpc3RzID0gW107IC8vIGRpc3RhbmNlcyBiZXR3ZWVuIGVhY2ggcGFpciBvZiBjbHVzdGVyc1xuXG4gICAgdmFyIG1pbnMgPSBbXTsgLy8gY2xvc2VzdCBjbHVzdGVyIGZvciBlYWNoIGNsdXN0ZXJcblxuICAgIHZhciBpbmRleCA9IFtdOyAvLyBoYXNoIG9mIGFsbCBjbHVzdGVycyBieSBrZXlcbiAgICAvLyBJbiBhZ2dsb21lcmF0aXZlIChib3R0b20tdXApIGNsdXN0ZXJpbmcsIGVhY2ggbm9kZSBzdGFydHMgYXMgaXRzIG93biBjbHVzdGVyXG5cbiAgICBmb3IgKHZhciBuID0gMDsgbiA8IG5vZGVzLmxlbmd0aDsgbisrKSB7XG4gICAgICB2YXIgY2x1c3RlciA9IHtcbiAgICAgICAgdmFsdWU6IG9wdHMubW9kZSA9PT0gJ2RlbmRyb2dyYW0nID8gbm9kZXNbbl0gOiBbbm9kZXNbbl1dLFxuICAgICAgICBrZXk6IG4sXG4gICAgICAgIGluZGV4OiBuXG4gICAgICB9O1xuICAgICAgY2x1c3RlcnNbbl0gPSBjbHVzdGVyO1xuICAgICAgaW5kZXhbbl0gPSBjbHVzdGVyO1xuICAgICAgZGlzdHNbbl0gPSBbXTtcbiAgICAgIG1pbnNbbl0gPSAwO1xuICAgIH0gLy8gQ2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIGVhY2ggcGFpciBvZiBjbHVzdGVyc1xuXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsdXN0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8PSBpOyBqKyspIHtcbiAgICAgICAgdmFyIGRpc3QgPSB2b2lkIDA7XG5cbiAgICAgICAgaWYgKG9wdHMubW9kZSA9PT0gJ2RlbmRyb2dyYW0nKSB7XG4gICAgICAgICAgLy8gbW9kZXMgc3RvcmUgY2x1c3RlciB2YWx1ZXMgZGlmZmVyZW50bHlcbiAgICAgICAgICBkaXN0ID0gaSA9PT0gaiA/IEluZmluaXR5IDogZ2V0RGlzdChjbHVzdGVyc1tpXS52YWx1ZSwgY2x1c3RlcnNbal0udmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRpc3QgPSBpID09PSBqID8gSW5maW5pdHkgOiBnZXREaXN0KGNsdXN0ZXJzW2ldLnZhbHVlWzBdLCBjbHVzdGVyc1tqXS52YWx1ZVswXSk7XG4gICAgICAgIH1cblxuICAgICAgICBkaXN0c1tpXVtqXSA9IGRpc3Q7XG4gICAgICAgIGRpc3RzW2pdW2ldID0gZGlzdDtcblxuICAgICAgICBpZiAoZGlzdCA8IGRpc3RzW2ldW21pbnNbaV1dKSB7XG4gICAgICAgICAgbWluc1tpXSA9IGo7IC8vIENhY2hlIG1pbnM6IGNsb3Nlc3QgY2x1c3RlciB0byBjbHVzdGVyIGkgaXMgY2x1c3RlciBqXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIEZpbmQgdGhlIGNsb3Nlc3QgcGFpciBvZiBjbHVzdGVycyBhbmQgbWVyZ2UgdGhlbSBpbnRvIGEgc2luZ2xlIGNsdXN0ZXIuXG4gICAgLy8gVXBkYXRlIGRpc3RhbmNlcyBiZXR3ZWVuIG5ldyBjbHVzdGVyIGFuZCBlYWNoIG9mIHRoZSBvbGQgY2x1c3RlcnMsIGFuZCBsb29wIHVudGlsIHRocmVzaG9sZCByZWFjaGVkLlxuXG5cbiAgICB2YXIgbWVyZ2VkID0gbWVyZ2VDbG9zZXN0KGNsdXN0ZXJzLCBpbmRleCwgZGlzdHMsIG1pbnMsIG9wdHMpO1xuXG4gICAgd2hpbGUgKG1lcmdlZCkge1xuICAgICAgbWVyZ2VkID0gbWVyZ2VDbG9zZXN0KGNsdXN0ZXJzLCBpbmRleCwgZGlzdHMsIG1pbnMsIG9wdHMpO1xuICAgIH1cblxuICAgIHZhciByZXRDbHVzdGVyczsgLy8gRGVuZHJvZ3JhbSBtb2RlIGJ1aWxkcyB0aGUgaGllcmFyY2h5IGFuZCBhZGRzIGludGVybWVkaWFyeSBub2RlcyArIGVkZ2VzXG4gICAgLy8gaW4gYWRkaXRpb24gdG8gcmV0dXJuaW5nIHRoZSBjbHVzdGVycy5cblxuICAgIGlmIChvcHRzLm1vZGUgPT09ICdkZW5kcm9ncmFtJykge1xuICAgICAgcmV0Q2x1c3RlcnMgPSBidWlsZENsdXN0ZXJzRnJvbVRyZWUoY2x1c3RlcnNbMF0sIG9wdHMuZGVuZHJvZ3JhbURlcHRoLCBjeSk7XG4gICAgICBpZiAob3B0cy5hZGREZW5kcm9ncmFtKSBidWlsZERlbmRyb2dyYW0oY2x1c3RlcnNbMF0sIGN5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVndWxhciBtb2RlIHNpbXBseSByZXR1cm5zIHRoZSBjbHVzdGVyc1xuICAgICAgcmV0Q2x1c3RlcnMgPSBuZXcgQXJyYXkoY2x1c3RlcnMubGVuZ3RoKTtcbiAgICAgIGNsdXN0ZXJzLmZvckVhY2goZnVuY3Rpb24gKGNsdXN0ZXIsIGkpIHtcbiAgICAgICAgLy8gQ2xlYW4gdXAgbWV0YSBkYXRhIHVzZWQgZm9yIGNsdXN0ZXJpbmdcbiAgICAgICAgY2x1c3Rlci5rZXkgPSBjbHVzdGVyLmluZGV4ID0gbnVsbDtcbiAgICAgICAgcmV0Q2x1c3RlcnNbaV0gPSBjeS5jb2xsZWN0aW9uKGNsdXN0ZXIudmFsdWUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldENsdXN0ZXJzO1xuICB9O1xuXG4gIHZhciBoaWVyYXJjaGljYWxDbHVzdGVyaW5nJDEgPSB7XG4gICAgaGllcmFyY2hpY2FsQ2x1c3RlcmluZzogaGllcmFyY2hpY2FsQ2x1c3RlcmluZyxcbiAgICBoY2E6IGhpZXJhcmNoaWNhbENsdXN0ZXJpbmdcbiAgfTtcblxuICAvLyBJbXBsZW1lbnRlZCBieSBab2UgWGkgQHpvZXhpIGZvciBHU09DIDIwMTZcbiAgdmFyIGRlZmF1bHRzJDkgPSBkZWZhdWx0cyRnKHtcbiAgICBkaXN0YW5jZTogJ2V1Y2xpZGVhbicsXG4gICAgLy8gZGlzdGFuY2UgbWV0cmljIHRvIGNvbXBhcmUgYXR0cmlidXRlcyBiZXR3ZWVuIHR3byBub2Rlc1xuICAgIHByZWZlcmVuY2U6ICdtZWRpYW4nLFxuICAgIC8vIHN1aXRhYmlsaXR5IG9mIGEgZGF0YSBwb2ludCB0byBzZXJ2ZSBhcyBhbiBleGVtcGxhclxuICAgIGRhbXBpbmc6IDAuOCxcbiAgICAvLyBkYW1waW5nIGZhY3RvciBiZXR3ZWVuIFswLjUsIDEpXG4gICAgbWF4SXRlcmF0aW9uczogMTAwMCxcbiAgICAvLyBtYXggbnVtYmVyIG9mIGl0ZXJhdGlvbnMgdG8gcnVuXG4gICAgbWluSXRlcmF0aW9uczogMTAwLFxuICAgIC8vIG1pbiBudW1iZXIgb2YgaXRlcmF0aW9ucyB0byBydW4gaW4gb3JkZXIgZm9yIGNsdXN0ZXJpbmcgdG8gc3RvcFxuICAgIGF0dHJpYnV0ZXM6IFsvLyBmdW5jdGlvbnMgdG8gcXVhbnRpZnkgdGhlIHNpbWlsYXJpdHkgYmV0d2VlbiBhbnkgdHdvIHBvaW50c1xuICAgICAgLy8gZS5nLiBub2RlID0+IG5vZGUuZGF0YSgnd2VpZ2h0JylcbiAgICBdXG4gIH0pO1xuXG4gIHZhciBzZXRPcHRpb25zID0gZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgdmFyIGRtcCA9IG9wdGlvbnMuZGFtcGluZztcbiAgICB2YXIgcHJlZiA9IG9wdGlvbnMucHJlZmVyZW5jZTtcblxuICAgIGlmICghKDAuNSA8PSBkbXAgJiYgZG1wIDwgMSkpIHtcbiAgICAgIGVycm9yKFwiRGFtcGluZyBtdXN0IHJhbmdlIG9uIFswLjUsIDEpLiAgR290OiBcIi5jb25jYXQoZG1wKSk7XG4gICAgfVxuXG4gICAgdmFyIHZhbGlkUHJlZnMgPSBbJ21lZGlhbicsICdtZWFuJywgJ21pbicsICdtYXgnXTtcblxuICAgIGlmICghKHZhbGlkUHJlZnMuc29tZShmdW5jdGlvbiAodikge1xuICAgICAgcmV0dXJuIHYgPT09IHByZWY7XG4gICAgfSkgfHwgbnVtYmVyJDEocHJlZikpKSB7XG4gICAgICBlcnJvcihcIlByZWZlcmVuY2UgbXVzdCBiZSBvbmUgb2YgW1wiLmNvbmNhdCh2YWxpZFByZWZzLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgICByZXR1cm4gXCInXCIuY29uY2F0KHAsIFwiJ1wiKTtcbiAgICAgIH0pLmpvaW4oJywgJyksIFwiXSBvciBhIG51bWJlci4gIEdvdDogXCIpLmNvbmNhdChwcmVmKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlZmF1bHRzJDkob3B0aW9ucyk7XG4gIH07XG4gIC8qIGVzbGludC1lbmFibGUgKi9cblxuXG4gIHZhciBnZXRTaW1pbGFyaXR5ID0gZnVuY3Rpb24gZ2V0U2ltaWxhcml0eSh0eXBlLCBuMSwgbjIsIGF0dHJpYnV0ZXMpIHtcbiAgICB2YXIgYXR0ciA9IGZ1bmN0aW9uIGF0dHIobiwgaSkge1xuICAgICAgcmV0dXJuIGF0dHJpYnV0ZXNbaV0obik7XG4gICAgfTsgLy8gbmIgbmVnYXRpdmUgYmVjYXVzZSBzaW1pbGFyaXR5IHNob3VsZCBoYXZlIGFuIGludmVyc2UgcmVsYXRpb25zaGlwIHRvIGRpc3RhbmNlXG5cblxuICAgIHJldHVybiAtY2x1c3RlcmluZ0Rpc3RhbmNlKHR5cGUsIGF0dHJpYnV0ZXMubGVuZ3RoLCBmdW5jdGlvbiAoaSkge1xuICAgICAgcmV0dXJuIGF0dHIobjEsIGkpO1xuICAgIH0sIGZ1bmN0aW9uIChpKSB7XG4gICAgICByZXR1cm4gYXR0cihuMiwgaSk7XG4gICAgfSwgbjEsIG4yKTtcbiAgfTtcblxuICB2YXIgZ2V0UHJlZmVyZW5jZSA9IGZ1bmN0aW9uIGdldFByZWZlcmVuY2UoUywgcHJlZmVyZW5jZSkge1xuICAgIC8vIGxhcmdlciBwcmVmZXJlbmNlID0gZ3JlYXRlciAjIG9mIGNsdXN0ZXJzXG4gICAgdmFyIHAgPSBudWxsO1xuXG4gICAgaWYgKHByZWZlcmVuY2UgPT09ICdtZWRpYW4nKSB7XG4gICAgICBwID0gbWVkaWFuKFMpO1xuICAgIH0gZWxzZSBpZiAocHJlZmVyZW5jZSA9PT0gJ21lYW4nKSB7XG4gICAgICBwID0gbWVhbihTKTtcbiAgICB9IGVsc2UgaWYgKHByZWZlcmVuY2UgPT09ICdtaW4nKSB7XG4gICAgICBwID0gbWluKFMpO1xuICAgIH0gZWxzZSBpZiAocHJlZmVyZW5jZSA9PT0gJ21heCcpIHtcbiAgICAgIHAgPSBtYXgoUyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEN1c3RvbSBwcmVmZXJlbmNlIG51bWJlciwgYXMgc2V0IGJ5IHVzZXJcbiAgICAgIHAgPSBwcmVmZXJlbmNlO1xuICAgIH1cblxuICAgIHJldHVybiBwO1xuICB9O1xuXG4gIHZhciBmaW5kRXhlbXBsYXJzID0gZnVuY3Rpb24gZmluZEV4ZW1wbGFycyhuLCBSLCBBKSB7XG4gICAgdmFyIGluZGljZXMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICBpZiAoUltpICogbiArIGldICsgQVtpICogbiArIGldID4gMCkge1xuICAgICAgICBpbmRpY2VzLnB1c2goaSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZGljZXM7XG4gIH07XG5cbiAgdmFyIGFzc2lnbkNsdXN0ZXJzID0gZnVuY3Rpb24gYXNzaWduQ2x1c3RlcnMobiwgUywgZXhlbXBsYXJzKSB7XG4gICAgdmFyIGNsdXN0ZXJzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICB2YXIgbWF4ID0gLUluZmluaXR5O1xuXG4gICAgICBmb3IgKHZhciBlaSA9IDA7IGVpIDwgZXhlbXBsYXJzLmxlbmd0aDsgZWkrKykge1xuICAgICAgICB2YXIgZSA9IGV4ZW1wbGFyc1tlaV07XG5cbiAgICAgICAgaWYgKFNbaSAqIG4gKyBlXSA+IG1heCkge1xuICAgICAgICAgIGluZGV4ID0gZTtcbiAgICAgICAgICBtYXggPSBTW2kgKiBuICsgZV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGluZGV4ID4gMCkge1xuICAgICAgICBjbHVzdGVycy5wdXNoKGluZGV4KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBfZWkgPSAwOyBfZWkgPCBleGVtcGxhcnMubGVuZ3RoOyBfZWkrKykge1xuICAgICAgY2x1c3RlcnNbZXhlbXBsYXJzW19laV1dID0gZXhlbXBsYXJzW19laV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsdXN0ZXJzO1xuICB9O1xuXG4gIHZhciBhc3NpZ24gPSBmdW5jdGlvbiBhc3NpZ24obiwgUywgZXhlbXBsYXJzKSB7XG4gICAgdmFyIGNsdXN0ZXJzID0gYXNzaWduQ2x1c3RlcnMobiwgUywgZXhlbXBsYXJzKTtcblxuICAgIGZvciAodmFyIGVpID0gMDsgZWkgPCBleGVtcGxhcnMubGVuZ3RoOyBlaSsrKSB7XG4gICAgICB2YXIgaWkgPSBbXTtcblxuICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBjbHVzdGVycy5sZW5ndGg7IGMrKykge1xuICAgICAgICBpZiAoY2x1c3RlcnNbY10gPT09IGV4ZW1wbGFyc1tlaV0pIHtcbiAgICAgICAgICBpaS5wdXNoKGMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBtYXhJID0gLTE7XG4gICAgICB2YXIgbWF4U3VtID0gLUluZmluaXR5O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlpLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzdW0gPSAwO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaWkubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBzdW0gKz0gU1tpaVtqXSAqIG4gKyBpaVtpXV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3VtID4gbWF4U3VtKSB7XG4gICAgICAgICAgbWF4SSA9IGk7XG4gICAgICAgICAgbWF4U3VtID0gc3VtO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGV4ZW1wbGFyc1tlaV0gPSBpaVttYXhJXTtcbiAgICB9XG5cbiAgICBjbHVzdGVycyA9IGFzc2lnbkNsdXN0ZXJzKG4sIFMsIGV4ZW1wbGFycyk7XG4gICAgcmV0dXJuIGNsdXN0ZXJzO1xuICB9O1xuXG4gIHZhciBhZmZpbml0eVByb3BhZ2F0aW9uID0gZnVuY3Rpb24gYWZmaW5pdHlQcm9wYWdhdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgICB2YXIgb3B0cyA9IHNldE9wdGlvbnMob3B0aW9ucyk7IC8vIE1hcCBlYWNoIG5vZGUgdG8gaXRzIHBvc2l0aW9uIGluIG5vZGUgYXJyYXlcblxuICAgIHZhciBpZDJwb3NpdGlvbiA9IHt9O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWQycG9zaXRpb25bbm9kZXNbaV0uaWQoKV0gPSBpO1xuICAgIH0gLy8gQmVnaW4gYWZmaW5pdHkgcHJvcGFnYXRpb24gYWxnb3JpdGhtXG5cblxuICAgIHZhciBuOyAvLyBudW1iZXIgb2YgZGF0YSBwb2ludHNcblxuICAgIHZhciBuMjsgLy8gc2l6ZSBvZiBtYXRyaWNlc1xuXG4gICAgdmFyIFM7IC8vIHNpbWlsYXJpdHkgbWF0cml4ICgxRCBhcnJheSlcblxuICAgIHZhciBwOyAvLyBwcmVmZXJlbmNlL3N1aXRhYmlsaXR5IG9mIGEgZGF0YSBwb2ludCB0byBzZXJ2ZSBhcyBhbiBleGVtcGxhclxuXG4gICAgdmFyIFI7IC8vIHJlc3BvbnNpYmlsaXR5IG1hdHJpeCAoMUQgYXJyYXkpXG5cbiAgICB2YXIgQTsgLy8gYXZhaWxhYmlsaXR5IG1hdHJpeCAoMUQgYXJyYXkpXG5cbiAgICBuID0gbm9kZXMubGVuZ3RoO1xuICAgIG4yID0gbiAqIG47IC8vIEluaXRpYWxpemUgYW5kIGJ1aWxkIFMgc2ltaWxhcml0eSBtYXRyaXhcblxuICAgIFMgPSBuZXcgQXJyYXkobjIpO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG4yOyBfaSsrKSB7XG4gICAgICBTW19pXSA9IC1JbmZpbml0eTsgLy8gZm9yIGNhc2VzIHdoZXJlIHR3byBkYXRhIHBvaW50cyBzaG91bGRuJ3QgYmUgbGlua2VkIHRvZ2V0aGVyXG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbjsgX2kyKyspIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbjsgaisrKSB7XG4gICAgICAgIGlmIChfaTIgIT09IGopIHtcbiAgICAgICAgICBTW19pMiAqIG4gKyBqXSA9IGdldFNpbWlsYXJpdHkob3B0cy5kaXN0YW5jZSwgbm9kZXNbX2kyXSwgbm9kZXNbal0sIG9wdHMuYXR0cmlidXRlcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIFBsYWNlIHByZWZlcmVuY2VzIG9uIHRoZSBkaWFnb25hbCBvZiBTXG5cblxuICAgIHAgPSBnZXRQcmVmZXJlbmNlKFMsIG9wdHMucHJlZmVyZW5jZSk7XG5cbiAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBuOyBfaTMrKykge1xuICAgICAgU1tfaTMgKiBuICsgX2kzXSA9IHA7XG4gICAgfSAvLyBJbml0aWFsaXplIFIgcmVzcG9uc2liaWxpdHkgbWF0cml4XG5cblxuICAgIFIgPSBuZXcgQXJyYXkobjIpO1xuXG4gICAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgbjI7IF9pNCsrKSB7XG4gICAgICBSW19pNF0gPSAwLjA7XG4gICAgfSAvLyBJbml0aWFsaXplIEEgYXZhaWxhYmlsaXR5IG1hdHJpeFxuXG5cbiAgICBBID0gbmV3IEFycmF5KG4yKTtcblxuICAgIGZvciAodmFyIF9pNSA9IDA7IF9pNSA8IG4yOyBfaTUrKykge1xuICAgICAgQVtfaTVdID0gMC4wO1xuICAgIH1cblxuICAgIHZhciBvbGQgPSBuZXcgQXJyYXkobik7XG4gICAgdmFyIFJwID0gbmV3IEFycmF5KG4pO1xuICAgIHZhciBzZSA9IG5ldyBBcnJheShuKTtcblxuICAgIGZvciAodmFyIF9pNiA9IDA7IF9pNiA8IG47IF9pNisrKSB7XG4gICAgICBvbGRbX2k2XSA9IDAuMDtcbiAgICAgIFJwW19pNl0gPSAwLjA7XG4gICAgICBzZVtfaTZdID0gMDtcbiAgICB9XG5cbiAgICB2YXIgZSA9IG5ldyBBcnJheShuICogb3B0cy5taW5JdGVyYXRpb25zKTtcblxuICAgIGZvciAodmFyIF9pNyA9IDA7IF9pNyA8IGUubGVuZ3RoOyBfaTcrKykge1xuICAgICAgZVtfaTddID0gMDtcbiAgICB9XG5cbiAgICB2YXIgaXRlcjtcblxuICAgIGZvciAoaXRlciA9IDA7IGl0ZXIgPCBvcHRzLm1heEl0ZXJhdGlvbnM7IGl0ZXIrKykge1xuICAgICAgLy8gbWFpbiBhbGdvcml0aG1pYyBsb29wXG4gICAgICAvLyBVcGRhdGUgUiByZXNwb25zaWJpbGl0eSBtYXRyaXhcbiAgICAgIGZvciAodmFyIF9pOCA9IDA7IF9pOCA8IG47IF9pOCsrKSB7XG4gICAgICAgIHZhciBtYXggPSAtSW5maW5pdHksXG4gICAgICAgICAgICBtYXgyID0gLUluZmluaXR5LFxuICAgICAgICAgICAgbWF4SSA9IC0xLFxuICAgICAgICAgICAgQVMgPSAwLjA7XG5cbiAgICAgICAgZm9yICh2YXIgX2ogPSAwOyBfaiA8IG47IF9qKyspIHtcbiAgICAgICAgICBvbGRbX2pdID0gUltfaTggKiBuICsgX2pdO1xuICAgICAgICAgIEFTID0gQVtfaTggKiBuICsgX2pdICsgU1tfaTggKiBuICsgX2pdO1xuXG4gICAgICAgICAgaWYgKEFTID49IG1heCkge1xuICAgICAgICAgICAgbWF4MiA9IG1heDtcbiAgICAgICAgICAgIG1heCA9IEFTO1xuICAgICAgICAgICAgbWF4SSA9IF9qO1xuICAgICAgICAgIH0gZWxzZSBpZiAoQVMgPiBtYXgyKSB7XG4gICAgICAgICAgICBtYXgyID0gQVM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgX2oyID0gMDsgX2oyIDwgbjsgX2oyKyspIHtcbiAgICAgICAgICBSW19pOCAqIG4gKyBfajJdID0gKDEgLSBvcHRzLmRhbXBpbmcpICogKFNbX2k4ICogbiArIF9qMl0gLSBtYXgpICsgb3B0cy5kYW1waW5nICogb2xkW19qMl07XG4gICAgICAgIH1cblxuICAgICAgICBSW19pOCAqIG4gKyBtYXhJXSA9ICgxIC0gb3B0cy5kYW1waW5nKSAqIChTW19pOCAqIG4gKyBtYXhJXSAtIG1heDIpICsgb3B0cy5kYW1waW5nICogb2xkW21heEldO1xuICAgICAgfSAvLyBVcGRhdGUgQSBhdmFpbGFiaWxpdHkgbWF0cml4XG5cblxuICAgICAgZm9yICh2YXIgX2k5ID0gMDsgX2k5IDwgbjsgX2k5KyspIHtcbiAgICAgICAgdmFyIHN1bSA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgX2ozID0gMDsgX2ozIDwgbjsgX2ozKyspIHtcbiAgICAgICAgICBvbGRbX2ozXSA9IEFbX2ozICogbiArIF9pOV07XG4gICAgICAgICAgUnBbX2ozXSA9IE1hdGgubWF4KDAsIFJbX2ozICogbiArIF9pOV0pO1xuICAgICAgICAgIHN1bSArPSBScFtfajNdO1xuICAgICAgICB9XG5cbiAgICAgICAgc3VtIC09IFJwW19pOV07XG4gICAgICAgIFJwW19pOV0gPSBSW19pOSAqIG4gKyBfaTldO1xuICAgICAgICBzdW0gKz0gUnBbX2k5XTtcblxuICAgICAgICBmb3IgKHZhciBfajQgPSAwOyBfajQgPCBuOyBfajQrKykge1xuICAgICAgICAgIEFbX2o0ICogbiArIF9pOV0gPSAoMSAtIG9wdHMuZGFtcGluZykgKiBNYXRoLm1pbigwLCBzdW0gLSBScFtfajRdKSArIG9wdHMuZGFtcGluZyAqIG9sZFtfajRdO1xuICAgICAgICB9XG5cbiAgICAgICAgQVtfaTkgKiBuICsgX2k5XSA9ICgxIC0gb3B0cy5kYW1waW5nKSAqIChzdW0gLSBScFtfaTldKSArIG9wdHMuZGFtcGluZyAqIG9sZFtfaTldO1xuICAgICAgfSAvLyBDaGVjayBmb3IgY29udmVyZ2VuY2VcblxuXG4gICAgICB2YXIgSyA9IDA7XG5cbiAgICAgIGZvciAodmFyIF9pMTAgPSAwOyBfaTEwIDwgbjsgX2kxMCsrKSB7XG4gICAgICAgIHZhciBFID0gQVtfaTEwICogbiArIF9pMTBdICsgUltfaTEwICogbiArIF9pMTBdID4gMCA/IDEgOiAwO1xuICAgICAgICBlW2l0ZXIgJSBvcHRzLm1pbkl0ZXJhdGlvbnMgKiBuICsgX2kxMF0gPSBFO1xuICAgICAgICBLICs9IEU7XG4gICAgICB9XG5cbiAgICAgIGlmIChLID4gMCAmJiAoaXRlciA+PSBvcHRzLm1pbkl0ZXJhdGlvbnMgLSAxIHx8IGl0ZXIgPT0gb3B0cy5tYXhJdGVyYXRpb25zIC0gMSkpIHtcbiAgICAgICAgdmFyIF9zdW0gPSAwO1xuXG4gICAgICAgIGZvciAodmFyIF9pMTEgPSAwOyBfaTExIDwgbjsgX2kxMSsrKSB7XG4gICAgICAgICAgc2VbX2kxMV0gPSAwO1xuXG4gICAgICAgICAgZm9yICh2YXIgX2o1ID0gMDsgX2o1IDwgb3B0cy5taW5JdGVyYXRpb25zOyBfajUrKykge1xuICAgICAgICAgICAgc2VbX2kxMV0gKz0gZVtfajUgKiBuICsgX2kxMV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlW19pMTFdID09PSAwIHx8IHNlW19pMTFdID09PSBvcHRzLm1pbkl0ZXJhdGlvbnMpIHtcbiAgICAgICAgICAgIF9zdW0rKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX3N1bSA9PT0gbikge1xuICAgICAgICAgIC8vIHRoZW4gd2UgaGF2ZSBjb252ZXJnZW5jZVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBJZGVudGlmeSBleGVtcGxhcnMgKGNsdXN0ZXIgY2VudGVycylcblxuXG4gICAgdmFyIGV4ZW1wbGFyc0luZGljZXMgPSBmaW5kRXhlbXBsYXJzKG4sIFIsIEEpOyAvLyBBc3NpZ24gbm9kZXMgdG8gY2x1c3RlcnNcblxuICAgIHZhciBjbHVzdGVySW5kaWNlcyA9IGFzc2lnbihuLCBTLCBleGVtcGxhcnNJbmRpY2VzKTtcbiAgICB2YXIgY2x1c3RlcnMgPSB7fTtcblxuICAgIGZvciAodmFyIGMgPSAwOyBjIDwgZXhlbXBsYXJzSW5kaWNlcy5sZW5ndGg7IGMrKykge1xuICAgICAgY2x1c3RlcnNbZXhlbXBsYXJzSW5kaWNlc1tjXV0gPSBbXTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaTEyID0gMDsgX2kxMiA8IG5vZGVzLmxlbmd0aDsgX2kxMisrKSB7XG4gICAgICB2YXIgcG9zID0gaWQycG9zaXRpb25bbm9kZXNbX2kxMl0uaWQoKV07XG5cbiAgICAgIHZhciBjbHVzdGVySW5kZXggPSBjbHVzdGVySW5kaWNlc1twb3NdO1xuXG4gICAgICBpZiAoY2x1c3RlckluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgLy8gdGhlIG5vZGUgbWF5IGhhdmUgbm90IGJlZW4gYXNzaWduZWQgYSBjbHVzdGVyIGlmIG5vIHZhbGlkIGF0dHJpYnV0ZXMgd2VyZSBzcGVjaWZpZWRcbiAgICAgICAgY2x1c3RlcnNbY2x1c3RlckluZGV4XS5wdXNoKG5vZGVzW19pMTJdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmV0Q2x1c3RlcnMgPSBuZXcgQXJyYXkoZXhlbXBsYXJzSW5kaWNlcy5sZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgX2MgPSAwOyBfYyA8IGV4ZW1wbGFyc0luZGljZXMubGVuZ3RoOyBfYysrKSB7XG4gICAgICByZXRDbHVzdGVyc1tfY10gPSBjeS5jb2xsZWN0aW9uKGNsdXN0ZXJzW2V4ZW1wbGFyc0luZGljZXNbX2NdXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldENsdXN0ZXJzO1xuICB9O1xuXG4gIHZhciBhZmZpbml0eVByb3BhZ2F0aW9uJDEgPSB7XG4gICAgYWZmaW5pdHlQcm9wYWdhdGlvbjogYWZmaW5pdHlQcm9wYWdhdGlvbixcbiAgICBhcDogYWZmaW5pdHlQcm9wYWdhdGlvblxuICB9O1xuXG4gIHZhciBoaWVyaG9semVyRGVmYXVsdHMgPSBkZWZhdWx0cyRnKHtcbiAgICByb290OiB1bmRlZmluZWQsXG4gICAgZGlyZWN0ZWQ6IGZhbHNlXG4gIH0pO1xuICB2YXIgZWxlc2ZuJGsgPSB7XG4gICAgaGllcmhvbHplcjogZnVuY3Rpb24gaGllcmhvbHplcihvcHRpb25zKSB7XG4gICAgICBpZiAoIXBsYWluT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgIHJvb3Q6IGFyZ3NbMF0sXG4gICAgICAgICAgZGlyZWN0ZWQ6IGFyZ3NbMV1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdmFyIF9oaWVyaG9semVyRGVmYXVsdHMgPSBoaWVyaG9semVyRGVmYXVsdHMob3B0aW9ucyksXG4gICAgICAgICAgcm9vdCA9IF9oaWVyaG9semVyRGVmYXVsdHMucm9vdCxcbiAgICAgICAgICBkaXJlY3RlZCA9IF9oaWVyaG9semVyRGVmYXVsdHMuZGlyZWN0ZWQ7XG5cbiAgICAgIHZhciBlbGVzID0gdGhpcztcbiAgICAgIHZhciBkZmxhZyA9IGZhbHNlO1xuICAgICAgdmFyIG9kZEluO1xuICAgICAgdmFyIG9kZE91dDtcbiAgICAgIHZhciBzdGFydFZlcnRleDtcbiAgICAgIGlmIChyb290KSBzdGFydFZlcnRleCA9IHN0cmluZyhyb290KSA/IHRoaXMuZmlsdGVyKHJvb3QpWzBdLmlkKCkgOiByb290WzBdLmlkKCk7XG4gICAgICB2YXIgbm9kZXMgPSB7fTtcbiAgICAgIHZhciBlZGdlcyA9IHt9O1xuXG4gICAgICBpZiAoZGlyZWN0ZWQpIHtcbiAgICAgICAgZWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgICB2YXIgaWQgPSBlbGUuaWQoKTtcblxuICAgICAgICAgIGlmIChlbGUuaXNOb2RlKCkpIHtcbiAgICAgICAgICAgIHZhciBpbmQgPSBlbGUuaW5kZWdyZWUodHJ1ZSk7XG4gICAgICAgICAgICB2YXIgb3V0ZCA9IGVsZS5vdXRkZWdyZWUodHJ1ZSk7XG4gICAgICAgICAgICB2YXIgZDEgPSBpbmQgLSBvdXRkO1xuICAgICAgICAgICAgdmFyIGQyID0gb3V0ZCAtIGluZDtcblxuICAgICAgICAgICAgaWYgKGQxID09IDEpIHtcbiAgICAgICAgICAgICAgaWYgKG9kZEluKSBkZmxhZyA9IHRydWU7ZWxzZSBvZGRJbiA9IGlkO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkMiA9PSAxKSB7XG4gICAgICAgICAgICAgIGlmIChvZGRPdXQpIGRmbGFnID0gdHJ1ZTtlbHNlIG9kZE91dCA9IGlkO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkMiA+IDEgfHwgZDEgPiAxKSB7XG4gICAgICAgICAgICAgIGRmbGFnID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbm9kZXNbaWRdID0gW107XG4gICAgICAgICAgICBlbGUub3V0Z29lcnMoKS5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIGlmIChlLmlzRWRnZSgpKSBub2Rlc1tpZF0ucHVzaChlLmlkKCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVkZ2VzW2lkXSA9IFt1bmRlZmluZWQsIGVsZS50YXJnZXQoKS5pZCgpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgICB2YXIgaWQgPSBlbGUuaWQoKTtcblxuICAgICAgICAgIGlmIChlbGUuaXNOb2RlKCkpIHtcbiAgICAgICAgICAgIHZhciBkID0gZWxlLmRlZ3JlZSh0cnVlKTtcblxuICAgICAgICAgICAgaWYgKGQgJSAyKSB7XG4gICAgICAgICAgICAgIGlmICghb2RkSW4pIG9kZEluID0gaWQ7ZWxzZSBpZiAoIW9kZE91dCkgb2RkT3V0ID0gaWQ7ZWxzZSBkZmxhZyA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5vZGVzW2lkXSA9IFtdO1xuICAgICAgICAgICAgZWxlLmNvbm5lY3RlZEVkZ2VzKCkuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICByZXR1cm4gbm9kZXNbaWRdLnB1c2goZS5pZCgpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlZGdlc1tpZF0gPSBbZWxlLnNvdXJjZSgpLmlkKCksIGVsZS50YXJnZXQoKS5pZCgpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICBmb3VuZDogZmFsc2UsXG4gICAgICAgIHRyYWlsOiB1bmRlZmluZWRcbiAgICAgIH07XG4gICAgICBpZiAoZGZsYWcpIHJldHVybiByZXN1bHQ7ZWxzZSBpZiAob2RkT3V0ICYmIG9kZEluKSB7XG4gICAgICAgIGlmIChkaXJlY3RlZCkge1xuICAgICAgICAgIGlmIChzdGFydFZlcnRleCAmJiBvZGRPdXQgIT0gc3RhcnRWZXJ0ZXgpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3RhcnRWZXJ0ZXggPSBvZGRPdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHN0YXJ0VmVydGV4ICYmIG9kZE91dCAhPSBzdGFydFZlcnRleCAmJiBvZGRJbiAhPSBzdGFydFZlcnRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFzdGFydFZlcnRleCkge1xuICAgICAgICAgICAgc3RhcnRWZXJ0ZXggPSBvZGRPdXQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXN0YXJ0VmVydGV4KSBzdGFydFZlcnRleCA9IGVsZXNbMF0uaWQoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHdhbGsgPSBmdW5jdGlvbiB3YWxrKHYpIHtcbiAgICAgICAgdmFyIGN1cnJlbnROb2RlID0gdjtcbiAgICAgICAgdmFyIHN1YnRvdXIgPSBbdl07XG4gICAgICAgIHZhciBhZGosIGFkalRhaWwsIGFkakhlYWQ7XG5cbiAgICAgICAgd2hpbGUgKG5vZGVzW2N1cnJlbnROb2RlXS5sZW5ndGgpIHtcbiAgICAgICAgICBhZGogPSBub2Rlc1tjdXJyZW50Tm9kZV0uc2hpZnQoKTtcbiAgICAgICAgICBhZGpUYWlsID0gZWRnZXNbYWRqXVswXTtcbiAgICAgICAgICBhZGpIZWFkID0gZWRnZXNbYWRqXVsxXTtcblxuICAgICAgICAgIGlmIChjdXJyZW50Tm9kZSAhPSBhZGpIZWFkKSB7XG4gICAgICAgICAgICBub2Rlc1thZGpIZWFkXSA9IG5vZGVzW2FkakhlYWRdLmZpbHRlcihmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICByZXR1cm4gZSAhPSBhZGo7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGN1cnJlbnROb2RlID0gYWRqSGVhZDtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFkaXJlY3RlZCAmJiBjdXJyZW50Tm9kZSAhPSBhZGpUYWlsKSB7XG4gICAgICAgICAgICBub2Rlc1thZGpUYWlsXSA9IG5vZGVzW2FkalRhaWxdLmZpbHRlcihmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICByZXR1cm4gZSAhPSBhZGo7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGN1cnJlbnROb2RlID0gYWRqVGFpbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzdWJ0b3VyLnVuc2hpZnQoYWRqKTtcbiAgICAgICAgICBzdWJ0b3VyLnVuc2hpZnQoY3VycmVudE5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN1YnRvdXI7XG4gICAgICB9O1xuXG4gICAgICB2YXIgdHJhaWwgPSBbXTtcbiAgICAgIHZhciBzdWJ0b3VyID0gW107XG4gICAgICBzdWJ0b3VyID0gd2FsayhzdGFydFZlcnRleCk7XG5cbiAgICAgIHdoaWxlIChzdWJ0b3VyLmxlbmd0aCAhPSAxKSB7XG4gICAgICAgIGlmIChub2Rlc1tzdWJ0b3VyWzBdXS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgIHRyYWlsLnVuc2hpZnQoZWxlcy5nZXRFbGVtZW50QnlJZChzdWJ0b3VyLnNoaWZ0KCkpKTtcbiAgICAgICAgICB0cmFpbC51bnNoaWZ0KGVsZXMuZ2V0RWxlbWVudEJ5SWQoc3VidG91ci5zaGlmdCgpKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3VidG91ciA9IHdhbGsoc3VidG91ci5zaGlmdCgpKS5jb25jYXQoc3VidG91cik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdHJhaWwudW5zaGlmdChlbGVzLmdldEVsZW1lbnRCeUlkKHN1YnRvdXIuc2hpZnQoKSkpOyAvLyBmaW5hbCBub2RlXG5cbiAgICAgIGZvciAodmFyIGQgaW4gbm9kZXMpIHtcbiAgICAgICAgaWYgKG5vZGVzW2RdLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVzdWx0LmZvdW5kID0gdHJ1ZTtcbiAgICAgIHJlc3VsdC50cmFpbCA9IHRoaXMuc3Bhd24odHJhaWwsIHRydWUpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGhvcGNyb2Z0VGFyamFuQmljb25uZWN0ZWQgPSBmdW5jdGlvbiBob3Bjcm9mdFRhcmphbkJpY29ubmVjdGVkKCkge1xuICAgIHZhciBlbGVzID0gdGhpcztcbiAgICB2YXIgbm9kZXMgPSB7fTtcbiAgICB2YXIgaWQgPSAwO1xuICAgIHZhciBlZGdlQ291bnQgPSAwO1xuICAgIHZhciBjb21wb25lbnRzID0gW107XG4gICAgdmFyIHN0YWNrID0gW107XG4gICAgdmFyIHZpc2l0ZWRFZGdlcyA9IHt9O1xuXG4gICAgdmFyIGJ1aWxkQ29tcG9uZW50ID0gZnVuY3Rpb24gYnVpbGRDb21wb25lbnQoeCwgeSkge1xuICAgICAgdmFyIGkgPSBzdGFjay5sZW5ndGggLSAxO1xuICAgICAgdmFyIGN1dHNldCA9IFtdO1xuICAgICAgdmFyIGNvbXBvbmVudCA9IGVsZXMuc3Bhd24oKTtcblxuICAgICAgd2hpbGUgKHN0YWNrW2ldLnggIT0geCB8fCBzdGFja1tpXS55ICE9IHkpIHtcbiAgICAgICAgY3V0c2V0LnB1c2goc3RhY2sucG9wKCkuZWRnZSk7XG4gICAgICAgIGktLTtcbiAgICAgIH1cblxuICAgICAgY3V0c2V0LnB1c2goc3RhY2sucG9wKCkuZWRnZSk7XG4gICAgICBjdXRzZXQuZm9yRWFjaChmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICB2YXIgY29ubmVjdGVkTm9kZXMgPSBlZGdlLmNvbm5lY3RlZE5vZGVzKCkuaW50ZXJzZWN0aW9uKGVsZXMpO1xuICAgICAgICBjb21wb25lbnQubWVyZ2UoZWRnZSk7XG4gICAgICAgIGNvbm5lY3RlZE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICB2YXIgbm9kZUlkID0gbm9kZS5pZCgpO1xuICAgICAgICAgIHZhciBjb25uZWN0ZWRFZGdlcyA9IG5vZGUuY29ubmVjdGVkRWRnZXMoKS5pbnRlcnNlY3Rpb24oZWxlcyk7XG4gICAgICAgICAgY29tcG9uZW50Lm1lcmdlKG5vZGUpO1xuXG4gICAgICAgICAgaWYgKCFub2Rlc1tub2RlSWRdLmN1dFZlcnRleCkge1xuICAgICAgICAgICAgY29tcG9uZW50Lm1lcmdlKGNvbm5lY3RlZEVkZ2VzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29tcG9uZW50Lm1lcmdlKGNvbm5lY3RlZEVkZ2VzLmZpbHRlcihmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICAgICAgICByZXR1cm4gZWRnZS5pc0xvb3AoKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBjb21wb25lbnRzLnB1c2goY29tcG9uZW50KTtcbiAgICB9O1xuXG4gICAgdmFyIGJpY29ubmVjdGVkU2VhcmNoID0gZnVuY3Rpb24gYmljb25uZWN0ZWRTZWFyY2gocm9vdCwgY3VycmVudE5vZGUsIHBhcmVudCkge1xuICAgICAgaWYgKHJvb3QgPT09IHBhcmVudCkgZWRnZUNvdW50ICs9IDE7XG4gICAgICBub2Rlc1tjdXJyZW50Tm9kZV0gPSB7XG4gICAgICAgIGlkOiBpZCxcbiAgICAgICAgbG93OiBpZCsrLFxuICAgICAgICBjdXRWZXJ0ZXg6IGZhbHNlXG4gICAgICB9O1xuICAgICAgdmFyIGVkZ2VzID0gZWxlcy5nZXRFbGVtZW50QnlJZChjdXJyZW50Tm9kZSkuY29ubmVjdGVkRWRnZXMoKS5pbnRlcnNlY3Rpb24oZWxlcyk7XG5cbiAgICAgIGlmIChlZGdlcy5zaXplKCkgPT09IDApIHtcbiAgICAgICAgY29tcG9uZW50cy5wdXNoKGVsZXMuc3Bhd24oZWxlcy5nZXRFbGVtZW50QnlJZChjdXJyZW50Tm9kZSkpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzb3VyY2VJZCwgdGFyZ2V0SWQsIG90aGVyTm9kZUlkLCBlZGdlSWQ7XG4gICAgICAgIGVkZ2VzLmZvckVhY2goZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgICAgICBzb3VyY2VJZCA9IGVkZ2Uuc291cmNlKCkuaWQoKTtcbiAgICAgICAgICB0YXJnZXRJZCA9IGVkZ2UudGFyZ2V0KCkuaWQoKTtcbiAgICAgICAgICBvdGhlck5vZGVJZCA9IHNvdXJjZUlkID09PSBjdXJyZW50Tm9kZSA/IHRhcmdldElkIDogc291cmNlSWQ7XG5cbiAgICAgICAgICBpZiAob3RoZXJOb2RlSWQgIT09IHBhcmVudCkge1xuICAgICAgICAgICAgZWRnZUlkID0gZWRnZS5pZCgpO1xuXG4gICAgICAgICAgICBpZiAoIXZpc2l0ZWRFZGdlc1tlZGdlSWRdKSB7XG4gICAgICAgICAgICAgIHZpc2l0ZWRFZGdlc1tlZGdlSWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgc3RhY2sucHVzaCh7XG4gICAgICAgICAgICAgICAgeDogY3VycmVudE5vZGUsXG4gICAgICAgICAgICAgICAgeTogb3RoZXJOb2RlSWQsXG4gICAgICAgICAgICAgICAgZWRnZTogZWRnZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCEob3RoZXJOb2RlSWQgaW4gbm9kZXMpKSB7XG4gICAgICAgICAgICAgIGJpY29ubmVjdGVkU2VhcmNoKHJvb3QsIG90aGVyTm9kZUlkLCBjdXJyZW50Tm9kZSk7XG4gICAgICAgICAgICAgIG5vZGVzW2N1cnJlbnROb2RlXS5sb3cgPSBNYXRoLm1pbihub2Rlc1tjdXJyZW50Tm9kZV0ubG93LCBub2Rlc1tvdGhlck5vZGVJZF0ubG93KTtcblxuICAgICAgICAgICAgICBpZiAobm9kZXNbY3VycmVudE5vZGVdLmlkIDw9IG5vZGVzW290aGVyTm9kZUlkXS5sb3cpIHtcbiAgICAgICAgICAgICAgICBub2Rlc1tjdXJyZW50Tm9kZV0uY3V0VmVydGV4ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBidWlsZENvbXBvbmVudChjdXJyZW50Tm9kZSwgb3RoZXJOb2RlSWQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBub2Rlc1tjdXJyZW50Tm9kZV0ubG93ID0gTWF0aC5taW4obm9kZXNbY3VycmVudE5vZGVdLmxvdywgbm9kZXNbb3RoZXJOb2RlSWRdLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBlbGVzLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgICB2YXIgbm9kZUlkID0gZWxlLmlkKCk7XG5cbiAgICAgICAgaWYgKCEobm9kZUlkIGluIG5vZGVzKSkge1xuICAgICAgICAgIGVkZ2VDb3VudCA9IDA7XG4gICAgICAgICAgYmljb25uZWN0ZWRTZWFyY2gobm9kZUlkLCBub2RlSWQpO1xuICAgICAgICAgIG5vZGVzW25vZGVJZF0uY3V0VmVydGV4ID0gZWRnZUNvdW50ID4gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBjdXRWZXJ0aWNlcyA9IE9iamVjdC5rZXlzKG5vZGVzKS5maWx0ZXIoZnVuY3Rpb24gKGlkKSB7XG4gICAgICByZXR1cm4gbm9kZXNbaWRdLmN1dFZlcnRleDtcbiAgICB9KS5tYXAoZnVuY3Rpb24gKGlkKSB7XG4gICAgICByZXR1cm4gZWxlcy5nZXRFbGVtZW50QnlJZChpZCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGN1dDogZWxlcy5zcGF3bihjdXRWZXJ0aWNlcyksXG4gICAgICBjb21wb25lbnRzOiBjb21wb25lbnRzXG4gICAgfTtcbiAgfTtcblxuICB2YXIgaG9wY3JvZnRUYXJqYW5CaWNvbm5lY3RlZCQxID0ge1xuICAgIGhvcGNyb2Z0VGFyamFuQmljb25uZWN0ZWQ6IGhvcGNyb2Z0VGFyamFuQmljb25uZWN0ZWQsXG4gICAgaHRiYzogaG9wY3JvZnRUYXJqYW5CaWNvbm5lY3RlZCxcbiAgICBodGI6IGhvcGNyb2Z0VGFyamFuQmljb25uZWN0ZWQsXG4gICAgaG9wY3JvZnRUYXJqYW5CaWNvbm5lY3RlZENvbXBvbmVudHM6IGhvcGNyb2Z0VGFyamFuQmljb25uZWN0ZWRcbiAgfTtcblxuICB2YXIgdGFyamFuU3Ryb25nbHlDb25uZWN0ZWQgPSBmdW5jdGlvbiB0YXJqYW5TdHJvbmdseUNvbm5lY3RlZCgpIHtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgdmFyIG5vZGVzID0ge307XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgY29tcG9uZW50cyA9IFtdO1xuICAgIHZhciBzdGFjayA9IFtdO1xuICAgIHZhciBjdXQgPSBlbGVzLnNwYXduKGVsZXMpO1xuXG4gICAgdmFyIHN0cm9uZ2x5Q29ubmVjdGVkU2VhcmNoID0gZnVuY3Rpb24gc3Ryb25nbHlDb25uZWN0ZWRTZWFyY2goc291cmNlTm9kZUlkKSB7XG4gICAgICBzdGFjay5wdXNoKHNvdXJjZU5vZGVJZCk7XG4gICAgICBub2Rlc1tzb3VyY2VOb2RlSWRdID0ge1xuICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgIGxvdzogaW5kZXgrKyxcbiAgICAgICAgZXhwbG9yZWQ6IGZhbHNlXG4gICAgICB9O1xuICAgICAgdmFyIGNvbm5lY3RlZEVkZ2VzID0gZWxlcy5nZXRFbGVtZW50QnlJZChzb3VyY2VOb2RlSWQpLmNvbm5lY3RlZEVkZ2VzKCkuaW50ZXJzZWN0aW9uKGVsZXMpO1xuICAgICAgY29ubmVjdGVkRWRnZXMuZm9yRWFjaChmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICB2YXIgdGFyZ2V0Tm9kZUlkID0gZWRnZS50YXJnZXQoKS5pZCgpO1xuXG4gICAgICAgIGlmICh0YXJnZXROb2RlSWQgIT09IHNvdXJjZU5vZGVJZCkge1xuICAgICAgICAgIGlmICghKHRhcmdldE5vZGVJZCBpbiBub2RlcykpIHtcbiAgICAgICAgICAgIHN0cm9uZ2x5Q29ubmVjdGVkU2VhcmNoKHRhcmdldE5vZGVJZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFub2Rlc1t0YXJnZXROb2RlSWRdLmV4cGxvcmVkKSB7XG4gICAgICAgICAgICBub2Rlc1tzb3VyY2VOb2RlSWRdLmxvdyA9IE1hdGgubWluKG5vZGVzW3NvdXJjZU5vZGVJZF0ubG93LCBub2Rlc1t0YXJnZXROb2RlSWRdLmxvdyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKG5vZGVzW3NvdXJjZU5vZGVJZF0uaW5kZXggPT09IG5vZGVzW3NvdXJjZU5vZGVJZF0ubG93KSB7XG4gICAgICAgIHZhciBjb21wb25lbnROb2RlcyA9IGVsZXMuc3Bhd24oKTtcblxuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgdmFyIG5vZGVJZCA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgIGNvbXBvbmVudE5vZGVzLm1lcmdlKGVsZXMuZ2V0RWxlbWVudEJ5SWQobm9kZUlkKSk7XG4gICAgICAgICAgbm9kZXNbbm9kZUlkXS5sb3cgPSBub2Rlc1tzb3VyY2VOb2RlSWRdLmluZGV4O1xuICAgICAgICAgIG5vZGVzW25vZGVJZF0uZXhwbG9yZWQgPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKG5vZGVJZCA9PT0gc291cmNlTm9kZUlkKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29tcG9uZW50RWRnZXMgPSBjb21wb25lbnROb2Rlcy5lZGdlc1dpdGgoY29tcG9uZW50Tm9kZXMpO1xuICAgICAgICB2YXIgY29tcG9uZW50ID0gY29tcG9uZW50Tm9kZXMubWVyZ2UoY29tcG9uZW50RWRnZXMpO1xuICAgICAgICBjb21wb25lbnRzLnB1c2goY29tcG9uZW50KTtcbiAgICAgICAgY3V0ID0gY3V0LmRpZmZlcmVuY2UoY29tcG9uZW50KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgIGlmIChlbGUuaXNOb2RlKCkpIHtcbiAgICAgICAgdmFyIG5vZGVJZCA9IGVsZS5pZCgpO1xuXG4gICAgICAgIGlmICghKG5vZGVJZCBpbiBub2RlcykpIHtcbiAgICAgICAgICBzdHJvbmdseUNvbm5lY3RlZFNlYXJjaChub2RlSWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGN1dDogY3V0LFxuICAgICAgY29tcG9uZW50czogY29tcG9uZW50c1xuICAgIH07XG4gIH07XG5cbiAgdmFyIHRhcmphblN0cm9uZ2x5Q29ubmVjdGVkJDEgPSB7XG4gICAgdGFyamFuU3Ryb25nbHlDb25uZWN0ZWQ6IHRhcmphblN0cm9uZ2x5Q29ubmVjdGVkLFxuICAgIHRzYzogdGFyamFuU3Ryb25nbHlDb25uZWN0ZWQsXG4gICAgdHNjYzogdGFyamFuU3Ryb25nbHlDb25uZWN0ZWQsXG4gICAgdGFyamFuU3Ryb25nbHlDb25uZWN0ZWRDb21wb25lbnRzOiB0YXJqYW5TdHJvbmdseUNvbm5lY3RlZFxuICB9O1xuXG4gIHZhciBlbGVzZm4kaiA9IHt9O1xuICBbZWxlc2ZuJHYsIGVsZXNmbiR1LCBlbGVzZm4kdCwgZWxlc2ZuJHMsIGVsZXNmbiRyLCBlbGVzZm4kcSwgZWxlc2ZuJHAsIGVsZXNmbiRvLCBlbGVzZm4kbiwgZWxlc2ZuJG0sIGVsZXNmbiRsLCBtYXJrb3ZDbHVzdGVyaW5nJDEsIGtDbHVzdGVyaW5nLCBoaWVyYXJjaGljYWxDbHVzdGVyaW5nJDEsIGFmZmluaXR5UHJvcGFnYXRpb24kMSwgZWxlc2ZuJGssIGhvcGNyb2Z0VGFyamFuQmljb25uZWN0ZWQkMSwgdGFyamFuU3Ryb25nbHlDb25uZWN0ZWQkMV0uZm9yRWFjaChmdW5jdGlvbiAocHJvcHMpIHtcbiAgICBleHRlbmQoZWxlc2ZuJGosIHByb3BzKTtcbiAgfSk7XG5cbiAgLyohXG4gIEVtYmVkZGFibGUgTWluaW11bSBTdHJpY3RseS1Db21wbGlhbnQgUHJvbWlzZXMvQSsgMS4xLjEgVGhlbmFibGVcbiAgQ29weXJpZ2h0IChjKSAyMDEzLTIwMTQgUmFsZiBTLiBFbmdlbHNjaGFsbCAoaHR0cDovL2VuZ2Vsc2NoYWxsLmNvbSlcbiAgTGljZW5zZWQgdW5kZXIgVGhlIE1JVCBMaWNlbnNlIChodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUKVxuICAqL1xuXG4gIC8qICBwcm9taXNlIHN0YXRlcyBbUHJvbWlzZXMvQSsgMi4xXSAgKi9cbiAgdmFyIFNUQVRFX1BFTkRJTkcgPSAwO1xuICAvKiAgW1Byb21pc2VzL0ErIDIuMS4xXSAgKi9cblxuICB2YXIgU1RBVEVfRlVMRklMTEVEID0gMTtcbiAgLyogIFtQcm9taXNlcy9BKyAyLjEuMl0gICovXG5cbiAgdmFyIFNUQVRFX1JFSkVDVEVEID0gMjtcbiAgLyogIFtQcm9taXNlcy9BKyAyLjEuM10gICovXG5cbiAgLyogIHByb21pc2Ugb2JqZWN0IGNvbnN0cnVjdG9yICAqL1xuXG4gIHZhciBhcGkgPSBmdW5jdGlvbiBhcGkoZXhlY3V0b3IpIHtcbiAgICAvKiAgb3B0aW9uYWxseSBzdXBwb3J0IG5vbi1jb25zdHJ1Y3Rvci9wbGFpbi1mdW5jdGlvbiBjYWxsICAqL1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBhcGkpKSByZXR1cm4gbmV3IGFwaShleGVjdXRvcik7XG4gICAgLyogIGluaXRpYWxpemUgb2JqZWN0ICAqL1xuXG4gICAgdGhpcy5pZCA9ICdUaGVuYWJsZS8xLjAuNyc7XG4gICAgdGhpcy5zdGF0ZSA9IFNUQVRFX1BFTkRJTkc7XG4gICAgLyogIGluaXRpYWwgc3RhdGUgICovXG5cbiAgICB0aGlzLmZ1bGZpbGxWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAvKiAgaW5pdGlhbCB2YWx1ZSAgKi9cblxuICAgIC8qICBbUHJvbWlzZXMvQSsgMS4zLCAyLjEuMi4yXSAgKi9cblxuICAgIHRoaXMucmVqZWN0UmVhc29uID0gdW5kZWZpbmVkO1xuICAgIC8qICBpbml0aWFsIHJlYXNvbiAqL1xuXG4gICAgLyogIFtQcm9taXNlcy9BKyAxLjUsIDIuMS4zLjJdICAqL1xuXG4gICAgdGhpcy5vbkZ1bGZpbGxlZCA9IFtdO1xuICAgIC8qICBpbml0aWFsIGhhbmRsZXJzICAqL1xuXG4gICAgdGhpcy5vblJlamVjdGVkID0gW107XG4gICAgLyogIGluaXRpYWwgaGFuZGxlcnMgICovXG5cbiAgICAvKiAgcHJvdmlkZSBvcHRpb25hbCBpbmZvcm1hdGlvbi1oaWRpbmcgcHJveHkgICovXG5cbiAgICB0aGlzLnByb3h5ID0ge1xuICAgICAgdGhlbjogdGhpcy50aGVuLmJpbmQodGhpcylcbiAgICB9O1xuICAgIC8qICBzdXBwb3J0IG9wdGlvbmFsIGV4ZWN1dG9yIGZ1bmN0aW9uICAqL1xuXG4gICAgaWYgKHR5cGVvZiBleGVjdXRvciA9PT0gJ2Z1bmN0aW9uJykgZXhlY3V0b3IuY2FsbCh0aGlzLCB0aGlzLmZ1bGZpbGwuYmluZCh0aGlzKSwgdGhpcy5yZWplY3QuYmluZCh0aGlzKSk7XG4gIH07XG4gIC8qICBwcm9taXNlIEFQSSBtZXRob2RzICAqL1xuXG5cbiAgYXBpLnByb3RvdHlwZSA9IHtcbiAgICAvKiAgcHJvbWlzZSByZXNvbHZpbmcgbWV0aG9kcyAgKi9cbiAgICBmdWxmaWxsOiBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7XG4gICAgICByZXR1cm4gZGVsaXZlcih0aGlzLCBTVEFURV9GVUxGSUxMRUQsICdmdWxmaWxsVmFsdWUnLCB2YWx1ZSk7XG4gICAgfSxcbiAgICByZWplY3Q6IGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGRlbGl2ZXIodGhpcywgU1RBVEVfUkVKRUNURUQsICdyZWplY3RSZWFzb24nLCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qICBcIlRoZSB0aGVuIE1ldGhvZFwiIFtQcm9taXNlcy9BKyAxLjEsIDEuMiwgMi4yXSAgKi9cbiAgICB0aGVuOiBmdW5jdGlvbiB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgICB2YXIgY3VyciA9IHRoaXM7XG4gICAgICB2YXIgbmV4dCA9IG5ldyBhcGkoKTtcbiAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjddICAqL1xuXG4gICAgICBjdXJyLm9uRnVsZmlsbGVkLnB1c2gocmVzb2x2ZXIob25GdWxmaWxsZWQsIG5leHQsICdmdWxmaWxsJykpO1xuICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjIuMi8yLjIuNl0gICovXG5cbiAgICAgIGN1cnIub25SZWplY3RlZC5wdXNoKHJlc29sdmVyKG9uUmVqZWN0ZWQsIG5leHQsICdyZWplY3QnKSk7XG4gICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMi4zLzIuMi42XSAgKi9cblxuICAgICAgZXhlY3V0ZShjdXJyKTtcbiAgICAgIHJldHVybiBuZXh0LnByb3h5O1xuICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjIuNywgMy4zXSAgKi9cbiAgICB9XG4gIH07XG4gIC8qICBkZWxpdmVyIGFuIGFjdGlvbiAgKi9cblxuICB2YXIgZGVsaXZlciA9IGZ1bmN0aW9uIGRlbGl2ZXIoY3Vyciwgc3RhdGUsIG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKGN1cnIuc3RhdGUgPT09IFNUQVRFX1BFTkRJTkcpIHtcbiAgICAgIGN1cnIuc3RhdGUgPSBzdGF0ZTtcbiAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4xLjIuMSwgMi4xLjMuMV0gICovXG5cbiAgICAgIGN1cnJbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4xLjIuMiwgMi4xLjMuMl0gICovXG5cbiAgICAgIGV4ZWN1dGUoY3Vycik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGN1cnI7XG4gIH07XG4gIC8qICBleGVjdXRlIGFsbCBoYW5kbGVycyAgKi9cblxuXG4gIHZhciBleGVjdXRlID0gZnVuY3Rpb24gZXhlY3V0ZShjdXJyKSB7XG4gICAgaWYgKGN1cnIuc3RhdGUgPT09IFNUQVRFX0ZVTEZJTExFRCkgZXhlY3V0ZV9oYW5kbGVycyhjdXJyLCAnb25GdWxmaWxsZWQnLCBjdXJyLmZ1bGZpbGxWYWx1ZSk7ZWxzZSBpZiAoY3Vyci5zdGF0ZSA9PT0gU1RBVEVfUkVKRUNURUQpIGV4ZWN1dGVfaGFuZGxlcnMoY3VyciwgJ29uUmVqZWN0ZWQnLCBjdXJyLnJlamVjdFJlYXNvbik7XG4gIH07XG4gIC8qICBleGVjdXRlIHBhcnRpY3VsYXIgc2V0IG9mIGhhbmRsZXJzICAqL1xuXG5cbiAgdmFyIGV4ZWN1dGVfaGFuZGxlcnMgPSBmdW5jdGlvbiBleGVjdXRlX2hhbmRsZXJzKGN1cnIsIG5hbWUsIHZhbHVlKSB7XG4gICAgLyogZ2xvYmFsIHNldEltbWVkaWF0ZTogdHJ1ZSAqL1xuXG4gICAgLyogZ2xvYmFsIHNldFRpbWVvdXQ6IHRydWUgKi9cblxuICAgIC8qICBzaG9ydC1jaXJjdWl0IHByb2Nlc3NpbmcgICovXG4gICAgaWYgKGN1cnJbbmFtZV0ubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgLyogIGl0ZXJhdGUgb3ZlciBhbGwgaGFuZGxlcnMsIGV4YWN0bHkgb25jZSAgKi9cblxuICAgIHZhciBoYW5kbGVycyA9IGN1cnJbbmFtZV07XG4gICAgY3VycltuYW1lXSA9IFtdO1xuICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjIuMywgMi4yLjMuM10gICovXG5cbiAgICB2YXIgZnVuYyA9IGZ1bmN0aW9uIGZ1bmMoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhhbmRsZXJzW2ldKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjVdICAqL1xuXG4gICAgfTtcbiAgICAvKiAgZXhlY3V0ZSBwcm9jZWR1cmUgYXN5bmNocm9ub3VzbHkgICovXG5cbiAgICAvKiAgW1Byb21pc2VzL0ErIDIuMi40LCAzLjFdICAqL1xuXG5cbiAgICBpZiAodHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJykgc2V0SW1tZWRpYXRlKGZ1bmMpO2Vsc2Ugc2V0VGltZW91dChmdW5jLCAwKTtcbiAgfTtcbiAgLyogIGdlbmVyYXRlIGEgcmVzb2x2ZXIgZnVuY3Rpb24gICovXG5cblxuICB2YXIgcmVzb2x2ZXIgPSBmdW5jdGlvbiByZXNvbHZlcihjYiwgbmV4dCwgbWV0aG9kKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjIuMSwgMi4yLjcuMywgMi4yLjcuNF0gICovXG4gICAgICAgIG5leHRbbWV0aG9kXS5jYWxsKG5leHQsIHZhbHVlKTtcbiAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjIuNy4zLCAyLjIuNy40XSAgKi9cbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVzdWx0ID0gY2IodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjIuMSwgMi4yLjMuMSwgMi4yLjUsIDMuMl0gICovXG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgbmV4dC5yZWplY3QoZSk7XG4gICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjIuNy4yXSAgKi9cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc29sdmUobmV4dCwgcmVzdWx0KTtcbiAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjIuNy4xXSAgKi9cbiAgICAgIH1cbiAgICB9O1xuICB9O1xuICAvKiAgXCJQcm9taXNlIFJlc29sdXRpb24gUHJvY2VkdXJlXCIgICovXG5cbiAgLyogIFtQcm9taXNlcy9BKyAyLjNdICAqL1xuXG5cbiAgdmFyIHJlc29sdmUgPSBmdW5jdGlvbiByZXNvbHZlKHByb21pc2UsIHgpIHtcbiAgICAvKiAgc2FuaXR5IGNoZWNrIGFyZ3VtZW50cyAgKi9cblxuICAgIC8qICBbUHJvbWlzZXMvQSsgMi4zLjFdICAqL1xuICAgIGlmIChwcm9taXNlID09PSB4IHx8IHByb21pc2UucHJveHkgPT09IHgpIHtcbiAgICAgIHByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IoJ2Nhbm5vdCByZXNvbHZlIHByb21pc2Ugd2l0aCBpdHNlbGYnKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8qICBzdXJnaWNhbGx5IGNoZWNrIGZvciBhIFwidGhlblwiIG1ldGhvZFxuICAgICAgKG1haW5seSB0byBqdXN0IGNhbGwgdGhlIFwiZ2V0dGVyXCIgb2YgXCJ0aGVuXCIgb25seSBvbmNlKSAgKi9cblxuXG4gICAgdmFyIHRoZW47XG5cbiAgICBpZiAoX3R5cGVvZih4KSA9PT0gJ29iamVjdCcgJiYgeCAhPT0gbnVsbCB8fCB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhlbiA9IHgudGhlbjtcbiAgICAgIH1cbiAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4zLjMuMSwgMy41XSAgKi9cbiAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHByb21pc2UucmVqZWN0KGUpO1xuICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjJdICAqL1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgLyogIGhhbmRsZSBvd24gVGhlbmFibGVzICAgIFtQcm9taXNlcy9BKyAyLjMuMl1cbiAgICAgIGFuZCBzaW1pbGFyIFwidGhlbmFibGVzXCIgW1Byb21pc2VzL0ErIDIuMy4zXSAgKi9cblxuXG4gICAgaWYgKHR5cGVvZiB0aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgcmVzb2x2ZWQgPSBmYWxzZTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLyogIGNhbGwgcmV0cmlldmVkIFwidGhlblwiIG1ldGhvZCAqL1xuXG4gICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4zLjMuM10gICovXG4gICAgICAgIHRoZW4uY2FsbCh4LFxuICAgICAgICAvKiAgcmVzb2x2ZVByb21pc2UgICovXG5cbiAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjMuMy4zLjFdICAqL1xuICAgICAgICBmdW5jdGlvbiAoeSkge1xuICAgICAgICAgIGlmIChyZXNvbHZlZCkgcmV0dXJuO1xuICAgICAgICAgIHJlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjMuM10gICovXG5cbiAgICAgICAgICBpZiAoeSA9PT0geClcbiAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMy42XSAgKi9cbiAgICAgICAgICAgIHByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IoJ2NpcmN1bGFyIHRoZW5hYmxlIGNoYWluJykpO2Vsc2UgcmVzb2x2ZShwcm9taXNlLCB5KTtcbiAgICAgICAgfSxcbiAgICAgICAgLyogIHJlamVjdFByb21pc2UgICovXG5cbiAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjMuMy4zLjJdICAqL1xuICAgICAgICBmdW5jdGlvbiAocikge1xuICAgICAgICAgIGlmIChyZXNvbHZlZCkgcmV0dXJuO1xuICAgICAgICAgIHJlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjMuM10gICovXG5cbiAgICAgICAgICBwcm9taXNlLnJlamVjdChyKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmICghcmVzb2x2ZWQpXG4gICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjMuMy4zLjNdICAqL1xuICAgICAgICAgIHByb21pc2UucmVqZWN0KGUpO1xuICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjMuNF0gICovXG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLyogIGhhbmRsZSBvdGhlciB2YWx1ZXMgICovXG5cblxuICAgIHByb21pc2UuZnVsZmlsbCh4KTtcbiAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy40LCAyLjMuMy40XSAgKi9cbiAgfTsgLy8gc28gd2UgYWx3YXlzIGhhdmUgUHJvbWlzZS5hbGwoKVxuXG5cbiAgYXBpLmFsbCA9IGZ1bmN0aW9uIChwcykge1xuICAgIHJldHVybiBuZXcgYXBpKGZ1bmN0aW9uIChyZXNvbHZlQWxsLCByZWplY3RBbGwpIHtcbiAgICAgIHZhciB2YWxzID0gbmV3IEFycmF5KHBzLmxlbmd0aCk7XG4gICAgICB2YXIgZG9uZUNvdW50ID0gMDtcblxuICAgICAgdmFyIGZ1bGZpbGwgPSBmdW5jdGlvbiBmdWxmaWxsKGksIHZhbCkge1xuICAgICAgICB2YWxzW2ldID0gdmFsO1xuICAgICAgICBkb25lQ291bnQrKztcblxuICAgICAgICBpZiAoZG9uZUNvdW50ID09PSBwcy5sZW5ndGgpIHtcbiAgICAgICAgICByZXNvbHZlQWxsKHZhbHMpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgIHZhciBwID0gcHNbaV07XG4gICAgICAgICAgdmFyIGlzUHJvbWlzZSA9IHAgIT0gbnVsbCAmJiBwLnRoZW4gIT0gbnVsbDtcblxuICAgICAgICAgIGlmIChpc1Byb21pc2UpIHtcbiAgICAgICAgICAgIHAudGhlbihmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgIGZ1bGZpbGwoaSwgdmFsKTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgcmVqZWN0QWxsKGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHZhbCA9IHA7XG4gICAgICAgICAgICBmdWxmaWxsKGksIHZhbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KShpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBhcGkucmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gbmV3IGFwaShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICByZXNvbHZlKHZhbCk7XG4gICAgfSk7XG4gIH07XG5cbiAgYXBpLnJlamVjdCA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gbmV3IGFwaShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICByZWplY3QodmFsKTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgUHJvbWlzZSQxID0gdHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnID8gUHJvbWlzZSA6IGFwaTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4gIHZhciBBbmltYXRpb24gPSBmdW5jdGlvbiBBbmltYXRpb24odGFyZ2V0LCBvcHRzLCBvcHRzMikge1xuICAgIHZhciBpc0NvcmUgPSBjb3JlKHRhcmdldCk7XG4gICAgdmFyIGlzRWxlID0gIWlzQ29yZTtcblxuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGUgPSBleHRlbmQoe1xuICAgICAgZHVyYXRpb246IDEwMDBcbiAgICB9LCBvcHRzLCBvcHRzMik7XG5cbiAgICBfcC50YXJnZXQgPSB0YXJnZXQ7XG4gICAgX3Auc3R5bGUgPSBfcC5zdHlsZSB8fCBfcC5jc3M7XG4gICAgX3Auc3RhcnRlZCA9IGZhbHNlO1xuICAgIF9wLnBsYXlpbmcgPSBmYWxzZTtcbiAgICBfcC5ob29rZWQgPSBmYWxzZTtcbiAgICBfcC5hcHBseWluZyA9IGZhbHNlO1xuICAgIF9wLnByb2dyZXNzID0gMDtcbiAgICBfcC5jb21wbGV0ZXMgPSBbXTtcbiAgICBfcC5mcmFtZXMgPSBbXTtcblxuICAgIGlmIChfcC5jb21wbGV0ZSAmJiBmbiQ2KF9wLmNvbXBsZXRlKSkge1xuICAgICAgX3AuY29tcGxldGVzLnB1c2goX3AuY29tcGxldGUpO1xuICAgIH1cblxuICAgIGlmIChpc0VsZSkge1xuICAgICAgdmFyIHBvcyA9IHRhcmdldC5wb3NpdGlvbigpO1xuICAgICAgX3Auc3RhcnRQb3NpdGlvbiA9IF9wLnN0YXJ0UG9zaXRpb24gfHwge1xuICAgICAgICB4OiBwb3MueCxcbiAgICAgICAgeTogcG9zLnlcbiAgICAgIH07XG4gICAgICBfcC5zdGFydFN0eWxlID0gX3Auc3RhcnRTdHlsZSB8fCB0YXJnZXQuY3koKS5zdHlsZSgpLmdldEFuaW1hdGlvblN0YXJ0U3R5bGUodGFyZ2V0LCBfcC5zdHlsZSk7XG4gICAgfVxuXG4gICAgaWYgKGlzQ29yZSkge1xuICAgICAgdmFyIHBhbiA9IHRhcmdldC5wYW4oKTtcbiAgICAgIF9wLnN0YXJ0UGFuID0ge1xuICAgICAgICB4OiBwYW4ueCxcbiAgICAgICAgeTogcGFuLnlcbiAgICAgIH07XG4gICAgICBfcC5zdGFydFpvb20gPSB0YXJnZXQuem9vbSgpO1xuICAgIH0gLy8gZm9yIGZ1dHVyZSB0aW1lbGluZS9hbmltYXRpb25zIGltcGxcblxuXG4gICAgdGhpcy5sZW5ndGggPSAxO1xuICAgIHRoaXNbMF0gPSB0aGlzO1xuICB9O1xuXG4gIHZhciBhbmlmbiA9IEFuaW1hdGlvbi5wcm90b3R5cGU7XG4gIGV4dGVuZChhbmlmbiwge1xuICAgIGluc3RhbmNlU3RyaW5nOiBmdW5jdGlvbiBpbnN0YW5jZVN0cmluZygpIHtcbiAgICAgIHJldHVybiAnYW5pbWF0aW9uJztcbiAgICB9LFxuICAgIGhvb2s6IGZ1bmN0aW9uIGhvb2soKSB7XG4gICAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuXG4gICAgICBpZiAoIV9wLmhvb2tlZCkge1xuICAgICAgICAvLyBhZGQgdG8gdGFyZ2V0J3MgYW5pbWF0aW9uIHF1ZXVlXG4gICAgICAgIHZhciBxO1xuICAgICAgICB2YXIgdEFuaSA9IF9wLnRhcmdldC5fcHJpdmF0ZS5hbmltYXRpb247XG5cbiAgICAgICAgaWYgKF9wLnF1ZXVlKSB7XG4gICAgICAgICAgcSA9IHRBbmkucXVldWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcSA9IHRBbmkuY3VycmVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIHEucHVzaCh0aGlzKTsgLy8gYWRkIHRvIHRoZSBhbmltYXRpb24gbG9vcCBwb29sXG5cbiAgICAgICAgaWYgKGVsZW1lbnRPckNvbGxlY3Rpb24oX3AudGFyZ2V0KSkge1xuICAgICAgICAgIF9wLnRhcmdldC5jeSgpLmFkZFRvQW5pbWF0aW9uUG9vbChfcC50YXJnZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3AuaG9va2VkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBwbGF5OiBmdW5jdGlvbiBwbGF5KCkge1xuICAgICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTsgLy8gYXV0b3Jld2luZFxuXG4gICAgICBpZiAoX3AucHJvZ3Jlc3MgPT09IDEpIHtcbiAgICAgICAgX3AucHJvZ3Jlc3MgPSAwO1xuICAgICAgfVxuXG4gICAgICBfcC5wbGF5aW5nID0gdHJ1ZTtcbiAgICAgIF9wLnN0YXJ0ZWQgPSBmYWxzZTsgLy8gbmVlZHMgdG8gYmUgc3RhcnRlZCBieSBhbmltYXRpb24gbG9vcFxuXG4gICAgICBfcC5zdG9wcGVkID0gZmFsc2U7XG4gICAgICB0aGlzLmhvb2soKTsgLy8gdGhlIGFuaW1hdGlvbiBsb29wIHdpbGwgc3RhcnQgdGhlIGFuaW1hdGlvbi4uLlxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHBsYXlpbmc6IGZ1bmN0aW9uIHBsYXlpbmcoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5wbGF5aW5nO1xuICAgIH0sXG4gICAgYXBwbHk6IGZ1bmN0aW9uIGFwcGx5KCkge1xuICAgICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICAgIF9wLmFwcGx5aW5nID0gdHJ1ZTtcbiAgICAgIF9wLnN0YXJ0ZWQgPSBmYWxzZTsgLy8gbmVlZHMgdG8gYmUgc3RhcnRlZCBieSBhbmltYXRpb24gbG9vcFxuXG4gICAgICBfcC5zdG9wcGVkID0gZmFsc2U7XG4gICAgICB0aGlzLmhvb2soKTsgLy8gdGhlIGFuaW1hdGlvbiBsb29wIHdpbGwgYXBwbHkgdGhlIGFuaW1hdGlvbiBhdCB0aGlzIHByb2dyZXNzXG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgYXBwbHlpbmc6IGZ1bmN0aW9uIGFwcGx5aW5nKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuYXBwbHlpbmc7XG4gICAgfSxcbiAgICBwYXVzZTogZnVuY3Rpb24gcGF1c2UoKSB7XG4gICAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgICAgX3AucGxheWluZyA9IGZhbHNlO1xuICAgICAgX3Auc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBzdG9wOiBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICAgIF9wLnBsYXlpbmcgPSBmYWxzZTtcbiAgICAgIF9wLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgIF9wLnN0b3BwZWQgPSB0cnVlOyAvLyB0byBiZSByZW1vdmVkIGZyb20gYW5pbWF0aW9uIHF1ZXVlc1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHJld2luZDogZnVuY3Rpb24gcmV3aW5kKCkge1xuICAgICAgcmV0dXJuIHRoaXMucHJvZ3Jlc3MoMCk7XG4gICAgfSxcbiAgICBmYXN0Zm9yd2FyZDogZnVuY3Rpb24gZmFzdGZvcndhcmQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9ncmVzcygxKTtcbiAgICB9LFxuICAgIHRpbWU6IGZ1bmN0aW9uIHRpbWUodCkge1xuICAgICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcblxuICAgICAgaWYgKHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gX3AucHJvZ3Jlc3MgKiBfcC5kdXJhdGlvbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb2dyZXNzKHQgLyBfcC5kdXJhdGlvbik7XG4gICAgICB9XG4gICAgfSxcbiAgICBwcm9ncmVzczogZnVuY3Rpb24gcHJvZ3Jlc3MocCkge1xuICAgICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICAgIHZhciB3YXNQbGF5aW5nID0gX3AucGxheWluZztcblxuICAgICAgaWYgKHAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gX3AucHJvZ3Jlc3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAod2FzUGxheWluZykge1xuICAgICAgICAgIHRoaXMucGF1c2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9wLnByb2dyZXNzID0gcDtcbiAgICAgICAgX3Auc3RhcnRlZCA9IGZhbHNlO1xuXG4gICAgICAgIGlmICh3YXNQbGF5aW5nKSB7XG4gICAgICAgICAgdGhpcy5wbGF5KCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBjb21wbGV0ZWQ6IGZ1bmN0aW9uIGNvbXBsZXRlZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnByb2dyZXNzID09PSAxO1xuICAgIH0sXG4gICAgcmV2ZXJzZTogZnVuY3Rpb24gcmV2ZXJzZSgpIHtcbiAgICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgICB2YXIgd2FzUGxheWluZyA9IF9wLnBsYXlpbmc7XG5cbiAgICAgIGlmICh3YXNQbGF5aW5nKSB7XG4gICAgICAgIHRoaXMucGF1c2UoKTtcbiAgICAgIH1cblxuICAgICAgX3AucHJvZ3Jlc3MgPSAxIC0gX3AucHJvZ3Jlc3M7XG4gICAgICBfcC5zdGFydGVkID0gZmFsc2U7XG5cbiAgICAgIHZhciBzd2FwID0gZnVuY3Rpb24gc3dhcChhLCBiKSB7XG4gICAgICAgIHZhciBfcGEgPSBfcFthXTtcblxuICAgICAgICBpZiAoX3BhID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBfcFthXSA9IF9wW2JdO1xuICAgICAgICBfcFtiXSA9IF9wYTtcbiAgICAgIH07XG5cbiAgICAgIHN3YXAoJ3pvb20nLCAnc3RhcnRab29tJyk7XG4gICAgICBzd2FwKCdwYW4nLCAnc3RhcnRQYW4nKTtcbiAgICAgIHN3YXAoJ3Bvc2l0aW9uJywgJ3N0YXJ0UG9zaXRpb24nKTsgLy8gc3dhcCBzdHlsZXNcblxuICAgICAgaWYgKF9wLnN0eWxlKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3Auc3R5bGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgcHJvcCA9IF9wLnN0eWxlW2ldO1xuICAgICAgICAgIHZhciBuYW1lID0gcHJvcC5uYW1lO1xuICAgICAgICAgIHZhciBzdGFydFN0eWxlUHJvcCA9IF9wLnN0YXJ0U3R5bGVbbmFtZV07XG4gICAgICAgICAgX3Auc3RhcnRTdHlsZVtuYW1lXSA9IHByb3A7XG4gICAgICAgICAgX3Auc3R5bGVbaV0gPSBzdGFydFN0eWxlUHJvcDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAod2FzUGxheWluZykge1xuICAgICAgICB0aGlzLnBsYXkoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBwcm9taXNlOiBmdW5jdGlvbiBwcm9taXNlKHR5cGUpIHtcbiAgICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgICB2YXIgYXJyO1xuXG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnZnJhbWUnOlxuICAgICAgICAgIGFyciA9IF9wLmZyYW1lcztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICBjYXNlICdjb21wbGV0ZSc6XG4gICAgICAgIGNhc2UgJ2NvbXBsZXRlZCc6XG4gICAgICAgICAgYXJyID0gX3AuY29tcGxldGVzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGFyci5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgYW5pZm4uY29tcGxldGUgPSBhbmlmbi5jb21wbGV0ZWQ7XG4gIGFuaWZuLnJ1biA9IGFuaWZuLnBsYXk7XG4gIGFuaWZuLnJ1bm5pbmcgPSBhbmlmbi5wbGF5aW5nO1xuXG4gIHZhciBkZWZpbmUkMyA9IHtcbiAgICBhbmltYXRlZDogZnVuY3Rpb24gYW5pbWF0ZWQoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gYW5pbWF0ZWRJbXBsKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBzZWxmSXNBcnJheUxpa2UgPSBzZWxmLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgYWxsID0gc2VsZklzQXJyYXlMaWtlID8gc2VsZiA6IFtzZWxmXTsgLy8gcHV0IGluIGFycmF5IGlmIG5vdCBhcnJheS1saWtlXG5cbiAgICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeSB8fCB0aGlzO1xuXG4gICAgICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZWxlID0gYWxsWzBdO1xuXG4gICAgICAgIGlmIChlbGUpIHtcbiAgICAgICAgICByZXR1cm4gZWxlLl9wcml2YXRlLmFuaW1hdGlvbi5jdXJyZW50Lmxlbmd0aCA+IDA7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSxcbiAgICAvLyBhbmltYXRlZFxuICAgIGNsZWFyUXVldWU6IGZ1bmN0aW9uIGNsZWFyUXVldWUoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gY2xlYXJRdWV1ZUltcGwoKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHNlbGZJc0FycmF5TGlrZSA9IHNlbGYubGVuZ3RoICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogW3NlbGZdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcblxuICAgICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5IHx8IHRoaXM7XG5cbiAgICAgICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZWxlID0gYWxsW2ldO1xuICAgICAgICAgIGVsZS5fcHJpdmF0ZS5hbmltYXRpb24ucXVldWUgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcbiAgICB9LFxuICAgIC8vIGNsZWFyUXVldWVcbiAgICBkZWxheTogZnVuY3Rpb24gZGVsYXkoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gZGVsYXlJbXBsKHRpbWUsIGNvbXBsZXRlKSB7XG4gICAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3kgfHwgdGhpcztcblxuICAgICAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5hbmltYXRlKHtcbiAgICAgICAgICBkZWxheTogdGltZSxcbiAgICAgICAgICBkdXJhdGlvbjogdGltZSxcbiAgICAgICAgICBjb21wbGV0ZTogY29tcGxldGVcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH0sXG4gICAgLy8gZGVsYXlcbiAgICBkZWxheUFuaW1hdGlvbjogZnVuY3Rpb24gZGVsYXlBbmltYXRpb24oKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gZGVsYXlBbmltYXRpb25JbXBsKHRpbWUsIGNvbXBsZXRlKSB7XG4gICAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3kgfHwgdGhpcztcblxuICAgICAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5hbmltYXRpb24oe1xuICAgICAgICAgIGRlbGF5OiB0aW1lLFxuICAgICAgICAgIGR1cmF0aW9uOiB0aW1lLFxuICAgICAgICAgIGNvbXBsZXRlOiBjb21wbGV0ZVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfSxcbiAgICAvLyBkZWxheVxuICAgIGFuaW1hdGlvbjogZnVuY3Rpb24gYW5pbWF0aW9uKCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGFuaW1hdGlvbkltcGwocHJvcGVydGllcywgcGFyYW1zKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHNlbGZJc0FycmF5TGlrZSA9IHNlbGYubGVuZ3RoICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogW3NlbGZdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcblxuICAgICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5IHx8IHRoaXM7XG4gICAgICAgIHZhciBpc0NvcmUgPSAhc2VsZklzQXJyYXlMaWtlO1xuICAgICAgICB2YXIgaXNFbGVzID0gIWlzQ29yZTtcblxuICAgICAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3R5bGUgPSBjeS5zdHlsZSgpO1xuICAgICAgICBwcm9wZXJ0aWVzID0gZXh0ZW5kKHt9LCBwcm9wZXJ0aWVzLCBwYXJhbXMpO1xuICAgICAgICB2YXIgcHJvcGVydGllc0VtcHR5ID0gT2JqZWN0LmtleXMocHJvcGVydGllcykubGVuZ3RoID09PSAwO1xuXG4gICAgICAgIGlmIChwcm9wZXJ0aWVzRW1wdHkpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEFuaW1hdGlvbihhbGxbMF0sIHByb3BlcnRpZXMpOyAvLyBub3RoaW5nIHRvIGFuaW1hdGVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9wZXJ0aWVzLmR1cmF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwcm9wZXJ0aWVzLmR1cmF0aW9uID0gNDAwO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChwcm9wZXJ0aWVzLmR1cmF0aW9uKSB7XG4gICAgICAgICAgY2FzZSAnc2xvdyc6XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLmR1cmF0aW9uID0gNjAwO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdmYXN0JzpcbiAgICAgICAgICAgIHByb3BlcnRpZXMuZHVyYXRpb24gPSAyMDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0VsZXMpIHtcbiAgICAgICAgICBwcm9wZXJ0aWVzLnN0eWxlID0gc3R5bGUuZ2V0UHJvcHNMaXN0KHByb3BlcnRpZXMuc3R5bGUgfHwgcHJvcGVydGllcy5jc3MpO1xuICAgICAgICAgIHByb3BlcnRpZXMuY3NzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRWxlcyAmJiBwcm9wZXJ0aWVzLnJlbmRlcmVkUG9zaXRpb24gIT0gbnVsbCkge1xuICAgICAgICAgIHZhciBycG9zID0gcHJvcGVydGllcy5yZW5kZXJlZFBvc2l0aW9uO1xuICAgICAgICAgIHZhciBwYW4gPSBjeS5wYW4oKTtcbiAgICAgICAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcbiAgICAgICAgICBwcm9wZXJ0aWVzLnBvc2l0aW9uID0gcmVuZGVyZWRUb01vZGVsUG9zaXRpb24ocnBvcywgem9vbSwgcGFuKTtcbiAgICAgICAgfSAvLyBvdmVycmlkZSBwYW4gdy8gcGFuQnkgaWYgc2V0XG5cblxuICAgICAgICBpZiAoaXNDb3JlICYmIHByb3BlcnRpZXMucGFuQnkgIT0gbnVsbCkge1xuICAgICAgICAgIHZhciBwYW5CeSA9IHByb3BlcnRpZXMucGFuQnk7XG4gICAgICAgICAgdmFyIGN5UGFuID0gY3kucGFuKCk7XG4gICAgICAgICAgcHJvcGVydGllcy5wYW4gPSB7XG4gICAgICAgICAgICB4OiBjeVBhbi54ICsgcGFuQnkueCxcbiAgICAgICAgICAgIHk6IGN5UGFuLnkgKyBwYW5CeS55XG4gICAgICAgICAgfTtcbiAgICAgICAgfSAvLyBvdmVycmlkZSBwYW4gdy8gY2VudGVyIGlmIHNldFxuXG5cbiAgICAgICAgdmFyIGNlbnRlciA9IHByb3BlcnRpZXMuY2VudGVyIHx8IHByb3BlcnRpZXMuY2VudHJlO1xuXG4gICAgICAgIGlmIChpc0NvcmUgJiYgY2VudGVyICE9IG51bGwpIHtcbiAgICAgICAgICB2YXIgY2VudGVyUGFuID0gY3kuZ2V0Q2VudGVyUGFuKGNlbnRlci5lbGVzLCBwcm9wZXJ0aWVzLnpvb20pO1xuXG4gICAgICAgICAgaWYgKGNlbnRlclBhbiAhPSBudWxsKSB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLnBhbiA9IGNlbnRlclBhbjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gb3ZlcnJpZGUgcGFuICYgem9vbSB3LyBmaXQgaWYgc2V0XG5cblxuICAgICAgICBpZiAoaXNDb3JlICYmIHByb3BlcnRpZXMuZml0ICE9IG51bGwpIHtcbiAgICAgICAgICB2YXIgZml0ID0gcHJvcGVydGllcy5maXQ7XG4gICAgICAgICAgdmFyIGZpdFZwID0gY3kuZ2V0Rml0Vmlld3BvcnQoZml0LmVsZXMgfHwgZml0LmJvdW5kaW5nQm94LCBmaXQucGFkZGluZyk7XG5cbiAgICAgICAgICBpZiAoZml0VnAgIT0gbnVsbCkge1xuICAgICAgICAgICAgcHJvcGVydGllcy5wYW4gPSBmaXRWcC5wYW47XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLnpvb20gPSBmaXRWcC56b29tO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBvdmVycmlkZSB6b29tICgmIHBvdGVudGlhbGx5IHBhbikgdy8gem9vbSBvYmogaWYgc2V0XG5cblxuICAgICAgICBpZiAoaXNDb3JlICYmIHBsYWluT2JqZWN0KHByb3BlcnRpZXMuem9vbSkpIHtcbiAgICAgICAgICB2YXIgdnAgPSBjeS5nZXRab29tZWRWaWV3cG9ydChwcm9wZXJ0aWVzLnpvb20pO1xuXG4gICAgICAgICAgaWYgKHZwICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh2cC56b29tZWQpIHtcbiAgICAgICAgICAgICAgcHJvcGVydGllcy56b29tID0gdnAuem9vbTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHZwLnBhbm5lZCkge1xuICAgICAgICAgICAgICBwcm9wZXJ0aWVzLnBhbiA9IHZwLnBhbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvcGVydGllcy56b29tID0gbnVsbDsgLy8gYW4gaW5hdmFsaWQgem9vbSAoZS5nLiBubyBkZWx0YSkgZ2V0cyBhdXRvbWF0aWNhbGx5IGRlc3Ryb3llZFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgQW5pbWF0aW9uKGFsbFswXSwgcHJvcGVydGllcyk7XG4gICAgICB9O1xuICAgIH0sXG4gICAgLy8gYW5pbWF0ZVxuICAgIGFuaW1hdGU6IGZ1bmN0aW9uIGFuaW1hdGUoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gYW5pbWF0ZUltcGwocHJvcGVydGllcywgcGFyYW1zKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHNlbGZJc0FycmF5TGlrZSA9IHNlbGYubGVuZ3RoICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogW3NlbGZdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcblxuICAgICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5IHx8IHRoaXM7XG5cbiAgICAgICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcmFtcykge1xuICAgICAgICAgIHByb3BlcnRpZXMgPSBleHRlbmQoe30sIHByb3BlcnRpZXMsIHBhcmFtcyk7XG4gICAgICAgIH0gLy8gbWFudWFsbHkgaG9vayBhbmQgcnVuIHRoZSBhbmltYXRpb25cblxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVsZSA9IGFsbFtpXTtcbiAgICAgICAgICB2YXIgcXVldWUgPSBlbGUuYW5pbWF0ZWQoKSAmJiAocHJvcGVydGllcy5xdWV1ZSA9PT0gdW5kZWZpbmVkIHx8IHByb3BlcnRpZXMucXVldWUpO1xuICAgICAgICAgIHZhciBhbmkgPSBlbGUuYW5pbWF0aW9uKHByb3BlcnRpZXMsIHF1ZXVlID8ge1xuICAgICAgICAgICAgcXVldWU6IHRydWVcbiAgICAgICAgICB9IDogdW5kZWZpbmVkKTtcbiAgICAgICAgICBhbmkucGxheSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgICB9O1xuICAgIH0sXG4gICAgLy8gYW5pbWF0ZVxuICAgIHN0b3A6IGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gc3RvcEltcGwoY2xlYXJRdWV1ZSwganVtcFRvRW5kKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHNlbGZJc0FycmF5TGlrZSA9IHNlbGYubGVuZ3RoICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogW3NlbGZdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcblxuICAgICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5IHx8IHRoaXM7XG5cbiAgICAgICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZWxlID0gYWxsW2ldO1xuICAgICAgICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICAgICAgICB2YXIgYW5pcyA9IF9wLmFuaW1hdGlvbi5jdXJyZW50O1xuXG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBhbmlzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgYW5pID0gYW5pc1tqXTtcbiAgICAgICAgICAgIHZhciBhbmlfcCA9IGFuaS5fcHJpdmF0ZTtcblxuICAgICAgICAgICAgaWYgKGp1bXBUb0VuZCkge1xuICAgICAgICAgICAgICAvLyBuZXh0IGl0ZXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uIGxvb3AsIHRoZSBhbmltYXRpb25cbiAgICAgICAgICAgICAgLy8gd2lsbCBnbyBzdHJhaWdodCB0byB0aGUgZW5kIGFuZCBiZSByZW1vdmVkXG4gICAgICAgICAgICAgIGFuaV9wLmR1cmF0aW9uID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIGNsZWFyIHRoZSBxdWV1ZSBvZiBmdXR1cmUgYW5pbWF0aW9uc1xuXG5cbiAgICAgICAgICBpZiAoY2xlYXJRdWV1ZSkge1xuICAgICAgICAgICAgX3AuYW5pbWF0aW9uLnF1ZXVlID0gW107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFqdW1wVG9FbmQpIHtcbiAgICAgICAgICAgIF9wLmFuaW1hdGlvbi5jdXJyZW50ID0gW107XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIHdlIGhhdmUgdG8gbm90aWZ5ICh0aGUgYW5pbWF0aW9uIGxvb3AgZG9lc24ndCBkbyBpdCBmb3IgdXMgb24gYHN0b3BgKVxuXG5cbiAgICAgICAgY3kubm90aWZ5KCdkcmF3Jyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcbiAgICB9IC8vIHN0b3BcblxuICB9OyAvLyBkZWZpbmVcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgMC4xLjBcbiAgICogQGNhdGVnb3J5IExhbmdcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICpcbiAgICogXy5pc0FycmF5KCdhYmMnKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICpcbiAgICogXy5pc0FycmF5KF8ubm9vcCk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqL1xuICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbiAgdmFyIGlzQXJyYXlfMSA9IGlzQXJyYXk7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xuICB2YXIgcmVJc0RlZXBQcm9wID0gL1xcLnxcXFsoPzpbXltcXF1dKnwoW1wiJ10pKD86KD8hXFwxKVteXFxcXF18XFxcXC4pKj9cXDEpXFxdLyxcbiAgICAgIHJlSXNQbGFpblByb3AgPSAvXlxcdyokLztcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lIGFuZCBub3QgYSBwcm9wZXJ0eSBwYXRoLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBpc0tleSh2YWx1ZSwgb2JqZWN0KSB7XG4gICAgaWYgKGlzQXJyYXlfMSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgaWYgKHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJyB8fFxuICAgICAgICB2YWx1ZSA9PSBudWxsIHx8IGlzU3ltYm9sXzEodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlSXNQbGFpblByb3AudGVzdCh2YWx1ZSkgfHwgIXJlSXNEZWVwUHJvcC50ZXN0KHZhbHVlKSB8fFxuICAgICAgKG9iamVjdCAhPSBudWxsICYmIHZhbHVlIGluIE9iamVjdChvYmplY3QpKTtcbiAgfVxuXG4gIHZhciBfaXNLZXkgPSBpc0tleTtcblxuICAvKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG4gIHZhciBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyxcbiAgICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICAgIHByb3h5VGFnID0gJ1tvYmplY3QgUHJveHldJztcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSAwLjEuMFxuICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLmlzRnVuY3Rpb24oXyk7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICovXG4gIGZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgICBpZiAoIWlzT2JqZWN0XzEodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAgIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICAgIHZhciB0YWcgPSBfYmFzZUdldFRhZyh2YWx1ZSk7XG4gICAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbiAgfVxuXG4gIHZhciBpc0Z1bmN0aW9uXzEgPSBpc0Z1bmN0aW9uO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbiAgdmFyIGNvcmVKc0RhdGEgPSBfcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbiAgdmFyIF9jb3JlSnNEYXRhID0gY29yZUpzRGF0YTtcblxuICAvKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xuICB2YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhfY29yZUpzRGF0YSAmJiBfY29yZUpzRGF0YS5rZXlzICYmIF9jb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICAgIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcbiAgfSgpKTtcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICAgIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG4gIH1cblxuICB2YXIgX2lzTWFza2VkID0gaXNNYXNrZWQ7XG5cbiAgLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuICB2YXIgZnVuY1Byb3RvJDEgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbiAgLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xuICB2YXIgZnVuY1RvU3RyaW5nJDEgPSBmdW5jUHJvdG8kMS50b1N0cmluZztcblxuICAvKipcbiAgICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gICAqL1xuICBmdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gICAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZyQxLmNhbGwoZnVuYyk7XG4gICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgICAgfSBjYXRjaCAoZSkge31cbiAgICB9XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgdmFyIF90b1NvdXJjZSA9IHRvU291cmNlO1xuXG4gIC8qKlxuICAgKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gICAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICAgKi9cbiAgdmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcblxuICAvKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG4gIHZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4gIC8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbiAgdmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICAgIG9iamVjdFByb3RvJDMgPSBPYmplY3QucHJvdG90eXBlO1xuXG4gIC8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbiAgdmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuICAvKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbiAgdmFyIGhhc093blByb3BlcnR5JDMgPSBvYmplY3RQcm90byQzLmhhc093blByb3BlcnR5O1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG4gIHZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gICAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkkMykucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAgIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuICApO1xuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hdGl2ZWAgd2l0aG91dCBiYWQgc2hpbSBjaGVja3MuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAgICogIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICAgIGlmICghaXNPYmplY3RfMSh2YWx1ZSkgfHwgX2lzTWFza2VkKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb25fMSh2YWx1ZSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICAgIHJldHVybiBwYXR0ZXJuLnRlc3QoX3RvU291cmNlKHZhbHVlKSk7XG4gIH1cblxuICB2YXIgX2Jhc2VJc05hdGl2ZSA9IGJhc2VJc05hdGl2ZTtcblxuICAvKipcbiAgICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0VmFsdWUkMShvYmplY3QsIGtleSkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9XG5cbiAgdmFyIF9nZXRWYWx1ZSA9IGdldFZhbHVlJDE7XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICovXG4gIGZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICAgIHZhciB2YWx1ZSA9IF9nZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gICAgcmV0dXJuIF9iYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG4gIH1cblxuICB2YXIgX2dldE5hdGl2ZSA9IGdldE5hdGl2ZTtcblxuICAvKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG4gIHZhciBuYXRpdmVDcmVhdGUgPSBfZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG4gIHZhciBfbmF0aXZlQ3JlYXRlID0gbmF0aXZlQ3JlYXRlO1xuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBoYXNoLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbmFtZSBjbGVhclxuICAgKiBAbWVtYmVyT2YgSGFzaFxuICAgKi9cbiAgZnVuY3Rpb24gaGFzaENsZWFyKCkge1xuICAgIHRoaXMuX19kYXRhX18gPSBfbmF0aXZlQ3JlYXRlID8gX25hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICAgIHRoaXMuc2l6ZSA9IDA7XG4gIH1cblxuICB2YXIgX2hhc2hDbGVhciA9IGhhc2hDbGVhcjtcblxuICAvKipcbiAgICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBuYW1lIGRlbGV0ZVxuICAgKiBAbWVtYmVyT2YgSGFzaFxuICAgKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICAgIHZhciByZXN1bHQgPSB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gICAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgX2hhc2hEZWxldGUgPSBoYXNoRGVsZXRlO1xuXG4gIC8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbiAgdmFyIEhBU0hfVU5ERUZJTkVEJDEgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbiAgLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuICB2YXIgb2JqZWN0UHJvdG8kMiA9IE9iamVjdC5wcm90b3R5cGU7XG5cbiAgLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG4gIHZhciBoYXNPd25Qcm9wZXJ0eSQyID0gb2JqZWN0UHJvdG8kMi5oYXNPd25Qcm9wZXJ0eTtcblxuICAvKipcbiAgICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBuYW1lIGdldFxuICAgKiBAbWVtYmVyT2YgSGFzaFxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICAgKi9cbiAgZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gICAgaWYgKF9uYXRpdmVDcmVhdGUpIHtcbiAgICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCQxID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gaGFzT3duUHJvcGVydHkkMi5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG4gIH1cblxuICB2YXIgX2hhc2hHZXQgPSBoYXNoR2V0O1xuXG4gIC8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbiAgdmFyIG9iamVjdFByb3RvJDEgPSBPYmplY3QucHJvdG90eXBlO1xuXG4gIC8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xuICB2YXIgaGFzT3duUHJvcGVydHkkMSA9IG9iamVjdFByb3RvJDEuaGFzT3duUHJvcGVydHk7XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG5hbWUgaGFzXG4gICAqIEBtZW1iZXJPZiBIYXNoXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgICByZXR1cm4gX25hdGl2ZUNyZWF0ZSA/IChkYXRhW2tleV0gIT09IHVuZGVmaW5lZCkgOiBoYXNPd25Qcm9wZXJ0eSQxLmNhbGwoZGF0YSwga2V5KTtcbiAgfVxuXG4gIHZhciBfaGFzaEhhcyA9IGhhc2hIYXM7XG5cbiAgLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xuICB2YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG5hbWUgc2V0XG4gICAqIEBtZW1iZXJPZiBIYXNoXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gICAqL1xuICBmdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gICAgdGhpcy5zaXplICs9IHRoaXMuaGFzKGtleSkgPyAwIDogMTtcbiAgICBkYXRhW2tleV0gPSAoX25hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB2YXIgX2hhc2hTZXQgPSBoYXNoU2V0O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAgICovXG4gIGZ1bmN0aW9uIEhhc2goZW50cmllcykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgICB0aGlzLmNsZWFyKCk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgICB9XG4gIH1cblxuICAvLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG4gIEhhc2gucHJvdG90eXBlLmNsZWFyID0gX2hhc2hDbGVhcjtcbiAgSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gX2hhc2hEZWxldGU7XG4gIEhhc2gucHJvdG90eXBlLmdldCA9IF9oYXNoR2V0O1xuICBIYXNoLnByb3RvdHlwZS5oYXMgPSBfaGFzaEhhcztcbiAgSGFzaC5wcm90b3R5cGUuc2V0ID0gX2hhc2hTZXQ7XG5cbiAgdmFyIF9IYXNoID0gSGFzaDtcblxuICAvKipcbiAgICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG5hbWUgY2xlYXJcbiAgICogQG1lbWJlck9mIExpc3RDYWNoZVxuICAgKi9cbiAgZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gICAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICAgIHRoaXMuc2l6ZSA9IDA7XG4gIH1cblxuICB2YXIgX2xpc3RDYWNoZUNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG5cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGFcbiAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDQuMC4wXG4gICAqIEBjYXRlZ29yeSBMYW5nXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICAgKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICAgKlxuICAgKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKlxuICAgKiBfLmVxKCdhJywgJ2EnKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKlxuICAgKiBfLmVxKE5hTiwgTmFOKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKi9cbiAgZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG4gIH1cblxuICB2YXIgZXFfMSA9IGVxO1xuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICBpZiAoZXFfMShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIHZhciBfYXNzb2NJbmRleE9mID0gYXNzb2NJbmRleE9mO1xuXG4gIC8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbiAgdmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbiAgLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG4gIHZhciBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZTtcblxuICAvKipcbiAgICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBuYW1lIGRlbGV0ZVxuICAgKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgICBpbmRleCA9IF9hc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgICBkYXRhLnBvcCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gICAgfVxuICAgIC0tdGhpcy5zaXplO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIF9saXN0Q2FjaGVEZWxldGUgPSBsaXN0Q2FjaGVEZWxldGU7XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbmFtZSBnZXRcbiAgICogQG1lbWJlck9mIExpc3RDYWNoZVxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICAgKi9cbiAgZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgICAgaW5kZXggPSBfYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG4gIH1cblxuICB2YXIgX2xpc3RDYWNoZUdldCA9IGxpc3RDYWNoZUdldDtcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbmFtZSBoYXNcbiAgICogQG1lbWJlck9mIExpc3RDYWNoZVxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuICAgIHJldHVybiBfYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbiAgfVxuXG4gIHZhciBfbGlzdENhY2hlSGFzID0gbGlzdENhY2hlSGFzO1xuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBuYW1lIHNldFxuICAgKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gICAqL1xuICBmdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgICAgaW5kZXggPSBfYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICArK3RoaXMuc2l6ZTtcbiAgICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHZhciBfbGlzdENhY2hlU2V0ID0gbGlzdENhY2hlU2V0O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gICAqL1xuICBmdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgICB0aGlzLmNsZWFyKCk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgICB9XG4gIH1cblxuICAvLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbiAgTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IF9saXN0Q2FjaGVDbGVhcjtcbiAgTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBfbGlzdENhY2hlRGVsZXRlO1xuICBMaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IF9saXN0Q2FjaGVHZXQ7XG4gIExpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gX2xpc3RDYWNoZUhhcztcbiAgTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBfbGlzdENhY2hlU2V0O1xuXG4gIHZhciBfTGlzdENhY2hlID0gTGlzdENhY2hlO1xuXG4gIC8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbiAgdmFyIE1hcCQxID0gX2dldE5hdGl2ZShfcm9vdCwgJ01hcCcpO1xuXG4gIHZhciBfTWFwID0gTWFwJDE7XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG5hbWUgY2xlYXJcbiAgICogQG1lbWJlck9mIE1hcENhY2hlXG4gICAqL1xuICBmdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAgICdoYXNoJzogbmV3IF9IYXNoLFxuICAgICAgJ21hcCc6IG5ldyAoX01hcCB8fCBfTGlzdENhY2hlKSxcbiAgICAgICdzdHJpbmcnOiBuZXcgX0hhc2hcbiAgICB9O1xuICB9XG5cbiAgdmFyIF9tYXBDYWNoZUNsZWFyID0gbWFwQ2FjaGVDbGVhcjtcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICByZXR1cm4gKHR5cGUgPT0gJ3N0cmluZycgfHwgdHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nKVxuICAgICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgICAgOiAodmFsdWUgPT09IG51bGwpO1xuICB9XG5cbiAgdmFyIF9pc0tleWFibGUgPSBpc0tleWFibGU7XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHJlZmVyZW5jZSBrZXkuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAgICovXG4gIGZ1bmN0aW9uIGdldE1hcERhdGEobWFwLCBrZXkpIHtcbiAgICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgICByZXR1cm4gX2lzS2V5YWJsZShrZXkpXG4gICAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgICAgOiBkYXRhLm1hcDtcbiAgfVxuXG4gIHZhciBfZ2V0TWFwRGF0YSA9IGdldE1hcERhdGE7XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBuYW1lIGRlbGV0ZVxuICAgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICAgIHZhciByZXN1bHQgPSBfZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xuICAgIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIF9tYXBDYWNoZURlbGV0ZSA9IG1hcENhY2hlRGVsZXRlO1xuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbmFtZSBnZXRcbiAgICogQG1lbWJlck9mIE1hcENhY2hlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gICAqL1xuICBmdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgICByZXR1cm4gX2dldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbiAgfVxuXG4gIHZhciBfbWFwQ2FjaGVHZXQgPSBtYXBDYWNoZUdldDtcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBuYW1lIGhhc1xuICAgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICAgIHJldHVybiBfZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xuICB9XG5cbiAgdmFyIF9tYXBDYWNoZUhhcyA9IG1hcENhY2hlSGFzO1xuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG5hbWUgc2V0XG4gICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gICAqL1xuICBmdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gICAgdmFyIGRhdGEgPSBfZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLFxuICAgICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gICAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgdGhpcy5zaXplICs9IGRhdGEuc2l6ZSA9PSBzaXplID8gMCA6IDE7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB2YXIgX21hcENhY2hlU2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICAgKi9cbiAgZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgICB0aGlzLmNsZWFyKCk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgICB9XG4gIH1cblxuICAvLyBBZGQgbWV0aG9kcyB0byBgTWFwQ2FjaGVgLlxuICBNYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBfbWFwQ2FjaGVDbGVhcjtcbiAgTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IF9tYXBDYWNoZURlbGV0ZTtcbiAgTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IF9tYXBDYWNoZUdldDtcbiAgTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IF9tYXBDYWNoZUhhcztcbiAgTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IF9tYXBDYWNoZVNldDtcblxuICB2YXIgX01hcENhY2hlID0gTWFwQ2FjaGU7XG5cbiAgLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xuICB2YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBtZW1vaXplcyB0aGUgcmVzdWx0IG9mIGBmdW5jYC4gSWYgYHJlc29sdmVyYCBpc1xuICAgKiBwcm92aWRlZCwgaXQgZGV0ZXJtaW5lcyB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHQgYmFzZWQgb24gdGhlXG4gICAqIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZSBmaXJzdCBhcmd1bWVudFxuICAgKiBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24gaXMgdXNlZCBhcyB0aGUgbWFwIGNhY2hlIGtleS4gVGhlIGBmdW5jYFxuICAgKiBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAgICpcbiAgICogKipOb3RlOioqIFRoZSBjYWNoZSBpcyBleHBvc2VkIGFzIHRoZSBgY2FjaGVgIHByb3BlcnR5IG9uIHRoZSBtZW1vaXplZFxuICAgKiBmdW5jdGlvbi4gSXRzIGNyZWF0aW9uIG1heSBiZSBjdXN0b21pemVkIGJ5IHJlcGxhY2luZyB0aGUgYF8ubWVtb2l6ZS5DYWNoZWBcbiAgICogY29uc3RydWN0b3Igd2l0aCBvbmUgd2hvc2UgaW5zdGFuY2VzIGltcGxlbWVudCB0aGVcbiAgICogW2BNYXBgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wcm9wZXJ0aWVzLW9mLXRoZS1tYXAtcHJvdG90eXBlLW9iamVjdClcbiAgICogbWV0aG9kIGludGVyZmFjZSBvZiBgY2xlYXJgLCBgZGVsZXRlYCwgYGdldGAsIGBoYXNgLCBhbmQgYHNldGAuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDAuMS4wXG4gICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlcl0gVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgdGhlIGNhY2hlIGtleS5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gICAqIHZhciBvdGhlciA9IHsgJ2MnOiAzLCAnZCc6IDQgfTtcbiAgICpcbiAgICogdmFyIHZhbHVlcyA9IF8ubWVtb2l6ZShfLnZhbHVlcyk7XG4gICAqIHZhbHVlcyhvYmplY3QpO1xuICAgKiAvLyA9PiBbMSwgMl1cbiAgICpcbiAgICogdmFsdWVzKG90aGVyKTtcbiAgICogLy8gPT4gWzMsIDRdXG4gICAqXG4gICAqIG9iamVjdC5hID0gMjtcbiAgICogdmFsdWVzKG9iamVjdCk7XG4gICAqIC8vID0+IFsxLCAyXVxuICAgKlxuICAgKiAvLyBNb2RpZnkgdGhlIHJlc3VsdCBjYWNoZS5cbiAgICogdmFsdWVzLmNhY2hlLnNldChvYmplY3QsIFsnYScsICdiJ10pO1xuICAgKiB2YWx1ZXMob2JqZWN0KTtcbiAgICogLy8gPT4gWydhJywgJ2InXVxuICAgKlxuICAgKiAvLyBSZXBsYWNlIGBfLm1lbW9pemUuQ2FjaGVgLlxuICAgKiBfLm1lbW9pemUuQ2FjaGUgPSBXZWFrTWFwO1xuICAgKi9cbiAgZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nIHx8IChyZXNvbHZlciAhPSBudWxsICYmIHR5cGVvZiByZXNvbHZlciAhPSAnZnVuY3Rpb24nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgIH1cbiAgICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuICAgICAgICAgIGNhY2hlID0gbWVtb2l6ZWQuY2FjaGU7XG5cbiAgICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xuICAgICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KSB8fCBjYWNoZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBtZW1vaXplZC5jYWNoZSA9IG5ldyAobWVtb2l6ZS5DYWNoZSB8fCBfTWFwQ2FjaGUpO1xuICAgIHJldHVybiBtZW1vaXplZDtcbiAgfVxuXG4gIC8vIEV4cG9zZSBgTWFwQ2FjaGVgLlxuICBtZW1vaXplLkNhY2hlID0gX01hcENhY2hlO1xuXG4gIHZhciBtZW1vaXplXzEgPSBtZW1vaXplO1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBtYXhpbXVtIG1lbW9pemUgY2FjaGUgc2l6ZS4gKi9cbiAgdmFyIE1BWF9NRU1PSVpFX1NJWkUgPSA1MDA7XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tZW1vaXplYCB3aGljaCBjbGVhcnMgdGhlIG1lbW9pemVkIGZ1bmN0aW9uJ3NcbiAgICogY2FjaGUgd2hlbiBpdCBleGNlZWRzIGBNQVhfTUVNT0laRV9TSVpFYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIG1lbW9pemVDYXBwZWQoZnVuYykge1xuICAgIHZhciByZXN1bHQgPSBtZW1vaXplXzEoZnVuYywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICBpZiAoY2FjaGUuc2l6ZSA9PT0gTUFYX01FTU9JWkVfU0laRSkge1xuICAgICAgICBjYWNoZS5jbGVhcigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGtleTtcbiAgICB9KTtcblxuICAgIHZhciBjYWNoZSA9IHJlc3VsdC5jYWNoZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIF9tZW1vaXplQ2FwcGVkID0gbWVtb2l6ZUNhcHBlZDtcblxuICAvKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG4gIHZhciByZVByb3BOYW1lID0gL1teLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCQpKS9nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xuICB2YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGEgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAgICovXG4gIHZhciBzdHJpbmdUb1BhdGggPSBfbWVtb2l6ZUNhcHBlZChmdW5jdGlvbihzdHJpbmcpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgaWYgKHN0cmluZy5jaGFyQ29kZUF0KDApID09PSA0NiAvKiAuICovKSB7XG4gICAgICByZXN1bHQucHVzaCgnJyk7XG4gICAgfVxuICAgIHN0cmluZy5yZXBsYWNlKHJlUHJvcE5hbWUsIGZ1bmN0aW9uKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdWJTdHJpbmcpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHF1b3RlID8gc3ViU3RyaW5nLnJlcGxhY2UocmVFc2NhcGVDaGFyLCAnJDEnKSA6IChudW1iZXIgfHwgbWF0Y2gpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9KTtcblxuICB2YXIgX3N0cmluZ1RvUGF0aCA9IHN0cmluZ1RvUGF0aDtcblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gICAqIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgX2FycmF5TWFwID0gYXJyYXlNYXA7XG5cbiAgLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG4gIHZhciBJTkZJTklUWSQxID0gMSAvIDA7XG5cbiAgLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG4gIHZhciBzeW1ib2xQcm90byA9IF9TeW1ib2wgPyBfU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICAgIHN5bWJvbFRvU3RyaW5nID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by50b1N0cmluZyA6IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9TdHJpbmdgIHdoaWNoIGRvZXNuJ3QgY29udmVydCBudWxsaXNoXG4gICAqIHZhbHVlcyB0byBlbXB0eSBzdHJpbmdzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlVG9TdHJpbmcodmFsdWUpIHtcbiAgICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKGlzQXJyYXlfMSh2YWx1ZSkpIHtcbiAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgdmFsdWVzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICByZXR1cm4gX2FycmF5TWFwKHZhbHVlLCBiYXNlVG9TdHJpbmcpICsgJyc7XG4gICAgfVxuICAgIGlmIChpc1N5bWJvbF8xKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHN5bWJvbFRvU3RyaW5nID8gc3ltYm9sVG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZJDEpID8gJy0wJyA6IHJlc3VsdDtcbiAgfVxuXG4gIHZhciBfYmFzZVRvU3RyaW5nID0gYmFzZVRvU3RyaW5nO1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQgZm9yIGBudWxsYFxuICAgKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAc2luY2UgNC4wLjBcbiAgICogQGNhdGVnb3J5IExhbmdcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy50b1N0cmluZyhudWxsKTtcbiAgICogLy8gPT4gJydcbiAgICpcbiAgICogXy50b1N0cmluZygtMCk7XG4gICAqIC8vID0+ICctMCdcbiAgICpcbiAgICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICAgKiAvLyA9PiAnMSwyLDMnXG4gICAqL1xuICBmdW5jdGlvbiB0b1N0cmluZyQxKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IF9iYXNlVG9TdHJpbmcodmFsdWUpO1xuICB9XG5cbiAgdmFyIHRvU3RyaW5nXzEgPSB0b1N0cmluZyQxO1xuXG4gIC8qKlxuICAgKiBDYXN0cyBgdmFsdWVgIHRvIGEgcGF0aCBhcnJheSBpZiBpdCdzIG5vdCBvbmUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gY2FzdFBhdGgodmFsdWUsIG9iamVjdCkge1xuICAgIGlmIChpc0FycmF5XzEodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBfaXNLZXkodmFsdWUsIG9iamVjdCkgPyBbdmFsdWVdIDogX3N0cmluZ1RvUGF0aCh0b1N0cmluZ18xKHZhbHVlKSk7XG4gIH1cblxuICB2YXIgX2Nhc3RQYXRoID0gY2FzdFBhdGg7XG5cbiAgLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG4gIHZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIGtleSBpZiBpdCdzIG5vdCBhIHN0cmluZyBvciBzeW1ib2wuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd8c3ltYm9sfSBSZXR1cm5zIHRoZSBrZXkuXG4gICAqL1xuICBmdW5jdGlvbiB0b0tleSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgaXNTeW1ib2xfMSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG4gIH1cblxuICB2YXIgX3RvS2V5ID0gdG9LZXk7XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmdldGAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWZhdWx0IHZhbHVlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlR2V0KG9iamVjdCwgcGF0aCkge1xuICAgIHBhdGggPSBfY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICAgIHZhciBpbmRleCA9IDAsXG4gICAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gICAgd2hpbGUgKG9iamVjdCAhPSBudWxsICYmIGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBvYmplY3QgPSBvYmplY3RbX3RvS2V5KHBhdGhbaW5kZXgrK10pXTtcbiAgICB9XG4gICAgcmV0dXJuIChpbmRleCAmJiBpbmRleCA9PSBsZW5ndGgpID8gb2JqZWN0IDogdW5kZWZpbmVkO1xuICB9XG5cbiAgdmFyIF9iYXNlR2V0ID0gYmFzZUdldDtcblxuICAvKipcbiAgICogR2V0cyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXNcbiAgICogYHVuZGVmaW5lZGAsIHRoZSBgZGVmYXVsdFZhbHVlYCBpcyByZXR1cm5lZCBpbiBpdHMgcGxhY2UuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDMuNy4wXG4gICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSByZXR1cm5lZCBmb3IgYHVuZGVmaW5lZGAgcmVzb2x2ZWQgdmFsdWVzLlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gICAqXG4gICAqIF8uZ2V0KG9iamVjdCwgJ2FbMF0uYi5jJyk7XG4gICAqIC8vID0+IDNcbiAgICpcbiAgICogXy5nZXQob2JqZWN0LCBbJ2EnLCAnMCcsICdiJywgJ2MnXSk7XG4gICAqIC8vID0+IDNcbiAgICpcbiAgICogXy5nZXQob2JqZWN0LCAnYS5iLmMnLCAnZGVmYXVsdCcpO1xuICAgKiAvLyA9PiAnZGVmYXVsdCdcbiAgICovXG4gIGZ1bmN0aW9uIGdldChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IF9iYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdFZhbHVlIDogcmVzdWx0O1xuICB9XG5cbiAgdmFyIGdldF8xID0gZ2V0O1xuXG4gIHZhciBkZWZpbmVQcm9wZXJ0eSA9IChmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIGZ1bmMgPSBfZ2V0TmF0aXZlKE9iamVjdCwgJ2RlZmluZVByb3BlcnR5Jyk7XG4gICAgICBmdW5jKHt9LCAnJywge30pO1xuICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfSgpKTtcblxuICB2YXIgX2RlZmluZVByb3BlcnR5ID0gZGVmaW5lUHJvcGVydHk7XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBhc3NpZ25WYWx1ZWAgYW5kIGBhc3NpZ25NZXJnZVZhbHVlYCB3aXRob3V0XG4gICAqIHZhbHVlIGNoZWNrcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5ID09ICdfX3Byb3RvX18nICYmIF9kZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgX2RlZmluZVByb3BlcnR5KG9iamVjdCwga2V5LCB7XG4gICAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICAgICAnZW51bWVyYWJsZSc6IHRydWUsXG4gICAgICAgICd2YWx1ZSc6IHZhbHVlLFxuICAgICAgICAnd3JpdGFibGUnOiB0cnVlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICB2YXIgX2Jhc2VBc3NpZ25WYWx1ZSA9IGJhc2VBc3NpZ25WYWx1ZTtcblxuICAvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG4gIHZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbiAgLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG4gIHZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4gIC8qKlxuICAgKiBBc3NpZ25zIGB2YWx1ZWAgdG8gYGtleWAgb2YgYG9iamVjdGAgaWYgdGhlIGV4aXN0aW5nIHZhbHVlIGlzIG5vdCBlcXVpdmFsZW50XG4gICAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAgICovXG4gIGZ1bmN0aW9uIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldO1xuICAgIGlmICghKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGVxXzEob2JqVmFsdWUsIHZhbHVlKSkgfHxcbiAgICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICAgIF9iYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgX2Fzc2lnblZhbHVlID0gYXNzaWduVmFsdWU7XG5cbiAgLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG4gIHZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuICAvKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG4gIHZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuXG4gICAgcmV0dXJuICEhbGVuZ3RoICYmXG4gICAgICAodHlwZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgICAodHlwZSAhPSAnc3ltYm9sJyAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkpICYmXG4gICAgICAgICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xuICB9XG5cbiAgdmFyIF9pc0luZGV4ID0gaXNJbmRleDtcblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2V0YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBwYXRoIGNyZWF0aW9uLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVNldChvYmplY3QsIHBhdGgsIHZhbHVlLCBjdXN0b21pemVyKSB7XG4gICAgaWYgKCFpc09iamVjdF8xKG9iamVjdCkpIHtcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuICAgIHBhdGggPSBfY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgICAgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMSxcbiAgICAgICAgbmVzdGVkID0gb2JqZWN0O1xuXG4gICAgd2hpbGUgKG5lc3RlZCAhPSBudWxsICYmICsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciBrZXkgPSBfdG9LZXkocGF0aFtpbmRleF0pLFxuICAgICAgICAgIG5ld1ZhbHVlID0gdmFsdWU7XG5cbiAgICAgIGlmIChrZXkgPT09ICdfX3Byb3RvX18nIHx8IGtleSA9PT0gJ2NvbnN0cnVjdG9yJyB8fCBrZXkgPT09ICdwcm90b3R5cGUnKSB7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleCAhPSBsYXN0SW5kZXgpIHtcbiAgICAgICAgdmFyIG9ialZhbHVlID0gbmVzdGVkW2tleV07XG4gICAgICAgIG5ld1ZhbHVlID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIob2JqVmFsdWUsIGtleSwgbmVzdGVkKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBuZXdWYWx1ZSA9IGlzT2JqZWN0XzEob2JqVmFsdWUpXG4gICAgICAgICAgICA/IG9ialZhbHVlXG4gICAgICAgICAgICA6IChfaXNJbmRleChwYXRoW2luZGV4ICsgMV0pID8gW10gOiB7fSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIF9hc3NpZ25WYWx1ZShuZXN0ZWQsIGtleSwgbmV3VmFsdWUpO1xuICAgICAgbmVzdGVkID0gbmVzdGVkW2tleV07XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH1cblxuICB2YXIgX2Jhc2VTZXQgPSBiYXNlU2V0O1xuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuIElmIGEgcG9ydGlvbiBvZiBgcGF0aGAgZG9lc24ndCBleGlzdCxcbiAgICogaXQncyBjcmVhdGVkLiBBcnJheXMgYXJlIGNyZWF0ZWQgZm9yIG1pc3NpbmcgaW5kZXggcHJvcGVydGllcyB3aGlsZSBvYmplY3RzXG4gICAqIGFyZSBjcmVhdGVkIGZvciBhbGwgb3RoZXIgbWlzc2luZyBwcm9wZXJ0aWVzLiBVc2UgYF8uc2V0V2l0aGAgdG8gY3VzdG9taXplXG4gICAqIGBwYXRoYCBjcmVhdGlvbi5cbiAgICpcbiAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDMuNy4wXG4gICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICAgKlxuICAgKiBfLnNldChvYmplY3QsICdhWzBdLmIuYycsIDQpO1xuICAgKiBjb25zb2xlLmxvZyhvYmplY3QuYVswXS5iLmMpO1xuICAgKiAvLyA9PiA0XG4gICAqXG4gICAqIF8uc2V0KG9iamVjdCwgWyd4JywgJzAnLCAneScsICd6J10sIDUpO1xuICAgKiBjb25zb2xlLmxvZyhvYmplY3QueFswXS55LnopO1xuICAgKiAvLyA9PiA1XG4gICAqL1xuICBmdW5jdGlvbiBzZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IF9iYXNlU2V0KG9iamVjdCwgcGF0aCwgdmFsdWUpO1xuICB9XG5cbiAgdmFyIHNldF8xID0gc2V0O1xuXG4gIC8qKlxuICAgKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiBgc291cmNlYCB0byBgYXJyYXlgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIGZyb20uXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheT1bXV0gVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIHRvLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICovXG4gIGZ1bmN0aW9uIGNvcHlBcnJheShzb3VyY2UsIGFycmF5KSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG5cbiAgICBhcnJheSB8fCAoYXJyYXkgPSBBcnJheShsZW5ndGgpKTtcbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgYXJyYXlbaW5kZXhdID0gc291cmNlW2luZGV4XTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG5cbiAgdmFyIF9jb3B5QXJyYXkgPSBjb3B5QXJyYXk7XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBzaW5jZSA0LjAuMFxuICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLnRvUGF0aCgnYS5iLmMnKTtcbiAgICogLy8gPT4gWydhJywgJ2InLCAnYyddXG4gICAqXG4gICAqIF8udG9QYXRoKCdhWzBdLmIuYycpO1xuICAgKiAvLyA9PiBbJ2EnLCAnMCcsICdiJywgJ2MnXVxuICAgKi9cbiAgZnVuY3Rpb24gdG9QYXRoKHZhbHVlKSB7XG4gICAgaWYgKGlzQXJyYXlfMSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBfYXJyYXlNYXAodmFsdWUsIF90b0tleSk7XG4gICAgfVxuICAgIHJldHVybiBpc1N5bWJvbF8xKHZhbHVlKSA/IFt2YWx1ZV0gOiBfY29weUFycmF5KF9zdHJpbmdUb1BhdGgodG9TdHJpbmdfMSh2YWx1ZSkpKTtcbiAgfVxuXG4gIHZhciB0b1BhdGhfMSA9IHRvUGF0aDtcblxuICB2YXIgZGVmaW5lJDIgPSB7XG4gICAgLy8gYWNjZXNzIGRhdGEgZmllbGRcbiAgICBkYXRhOiBmdW5jdGlvbiBkYXRhKHBhcmFtcykge1xuICAgICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgICBmaWVsZDogJ2RhdGEnLFxuICAgICAgICBiaW5kaW5nRXZlbnQ6ICdkYXRhJyxcbiAgICAgICAgYWxsb3dCaW5kaW5nOiBmYWxzZSxcbiAgICAgICAgYWxsb3dTZXR0aW5nOiBmYWxzZSxcbiAgICAgICAgYWxsb3dHZXR0aW5nOiBmYWxzZSxcbiAgICAgICAgc2V0dGluZ0V2ZW50OiAnZGF0YScsXG4gICAgICAgIHNldHRpbmdUcmlnZ2Vyc0V2ZW50OiBmYWxzZSxcbiAgICAgICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgICAgICBpbW11dGFibGVLZXlzOiB7fSxcbiAgICAgICAgLy8ga2V5ID0+IHRydWUgaWYgaW1tdXRhYmxlXG4gICAgICAgIHVwZGF0ZVN0eWxlOiBmYWxzZSxcbiAgICAgICAgYmVmb3JlR2V0OiBmdW5jdGlvbiBiZWZvcmVHZXQoc2VsZikge30sXG4gICAgICAgIGJlZm9yZVNldDogZnVuY3Rpb24gYmVmb3JlU2V0KHNlbGYsIG9iaikge30sXG4gICAgICAgIG9uU2V0OiBmdW5jdGlvbiBvblNldChzZWxmKSB7fSxcbiAgICAgICAgY2FuU2V0OiBmdW5jdGlvbiBjYW5TZXQoc2VsZikge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcGFyYW1zID0gZXh0ZW5kKHt9LCBkZWZhdWx0cywgcGFyYW1zKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBkYXRhSW1wbChuYW1lLCB2YWx1ZSkge1xuICAgICAgICB2YXIgcCA9IHBhcmFtcztcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGFsbCA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGYgOiBbc2VsZl07IC8vIHB1dCBpbiBhcnJheSBpZiBub3QgYXJyYXktbGlrZVxuXG4gICAgICAgIHZhciBzaW5nbGUgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmWzBdIDogc2VsZjsgLy8gLmRhdGEoJ2ZvbycsIC4uLilcblxuICAgICAgICBpZiAoc3RyaW5nKG5hbWUpKSB7XG4gICAgICAgICAgLy8gc2V0IG9yIGdldCBwcm9wZXJ0eVxuICAgICAgICAgIHZhciBpc1BhdGhMaWtlID0gbmFtZS5pbmRleE9mKCcuJykgIT09IC0xOyAvLyB0aGVyZSBtaWdodCBiZSBhIG5vcm1hbCBmaWVsZCB3aXRoIGEgZG90IFxuXG4gICAgICAgICAgdmFyIHBhdGggPSBpc1BhdGhMaWtlICYmIHRvUGF0aF8xKG5hbWUpOyAvLyAuZGF0YSgnZm9vJylcblxuICAgICAgICAgIGlmIChwLmFsbG93R2V0dGluZyAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBnZXRcbiAgICAgICAgICAgIHZhciByZXQ7XG5cbiAgICAgICAgICAgIGlmIChzaW5nbGUpIHtcbiAgICAgICAgICAgICAgcC5iZWZvcmVHZXQoc2luZ2xlKTsgLy8gY2hlY2sgaWYgaXQncyBwYXRoIGFuZCBhIGZpZWxkIHdpdGggdGhlIHNhbWUgbmFtZSBkb2Vzbid0IGV4aXN0XG5cbiAgICAgICAgICAgICAgaWYgKHBhdGggJiYgc2luZ2xlLl9wcml2YXRlW3AuZmllbGRdW25hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXQgPSBnZXRfMShzaW5nbGUuX3ByaXZhdGVbcC5maWVsZF0sIHBhdGgpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldCA9IHNpbmdsZS5fcHJpdmF0ZVtwLmZpZWxkXVtuYW1lXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmV0OyAvLyAuZGF0YSgnZm9vJywgJ2JhcicpXG4gICAgICAgICAgfSBlbHNlIGlmIChwLmFsbG93U2V0dGluZyAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBzZXRcbiAgICAgICAgICAgIHZhciB2YWxpZCA9ICFwLmltbXV0YWJsZUtleXNbbmFtZV07XG5cbiAgICAgICAgICAgIGlmICh2YWxpZCkge1xuICAgICAgICAgICAgICB2YXIgY2hhbmdlID0gX2RlZmluZVByb3BlcnR5JDEoe30sIG5hbWUsIHZhbHVlKTtcblxuICAgICAgICAgICAgICBwLmJlZm9yZVNldChzZWxmLCBjaGFuZ2UpO1xuXG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gYWxsLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBlbGUgPSBhbGxbaV07XG5cbiAgICAgICAgICAgICAgICBpZiAocC5jYW5TZXQoZWxlKSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHBhdGggJiYgc2luZ2xlLl9wcml2YXRlW3AuZmllbGRdW25hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0XzEoZWxlLl9wcml2YXRlW3AuZmllbGRdLCBwYXRoLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbGUuX3ByaXZhdGVbcC5maWVsZF1bbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gLy8gdXBkYXRlIG1hcHBlcnMgaWYgYXNrZWRcblxuXG4gICAgICAgICAgICAgIGlmIChwLnVwZGF0ZVN0eWxlKSB7XG4gICAgICAgICAgICAgICAgc2VsZi51cGRhdGVTdHlsZSgpO1xuICAgICAgICAgICAgICB9IC8vIGNhbGwgb25TZXQgY2FsbGJhY2tcblxuXG4gICAgICAgICAgICAgIHAub25TZXQoc2VsZik7XG5cbiAgICAgICAgICAgICAgaWYgKHAuc2V0dGluZ1RyaWdnZXJzRXZlbnQpIHtcbiAgICAgICAgICAgICAgICBzZWxmW3AudHJpZ2dlckZuTmFtZV0ocC5zZXR0aW5nRXZlbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyAuZGF0YSh7ICdmb28nOiAnYmFyJyB9KVxuXG4gICAgICAgIH0gZWxzZSBpZiAocC5hbGxvd1NldHRpbmcgJiYgcGxhaW5PYmplY3QobmFtZSkpIHtcbiAgICAgICAgICAvLyBleHRlbmRcbiAgICAgICAgICB2YXIgb2JqID0gbmFtZTtcbiAgICAgICAgICB2YXIgaywgdjtcbiAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgICAgICAgcC5iZWZvcmVTZXQoc2VsZiwgb2JqKTtcblxuICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBrZXlzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgayA9IGtleXNbX2ldO1xuICAgICAgICAgICAgdiA9IG9ialtrXTtcblxuICAgICAgICAgICAgdmFyIF92YWxpZCA9ICFwLmltbXV0YWJsZUtleXNba107XG5cbiAgICAgICAgICAgIGlmIChfdmFsaWQpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBhbGwubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgX2VsZSA9IGFsbFtqXTtcblxuICAgICAgICAgICAgICAgIGlmIChwLmNhblNldChfZWxlKSkge1xuICAgICAgICAgICAgICAgICAgX2VsZS5fcHJpdmF0ZVtwLmZpZWxkXVtrXSA9IHY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyB1cGRhdGUgbWFwcGVycyBpZiBhc2tlZFxuXG5cbiAgICAgICAgICBpZiAocC51cGRhdGVTdHlsZSkge1xuICAgICAgICAgICAgc2VsZi51cGRhdGVTdHlsZSgpO1xuICAgICAgICAgIH0gLy8gY2FsbCBvblNldCBjYWxsYmFja1xuXG5cbiAgICAgICAgICBwLm9uU2V0KHNlbGYpO1xuXG4gICAgICAgICAgaWYgKHAuc2V0dGluZ1RyaWdnZXJzRXZlbnQpIHtcbiAgICAgICAgICAgIHNlbGZbcC50cmlnZ2VyRm5OYW1lXShwLnNldHRpbmdFdmVudCk7XG4gICAgICAgICAgfSAvLyAuZGF0YShmdW5jdGlvbigpeyAuLi4gfSlcblxuICAgICAgICB9IGVsc2UgaWYgKHAuYWxsb3dCaW5kaW5nICYmIGZuJDYobmFtZSkpIHtcbiAgICAgICAgICAvLyBiaW5kIHRvIGV2ZW50XG4gICAgICAgICAgdmFyIGZuID0gbmFtZTtcbiAgICAgICAgICBzZWxmLm9uKHAuYmluZGluZ0V2ZW50LCBmbik7IC8vIC5kYXRhKClcbiAgICAgICAgfSBlbHNlIGlmIChwLmFsbG93R2V0dGluZyAmJiBuYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBnZXQgd2hvbGUgb2JqZWN0XG4gICAgICAgICAgdmFyIF9yZXQ7XG5cbiAgICAgICAgICBpZiAoc2luZ2xlKSB7XG4gICAgICAgICAgICBwLmJlZm9yZUdldChzaW5nbGUpO1xuICAgICAgICAgICAgX3JldCA9IHNpbmdsZS5fcHJpdmF0ZVtwLmZpZWxkXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gX3JldDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZWxmOyAvLyBtYWludGFpbiBjaGFpbmFiaWxpdHlcbiAgICAgIH07IC8vIGZ1bmN0aW9uXG4gICAgfSxcbiAgICAvLyBkYXRhXG4gICAgLy8gcmVtb3ZlIGRhdGEgZmllbGRcbiAgICByZW1vdmVEYXRhOiBmdW5jdGlvbiByZW1vdmVEYXRhKHBhcmFtcykge1xuICAgICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgICBmaWVsZDogJ2RhdGEnLFxuICAgICAgICBldmVudDogJ2RhdGEnLFxuICAgICAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgICAgIHRyaWdnZXJFdmVudDogZmFsc2UsXG4gICAgICAgIGltbXV0YWJsZUtleXM6IHt9IC8vIGtleSA9PiB0cnVlIGlmIGltbXV0YWJsZVxuXG4gICAgICB9O1xuICAgICAgcGFyYW1zID0gZXh0ZW5kKHt9LCBkZWZhdWx0cywgcGFyYW1zKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiByZW1vdmVEYXRhSW1wbChuYW1lcykge1xuICAgICAgICB2YXIgcCA9IHBhcmFtcztcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGFsbCA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGYgOiBbc2VsZl07IC8vIHB1dCBpbiBhcnJheSBpZiBub3QgYXJyYXktbGlrZVxuICAgICAgICAvLyAucmVtb3ZlRGF0YSgnZm9vIGJhcicpXG5cbiAgICAgICAgaWYgKHN0cmluZyhuYW1lcykpIHtcbiAgICAgICAgICAvLyB0aGVuIGdldCB0aGUgbGlzdCBvZiBrZXlzLCBhbmQgZGVsZXRlIHRoZW1cbiAgICAgICAgICB2YXIga2V5cyA9IG5hbWVzLnNwbGl0KC9cXHMrLyk7XG4gICAgICAgICAgdmFyIGwgPSBrZXlzLmxlbmd0aDtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBkZWxldGUgZWFjaCBub24tZW1wdHkga2V5XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICAgICAgaWYgKGVtcHR5U3RyaW5nKGtleSkpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB2YWxpZCA9ICFwLmltbXV0YWJsZUtleXNba2V5XTsgLy8gbm90IHZhbGlkIGlmIGltbXV0YWJsZVxuXG4gICAgICAgICAgICBpZiAodmFsaWQpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaV9hID0gMCwgbF9hID0gYWxsLmxlbmd0aDsgaV9hIDwgbF9hOyBpX2ErKykge1xuICAgICAgICAgICAgICAgIGFsbFtpX2FdLl9wcml2YXRlW3AuZmllbGRdW2tleV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocC50cmlnZ2VyRXZlbnQpIHtcbiAgICAgICAgICAgIHNlbGZbcC50cmlnZ2VyRm5OYW1lXShwLmV2ZW50KTtcbiAgICAgICAgICB9IC8vIC5yZW1vdmVEYXRhKClcblxuICAgICAgICB9IGVsc2UgaWYgKG5hbWVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyB0aGVuIGRlbGV0ZSBhbGwga2V5c1xuICAgICAgICAgIGZvciAodmFyIF9pX2EgPSAwLCBfbF9hID0gYWxsLmxlbmd0aDsgX2lfYSA8IF9sX2E7IF9pX2ErKykge1xuICAgICAgICAgICAgdmFyIF9wcml2YXRlRmllbGRzID0gYWxsW19pX2FdLl9wcml2YXRlW3AuZmllbGRdO1xuXG4gICAgICAgICAgICB2YXIgX2tleXMgPSBPYmplY3Qua2V5cyhfcHJpdmF0ZUZpZWxkcyk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IF9rZXlzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgICAgICAgdmFyIF9rZXkgPSBfa2V5c1tfaTJdO1xuICAgICAgICAgICAgICB2YXIgdmFsaWRLZXlUb0RlbGV0ZSA9ICFwLmltbXV0YWJsZUtleXNbX2tleV07XG5cbiAgICAgICAgICAgICAgaWYgKHZhbGlkS2V5VG9EZWxldGUpIHtcbiAgICAgICAgICAgICAgICBfcHJpdmF0ZUZpZWxkc1tfa2V5XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwLnRyaWdnZXJFdmVudCkge1xuICAgICAgICAgICAgc2VsZltwLnRyaWdnZXJGbk5hbWVdKHAuZXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZWxmOyAvLyBtYWludGFpbiBjaGFpbmluZ1xuICAgICAgfTsgLy8gZnVuY3Rpb25cbiAgICB9IC8vIHJlbW92ZURhdGFcblxuICB9OyAvLyBkZWZpbmVcblxuICB2YXIgZGVmaW5lJDEgPSB7XG4gICAgZXZlbnRBbGlhc2VzT246IGZ1bmN0aW9uIGV2ZW50QWxpYXNlc09uKHByb3RvKSB7XG4gICAgICB2YXIgcCA9IHByb3RvO1xuICAgICAgcC5hZGRMaXN0ZW5lciA9IHAubGlzdGVuID0gcC5iaW5kID0gcC5vbjtcbiAgICAgIHAudW5saXN0ZW4gPSBwLnVuYmluZCA9IHAub2ZmID0gcC5yZW1vdmVMaXN0ZW5lcjtcbiAgICAgIHAudHJpZ2dlciA9IHAuZW1pdDsgLy8gdGhpcyBpcyBqdXN0IGEgd3JhcHBlciBhbGlhcyBvZiAub24oKVxuXG4gICAgICBwLnBvbiA9IHAucHJvbWlzZU9uID0gZnVuY3Rpb24gKGV2ZW50cywgc2VsZWN0b3IpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbiBjYWxsYmFjayhlKSB7XG4gICAgICAgICAgICBzZWxmLm9mZi5hcHBseShzZWxmLCBvZmZBcmdzKTtcbiAgICAgICAgICAgIHJlc29sdmUoZSk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHZhciBvbkFyZ3MgPSBhcmdzLmNvbmNhdChbY2FsbGJhY2tdKTtcbiAgICAgICAgICB2YXIgb2ZmQXJncyA9IG9uQXJncy5jb25jYXQoW10pO1xuICAgICAgICAgIHNlbGYub24uYXBwbHkoc2VsZiwgb25BcmdzKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH1cbiAgfTsgLy8gZGVmaW5lXG5cbiAgLy8gdXNlIHRoaXMgbW9kdWxlIHRvIGNoZXJyeSBwaWNrIGZ1bmN0aW9ucyBpbnRvIHlvdXIgcHJvdG90eXBlXG4gIHZhciBkZWZpbmUgPSB7fTtcbiAgW2RlZmluZSQzLCBkZWZpbmUkMiwgZGVmaW5lJDFdLmZvckVhY2goZnVuY3Rpb24gKG0pIHtcbiAgICBleHRlbmQoZGVmaW5lLCBtKTtcbiAgfSk7XG5cbiAgdmFyIGVsZXNmbiRpID0ge1xuICAgIGFuaW1hdGU6IGRlZmluZS5hbmltYXRlKCksXG4gICAgYW5pbWF0aW9uOiBkZWZpbmUuYW5pbWF0aW9uKCksXG4gICAgYW5pbWF0ZWQ6IGRlZmluZS5hbmltYXRlZCgpLFxuICAgIGNsZWFyUXVldWU6IGRlZmluZS5jbGVhclF1ZXVlKCksXG4gICAgZGVsYXk6IGRlZmluZS5kZWxheSgpLFxuICAgIGRlbGF5QW5pbWF0aW9uOiBkZWZpbmUuZGVsYXlBbmltYXRpb24oKSxcbiAgICBzdG9wOiBkZWZpbmUuc3RvcCgpXG4gIH07XG5cbiAgdmFyIGVsZXNmbiRoID0ge1xuICAgIGNsYXNzZXM6IGZ1bmN0aW9uIGNsYXNzZXMoX2NsYXNzZXMpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgaWYgKF9jbGFzc2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIHJldCA9IFtdO1xuXG4gICAgICAgIHNlbGZbMF0uX3ByaXZhdGUuY2xhc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChjbHMpIHtcbiAgICAgICAgICByZXR1cm4gcmV0LnB1c2goY2xzKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH0gZWxzZSBpZiAoIWFycmF5KF9jbGFzc2VzKSkge1xuICAgICAgICAvLyBleHRyYWN0IGNsYXNzZXMgZnJvbSBzdHJpbmdcbiAgICAgICAgX2NsYXNzZXMgPSAoX2NsYXNzZXMgfHwgJycpLm1hdGNoKC9cXFMrL2cpIHx8IFtdO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2hhbmdlZCA9IFtdO1xuICAgICAgdmFyIGNsYXNzZXNTZXQgPSBuZXcgU2V0JDEoX2NsYXNzZXMpOyAvLyBjaGVjayBhbmQgdXBkYXRlIGVhY2ggZWxlXG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2VsZi5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgZWxlID0gc2VsZltqXTtcbiAgICAgICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgICAgICB2YXIgZWxlQ2xhc3NlcyA9IF9wLmNsYXNzZXM7XG4gICAgICAgIHZhciBjaGFuZ2VkRWxlID0gZmFsc2U7IC8vIGNoZWNrIGlmIGVsZSBoYXMgYWxsIG9mIHRoZSBwYXNzZWQgY2xhc3Nlc1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX2NsYXNzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgY2xzID0gX2NsYXNzZXNbaV07XG4gICAgICAgICAgdmFyIGVsZUhhc0NsYXNzID0gZWxlQ2xhc3Nlcy5oYXMoY2xzKTtcblxuICAgICAgICAgIGlmICghZWxlSGFzQ2xhc3MpIHtcbiAgICAgICAgICAgIGNoYW5nZWRFbGUgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIGNoZWNrIGlmIGVsZSBoYXMgY2xhc3NlcyBvdXRzaWRlIG9mIHRob3NlIHBhc3NlZFxuXG5cbiAgICAgICAgaWYgKCFjaGFuZ2VkRWxlKSB7XG4gICAgICAgICAgY2hhbmdlZEVsZSA9IGVsZUNsYXNzZXMuc2l6ZSAhPT0gX2NsYXNzZXMubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoYW5nZWRFbGUpIHtcbiAgICAgICAgICBfcC5jbGFzc2VzID0gY2xhc3Nlc1NldDtcbiAgICAgICAgICBjaGFuZ2VkLnB1c2goZWxlKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyB0cmlnZ2VyIHVwZGF0ZSBzdHlsZSBvbiB0aG9zZSBlbGVzIHRoYXQgaGFkIGNsYXNzIGNoYW5nZXNcblxuXG4gICAgICBpZiAoY2hhbmdlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuc3Bhd24oY2hhbmdlZCkudXBkYXRlU3R5bGUoKS5lbWl0KCdjbGFzcycpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuICAgIGFkZENsYXNzOiBmdW5jdGlvbiBhZGRDbGFzcyhjbGFzc2VzKSB7XG4gICAgICByZXR1cm4gdGhpcy50b2dnbGVDbGFzcyhjbGFzc2VzLCB0cnVlKTtcbiAgICB9LFxuICAgIGhhc0NsYXNzOiBmdW5jdGlvbiBoYXNDbGFzcyhjbGFzc05hbWUpIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgICAgcmV0dXJuIGVsZSAhPSBudWxsICYmIGVsZS5fcHJpdmF0ZS5jbGFzc2VzLmhhcyhjbGFzc05hbWUpO1xuICAgIH0sXG4gICAgdG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uIHRvZ2dsZUNsYXNzKGNsYXNzZXMsIHRvZ2dsZSkge1xuICAgICAgaWYgKCFhcnJheShjbGFzc2VzKSkge1xuICAgICAgICAvLyBleHRyYWN0IGNsYXNzZXMgZnJvbSBzdHJpbmdcbiAgICAgICAgY2xhc3NlcyA9IGNsYXNzZXMubWF0Y2goL1xcUysvZykgfHwgW107XG4gICAgICB9XG5cbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciB0b2dnbGVVbmRlZmQgPSB0b2dnbGUgPT09IHVuZGVmaW5lZDtcbiAgICAgIHZhciBjaGFuZ2VkID0gW107IC8vIGVsZXMgd2hvIGhhZCBjbGFzc2VzIGNoYW5nZWRcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGlsID0gc2VsZi5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSBzZWxmW2ldO1xuICAgICAgICB2YXIgZWxlQ2xhc3NlcyA9IGVsZS5fcHJpdmF0ZS5jbGFzc2VzO1xuICAgICAgICB2YXIgY2hhbmdlZEVsZSA9IGZhbHNlO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2xhc3Nlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHZhciBjbHMgPSBjbGFzc2VzW2pdO1xuICAgICAgICAgIHZhciBoYXNDbGFzcyA9IGVsZUNsYXNzZXMuaGFzKGNscyk7XG4gICAgICAgICAgdmFyIGNoYW5nZWROb3cgPSBmYWxzZTtcblxuICAgICAgICAgIGlmICh0b2dnbGUgfHwgdG9nZ2xlVW5kZWZkICYmICFoYXNDbGFzcykge1xuICAgICAgICAgICAgZWxlQ2xhc3Nlcy5hZGQoY2xzKTtcbiAgICAgICAgICAgIGNoYW5nZWROb3cgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIXRvZ2dsZSB8fCB0b2dnbGVVbmRlZmQgJiYgaGFzQ2xhc3MpIHtcbiAgICAgICAgICAgIGVsZUNsYXNzZXNbXCJkZWxldGVcIl0oY2xzKTtcbiAgICAgICAgICAgIGNoYW5nZWROb3cgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghY2hhbmdlZEVsZSAmJiBjaGFuZ2VkTm93KSB7XG4gICAgICAgICAgICBjaGFuZ2VkLnB1c2goZWxlKTtcbiAgICAgICAgICAgIGNoYW5nZWRFbGUgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBmb3IgaiBjbGFzc2VzXG5cbiAgICAgIH0gLy8gZm9yIGkgZWxlc1xuICAgICAgLy8gdHJpZ2dlciB1cGRhdGUgc3R5bGUgb24gdGhvc2UgZWxlcyB0aGF0IGhhZCBjbGFzcyBjaGFuZ2VzXG5cblxuICAgICAgaWYgKGNoYW5nZWQubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLnNwYXduKGNoYW5nZWQpLnVwZGF0ZVN0eWxlKCkuZW1pdCgnY2xhc3MnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcbiAgICByZW1vdmVDbGFzczogZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoY2xhc3Nlcykge1xuICAgICAgcmV0dXJuIHRoaXMudG9nZ2xlQ2xhc3MoY2xhc3NlcywgZmFsc2UpO1xuICAgIH0sXG4gICAgZmxhc2hDbGFzczogZnVuY3Rpb24gZmxhc2hDbGFzcyhjbGFzc2VzLCBkdXJhdGlvbikge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICBpZiAoZHVyYXRpb24gPT0gbnVsbCkge1xuICAgICAgICBkdXJhdGlvbiA9IDI1MDtcbiAgICAgIH0gZWxzZSBpZiAoZHVyYXRpb24gPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHNlbGY7IC8vIG5vdGhpbmcgdG8gZG8gcmVhbGx5XG4gICAgICB9XG5cbiAgICAgIHNlbGYuYWRkQ2xhc3MoY2xhc3Nlcyk7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5yZW1vdmVDbGFzcyhjbGFzc2VzKTtcbiAgICAgIH0sIGR1cmF0aW9uKTtcbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgfTtcbiAgZWxlc2ZuJGguY2xhc3NOYW1lID0gZWxlc2ZuJGguY2xhc3NOYW1lcyA9IGVsZXNmbiRoLmNsYXNzZXM7XG5cbiAgdmFyIHRva2VucyA9IHtcbiAgICBtZXRhQ2hhcjogJ1tcXFxcIVxcXFxcIlxcXFwjXFxcXCRcXFxcJVxcXFwmXFxcXFxcJ1xcXFwoXFxcXClcXFxcKlxcXFwrXFxcXCxcXFxcLlxcXFwvXFxcXDpcXFxcO1xcXFw8XFxcXD1cXFxcPlxcXFw/XFxcXEBcXFxcW1xcXFxdXFxcXF5cXFxcYFxcXFx7XFxcXHxcXFxcfVxcXFx+XScsXG4gICAgLy8gY2hhcnMgd2UgbmVlZCB0byBlc2NhcGUgaW4gbGV0IG5hbWVzLCBldGNcbiAgICBjb21wYXJhdG9yT3A6ICc9fFxcXFwhPXw+fD49fDx8PD18XFxcXCQ9fFxcXFxePXxcXFxcKj0nLFxuICAgIC8vIGJpbmFyeSBjb21wYXJpc29uIG9wICh1c2VkIGluIGRhdGEgc2VsZWN0b3JzKVxuICAgIGJvb2xPcDogJ1xcXFw/fFxcXFwhfFxcXFxeJyxcbiAgICAvLyBib29sZWFuICh1bmFyeSkgb3BlcmF0b3JzICh1c2VkIGluIGRhdGEgc2VsZWN0b3JzKVxuICAgIHN0cmluZzogJ1wiKD86XFxcXFxcXFxcInxbXlwiXSkqXCInICsgJ3wnICsgXCInKD86XFxcXFxcXFwnfFteJ10pKidcIixcbiAgICAvLyBzdHJpbmcgbGl0ZXJhbHMgKHVzZWQgaW4gZGF0YSBzZWxlY3RvcnMpIC0tIGRvdWJsZXF1b3RlcyB8IHNpbmdsZXF1b3Rlc1xuICAgIG51bWJlcjogbnVtYmVyLFxuICAgIC8vIG51bWJlciBsaXRlcmFsICh1c2VkIGluIGRhdGEgc2VsZWN0b3JzKSAtLS0gZS5nLiAwLjEyMzQsIDEyMzQsIDEyZTEyM1xuICAgIG1ldGE6ICdkZWdyZWV8aW5kZWdyZWV8b3V0ZGVncmVlJyxcbiAgICAvLyBhbGxvd2VkIG1ldGFkYXRhIGZpZWxkcyAoaS5lLiBhbGxvd2VkIGZ1bmN0aW9ucyB0byB1c2UgZnJvbSBDb2xsZWN0aW9uKVxuICAgIHNlcGFyYXRvcjogJ1xcXFxzKixcXFxccyonLFxuICAgIC8vIHF1ZXJpZXMgYXJlIHNlcGFyYXRlZCBieSBjb21tYXMsIGUuZy4gZWRnZVtmb28gPSAnYmFyJ10sIG5vZGUuc29tZUNsYXNzXG4gICAgZGVzY2VuZGFudDogJ1xcXFxzKycsXG4gICAgY2hpbGQ6ICdcXFxccys+XFxcXHMrJyxcbiAgICBzdWJqZWN0OiAnXFxcXCQnLFxuICAgIGdyb3VwOiAnbm9kZXxlZGdlfFxcXFwqJyxcbiAgICBkaXJlY3RlZEVkZ2U6ICdcXFxccystPlxcXFxzKycsXG4gICAgdW5kaXJlY3RlZEVkZ2U6ICdcXFxccys8LT5cXFxccysnXG4gIH07XG4gIHRva2Vucy52YXJpYWJsZSA9ICcoPzpbXFxcXHctLl18KD86XFxcXFxcXFwnICsgdG9rZW5zLm1ldGFDaGFyICsgJykpKyc7IC8vIGEgdmFyaWFibGUgbmFtZSBjYW4gaGF2ZSBsZXR0ZXJzLCBudW1iZXJzLCBkYXNoZXMsIGFuZCBwZXJpb2RzXG5cbiAgdG9rZW5zLmNsYXNzTmFtZSA9ICcoPzpbXFxcXHctXXwoPzpcXFxcXFxcXCcgKyB0b2tlbnMubWV0YUNoYXIgKyAnKSkrJzsgLy8gYSBjbGFzcyBuYW1lIGhhcyB0aGUgc2FtZSBydWxlcyBhcyBhIHZhcmlhYmxlIGV4Y2VwdCBpdCBjYW4ndCBoYXZlIGEgJy4nIGluIHRoZSBuYW1lXG5cbiAgdG9rZW5zLnZhbHVlID0gdG9rZW5zLnN0cmluZyArICd8JyArIHRva2Vucy5udW1iZXI7IC8vIGEgdmFsdWUgbGl0ZXJhbCwgZWl0aGVyIGEgc3RyaW5nIG9yIG51bWJlclxuXG4gIHRva2Vucy5pZCA9IHRva2Vucy52YXJpYWJsZTsgLy8gYW4gZWxlbWVudCBpZCAoZm9sbG93cyB2YXJpYWJsZSBjb252ZW50aW9ucylcblxuICAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBvcHMsIG9wLCBpOyAvLyBhZGQgQCB2YXJpYW50cyB0byBjb21wYXJhdG9yT3BcblxuICAgIG9wcyA9IHRva2Vucy5jb21wYXJhdG9yT3Auc3BsaXQoJ3wnKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG9wID0gb3BzW2ldO1xuICAgICAgdG9rZW5zLmNvbXBhcmF0b3JPcCArPSAnfEAnICsgb3A7XG4gICAgfSAvLyBhZGQgISB2YXJpYW50cyB0byBjb21wYXJhdG9yT3BcblxuXG4gICAgb3BzID0gdG9rZW5zLmNvbXBhcmF0b3JPcC5zcGxpdCgnfCcpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgb3AgPSBvcHNbaV07XG5cbiAgICAgIGlmIChvcC5pbmRleE9mKCchJykgPj0gMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8gc2tpcCBvcHMgdGhhdCBleHBsaWNpdGx5IGNvbnRhaW4gIVxuXG5cbiAgICAgIGlmIChvcCA9PT0gJz0nKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvLyBza2lwID0gYi9jICE9IGlzIGV4cGxpY2l0bHkgZGVmaW5lZFxuXG5cbiAgICAgIHRva2Vucy5jb21wYXJhdG9yT3AgKz0gJ3xcXFxcIScgKyBvcDtcbiAgICB9XG4gIH0pKCk7XG5cbiAgLyoqXG4gICAqIE1ha2UgYSBuZXcgcXVlcnkgb2JqZWN0XG4gICAqXG4gICAqIEBwcm9wIHR5cGUge1R5cGV9IFRoZSB0eXBlIGVudW0gKGludCkgb2YgdGhlIHF1ZXJ5XG4gICAqIEBwcm9wIGNoZWNrcyBMaXN0IG9mIGNoZWNrcyB0byBtYWtlIGFnYWluc3QgYW4gZWxlIHRvIHRlc3QgZm9yIGEgbWF0Y2hcbiAgICovXG4gIHZhciBuZXdRdWVyeSA9IGZ1bmN0aW9uIG5ld1F1ZXJ5KCkge1xuICAgIHJldHVybiB7XG4gICAgICBjaGVja3M6IFtdXG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogQSBjaGVjayB0eXBlIGVudW0tbGlrZSBvYmplY3QuICBVc2VzIGludGVnZXIgdmFsdWVzIGZvciBmYXN0IG1hdGNoKCkgbG9va3VwLlxuICAgKiBUaGUgb3JkZXJpbmcgZG9lcyBub3QgbWF0dGVyIGFzIGxvbmcgYXMgdGhlIGludHMgYXJlIHVuaXF1ZS5cbiAgICovXG4gIHZhciBUeXBlID0ge1xuICAgIC8qKiBFLmcuIG5vZGUgKi9cbiAgICBHUk9VUDogMCxcblxuICAgIC8qKiBBIGNvbGxlY3Rpb24gb2YgZWxlbWVudHMgKi9cbiAgICBDT0xMRUNUSU9OOiAxLFxuXG4gICAgLyoqIEEgZmlsdGVyKGVsZSkgZnVuY3Rpb24gKi9cbiAgICBGSUxURVI6IDIsXG5cbiAgICAvKiogRS5nLiBbZm9vID4gMV0gKi9cbiAgICBEQVRBX0NPTVBBUkU6IDMsXG5cbiAgICAvKiogRS5nLiBbZm9vXSAqL1xuICAgIERBVEFfRVhJU1Q6IDQsXG5cbiAgICAvKiogRS5nLiBbP2Zvb10gKi9cbiAgICBEQVRBX0JPT0w6IDUsXG5cbiAgICAvKiogRS5nLiBbW2RlZ3JlZSA+IDJdXSAqL1xuICAgIE1FVEFfQ09NUEFSRTogNixcblxuICAgIC8qKiBFLmcuIDpzZWxlY3RlZCAqL1xuICAgIFNUQVRFOiA3LFxuXG4gICAgLyoqIEUuZy4gI2ZvbyAqL1xuICAgIElEOiA4LFxuXG4gICAgLyoqIEUuZy4gLmZvbyAqL1xuICAgIENMQVNTOiA5LFxuXG4gICAgLyoqIEUuZy4gI2ZvbyA8LT4gI2JhciAqL1xuICAgIFVORElSRUNURURfRURHRTogMTAsXG5cbiAgICAvKiogRS5nLiAjZm9vIC0+ICNiYXIgKi9cbiAgICBESVJFQ1RFRF9FREdFOiAxMSxcblxuICAgIC8qKiBFLmcuICQjZm9vIC0+ICNiYXIgKi9cbiAgICBOT0RFX1NPVVJDRTogMTIsXG5cbiAgICAvKiogRS5nLiAjZm9vIC0+ICQjYmFyICovXG4gICAgTk9ERV9UQVJHRVQ6IDEzLFxuXG4gICAgLyoqIEUuZy4gJCNmb28gPC0+ICNiYXIgKi9cbiAgICBOT0RFX05FSUdIQk9SOiAxNCxcblxuICAgIC8qKiBFLmcuICNmb28gPiAjYmFyICovXG4gICAgQ0hJTEQ6IDE1LFxuXG4gICAgLyoqIEUuZy4gI2ZvbyAjYmFyICovXG4gICAgREVTQ0VOREFOVDogMTYsXG5cbiAgICAvKiogRS5nLiAkI2ZvbyA+ICNiYXIgKi9cbiAgICBQQVJFTlQ6IDE3LFxuXG4gICAgLyoqIEUuZy4gJCNmb28gI2JhciAqL1xuICAgIEFOQ0VTVE9SOiAxOCxcblxuICAgIC8qKiBFLmcuICNmb28gPiAkYmFyID4gI2JheiAqL1xuICAgIENPTVBPVU5EX1NQTElUOiAxOSxcblxuICAgIC8qKiBBbHdheXMgbWF0Y2hlcywgdXNlZnVsIHBsYWNlaG9sZGVyIGZvciBzdWJqZWN0IGluIGBDT01QT1VORF9TUExJVGAgKi9cbiAgICBUUlVFOiAyMFxuICB9O1xuXG4gIHZhciBzdGF0ZVNlbGVjdG9ycyA9IFt7XG4gICAgc2VsZWN0b3I6ICc6c2VsZWN0ZWQnLFxuICAgIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLnNlbGVjdGVkKCk7XG4gICAgfVxuICB9LCB7XG4gICAgc2VsZWN0b3I6ICc6dW5zZWxlY3RlZCcsXG4gICAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICAgIHJldHVybiAhZWxlLnNlbGVjdGVkKCk7XG4gICAgfVxuICB9LCB7XG4gICAgc2VsZWN0b3I6ICc6c2VsZWN0YWJsZScsXG4gICAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuc2VsZWN0YWJsZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIHNlbGVjdG9yOiAnOnVuc2VsZWN0YWJsZScsXG4gICAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICAgIHJldHVybiAhZWxlLnNlbGVjdGFibGUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBzZWxlY3RvcjogJzpsb2NrZWQnLFxuICAgIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLmxvY2tlZCgpO1xuICAgIH1cbiAgfSwge1xuICAgIHNlbGVjdG9yOiAnOnVubG9ja2VkJyxcbiAgICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgICAgcmV0dXJuICFlbGUubG9ja2VkKCk7XG4gICAgfVxuICB9LCB7XG4gICAgc2VsZWN0b3I6ICc6dmlzaWJsZScsXG4gICAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICAgIHJldHVybiBlbGUudmlzaWJsZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIHNlbGVjdG9yOiAnOmhpZGRlbicsXG4gICAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICAgIHJldHVybiAhZWxlLnZpc2libGUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBzZWxlY3RvcjogJzp0cmFuc3BhcmVudCcsXG4gICAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICAgIHJldHVybiBlbGUudHJhbnNwYXJlbnQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBzZWxlY3RvcjogJzpncmFiYmVkJyxcbiAgICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5ncmFiYmVkKCk7XG4gICAgfVxuICB9LCB7XG4gICAgc2VsZWN0b3I6ICc6ZnJlZScsXG4gICAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICAgIHJldHVybiAhZWxlLmdyYWJiZWQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBzZWxlY3RvcjogJzpyZW1vdmVkJyxcbiAgICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5yZW1vdmVkKCk7XG4gICAgfVxuICB9LCB7XG4gICAgc2VsZWN0b3I6ICc6aW5zaWRlJyxcbiAgICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgICAgcmV0dXJuICFlbGUucmVtb3ZlZCgpO1xuICAgIH1cbiAgfSwge1xuICAgIHNlbGVjdG9yOiAnOmdyYWJiYWJsZScsXG4gICAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuZ3JhYmJhYmxlKCk7XG4gICAgfVxuICB9LCB7XG4gICAgc2VsZWN0b3I6ICc6dW5ncmFiYmFibGUnLFxuICAgIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgICByZXR1cm4gIWVsZS5ncmFiYmFibGUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBzZWxlY3RvcjogJzphbmltYXRlZCcsXG4gICAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuYW5pbWF0ZWQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBzZWxlY3RvcjogJzp1bmFuaW1hdGVkJyxcbiAgICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgICAgcmV0dXJuICFlbGUuYW5pbWF0ZWQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBzZWxlY3RvcjogJzpwYXJlbnQnLFxuICAgIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLmlzUGFyZW50KCk7XG4gICAgfVxuICB9LCB7XG4gICAgc2VsZWN0b3I6ICc6Y2hpbGRsZXNzJyxcbiAgICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5pc0NoaWxkbGVzcygpO1xuICAgIH1cbiAgfSwge1xuICAgIHNlbGVjdG9yOiAnOmNoaWxkJyxcbiAgICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5pc0NoaWxkKCk7XG4gICAgfVxuICB9LCB7XG4gICAgc2VsZWN0b3I6ICc6b3JwaGFuJyxcbiAgICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5pc09ycGhhbigpO1xuICAgIH1cbiAgfSwge1xuICAgIHNlbGVjdG9yOiAnOm5vbm9ycGhhbicsXG4gICAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuaXNDaGlsZCgpO1xuICAgIH1cbiAgfSwge1xuICAgIHNlbGVjdG9yOiAnOmNvbXBvdW5kJyxcbiAgICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgICByZXR1cm4gZWxlLmlzUGFyZW50KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZWxlLnNvdXJjZSgpLmlzUGFyZW50KCkgfHwgZWxlLnRhcmdldCgpLmlzUGFyZW50KCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAgc2VsZWN0b3I6ICc6bG9vcCcsXG4gICAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuaXNMb29wKCk7XG4gICAgfVxuICB9LCB7XG4gICAgc2VsZWN0b3I6ICc6c2ltcGxlJyxcbiAgICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5pc1NpbXBsZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIHNlbGVjdG9yOiAnOmFjdGl2ZScsXG4gICAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuYWN0aXZlKCk7XG4gICAgfVxuICB9LCB7XG4gICAgc2VsZWN0b3I6ICc6aW5hY3RpdmUnLFxuICAgIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgICByZXR1cm4gIWVsZS5hY3RpdmUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBzZWxlY3RvcjogJzpiYWNrZ3JvdW5kaW5nJyxcbiAgICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5iYWNrZ3JvdW5kaW5nKCk7XG4gICAgfVxuICB9LCB7XG4gICAgc2VsZWN0b3I6ICc6bm9uYmFja2dyb3VuZGluZycsXG4gICAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICAgIHJldHVybiAhZWxlLmJhY2tncm91bmRpbmcoKTtcbiAgICB9XG4gIH1dLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAvLyBuLmIuIHNlbGVjdG9ycyB0aGF0IGFyZSBzdGFydGluZyBzdWJzdHJpbmdzIG9mIG90aGVycyBtdXN0IGhhdmUgdGhlIGxvbmdlciBvbmVzIGZpcnN0XG4gICAgcmV0dXJuIGRlc2NlbmRpbmcoYS5zZWxlY3RvciwgYi5zZWxlY3Rvcik7XG4gIH0pO1xuXG4gIHZhciBsb29rdXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbFRvRm4gPSB7fTtcbiAgICB2YXIgcztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGVTZWxlY3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHMgPSBzdGF0ZVNlbGVjdG9yc1tpXTtcbiAgICAgIHNlbFRvRm5bcy5zZWxlY3Rvcl0gPSBzLm1hdGNoZXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbFRvRm47XG4gIH0oKTtcblxuICB2YXIgc3RhdGVTZWxlY3Rvck1hdGNoZXMgPSBmdW5jdGlvbiBzdGF0ZVNlbGVjdG9yTWF0Y2hlcyhzZWwsIGVsZSkge1xuICAgIHJldHVybiBsb29rdXBbc2VsXShlbGUpO1xuICB9O1xuICB2YXIgc3RhdGVTZWxlY3RvclJlZ2V4ID0gJygnICsgc3RhdGVTZWxlY3RvcnMubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgcmV0dXJuIHMuc2VsZWN0b3I7XG4gIH0pLmpvaW4oJ3wnKSArICcpJztcblxuICAvLyBzbyB0aGF0IHZhbHVlcyBnZXQgY29tcGFyZWQgcHJvcGVybHkgaW4gU2VsZWN0b3IuZmlsdGVyKClcblxuICB2YXIgY2xlYW5NZXRhQ2hhcnMgPSBmdW5jdGlvbiBjbGVhbk1ldGFDaGFycyhzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UobmV3IFJlZ0V4cCgnXFxcXFxcXFwoJyArIHRva2Vucy5tZXRhQ2hhciArICcpJywgJ2cnKSwgZnVuY3Rpb24gKG1hdGNoLCAkMSkge1xuICAgICAgcmV0dXJuICQxO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciByZXBsYWNlTGFzdFF1ZXJ5ID0gZnVuY3Rpb24gcmVwbGFjZUxhc3RRdWVyeShzZWxlY3RvciwgZXhhbWluaW5nUXVlcnksIHJlcGxhY2VtZW50UXVlcnkpIHtcbiAgICBzZWxlY3RvcltzZWxlY3Rvci5sZW5ndGggLSAxXSA9IHJlcGxhY2VtZW50UXVlcnk7XG4gIH07IC8vIE5PVEU6IGFkZCBuZXcgZXhwcmVzc2lvbiBzeW50YXggaGVyZSB0byBoYXZlIGl0IHJlY29nbmlzZWQgYnkgdGhlIHBhcnNlcjtcbiAgLy8gLSBhIHF1ZXJ5IGNvbnRhaW5zIGFsbCBhZGphY2VudCAoaS5lLiBubyBzZXBhcmF0b3IgaW4gYmV0d2VlbikgZXhwcmVzc2lvbnM7XG4gIC8vIC0gdGhlIGN1cnJlbnQgcXVlcnkgaXMgc3RvcmVkIGluIHNlbGVjdG9yW2ldXG4gIC8vIC0geW91IG5lZWQgdG8gY2hlY2sgdGhlIHF1ZXJ5IG9iamVjdHMgaW4gbWF0Y2goKSBmb3IgaXQgYWN0dWFsbHkgZmlsdGVyIHByb3Blcmx5LCBidXQgdGhhdCdzIHByZXR0eSBzdHJhaWdodCBmb3J3YXJkXG5cblxuICB2YXIgZXhwcnMgPSBbe1xuICAgIG5hbWU6ICdncm91cCcsXG4gICAgLy8ganVzdCB1c2VkIGZvciBpZGVudGlmeWluZyB3aGVuIGRlYnVnZ2luZ1xuICAgIHF1ZXJ5OiB0cnVlLFxuICAgIHJlZ2V4OiAnKCcgKyB0b2tlbnMuZ3JvdXAgKyAnKScsXG4gICAgcG9wdWxhdGU6IGZ1bmN0aW9uIHBvcHVsYXRlKHNlbGVjdG9yLCBxdWVyeSwgX3JlZikge1xuICAgICAgdmFyIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMSksXG4gICAgICAgICAgZ3JvdXAgPSBfcmVmMlswXTtcblxuICAgICAgcXVlcnkuY2hlY2tzLnB1c2goe1xuICAgICAgICB0eXBlOiBUeXBlLkdST1VQLFxuICAgICAgICB2YWx1ZTogZ3JvdXAgPT09ICcqJyA/IGdyb3VwIDogZ3JvdXAgKyAncydcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIG5hbWU6ICdzdGF0ZScsXG4gICAgcXVlcnk6IHRydWUsXG4gICAgcmVnZXg6IHN0YXRlU2VsZWN0b3JSZWdleCxcbiAgICBwb3B1bGF0ZTogZnVuY3Rpb24gcG9wdWxhdGUoc2VsZWN0b3IsIHF1ZXJ5LCBfcmVmMykge1xuICAgICAgdmFyIF9yZWY0ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjMsIDEpLFxuICAgICAgICAgIHN0YXRlID0gX3JlZjRbMF07XG5cbiAgICAgIHF1ZXJ5LmNoZWNrcy5wdXNoKHtcbiAgICAgICAgdHlwZTogVHlwZS5TVEFURSxcbiAgICAgICAgdmFsdWU6IHN0YXRlXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBuYW1lOiAnaWQnLFxuICAgIHF1ZXJ5OiB0cnVlLFxuICAgIHJlZ2V4OiAnXFxcXCMoJyArIHRva2Vucy5pZCArICcpJyxcbiAgICBwb3B1bGF0ZTogZnVuY3Rpb24gcG9wdWxhdGUoc2VsZWN0b3IsIHF1ZXJ5LCBfcmVmNSkge1xuICAgICAgdmFyIF9yZWY2ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjUsIDEpLFxuICAgICAgICAgIGlkID0gX3JlZjZbMF07XG5cbiAgICAgIHF1ZXJ5LmNoZWNrcy5wdXNoKHtcbiAgICAgICAgdHlwZTogVHlwZS5JRCxcbiAgICAgICAgdmFsdWU6IGNsZWFuTWV0YUNoYXJzKGlkKVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAgbmFtZTogJ2NsYXNzTmFtZScsXG4gICAgcXVlcnk6IHRydWUsXG4gICAgcmVnZXg6ICdcXFxcLignICsgdG9rZW5zLmNsYXNzTmFtZSArICcpJyxcbiAgICBwb3B1bGF0ZTogZnVuY3Rpb24gcG9wdWxhdGUoc2VsZWN0b3IsIHF1ZXJ5LCBfcmVmNykge1xuICAgICAgdmFyIF9yZWY4ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjcsIDEpLFxuICAgICAgICAgIGNsYXNzTmFtZSA9IF9yZWY4WzBdO1xuXG4gICAgICBxdWVyeS5jaGVja3MucHVzaCh7XG4gICAgICAgIHR5cGU6IFR5cGUuQ0xBU1MsXG4gICAgICAgIHZhbHVlOiBjbGVhbk1ldGFDaGFycyhjbGFzc05hbWUpXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBuYW1lOiAnZGF0YUV4aXN0cycsXG4gICAgcXVlcnk6IHRydWUsXG4gICAgcmVnZXg6ICdcXFxcW1xcXFxzKignICsgdG9rZW5zLnZhcmlhYmxlICsgJylcXFxccypcXFxcXScsXG4gICAgcG9wdWxhdGU6IGZ1bmN0aW9uIHBvcHVsYXRlKHNlbGVjdG9yLCBxdWVyeSwgX3JlZjkpIHtcbiAgICAgIHZhciBfcmVmMTAgPSBfc2xpY2VkVG9BcnJheShfcmVmOSwgMSksXG4gICAgICAgICAgdmFyaWFibGUgPSBfcmVmMTBbMF07XG5cbiAgICAgIHF1ZXJ5LmNoZWNrcy5wdXNoKHtcbiAgICAgICAgdHlwZTogVHlwZS5EQVRBX0VYSVNULFxuICAgICAgICBmaWVsZDogY2xlYW5NZXRhQ2hhcnModmFyaWFibGUpXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBuYW1lOiAnZGF0YUNvbXBhcmUnLFxuICAgIHF1ZXJ5OiB0cnVlLFxuICAgIHJlZ2V4OiAnXFxcXFtcXFxccyooJyArIHRva2Vucy52YXJpYWJsZSArICcpXFxcXHMqKCcgKyB0b2tlbnMuY29tcGFyYXRvck9wICsgJylcXFxccyooJyArIHRva2Vucy52YWx1ZSArICcpXFxcXHMqXFxcXF0nLFxuICAgIHBvcHVsYXRlOiBmdW5jdGlvbiBwb3B1bGF0ZShzZWxlY3RvciwgcXVlcnksIF9yZWYxMSkge1xuICAgICAgdmFyIF9yZWYxMiA9IF9zbGljZWRUb0FycmF5KF9yZWYxMSwgMyksXG4gICAgICAgICAgdmFyaWFibGUgPSBfcmVmMTJbMF0sXG4gICAgICAgICAgY29tcGFyYXRvck9wID0gX3JlZjEyWzFdLFxuICAgICAgICAgIHZhbHVlID0gX3JlZjEyWzJdO1xuXG4gICAgICB2YXIgdmFsdWVJc1N0cmluZyA9IG5ldyBSZWdFeHAoJ14nICsgdG9rZW5zLnN0cmluZyArICckJykuZXhlYyh2YWx1ZSkgIT0gbnVsbDtcblxuICAgICAgaWYgKHZhbHVlSXNTdHJpbmcpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoMSwgdmFsdWUubGVuZ3RoIC0gMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBxdWVyeS5jaGVja3MucHVzaCh7XG4gICAgICAgIHR5cGU6IFR5cGUuREFUQV9DT01QQVJFLFxuICAgICAgICBmaWVsZDogY2xlYW5NZXRhQ2hhcnModmFyaWFibGUpLFxuICAgICAgICBvcGVyYXRvcjogY29tcGFyYXRvck9wLFxuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIG5hbWU6ICdkYXRhQm9vbCcsXG4gICAgcXVlcnk6IHRydWUsXG4gICAgcmVnZXg6ICdcXFxcW1xcXFxzKignICsgdG9rZW5zLmJvb2xPcCArICcpXFxcXHMqKCcgKyB0b2tlbnMudmFyaWFibGUgKyAnKVxcXFxzKlxcXFxdJyxcbiAgICBwb3B1bGF0ZTogZnVuY3Rpb24gcG9wdWxhdGUoc2VsZWN0b3IsIHF1ZXJ5LCBfcmVmMTMpIHtcbiAgICAgIHZhciBfcmVmMTQgPSBfc2xpY2VkVG9BcnJheShfcmVmMTMsIDIpLFxuICAgICAgICAgIGJvb2xPcCA9IF9yZWYxNFswXSxcbiAgICAgICAgICB2YXJpYWJsZSA9IF9yZWYxNFsxXTtcblxuICAgICAgcXVlcnkuY2hlY2tzLnB1c2goe1xuICAgICAgICB0eXBlOiBUeXBlLkRBVEFfQk9PTCxcbiAgICAgICAgZmllbGQ6IGNsZWFuTWV0YUNoYXJzKHZhcmlhYmxlKSxcbiAgICAgICAgb3BlcmF0b3I6IGJvb2xPcFxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAgbmFtZTogJ21ldGFDb21wYXJlJyxcbiAgICBxdWVyeTogdHJ1ZSxcbiAgICByZWdleDogJ1xcXFxbXFxcXFtcXFxccyooJyArIHRva2Vucy5tZXRhICsgJylcXFxccyooJyArIHRva2Vucy5jb21wYXJhdG9yT3AgKyAnKVxcXFxzKignICsgdG9rZW5zLm51bWJlciArICcpXFxcXHMqXFxcXF1cXFxcXScsXG4gICAgcG9wdWxhdGU6IGZ1bmN0aW9uIHBvcHVsYXRlKHNlbGVjdG9yLCBxdWVyeSwgX3JlZjE1KSB7XG4gICAgICB2YXIgX3JlZjE2ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjE1LCAzKSxcbiAgICAgICAgICBtZXRhID0gX3JlZjE2WzBdLFxuICAgICAgICAgIGNvbXBhcmF0b3JPcCA9IF9yZWYxNlsxXSxcbiAgICAgICAgICBudW1iZXIgPSBfcmVmMTZbMl07XG5cbiAgICAgIHF1ZXJ5LmNoZWNrcy5wdXNoKHtcbiAgICAgICAgdHlwZTogVHlwZS5NRVRBX0NPTVBBUkUsXG4gICAgICAgIGZpZWxkOiBjbGVhbk1ldGFDaGFycyhtZXRhKSxcbiAgICAgICAgb3BlcmF0b3I6IGNvbXBhcmF0b3JPcCxcbiAgICAgICAgdmFsdWU6IHBhcnNlRmxvYXQobnVtYmVyKVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAgbmFtZTogJ25leHRRdWVyeScsXG4gICAgc2VwYXJhdG9yOiB0cnVlLFxuICAgIHJlZ2V4OiB0b2tlbnMuc2VwYXJhdG9yLFxuICAgIHBvcHVsYXRlOiBmdW5jdGlvbiBwb3B1bGF0ZShzZWxlY3RvciwgcXVlcnkpIHtcbiAgICAgIHZhciBjdXJyZW50U3ViamVjdCA9IHNlbGVjdG9yLmN1cnJlbnRTdWJqZWN0O1xuICAgICAgdmFyIGVkZ2VDb3VudCA9IHNlbGVjdG9yLmVkZ2VDb3VudDtcbiAgICAgIHZhciBjb21wb3VuZENvdW50ID0gc2VsZWN0b3IuY29tcG91bmRDb3VudDtcbiAgICAgIHZhciBsYXN0USA9IHNlbGVjdG9yW3NlbGVjdG9yLmxlbmd0aCAtIDFdO1xuXG4gICAgICBpZiAoY3VycmVudFN1YmplY3QgIT0gbnVsbCkge1xuICAgICAgICBsYXN0US5zdWJqZWN0ID0gY3VycmVudFN1YmplY3Q7XG4gICAgICAgIHNlbGVjdG9yLmN1cnJlbnRTdWJqZWN0ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgbGFzdFEuZWRnZUNvdW50ID0gZWRnZUNvdW50O1xuICAgICAgbGFzdFEuY29tcG91bmRDb3VudCA9IGNvbXBvdW5kQ291bnQ7XG4gICAgICBzZWxlY3Rvci5lZGdlQ291bnQgPSAwO1xuICAgICAgc2VsZWN0b3IuY29tcG91bmRDb3VudCA9IDA7IC8vIGdvIG9uIHRvIG5leHQgcXVlcnlcblxuICAgICAgdmFyIG5leHRRdWVyeSA9IHNlbGVjdG9yW3NlbGVjdG9yLmxlbmd0aCsrXSA9IG5ld1F1ZXJ5KCk7XG4gICAgICByZXR1cm4gbmV4dFF1ZXJ5OyAvLyB0aGlzIGlzIHRoZSBuZXcgcXVlcnkgdG8gYmUgZmlsbGVkIGJ5IHRoZSBmb2xsb3dpbmcgZXhwcnNcbiAgICB9XG4gIH0sIHtcbiAgICBuYW1lOiAnZGlyZWN0ZWRFZGdlJyxcbiAgICBzZXBhcmF0b3I6IHRydWUsXG4gICAgcmVnZXg6IHRva2Vucy5kaXJlY3RlZEVkZ2UsXG4gICAgcG9wdWxhdGU6IGZ1bmN0aW9uIHBvcHVsYXRlKHNlbGVjdG9yLCBxdWVyeSkge1xuICAgICAgaWYgKHNlbGVjdG9yLmN1cnJlbnRTdWJqZWN0ID09IG51bGwpIHtcbiAgICAgICAgLy8gdW5kaXJlY3RlZCBlZGdlXG4gICAgICAgIHZhciBlZGdlUXVlcnkgPSBuZXdRdWVyeSgpO1xuICAgICAgICB2YXIgc291cmNlID0gcXVlcnk7XG4gICAgICAgIHZhciB0YXJnZXQgPSBuZXdRdWVyeSgpO1xuICAgICAgICBlZGdlUXVlcnkuY2hlY2tzLnB1c2goe1xuICAgICAgICAgIHR5cGU6IFR5cGUuRElSRUNURURfRURHRSxcbiAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICB0YXJnZXQ6IHRhcmdldFxuICAgICAgICB9KTsgLy8gdGhlIHF1ZXJ5IGluIHRoZSBzZWxlY3RvciBzaG91bGQgYmUgdGhlIGVkZ2UgcmF0aGVyIHRoYW4gdGhlIHNvdXJjZVxuXG4gICAgICAgIHJlcGxhY2VMYXN0UXVlcnkoc2VsZWN0b3IsIHF1ZXJ5LCBlZGdlUXVlcnkpO1xuICAgICAgICBzZWxlY3Rvci5lZGdlQ291bnQrKzsgLy8gd2UncmUgbm93IHBvcHVsYXRpbmcgdGhlIHRhcmdldCBxdWVyeSB3aXRoIGV4cHJlc3Npb25zIHRoYXQgZm9sbG93XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHNvdXJjZS90YXJnZXRcbiAgICAgICAgdmFyIHNyY1RndFEgPSBuZXdRdWVyeSgpO1xuICAgICAgICB2YXIgX3NvdXJjZSA9IHF1ZXJ5O1xuXG4gICAgICAgIHZhciBfdGFyZ2V0ID0gbmV3UXVlcnkoKTtcblxuICAgICAgICBzcmNUZ3RRLmNoZWNrcy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBUeXBlLk5PREVfU09VUkNFLFxuICAgICAgICAgIHNvdXJjZTogX3NvdXJjZSxcbiAgICAgICAgICB0YXJnZXQ6IF90YXJnZXRcbiAgICAgICAgfSk7IC8vIHRoZSBxdWVyeSBpbiB0aGUgc2VsZWN0b3Igc2hvdWxkIGJlIHRoZSBuZWlnaGJvdXJob29kIHJhdGhlciB0aGFuIHRoZSBub2RlXG5cbiAgICAgICAgcmVwbGFjZUxhc3RRdWVyeShzZWxlY3RvciwgcXVlcnksIHNyY1RndFEpO1xuICAgICAgICBzZWxlY3Rvci5lZGdlQ291bnQrKztcbiAgICAgICAgcmV0dXJuIF90YXJnZXQ7IC8vIG5vdyBwb3B1bGF0aW5nIHRoZSB0YXJnZXQgd2l0aCB0aGUgZm9sbG93aW5nIGV4cHJlc3Npb25zXG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAgbmFtZTogJ3VuZGlyZWN0ZWRFZGdlJyxcbiAgICBzZXBhcmF0b3I6IHRydWUsXG4gICAgcmVnZXg6IHRva2Vucy51bmRpcmVjdGVkRWRnZSxcbiAgICBwb3B1bGF0ZTogZnVuY3Rpb24gcG9wdWxhdGUoc2VsZWN0b3IsIHF1ZXJ5KSB7XG4gICAgICBpZiAoc2VsZWN0b3IuY3VycmVudFN1YmplY3QgPT0gbnVsbCkge1xuICAgICAgICAvLyB1bmRpcmVjdGVkIGVkZ2VcbiAgICAgICAgdmFyIGVkZ2VRdWVyeSA9IG5ld1F1ZXJ5KCk7XG4gICAgICAgIHZhciBzb3VyY2UgPSBxdWVyeTtcbiAgICAgICAgdmFyIHRhcmdldCA9IG5ld1F1ZXJ5KCk7XG4gICAgICAgIGVkZ2VRdWVyeS5jaGVja3MucHVzaCh7XG4gICAgICAgICAgdHlwZTogVHlwZS5VTkRJUkVDVEVEX0VER0UsXG4gICAgICAgICAgbm9kZXM6IFtzb3VyY2UsIHRhcmdldF1cbiAgICAgICAgfSk7IC8vIHRoZSBxdWVyeSBpbiB0aGUgc2VsZWN0b3Igc2hvdWxkIGJlIHRoZSBlZGdlIHJhdGhlciB0aGFuIHRoZSBzb3VyY2VcblxuICAgICAgICByZXBsYWNlTGFzdFF1ZXJ5KHNlbGVjdG9yLCBxdWVyeSwgZWRnZVF1ZXJ5KTtcbiAgICAgICAgc2VsZWN0b3IuZWRnZUNvdW50Kys7IC8vIHdlJ3JlIG5vdyBwb3B1bGF0aW5nIHRoZSB0YXJnZXQgcXVlcnkgd2l0aCBleHByZXNzaW9ucyB0aGF0IGZvbGxvd1xuXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBuZWlnaGJvdXJob29kXG4gICAgICAgIHZhciBuaG9vZFEgPSBuZXdRdWVyeSgpO1xuICAgICAgICB2YXIgbm9kZSA9IHF1ZXJ5O1xuICAgICAgICB2YXIgbmVpZ2hib3IgPSBuZXdRdWVyeSgpO1xuICAgICAgICBuaG9vZFEuY2hlY2tzLnB1c2goe1xuICAgICAgICAgIHR5cGU6IFR5cGUuTk9ERV9ORUlHSEJPUixcbiAgICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICAgIG5laWdoYm9yOiBuZWlnaGJvclxuICAgICAgICB9KTsgLy8gdGhlIHF1ZXJ5IGluIHRoZSBzZWxlY3RvciBzaG91bGQgYmUgdGhlIG5laWdoYm91cmhvb2QgcmF0aGVyIHRoYW4gdGhlIG5vZGVcblxuICAgICAgICByZXBsYWNlTGFzdFF1ZXJ5KHNlbGVjdG9yLCBxdWVyeSwgbmhvb2RRKTtcbiAgICAgICAgcmV0dXJuIG5laWdoYm9yOyAvLyBub3cgcG9wdWxhdGluZyB0aGUgbmVpZ2hib3Igd2l0aCBmb2xsb3dpbmcgZXhwcmVzc2lvbnNcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBuYW1lOiAnY2hpbGQnLFxuICAgIHNlcGFyYXRvcjogdHJ1ZSxcbiAgICByZWdleDogdG9rZW5zLmNoaWxkLFxuICAgIHBvcHVsYXRlOiBmdW5jdGlvbiBwb3B1bGF0ZShzZWxlY3RvciwgcXVlcnkpIHtcbiAgICAgIGlmIChzZWxlY3Rvci5jdXJyZW50U3ViamVjdCA9PSBudWxsKSB7XG4gICAgICAgIC8vIGRlZmF1bHQ6IGNoaWxkIHF1ZXJ5XG4gICAgICAgIHZhciBwYXJlbnRDaGlsZFF1ZXJ5ID0gbmV3UXVlcnkoKTtcbiAgICAgICAgdmFyIGNoaWxkID0gbmV3UXVlcnkoKTtcbiAgICAgICAgdmFyIHBhcmVudCA9IHNlbGVjdG9yW3NlbGVjdG9yLmxlbmd0aCAtIDFdO1xuICAgICAgICBwYXJlbnRDaGlsZFF1ZXJ5LmNoZWNrcy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBUeXBlLkNISUxELFxuICAgICAgICAgIHBhcmVudDogcGFyZW50LFxuICAgICAgICAgIGNoaWxkOiBjaGlsZFxuICAgICAgICB9KTsgLy8gdGhlIHF1ZXJ5IGluIHRoZSBzZWxlY3RvciBzaG91bGQgYmUgdGhlICc+JyBpdHNlbGZcblxuICAgICAgICByZXBsYWNlTGFzdFF1ZXJ5KHNlbGVjdG9yLCBxdWVyeSwgcGFyZW50Q2hpbGRRdWVyeSk7XG4gICAgICAgIHNlbGVjdG9yLmNvbXBvdW5kQ291bnQrKzsgLy8gd2UncmUgbm93IHBvcHVsYXRpbmcgdGhlIGNoaWxkIHF1ZXJ5IHdpdGggZXhwcmVzc2lvbnMgdGhhdCBmb2xsb3dcblxuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICB9IGVsc2UgaWYgKHNlbGVjdG9yLmN1cnJlbnRTdWJqZWN0ID09PSBxdWVyeSkge1xuICAgICAgICAvLyBjb21wb3VuZCBzcGxpdCBxdWVyeVxuICAgICAgICB2YXIgY29tcG91bmQgPSBuZXdRdWVyeSgpO1xuICAgICAgICB2YXIgbGVmdCA9IHNlbGVjdG9yW3NlbGVjdG9yLmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgcmlnaHQgPSBuZXdRdWVyeSgpO1xuICAgICAgICB2YXIgc3ViamVjdCA9IG5ld1F1ZXJ5KCk7XG5cbiAgICAgICAgdmFyIF9jaGlsZCA9IG5ld1F1ZXJ5KCk7XG5cbiAgICAgICAgdmFyIF9wYXJlbnQgPSBuZXdRdWVyeSgpOyAvLyBzZXQgdXAgdGhlIHJvb3QgY29tcG91bmQgcVxuXG5cbiAgICAgICAgY29tcG91bmQuY2hlY2tzLnB1c2goe1xuICAgICAgICAgIHR5cGU6IFR5cGUuQ09NUE9VTkRfU1BMSVQsXG4gICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICByaWdodDogcmlnaHQsXG4gICAgICAgICAgc3ViamVjdDogc3ViamVjdFxuICAgICAgICB9KTsgLy8gcG9wdWxhdGUgdGhlIHN1YmplY3QgYW5kIHJlcGxhY2UgdGhlIHEgYXQgdGhlIG9sZCBzcG90ICh3aXRoaW4gbGVmdCkgd2l0aCBUUlVFXG5cbiAgICAgICAgc3ViamVjdC5jaGVja3MgPSBxdWVyeS5jaGVja3M7IC8vIHRha2UgdGhlIGNoZWNrcyBmcm9tIHRoZSBsZWZ0XG5cbiAgICAgICAgcXVlcnkuY2hlY2tzID0gW3tcbiAgICAgICAgICB0eXBlOiBUeXBlLlRSVUVcbiAgICAgICAgfV07IC8vIGNoZWNrcyB1bmRlciBsZWZ0IHJlZnMgdGhlIHN1YmplY3QgaW1wbGljaXRseVxuICAgICAgICAvLyBzZXQgdXAgdGhlIHJpZ2h0IHFcblxuICAgICAgICBfcGFyZW50LmNoZWNrcy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBUeXBlLlRSVUVcbiAgICAgICAgfSk7IC8vIHBhcmVudCBpbXBsaWNpdGx5IHJlZnMgdGhlIHN1YmplY3RcblxuXG4gICAgICAgIHJpZ2h0LmNoZWNrcy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBUeXBlLlBBUkVOVCxcbiAgICAgICAgICAvLyB0eXBlIGlzIHN3YXBwZWQgb24gcmlnaHQgc2lkZSBxdWVyaWVzXG4gICAgICAgICAgcGFyZW50OiBfcGFyZW50LFxuICAgICAgICAgIGNoaWxkOiBfY2hpbGQgLy8gZW1wdHkgZm9yIG5vd1xuXG4gICAgICAgIH0pO1xuICAgICAgICByZXBsYWNlTGFzdFF1ZXJ5KHNlbGVjdG9yLCBsZWZ0LCBjb21wb3VuZCk7IC8vIHVwZGF0ZSB0aGUgcmVmIHNpbmNlIHdlIG1vdmVkIHRoaW5ncyBhcm91bmQgZm9yIGBxdWVyeWBcblxuICAgICAgICBzZWxlY3Rvci5jdXJyZW50U3ViamVjdCA9IHN1YmplY3Q7XG4gICAgICAgIHNlbGVjdG9yLmNvbXBvdW5kQ291bnQrKztcbiAgICAgICAgcmV0dXJuIF9jaGlsZDsgLy8gbm93IHBvcHVsYXRpbmcgdGhlIHJpZ2h0IHNpZGUncyBjaGlsZFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcGFyZW50IHF1ZXJ5XG4gICAgICAgIC8vIGluZm8gZm9yIHBhcmVudCBxdWVyeVxuICAgICAgICB2YXIgX3BhcmVudDIgPSBuZXdRdWVyeSgpO1xuXG4gICAgICAgIHZhciBfY2hpbGQyID0gbmV3UXVlcnkoKTtcblxuICAgICAgICB2YXIgcGNRQ2hlY2tzID0gW3tcbiAgICAgICAgICB0eXBlOiBUeXBlLlBBUkVOVCxcbiAgICAgICAgICBwYXJlbnQ6IF9wYXJlbnQyLFxuICAgICAgICAgIGNoaWxkOiBfY2hpbGQyXG4gICAgICAgIH1dOyAvLyB0aGUgcGFyZW50LWNoaWxkIHF1ZXJ5IHRha2VzIHRoZSBwbGFjZSBvZiB0aGUgcXVlcnkgcHJldmlvdXNseSBiZWluZyBwb3B1bGF0ZWRcblxuICAgICAgICBfcGFyZW50Mi5jaGVja3MgPSBxdWVyeS5jaGVja3M7IC8vIHRoZSBwcmV2aW91cyBxdWVyeSBjb250YWlucyB0aGUgY2hlY2tzIGZvciB0aGUgcGFyZW50XG5cbiAgICAgICAgcXVlcnkuY2hlY2tzID0gcGNRQ2hlY2tzOyAvLyBwYyBxdWVyeSB0YWtlcyBvdmVyXG5cbiAgICAgICAgc2VsZWN0b3IuY29tcG91bmRDb3VudCsrO1xuICAgICAgICByZXR1cm4gX2NoaWxkMjsgLy8gd2UncmUgbm93IHBvcHVsYXRpbmcgdGhlIGNoaWxkXG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAgbmFtZTogJ2Rlc2NlbmRhbnQnLFxuICAgIHNlcGFyYXRvcjogdHJ1ZSxcbiAgICByZWdleDogdG9rZW5zLmRlc2NlbmRhbnQsXG4gICAgcG9wdWxhdGU6IGZ1bmN0aW9uIHBvcHVsYXRlKHNlbGVjdG9yLCBxdWVyeSkge1xuICAgICAgaWYgKHNlbGVjdG9yLmN1cnJlbnRTdWJqZWN0ID09IG51bGwpIHtcbiAgICAgICAgLy8gZGVmYXVsdDogZGVzY2VuZGFudCBxdWVyeVxuICAgICAgICB2YXIgYW5jQ2hRdWVyeSA9IG5ld1F1ZXJ5KCk7XG4gICAgICAgIHZhciBkZXNjZW5kYW50ID0gbmV3UXVlcnkoKTtcbiAgICAgICAgdmFyIGFuY2VzdG9yID0gc2VsZWN0b3Jbc2VsZWN0b3IubGVuZ3RoIC0gMV07XG4gICAgICAgIGFuY0NoUXVlcnkuY2hlY2tzLnB1c2goe1xuICAgICAgICAgIHR5cGU6IFR5cGUuREVTQ0VOREFOVCxcbiAgICAgICAgICBhbmNlc3RvcjogYW5jZXN0b3IsXG4gICAgICAgICAgZGVzY2VuZGFudDogZGVzY2VuZGFudFxuICAgICAgICB9KTsgLy8gdGhlIHF1ZXJ5IGluIHRoZSBzZWxlY3RvciBzaG91bGQgYmUgdGhlICc+JyBpdHNlbGZcblxuICAgICAgICByZXBsYWNlTGFzdFF1ZXJ5KHNlbGVjdG9yLCBxdWVyeSwgYW5jQ2hRdWVyeSk7XG4gICAgICAgIHNlbGVjdG9yLmNvbXBvdW5kQ291bnQrKzsgLy8gd2UncmUgbm93IHBvcHVsYXRpbmcgdGhlIGRlc2NlbmRhbnQgcXVlcnkgd2l0aCBleHByZXNzaW9ucyB0aGF0IGZvbGxvd1xuXG4gICAgICAgIHJldHVybiBkZXNjZW5kYW50O1xuICAgICAgfSBlbHNlIGlmIChzZWxlY3Rvci5jdXJyZW50U3ViamVjdCA9PT0gcXVlcnkpIHtcbiAgICAgICAgLy8gY29tcG91bmQgc3BsaXQgcXVlcnlcbiAgICAgICAgdmFyIGNvbXBvdW5kID0gbmV3UXVlcnkoKTtcbiAgICAgICAgdmFyIGxlZnQgPSBzZWxlY3RvcltzZWxlY3Rvci5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIHJpZ2h0ID0gbmV3UXVlcnkoKTtcbiAgICAgICAgdmFyIHN1YmplY3QgPSBuZXdRdWVyeSgpO1xuXG4gICAgICAgIHZhciBfZGVzY2VuZGFudCA9IG5ld1F1ZXJ5KCk7XG5cbiAgICAgICAgdmFyIF9hbmNlc3RvciA9IG5ld1F1ZXJ5KCk7IC8vIHNldCB1cCB0aGUgcm9vdCBjb21wb3VuZCBxXG5cblxuICAgICAgICBjb21wb3VuZC5jaGVja3MucHVzaCh7XG4gICAgICAgICAgdHlwZTogVHlwZS5DT01QT1VORF9TUExJVCxcbiAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICAgIHJpZ2h0OiByaWdodCxcbiAgICAgICAgICBzdWJqZWN0OiBzdWJqZWN0XG4gICAgICAgIH0pOyAvLyBwb3B1bGF0ZSB0aGUgc3ViamVjdCBhbmQgcmVwbGFjZSB0aGUgcSBhdCB0aGUgb2xkIHNwb3QgKHdpdGhpbiBsZWZ0KSB3aXRoIFRSVUVcblxuICAgICAgICBzdWJqZWN0LmNoZWNrcyA9IHF1ZXJ5LmNoZWNrczsgLy8gdGFrZSB0aGUgY2hlY2tzIGZyb20gdGhlIGxlZnRcblxuICAgICAgICBxdWVyeS5jaGVja3MgPSBbe1xuICAgICAgICAgIHR5cGU6IFR5cGUuVFJVRVxuICAgICAgICB9XTsgLy8gY2hlY2tzIHVuZGVyIGxlZnQgcmVmcyB0aGUgc3ViamVjdCBpbXBsaWNpdGx5XG4gICAgICAgIC8vIHNldCB1cCB0aGUgcmlnaHQgcVxuXG4gICAgICAgIF9hbmNlc3Rvci5jaGVja3MucHVzaCh7XG4gICAgICAgICAgdHlwZTogVHlwZS5UUlVFXG4gICAgICAgIH0pOyAvLyBhbmNlc3RvciBpbXBsaWNpdGx5IHJlZnMgdGhlIHN1YmplY3RcblxuXG4gICAgICAgIHJpZ2h0LmNoZWNrcy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBUeXBlLkFOQ0VTVE9SLFxuICAgICAgICAgIC8vIHR5cGUgaXMgc3dhcHBlZCBvbiByaWdodCBzaWRlIHF1ZXJpZXNcbiAgICAgICAgICBhbmNlc3RvcjogX2FuY2VzdG9yLFxuICAgICAgICAgIGRlc2NlbmRhbnQ6IF9kZXNjZW5kYW50IC8vIGVtcHR5IGZvciBub3dcblxuICAgICAgICB9KTtcbiAgICAgICAgcmVwbGFjZUxhc3RRdWVyeShzZWxlY3RvciwgbGVmdCwgY29tcG91bmQpOyAvLyB1cGRhdGUgdGhlIHJlZiBzaW5jZSB3ZSBtb3ZlZCB0aGluZ3MgYXJvdW5kIGZvciBgcXVlcnlgXG5cbiAgICAgICAgc2VsZWN0b3IuY3VycmVudFN1YmplY3QgPSBzdWJqZWN0O1xuICAgICAgICBzZWxlY3Rvci5jb21wb3VuZENvdW50Kys7XG4gICAgICAgIHJldHVybiBfZGVzY2VuZGFudDsgLy8gbm93IHBvcHVsYXRpbmcgdGhlIHJpZ2h0IHNpZGUncyBkZXNjZW5kYW50XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBhbmNlc3RvciBxdWVyeVxuICAgICAgICAvLyBpbmZvIGZvciBwYXJlbnQgcXVlcnlcbiAgICAgICAgdmFyIF9hbmNlc3RvcjIgPSBuZXdRdWVyeSgpO1xuXG4gICAgICAgIHZhciBfZGVzY2VuZGFudDIgPSBuZXdRdWVyeSgpO1xuXG4gICAgICAgIHZhciBhZFFDaGVja3MgPSBbe1xuICAgICAgICAgIHR5cGU6IFR5cGUuQU5DRVNUT1IsXG4gICAgICAgICAgYW5jZXN0b3I6IF9hbmNlc3RvcjIsXG4gICAgICAgICAgZGVzY2VuZGFudDogX2Rlc2NlbmRhbnQyXG4gICAgICAgIH1dOyAvLyB0aGUgcGFyZW50LWNoaWxkIHF1ZXJ5IHRha2VzIHRoZSBwbGFjZSBvZiB0aGUgcXVlcnkgcHJldmlvdXNseSBiZWluZyBwb3B1bGF0ZWRcblxuICAgICAgICBfYW5jZXN0b3IyLmNoZWNrcyA9IHF1ZXJ5LmNoZWNrczsgLy8gdGhlIHByZXZpb3VzIHF1ZXJ5IGNvbnRhaW5zIHRoZSBjaGVja3MgZm9yIHRoZSBwYXJlbnRcblxuICAgICAgICBxdWVyeS5jaGVja3MgPSBhZFFDaGVja3M7IC8vIHBjIHF1ZXJ5IHRha2VzIG92ZXJcblxuICAgICAgICBzZWxlY3Rvci5jb21wb3VuZENvdW50Kys7XG4gICAgICAgIHJldHVybiBfZGVzY2VuZGFudDI7IC8vIHdlJ3JlIG5vdyBwb3B1bGF0aW5nIHRoZSBjaGlsZFxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIG5hbWU6ICdzdWJqZWN0JyxcbiAgICBtb2RpZmllcjogdHJ1ZSxcbiAgICByZWdleDogdG9rZW5zLnN1YmplY3QsXG4gICAgcG9wdWxhdGU6IGZ1bmN0aW9uIHBvcHVsYXRlKHNlbGVjdG9yLCBxdWVyeSkge1xuICAgICAgaWYgKHNlbGVjdG9yLmN1cnJlbnRTdWJqZWN0ICE9IG51bGwgJiYgc2VsZWN0b3IuY3VycmVudFN1YmplY3QgIT09IHF1ZXJ5KSB7XG4gICAgICAgIHdhcm4oJ1JlZGVmaW5pdGlvbiBvZiBzdWJqZWN0IGluIHNlbGVjdG9yIGAnICsgc2VsZWN0b3IudG9TdHJpbmcoKSArICdgJyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgc2VsZWN0b3IuY3VycmVudFN1YmplY3QgPSBxdWVyeTtcbiAgICAgIHZhciB0b3BRID0gc2VsZWN0b3Jbc2VsZWN0b3IubGVuZ3RoIC0gMV07XG4gICAgICB2YXIgdG9wQ2hrID0gdG9wUS5jaGVja3NbMF07XG4gICAgICB2YXIgdG9wVHlwZSA9IHRvcENoayA9PSBudWxsID8gbnVsbCA6IHRvcENoay50eXBlO1xuXG4gICAgICBpZiAodG9wVHlwZSA9PT0gVHlwZS5ESVJFQ1RFRF9FREdFKSB7XG4gICAgICAgIC8vIGRpcmVjdGVkIGVkZ2Ugd2l0aCBzdWJqZWN0IG9uIHRoZSB0YXJnZXRcbiAgICAgICAgLy8gY2hhbmdlIHRvIHRhcmdldCBub2RlIGNoZWNrXG4gICAgICAgIHRvcENoay50eXBlID0gVHlwZS5OT0RFX1RBUkdFVDtcbiAgICAgIH0gZWxzZSBpZiAodG9wVHlwZSA9PT0gVHlwZS5VTkRJUkVDVEVEX0VER0UpIHtcbiAgICAgICAgLy8gdW5kaXJlY3RlZCBlZGdlIHdpdGggc3ViamVjdCBvbiB0aGUgc2Vjb25kIG5vZGVcbiAgICAgICAgLy8gY2hhbmdlIHRvIG5laWdoYm9yIGNoZWNrXG4gICAgICAgIHRvcENoay50eXBlID0gVHlwZS5OT0RFX05FSUdIQk9SO1xuICAgICAgICB0b3BDaGsubm9kZSA9IHRvcENoay5ub2Rlc1sxXTsgLy8gc2Vjb25kIG5vZGUgaXMgc3ViamVjdFxuXG4gICAgICAgIHRvcENoay5uZWlnaGJvciA9IHRvcENoay5ub2Rlc1swXTsgLy8gY2xlYW4gdXAgdW51c2VkIGZpZWxkcyBmb3IgbmV3IHR5cGVcblxuICAgICAgICB0b3BDaGsubm9kZXMgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfV07XG4gIGV4cHJzLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICByZXR1cm4gZS5yZWdleE9iaiA9IG5ldyBSZWdFeHAoJ14nICsgZS5yZWdleCk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBPZiBhbGwgdGhlIGV4cHJlc3Npb25zLCBmaW5kIHRoZSBmaXJzdCBtYXRjaCBpbiB0aGUgcmVtYWluaW5nIHRleHQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZW1haW5pbmcgVGhlIHJlbWFpbmluZyB0ZXh0IHRvIHBhcnNlXG4gICAqIEByZXR1cm5zIFRoZSBtYXRjaGVkIGV4cHJlc3Npb24gYW5kIHRoZSBuZXdseSByZW1haW5pbmcgdGV4dCBgeyBleHByLCBtYXRjaCwgbmFtZSwgcmVtYWluaW5nIH1gXG4gICAqL1xuXG4gIHZhciBjb25zdW1lRXhwciA9IGZ1bmN0aW9uIGNvbnN1bWVFeHByKHJlbWFpbmluZykge1xuICAgIHZhciBleHByO1xuICAgIHZhciBtYXRjaDtcbiAgICB2YXIgbmFtZTtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgZXhwcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBlID0gZXhwcnNbal07XG4gICAgICB2YXIgbiA9IGUubmFtZTtcbiAgICAgIHZhciBtID0gcmVtYWluaW5nLm1hdGNoKGUucmVnZXhPYmopO1xuXG4gICAgICBpZiAobSAhPSBudWxsKSB7XG4gICAgICAgIG1hdGNoID0gbTtcbiAgICAgICAgZXhwciA9IGU7XG4gICAgICAgIG5hbWUgPSBuO1xuICAgICAgICB2YXIgY29uc3VtZWQgPSBtWzBdO1xuICAgICAgICByZW1haW5pbmcgPSByZW1haW5pbmcuc3Vic3RyaW5nKGNvbnN1bWVkLmxlbmd0aCk7XG4gICAgICAgIGJyZWFrOyAvLyB3ZSd2ZSBjb25zdW1lZCBvbmUgZXhwciwgc28gd2UgY2FuIHJldHVybiBub3dcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZXhwcjogZXhwcixcbiAgICAgIG1hdGNoOiBtYXRjaCxcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICByZW1haW5pbmc6IHJlbWFpbmluZ1xuICAgIH07XG4gIH07XG4gIC8qKlxuICAgKiBDb25zdW1lIGFsbCB0aGUgbGVhZGluZyB3aGl0ZXNwYWNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZW1haW5pbmcgVGhlIHRleHQgdG8gY29uc3VtZVxuICAgKiBAcmV0dXJucyBUaGUgdGV4dCB3aXRoIHRoZSBsZWFkaW5nIHdoaXRlc3BhY2UgcmVtb3ZlZFxuICAgKi9cblxuXG4gIHZhciBjb25zdW1lV2hpdGVzcGFjZSA9IGZ1bmN0aW9uIGNvbnN1bWVXaGl0ZXNwYWNlKHJlbWFpbmluZykge1xuICAgIHZhciBtYXRjaCA9IHJlbWFpbmluZy5tYXRjaCgvXlxccysvKTtcblxuICAgIGlmIChtYXRjaCkge1xuICAgICAgdmFyIGNvbnN1bWVkID0gbWF0Y2hbMF07XG4gICAgICByZW1haW5pbmcgPSByZW1haW5pbmcuc3Vic3RyaW5nKGNvbnN1bWVkLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlbWFpbmluZztcbiAgfTtcbiAgLyoqXG4gICAqIFBhcnNlIHRoZSBzdHJpbmcgYW5kIHN0b3JlIHRoZSBwYXJzZWQgcmVwcmVzZW50YXRpb24gaW4gdGhlIFNlbGVjdG9yLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgVGhlIHNlbGVjdG9yIHN0cmluZ1xuICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHNlbGVjdG9yIHdhcyBzdWNjZXNzZnVsbHkgcGFyc2VkLCBgZmFsc2VgIG90aGVyd2lzZVxuICAgKi9cblxuXG4gIHZhciBwYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKHNlbGVjdG9yKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciByZW1haW5pbmcgPSBzZWxmLmlucHV0VGV4dCA9IHNlbGVjdG9yO1xuICAgIHZhciBjdXJyZW50UXVlcnkgPSBzZWxmWzBdID0gbmV3UXVlcnkoKTtcbiAgICBzZWxmLmxlbmd0aCA9IDE7XG4gICAgcmVtYWluaW5nID0gY29uc3VtZVdoaXRlc3BhY2UocmVtYWluaW5nKTsgLy8gZ2V0IHJpZCBvZiBsZWFkaW5nIHdoaXRlc3BhY2VcblxuICAgIGZvciAoOzspIHtcbiAgICAgIHZhciBleHBySW5mbyA9IGNvbnN1bWVFeHByKHJlbWFpbmluZyk7XG5cbiAgICAgIGlmIChleHBySW5mby5leHByID09IG51bGwpIHtcbiAgICAgICAgd2FybignVGhlIHNlbGVjdG9yIGAnICsgc2VsZWN0b3IgKyAnYGlzIGludmFsaWQnKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBleHBySW5mby5tYXRjaC5zbGljZSgxKTsgLy8gbGV0IHRoZSB0b2tlbiBwb3B1bGF0ZSB0aGUgc2VsZWN0b3Igb2JqZWN0IGluIGN1cnJlbnRRdWVyeVxuXG4gICAgICAgIHZhciByZXQgPSBleHBySW5mby5leHByLnBvcHVsYXRlKHNlbGYsIGN1cnJlbnRRdWVyeSwgYXJncyk7XG5cbiAgICAgICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIGV4aXQgaWYgcG9wdWxhdGlvbiBmYWlsZWRcbiAgICAgICAgfSBlbHNlIGlmIChyZXQgIT0gbnVsbCkge1xuICAgICAgICAgIGN1cnJlbnRRdWVyeSA9IHJldDsgLy8gY2hhbmdlIHRoZSBjdXJyZW50IHF1ZXJ5IHRvIGJlIGZpbGxlZCBpZiB0aGUgZXhwciBzcGVjaWZpZXNcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZW1haW5pbmcgPSBleHBySW5mby5yZW1haW5pbmc7IC8vIHdlJ3JlIGRvbmUgd2hlbiB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byBwYXJzZVxuXG4gICAgICBpZiAocmVtYWluaW5nLm1hdGNoKC9eXFxzKiQvKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbGFzdFEgPSBzZWxmW3NlbGYubGVuZ3RoIC0gMV07XG5cbiAgICBpZiAoc2VsZi5jdXJyZW50U3ViamVjdCAhPSBudWxsKSB7XG4gICAgICBsYXN0US5zdWJqZWN0ID0gc2VsZi5jdXJyZW50U3ViamVjdDtcbiAgICB9XG5cbiAgICBsYXN0US5lZGdlQ291bnQgPSBzZWxmLmVkZ2VDb3VudDtcbiAgICBsYXN0US5jb21wb3VuZENvdW50ID0gc2VsZi5jb21wb3VuZENvdW50O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcSA9IHNlbGZbaV07IC8vIGluIGZ1dHVyZSwgdGhpcyBjb3VsZCBwb3RlbnRpYWxseSBiZSBhbGxvd2VkIGlmIHRoZXJlIHdlcmUgb3BlcmF0b3IgcHJlY2VkZW5jZSBhbmQgZGV0ZWN0aW9uIG9mIGludmFsaWQgY29tYmluYXRpb25zXG5cbiAgICAgIGlmIChxLmNvbXBvdW5kQ291bnQgPiAwICYmIHEuZWRnZUNvdW50ID4gMCkge1xuICAgICAgICB3YXJuKCdUaGUgc2VsZWN0b3IgYCcgKyBzZWxlY3RvciArICdgIGlzIGludmFsaWQgYmVjYXVzZSBpdCB1c2VzIGJvdGggYSBjb21wb3VuZCBzZWxlY3RvciBhbmQgYW4gZWRnZSBzZWxlY3RvcicpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChxLmVkZ2VDb3VudCA+IDEpIHtcbiAgICAgICAgd2FybignVGhlIHNlbGVjdG9yIGAnICsgc2VsZWN0b3IgKyAnYCBpcyBpbnZhbGlkIGJlY2F1c2UgaXQgdXNlcyBtdWx0aXBsZSBlZGdlIHNlbGVjdG9ycycpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKHEuZWRnZUNvdW50ID09PSAxKSB7XG4gICAgICAgIHdhcm4oJ1RoZSBzZWxlY3RvciBgJyArIHNlbGVjdG9yICsgJ2AgaXMgZGVwcmVjYXRlZC4gIEVkZ2Ugc2VsZWN0b3JzIGRvIG5vdCB0YWtlIGVmZmVjdCBvbiBjaGFuZ2VzIHRvIHNvdXJjZSBhbmQgdGFyZ2V0IG5vZGVzIGFmdGVyIGFuIGVkZ2UgaXMgYWRkZWQsIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLiAgVXNlIGEgY2xhc3Mgb3IgZGF0YSBzZWxlY3RvciBvbiBlZGdlcyBpbnN0ZWFkLCB1cGRhdGluZyB0aGUgY2xhc3Mgb3IgZGF0YSBvZiBhbiBlZGdlIHdoZW4geW91ciBhcHAgZGV0ZWN0cyBhIGNoYW5nZSBpbiBzb3VyY2Ugb3IgdGFyZ2V0IG5vZGVzLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlOyAvLyBzdWNjZXNzXG4gIH07XG4gIC8qKlxuICAgKiBHZXQgdGhlIHNlbGVjdG9yIHJlcHJlc2VudGVkIGFzIGEgc3RyaW5nLiAgVGhpcyB2YWx1ZSB1c2VzIGRlZmF1bHQgZm9ybWF0dGluZyxcbiAgICogc28gdGhpbmdzIGxpa2Ugc3BhY2luZyBtYXkgZGlmZmVyIGZyb20gdGhlIGlucHV0IHRleHQgcGFzc2VkIHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIHNlbGVjdG9yIHN0cmluZ1xuICAgKi9cblxuXG4gIHZhciB0b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIGlmICh0aGlzLnRvU3RyaW5nQ2FjaGUgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMudG9TdHJpbmdDYWNoZTtcbiAgICB9XG5cbiAgICB2YXIgY2xlYW4gPSBmdW5jdGlvbiBjbGVhbihvYmopIHtcbiAgICAgIGlmIChvYmogPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgY2xlYW5WYWwgPSBmdW5jdGlvbiBjbGVhblZhbCh2YWwpIHtcbiAgICAgIGlmIChzdHJpbmcodmFsKSkge1xuICAgICAgICByZXR1cm4gJ1wiJyArIHZhbCArICdcIic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY2xlYW4odmFsKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHNwYWNlID0gZnVuY3Rpb24gc3BhY2UodmFsKSB7XG4gICAgICByZXR1cm4gJyAnICsgdmFsICsgJyAnO1xuICAgIH07XG5cbiAgICB2YXIgY2hlY2tUb1N0cmluZyA9IGZ1bmN0aW9uIGNoZWNrVG9TdHJpbmcoY2hlY2ssIHN1YmplY3QpIHtcbiAgICAgIHZhciB0eXBlID0gY2hlY2sudHlwZSxcbiAgICAgICAgICB2YWx1ZSA9IGNoZWNrLnZhbHVlO1xuXG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBUeXBlLkdST1VQOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBncm91cCA9IGNsZWFuKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBncm91cC5zdWJzdHJpbmcoMCwgZ3JvdXAubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgVHlwZS5EQVRBX0NPTVBBUkU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIGZpZWxkID0gY2hlY2suZmllbGQsXG4gICAgICAgICAgICAgICAgb3BlcmF0b3IgPSBjaGVjay5vcGVyYXRvcjtcbiAgICAgICAgICAgIHJldHVybiAnWycgKyBmaWVsZCArIHNwYWNlKGNsZWFuKG9wZXJhdG9yKSkgKyBjbGVhblZhbCh2YWx1ZSkgKyAnXSc7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgVHlwZS5EQVRBX0JPT0w6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9vcGVyYXRvciA9IGNoZWNrLm9wZXJhdG9yLFxuICAgICAgICAgICAgICAgIF9maWVsZCA9IGNoZWNrLmZpZWxkO1xuICAgICAgICAgICAgcmV0dXJuICdbJyArIGNsZWFuKF9vcGVyYXRvcikgKyBfZmllbGQgKyAnXSc7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgVHlwZS5EQVRBX0VYSVNUOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfZmllbGQyID0gY2hlY2suZmllbGQ7XG4gICAgICAgICAgICByZXR1cm4gJ1snICsgX2ZpZWxkMiArICddJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBUeXBlLk1FVEFfQ09NUEFSRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX29wZXJhdG9yMiA9IGNoZWNrLm9wZXJhdG9yLFxuICAgICAgICAgICAgICAgIF9maWVsZDMgPSBjaGVjay5maWVsZDtcbiAgICAgICAgICAgIHJldHVybiAnW1snICsgX2ZpZWxkMyArIHNwYWNlKGNsZWFuKF9vcGVyYXRvcjIpKSArIGNsZWFuVmFsKHZhbHVlKSArICddXSc7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgVHlwZS5TVEFURTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgVHlwZS5JRDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gJyMnICsgdmFsdWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgVHlwZS5DTEFTUzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gJy4nICsgdmFsdWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgVHlwZS5QQVJFTlQ6XG4gICAgICAgIGNhc2UgVHlwZS5DSElMRDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gcXVlcnlUb1N0cmluZyhjaGVjay5wYXJlbnQsIHN1YmplY3QpICsgc3BhY2UoJz4nKSArIHF1ZXJ5VG9TdHJpbmcoY2hlY2suY2hpbGQsIHN1YmplY3QpO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFR5cGUuQU5DRVNUT1I6XG4gICAgICAgIGNhc2UgVHlwZS5ERVNDRU5EQU5UOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBxdWVyeVRvU3RyaW5nKGNoZWNrLmFuY2VzdG9yLCBzdWJqZWN0KSArICcgJyArIHF1ZXJ5VG9TdHJpbmcoY2hlY2suZGVzY2VuZGFudCwgc3ViamVjdCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgVHlwZS5DT01QT1VORF9TUExJVDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgbGhzID0gcXVlcnlUb1N0cmluZyhjaGVjay5sZWZ0LCBzdWJqZWN0KTtcbiAgICAgICAgICAgIHZhciBzdWIgPSBxdWVyeVRvU3RyaW5nKGNoZWNrLnN1YmplY3QsIHN1YmplY3QpO1xuICAgICAgICAgICAgdmFyIHJocyA9IHF1ZXJ5VG9TdHJpbmcoY2hlY2sucmlnaHQsIHN1YmplY3QpO1xuICAgICAgICAgICAgcmV0dXJuIGxocyArIChsaHMubGVuZ3RoID4gMCA/ICcgJyA6ICcnKSArIHN1YiArIHJocztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBUeXBlLlRSVUU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHF1ZXJ5VG9TdHJpbmcgPSBmdW5jdGlvbiBxdWVyeVRvU3RyaW5nKHF1ZXJ5LCBzdWJqZWN0KSB7XG4gICAgICByZXR1cm4gcXVlcnkuY2hlY2tzLnJlZHVjZShmdW5jdGlvbiAoc3RyLCBjaGssIGkpIHtcbiAgICAgICAgcmV0dXJuIHN0ciArIChzdWJqZWN0ID09PSBxdWVyeSAmJiBpID09PSAwID8gJyQnIDogJycpICsgY2hlY2tUb1N0cmluZyhjaGssIHN1YmplY3QpO1xuICAgICAgfSwgJycpO1xuICAgIH07XG5cbiAgICB2YXIgc3RyID0gJyc7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBxdWVyeSA9IHRoaXNbaV07XG4gICAgICBzdHIgKz0gcXVlcnlUb1N0cmluZyhxdWVyeSwgcXVlcnkuc3ViamVjdCk7XG5cbiAgICAgIGlmICh0aGlzLmxlbmd0aCA+IDEgJiYgaSA8IHRoaXMubGVuZ3RoIC0gMSkge1xuICAgICAgICBzdHIgKz0gJywgJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnRvU3RyaW5nQ2FjaGUgPSBzdHI7XG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcbiAgdmFyIHBhcnNlJDEgPSB7XG4gICAgcGFyc2U6IHBhcnNlLFxuICAgIHRvU3RyaW5nOiB0b1N0cmluZ1xuICB9O1xuXG4gIHZhciB2YWxDbXAgPSBmdW5jdGlvbiB2YWxDbXAoZmllbGRWYWwsIG9wZXJhdG9yLCB2YWx1ZSkge1xuICAgIHZhciBtYXRjaGVzO1xuICAgIHZhciBpc0ZpZWxkU3RyID0gc3RyaW5nKGZpZWxkVmFsKTtcbiAgICB2YXIgaXNGaWVsZE51bSA9IG51bWJlciQxKGZpZWxkVmFsKTtcbiAgICB2YXIgaXNWYWxTdHIgPSBzdHJpbmcodmFsdWUpO1xuICAgIHZhciBmaWVsZFN0ciwgdmFsU3RyO1xuICAgIHZhciBjYXNlSW5zZW5zaXRpdmUgPSBmYWxzZTtcbiAgICB2YXIgbm90RXhwciA9IGZhbHNlO1xuICAgIHZhciBpc0luZXFDbXAgPSBmYWxzZTtcblxuICAgIGlmIChvcGVyYXRvci5pbmRleE9mKCchJykgPj0gMCkge1xuICAgICAgb3BlcmF0b3IgPSBvcGVyYXRvci5yZXBsYWNlKCchJywgJycpO1xuICAgICAgbm90RXhwciA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG9wZXJhdG9yLmluZGV4T2YoJ0AnKSA+PSAwKSB7XG4gICAgICBvcGVyYXRvciA9IG9wZXJhdG9yLnJlcGxhY2UoJ0AnLCAnJyk7XG4gICAgICBjYXNlSW5zZW5zaXRpdmUgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChpc0ZpZWxkU3RyIHx8IGlzVmFsU3RyIHx8IGNhc2VJbnNlbnNpdGl2ZSkge1xuICAgICAgZmllbGRTdHIgPSAhaXNGaWVsZFN0ciAmJiAhaXNGaWVsZE51bSA/ICcnIDogJycgKyBmaWVsZFZhbDtcbiAgICAgIHZhbFN0ciA9ICcnICsgdmFsdWU7XG4gICAgfSAvLyBpZiB3ZSdyZSBkb2luZyBhIGNhc2UgaW5zZW5zaXRpdmUgY29tcGFyaXNvbiwgdGhlbiB3ZSdyZSB1c2luZyBhIFNUUklORyBjb21wYXJpc29uXG4gICAgLy8gZXZlbiBpZiB3ZSdyZSBjb21wYXJpbmcgbnVtYmVyc1xuXG5cbiAgICBpZiAoY2FzZUluc2Vuc2l0aXZlKSB7XG4gICAgICBmaWVsZFZhbCA9IGZpZWxkU3RyID0gZmllbGRTdHIudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhbHVlID0gdmFsU3RyID0gdmFsU3RyLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgICAgY2FzZSAnKj0nOlxuICAgICAgICBtYXRjaGVzID0gZmllbGRTdHIuaW5kZXhPZih2YWxTdHIpID49IDA7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICckPSc6XG4gICAgICAgIG1hdGNoZXMgPSBmaWVsZFN0ci5pbmRleE9mKHZhbFN0ciwgZmllbGRTdHIubGVuZ3RoIC0gdmFsU3RyLmxlbmd0aCkgPj0gMDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ149JzpcbiAgICAgICAgbWF0Y2hlcyA9IGZpZWxkU3RyLmluZGV4T2YodmFsU3RyKSA9PT0gMDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJz0nOlxuICAgICAgICBtYXRjaGVzID0gZmllbGRWYWwgPT09IHZhbHVlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnPic6XG4gICAgICAgIGlzSW5lcUNtcCA9IHRydWU7XG4gICAgICAgIG1hdGNoZXMgPSBmaWVsZFZhbCA+IHZhbHVlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnPj0nOlxuICAgICAgICBpc0luZXFDbXAgPSB0cnVlO1xuICAgICAgICBtYXRjaGVzID0gZmllbGRWYWwgPj0gdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICc8JzpcbiAgICAgICAgaXNJbmVxQ21wID0gdHJ1ZTtcbiAgICAgICAgbWF0Y2hlcyA9IGZpZWxkVmFsIDwgdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICc8PSc6XG4gICAgICAgIGlzSW5lcUNtcCA9IHRydWU7XG4gICAgICAgIG1hdGNoZXMgPSBmaWVsZFZhbCA8PSB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIG1hdGNoZXMgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfSAvLyBhcHBseSB0aGUgbm90IG9wLCBidXQgbnVsbCB2YWxzIGZvciBpbmVxdWFsaXRpZXMgc2hvdWxkIGFsd2F5cyBzdGF5IG5vbi1tYXRjaGluZ1xuXG5cbiAgICBpZiAobm90RXhwciAmJiAoZmllbGRWYWwgIT0gbnVsbCB8fCAhaXNJbmVxQ21wKSkge1xuICAgICAgbWF0Y2hlcyA9ICFtYXRjaGVzO1xuICAgIH1cblxuICAgIHJldHVybiBtYXRjaGVzO1xuICB9O1xuICB2YXIgYm9vbENtcCA9IGZ1bmN0aW9uIGJvb2xDbXAoZmllbGRWYWwsIG9wZXJhdG9yKSB7XG4gICAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgICAgY2FzZSAnPyc6XG4gICAgICAgIHJldHVybiBmaWVsZFZhbCA/IHRydWUgOiBmYWxzZTtcblxuICAgICAgY2FzZSAnISc6XG4gICAgICAgIHJldHVybiBmaWVsZFZhbCA/IGZhbHNlIDogdHJ1ZTtcblxuICAgICAgY2FzZSAnXic6XG4gICAgICAgIHJldHVybiBmaWVsZFZhbCA9PT0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfTtcbiAgdmFyIGV4aXN0Q21wID0gZnVuY3Rpb24gZXhpc3RDbXAoZmllbGRWYWwpIHtcbiAgICByZXR1cm4gZmllbGRWYWwgIT09IHVuZGVmaW5lZDtcbiAgfTtcbiAgdmFyIGRhdGEkMSA9IGZ1bmN0aW9uIGRhdGEoZWxlLCBmaWVsZCkge1xuICAgIHJldHVybiBlbGUuZGF0YShmaWVsZCk7XG4gIH07XG4gIHZhciBtZXRhID0gZnVuY3Rpb24gbWV0YShlbGUsIGZpZWxkKSB7XG4gICAgcmV0dXJuIGVsZVtmaWVsZF0oKTtcbiAgfTtcblxuICAvKiogQSBsb29rdXAgb2YgYG1hdGNoKGNoZWNrLCBlbGUpYCBmdW5jdGlvbnMgYnkgYFR5cGVgIGludCAqL1xuXG4gIHZhciBtYXRjaCA9IFtdO1xuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBxdWVyeSBtYXRjaGVzIGZvciB0aGUgZWxlbWVudFxuICAgKiBAcGFyYW0gcXVlcnkgVGhlIGB7IHR5cGUsIHZhbHVlLCAuLi4gfWAgcXVlcnkgb2JqZWN0XG4gICAqIEBwYXJhbSBlbGUgVGhlIGVsZW1lbnQgdG8gY29tcGFyZSBhZ2FpbnN0XG4gICovXG5cbiAgdmFyIG1hdGNoZXMkMSA9IGZ1bmN0aW9uIG1hdGNoZXMocXVlcnksIGVsZSkge1xuICAgIHJldHVybiBxdWVyeS5jaGVja3MuZXZlcnkoZnVuY3Rpb24gKGNoaykge1xuICAgICAgcmV0dXJuIG1hdGNoW2Noay50eXBlXShjaGssIGVsZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgbWF0Y2hbVHlwZS5HUk9VUF0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICAgIHZhciBncm91cCA9IGNoZWNrLnZhbHVlO1xuICAgIHJldHVybiBncm91cCA9PT0gJyonIHx8IGdyb3VwID09PSBlbGUuZ3JvdXAoKTtcbiAgfTtcblxuICBtYXRjaFtUeXBlLlNUQVRFXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gICAgdmFyIHN0YXRlU2VsZWN0b3IgPSBjaGVjay52YWx1ZTtcbiAgICByZXR1cm4gc3RhdGVTZWxlY3Rvck1hdGNoZXMoc3RhdGVTZWxlY3RvciwgZWxlKTtcbiAgfTtcblxuICBtYXRjaFtUeXBlLklEXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gICAgdmFyIGlkID0gY2hlY2sudmFsdWU7XG4gICAgcmV0dXJuIGVsZS5pZCgpID09PSBpZDtcbiAgfTtcblxuICBtYXRjaFtUeXBlLkNMQVNTXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gICAgdmFyIGNscyA9IGNoZWNrLnZhbHVlO1xuICAgIHJldHVybiBlbGUuaGFzQ2xhc3MoY2xzKTtcbiAgfTtcblxuICBtYXRjaFtUeXBlLk1FVEFfQ09NUEFSRV0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICAgIHZhciBmaWVsZCA9IGNoZWNrLmZpZWxkLFxuICAgICAgICBvcGVyYXRvciA9IGNoZWNrLm9wZXJhdG9yLFxuICAgICAgICB2YWx1ZSA9IGNoZWNrLnZhbHVlO1xuICAgIHJldHVybiB2YWxDbXAobWV0YShlbGUsIGZpZWxkKSwgb3BlcmF0b3IsIHZhbHVlKTtcbiAgfTtcblxuICBtYXRjaFtUeXBlLkRBVEFfQ09NUEFSRV0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICAgIHZhciBmaWVsZCA9IGNoZWNrLmZpZWxkLFxuICAgICAgICBvcGVyYXRvciA9IGNoZWNrLm9wZXJhdG9yLFxuICAgICAgICB2YWx1ZSA9IGNoZWNrLnZhbHVlO1xuICAgIHJldHVybiB2YWxDbXAoZGF0YSQxKGVsZSwgZmllbGQpLCBvcGVyYXRvciwgdmFsdWUpO1xuICB9O1xuXG4gIG1hdGNoW1R5cGUuREFUQV9CT09MXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gICAgdmFyIGZpZWxkID0gY2hlY2suZmllbGQsXG4gICAgICAgIG9wZXJhdG9yID0gY2hlY2sub3BlcmF0b3I7XG4gICAgcmV0dXJuIGJvb2xDbXAoZGF0YSQxKGVsZSwgZmllbGQpLCBvcGVyYXRvcik7XG4gIH07XG5cbiAgbWF0Y2hbVHlwZS5EQVRBX0VYSVNUXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gICAgdmFyIGZpZWxkID0gY2hlY2suZmllbGQ7XG4gICAgICAgIGNoZWNrLm9wZXJhdG9yO1xuICAgIHJldHVybiBleGlzdENtcChkYXRhJDEoZWxlLCBmaWVsZCkpO1xuICB9O1xuXG4gIG1hdGNoW1R5cGUuVU5ESVJFQ1RFRF9FREdFXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gICAgdmFyIHFBID0gY2hlY2subm9kZXNbMF07XG4gICAgdmFyIHFCID0gY2hlY2subm9kZXNbMV07XG4gICAgdmFyIHNyYyA9IGVsZS5zb3VyY2UoKTtcbiAgICB2YXIgdGd0ID0gZWxlLnRhcmdldCgpO1xuICAgIHJldHVybiBtYXRjaGVzJDEocUEsIHNyYykgJiYgbWF0Y2hlcyQxKHFCLCB0Z3QpIHx8IG1hdGNoZXMkMShxQiwgc3JjKSAmJiBtYXRjaGVzJDEocUEsIHRndCk7XG4gIH07XG5cbiAgbWF0Y2hbVHlwZS5OT0RFX05FSUdIQk9SXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gICAgcmV0dXJuIG1hdGNoZXMkMShjaGVjay5ub2RlLCBlbGUpICYmIGVsZS5uZWlnaGJvcmhvb2QoKS5zb21lKGZ1bmN0aW9uIChuKSB7XG4gICAgICByZXR1cm4gbi5pc05vZGUoKSAmJiBtYXRjaGVzJDEoY2hlY2submVpZ2hib3IsIG4pO1xuICAgIH0pO1xuICB9O1xuXG4gIG1hdGNoW1R5cGUuRElSRUNURURfRURHRV0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICAgIHJldHVybiBtYXRjaGVzJDEoY2hlY2suc291cmNlLCBlbGUuc291cmNlKCkpICYmIG1hdGNoZXMkMShjaGVjay50YXJnZXQsIGVsZS50YXJnZXQoKSk7XG4gIH07XG5cbiAgbWF0Y2hbVHlwZS5OT0RFX1NPVVJDRV0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICAgIHJldHVybiBtYXRjaGVzJDEoY2hlY2suc291cmNlLCBlbGUpICYmIGVsZS5vdXRnb2VycygpLnNvbWUoZnVuY3Rpb24gKG4pIHtcbiAgICAgIHJldHVybiBuLmlzTm9kZSgpICYmIG1hdGNoZXMkMShjaGVjay50YXJnZXQsIG4pO1xuICAgIH0pO1xuICB9O1xuXG4gIG1hdGNoW1R5cGUuTk9ERV9UQVJHRVRdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgICByZXR1cm4gbWF0Y2hlcyQxKGNoZWNrLnRhcmdldCwgZWxlKSAmJiBlbGUuaW5jb21lcnMoKS5zb21lKGZ1bmN0aW9uIChuKSB7XG4gICAgICByZXR1cm4gbi5pc05vZGUoKSAmJiBtYXRjaGVzJDEoY2hlY2suc291cmNlLCBuKTtcbiAgICB9KTtcbiAgfTtcblxuICBtYXRjaFtUeXBlLkNISUxEXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gICAgcmV0dXJuIG1hdGNoZXMkMShjaGVjay5jaGlsZCwgZWxlKSAmJiBtYXRjaGVzJDEoY2hlY2sucGFyZW50LCBlbGUucGFyZW50KCkpO1xuICB9O1xuXG4gIG1hdGNoW1R5cGUuUEFSRU5UXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gICAgcmV0dXJuIG1hdGNoZXMkMShjaGVjay5wYXJlbnQsIGVsZSkgJiYgZWxlLmNoaWxkcmVuKCkuc29tZShmdW5jdGlvbiAoYykge1xuICAgICAgcmV0dXJuIG1hdGNoZXMkMShjaGVjay5jaGlsZCwgYyk7XG4gICAgfSk7XG4gIH07XG5cbiAgbWF0Y2hbVHlwZS5ERVNDRU5EQU5UXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gICAgcmV0dXJuIG1hdGNoZXMkMShjaGVjay5kZXNjZW5kYW50LCBlbGUpICYmIGVsZS5hbmNlc3RvcnMoKS5zb21lKGZ1bmN0aW9uIChhKSB7XG4gICAgICByZXR1cm4gbWF0Y2hlcyQxKGNoZWNrLmFuY2VzdG9yLCBhKTtcbiAgICB9KTtcbiAgfTtcblxuICBtYXRjaFtUeXBlLkFOQ0VTVE9SXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gICAgcmV0dXJuIG1hdGNoZXMkMShjaGVjay5hbmNlc3RvciwgZWxlKSAmJiBlbGUuZGVzY2VuZGFudHMoKS5zb21lKGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gbWF0Y2hlcyQxKGNoZWNrLmRlc2NlbmRhbnQsIGQpO1xuICAgIH0pO1xuICB9O1xuXG4gIG1hdGNoW1R5cGUuQ09NUE9VTkRfU1BMSVRdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgICByZXR1cm4gbWF0Y2hlcyQxKGNoZWNrLnN1YmplY3QsIGVsZSkgJiYgbWF0Y2hlcyQxKGNoZWNrLmxlZnQsIGVsZSkgJiYgbWF0Y2hlcyQxKGNoZWNrLnJpZ2h0LCBlbGUpO1xuICB9O1xuXG4gIG1hdGNoW1R5cGUuVFJVRV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgbWF0Y2hbVHlwZS5DT0xMRUNUSU9OXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gICAgdmFyIGNvbGxlY3Rpb24gPSBjaGVjay52YWx1ZTtcbiAgICByZXR1cm4gY29sbGVjdGlvbi5oYXMoZWxlKTtcbiAgfTtcblxuICBtYXRjaFtUeXBlLkZJTFRFUl0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICAgIHZhciBmaWx0ZXIgPSBjaGVjay52YWx1ZTtcbiAgICByZXR1cm4gZmlsdGVyKGVsZSk7XG4gIH07XG5cbiAgdmFyIGZpbHRlciA9IGZ1bmN0aW9uIGZpbHRlcihjb2xsZWN0aW9uKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzOyAvLyBmb3IgMSBpZCAjZm9vIHF1ZXJpZXMsIGp1c3QgZ2V0IHRoZSBlbGVtZW50XG5cbiAgICBpZiAoc2VsZi5sZW5ndGggPT09IDEgJiYgc2VsZlswXS5jaGVja3MubGVuZ3RoID09PSAxICYmIHNlbGZbMF0uY2hlY2tzWzBdLnR5cGUgPT09IFR5cGUuSUQpIHtcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uLmdldEVsZW1lbnRCeUlkKHNlbGZbMF0uY2hlY2tzWzBdLnZhbHVlKS5jb2xsZWN0aW9uKCk7XG4gICAgfVxuXG4gICAgdmFyIHNlbGVjdG9yRnVuY3Rpb24gPSBmdW5jdGlvbiBzZWxlY3RvckZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2VsZi5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgcXVlcnkgPSBzZWxmW2pdO1xuXG4gICAgICAgIGlmIChtYXRjaGVzJDEocXVlcnksIGVsZW1lbnQpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBpZiAoc2VsZi50ZXh0KCkgPT0gbnVsbCkge1xuICAgICAgc2VsZWN0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uIHNlbGVjdG9yRnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29sbGVjdGlvbi5maWx0ZXIoc2VsZWN0b3JGdW5jdGlvbik7XG4gIH07IC8vIGZpbHRlclxuICAvLyBkb2VzIHNlbGVjdG9yIG1hdGNoIGEgc2luZ2xlIGVsZW1lbnQ/XG5cblxuICB2YXIgbWF0Y2hlcyA9IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBzZWxmLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgcXVlcnkgPSBzZWxmW2pdO1xuXG4gICAgICBpZiAobWF0Y2hlcyQxKHF1ZXJ5LCBlbGUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTsgLy8gbWF0Y2hlc1xuXG5cbiAgdmFyIG1hdGNoaW5nID0ge1xuICAgIG1hdGNoZXM6IG1hdGNoZXMsXG4gICAgZmlsdGVyOiBmaWx0ZXJcbiAgfTtcblxuICB2YXIgU2VsZWN0b3IgPSBmdW5jdGlvbiBTZWxlY3RvcihzZWxlY3Rvcikge1xuICAgIHRoaXMuaW5wdXRUZXh0ID0gc2VsZWN0b3I7XG4gICAgdGhpcy5jdXJyZW50U3ViamVjdCA9IG51bGw7XG4gICAgdGhpcy5jb21wb3VuZENvdW50ID0gMDtcbiAgICB0aGlzLmVkZ2VDb3VudCA9IDA7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuXG4gICAgaWYgKHNlbGVjdG9yID09IG51bGwgfHwgc3RyaW5nKHNlbGVjdG9yKSAmJiBzZWxlY3Rvci5tYXRjaCgvXlxccyokLykpIDsgZWxzZSBpZiAoZWxlbWVudE9yQ29sbGVjdGlvbihzZWxlY3RvcikpIHtcbiAgICAgIHRoaXMuYWRkUXVlcnkoe1xuICAgICAgICBjaGVja3M6IFt7XG4gICAgICAgICAgdHlwZTogVHlwZS5DT0xMRUNUSU9OLFxuICAgICAgICAgIHZhbHVlOiBzZWxlY3Rvci5jb2xsZWN0aW9uKClcbiAgICAgICAgfV1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoZm4kNihzZWxlY3RvcikpIHtcbiAgICAgIHRoaXMuYWRkUXVlcnkoe1xuICAgICAgICBjaGVja3M6IFt7XG4gICAgICAgICAgdHlwZTogVHlwZS5GSUxURVIsXG4gICAgICAgICAgdmFsdWU6IHNlbGVjdG9yXG4gICAgICAgIH1dXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHN0cmluZyhzZWxlY3RvcikpIHtcbiAgICAgIGlmICghdGhpcy5wYXJzZShzZWxlY3RvcikpIHtcbiAgICAgICAgdGhpcy5pbnZhbGlkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZXJyb3IoJ0Egc2VsZWN0b3IgbXVzdCBiZSBjcmVhdGVkIGZyb20gYSBzdHJpbmc7IGZvdW5kICcpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgc2VsZm4gPSBTZWxlY3Rvci5wcm90b3R5cGU7XG4gIFtwYXJzZSQxLCBtYXRjaGluZ10uZm9yRWFjaChmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiBleHRlbmQoc2VsZm4sIHApO1xuICB9KTtcblxuICBzZWxmbi50ZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmlucHV0VGV4dDtcbiAgfTtcblxuICBzZWxmbi5zaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmxlbmd0aDtcbiAgfTtcblxuICBzZWxmbi5lcSA9IGZ1bmN0aW9uIChpKSB7XG4gICAgcmV0dXJuIHRoaXNbaV07XG4gIH07XG5cbiAgc2VsZm4uc2FtZVRleHQgPSBmdW5jdGlvbiAob3RoZXJTZWwpIHtcbiAgICByZXR1cm4gIXRoaXMuaW52YWxpZCAmJiAhb3RoZXJTZWwuaW52YWxpZCAmJiB0aGlzLnRleHQoKSA9PT0gb3RoZXJTZWwudGV4dCgpO1xuICB9O1xuXG4gIHNlbGZuLmFkZFF1ZXJ5ID0gZnVuY3Rpb24gKHEpIHtcbiAgICB0aGlzW3RoaXMubGVuZ3RoKytdID0gcTtcbiAgfTtcblxuICBzZWxmbi5zZWxlY3RvciA9IHNlbGZuLnRvU3RyaW5nO1xuXG4gIHZhciBlbGVzZm4kZyA9IHtcbiAgICBhbGxBcmU6IGZ1bmN0aW9uIGFsbEFyZShzZWxlY3Rvcikge1xuICAgICAgdmFyIHNlbE9iaiA9IG5ldyBTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgICByZXR1cm4gdGhpcy5ldmVyeShmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgIHJldHVybiBzZWxPYmoubWF0Y2hlcyhlbGUpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBpczogZnVuY3Rpb24gaXMoc2VsZWN0b3IpIHtcbiAgICAgIHZhciBzZWxPYmogPSBuZXcgU2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgICAgcmV0dXJuIHRoaXMuc29tZShmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgIHJldHVybiBzZWxPYmoubWF0Y2hlcyhlbGUpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBzb21lOiBmdW5jdGlvbiBzb21lKGZuLCB0aGlzQXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHJldCA9ICF0aGlzQXJnID8gZm4odGhpc1tpXSwgaSwgdGhpcykgOiBmbi5hcHBseSh0aGlzQXJnLCBbdGhpc1tpXSwgaSwgdGhpc10pO1xuXG4gICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBldmVyeTogZnVuY3Rpb24gZXZlcnkoZm4sIHRoaXNBcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcmV0ID0gIXRoaXNBcmcgPyBmbih0aGlzW2ldLCBpLCB0aGlzKSA6IGZuLmFwcGx5KHRoaXNBcmcsIFt0aGlzW2ldLCBpLCB0aGlzXSk7XG5cbiAgICAgICAgaWYgKCFyZXQpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBzYW1lOiBmdW5jdGlvbiBzYW1lKGNvbGxlY3Rpb24pIHtcbiAgICAgIC8vIGNoZWFwIGNvbGxlY3Rpb24gcmVmIGNoZWNrXG4gICAgICBpZiAodGhpcyA9PT0gY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgY29sbGVjdGlvbiA9IHRoaXMuY3koKS5jb2xsZWN0aW9uKGNvbGxlY3Rpb24pO1xuICAgICAgdmFyIHRoaXNMZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICAgIHZhciBjb2xsZWN0aW9uTGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7IC8vIGNoZWFwIGxlbmd0aCBjaGVja1xuXG4gICAgICBpZiAodGhpc0xlbmd0aCAhPT0gY29sbGVjdGlvbkxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IC8vIGNoZWFwIGVsZW1lbnQgcmVmIGNoZWNrXG5cblxuICAgICAgaWYgKHRoaXNMZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbMF0gPT09IGNvbGxlY3Rpb25bMF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmV2ZXJ5KGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uaGFzRWxlbWVudFdpdGhJZChlbGUuaWQoKSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGFueVNhbWU6IGZ1bmN0aW9uIGFueVNhbWUoY29sbGVjdGlvbikge1xuICAgICAgY29sbGVjdGlvbiA9IHRoaXMuY3koKS5jb2xsZWN0aW9uKGNvbGxlY3Rpb24pO1xuICAgICAgcmV0dXJuIHRoaXMuc29tZShmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uLmhhc0VsZW1lbnRXaXRoSWQoZWxlLmlkKCkpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBhbGxBcmVOZWlnaGJvcnM6IGZ1bmN0aW9uIGFsbEFyZU5laWdoYm9ycyhjb2xsZWN0aW9uKSB7XG4gICAgICBjb2xsZWN0aW9uID0gdGhpcy5jeSgpLmNvbGxlY3Rpb24oY29sbGVjdGlvbik7XG4gICAgICB2YXIgbmhvb2QgPSB0aGlzLm5laWdoYm9yaG9vZCgpO1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uZXZlcnkoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICByZXR1cm4gbmhvb2QuaGFzRWxlbWVudFdpdGhJZChlbGUuaWQoKSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGNvbnRhaW5zOiBmdW5jdGlvbiBjb250YWlucyhjb2xsZWN0aW9uKSB7XG4gICAgICBjb2xsZWN0aW9uID0gdGhpcy5jeSgpLmNvbGxlY3Rpb24oY29sbGVjdGlvbik7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbi5ldmVyeShmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmhhc0VsZW1lbnRXaXRoSWQoZWxlLmlkKCkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBlbGVzZm4kZy5hbGxBcmVOZWlnaGJvdXJzID0gZWxlc2ZuJGcuYWxsQXJlTmVpZ2hib3JzO1xuICBlbGVzZm4kZy5oYXMgPSBlbGVzZm4kZy5jb250YWlucztcbiAgZWxlc2ZuJGcuZXF1YWwgPSBlbGVzZm4kZy5lcXVhbHMgPSBlbGVzZm4kZy5zYW1lO1xuXG4gIHZhciBjYWNoZSA9IGZ1bmN0aW9uIGNhY2hlKGZuLCBuYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHRyYXZlcnNhbENhY2hlKGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQpIHtcbiAgICAgIHZhciBzZWxlY3Rvck9yRWxlcyA9IGFyZzE7XG4gICAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgICB2YXIga2V5O1xuXG4gICAgICBpZiAoc2VsZWN0b3JPckVsZXMgPT0gbnVsbCkge1xuICAgICAgICBrZXkgPSAnJztcbiAgICAgIH0gZWxzZSBpZiAoZWxlbWVudE9yQ29sbGVjdGlvbihzZWxlY3Rvck9yRWxlcykgJiYgc2VsZWN0b3JPckVsZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGtleSA9IHNlbGVjdG9yT3JFbGVzLmlkKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbGVzLmxlbmd0aCA9PT0gMSAmJiBrZXkpIHtcbiAgICAgICAgdmFyIF9wID0gZWxlc1swXS5fcHJpdmF0ZTtcbiAgICAgICAgdmFyIHRjaCA9IF9wLnRyYXZlcnNhbENhY2hlID0gX3AudHJhdmVyc2FsQ2FjaGUgfHwge307XG4gICAgICAgIHZhciBjaCA9IHRjaFtuYW1lXSA9IHRjaFtuYW1lXSB8fCBbXTtcbiAgICAgICAgdmFyIGhhc2ggPSBoYXNoU3RyaW5nKGtleSk7XG4gICAgICAgIHZhciBjYWNoZUhpdCA9IGNoW2hhc2hdO1xuXG4gICAgICAgIGlmIChjYWNoZUhpdCkge1xuICAgICAgICAgIHJldHVybiBjYWNoZUhpdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gY2hbaGFzaF0gPSBmbi5jYWxsKGVsZXMsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZm4uY2FsbChlbGVzLCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0KTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIHZhciBlbGVzZm4kZiA9IHtcbiAgICBwYXJlbnQ6IGZ1bmN0aW9uIHBhcmVudChzZWxlY3Rvcikge1xuICAgICAgdmFyIHBhcmVudHMgPSBbXTsgLy8gb3B0aW1pc2F0aW9uIGZvciBzaW5nbGUgZWxlIGNhbGxcblxuICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzWzBdLl9wcml2YXRlLnBhcmVudDtcblxuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICAgIHZhciBfcGFyZW50ID0gZWxlLl9wcml2YXRlLnBhcmVudDtcblxuICAgICAgICBpZiAoX3BhcmVudCkge1xuICAgICAgICAgIHBhcmVudHMucHVzaChfcGFyZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5zcGF3bihwYXJlbnRzLCB0cnVlKS5maWx0ZXIoc2VsZWN0b3IpO1xuICAgIH0sXG4gICAgcGFyZW50czogZnVuY3Rpb24gcGFyZW50cyhzZWxlY3Rvcikge1xuICAgICAgdmFyIHBhcmVudHMgPSBbXTtcbiAgICAgIHZhciBlbGVzID0gdGhpcy5wYXJlbnQoKTtcblxuICAgICAgd2hpbGUgKGVsZXMubm9uZW1wdHkoKSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgICAgICBwYXJlbnRzLnB1c2goZWxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZXMgPSBlbGVzLnBhcmVudCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5zcGF3bihwYXJlbnRzLCB0cnVlKS5maWx0ZXIoc2VsZWN0b3IpO1xuICAgIH0sXG4gICAgY29tbW9uQW5jZXN0b3JzOiBmdW5jdGlvbiBjb21tb25BbmNlc3RvcnMoc2VsZWN0b3IpIHtcbiAgICAgIHZhciBhbmNlc3RvcnM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgICAgdmFyIHBhcmVudHMgPSBlbGUucGFyZW50cygpO1xuICAgICAgICBhbmNlc3RvcnMgPSBhbmNlc3RvcnMgfHwgcGFyZW50cztcbiAgICAgICAgYW5jZXN0b3JzID0gYW5jZXN0b3JzLmludGVyc2VjdChwYXJlbnRzKTsgLy8gY3VycmVudCBsaXN0IG11c3QgYmUgY29tbW9uIHdpdGggY3VycmVudCBlbGUgcGFyZW50cyBzZXRcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFuY2VzdG9ycy5maWx0ZXIoc2VsZWN0b3IpO1xuICAgIH0sXG4gICAgb3JwaGFuczogZnVuY3Rpb24gb3JwaGFucyhzZWxlY3Rvcikge1xuICAgICAgcmV0dXJuIHRoaXMuc3RkRmlsdGVyKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgcmV0dXJuIGVsZS5pc09ycGhhbigpO1xuICAgICAgfSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgICB9LFxuICAgIG5vbm9ycGhhbnM6IGZ1bmN0aW9uIG5vbm9ycGhhbnMoc2VsZWN0b3IpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0ZEZpbHRlcihmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgIHJldHVybiBlbGUuaXNDaGlsZCgpO1xuICAgICAgfSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgICB9LFxuICAgIGNoaWxkcmVuOiBjYWNoZShmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICAgIHZhciBlbGVDaGlsZHJlbiA9IGVsZS5fcHJpdmF0ZS5jaGlsZHJlbjtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGVsZUNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaChlbGVDaGlsZHJlbltqXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuc3Bhd24oY2hpbGRyZW4sIHRydWUpLmZpbHRlcihzZWxlY3Rvcik7XG4gICAgfSwgJ2NoaWxkcmVuJyksXG4gICAgc2libGluZ3M6IGZ1bmN0aW9uIHNpYmxpbmdzKHNlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQoKS5jaGlsZHJlbigpLm5vdCh0aGlzKS5maWx0ZXIoc2VsZWN0b3IpO1xuICAgIH0sXG4gICAgaXNQYXJlbnQ6IGZ1bmN0aW9uIGlzUGFyZW50KCkge1xuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICAgIGlmIChlbGUpIHtcbiAgICAgICAgcmV0dXJuIGVsZS5pc05vZGUoKSAmJiBlbGUuX3ByaXZhdGUuY2hpbGRyZW4ubGVuZ3RoICE9PSAwO1xuICAgICAgfVxuICAgIH0sXG4gICAgaXNDaGlsZGxlc3M6IGZ1bmN0aW9uIGlzQ2hpbGRsZXNzKCkge1xuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICAgIGlmIChlbGUpIHtcbiAgICAgICAgcmV0dXJuIGVsZS5pc05vZGUoKSAmJiBlbGUuX3ByaXZhdGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwO1xuICAgICAgfVxuICAgIH0sXG4gICAgaXNDaGlsZDogZnVuY3Rpb24gaXNDaGlsZCgpIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgICBpZiAoZWxlKSB7XG4gICAgICAgIHJldHVybiBlbGUuaXNOb2RlKCkgJiYgZWxlLl9wcml2YXRlLnBhcmVudCAhPSBudWxsO1xuICAgICAgfVxuICAgIH0sXG4gICAgaXNPcnBoYW46IGZ1bmN0aW9uIGlzT3JwaGFuKCkge1xuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICAgIGlmIChlbGUpIHtcbiAgICAgICAgcmV0dXJuIGVsZS5pc05vZGUoKSAmJiBlbGUuX3ByaXZhdGUucGFyZW50ID09IG51bGw7XG4gICAgICB9XG4gICAgfSxcbiAgICBkZXNjZW5kYW50czogZnVuY3Rpb24gZGVzY2VuZGFudHMoc2VsZWN0b3IpIHtcbiAgICAgIHZhciBlbGVtZW50cyA9IFtdO1xuXG4gICAgICBmdW5jdGlvbiBhZGQoZWxlcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgICAgICBlbGVtZW50cy5wdXNoKGVsZSk7XG5cbiAgICAgICAgICBpZiAoZWxlLmNoaWxkcmVuKCkubm9uZW1wdHkoKSkge1xuICAgICAgICAgICAgYWRkKGVsZS5jaGlsZHJlbigpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYWRkKHRoaXMuY2hpbGRyZW4oKSk7XG4gICAgICByZXR1cm4gdGhpcy5zcGF3bihlbGVtZW50cywgdHJ1ZSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gZm9yRWFjaENvbXBvdW5kKGVsZXMsIGZuLCBpbmNsdWRlU2VsZiwgcmVjdXJzaXZlU3RlcCkge1xuICAgIHZhciBxID0gW107XG4gICAgdmFyIGRpZCA9IG5ldyBTZXQkMSgpO1xuICAgIHZhciBjeSA9IGVsZXMuY3koKTtcbiAgICB2YXIgaGFzQ29tcG91bmRzID0gY3kuaGFzQ29tcG91bmROb2RlcygpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gZWxlc1tpXTtcblxuICAgICAgaWYgKGluY2x1ZGVTZWxmKSB7XG4gICAgICAgIHEucHVzaChlbGUpO1xuICAgICAgfSBlbHNlIGlmIChoYXNDb21wb3VuZHMpIHtcbiAgICAgICAgcmVjdXJzaXZlU3RlcChxLCBkaWQsIGVsZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgd2hpbGUgKHEubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIF9lbGUgPSBxLnNoaWZ0KCk7XG5cbiAgICAgIGZuKF9lbGUpO1xuICAgICAgZGlkLmFkZChfZWxlLmlkKCkpO1xuXG4gICAgICBpZiAoaGFzQ29tcG91bmRzKSB7XG4gICAgICAgIHJlY3Vyc2l2ZVN0ZXAocSwgZGlkLCBfZWxlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZWxlcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZENoaWxkcmVuKHEsIGRpZCwgZWxlKSB7XG4gICAgaWYgKGVsZS5pc1BhcmVudCgpKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBlbGUuX3ByaXZhdGUuY2hpbGRyZW47XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG5cbiAgICAgICAgaWYgKCFkaWQuaGFzKGNoaWxkLmlkKCkpKSB7XG4gICAgICAgICAgcS5wdXNoKGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSAvLyB2ZXJ5IGVmZmljaWVudCB2ZXJzaW9uIG9mIGVsZXMuYWRkKCBlbGVzLmRlc2NlbmRhbnRzKCkgKS5mb3JFYWNoKClcbiAgLy8gZm9yIGludGVybmFsIHVzZVxuXG5cbiAgZWxlc2ZuJGYuZm9yRWFjaERvd24gPSBmdW5jdGlvbiAoZm4pIHtcbiAgICB2YXIgaW5jbHVkZVNlbGYgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgcmV0dXJuIGZvckVhY2hDb21wb3VuZCh0aGlzLCBmbiwgaW5jbHVkZVNlbGYsIGFkZENoaWxkcmVuKTtcbiAgfTtcblxuICBmdW5jdGlvbiBhZGRQYXJlbnQocSwgZGlkLCBlbGUpIHtcbiAgICBpZiAoZWxlLmlzQ2hpbGQoKSkge1xuICAgICAgdmFyIHBhcmVudCA9IGVsZS5fcHJpdmF0ZS5wYXJlbnQ7XG5cbiAgICAgIGlmICghZGlkLmhhcyhwYXJlbnQuaWQoKSkpIHtcbiAgICAgICAgcS5wdXNoKHBhcmVudCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZWxlc2ZuJGYuZm9yRWFjaFVwID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgdmFyIGluY2x1ZGVTZWxmID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICAgIHJldHVybiBmb3JFYWNoQ29tcG91bmQodGhpcywgZm4sIGluY2x1ZGVTZWxmLCBhZGRQYXJlbnQpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGFkZFBhcmVudEFuZENoaWxkcmVuKHEsIGRpZCwgZWxlKSB7XG4gICAgYWRkUGFyZW50KHEsIGRpZCwgZWxlKTtcbiAgICBhZGRDaGlsZHJlbihxLCBkaWQsIGVsZSk7XG4gIH1cblxuICBlbGVzZm4kZi5mb3JFYWNoVXBBbmREb3duID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgdmFyIGluY2x1ZGVTZWxmID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICAgIHJldHVybiBmb3JFYWNoQ29tcG91bmQodGhpcywgZm4sIGluY2x1ZGVTZWxmLCBhZGRQYXJlbnRBbmRDaGlsZHJlbik7XG4gIH07IC8vIGFsaWFzZXNcblxuXG4gIGVsZXNmbiRmLmFuY2VzdG9ycyA9IGVsZXNmbiRmLnBhcmVudHM7XG5cbiAgdmFyIGZuJDUsIGVsZXNmbiRlO1xuICBmbiQ1ID0gZWxlc2ZuJGUgPSB7XG4gICAgZGF0YTogZGVmaW5lLmRhdGEoe1xuICAgICAgZmllbGQ6ICdkYXRhJyxcbiAgICAgIGJpbmRpbmdFdmVudDogJ2RhdGEnLFxuICAgICAgYWxsb3dCaW5kaW5nOiB0cnVlLFxuICAgICAgYWxsb3dTZXR0aW5nOiB0cnVlLFxuICAgICAgc2V0dGluZ0V2ZW50OiAnZGF0YScsXG4gICAgICBzZXR0aW5nVHJpZ2dlcnNFdmVudDogdHJ1ZSxcbiAgICAgIHRyaWdnZXJGbk5hbWU6ICd0cmlnZ2VyJyxcbiAgICAgIGFsbG93R2V0dGluZzogdHJ1ZSxcbiAgICAgIGltbXV0YWJsZUtleXM6IHtcbiAgICAgICAgJ2lkJzogdHJ1ZSxcbiAgICAgICAgJ3NvdXJjZSc6IHRydWUsXG4gICAgICAgICd0YXJnZXQnOiB0cnVlLFxuICAgICAgICAncGFyZW50JzogdHJ1ZVxuICAgICAgfSxcbiAgICAgIHVwZGF0ZVN0eWxlOiB0cnVlXG4gICAgfSksXG4gICAgcmVtb3ZlRGF0YTogZGVmaW5lLnJlbW92ZURhdGEoe1xuICAgICAgZmllbGQ6ICdkYXRhJyxcbiAgICAgIGV2ZW50OiAnZGF0YScsXG4gICAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgICB0cmlnZ2VyRXZlbnQ6IHRydWUsXG4gICAgICBpbW11dGFibGVLZXlzOiB7XG4gICAgICAgICdpZCc6IHRydWUsXG4gICAgICAgICdzb3VyY2UnOiB0cnVlLFxuICAgICAgICAndGFyZ2V0JzogdHJ1ZSxcbiAgICAgICAgJ3BhcmVudCc6IHRydWVcbiAgICAgIH0sXG4gICAgICB1cGRhdGVTdHlsZTogdHJ1ZVxuICAgIH0pLFxuICAgIHNjcmF0Y2g6IGRlZmluZS5kYXRhKHtcbiAgICAgIGZpZWxkOiAnc2NyYXRjaCcsXG4gICAgICBiaW5kaW5nRXZlbnQ6ICdzY3JhdGNoJyxcbiAgICAgIGFsbG93QmluZGluZzogdHJ1ZSxcbiAgICAgIGFsbG93U2V0dGluZzogdHJ1ZSxcbiAgICAgIHNldHRpbmdFdmVudDogJ3NjcmF0Y2gnLFxuICAgICAgc2V0dGluZ1RyaWdnZXJzRXZlbnQ6IHRydWUsXG4gICAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgICBhbGxvd0dldHRpbmc6IHRydWUsXG4gICAgICB1cGRhdGVTdHlsZTogdHJ1ZVxuICAgIH0pLFxuICAgIHJlbW92ZVNjcmF0Y2g6IGRlZmluZS5yZW1vdmVEYXRhKHtcbiAgICAgIGZpZWxkOiAnc2NyYXRjaCcsXG4gICAgICBldmVudDogJ3NjcmF0Y2gnLFxuICAgICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgICAgdHJpZ2dlckV2ZW50OiB0cnVlLFxuICAgICAgdXBkYXRlU3R5bGU6IHRydWVcbiAgICB9KSxcbiAgICByc2NyYXRjaDogZGVmaW5lLmRhdGEoe1xuICAgICAgZmllbGQ6ICdyc2NyYXRjaCcsXG4gICAgICBhbGxvd0JpbmRpbmc6IGZhbHNlLFxuICAgICAgYWxsb3dTZXR0aW5nOiB0cnVlLFxuICAgICAgc2V0dGluZ1RyaWdnZXJzRXZlbnQ6IGZhbHNlLFxuICAgICAgYWxsb3dHZXR0aW5nOiB0cnVlXG4gICAgfSksXG4gICAgcmVtb3ZlUnNjcmF0Y2g6IGRlZmluZS5yZW1vdmVEYXRhKHtcbiAgICAgIGZpZWxkOiAncnNjcmF0Y2gnLFxuICAgICAgdHJpZ2dlckV2ZW50OiBmYWxzZVxuICAgIH0pLFxuICAgIGlkOiBmdW5jdGlvbiBpZCgpIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgICBpZiAoZWxlKSB7XG4gICAgICAgIHJldHVybiBlbGUuX3ByaXZhdGUuZGF0YS5pZDtcbiAgICAgIH1cbiAgICB9XG4gIH07IC8vIGFsaWFzZXNcblxuICBmbiQ1LmF0dHIgPSBmbiQ1LmRhdGE7XG4gIGZuJDUucmVtb3ZlQXR0ciA9IGZuJDUucmVtb3ZlRGF0YTtcbiAgdmFyIGRhdGEgPSBlbGVzZm4kZTtcblxuICB2YXIgZWxlc2ZuJGQgPSB7fTtcblxuICBmdW5jdGlvbiBkZWZpbmVEZWdyZWVGdW5jdGlvbihjYWxsYmFjaykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoaW5jbHVkZUxvb3BzKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIGlmIChpbmNsdWRlTG9vcHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpbmNsdWRlTG9vcHMgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZi5pc05vZGUoKSAmJiAhc2VsZi5yZW1vdmVkKCkpIHtcbiAgICAgICAgdmFyIGRlZ3JlZSA9IDA7XG4gICAgICAgIHZhciBub2RlID0gc2VsZlswXTtcbiAgICAgICAgdmFyIGNvbm5lY3RlZEVkZ2VzID0gbm9kZS5fcHJpdmF0ZS5lZGdlcztcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbm5lY3RlZEVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVkZ2UgPSBjb25uZWN0ZWRFZGdlc1tpXTtcblxuICAgICAgICAgIGlmICghaW5jbHVkZUxvb3BzICYmIGVkZ2UuaXNMb29wKCkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRlZ3JlZSArPSBjYWxsYmFjayhub2RlLCBlZGdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZWdyZWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGV4dGVuZChlbGVzZm4kZCwge1xuICAgIGRlZ3JlZTogZGVmaW5lRGVncmVlRnVuY3Rpb24oZnVuY3Rpb24gKG5vZGUsIGVkZ2UpIHtcbiAgICAgIGlmIChlZGdlLnNvdXJjZSgpLnNhbWUoZWRnZS50YXJnZXQoKSkpIHtcbiAgICAgICAgcmV0dXJuIDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICB9KSxcbiAgICBpbmRlZ3JlZTogZGVmaW5lRGVncmVlRnVuY3Rpb24oZnVuY3Rpb24gKG5vZGUsIGVkZ2UpIHtcbiAgICAgIGlmIChlZGdlLnRhcmdldCgpLnNhbWUobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICB9KSxcbiAgICBvdXRkZWdyZWU6IGRlZmluZURlZ3JlZUZ1bmN0aW9uKGZ1bmN0aW9uIChub2RlLCBlZGdlKSB7XG4gICAgICBpZiAoZWRnZS5zb3VyY2UoKS5zYW1lKG5vZGUpKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgfSlcbiAgfSk7XG5cbiAgZnVuY3Rpb24gZGVmaW5lRGVncmVlQm91bmRzRnVuY3Rpb24oZGVncmVlRm4sIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpbmNsdWRlTG9vcHMpIHtcbiAgICAgIHZhciByZXQ7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IG5vZGVzW2ldO1xuICAgICAgICB2YXIgZGVncmVlID0gZWxlW2RlZ3JlZUZuXShpbmNsdWRlTG9vcHMpO1xuXG4gICAgICAgIGlmIChkZWdyZWUgIT09IHVuZGVmaW5lZCAmJiAocmV0ID09PSB1bmRlZmluZWQgfHwgY2FsbGJhY2soZGVncmVlLCByZXQpKSkge1xuICAgICAgICAgIHJldCA9IGRlZ3JlZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gIH1cblxuICBleHRlbmQoZWxlc2ZuJGQsIHtcbiAgICBtaW5EZWdyZWU6IGRlZmluZURlZ3JlZUJvdW5kc0Z1bmN0aW9uKCdkZWdyZWUnLCBmdW5jdGlvbiAoZGVncmVlLCBtaW4pIHtcbiAgICAgIHJldHVybiBkZWdyZWUgPCBtaW47XG4gICAgfSksXG4gICAgbWF4RGVncmVlOiBkZWZpbmVEZWdyZWVCb3VuZHNGdW5jdGlvbignZGVncmVlJywgZnVuY3Rpb24gKGRlZ3JlZSwgbWF4KSB7XG4gICAgICByZXR1cm4gZGVncmVlID4gbWF4O1xuICAgIH0pLFxuICAgIG1pbkluZGVncmVlOiBkZWZpbmVEZWdyZWVCb3VuZHNGdW5jdGlvbignaW5kZWdyZWUnLCBmdW5jdGlvbiAoZGVncmVlLCBtaW4pIHtcbiAgICAgIHJldHVybiBkZWdyZWUgPCBtaW47XG4gICAgfSksXG4gICAgbWF4SW5kZWdyZWU6IGRlZmluZURlZ3JlZUJvdW5kc0Z1bmN0aW9uKCdpbmRlZ3JlZScsIGZ1bmN0aW9uIChkZWdyZWUsIG1heCkge1xuICAgICAgcmV0dXJuIGRlZ3JlZSA+IG1heDtcbiAgICB9KSxcbiAgICBtaW5PdXRkZWdyZWU6IGRlZmluZURlZ3JlZUJvdW5kc0Z1bmN0aW9uKCdvdXRkZWdyZWUnLCBmdW5jdGlvbiAoZGVncmVlLCBtaW4pIHtcbiAgICAgIHJldHVybiBkZWdyZWUgPCBtaW47XG4gICAgfSksXG4gICAgbWF4T3V0ZGVncmVlOiBkZWZpbmVEZWdyZWVCb3VuZHNGdW5jdGlvbignb3V0ZGVncmVlJywgZnVuY3Rpb24gKGRlZ3JlZSwgbWF4KSB7XG4gICAgICByZXR1cm4gZGVncmVlID4gbWF4O1xuICAgIH0pXG4gIH0pO1xuICBleHRlbmQoZWxlc2ZuJGQsIHtcbiAgICB0b3RhbERlZ3JlZTogZnVuY3Rpb24gdG90YWxEZWdyZWUoaW5jbHVkZUxvb3BzKSB7XG4gICAgICB2YXIgdG90YWwgPSAwO1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRvdGFsICs9IG5vZGVzW2ldLmRlZ3JlZShpbmNsdWRlTG9vcHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdG90YWw7XG4gICAgfVxuICB9KTtcblxuICB2YXIgZm4kNCwgZWxlc2ZuJGM7XG5cbiAgdmFyIGJlZm9yZVBvc2l0aW9uU2V0ID0gZnVuY3Rpb24gYmVmb3JlUG9zaXRpb25TZXQoZWxlcywgbmV3UG9zLCBzaWxlbnQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuXG4gICAgICBpZiAoIWVsZS5sb2NrZWQoKSkge1xuICAgICAgICB2YXIgb2xkUG9zID0gZWxlLl9wcml2YXRlLnBvc2l0aW9uO1xuICAgICAgICB2YXIgZGVsdGEgPSB7XG4gICAgICAgICAgeDogbmV3UG9zLnggIT0gbnVsbCA/IG5ld1Bvcy54IC0gb2xkUG9zLnggOiAwLFxuICAgICAgICAgIHk6IG5ld1Bvcy55ICE9IG51bGwgPyBuZXdQb3MueSAtIG9sZFBvcy55IDogMFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChlbGUuaXNQYXJlbnQoKSAmJiAhKGRlbHRhLnggPT09IDAgJiYgZGVsdGEueSA9PT0gMCkpIHtcbiAgICAgICAgICBlbGUuY2hpbGRyZW4oKS5zaGlmdChkZWx0YSwgc2lsZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZS5kaXJ0eUJvdW5kaW5nQm94Q2FjaGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIHBvc2l0aW9uRGVmID0ge1xuICAgIGZpZWxkOiAncG9zaXRpb24nLFxuICAgIGJpbmRpbmdFdmVudDogJ3Bvc2l0aW9uJyxcbiAgICBhbGxvd0JpbmRpbmc6IHRydWUsXG4gICAgYWxsb3dTZXR0aW5nOiB0cnVlLFxuICAgIHNldHRpbmdFdmVudDogJ3Bvc2l0aW9uJyxcbiAgICBzZXR0aW5nVHJpZ2dlcnNFdmVudDogdHJ1ZSxcbiAgICB0cmlnZ2VyRm5OYW1lOiAnZW1pdEFuZE5vdGlmeScsXG4gICAgYWxsb3dHZXR0aW5nOiB0cnVlLFxuICAgIHZhbGlkS2V5czogWyd4JywgJ3knXSxcbiAgICBiZWZvcmVHZXQ6IGZ1bmN0aW9uIGJlZm9yZUdldChlbGUpIHtcbiAgICAgIGVsZS51cGRhdGVDb21wb3VuZEJvdW5kcygpO1xuICAgIH0sXG4gICAgYmVmb3JlU2V0OiBmdW5jdGlvbiBiZWZvcmVTZXQoZWxlcywgbmV3UG9zKSB7XG4gICAgICBiZWZvcmVQb3NpdGlvblNldChlbGVzLCBuZXdQb3MsIGZhbHNlKTtcbiAgICB9LFxuICAgIG9uU2V0OiBmdW5jdGlvbiBvblNldChlbGVzKSB7XG4gICAgICBlbGVzLmRpcnR5Q29tcG91bmRCb3VuZHNDYWNoZSgpO1xuICAgIH0sXG4gICAgY2FuU2V0OiBmdW5jdGlvbiBjYW5TZXQoZWxlKSB7XG4gICAgICByZXR1cm4gIWVsZS5sb2NrZWQoKTtcbiAgICB9XG4gIH07XG4gIGZuJDQgPSBlbGVzZm4kYyA9IHtcbiAgICBwb3NpdGlvbjogZGVmaW5lLmRhdGEocG9zaXRpb25EZWYpLFxuICAgIC8vIHBvc2l0aW9uIGJ1dCBubyBub3RpZmljYXRpb24gdG8gcmVuZGVyZXJcbiAgICBzaWxlbnRQb3NpdGlvbjogZGVmaW5lLmRhdGEoZXh0ZW5kKHt9LCBwb3NpdGlvbkRlZiwge1xuICAgICAgYWxsb3dCaW5kaW5nOiBmYWxzZSxcbiAgICAgIGFsbG93U2V0dGluZzogdHJ1ZSxcbiAgICAgIHNldHRpbmdUcmlnZ2Vyc0V2ZW50OiBmYWxzZSxcbiAgICAgIGFsbG93R2V0dGluZzogZmFsc2UsXG4gICAgICBiZWZvcmVTZXQ6IGZ1bmN0aW9uIGJlZm9yZVNldChlbGVzLCBuZXdQb3MpIHtcbiAgICAgICAgYmVmb3JlUG9zaXRpb25TZXQoZWxlcywgbmV3UG9zLCB0cnVlKTtcbiAgICAgIH0sXG4gICAgICBvblNldDogZnVuY3Rpb24gb25TZXQoZWxlcykge1xuICAgICAgICBlbGVzLmRpcnR5Q29tcG91bmRCb3VuZHNDYWNoZSgpO1xuICAgICAgfVxuICAgIH0pKSxcbiAgICBwb3NpdGlvbnM6IGZ1bmN0aW9uIHBvc2l0aW9ucyhwb3MsIHNpbGVudCkge1xuICAgICAgaWYgKHBsYWluT2JqZWN0KHBvcykpIHtcbiAgICAgICAgaWYgKHNpbGVudCkge1xuICAgICAgICAgIHRoaXMuc2lsZW50UG9zaXRpb24ocG9zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnBvc2l0aW9uKHBvcyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZm4kNihwb3MpKSB7XG4gICAgICAgIHZhciBfZm4gPSBwb3M7XG4gICAgICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICAgICAgY3kuc3RhcnRCYXRjaCgpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuXG4gICAgICAgICAgdmFyIF9wb3MgPSB2b2lkIDA7XG5cbiAgICAgICAgICBpZiAoX3BvcyA9IF9mbihlbGUsIGkpKSB7XG4gICAgICAgICAgICBpZiAoc2lsZW50KSB7XG4gICAgICAgICAgICAgIGVsZS5zaWxlbnRQb3NpdGlvbihfcG9zKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVsZS5wb3NpdGlvbihfcG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjeS5lbmRCYXRjaCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuICAgIHNpbGVudFBvc2l0aW9uczogZnVuY3Rpb24gc2lsZW50UG9zaXRpb25zKHBvcykge1xuICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb25zKHBvcywgdHJ1ZSk7XG4gICAgfSxcbiAgICBzaGlmdDogZnVuY3Rpb24gc2hpZnQoZGltLCB2YWwsIHNpbGVudCkge1xuICAgICAgdmFyIGRlbHRhO1xuXG4gICAgICBpZiAocGxhaW5PYmplY3QoZGltKSkge1xuICAgICAgICBkZWx0YSA9IHtcbiAgICAgICAgICB4OiBudW1iZXIkMShkaW0ueCkgPyBkaW0ueCA6IDAsXG4gICAgICAgICAgeTogbnVtYmVyJDEoZGltLnkpID8gZGltLnkgOiAwXG4gICAgICAgIH07XG4gICAgICAgIHNpbGVudCA9IHZhbDtcbiAgICAgIH0gZWxzZSBpZiAoc3RyaW5nKGRpbSkgJiYgbnVtYmVyJDEodmFsKSkge1xuICAgICAgICBkZWx0YSA9IHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDBcbiAgICAgICAgfTtcbiAgICAgICAgZGVsdGFbZGltXSA9IHZhbDtcbiAgICAgIH1cblxuICAgICAgaWYgKGRlbHRhICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgICAgICBjeS5zdGFydEJhdGNoKCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVsZSA9IHRoaXNbaV07IC8vIGV4Y2x1ZGUgYW55IG5vZGUgdGhhdCBpcyBhIGRlc2NlbmRhbnQgb2YgdGhlIGNhbGxpbmcgY29sbGVjdGlvblxuXG4gICAgICAgICAgaWYgKGN5Lmhhc0NvbXBvdW5kTm9kZXMoKSAmJiBlbGUuaXNDaGlsZCgpICYmIGVsZS5hbmNlc3RvcnMoKS5hbnlTYW1lKHRoaXMpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcG9zID0gZWxlLnBvc2l0aW9uKCk7XG4gICAgICAgICAgdmFyIG5ld1BvcyA9IHtcbiAgICAgICAgICAgIHg6IHBvcy54ICsgZGVsdGEueCxcbiAgICAgICAgICAgIHk6IHBvcy55ICsgZGVsdGEueVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAoc2lsZW50KSB7XG4gICAgICAgICAgICBlbGUuc2lsZW50UG9zaXRpb24obmV3UG9zKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlLnBvc2l0aW9uKG5ld1Bvcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY3kuZW5kQmF0Y2goKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBzaWxlbnRTaGlmdDogZnVuY3Rpb24gc2lsZW50U2hpZnQoZGltLCB2YWwpIHtcbiAgICAgIGlmIChwbGFpbk9iamVjdChkaW0pKSB7XG4gICAgICAgIHRoaXMuc2hpZnQoZGltLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RyaW5nKGRpbSkgJiYgbnVtYmVyJDEodmFsKSkge1xuICAgICAgICB0aGlzLnNoaWZ0KGRpbSwgdmFsLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvLyBnZXQvc2V0IHRoZSByZW5kZXJlZCAoaS5lLiBvbiBzY3JlZW4pIHBvc2l0b24gb2YgdGhlIGVsZW1lbnRcbiAgICByZW5kZXJlZFBvc2l0aW9uOiBmdW5jdGlvbiByZW5kZXJlZFBvc2l0aW9uKGRpbSwgdmFsKSB7XG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuICAgICAgdmFyIHBhbiA9IGN5LnBhbigpO1xuICAgICAgdmFyIHJwb3MgPSBwbGFpbk9iamVjdChkaW0pID8gZGltIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIHNldHRpbmcgPSBycG9zICE9PSB1bmRlZmluZWQgfHwgdmFsICE9PSB1bmRlZmluZWQgJiYgc3RyaW5nKGRpbSk7XG5cbiAgICAgIGlmIChlbGUgJiYgZWxlLmlzTm9kZSgpKSB7XG4gICAgICAgIC8vIG11c3QgaGF2ZSBhbiBlbGVtZW50IGFuZCBtdXN0IGJlIGEgbm9kZSB0byByZXR1cm4gcG9zaXRpb25cbiAgICAgICAgaWYgKHNldHRpbmcpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBfZWxlID0gdGhpc1tpXTtcblxuICAgICAgICAgICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIC8vIHNldCBvbmUgZGltZW5zaW9uXG4gICAgICAgICAgICAgIF9lbGUucG9zaXRpb24oZGltLCAodmFsIC0gcGFuW2RpbV0pIC8gem9vbSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJwb3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAvLyBzZXQgd2hvbGUgcG9zaXRpb25cbiAgICAgICAgICAgICAgX2VsZS5wb3NpdGlvbihyZW5kZXJlZFRvTW9kZWxQb3NpdGlvbihycG9zLCB6b29tLCBwYW4pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZ2V0dGluZ1xuICAgICAgICAgIHZhciBwb3MgPSBlbGUucG9zaXRpb24oKTtcbiAgICAgICAgICBycG9zID0gbW9kZWxUb1JlbmRlcmVkUG9zaXRpb24ocG9zLCB6b29tLCBwYW4pO1xuXG4gICAgICAgICAgaWYgKGRpbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyB0aGVuIHJldHVybiB0aGUgd2hvbGUgcmVuZGVyZWQgcG9zaXRpb25cbiAgICAgICAgICAgIHJldHVybiBycG9zO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB0aGVuIHJldHVybiB0aGUgc3BlY2lmaWVkIGRpbWVuc2lvblxuICAgICAgICAgICAgcmV0dXJuIHJwb3NbZGltXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIXNldHRpbmcpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDsgLy8gZm9yIGVtcHR5IGNvbGxlY3Rpb24gY2FzZVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuICAgIC8vIGdldC9zZXQgdGhlIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSBwYXJlbnRcbiAgICByZWxhdGl2ZVBvc2l0aW9uOiBmdW5jdGlvbiByZWxhdGl2ZVBvc2l0aW9uKGRpbSwgdmFsKSB7XG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICAgIHZhciBwcG9zID0gcGxhaW5PYmplY3QoZGltKSA/IGRpbSA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciBzZXR0aW5nID0gcHBvcyAhPT0gdW5kZWZpbmVkIHx8IHZhbCAhPT0gdW5kZWZpbmVkICYmIHN0cmluZyhkaW0pO1xuICAgICAgdmFyIGhhc0NvbXBvdW5kTm9kZXMgPSBjeS5oYXNDb21wb3VuZE5vZGVzKCk7XG5cbiAgICAgIGlmIChlbGUgJiYgZWxlLmlzTm9kZSgpKSB7XG4gICAgICAgIC8vIG11c3QgaGF2ZSBhbiBlbGVtZW50IGFuZCBtdXN0IGJlIGEgbm9kZSB0byByZXR1cm4gcG9zaXRpb25cbiAgICAgICAgaWYgKHNldHRpbmcpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBfZWxlMiA9IHRoaXNbaV07XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gaGFzQ29tcG91bmROb2RlcyA/IF9lbGUyLnBhcmVudCgpIDogbnVsbDtcbiAgICAgICAgICAgIHZhciBoYXNQYXJlbnQgPSBwYXJlbnQgJiYgcGFyZW50Lmxlbmd0aCA+IDA7XG4gICAgICAgICAgICB2YXIgcmVsYXRpdmVUb1BhcmVudCA9IGhhc1BhcmVudDtcblxuICAgICAgICAgICAgaWYgKGhhc1BhcmVudCkge1xuICAgICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnRbMF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBvcmlnaW4gPSByZWxhdGl2ZVRvUGFyZW50ID8gcGFyZW50LnBvc2l0aW9uKCkgOiB7XG4gICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgIHk6IDBcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAvLyBzZXQgb25lIGRpbWVuc2lvblxuICAgICAgICAgICAgICBfZWxlMi5wb3NpdGlvbihkaW0sIHZhbCArIG9yaWdpbltkaW1dKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHBvcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIC8vIHNldCB3aG9sZSBwb3NpdGlvblxuICAgICAgICAgICAgICBfZWxlMi5wb3NpdGlvbih7XG4gICAgICAgICAgICAgICAgeDogcHBvcy54ICsgb3JpZ2luLngsXG4gICAgICAgICAgICAgICAgeTogcHBvcy55ICsgb3JpZ2luLnlcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGdldHRpbmdcbiAgICAgICAgICB2YXIgcG9zID0gZWxlLnBvc2l0aW9uKCk7XG5cbiAgICAgICAgICB2YXIgX3BhcmVudCA9IGhhc0NvbXBvdW5kTm9kZXMgPyBlbGUucGFyZW50KCkgOiBudWxsO1xuXG4gICAgICAgICAgdmFyIF9oYXNQYXJlbnQgPSBfcGFyZW50ICYmIF9wYXJlbnQubGVuZ3RoID4gMDtcblxuICAgICAgICAgIHZhciBfcmVsYXRpdmVUb1BhcmVudCA9IF9oYXNQYXJlbnQ7XG5cbiAgICAgICAgICBpZiAoX2hhc1BhcmVudCkge1xuICAgICAgICAgICAgX3BhcmVudCA9IF9wYXJlbnRbMF07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9vcmlnaW4gPSBfcmVsYXRpdmVUb1BhcmVudCA/IF9wYXJlbnQucG9zaXRpb24oKSA6IHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHBwb3MgPSB7XG4gICAgICAgICAgICB4OiBwb3MueCAtIF9vcmlnaW4ueCxcbiAgICAgICAgICAgIHk6IHBvcy55IC0gX29yaWdpbi55XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmIChkaW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gdGhlbiByZXR1cm4gdGhlIHdob2xlIHJlbmRlcmVkIHBvc2l0aW9uXG4gICAgICAgICAgICByZXR1cm4gcHBvcztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdGhlbiByZXR1cm4gdGhlIHNwZWNpZmllZCBkaW1lbnNpb25cbiAgICAgICAgICAgIHJldHVybiBwcG9zW2RpbV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFzZXR0aW5nKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7IC8vIGZvciBlbXB0eSBjb2xsZWN0aW9uIGNhc2VcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfVxuICB9OyAvLyBhbGlhc2VzXG5cbiAgZm4kNC5tb2RlbFBvc2l0aW9uID0gZm4kNC5wb2ludCA9IGZuJDQucG9zaXRpb247XG4gIGZuJDQubW9kZWxQb3NpdGlvbnMgPSBmbiQ0LnBvaW50cyA9IGZuJDQucG9zaXRpb25zO1xuICBmbiQ0LnJlbmRlcmVkUG9pbnQgPSBmbiQ0LnJlbmRlcmVkUG9zaXRpb247XG4gIGZuJDQucmVsYXRpdmVQb2ludCA9IGZuJDQucmVsYXRpdmVQb3NpdGlvbjtcbiAgdmFyIHBvc2l0aW9uID0gZWxlc2ZuJGM7XG5cbiAgdmFyIGZuJDMsIGVsZXNmbiRiO1xuICBmbiQzID0gZWxlc2ZuJGIgPSB7fTtcblxuICBlbGVzZm4kYi5yZW5kZXJlZEJvdW5kaW5nQm94ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgYmIgPSB0aGlzLmJvdW5kaW5nQm94KG9wdGlvbnMpO1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcbiAgICB2YXIgcGFuID0gY3kucGFuKCk7XG4gICAgdmFyIHgxID0gYmIueDEgKiB6b29tICsgcGFuLng7XG4gICAgdmFyIHgyID0gYmIueDIgKiB6b29tICsgcGFuLng7XG4gICAgdmFyIHkxID0gYmIueTEgKiB6b29tICsgcGFuLnk7XG4gICAgdmFyIHkyID0gYmIueTIgKiB6b29tICsgcGFuLnk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHgxOiB4MSxcbiAgICAgIHgyOiB4MixcbiAgICAgIHkxOiB5MSxcbiAgICAgIHkyOiB5MixcbiAgICAgIHc6IHgyIC0geDEsXG4gICAgICBoOiB5MiAtIHkxXG4gICAgfTtcbiAgfTtcblxuICBlbGVzZm4kYi5kaXJ0eUNvbXBvdW5kQm91bmRzQ2FjaGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNpbGVudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuXG4gICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSB8fCAhY3kuaGFzQ29tcG91bmROb2RlcygpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB0aGlzLmZvckVhY2hVcChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICBpZiAoZWxlLmlzUGFyZW50KCkpIHtcbiAgICAgICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgICAgICBfcC5jb21wb3VuZEJvdW5kc0NsZWFuID0gZmFsc2U7XG4gICAgICAgIF9wLmJiQ2FjaGUgPSBudWxsO1xuXG4gICAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgICAgZWxlLmVtaXRBbmROb3RpZnkoJ2JvdW5kcycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgZWxlc2ZuJGIudXBkYXRlQ29tcG91bmRCb3VuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZvcmNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7IC8vIG5vdCBwb3NzaWJsZSB0byBkbyBvbiBub24tY29tcG91bmQgZ3JhcGhzIG9yIHdpdGggdGhlIHN0eWxlIGRpc2FibGVkXG5cbiAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpIHx8ICFjeS5oYXNDb21wb3VuZE5vZGVzKCkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gLy8gc2F2ZSBjeWNsZXMgd2hlbiBiYXRjaGluZyAtLSBidXQgYm91bmRzIHdpbGwgYmUgc3RhbGUgKG9yIG5vdCBleGlzdCB5ZXQpXG5cblxuICAgIGlmICghZm9yY2UgJiYgY3kuYmF0Y2hpbmcoKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlKHBhcmVudCkge1xuICAgICAgaWYgKCFwYXJlbnQuaXNQYXJlbnQoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBfcCA9IHBhcmVudC5fcHJpdmF0ZTtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHBhcmVudC5jaGlsZHJlbigpO1xuICAgICAgdmFyIGluY2x1ZGVMYWJlbHMgPSBwYXJlbnQucHN0eWxlKCdjb21wb3VuZC1zaXppbmctd3J0LWxhYmVscycpLnZhbHVlID09PSAnaW5jbHVkZSc7XG4gICAgICB2YXIgbWluID0ge1xuICAgICAgICB3aWR0aDoge1xuICAgICAgICAgIHZhbDogcGFyZW50LnBzdHlsZSgnbWluLXdpZHRoJykucGZWYWx1ZSxcbiAgICAgICAgICBsZWZ0OiBwYXJlbnQucHN0eWxlKCdtaW4td2lkdGgtYmlhcy1sZWZ0JyksXG4gICAgICAgICAgcmlnaHQ6IHBhcmVudC5wc3R5bGUoJ21pbi13aWR0aC1iaWFzLXJpZ2h0JylcbiAgICAgICAgfSxcbiAgICAgICAgaGVpZ2h0OiB7XG4gICAgICAgICAgdmFsOiBwYXJlbnQucHN0eWxlKCdtaW4taGVpZ2h0JykucGZWYWx1ZSxcbiAgICAgICAgICB0b3A6IHBhcmVudC5wc3R5bGUoJ21pbi1oZWlnaHQtYmlhcy10b3AnKSxcbiAgICAgICAgICBib3R0b206IHBhcmVudC5wc3R5bGUoJ21pbi1oZWlnaHQtYmlhcy1ib3R0b20nKVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdmFyIGJiID0gY2hpbGRyZW4uYm91bmRpbmdCb3goe1xuICAgICAgICBpbmNsdWRlTGFiZWxzOiBpbmNsdWRlTGFiZWxzLFxuICAgICAgICBpbmNsdWRlT3ZlcmxheXM6IGZhbHNlLFxuICAgICAgICAvLyB1cGRhdGluZyB0aGUgY29tcG91bmQgYm91bmRzIGhhcHBlbnMgb3V0c2lkZSBvZiB0aGUgcmVndWxhclxuICAgICAgICAvLyBjYWNoZSBjeWNsZSAoaS5lLiBiZWZvcmUgZmlyZWQgZXZlbnRzKVxuICAgICAgICB1c2VDYWNoZTogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgdmFyIHBvcyA9IF9wLnBvc2l0aW9uOyAvLyBpZiBjaGlsZHJlbiB0YWtlIHVwIHplcm8gYXJlYSB0aGVuIGtlZXAgcG9zaXRpb24gYW5kIGZhbGwgYmFjayBvbiBzdHlsZXNoZWV0IHcvaFxuXG4gICAgICBpZiAoYmIudyA9PT0gMCB8fCBiYi5oID09PSAwKSB7XG4gICAgICAgIGJiID0ge1xuICAgICAgICAgIHc6IHBhcmVudC5wc3R5bGUoJ3dpZHRoJykucGZWYWx1ZSxcbiAgICAgICAgICBoOiBwYXJlbnQucHN0eWxlKCdoZWlnaHQnKS5wZlZhbHVlXG4gICAgICAgIH07XG4gICAgICAgIGJiLngxID0gcG9zLnggLSBiYi53IC8gMjtcbiAgICAgICAgYmIueDIgPSBwb3MueCArIGJiLncgLyAyO1xuICAgICAgICBiYi55MSA9IHBvcy55IC0gYmIuaCAvIDI7XG4gICAgICAgIGJiLnkyID0gcG9zLnkgKyBiYi5oIC8gMjtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY29tcHV0ZUJpYXNWYWx1ZXMocHJvcERpZmYsIHByb3BCaWFzLCBwcm9wQmlhc0NvbXBsZW1lbnQpIHtcbiAgICAgICAgdmFyIGJpYXNEaWZmID0gMDtcbiAgICAgICAgdmFyIGJpYXNDb21wbGVtZW50RGlmZiA9IDA7XG4gICAgICAgIHZhciBiaWFzVG90YWwgPSBwcm9wQmlhcyArIHByb3BCaWFzQ29tcGxlbWVudDtcblxuICAgICAgICBpZiAocHJvcERpZmYgPiAwICYmIGJpYXNUb3RhbCA+IDApIHtcbiAgICAgICAgICBiaWFzRGlmZiA9IHByb3BCaWFzIC8gYmlhc1RvdGFsICogcHJvcERpZmY7XG4gICAgICAgICAgYmlhc0NvbXBsZW1lbnREaWZmID0gcHJvcEJpYXNDb21wbGVtZW50IC8gYmlhc1RvdGFsICogcHJvcERpZmY7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGJpYXNEaWZmOiBiaWFzRGlmZixcbiAgICAgICAgICBiaWFzQ29tcGxlbWVudERpZmY6IGJpYXNDb21wbGVtZW50RGlmZlxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjb21wdXRlUGFkZGluZ1ZhbHVlcyh3aWR0aCwgaGVpZ2h0LCBwYWRkaW5nT2JqZWN0LCByZWxhdGl2ZVRvKSB7XG4gICAgICAgIC8vIEFzc3VtaW5nIHBlcmNlbnRhZ2UgaXMgbnVtYmVyIGZyb20gMCB0byAxXG4gICAgICAgIGlmIChwYWRkaW5nT2JqZWN0LnVuaXRzID09PSAnJScpIHtcbiAgICAgICAgICBzd2l0Y2ggKHJlbGF0aXZlVG8pIHtcbiAgICAgICAgICAgIGNhc2UgJ3dpZHRoJzpcbiAgICAgICAgICAgICAgcmV0dXJuIHdpZHRoID4gMCA/IHBhZGRpbmdPYmplY3QucGZWYWx1ZSAqIHdpZHRoIDogMDtcblxuICAgICAgICAgICAgY2FzZSAnaGVpZ2h0JzpcbiAgICAgICAgICAgICAgcmV0dXJuIGhlaWdodCA+IDAgPyBwYWRkaW5nT2JqZWN0LnBmVmFsdWUgKiBoZWlnaHQgOiAwO1xuXG4gICAgICAgICAgICBjYXNlICdhdmVyYWdlJzpcbiAgICAgICAgICAgICAgcmV0dXJuIHdpZHRoID4gMCAmJiBoZWlnaHQgPiAwID8gcGFkZGluZ09iamVjdC5wZlZhbHVlICogKHdpZHRoICsgaGVpZ2h0KSAvIDIgOiAwO1xuXG4gICAgICAgICAgICBjYXNlICdtaW4nOlxuICAgICAgICAgICAgICByZXR1cm4gd2lkdGggPiAwICYmIGhlaWdodCA+IDAgPyB3aWR0aCA+IGhlaWdodCA/IHBhZGRpbmdPYmplY3QucGZWYWx1ZSAqIGhlaWdodCA6IHBhZGRpbmdPYmplY3QucGZWYWx1ZSAqIHdpZHRoIDogMDtcblxuICAgICAgICAgICAgY2FzZSAnbWF4JzpcbiAgICAgICAgICAgICAgcmV0dXJuIHdpZHRoID4gMCAmJiBoZWlnaHQgPiAwID8gd2lkdGggPiBoZWlnaHQgPyBwYWRkaW5nT2JqZWN0LnBmVmFsdWUgKiB3aWR0aCA6IHBhZGRpbmdPYmplY3QucGZWYWx1ZSAqIGhlaWdodCA6IDA7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChwYWRkaW5nT2JqZWN0LnVuaXRzID09PSAncHgnKSB7XG4gICAgICAgICAgcmV0dXJuIHBhZGRpbmdPYmplY3QucGZWYWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgbGVmdFZhbCA9IG1pbi53aWR0aC5sZWZ0LnZhbHVlO1xuXG4gICAgICBpZiAobWluLndpZHRoLmxlZnQudW5pdHMgPT09ICdweCcgJiYgbWluLndpZHRoLnZhbCA+IDApIHtcbiAgICAgICAgbGVmdFZhbCA9IGxlZnRWYWwgKiAxMDAgLyBtaW4ud2lkdGgudmFsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmlnaHRWYWwgPSBtaW4ud2lkdGgucmlnaHQudmFsdWU7XG5cbiAgICAgIGlmIChtaW4ud2lkdGgucmlnaHQudW5pdHMgPT09ICdweCcgJiYgbWluLndpZHRoLnZhbCA+IDApIHtcbiAgICAgICAgcmlnaHRWYWwgPSByaWdodFZhbCAqIDEwMCAvIG1pbi53aWR0aC52YWw7XG4gICAgICB9XG5cbiAgICAgIHZhciB0b3BWYWwgPSBtaW4uaGVpZ2h0LnRvcC52YWx1ZTtcblxuICAgICAgaWYgKG1pbi5oZWlnaHQudG9wLnVuaXRzID09PSAncHgnICYmIG1pbi5oZWlnaHQudmFsID4gMCkge1xuICAgICAgICB0b3BWYWwgPSB0b3BWYWwgKiAxMDAgLyBtaW4uaGVpZ2h0LnZhbDtcbiAgICAgIH1cblxuICAgICAgdmFyIGJvdHRvbVZhbCA9IG1pbi5oZWlnaHQuYm90dG9tLnZhbHVlO1xuXG4gICAgICBpZiAobWluLmhlaWdodC5ib3R0b20udW5pdHMgPT09ICdweCcgJiYgbWluLmhlaWdodC52YWwgPiAwKSB7XG4gICAgICAgIGJvdHRvbVZhbCA9IGJvdHRvbVZhbCAqIDEwMCAvIG1pbi5oZWlnaHQudmFsO1xuICAgICAgfVxuXG4gICAgICB2YXIgd2lkdGhCaWFzRGlmZnMgPSBjb21wdXRlQmlhc1ZhbHVlcyhtaW4ud2lkdGgudmFsIC0gYmIudywgbGVmdFZhbCwgcmlnaHRWYWwpO1xuICAgICAgdmFyIGRpZmZMZWZ0ID0gd2lkdGhCaWFzRGlmZnMuYmlhc0RpZmY7XG4gICAgICB2YXIgZGlmZlJpZ2h0ID0gd2lkdGhCaWFzRGlmZnMuYmlhc0NvbXBsZW1lbnREaWZmO1xuICAgICAgdmFyIGhlaWdodEJpYXNEaWZmcyA9IGNvbXB1dGVCaWFzVmFsdWVzKG1pbi5oZWlnaHQudmFsIC0gYmIuaCwgdG9wVmFsLCBib3R0b21WYWwpO1xuICAgICAgdmFyIGRpZmZUb3AgPSBoZWlnaHRCaWFzRGlmZnMuYmlhc0RpZmY7XG4gICAgICB2YXIgZGlmZkJvdHRvbSA9IGhlaWdodEJpYXNEaWZmcy5iaWFzQ29tcGxlbWVudERpZmY7XG4gICAgICBfcC5hdXRvUGFkZGluZyA9IGNvbXB1dGVQYWRkaW5nVmFsdWVzKGJiLncsIGJiLmgsIHBhcmVudC5wc3R5bGUoJ3BhZGRpbmcnKSwgcGFyZW50LnBzdHlsZSgncGFkZGluZy1yZWxhdGl2ZS10bycpLnZhbHVlKTtcbiAgICAgIF9wLmF1dG9XaWR0aCA9IE1hdGgubWF4KGJiLncsIG1pbi53aWR0aC52YWwpO1xuICAgICAgcG9zLnggPSAoLWRpZmZMZWZ0ICsgYmIueDEgKyBiYi54MiArIGRpZmZSaWdodCkgLyAyO1xuICAgICAgX3AuYXV0b0hlaWdodCA9IE1hdGgubWF4KGJiLmgsIG1pbi5oZWlnaHQudmFsKTtcbiAgICAgIHBvcy55ID0gKC1kaWZmVG9wICsgYmIueTEgKyBiYi55MiArIGRpZmZCb3R0b20pIC8gMjtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuXG4gICAgICBpZiAoIV9wLmNvbXBvdW5kQm91bmRzQ2xlYW4gfHwgZm9yY2UpIHtcbiAgICAgICAgdXBkYXRlKGVsZSk7XG5cbiAgICAgICAgaWYgKCFjeS5iYXRjaGluZygpKSB7XG4gICAgICAgICAgX3AuY29tcG91bmRCb3VuZHNDbGVhbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB2YXIgbm9uaW5mID0gZnVuY3Rpb24gbm9uaW5mKHgpIHtcbiAgICBpZiAoeCA9PT0gSW5maW5pdHkgfHwgeCA9PT0gLUluZmluaXR5KSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICByZXR1cm4geDtcbiAgfTtcblxuICB2YXIgdXBkYXRlQm91bmRzID0gZnVuY3Rpb24gdXBkYXRlQm91bmRzKGIsIHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgLy8gZG9uJ3QgdXBkYXRlIHdpdGggemVybyBhcmVhIGJveGVzXG4gICAgaWYgKHgyIC0geDEgPT09IDAgfHwgeTIgLSB5MSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gZG9uJ3QgdXBkYXRlIHdpdGggbnVsbCBkaW1cblxuXG4gICAgaWYgKHgxID09IG51bGwgfHwgeTEgPT0gbnVsbCB8fCB4MiA9PSBudWxsIHx8IHkyID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBiLngxID0geDEgPCBiLngxID8geDEgOiBiLngxO1xuICAgIGIueDIgPSB4MiA+IGIueDIgPyB4MiA6IGIueDI7XG4gICAgYi55MSA9IHkxIDwgYi55MSA/IHkxIDogYi55MTtcbiAgICBiLnkyID0geTIgPiBiLnkyID8geTIgOiBiLnkyO1xuICAgIGIudyA9IGIueDIgLSBiLngxO1xuICAgIGIuaCA9IGIueTIgLSBiLnkxO1xuICB9O1xuXG4gIHZhciB1cGRhdGVCb3VuZHNGcm9tQm94ID0gZnVuY3Rpb24gdXBkYXRlQm91bmRzRnJvbUJveChiLCBiMikge1xuICAgIGlmIChiMiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gYjtcbiAgICB9XG5cbiAgICByZXR1cm4gdXBkYXRlQm91bmRzKGIsIGIyLngxLCBiMi55MSwgYjIueDIsIGIyLnkyKTtcbiAgfTtcblxuICB2YXIgcHJlZml4ZWRQcm9wZXJ0eSA9IGZ1bmN0aW9uIHByZWZpeGVkUHJvcGVydHkob2JqLCBmaWVsZCwgcHJlZml4KSB7XG4gICAgcmV0dXJuIGdldFByZWZpeGVkUHJvcGVydHkob2JqLCBmaWVsZCwgcHJlZml4KTtcbiAgfTtcblxuICB2YXIgdXBkYXRlQm91bmRzRnJvbUFycm93ID0gZnVuY3Rpb24gdXBkYXRlQm91bmRzRnJvbUFycm93KGJvdW5kcywgZWxlLCBwcmVmaXgpIHtcbiAgICBpZiAoZWxlLmN5KCkuaGVhZGxlc3MoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICB2YXIgcnN0eWxlID0gX3AucnN0eWxlO1xuICAgIHZhciBoYWxmQXJXID0gcnN0eWxlLmFycm93V2lkdGggLyAyO1xuICAgIHZhciBhcnJvd1R5cGUgPSBlbGUucHN0eWxlKHByZWZpeCArICctYXJyb3ctc2hhcGUnKS52YWx1ZTtcbiAgICB2YXIgeDtcbiAgICB2YXIgeTtcblxuICAgIGlmIChhcnJvd1R5cGUgIT09ICdub25lJykge1xuICAgICAgaWYgKHByZWZpeCA9PT0gJ3NvdXJjZScpIHtcbiAgICAgICAgeCA9IHJzdHlsZS5zcmNYO1xuICAgICAgICB5ID0gcnN0eWxlLnNyY1k7XG4gICAgICB9IGVsc2UgaWYgKHByZWZpeCA9PT0gJ3RhcmdldCcpIHtcbiAgICAgICAgeCA9IHJzdHlsZS50Z3RYO1xuICAgICAgICB5ID0gcnN0eWxlLnRndFk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4ID0gcnN0eWxlLm1pZFg7XG4gICAgICAgIHkgPSByc3R5bGUubWlkWTtcbiAgICAgIH0gLy8gYWx3YXlzIHN0b3JlIHRoZSBpbmRpdmlkdWFsIGFycm93IGJvdW5kc1xuXG5cbiAgICAgIHZhciBiYnMgPSBfcC5hcnJvd0JvdW5kcyA9IF9wLmFycm93Qm91bmRzIHx8IHt9O1xuICAgICAgdmFyIGJiID0gYmJzW3ByZWZpeF0gPSBiYnNbcHJlZml4XSB8fCB7fTtcbiAgICAgIGJiLngxID0geCAtIGhhbGZBclc7XG4gICAgICBiYi55MSA9IHkgLSBoYWxmQXJXO1xuICAgICAgYmIueDIgPSB4ICsgaGFsZkFyVztcbiAgICAgIGJiLnkyID0geSArIGhhbGZBclc7XG4gICAgICBiYi53ID0gYmIueDIgLSBiYi54MTtcbiAgICAgIGJiLmggPSBiYi55MiAtIGJiLnkxO1xuICAgICAgZXhwYW5kQm91bmRpbmdCb3goYmIsIDEpO1xuICAgICAgdXBkYXRlQm91bmRzKGJvdW5kcywgYmIueDEsIGJiLnkxLCBiYi54MiwgYmIueTIpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgdXBkYXRlQm91bmRzRnJvbUxhYmVsID0gZnVuY3Rpb24gdXBkYXRlQm91bmRzRnJvbUxhYmVsKGJvdW5kcywgZWxlLCBwcmVmaXgpIHtcbiAgICBpZiAoZWxlLmN5KCkuaGVhZGxlc3MoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwcmVmaXhEYXNoO1xuXG4gICAgaWYgKHByZWZpeCkge1xuICAgICAgcHJlZml4RGFzaCA9IHByZWZpeCArICctJztcbiAgICB9IGVsc2Uge1xuICAgICAgcHJlZml4RGFzaCA9ICcnO1xuICAgIH1cblxuICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICB2YXIgcnN0eWxlID0gX3AucnN0eWxlO1xuICAgIHZhciBsYWJlbCA9IGVsZS5wc3R5bGUocHJlZml4RGFzaCArICdsYWJlbCcpLnN0clZhbHVlO1xuXG4gICAgaWYgKGxhYmVsKSB7XG4gICAgICB2YXIgaGFsaWduID0gZWxlLnBzdHlsZSgndGV4dC1oYWxpZ24nKTtcbiAgICAgIHZhciB2YWxpZ24gPSBlbGUucHN0eWxlKCd0ZXh0LXZhbGlnbicpO1xuICAgICAgdmFyIGxhYmVsV2lkdGggPSBwcmVmaXhlZFByb3BlcnR5KHJzdHlsZSwgJ2xhYmVsV2lkdGgnLCBwcmVmaXgpO1xuICAgICAgdmFyIGxhYmVsSGVpZ2h0ID0gcHJlZml4ZWRQcm9wZXJ0eShyc3R5bGUsICdsYWJlbEhlaWdodCcsIHByZWZpeCk7XG4gICAgICB2YXIgbGFiZWxYID0gcHJlZml4ZWRQcm9wZXJ0eShyc3R5bGUsICdsYWJlbFgnLCBwcmVmaXgpO1xuICAgICAgdmFyIGxhYmVsWSA9IHByZWZpeGVkUHJvcGVydHkocnN0eWxlLCAnbGFiZWxZJywgcHJlZml4KTtcbiAgICAgIHZhciBtYXJnaW5YID0gZWxlLnBzdHlsZShwcmVmaXhEYXNoICsgJ3RleHQtbWFyZ2luLXgnKS5wZlZhbHVlO1xuICAgICAgdmFyIG1hcmdpblkgPSBlbGUucHN0eWxlKHByZWZpeERhc2ggKyAndGV4dC1tYXJnaW4teScpLnBmVmFsdWU7XG4gICAgICB2YXIgaXNFZGdlID0gZWxlLmlzRWRnZSgpO1xuICAgICAgdmFyIHJvdGF0aW9uID0gZWxlLnBzdHlsZShwcmVmaXhEYXNoICsgJ3RleHQtcm90YXRpb24nKTtcbiAgICAgIHZhciBvdXRsaW5lV2lkdGggPSBlbGUucHN0eWxlKCd0ZXh0LW91dGxpbmUtd2lkdGgnKS5wZlZhbHVlO1xuICAgICAgdmFyIGJvcmRlcldpZHRoID0gZWxlLnBzdHlsZSgndGV4dC1ib3JkZXItd2lkdGgnKS5wZlZhbHVlO1xuICAgICAgdmFyIGhhbGZCb3JkZXJXaWR0aCA9IGJvcmRlcldpZHRoIC8gMjtcbiAgICAgIHZhciBwYWRkaW5nID0gZWxlLnBzdHlsZSgndGV4dC1iYWNrZ3JvdW5kLXBhZGRpbmcnKS5wZlZhbHVlO1xuICAgICAgdmFyIG1hcmdpbk9mRXJyb3IgPSAyOyAvLyBleHBhbmQgdG8gd29yayBhcm91bmQgYnJvd3NlciBkaW1lbnNpb24gaW5hY2N1cmFjaWVzXG5cbiAgICAgIHZhciBsaCA9IGxhYmVsSGVpZ2h0O1xuICAgICAgdmFyIGx3ID0gbGFiZWxXaWR0aDtcbiAgICAgIHZhciBsd18yID0gbHcgLyAyO1xuICAgICAgdmFyIGxoXzIgPSBsaCAvIDI7XG4gICAgICB2YXIgbHgxLCBseDIsIGx5MSwgbHkyO1xuXG4gICAgICBpZiAoaXNFZGdlKSB7XG4gICAgICAgIGx4MSA9IGxhYmVsWCAtIGx3XzI7XG4gICAgICAgIGx4MiA9IGxhYmVsWCArIGx3XzI7XG4gICAgICAgIGx5MSA9IGxhYmVsWSAtIGxoXzI7XG4gICAgICAgIGx5MiA9IGxhYmVsWSArIGxoXzI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzd2l0Y2ggKGhhbGlnbi52YWx1ZSkge1xuICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgbHgxID0gbGFiZWxYIC0gbHc7XG4gICAgICAgICAgICBseDIgPSBsYWJlbFg7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgICBseDEgPSBsYWJlbFggLSBsd18yO1xuICAgICAgICAgICAgbHgyID0gbGFiZWxYICsgbHdfMjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgbHgxID0gbGFiZWxYO1xuICAgICAgICAgICAgbHgyID0gbGFiZWxYICsgbHc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAodmFsaWduLnZhbHVlKSB7XG4gICAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgIGx5MSA9IGxhYmVsWSAtIGxoO1xuICAgICAgICAgICAgbHkyID0gbGFiZWxZO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgICAgbHkxID0gbGFiZWxZIC0gbGhfMjtcbiAgICAgICAgICAgIGx5MiA9IGxhYmVsWSArIGxoXzI7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICBseTEgPSBsYWJlbFk7XG4gICAgICAgICAgICBseTIgPSBsYWJlbFkgKyBsaDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IC8vIHNoaWZ0IGJ5IG1hcmdpbiBhbmQgZXhwYW5kIGJ5IG91dGxpbmUgYW5kIGJvcmRlclxuXG5cbiAgICAgIGx4MSArPSBtYXJnaW5YIC0gTWF0aC5tYXgob3V0bGluZVdpZHRoLCBoYWxmQm9yZGVyV2lkdGgpIC0gcGFkZGluZyAtIG1hcmdpbk9mRXJyb3I7XG4gICAgICBseDIgKz0gbWFyZ2luWCArIE1hdGgubWF4KG91dGxpbmVXaWR0aCwgaGFsZkJvcmRlcldpZHRoKSArIHBhZGRpbmcgKyBtYXJnaW5PZkVycm9yO1xuICAgICAgbHkxICs9IG1hcmdpblkgLSBNYXRoLm1heChvdXRsaW5lV2lkdGgsIGhhbGZCb3JkZXJXaWR0aCkgLSBwYWRkaW5nIC0gbWFyZ2luT2ZFcnJvcjtcbiAgICAgIGx5MiArPSBtYXJnaW5ZICsgTWF0aC5tYXgob3V0bGluZVdpZHRoLCBoYWxmQm9yZGVyV2lkdGgpICsgcGFkZGluZyArIG1hcmdpbk9mRXJyb3I7IC8vIGFsd2F5cyBzdG9yZSB0aGUgdW5yb3RhdGVkIGxhYmVsIGJvdW5kcyBzZXBhcmF0ZWx5XG5cbiAgICAgIHZhciBiYlByZWZpeCA9IHByZWZpeCB8fCAnbWFpbic7XG4gICAgICB2YXIgYmJzID0gX3AubGFiZWxCb3VuZHM7XG4gICAgICB2YXIgYmIgPSBiYnNbYmJQcmVmaXhdID0gYmJzW2JiUHJlZml4XSB8fCB7fTtcbiAgICAgIGJiLngxID0gbHgxO1xuICAgICAgYmIueTEgPSBseTE7XG4gICAgICBiYi54MiA9IGx4MjtcbiAgICAgIGJiLnkyID0gbHkyO1xuICAgICAgYmIudyA9IGx4MiAtIGx4MTtcbiAgICAgIGJiLmggPSBseTIgLSBseTE7XG4gICAgICB2YXIgaXNBdXRvcm90YXRlID0gaXNFZGdlICYmIHJvdGF0aW9uLnN0clZhbHVlID09PSAnYXV0b3JvdGF0ZSc7XG4gICAgICB2YXIgaXNQZlZhbHVlID0gcm90YXRpb24ucGZWYWx1ZSAhPSBudWxsICYmIHJvdGF0aW9uLnBmVmFsdWUgIT09IDA7XG5cbiAgICAgIGlmIChpc0F1dG9yb3RhdGUgfHwgaXNQZlZhbHVlKSB7XG4gICAgICAgIHZhciB0aGV0YSA9IGlzQXV0b3JvdGF0ZSA/IHByZWZpeGVkUHJvcGVydHkoX3AucnN0eWxlLCAnbGFiZWxBbmdsZScsIHByZWZpeCkgOiByb3RhdGlvbi5wZlZhbHVlO1xuICAgICAgICB2YXIgY29zID0gTWF0aC5jb3ModGhldGEpO1xuICAgICAgICB2YXIgc2luID0gTWF0aC5zaW4odGhldGEpOyAvLyByb3RhdGlvbiBwb2ludCAoZGVmYXVsdCB2YWx1ZSBmb3IgY2VudGVyLWNlbnRlcilcblxuICAgICAgICB2YXIgeG8gPSAobHgxICsgbHgyKSAvIDI7XG4gICAgICAgIHZhciB5byA9IChseTEgKyBseTIpIC8gMjtcblxuICAgICAgICBpZiAoIWlzRWRnZSkge1xuICAgICAgICAgIHN3aXRjaCAoaGFsaWduLnZhbHVlKSB7XG4gICAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgICAgeG8gPSBseDI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICAgIHhvID0gbHgxO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzd2l0Y2ggKHZhbGlnbi52YWx1ZSkge1xuICAgICAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgICAgeW8gPSBseTI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgICB5byA9IGx5MTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJvdGF0ZSA9IGZ1bmN0aW9uIHJvdGF0ZSh4LCB5KSB7XG4gICAgICAgICAgeCA9IHggLSB4bztcbiAgICAgICAgICB5ID0geSAtIHlvO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiB4ICogY29zIC0geSAqIHNpbiArIHhvLFxuICAgICAgICAgICAgeTogeCAqIHNpbiArIHkgKiBjb3MgKyB5b1xuICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHB4MXkxID0gcm90YXRlKGx4MSwgbHkxKTtcbiAgICAgICAgdmFyIHB4MXkyID0gcm90YXRlKGx4MSwgbHkyKTtcbiAgICAgICAgdmFyIHB4MnkxID0gcm90YXRlKGx4MiwgbHkxKTtcbiAgICAgICAgdmFyIHB4MnkyID0gcm90YXRlKGx4MiwgbHkyKTtcbiAgICAgICAgbHgxID0gTWF0aC5taW4ocHgxeTEueCwgcHgxeTIueCwgcHgyeTEueCwgcHgyeTIueCk7XG4gICAgICAgIGx4MiA9IE1hdGgubWF4KHB4MXkxLngsIHB4MXkyLngsIHB4MnkxLngsIHB4MnkyLngpO1xuICAgICAgICBseTEgPSBNYXRoLm1pbihweDF5MS55LCBweDF5Mi55LCBweDJ5MS55LCBweDJ5Mi55KTtcbiAgICAgICAgbHkyID0gTWF0aC5tYXgocHgxeTEueSwgcHgxeTIueSwgcHgyeTEueSwgcHgyeTIueSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBiYlByZWZpeFJvdCA9IGJiUHJlZml4ICsgJ1JvdCc7XG4gICAgICB2YXIgYmJSb3QgPSBiYnNbYmJQcmVmaXhSb3RdID0gYmJzW2JiUHJlZml4Um90XSB8fCB7fTtcbiAgICAgIGJiUm90LngxID0gbHgxO1xuICAgICAgYmJSb3QueTEgPSBseTE7XG4gICAgICBiYlJvdC54MiA9IGx4MjtcbiAgICAgIGJiUm90LnkyID0gbHkyO1xuICAgICAgYmJSb3QudyA9IGx4MiAtIGx4MTtcbiAgICAgIGJiUm90LmggPSBseTIgLSBseTE7XG4gICAgICB1cGRhdGVCb3VuZHMoYm91bmRzLCBseDEsIGx5MSwgbHgyLCBseTIpO1xuICAgICAgdXBkYXRlQm91bmRzKF9wLmxhYmVsQm91bmRzLmFsbCwgbHgxLCBseTEsIGx4MiwgbHkyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYm91bmRzO1xuICB9OyAvLyBnZXQgdGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgZWxlbWVudHMgKGluIHJhdyBtb2RlbCBwb3NpdGlvbilcblxuXG4gIHZhciBib3VuZGluZ0JveEltcGwgPSBmdW5jdGlvbiBib3VuZGluZ0JveEltcGwoZWxlLCBvcHRpb25zKSB7XG4gICAgdmFyIGN5ID0gZWxlLl9wcml2YXRlLmN5O1xuICAgIHZhciBzdHlsZUVuYWJsZWQgPSBjeS5zdHlsZUVuYWJsZWQoKTtcbiAgICB2YXIgaGVhZGxlc3MgPSBjeS5oZWFkbGVzcygpO1xuICAgIHZhciBib3VuZHMgPSBtYWtlQm91bmRpbmdCb3goKTtcbiAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgdmFyIGlzTm9kZSA9IGVsZS5pc05vZGUoKTtcbiAgICB2YXIgaXNFZGdlID0gZWxlLmlzRWRnZSgpO1xuICAgIHZhciBleDEsIGV4MiwgZXkxLCBleTI7IC8vIGV4dHJlbWEgb2YgYm9keSAvIGxpbmVzXG5cbiAgICB2YXIgeCwgeTsgLy8gbm9kZSBwb3NcblxuICAgIHZhciByc3R5bGUgPSBfcC5yc3R5bGU7XG4gICAgdmFyIG1hbnVhbEV4cGFuc2lvbiA9IGlzTm9kZSAmJiBzdHlsZUVuYWJsZWQgPyBlbGUucHN0eWxlKCdib3VuZHMtZXhwYW5zaW9uJykucGZWYWx1ZSA6IFswXTsgLy8gbXVzdCB1c2UgYGRpc3BsYXlgIHByb3Agb25seSwgYXMgcmVhZGluZyBgY29tcG91bmQud2lkdGgoKWAgY2F1c2VzIHJlY3Vyc2lvblxuICAgIC8vIChvdGhlciBmYWN0b3JzIGxpa2Ugd2lkdGggdmFsdWVzIHdpbGwgYmUgY29uc2lkZXJlZCBsYXRlciBpbiB0aGlzIGZ1bmN0aW9uIGFueXdheSlcblxuICAgIHZhciBpc0Rpc3BsYXllZCA9IGZ1bmN0aW9uIGlzRGlzcGxheWVkKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5wc3R5bGUoJ2Rpc3BsYXknKS52YWx1ZSAhPT0gJ25vbmUnO1xuICAgIH07XG5cbiAgICB2YXIgZGlzcGxheWVkID0gIXN0eWxlRW5hYmxlZCB8fCBpc0Rpc3BsYXllZChlbGUpIC8vIG11c3QgdGFrZSBpbnRvIGFjY291bnQgY29ubmVjdGVkIG5vZGVzIGIvYyBvZiBpbXBsaWNpdCBlZGdlIGhpZGluZyBvbiBkaXNwbGF5Om5vbmUgbm9kZVxuICAgICYmICghaXNFZGdlIHx8IGlzRGlzcGxheWVkKGVsZS5zb3VyY2UoKSkgJiYgaXNEaXNwbGF5ZWQoZWxlLnRhcmdldCgpKSk7XG5cbiAgICBpZiAoZGlzcGxheWVkKSB7XG4gICAgICAvLyBkaXNwbGF5ZWQgc3VmZmljZXMsIHNpbmNlIHdlIHdpbGwgZmluZCB6ZXJvIGFyZWEgZWxlcyBhbnl3YXlcbiAgICAgIHZhciBvdmVybGF5T3BhY2l0eSA9IDA7XG4gICAgICB2YXIgb3ZlcmxheVBhZGRpbmcgPSAwO1xuXG4gICAgICBpZiAoc3R5bGVFbmFibGVkICYmIG9wdGlvbnMuaW5jbHVkZU92ZXJsYXlzKSB7XG4gICAgICAgIG92ZXJsYXlPcGFjaXR5ID0gZWxlLnBzdHlsZSgnb3ZlcmxheS1vcGFjaXR5JykudmFsdWU7XG5cbiAgICAgICAgaWYgKG92ZXJsYXlPcGFjaXR5ICE9PSAwKSB7XG4gICAgICAgICAgb3ZlcmxheVBhZGRpbmcgPSBlbGUucHN0eWxlKCdvdmVybGF5LXBhZGRpbmcnKS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdW5kZXJsYXlPcGFjaXR5ID0gMDtcbiAgICAgIHZhciB1bmRlcmxheVBhZGRpbmcgPSAwO1xuXG4gICAgICBpZiAoc3R5bGVFbmFibGVkICYmIG9wdGlvbnMuaW5jbHVkZVVuZGVybGF5cykge1xuICAgICAgICB1bmRlcmxheU9wYWNpdHkgPSBlbGUucHN0eWxlKCd1bmRlcmxheS1vcGFjaXR5JykudmFsdWU7XG5cbiAgICAgICAgaWYgKHVuZGVybGF5T3BhY2l0eSAhPT0gMCkge1xuICAgICAgICAgIHVuZGVybGF5UGFkZGluZyA9IGVsZS5wc3R5bGUoJ3VuZGVybGF5LXBhZGRpbmcnKS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgcGFkZGluZyA9IE1hdGgubWF4KG92ZXJsYXlQYWRkaW5nLCB1bmRlcmxheVBhZGRpbmcpO1xuICAgICAgdmFyIHcgPSAwO1xuICAgICAgdmFyIHdIYWxmID0gMDtcblxuICAgICAgaWYgKHN0eWxlRW5hYmxlZCkge1xuICAgICAgICB3ID0gZWxlLnBzdHlsZSgnd2lkdGgnKS5wZlZhbHVlO1xuICAgICAgICB3SGFsZiA9IHcgLyAyO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNOb2RlICYmIG9wdGlvbnMuaW5jbHVkZU5vZGVzKSB7XG4gICAgICAgIHZhciBwb3MgPSBlbGUucG9zaXRpb24oKTtcbiAgICAgICAgeCA9IHBvcy54O1xuICAgICAgICB5ID0gcG9zLnk7XG5cbiAgICAgICAgdmFyIF93ID0gZWxlLm91dGVyV2lkdGgoKTtcblxuICAgICAgICB2YXIgaGFsZlcgPSBfdyAvIDI7XG4gICAgICAgIHZhciBoID0gZWxlLm91dGVySGVpZ2h0KCk7XG4gICAgICAgIHZhciBoYWxmSCA9IGggLyAyOyAvLyBoYW5kbGUgbm9kZSBkaW1lbnNpb25zXG4gICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgICAgICBleDEgPSB4IC0gaGFsZlc7XG4gICAgICAgIGV4MiA9IHggKyBoYWxmVztcbiAgICAgICAgZXkxID0geSAtIGhhbGZIO1xuICAgICAgICBleTIgPSB5ICsgaGFsZkg7XG4gICAgICAgIHVwZGF0ZUJvdW5kcyhib3VuZHMsIGV4MSwgZXkxLCBleDIsIGV5Mik7XG4gICAgICB9IGVsc2UgaWYgKGlzRWRnZSAmJiBvcHRpb25zLmluY2x1ZGVFZGdlcykge1xuICAgICAgICBpZiAoc3R5bGVFbmFibGVkICYmICFoZWFkbGVzcykge1xuICAgICAgICAgIHZhciBjdXJ2ZVN0eWxlID0gZWxlLnBzdHlsZSgnY3VydmUtc3R5bGUnKS5zdHJWYWx1ZTsgLy8gaGFuZGxlIGVkZ2UgZGltZW5zaW9ucyAocm91Z2ggYm94IGVzdGltYXRlKVxuICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgICAgICAgIGV4MSA9IE1hdGgubWluKHJzdHlsZS5zcmNYLCByc3R5bGUubWlkWCwgcnN0eWxlLnRndFgpO1xuICAgICAgICAgIGV4MiA9IE1hdGgubWF4KHJzdHlsZS5zcmNYLCByc3R5bGUubWlkWCwgcnN0eWxlLnRndFgpO1xuICAgICAgICAgIGV5MSA9IE1hdGgubWluKHJzdHlsZS5zcmNZLCByc3R5bGUubWlkWSwgcnN0eWxlLnRndFkpO1xuICAgICAgICAgIGV5MiA9IE1hdGgubWF4KHJzdHlsZS5zcmNZLCByc3R5bGUubWlkWSwgcnN0eWxlLnRndFkpOyAvLyB0YWtlIGludG8gYWNjb3VudCBlZGdlIHdpZHRoXG5cbiAgICAgICAgICBleDEgLT0gd0hhbGY7XG4gICAgICAgICAgZXgyICs9IHdIYWxmO1xuICAgICAgICAgIGV5MSAtPSB3SGFsZjtcbiAgICAgICAgICBleTIgKz0gd0hhbGY7XG4gICAgICAgICAgdXBkYXRlQm91bmRzKGJvdW5kcywgZXgxLCBleTEsIGV4MiwgZXkyKTsgLy8gcHJlY2lzZSBlZGdlc1xuICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy9cblxuICAgICAgICAgIGlmIChjdXJ2ZVN0eWxlID09PSAnaGF5c3RhY2snKSB7XG4gICAgICAgICAgICB2YXIgaHB0cyA9IHJzdHlsZS5oYXlzdGFja1B0cztcblxuICAgICAgICAgICAgaWYgKGhwdHMgJiYgaHB0cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgZXgxID0gaHB0c1swXS54O1xuICAgICAgICAgICAgICBleTEgPSBocHRzWzBdLnk7XG4gICAgICAgICAgICAgIGV4MiA9IGhwdHNbMV0ueDtcbiAgICAgICAgICAgICAgZXkyID0gaHB0c1sxXS55O1xuXG4gICAgICAgICAgICAgIGlmIChleDEgPiBleDIpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGVtcCA9IGV4MTtcbiAgICAgICAgICAgICAgICBleDEgPSBleDI7XG4gICAgICAgICAgICAgICAgZXgyID0gdGVtcDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChleTEgPiBleTIpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RlbXAgPSBleTE7XG4gICAgICAgICAgICAgICAgZXkxID0gZXkyO1xuICAgICAgICAgICAgICAgIGV5MiA9IF90ZW1wO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdXBkYXRlQm91bmRzKGJvdW5kcywgZXgxIC0gd0hhbGYsIGV5MSAtIHdIYWxmLCBleDIgKyB3SGFsZiwgZXkyICsgd0hhbGYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoY3VydmVTdHlsZSA9PT0gJ2JlemllcicgfHwgY3VydmVTdHlsZSA9PT0gJ3VuYnVuZGxlZC1iZXppZXInIHx8IGN1cnZlU3R5bGUgPT09ICdzZWdtZW50cycgfHwgY3VydmVTdHlsZSA9PT0gJ3RheGknKSB7XG4gICAgICAgICAgICB2YXIgcHRzO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKGN1cnZlU3R5bGUpIHtcbiAgICAgICAgICAgICAgY2FzZSAnYmV6aWVyJzpcbiAgICAgICAgICAgICAgY2FzZSAndW5idW5kbGVkLWJlemllcic6XG4gICAgICAgICAgICAgICAgcHRzID0gcnN0eWxlLmJlemllclB0cztcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlICdzZWdtZW50cyc6XG4gICAgICAgICAgICAgIGNhc2UgJ3RheGknOlxuICAgICAgICAgICAgICAgIHB0cyA9IHJzdHlsZS5saW5lUHRzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocHRzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwdHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcHQgPSBwdHNbal07XG4gICAgICAgICAgICAgICAgZXgxID0gcHQueCAtIHdIYWxmO1xuICAgICAgICAgICAgICAgIGV4MiA9IHB0LnggKyB3SGFsZjtcbiAgICAgICAgICAgICAgICBleTEgPSBwdC55IC0gd0hhbGY7XG4gICAgICAgICAgICAgICAgZXkyID0gcHQueSArIHdIYWxmO1xuICAgICAgICAgICAgICAgIHVwZGF0ZUJvdW5kcyhib3VuZHMsIGV4MSwgZXkxLCBleDIsIGV5Mik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIGJlemllci1saWtlIG9yIHNlZ21lbnQtbGlrZSBlZGdlXG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBoZWFkbGVzcyBvciBzdHlsZSBkaXNhYmxlZFxuICAgICAgICAgIC8vIGZhbGxiYWNrIG9uIHNvdXJjZSBhbmQgdGFyZ2V0IHBvc2l0aW9uc1xuICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgICAgICAgIHZhciBuMSA9IGVsZS5zb3VyY2UoKTtcbiAgICAgICAgICB2YXIgbjFwb3MgPSBuMS5wb3NpdGlvbigpO1xuICAgICAgICAgIHZhciBuMiA9IGVsZS50YXJnZXQoKTtcbiAgICAgICAgICB2YXIgbjJwb3MgPSBuMi5wb3NpdGlvbigpO1xuICAgICAgICAgIGV4MSA9IG4xcG9zLng7XG4gICAgICAgICAgZXgyID0gbjJwb3MueDtcbiAgICAgICAgICBleTEgPSBuMXBvcy55O1xuICAgICAgICAgIGV5MiA9IG4ycG9zLnk7XG5cbiAgICAgICAgICBpZiAoZXgxID4gZXgyKSB7XG4gICAgICAgICAgICB2YXIgX3RlbXAyID0gZXgxO1xuICAgICAgICAgICAgZXgxID0gZXgyO1xuICAgICAgICAgICAgZXgyID0gX3RlbXAyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChleTEgPiBleTIpIHtcbiAgICAgICAgICAgIHZhciBfdGVtcDMgPSBleTE7XG4gICAgICAgICAgICBleTEgPSBleTI7XG4gICAgICAgICAgICBleTIgPSBfdGVtcDM7XG4gICAgICAgICAgfSAvLyB0YWtlIGludG8gYWNjb3VudCBlZGdlIHdpZHRoXG5cblxuICAgICAgICAgIGV4MSAtPSB3SGFsZjtcbiAgICAgICAgICBleDIgKz0gd0hhbGY7XG4gICAgICAgICAgZXkxIC09IHdIYWxmO1xuICAgICAgICAgIGV5MiArPSB3SGFsZjtcbiAgICAgICAgICB1cGRhdGVCb3VuZHMoYm91bmRzLCBleDEsIGV5MSwgZXgyLCBleTIpO1xuICAgICAgICB9IC8vIGhlYWRsZXNzIG9yIHN0eWxlIGRpc2FibGVkXG5cbiAgICAgIH0gLy8gZWRnZXNcbiAgICAgIC8vIGhhbmRsZSBlZGdlIGFycm93IHNpemVcbiAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXG4gICAgICBpZiAoc3R5bGVFbmFibGVkICYmIG9wdGlvbnMuaW5jbHVkZUVkZ2VzICYmIGlzRWRnZSkge1xuICAgICAgICB1cGRhdGVCb3VuZHNGcm9tQXJyb3coYm91bmRzLCBlbGUsICdtaWQtc291cmNlJyk7XG4gICAgICAgIHVwZGF0ZUJvdW5kc0Zyb21BcnJvdyhib3VuZHMsIGVsZSwgJ21pZC10YXJnZXQnKTtcbiAgICAgICAgdXBkYXRlQm91bmRzRnJvbUFycm93KGJvdW5kcywgZWxlLCAnc291cmNlJyk7XG4gICAgICAgIHVwZGF0ZUJvdW5kc0Zyb21BcnJvdyhib3VuZHMsIGVsZSwgJ3RhcmdldCcpO1xuICAgICAgfSAvLyBnaG9zdFxuICAgICAgLy8vLy8vLy9cblxuXG4gICAgICBpZiAoc3R5bGVFbmFibGVkKSB7XG4gICAgICAgIHZhciBnaG9zdCA9IGVsZS5wc3R5bGUoJ2dob3N0JykudmFsdWUgPT09ICd5ZXMnO1xuXG4gICAgICAgIGlmIChnaG9zdCkge1xuICAgICAgICAgIHZhciBneCA9IGVsZS5wc3R5bGUoJ2dob3N0LW9mZnNldC14JykucGZWYWx1ZTtcbiAgICAgICAgICB2YXIgZ3kgPSBlbGUucHN0eWxlKCdnaG9zdC1vZmZzZXQteScpLnBmVmFsdWU7XG4gICAgICAgICAgdXBkYXRlQm91bmRzKGJvdW5kcywgYm91bmRzLngxICsgZ3gsIGJvdW5kcy55MSArIGd5LCBib3VuZHMueDIgKyBneCwgYm91bmRzLnkyICsgZ3kpO1xuICAgICAgICB9XG4gICAgICB9IC8vIGFsd2F5cyBzdG9yZSB0aGUgYm9keSBib3VuZHMgc2VwYXJhdGVseSBmcm9tIHRoZSBsYWJlbHNcblxuXG4gICAgICB2YXIgYmJCb2R5ID0gX3AuYm9keUJvdW5kcyA9IF9wLmJvZHlCb3VuZHMgfHwge307XG4gICAgICBhc3NpZ25Cb3VuZGluZ0JveChiYkJvZHksIGJvdW5kcyk7XG4gICAgICBleHBhbmRCb3VuZGluZ0JveFNpZGVzKGJiQm9keSwgbWFudWFsRXhwYW5zaW9uKTtcbiAgICAgIGV4cGFuZEJvdW5kaW5nQm94KGJiQm9keSwgMSk7IC8vIGV4cGFuZCB0byB3b3JrIGFyb3VuZCBicm93c2VyIGRpbWVuc2lvbiBpbmFjY3VyYWNpZXNcbiAgICAgIC8vIG92ZXJsYXlcbiAgICAgIC8vLy8vLy8vLy9cblxuICAgICAgaWYgKHN0eWxlRW5hYmxlZCkge1xuICAgICAgICBleDEgPSBib3VuZHMueDE7XG4gICAgICAgIGV4MiA9IGJvdW5kcy54MjtcbiAgICAgICAgZXkxID0gYm91bmRzLnkxO1xuICAgICAgICBleTIgPSBib3VuZHMueTI7XG4gICAgICAgIHVwZGF0ZUJvdW5kcyhib3VuZHMsIGV4MSAtIHBhZGRpbmcsIGV5MSAtIHBhZGRpbmcsIGV4MiArIHBhZGRpbmcsIGV5MiArIHBhZGRpbmcpO1xuICAgICAgfSAvLyBhbHdheXMgc3RvcmUgdGhlIGJvZHkgYm91bmRzIHNlcGFyYXRlbHkgZnJvbSB0aGUgbGFiZWxzXG5cblxuICAgICAgdmFyIGJiT3ZlcmxheSA9IF9wLm92ZXJsYXlCb3VuZHMgPSBfcC5vdmVybGF5Qm91bmRzIHx8IHt9O1xuICAgICAgYXNzaWduQm91bmRpbmdCb3goYmJPdmVybGF5LCBib3VuZHMpO1xuICAgICAgZXhwYW5kQm91bmRpbmdCb3hTaWRlcyhiYk92ZXJsYXksIG1hbnVhbEV4cGFuc2lvbik7XG4gICAgICBleHBhbmRCb3VuZGluZ0JveChiYk92ZXJsYXksIDEpOyAvLyBleHBhbmQgdG8gd29yayBhcm91bmQgYnJvd3NlciBkaW1lbnNpb24gaW5hY2N1cmFjaWVzXG4gICAgICAvLyBoYW5kbGUgbGFiZWwgZGltZW5zaW9uc1xuICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgICAgdmFyIGJiTGFiZWxzID0gX3AubGFiZWxCb3VuZHMgPSBfcC5sYWJlbEJvdW5kcyB8fCB7fTtcblxuICAgICAgaWYgKGJiTGFiZWxzLmFsbCAhPSBudWxsKSB7XG4gICAgICAgIGNsZWFyQm91bmRpbmdCb3goYmJMYWJlbHMuYWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJiTGFiZWxzLmFsbCA9IG1ha2VCb3VuZGluZ0JveCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3R5bGVFbmFibGVkICYmIG9wdGlvbnMuaW5jbHVkZUxhYmVscykge1xuICAgICAgICBpZiAob3B0aW9ucy5pbmNsdWRlTWFpbkxhYmVscykge1xuICAgICAgICAgIHVwZGF0ZUJvdW5kc0Zyb21MYWJlbChib3VuZHMsIGVsZSwgbnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNFZGdlKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMuaW5jbHVkZVNvdXJjZUxhYmVscykge1xuICAgICAgICAgICAgdXBkYXRlQm91bmRzRnJvbUxhYmVsKGJvdW5kcywgZWxlLCAnc291cmNlJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG9wdGlvbnMuaW5jbHVkZVRhcmdldExhYmVscykge1xuICAgICAgICAgICAgdXBkYXRlQm91bmRzRnJvbUxhYmVsKGJvdW5kcywgZWxlLCAndGFyZ2V0Jyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIHN0eWxlIGVuYWJsZWQgZm9yIGxhYmVsc1xuXG4gICAgfSAvLyBpZiBkaXNwbGF5ZWRcblxuXG4gICAgYm91bmRzLngxID0gbm9uaW5mKGJvdW5kcy54MSk7XG4gICAgYm91bmRzLnkxID0gbm9uaW5mKGJvdW5kcy55MSk7XG4gICAgYm91bmRzLngyID0gbm9uaW5mKGJvdW5kcy54Mik7XG4gICAgYm91bmRzLnkyID0gbm9uaW5mKGJvdW5kcy55Mik7XG4gICAgYm91bmRzLncgPSBub25pbmYoYm91bmRzLngyIC0gYm91bmRzLngxKTtcbiAgICBib3VuZHMuaCA9IG5vbmluZihib3VuZHMueTIgLSBib3VuZHMueTEpO1xuXG4gICAgaWYgKGJvdW5kcy53ID4gMCAmJiBib3VuZHMuaCA+IDAgJiYgZGlzcGxheWVkKSB7XG4gICAgICBleHBhbmRCb3VuZGluZ0JveFNpZGVzKGJvdW5kcywgbWFudWFsRXhwYW5zaW9uKTsgLy8gZXhwYW5kIGJvdW5kcyBieSAxIGJlY2F1c2UgYW50aWFsaWFzaW5nIGNhbiBpbmNyZWFzZSB0aGUgdmlzdWFsL2VmZmVjdGl2ZSBzaXplIGJ5IDEgb24gYWxsIHNpZGVzXG5cbiAgICAgIGV4cGFuZEJvdW5kaW5nQm94KGJvdW5kcywgMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJvdW5kcztcbiAgfTtcblxuICB2YXIgZ2V0S2V5ID0gZnVuY3Rpb24gZ2V0S2V5KG9wdHMpIHtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICB2YXIgdGYgPSBmdW5jdGlvbiB0Zih2YWwpIHtcbiAgICAgIHJldHVybiAodmFsID8gMSA6IDApIDw8IGkrKztcbiAgICB9O1xuXG4gICAgdmFyIGtleSA9IDA7XG4gICAga2V5ICs9IHRmKG9wdHMuaW5jdWRlTm9kZXMpO1xuICAgIGtleSArPSB0ZihvcHRzLmluY2x1ZGVFZGdlcyk7XG4gICAga2V5ICs9IHRmKG9wdHMuaW5jbHVkZUxhYmVscyk7XG4gICAga2V5ICs9IHRmKG9wdHMuaW5jbHVkZU1haW5MYWJlbHMpO1xuICAgIGtleSArPSB0ZihvcHRzLmluY2x1ZGVTb3VyY2VMYWJlbHMpO1xuICAgIGtleSArPSB0ZihvcHRzLmluY2x1ZGVUYXJnZXRMYWJlbHMpO1xuICAgIGtleSArPSB0ZihvcHRzLmluY2x1ZGVPdmVybGF5cyk7XG4gICAgcmV0dXJuIGtleTtcbiAgfTtcblxuICB2YXIgZ2V0Qm91bmRpbmdCb3hQb3NLZXkgPSBmdW5jdGlvbiBnZXRCb3VuZGluZ0JveFBvc0tleShlbGUpIHtcbiAgICBpZiAoZWxlLmlzRWRnZSgpKSB7XG4gICAgICB2YXIgcDEgPSBlbGUuc291cmNlKCkucG9zaXRpb24oKTtcbiAgICAgIHZhciBwMiA9IGVsZS50YXJnZXQoKS5wb3NpdGlvbigpO1xuXG4gICAgICB2YXIgciA9IGZ1bmN0aW9uIHIoeCkge1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCh4KTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBoYXNoSW50c0FycmF5KFtyKHAxLngpLCByKHAxLnkpLCByKHAyLngpLCByKHAyLnkpXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfTtcblxuICB2YXIgY2FjaGVkQm91bmRpbmdCb3hJbXBsID0gZnVuY3Rpb24gY2FjaGVkQm91bmRpbmdCb3hJbXBsKGVsZSwgb3B0cykge1xuICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICB2YXIgYmI7XG4gICAgdmFyIGlzRWRnZSA9IGVsZS5pc0VkZ2UoKTtcbiAgICB2YXIga2V5ID0gb3B0cyA9PSBudWxsID8gZGVmQmJPcHRzS2V5IDogZ2V0S2V5KG9wdHMpO1xuICAgIHZhciB1c2luZ0RlZk9wdHMgPSBrZXkgPT09IGRlZkJiT3B0c0tleTtcbiAgICB2YXIgY3VyclBvc0tleSA9IGdldEJvdW5kaW5nQm94UG9zS2V5KGVsZSk7XG4gICAgdmFyIGlzUG9zS2V5U2FtZSA9IF9wLmJiQ2FjaGVQb3NLZXkgPT09IGN1cnJQb3NLZXk7XG4gICAgdmFyIHVzZUNhY2hlID0gb3B0cy51c2VDYWNoZSAmJiBpc1Bvc0tleVNhbWU7XG5cbiAgICB2YXIgaXNEaXJ0eSA9IGZ1bmN0aW9uIGlzRGlydHkoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLl9wcml2YXRlLmJiQ2FjaGUgPT0gbnVsbCB8fCBlbGUuX3ByaXZhdGUuc3R5bGVEaXJ0eTtcbiAgICB9O1xuXG4gICAgdmFyIG5lZWRSZWNhbGMgPSAhdXNlQ2FjaGUgfHwgaXNEaXJ0eShlbGUpIHx8IGlzRWRnZSAmJiBpc0RpcnR5KGVsZS5zb3VyY2UoKSkgfHwgaXNEaXJ0eShlbGUudGFyZ2V0KCkpO1xuXG4gICAgaWYgKG5lZWRSZWNhbGMpIHtcbiAgICAgIGlmICghaXNQb3NLZXlTYW1lKSB7XG4gICAgICAgIGVsZS5yZWNhbGN1bGF0ZVJlbmRlcmVkU3R5bGUodXNlQ2FjaGUpO1xuICAgICAgfVxuXG4gICAgICBiYiA9IGJvdW5kaW5nQm94SW1wbChlbGUsIGRlZkJiT3B0cyk7XG4gICAgICBfcC5iYkNhY2hlID0gYmI7XG4gICAgICBfcC5iYkNhY2hlUG9zS2V5ID0gY3VyclBvc0tleTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmIgPSBfcC5iYkNhY2hlO1xuICAgIH0gLy8gbm90IHVzaW5nIGRlZiBvcHRzID0+IG5lZWQgdG8gYnVpbGQgdXAgYmIgZnJvbSBjb21iaW5hdGlvbiBvZiBzdWIgYmJzXG5cblxuICAgIGlmICghdXNpbmdEZWZPcHRzKSB7XG4gICAgICB2YXIgaXNOb2RlID0gZWxlLmlzTm9kZSgpO1xuICAgICAgYmIgPSBtYWtlQm91bmRpbmdCb3goKTtcblxuICAgICAgaWYgKG9wdHMuaW5jbHVkZU5vZGVzICYmIGlzTm9kZSB8fCBvcHRzLmluY2x1ZGVFZGdlcyAmJiAhaXNOb2RlKSB7XG4gICAgICAgIGlmIChvcHRzLmluY2x1ZGVPdmVybGF5cykge1xuICAgICAgICAgIHVwZGF0ZUJvdW5kc0Zyb21Cb3goYmIsIF9wLm92ZXJsYXlCb3VuZHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVwZGF0ZUJvdW5kc0Zyb21Cb3goYmIsIF9wLmJvZHlCb3VuZHMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRzLmluY2x1ZGVMYWJlbHMpIHtcbiAgICAgICAgaWYgKG9wdHMuaW5jbHVkZU1haW5MYWJlbHMgJiYgKCFpc0VkZ2UgfHwgb3B0cy5pbmNsdWRlU291cmNlTGFiZWxzICYmIG9wdHMuaW5jbHVkZVRhcmdldExhYmVscykpIHtcbiAgICAgICAgICB1cGRhdGVCb3VuZHNGcm9tQm94KGJiLCBfcC5sYWJlbEJvdW5kcy5hbGwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChvcHRzLmluY2x1ZGVNYWluTGFiZWxzKSB7XG4gICAgICAgICAgICB1cGRhdGVCb3VuZHNGcm9tQm94KGJiLCBfcC5sYWJlbEJvdW5kcy5tYWluUm90KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob3B0cy5pbmNsdWRlU291cmNlTGFiZWxzKSB7XG4gICAgICAgICAgICB1cGRhdGVCb3VuZHNGcm9tQm94KGJiLCBfcC5sYWJlbEJvdW5kcy5zb3VyY2VSb3QpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvcHRzLmluY2x1ZGVUYXJnZXRMYWJlbHMpIHtcbiAgICAgICAgICAgIHVwZGF0ZUJvdW5kc0Zyb21Cb3goYmIsIF9wLmxhYmVsQm91bmRzLnRhcmdldFJvdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGJiLncgPSBiYi54MiAtIGJiLngxO1xuICAgICAgYmIuaCA9IGJiLnkyIC0gYmIueTE7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJiO1xuICB9O1xuXG4gIHZhciBkZWZCYk9wdHMgPSB7XG4gICAgaW5jbHVkZU5vZGVzOiB0cnVlLFxuICAgIGluY2x1ZGVFZGdlczogdHJ1ZSxcbiAgICBpbmNsdWRlTGFiZWxzOiB0cnVlLFxuICAgIGluY2x1ZGVNYWluTGFiZWxzOiB0cnVlLFxuICAgIGluY2x1ZGVTb3VyY2VMYWJlbHM6IHRydWUsXG4gICAgaW5jbHVkZVRhcmdldExhYmVsczogdHJ1ZSxcbiAgICBpbmNsdWRlT3ZlcmxheXM6IHRydWUsXG4gICAgaW5jbHVkZVVuZGVybGF5czogdHJ1ZSxcbiAgICB1c2VDYWNoZTogdHJ1ZVxuICB9O1xuICB2YXIgZGVmQmJPcHRzS2V5ID0gZ2V0S2V5KGRlZkJiT3B0cyk7XG4gIHZhciBmaWxsZWRCYk9wdHMgPSBkZWZhdWx0cyRnKGRlZkJiT3B0cyk7XG5cbiAgZWxlc2ZuJGIuYm91bmRpbmdCb3ggPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciBib3VuZHM7IC8vIHRoZSBtYWluIHVzZWNhc2UgaXMgZWxlLmJvdW5kaW5nQm94KCkgZm9yIGEgc2luZ2xlIGVsZW1lbnQgd2l0aCBuby9kZWYgb3B0aW9uc1xuICAgIC8vIHNwZWNpZmllZCBzLnQuIHRoZSBjYWNoZSBpcyB1c2VkLCBzbyBjaGVjayBmb3IgdGhpcyBjYXNlIHRvIG1ha2UgaXQgZmFzdGVyIGJ5XG4gICAgLy8gYXZvaWRpbmcgdGhlIG92ZXJoZWFkIG9mIHRoZSByZXN0IG9mIHRoZSBmdW5jdGlvblxuXG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxICYmIHRoaXNbMF0uX3ByaXZhdGUuYmJDYWNoZSAhPSBudWxsICYmICF0aGlzWzBdLl9wcml2YXRlLnN0eWxlRGlydHkgJiYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLnVzZUNhY2hlID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy51c2VDYWNoZSA9PT0gdHJ1ZSkpIHtcbiAgICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucyA9IGRlZkJiT3B0cztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdGlvbnMgPSBmaWxsZWRCYk9wdHMob3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIGJvdW5kcyA9IGNhY2hlZEJvdW5kaW5nQm94SW1wbCh0aGlzWzBdLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYm91bmRzID0gbWFrZUJvdW5kaW5nQm94KCk7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCBkZWZCYk9wdHM7XG4gICAgICB2YXIgb3B0cyA9IGZpbGxlZEJiT3B0cyhvcHRpb25zKTtcbiAgICAgIHZhciBlbGVzID0gdGhpcztcbiAgICAgIHZhciBjeSA9IGVsZXMuY3koKTtcbiAgICAgIHZhciBzdHlsZUVuYWJsZWQgPSBjeS5zdHlsZUVuYWJsZWQoKTtcblxuICAgICAgaWYgKHN0eWxlRW5hYmxlZCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgICAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgICAgICAgdmFyIGN1cnJQb3NLZXkgPSBnZXRCb3VuZGluZ0JveFBvc0tleShlbGUpO1xuICAgICAgICAgIHZhciBpc1Bvc0tleVNhbWUgPSBfcC5iYkNhY2hlUG9zS2V5ID09PSBjdXJyUG9zS2V5O1xuICAgICAgICAgIHZhciB1c2VDYWNoZSA9IG9wdHMudXNlQ2FjaGUgJiYgaXNQb3NLZXlTYW1lICYmICFfcC5zdHlsZURpcnR5O1xuICAgICAgICAgIGVsZS5yZWNhbGN1bGF0ZVJlbmRlcmVkU3R5bGUodXNlQ2FjaGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMudXBkYXRlQ29tcG91bmRCb3VuZHMoIW9wdGlvbnMudXNlQ2FjaGUpO1xuXG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgZWxlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIF9lbGUgPSBlbGVzW19pXTtcbiAgICAgICAgdXBkYXRlQm91bmRzRnJvbUJveChib3VuZHMsIGNhY2hlZEJvdW5kaW5nQm94SW1wbChfZWxlLCBvcHRzKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYm91bmRzLngxID0gbm9uaW5mKGJvdW5kcy54MSk7XG4gICAgYm91bmRzLnkxID0gbm9uaW5mKGJvdW5kcy55MSk7XG4gICAgYm91bmRzLngyID0gbm9uaW5mKGJvdW5kcy54Mik7XG4gICAgYm91bmRzLnkyID0gbm9uaW5mKGJvdW5kcy55Mik7XG4gICAgYm91bmRzLncgPSBub25pbmYoYm91bmRzLngyIC0gYm91bmRzLngxKTtcbiAgICBib3VuZHMuaCA9IG5vbmluZihib3VuZHMueTIgLSBib3VuZHMueTEpO1xuICAgIHJldHVybiBib3VuZHM7XG4gIH07XG5cbiAgZWxlc2ZuJGIuZGlydHlCb3VuZGluZ0JveENhY2hlID0gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIF9wID0gdGhpc1tpXS5fcHJpdmF0ZTtcbiAgICAgIF9wLmJiQ2FjaGUgPSBudWxsO1xuICAgICAgX3AuYmJDYWNoZVBvc0tleSA9IG51bGw7XG4gICAgICBfcC5ib2R5Qm91bmRzID0gbnVsbDtcbiAgICAgIF9wLm92ZXJsYXlCb3VuZHMgPSBudWxsO1xuICAgICAgX3AubGFiZWxCb3VuZHMuYWxsID0gbnVsbDtcbiAgICAgIF9wLmxhYmVsQm91bmRzLnNvdXJjZSA9IG51bGw7XG4gICAgICBfcC5sYWJlbEJvdW5kcy50YXJnZXQgPSBudWxsO1xuICAgICAgX3AubGFiZWxCb3VuZHMubWFpbiA9IG51bGw7XG4gICAgICBfcC5sYWJlbEJvdW5kcy5zb3VyY2VSb3QgPSBudWxsO1xuICAgICAgX3AubGFiZWxCb3VuZHMudGFyZ2V0Um90ID0gbnVsbDtcbiAgICAgIF9wLmxhYmVsQm91bmRzLm1haW5Sb3QgPSBudWxsO1xuICAgICAgX3AuYXJyb3dCb3VuZHMuc291cmNlID0gbnVsbDtcbiAgICAgIF9wLmFycm93Qm91bmRzLnRhcmdldCA9IG51bGw7XG4gICAgICBfcC5hcnJvd0JvdW5kc1snbWlkLXNvdXJjZSddID0gbnVsbDtcbiAgICAgIF9wLmFycm93Qm91bmRzWydtaWQtdGFyZ2V0J10gPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMuZW1pdEFuZE5vdGlmeSgnYm91bmRzJyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07IC8vIHByaXZhdGUgaGVscGVyIHRvIGdldCBib3VuZGluZyBib3ggZm9yIGN1c3RvbSBub2RlIHBvc2l0aW9uc1xuICAvLyAtIGdvb2QgZm9yIHBlcmYgaW4gY2VydGFpbiBjYXNlcyBidXQgY3VycmVudGx5IHJlcXVpcmVzIGRpcnR5aW5nIHRoZSByZW5kZXJlZCBzdHlsZVxuICAvLyAtIHdvdWxkIGJlIGJldHRlciB0byBub3QgbW9kaWZ5IHRoZSBub2RlcyBidXQgdGhlIG5vZGVzIGFyZSByZWFkIGRpcmVjdGx5IGV2ZXJ5d2hlcmUgaW4gdGhlIHJlbmRlcmVyLi4uXG4gIC8vIC0gdHJ5IHRvIHVzZSBmb3Igb25seSB0aGluZ3MgbGlrZSBkaXNjcmV0ZSBsYXlvdXRzIHdoZXJlIHRoZSBub2RlIHBvc2l0aW9uIHdvdWxkIGNoYW5nZSBhbnl3YXlcblxuXG4gIGVsZXNmbiRiLmJvdW5kaW5nQm94QXQgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIHZhciBoYXNDb21wb3VuZE5vZGVzID0gY3kuaGFzQ29tcG91bmROb2RlcygpO1xuICAgIHZhciBwYXJlbnRzID0gY3kuY29sbGVjdGlvbigpO1xuXG4gICAgaWYgKGhhc0NvbXBvdW5kTm9kZXMpIHtcbiAgICAgIHBhcmVudHMgPSBub2Rlcy5maWx0ZXIoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUuaXNQYXJlbnQoKTtcbiAgICAgIH0pO1xuICAgICAgbm9kZXMgPSBub2Rlcy5ub3QocGFyZW50cyk7XG4gICAgfVxuXG4gICAgaWYgKHBsYWluT2JqZWN0KGZuKSkge1xuICAgICAgdmFyIG9iaiA9IGZuO1xuXG4gICAgICBmbiA9IGZ1bmN0aW9uIGZuKCkge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgc3RvcmVPbGRQb3MgPSBmdW5jdGlvbiBzdG9yZU9sZFBvcyhub2RlLCBpKSB7XG4gICAgICByZXR1cm4gbm9kZS5fcHJpdmF0ZS5iYkF0T2xkUG9zID0gZm4obm9kZSwgaSk7XG4gICAgfTtcblxuICAgIHZhciBnZXRPbGRQb3MgPSBmdW5jdGlvbiBnZXRPbGRQb3Mobm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGUuX3ByaXZhdGUuYmJBdE9sZFBvcztcbiAgICB9O1xuXG4gICAgY3kuc3RhcnRCYXRjaCgpO1xuICAgIG5vZGVzLmZvckVhY2goc3RvcmVPbGRQb3MpLnNpbGVudFBvc2l0aW9ucyhmbik7XG5cbiAgICBpZiAoaGFzQ29tcG91bmROb2Rlcykge1xuICAgICAgcGFyZW50cy5kaXJ0eUNvbXBvdW5kQm91bmRzQ2FjaGUoKTtcbiAgICAgIHBhcmVudHMuZGlydHlCb3VuZGluZ0JveENhY2hlKCk7XG4gICAgICBwYXJlbnRzLnVwZGF0ZUNvbXBvdW5kQm91bmRzKHRydWUpOyAvLyBmb3JjZSB1cGRhdGUgYi9jIHdlJ3JlIGluc2lkZSBhIGJhdGNoIGN5Y2xlXG4gICAgfVxuXG4gICAgdmFyIGJiID0gY29weUJvdW5kaW5nQm94KHRoaXMuYm91bmRpbmdCb3goe1xuICAgICAgdXNlQ2FjaGU6IGZhbHNlXG4gICAgfSkpO1xuICAgIG5vZGVzLnNpbGVudFBvc2l0aW9ucyhnZXRPbGRQb3MpO1xuXG4gICAgaWYgKGhhc0NvbXBvdW5kTm9kZXMpIHtcbiAgICAgIHBhcmVudHMuZGlydHlDb21wb3VuZEJvdW5kc0NhY2hlKCk7XG4gICAgICBwYXJlbnRzLmRpcnR5Qm91bmRpbmdCb3hDYWNoZSgpO1xuICAgICAgcGFyZW50cy51cGRhdGVDb21wb3VuZEJvdW5kcyh0cnVlKTsgLy8gZm9yY2UgdXBkYXRlIGIvYyB3ZSdyZSBpbnNpZGUgYSBiYXRjaCBjeWNsZVxuICAgIH1cblxuICAgIGN5LmVuZEJhdGNoKCk7XG4gICAgcmV0dXJuIGJiO1xuICB9O1xuXG4gIGZuJDMuYm91bmRpbmdib3ggPSBmbiQzLmJiID0gZm4kMy5ib3VuZGluZ0JveDtcbiAgZm4kMy5yZW5kZXJlZEJvdW5kaW5nYm94ID0gZm4kMy5yZW5kZXJlZEJvdW5kaW5nQm94O1xuICB2YXIgYm91bmRzID0gZWxlc2ZuJGI7XG5cbiAgdmFyIGZuJDIsIGVsZXNmbiRhO1xuICBmbiQyID0gZWxlc2ZuJGEgPSB7fTtcblxuICB2YXIgZGVmaW5lRGltRm5zID0gZnVuY3Rpb24gZGVmaW5lRGltRm5zKG9wdHMpIHtcbiAgICBvcHRzLnVwcGVyY2FzZU5hbWUgPSBjYXBpdGFsaXplKG9wdHMubmFtZSk7XG4gICAgb3B0cy5hdXRvTmFtZSA9ICdhdXRvJyArIG9wdHMudXBwZXJjYXNlTmFtZTtcbiAgICBvcHRzLmxhYmVsTmFtZSA9ICdsYWJlbCcgKyBvcHRzLnVwcGVyY2FzZU5hbWU7XG4gICAgb3B0cy5vdXRlck5hbWUgPSAnb3V0ZXInICsgb3B0cy51cHBlcmNhc2VOYW1lO1xuICAgIG9wdHMudXBwZXJjYXNlT3V0ZXJOYW1lID0gY2FwaXRhbGl6ZShvcHRzLm91dGVyTmFtZSk7XG5cbiAgICBmbiQyW29wdHMubmFtZV0gPSBmdW5jdGlvbiBkaW1JbXBsKCkge1xuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgICB2YXIgY3kgPSBfcC5jeTtcbiAgICAgIHZhciBzdHlsZUVuYWJsZWQgPSBjeS5fcHJpdmF0ZS5zdHlsZUVuYWJsZWQ7XG5cbiAgICAgIGlmIChlbGUpIHtcbiAgICAgICAgaWYgKHN0eWxlRW5hYmxlZCkge1xuICAgICAgICAgIGlmIChlbGUuaXNQYXJlbnQoKSkge1xuICAgICAgICAgICAgZWxlLnVwZGF0ZUNvbXBvdW5kQm91bmRzKCk7XG4gICAgICAgICAgICByZXR1cm4gX3Bbb3B0cy5hdXRvTmFtZV0gfHwgMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZCA9IGVsZS5wc3R5bGUob3B0cy5uYW1lKTtcblxuICAgICAgICAgIHN3aXRjaCAoZC5zdHJWYWx1ZSkge1xuICAgICAgICAgICAgY2FzZSAnbGFiZWwnOlxuICAgICAgICAgICAgICBlbGUucmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlKCk7XG4gICAgICAgICAgICAgIHJldHVybiBfcC5yc3R5bGVbb3B0cy5sYWJlbE5hbWVdIHx8IDA7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJldHVybiBkLnBmVmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZuJDJbJ291dGVyJyArIG9wdHMudXBwZXJjYXNlTmFtZV0gPSBmdW5jdGlvbiBvdXRlckRpbUltcGwoKSB7XG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICAgIHZhciBjeSA9IF9wLmN5O1xuICAgICAgdmFyIHN0eWxlRW5hYmxlZCA9IGN5Ll9wcml2YXRlLnN0eWxlRW5hYmxlZDtcblxuICAgICAgaWYgKGVsZSkge1xuICAgICAgICBpZiAoc3R5bGVFbmFibGVkKSB7XG4gICAgICAgICAgdmFyIGRpbSA9IGVsZVtvcHRzLm5hbWVdKCk7XG4gICAgICAgICAgdmFyIGJvcmRlciA9IGVsZS5wc3R5bGUoJ2JvcmRlci13aWR0aCcpLnBmVmFsdWU7IC8vIG4uYi4gMS8yIGVhY2ggc2lkZVxuXG4gICAgICAgICAgdmFyIHBhZGRpbmcgPSAyICogZWxlLnBhZGRpbmcoKTtcbiAgICAgICAgICByZXR1cm4gZGltICsgYm9yZGVyICsgcGFkZGluZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBmbiQyWydyZW5kZXJlZCcgKyBvcHRzLnVwcGVyY2FzZU5hbWVdID0gZnVuY3Rpb24gcmVuZGVyZWREaW1JbXBsKCkge1xuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICAgIGlmIChlbGUpIHtcbiAgICAgICAgdmFyIGQgPSBlbGVbb3B0cy5uYW1lXSgpO1xuICAgICAgICByZXR1cm4gZCAqIHRoaXMuY3koKS56b29tKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZuJDJbJ3JlbmRlcmVkJyArIG9wdHMudXBwZXJjYXNlT3V0ZXJOYW1lXSA9IGZ1bmN0aW9uIHJlbmRlcmVkT3V0ZXJEaW1JbXBsKCkge1xuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICAgIGlmIChlbGUpIHtcbiAgICAgICAgdmFyIG9kID0gZWxlW29wdHMub3V0ZXJOYW1lXSgpO1xuICAgICAgICByZXR1cm4gb2QgKiB0aGlzLmN5KCkuem9vbSgpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgZGVmaW5lRGltRm5zKHtcbiAgICBuYW1lOiAnd2lkdGgnXG4gIH0pO1xuICBkZWZpbmVEaW1GbnMoe1xuICAgIG5hbWU6ICdoZWlnaHQnXG4gIH0pO1xuXG4gIGVsZXNmbiRhLnBhZGRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuXG4gICAgaWYgKGVsZS5pc1BhcmVudCgpKSB7XG4gICAgICBlbGUudXBkYXRlQ29tcG91bmRCb3VuZHMoKTtcblxuICAgICAgaWYgKF9wLmF1dG9QYWRkaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIF9wLmF1dG9QYWRkaW5nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGVsZS5wc3R5bGUoJ3BhZGRpbmcnKS5wZlZhbHVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZWxlLnBzdHlsZSgncGFkZGluZycpLnBmVmFsdWU7XG4gICAgfVxuICB9O1xuXG4gIGVsZXNmbiRhLnBhZGRlZEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICByZXR1cm4gZWxlLmhlaWdodCgpICsgMiAqIGVsZS5wYWRkaW5nKCk7XG4gIH07XG5cbiAgZWxlc2ZuJGEucGFkZGVkV2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgcmV0dXJuIGVsZS53aWR0aCgpICsgMiAqIGVsZS5wYWRkaW5nKCk7XG4gIH07XG5cbiAgdmFyIHdpZHRoSGVpZ2h0ID0gZWxlc2ZuJGE7XG5cbiAgdmFyIGlmRWRnZSA9IGZ1bmN0aW9uIGlmRWRnZShlbGUsIGdldFZhbHVlKSB7XG4gICAgaWYgKGVsZS5pc0VkZ2UoKSkge1xuICAgICAgcmV0dXJuIGdldFZhbHVlKGVsZSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBpZkVkZ2VSZW5kZXJlZFBvc2l0aW9uID0gZnVuY3Rpb24gaWZFZGdlUmVuZGVyZWRQb3NpdGlvbihlbGUsIGdldFBvaW50KSB7XG4gICAgaWYgKGVsZS5pc0VkZ2UoKSkge1xuICAgICAgdmFyIGN5ID0gZWxlLmN5KCk7XG4gICAgICByZXR1cm4gbW9kZWxUb1JlbmRlcmVkUG9zaXRpb24oZ2V0UG9pbnQoZWxlKSwgY3kuem9vbSgpLCBjeS5wYW4oKSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBpZkVkZ2VSZW5kZXJlZFBvc2l0aW9ucyA9IGZ1bmN0aW9uIGlmRWRnZVJlbmRlcmVkUG9zaXRpb25zKGVsZSwgZ2V0UG9pbnRzKSB7XG4gICAgaWYgKGVsZS5pc0VkZ2UoKSkge1xuICAgICAgdmFyIGN5ID0gZWxlLmN5KCk7XG4gICAgICB2YXIgcGFuID0gY3kucGFuKCk7XG4gICAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcbiAgICAgIHJldHVybiBnZXRQb2ludHMoZWxlKS5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcmV0dXJuIG1vZGVsVG9SZW5kZXJlZFBvc2l0aW9uKHAsIHpvb20sIHBhbik7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGNvbnRyb2xQb2ludHMgPSBmdW5jdGlvbiBjb250cm9sUG9pbnRzKGVsZSkge1xuICAgIHJldHVybiBlbGUucmVuZGVyZXIoKS5nZXRDb250cm9sUG9pbnRzKGVsZSk7XG4gIH07XG5cbiAgdmFyIHNlZ21lbnRQb2ludHMgPSBmdW5jdGlvbiBzZWdtZW50UG9pbnRzKGVsZSkge1xuICAgIHJldHVybiBlbGUucmVuZGVyZXIoKS5nZXRTZWdtZW50UG9pbnRzKGVsZSk7XG4gIH07XG5cbiAgdmFyIHNvdXJjZUVuZHBvaW50ID0gZnVuY3Rpb24gc291cmNlRW5kcG9pbnQoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5yZW5kZXJlcigpLmdldFNvdXJjZUVuZHBvaW50KGVsZSk7XG4gIH07XG5cbiAgdmFyIHRhcmdldEVuZHBvaW50ID0gZnVuY3Rpb24gdGFyZ2V0RW5kcG9pbnQoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5yZW5kZXJlcigpLmdldFRhcmdldEVuZHBvaW50KGVsZSk7XG4gIH07XG5cbiAgdmFyIG1pZHBvaW50ID0gZnVuY3Rpb24gbWlkcG9pbnQoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5yZW5kZXJlcigpLmdldEVkZ2VNaWRwb2ludChlbGUpO1xuICB9O1xuXG4gIHZhciBwdHMgPSB7XG4gICAgY29udHJvbFBvaW50czoge1xuICAgICAgZ2V0OiBjb250cm9sUG9pbnRzLFxuICAgICAgbXVsdDogdHJ1ZVxuICAgIH0sXG4gICAgc2VnbWVudFBvaW50czoge1xuICAgICAgZ2V0OiBzZWdtZW50UG9pbnRzLFxuICAgICAgbXVsdDogdHJ1ZVxuICAgIH0sXG4gICAgc291cmNlRW5kcG9pbnQ6IHtcbiAgICAgIGdldDogc291cmNlRW5kcG9pbnRcbiAgICB9LFxuICAgIHRhcmdldEVuZHBvaW50OiB7XG4gICAgICBnZXQ6IHRhcmdldEVuZHBvaW50XG4gICAgfSxcbiAgICBtaWRwb2ludDoge1xuICAgICAgZ2V0OiBtaWRwb2ludFxuICAgIH1cbiAgfTtcblxuICB2YXIgcmVuZGVyZWROYW1lID0gZnVuY3Rpb24gcmVuZGVyZWROYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gJ3JlbmRlcmVkJyArIG5hbWVbMF0udG9VcHBlckNhc2UoKSArIG5hbWUuc3Vic3RyKDEpO1xuICB9O1xuXG4gIHZhciBlZGdlUG9pbnRzID0gT2JqZWN0LmtleXMocHRzKS5yZWR1Y2UoZnVuY3Rpb24gKG9iaiwgbmFtZSkge1xuICAgIHZhciBzcGVjID0gcHRzW25hbWVdO1xuICAgIHZhciByTmFtZSA9IHJlbmRlcmVkTmFtZShuYW1lKTtcblxuICAgIG9ialtuYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBpZkVkZ2UodGhpcywgc3BlYy5nZXQpO1xuICAgIH07XG5cbiAgICBpZiAoc3BlYy5tdWx0KSB7XG4gICAgICBvYmpbck5hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gaWZFZGdlUmVuZGVyZWRQb3NpdGlvbnModGhpcywgc3BlYy5nZXQpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW3JOYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGlmRWRnZVJlbmRlcmVkUG9zaXRpb24odGhpcywgc3BlYy5nZXQpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xuICB9LCB7fSk7XG5cbiAgdmFyIGRpbWVuc2lvbnMgPSBleHRlbmQoe30sIHBvc2l0aW9uLCBib3VuZHMsIHdpZHRoSGVpZ2h0LCBlZGdlUG9pbnRzKTtcblxuICAvKiFcbiAgRXZlbnQgb2JqZWN0IGJhc2VkIG9uIGpRdWVyeSBldmVudHMsIE1JVCBsaWNlbnNlXG5cbiAgaHR0cHM6Ly9qcXVlcnkub3JnL2xpY2Vuc2UvXG4gIGh0dHBzOi8vdGxkcmxlZ2FsLmNvbS9saWNlbnNlL21pdC1saWNlbnNlXG4gIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L2Jsb2IvbWFzdGVyL3NyYy9ldmVudC5qc1xuICAqL1xuICB2YXIgRXZlbnQgPSBmdW5jdGlvbiBFdmVudChzcmMsIHByb3BzKSB7XG4gICAgdGhpcy5yZWN5Y2xlKHNyYywgcHJvcHMpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHJldHVybkZhbHNlKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJldHVyblRydWUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAwMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwMzAzMzEvZWNtYS1zY3JpcHQtYmluZGluZy5odG1sXG5cblxuICBFdmVudC5wcm90b3R5cGUgPSB7XG4gICAgaW5zdGFuY2VTdHJpbmc6IGZ1bmN0aW9uIGluc3RhbmNlU3RyaW5nKCkge1xuICAgICAgcmV0dXJuICdldmVudCc7XG4gICAgfSxcbiAgICByZWN5Y2xlOiBmdW5jdGlvbiByZWN5Y2xlKHNyYywgcHJvcHMpIHtcbiAgICAgIHRoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSByZXR1cm5GYWxzZTtcblxuICAgICAgaWYgKHNyYyAhPSBudWxsICYmIHNyYy5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAvLyBCcm93c2VyIEV2ZW50IG9iamVjdFxuICAgICAgICB0aGlzLnR5cGUgPSBzcmMudHlwZTsgLy8gRXZlbnRzIGJ1YmJsaW5nIHVwIHRoZSBkb2N1bWVudCBtYXkgaGF2ZSBiZWVuIG1hcmtlZCBhcyBwcmV2ZW50ZWRcbiAgICAgICAgLy8gYnkgYSBoYW5kbGVyIGxvd2VyIGRvd24gdGhlIHRyZWU7IHJlZmxlY3QgdGhlIGNvcnJlY3QgdmFsdWUuXG5cbiAgICAgICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBzcmMuZGVmYXVsdFByZXZlbnRlZCA/IHJldHVyblRydWUgOiByZXR1cm5GYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoc3JjICE9IG51bGwgJiYgc3JjLnR5cGUpIHtcbiAgICAgICAgLy8gUGxhaW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIGV2ZW50IGRldGFpbHNcbiAgICAgICAgcHJvcHMgPSBzcmM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBFdmVudCBzdHJpbmdcbiAgICAgICAgdGhpcy50eXBlID0gc3JjO1xuICAgICAgfSAvLyBQdXQgZXhwbGljaXRseSBwcm92aWRlZCBwcm9wZXJ0aWVzIG9udG8gdGhlIGV2ZW50IG9iamVjdFxuXG5cbiAgICAgIGlmIChwcm9wcyAhPSBudWxsKSB7XG4gICAgICAgIC8vIG1vcmUgZWZmaWNpZW50IHRvIG1hbnVhbGx5IGNvcHkgZmllbGRzIHdlIHVzZVxuICAgICAgICB0aGlzLm9yaWdpbmFsRXZlbnQgPSBwcm9wcy5vcmlnaW5hbEV2ZW50O1xuICAgICAgICB0aGlzLnR5cGUgPSBwcm9wcy50eXBlICE9IG51bGwgPyBwcm9wcy50eXBlIDogdGhpcy50eXBlO1xuICAgICAgICB0aGlzLmN5ID0gcHJvcHMuY3k7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gcHJvcHMudGFyZ2V0O1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gcHJvcHMucG9zaXRpb247XG4gICAgICAgIHRoaXMucmVuZGVyZWRQb3NpdGlvbiA9IHByb3BzLnJlbmRlcmVkUG9zaXRpb247XG4gICAgICAgIHRoaXMubmFtZXNwYWNlID0gcHJvcHMubmFtZXNwYWNlO1xuICAgICAgICB0aGlzLmxheW91dCA9IHByb3BzLmxheW91dDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuY3kgIT0gbnVsbCAmJiB0aGlzLnBvc2l0aW9uICE9IG51bGwgJiYgdGhpcy5yZW5kZXJlZFBvc2l0aW9uID09IG51bGwpIHtcbiAgICAgICAgLy8gY3JlYXRlIGEgcmVuZGVyZWQgcG9zaXRpb24gYmFzZWQgb24gdGhlIHBhc3NlZCBwb3NpdGlvblxuICAgICAgICB2YXIgcG9zID0gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgdmFyIHpvb20gPSB0aGlzLmN5Lnpvb20oKTtcbiAgICAgICAgdmFyIHBhbiA9IHRoaXMuY3kucGFuKCk7XG4gICAgICAgIHRoaXMucmVuZGVyZWRQb3NpdGlvbiA9IHtcbiAgICAgICAgICB4OiBwb3MueCAqIHpvb20gKyBwYW4ueCxcbiAgICAgICAgICB5OiBwb3MueSAqIHpvb20gKyBwYW4ueVxuICAgICAgICB9O1xuICAgICAgfSAvLyBDcmVhdGUgYSB0aW1lc3RhbXAgaWYgaW5jb21pbmcgZXZlbnQgZG9lc24ndCBoYXZlIG9uZVxuXG5cbiAgICAgIHRoaXMudGltZVN0YW1wID0gc3JjICYmIHNyYy50aW1lU3RhbXAgfHwgRGF0ZS5ub3coKTtcbiAgICB9LFxuICAgIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdCgpIHtcbiAgICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gcmV0dXJuVHJ1ZTtcbiAgICAgIHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG4gICAgICBpZiAoIWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBpZiBwcmV2ZW50RGVmYXVsdCBleGlzdHMgcnVuIGl0IG9uIHRoZSBvcmlnaW5hbCBldmVudFxuXG5cbiAgICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uKCkge1xuICAgICAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG4gICAgICB2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuICAgICAgaWYgKCFlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gaWYgc3RvcFByb3BhZ2F0aW9uIGV4aXN0cyBydW4gaXQgb24gdGhlIG9yaWdpbmFsIGV2ZW50XG5cblxuICAgICAgaWYgKGUuc3RvcFByb3BhZ2F0aW9uKSB7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpIHtcbiAgICAgIHRoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuICAgICAgdGhpcy5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9LFxuICAgIGlzRGVmYXVsdFByZXZlbnRlZDogcmV0dXJuRmFsc2UsXG4gICAgaXNQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuICAgIGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZVxuICB9O1xuXG4gIHZhciBldmVudFJlZ2V4ID0gL14oW14uXSspKFxcLig/OlteLl0rKSk/JC87IC8vIHJlZ2V4IGZvciBtYXRjaGluZyBldmVudCBzdHJpbmdzIChlLmcuIFwiY2xpY2submFtZXNwYWNlXCIpXG5cbiAgdmFyIHVuaXZlcnNhbE5hbWVzcGFjZSA9ICcuKic7IC8vIG1hdGNoZXMgYXMgaWYgbm8gbmFtZXNwYWNlIHNwZWNpZmllZCBhbmQgcHJldmVudHMgdXNlcnMgZnJvbSB1bmJpbmRpbmcgYWNjaWRlbnRhbGx5XG5cbiAgdmFyIGRlZmF1bHRzJDggPSB7XG4gICAgcXVhbGlmaWVyQ29tcGFyZTogZnVuY3Rpb24gcXVhbGlmaWVyQ29tcGFyZShxMSwgcTIpIHtcbiAgICAgIHJldHVybiBxMSA9PT0gcTI7XG4gICAgfSxcbiAgICBldmVudE1hdGNoZXM6IGZ1bmN0aW9uXG4gICAgICAvKmNvbnRleHQsIGxpc3RlbmVyLCBldmVudE9iaiovXG4gICAgZXZlbnRNYXRjaGVzKCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBhZGRFdmVudEZpZWxkczogZnVuY3Rpb25cbiAgICAgIC8qY29udGV4dCwgZXZ0Ki9cbiAgICBhZGRFdmVudEZpZWxkcygpIHt9LFxuICAgIGNhbGxiYWNrQ29udGV4dDogZnVuY3Rpb24gY2FsbGJhY2tDb250ZXh0KGNvbnRleHRcbiAgICAvKiwgbGlzdGVuZXIsIGV2ZW50T2JqKi9cbiAgICApIHtcbiAgICAgIHJldHVybiBjb250ZXh0O1xuICAgIH0sXG4gICAgYmVmb3JlRW1pdDogZnVuY3Rpb25cbiAgICAgIC8qIGNvbnRleHQsIGxpc3RlbmVyLCBldmVudE9iaiAqL1xuICAgIGJlZm9yZUVtaXQoKSB7fSxcbiAgICBhZnRlckVtaXQ6IGZ1bmN0aW9uXG4gICAgICAvKiBjb250ZXh0LCBsaXN0ZW5lciwgZXZlbnRPYmogKi9cbiAgICBhZnRlckVtaXQoKSB7fSxcbiAgICBidWJibGU6IGZ1bmN0aW9uXG4gICAgICAvKmNvbnRleHQqL1xuICAgIGJ1YmJsZSgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIHBhcmVudDogZnVuY3Rpb25cbiAgICAgIC8qY29udGV4dCovXG4gICAgcGFyZW50KCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBjb250ZXh0OiBudWxsXG4gIH07XG4gIHZhciBkZWZhdWx0c0tleXMgPSBPYmplY3Qua2V5cyhkZWZhdWx0cyQ4KTtcbiAgdmFyIGVtcHR5T3B0cyA9IHt9O1xuXG4gIGZ1bmN0aW9uIEVtaXR0ZXIoKSB7XG4gICAgdmFyIG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGVtcHR5T3B0cztcbiAgICB2YXIgY29udGV4dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuXG4gICAgLy8gbWljcm8tb3B0aW1pc2F0aW9uIHZzIE9iamVjdC5hc3NpZ24oKSAtLSByZWR1Y2VzIEVsZW1lbnQgaW5zdGFudGlhdGlvbiB0aW1lXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWZhdWx0c0tleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBkZWZhdWx0c0tleXNbaV07XG4gICAgICB0aGlzW2tleV0gPSBvcHRzW2tleV0gfHwgZGVmYXVsdHMkOFtrZXldO1xuICAgIH1cblxuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQgfHwgdGhpcy5jb250ZXh0O1xuICAgIHRoaXMubGlzdGVuZXJzID0gW107XG4gICAgdGhpcy5lbWl0dGluZyA9IDA7XG4gIH1cblxuICB2YXIgcCA9IEVtaXR0ZXIucHJvdG90eXBlO1xuXG4gIHZhciBmb3JFYWNoRXZlbnQgPSBmdW5jdGlvbiBmb3JFYWNoRXZlbnQoc2VsZiwgaGFuZGxlciwgZXZlbnRzLCBxdWFsaWZpZXIsIGNhbGxiYWNrLCBjb25mLCBjb25mT3ZlcnJpZGVzKSB7XG4gICAgaWYgKGZuJDYocXVhbGlmaWVyKSkge1xuICAgICAgY2FsbGJhY2sgPSBxdWFsaWZpZXI7XG4gICAgICBxdWFsaWZpZXIgPSBudWxsO1xuICAgIH1cblxuICAgIGlmIChjb25mT3ZlcnJpZGVzKSB7XG4gICAgICBpZiAoY29uZiA9PSBudWxsKSB7XG4gICAgICAgIGNvbmYgPSBjb25mT3ZlcnJpZGVzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uZiA9IGV4dGVuZCh7fSwgY29uZiwgY29uZk92ZXJyaWRlcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGV2ZW50TGlzdCA9IGFycmF5KGV2ZW50cykgPyBldmVudHMgOiBldmVudHMuc3BsaXQoL1xccysvKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnRMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZXZ0ID0gZXZlbnRMaXN0W2ldO1xuXG4gICAgICBpZiAoZW1wdHlTdHJpbmcoZXZ0KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIG1hdGNoID0gZXZ0Lm1hdGNoKGV2ZW50UmVnZXgpOyAvLyB0eXBlWy5uYW1lc3BhY2VdXG5cbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICB2YXIgdHlwZSA9IG1hdGNoWzFdO1xuICAgICAgICB2YXIgbmFtZXNwYWNlID0gbWF0Y2hbMl0gPyBtYXRjaFsyXSA6IG51bGw7XG4gICAgICAgIHZhciByZXQgPSBoYW5kbGVyKHNlbGYsIGV2dCwgdHlwZSwgbmFtZXNwYWNlLCBxdWFsaWZpZXIsIGNhbGxiYWNrLCBjb25mKTtcblxuICAgICAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IC8vIGFsbG93IGV4aXRpbmcgZWFybHlcblxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgbWFrZUV2ZW50T2JqID0gZnVuY3Rpb24gbWFrZUV2ZW50T2JqKHNlbGYsIG9iaikge1xuICAgIHNlbGYuYWRkRXZlbnRGaWVsZHMoc2VsZi5jb250ZXh0LCBvYmopO1xuICAgIHJldHVybiBuZXcgRXZlbnQob2JqLnR5cGUsIG9iaik7XG4gIH07XG5cbiAgdmFyIGZvckVhY2hFdmVudE9iaiA9IGZ1bmN0aW9uIGZvckVhY2hFdmVudE9iaihzZWxmLCBoYW5kbGVyLCBldmVudHMpIHtcbiAgICBpZiAoZXZlbnQoZXZlbnRzKSkge1xuICAgICAgaGFuZGxlcihzZWxmLCBldmVudHMpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAocGxhaW5PYmplY3QoZXZlbnRzKSkge1xuICAgICAgaGFuZGxlcihzZWxmLCBtYWtlRXZlbnRPYmooc2VsZiwgZXZlbnRzKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGV2ZW50TGlzdCA9IGFycmF5KGV2ZW50cykgPyBldmVudHMgOiBldmVudHMuc3BsaXQoL1xccysvKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnRMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZXZ0ID0gZXZlbnRMaXN0W2ldO1xuXG4gICAgICBpZiAoZW1wdHlTdHJpbmcoZXZ0KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIG1hdGNoID0gZXZ0Lm1hdGNoKGV2ZW50UmVnZXgpOyAvLyB0eXBlWy5uYW1lc3BhY2VdXG5cbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICB2YXIgdHlwZSA9IG1hdGNoWzFdO1xuICAgICAgICB2YXIgbmFtZXNwYWNlID0gbWF0Y2hbMl0gPyBtYXRjaFsyXSA6IG51bGw7XG4gICAgICAgIHZhciBldmVudE9iaiA9IG1ha2VFdmVudE9iaihzZWxmLCB7XG4gICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICBuYW1lc3BhY2U6IG5hbWVzcGFjZSxcbiAgICAgICAgICB0YXJnZXQ6IHNlbGYuY29udGV4dFxuICAgICAgICB9KTtcbiAgICAgICAgaGFuZGxlcihzZWxmLCBldmVudE9iaik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHAub24gPSBwLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50cywgcXVhbGlmaWVyLCBjYWxsYmFjaywgY29uZiwgY29uZk92ZXJyaWRlcykge1xuICAgIGZvckVhY2hFdmVudCh0aGlzLCBmdW5jdGlvbiAoc2VsZiwgZXZlbnQsIHR5cGUsIG5hbWVzcGFjZSwgcXVhbGlmaWVyLCBjYWxsYmFjaywgY29uZikge1xuICAgICAgaWYgKGZuJDYoY2FsbGJhY2spKSB7XG4gICAgICAgIHNlbGYubGlzdGVuZXJzLnB1c2goe1xuICAgICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgICAvLyBmdWxsIGV2ZW50IHN0cmluZ1xuICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgICAvLyBjYWxsYmFjayB0byBydW5cbiAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgIC8vIHRoZSBldmVudCB0eXBlIChlLmcuICdjbGljaycpXG4gICAgICAgICAgbmFtZXNwYWNlOiBuYW1lc3BhY2UsXG4gICAgICAgICAgLy8gdGhlIGV2ZW50IG5hbWVzcGFjZSAoZS5nLiBcIi5mb29cIilcbiAgICAgICAgICBxdWFsaWZpZXI6IHF1YWxpZmllcixcbiAgICAgICAgICAvLyBhIHJlc3RyaWN0aW9uIG9uIHdoZXRoZXIgdG8gbWF0Y2ggdGhpcyBlbWl0dGVyXG4gICAgICAgICAgY29uZjogY29uZiAvLyBhZGRpdGlvbmFsIGNvbmZpZ3VyYXRpb25cblxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCBldmVudHMsIHF1YWxpZmllciwgY2FsbGJhY2ssIGNvbmYsIGNvbmZPdmVycmlkZXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHAub25lID0gZnVuY3Rpb24gKGV2ZW50cywgcXVhbGlmaWVyLCBjYWxsYmFjaywgY29uZikge1xuICAgIHJldHVybiB0aGlzLm9uKGV2ZW50cywgcXVhbGlmaWVyLCBjYWxsYmFjaywgY29uZiwge1xuICAgICAgb25lOiB0cnVlXG4gICAgfSk7XG4gIH07XG5cbiAgcC5yZW1vdmVMaXN0ZW5lciA9IHAub2ZmID0gZnVuY3Rpb24gKGV2ZW50cywgcXVhbGlmaWVyLCBjYWxsYmFjaywgY29uZikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy5lbWl0dGluZyAhPT0gMCkge1xuICAgICAgdGhpcy5saXN0ZW5lcnMgPSBjb3B5QXJyYXkkMSh0aGlzLmxpc3RlbmVycyk7XG4gICAgfVxuXG4gICAgdmFyIGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzO1xuXG4gICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoaSkge1xuICAgICAgdmFyIGxpc3RlbmVyID0gbGlzdGVuZXJzW2ldO1xuICAgICAgZm9yRWFjaEV2ZW50KF90aGlzLCBmdW5jdGlvbiAoc2VsZiwgZXZlbnQsIHR5cGUsIG5hbWVzcGFjZSwgcXVhbGlmaWVyLCBjYWxsYmFja1xuICAgICAgLyosIGNvbmYqL1xuICAgICAgKSB7XG4gICAgICAgIGlmICgobGlzdGVuZXIudHlwZSA9PT0gdHlwZSB8fCBldmVudHMgPT09ICcqJykgJiYgKCFuYW1lc3BhY2UgJiYgbGlzdGVuZXIubmFtZXNwYWNlICE9PSAnLionIHx8IGxpc3RlbmVyLm5hbWVzcGFjZSA9PT0gbmFtZXNwYWNlKSAmJiAoIXF1YWxpZmllciB8fCBzZWxmLnF1YWxpZmllckNvbXBhcmUobGlzdGVuZXIucXVhbGlmaWVyLCBxdWFsaWZpZXIpKSAmJiAoIWNhbGxiYWNrIHx8IGxpc3RlbmVyLmNhbGxiYWNrID09PSBjYWxsYmFjaykpIHtcbiAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSwgZXZlbnRzLCBxdWFsaWZpZXIsIGNhbGxiYWNrLCBjb25mKTtcbiAgICB9O1xuXG4gICAgZm9yICh2YXIgaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgX2xvb3AoaSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgcC5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVtb3ZlTGlzdGVuZXIoJyonKTtcbiAgfTtcblxuICBwLmVtaXQgPSBwLnRyaWdnZXIgPSBmdW5jdGlvbiAoZXZlbnRzLCBleHRyYVBhcmFtcywgbWFudWFsQ2FsbGJhY2spIHtcbiAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnM7XG4gICAgdmFyIG51bUxpc3RlbmVyc0JlZm9yZUVtaXQgPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgIHRoaXMuZW1pdHRpbmcrKztcblxuICAgIGlmICghYXJyYXkoZXh0cmFQYXJhbXMpKSB7XG4gICAgICBleHRyYVBhcmFtcyA9IFtleHRyYVBhcmFtc107XG4gICAgfVxuXG4gICAgZm9yRWFjaEV2ZW50T2JqKHRoaXMsIGZ1bmN0aW9uIChzZWxmLCBldmVudE9iaikge1xuICAgICAgaWYgKG1hbnVhbENhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgICAgbGlzdGVuZXJzID0gW3tcbiAgICAgICAgICBldmVudDogZXZlbnRPYmouZXZlbnQsXG4gICAgICAgICAgdHlwZTogZXZlbnRPYmoudHlwZSxcbiAgICAgICAgICBuYW1lc3BhY2U6IGV2ZW50T2JqLm5hbWVzcGFjZSxcbiAgICAgICAgICBjYWxsYmFjazogbWFudWFsQ2FsbGJhY2tcbiAgICAgICAgfV07XG4gICAgICAgIG51bUxpc3RlbmVyc0JlZm9yZUVtaXQgPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICB2YXIgX2xvb3AyID0gZnVuY3Rpb24gX2xvb3AyKGkpIHtcbiAgICAgICAgdmFyIGxpc3RlbmVyID0gbGlzdGVuZXJzW2ldO1xuXG4gICAgICAgIGlmIChsaXN0ZW5lci50eXBlID09PSBldmVudE9iai50eXBlICYmICghbGlzdGVuZXIubmFtZXNwYWNlIHx8IGxpc3RlbmVyLm5hbWVzcGFjZSA9PT0gZXZlbnRPYmoubmFtZXNwYWNlIHx8IGxpc3RlbmVyLm5hbWVzcGFjZSA9PT0gdW5pdmVyc2FsTmFtZXNwYWNlKSAmJiBzZWxmLmV2ZW50TWF0Y2hlcyhzZWxmLmNvbnRleHQsIGxpc3RlbmVyLCBldmVudE9iaikpIHtcbiAgICAgICAgICB2YXIgYXJncyA9IFtldmVudE9ial07XG5cbiAgICAgICAgICBpZiAoZXh0cmFQYXJhbXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgcHVzaChhcmdzLCBleHRyYVBhcmFtcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2VsZi5iZWZvcmVFbWl0KHNlbGYuY29udGV4dCwgbGlzdGVuZXIsIGV2ZW50T2JqKTtcblxuICAgICAgICAgIGlmIChsaXN0ZW5lci5jb25mICYmIGxpc3RlbmVyLmNvbmYub25lKSB7XG4gICAgICAgICAgICBzZWxmLmxpc3RlbmVycyA9IHNlbGYubGlzdGVuZXJzLmZpbHRlcihmdW5jdGlvbiAobCkge1xuICAgICAgICAgICAgICByZXR1cm4gbCAhPT0gbGlzdGVuZXI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgY29udGV4dCA9IHNlbGYuY2FsbGJhY2tDb250ZXh0KHNlbGYuY29udGV4dCwgbGlzdGVuZXIsIGV2ZW50T2JqKTtcbiAgICAgICAgICB2YXIgcmV0ID0gbGlzdGVuZXIuY2FsbGJhY2suYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgc2VsZi5hZnRlckVtaXQoc2VsZi5jb250ZXh0LCBsaXN0ZW5lciwgZXZlbnRPYmopO1xuXG4gICAgICAgICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGV2ZW50T2JqLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgZXZlbnRPYmoucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gaWYgbGlzdGVuZXIgbWF0Y2hlc1xuXG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUxpc3RlbmVyc0JlZm9yZUVtaXQ7IGkrKykge1xuICAgICAgICBfbG9vcDIoaSk7XG4gICAgICB9IC8vIGZvciBsaXN0ZW5lclxuXG5cbiAgICAgIGlmIChzZWxmLmJ1YmJsZShzZWxmLmNvbnRleHQpICYmICFldmVudE9iai5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XG4gICAgICAgIHNlbGYucGFyZW50KHNlbGYuY29udGV4dCkuZW1pdChldmVudE9iaiwgZXh0cmFQYXJhbXMpO1xuICAgICAgfVxuICAgIH0sIGV2ZW50cyk7XG4gICAgdGhpcy5lbWl0dGluZy0tO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHZhciBlbWl0dGVyT3B0aW9ucyQxID0ge1xuICAgIHF1YWxpZmllckNvbXBhcmU6IGZ1bmN0aW9uIHF1YWxpZmllckNvbXBhcmUoc2VsZWN0b3IxLCBzZWxlY3RvcjIpIHtcbiAgICAgIGlmIChzZWxlY3RvcjEgPT0gbnVsbCB8fCBzZWxlY3RvcjIgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc2VsZWN0b3IxID09IG51bGwgJiYgc2VsZWN0b3IyID09IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc2VsZWN0b3IxLnNhbWVUZXh0KHNlbGVjdG9yMik7XG4gICAgICB9XG4gICAgfSxcbiAgICBldmVudE1hdGNoZXM6IGZ1bmN0aW9uIGV2ZW50TWF0Y2hlcyhlbGUsIGxpc3RlbmVyLCBldmVudE9iaikge1xuICAgICAgdmFyIHNlbGVjdG9yID0gbGlzdGVuZXIucXVhbGlmaWVyO1xuXG4gICAgICBpZiAoc2VsZWN0b3IgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZWxlICE9PSBldmVudE9iai50YXJnZXQgJiYgZWxlbWVudChldmVudE9iai50YXJnZXQpICYmIHNlbGVjdG9yLm1hdGNoZXMoZXZlbnRPYmoudGFyZ2V0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBhZGRFdmVudEZpZWxkczogZnVuY3Rpb24gYWRkRXZlbnRGaWVsZHMoZWxlLCBldnQpIHtcbiAgICAgIGV2dC5jeSA9IGVsZS5jeSgpO1xuICAgICAgZXZ0LnRhcmdldCA9IGVsZTtcbiAgICB9LFxuICAgIGNhbGxiYWNrQ29udGV4dDogZnVuY3Rpb24gY2FsbGJhY2tDb250ZXh0KGVsZSwgbGlzdGVuZXIsIGV2ZW50T2JqKSB7XG4gICAgICByZXR1cm4gbGlzdGVuZXIucXVhbGlmaWVyICE9IG51bGwgPyBldmVudE9iai50YXJnZXQgOiBlbGU7XG4gICAgfSxcbiAgICBiZWZvcmVFbWl0OiBmdW5jdGlvbiBiZWZvcmVFbWl0KGNvbnRleHQsIGxpc3RlbmVyXG4gICAgLyosIGV2ZW50T2JqKi9cbiAgICApIHtcbiAgICAgIGlmIChsaXN0ZW5lci5jb25mICYmIGxpc3RlbmVyLmNvbmYub25jZSkge1xuICAgICAgICBsaXN0ZW5lci5jb25mLm9uY2VDb2xsZWN0aW9uLnJlbW92ZUxpc3RlbmVyKGxpc3RlbmVyLmV2ZW50LCBsaXN0ZW5lci5xdWFsaWZpZXIsIGxpc3RlbmVyLmNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGJ1YmJsZTogZnVuY3Rpb24gYnViYmxlKCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBwYXJlbnQ6IGZ1bmN0aW9uIHBhcmVudChlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuaXNDaGlsZCgpID8gZWxlLnBhcmVudCgpIDogZWxlLmN5KCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBhcmdTZWxlY3RvciQxID0gZnVuY3Rpb24gYXJnU2VsZWN0b3IoYXJnKSB7XG4gICAgaWYgKHN0cmluZyhhcmcpKSB7XG4gICAgICByZXR1cm4gbmV3IFNlbGVjdG9yKGFyZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhcmc7XG4gICAgfVxuICB9O1xuXG4gIHZhciBlbGVzZm4kOSA9IHtcbiAgICBjcmVhdGVFbWl0dGVyOiBmdW5jdGlvbiBjcmVhdGVFbWl0dGVyKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG5cbiAgICAgICAgaWYgKCFfcC5lbWl0dGVyKSB7XG4gICAgICAgICAgX3AuZW1pdHRlciA9IG5ldyBFbWl0dGVyKGVtaXR0ZXJPcHRpb25zJDEsIGVsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBlbWl0dGVyOiBmdW5jdGlvbiBlbWl0dGVyKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuZW1pdHRlcjtcbiAgICB9LFxuICAgIG9uOiBmdW5jdGlvbiBvbihldmVudHMsIHNlbGVjdG9yLCBjYWxsYmFjaykge1xuICAgICAgdmFyIGFyZ1NlbCA9IGFyZ1NlbGVjdG9yJDEoc2VsZWN0b3IpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICAgIGVsZS5lbWl0dGVyKCkub24oZXZlbnRzLCBhcmdTZWwsIGNhbGxiYWNrKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICByZW1vdmVMaXN0ZW5lcjogZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoZXZlbnRzLCBzZWxlY3RvciwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBhcmdTZWwgPSBhcmdTZWxlY3RvciQxKHNlbGVjdG9yKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgICBlbGUuZW1pdHRlcigpLnJlbW92ZUxpc3RlbmVyKGV2ZW50cywgYXJnU2VsLCBjYWxsYmFjayk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgcmVtb3ZlQWxsTGlzdGVuZXJzOiBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnMoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICAgIGVsZS5lbWl0dGVyKCkucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgb25lOiBmdW5jdGlvbiBvbmUoZXZlbnRzLCBzZWxlY3RvciwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBhcmdTZWwgPSBhcmdTZWxlY3RvciQxKHNlbGVjdG9yKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgICBlbGUuZW1pdHRlcigpLm9uZShldmVudHMsIGFyZ1NlbCwgY2FsbGJhY2spO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIG9uY2U6IGZ1bmN0aW9uIG9uY2UoZXZlbnRzLCBzZWxlY3RvciwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBhcmdTZWwgPSBhcmdTZWxlY3RvciQxKHNlbGVjdG9yKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgICBlbGUuZW1pdHRlcigpLm9uKGV2ZW50cywgYXJnU2VsLCBjYWxsYmFjaywge1xuICAgICAgICAgIG9uY2U6IHRydWUsXG4gICAgICAgICAgb25jZUNvbGxlY3Rpb246IHRoaXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBlbWl0OiBmdW5jdGlvbiBlbWl0KGV2ZW50cywgZXh0cmFQYXJhbXMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgICAgZWxlLmVtaXR0ZXIoKS5lbWl0KGV2ZW50cywgZXh0cmFQYXJhbXMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGVtaXRBbmROb3RpZnk6IGZ1bmN0aW9uIGVtaXRBbmROb3RpZnkoZXZlbnQsIGV4dHJhUGFyYW1zKSB7XG4gICAgICAvLyBmb3IgaW50ZXJuYWwgdXNlIG9ubHlcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIGVtcHR5IGNvbGxlY3Rpb25zIGRvbid0IG5lZWQgdG8gbm90aWZ5IGFueXRoaW5nXG4gICAgICAvLyBub3RpZnkgcmVuZGVyZXJcblxuXG4gICAgICB0aGlzLmN5KCkubm90aWZ5KGV2ZW50LCB0aGlzKTtcbiAgICAgIHRoaXMuZW1pdChldmVudCwgZXh0cmFQYXJhbXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O1xuICBkZWZpbmUuZXZlbnRBbGlhc2VzT24oZWxlc2ZuJDkpO1xuXG4gIHZhciBlbGVzZm4kOCA9IHtcbiAgICBub2RlczogZnVuY3Rpb24gbm9kZXMoc2VsZWN0b3IpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgIHJldHVybiBlbGUuaXNOb2RlKCk7XG4gICAgICB9KS5maWx0ZXIoc2VsZWN0b3IpO1xuICAgIH0sXG4gICAgZWRnZXM6IGZ1bmN0aW9uIGVkZ2VzKHNlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICByZXR1cm4gZWxlLmlzRWRnZSgpO1xuICAgICAgfSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgICB9LFxuICAgIC8vIGludGVybmFsIGhlbHBlciB0byBnZXQgbm9kZXMgYW5kIGVkZ2VzIGFzIHNlcGFyYXRlIGNvbGxlY3Rpb25zIHdpdGggc2luZ2xlIGl0ZXJhdGlvbiBvdmVyIGVsZW1lbnRzXG4gICAgYnlHcm91cDogZnVuY3Rpb24gYnlHcm91cCgpIHtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMuc3Bhd24oKTtcbiAgICAgIHZhciBlZGdlcyA9IHRoaXMuc3Bhd24oKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuXG4gICAgICAgIGlmIChlbGUuaXNOb2RlKCkpIHtcbiAgICAgICAgICBub2Rlcy5wdXNoKGVsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWRnZXMucHVzaChlbGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5vZGVzOiBub2RlcyxcbiAgICAgICAgZWRnZXM6IGVkZ2VzXG4gICAgICB9O1xuICAgIH0sXG4gICAgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIoX2ZpbHRlciwgdGhpc0FyZykge1xuICAgICAgaWYgKF9maWx0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBjaGVjayB0aGlzIGZpcnN0IGIvYyBpdCdzIHRoZSBtb3N0IGNvbW1vbi9wZXJmb3JtYW50IGNhc2VcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9IGVsc2UgaWYgKHN0cmluZyhfZmlsdGVyKSB8fCBlbGVtZW50T3JDb2xsZWN0aW9uKF9maWx0ZXIpKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2VsZWN0b3IoX2ZpbHRlcikuZmlsdGVyKHRoaXMpO1xuICAgICAgfSBlbHNlIGlmIChmbiQ2KF9maWx0ZXIpKSB7XG4gICAgICAgIHZhciBmaWx0ZXJFbGVzID0gdGhpcy5zcGF3bigpO1xuICAgICAgICB2YXIgZWxlcyA9IHRoaXM7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICAgICAgdmFyIGluY2x1ZGUgPSB0aGlzQXJnID8gX2ZpbHRlci5hcHBseSh0aGlzQXJnLCBbZWxlLCBpLCBlbGVzXSkgOiBfZmlsdGVyKGVsZSwgaSwgZWxlcyk7XG5cbiAgICAgICAgICBpZiAoaW5jbHVkZSkge1xuICAgICAgICAgICAgZmlsdGVyRWxlcy5wdXNoKGVsZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZpbHRlckVsZXM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnNwYXduKCk7IC8vIGlmIG5vdCBoYW5kbGVkIGJ5IGFib3ZlLCBnaXZlICdlbSBhbiBlbXB0eSBjb2xsZWN0aW9uXG4gICAgfSxcbiAgICBub3Q6IGZ1bmN0aW9uIG5vdCh0b1JlbW92ZSkge1xuICAgICAgaWYgKCF0b1JlbW92ZSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChzdHJpbmcodG9SZW1vdmUpKSB7XG4gICAgICAgICAgdG9SZW1vdmUgPSB0aGlzLmZpbHRlcih0b1JlbW92ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLnNwYXduKCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzW2ldO1xuICAgICAgICAgIHZhciByZW1vdmUgPSB0b1JlbW92ZS5oYXMoZWxlbWVudCk7XG5cbiAgICAgICAgICBpZiAoIXJlbW92ZSkge1xuICAgICAgICAgICAgZWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZWxlbWVudHM7XG4gICAgICB9XG4gICAgfSxcbiAgICBhYnNvbHV0ZUNvbXBsZW1lbnQ6IGZ1bmN0aW9uIGFic29sdXRlQ29tcGxlbWVudCgpIHtcbiAgICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICAgIHJldHVybiBjeS5tdXRhYmxlRWxlbWVudHMoKS5ub3QodGhpcyk7XG4gICAgfSxcbiAgICBpbnRlcnNlY3Q6IGZ1bmN0aW9uIGludGVyc2VjdChvdGhlcikge1xuICAgICAgLy8gaWYgYSBzZWxlY3RvciBpcyBzcGVjaWZpZWQsIHRoZW4gZmlsdGVyIGJ5IGl0IGluc3RlYWRcbiAgICAgIGlmIChzdHJpbmcob3RoZXIpKSB7XG4gICAgICAgIHZhciBzZWxlY3RvciA9IG90aGVyO1xuICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXIoc2VsZWN0b3IpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLnNwYXduKCk7XG4gICAgICB2YXIgY29sMSA9IHRoaXM7XG4gICAgICB2YXIgY29sMiA9IG90aGVyO1xuICAgICAgdmFyIGNvbDFTbWFsbGVyID0gdGhpcy5sZW5ndGggPCBvdGhlci5sZW5ndGg7XG4gICAgICB2YXIgY29sUyA9IGNvbDFTbWFsbGVyID8gY29sMSA6IGNvbDI7XG4gICAgICB2YXIgY29sTCA9IGNvbDFTbWFsbGVyID8gY29sMiA6IGNvbDE7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sUy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gY29sU1tpXTtcblxuICAgICAgICBpZiAoY29sTC5oYXMoZWxlKSkge1xuICAgICAgICAgIGVsZW1lbnRzLnB1c2goZWxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZWxlbWVudHM7XG4gICAgfSxcbiAgICB4b3I6IGZ1bmN0aW9uIHhvcihvdGhlcikge1xuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcblxuICAgICAgaWYgKHN0cmluZyhvdGhlcikpIHtcbiAgICAgICAgb3RoZXIgPSBjeS4kKG90aGVyKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVsZW1lbnRzID0gdGhpcy5zcGF3bigpO1xuICAgICAgdmFyIGNvbDEgPSB0aGlzO1xuICAgICAgdmFyIGNvbDIgPSBvdGhlcjtcblxuICAgICAgdmFyIGFkZCA9IGZ1bmN0aW9uIGFkZChjb2wsIG90aGVyKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVsZSA9IGNvbFtpXTtcbiAgICAgICAgICB2YXIgaWQgPSBlbGUuX3ByaXZhdGUuZGF0YS5pZDtcbiAgICAgICAgICB2YXIgaW5PdGhlciA9IG90aGVyLmhhc0VsZW1lbnRXaXRoSWQoaWQpO1xuXG4gICAgICAgICAgaWYgKCFpbk90aGVyKSB7XG4gICAgICAgICAgICBlbGVtZW50cy5wdXNoKGVsZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBhZGQoY29sMSwgY29sMik7XG4gICAgICBhZGQoY29sMiwgY29sMSk7XG4gICAgICByZXR1cm4gZWxlbWVudHM7XG4gICAgfSxcbiAgICBkaWZmOiBmdW5jdGlvbiBkaWZmKG90aGVyKSB7XG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuXG4gICAgICBpZiAoc3RyaW5nKG90aGVyKSkge1xuICAgICAgICBvdGhlciA9IGN5LiQob3RoZXIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGVmdCA9IHRoaXMuc3Bhd24oKTtcbiAgICAgIHZhciByaWdodCA9IHRoaXMuc3Bhd24oKTtcbiAgICAgIHZhciBib3RoID0gdGhpcy5zcGF3bigpO1xuICAgICAgdmFyIGNvbDEgPSB0aGlzO1xuICAgICAgdmFyIGNvbDIgPSBvdGhlcjtcblxuICAgICAgdmFyIGFkZCA9IGZ1bmN0aW9uIGFkZChjb2wsIG90aGVyLCByZXRFbGVzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVsZSA9IGNvbFtpXTtcbiAgICAgICAgICB2YXIgaWQgPSBlbGUuX3ByaXZhdGUuZGF0YS5pZDtcbiAgICAgICAgICB2YXIgaW5PdGhlciA9IG90aGVyLmhhc0VsZW1lbnRXaXRoSWQoaWQpO1xuXG4gICAgICAgICAgaWYgKGluT3RoZXIpIHtcbiAgICAgICAgICAgIGJvdGgubWVyZ2UoZWxlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0RWxlcy5wdXNoKGVsZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBhZGQoY29sMSwgY29sMiwgbGVmdCk7XG4gICAgICBhZGQoY29sMiwgY29sMSwgcmlnaHQpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgcmlnaHQ6IHJpZ2h0LFxuICAgICAgICBib3RoOiBib3RoXG4gICAgICB9O1xuICAgIH0sXG4gICAgYWRkOiBmdW5jdGlvbiBhZGQodG9BZGQpIHtcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG5cbiAgICAgIGlmICghdG9BZGQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdHJpbmcodG9BZGQpKSB7XG4gICAgICAgIHZhciBzZWxlY3RvciA9IHRvQWRkO1xuICAgICAgICB0b0FkZCA9IGN5Lm11dGFibGVFbGVtZW50cygpLmZpbHRlcihzZWxlY3Rvcik7XG4gICAgICB9XG5cbiAgICAgIHZhciBlbGVtZW50cyA9IHRoaXMuc3Bhd25TZWxmKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9BZGQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IHRvQWRkW2ldO1xuICAgICAgICB2YXIgYWRkID0gIXRoaXMuaGFzKGVsZSk7XG5cbiAgICAgICAgaWYgKGFkZCkge1xuICAgICAgICAgIGVsZW1lbnRzLnB1c2goZWxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZWxlbWVudHM7XG4gICAgfSxcbiAgICAvLyBpbiBwbGFjZSBtZXJnZSBvbiBjYWxsaW5nIGNvbGxlY3Rpb25cbiAgICBtZXJnZTogZnVuY3Rpb24gbWVyZ2UodG9BZGQpIHtcbiAgICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgICB2YXIgY3kgPSBfcC5jeTtcblxuICAgICAgaWYgKCF0b0FkZCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgaWYgKHRvQWRkICYmIHN0cmluZyh0b0FkZCkpIHtcbiAgICAgICAgdmFyIHNlbGVjdG9yID0gdG9BZGQ7XG4gICAgICAgIHRvQWRkID0gY3kubXV0YWJsZUVsZW1lbnRzKCkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG1hcCA9IF9wLm1hcDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b0FkZC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdG9BZGRFbGUgPSB0b0FkZFtpXTtcbiAgICAgICAgdmFyIGlkID0gdG9BZGRFbGUuX3ByaXZhdGUuZGF0YS5pZDtcbiAgICAgICAgdmFyIGFkZCA9ICFtYXAuaGFzKGlkKTtcblxuICAgICAgICBpZiAoYWRkKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5sZW5ndGgrKztcbiAgICAgICAgICB0aGlzW2luZGV4XSA9IHRvQWRkRWxlO1xuICAgICAgICAgIG1hcC5zZXQoaWQsIHtcbiAgICAgICAgICAgIGVsZTogdG9BZGRFbGUsXG4gICAgICAgICAgICBpbmRleDogaW5kZXhcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuICAgIHVubWVyZ2VBdDogZnVuY3Rpb24gdW5tZXJnZUF0KGkpIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgdmFyIGlkID0gZWxlLmlkKCk7XG4gICAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgICAgdmFyIG1hcCA9IF9wLm1hcDsgLy8gcmVtb3ZlIGVsZVxuXG4gICAgICB0aGlzW2ldID0gdW5kZWZpbmVkO1xuICAgICAgbWFwW1wiZGVsZXRlXCJdKGlkKTtcbiAgICAgIHZhciB1bm1lcmdlZExhc3RFbGUgPSBpID09PSB0aGlzLmxlbmd0aCAtIDE7IC8vIHJlcGxhY2UgZW1wdHkgc3BvdCB3aXRoIGxhc3QgZWxlIGluIGNvbGxlY3Rpb25cblxuICAgICAgaWYgKHRoaXMubGVuZ3RoID4gMSAmJiAhdW5tZXJnZWRMYXN0RWxlKSB7XG4gICAgICAgIHZhciBsYXN0RWxlSSA9IHRoaXMubGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIGxhc3RFbGUgPSB0aGlzW2xhc3RFbGVJXTtcbiAgICAgICAgdmFyIGxhc3RFbGVJZCA9IGxhc3RFbGUuX3ByaXZhdGUuZGF0YS5pZDtcbiAgICAgICAgdGhpc1tsYXN0RWxlSV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXNbaV0gPSBsYXN0RWxlO1xuICAgICAgICBtYXAuc2V0KGxhc3RFbGVJZCwge1xuICAgICAgICAgIGVsZTogbGFzdEVsZSxcbiAgICAgICAgICBpbmRleDogaVxuICAgICAgICB9KTtcbiAgICAgIH0gLy8gdGhlIGNvbGxlY3Rpb24gaXMgbm93IDEgZWxlIHNtYWxsZXJcblxuXG4gICAgICB0aGlzLmxlbmd0aC0tO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvLyByZW1vdmUgc2luZ2xlIGVsZSBpbiBwbGFjZSBpbiBjYWxsaW5nIGNvbGxlY3Rpb25cbiAgICB1bm1lcmdlT25lOiBmdW5jdGlvbiB1bm1lcmdlT25lKGVsZSkge1xuICAgICAgZWxlID0gZWxlWzBdO1xuICAgICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICAgIHZhciBpZCA9IGVsZS5fcHJpdmF0ZS5kYXRhLmlkO1xuICAgICAgdmFyIG1hcCA9IF9wLm1hcDtcbiAgICAgIHZhciBlbnRyeSA9IG1hcC5nZXQoaWQpO1xuXG4gICAgICBpZiAoIWVudHJ5KSB7XG4gICAgICAgIHJldHVybiB0aGlzOyAvLyBubyBuZWVkIHRvIHJlbW92ZVxuICAgICAgfVxuXG4gICAgICB2YXIgaSA9IGVudHJ5LmluZGV4O1xuICAgICAgdGhpcy51bm1lcmdlQXQoaSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8vIHJlbW92ZSBlbGVzIGluIHBsYWNlIG9uIGNhbGxpbmcgY29sbGVjdGlvblxuICAgIHVubWVyZ2U6IGZ1bmN0aW9uIHVubWVyZ2UodG9SZW1vdmUpIHtcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG5cbiAgICAgIGlmICghdG9SZW1vdmUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGlmICh0b1JlbW92ZSAmJiBzdHJpbmcodG9SZW1vdmUpKSB7XG4gICAgICAgIHZhciBzZWxlY3RvciA9IHRvUmVtb3ZlO1xuICAgICAgICB0b1JlbW92ZSA9IGN5Lm11dGFibGVFbGVtZW50cygpLmZpbHRlcihzZWxlY3Rvcik7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9SZW1vdmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy51bm1lcmdlT25lKHRvUmVtb3ZlW2ldKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcbiAgICB1bm1lcmdlQnk6IGZ1bmN0aW9uIHVubWVyZ2VCeSh0b1JtRm4pIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuXG4gICAgICAgIGlmICh0b1JtRm4oZWxlKSkge1xuICAgICAgICAgIHRoaXMudW5tZXJnZUF0KGkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgbWFwOiBmdW5jdGlvbiBtYXAobWFwRm4sIHRoaXNBcmcpIHtcbiAgICAgIHZhciBhcnIgPSBbXTtcbiAgICAgIHZhciBlbGVzID0gdGhpcztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgICB2YXIgcmV0ID0gdGhpc0FyZyA/IG1hcEZuLmFwcGx5KHRoaXNBcmcsIFtlbGUsIGksIGVsZXNdKSA6IG1hcEZuKGVsZSwgaSwgZWxlcyk7XG4gICAgICAgIGFyci5wdXNoKHJldCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcbiAgICByZWR1Y2U6IGZ1bmN0aW9uIHJlZHVjZShmbiwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICB2YXIgdmFsID0gaW5pdGlhbFZhbHVlO1xuICAgICAgdmFyIGVsZXMgPSB0aGlzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsID0gZm4odmFsLCBlbGVzW2ldLCBpLCBlbGVzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9LFxuICAgIG1heDogZnVuY3Rpb24gbWF4KHZhbEZuLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgbWF4ID0gLUluZmluaXR5O1xuICAgICAgdmFyIG1heEVsZTtcbiAgICAgIHZhciBlbGVzID0gdGhpcztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgICB2YXIgdmFsID0gdGhpc0FyZyA/IHZhbEZuLmFwcGx5KHRoaXNBcmcsIFtlbGUsIGksIGVsZXNdKSA6IHZhbEZuKGVsZSwgaSwgZWxlcyk7XG5cbiAgICAgICAgaWYgKHZhbCA+IG1heCkge1xuICAgICAgICAgIG1heCA9IHZhbDtcbiAgICAgICAgICBtYXhFbGUgPSBlbGU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IG1heCxcbiAgICAgICAgZWxlOiBtYXhFbGVcbiAgICAgIH07XG4gICAgfSxcbiAgICBtaW46IGZ1bmN0aW9uIG1pbih2YWxGbiwgdGhpc0FyZykge1xuICAgICAgdmFyIG1pbiA9IEluZmluaXR5O1xuICAgICAgdmFyIG1pbkVsZTtcbiAgICAgIHZhciBlbGVzID0gdGhpcztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgICB2YXIgdmFsID0gdGhpc0FyZyA/IHZhbEZuLmFwcGx5KHRoaXNBcmcsIFtlbGUsIGksIGVsZXNdKSA6IHZhbEZuKGVsZSwgaSwgZWxlcyk7XG5cbiAgICAgICAgaWYgKHZhbCA8IG1pbikge1xuICAgICAgICAgIG1pbiA9IHZhbDtcbiAgICAgICAgICBtaW5FbGUgPSBlbGU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IG1pbixcbiAgICAgICAgZWxlOiBtaW5FbGVcbiAgICAgIH07XG4gICAgfVxuICB9OyAvLyBhbGlhc2VzXG5cbiAgdmFyIGZuJDEgPSBlbGVzZm4kODtcbiAgZm4kMVsndSddID0gZm4kMVsnfCddID0gZm4kMVsnKyddID0gZm4kMS51bmlvbiA9IGZuJDEub3IgPSBmbiQxLmFkZDtcbiAgZm4kMVsnXFxcXCddID0gZm4kMVsnISddID0gZm4kMVsnLSddID0gZm4kMS5kaWZmZXJlbmNlID0gZm4kMS5yZWxhdGl2ZUNvbXBsZW1lbnQgPSBmbiQxLnN1YnRyYWN0ID0gZm4kMS5ub3Q7XG4gIGZuJDFbJ24nXSA9IGZuJDFbJyYnXSA9IGZuJDFbJy4nXSA9IGZuJDEuYW5kID0gZm4kMS5pbnRlcnNlY3Rpb24gPSBmbiQxLmludGVyc2VjdDtcbiAgZm4kMVsnXiddID0gZm4kMVsnKCspJ10gPSBmbiQxWycoLSknXSA9IGZuJDEuc3ltbWV0cmljRGlmZmVyZW5jZSA9IGZuJDEuc3ltZGlmZiA9IGZuJDEueG9yO1xuICBmbiQxLmZuRmlsdGVyID0gZm4kMS5maWx0ZXJGbiA9IGZuJDEuc3RkRmlsdGVyID0gZm4kMS5maWx0ZXI7XG4gIGZuJDEuY29tcGxlbWVudCA9IGZuJDEuYWJzY29tcCA9IGZuJDEuYWJzb2x1dGVDb21wbGVtZW50O1xuXG4gIHZhciBlbGVzZm4kNyA9IHtcbiAgICBpc05vZGU6IGZ1bmN0aW9uIGlzTm9kZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdyb3VwKCkgPT09ICdub2Rlcyc7XG4gICAgfSxcbiAgICBpc0VkZ2U6IGZ1bmN0aW9uIGlzRWRnZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdyb3VwKCkgPT09ICdlZGdlcyc7XG4gICAgfSxcbiAgICBpc0xvb3A6IGZ1bmN0aW9uIGlzTG9vcCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzRWRnZSgpICYmIHRoaXMuc291cmNlKClbMF0gPT09IHRoaXMudGFyZ2V0KClbMF07XG4gICAgfSxcbiAgICBpc1NpbXBsZTogZnVuY3Rpb24gaXNTaW1wbGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc0VkZ2UoKSAmJiB0aGlzLnNvdXJjZSgpWzBdICE9PSB0aGlzLnRhcmdldCgpWzBdO1xuICAgIH0sXG4gICAgZ3JvdXA6IGZ1bmN0aW9uIGdyb3VwKCkge1xuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICAgIGlmIChlbGUpIHtcbiAgICAgICAgcmV0dXJuIGVsZS5fcHJpdmF0ZS5ncm91cDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqICBFbGVtZW50cyBhcmUgZHJhd24gaW4gYSBzcGVjaWZpYyBvcmRlciBiYXNlZCBvbiBjb21wb3VuZCBkZXB0aCAobG93IHRvIGhpZ2gpLCB0aGUgZWxlbWVudCB0eXBlIChub2RlcyBhYm92ZSBlZGdlcyksXG4gICAqICBhbmQgei1pbmRleCAobG93IHRvIGhpZ2gpLiAgVGhlc2Ugc3R5bGVzIGFmZmVjdCBob3cgdGhpcyBhcHBsaWVzOlxuICAgKlxuICAgKiAgei1jb21wb3VuZC1kZXB0aDogTWF5IGJlIGBib3R0b20gfCBvcnBoYW4gfCBhdXRvIHwgdG9wYC4gIFRoZSBmaXJzdCBkcmF3biBpcyBgYm90dG9tYCwgdGhlbiBgb3JwaGFuYCB3aGljaCBpcyB0aGVcbiAgICogICAgICBzYW1lIGRlcHRoIGFzIHRoZSByb290IG9mIHRoZSBjb21wb3VuZCBncmFwaCwgZm9sbG93ZWQgYnkgdGhlIGRlZmF1bHQgdmFsdWUgYGF1dG9gIHdoaWNoIGRyYXdzIGluIG9yZGVyIGZyb21cbiAgICogICAgICByb290IHRvIGxlYXZlcyBvZiB0aGUgY29tcG91bmQgZ3JhcGguICBUaGUgbGFzdCBkcmF3biBpcyBgdG9wYC5cbiAgICogIHotaW5kZXgtY29tcGFyZTogTWF5IGJlIGBhdXRvIHwgbWFudWFsYC4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGBhdXRvYCB3aGljaCBhbHdheXMgZHJhd3MgZWRnZXMgdW5kZXIgbm9kZXMuXG4gICAqICAgICAgYG1hbnVhbGAgaWdub3JlcyB0aGlzIGNvbnZlbnRpb24gYW5kIGRyYXdzIGJhc2VkIG9uIHRoZSBgei1pbmRleGAgdmFsdWUgc2V0dGluZy5cbiAgICogIHotaW5kZXg6IEFuIGludGVnZXIgdmFsdWUgdGhhdCBhZmZlY3RzIHRoZSByZWxhdGl2ZSBkcmF3IG9yZGVyIG9mIGVsZW1lbnRzLiAgSW4gZ2VuZXJhbCwgYW4gZWxlbWVudCB3aXRoIGEgaGlnaGVyXG4gICAqICAgICAgYHotaW5kZXhgIHdpbGwgYmUgZHJhd24gb24gdG9wIG9mIGFuIGVsZW1lbnQgd2l0aCBhIGxvd2VyIGB6LWluZGV4YC5cbiAgICovXG5cbiAgdmFyIHpJbmRleFNvcnQgPSBmdW5jdGlvbiB6SW5kZXhTb3J0KGEsIGIpIHtcbiAgICB2YXIgY3kgPSBhLmN5KCk7XG4gICAgdmFyIGhhc0NvbXBvdW5kTm9kZXMgPSBjeS5oYXNDb21wb3VuZE5vZGVzKCk7XG5cbiAgICBmdW5jdGlvbiBnZXREZXB0aChlbGUpIHtcbiAgICAgIHZhciBzdHlsZSA9IGVsZS5wc3R5bGUoJ3otY29tcG91bmQtZGVwdGgnKTtcblxuICAgICAgaWYgKHN0eWxlLnZhbHVlID09PSAnYXV0bycpIHtcbiAgICAgICAgcmV0dXJuIGhhc0NvbXBvdW5kTm9kZXMgPyBlbGUuekRlcHRoKCkgOiAwO1xuICAgICAgfSBlbHNlIGlmIChzdHlsZS52YWx1ZSA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfSBlbHNlIGlmIChzdHlsZS52YWx1ZSA9PT0gJ3RvcCcpIHtcbiAgICAgICAgcmV0dXJuIE1BWF9JTlQkMTtcbiAgICAgIH0gLy8gJ29ycGhhbidcblxuXG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICB2YXIgZGVwdGhEaWZmID0gZ2V0RGVwdGgoYSkgLSBnZXREZXB0aChiKTtcblxuICAgIGlmIChkZXB0aERpZmYgIT09IDApIHtcbiAgICAgIHJldHVybiBkZXB0aERpZmY7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RWxlRGVwdGgoZWxlKSB7XG4gICAgICB2YXIgc3R5bGUgPSBlbGUucHN0eWxlKCd6LWluZGV4LWNvbXBhcmUnKTtcblxuICAgICAgaWYgKHN0eWxlLnZhbHVlID09PSAnYXV0bycpIHtcbiAgICAgICAgcmV0dXJuIGVsZS5pc05vZGUoKSA/IDEgOiAwO1xuICAgICAgfSAvLyAnbWFudWFsJ1xuXG5cbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHZhciBlbGVEaWZmID0gZ2V0RWxlRGVwdGgoYSkgLSBnZXRFbGVEZXB0aChiKTtcblxuICAgIGlmIChlbGVEaWZmICE9PSAwKSB7XG4gICAgICByZXR1cm4gZWxlRGlmZjtcbiAgICB9XG5cbiAgICB2YXIgekRpZmYgPSBhLnBzdHlsZSgnei1pbmRleCcpLnZhbHVlIC0gYi5wc3R5bGUoJ3otaW5kZXgnKS52YWx1ZTtcblxuICAgIGlmICh6RGlmZiAhPT0gMCkge1xuICAgICAgcmV0dXJuIHpEaWZmO1xuICAgIH0gLy8gY29tcGFyZSBpbmRpY2VzIGluIHRoZSBjb3JlIChvcmRlciBhZGRlZCB0byBncmFwaCB3LyBsYXN0IG9uIHRvcClcblxuXG4gICAgcmV0dXJuIGEucG9vbEluZGV4KCkgLSBiLnBvb2xJbmRleCgpO1xuICB9O1xuXG4gIHZhciBlbGVzZm4kNiA9IHtcbiAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGZuLCB0aGlzQXJnKSB7XG4gICAgICBpZiAoZm4kNihmbikpIHtcbiAgICAgICAgdmFyIE4gPSB0aGlzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IE47IGkrKykge1xuICAgICAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgICAgIHZhciByZXQgPSB0aGlzQXJnID8gZm4uYXBwbHkodGhpc0FyZywgW2VsZSwgaSwgdGhpc10pIDogZm4oZWxlLCBpLCB0aGlzKTtcblxuICAgICAgICAgIGlmIChyZXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IC8vIGV4aXQgZWFjaCBlYXJseSBvbiByZXR1cm4gZmFsc2VcblxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgdG9BcnJheTogZnVuY3Rpb24gdG9BcnJheSgpIHtcbiAgICAgIHZhciBhcnJheSA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyYXkucHVzaCh0aGlzW2ldKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH0sXG4gICAgc2xpY2U6IGZ1bmN0aW9uIHNsaWNlKHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBhcnJheSA9IFtdO1xuICAgICAgdmFyIHRoaXNTaXplID0gdGhpcy5sZW5ndGg7XG5cbiAgICAgIGlmIChlbmQgPT0gbnVsbCkge1xuICAgICAgICBlbmQgPSB0aGlzU2l6ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXJ0ID09IG51bGwpIHtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgIHN0YXJ0ID0gdGhpc1NpemUgKyBzdGFydDtcbiAgICAgIH1cblxuICAgICAgaWYgKGVuZCA8IDApIHtcbiAgICAgICAgZW5kID0gdGhpc1NpemUgKyBlbmQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA+PSAwICYmIGkgPCBlbmQgJiYgaSA8IHRoaXNTaXplOyBpKyspIHtcbiAgICAgICAgYXJyYXkucHVzaCh0aGlzW2ldKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuc3Bhd24oYXJyYXkpO1xuICAgIH0sXG4gICAgc2l6ZTogZnVuY3Rpb24gc2l6ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmxlbmd0aDtcbiAgICB9LFxuICAgIGVxOiBmdW5jdGlvbiBlcShpKSB7XG4gICAgICByZXR1cm4gdGhpc1tpXSB8fCB0aGlzLnNwYXduKCk7XG4gICAgfSxcbiAgICBmaXJzdDogZnVuY3Rpb24gZmlyc3QoKSB7XG4gICAgICByZXR1cm4gdGhpc1swXSB8fCB0aGlzLnNwYXduKCk7XG4gICAgfSxcbiAgICBsYXN0OiBmdW5jdGlvbiBsYXN0KCkge1xuICAgICAgcmV0dXJuIHRoaXNbdGhpcy5sZW5ndGggLSAxXSB8fCB0aGlzLnNwYXduKCk7XG4gICAgfSxcbiAgICBlbXB0eTogZnVuY3Rpb24gZW1wdHkoKSB7XG4gICAgICByZXR1cm4gdGhpcy5sZW5ndGggPT09IDA7XG4gICAgfSxcbiAgICBub25lbXB0eTogZnVuY3Rpb24gbm9uZW1wdHkoKSB7XG4gICAgICByZXR1cm4gIXRoaXMuZW1wdHkoKTtcbiAgICB9LFxuICAgIHNvcnQ6IGZ1bmN0aW9uIHNvcnQoc29ydEZuKSB7XG4gICAgICBpZiAoIWZuJDYoc29ydEZuKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdmFyIHNvcnRlZCA9IHRoaXMudG9BcnJheSgpLnNvcnQoc29ydEZuKTtcbiAgICAgIHJldHVybiB0aGlzLnNwYXduKHNvcnRlZCk7XG4gICAgfSxcbiAgICBzb3J0QnlaSW5kZXg6IGZ1bmN0aW9uIHNvcnRCeVpJbmRleCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNvcnQoekluZGV4U29ydCk7XG4gICAgfSxcbiAgICB6RGVwdGg6IGZ1bmN0aW9uIHpEZXB0aCgpIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgICBpZiAoIWVsZSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfSAvLyBsZXQgY3kgPSBlbGUuY3koKTtcblxuXG4gICAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgICB2YXIgZ3JvdXAgPSBfcC5ncm91cDtcblxuICAgICAgaWYgKGdyb3VwID09PSAnbm9kZXMnKSB7XG4gICAgICAgIHZhciBkZXB0aCA9IF9wLmRhdGEucGFyZW50ID8gZWxlLnBhcmVudHMoKS5zaXplKCkgOiAwO1xuXG4gICAgICAgIGlmICghZWxlLmlzUGFyZW50KCkpIHtcbiAgICAgICAgICByZXR1cm4gTUFYX0lOVCQxIC0gMTsgLy8gY2hpbGRsZXNzIG5vZGVzIGFsd2F5cyBvbiB0b3BcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZXB0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzcmMgPSBfcC5zb3VyY2U7XG4gICAgICAgIHZhciB0Z3QgPSBfcC50YXJnZXQ7XG4gICAgICAgIHZhciBzcmNEZXB0aCA9IHNyYy56RGVwdGgoKTtcbiAgICAgICAgdmFyIHRndERlcHRoID0gdGd0LnpEZXB0aCgpO1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoc3JjRGVwdGgsIHRndERlcHRoLCAwKTsgLy8gZGVwdGggb2YgZGVlcGVzdCBwYXJlbnRcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGVsZXNmbiQ2LmVhY2ggPSBlbGVzZm4kNi5mb3JFYWNoO1xuXG4gIHZhciBkZWZpbmVTeW1ib2xJdGVyYXRvciA9IGZ1bmN0aW9uIGRlZmluZVN5bWJvbEl0ZXJhdG9yKCkge1xuICAgIHZhciB0eXBlb2ZVbmRlZiA9IFwidW5kZWZpbmVkXCIgO1xuICAgIHZhciBpc0l0ZXJhdG9yU3VwcG9ydGVkID0gKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihTeW1ib2wpKSAhPSB0eXBlb2ZVbmRlZiAmJiBfdHlwZW9mKFN5bWJvbC5pdGVyYXRvcikgIT0gdHlwZW9mVW5kZWY7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuICAgIGlmIChpc0l0ZXJhdG9yU3VwcG9ydGVkKSB7XG4gICAgICBlbGVzZm4kNltTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgICAgICAgdmFyIGVudHJ5ID0ge1xuICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIHJldHVybiBfZGVmaW5lUHJvcGVydHkkMSh7XG4gICAgICAgICAgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICAgIGlmIChpIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGVudHJ5LnZhbHVlID0gX3RoaXNbaSsrXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVudHJ5LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICBlbnRyeS5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGVudHJ5O1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgU3ltYm9sLml0ZXJhdG9yLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfVxuICB9O1xuXG4gIGRlZmluZVN5bWJvbEl0ZXJhdG9yKCk7XG5cbiAgdmFyIGdldExheW91dERpbWVuc2lvbk9wdGlvbnMgPSBkZWZhdWx0cyRnKHtcbiAgICBub2RlRGltZW5zaW9uc0luY2x1ZGVMYWJlbHM6IGZhbHNlXG4gIH0pO1xuICB2YXIgZWxlc2ZuJDUgPSB7XG4gICAgLy8gQ2FsY3VsYXRlcyBhbmQgcmV0dXJucyBub2RlIGRpbWVuc2lvbnMgeyB4LCB5IH0gYmFzZWQgb24gb3B0aW9ucyBnaXZlblxuICAgIGxheW91dERpbWVuc2lvbnM6IGZ1bmN0aW9uIGxheW91dERpbWVuc2lvbnMob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IGdldExheW91dERpbWVuc2lvbk9wdGlvbnMob3B0aW9ucyk7XG4gICAgICB2YXIgZGltcztcblxuICAgICAgaWYgKCF0aGlzLnRha2VzVXBTcGFjZSgpKSB7XG4gICAgICAgIGRpbXMgPSB7XG4gICAgICAgICAgdzogMCxcbiAgICAgICAgICBoOiAwXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMubm9kZURpbWVuc2lvbnNJbmNsdWRlTGFiZWxzKSB7XG4gICAgICAgIHZhciBiYkRpbSA9IHRoaXMuYm91bmRpbmdCb3goKTtcbiAgICAgICAgZGltcyA9IHtcbiAgICAgICAgICB3OiBiYkRpbS53LFxuICAgICAgICAgIGg6IGJiRGltLmhcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpbXMgPSB7XG4gICAgICAgICAgdzogdGhpcy5vdXRlcldpZHRoKCksXG4gICAgICAgICAgaDogdGhpcy5vdXRlckhlaWdodCgpXG4gICAgICAgIH07XG4gICAgICB9IC8vIHNhbml0aXNlIHRoZSBkaW1lbnNpb25zIGZvciBleHRlcm5hbCBsYXlvdXRzIChhdm9pZCBkaXZpc2lvbiBieSB6ZXJvKVxuXG5cbiAgICAgIGlmIChkaW1zLncgPT09IDAgfHwgZGltcy5oID09PSAwKSB7XG4gICAgICAgIGRpbXMudyA9IGRpbXMuaCA9IDE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkaW1zO1xuICAgIH0sXG4gICAgLy8gdXNpbmcgc3RhbmRhcmQgbGF5b3V0IG9wdGlvbnMsIGFwcGx5IHBvc2l0aW9uIGZ1bmN0aW9uICh3LyBvciB3L28gYW5pbWF0aW9uKVxuICAgIGxheW91dFBvc2l0aW9uczogZnVuY3Rpb24gbGF5b3V0UG9zaXRpb25zKGxheW91dCwgb3B0aW9ucywgZm4pIHtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKS5maWx0ZXIoZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgcmV0dXJuICFuLmlzUGFyZW50KCk7XG4gICAgICB9KTtcbiAgICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICAgIHZhciBsYXlvdXRFbGVzID0gb3B0aW9ucy5lbGVzOyAvLyBub2RlcyAmIGVkZ2VzXG5cbiAgICAgIHZhciBnZXRNZW1vaXplS2V5ID0gZnVuY3Rpb24gZ2V0TWVtb2l6ZUtleShub2RlKSB7XG4gICAgICAgIHJldHVybiBub2RlLmlkKCk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgZm5NZW0gPSBtZW1vaXplJDEoZm4sIGdldE1lbW9pemVLZXkpOyAvLyBtZW1vaXplZCB2ZXJzaW9uIG9mIHBvc2l0aW9uIGZ1bmN0aW9uXG5cbiAgICAgIGxheW91dC5lbWl0KHtcbiAgICAgICAgdHlwZTogJ2xheW91dHN0YXJ0JyxcbiAgICAgICAgbGF5b3V0OiBsYXlvdXRcbiAgICAgIH0pO1xuICAgICAgbGF5b3V0LmFuaW1hdGlvbnMgPSBbXTtcblxuICAgICAgdmFyIGNhbGN1bGF0ZVNwYWNpbmcgPSBmdW5jdGlvbiBjYWxjdWxhdGVTcGFjaW5nKHNwYWNpbmcsIG5vZGVzQmIsIHBvcykge1xuICAgICAgICB2YXIgY2VudGVyID0ge1xuICAgICAgICAgIHg6IG5vZGVzQmIueDEgKyBub2Rlc0JiLncgLyAyLFxuICAgICAgICAgIHk6IG5vZGVzQmIueTEgKyBub2Rlc0JiLmggLyAyXG4gICAgICAgIH07XG4gICAgICAgIHZhciBzcGFjaW5nVmVjdG9yID0ge1xuICAgICAgICAgIC8vIHNjYWxlIGZyb20gY2VudGVyIG9mIGJvdW5kaW5nIGJveCAobm90IG5lY2Vzc2FyaWx5IDAsMClcbiAgICAgICAgICB4OiAocG9zLnggLSBjZW50ZXIueCkgKiBzcGFjaW5nLFxuICAgICAgICAgIHk6IChwb3MueSAtIGNlbnRlci55KSAqIHNwYWNpbmdcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiBjZW50ZXIueCArIHNwYWNpbmdWZWN0b3IueCxcbiAgICAgICAgICB5OiBjZW50ZXIueSArIHNwYWNpbmdWZWN0b3IueVxuICAgICAgICB9O1xuICAgICAgfTtcblxuICAgICAgdmFyIHVzZVNwYWNpbmdGYWN0b3IgPSBvcHRpb25zLnNwYWNpbmdGYWN0b3IgJiYgb3B0aW9ucy5zcGFjaW5nRmFjdG9yICE9PSAxO1xuXG4gICAgICB2YXIgc3BhY2luZ0JiID0gZnVuY3Rpb24gc3BhY2luZ0JiKCkge1xuICAgICAgICBpZiAoIXVzZVNwYWNpbmdGYWN0b3IpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBiYiA9IG1ha2VCb3VuZGluZ0JveCgpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgIHZhciBwb3MgPSBmbk1lbShub2RlLCBpKTtcbiAgICAgICAgICBleHBhbmRCb3VuZGluZ0JveEJ5UG9pbnQoYmIsIHBvcy54LCBwb3MueSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYmI7XG4gICAgICB9O1xuXG4gICAgICB2YXIgYmIgPSBzcGFjaW5nQmIoKTtcbiAgICAgIHZhciBnZXRGaW5hbFBvcyA9IG1lbW9pemUkMShmdW5jdGlvbiAobm9kZSwgaSkge1xuICAgICAgICB2YXIgbmV3UG9zID0gZm5NZW0obm9kZSwgaSk7XG5cbiAgICAgICAgaWYgKHVzZVNwYWNpbmdGYWN0b3IpIHtcbiAgICAgICAgICB2YXIgc3BhY2luZyA9IE1hdGguYWJzKG9wdGlvbnMuc3BhY2luZ0ZhY3Rvcik7XG4gICAgICAgICAgbmV3UG9zID0gY2FsY3VsYXRlU3BhY2luZyhzcGFjaW5nLCBiYiwgbmV3UG9zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLnRyYW5zZm9ybSAhPSBudWxsKSB7XG4gICAgICAgICAgbmV3UG9zID0gb3B0aW9ucy50cmFuc2Zvcm0obm9kZSwgbmV3UG9zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXdQb3M7XG4gICAgICB9LCBnZXRNZW1vaXplS2V5KTtcblxuICAgICAgaWYgKG9wdGlvbnMuYW5pbWF0ZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICB2YXIgbmV3UG9zID0gZ2V0RmluYWxQb3Mobm9kZSwgaSk7XG4gICAgICAgICAgdmFyIGFuaW1hdGVOb2RlID0gb3B0aW9ucy5hbmltYXRlRmlsdGVyID09IG51bGwgfHwgb3B0aW9ucy5hbmltYXRlRmlsdGVyKG5vZGUsIGkpO1xuXG4gICAgICAgICAgaWYgKGFuaW1hdGVOb2RlKSB7XG4gICAgICAgICAgICB2YXIgYW5pID0gbm9kZS5hbmltYXRpb24oe1xuICAgICAgICAgICAgICBwb3NpdGlvbjogbmV3UG9zLFxuICAgICAgICAgICAgICBkdXJhdGlvbjogb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbixcbiAgICAgICAgICAgICAgZWFzaW5nOiBvcHRpb25zLmFuaW1hdGlvbkVhc2luZ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsYXlvdXQuYW5pbWF0aW9ucy5wdXNoKGFuaSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUucG9zaXRpb24obmV3UG9zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5maXQpIHtcbiAgICAgICAgICB2YXIgZml0QW5pID0gY3kuYW5pbWF0aW9uKHtcbiAgICAgICAgICAgIGZpdDoge1xuICAgICAgICAgICAgICBib3VuZGluZ0JveDogbGF5b3V0RWxlcy5ib3VuZGluZ0JveEF0KGdldEZpbmFsUG9zKSxcbiAgICAgICAgICAgICAgcGFkZGluZzogb3B0aW9ucy5wYWRkaW5nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHVyYXRpb246IG9wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb24sXG4gICAgICAgICAgICBlYXNpbmc6IG9wdGlvbnMuYW5pbWF0aW9uRWFzaW5nXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbGF5b3V0LmFuaW1hdGlvbnMucHVzaChmaXRBbmkpO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuem9vbSAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMucGFuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgem9vbVBhbkFuaSA9IGN5LmFuaW1hdGlvbih7XG4gICAgICAgICAgICB6b29tOiBvcHRpb25zLnpvb20sXG4gICAgICAgICAgICBwYW46IG9wdGlvbnMucGFuLFxuICAgICAgICAgICAgZHVyYXRpb246IG9wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb24sXG4gICAgICAgICAgICBlYXNpbmc6IG9wdGlvbnMuYW5pbWF0aW9uRWFzaW5nXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbGF5b3V0LmFuaW1hdGlvbnMucHVzaCh6b29tUGFuQW5pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxheW91dC5hbmltYXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGFuaSkge1xuICAgICAgICAgIHJldHVybiBhbmkucGxheSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgbGF5b3V0Lm9uZSgnbGF5b3V0cmVhZHknLCBvcHRpb25zLnJlYWR5KTtcbiAgICAgICAgbGF5b3V0LmVtaXQoe1xuICAgICAgICAgIHR5cGU6ICdsYXlvdXRyZWFkeScsXG4gICAgICAgICAgbGF5b3V0OiBsYXlvdXRcbiAgICAgICAgfSk7XG4gICAgICAgIFByb21pc2UkMS5hbGwobGF5b3V0LmFuaW1hdGlvbnMubWFwKGZ1bmN0aW9uIChhbmkpIHtcbiAgICAgICAgICByZXR1cm4gYW5pLnByb21pc2UoKTtcbiAgICAgICAgfSkpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGxheW91dC5vbmUoJ2xheW91dHN0b3AnLCBvcHRpb25zLnN0b3ApO1xuICAgICAgICAgIGxheW91dC5lbWl0KHtcbiAgICAgICAgICAgIHR5cGU6ICdsYXlvdXRzdG9wJyxcbiAgICAgICAgICAgIGxheW91dDogbGF5b3V0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZXMucG9zaXRpb25zKGdldEZpbmFsUG9zKTtcblxuICAgICAgICBpZiAob3B0aW9ucy5maXQpIHtcbiAgICAgICAgICBjeS5maXQob3B0aW9ucy5lbGVzLCBvcHRpb25zLnBhZGRpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuem9vbSAhPSBudWxsKSB7XG4gICAgICAgICAgY3kuem9vbShvcHRpb25zLnpvb20pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMucGFuKSB7XG4gICAgICAgICAgY3kucGFuKG9wdGlvbnMucGFuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxheW91dC5vbmUoJ2xheW91dHJlYWR5Jywgb3B0aW9ucy5yZWFkeSk7XG4gICAgICAgIGxheW91dC5lbWl0KHtcbiAgICAgICAgICB0eXBlOiAnbGF5b3V0cmVhZHknLFxuICAgICAgICAgIGxheW91dDogbGF5b3V0XG4gICAgICAgIH0pO1xuICAgICAgICBsYXlvdXQub25lKCdsYXlvdXRzdG9wJywgb3B0aW9ucy5zdG9wKTtcbiAgICAgICAgbGF5b3V0LmVtaXQoe1xuICAgICAgICAgIHR5cGU6ICdsYXlvdXRzdG9wJyxcbiAgICAgICAgICBsYXlvdXQ6IGxheW91dFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcbiAgICBsYXlvdXQ6IGZ1bmN0aW9uIGxheW91dChvcHRpb25zKSB7XG4gICAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgICByZXR1cm4gY3kubWFrZUxheW91dChleHRlbmQoe30sIG9wdGlvbnMsIHtcbiAgICAgICAgZWxlczogdGhpc1xuICAgICAgfSkpO1xuICAgIH1cbiAgfTsgLy8gYWxpYXNlczpcblxuICBlbGVzZm4kNS5jcmVhdGVMYXlvdXQgPSBlbGVzZm4kNS5tYWtlTGF5b3V0ID0gZWxlc2ZuJDUubGF5b3V0O1xuXG4gIGZ1bmN0aW9uIHN0eWxlQ2FjaGUoa2V5LCBmbiwgZWxlKSB7XG4gICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgIHZhciBjYWNoZSA9IF9wLnN0eWxlQ2FjaGUgPSBfcC5zdHlsZUNhY2hlIHx8IFtdO1xuICAgIHZhciB2YWw7XG5cbiAgICBpZiAoKHZhbCA9IGNhY2hlW2tleV0pICE9IG51bGwpIHtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbCA9IGNhY2hlW2tleV0gPSBmbihlbGUpO1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjYWNoZVN0eWxlRnVuY3Rpb24oa2V5LCBmbikge1xuICAgIGtleSA9IGhhc2hTdHJpbmcoa2V5KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gY2FjaGVkU3R5bGVGdW5jdGlvbihlbGUpIHtcbiAgICAgIHJldHVybiBzdHlsZUNhY2hlKGtleSwgZm4sIGVsZSk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhY2hlUHJvdG90eXBlU3R5bGVGdW5jdGlvbihrZXksIGZuKSB7XG4gICAga2V5ID0gaGFzaFN0cmluZyhrZXkpO1xuXG4gICAgdmFyIHNlbGZGbiA9IGZ1bmN0aW9uIHNlbGZGbihlbGUpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKGVsZSk7XG4gICAgfTtcblxuICAgIHJldHVybiBmdW5jdGlvbiBjYWNoZWRQcm90b3R5cGVTdHlsZUZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICAgIGlmIChlbGUpIHtcbiAgICAgICAgcmV0dXJuIHN0eWxlQ2FjaGUoa2V5LCBzZWxmRm4sIGVsZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHZhciBlbGVzZm4kNCA9IHtcbiAgICByZWNhbGN1bGF0ZVJlbmRlcmVkU3R5bGU6IGZ1bmN0aW9uIHJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZSh1c2VDYWNoZSkge1xuICAgICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgICAgdmFyIHJlbmRlcmVyID0gY3kucmVuZGVyZXIoKTtcbiAgICAgIHZhciBzdHlsZUVuYWJsZWQgPSBjeS5zdHlsZUVuYWJsZWQoKTtcblxuICAgICAgaWYgKHJlbmRlcmVyICYmIHN0eWxlRW5hYmxlZCkge1xuICAgICAgICByZW5kZXJlci5yZWNhbGN1bGF0ZVJlbmRlcmVkU3R5bGUodGhpcywgdXNlQ2FjaGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGRpcnR5U3R5bGVDYWNoZTogZnVuY3Rpb24gZGlydHlTdHlsZUNhY2hlKCkge1xuICAgICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuXG4gICAgICB2YXIgZGlydHkgPSBmdW5jdGlvbiBkaXJ0eShlbGUpIHtcbiAgICAgICAgcmV0dXJuIGVsZS5fcHJpdmF0ZS5zdHlsZUNhY2hlID0gbnVsbDtcbiAgICAgIH07XG5cbiAgICAgIGlmIChjeS5oYXNDb21wb3VuZE5vZGVzKCkpIHtcbiAgICAgICAgdmFyIGVsZXM7XG4gICAgICAgIGVsZXMgPSB0aGlzLnNwYXduU2VsZigpLm1lcmdlKHRoaXMuZGVzY2VuZGFudHMoKSkubWVyZ2UodGhpcy5wYXJlbnRzKCkpO1xuICAgICAgICBlbGVzLm1lcmdlKGVsZXMuY29ubmVjdGVkRWRnZXMoKSk7XG4gICAgICAgIGVsZXMuZm9yRWFjaChkaXJ0eSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICAgIGRpcnR5KGVsZSk7XG4gICAgICAgICAgZWxlLmNvbm5lY3RlZEVkZ2VzKCkuZm9yRWFjaChkaXJ0eSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8vIGZ1bGx5IHVwZGF0ZXMgKHJlY2FsY3VsYXRlcykgdGhlIHN0eWxlIGZvciB0aGUgZWxlbWVudHNcbiAgICB1cGRhdGVTdHlsZTogZnVuY3Rpb24gdXBkYXRlU3R5bGUobm90aWZ5UmVuZGVyZXIpIHtcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG5cbiAgICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGlmIChjeS5iYXRjaGluZygpKSB7XG4gICAgICAgIHZhciBiRWxlcyA9IGN5Ll9wcml2YXRlLmJhdGNoU3R5bGVFbGVzO1xuICAgICAgICBiRWxlcy5tZXJnZSh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nIGFuZCBleGl0IGVhcmx5IHdoZW4gYmF0Y2hpbmdcbiAgICAgIH1cblxuICAgICAgdmFyIGhhc0NvbXBvdW5kcyA9IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcbiAgICAgIHZhciB1cGRhdGVkRWxlcyA9IHRoaXM7XG4gICAgICBub3RpZnlSZW5kZXJlciA9IG5vdGlmeVJlbmRlcmVyIHx8IG5vdGlmeVJlbmRlcmVyID09PSB1bmRlZmluZWQgPyB0cnVlIDogZmFsc2U7XG5cbiAgICAgIGlmIChoYXNDb21wb3VuZHMpIHtcbiAgICAgICAgLy8gdGhlbiBhZGQgZXZlcnl0aGluZyB1cCBhbmQgZG93biBmb3IgY29tcG91bmQgc2VsZWN0b3IgY2hlY2tzXG4gICAgICAgIHVwZGF0ZWRFbGVzID0gdGhpcy5zcGF3blNlbGYoKS5tZXJnZSh0aGlzLmRlc2NlbmRhbnRzKCkpLm1lcmdlKHRoaXMucGFyZW50cygpKTtcbiAgICAgIH0gLy8gbGV0IGNoYW5nZWRFbGVzID0gc3R5bGUuYXBwbHkoIHVwZGF0ZWRFbGVzICk7XG5cblxuICAgICAgdmFyIGNoYW5nZWRFbGVzID0gdXBkYXRlZEVsZXM7XG5cbiAgICAgIGlmIChub3RpZnlSZW5kZXJlcikge1xuICAgICAgICBjaGFuZ2VkRWxlcy5lbWl0QW5kTm90aWZ5KCdzdHlsZScpOyAvLyBsZXQgcmVuZGVyZXIga25vdyB3ZSBjaGFuZ2VkIHN0eWxlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGFuZ2VkRWxlcy5lbWl0KCdzdHlsZScpOyAvLyBqdXN0IGZpcmUgdGhlIGV2ZW50XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZWRFbGVzLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICByZXR1cm4gZWxlLl9wcml2YXRlLnN0eWxlRGlydHkgPSB0cnVlO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuICAgIC8vIHByaXZhdGU6IGNsZWFycyBkaXJ0eSBmbGFnIGFuZCByZWNhbGN1bGF0ZXMgc3R5bGVcbiAgICBjbGVhblN0eWxlOiBmdW5jdGlvbiBjbGVhblN0eWxlKCkge1xuICAgICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuXG4gICAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuXG4gICAgICAgIGlmIChlbGUuX3ByaXZhdGUuc3R5bGVEaXJ0eSkge1xuICAgICAgICAgIC8vIG4uYi4gdGhpcyBmbGFnIHNob3VsZCBiZSBzZXQgYmVmb3JlIGFwcGx5KCkgdG8gYXZvaWQgcG90ZW50aWFsIGluZmluaXRlIHJlY3Vyc2lvblxuICAgICAgICAgIGVsZS5fcHJpdmF0ZS5zdHlsZURpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgY3kuc3R5bGUoKS5hcHBseShlbGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBnZXQgdGhlIGludGVybmFsIHBhcnNlZCBzdHlsZSBvYmplY3QgZm9yIHRoZSBzcGVjaWZpZWQgcHJvcGVydHlcbiAgICBwYXJzZWRTdHlsZTogZnVuY3Rpb24gcGFyc2VkU3R5bGUocHJvcGVydHkpIHtcbiAgICAgIHZhciBpbmNsdWRlTm9uRGVmYXVsdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgICAgdmFyIGN5ID0gZWxlLmN5KCk7XG5cbiAgICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWxlKSB7XG4gICAgICAgIHRoaXMuY2xlYW5TdHlsZSgpO1xuICAgICAgICB2YXIgb3ZlcnJpZGRlblN0eWxlID0gZWxlLl9wcml2YXRlLnN0eWxlW3Byb3BlcnR5XTtcblxuICAgICAgICBpZiAob3ZlcnJpZGRlblN0eWxlICE9IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gb3ZlcnJpZGRlblN0eWxlO1xuICAgICAgICB9IGVsc2UgaWYgKGluY2x1ZGVOb25EZWZhdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIGN5LnN0eWxlKCkuZ2V0RGVmYXVsdFByb3BlcnR5KHByb3BlcnR5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgbnVtZXJpY1N0eWxlOiBmdW5jdGlvbiBudW1lcmljU3R5bGUocHJvcGVydHkpIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgICBpZiAoIWVsZS5jeSgpLnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGVsZSkge1xuICAgICAgICB2YXIgcHN0eWxlID0gZWxlLnBzdHlsZShwcm9wZXJ0eSk7XG4gICAgICAgIHJldHVybiBwc3R5bGUucGZWYWx1ZSAhPT0gdW5kZWZpbmVkID8gcHN0eWxlLnBmVmFsdWUgOiBwc3R5bGUudmFsdWU7XG4gICAgICB9XG4gICAgfSxcbiAgICBudW1lcmljU3R5bGVVbml0czogZnVuY3Rpb24gbnVtZXJpY1N0eWxlVW5pdHMocHJvcGVydHkpIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgICBpZiAoIWVsZS5jeSgpLnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGVsZSkge1xuICAgICAgICByZXR1cm4gZWxlLnBzdHlsZShwcm9wZXJ0eSkudW5pdHM7XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBnZXQgdGhlIHNwZWNpZmllZCBjc3MgcHJvcGVydHkgYXMgYSByZW5kZXJlZCB2YWx1ZSAoaS5lLiBvbi1zY3JlZW4gdmFsdWUpXG4gICAgLy8gb3IgZ2V0IHRoZSB3aG9sZSByZW5kZXJlZCBzdHlsZSBpZiBubyBwcm9wZXJ0eSBzcGVjaWZpZWQgKE5CIGRvZXNuJ3QgYWxsb3cgc2V0dGluZylcbiAgICByZW5kZXJlZFN0eWxlOiBmdW5jdGlvbiByZW5kZXJlZFN0eWxlKHByb3BlcnR5KSB7XG4gICAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgICBpZiAoZWxlKSB7XG4gICAgICAgIHJldHVybiBjeS5zdHlsZSgpLmdldFJlbmRlcmVkU3R5bGUoZWxlLCBwcm9wZXJ0eSk7XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyByZWFkIHRoZSBjYWxjdWxhdGVkIGNzcyBzdHlsZSBvZiB0aGUgZWxlbWVudCBvciBvdmVycmlkZSB0aGUgc3R5bGUgKHZpYSBhIGJ5cGFzcylcbiAgICBzdHlsZTogZnVuY3Rpb24gc3R5bGUobmFtZSwgdmFsdWUpIHtcbiAgICAgIHZhciBjeSA9IHRoaXMuY3koKTtcblxuICAgICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdmFyIHVwZGF0ZVRyYW5zaXRpb25zID0gZmFsc2U7XG4gICAgICB2YXIgc3R5bGUgPSBjeS5zdHlsZSgpO1xuXG4gICAgICBpZiAocGxhaW5PYmplY3QobmFtZSkpIHtcbiAgICAgICAgLy8gdGhlbiBleHRlbmQgdGhlIGJ5cGFzc1xuICAgICAgICB2YXIgcHJvcHMgPSBuYW1lO1xuICAgICAgICBzdHlsZS5hcHBseUJ5cGFzcyh0aGlzLCBwcm9wcywgdXBkYXRlVHJhbnNpdGlvbnMpO1xuICAgICAgICB0aGlzLmVtaXRBbmROb3RpZnkoJ3N0eWxlJyk7IC8vIGxldCB0aGUgcmVuZGVyZXIga25vdyB3ZSd2ZSB1cGRhdGVkIHN0eWxlXG4gICAgICB9IGVsc2UgaWYgKHN0cmluZyhuYW1lKSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIHRoZW4gZ2V0IHRoZSBwcm9wZXJ0eSBmcm9tIHRoZSBzdHlsZVxuICAgICAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgICAgICAgaWYgKGVsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0eWxlLmdldFN0eWxlUHJvcGVydHlWYWx1ZShlbGUsIG5hbWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBlbXB0eSBjb2xsZWN0aW9uID0+IGNhbid0IGdldCBhbnkgdmFsdWVcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdGhlbiBzZXQgdGhlIGJ5cGFzcyB3aXRoIHRoZSBwcm9wZXJ0eSB2YWx1ZVxuICAgICAgICAgIHN0eWxlLmFwcGx5QnlwYXNzKHRoaXMsIG5hbWUsIHZhbHVlLCB1cGRhdGVUcmFuc2l0aW9ucyk7XG4gICAgICAgICAgdGhpcy5lbWl0QW5kTm90aWZ5KCdzdHlsZScpOyAvLyBsZXQgdGhlIHJlbmRlcmVyIGtub3cgd2UndmUgdXBkYXRlZCBzdHlsZVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgX2VsZSA9IHRoaXNbMF07XG5cbiAgICAgICAgaWYgKF9lbGUpIHtcbiAgICAgICAgICByZXR1cm4gc3R5bGUuZ2V0UmF3U3R5bGUoX2VsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZW1wdHkgY29sbGVjdGlvbiA9PiBjYW4ndCBnZXQgYW55IHZhbHVlXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG4gICAgcmVtb3ZlU3R5bGU6IGZ1bmN0aW9uIHJlbW92ZVN0eWxlKG5hbWVzKSB7XG4gICAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHZhciB1cGRhdGVUcmFuc2l0aW9ucyA9IGZhbHNlO1xuICAgICAgdmFyIHN0eWxlID0gY3kuc3R5bGUoKTtcbiAgICAgIHZhciBlbGVzID0gdGhpcztcblxuICAgICAgaWYgKG5hbWVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICAgICAgc3R5bGUucmVtb3ZlQWxsQnlwYXNzZXMoZWxlLCB1cGRhdGVUcmFuc2l0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5hbWVzID0gbmFtZXMuc3BsaXQoL1xccysvKTtcblxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgZWxlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICB2YXIgX2VsZTIgPSBlbGVzW19pXTtcbiAgICAgICAgICBzdHlsZS5yZW1vdmVCeXBhc3NlcyhfZWxlMiwgbmFtZXMsIHVwZGF0ZVRyYW5zaXRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmVtaXRBbmROb3RpZnkoJ3N0eWxlJyk7IC8vIGxldCB0aGUgcmVuZGVyZXIga25vdyB3ZSd2ZSB1cGRhdGVkIHN0eWxlXG5cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG4gICAgc2hvdzogZnVuY3Rpb24gc2hvdygpIHtcbiAgICAgIHRoaXMuY3NzKCdkaXNwbGF5JywgJ2VsZW1lbnQnKTtcbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG4gICAgaGlkZTogZnVuY3Rpb24gaGlkZSgpIHtcbiAgICAgIHRoaXMuY3NzKCdkaXNwbGF5JywgJ25vbmUnKTtcbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG4gICAgZWZmZWN0aXZlT3BhY2l0eTogZnVuY3Rpb24gZWZmZWN0aXZlT3BhY2l0eSgpIHtcbiAgICAgIHZhciBjeSA9IHRoaXMuY3koKTtcblxuICAgICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cblxuICAgICAgdmFyIGhhc0NvbXBvdW5kTm9kZXMgPSBjeS5oYXNDb21wb3VuZE5vZGVzKCk7XG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgICAgaWYgKGVsZSkge1xuICAgICAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgICAgIHZhciBwYXJlbnRPcGFjaXR5ID0gZWxlLnBzdHlsZSgnb3BhY2l0eScpLnZhbHVlO1xuXG4gICAgICAgIGlmICghaGFzQ29tcG91bmROb2Rlcykge1xuICAgICAgICAgIHJldHVybiBwYXJlbnRPcGFjaXR5O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBhcmVudHMgPSAhX3AuZGF0YS5wYXJlbnQgPyBudWxsIDogZWxlLnBhcmVudHMoKTtcblxuICAgICAgICBpZiAocGFyZW50cykge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IHBhcmVudHNbaV07XG4gICAgICAgICAgICB2YXIgb3BhY2l0eSA9IHBhcmVudC5wc3R5bGUoJ29wYWNpdHknKS52YWx1ZTtcbiAgICAgICAgICAgIHBhcmVudE9wYWNpdHkgPSBvcGFjaXR5ICogcGFyZW50T3BhY2l0eTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFyZW50T3BhY2l0eTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHRyYW5zcGFyZW50OiBmdW5jdGlvbiB0cmFuc3BhcmVudCgpIHtcbiAgICAgIHZhciBjeSA9IHRoaXMuY3koKTtcblxuICAgICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgICAgdmFyIGhhc0NvbXBvdW5kTm9kZXMgPSBlbGUuY3koKS5oYXNDb21wb3VuZE5vZGVzKCk7XG5cbiAgICAgIGlmIChlbGUpIHtcbiAgICAgICAgaWYgKCFoYXNDb21wb3VuZE5vZGVzKSB7XG4gICAgICAgICAgcmV0dXJuIGVsZS5wc3R5bGUoJ29wYWNpdHknKS52YWx1ZSA9PT0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZWxlLmVmZmVjdGl2ZU9wYWNpdHkoKSA9PT0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgYmFja2dyb3VuZGluZzogZnVuY3Rpb24gYmFja2dyb3VuZGluZygpIHtcbiAgICAgIHZhciBjeSA9IHRoaXMuY3koKTtcblxuICAgICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgICAgcmV0dXJuIGVsZS5fcHJpdmF0ZS5iYWNrZ3JvdW5kaW5nID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBjaGVja0NvbXBvdW5kKGVsZSwgcGFyZW50T2spIHtcbiAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgdmFyIHBhcmVudHMgPSBfcC5kYXRhLnBhcmVudCA/IGVsZS5wYXJlbnRzKCkgOiBudWxsO1xuXG4gICAgaWYgKHBhcmVudHMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcGFyZW50ID0gcGFyZW50c1tpXTtcblxuICAgICAgICBpZiAoIXBhcmVudE9rKHBhcmVudCkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZmluZURlcml2ZWRTdGF0ZUZ1bmN0aW9uKHNwZWNzKSB7XG4gICAgdmFyIG9rID0gc3BlY3Mub2s7XG4gICAgdmFyIGVkZ2VPa1ZpYU5vZGUgPSBzcGVjcy5lZGdlT2tWaWFOb2RlIHx8IHNwZWNzLm9rO1xuICAgIHZhciBwYXJlbnRPayA9IHNwZWNzLnBhcmVudE9rIHx8IHNwZWNzLm9rO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgICAgdmFyIGhhc0NvbXBvdW5kTm9kZXMgPSBjeS5oYXNDb21wb3VuZE5vZGVzKCk7XG5cbiAgICAgIGlmIChlbGUpIHtcbiAgICAgICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuXG4gICAgICAgIGlmICghb2soZWxlKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbGUuaXNOb2RlKCkpIHtcbiAgICAgICAgICByZXR1cm4gIWhhc0NvbXBvdW5kTm9kZXMgfHwgY2hlY2tDb21wb3VuZChlbGUsIHBhcmVudE9rKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgc3JjID0gX3Auc291cmNlO1xuICAgICAgICAgIHZhciB0Z3QgPSBfcC50YXJnZXQ7XG4gICAgICAgICAgcmV0dXJuIGVkZ2VPa1ZpYU5vZGUoc3JjKSAmJiAoIWhhc0NvbXBvdW5kTm9kZXMgfHwgY2hlY2tDb21wb3VuZChzcmMsIGVkZ2VPa1ZpYU5vZGUpKSAmJiAoc3JjID09PSB0Z3QgfHwgZWRnZU9rVmlhTm9kZSh0Z3QpICYmICghaGFzQ29tcG91bmROb2RlcyB8fCBjaGVja0NvbXBvdW5kKHRndCwgZWRnZU9rVmlhTm9kZSkpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICB2YXIgZWxlVGFrZXNVcFNwYWNlID0gY2FjaGVTdHlsZUZ1bmN0aW9uKCdlbGVUYWtlc1VwU3BhY2UnLCBmdW5jdGlvbiAoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5wc3R5bGUoJ2Rpc3BsYXknKS52YWx1ZSA9PT0gJ2VsZW1lbnQnICYmIGVsZS53aWR0aCgpICE9PSAwICYmIChlbGUuaXNOb2RlKCkgPyBlbGUuaGVpZ2h0KCkgIT09IDAgOiB0cnVlKTtcbiAgfSk7XG4gIGVsZXNmbiQ0LnRha2VzVXBTcGFjZSA9IGNhY2hlUHJvdG90eXBlU3R5bGVGdW5jdGlvbigndGFrZXNVcFNwYWNlJywgZGVmaW5lRGVyaXZlZFN0YXRlRnVuY3Rpb24oe1xuICAgIG9rOiBlbGVUYWtlc1VwU3BhY2VcbiAgfSkpO1xuICB2YXIgZWxlSW50ZXJhY3RpdmUgPSBjYWNoZVN0eWxlRnVuY3Rpb24oJ2VsZUludGVyYWN0aXZlJywgZnVuY3Rpb24gKGVsZSkge1xuICAgIHJldHVybiBlbGUucHN0eWxlKCdldmVudHMnKS52YWx1ZSA9PT0gJ3llcycgJiYgZWxlLnBzdHlsZSgndmlzaWJpbGl0eScpLnZhbHVlID09PSAndmlzaWJsZScgJiYgZWxlVGFrZXNVcFNwYWNlKGVsZSk7XG4gIH0pO1xuICB2YXIgcGFyZW50SW50ZXJhY3RpdmUgPSBjYWNoZVN0eWxlRnVuY3Rpb24oJ3BhcmVudEludGVyYWN0aXZlJywgZnVuY3Rpb24gKHBhcmVudCkge1xuICAgIHJldHVybiBwYXJlbnQucHN0eWxlKCd2aXNpYmlsaXR5JykudmFsdWUgPT09ICd2aXNpYmxlJyAmJiBlbGVUYWtlc1VwU3BhY2UocGFyZW50KTtcbiAgfSk7XG4gIGVsZXNmbiQ0LmludGVyYWN0aXZlID0gY2FjaGVQcm90b3R5cGVTdHlsZUZ1bmN0aW9uKCdpbnRlcmFjdGl2ZScsIGRlZmluZURlcml2ZWRTdGF0ZUZ1bmN0aW9uKHtcbiAgICBvazogZWxlSW50ZXJhY3RpdmUsXG4gICAgcGFyZW50T2s6IHBhcmVudEludGVyYWN0aXZlLFxuICAgIGVkZ2VPa1ZpYU5vZGU6IGVsZVRha2VzVXBTcGFjZVxuICB9KSk7XG5cbiAgZWxlc2ZuJDQubm9uaW50ZXJhY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICBpZiAoZWxlKSB7XG4gICAgICByZXR1cm4gIWVsZS5pbnRlcmFjdGl2ZSgpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgZWxlVmlzaWJsZSA9IGNhY2hlU3R5bGVGdW5jdGlvbignZWxlVmlzaWJsZScsIGZ1bmN0aW9uIChlbGUpIHtcbiAgICByZXR1cm4gZWxlLnBzdHlsZSgndmlzaWJpbGl0eScpLnZhbHVlID09PSAndmlzaWJsZScgJiYgZWxlLnBzdHlsZSgnb3BhY2l0eScpLnBmVmFsdWUgIT09IDAgJiYgZWxlVGFrZXNVcFNwYWNlKGVsZSk7XG4gIH0pO1xuICB2YXIgZWRnZVZpc2libGVWaWFOb2RlID0gZWxlVGFrZXNVcFNwYWNlO1xuICBlbGVzZm4kNC52aXNpYmxlID0gY2FjaGVQcm90b3R5cGVTdHlsZUZ1bmN0aW9uKCd2aXNpYmxlJywgZGVmaW5lRGVyaXZlZFN0YXRlRnVuY3Rpb24oe1xuICAgIG9rOiBlbGVWaXNpYmxlLFxuICAgIGVkZ2VPa1ZpYU5vZGU6IGVkZ2VWaXNpYmxlVmlhTm9kZVxuICB9KSk7XG5cbiAgZWxlc2ZuJDQuaGlkZGVuID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgaWYgKGVsZSkge1xuICAgICAgcmV0dXJuICFlbGUudmlzaWJsZSgpO1xuICAgIH1cbiAgfTtcblxuICBlbGVzZm4kNC5pc0J1bmRsZWRCZXppZXIgPSBjYWNoZVByb3RvdHlwZVN0eWxlRnVuY3Rpb24oJ2lzQnVuZGxlZEJlemllcicsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuY3koKS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiAhdGhpcy5yZW1vdmVkKCkgJiYgdGhpcy5wc3R5bGUoJ2N1cnZlLXN0eWxlJykudmFsdWUgPT09ICdiZXppZXInICYmIHRoaXMudGFrZXNVcFNwYWNlKCk7XG4gIH0pO1xuICBlbGVzZm4kNC5ieXBhc3MgPSBlbGVzZm4kNC5jc3MgPSBlbGVzZm4kNC5zdHlsZTtcbiAgZWxlc2ZuJDQucmVuZGVyZWRDc3MgPSBlbGVzZm4kNC5yZW5kZXJlZFN0eWxlO1xuICBlbGVzZm4kNC5yZW1vdmVCeXBhc3MgPSBlbGVzZm4kNC5yZW1vdmVDc3MgPSBlbGVzZm4kNC5yZW1vdmVTdHlsZTtcbiAgZWxlc2ZuJDQucHN0eWxlID0gZWxlc2ZuJDQucGFyc2VkU3R5bGU7XG5cbiAgdmFyIGVsZXNmbiQzID0ge307XG5cbiAgZnVuY3Rpb24gZGVmaW5lU3dpdGNoRnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgdmFyIGNoYW5nZWRFbGVzID0gW107IC8vIGUuZy4gY3kubm9kZXMoKS5zZWxlY3QoIGRhdGEsIGhhbmRsZXIgKVxuXG4gICAgICBpZiAoYXJncy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBhcmdzWzBdO1xuICAgICAgICB2YXIgaGFuZGxlciA9IGFyZ3NbMV07XG4gICAgICAgIHRoaXMub24ocGFyYW1zLmV2ZW50LCBkYXRhLCBoYW5kbGVyKTtcbiAgICAgIH0gLy8gZS5nLiBjeS5ub2RlcygpLnNlbGVjdCggaGFuZGxlciApXG4gICAgICBlbHNlIGlmIChhcmdzLmxlbmd0aCA9PT0gMSAmJiBmbiQ2KGFyZ3NbMF0pKSB7XG4gICAgICAgIHZhciBfaGFuZGxlciA9IGFyZ3NbMF07XG4gICAgICAgIHRoaXMub24ocGFyYW1zLmV2ZW50LCBfaGFuZGxlcik7XG4gICAgICB9IC8vIGUuZy4gY3kubm9kZXMoKS5zZWxlY3QoKVxuICAgICAgLy8gZS5nLiAocHJpdmF0ZSkgY3kubm9kZXMoKS5zZWxlY3QoWyd0YXBzZWxlY3QnXSlcbiAgICAgIGVsc2UgaWYgKGFyZ3MubGVuZ3RoID09PSAwIHx8IGFyZ3MubGVuZ3RoID09PSAxICYmIGFycmF5KGFyZ3NbMF0pKSB7XG4gICAgICAgIHZhciBhZGRsRXZlbnRzID0gYXJncy5sZW5ndGggPT09IDEgPyBhcmdzWzBdIDogbnVsbDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgICAgICB2YXIgYWJsZSA9ICFwYXJhbXMuYWJsZUZpZWxkIHx8IGVsZS5fcHJpdmF0ZVtwYXJhbXMuYWJsZUZpZWxkXTtcbiAgICAgICAgICB2YXIgY2hhbmdlZCA9IGVsZS5fcHJpdmF0ZVtwYXJhbXMuZmllbGRdICE9IHBhcmFtcy52YWx1ZTtcblxuICAgICAgICAgIGlmIChwYXJhbXMub3ZlcnJpZGVBYmxlKSB7XG4gICAgICAgICAgICB2YXIgb3ZlcnJpZGVBYmxlID0gcGFyYW1zLm92ZXJyaWRlQWJsZShlbGUpO1xuXG4gICAgICAgICAgICBpZiAob3ZlcnJpZGVBYmxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgYWJsZSA9IG92ZXJyaWRlQWJsZTtcblxuICAgICAgICAgICAgICBpZiAoIW92ZXJyaWRlQWJsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICB9IC8vIHRvIHNhdmUgY3ljbGVzIGFzc3VtZSBub3QgYWJsZSBmb3IgYWxsIG9uIG92ZXJyaWRlXG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYWJsZSkge1xuICAgICAgICAgICAgZWxlLl9wcml2YXRlW3BhcmFtcy5maWVsZF0gPSBwYXJhbXMudmFsdWU7XG5cbiAgICAgICAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgICAgICAgIGNoYW5nZWRFbGVzLnB1c2goZWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2hhbmdlZENvbGwgPSB0aGlzLnNwYXduKGNoYW5nZWRFbGVzKTtcbiAgICAgICAgY2hhbmdlZENvbGwudXBkYXRlU3R5bGUoKTsgLy8gY2hhbmdlIG9mIHN0YXRlID0+IHBvc3NpYmxlIGNoYW5nZSBvZiBzdHlsZVxuXG4gICAgICAgIGNoYW5nZWRDb2xsLmVtaXQocGFyYW1zLmV2ZW50KTtcblxuICAgICAgICBpZiAoYWRkbEV2ZW50cykge1xuICAgICAgICAgIGNoYW5nZWRDb2xsLmVtaXQoYWRkbEV2ZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZmluZVN3aXRjaFNldChwYXJhbXMpIHtcbiAgICBlbGVzZm4kM1twYXJhbXMuZmllbGRdID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICAgIGlmIChlbGUpIHtcbiAgICAgICAgaWYgKHBhcmFtcy5vdmVycmlkZUZpZWxkKSB7XG4gICAgICAgICAgdmFyIHZhbCA9IHBhcmFtcy5vdmVycmlkZUZpZWxkKGVsZSk7XG5cbiAgICAgICAgICBpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVsZS5fcHJpdmF0ZVtwYXJhbXMuZmllbGRdO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBlbGVzZm4kM1twYXJhbXMub25dID0gZGVmaW5lU3dpdGNoRnVuY3Rpb24oe1xuICAgICAgZXZlbnQ6IHBhcmFtcy5vbixcbiAgICAgIGZpZWxkOiBwYXJhbXMuZmllbGQsXG4gICAgICBhYmxlRmllbGQ6IHBhcmFtcy5hYmxlRmllbGQsXG4gICAgICBvdmVycmlkZUFibGU6IHBhcmFtcy5vdmVycmlkZUFibGUsXG4gICAgICB2YWx1ZTogdHJ1ZVxuICAgIH0pO1xuICAgIGVsZXNmbiQzW3BhcmFtcy5vZmZdID0gZGVmaW5lU3dpdGNoRnVuY3Rpb24oe1xuICAgICAgZXZlbnQ6IHBhcmFtcy5vZmYsXG4gICAgICBmaWVsZDogcGFyYW1zLmZpZWxkLFxuICAgICAgYWJsZUZpZWxkOiBwYXJhbXMuYWJsZUZpZWxkLFxuICAgICAgb3ZlcnJpZGVBYmxlOiBwYXJhbXMub3ZlcnJpZGVBYmxlLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSk7XG4gIH1cblxuICBkZWZpbmVTd2l0Y2hTZXQoe1xuICAgIGZpZWxkOiAnbG9ja2VkJyxcbiAgICBvdmVycmlkZUZpZWxkOiBmdW5jdGlvbiBvdmVycmlkZUZpZWxkKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5jeSgpLmF1dG9sb2NrKCkgPyB0cnVlIDogdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgb246ICdsb2NrJyxcbiAgICBvZmY6ICd1bmxvY2snXG4gIH0pO1xuICBkZWZpbmVTd2l0Y2hTZXQoe1xuICAgIGZpZWxkOiAnZ3JhYmJhYmxlJyxcbiAgICBvdmVycmlkZUZpZWxkOiBmdW5jdGlvbiBvdmVycmlkZUZpZWxkKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5jeSgpLmF1dG91bmdyYWJpZnkoKSB8fCBlbGUucGFubmFibGUoKSA/IGZhbHNlIDogdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgb246ICdncmFiaWZ5JyxcbiAgICBvZmY6ICd1bmdyYWJpZnknXG4gIH0pO1xuICBkZWZpbmVTd2l0Y2hTZXQoe1xuICAgIGZpZWxkOiAnc2VsZWN0ZWQnLFxuICAgIGFibGVGaWVsZDogJ3NlbGVjdGFibGUnLFxuICAgIG92ZXJyaWRlQWJsZTogZnVuY3Rpb24gb3ZlcnJpZGVBYmxlKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5jeSgpLmF1dG91bnNlbGVjdGlmeSgpID8gZmFsc2UgOiB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBvbjogJ3NlbGVjdCcsXG4gICAgb2ZmOiAndW5zZWxlY3QnXG4gIH0pO1xuICBkZWZpbmVTd2l0Y2hTZXQoe1xuICAgIGZpZWxkOiAnc2VsZWN0YWJsZScsXG4gICAgb3ZlcnJpZGVGaWVsZDogZnVuY3Rpb24gb3ZlcnJpZGVGaWVsZChlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuY3koKS5hdXRvdW5zZWxlY3RpZnkoKSA/IGZhbHNlIDogdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgb246ICdzZWxlY3RpZnknLFxuICAgIG9mZjogJ3Vuc2VsZWN0aWZ5J1xuICB9KTtcbiAgZWxlc2ZuJDMuZGVzZWxlY3QgPSBlbGVzZm4kMy51bnNlbGVjdDtcblxuICBlbGVzZm4kMy5ncmFiYmVkID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgaWYgKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5fcHJpdmF0ZS5ncmFiYmVkO1xuICAgIH1cbiAgfTtcblxuICBkZWZpbmVTd2l0Y2hTZXQoe1xuICAgIGZpZWxkOiAnYWN0aXZlJyxcbiAgICBvbjogJ2FjdGl2YXRlJyxcbiAgICBvZmY6ICd1bmFjdGl2YXRlJ1xuICB9KTtcbiAgZGVmaW5lU3dpdGNoU2V0KHtcbiAgICBmaWVsZDogJ3Bhbm5hYmxlJyxcbiAgICBvbjogJ3BhbmlmeScsXG4gICAgb2ZmOiAndW5wYW5pZnknXG4gIH0pO1xuXG4gIGVsZXNmbiQzLmluYWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgaWYgKGVsZSkge1xuICAgICAgcmV0dXJuICFlbGUuX3ByaXZhdGUuYWN0aXZlO1xuICAgIH1cbiAgfTtcblxuICB2YXIgZWxlc2ZuJDIgPSB7fTsgLy8gREFHIGZ1bmN0aW9uc1xuICAvLy8vLy8vLy8vLy8vLy8vXG5cbiAgdmFyIGRlZmluZURhZ0V4dHJlbWl0eSA9IGZ1bmN0aW9uIGRlZmluZURhZ0V4dHJlbWl0eShwYXJhbXMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gZGFnRXh0cmVtaXR5SW1wbChzZWxlY3Rvcikge1xuICAgICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgICAgdmFyIHJldCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG5cbiAgICAgICAgaWYgKCFlbGUuaXNOb2RlKCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkaXNxdWFsaWZpZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGVkZ2VzID0gZWxlLmNvbm5lY3RlZEVkZ2VzKCk7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBlZGdlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHZhciBlZGdlID0gZWRnZXNbal07XG4gICAgICAgICAgdmFyIHNyYyA9IGVkZ2Uuc291cmNlKCk7XG4gICAgICAgICAgdmFyIHRndCA9IGVkZ2UudGFyZ2V0KCk7XG5cbiAgICAgICAgICBpZiAocGFyYW1zLm5vSW5jb21pbmdFZGdlcyAmJiB0Z3QgPT09IGVsZSAmJiBzcmMgIT09IGVsZSB8fCBwYXJhbXMubm9PdXRnb2luZ0VkZ2VzICYmIHNyYyA9PT0gZWxlICYmIHRndCAhPT0gZWxlKSB7XG4gICAgICAgICAgICBkaXNxdWFsaWZpZWQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFkaXNxdWFsaWZpZWQpIHtcbiAgICAgICAgICByZXQucHVzaChlbGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnNwYXduKHJldCwgdHJ1ZSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBkZWZpbmVEYWdPbmVIb3AgPSBmdW5jdGlvbiBkZWZpbmVEYWdPbmVIb3AocGFyYW1zKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgICAgdmFyIG9FbGVzID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcblxuICAgICAgICBpZiAoIWVsZS5pc05vZGUoKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVkZ2VzID0gZWxlLmNvbm5lY3RlZEVkZ2VzKCk7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBlZGdlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHZhciBlZGdlID0gZWRnZXNbal07XG4gICAgICAgICAgdmFyIHNyYyA9IGVkZ2Uuc291cmNlKCk7XG4gICAgICAgICAgdmFyIHRndCA9IGVkZ2UudGFyZ2V0KCk7XG5cbiAgICAgICAgICBpZiAocGFyYW1zLm91dGdvaW5nICYmIHNyYyA9PT0gZWxlKSB7XG4gICAgICAgICAgICBvRWxlcy5wdXNoKGVkZ2UpO1xuICAgICAgICAgICAgb0VsZXMucHVzaCh0Z3QpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocGFyYW1zLmluY29taW5nICYmIHRndCA9PT0gZWxlKSB7XG4gICAgICAgICAgICBvRWxlcy5wdXNoKGVkZ2UpO1xuICAgICAgICAgICAgb0VsZXMucHVzaChzcmMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5zcGF3bihvRWxlcywgdHJ1ZSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBkZWZpbmVEYWdBbGxIb3BzID0gZnVuY3Rpb24gZGVmaW5lRGFnQWxsSG9wcyhwYXJhbXMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgICB2YXIgc0VsZXMgPSBbXTtcbiAgICAgIHZhciBzRWxlc0lkcyA9IHt9O1xuXG4gICAgICBmb3IgKDs7KSB7XG4gICAgICAgIHZhciBuZXh0ID0gcGFyYW1zLm91dGdvaW5nID8gZWxlcy5vdXRnb2VycygpIDogZWxlcy5pbmNvbWVycygpO1xuXG4gICAgICAgIGlmIChuZXh0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IC8vIGRvbmUgaWYgbm9uZSBsZWZ0XG5cblxuICAgICAgICB2YXIgbmV3TmV4dCA9IGZhbHNlO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBuID0gbmV4dFtpXTtcbiAgICAgICAgICB2YXIgbmlkID0gbi5pZCgpO1xuXG4gICAgICAgICAgaWYgKCFzRWxlc0lkc1tuaWRdKSB7XG4gICAgICAgICAgICBzRWxlc0lkc1tuaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgIHNFbGVzLnB1c2gobik7XG4gICAgICAgICAgICBuZXdOZXh0ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW5ld05leHQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSAvLyBkb25lIGlmIHRvdWNoZWQgYWxsIG91dGdvZXJzIGFscmVhZHlcblxuXG4gICAgICAgIGVsZXMgPSBuZXh0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5zcGF3bihzRWxlcywgdHJ1ZSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgICB9O1xuICB9O1xuXG4gIGVsZXNmbiQyLmNsZWFyVHJhdmVyc2FsQ2FjaGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzW2ldLl9wcml2YXRlLnRyYXZlcnNhbENhY2hlID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgZXh0ZW5kKGVsZXNmbiQyLCB7XG4gICAgLy8gZ2V0IHRoZSByb290IG5vZGVzIGluIHRoZSBEQUdcbiAgICByb290czogZGVmaW5lRGFnRXh0cmVtaXR5KHtcbiAgICAgIG5vSW5jb21pbmdFZGdlczogdHJ1ZVxuICAgIH0pLFxuICAgIC8vIGdldCB0aGUgbGVhZiBub2RlcyBpbiB0aGUgREFHXG4gICAgbGVhdmVzOiBkZWZpbmVEYWdFeHRyZW1pdHkoe1xuICAgICAgbm9PdXRnb2luZ0VkZ2VzOiB0cnVlXG4gICAgfSksXG4gICAgLy8gbm9ybWFsbHkgY2FsbGVkIGNoaWxkcmVuIGluIGdyYXBoIHRoZW9yeVxuICAgIC8vIHRoZXNlIG5vZGVzID1lZGdlcz0+IG91dGdvaW5nIG5vZGVzXG4gICAgb3V0Z29lcnM6IGNhY2hlKGRlZmluZURhZ09uZUhvcCh7XG4gICAgICBvdXRnb2luZzogdHJ1ZVxuICAgIH0pLCAnb3V0Z29lcnMnKSxcbiAgICAvLyBha2EgREFHIGRlc2NlbmRhbnRzXG4gICAgc3VjY2Vzc29yczogZGVmaW5lRGFnQWxsSG9wcyh7XG4gICAgICBvdXRnb2luZzogdHJ1ZVxuICAgIH0pLFxuICAgIC8vIG5vcm1hbGx5IGNhbGxlZCBwYXJlbnRzIGluIGdyYXBoIHRoZW9yeVxuICAgIC8vIHRoZXNlIG5vZGVzIDw9ZWRnZXM9IGluY29taW5nIG5vZGVzXG4gICAgaW5jb21lcnM6IGNhY2hlKGRlZmluZURhZ09uZUhvcCh7XG4gICAgICBpbmNvbWluZzogdHJ1ZVxuICAgIH0pLCAnaW5jb21lcnMnKSxcbiAgICAvLyBha2EgREFHIGFuY2VzdG9yc1xuICAgIHByZWRlY2Vzc29yczogZGVmaW5lRGFnQWxsSG9wcyh7XG4gICAgICBpbmNvbWluZzogdHJ1ZVxuICAgIH0pXG4gIH0pOyAvLyBOZWlnaGJvdXJob29kIGZ1bmN0aW9uc1xuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gIGV4dGVuZChlbGVzZm4kMiwge1xuICAgIG5laWdoYm9yaG9vZDogY2FjaGUoZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICB2YXIgZWxlbWVudHMgPSBbXTtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBmb3IgYWxsIG5vZGVzXG4gICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIHZhciBjb25uZWN0ZWRFZGdlcyA9IG5vZGUuY29ubmVjdGVkRWRnZXMoKTsgLy8gZm9yIGVhY2ggY29ubmVjdGVkIGVkZ2UsIGFkZCB0aGUgZWRnZSBhbmQgdGhlIG90aGVyIG5vZGVcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvbm5lY3RlZEVkZ2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdmFyIGVkZ2UgPSBjb25uZWN0ZWRFZGdlc1tqXTtcbiAgICAgICAgICB2YXIgc3JjID0gZWRnZS5zb3VyY2UoKTtcbiAgICAgICAgICB2YXIgdGd0ID0gZWRnZS50YXJnZXQoKTtcbiAgICAgICAgICB2YXIgb3RoZXJOb2RlID0gbm9kZSA9PT0gc3JjID8gdGd0IDogc3JjOyAvLyBuZWVkIGNoZWNrIGluIGNhc2Ugb2YgbG9vcFxuXG4gICAgICAgICAgaWYgKG90aGVyTm9kZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBlbGVtZW50cy5wdXNoKG90aGVyTm9kZVswXSk7IC8vIGFkZCBub2RlIDEgaG9wIGF3YXlcbiAgICAgICAgICB9IC8vIGFkZCBjb25uZWN0ZWQgZWRnZVxuXG5cbiAgICAgICAgICBlbGVtZW50cy5wdXNoKGVkZ2VbMF0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnNwYXduKGVsZW1lbnRzLCB0cnVlKS5maWx0ZXIoc2VsZWN0b3IpO1xuICAgIH0sICduZWlnaGJvcmhvb2QnKSxcbiAgICBjbG9zZWROZWlnaGJvcmhvb2Q6IGZ1bmN0aW9uIGNsb3NlZE5laWdoYm9yaG9vZChzZWxlY3Rvcikge1xuICAgICAgcmV0dXJuIHRoaXMubmVpZ2hib3Job29kKCkuYWRkKHRoaXMpLmZpbHRlcihzZWxlY3Rvcik7XG4gICAgfSxcbiAgICBvcGVuTmVpZ2hib3Job29kOiBmdW5jdGlvbiBvcGVuTmVpZ2hib3Job29kKHNlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gdGhpcy5uZWlnaGJvcmhvb2Qoc2VsZWN0b3IpO1xuICAgIH1cbiAgfSk7IC8vIGFsaWFzZXNcblxuICBlbGVzZm4kMi5uZWlnaGJvdXJob29kID0gZWxlc2ZuJDIubmVpZ2hib3Job29kO1xuICBlbGVzZm4kMi5jbG9zZWROZWlnaGJvdXJob29kID0gZWxlc2ZuJDIuY2xvc2VkTmVpZ2hib3Job29kO1xuICBlbGVzZm4kMi5vcGVuTmVpZ2hib3VyaG9vZCA9IGVsZXNmbiQyLm9wZW5OZWlnaGJvcmhvb2Q7IC8vIEVkZ2UgZnVuY3Rpb25zXG4gIC8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgZXh0ZW5kKGVsZXNmbiQyLCB7XG4gICAgc291cmNlOiBjYWNoZShmdW5jdGlvbiBzb3VyY2VJbXBsKHNlbGVjdG9yKSB7XG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICAgIHZhciBzcmM7XG5cbiAgICAgIGlmIChlbGUpIHtcbiAgICAgICAgc3JjID0gZWxlLl9wcml2YXRlLnNvdXJjZSB8fCBlbGUuY3koKS5jb2xsZWN0aW9uKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzcmMgJiYgc2VsZWN0b3IgPyBzcmMuZmlsdGVyKHNlbGVjdG9yKSA6IHNyYztcbiAgICB9LCAnc291cmNlJyksXG4gICAgdGFyZ2V0OiBjYWNoZShmdW5jdGlvbiB0YXJnZXRJbXBsKHNlbGVjdG9yKSB7XG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICAgIHZhciB0Z3Q7XG5cbiAgICAgIGlmIChlbGUpIHtcbiAgICAgICAgdGd0ID0gZWxlLl9wcml2YXRlLnRhcmdldCB8fCBlbGUuY3koKS5jb2xsZWN0aW9uKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0Z3QgJiYgc2VsZWN0b3IgPyB0Z3QuZmlsdGVyKHNlbGVjdG9yKSA6IHRndDtcbiAgICB9LCAndGFyZ2V0JyksXG4gICAgc291cmNlczogZGVmaW5lU291cmNlRnVuY3Rpb24oe1xuICAgICAgYXR0cjogJ3NvdXJjZSdcbiAgICB9KSxcbiAgICB0YXJnZXRzOiBkZWZpbmVTb3VyY2VGdW5jdGlvbih7XG4gICAgICBhdHRyOiAndGFyZ2V0J1xuICAgIH0pXG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGRlZmluZVNvdXJjZUZ1bmN0aW9uKHBhcmFtcykge1xuICAgIHJldHVybiBmdW5jdGlvbiBzb3VyY2VJbXBsKHNlbGVjdG9yKSB7XG4gICAgICB2YXIgc291cmNlcyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICAgIHZhciBzcmMgPSBlbGUuX3ByaXZhdGVbcGFyYW1zLmF0dHJdO1xuXG4gICAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgICBzb3VyY2VzLnB1c2goc3JjKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5zcGF3bihzb3VyY2VzLCB0cnVlKS5maWx0ZXIoc2VsZWN0b3IpO1xuICAgIH07XG4gIH1cblxuICBleHRlbmQoZWxlc2ZuJDIsIHtcbiAgICBlZGdlc1dpdGg6IGNhY2hlKGRlZmluZUVkZ2VzV2l0aEZ1bmN0aW9uKCksICdlZGdlc1dpdGgnKSxcbiAgICBlZGdlc1RvOiBjYWNoZShkZWZpbmVFZGdlc1dpdGhGdW5jdGlvbih7XG4gICAgICB0aGlzSXNTcmM6IHRydWVcbiAgICB9KSwgJ2VkZ2VzVG8nKVxuICB9KTtcblxuICBmdW5jdGlvbiBkZWZpbmVFZGdlc1dpdGhGdW5jdGlvbihwYXJhbXMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gZWRnZXNXaXRoSW1wbChvdGhlck5vZGVzKSB7XG4gICAgICB2YXIgZWxlbWVudHMgPSBbXTtcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgICB2YXIgcCA9IHBhcmFtcyB8fCB7fTsgLy8gZ2V0IGVsZW1lbnRzIGlmIGEgc2VsZWN0b3IgaXMgc3BlY2lmaWVkXG5cbiAgICAgIGlmIChzdHJpbmcob3RoZXJOb2RlcykpIHtcbiAgICAgICAgb3RoZXJOb2RlcyA9IGN5LiQob3RoZXJOb2Rlcyk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGggPSAwOyBoIDwgb3RoZXJOb2Rlcy5sZW5ndGg7IGgrKykge1xuICAgICAgICB2YXIgZWRnZXMgPSBvdGhlck5vZGVzW2hdLl9wcml2YXRlLmVkZ2VzO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2ldO1xuICAgICAgICAgIHZhciBlZGdlRGF0YSA9IGVkZ2UuX3ByaXZhdGUuZGF0YTtcbiAgICAgICAgICB2YXIgdGhpc1RvT3RoZXIgPSB0aGlzLmhhc0VsZW1lbnRXaXRoSWQoZWRnZURhdGEuc291cmNlKSAmJiBvdGhlck5vZGVzLmhhc0VsZW1lbnRXaXRoSWQoZWRnZURhdGEudGFyZ2V0KTtcbiAgICAgICAgICB2YXIgb3RoZXJUb1RoaXMgPSBvdGhlck5vZGVzLmhhc0VsZW1lbnRXaXRoSWQoZWRnZURhdGEuc291cmNlKSAmJiB0aGlzLmhhc0VsZW1lbnRXaXRoSWQoZWRnZURhdGEudGFyZ2V0KTtcbiAgICAgICAgICB2YXIgZWRnZUNvbm5lY3RzVGhpc0FuZE90aGVyID0gdGhpc1RvT3RoZXIgfHwgb3RoZXJUb1RoaXM7XG5cbiAgICAgICAgICBpZiAoIWVkZ2VDb25uZWN0c1RoaXNBbmRPdGhlcikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHAudGhpc0lzU3JjIHx8IHAudGhpc0lzVGd0KSB7XG4gICAgICAgICAgICBpZiAocC50aGlzSXNTcmMgJiYgIXRoaXNUb090aGVyKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocC50aGlzSXNUZ3QgJiYgIW90aGVyVG9UaGlzKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGVsZW1lbnRzLnB1c2goZWRnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuc3Bhd24oZWxlbWVudHMsIHRydWUpO1xuICAgIH07XG4gIH1cblxuICBleHRlbmQoZWxlc2ZuJDIsIHtcbiAgICBjb25uZWN0ZWRFZGdlczogY2FjaGUoZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICB2YXIgcmV0RWxlcyA9IFtdO1xuICAgICAgdmFyIGVsZXMgPSB0aGlzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSBlbGVzW2ldO1xuXG4gICAgICAgIGlmICghbm9kZS5pc05vZGUoKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVkZ2VzID0gbm9kZS5fcHJpdmF0ZS5lZGdlcztcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGVkZ2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tqXTtcbiAgICAgICAgICByZXRFbGVzLnB1c2goZWRnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuc3Bhd24ocmV0RWxlcywgdHJ1ZSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgICB9LCAnY29ubmVjdGVkRWRnZXMnKSxcbiAgICBjb25uZWN0ZWROb2RlczogY2FjaGUoZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICB2YXIgcmV0RWxlcyA9IFtdO1xuICAgICAgdmFyIGVsZXMgPSB0aGlzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBlbGVzW2ldO1xuXG4gICAgICAgIGlmICghZWRnZS5pc0VkZ2UoKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0RWxlcy5wdXNoKGVkZ2Uuc291cmNlKClbMF0pO1xuICAgICAgICByZXRFbGVzLnB1c2goZWRnZS50YXJnZXQoKVswXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnNwYXduKHJldEVsZXMsIHRydWUpLmZpbHRlcihzZWxlY3Rvcik7XG4gICAgfSwgJ2Nvbm5lY3RlZE5vZGVzJyksXG4gICAgcGFyYWxsZWxFZGdlczogY2FjaGUoZGVmaW5lUGFyYWxsZWxFZGdlc0Z1bmN0aW9uKCksICdwYXJhbGxlbEVkZ2VzJyksXG4gICAgY29kaXJlY3RlZEVkZ2VzOiBjYWNoZShkZWZpbmVQYXJhbGxlbEVkZ2VzRnVuY3Rpb24oe1xuICAgICAgY29kaXJlY3RlZDogdHJ1ZVxuICAgIH0pLCAnY29kaXJlY3RlZEVkZ2VzJylcbiAgfSk7XG5cbiAgZnVuY3Rpb24gZGVmaW5lUGFyYWxsZWxFZGdlc0Z1bmN0aW9uKHBhcmFtcykge1xuICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICAgIGNvZGlyZWN0ZWQ6IGZhbHNlXG4gICAgfTtcbiAgICBwYXJhbXMgPSBleHRlbmQoe30sIGRlZmF1bHRzLCBwYXJhbXMpO1xuICAgIHJldHVybiBmdW5jdGlvbiBwYXJhbGxlbEVkZ2VzSW1wbChzZWxlY3Rvcikge1xuICAgICAgLy8gbWljcm8tb3B0aW1pc2VkIGZvciByZW5kZXJlclxuICAgICAgdmFyIGVsZW1lbnRzID0gW107XG4gICAgICB2YXIgZWRnZXMgPSB0aGlzLmVkZ2VzKCk7XG4gICAgICB2YXIgcCA9IHBhcmFtczsgLy8gbG9vayBhdCBhbGwgdGhlIGVkZ2VzIGluIHRoZSBjb2xsZWN0aW9uXG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVkZ2UxID0gZWRnZXNbaV07XG4gICAgICAgIHZhciBlZGdlMV9wID0gZWRnZTEuX3ByaXZhdGU7XG4gICAgICAgIHZhciBzcmMxID0gZWRnZTFfcC5zb3VyY2U7XG4gICAgICAgIHZhciBzcmNpZDEgPSBzcmMxLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgICAgIHZhciB0Z3RpZDEgPSBlZGdlMV9wLmRhdGEudGFyZ2V0O1xuICAgICAgICB2YXIgc3JjRWRnZXMxID0gc3JjMS5fcHJpdmF0ZS5lZGdlczsgLy8gbG9vayBhdCBlZGdlcyBjb25uZWN0ZWQgdG8gdGhlIHNyYyBub2RlIG9mIHRoaXMgZWRnZVxuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3JjRWRnZXMxLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdmFyIGVkZ2UyID0gc3JjRWRnZXMxW2pdO1xuICAgICAgICAgIHZhciBlZGdlMmRhdGEgPSBlZGdlMi5fcHJpdmF0ZS5kYXRhO1xuICAgICAgICAgIHZhciB0Z3RpZDIgPSBlZGdlMmRhdGEudGFyZ2V0O1xuICAgICAgICAgIHZhciBzcmNpZDIgPSBlZGdlMmRhdGEuc291cmNlO1xuICAgICAgICAgIHZhciBjb2RpcmVjdGVkID0gdGd0aWQyID09PSB0Z3RpZDEgJiYgc3JjaWQyID09PSBzcmNpZDE7XG4gICAgICAgICAgdmFyIG9wcGRpcmVjdGVkID0gc3JjaWQxID09PSB0Z3RpZDIgJiYgdGd0aWQxID09PSBzcmNpZDI7XG5cbiAgICAgICAgICBpZiAocC5jb2RpcmVjdGVkICYmIGNvZGlyZWN0ZWQgfHwgIXAuY29kaXJlY3RlZCAmJiAoY29kaXJlY3RlZCB8fCBvcHBkaXJlY3RlZCkpIHtcbiAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goZWRnZTIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5zcGF3bihlbGVtZW50cywgdHJ1ZSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgICB9O1xuICB9IC8vIE1pc2MgZnVuY3Rpb25zXG4gIC8vLy8vLy8vLy8vLy8vLy8vXG5cblxuICBleHRlbmQoZWxlc2ZuJDIsIHtcbiAgICBjb21wb25lbnRzOiBmdW5jdGlvbiBjb21wb25lbnRzKHJvb3QpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBjeSA9IHNlbGYuY3koKTtcbiAgICAgIHZhciB2aXNpdGVkID0gY3kuY29sbGVjdGlvbigpO1xuICAgICAgdmFyIHVudmlzaXRlZCA9IHJvb3QgPT0gbnVsbCA/IHNlbGYubm9kZXMoKSA6IHJvb3Qubm9kZXMoKTtcbiAgICAgIHZhciBjb21wb25lbnRzID0gW107XG5cbiAgICAgIGlmIChyb290ICE9IG51bGwgJiYgdW52aXNpdGVkLmVtcHR5KCkpIHtcbiAgICAgICAgLy8gcm9vdCBtYXkgY29udGFpbiBvbmx5IGVkZ2VzXG4gICAgICAgIHVudmlzaXRlZCA9IHJvb3Quc291cmNlcygpOyAvLyBkb2Vzbid0IG1hdHRlciB3aGljaCBub2RlIHRvIHVzZSAodW5kaXJlY3RlZCksIHNvIGp1c3QgdXNlIHRoZSBzb3VyY2Ugc2lkZXNcbiAgICAgIH1cblxuICAgICAgdmFyIHZpc2l0SW5Db21wb25lbnQgPSBmdW5jdGlvbiB2aXNpdEluQ29tcG9uZW50KG5vZGUsIGNvbXBvbmVudCkge1xuICAgICAgICB2aXNpdGVkLm1lcmdlKG5vZGUpO1xuICAgICAgICB1bnZpc2l0ZWQudW5tZXJnZShub2RlKTtcbiAgICAgICAgY29tcG9uZW50Lm1lcmdlKG5vZGUpO1xuICAgICAgfTtcblxuICAgICAgaWYgKHVudmlzaXRlZC5lbXB0eSgpKSB7XG4gICAgICAgIHJldHVybiBzZWxmLnNwYXduKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKCkge1xuICAgICAgICAvLyBlYWNoIGl0ZXJhdGlvbiB5aWVsZHMgYSBjb21wb25lbnRcbiAgICAgICAgdmFyIGNtcHQgPSBjeS5jb2xsZWN0aW9uKCk7XG4gICAgICAgIGNvbXBvbmVudHMucHVzaChjbXB0KTtcbiAgICAgICAgdmFyIHJvb3QgPSB1bnZpc2l0ZWRbMF07XG4gICAgICAgIHZpc2l0SW5Db21wb25lbnQocm9vdCwgY21wdCk7XG4gICAgICAgIHNlbGYuYmZzKHtcbiAgICAgICAgICBkaXJlY3RlZDogZmFsc2UsXG4gICAgICAgICAgcm9vdHM6IHJvb3QsXG4gICAgICAgICAgdmlzaXQ6IGZ1bmN0aW9uIHZpc2l0KHYpIHtcbiAgICAgICAgICAgIHJldHVybiB2aXNpdEluQ29tcG9uZW50KHYsIGNtcHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNtcHQuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIG5vZGUuY29ubmVjdGVkRWRnZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAvLyBjb25uZWN0ZWRFZGdlcygpIHVzdWFsbHkgY2FjaGVkXG4gICAgICAgICAgICBpZiAoc2VsZi5oYXMoZSkgJiYgY21wdC5oYXMoZS5zb3VyY2UoKSkgJiYgY21wdC5oYXMoZS50YXJnZXQoKSkpIHtcbiAgICAgICAgICAgICAgLy8gaGFzKCkgaXMgY2hlYXBcbiAgICAgICAgICAgICAgY21wdC5tZXJnZShlKTsgLy8gZm9yRWFjaCgpIG9ubHkgY29uc2lkZXJzIG5vZGVzIC0tIHNldHMgTiBhdCBjYWxsIHRpbWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBkbyB7XG4gICAgICAgIF9sb29wKCk7XG4gICAgICB9IHdoaWxlICh1bnZpc2l0ZWQubGVuZ3RoID4gMCk7XG5cbiAgICAgIHJldHVybiBjb21wb25lbnRzO1xuICAgIH0sXG4gICAgY29tcG9uZW50OiBmdW5jdGlvbiBjb21wb25lbnQoKSB7XG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICAgIHJldHVybiBlbGUuY3koKS5tdXRhYmxlRWxlbWVudHMoKS5jb21wb25lbnRzKGVsZSlbMF07XG4gICAgfVxuICB9KTtcbiAgZWxlc2ZuJDIuY29tcG9uZW50c09mID0gZWxlc2ZuJDIuY29tcG9uZW50cztcblxuICB2YXIgQ29sbGVjdGlvbiA9IGZ1bmN0aW9uIENvbGxlY3Rpb24oY3ksIGVsZW1lbnRzKSB7XG4gICAgdmFyIHVuaXF1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gICAgdmFyIHJlbW92ZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IGZhbHNlO1xuXG4gICAgaWYgKGN5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yKCdBIGNvbGxlY3Rpb24gbXVzdCBoYXZlIGEgcmVmZXJlbmNlIHRvIHRoZSBjb3JlJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG1hcCA9IG5ldyBNYXAkMigpO1xuICAgIHZhciBjcmVhdGVkRWxlbWVudHMgPSBmYWxzZTtcblxuICAgIGlmICghZWxlbWVudHMpIHtcbiAgICAgIGVsZW1lbnRzID0gW107XG4gICAgfSBlbHNlIGlmIChlbGVtZW50cy5sZW5ndGggPiAwICYmIHBsYWluT2JqZWN0KGVsZW1lbnRzWzBdKSAmJiAhZWxlbWVudChlbGVtZW50c1swXSkpIHtcbiAgICAgIGNyZWF0ZWRFbGVtZW50cyA9IHRydWU7IC8vIG1ha2UgZWxlbWVudHMgZnJvbSBqc29uIGFuZCByZXN0b3JlIGFsbCBhdCBvbmNlIGxhdGVyXG5cbiAgICAgIHZhciBlbGVzID0gW107XG4gICAgICB2YXIgZWxlc0lkcyA9IG5ldyBTZXQkMSgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIganNvbiA9IGVsZW1lbnRzW2ldO1xuXG4gICAgICAgIGlmIChqc29uLmRhdGEgPT0gbnVsbCkge1xuICAgICAgICAgIGpzb24uZGF0YSA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9kYXRhID0ganNvbi5kYXRhOyAvLyBtYWtlIHN1cmUgbmV3bHkgY3JlYXRlZCBlbGVtZW50cyBoYXZlIHZhbGlkIGlkc1xuXG4gICAgICAgIGlmIChfZGF0YS5pZCA9PSBudWxsKSB7XG4gICAgICAgICAgX2RhdGEuaWQgPSB1dWlkKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoY3kuaGFzRWxlbWVudFdpdGhJZChfZGF0YS5pZCkgfHwgZWxlc0lkcy5oYXMoX2RhdGEuaWQpKSB7XG4gICAgICAgICAgY29udGludWU7IC8vIGNhbid0IGNyZWF0ZSBlbGVtZW50IGlmIHByaW9yIGlkIGFscmVhZHkgZXhpc3RzXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZWxlID0gbmV3IEVsZW1lbnQoY3ksIGpzb24sIGZhbHNlKTtcbiAgICAgICAgZWxlcy5wdXNoKGVsZSk7XG4gICAgICAgIGVsZXNJZHMuYWRkKF9kYXRhLmlkKTtcbiAgICAgIH1cblxuICAgICAgZWxlbWVudHMgPSBlbGVzO1xuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gMDtcblxuICAgIGZvciAodmFyIF9pID0gMCwgX2wgPSBlbGVtZW50cy5sZW5ndGg7IF9pIDwgX2w7IF9pKyspIHtcbiAgICAgIHZhciBlbGVtZW50JDEgPSBlbGVtZW50c1tfaV1bMF07IC8vIFswXSBpbiBjYXNlIGVsZW1lbnRzIGlzIGFuIGFycmF5IG9mIGNvbGxlY3Rpb25zLCByYXRoZXIgdGhhbiBhcnJheSBvZiBlbGVtZW50c1xuXG4gICAgICBpZiAoZWxlbWVudCQxID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBpZCA9IGVsZW1lbnQkMS5fcHJpdmF0ZS5kYXRhLmlkO1xuXG4gICAgICBpZiAoIXVuaXF1ZSB8fCAhbWFwLmhhcyhpZCkpIHtcbiAgICAgICAgaWYgKHVuaXF1ZSkge1xuICAgICAgICAgIG1hcC5zZXQoaWQsIHtcbiAgICAgICAgICAgIGluZGV4OiB0aGlzLmxlbmd0aCxcbiAgICAgICAgICAgIGVsZTogZWxlbWVudCQxXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzW3RoaXMubGVuZ3RoXSA9IGVsZW1lbnQkMTtcbiAgICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9wcml2YXRlID0ge1xuICAgICAgZWxlczogdGhpcyxcbiAgICAgIGN5OiBjeSxcblxuICAgICAgZ2V0IG1hcCgpIHtcbiAgICAgICAgaWYgKHRoaXMubGF6eU1hcCA9PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5yZWJ1aWxkTWFwKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5sYXp5TWFwO1xuICAgICAgfSxcblxuICAgICAgc2V0IG1hcChtKSB7XG4gICAgICAgIHRoaXMubGF6eU1hcCA9IG07XG4gICAgICB9LFxuXG4gICAgICByZWJ1aWxkTWFwOiBmdW5jdGlvbiByZWJ1aWxkTWFwKCkge1xuICAgICAgICB2YXIgbSA9IHRoaXMubGF6eU1hcCA9IG5ldyBNYXAkMigpO1xuICAgICAgICB2YXIgZWxlcyA9IHRoaXMuZWxlcztcblxuICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBlbGVzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgICB2YXIgX2VsZSA9IGVsZXNbX2kyXTtcbiAgICAgICAgICBtLnNldChfZWxlLmlkKCksIHtcbiAgICAgICAgICAgIGluZGV4OiBfaTIsXG4gICAgICAgICAgICBlbGU6IF9lbGVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAodW5pcXVlKSB7XG4gICAgICB0aGlzLl9wcml2YXRlLm1hcCA9IG1hcDtcbiAgICB9IC8vIHJlc3RvcmUgdGhlIGVsZW1lbnRzIGlmIHdlIGNyZWF0ZWQgdGhlbSBmcm9tIGpzb25cblxuXG4gICAgaWYgKGNyZWF0ZWRFbGVtZW50cyAmJiAhcmVtb3ZlZCkge1xuICAgICAgdGhpcy5yZXN0b3JlKCk7XG4gICAgfVxuICB9OyAvLyBGdW5jdGlvbnNcbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLyBrZWVwIHRoZSBwcm90b3R5cGVzIGluIHN5bmMgKGFuIGVsZW1lbnQgaGFzIHRoZSBzYW1lIGZ1bmN0aW9ucyBhcyBhIGNvbGxlY3Rpb24pXG4gIC8vIGFuZCB1c2UgZWxlZm4gYW5kIGVsZXNmbiBhcyBzaG9ydGhhbmRzIHRvIHRoZSBwcm90b3R5cGVzXG5cblxuICB2YXIgZWxlc2ZuJDEgPSBFbGVtZW50LnByb3RvdHlwZSA9IENvbGxlY3Rpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShBcnJheS5wcm90b3R5cGUpO1xuXG4gIGVsZXNmbiQxLmluc3RhbmNlU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnY29sbGVjdGlvbic7XG4gIH07XG5cbiAgZWxlc2ZuJDEuc3Bhd24gPSBmdW5jdGlvbiAoZWxlcywgdW5pcXVlKSB7XG4gICAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uKHRoaXMuY3koKSwgZWxlcywgdW5pcXVlKTtcbiAgfTtcblxuICBlbGVzZm4kMS5zcGF3blNlbGYgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3Bhd24odGhpcyk7XG4gIH07XG5cbiAgZWxlc2ZuJDEuY3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuY3k7XG4gIH07XG5cbiAgZWxlc2ZuJDEucmVuZGVyZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuY3kucmVuZGVyZXIoKTtcbiAgfTtcblxuICBlbGVzZm4kMS5lbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzWzBdO1xuICB9O1xuXG4gIGVsZXNmbiQxLmNvbGxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNvbGxlY3Rpb24odGhpcykpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhbiBlbGVtZW50XG4gICAgICByZXR1cm4gbmV3IENvbGxlY3Rpb24odGhpcy5fcHJpdmF0ZS5jeSwgW3RoaXNdKTtcbiAgICB9XG4gIH07XG5cbiAgZWxlc2ZuJDEudW5pcXVlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgQ29sbGVjdGlvbih0aGlzLl9wcml2YXRlLmN5LCB0aGlzLCB0cnVlKTtcbiAgfTtcblxuICBlbGVzZm4kMS5oYXNFbGVtZW50V2l0aElkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgaWQgPSAnJyArIGlkOyAvLyBpZCBtdXN0IGJlIHN0cmluZ1xuXG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUubWFwLmhhcyhpZCk7XG4gIH07XG5cbiAgZWxlc2ZuJDEuZ2V0RWxlbWVudEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICBpZCA9ICcnICsgaWQ7IC8vIGlkIG11c3QgYmUgc3RyaW5nXG5cbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuXG4gICAgdmFyIGVudHJ5ID0gdGhpcy5fcHJpdmF0ZS5tYXAuZ2V0KGlkKTtcblxuICAgIHJldHVybiBlbnRyeSA/IGVudHJ5LmVsZSA6IG5ldyBDb2xsZWN0aW9uKGN5KTsgLy8gZ2V0IGVsZSBvciBlbXB0eSBjb2xsZWN0aW9uXG4gIH07XG5cbiAgZWxlc2ZuJDEuJGlkID0gZWxlc2ZuJDEuZ2V0RWxlbWVudEJ5SWQ7XG5cbiAgZWxlc2ZuJDEucG9vbEluZGV4ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgdmFyIGVsZXMgPSBjeS5fcHJpdmF0ZS5lbGVtZW50cztcbiAgICB2YXIgaWQgPSB0aGlzWzBdLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgcmV0dXJuIGVsZXMuX3ByaXZhdGUubWFwLmdldChpZCkuaW5kZXg7XG4gIH07XG5cbiAgZWxlc2ZuJDEuaW5kZXhPZiA9IGZ1bmN0aW9uIChlbGUpIHtcbiAgICB2YXIgaWQgPSBlbGVbMF0uX3ByaXZhdGUuZGF0YS5pZDtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5tYXAuZ2V0KGlkKS5pbmRleDtcbiAgfTtcblxuICBlbGVzZm4kMS5pbmRleE9mSWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICBpZCA9ICcnICsgaWQ7IC8vIGlkIG11c3QgYmUgc3RyaW5nXG5cbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5tYXAuZ2V0KGlkKS5pbmRleDtcbiAgfTtcblxuICBlbGVzZm4kMS5qc29uID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciBlbGUgPSB0aGlzLmVsZW1lbnQoKTtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICBpZiAoZWxlID09IG51bGwgJiYgb2JqKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IC8vIGNhbid0IHNldCB0byBubyBlbGVzXG5cblxuICAgIGlmIChlbGUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9IC8vIGNhbid0IGdldCBmcm9tIG5vIGVsZXNcblxuXG4gICAgdmFyIHAgPSBlbGUuX3ByaXZhdGU7XG5cbiAgICBpZiAocGxhaW5PYmplY3Qob2JqKSkge1xuICAgICAgLy8gc2V0XG4gICAgICBjeS5zdGFydEJhdGNoKCk7XG5cbiAgICAgIGlmIChvYmouZGF0YSkge1xuICAgICAgICBlbGUuZGF0YShvYmouZGF0YSk7XG4gICAgICAgIHZhciBfZGF0YTIgPSBwLmRhdGE7XG5cbiAgICAgICAgaWYgKGVsZS5pc0VkZ2UoKSkge1xuICAgICAgICAgIC8vIHNvdXJjZSBhbmQgdGFyZ2V0IGFyZSBpbW11dGFibGUgdmlhIGRhdGEoKVxuICAgICAgICAgIHZhciBtb3ZlID0gZmFsc2U7XG4gICAgICAgICAgdmFyIHNwZWMgPSB7fTtcbiAgICAgICAgICB2YXIgc3JjID0gb2JqLmRhdGEuc291cmNlO1xuICAgICAgICAgIHZhciB0Z3QgPSBvYmouZGF0YS50YXJnZXQ7XG5cbiAgICAgICAgICBpZiAoc3JjICE9IG51bGwgJiYgc3JjICE9IF9kYXRhMi5zb3VyY2UpIHtcbiAgICAgICAgICAgIHNwZWMuc291cmNlID0gJycgKyBzcmM7IC8vIGlkIG11c3QgYmUgc3RyaW5nXG5cbiAgICAgICAgICAgIG1vdmUgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0Z3QgIT0gbnVsbCAmJiB0Z3QgIT0gX2RhdGEyLnRhcmdldCkge1xuICAgICAgICAgICAgc3BlYy50YXJnZXQgPSAnJyArIHRndDsgLy8gaWQgbXVzdCBiZSBzdHJpbmdcblxuICAgICAgICAgICAgbW92ZSA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG1vdmUpIHtcbiAgICAgICAgICAgIGVsZSA9IGVsZS5tb3ZlKHNwZWMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBwYXJlbnQgaXMgaW1tdXRhYmxlIHZpYSBkYXRhKClcbiAgICAgICAgICB2YXIgbmV3UGFyZW50VmFsU3BlY2QgPSAoJ3BhcmVudCcgaW4gb2JqLmRhdGEpO1xuICAgICAgICAgIHZhciBwYXJlbnQgPSBvYmouZGF0YS5wYXJlbnQ7XG5cbiAgICAgICAgICBpZiAobmV3UGFyZW50VmFsU3BlY2QgJiYgKHBhcmVudCAhPSBudWxsIHx8IF9kYXRhMi5wYXJlbnQgIT0gbnVsbCkgJiYgcGFyZW50ICE9IF9kYXRhMi5wYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAvLyBjYW4ndCBzZXQgdW5kZWZpbmVkIGltcGVyYXRpdmVseSwgc28gdXNlIG51bGxcbiAgICAgICAgICAgICAgcGFyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBhcmVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHBhcmVudCA9ICcnICsgcGFyZW50OyAvLyBpZCBtdXN0IGJlIHN0cmluZ1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlbGUgPSBlbGUubW92ZSh7XG4gICAgICAgICAgICAgIHBhcmVudDogcGFyZW50XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG9iai5wb3NpdGlvbikge1xuICAgICAgICBlbGUucG9zaXRpb24ob2JqLnBvc2l0aW9uKTtcbiAgICAgIH0gLy8gaWdub3JlIGdyb3VwIC0tIGltbXV0YWJsZVxuXG5cbiAgICAgIHZhciBjaGVja1N3aXRjaCA9IGZ1bmN0aW9uIGNoZWNrU3dpdGNoKGssIHRydWVGbk5hbWUsIGZhbHNlRm5OYW1lKSB7XG4gICAgICAgIHZhciBvYmpfayA9IG9ialtrXTtcblxuICAgICAgICBpZiAob2JqX2sgIT0gbnVsbCAmJiBvYmpfayAhPT0gcFtrXSkge1xuICAgICAgICAgIGlmIChvYmpfaykge1xuICAgICAgICAgICAgZWxlW3RydWVGbk5hbWVdKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsZVtmYWxzZUZuTmFtZV0oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGNoZWNrU3dpdGNoKCdyZW1vdmVkJywgJ3JlbW92ZScsICdyZXN0b3JlJyk7XG4gICAgICBjaGVja1N3aXRjaCgnc2VsZWN0ZWQnLCAnc2VsZWN0JywgJ3Vuc2VsZWN0Jyk7XG4gICAgICBjaGVja1N3aXRjaCgnc2VsZWN0YWJsZScsICdzZWxlY3RpZnknLCAndW5zZWxlY3RpZnknKTtcbiAgICAgIGNoZWNrU3dpdGNoKCdsb2NrZWQnLCAnbG9jaycsICd1bmxvY2snKTtcbiAgICAgIGNoZWNrU3dpdGNoKCdncmFiYmFibGUnLCAnZ3JhYmlmeScsICd1bmdyYWJpZnknKTtcbiAgICAgIGNoZWNrU3dpdGNoKCdwYW5uYWJsZScsICdwYW5pZnknLCAndW5wYW5pZnknKTtcblxuICAgICAgaWYgKG9iai5jbGFzc2VzICE9IG51bGwpIHtcbiAgICAgICAgZWxlLmNsYXNzZXMob2JqLmNsYXNzZXMpO1xuICAgICAgfVxuXG4gICAgICBjeS5lbmRCYXRjaCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIGlmIChvYmogPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gZ2V0XG4gICAgICB2YXIganNvbiA9IHtcbiAgICAgICAgZGF0YTogY29weShwLmRhdGEpLFxuICAgICAgICBwb3NpdGlvbjogY29weShwLnBvc2l0aW9uKSxcbiAgICAgICAgZ3JvdXA6IHAuZ3JvdXAsXG4gICAgICAgIHJlbW92ZWQ6IHAucmVtb3ZlZCxcbiAgICAgICAgc2VsZWN0ZWQ6IHAuc2VsZWN0ZWQsXG4gICAgICAgIHNlbGVjdGFibGU6IHAuc2VsZWN0YWJsZSxcbiAgICAgICAgbG9ja2VkOiBwLmxvY2tlZCxcbiAgICAgICAgZ3JhYmJhYmxlOiBwLmdyYWJiYWJsZSxcbiAgICAgICAgcGFubmFibGU6IHAucGFubmFibGUsXG4gICAgICAgIGNsYXNzZXM6IG51bGxcbiAgICAgIH07XG4gICAgICBqc29uLmNsYXNzZXMgPSAnJztcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHAuY2xhc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChjbHMpIHtcbiAgICAgICAgcmV0dXJuIGpzb24uY2xhc3NlcyArPSBpKysgPT09IDAgPyBjbHMgOiAnICcgKyBjbHM7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBqc29uO1xuICAgIH1cbiAgfTtcblxuICBlbGVzZm4kMS5qc29ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIganNvbnMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICB2YXIganNvbiA9IGVsZS5qc29uKCk7XG4gICAgICBqc29ucy5wdXNoKGpzb24pO1xuICAgIH1cblxuICAgIHJldHVybiBqc29ucztcbiAgfTtcblxuICBlbGVzZm4kMS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgdmFyIGVsZXNBcnIgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICB2YXIganNvbiA9IGVsZS5qc29uKCk7XG4gICAgICB2YXIgY2xvbmUgPSBuZXcgRWxlbWVudChjeSwganNvbiwgZmFsc2UpOyAvLyBOQiBubyByZXN0b3JlXG5cbiAgICAgIGVsZXNBcnIucHVzaChjbG9uZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uKGN5LCBlbGVzQXJyKTtcbiAgfTtcblxuICBlbGVzZm4kMS5jb3B5ID0gZWxlc2ZuJDEuY2xvbmU7XG5cbiAgZWxlc2ZuJDEucmVzdG9yZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbm90aWZ5UmVuZGVyZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRydWU7XG4gICAgdmFyIGFkZFRvUG9vbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGN5ID0gc2VsZi5jeSgpO1xuICAgIHZhciBjeV9wID0gY3kuX3ByaXZhdGU7IC8vIGNyZWF0ZSBhcnJheXMgb2Ygbm9kZXMgYW5kIGVkZ2VzLCBzaW5jZSB3ZSBuZWVkIHRvXG4gICAgLy8gcmVzdG9yZSB0aGUgbm9kZXMgZmlyc3RcblxuICAgIHZhciBub2RlcyA9IFtdO1xuICAgIHZhciBlZGdlcyA9IFtdO1xuICAgIHZhciBlbGVtZW50cztcblxuICAgIGZvciAodmFyIF9pMyA9IDAsIGwgPSBzZWxmLmxlbmd0aDsgX2kzIDwgbDsgX2kzKyspIHtcbiAgICAgIHZhciBlbGUgPSBzZWxmW19pM107XG5cbiAgICAgIGlmIChhZGRUb1Bvb2wgJiYgIWVsZS5yZW1vdmVkKCkpIHtcbiAgICAgICAgLy8gZG9uJ3QgbmVlZCB0byBoYW5kbGUgdGhpcyBlbGVcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIGtlZXAgbm9kZXMgZmlyc3QgaW4gdGhlIGFycmF5IGFuZCBlZGdlcyBhZnRlclxuXG5cbiAgICAgIGlmIChlbGUuaXNOb2RlKCkpIHtcbiAgICAgICAgLy8gcHV0IHRvIGZyb250IG9mIGFycmF5IGlmIG5vZGVcbiAgICAgICAgbm9kZXMucHVzaChlbGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcHV0IHRvIGVuZCBvZiBhcnJheSBpZiBlZGdlXG4gICAgICAgIGVkZ2VzLnB1c2goZWxlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBlbGVtZW50cyA9IG5vZGVzLmNvbmNhdChlZGdlcyk7XG4gICAgdmFyIGk7XG5cbiAgICB2YXIgcmVtb3ZlRnJvbUVsZW1lbnRzID0gZnVuY3Rpb24gcmVtb3ZlRnJvbUVsZW1lbnRzKCkge1xuICAgICAgZWxlbWVudHMuc3BsaWNlKGksIDEpO1xuICAgICAgaS0tO1xuICAgIH07IC8vIG5vdywgcmVzdG9yZSBlYWNoIGVsZW1lbnRcblxuXG4gICAgZm9yIChpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgX2VsZTIgPSBlbGVtZW50c1tpXTtcbiAgICAgIHZhciBfcHJpdmF0ZSA9IF9lbGUyLl9wcml2YXRlO1xuICAgICAgdmFyIF9kYXRhMyA9IF9wcml2YXRlLmRhdGE7IC8vIHRoZSB0cmF2ZXJzYWwgY2FjaGUgc2hvdWxkIHN0YXJ0IGZyZXNoIHdoZW4gZWxlIGlzIGFkZGVkXG5cbiAgICAgIF9lbGUyLmNsZWFyVHJhdmVyc2FsQ2FjaGUoKTsgLy8gc2V0IGlkIGFuZCB2YWxpZGF0ZVxuXG5cbiAgICAgIGlmICghYWRkVG9Qb29sICYmICFfcHJpdmF0ZS5yZW1vdmVkKSA7IGVsc2UgaWYgKF9kYXRhMy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIF9kYXRhMy5pZCA9IHV1aWQoKTtcbiAgICAgIH0gZWxzZSBpZiAobnVtYmVyJDEoX2RhdGEzLmlkKSkge1xuICAgICAgICBfZGF0YTMuaWQgPSAnJyArIF9kYXRhMy5pZDsgLy8gbm93IGl0J3MgYSBzdHJpbmdcbiAgICAgIH0gZWxzZSBpZiAoZW1wdHlTdHJpbmcoX2RhdGEzLmlkKSB8fCAhc3RyaW5nKF9kYXRhMy5pZCkpIHtcbiAgICAgICAgZXJyb3IoJ0NhbiBub3QgY3JlYXRlIGVsZW1lbnQgd2l0aCBpbnZhbGlkIHN0cmluZyBJRCBgJyArIF9kYXRhMy5pZCArICdgJyk7IC8vIGNhbid0IGNyZWF0ZSBlbGVtZW50IGlmIGl0IGhhcyBlbXB0eSBzdHJpbmcgYXMgaWQgb3Igbm9uLXN0cmluZyBpZFxuXG4gICAgICAgIHJlbW92ZUZyb21FbGVtZW50cygpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSBpZiAoY3kuaGFzRWxlbWVudFdpdGhJZChfZGF0YTMuaWQpKSB7XG4gICAgICAgIGVycm9yKCdDYW4gbm90IGNyZWF0ZSBzZWNvbmQgZWxlbWVudCB3aXRoIElEIGAnICsgX2RhdGEzLmlkICsgJ2AnKTsgLy8gY2FuJ3QgY3JlYXRlIGVsZW1lbnQgaWYgb25lIGFscmVhZHkgaGFzIHRoYXQgaWRcblxuICAgICAgICByZW1vdmVGcm9tRWxlbWVudHMoKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBpZCA9IF9kYXRhMy5pZDsgLy8gaWQgaXMgZmluYWxpc2VkLCBub3cgbGV0J3Mga2VlcCBhIHJlZlxuXG4gICAgICBpZiAoX2VsZTIuaXNOb2RlKCkpIHtcbiAgICAgICAgLy8gZXh0cmEgY2hlY2tzIGZvciBub2Rlc1xuICAgICAgICB2YXIgcG9zID0gX3ByaXZhdGUucG9zaXRpb247IC8vIG1ha2Ugc3VyZSB0aGUgbm9kZXMgaGF2ZSBhIGRlZmluZWQgcG9zaXRpb25cblxuICAgICAgICBpZiAocG9zLnggPT0gbnVsbCkge1xuICAgICAgICAgIHBvcy54ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3MueSA9PSBudWxsKSB7XG4gICAgICAgICAgcG9zLnkgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChfZWxlMi5pc0VkZ2UoKSkge1xuICAgICAgICAvLyBleHRyYSBjaGVja3MgZm9yIGVkZ2VzXG4gICAgICAgIHZhciBlZGdlID0gX2VsZTI7XG4gICAgICAgIHZhciBmaWVsZHMgPSBbJ3NvdXJjZScsICd0YXJnZXQnXTtcbiAgICAgICAgdmFyIGZpZWxkc0xlbmd0aCA9IGZpZWxkcy5sZW5ndGg7XG4gICAgICAgIHZhciBiYWRTb3VyY2VPclRhcmdldCA9IGZhbHNlO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZmllbGRzTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB2YXIgZmllbGQgPSBmaWVsZHNbal07XG4gICAgICAgICAgdmFyIHZhbCA9IF9kYXRhM1tmaWVsZF07XG5cbiAgICAgICAgICBpZiAobnVtYmVyJDEodmFsKSkge1xuICAgICAgICAgICAgdmFsID0gX2RhdGEzW2ZpZWxkXSA9ICcnICsgX2RhdGEzW2ZpZWxkXTsgLy8gbm93IHN0cmluZ1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh2YWwgPT0gbnVsbCB8fCB2YWwgPT09ICcnKSB7XG4gICAgICAgICAgICAvLyBjYW4ndCBjcmVhdGUgaWYgc291cmNlIG9yIHRhcmdldCBpcyBub3QgZGVmaW5lZCBwcm9wZXJseVxuICAgICAgICAgICAgZXJyb3IoJ0NhbiBub3QgY3JlYXRlIGVkZ2UgYCcgKyBpZCArICdgIHdpdGggdW5zcGVjaWZpZWQgJyArIGZpZWxkKTtcbiAgICAgICAgICAgIGJhZFNvdXJjZU9yVGFyZ2V0ID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFjeS5oYXNFbGVtZW50V2l0aElkKHZhbCkpIHtcbiAgICAgICAgICAgIC8vIGNhbid0IGNyZWF0ZSBlZGdlIGlmIG9uZSBvZiBpdHMgbm9kZXMgZG9lc24ndCBleGlzdFxuICAgICAgICAgICAgZXJyb3IoJ0NhbiBub3QgY3JlYXRlIGVkZ2UgYCcgKyBpZCArICdgIHdpdGggbm9uZXhpc3RhbnQgJyArIGZpZWxkICsgJyBgJyArIHZhbCArICdgJyk7XG4gICAgICAgICAgICBiYWRTb3VyY2VPclRhcmdldCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJhZFNvdXJjZU9yVGFyZ2V0KSB7XG4gICAgICAgICAgcmVtb3ZlRnJvbUVsZW1lbnRzKCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gY2FuJ3QgY3JlYXRlIHRoaXNcblxuXG4gICAgICAgIHZhciBzcmMgPSBjeS5nZXRFbGVtZW50QnlJZChfZGF0YTMuc291cmNlKTtcbiAgICAgICAgdmFyIHRndCA9IGN5LmdldEVsZW1lbnRCeUlkKF9kYXRhMy50YXJnZXQpOyAvLyBvbmx5IG9uZSBlZGdlIGluIG5vZGUgaWYgbG9vcFxuXG4gICAgICAgIGlmIChzcmMuc2FtZSh0Z3QpKSB7XG4gICAgICAgICAgc3JjLl9wcml2YXRlLmVkZ2VzLnB1c2goZWRnZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3JjLl9wcml2YXRlLmVkZ2VzLnB1c2goZWRnZSk7XG5cbiAgICAgICAgICB0Z3QuX3ByaXZhdGUuZWRnZXMucHVzaChlZGdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVkZ2UuX3ByaXZhdGUuc291cmNlID0gc3JjO1xuICAgICAgICBlZGdlLl9wcml2YXRlLnRhcmdldCA9IHRndDtcbiAgICAgIH0gLy8gaWYgaXMgZWRnZVxuICAgICAgLy8gY3JlYXRlIG1vY2sgaWRzIC8gaW5kZXhlcyBtYXBzIGZvciBlbGVtZW50IHNvIGl0IGNhbiBiZSB1c2VkIGxpa2UgY29sbGVjdGlvbnNcblxuXG4gICAgICBfcHJpdmF0ZS5tYXAgPSBuZXcgTWFwJDIoKTtcblxuICAgICAgX3ByaXZhdGUubWFwLnNldChpZCwge1xuICAgICAgICBlbGU6IF9lbGUyLFxuICAgICAgICBpbmRleDogMFxuICAgICAgfSk7XG5cbiAgICAgIF9wcml2YXRlLnJlbW92ZWQgPSBmYWxzZTtcblxuICAgICAgaWYgKGFkZFRvUG9vbCkge1xuICAgICAgICBjeS5hZGRUb1Bvb2woX2VsZTIpO1xuICAgICAgfVxuICAgIH0gLy8gZm9yIGVhY2ggZWxlbWVudFxuICAgIC8vIGRvIGNvbXBvdW5kIG5vZGUgc2FuaXR5IGNoZWNrc1xuXG5cbiAgICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBub2Rlcy5sZW5ndGg7IF9pNCsrKSB7XG4gICAgICAvLyBlYWNoIG5vZGVcbiAgICAgIHZhciBub2RlID0gbm9kZXNbX2k0XTtcbiAgICAgIHZhciBfZGF0YTQgPSBub2RlLl9wcml2YXRlLmRhdGE7XG5cbiAgICAgIGlmIChudW1iZXIkMShfZGF0YTQucGFyZW50KSkge1xuICAgICAgICAvLyB0aGVuIGF1dG9tYWtlIHN0cmluZ1xuICAgICAgICBfZGF0YTQucGFyZW50ID0gJycgKyBfZGF0YTQucGFyZW50O1xuICAgICAgfVxuXG4gICAgICB2YXIgcGFyZW50SWQgPSBfZGF0YTQucGFyZW50O1xuICAgICAgdmFyIHNwZWNpZmllZFBhcmVudCA9IHBhcmVudElkICE9IG51bGw7XG5cbiAgICAgIGlmIChzcGVjaWZpZWRQYXJlbnQgfHwgbm9kZS5fcHJpdmF0ZS5wYXJlbnQpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IG5vZGUuX3ByaXZhdGUucGFyZW50ID8gY3kuY29sbGVjdGlvbigpLm1lcmdlKG5vZGUuX3ByaXZhdGUucGFyZW50KSA6IGN5LmdldEVsZW1lbnRCeUlkKHBhcmVudElkKTtcblxuICAgICAgICBpZiAocGFyZW50LmVtcHR5KCkpIHtcbiAgICAgICAgICAvLyBub24tZXhpc3RhbnQgcGFyZW50OyBqdXN0IHJlbW92ZSBpdFxuICAgICAgICAgIF9kYXRhNC5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH0gZWxzZSBpZiAocGFyZW50WzBdLnJlbW92ZWQoKSkge1xuICAgICAgICAgIHdhcm4oJ05vZGUgYWRkZWQgd2l0aCBtaXNzaW5nIHBhcmVudCwgcmVmZXJlbmNlIHRvIHBhcmVudCByZW1vdmVkJyk7XG4gICAgICAgICAgX2RhdGE0LnBhcmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBub2RlLl9wcml2YXRlLnBhcmVudCA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHNlbGZBc1BhcmVudCA9IGZhbHNlO1xuICAgICAgICAgIHZhciBhbmNlc3RvciA9IHBhcmVudDtcblxuICAgICAgICAgIHdoaWxlICghYW5jZXN0b3IuZW1wdHkoKSkge1xuICAgICAgICAgICAgaWYgKG5vZGUuc2FtZShhbmNlc3RvcikpIHtcbiAgICAgICAgICAgICAgLy8gbWFyayBzZWxmIGFzIHBhcmVudCBhbmQgcmVtb3ZlIGZyb20gZGF0YVxuICAgICAgICAgICAgICBzZWxmQXNQYXJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICBfZGF0YTQucGFyZW50ID0gdW5kZWZpbmVkOyAvLyByZW1vdmUgcGFyZW50IHJlZmVyZW5jZVxuICAgICAgICAgICAgICAvLyBleGl0IG9yIHdlIGxvb3AgZm9yZXZlclxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghc2VsZkFzUGFyZW50KSB7XG4gICAgICAgICAgICAvLyBjb25uZWN0IHdpdGggY2hpbGRyZW5cbiAgICAgICAgICAgIHBhcmVudFswXS5fcHJpdmF0ZS5jaGlsZHJlbi5wdXNoKG5vZGUpO1xuXG4gICAgICAgICAgICBub2RlLl9wcml2YXRlLnBhcmVudCA9IHBhcmVudFswXTsgLy8gbGV0IHRoZSBjb3JlIGtub3cgd2UgaGF2ZSBhIGNvbXBvdW5kIGdyYXBoXG5cbiAgICAgICAgICAgIGN5X3AuaGFzQ29tcG91bmROb2RlcyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIGVsc2VcblxuICAgICAgfSAvLyBpZiBzcGVjaWZpZWQgcGFyZW50XG5cbiAgICB9IC8vIGZvciBlYWNoIG5vZGVcblxuXG4gICAgaWYgKGVsZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciByZXN0b3JlZCA9IGVsZW1lbnRzLmxlbmd0aCA9PT0gc2VsZi5sZW5ndGggPyBzZWxmIDogbmV3IENvbGxlY3Rpb24oY3ksIGVsZW1lbnRzKTtcblxuICAgICAgZm9yICh2YXIgX2k1ID0gMDsgX2k1IDwgcmVzdG9yZWQubGVuZ3RoOyBfaTUrKykge1xuICAgICAgICB2YXIgX2VsZTMgPSByZXN0b3JlZFtfaTVdO1xuXG4gICAgICAgIGlmIChfZWxlMy5pc05vZGUoKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIGFkZGluZyBhbiBlZGdlIGludmFsaWRhdGVzIHRoZSB0cmF2ZXJzYWwgY2FjaGVzIGZvciB0aGUgcGFyYWxsZWwgZWRnZXNcblxuXG4gICAgICAgIF9lbGUzLnBhcmFsbGVsRWRnZXMoKS5jbGVhclRyYXZlcnNhbENhY2hlKCk7IC8vIGFkZGluZyBhbiBlZGdlIGludmFsaWRhdGVzIHRoZSB0cmF2ZXJzYWwgY2FjaGUgZm9yIHRoZSBjb25uZWN0ZWQgbm9kZXNcblxuXG4gICAgICAgIF9lbGUzLnNvdXJjZSgpLmNsZWFyVHJhdmVyc2FsQ2FjaGUoKTtcblxuICAgICAgICBfZWxlMy50YXJnZXQoKS5jbGVhclRyYXZlcnNhbENhY2hlKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0b1VwZGF0ZVN0eWxlO1xuXG4gICAgICBpZiAoY3lfcC5oYXNDb21wb3VuZE5vZGVzKSB7XG4gICAgICAgIHRvVXBkYXRlU3R5bGUgPSBjeS5jb2xsZWN0aW9uKCkubWVyZ2UocmVzdG9yZWQpLm1lcmdlKHJlc3RvcmVkLmNvbm5lY3RlZE5vZGVzKCkpLm1lcmdlKHJlc3RvcmVkLnBhcmVudCgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRvVXBkYXRlU3R5bGUgPSByZXN0b3JlZDtcbiAgICAgIH1cblxuICAgICAgdG9VcGRhdGVTdHlsZS5kaXJ0eUNvbXBvdW5kQm91bmRzQ2FjaGUoKS5kaXJ0eUJvdW5kaW5nQm94Q2FjaGUoKS51cGRhdGVTdHlsZShub3RpZnlSZW5kZXJlcik7XG5cbiAgICAgIGlmIChub3RpZnlSZW5kZXJlcikge1xuICAgICAgICByZXN0b3JlZC5lbWl0QW5kTm90aWZ5KCdhZGQnKTtcbiAgICAgIH0gZWxzZSBpZiAoYWRkVG9Qb29sKSB7XG4gICAgICAgIHJlc3RvcmVkLmVtaXQoJ2FkZCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzZWxmOyAvLyBjaGFpbmFiaWxpdHlcbiAgfTtcblxuICBlbGVzZm4kMS5yZW1vdmVkID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIHJldHVybiBlbGUgJiYgZWxlLl9wcml2YXRlLnJlbW92ZWQ7XG4gIH07XG5cbiAgZWxlc2ZuJDEuaW5zaWRlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIHJldHVybiBlbGUgJiYgIWVsZS5fcHJpdmF0ZS5yZW1vdmVkO1xuICB9O1xuXG4gIGVsZXNmbiQxLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbm90aWZ5UmVuZGVyZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRydWU7XG4gICAgdmFyIHJlbW92ZUZyb21Qb29sID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZWxlc1RvUmVtb3ZlID0gW107XG4gICAgdmFyIGVsZXNUb1JlbW92ZUlkcyA9IHt9O1xuICAgIHZhciBjeSA9IHNlbGYuX3ByaXZhdGUuY3k7IC8vIGFkZCBjb25uZWN0ZWQgZWRnZXNcblxuICAgIGZ1bmN0aW9uIGFkZENvbm5lY3RlZEVkZ2VzKG5vZGUpIHtcbiAgICAgIHZhciBlZGdlcyA9IG5vZGUuX3ByaXZhdGUuZWRnZXM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYWRkKGVkZ2VzW2ldKTtcbiAgICAgIH1cbiAgICB9IC8vIGFkZCBkZXNjZW5kYW50IG5vZGVzXG5cblxuICAgIGZ1bmN0aW9uIGFkZENoaWxkcmVuKG5vZGUpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuX3ByaXZhdGUuY2hpbGRyZW47XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYWRkKGNoaWxkcmVuW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGQoZWxlKSB7XG4gICAgICB2YXIgYWxyZWFkeUFkZGVkID0gZWxlc1RvUmVtb3ZlSWRzW2VsZS5pZCgpXTtcblxuICAgICAgaWYgKHJlbW92ZUZyb21Qb29sICYmIGVsZS5yZW1vdmVkKCkgfHwgYWxyZWFkeUFkZGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZXNUb1JlbW92ZUlkc1tlbGUuaWQoKV0gPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgICAgIGVsZXNUb1JlbW92ZS5wdXNoKGVsZSk7IC8vIG5vZGVzIGFyZSByZW1vdmVkIGxhc3RcblxuICAgICAgICBhZGRDb25uZWN0ZWRFZGdlcyhlbGUpO1xuICAgICAgICBhZGRDaGlsZHJlbihlbGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlc1RvUmVtb3ZlLnVuc2hpZnQoZWxlKTsgLy8gZWRnZXMgYXJlIHJlbW92ZWQgZmlyc3RcbiAgICAgIH1cbiAgICB9IC8vIG1ha2UgdGhlIGxpc3Qgb2YgZWxlbWVudHMgdG8gcmVtb3ZlXG4gICAgLy8gKG1heSBiZSByZW1vdmluZyBtb3JlIHRoYW4gc3BlY2lmaWVkIGR1ZSB0byBjb25uZWN0ZWQgZWRnZXMgZXRjKVxuXG5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHNlbGYubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gc2VsZltpXTtcbiAgICAgIGFkZChlbGUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUVkZ2VSZWYobm9kZSwgZWRnZSkge1xuICAgICAgdmFyIGNvbm5lY3RlZEVkZ2VzID0gbm9kZS5fcHJpdmF0ZS5lZGdlcztcbiAgICAgIHJlbW92ZUZyb21BcnJheShjb25uZWN0ZWRFZGdlcywgZWRnZSk7IC8vIHJlbW92aW5nIGFuIGVkZ2VzIGludmFsaWRhdGVzIHRoZSB0cmF2ZXJzYWwgY2FjaGUgZm9yIGl0cyBub2Rlc1xuXG4gICAgICBub2RlLmNsZWFyVHJhdmVyc2FsQ2FjaGUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmVQYXJhbGxlbFJlZihwbGxFZGdlKSB7XG4gICAgICAvLyByZW1vdmluZyBhbiBlZGdlIGludmFsaWRhdGVzIHRoZSB0cmF2ZXJzYWwgY2FjaGVzIGZvciB0aGUgcGFyYWxsZWwgZWRnZXNcbiAgICAgIHBsbEVkZ2UuY2xlYXJUcmF2ZXJzYWxDYWNoZSgpO1xuICAgIH1cblxuICAgIHZhciBhbHRlcmVkUGFyZW50cyA9IFtdO1xuICAgIGFsdGVyZWRQYXJlbnRzLmlkcyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gcmVtb3ZlQ2hpbGRSZWYocGFyZW50LCBlbGUpIHtcbiAgICAgIGVsZSA9IGVsZVswXTtcbiAgICAgIHBhcmVudCA9IHBhcmVudFswXTtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHBhcmVudC5fcHJpdmF0ZS5jaGlsZHJlbjtcbiAgICAgIHZhciBwaWQgPSBwYXJlbnQuaWQoKTtcbiAgICAgIHJlbW92ZUZyb21BcnJheShjaGlsZHJlbiwgZWxlKTsgLy8gcmVtb3ZlIHBhcmVudCA9PiBjaGlsZCByZWZcblxuICAgICAgZWxlLl9wcml2YXRlLnBhcmVudCA9IG51bGw7IC8vIHJlbW92ZSBjaGlsZCA9PiBwYXJlbnQgcmVmXG5cbiAgICAgIGlmICghYWx0ZXJlZFBhcmVudHMuaWRzW3BpZF0pIHtcbiAgICAgICAgYWx0ZXJlZFBhcmVudHMuaWRzW3BpZF0gPSB0cnVlO1xuICAgICAgICBhbHRlcmVkUGFyZW50cy5wdXNoKHBhcmVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZi5kaXJ0eUNvbXBvdW5kQm91bmRzQ2FjaGUoKTtcblxuICAgIGlmIChyZW1vdmVGcm9tUG9vbCkge1xuICAgICAgY3kucmVtb3ZlRnJvbVBvb2woZWxlc1RvUmVtb3ZlKTsgLy8gcmVtb3ZlIGZyb20gY29yZSBwb29sXG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2k2ID0gMDsgX2k2IDwgZWxlc1RvUmVtb3ZlLmxlbmd0aDsgX2k2KyspIHtcbiAgICAgIHZhciBfZWxlNCA9IGVsZXNUb1JlbW92ZVtfaTZdO1xuXG4gICAgICBpZiAoX2VsZTQuaXNFZGdlKCkpIHtcbiAgICAgICAgLy8gcmVtb3ZlIHJlZmVyZW5jZXMgdG8gdGhpcyBlZGdlIGluIGl0cyBjb25uZWN0ZWQgbm9kZXNcbiAgICAgICAgdmFyIHNyYyA9IF9lbGU0LnNvdXJjZSgpWzBdO1xuXG4gICAgICAgIHZhciB0Z3QgPSBfZWxlNC50YXJnZXQoKVswXTtcblxuICAgICAgICByZW1vdmVFZGdlUmVmKHNyYywgX2VsZTQpO1xuICAgICAgICByZW1vdmVFZGdlUmVmKHRndCwgX2VsZTQpO1xuXG4gICAgICAgIHZhciBwbGxFZGdlcyA9IF9lbGU0LnBhcmFsbGVsRWRnZXMoKTtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBsbEVkZ2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdmFyIHBsbEVkZ2UgPSBwbGxFZGdlc1tqXTtcbiAgICAgICAgICByZW1vdmVQYXJhbGxlbFJlZihwbGxFZGdlKTtcblxuICAgICAgICAgIGlmIChwbGxFZGdlLmlzQnVuZGxlZEJlemllcigpKSB7XG4gICAgICAgICAgICBwbGxFZGdlLmRpcnR5Qm91bmRpbmdCb3hDYWNoZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcmVtb3ZlIHJlZmVyZW5jZSB0byBwYXJlbnRcbiAgICAgICAgdmFyIHBhcmVudCA9IF9lbGU0LnBhcmVudCgpO1xuXG4gICAgICAgIGlmIChwYXJlbnQubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgcmVtb3ZlQ2hpbGRSZWYocGFyZW50LCBfZWxlNCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHJlbW92ZUZyb21Qb29sKSB7XG4gICAgICAgIC8vIG1hcmsgYXMgcmVtb3ZlZFxuICAgICAgICBfZWxlNC5fcHJpdmF0ZS5yZW1vdmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IC8vIGNoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGEgY29tcG91bmQgZ3JhcGggb3Igbm90XG5cblxuICAgIHZhciBlbGVzU3RpbGxJbnNpZGUgPSBjeS5fcHJpdmF0ZS5lbGVtZW50cztcbiAgICBjeS5fcHJpdmF0ZS5oYXNDb21wb3VuZE5vZGVzID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBfaTcgPSAwOyBfaTcgPCBlbGVzU3RpbGxJbnNpZGUubGVuZ3RoOyBfaTcrKykge1xuICAgICAgdmFyIF9lbGU1ID0gZWxlc1N0aWxsSW5zaWRlW19pN107XG5cbiAgICAgIGlmIChfZWxlNS5pc1BhcmVudCgpKSB7XG4gICAgICAgIGN5Ll9wcml2YXRlLmhhc0NvbXBvdW5kTm9kZXMgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVtb3ZlZEVsZW1lbnRzID0gbmV3IENvbGxlY3Rpb24odGhpcy5jeSgpLCBlbGVzVG9SZW1vdmUpO1xuXG4gICAgaWYgKHJlbW92ZWRFbGVtZW50cy5zaXplKCkgPiAwKSB7XG4gICAgICAvLyBtdXN0IG1hbnVhbGx5IG5vdGlmeSBzaW5jZSB0cmlnZ2VyIHdvbid0IGRvIHRoaXMgYXV0b21hdGljYWxseSBvbmNlIHJlbW92ZWRcbiAgICAgIGlmIChub3RpZnlSZW5kZXJlcikge1xuICAgICAgICByZW1vdmVkRWxlbWVudHMuZW1pdEFuZE5vdGlmeSgncmVtb3ZlJyk7XG4gICAgICB9IGVsc2UgaWYgKHJlbW92ZUZyb21Qb29sKSB7XG4gICAgICAgIHJlbW92ZWRFbGVtZW50cy5lbWl0KCdyZW1vdmUnKTtcbiAgICAgIH1cbiAgICB9IC8vIHRoZSBwYXJlbnRzIHdobyB3ZXJlIG1vZGlmaWVkIGJ5IHRoZSByZW1vdmFsIG5lZWQgdGhlaXIgc3R5bGUgdXBkYXRlZFxuXG5cbiAgICBmb3IgKHZhciBfaTggPSAwOyBfaTggPCBhbHRlcmVkUGFyZW50cy5sZW5ndGg7IF9pOCsrKSB7XG4gICAgICB2YXIgX2VsZTYgPSBhbHRlcmVkUGFyZW50c1tfaThdO1xuXG4gICAgICBpZiAoIXJlbW92ZUZyb21Qb29sIHx8ICFfZWxlNi5yZW1vdmVkKCkpIHtcbiAgICAgICAgX2VsZTYudXBkYXRlU3R5bGUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVtb3ZlZEVsZW1lbnRzO1xuICB9O1xuXG4gIGVsZXNmbiQxLm1vdmUgPSBmdW5jdGlvbiAoc3RydWN0KSB7XG4gICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgICB2YXIgZWxlcyA9IHRoaXM7IC8vIGp1c3QgY2xlYW4gdXAgcmVmcywgY2FjaGVzLCBldGMuIGluIHRoZSBzYW1lIHdheSBhcyB3aGVuIHJlbW92aW5nIGFuZCB0aGVuIHJlc3RvcmluZ1xuICAgIC8vIChvdXIgY2FsbHMgdG8gcmVtb3ZlL3Jlc3RvcmUgZG8gbm90IHJlbW92ZSBmcm9tIHRoZSBncmFwaCBvciBtYWtlIGV2ZW50cylcblxuICAgIHZhciBub3RpZnlSZW5kZXJlciA9IGZhbHNlO1xuICAgIHZhciBtb2RpZnlQb29sID0gZmFsc2U7XG5cbiAgICB2YXIgdG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhpZCkge1xuICAgICAgcmV0dXJuIGlkID09IG51bGwgPyBpZCA6ICcnICsgaWQ7XG4gICAgfTsgLy8gaWQgbXVzdCBiZSBzdHJpbmdcblxuXG4gICAgaWYgKHN0cnVjdC5zb3VyY2UgIT09IHVuZGVmaW5lZCB8fCBzdHJ1Y3QudGFyZ2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBzcmNJZCA9IHRvU3RyaW5nKHN0cnVjdC5zb3VyY2UpO1xuICAgICAgdmFyIHRndElkID0gdG9TdHJpbmcoc3RydWN0LnRhcmdldCk7XG4gICAgICB2YXIgc3JjRXhpc3RzID0gc3JjSWQgIT0gbnVsbCAmJiBjeS5oYXNFbGVtZW50V2l0aElkKHNyY0lkKTtcbiAgICAgIHZhciB0Z3RFeGlzdHMgPSB0Z3RJZCAhPSBudWxsICYmIGN5Lmhhc0VsZW1lbnRXaXRoSWQodGd0SWQpO1xuXG4gICAgICBpZiAoc3JjRXhpc3RzIHx8IHRndEV4aXN0cykge1xuICAgICAgICBjeS5iYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gYXZvaWQgZHVwbGljYXRlIHN0eWxlIHVwZGF0ZXNcbiAgICAgICAgICBlbGVzLnJlbW92ZShub3RpZnlSZW5kZXJlciwgbW9kaWZ5UG9vbCk7IC8vIGNsZWFuIHVwIHJlZnMgZXRjLlxuXG4gICAgICAgICAgZWxlcy5lbWl0QW5kTm90aWZ5KCdtb3Zlb3V0Jyk7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgICAgICAgdmFyIF9kYXRhNSA9IGVsZS5fcHJpdmF0ZS5kYXRhO1xuXG4gICAgICAgICAgICBpZiAoZWxlLmlzRWRnZSgpKSB7XG4gICAgICAgICAgICAgIGlmIChzcmNFeGlzdHMpIHtcbiAgICAgICAgICAgICAgICBfZGF0YTUuc291cmNlID0gc3JjSWQ7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAodGd0RXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgX2RhdGE1LnRhcmdldCA9IHRndElkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZWxlcy5yZXN0b3JlKG5vdGlmeVJlbmRlcmVyLCBtb2RpZnlQb29sKTsgLy8gbWFrZSBuZXcgcmVmcywgc3R5bGUsIGV0Yy5cbiAgICAgICAgfSk7XG4gICAgICAgIGVsZXMuZW1pdEFuZE5vdGlmeSgnbW92ZScpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc3RydWN0LnBhcmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBtb3ZlIG5vZGUgdG8gbmV3IHBhcmVudFxuICAgICAgdmFyIHBhcmVudElkID0gdG9TdHJpbmcoc3RydWN0LnBhcmVudCk7XG4gICAgICB2YXIgcGFyZW50RXhpc3RzID0gcGFyZW50SWQgPT09IG51bGwgfHwgY3kuaGFzRWxlbWVudFdpdGhJZChwYXJlbnRJZCk7XG5cbiAgICAgIGlmIChwYXJlbnRFeGlzdHMpIHtcbiAgICAgICAgdmFyIHBpZFRvQXNzaWduID0gcGFyZW50SWQgPT09IG51bGwgPyB1bmRlZmluZWQgOiBwYXJlbnRJZDtcbiAgICAgICAgY3kuYmF0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIGF2b2lkIGR1cGxpY2F0ZSBzdHlsZSB1cGRhdGVzXG4gICAgICAgICAgdmFyIHVwZGF0ZWQgPSBlbGVzLnJlbW92ZShub3RpZnlSZW5kZXJlciwgbW9kaWZ5UG9vbCk7IC8vIGNsZWFuIHVwIHJlZnMgZXRjLlxuXG4gICAgICAgICAgdXBkYXRlZC5lbWl0QW5kTm90aWZ5KCdtb3Zlb3V0Jyk7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgICAgICAgdmFyIF9kYXRhNiA9IGVsZS5fcHJpdmF0ZS5kYXRhO1xuXG4gICAgICAgICAgICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgICAgICAgICAgIF9kYXRhNi5wYXJlbnQgPSBwaWRUb0Fzc2lnbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB1cGRhdGVkLnJlc3RvcmUobm90aWZ5UmVuZGVyZXIsIG1vZGlmeVBvb2wpOyAvLyBtYWtlIG5ldyByZWZzLCBzdHlsZSwgZXRjLlxuICAgICAgICB9KTtcbiAgICAgICAgZWxlcy5lbWl0QW5kTm90aWZ5KCdtb3ZlJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgW2VsZXNmbiRqLCBlbGVzZm4kaSwgZWxlc2ZuJGgsIGVsZXNmbiRnLCBlbGVzZm4kZiwgZGF0YSwgZWxlc2ZuJGQsIGRpbWVuc2lvbnMsIGVsZXNmbiQ5LCBlbGVzZm4kOCwgZWxlc2ZuJDcsIGVsZXNmbiQ2LCBlbGVzZm4kNSwgZWxlc2ZuJDQsIGVsZXNmbiQzLCBlbGVzZm4kMl0uZm9yRWFjaChmdW5jdGlvbiAocHJvcHMpIHtcbiAgICBleHRlbmQoZWxlc2ZuJDEsIHByb3BzKTtcbiAgfSk7XG5cbiAgdmFyIGNvcmVmbiQ5ID0ge1xuICAgIGFkZDogZnVuY3Rpb24gYWRkKG9wdHMpIHtcbiAgICAgIHZhciBlbGVtZW50cztcbiAgICAgIHZhciBjeSA9IHRoaXM7IC8vIGFkZCB0aGUgZWxlbWVudHNcblxuICAgICAgaWYgKGVsZW1lbnRPckNvbGxlY3Rpb24ob3B0cykpIHtcbiAgICAgICAgdmFyIGVsZXMgPSBvcHRzO1xuXG4gICAgICAgIGlmIChlbGVzLl9wcml2YXRlLmN5ID09PSBjeSkge1xuICAgICAgICAgIC8vIHNhbWUgaW5zdGFuY2UgPT4ganVzdCByZXN0b3JlXG4gICAgICAgICAgZWxlbWVudHMgPSBlbGVzLnJlc3RvcmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBvdGhlcndpc2UsIGNvcHkgZnJvbSBqc29uXG4gICAgICAgICAgdmFyIGpzb25zID0gW107XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgICAgICAganNvbnMucHVzaChlbGUuanNvbigpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlbGVtZW50cyA9IG5ldyBDb2xsZWN0aW9uKGN5LCBqc29ucyk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gc3BlY2lmeSBhbiBhcnJheSBvZiBvcHRpb25zXG4gICAgICBlbHNlIGlmIChhcnJheShvcHRzKSkge1xuICAgICAgICB2YXIgX2pzb25zID0gb3B0cztcbiAgICAgICAgZWxlbWVudHMgPSBuZXcgQ29sbGVjdGlvbihjeSwgX2pzb25zKTtcbiAgICAgIH0gLy8gc3BlY2lmeSB2aWEgb3B0cy5ub2RlcyBhbmQgb3B0cy5lZGdlc1xuICAgICAgZWxzZSBpZiAocGxhaW5PYmplY3Qob3B0cykgJiYgKGFycmF5KG9wdHMubm9kZXMpIHx8IGFycmF5KG9wdHMuZWRnZXMpKSkge1xuICAgICAgICB2YXIgZWxlc0J5R3JvdXAgPSBvcHRzO1xuICAgICAgICB2YXIgX2pzb25zMiA9IFtdO1xuICAgICAgICB2YXIgZ3JzID0gWydub2RlcycsICdlZGdlcyddO1xuXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgaWwgPSBncnMubGVuZ3RoOyBfaSA8IGlsOyBfaSsrKSB7XG4gICAgICAgICAgdmFyIGdyb3VwID0gZ3JzW19pXTtcbiAgICAgICAgICB2YXIgZWxlc0FycmF5ID0gZWxlc0J5R3JvdXBbZ3JvdXBdO1xuXG4gICAgICAgICAgaWYgKGFycmF5KGVsZXNBcnJheSkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwLCBqbCA9IGVsZXNBcnJheS5sZW5ndGg7IGogPCBqbDsgaisrKSB7XG4gICAgICAgICAgICAgIHZhciBqc29uID0gZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICBncm91cDogZ3JvdXBcbiAgICAgICAgICAgICAgfSwgZWxlc0FycmF5W2pdKTtcblxuICAgICAgICAgICAgICBfanNvbnMyLnB1c2goanNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZWxlbWVudHMgPSBuZXcgQ29sbGVjdGlvbihjeSwgX2pzb25zMik7XG4gICAgICB9IC8vIHNwZWNpZnkgb3B0aW9ucyBmb3Igb25lIGVsZW1lbnRcbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgX2pzb24gPSBvcHRzO1xuICAgICAgICBlbGVtZW50cyA9IG5ldyBFbGVtZW50KGN5LCBfanNvbikuY29sbGVjdGlvbigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZWxlbWVudHM7XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShjb2xsZWN0aW9uKSB7XG4gICAgICBpZiAoZWxlbWVudE9yQ29sbGVjdGlvbihjb2xsZWN0aW9uKSkgOyBlbHNlIGlmIChzdHJpbmcoY29sbGVjdGlvbikpIHtcbiAgICAgICAgdmFyIHNlbGVjdG9yID0gY29sbGVjdGlvbjtcbiAgICAgICAgY29sbGVjdGlvbiA9IHRoaXMuJChzZWxlY3Rvcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb2xsZWN0aW9uLnJlbW92ZSgpO1xuICAgIH1cbiAgfTtcblxuICAvKiBnbG9iYWwgRmxvYXQzMkFycmF5ICovXG5cbiAgLyohIEJlemllciBjdXJ2ZSBmdW5jdGlvbiBnZW5lcmF0b3IuIENvcHlyaWdodCBHYWV0YW4gUmVuYXVkZWF1LiBNSVQgTGljZW5zZTogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NSVRfTGljZW5zZSAqL1xuICBmdW5jdGlvbiBnZW5lcmF0ZUN1YmljQmV6aWVyKG1YMSwgbVkxLCBtWDIsIG1ZMikge1xuICAgIHZhciBORVdUT05fSVRFUkFUSU9OUyA9IDQsXG4gICAgICAgIE5FV1RPTl9NSU5fU0xPUEUgPSAwLjAwMSxcbiAgICAgICAgU1VCRElWSVNJT05fUFJFQ0lTSU9OID0gMC4wMDAwMDAxLFxuICAgICAgICBTVUJESVZJU0lPTl9NQVhfSVRFUkFUSU9OUyA9IDEwLFxuICAgICAgICBrU3BsaW5lVGFibGVTaXplID0gMTEsXG4gICAgICAgIGtTYW1wbGVTdGVwU2l6ZSA9IDEuMCAvIChrU3BsaW5lVGFibGVTaXplIC0gMS4wKSxcbiAgICAgICAgZmxvYXQzMkFycmF5U3VwcG9ydGVkID0gdHlwZW9mIEZsb2F0MzJBcnJheSAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgLyogTXVzdCBjb250YWluIGZvdXIgYXJndW1lbnRzLiAqL1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyogQXJndW1lbnRzIG11c3QgYmUgbnVtYmVycy4gKi9cblxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyArK2kpIHtcbiAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzW2ldICE9PSBcIm51bWJlclwiIHx8IGlzTmFOKGFyZ3VtZW50c1tpXSkgfHwgIWlzRmluaXRlKGFyZ3VtZW50c1tpXSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiBYIHZhbHVlcyBtdXN0IGJlIGluIHRoZSBbMCwgMV0gcmFuZ2UuICovXG5cblxuICAgIG1YMSA9IE1hdGgubWluKG1YMSwgMSk7XG4gICAgbVgyID0gTWF0aC5taW4obVgyLCAxKTtcbiAgICBtWDEgPSBNYXRoLm1heChtWDEsIDApO1xuICAgIG1YMiA9IE1hdGgubWF4KG1YMiwgMCk7XG4gICAgdmFyIG1TYW1wbGVWYWx1ZXMgPSBmbG9hdDMyQXJyYXlTdXBwb3J0ZWQgPyBuZXcgRmxvYXQzMkFycmF5KGtTcGxpbmVUYWJsZVNpemUpIDogbmV3IEFycmF5KGtTcGxpbmVUYWJsZVNpemUpO1xuXG4gICAgZnVuY3Rpb24gQShhQTEsIGFBMikge1xuICAgICAgcmV0dXJuIDEuMCAtIDMuMCAqIGFBMiArIDMuMCAqIGFBMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBCKGFBMSwgYUEyKSB7XG4gICAgICByZXR1cm4gMy4wICogYUEyIC0gNi4wICogYUExO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIEMoYUExKSB7XG4gICAgICByZXR1cm4gMy4wICogYUExO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhbGNCZXppZXIoYVQsIGFBMSwgYUEyKSB7XG4gICAgICByZXR1cm4gKChBKGFBMSwgYUEyKSAqIGFUICsgQihhQTEsIGFBMikpICogYVQgKyBDKGFBMSkpICogYVQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2xvcGUoYVQsIGFBMSwgYUEyKSB7XG4gICAgICByZXR1cm4gMy4wICogQShhQTEsIGFBMikgKiBhVCAqIGFUICsgMi4wICogQihhQTEsIGFBMikgKiBhVCArIEMoYUExKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBuZXd0b25SYXBoc29uSXRlcmF0ZShhWCwgYUd1ZXNzVCkge1xuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IE5FV1RPTl9JVEVSQVRJT05TOyArK19pKSB7XG4gICAgICAgIHZhciBjdXJyZW50U2xvcGUgPSBnZXRTbG9wZShhR3Vlc3NULCBtWDEsIG1YMik7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRTbG9wZSA9PT0gMC4wKSB7XG4gICAgICAgICAgcmV0dXJuIGFHdWVzc1Q7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY3VycmVudFggPSBjYWxjQmV6aWVyKGFHdWVzc1QsIG1YMSwgbVgyKSAtIGFYO1xuICAgICAgICBhR3Vlc3NUIC09IGN1cnJlbnRYIC8gY3VycmVudFNsb3BlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYUd1ZXNzVDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYWxjU2FtcGxlVmFsdWVzKCkge1xuICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwga1NwbGluZVRhYmxlU2l6ZTsgKytfaTIpIHtcbiAgICAgICAgbVNhbXBsZVZhbHVlc1tfaTJdID0gY2FsY0JlemllcihfaTIgKiBrU2FtcGxlU3RlcFNpemUsIG1YMSwgbVgyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBiaW5hcnlTdWJkaXZpZGUoYVgsIGFBLCBhQikge1xuICAgICAgdmFyIGN1cnJlbnRYLFxuICAgICAgICAgIGN1cnJlbnRULFxuICAgICAgICAgIGkgPSAwO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGN1cnJlbnRUID0gYUEgKyAoYUIgLSBhQSkgLyAyLjA7XG4gICAgICAgIGN1cnJlbnRYID0gY2FsY0JlemllcihjdXJyZW50VCwgbVgxLCBtWDIpIC0gYVg7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRYID4gMC4wKSB7XG4gICAgICAgICAgYUIgPSBjdXJyZW50VDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhQSA9IGN1cnJlbnRUO1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlIChNYXRoLmFicyhjdXJyZW50WCkgPiBTVUJESVZJU0lPTl9QUkVDSVNJT04gJiYgKytpIDwgU1VCRElWSVNJT05fTUFYX0lURVJBVElPTlMpO1xuXG4gICAgICByZXR1cm4gY3VycmVudFQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0VEZvclgoYVgpIHtcbiAgICAgIHZhciBpbnRlcnZhbFN0YXJ0ID0gMC4wLFxuICAgICAgICAgIGN1cnJlbnRTYW1wbGUgPSAxLFxuICAgICAgICAgIGxhc3RTYW1wbGUgPSBrU3BsaW5lVGFibGVTaXplIC0gMTtcblxuICAgICAgZm9yICg7IGN1cnJlbnRTYW1wbGUgIT09IGxhc3RTYW1wbGUgJiYgbVNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSA8PSBhWDsgKytjdXJyZW50U2FtcGxlKSB7XG4gICAgICAgIGludGVydmFsU3RhcnQgKz0ga1NhbXBsZVN0ZXBTaXplO1xuICAgICAgfVxuXG4gICAgICAtLWN1cnJlbnRTYW1wbGU7XG4gICAgICB2YXIgZGlzdCA9IChhWCAtIG1TYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZV0pIC8gKG1TYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZSArIDFdIC0gbVNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSksXG4gICAgICAgICAgZ3Vlc3NGb3JUID0gaW50ZXJ2YWxTdGFydCArIGRpc3QgKiBrU2FtcGxlU3RlcFNpemUsXG4gICAgICAgICAgaW5pdGlhbFNsb3BlID0gZ2V0U2xvcGUoZ3Vlc3NGb3JULCBtWDEsIG1YMik7XG5cbiAgICAgIGlmIChpbml0aWFsU2xvcGUgPj0gTkVXVE9OX01JTl9TTE9QRSkge1xuICAgICAgICByZXR1cm4gbmV3dG9uUmFwaHNvbkl0ZXJhdGUoYVgsIGd1ZXNzRm9yVCk7XG4gICAgICB9IGVsc2UgaWYgKGluaXRpYWxTbG9wZSA9PT0gMC4wKSB7XG4gICAgICAgIHJldHVybiBndWVzc0ZvclQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYmluYXJ5U3ViZGl2aWRlKGFYLCBpbnRlcnZhbFN0YXJ0LCBpbnRlcnZhbFN0YXJ0ICsga1NhbXBsZVN0ZXBTaXplKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgX3ByZWNvbXB1dGVkID0gZmFsc2U7XG5cbiAgICBmdW5jdGlvbiBwcmVjb21wdXRlKCkge1xuICAgICAgX3ByZWNvbXB1dGVkID0gdHJ1ZTtcblxuICAgICAgaWYgKG1YMSAhPT0gbVkxIHx8IG1YMiAhPT0gbVkyKSB7XG4gICAgICAgIGNhbGNTYW1wbGVWYWx1ZXMoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZiA9IGZ1bmN0aW9uIGYoYVgpIHtcbiAgICAgIGlmICghX3ByZWNvbXB1dGVkKSB7XG4gICAgICAgIHByZWNvbXB1dGUoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1YMSA9PT0gbVkxICYmIG1YMiA9PT0gbVkyKSB7XG4gICAgICAgIHJldHVybiBhWDtcbiAgICAgIH1cblxuICAgICAgaWYgKGFYID09PSAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoYVggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjYWxjQmV6aWVyKGdldFRGb3JYKGFYKSwgbVkxLCBtWTIpO1xuICAgIH07XG5cbiAgICBmLmdldENvbnRyb2xQb2ludHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gW3tcbiAgICAgICAgeDogbVgxLFxuICAgICAgICB5OiBtWTFcbiAgICAgIH0sIHtcbiAgICAgICAgeDogbVgyLFxuICAgICAgICB5OiBtWTJcbiAgICAgIH1dO1xuICAgIH07XG5cbiAgICB2YXIgc3RyID0gXCJnZW5lcmF0ZUJlemllcihcIiArIFttWDEsIG1ZMSwgbVgyLCBtWTJdICsgXCIpXCI7XG5cbiAgICBmLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGY7XG4gIH1cblxuICAvKiEgUnVuZ2UtS3V0dGEgc3ByaW5nIHBoeXNpY3MgZnVuY3Rpb24gZ2VuZXJhdG9yLiBBZGFwdGVkIGZyb20gRnJhbWVyLmpzLCBjb3B5cmlnaHQgS29lbiBCb2suIE1JVCBMaWNlbnNlOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01JVF9MaWNlbnNlICovXG5cbiAgLyogR2l2ZW4gYSB0ZW5zaW9uLCBmcmljdGlvbiwgYW5kIGR1cmF0aW9uLCBhIHNpbXVsYXRpb24gYXQgNjBGUFMgd2lsbCBmaXJzdCBydW4gd2l0aG91dCBhIGRlZmluZWQgZHVyYXRpb24gaW4gb3JkZXIgdG8gY2FsY3VsYXRlIHRoZSBmdWxsIHBhdGguIEEgc2Vjb25kIHBhc3NcbiAgICAgdGhlbiBhZGp1c3RzIHRoZSB0aW1lIGRlbHRhIC0tIHVzaW5nIHRoZSByZWxhdGlvbiBiZXR3ZWVuIGFjdHVhbCB0aW1lIGFuZCBkdXJhdGlvbiAtLSB0byBjYWxjdWxhdGUgdGhlIHBhdGggZm9yIHRoZSBkdXJhdGlvbi1jb25zdHJhaW5lZCBhbmltYXRpb24uICovXG4gIHZhciBnZW5lcmF0ZVNwcmluZ1JLNCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBzcHJpbmdBY2NlbGVyYXRpb25Gb3JTdGF0ZShzdGF0ZSkge1xuICAgICAgcmV0dXJuIC1zdGF0ZS50ZW5zaW9uICogc3RhdGUueCAtIHN0YXRlLmZyaWN0aW9uICogc3RhdGUudjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzcHJpbmdFdmFsdWF0ZVN0YXRlV2l0aERlcml2YXRpdmUoaW5pdGlhbFN0YXRlLCBkdCwgZGVyaXZhdGl2ZSkge1xuICAgICAgdmFyIHN0YXRlID0ge1xuICAgICAgICB4OiBpbml0aWFsU3RhdGUueCArIGRlcml2YXRpdmUuZHggKiBkdCxcbiAgICAgICAgdjogaW5pdGlhbFN0YXRlLnYgKyBkZXJpdmF0aXZlLmR2ICogZHQsXG4gICAgICAgIHRlbnNpb246IGluaXRpYWxTdGF0ZS50ZW5zaW9uLFxuICAgICAgICBmcmljdGlvbjogaW5pdGlhbFN0YXRlLmZyaWN0aW9uXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZHg6IHN0YXRlLnYsXG4gICAgICAgIGR2OiBzcHJpbmdBY2NlbGVyYXRpb25Gb3JTdGF0ZShzdGF0ZSlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3ByaW5nSW50ZWdyYXRlU3RhdGUoc3RhdGUsIGR0KSB7XG4gICAgICB2YXIgYSA9IHtcbiAgICAgICAgZHg6IHN0YXRlLnYsXG4gICAgICAgIGR2OiBzcHJpbmdBY2NlbGVyYXRpb25Gb3JTdGF0ZShzdGF0ZSlcbiAgICAgIH0sXG4gICAgICAgICAgYiA9IHNwcmluZ0V2YWx1YXRlU3RhdGVXaXRoRGVyaXZhdGl2ZShzdGF0ZSwgZHQgKiAwLjUsIGEpLFxuICAgICAgICAgIGMgPSBzcHJpbmdFdmFsdWF0ZVN0YXRlV2l0aERlcml2YXRpdmUoc3RhdGUsIGR0ICogMC41LCBiKSxcbiAgICAgICAgICBkID0gc3ByaW5nRXZhbHVhdGVTdGF0ZVdpdGhEZXJpdmF0aXZlKHN0YXRlLCBkdCwgYyksXG4gICAgICAgICAgZHhkdCA9IDEuMCAvIDYuMCAqIChhLmR4ICsgMi4wICogKGIuZHggKyBjLmR4KSArIGQuZHgpLFxuICAgICAgICAgIGR2ZHQgPSAxLjAgLyA2LjAgKiAoYS5kdiArIDIuMCAqIChiLmR2ICsgYy5kdikgKyBkLmR2KTtcbiAgICAgIHN0YXRlLnggPSBzdGF0ZS54ICsgZHhkdCAqIGR0O1xuICAgICAgc3RhdGUudiA9IHN0YXRlLnYgKyBkdmR0ICogZHQ7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHNwcmluZ1JLNEZhY3RvcnkodGVuc2lvbiwgZnJpY3Rpb24sIGR1cmF0aW9uKSB7XG4gICAgICB2YXIgaW5pdFN0YXRlID0ge1xuICAgICAgICB4OiAtMSxcbiAgICAgICAgdjogMCxcbiAgICAgICAgdGVuc2lvbjogbnVsbCxcbiAgICAgICAgZnJpY3Rpb246IG51bGxcbiAgICAgIH0sXG4gICAgICAgICAgcGF0aCA9IFswXSxcbiAgICAgICAgICB0aW1lX2xhcHNlZCA9IDAsXG4gICAgICAgICAgdG9sZXJhbmNlID0gMSAvIDEwMDAwLFxuICAgICAgICAgIERUID0gMTYgLyAxMDAwLFxuICAgICAgICAgIGhhdmVfZHVyYXRpb24sXG4gICAgICAgICAgZHQsXG4gICAgICAgICAgbGFzdF9zdGF0ZTtcbiAgICAgIHRlbnNpb24gPSBwYXJzZUZsb2F0KHRlbnNpb24pIHx8IDUwMDtcbiAgICAgIGZyaWN0aW9uID0gcGFyc2VGbG9hdChmcmljdGlvbikgfHwgMjA7XG4gICAgICBkdXJhdGlvbiA9IGR1cmF0aW9uIHx8IG51bGw7XG4gICAgICBpbml0U3RhdGUudGVuc2lvbiA9IHRlbnNpb247XG4gICAgICBpbml0U3RhdGUuZnJpY3Rpb24gPSBmcmljdGlvbjtcbiAgICAgIGhhdmVfZHVyYXRpb24gPSBkdXJhdGlvbiAhPT0gbnVsbDtcbiAgICAgIC8qIENhbGN1bGF0ZSB0aGUgYWN0dWFsIHRpbWUgaXQgdGFrZXMgZm9yIHRoaXMgYW5pbWF0aW9uIHRvIGNvbXBsZXRlIHdpdGggdGhlIHByb3ZpZGVkIGNvbmRpdGlvbnMuICovXG5cbiAgICAgIGlmIChoYXZlX2R1cmF0aW9uKSB7XG4gICAgICAgIC8qIFJ1biB0aGUgc2ltdWxhdGlvbiB3aXRob3V0IGEgZHVyYXRpb24uICovXG4gICAgICAgIHRpbWVfbGFwc2VkID0gc3ByaW5nUks0RmFjdG9yeSh0ZW5zaW9uLCBmcmljdGlvbik7XG4gICAgICAgIC8qIENvbXB1dGUgdGhlIGFkanVzdGVkIHRpbWUgZGVsdGEuICovXG5cbiAgICAgICAgZHQgPSB0aW1lX2xhcHNlZCAvIGR1cmF0aW9uICogRFQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkdCA9IERUO1xuICAgICAgfVxuXG4gICAgICBmb3IgKDs7KSB7XG4gICAgICAgIC8qIE5leHQvc3RlcCBmdW5jdGlvbiAuKi9cbiAgICAgICAgbGFzdF9zdGF0ZSA9IHNwcmluZ0ludGVncmF0ZVN0YXRlKGxhc3Rfc3RhdGUgfHwgaW5pdFN0YXRlLCBkdCk7XG4gICAgICAgIC8qIFN0b3JlIHRoZSBwb3NpdGlvbi4gKi9cblxuICAgICAgICBwYXRoLnB1c2goMSArIGxhc3Rfc3RhdGUueCk7XG4gICAgICAgIHRpbWVfbGFwc2VkICs9IDE2O1xuICAgICAgICAvKiBJZiB0aGUgY2hhbmdlIHRocmVzaG9sZCBpcyByZWFjaGVkLCBicmVhay4gKi9cblxuICAgICAgICBpZiAoIShNYXRoLmFicyhsYXN0X3N0YXRlLngpID4gdG9sZXJhbmNlICYmIE1hdGguYWJzKGxhc3Rfc3RhdGUudikgPiB0b2xlcmFuY2UpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qIElmIGR1cmF0aW9uIGlzIG5vdCBkZWZpbmVkLCByZXR1cm4gdGhlIGFjdHVhbCB0aW1lIHJlcXVpcmVkIGZvciBjb21wbGV0aW5nIHRoaXMgYW5pbWF0aW9uLiBPdGhlcndpc2UsIHJldHVybiBhIGNsb3N1cmUgdGhhdCBob2xkcyB0aGVcbiAgICAgICAgIGNvbXB1dGVkIHBhdGggYW5kIHJldHVybnMgYSBzbmFwc2hvdCBvZiB0aGUgcG9zaXRpb24gYWNjb3JkaW5nIHRvIGEgZ2l2ZW4gcGVyY2VudENvbXBsZXRlLiAqL1xuXG5cbiAgICAgIHJldHVybiAhaGF2ZV9kdXJhdGlvbiA/IHRpbWVfbGFwc2VkIDogZnVuY3Rpb24gKHBlcmNlbnRDb21wbGV0ZSkge1xuICAgICAgICByZXR1cm4gcGF0aFtwZXJjZW50Q29tcGxldGUgKiAocGF0aC5sZW5ndGggLSAxKSB8IDBdO1xuICAgICAgfTtcbiAgICB9O1xuICB9KCk7XG5cbiAgdmFyIGN1YmljQmV6aWVyID0gZnVuY3Rpb24gY3ViaWNCZXppZXIodDEsIHAxLCB0MiwgcDIpIHtcbiAgICB2YXIgYmV6aWVyID0gZ2VuZXJhdGVDdWJpY0Jlemllcih0MSwgcDEsIHQyLCBwMik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdGFydCwgZW5kLCBwZXJjZW50KSB7XG4gICAgICByZXR1cm4gc3RhcnQgKyAoZW5kIC0gc3RhcnQpICogYmV6aWVyKHBlcmNlbnQpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGVhc2luZ3MgPSB7XG4gICAgJ2xpbmVhcic6IGZ1bmN0aW9uIGxpbmVhcihzdGFydCwgZW5kLCBwZXJjZW50KSB7XG4gICAgICByZXR1cm4gc3RhcnQgKyAoZW5kIC0gc3RhcnQpICogcGVyY2VudDtcbiAgICB9LFxuICAgIC8vIGRlZmF1bHQgZWFzaW5nc1xuICAgICdlYXNlJzogY3ViaWNCZXppZXIoMC4yNSwgMC4xLCAwLjI1LCAxKSxcbiAgICAnZWFzZS1pbic6IGN1YmljQmV6aWVyKDAuNDIsIDAsIDEsIDEpLFxuICAgICdlYXNlLW91dCc6IGN1YmljQmV6aWVyKDAsIDAsIDAuNTgsIDEpLFxuICAgICdlYXNlLWluLW91dCc6IGN1YmljQmV6aWVyKDAuNDIsIDAsIDAuNTgsIDEpLFxuICAgIC8vIHNpbmVcbiAgICAnZWFzZS1pbi1zaW5lJzogY3ViaWNCZXppZXIoMC40NywgMCwgMC43NDUsIDAuNzE1KSxcbiAgICAnZWFzZS1vdXQtc2luZSc6IGN1YmljQmV6aWVyKDAuMzksIDAuNTc1LCAwLjU2NSwgMSksXG4gICAgJ2Vhc2UtaW4tb3V0LXNpbmUnOiBjdWJpY0JlemllcigwLjQ0NSwgMC4wNSwgMC41NSwgMC45NSksXG4gICAgLy8gcXVhZFxuICAgICdlYXNlLWluLXF1YWQnOiBjdWJpY0JlemllcigwLjU1LCAwLjA4NSwgMC42OCwgMC41MyksXG4gICAgJ2Vhc2Utb3V0LXF1YWQnOiBjdWJpY0JlemllcigwLjI1LCAwLjQ2LCAwLjQ1LCAwLjk0KSxcbiAgICAnZWFzZS1pbi1vdXQtcXVhZCc6IGN1YmljQmV6aWVyKDAuNDU1LCAwLjAzLCAwLjUxNSwgMC45NTUpLFxuICAgIC8vIGN1YmljXG4gICAgJ2Vhc2UtaW4tY3ViaWMnOiBjdWJpY0JlemllcigwLjU1LCAwLjA1NSwgMC42NzUsIDAuMTkpLFxuICAgICdlYXNlLW91dC1jdWJpYyc6IGN1YmljQmV6aWVyKDAuMjE1LCAwLjYxLCAwLjM1NSwgMSksXG4gICAgJ2Vhc2UtaW4tb3V0LWN1YmljJzogY3ViaWNCZXppZXIoMC42NDUsIDAuMDQ1LCAwLjM1NSwgMSksXG4gICAgLy8gcXVhcnRcbiAgICAnZWFzZS1pbi1xdWFydCc6IGN1YmljQmV6aWVyKDAuODk1LCAwLjAzLCAwLjY4NSwgMC4yMiksXG4gICAgJ2Vhc2Utb3V0LXF1YXJ0JzogY3ViaWNCZXppZXIoMC4xNjUsIDAuODQsIDAuNDQsIDEpLFxuICAgICdlYXNlLWluLW91dC1xdWFydCc6IGN1YmljQmV6aWVyKDAuNzcsIDAsIDAuMTc1LCAxKSxcbiAgICAvLyBxdWludFxuICAgICdlYXNlLWluLXF1aW50JzogY3ViaWNCZXppZXIoMC43NTUsIDAuMDUsIDAuODU1LCAwLjA2KSxcbiAgICAnZWFzZS1vdXQtcXVpbnQnOiBjdWJpY0JlemllcigwLjIzLCAxLCAwLjMyLCAxKSxcbiAgICAnZWFzZS1pbi1vdXQtcXVpbnQnOiBjdWJpY0JlemllcigwLjg2LCAwLCAwLjA3LCAxKSxcbiAgICAvLyBleHBvXG4gICAgJ2Vhc2UtaW4tZXhwbyc6IGN1YmljQmV6aWVyKDAuOTUsIDAuMDUsIDAuNzk1LCAwLjAzNSksXG4gICAgJ2Vhc2Utb3V0LWV4cG8nOiBjdWJpY0JlemllcigwLjE5LCAxLCAwLjIyLCAxKSxcbiAgICAnZWFzZS1pbi1vdXQtZXhwbyc6IGN1YmljQmV6aWVyKDEsIDAsIDAsIDEpLFxuICAgIC8vIGNpcmNcbiAgICAnZWFzZS1pbi1jaXJjJzogY3ViaWNCZXppZXIoMC42LCAwLjA0LCAwLjk4LCAwLjMzNSksXG4gICAgJ2Vhc2Utb3V0LWNpcmMnOiBjdWJpY0JlemllcigwLjA3NSwgMC44MiwgMC4xNjUsIDEpLFxuICAgICdlYXNlLWluLW91dC1jaXJjJzogY3ViaWNCZXppZXIoMC43ODUsIDAuMTM1LCAwLjE1LCAwLjg2KSxcbiAgICAvLyB1c2VyIHBhcmFtIGVhc2luZ3MuLi5cbiAgICAnc3ByaW5nJzogZnVuY3Rpb24gc3ByaW5nKHRlbnNpb24sIGZyaWN0aW9uLCBkdXJhdGlvbikge1xuICAgICAgaWYgKGR1cmF0aW9uID09PSAwKSB7XG4gICAgICAgIC8vIGNhbid0IGdldCBhIHNwcmluZyB3LyBkdXJhdGlvbiAwXG4gICAgICAgIHJldHVybiBlYXNpbmdzLmxpbmVhcjsgLy8gZHVyYXRpb24gMCA9PiBqdW1wIHRvIGVuZCBzbyBpbXBsIGRvZXNuJ3QgbWF0dGVyXG4gICAgICB9XG5cbiAgICAgIHZhciBzcHJpbmcgPSBnZW5lcmF0ZVNwcmluZ1JLNCh0ZW5zaW9uLCBmcmljdGlvbiwgZHVyYXRpb24pO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzdGFydCwgZW5kLCBwZXJjZW50KSB7XG4gICAgICAgIHJldHVybiBzdGFydCArIChlbmQgLSBzdGFydCkgKiBzcHJpbmcocGVyY2VudCk7XG4gICAgICB9O1xuICAgIH0sXG4gICAgJ2N1YmljLWJlemllcic6IGN1YmljQmV6aWVyXG4gIH07XG5cbiAgZnVuY3Rpb24gZ2V0RWFzZWRWYWx1ZSh0eXBlLCBzdGFydCwgZW5kLCBwZXJjZW50LCBlYXNpbmdGbikge1xuICAgIGlmIChwZXJjZW50ID09PSAxKSB7XG4gICAgICByZXR1cm4gZW5kO1xuICAgIH1cblxuICAgIGlmIChzdGFydCA9PT0gZW5kKSB7XG4gICAgICByZXR1cm4gZW5kO1xuICAgIH1cblxuICAgIHZhciB2YWwgPSBlYXNpbmdGbihzdGFydCwgZW5kLCBwZXJjZW50KTtcblxuICAgIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUucm91bmRWYWx1ZSB8fCB0eXBlLmNvbG9yKSB7XG4gICAgICB2YWwgPSBNYXRoLnJvdW5kKHZhbCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUubWluICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhbCA9IE1hdGgubWF4KHZhbCwgdHlwZS5taW4pO1xuICAgIH1cblxuICAgIGlmICh0eXBlLm1heCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YWwgPSBNYXRoLm1pbih2YWwsIHR5cGUubWF4KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VmFsdWUocHJvcCwgc3BlYykge1xuICAgIGlmIChwcm9wLnBmVmFsdWUgIT0gbnVsbCB8fCBwcm9wLnZhbHVlICE9IG51bGwpIHtcbiAgICAgIGlmIChwcm9wLnBmVmFsdWUgIT0gbnVsbCAmJiAoc3BlYyA9PSBudWxsIHx8IHNwZWMudHlwZS51bml0cyAhPT0gJyUnKSkge1xuICAgICAgICByZXR1cm4gcHJvcC5wZlZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHByb3AudmFsdWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwcm9wO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVhc2Uoc3RhcnRQcm9wLCBlbmRQcm9wLCBwZXJjZW50LCBlYXNpbmdGbiwgcHJvcFNwZWMpIHtcbiAgICB2YXIgdHlwZSA9IHByb3BTcGVjICE9IG51bGwgPyBwcm9wU3BlYy50eXBlIDogbnVsbDtcblxuICAgIGlmIChwZXJjZW50IDwgMCkge1xuICAgICAgcGVyY2VudCA9IDA7XG4gICAgfSBlbHNlIGlmIChwZXJjZW50ID4gMSkge1xuICAgICAgcGVyY2VudCA9IDE7XG4gICAgfVxuXG4gICAgdmFyIHN0YXJ0ID0gZ2V0VmFsdWUoc3RhcnRQcm9wLCBwcm9wU3BlYyk7XG4gICAgdmFyIGVuZCA9IGdldFZhbHVlKGVuZFByb3AsIHByb3BTcGVjKTtcblxuICAgIGlmIChudW1iZXIkMShzdGFydCkgJiYgbnVtYmVyJDEoZW5kKSkge1xuICAgICAgcmV0dXJuIGdldEVhc2VkVmFsdWUodHlwZSwgc3RhcnQsIGVuZCwgcGVyY2VudCwgZWFzaW5nRm4pO1xuICAgIH0gZWxzZSBpZiAoYXJyYXkoc3RhcnQpICYmIGFycmF5KGVuZCkpIHtcbiAgICAgIHZhciBlYXNlZEFyciA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVuZC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc2kgPSBzdGFydFtpXTtcbiAgICAgICAgdmFyIGVpID0gZW5kW2ldO1xuXG4gICAgICAgIGlmIChzaSAhPSBudWxsICYmIGVpICE9IG51bGwpIHtcbiAgICAgICAgICB2YXIgdmFsID0gZ2V0RWFzZWRWYWx1ZSh0eXBlLCBzaSwgZWksIHBlcmNlbnQsIGVhc2luZ0ZuKTtcbiAgICAgICAgICBlYXNlZEFyci5wdXNoKHZhbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWFzZWRBcnIucHVzaChlaSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVhc2VkQXJyO1xuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBzdGVwJDEoc2VsZiwgYW5pLCBub3csIGlzQ29yZSkge1xuICAgIHZhciBpc0VsZXMgPSAhaXNDb3JlO1xuICAgIHZhciBfcCA9IHNlbGYuX3ByaXZhdGU7XG4gICAgdmFyIGFuaV9wID0gYW5pLl9wcml2YXRlO1xuICAgIHZhciBwRWFzaW5nID0gYW5pX3AuZWFzaW5nO1xuICAgIHZhciBzdGFydFRpbWUgPSBhbmlfcC5zdGFydFRpbWU7XG4gICAgdmFyIGN5ID0gaXNDb3JlID8gc2VsZiA6IHNlbGYuY3koKTtcbiAgICB2YXIgc3R5bGUgPSBjeS5zdHlsZSgpO1xuXG4gICAgaWYgKCFhbmlfcC5lYXNpbmdJbXBsKSB7XG4gICAgICBpZiAocEVhc2luZyA9PSBudWxsKSB7XG4gICAgICAgIC8vIHVzZSBkZWZhdWx0XG4gICAgICAgIGFuaV9wLmVhc2luZ0ltcGwgPSBlYXNpbmdzWydsaW5lYXInXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHRoZW4gZGVmaW5lIHcvIG5hbWVcbiAgICAgICAgdmFyIGVhc2luZ1ZhbHM7XG5cbiAgICAgICAgaWYgKHN0cmluZyhwRWFzaW5nKSkge1xuICAgICAgICAgIHZhciBlYXNpbmdQcm9wID0gc3R5bGUucGFyc2UoJ3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uJywgcEVhc2luZyk7XG4gICAgICAgICAgZWFzaW5nVmFscyA9IGVhc2luZ1Byb3AudmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdGhlbiBhc3N1bWUgcHJlcGFyc2VkIGFycmF5XG4gICAgICAgICAgZWFzaW5nVmFscyA9IHBFYXNpbmc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmFtZSwgYXJncztcblxuICAgICAgICBpZiAoc3RyaW5nKGVhc2luZ1ZhbHMpKSB7XG4gICAgICAgICAgbmFtZSA9IGVhc2luZ1ZhbHM7XG4gICAgICAgICAgYXJncyA9IFtdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5hbWUgPSBlYXNpbmdWYWxzWzFdO1xuICAgICAgICAgIGFyZ3MgPSBlYXNpbmdWYWxzLnNsaWNlKDIpLm1hcChmdW5jdGlvbiAobikge1xuICAgICAgICAgICAgcmV0dXJuICtuO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgIC8vIGNyZWF0ZSB3aXRoIGFyZ3NcbiAgICAgICAgICBpZiAobmFtZSA9PT0gJ3NwcmluZycpIHtcbiAgICAgICAgICAgIGFyZ3MucHVzaChhbmlfcC5kdXJhdGlvbik7IC8vIG5lZWQgZHVyYXRpb24gdG8gZ2VuZXJhdGUgc3ByaW5nXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYW5pX3AuZWFzaW5nSW1wbCA9IGVhc2luZ3NbbmFtZV0uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gc3RhdGljIGltcGwgYnkgbmFtZVxuICAgICAgICAgIGFuaV9wLmVhc2luZ0ltcGwgPSBlYXNpbmdzW25hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGVhc2luZyA9IGFuaV9wLmVhc2luZ0ltcGw7XG4gICAgdmFyIHBlcmNlbnQ7XG5cbiAgICBpZiAoYW5pX3AuZHVyYXRpb24gPT09IDApIHtcbiAgICAgIHBlcmNlbnQgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBwZXJjZW50ID0gKG5vdyAtIHN0YXJ0VGltZSkgLyBhbmlfcC5kdXJhdGlvbjtcbiAgICB9XG5cbiAgICBpZiAoYW5pX3AuYXBwbHlpbmcpIHtcbiAgICAgIHBlcmNlbnQgPSBhbmlfcC5wcm9ncmVzcztcbiAgICB9XG5cbiAgICBpZiAocGVyY2VudCA8IDApIHtcbiAgICAgIHBlcmNlbnQgPSAwO1xuICAgIH0gZWxzZSBpZiAocGVyY2VudCA+IDEpIHtcbiAgICAgIHBlcmNlbnQgPSAxO1xuICAgIH1cblxuICAgIGlmIChhbmlfcC5kZWxheSA9PSBudWxsKSB7XG4gICAgICAvLyB0aGVuIHVwZGF0ZVxuICAgICAgdmFyIHN0YXJ0UG9zID0gYW5pX3Auc3RhcnRQb3NpdGlvbjtcbiAgICAgIHZhciBlbmRQb3MgPSBhbmlfcC5wb3NpdGlvbjtcblxuICAgICAgaWYgKGVuZFBvcyAmJiBpc0VsZXMgJiYgIXNlbGYubG9ja2VkKCkpIHtcbiAgICAgICAgdmFyIG5ld1BvcyA9IHt9O1xuXG4gICAgICAgIGlmICh2YWxpZChzdGFydFBvcy54LCBlbmRQb3MueCkpIHtcbiAgICAgICAgICBuZXdQb3MueCA9IGVhc2Uoc3RhcnRQb3MueCwgZW5kUG9zLngsIHBlcmNlbnQsIGVhc2luZyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsaWQoc3RhcnRQb3MueSwgZW5kUG9zLnkpKSB7XG4gICAgICAgICAgbmV3UG9zLnkgPSBlYXNlKHN0YXJ0UG9zLnksIGVuZFBvcy55LCBwZXJjZW50LCBlYXNpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5wb3NpdGlvbihuZXdQb3MpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3RhcnRQYW4gPSBhbmlfcC5zdGFydFBhbjtcbiAgICAgIHZhciBlbmRQYW4gPSBhbmlfcC5wYW47XG4gICAgICB2YXIgcGFuID0gX3AucGFuO1xuICAgICAgdmFyIGFuaW1hdGluZ1BhbiA9IGVuZFBhbiAhPSBudWxsICYmIGlzQ29yZTtcblxuICAgICAgaWYgKGFuaW1hdGluZ1Bhbikge1xuICAgICAgICBpZiAodmFsaWQoc3RhcnRQYW4ueCwgZW5kUGFuLngpKSB7XG4gICAgICAgICAgcGFuLnggPSBlYXNlKHN0YXJ0UGFuLngsIGVuZFBhbi54LCBwZXJjZW50LCBlYXNpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbGlkKHN0YXJ0UGFuLnksIGVuZFBhbi55KSkge1xuICAgICAgICAgIHBhbi55ID0gZWFzZShzdGFydFBhbi55LCBlbmRQYW4ueSwgcGVyY2VudCwgZWFzaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuZW1pdCgncGFuJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzdGFydFpvb20gPSBhbmlfcC5zdGFydFpvb207XG4gICAgICB2YXIgZW5kWm9vbSA9IGFuaV9wLnpvb207XG4gICAgICB2YXIgYW5pbWF0aW5nWm9vbSA9IGVuZFpvb20gIT0gbnVsbCAmJiBpc0NvcmU7XG5cbiAgICAgIGlmIChhbmltYXRpbmdab29tKSB7XG4gICAgICAgIGlmICh2YWxpZChzdGFydFpvb20sIGVuZFpvb20pKSB7XG4gICAgICAgICAgX3Auem9vbSA9IGJvdW5kKF9wLm1pblpvb20sIGVhc2Uoc3RhcnRab29tLCBlbmRab29tLCBwZXJjZW50LCBlYXNpbmcpLCBfcC5tYXhab29tKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuZW1pdCgnem9vbScpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYW5pbWF0aW5nUGFuIHx8IGFuaW1hdGluZ1pvb20pIHtcbiAgICAgICAgc2VsZi5lbWl0KCd2aWV3cG9ydCcpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJvcHMgPSBhbmlfcC5zdHlsZTtcblxuICAgICAgaWYgKHByb3BzICYmIHByb3BzLmxlbmd0aCA+IDAgJiYgaXNFbGVzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuICAgICAgICAgIHZhciBfbmFtZSA9IHByb3AubmFtZTtcbiAgICAgICAgICB2YXIgZW5kID0gcHJvcDtcbiAgICAgICAgICB2YXIgc3RhcnQgPSBhbmlfcC5zdGFydFN0eWxlW19uYW1lXTtcbiAgICAgICAgICB2YXIgcHJvcFNwZWMgPSBzdHlsZS5wcm9wZXJ0aWVzW3N0YXJ0Lm5hbWVdO1xuICAgICAgICAgIHZhciBlYXNlZFZhbCA9IGVhc2Uoc3RhcnQsIGVuZCwgcGVyY2VudCwgZWFzaW5nLCBwcm9wU3BlYyk7XG4gICAgICAgICAgc3R5bGUub3ZlcnJpZGVCeXBhc3Moc2VsZiwgX25hbWUsIGVhc2VkVmFsKTtcbiAgICAgICAgfSAvLyBmb3IgcHJvcHNcblxuXG4gICAgICAgIHNlbGYuZW1pdCgnc3R5bGUnKTtcbiAgICAgIH0gLy8gaWZcblxuICAgIH1cblxuICAgIGFuaV9wLnByb2dyZXNzID0gcGVyY2VudDtcbiAgICByZXR1cm4gcGVyY2VudDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHZhbGlkKHN0YXJ0LCBlbmQpIHtcbiAgICBpZiAoc3RhcnQgPT0gbnVsbCB8fCBlbmQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChudW1iZXIkMShzdGFydCkgJiYgbnVtYmVyJDEoZW5kKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChzdGFydCAmJiBlbmQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0YXJ0QW5pbWF0aW9uKHNlbGYsIGFuaSwgbm93LCBpc0NvcmUpIHtcbiAgICB2YXIgYW5pX3AgPSBhbmkuX3ByaXZhdGU7XG4gICAgYW5pX3Auc3RhcnRlZCA9IHRydWU7XG4gICAgYW5pX3Auc3RhcnRUaW1lID0gbm93IC0gYW5pX3AucHJvZ3Jlc3MgKiBhbmlfcC5kdXJhdGlvbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0ZXBBbGwobm93LCBjeSkge1xuICAgIHZhciBlbGVzID0gY3kuX3ByaXZhdGUuYW5pRWxlcztcbiAgICB2YXIgZG9uZUVsZXMgPSBbXTtcblxuICAgIGZ1bmN0aW9uIHN0ZXBPbmUoZWxlLCBpc0NvcmUpIHtcbiAgICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICAgIHZhciBjdXJyZW50ID0gX3AuYW5pbWF0aW9uLmN1cnJlbnQ7XG4gICAgICB2YXIgcXVldWUgPSBfcC5hbmltYXRpb24ucXVldWU7XG4gICAgICB2YXIgcmFuQW5pcyA9IGZhbHNlOyAvLyBpZiBub3RoaW5nIGN1cnJlbnRseSBhbmltYXRpbmcsIGdldCBzb21ldGhpbmcgZnJvbSB0aGUgcXVldWVcblxuICAgICAgaWYgKGN1cnJlbnQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhciBuZXh0ID0gcXVldWUuc2hpZnQoKTtcblxuICAgICAgICBpZiAobmV4dCkge1xuICAgICAgICAgIGN1cnJlbnQucHVzaChuZXh0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgY2FsbGJhY2tzID0gZnVuY3Rpb24gY2FsbGJhY2tzKF9jYWxsYmFja3MpIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IF9jYWxsYmFja3MubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICB2YXIgY2IgPSBfY2FsbGJhY2tzW2pdO1xuICAgICAgICAgIGNiKCk7XG4gICAgICAgIH1cblxuICAgICAgICBfY2FsbGJhY2tzLnNwbGljZSgwLCBfY2FsbGJhY2tzLmxlbmd0aCk7XG4gICAgICB9OyAvLyBzdGVwIGFuZCByZW1vdmUgaWYgZG9uZVxuXG5cbiAgICAgIGZvciAodmFyIGkgPSBjdXJyZW50Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBhbmkgPSBjdXJyZW50W2ldO1xuICAgICAgICB2YXIgYW5pX3AgPSBhbmkuX3ByaXZhdGU7XG5cbiAgICAgICAgaWYgKGFuaV9wLnN0b3BwZWQpIHtcbiAgICAgICAgICBjdXJyZW50LnNwbGljZShpLCAxKTtcbiAgICAgICAgICBhbmlfcC5ob29rZWQgPSBmYWxzZTtcbiAgICAgICAgICBhbmlfcC5wbGF5aW5nID0gZmFsc2U7XG4gICAgICAgICAgYW5pX3Auc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgIGNhbGxiYWNrcyhhbmlfcC5mcmFtZXMpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFhbmlfcC5wbGF5aW5nICYmICFhbmlfcC5hcHBseWluZykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIGFuIGFwcGx5KCkgd2hpbGUgcGxheWluZyBzaG91bGRuJ3QgZG8gYW55dGhpbmdcblxuXG4gICAgICAgIGlmIChhbmlfcC5wbGF5aW5nICYmIGFuaV9wLmFwcGx5aW5nKSB7XG4gICAgICAgICAgYW5pX3AuYXBwbHlpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghYW5pX3Auc3RhcnRlZCkge1xuICAgICAgICAgIHN0YXJ0QW5pbWF0aW9uKGVsZSwgYW5pLCBub3cpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RlcCQxKGVsZSwgYW5pLCBub3csIGlzQ29yZSk7XG5cbiAgICAgICAgaWYgKGFuaV9wLmFwcGx5aW5nKSB7XG4gICAgICAgICAgYW5pX3AuYXBwbHlpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxiYWNrcyhhbmlfcC5mcmFtZXMpO1xuXG4gICAgICAgIGlmIChhbmlfcC5zdGVwICE9IG51bGwpIHtcbiAgICAgICAgICBhbmlfcC5zdGVwKG5vdyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYW5pLmNvbXBsZXRlZCgpKSB7XG4gICAgICAgICAgY3VycmVudC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgYW5pX3AuaG9va2VkID0gZmFsc2U7XG4gICAgICAgICAgYW5pX3AucGxheWluZyA9IGZhbHNlO1xuICAgICAgICAgIGFuaV9wLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICBjYWxsYmFja3MoYW5pX3AuY29tcGxldGVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJhbkFuaXMgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzQ29yZSAmJiBjdXJyZW50Lmxlbmd0aCA9PT0gMCAmJiBxdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZG9uZUVsZXMucHVzaChlbGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmFuQW5pcztcbiAgICB9IC8vIHN0ZXBFbGVtZW50XG4gICAgLy8gaGFuZGxlIGFsbCBlbGVzXG5cblxuICAgIHZhciByYW5FbGVBbmkgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGUgPSAwOyBlIDwgZWxlcy5sZW5ndGg7IGUrKykge1xuICAgICAgdmFyIGVsZSA9IGVsZXNbZV07XG4gICAgICB2YXIgaGFuZGxlZFRoaXNFbGUgPSBzdGVwT25lKGVsZSk7XG4gICAgICByYW5FbGVBbmkgPSByYW5FbGVBbmkgfHwgaGFuZGxlZFRoaXNFbGU7XG4gICAgfSAvLyBlYWNoIGVsZW1lbnRcblxuXG4gICAgdmFyIHJhbkNvcmVBbmkgPSBzdGVwT25lKGN5LCB0cnVlKTsgLy8gbm90aWZ5IHJlbmRlcmVyXG5cbiAgICBpZiAocmFuRWxlQW5pIHx8IHJhbkNvcmVBbmkpIHtcbiAgICAgIGlmIChlbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY3kubm90aWZ5KCdkcmF3JywgZWxlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjeS5ub3RpZnkoJ2RyYXcnKTtcbiAgICAgIH1cbiAgICB9IC8vIHJlbW92ZSBlbGVtZW50cyBmcm9tIGxpc3Qgb2YgY3VycmVudGx5IGFuaW1hdGluZyBpZiBpdHMgcXVldWVzIGFyZSBlbXB0eVxuXG5cbiAgICBlbGVzLnVubWVyZ2UoZG9uZUVsZXMpO1xuICAgIGN5LmVtaXQoJ3N0ZXAnKTtcbiAgfSAvLyBzdGVwQWxsXG5cbiAgdmFyIGNvcmVmbiQ4ID0ge1xuICAgIC8vIHB1bGwgaW4gYW5pbWF0aW9uIGZ1bmN0aW9uc1xuICAgIGFuaW1hdGU6IGRlZmluZS5hbmltYXRlKCksXG4gICAgYW5pbWF0aW9uOiBkZWZpbmUuYW5pbWF0aW9uKCksXG4gICAgYW5pbWF0ZWQ6IGRlZmluZS5hbmltYXRlZCgpLFxuICAgIGNsZWFyUXVldWU6IGRlZmluZS5jbGVhclF1ZXVlKCksXG4gICAgZGVsYXk6IGRlZmluZS5kZWxheSgpLFxuICAgIGRlbGF5QW5pbWF0aW9uOiBkZWZpbmUuZGVsYXlBbmltYXRpb24oKSxcbiAgICBzdG9wOiBkZWZpbmUuc3RvcCgpLFxuICAgIGFkZFRvQW5pbWF0aW9uUG9vbDogZnVuY3Rpb24gYWRkVG9BbmltYXRpb25Qb29sKGVsZXMpIHtcbiAgICAgIHZhciBjeSA9IHRoaXM7XG5cbiAgICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBzYXZlIGN5Y2xlcyB3aGVuIG5vIHN0eWxlIHVzZWRcblxuXG4gICAgICBjeS5fcHJpdmF0ZS5hbmlFbGVzLm1lcmdlKGVsZXMpO1xuICAgIH0sXG4gICAgc3RvcEFuaW1hdGlvbkxvb3A6IGZ1bmN0aW9uIHN0b3BBbmltYXRpb25Mb29wKCkge1xuICAgICAgdGhpcy5fcHJpdmF0ZS5hbmltYXRpb25zUnVubmluZyA9IGZhbHNlO1xuICAgIH0sXG4gICAgc3RhcnRBbmltYXRpb25Mb29wOiBmdW5jdGlvbiBzdGFydEFuaW1hdGlvbkxvb3AoKSB7XG4gICAgICB2YXIgY3kgPSB0aGlzO1xuICAgICAgY3kuX3ByaXZhdGUuYW5pbWF0aW9uc1J1bm5pbmcgPSB0cnVlO1xuXG4gICAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gc2F2ZSBjeWNsZXMgd2hlbiBubyBzdHlsZSB1c2VkXG4gICAgICAvLyBOQiB0aGUgYW5pbWF0aW9uIGxvb3Agd2lsbCBleGVjIGluIGhlYWRsZXNzIGVudmlyb25tZW50cyBpZiBzdHlsZSBlbmFibGVkXG4gICAgICAvLyBhbmQgZXhwbGljaXQgY3kuZGVzdHJveSgpIGlzIG5lY2Vzc2FyeSB0byBzdG9wIHRoZSBsb29wXG5cblxuICAgICAgZnVuY3Rpb24gaGVhZGxlc3NTdGVwKCkge1xuICAgICAgICBpZiAoIWN5Ll9wcml2YXRlLmFuaW1hdGlvbnNSdW5uaW5nKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uIGFuaW1hdGlvblN0ZXAobm93KSB7XG4gICAgICAgICAgc3RlcEFsbChub3csIGN5KTtcbiAgICAgICAgICBoZWFkbGVzc1N0ZXAoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZW5kZXJlciA9IGN5LnJlbmRlcmVyKCk7XG5cbiAgICAgIGlmIChyZW5kZXJlciAmJiByZW5kZXJlci5iZWZvcmVSZW5kZXIpIHtcbiAgICAgICAgLy8gbGV0IHRoZSByZW5kZXJlciBzY2hlZHVsZSBhbmltYXRpb25zXG4gICAgICAgIHJlbmRlcmVyLmJlZm9yZVJlbmRlcihmdW5jdGlvbiByZW5kZXJlckFuaW1hdGlvblN0ZXAod2lsbERyYXcsIG5vdykge1xuICAgICAgICAgIHN0ZXBBbGwobm93LCBjeSk7XG4gICAgICAgIH0sIHJlbmRlcmVyLmJlZm9yZVJlbmRlclByaW9yaXRpZXMuYW5pbWF0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBtYW5hZ2UgdGhlIGFuaW1hdGlvbiBsb29wIG91cnNlbHZlc1xuICAgICAgICBoZWFkbGVzc1N0ZXAoKTsgLy8gZmlyc3QgY2FsbFxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgZW1pdHRlck9wdGlvbnMgPSB7XG4gICAgcXVhbGlmaWVyQ29tcGFyZTogZnVuY3Rpb24gcXVhbGlmaWVyQ29tcGFyZShzZWxlY3RvcjEsIHNlbGVjdG9yMikge1xuICAgICAgaWYgKHNlbGVjdG9yMSA9PSBudWxsIHx8IHNlbGVjdG9yMiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzZWxlY3RvcjEgPT0gbnVsbCAmJiBzZWxlY3RvcjIgPT0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzZWxlY3RvcjEuc2FtZVRleHQoc2VsZWN0b3IyKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGV2ZW50TWF0Y2hlczogZnVuY3Rpb24gZXZlbnRNYXRjaGVzKGN5LCBsaXN0ZW5lciwgZXZlbnRPYmopIHtcbiAgICAgIHZhciBzZWxlY3RvciA9IGxpc3RlbmVyLnF1YWxpZmllcjtcblxuICAgICAgaWYgKHNlbGVjdG9yICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGN5ICE9PSBldmVudE9iai50YXJnZXQgJiYgZWxlbWVudChldmVudE9iai50YXJnZXQpICYmIHNlbGVjdG9yLm1hdGNoZXMoZXZlbnRPYmoudGFyZ2V0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBhZGRFdmVudEZpZWxkczogZnVuY3Rpb24gYWRkRXZlbnRGaWVsZHMoY3ksIGV2dCkge1xuICAgICAgZXZ0LmN5ID0gY3k7XG4gICAgICBldnQudGFyZ2V0ID0gY3k7XG4gICAgfSxcbiAgICBjYWxsYmFja0NvbnRleHQ6IGZ1bmN0aW9uIGNhbGxiYWNrQ29udGV4dChjeSwgbGlzdGVuZXIsIGV2ZW50T2JqKSB7XG4gICAgICByZXR1cm4gbGlzdGVuZXIucXVhbGlmaWVyICE9IG51bGwgPyBldmVudE9iai50YXJnZXQgOiBjeTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGFyZ1NlbGVjdG9yID0gZnVuY3Rpb24gYXJnU2VsZWN0b3IoYXJnKSB7XG4gICAgaWYgKHN0cmluZyhhcmcpKSB7XG4gICAgICByZXR1cm4gbmV3IFNlbGVjdG9yKGFyZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhcmc7XG4gICAgfVxuICB9O1xuXG4gIHZhciBlbGVzZm4gPSB7XG4gICAgY3JlYXRlRW1pdHRlcjogZnVuY3Rpb24gY3JlYXRlRW1pdHRlcigpIHtcbiAgICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICAgIGlmICghX3AuZW1pdHRlcikge1xuICAgICAgICBfcC5lbWl0dGVyID0gbmV3IEVtaXR0ZXIoZW1pdHRlck9wdGlvbnMsIHRoaXMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGVtaXR0ZXI6IGZ1bmN0aW9uIGVtaXR0ZXIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5lbWl0dGVyO1xuICAgIH0sXG4gICAgb246IGZ1bmN0aW9uIG9uKGV2ZW50cywgc2VsZWN0b3IsIGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLmVtaXR0ZXIoKS5vbihldmVudHMsIGFyZ1NlbGVjdG9yKHNlbGVjdG9yKSwgY2FsbGJhY2spO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICByZW1vdmVMaXN0ZW5lcjogZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoZXZlbnRzLCBzZWxlY3RvciwgY2FsbGJhY2spIHtcbiAgICAgIHRoaXMuZW1pdHRlcigpLnJlbW92ZUxpc3RlbmVyKGV2ZW50cywgYXJnU2VsZWN0b3Ioc2VsZWN0b3IpLCBjYWxsYmFjayk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHJlbW92ZUFsbExpc3RlbmVyczogZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKCkge1xuICAgICAgdGhpcy5lbWl0dGVyKCkucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIG9uZTogZnVuY3Rpb24gb25lKGV2ZW50cywgc2VsZWN0b3IsIGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLmVtaXR0ZXIoKS5vbmUoZXZlbnRzLCBhcmdTZWxlY3RvcihzZWxlY3RvciksIGNhbGxiYWNrKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgb25jZTogZnVuY3Rpb24gb25jZShldmVudHMsIHNlbGVjdG9yLCBjYWxsYmFjaykge1xuICAgICAgdGhpcy5lbWl0dGVyKCkub25lKGV2ZW50cywgYXJnU2VsZWN0b3Ioc2VsZWN0b3IpLCBjYWxsYmFjayk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGVtaXQ6IGZ1bmN0aW9uIGVtaXQoZXZlbnRzLCBleHRyYVBhcmFtcykge1xuICAgICAgdGhpcy5lbWl0dGVyKCkuZW1pdChldmVudHMsIGV4dHJhUGFyYW1zKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZW1pdEFuZE5vdGlmeTogZnVuY3Rpb24gZW1pdEFuZE5vdGlmeShldmVudCwgZWxlcykge1xuICAgICAgdGhpcy5lbWl0KGV2ZW50KTtcbiAgICAgIHRoaXMubm90aWZ5KGV2ZW50LCBlbGVzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcbiAgZGVmaW5lLmV2ZW50QWxpYXNlc09uKGVsZXNmbik7XG5cbiAgdmFyIGNvcmVmbiQ3ID0ge1xuICAgIHBuZzogZnVuY3Rpb24gcG5nKG9wdGlvbnMpIHtcbiAgICAgIHZhciByZW5kZXJlciA9IHRoaXMuX3ByaXZhdGUucmVuZGVyZXI7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIHJldHVybiByZW5kZXJlci5wbmcob3B0aW9ucyk7XG4gICAgfSxcbiAgICBqcGc6IGZ1bmN0aW9uIGpwZyhvcHRpb25zKSB7XG4gICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLl9wcml2YXRlLnJlbmRlcmVyO1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICBvcHRpb25zLmJnID0gb3B0aW9ucy5iZyB8fCAnI2ZmZic7XG4gICAgICByZXR1cm4gcmVuZGVyZXIuanBnKG9wdGlvbnMpO1xuICAgIH1cbiAgfTtcbiAgY29yZWZuJDcuanBlZyA9IGNvcmVmbiQ3LmpwZztcblxuICB2YXIgY29yZWZuJDYgPSB7XG4gICAgbGF5b3V0OiBmdW5jdGlvbiBsYXlvdXQob3B0aW9ucykge1xuICAgICAgdmFyIGN5ID0gdGhpcztcblxuICAgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICBlcnJvcignTGF5b3V0IG9wdGlvbnMgbXVzdCBiZSBzcGVjaWZpZWQgdG8gbWFrZSBhIGxheW91dCcpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLm5hbWUgPT0gbnVsbCkge1xuICAgICAgICBlcnJvcignQSBgbmFtZWAgbXVzdCBiZSBzcGVjaWZpZWQgdG8gbWFrZSBhIGxheW91dCcpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBuYW1lID0gb3B0aW9ucy5uYW1lO1xuICAgICAgdmFyIExheW91dCA9IGN5LmV4dGVuc2lvbignbGF5b3V0JywgbmFtZSk7XG5cbiAgICAgIGlmIChMYXlvdXQgPT0gbnVsbCkge1xuICAgICAgICBlcnJvcignTm8gc3VjaCBsYXlvdXQgYCcgKyBuYW1lICsgJ2AgZm91bmQuICBEaWQgeW91IGZvcmdldCB0byBpbXBvcnQgaXQgYW5kIGBjeXRvc2NhcGUudXNlKClgIGl0PycpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBlbGVzO1xuXG4gICAgICBpZiAoc3RyaW5nKG9wdGlvbnMuZWxlcykpIHtcbiAgICAgICAgZWxlcyA9IGN5LiQob3B0aW9ucy5lbGVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZXMgPSBvcHRpb25zLmVsZXMgIT0gbnVsbCA/IG9wdGlvbnMuZWxlcyA6IGN5LiQoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxheW91dCA9IG5ldyBMYXlvdXQoZXh0ZW5kKHt9LCBvcHRpb25zLCB7XG4gICAgICAgIGN5OiBjeSxcbiAgICAgICAgZWxlczogZWxlc1xuICAgICAgfSkpO1xuICAgICAgcmV0dXJuIGxheW91dDtcbiAgICB9XG4gIH07XG4gIGNvcmVmbiQ2LmNyZWF0ZUxheW91dCA9IGNvcmVmbiQ2Lm1ha2VMYXlvdXQgPSBjb3JlZm4kNi5sYXlvdXQ7XG5cbiAgdmFyIGNvcmVmbiQ1ID0ge1xuICAgIG5vdGlmeTogZnVuY3Rpb24gbm90aWZ5KGV2ZW50TmFtZSwgZXZlbnRFbGVzKSB7XG4gICAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuXG4gICAgICBpZiAodGhpcy5iYXRjaGluZygpKSB7XG4gICAgICAgIF9wLmJhdGNoTm90aWZpY2F0aW9ucyA9IF9wLmJhdGNoTm90aWZpY2F0aW9ucyB8fCB7fTtcbiAgICAgICAgdmFyIGVsZXMgPSBfcC5iYXRjaE5vdGlmaWNhdGlvbnNbZXZlbnROYW1lXSA9IF9wLmJhdGNoTm90aWZpY2F0aW9uc1tldmVudE5hbWVdIHx8IHRoaXMuY29sbGVjdGlvbigpO1xuXG4gICAgICAgIGlmIChldmVudEVsZXMgIT0gbnVsbCkge1xuICAgICAgICAgIGVsZXMubWVyZ2UoZXZlbnRFbGVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjsgLy8gbm90aWZpY2F0aW9ucyBhcmUgZGlzYWJsZWQgZHVyaW5nIGJhdGNoaW5nXG4gICAgICB9XG5cbiAgICAgIGlmICghX3Aubm90aWZpY2F0aW9uc0VuYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBleGl0IG9uIGRpc2FibGVkXG5cblxuICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcigpOyAvLyBleGl0IGlmIGRlc3Ryb3koKSBjYWxsZWQgb24gY29yZSBvciByZW5kZXJlciBpbiBiZXR3ZWVuIGZyYW1lcyAjMTQ5OSAjMTUyOFxuXG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQoKSB8fCAhcmVuZGVyZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZW5kZXJlci5ub3RpZnkoZXZlbnROYW1lLCBldmVudEVsZXMpO1xuICAgIH0sXG4gICAgbm90aWZpY2F0aW9uczogZnVuY3Rpb24gbm90aWZpY2F0aW9ucyhib29sKSB7XG4gICAgICB2YXIgcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICAgIGlmIChib29sID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHAubm90aWZpY2F0aW9uc0VuYWJsZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwLm5vdGlmaWNhdGlvbnNFbmFibGVkID0gYm9vbCA/IHRydWUgOiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBub05vdGlmaWNhdGlvbnM6IGZ1bmN0aW9uIG5vTm90aWZpY2F0aW9ucyhjYWxsYmFjaykge1xuICAgICAgdGhpcy5ub3RpZmljYXRpb25zKGZhbHNlKTtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB0aGlzLm5vdGlmaWNhdGlvbnModHJ1ZSk7XG4gICAgfSxcbiAgICBiYXRjaGluZzogZnVuY3Rpb24gYmF0Y2hpbmcoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5iYXRjaENvdW50ID4gMDtcbiAgICB9LFxuICAgIHN0YXJ0QmF0Y2g6IGZ1bmN0aW9uIHN0YXJ0QmF0Y2goKSB7XG4gICAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuXG4gICAgICBpZiAoX3AuYmF0Y2hDb3VudCA9PSBudWxsKSB7XG4gICAgICAgIF9wLmJhdGNoQ291bnQgPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoX3AuYmF0Y2hDb3VudCA9PT0gMCkge1xuICAgICAgICBfcC5iYXRjaFN0eWxlRWxlcyA9IHRoaXMuY29sbGVjdGlvbigpO1xuICAgICAgICBfcC5iYXRjaE5vdGlmaWNhdGlvbnMgPSB7fTtcbiAgICAgIH1cblxuICAgICAgX3AuYmF0Y2hDb3VudCsrO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBlbmRCYXRjaDogZnVuY3Rpb24gZW5kQmF0Y2goKSB7XG4gICAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuXG4gICAgICBpZiAoX3AuYmF0Y2hDb3VudCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgX3AuYmF0Y2hDb3VudC0tO1xuXG4gICAgICBpZiAoX3AuYmF0Y2hDb3VudCA9PT0gMCkge1xuICAgICAgICAvLyB1cGRhdGUgc3R5bGUgZm9yIGRpcnR5IGVsZXNcbiAgICAgICAgX3AuYmF0Y2hTdHlsZUVsZXMudXBkYXRlU3R5bGUoKTtcblxuICAgICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyKCk7IC8vIG5vdGlmeSB0aGUgcmVuZGVyZXIgb2YgcXVldWVkIGVsZXMgYW5kIGV2ZW50IHR5cGVzXG5cbiAgICAgICAgT2JqZWN0LmtleXMoX3AuYmF0Y2hOb3RpZmljYXRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudE5hbWUpIHtcbiAgICAgICAgICB2YXIgZWxlcyA9IF9wLmJhdGNoTm90aWZpY2F0aW9uc1tldmVudE5hbWVdO1xuXG4gICAgICAgICAgaWYgKGVsZXMuZW1wdHkoKSkge1xuICAgICAgICAgICAgcmVuZGVyZXIubm90aWZ5KGV2ZW50TmFtZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbmRlcmVyLm5vdGlmeShldmVudE5hbWUsIGVsZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgYmF0Y2g6IGZ1bmN0aW9uIGJhdGNoKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLnN0YXJ0QmF0Y2goKTtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB0aGlzLmVuZEJhdGNoKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8vIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgIGJhdGNoRGF0YTogZnVuY3Rpb24gYmF0Y2hEYXRhKG1hcCkge1xuICAgICAgdmFyIGN5ID0gdGhpcztcbiAgICAgIHJldHVybiB0aGlzLmJhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlkcyA9IE9iamVjdC5rZXlzKG1hcCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgaWQgPSBpZHNbaV07XG4gICAgICAgICAgdmFyIGRhdGEgPSBtYXBbaWRdO1xuICAgICAgICAgIHZhciBlbGUgPSBjeS5nZXRFbGVtZW50QnlJZChpZCk7XG4gICAgICAgICAgZWxlLmRhdGEoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICB2YXIgcmVuZGVyZXJEZWZhdWx0cyA9IGRlZmF1bHRzJGcoe1xuICAgIGhpZGVFZGdlc09uVmlld3BvcnQ6IGZhbHNlLFxuICAgIHRleHR1cmVPblZpZXdwb3J0OiBmYWxzZSxcbiAgICBtb3Rpb25CbHVyOiBmYWxzZSxcbiAgICBtb3Rpb25CbHVyT3BhY2l0eTogMC4wNSxcbiAgICBwaXhlbFJhdGlvOiB1bmRlZmluZWQsXG4gICAgZGVza3RvcFRhcFRocmVzaG9sZDogNCxcbiAgICB0b3VjaFRhcFRocmVzaG9sZDogOCxcbiAgICB3aGVlbFNlbnNpdGl2aXR5OiAxLFxuICAgIGRlYnVnOiBmYWxzZSxcbiAgICBzaG93RnBzOiBmYWxzZVxuICB9KTtcbiAgdmFyIGNvcmVmbiQ0ID0ge1xuICAgIHJlbmRlclRvOiBmdW5jdGlvbiByZW5kZXJUbyhjb250ZXh0LCB6b29tLCBwYW4sIHB4UmF0aW8pIHtcbiAgICAgIHZhciByID0gdGhpcy5fcHJpdmF0ZS5yZW5kZXJlcjtcbiAgICAgIHIucmVuZGVyVG8oY29udGV4dCwgem9vbSwgcGFuLCBweFJhdGlvKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgcmVuZGVyZXI6IGZ1bmN0aW9uIHJlbmRlcmVyKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUucmVuZGVyZXI7XG4gICAgfSxcbiAgICBmb3JjZVJlbmRlcjogZnVuY3Rpb24gZm9yY2VSZW5kZXIoKSB7XG4gICAgICB0aGlzLm5vdGlmeSgnZHJhdycpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICByZXNpemU6IGZ1bmN0aW9uIHJlc2l6ZSgpIHtcbiAgICAgIHRoaXMuaW52YWxpZGF0ZVNpemUoKTtcbiAgICAgIHRoaXMuZW1pdEFuZE5vdGlmeSgncmVzaXplJyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGluaXRSZW5kZXJlcjogZnVuY3Rpb24gaW5pdFJlbmRlcmVyKG9wdGlvbnMpIHtcbiAgICAgIHZhciBjeSA9IHRoaXM7XG4gICAgICB2YXIgUmVuZGVyZXJQcm90byA9IGN5LmV4dGVuc2lvbigncmVuZGVyZXInLCBvcHRpb25zLm5hbWUpO1xuXG4gICAgICBpZiAoUmVuZGVyZXJQcm90byA9PSBudWxsKSB7XG4gICAgICAgIGVycm9yKFwiQ2FuIG5vdCBpbml0aWFsaXNlOiBObyBzdWNoIHJlbmRlcmVyIGBcIi5jb25jYXQob3B0aW9ucy5uYW1lLCBcImAgZm91bmQuIERpZCB5b3UgZm9yZ2V0IHRvIGltcG9ydCBpdCBhbmQgYGN5dG9zY2FwZS51c2UoKWAgaXQ/XCIpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy53aGVlbFNlbnNpdGl2aXR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgd2FybihcIllvdSBoYXZlIHNldCBhIGN1c3RvbSB3aGVlbCBzZW5zaXRpdml0eS4gIFRoaXMgd2lsbCBtYWtlIHlvdXIgYXBwIHpvb20gdW5uYXR1cmFsbHkgd2hlbiB1c2luZyBtYWluc3RyZWFtIG1pY2UuICBZb3Ugc2hvdWxkIGNoYW5nZSB0aGlzIHZhbHVlIGZyb20gdGhlIGRlZmF1bHQgb25seSBpZiB5b3UgY2FuIGd1YXJhbnRlZSB0aGF0IGFsbCB5b3VyIHVzZXJzIHdpbGwgdXNlIHRoZSBzYW1lIGhhcmR3YXJlIGFuZCBPUyBjb25maWd1cmF0aW9uIGFzIHlvdXIgY3VycmVudCBtYWNoaW5lLlwiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJPcHRzID0gcmVuZGVyZXJEZWZhdWx0cyhvcHRpb25zKTtcbiAgICAgIHJPcHRzLmN5ID0gY3k7XG4gICAgICBjeS5fcHJpdmF0ZS5yZW5kZXJlciA9IG5ldyBSZW5kZXJlclByb3RvKHJPcHRzKTtcbiAgICAgIHRoaXMubm90aWZ5KCdpbml0Jyk7XG4gICAgfSxcbiAgICBkZXN0cm95UmVuZGVyZXI6IGZ1bmN0aW9uIGRlc3Ryb3lSZW5kZXJlcigpIHtcbiAgICAgIHZhciBjeSA9IHRoaXM7XG4gICAgICBjeS5ub3RpZnkoJ2Rlc3Ryb3knKTsgLy8gZGVzdHJveSB0aGUgcmVuZGVyZXJcblxuICAgICAgdmFyIGRvbUVsZSA9IGN5LmNvbnRhaW5lcigpO1xuXG4gICAgICBpZiAoZG9tRWxlKSB7XG4gICAgICAgIGRvbUVsZS5fY3lyZWcgPSBudWxsO1xuXG4gICAgICAgIHdoaWxlIChkb21FbGUuY2hpbGROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZG9tRWxlLnJlbW92ZUNoaWxkKGRvbUVsZS5jaGlsZE5vZGVzWzBdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjeS5fcHJpdmF0ZS5yZW5kZXJlciA9IG51bGw7IC8vIHRvIGJlIGV4dHJhIHNhZmUsIHJlbW92ZSB0aGUgcmVmXG5cbiAgICAgIGN5Lm11dGFibGVFbGVtZW50cygpLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgICAgIF9wLnJzY3JhdGNoID0ge307XG4gICAgICAgIF9wLnJzdHlsZSA9IHt9O1xuICAgICAgICBfcC5hbmltYXRpb24uY3VycmVudCA9IFtdO1xuICAgICAgICBfcC5hbmltYXRpb24ucXVldWUgPSBbXTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgb25SZW5kZXI6IGZ1bmN0aW9uIG9uUmVuZGVyKGZuKSB7XG4gICAgICByZXR1cm4gdGhpcy5vbigncmVuZGVyJywgZm4pO1xuICAgIH0sXG4gICAgb2ZmUmVuZGVyOiBmdW5jdGlvbiBvZmZSZW5kZXIoZm4pIHtcbiAgICAgIHJldHVybiB0aGlzLm9mZigncmVuZGVyJywgZm4pO1xuICAgIH1cbiAgfTtcbiAgY29yZWZuJDQuaW52YWxpZGF0ZURpbWVuc2lvbnMgPSBjb3JlZm4kNC5yZXNpemU7XG5cbiAgdmFyIGNvcmVmbiQzID0ge1xuICAgIC8vIGdldCBhIGNvbGxlY3Rpb25cbiAgICAvLyAtIGVtcHR5IGNvbGxlY3Rpb24gb24gbm8gYXJnc1xuICAgIC8vIC0gY29sbGVjdGlvbiBvZiBlbGVtZW50cyBpbiB0aGUgZ3JhcGggb24gc2VsZWN0b3IgYXJnXG4gICAgLy8gLSBndWFyYW50ZWUgYSByZXR1cm5lZCBjb2xsZWN0aW9uIHdoZW4gZWxlbWVudHMgb3IgY29sbGVjdGlvbiBzcGVjaWZpZWRcbiAgICBjb2xsZWN0aW9uOiBmdW5jdGlvbiBjb2xsZWN0aW9uKGVsZXMsIG9wdHMpIHtcbiAgICAgIGlmIChzdHJpbmcoZWxlcykpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJChlbGVzKTtcbiAgICAgIH0gZWxzZSBpZiAoZWxlbWVudE9yQ29sbGVjdGlvbihlbGVzKSkge1xuICAgICAgICByZXR1cm4gZWxlcy5jb2xsZWN0aW9uKCk7XG4gICAgICB9IGVsc2UgaWYgKGFycmF5KGVsZXMpKSB7XG4gICAgICAgIGlmICghb3B0cykge1xuICAgICAgICAgIG9wdHMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgQ29sbGVjdGlvbih0aGlzLCBlbGVzLCBvcHRzLnVuaXF1ZSwgb3B0cy5yZW1vdmVkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uKHRoaXMpO1xuICAgIH0sXG4gICAgbm9kZXM6IGZ1bmN0aW9uIG5vZGVzKHNlbGVjdG9yKSB7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLiQoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICByZXR1cm4gZWxlLmlzTm9kZSgpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gbm9kZXMuZmlsdGVyKHNlbGVjdG9yKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH0sXG4gICAgZWRnZXM6IGZ1bmN0aW9uIGVkZ2VzKHNlbGVjdG9yKSB7XG4gICAgICB2YXIgZWRnZXMgPSB0aGlzLiQoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICByZXR1cm4gZWxlLmlzRWRnZSgpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gZWRnZXMuZmlsdGVyKHNlbGVjdG9yKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVkZ2VzO1xuICAgIH0sXG4gICAgLy8gc2VhcmNoIHRoZSBncmFwaCBsaWtlIGpRdWVyeVxuICAgICQ6IGZ1bmN0aW9uICQoc2VsZWN0b3IpIHtcbiAgICAgIHZhciBlbGVzID0gdGhpcy5fcHJpdmF0ZS5lbGVtZW50cztcblxuICAgICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiBlbGVzLmZpbHRlcihzZWxlY3Rvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZWxlcy5zcGF3blNlbGYoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG11dGFibGVFbGVtZW50czogZnVuY3Rpb24gbXV0YWJsZUVsZW1lbnRzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuZWxlbWVudHM7XG4gICAgfVxuICB9OyAvLyBhbGlhc2VzXG5cbiAgY29yZWZuJDMuZWxlbWVudHMgPSBjb3JlZm4kMy5maWx0ZXIgPSBjb3JlZm4kMy4kO1xuXG4gIHZhciBzdHlmbiQ4ID0ge307IC8vIGtleXMgZm9yIHN0eWxlIGJsb2NrcywgZS5nLiB0dGZmdHRcblxuICB2YXIgVFJVRSA9ICd0JztcbiAgdmFyIEZBTFNFID0gJ2YnOyAvLyAocG90ZW50aWFsbHkgZXhwZW5zaXZlIGNhbGN1bGF0aW9uKVxuICAvLyBhcHBseSB0aGUgc3R5bGUgdG8gdGhlIGVsZW1lbnQgYmFzZWQgb25cbiAgLy8gLSBpdHMgYnlwYXNzXG4gIC8vIC0gd2hhdCBzZWxlY3RvcnMgbWF0Y2ggaXRcblxuICBzdHlmbiQ4LmFwcGx5ID0gZnVuY3Rpb24gKGVsZXMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIF9wID0gc2VsZi5fcHJpdmF0ZTtcbiAgICB2YXIgY3kgPSBfcC5jeTtcbiAgICB2YXIgdXBkYXRlZEVsZXMgPSBjeS5jb2xsZWN0aW9uKCk7XG5cbiAgICBmb3IgKHZhciBpZSA9IDA7IGllIDwgZWxlcy5sZW5ndGg7IGllKyspIHtcbiAgICAgIHZhciBlbGUgPSBlbGVzW2llXTtcbiAgICAgIHZhciBjeHRNZXRhID0gc2VsZi5nZXRDb250ZXh0TWV0YShlbGUpO1xuXG4gICAgICBpZiAoY3h0TWV0YS5lbXB0eSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGN4dFN0eWxlID0gc2VsZi5nZXRDb250ZXh0U3R5bGUoY3h0TWV0YSk7XG4gICAgICB2YXIgYXBwID0gc2VsZi5hcHBseUNvbnRleHRTdHlsZShjeHRNZXRhLCBjeHRTdHlsZSwgZWxlKTtcblxuICAgICAgaWYgKGVsZS5fcHJpdmF0ZS5hcHBsaWVkSW5pdFN0eWxlKSB7XG4gICAgICAgIHNlbGYudXBkYXRlVHJhbnNpdGlvbnMoZWxlLCBhcHAuZGlmZlByb3BzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZS5fcHJpdmF0ZS5hcHBsaWVkSW5pdFN0eWxlID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGhpbnRzRGlmZiA9IHNlbGYudXBkYXRlU3R5bGVIaW50cyhlbGUpO1xuXG4gICAgICBpZiAoaGludHNEaWZmKSB7XG4gICAgICAgIHVwZGF0ZWRFbGVzLnB1c2goZWxlKTtcbiAgICAgIH1cbiAgICB9IC8vIGZvciBlbGVtZW50c1xuXG5cbiAgICByZXR1cm4gdXBkYXRlZEVsZXM7XG4gIH07XG5cbiAgc3R5Zm4kOC5nZXRQcm9wZXJ0aWVzRGlmZiA9IGZ1bmN0aW9uIChvbGRDeHRLZXksIG5ld0N4dEtleSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY2FjaGUgPSBzZWxmLl9wcml2YXRlLnByb3BEaWZmcyA9IHNlbGYuX3ByaXZhdGUucHJvcERpZmZzIHx8IHt9O1xuICAgIHZhciBkdWFsQ3h0S2V5ID0gb2xkQ3h0S2V5ICsgJy0nICsgbmV3Q3h0S2V5O1xuICAgIHZhciBjYWNoZWRWYWwgPSBjYWNoZVtkdWFsQ3h0S2V5XTtcblxuICAgIGlmIChjYWNoZWRWYWwpIHtcbiAgICAgIHJldHVybiBjYWNoZWRWYWw7XG4gICAgfVxuXG4gICAgdmFyIGRpZmZQcm9wcyA9IFtdO1xuICAgIHZhciBhZGRlZFByb3AgPSB7fTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGN4dCA9IHNlbGZbaV07XG4gICAgICB2YXIgb2xkSGFzQ3h0ID0gb2xkQ3h0S2V5W2ldID09PSBUUlVFO1xuICAgICAgdmFyIG5ld0hhc0N4dCA9IG5ld0N4dEtleVtpXSA9PT0gVFJVRTtcbiAgICAgIHZhciBjeHRIYXNEaWZmZWQgPSBvbGRIYXNDeHQgIT09IG5ld0hhc0N4dDtcbiAgICAgIHZhciBjeHRIYXNNYXBwZWRQcm9wcyA9IGN4dC5tYXBwZWRQcm9wZXJ0aWVzLmxlbmd0aCA+IDA7XG5cbiAgICAgIGlmIChjeHRIYXNEaWZmZWQgfHwgbmV3SGFzQ3h0ICYmIGN4dEhhc01hcHBlZFByb3BzKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHZvaWQgMDtcblxuICAgICAgICBpZiAoY3h0SGFzRGlmZmVkICYmIGN4dEhhc01hcHBlZFByb3BzKSB7XG4gICAgICAgICAgcHJvcHMgPSBjeHQucHJvcGVydGllczsgLy8gc3VmZmljZXMgYi9jIG1hcHBlZFByb3BlcnRpZXMgaXMgYSBzdWJzZXQgb2YgcHJvcGVydGllc1xuICAgICAgICB9IGVsc2UgaWYgKGN4dEhhc0RpZmZlZCkge1xuICAgICAgICAgIHByb3BzID0gY3h0LnByb3BlcnRpZXM7IC8vIG5lZWQgdG8gY2hlY2sgdGhlbSBhbGxcbiAgICAgICAgfSBlbHNlIGlmIChjeHRIYXNNYXBwZWRQcm9wcykge1xuICAgICAgICAgIHByb3BzID0gY3h0Lm1hcHBlZFByb3BlcnRpZXM7IC8vIG9ubHkgbmVlZCB0byBjaGVjayBtYXBwZWRcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcHJvcHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB2YXIgcHJvcCA9IHByb3BzW2pdO1xuICAgICAgICAgIHZhciBuYW1lID0gcHJvcC5uYW1lOyAvLyBpZiBhIGxhdGVyIGNvbnRleHQgb3ZlcnJpZGVzIHRoaXMgcHJvcGVydHksIHRoZW4gdGhlIGZhY3QgdGhhdCB0aGlzIGNvbnRleHQgaGFzIHN3aXRjaGVkL2RpZmZlZCBkb2Vzbid0IG1hdHRlclxuICAgICAgICAgIC8vIChzZW1pIGV4cGVuc2l2ZSBjaGVjayBzaW5jZSBpdCBtYWtlcyB0aGlzIGZ1bmN0aW9uIE8obl4yKSBvbiBjb250ZXh0IGxlbmd0aCwgYnV0IHdvcnRoIGl0IHNpbmNlIG92ZXJhbGwgcmVzdWx0XG4gICAgICAgICAgLy8gaXMgY2FjaGVkKVxuXG4gICAgICAgICAgdmFyIGxhdGVyQ3h0T3ZlcnJpZGVzID0gZmFsc2U7XG5cbiAgICAgICAgICBmb3IgKHZhciBrID0gaSArIDE7IGsgPCBzZWxmLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICB2YXIgbGF0ZXJDeHQgPSBzZWxmW2tdO1xuICAgICAgICAgICAgdmFyIGhhc0xhdGVyQ3h0ID0gbmV3Q3h0S2V5W2tdID09PSBUUlVFO1xuXG4gICAgICAgICAgICBpZiAoIWhhc0xhdGVyQ3h0KSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSAvLyBjYW4ndCBvdmVycmlkZSB1bmxlc3MgdGhlIGNvbnRleHQgaXMgYWN0aXZlXG5cblxuICAgICAgICAgICAgbGF0ZXJDeHRPdmVycmlkZXMgPSBsYXRlckN4dC5wcm9wZXJ0aWVzW3Byb3AubmFtZV0gIT0gbnVsbDtcblxuICAgICAgICAgICAgaWYgKGxhdGVyQ3h0T3ZlcnJpZGVzKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSAvLyBleGl0IGVhcmx5IGFzIGxvbmcgYXMgb25lIGxhdGVyIGNvbnRleHQgb3ZlcnJpZGVzXG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWFkZGVkUHJvcFtuYW1lXSAmJiAhbGF0ZXJDeHRPdmVycmlkZXMpIHtcbiAgICAgICAgICAgIGFkZGVkUHJvcFtuYW1lXSA9IHRydWU7XG4gICAgICAgICAgICBkaWZmUHJvcHMucHVzaChuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gZm9yIHByb3BzXG5cbiAgICAgIH0gLy8gaWZcblxuICAgIH0gLy8gZm9yIGNvbnRleHRzXG5cblxuICAgIGNhY2hlW2R1YWxDeHRLZXldID0gZGlmZlByb3BzO1xuICAgIHJldHVybiBkaWZmUHJvcHM7XG4gIH07XG5cbiAgc3R5Zm4kOC5nZXRDb250ZXh0TWV0YSA9IGZ1bmN0aW9uIChlbGUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGN4dEtleSA9ICcnO1xuICAgIHZhciBkaWZmUHJvcHM7XG4gICAgdmFyIHByZXZLZXkgPSBlbGUuX3ByaXZhdGUuc3R5bGVDeHRLZXkgfHwgJyc7IC8vIGdldCB0aGUgY3h0IGtleVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY29udGV4dCA9IHNlbGZbaV07XG4gICAgICB2YXIgY29udGV4dFNlbGVjdG9yTWF0Y2hlcyA9IGNvbnRleHQuc2VsZWN0b3IgJiYgY29udGV4dC5zZWxlY3Rvci5tYXRjaGVzKGVsZSk7IC8vIE5COiBjb250ZXh0LnNlbGVjdG9yIG1heSBiZSBudWxsIGZvciAnY29yZSdcblxuICAgICAgaWYgKGNvbnRleHRTZWxlY3Rvck1hdGNoZXMpIHtcbiAgICAgICAgY3h0S2V5ICs9IFRSVUU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjeHRLZXkgKz0gRkFMU0U7XG4gICAgICB9XG4gICAgfSAvLyBmb3IgY29udGV4dFxuXG5cbiAgICBkaWZmUHJvcHMgPSBzZWxmLmdldFByb3BlcnRpZXNEaWZmKHByZXZLZXksIGN4dEtleSk7XG4gICAgZWxlLl9wcml2YXRlLnN0eWxlQ3h0S2V5ID0gY3h0S2V5O1xuICAgIHJldHVybiB7XG4gICAgICBrZXk6IGN4dEtleSxcbiAgICAgIGRpZmZQcm9wTmFtZXM6IGRpZmZQcm9wcyxcbiAgICAgIGVtcHR5OiBkaWZmUHJvcHMubGVuZ3RoID09PSAwXG4gICAgfTtcbiAgfTsgLy8gZ2V0cyBhIGNvbXB1dGVkIGVsZSBzdHlsZSBvYmplY3QgYmFzZWQgb24gbWF0Y2hlZCBjb250ZXh0c1xuXG5cbiAgc3R5Zm4kOC5nZXRDb250ZXh0U3R5bGUgPSBmdW5jdGlvbiAoY3h0TWV0YSkge1xuICAgIHZhciBjeHRLZXkgPSBjeHRNZXRhLmtleTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGN4dFN0eWxlcyA9IHRoaXMuX3ByaXZhdGUuY29udGV4dFN0eWxlcyA9IHRoaXMuX3ByaXZhdGUuY29udGV4dFN0eWxlcyB8fCB7fTsgLy8gaWYgYWxyZWFkeSBjb21wdXRlZCBzdHlsZSwgcmV0dXJuZWQgY2FjaGVkIGNvcHlcblxuICAgIGlmIChjeHRTdHlsZXNbY3h0S2V5XSkge1xuICAgICAgcmV0dXJuIGN4dFN0eWxlc1tjeHRLZXldO1xuICAgIH1cblxuICAgIHZhciBzdHlsZSA9IHtcbiAgICAgIF9wcml2YXRlOiB7XG4gICAgICAgIGtleTogY3h0S2V5XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGN4dCA9IHNlbGZbaV07XG4gICAgICB2YXIgaGFzQ3h0ID0gY3h0S2V5W2ldID09PSBUUlVFO1xuXG4gICAgICBpZiAoIWhhc0N4dCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjeHQucHJvcGVydGllcy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgcHJvcCA9IGN4dC5wcm9wZXJ0aWVzW2pdO1xuICAgICAgICBzdHlsZVtwcm9wLm5hbWVdID0gcHJvcDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjeHRTdHlsZXNbY3h0S2V5XSA9IHN0eWxlO1xuICAgIHJldHVybiBzdHlsZTtcbiAgfTtcblxuICBzdHlmbiQ4LmFwcGx5Q29udGV4dFN0eWxlID0gZnVuY3Rpb24gKGN4dE1ldGEsIGN4dFN0eWxlLCBlbGUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGRpZmZQcm9wcyA9IGN4dE1ldGEuZGlmZlByb3BOYW1lcztcbiAgICB2YXIgcmV0RGlmZlByb3BzID0ge307XG4gICAgdmFyIHR5cGVzID0gc2VsZi50eXBlcztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlmZlByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGlmZlByb3BOYW1lID0gZGlmZlByb3BzW2ldO1xuICAgICAgdmFyIGN4dFByb3AgPSBjeHRTdHlsZVtkaWZmUHJvcE5hbWVdO1xuICAgICAgdmFyIGVsZVByb3AgPSBlbGUucHN0eWxlKGRpZmZQcm9wTmFtZSk7XG5cbiAgICAgIGlmICghY3h0UHJvcCkge1xuICAgICAgICAvLyBubyBjb250ZXh0IHByb3AgbWVhbnMgZGVsZXRlXG4gICAgICAgIGlmICghZWxlUHJvcCkge1xuICAgICAgICAgIGNvbnRpbnVlOyAvLyBubyBleGlzdGluZyBwcm9wIG1lYW5zIG5vdGhpbmcgbmVlZHMgdG8gYmUgcmVtb3ZlZFxuICAgICAgICAgIC8vIG5iIGFmZmVjdHMgaW5pdGlhbCBhcHBsaWNhdGlvbiBvbiBtYXBwZWQgdmFsdWVzIGxpa2UgY29udHJvbC1wb2ludC1kaXN0YW5jZXNcbiAgICAgICAgfSBlbHNlIGlmIChlbGVQcm9wLmJ5cGFzcykge1xuICAgICAgICAgIGN4dFByb3AgPSB7XG4gICAgICAgICAgICBuYW1lOiBkaWZmUHJvcE5hbWUsXG4gICAgICAgICAgICBkZWxldGVCeXBhc3NlZDogdHJ1ZVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3h0UHJvcCA9IHtcbiAgICAgICAgICAgIG5hbWU6IGRpZmZQcm9wTmFtZSxcbiAgICAgICAgICAgIFwiZGVsZXRlXCI6IHRydWVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9IC8vIHNhdmUgY3ljbGVzIHdoZW4gdGhlIGNvbnRleHQgcHJvcCBkb2Vzbid0IG5lZWQgdG8gYmUgYXBwbGllZFxuXG5cbiAgICAgIGlmIChlbGVQcm9wID09PSBjeHRQcm9wKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvLyBzYXZlIGN5Y2xlcyB3aGVuIGEgbWFwcGVkIGNvbnRleHQgcHJvcCBkb2Vzbid0IG5lZWQgdG8gYmUgYXBwbGllZFxuXG5cbiAgICAgIGlmIChjeHRQcm9wLm1hcHBlZCA9PT0gdHlwZXMuZm4gLy8gY29udGV4dCBwcm9wIGlzIGZ1bmN0aW9uIG1hcHBlclxuICAgICAgJiYgZWxlUHJvcCAhPSBudWxsIC8vIHNvbWUgcHJvcHMgY2FuIGJlIG51bGwgZXZlbiBieSBkZWZhdWx0IChlLmcuIGEgcHJvcCB0aGF0IG92ZXJyaWRlcyBhbm90aGVyIG9uZSlcbiAgICAgICYmIGVsZVByb3AubWFwcGluZyAhPSBudWxsIC8vIGVsZSBwcm9wIGlzIGEgY29uY3JldGUgdmFsdWUgZnJvbSBmcm9tIGEgbWFwcGVyXG4gICAgICAmJiBlbGVQcm9wLm1hcHBpbmcudmFsdWUgPT09IGN4dFByb3AudmFsdWUgLy8gdGhlIGN1cnJlbnQgcHJvcCBvbiB0aGUgZWxlIGlzIGEgZmxhdCBwcm9wIHZhbHVlIGZvciB0aGUgZnVuY3Rpb24gbWFwcGVyXG4gICAgICApIHtcbiAgICAgICAgLy8gTkIgZG9uJ3Qgd3JpdGUgdG8gY3h0UHJvcCwgYXMgaXQncyBzaGFyZWQgYW1vbmcgZWxlcyAoc3RvcmVkIGluIHN0eWxlc2hlZXQpXG4gICAgICAgIHZhciBtYXBwaW5nID0gZWxlUHJvcC5tYXBwaW5nOyAvLyBjYW4gd3JpdGUgdG8gbWFwcGluZywgYXMgaXQncyBhIHBlci1lbGUgY29weVxuXG4gICAgICAgIHZhciBmblZhbHVlID0gbWFwcGluZy5mblZhbHVlID0gY3h0UHJvcC52YWx1ZShlbGUpOyAvLyB0ZW1wb3JhcmlseSBjYWNoZSB0aGUgdmFsdWUgaW4gY2FzZSBvZiBhIG1pc3NcblxuICAgICAgICBpZiAoZm5WYWx1ZSA9PT0gbWFwcGluZy5wcmV2Rm5WYWx1ZSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciByZXREaWZmUHJvcCA9IHJldERpZmZQcm9wc1tkaWZmUHJvcE5hbWVdID0ge1xuICAgICAgICBwcmV2OiBlbGVQcm9wXG4gICAgICB9O1xuICAgICAgc2VsZi5hcHBseVBhcnNlZFByb3BlcnR5KGVsZSwgY3h0UHJvcCk7XG4gICAgICByZXREaWZmUHJvcC5uZXh0ID0gZWxlLnBzdHlsZShkaWZmUHJvcE5hbWUpO1xuXG4gICAgICBpZiAocmV0RGlmZlByb3AubmV4dCAmJiByZXREaWZmUHJvcC5uZXh0LmJ5cGFzcykge1xuICAgICAgICByZXREaWZmUHJvcC5uZXh0ID0gcmV0RGlmZlByb3AubmV4dC5ieXBhc3NlZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZGlmZlByb3BzOiByZXREaWZmUHJvcHNcbiAgICB9O1xuICB9O1xuXG4gIHN0eWZuJDgudXBkYXRlU3R5bGVIaW50cyA9IGZ1bmN0aW9uIChlbGUpIHtcbiAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBwcm9wTmFtZXMgPSBzZWxmLnByb3BlcnR5R3JvdXBOYW1lcztcbiAgICB2YXIgcHJvcEdyS2V5cyA9IHNlbGYucHJvcGVydHlHcm91cEtleXM7XG5cbiAgICB2YXIgcHJvcEhhc2ggPSBmdW5jdGlvbiBwcm9wSGFzaChlbGUsIHByb3BOYW1lcywgc2VlZEtleSkge1xuICAgICAgcmV0dXJuIHNlbGYuZ2V0UHJvcGVydGllc0hhc2goZWxlLCBwcm9wTmFtZXMsIHNlZWRLZXkpO1xuICAgIH07XG5cbiAgICB2YXIgb2xkU3R5bGVLZXkgPSBfcC5zdHlsZUtleTtcblxuICAgIGlmIChlbGUucmVtb3ZlZCgpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGlzTm9kZSA9IF9wLmdyb3VwID09PSAnbm9kZXMnOyAvLyBnZXQgdGhlIHN0eWxlIGtleSBoYXNoZXMgcGVyIHByb3AgZ3JvdXBcbiAgICAvLyBidXQgbGF6aWx5IC0tIG9ubHkgdXNlIG5vbi1kZWZhdWx0IHByb3AgdmFsdWVzIHRvIHJlZHVjZSB0aGUgbnVtYmVyIG9mIGhhc2hlc1xuICAgIC8vXG5cbiAgICB2YXIgb3ZlcnJpZGRlblN0eWxlcyA9IGVsZS5fcHJpdmF0ZS5zdHlsZTtcbiAgICBwcm9wTmFtZXMgPSBPYmplY3Qua2V5cyhvdmVycmlkZGVuU3R5bGVzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcEdyS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGdyS2V5ID0gcHJvcEdyS2V5c1tpXTtcbiAgICAgIF9wLnN0eWxlS2V5c1tncktleV0gPSBbREVGQVVMVF9IQVNIX1NFRUQsIERFRkFVTFRfSEFTSF9TRUVEX0FMVF07XG4gICAgfVxuXG4gICAgdmFyIHVwZGF0ZUdyS2V5MSA9IGZ1bmN0aW9uIHVwZGF0ZUdyS2V5MSh2YWwsIGdyS2V5KSB7XG4gICAgICByZXR1cm4gX3Auc3R5bGVLZXlzW2dyS2V5XVswXSA9IGhhc2hJbnQodmFsLCBfcC5zdHlsZUtleXNbZ3JLZXldWzBdKTtcbiAgICB9O1xuXG4gICAgdmFyIHVwZGF0ZUdyS2V5MiA9IGZ1bmN0aW9uIHVwZGF0ZUdyS2V5Mih2YWwsIGdyS2V5KSB7XG4gICAgICByZXR1cm4gX3Auc3R5bGVLZXlzW2dyS2V5XVsxXSA9IGhhc2hJbnRBbHQodmFsLCBfcC5zdHlsZUtleXNbZ3JLZXldWzFdKTtcbiAgICB9O1xuXG4gICAgdmFyIHVwZGF0ZUdyS2V5ID0gZnVuY3Rpb24gdXBkYXRlR3JLZXkodmFsLCBncktleSkge1xuICAgICAgdXBkYXRlR3JLZXkxKHZhbCwgZ3JLZXkpO1xuICAgICAgdXBkYXRlR3JLZXkyKHZhbCwgZ3JLZXkpO1xuICAgIH07XG5cbiAgICB2YXIgdXBkYXRlR3JLZXlXU3RyID0gZnVuY3Rpb24gdXBkYXRlR3JLZXlXU3RyKHN0clZhbCwgZ3JLZXkpIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3RyVmFsLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBjaCA9IHN0clZhbC5jaGFyQ29kZUF0KGopO1xuICAgICAgICB1cGRhdGVHcktleTEoY2gsIGdyS2V5KTtcbiAgICAgICAgdXBkYXRlR3JLZXkyKGNoLCBncktleSk7XG4gICAgICB9XG4gICAgfTsgLy8gLSBoYXNoaW5nIHdvcmtzIG9uIDMyIGJpdCBpbnRzIGIvYyB3ZSB1c2UgYml0d2lzZSBvcHNcbiAgICAvLyAtIHNtYWxsIG51bWJlcnMgZ2V0IGN1dCBvZmYgKGUuZy4gMC4xMjMgaXMgc2VlbiBhcyAwIGJ5IHRoZSBoYXNoaW5nIGZ1bmN0aW9uKVxuICAgIC8vIC0gcmFpc2UgdXAgc21hbGwgbnVtYmVycyBzbyBtb3JlIHNpZ25pZmljYW50IGRpZ2l0cyBhcmUgc2VlbiBieSBoYXNoaW5nXG4gICAgLy8gLSBtYWtlIHNtYWxsIG51bWJlcnMgbGFyZ2VyIHRoYW4gYSBub3JtYWwgdmFsdWUgdG8gYXZvaWQgY29sbGlzaW9uc1xuICAgIC8vIC0gd29ya3MgaW4gcHJhY3RpY2UgYW5kIGl0J3MgcmVsYXRpdmVseSBjaGVhcFxuXG5cbiAgICB2YXIgTiA9IDIwMDAwMDAwMDA7XG5cbiAgICB2YXIgY2xlYW5OdW0gPSBmdW5jdGlvbiBjbGVhbk51bSh2YWwpIHtcbiAgICAgIHJldHVybiAtMTI4IDwgdmFsICYmIHZhbCA8IDEyOCAmJiBNYXRoLmZsb29yKHZhbCkgIT09IHZhbCA/IE4gLSAodmFsICogMTAyNCB8IDApIDogdmFsO1xuICAgIH07XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgcHJvcE5hbWVzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIG5hbWUgPSBwcm9wTmFtZXNbX2ldO1xuICAgICAgdmFyIHBhcnNlZFByb3AgPSBvdmVycmlkZGVuU3R5bGVzW25hbWVdO1xuXG4gICAgICBpZiAocGFyc2VkUHJvcCA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJvcEluZm8gPSB0aGlzLnByb3BlcnRpZXNbbmFtZV07XG4gICAgICB2YXIgdHlwZSA9IHByb3BJbmZvLnR5cGU7XG4gICAgICB2YXIgX2dyS2V5ID0gcHJvcEluZm8uZ3JvdXBLZXk7XG4gICAgICB2YXIgbm9ybWFsaXplZE51bWJlclZhbCA9IHZvaWQgMDtcblxuICAgICAgaWYgKHByb3BJbmZvLmhhc2hPdmVycmlkZSAhPSBudWxsKSB7XG4gICAgICAgIG5vcm1hbGl6ZWROdW1iZXJWYWwgPSBwcm9wSW5mby5oYXNoT3ZlcnJpZGUoZWxlLCBwYXJzZWRQcm9wKTtcbiAgICAgIH0gZWxzZSBpZiAocGFyc2VkUHJvcC5wZlZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgbm9ybWFsaXplZE51bWJlclZhbCA9IHBhcnNlZFByb3AucGZWYWx1ZTtcbiAgICAgIH0gLy8gbWlnaHQgbm90IGJlIGEgbnVtYmVyIGlmIGl0IGFsbG93cyBlbnVtc1xuXG5cbiAgICAgIHZhciBudW1iZXJWYWwgPSBwcm9wSW5mby5lbnVtcyA9PSBudWxsID8gcGFyc2VkUHJvcC52YWx1ZSA6IG51bGw7XG4gICAgICB2YXIgaGF2ZU5vcm1OdW0gPSBub3JtYWxpemVkTnVtYmVyVmFsICE9IG51bGw7XG4gICAgICB2YXIgaGF2ZVVuaXRlZE51bSA9IG51bWJlclZhbCAhPSBudWxsO1xuICAgICAgdmFyIGhhdmVOdW0gPSBoYXZlTm9ybU51bSB8fCBoYXZlVW5pdGVkTnVtO1xuICAgICAgdmFyIHVuaXRzID0gcGFyc2VkUHJvcC51bml0czsgLy8gbnVtYmVycyBhcmUgY2hlYXBlciB0byBoYXNoIHRoYW4gc3RyaW5nc1xuICAgICAgLy8gMSBoYXNoIG9wIHZzIG4gaGFzaCBvcHMgKGZvciBsZW5ndGggbiBzdHJpbmcpXG5cbiAgICAgIGlmICh0eXBlLm51bWJlciAmJiBoYXZlTnVtICYmICF0eXBlLm11bHRpcGxlKSB7XG4gICAgICAgIHZhciB2ID0gaGF2ZU5vcm1OdW0gPyBub3JtYWxpemVkTnVtYmVyVmFsIDogbnVtYmVyVmFsO1xuICAgICAgICB1cGRhdGVHcktleShjbGVhbk51bSh2KSwgX2dyS2V5KTtcblxuICAgICAgICBpZiAoIWhhdmVOb3JtTnVtICYmIHVuaXRzICE9IG51bGwpIHtcbiAgICAgICAgICB1cGRhdGVHcktleVdTdHIodW5pdHMsIF9ncktleSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVwZGF0ZUdyS2V5V1N0cihwYXJzZWRQcm9wLnN0clZhbHVlLCBfZ3JLZXkpO1xuICAgICAgfVxuICAgIH0gLy8gb3ZlcmFsbCBzdHlsZSBrZXlcbiAgICAvL1xuXG5cbiAgICB2YXIgaGFzaCA9IFtERUZBVUxUX0hBU0hfU0VFRCwgREVGQVVMVF9IQVNIX1NFRURfQUxUXTtcblxuICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IHByb3BHcktleXMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgdmFyIF9ncktleTIgPSBwcm9wR3JLZXlzW19pMl07XG4gICAgICB2YXIgZ3JIYXNoID0gX3Auc3R5bGVLZXlzW19ncktleTJdO1xuICAgICAgaGFzaFswXSA9IGhhc2hJbnQoZ3JIYXNoWzBdLCBoYXNoWzBdKTtcbiAgICAgIGhhc2hbMV0gPSBoYXNoSW50QWx0KGdySGFzaFsxXSwgaGFzaFsxXSk7XG4gICAgfVxuXG4gICAgX3Auc3R5bGVLZXkgPSBjb21iaW5lSGFzaGVzKGhhc2hbMF0sIGhhc2hbMV0pOyAvLyBsYWJlbCBkaW1zXG4gICAgLy9cblxuICAgIHZhciBzayA9IF9wLnN0eWxlS2V5cztcbiAgICBfcC5sYWJlbERpbXNLZXkgPSBjb21iaW5lSGFzaGVzQXJyYXkoc2subGFiZWxEaW1lbnNpb25zKTtcbiAgICB2YXIgbGFiZWxLZXlzID0gcHJvcEhhc2goZWxlLCBbJ2xhYmVsJ10sIHNrLmxhYmVsRGltZW5zaW9ucyk7XG4gICAgX3AubGFiZWxLZXkgPSBjb21iaW5lSGFzaGVzQXJyYXkobGFiZWxLZXlzKTtcbiAgICBfcC5sYWJlbFN0eWxlS2V5ID0gY29tYmluZUhhc2hlc0FycmF5KGhhc2hBcnJheXMoc2suY29tbW9uTGFiZWwsIGxhYmVsS2V5cykpO1xuXG4gICAgaWYgKCFpc05vZGUpIHtcbiAgICAgIHZhciBzb3VyY2VMYWJlbEtleXMgPSBwcm9wSGFzaChlbGUsIFsnc291cmNlLWxhYmVsJ10sIHNrLmxhYmVsRGltZW5zaW9ucyk7XG4gICAgICBfcC5zb3VyY2VMYWJlbEtleSA9IGNvbWJpbmVIYXNoZXNBcnJheShzb3VyY2VMYWJlbEtleXMpO1xuICAgICAgX3Auc291cmNlTGFiZWxTdHlsZUtleSA9IGNvbWJpbmVIYXNoZXNBcnJheShoYXNoQXJyYXlzKHNrLmNvbW1vbkxhYmVsLCBzb3VyY2VMYWJlbEtleXMpKTtcbiAgICAgIHZhciB0YXJnZXRMYWJlbEtleXMgPSBwcm9wSGFzaChlbGUsIFsndGFyZ2V0LWxhYmVsJ10sIHNrLmxhYmVsRGltZW5zaW9ucyk7XG4gICAgICBfcC50YXJnZXRMYWJlbEtleSA9IGNvbWJpbmVIYXNoZXNBcnJheSh0YXJnZXRMYWJlbEtleXMpO1xuICAgICAgX3AudGFyZ2V0TGFiZWxTdHlsZUtleSA9IGNvbWJpbmVIYXNoZXNBcnJheShoYXNoQXJyYXlzKHNrLmNvbW1vbkxhYmVsLCB0YXJnZXRMYWJlbEtleXMpKTtcbiAgICB9IC8vIG5vZGVcbiAgICAvL1xuXG5cbiAgICBpZiAoaXNOb2RlKSB7XG4gICAgICB2YXIgX3Akc3R5bGVLZXlzID0gX3Auc3R5bGVLZXlzLFxuICAgICAgICAgIG5vZGVCb2R5ID0gX3Akc3R5bGVLZXlzLm5vZGVCb2R5LFxuICAgICAgICAgIG5vZGVCb3JkZXIgPSBfcCRzdHlsZUtleXMubm9kZUJvcmRlcixcbiAgICAgICAgICBiYWNrZ3JvdW5kSW1hZ2UgPSBfcCRzdHlsZUtleXMuYmFja2dyb3VuZEltYWdlLFxuICAgICAgICAgIGNvbXBvdW5kID0gX3Akc3R5bGVLZXlzLmNvbXBvdW5kLFxuICAgICAgICAgIHBpZSA9IF9wJHN0eWxlS2V5cy5waWU7XG4gICAgICB2YXIgbm9kZUtleXMgPSBbbm9kZUJvZHksIG5vZGVCb3JkZXIsIGJhY2tncm91bmRJbWFnZSwgY29tcG91bmQsIHBpZV0uZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldHVybiBrICE9IG51bGw7XG4gICAgICB9KS5yZWR1Y2UoaGFzaEFycmF5cywgW0RFRkFVTFRfSEFTSF9TRUVELCBERUZBVUxUX0hBU0hfU0VFRF9BTFRdKTtcbiAgICAgIF9wLm5vZGVLZXkgPSBjb21iaW5lSGFzaGVzQXJyYXkobm9kZUtleXMpO1xuICAgICAgX3AuaGFzUGllID0gcGllICE9IG51bGwgJiYgcGllWzBdICE9PSBERUZBVUxUX0hBU0hfU0VFRCAmJiBwaWVbMV0gIT09IERFRkFVTFRfSEFTSF9TRUVEX0FMVDtcbiAgICB9XG5cbiAgICByZXR1cm4gb2xkU3R5bGVLZXkgIT09IF9wLnN0eWxlS2V5O1xuICB9O1xuXG4gIHN0eWZuJDguY2xlYXJTdHlsZUhpbnRzID0gZnVuY3Rpb24gKGVsZSkge1xuICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICBfcC5zdHlsZUN4dEtleSA9ICcnO1xuICAgIF9wLnN0eWxlS2V5cyA9IHt9O1xuICAgIF9wLnN0eWxlS2V5ID0gbnVsbDtcbiAgICBfcC5sYWJlbEtleSA9IG51bGw7XG4gICAgX3AubGFiZWxTdHlsZUtleSA9IG51bGw7XG4gICAgX3Auc291cmNlTGFiZWxLZXkgPSBudWxsO1xuICAgIF9wLnNvdXJjZUxhYmVsU3R5bGVLZXkgPSBudWxsO1xuICAgIF9wLnRhcmdldExhYmVsS2V5ID0gbnVsbDtcbiAgICBfcC50YXJnZXRMYWJlbFN0eWxlS2V5ID0gbnVsbDtcbiAgICBfcC5ub2RlS2V5ID0gbnVsbDtcbiAgICBfcC5oYXNQaWUgPSBudWxsO1xuICB9OyAvLyBhcHBseSBhIHByb3BlcnR5IHRvIHRoZSBzdHlsZSAoZm9yIGludGVybmFsIHVzZSlcbiAgLy8gcmV0dXJucyB3aGV0aGVyIGFwcGxpY2F0aW9uIHdhcyBzdWNjZXNzZnVsXG4gIC8vXG4gIC8vIG5vdywgdGhpcyBmdW5jdGlvbiBmbGF0dGVucyB0aGUgcHJvcGVydHksIGFuZCBoZXJlJ3MgaG93OlxuICAvL1xuICAvLyBmb3IgcGFyc2VkUHJvcDp7IGJ5cGFzczogdHJ1ZSwgZGVsZXRlQnlwYXNzOiB0cnVlIH1cbiAgLy8gbm8gcHJvcGVydHkgaXMgZ2VuZXJhdGVkLCBpbnN0ZWFkIHRoZSBieXBhc3MgcHJvcGVydHkgaW4gdGhlXG4gIC8vIGVsZW1lbnQncyBzdHlsZSBpcyByZXBsYWNlZCBieSB3aGF0J3MgcG9pbnRlZCB0byBieSB0aGUgYGJ5cGFzc2VkYFxuICAvLyBmaWVsZCBpbiB0aGUgYnlwYXNzIHByb3BlcnR5IChpLmUuIHJlc3RvcmluZyB0aGUgcHJvcGVydHkgdGhlXG4gIC8vIGJ5cGFzcyB3YXMgb3ZlcnJpZGluZylcbiAgLy9cbiAgLy8gZm9yIHBhcnNlZFByb3A6eyBtYXBwZWQ6IHRydXRoeSB9XG4gIC8vIHRoZSBnZW5lcmF0ZWQgZmxhdHRlbmVkUHJvcDp7IG1hcHBpbmc6IHByb3AgfVxuICAvL1xuICAvLyBmb3IgcGFyc2VkUHJvcDp7IGJ5cGFzczogdHJ1ZSB9XG4gIC8vIHRoZSBnZW5lcmF0ZWQgZmxhdHRlbmVkUHJvcDp7IGJ5cGFzc2VkOiBwYXJzZWRQcm9wIH1cblxuXG4gIHN0eWZuJDguYXBwbHlQYXJzZWRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChlbGUsIHBhcnNlZFByb3ApIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHByb3AgPSBwYXJzZWRQcm9wO1xuICAgIHZhciBzdHlsZSA9IGVsZS5fcHJpdmF0ZS5zdHlsZTtcbiAgICB2YXIgZmxhdFByb3A7XG4gICAgdmFyIHR5cGVzID0gc2VsZi50eXBlcztcbiAgICB2YXIgdHlwZSA9IHNlbGYucHJvcGVydGllc1twcm9wLm5hbWVdLnR5cGU7XG4gICAgdmFyIHByb3BJc0J5cGFzcyA9IHByb3AuYnlwYXNzO1xuICAgIHZhciBvcmlnUHJvcCA9IHN0eWxlW3Byb3AubmFtZV07XG4gICAgdmFyIG9yaWdQcm9wSXNCeXBhc3MgPSBvcmlnUHJvcCAmJiBvcmlnUHJvcC5ieXBhc3M7XG4gICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgIHZhciBmbGF0UHJvcE1hcHBpbmcgPSAnbWFwcGluZyc7XG5cbiAgICB2YXIgZ2V0VmFsID0gZnVuY3Rpb24gZ2V0VmFsKHApIHtcbiAgICAgIGlmIChwID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2UgaWYgKHAucGZWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBwLnBmVmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcC52YWx1ZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGNoZWNrVHJpZ2dlcnMgPSBmdW5jdGlvbiBjaGVja1RyaWdnZXJzKCkge1xuICAgICAgdmFyIGZyb21WYWwgPSBnZXRWYWwob3JpZ1Byb3ApO1xuICAgICAgdmFyIHRvVmFsID0gZ2V0VmFsKHByb3ApO1xuICAgICAgc2VsZi5jaGVja1RyaWdnZXJzKGVsZSwgcHJvcC5uYW1lLCBmcm9tVmFsLCB0b1ZhbCk7XG4gICAgfTtcblxuICAgIGlmIChwcm9wICYmIHByb3AubmFtZS5zdWJzdHIoMCwgMykgPT09ICdwaWUnKSB7XG4gICAgICB3YXJuKCdUaGUgcGllIHN0eWxlIHByb3BlcnRpZXMgYXJlIGRlcHJlY2F0ZWQuICBDcmVhdGUgY2hhcnRzIHVzaW5nIGJhY2tncm91bmQgaW1hZ2VzIGluc3RlYWQuJyk7XG4gICAgfSAvLyBlZGdlIHNhbml0eSBjaGVja3MgdG8gcHJldmVudCB0aGUgY2xpZW50IGZyb20gbWFraW5nIHNlcmlvdXMgbWlzdGFrZXNcblxuXG4gICAgaWYgKHBhcnNlZFByb3AubmFtZSA9PT0gJ2N1cnZlLXN0eWxlJyAmJiBlbGUuaXNFZGdlKCkgJiYgKCAvLyBsb29wcyBtdXN0IGJlIGJ1bmRsZWQgYmV6aWVyc1xuICAgIHBhcnNlZFByb3AudmFsdWUgIT09ICdiZXppZXInICYmIGVsZS5pc0xvb3AoKSB8fCAvLyBlZGdlcyBjb25uZWN0ZWQgdG8gY29tcG91bmQgbm9kZXMgY2FuIG5vdCBiZSBoYXlzdGFja3NcbiAgICBwYXJzZWRQcm9wLnZhbHVlID09PSAnaGF5c3RhY2snICYmIChlbGUuc291cmNlKCkuaXNQYXJlbnQoKSB8fCBlbGUudGFyZ2V0KCkuaXNQYXJlbnQoKSkpKSB7XG4gICAgICBwcm9wID0gcGFyc2VkUHJvcCA9IHRoaXMucGFyc2UocGFyc2VkUHJvcC5uYW1lLCAnYmV6aWVyJywgcHJvcElzQnlwYXNzKTtcbiAgICB9XG5cbiAgICBpZiAocHJvcFtcImRlbGV0ZVwiXSkge1xuICAgICAgLy8gZGVsZXRlIHRoZSBwcm9wZXJ0eSBhbmQgdXNlIHRoZSBkZWZhdWx0IHZhbHVlIG9uIGZhbHNleSB2YWx1ZVxuICAgICAgc3R5bGVbcHJvcC5uYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgIGNoZWNrVHJpZ2dlcnMoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChwcm9wLmRlbGV0ZUJ5cGFzc2VkKSB7XG4gICAgICAvLyBkZWxldGUgdGhlIHByb3BlcnR5IHRoYXQgdGhlXG4gICAgICBpZiAoIW9yaWdQcm9wKSB7XG4gICAgICAgIGNoZWNrVHJpZ2dlcnMoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7IC8vIGNhbid0IGRlbGV0ZSBpZiBubyBwcm9wXG4gICAgICB9IGVsc2UgaWYgKG9yaWdQcm9wLmJ5cGFzcykge1xuICAgICAgICAvLyBkZWxldGUgYnlwYXNzZWRcbiAgICAgICAgb3JpZ1Byb3AuYnlwYXNzZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGNoZWNrVHJpZ2dlcnMoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIHdlJ3JlIHVuc3VjY2Vzc2Z1bCBkZWxldGluZyB0aGUgYnlwYXNzZWRcbiAgICAgIH1cbiAgICB9IC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gZGVsZXRlIHRoZSBjdXJyZW50IGJ5cGFzc1xuXG5cbiAgICBpZiAocHJvcC5kZWxldGVCeXBhc3MpIHtcbiAgICAgIC8vIHRoZW4gdGhpcyBwcm9wZXJ0eSBpcyBqdXN0IGhlcmUgdG8gaW5kaWNhdGUgd2UgbmVlZCB0byBkZWxldGVcbiAgICAgIGlmICghb3JpZ1Byb3ApIHtcbiAgICAgICAgY2hlY2tUcmlnZ2VycygpO1xuICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gcHJvcGVydHkgaXMgYWxyZWFkeSBub3QgZGVmaW5lZFxuICAgICAgfSBlbHNlIGlmIChvcmlnUHJvcC5ieXBhc3MpIHtcbiAgICAgICAgLy8gdGhlbiByZXBsYWNlIHRoZSBieXBhc3MgcHJvcGVydHkgd2l0aCB0aGUgb3JpZ2luYWxcbiAgICAgICAgLy8gYmVjYXVzZSB0aGUgYnlwYXNzZWQgcHJvcGVydHkgd2FzIGFscmVhZHkgYXBwbGllZCAoYW5kIHRoZXJlZm9yZSBwYXJzZWQpLCB3ZSBjYW4ganVzdCByZXBsYWNlIGl0IChubyByZWFwcGx5aW5nIG5lY2Vzc2FyeSlcbiAgICAgICAgc3R5bGVbcHJvcC5uYW1lXSA9IG9yaWdQcm9wLmJ5cGFzc2VkO1xuICAgICAgICBjaGVja1RyaWdnZXJzKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyB3ZSdyZSB1bnN1Y2Nlc3NmdWwgZGVsZXRpbmcgdGhlIGJ5cGFzc1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcmludE1hcHBpbmdFcnIgPSBmdW5jdGlvbiBwcmludE1hcHBpbmdFcnIoKSB7XG4gICAgICB3YXJuKCdEbyBub3QgYXNzaWduIG1hcHBpbmdzIHRvIGVsZW1lbnRzIHdpdGhvdXQgY29ycmVzcG9uZGluZyBkYXRhIChpLmUuIGVsZSBgJyArIGVsZS5pZCgpICsgJ2AgaGFzIG5vIG1hcHBpbmcgZm9yIHByb3BlcnR5IGAnICsgcHJvcC5uYW1lICsgJ2Agd2l0aCBkYXRhIGZpZWxkIGAnICsgcHJvcC5maWVsZCArICdgKTsgdHJ5IGEgYFsnICsgcHJvcC5maWVsZCArICddYCBzZWxlY3RvciB0byBsaW1pdCBzY29wZSB0byBlbGVtZW50cyB3aXRoIGAnICsgcHJvcC5maWVsZCArICdgIGRlZmluZWQnKTtcbiAgICB9OyAvLyBwdXQgdGhlIHByb3BlcnR5IGluIHRoZSBzdHlsZSBvYmplY3RzXG5cblxuICAgIHN3aXRjaCAocHJvcC5tYXBwZWQpIHtcbiAgICAgIC8vIGZsYXR0ZW4gdGhlIHByb3BlcnR5IGlmIG1hcHBlZFxuICAgICAgY2FzZSB0eXBlcy5tYXBEYXRhOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gZmxhdHRlbiB0aGUgZmllbGQgKGUuZy4gZGF0YS5mb28uYmFyKVxuICAgICAgICAgIHZhciBmaWVsZHMgPSBwcm9wLmZpZWxkLnNwbGl0KCcuJyk7XG4gICAgICAgICAgdmFyIGZpZWxkVmFsID0gX3AuZGF0YTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aCAmJiBmaWVsZFZhbDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZmllbGQgPSBmaWVsZHNbaV07XG4gICAgICAgICAgICBmaWVsZFZhbCA9IGZpZWxkVmFsW2ZpZWxkXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZmllbGRWYWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgcHJpbnRNYXBwaW5nRXJyKCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHBlcmNlbnQ7XG5cbiAgICAgICAgICBpZiAoIW51bWJlciQxKGZpZWxkVmFsKSkge1xuICAgICAgICAgICAgLy8gdGhlbiBkb24ndCBhcHBseSBhbmQgZmFsbCBiYWNrIG9uIHRoZSBleGlzdGluZyBzdHlsZVxuICAgICAgICAgICAgd2FybignRG8gbm90IHVzZSBjb250aW51b3VzIG1hcHBlcnMgd2l0aG91dCBzcGVjaWZ5aW5nIG51bWVyaWMgZGF0YSAoaS5lLiBgJyArIHByb3AuZmllbGQgKyAnOiAnICsgZmllbGRWYWwgKyAnYCBmb3IgYCcgKyBlbGUuaWQoKSArICdgIGlzIG5vbi1udW1lcmljKScpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZmllbGRXaWR0aCA9IHByb3AuZmllbGRNYXggLSBwcm9wLmZpZWxkTWluO1xuXG4gICAgICAgICAgICBpZiAoZmllbGRXaWR0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAvLyBzYWZldHkgY2hlY2sgLS0gbm90IHN0cmljdGx5IG5lY2Vzc2FyeSBhcyBubyBwcm9wcyBvZiB6ZXJvIHJhbmdlIHNob3VsZCBiZSBwYXNzZWQgaGVyZVxuICAgICAgICAgICAgICBwZXJjZW50ID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBlcmNlbnQgPSAoZmllbGRWYWwgLSBwcm9wLmZpZWxkTWluKSAvIGZpZWxkV2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBtYWtlIHN1cmUgdG8gYm91bmQgcGVyY2VudCB2YWx1ZVxuXG5cbiAgICAgICAgICBpZiAocGVyY2VudCA8IDApIHtcbiAgICAgICAgICAgIHBlcmNlbnQgPSAwO1xuICAgICAgICAgIH0gZWxzZSBpZiAocGVyY2VudCA+IDEpIHtcbiAgICAgICAgICAgIHBlcmNlbnQgPSAxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0eXBlLmNvbG9yKSB7XG4gICAgICAgICAgICB2YXIgcjEgPSBwcm9wLnZhbHVlTWluWzBdO1xuICAgICAgICAgICAgdmFyIHIyID0gcHJvcC52YWx1ZU1heFswXTtcbiAgICAgICAgICAgIHZhciBnMSA9IHByb3AudmFsdWVNaW5bMV07XG4gICAgICAgICAgICB2YXIgZzIgPSBwcm9wLnZhbHVlTWF4WzFdO1xuICAgICAgICAgICAgdmFyIGIxID0gcHJvcC52YWx1ZU1pblsyXTtcbiAgICAgICAgICAgIHZhciBiMiA9IHByb3AudmFsdWVNYXhbMl07XG4gICAgICAgICAgICB2YXIgYTEgPSBwcm9wLnZhbHVlTWluWzNdID09IG51bGwgPyAxIDogcHJvcC52YWx1ZU1pblszXTtcbiAgICAgICAgICAgIHZhciBhMiA9IHByb3AudmFsdWVNYXhbM10gPT0gbnVsbCA/IDEgOiBwcm9wLnZhbHVlTWF4WzNdO1xuICAgICAgICAgICAgdmFyIGNsciA9IFtNYXRoLnJvdW5kKHIxICsgKHIyIC0gcjEpICogcGVyY2VudCksIE1hdGgucm91bmQoZzEgKyAoZzIgLSBnMSkgKiBwZXJjZW50KSwgTWF0aC5yb3VuZChiMSArIChiMiAtIGIxKSAqIHBlcmNlbnQpLCBNYXRoLnJvdW5kKGExICsgKGEyIC0gYTEpICogcGVyY2VudCldO1xuICAgICAgICAgICAgZmxhdFByb3AgPSB7XG4gICAgICAgICAgICAgIC8vIGNvbG91cnMgYXJlIHNpbXBsZSwgc28ganVzdCBjcmVhdGUgdGhlIGZsYXQgcHJvcGVydHkgaW5zdGVhZCBvZiBleHBlbnNpdmUgc3RyaW5nIHBhcnNpbmdcbiAgICAgICAgICAgICAgYnlwYXNzOiBwcm9wLmJ5cGFzcyxcbiAgICAgICAgICAgICAgLy8gd2UncmUgYSBieXBhc3MgaWYgdGhlIG1hcHBpbmcgcHJvcGVydHkgaXMgYSBieXBhc3NcbiAgICAgICAgICAgICAgbmFtZTogcHJvcC5uYW1lLFxuICAgICAgICAgICAgICB2YWx1ZTogY2xyLFxuICAgICAgICAgICAgICBzdHJWYWx1ZTogJ3JnYignICsgY2xyWzBdICsgJywgJyArIGNsclsxXSArICcsICcgKyBjbHJbMl0gKyAnKSdcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlLm51bWJlcikge1xuICAgICAgICAgICAgdmFyIGNhbGNWYWx1ZSA9IHByb3AudmFsdWVNaW4gKyAocHJvcC52YWx1ZU1heCAtIHByb3AudmFsdWVNaW4pICogcGVyY2VudDtcbiAgICAgICAgICAgIGZsYXRQcm9wID0gdGhpcy5wYXJzZShwcm9wLm5hbWUsIGNhbGNWYWx1ZSwgcHJvcC5ieXBhc3MsIGZsYXRQcm9wTWFwcGluZyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gY2FuIG9ubHkgbWFwIHRvIGNvbG91cnMgYW5kIG51bWJlcnNcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWZsYXRQcm9wKSB7XG4gICAgICAgICAgICAvLyBpZiB3ZSBjYW4ndCBmbGF0dGVuIHRoZSBwcm9wZXJ0eSwgdGhlbiBkb24ndCBhcHBseSB0aGUgcHJvcGVydHkgYW5kIGZhbGwgYmFjayBvbiB0aGUgZXhpc3Rpbmcgc3R5bGVcbiAgICAgICAgICAgIHByaW50TWFwcGluZ0VycigpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZsYXRQcm9wLm1hcHBpbmcgPSBwcm9wOyAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBtYXBwaW5nXG5cbiAgICAgICAgICBwcm9wID0gZmxhdFByb3A7IC8vIHRoZSBmbGF0dGVuZWQgKG1hcHBlZCkgcHJvcGVydHkgaXMgdGhlIG9uZSB3ZSB3YW50XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgLy8gZGlyZWN0IG1hcHBpbmdcblxuICAgICAgY2FzZSB0eXBlcy5kYXRhOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gZmxhdHRlbiB0aGUgZmllbGQgKGUuZy4gZGF0YS5mb28uYmFyKVxuICAgICAgICAgIHZhciBfZmllbGRzID0gcHJvcC5maWVsZC5zcGxpdCgnLicpO1xuXG4gICAgICAgICAgdmFyIF9maWVsZFZhbCA9IF9wLmRhdGE7XG5cbiAgICAgICAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBfZmllbGRzLmxlbmd0aCAmJiBfZmllbGRWYWw7IF9pMysrKSB7XG4gICAgICAgICAgICB2YXIgX2ZpZWxkID0gX2ZpZWxkc1tfaTNdO1xuICAgICAgICAgICAgX2ZpZWxkVmFsID0gX2ZpZWxkVmFsW19maWVsZF07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKF9maWVsZFZhbCAhPSBudWxsKSB7XG4gICAgICAgICAgICBmbGF0UHJvcCA9IHRoaXMucGFyc2UocHJvcC5uYW1lLCBfZmllbGRWYWwsIHByb3AuYnlwYXNzLCBmbGF0UHJvcE1hcHBpbmcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghZmxhdFByb3ApIHtcbiAgICAgICAgICAgIC8vIGlmIHdlIGNhbid0IGZsYXR0ZW4gdGhlIHByb3BlcnR5LCB0aGVuIGRvbid0IGFwcGx5IGFuZCBmYWxsIGJhY2sgb24gdGhlIGV4aXN0aW5nIHN0eWxlXG4gICAgICAgICAgICBwcmludE1hcHBpbmdFcnIoKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmbGF0UHJvcC5tYXBwaW5nID0gcHJvcDsgLy8ga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgbWFwcGluZ1xuXG4gICAgICAgICAgcHJvcCA9IGZsYXRQcm9wOyAvLyB0aGUgZmxhdHRlbmVkIChtYXBwZWQpIHByb3BlcnR5IGlzIHRoZSBvbmUgd2Ugd2FudFxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSB0eXBlcy5mbjpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBmbiA9IHByb3AudmFsdWU7XG4gICAgICAgICAgdmFyIGZuUmV0VmFsID0gcHJvcC5mblZhbHVlICE9IG51bGwgPyBwcm9wLmZuVmFsdWUgOiBmbihlbGUpOyAvLyBjaGVjayBmb3IgY2FjaGVkIHZhbHVlIGJlZm9yZSBjYWxsaW5nIGZ1bmN0aW9uXG5cbiAgICAgICAgICBwcm9wLnByZXZGblZhbHVlID0gZm5SZXRWYWw7XG5cbiAgICAgICAgICBpZiAoZm5SZXRWYWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgd2FybignQ3VzdG9tIGZ1bmN0aW9uIG1hcHBlcnMgbWF5IG5vdCByZXR1cm4gbnVsbCAoaS5lLiBgJyArIHByb3AubmFtZSArICdgIGZvciBlbGUgYCcgKyBlbGUuaWQoKSArICdgIGlzIG51bGwpJyk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZmxhdFByb3AgPSB0aGlzLnBhcnNlKHByb3AubmFtZSwgZm5SZXRWYWwsIHByb3AuYnlwYXNzLCBmbGF0UHJvcE1hcHBpbmcpO1xuXG4gICAgICAgICAgaWYgKCFmbGF0UHJvcCkge1xuICAgICAgICAgICAgd2FybignQ3VzdG9tIGZ1bmN0aW9uIG1hcHBlcnMgbWF5IG5vdCByZXR1cm4gaW52YWxpZCB2YWx1ZXMgZm9yIHRoZSBwcm9wZXJ0eSB0eXBlIChpLmUuIGAnICsgcHJvcC5uYW1lICsgJ2AgZm9yIGVsZSBgJyArIGVsZS5pZCgpICsgJ2AgaXMgaW52YWxpZCknKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmbGF0UHJvcC5tYXBwaW5nID0gY29weShwcm9wKTsgLy8ga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgbWFwcGluZ1xuXG4gICAgICAgICAgcHJvcCA9IGZsYXRQcm9wOyAvLyB0aGUgZmxhdHRlbmVkIChtYXBwZWQpIHByb3BlcnR5IGlzIHRoZSBvbmUgd2Ugd2FudFxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8ganVzdCBzZXQgdGhlIHByb3BlcnR5XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIC8vIG5vdCBhIHZhbGlkIG1hcHBpbmdcbiAgICB9IC8vIGlmIHRoZSBwcm9wZXJ0eSBpcyBhIGJ5cGFzcyBwcm9wZXJ0eSwgdGhlbiBsaW5rIHRoZSByZXN1bHRhbnQgcHJvcGVydHkgdG8gdGhlIG9yaWdpbmFsIG9uZVxuXG5cbiAgICBpZiAocHJvcElzQnlwYXNzKSB7XG4gICAgICBpZiAob3JpZ1Byb3BJc0J5cGFzcykge1xuICAgICAgICAvLyB0aGVuIHRoaXMgYnlwYXNzIG92ZXJyaWRlcyB0aGUgZXhpc3Rpbmcgb25lXG4gICAgICAgIHByb3AuYnlwYXNzZWQgPSBvcmlnUHJvcC5ieXBhc3NlZDsgLy8gc3RlYWwgYnlwYXNzZWQgcHJvcCBmcm9tIG9sZCBieXBhc3NcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHRoZW4gbGluayB0aGUgb3JpZyBwcm9wIHRvIHRoZSBuZXcgYnlwYXNzXG4gICAgICAgIHByb3AuYnlwYXNzZWQgPSBvcmlnUHJvcDtcbiAgICAgIH1cblxuICAgICAgc3R5bGVbcHJvcC5uYW1lXSA9IHByb3A7IC8vIGFuZCBzZXRcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcHJvcCBpcyBub3QgYnlwYXNzXG4gICAgICBpZiAob3JpZ1Byb3BJc0J5cGFzcykge1xuICAgICAgICAvLyB0aGVuIGtlZXAgdGhlIG9yaWcgcHJvcCAoc2luY2UgaXQncyBhIGJ5cGFzcykgYW5kIGxpbmsgdG8gdGhlIG5ldyBwcm9wXG4gICAgICAgIG9yaWdQcm9wLmJ5cGFzc2VkID0gcHJvcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHRoZW4ganVzdCByZXBsYWNlIHRoZSBvbGQgcHJvcCB3aXRoIHRoZSBuZXcgb25lXG4gICAgICAgIHN0eWxlW3Byb3AubmFtZV0gPSBwcm9wO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNoZWNrVHJpZ2dlcnMoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBzdHlmbiQ4LmNsZWFuRWxlbWVudHMgPSBmdW5jdGlvbiAoZWxlcywga2VlcEJ5cGFzc2VzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgIHRoaXMuY2xlYXJTdHlsZUhpbnRzKGVsZSk7XG4gICAgICBlbGUuZGlydHlDb21wb3VuZEJvdW5kc0NhY2hlKCk7XG4gICAgICBlbGUuZGlydHlCb3VuZGluZ0JveENhY2hlKCk7XG5cbiAgICAgIGlmICgha2VlcEJ5cGFzc2VzKSB7XG4gICAgICAgIGVsZS5fcHJpdmF0ZS5zdHlsZSA9IHt9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHN0eWxlID0gZWxlLl9wcml2YXRlLnN0eWxlO1xuICAgICAgICB2YXIgcHJvcE5hbWVzID0gT2JqZWN0LmtleXMoc3R5bGUpO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcHJvcE5hbWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdmFyIHByb3BOYW1lID0gcHJvcE5hbWVzW2pdO1xuICAgICAgICAgIHZhciBlbGVQcm9wID0gc3R5bGVbcHJvcE5hbWVdO1xuXG4gICAgICAgICAgaWYgKGVsZVByb3AgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGVsZVByb3AuYnlwYXNzKSB7XG4gICAgICAgICAgICAgIGVsZVByb3AuYnlwYXNzZWQgPSBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3R5bGVbcHJvcE5hbWVdID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07IC8vIHVwZGF0ZXMgdGhlIHZpc3VhbCBzdHlsZSBmb3IgYWxsIGVsZW1lbnRzICh1c2VmdWwgZm9yIG1hbnVhbCBzdHlsZSBtb2RpZmljYXRpb24gYWZ0ZXIgaW5pdClcblxuXG4gIHN0eWZuJDgudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgdmFyIGVsZXMgPSBjeS5tdXRhYmxlRWxlbWVudHMoKTtcbiAgICBlbGVzLnVwZGF0ZVN0eWxlKCk7XG4gIH07IC8vIGRpZmZQcm9wcyA6IHsgbmFtZSA9PiB7IHByZXYsIG5leHQgfSB9XG5cblxuICBzdHlmbiQ4LnVwZGF0ZVRyYW5zaXRpb25zID0gZnVuY3Rpb24gKGVsZSwgZGlmZlByb3BzKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICB2YXIgcHJvcHMgPSBlbGUucHN0eWxlKCd0cmFuc2l0aW9uLXByb3BlcnR5JykudmFsdWU7XG4gICAgdmFyIGR1cmF0aW9uID0gZWxlLnBzdHlsZSgndHJhbnNpdGlvbi1kdXJhdGlvbicpLnBmVmFsdWU7XG4gICAgdmFyIGRlbGF5ID0gZWxlLnBzdHlsZSgndHJhbnNpdGlvbi1kZWxheScpLnBmVmFsdWU7XG5cbiAgICBpZiAocHJvcHMubGVuZ3RoID4gMCAmJiBkdXJhdGlvbiA+IDApIHtcbiAgICAgIHZhciBzdHlsZSA9IHt9OyAvLyBidWlsZCB1cCB0aGUgc3R5bGUgdG8gYW5pbWF0ZSB0b3dhcmRzXG5cbiAgICAgIHZhciBhbnlQcmV2ID0gZmFsc2U7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHByb3AgPSBwcm9wc1tpXTtcbiAgICAgICAgdmFyIHN0eVByb3AgPSBlbGUucHN0eWxlKHByb3ApO1xuICAgICAgICB2YXIgZGlmZlByb3AgPSBkaWZmUHJvcHNbcHJvcF07XG5cbiAgICAgICAgaWYgKCFkaWZmUHJvcCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHByZXZQcm9wID0gZGlmZlByb3AucHJldjtcbiAgICAgICAgdmFyIGZyb21Qcm9wID0gcHJldlByb3A7XG4gICAgICAgIHZhciB0b1Byb3AgPSBkaWZmUHJvcC5uZXh0ICE9IG51bGwgPyBkaWZmUHJvcC5uZXh0IDogc3R5UHJvcDtcbiAgICAgICAgdmFyIGRpZmYgPSBmYWxzZTtcbiAgICAgICAgdmFyIGluaXRWYWwgPSB2b2lkIDA7XG4gICAgICAgIHZhciBpbml0RHQgPSAwLjAwMDAwMTsgLy8gZGVsdGEgdGltZSAlIHZhbHVlIGZvciBpbml0VmFsIChhbGxvd3MgYW5pbWF0aW5nIG91dCBvZiBpbml0IHplcm8gb3BhY2l0eSlcblxuICAgICAgICBpZiAoIWZyb21Qcm9wKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gY29uc2lkZXIgcHggdmFsdWVzXG5cblxuICAgICAgICBpZiAobnVtYmVyJDEoZnJvbVByb3AucGZWYWx1ZSkgJiYgbnVtYmVyJDEodG9Qcm9wLnBmVmFsdWUpKSB7XG4gICAgICAgICAgZGlmZiA9IHRvUHJvcC5wZlZhbHVlIC0gZnJvbVByb3AucGZWYWx1ZTsgLy8gbm9uemVybyBpcyB0cnV0aHlcblxuICAgICAgICAgIGluaXRWYWwgPSBmcm9tUHJvcC5wZlZhbHVlICsgaW5pdER0ICogZGlmZjsgLy8gY29uc2lkZXIgbnVtZXJpY2FsIHZhbHVlc1xuICAgICAgICB9IGVsc2UgaWYgKG51bWJlciQxKGZyb21Qcm9wLnZhbHVlKSAmJiBudW1iZXIkMSh0b1Byb3AudmFsdWUpKSB7XG4gICAgICAgICAgZGlmZiA9IHRvUHJvcC52YWx1ZSAtIGZyb21Qcm9wLnZhbHVlOyAvLyBub256ZXJvIGlzIHRydXRoeVxuXG4gICAgICAgICAgaW5pdFZhbCA9IGZyb21Qcm9wLnZhbHVlICsgaW5pdER0ICogZGlmZjsgLy8gY29uc2lkZXIgY29sb3VyIHZhbHVlc1xuICAgICAgICB9IGVsc2UgaWYgKGFycmF5KGZyb21Qcm9wLnZhbHVlKSAmJiBhcnJheSh0b1Byb3AudmFsdWUpKSB7XG4gICAgICAgICAgZGlmZiA9IGZyb21Qcm9wLnZhbHVlWzBdICE9PSB0b1Byb3AudmFsdWVbMF0gfHwgZnJvbVByb3AudmFsdWVbMV0gIT09IHRvUHJvcC52YWx1ZVsxXSB8fCBmcm9tUHJvcC52YWx1ZVsyXSAhPT0gdG9Qcm9wLnZhbHVlWzJdO1xuICAgICAgICAgIGluaXRWYWwgPSBmcm9tUHJvcC5zdHJWYWx1ZTtcbiAgICAgICAgfSAvLyB0aGUgcHJldmlvdXMgdmFsdWUgaXMgZ29vZCBmb3IgYW4gYW5pbWF0aW9uIG9ubHkgaWYgaXQncyBkaWZmZXJlbnRcblxuXG4gICAgICAgIGlmIChkaWZmKSB7XG4gICAgICAgICAgc3R5bGVbcHJvcF0gPSB0b1Byb3Auc3RyVmFsdWU7IC8vIHRvIHZhbFxuXG4gICAgICAgICAgdGhpcy5hcHBseUJ5cGFzcyhlbGUsIHByb3AsIGluaXRWYWwpOyAvLyBmcm9tIHZhbFxuXG4gICAgICAgICAgYW55UHJldiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gZW5kIGlmIHByb3BzIGFsbG93IGFuaVxuICAgICAgLy8gY2FuJ3QgdHJhbnNpdGlvbiBpZiB0aGVyZSdzIG5vdGhpbmcgcHJldmlvdXMgdG8gdHJhbnNpdGlvbiBmcm9tXG5cblxuICAgICAgaWYgKCFhbnlQcmV2KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgX3AudHJhbnNpdGlvbmluZyA9IHRydWU7XG4gICAgICBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgIGlmIChkZWxheSA+IDApIHtcbiAgICAgICAgICBlbGUuZGVsYXlBbmltYXRpb24oZGVsYXkpLnBsYXkoKS5wcm9taXNlKCkudGhlbihyZXNvbHZlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZWxlLmFuaW1hdGlvbih7XG4gICAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICAgICAgICBlYXNpbmc6IGVsZS5wc3R5bGUoJ3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uJykudmFsdWUsXG4gICAgICAgICAgcXVldWU6IGZhbHNlXG4gICAgICAgIH0pLnBsYXkoKS5wcm9taXNlKCk7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gaWYoICFpc0J5cGFzcyApe1xuICAgICAgICBzZWxmLnJlbW92ZUJ5cGFzc2VzKGVsZSwgcHJvcHMpO1xuICAgICAgICBlbGUuZW1pdEFuZE5vdGlmeSgnc3R5bGUnKTsgLy8gfVxuXG4gICAgICAgIF9wLnRyYW5zaXRpb25pbmcgPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoX3AudHJhbnNpdGlvbmluZykge1xuICAgICAgdGhpcy5yZW1vdmVCeXBhc3NlcyhlbGUsIHByb3BzKTtcbiAgICAgIGVsZS5lbWl0QW5kTm90aWZ5KCdzdHlsZScpO1xuICAgICAgX3AudHJhbnNpdGlvbmluZyA9IGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICBzdHlmbiQ4LmNoZWNrVHJpZ2dlciA9IGZ1bmN0aW9uIChlbGUsIG5hbWUsIGZyb21WYWx1ZSwgdG9WYWx1ZSwgZ2V0VHJpZ2dlciwgb25UcmlnZ2VyKSB7XG4gICAgdmFyIHByb3AgPSB0aGlzLnByb3BlcnRpZXNbbmFtZV07XG4gICAgdmFyIHRyaWdnZXJDaGVjayA9IGdldFRyaWdnZXIocHJvcCk7XG5cbiAgICBpZiAodHJpZ2dlckNoZWNrICE9IG51bGwgJiYgdHJpZ2dlckNoZWNrKGZyb21WYWx1ZSwgdG9WYWx1ZSkpIHtcbiAgICAgIG9uVHJpZ2dlcihwcm9wKTtcbiAgICB9XG4gIH07XG5cbiAgc3R5Zm4kOC5jaGVja1pPcmRlclRyaWdnZXIgPSBmdW5jdGlvbiAoZWxlLCBuYW1lLCBmcm9tVmFsdWUsIHRvVmFsdWUpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy5jaGVja1RyaWdnZXIoZWxlLCBuYW1lLCBmcm9tVmFsdWUsIHRvVmFsdWUsIGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICByZXR1cm4gcHJvcC50cmlnZ2Vyc1pPcmRlcjtcbiAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5fcHJpdmF0ZS5jeS5ub3RpZnkoJ3pvcmRlcicsIGVsZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgc3R5Zm4kOC5jaGVja0JvdW5kc1RyaWdnZXIgPSBmdW5jdGlvbiAoZWxlLCBuYW1lLCBmcm9tVmFsdWUsIHRvVmFsdWUpIHtcbiAgICB0aGlzLmNoZWNrVHJpZ2dlcihlbGUsIG5hbWUsIGZyb21WYWx1ZSwgdG9WYWx1ZSwgZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgIHJldHVybiBwcm9wLnRyaWdnZXJzQm91bmRzO1xuICAgIH0sIGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICBlbGUuZGlydHlDb21wb3VuZEJvdW5kc0NhY2hlKCk7XG4gICAgICBlbGUuZGlydHlCb3VuZGluZ0JveENhY2hlKCk7IC8vIGlmIHRoZSBwcm9wIGNoYW5nZSBtYWtlcyB0aGUgYmIgb2YgcGxsIGJlemllciBlZGdlcyBpbnZhbGlkLFxuICAgICAgLy8gdGhlbiBkaXJ0eSB0aGUgcGxsIGVkZ2UgYmIgY2FjaGUgYXMgd2VsbFxuXG4gICAgICBpZiAoIC8vIG9ubHkgZm9yIGJlemllcnMgLS0gc28gcGVyZm9ybWFuY2Ugb2Ygb3RoZXIgZWRnZXMgaXNuJ3QgYWZmZWN0ZWRcbiAgICAgIHByb3AudHJpZ2dlcnNCb3VuZHNPZlBhcmFsbGVsQmV6aWVycyAmJiAobmFtZSA9PT0gJ2N1cnZlLXN0eWxlJyAmJiAoZnJvbVZhbHVlID09PSAnYmV6aWVyJyB8fCB0b1ZhbHVlID09PSAnYmV6aWVyJykgfHwgbmFtZSA9PT0gJ2Rpc3BsYXknICYmIChmcm9tVmFsdWUgPT09ICdub25lJyB8fCB0b1ZhbHVlID09PSAnbm9uZScpKSkge1xuICAgICAgICBlbGUucGFyYWxsZWxFZGdlcygpLmZvckVhY2goZnVuY3Rpb24gKHBsbEVkZ2UpIHtcbiAgICAgICAgICBpZiAocGxsRWRnZS5pc0J1bmRsZWRCZXppZXIoKSkge1xuICAgICAgICAgICAgcGxsRWRnZS5kaXJ0eUJvdW5kaW5nQm94Q2FjaGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHN0eWZuJDguY2hlY2tUcmlnZ2VycyA9IGZ1bmN0aW9uIChlbGUsIG5hbWUsIGZyb21WYWx1ZSwgdG9WYWx1ZSkge1xuICAgIGVsZS5kaXJ0eVN0eWxlQ2FjaGUoKTtcbiAgICB0aGlzLmNoZWNrWk9yZGVyVHJpZ2dlcihlbGUsIG5hbWUsIGZyb21WYWx1ZSwgdG9WYWx1ZSk7XG4gICAgdGhpcy5jaGVja0JvdW5kc1RyaWdnZXIoZWxlLCBuYW1lLCBmcm9tVmFsdWUsIHRvVmFsdWUpO1xuICB9O1xuXG4gIHZhciBzdHlmbiQ3ID0ge307IC8vIGJ5cGFzc2VzIGFyZSBhcHBsaWVkIHRvIGFuIGV4aXN0aW5nIHN0eWxlIG9uIGFuIGVsZW1lbnQsIGFuZCBqdXN0IHRhY2tlZCBvbiB0ZW1wb3JhcmlseVxuICAvLyByZXR1cm5zIHRydWUgaWZmIGFwcGxpY2F0aW9uIHdhcyBzdWNjZXNzZnVsIGZvciBhdCBsZWFzdCAxIHNwZWNpZmllZCBwcm9wZXJ0eVxuXG4gIHN0eWZuJDcuYXBwbHlCeXBhc3MgPSBmdW5jdGlvbiAoZWxlcywgbmFtZSwgdmFsdWUsIHVwZGF0ZVRyYW5zaXRpb25zKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBwcm9wcyA9IFtdO1xuICAgIHZhciBpc0J5cGFzcyA9IHRydWU7IC8vIHB1dCBhbGwgdGhlIHByb3BlcnRpZXMgKGNhbiBzcGVjaWZ5IG9uZSBvciBtYW55KSBpbiBhbiBhcnJheSBhZnRlciBwYXJzaW5nIHRoZW1cblxuICAgIGlmIChuYW1lID09PSAnKicgfHwgbmFtZSA9PT0gJyoqJykge1xuICAgICAgLy8gYXBwbHkgdG8gYWxsIHByb3BlcnR5IG5hbWVzXG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYucHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBwcm9wID0gc2VsZi5wcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgIHZhciBfbmFtZSA9IHByb3AubmFtZTtcbiAgICAgICAgICB2YXIgcGFyc2VkUHJvcCA9IHRoaXMucGFyc2UoX25hbWUsIHZhbHVlLCB0cnVlKTtcblxuICAgICAgICAgIGlmIChwYXJzZWRQcm9wKSB7XG4gICAgICAgICAgICBwcm9wcy5wdXNoKHBhcnNlZFByb3ApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc3RyaW5nKG5hbWUpKSB7XG4gICAgICAvLyB0aGVuIHBhcnNlIHRoZSBzaW5nbGUgcHJvcGVydHlcbiAgICAgIHZhciBfcGFyc2VkUHJvcCA9IHRoaXMucGFyc2UobmFtZSwgdmFsdWUsIHRydWUpO1xuXG4gICAgICBpZiAoX3BhcnNlZFByb3ApIHtcbiAgICAgICAgcHJvcHMucHVzaChfcGFyc2VkUHJvcCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwbGFpbk9iamVjdChuYW1lKSkge1xuICAgICAgLy8gdGhlbiBwYXJzZSBlYWNoIHByb3BlcnR5XG4gICAgICB2YXIgc3BlY2lmaWVkUHJvcHMgPSBuYW1lO1xuICAgICAgdXBkYXRlVHJhbnNpdGlvbnMgPSB2YWx1ZTtcbiAgICAgIHZhciBuYW1lcyA9IE9iamVjdC5rZXlzKHNwZWNpZmllZFByb3BzKTtcblxuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG5hbWVzLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgX25hbWUyID0gbmFtZXNbX2ldO1xuICAgICAgICB2YXIgX3ZhbHVlID0gc3BlY2lmaWVkUHJvcHNbX25hbWUyXTtcblxuICAgICAgICBpZiAoX3ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyB0cnkgY2FtZWwgY2FzZSBuYW1lIHRvb1xuICAgICAgICAgIF92YWx1ZSA9IHNwZWNpZmllZFByb3BzW2Rhc2gyY2FtZWwoX25hbWUyKV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX3ZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgX3BhcnNlZFByb3AyID0gdGhpcy5wYXJzZShfbmFtZTIsIF92YWx1ZSwgdHJ1ZSk7XG5cbiAgICAgICAgICBpZiAoX3BhcnNlZFByb3AyKSB7XG4gICAgICAgICAgICBwcm9wcy5wdXNoKF9wYXJzZWRQcm9wMik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNhbid0IGRvIGFueXRoaW5nIHdpdGhvdXQgd2VsbCBkZWZpbmVkIHByb3BlcnRpZXNcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIHdlJ3ZlIGZhaWxlZCBpZiB0aGVyZSBhcmUgbm8gdmFsaWQgcHJvcGVydGllc1xuXG5cbiAgICBpZiAocHJvcHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBub3csIGFwcGx5IHRoZSBieXBhc3MgcHJvcGVydGllcyBvbiB0aGUgZWxlbWVudHNcblxuXG4gICAgdmFyIHJldCA9IGZhbHNlOyAvLyByZXR1cm4gdHJ1ZSBpZiBhdCBsZWFzdCBvbmUgc3VjY2VzZnVsIGJ5cGFzcyBhcHBsaWVkXG5cbiAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBlbGVzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgIC8vIGZvciBlYWNoIGVsZVxuICAgICAgdmFyIGVsZSA9IGVsZXNbX2kyXTtcbiAgICAgIHZhciBkaWZmUHJvcHMgPSB7fTtcbiAgICAgIHZhciBkaWZmUHJvcCA9IHZvaWQgMDtcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwcm9wcy5sZW5ndGg7IGorKykge1xuICAgICAgICAvLyBmb3IgZWFjaCBwcm9wXG4gICAgICAgIHZhciBfcHJvcCA9IHByb3BzW2pdO1xuXG4gICAgICAgIGlmICh1cGRhdGVUcmFuc2l0aW9ucykge1xuICAgICAgICAgIHZhciBwcmV2UHJvcCA9IGVsZS5wc3R5bGUoX3Byb3AubmFtZSk7XG4gICAgICAgICAgZGlmZlByb3AgPSBkaWZmUHJvcHNbX3Byb3AubmFtZV0gPSB7XG4gICAgICAgICAgICBwcmV2OiBwcmV2UHJvcFxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXQgPSB0aGlzLmFwcGx5UGFyc2VkUHJvcGVydHkoZWxlLCBjb3B5KF9wcm9wKSkgfHwgcmV0O1xuXG4gICAgICAgIGlmICh1cGRhdGVUcmFuc2l0aW9ucykge1xuICAgICAgICAgIGRpZmZQcm9wLm5leHQgPSBlbGUucHN0eWxlKF9wcm9wLm5hbWUpO1xuICAgICAgICB9XG4gICAgICB9IC8vIGZvciBwcm9wc1xuXG5cbiAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgdGhpcy51cGRhdGVTdHlsZUhpbnRzKGVsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh1cGRhdGVUcmFuc2l0aW9ucykge1xuICAgICAgICB0aGlzLnVwZGF0ZVRyYW5zaXRpb25zKGVsZSwgZGlmZlByb3BzLCBpc0J5cGFzcyk7XG4gICAgICB9XG4gICAgfSAvLyBmb3IgZWxlc1xuXG5cbiAgICByZXR1cm4gcmV0O1xuICB9OyAvLyBvbmx5IHVzZWZ1bCBpbiBzcGVjaWZpYyBjYXNlcyBsaWtlIGFuaW1hdGlvblxuXG5cbiAgc3R5Zm4kNy5vdmVycmlkZUJ5cGFzcyA9IGZ1bmN0aW9uIChlbGVzLCBuYW1lLCB2YWx1ZSkge1xuICAgIG5hbWUgPSBjYW1lbDJkYXNoKG5hbWUpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgIHZhciBwcm9wID0gZWxlLl9wcml2YXRlLnN0eWxlW25hbWVdO1xuICAgICAgdmFyIHR5cGUgPSB0aGlzLnByb3BlcnRpZXNbbmFtZV0udHlwZTtcbiAgICAgIHZhciBpc0NvbG9yID0gdHlwZS5jb2xvcjtcbiAgICAgIHZhciBpc011bHRpID0gdHlwZS5tdXRpcGxlO1xuICAgICAgdmFyIG9sZFZhbHVlID0gIXByb3AgPyBudWxsIDogcHJvcC5wZlZhbHVlICE9IG51bGwgPyBwcm9wLnBmVmFsdWUgOiBwcm9wLnZhbHVlO1xuXG4gICAgICBpZiAoIXByb3AgfHwgIXByb3AuYnlwYXNzKSB7XG4gICAgICAgIC8vIG5lZWQgYSBieXBhc3MgaWYgb25lIGRvZXNuJ3QgZXhpc3RcbiAgICAgICAgdGhpcy5hcHBseUJ5cGFzcyhlbGUsIG5hbWUsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3AudmFsdWUgPSB2YWx1ZTtcblxuICAgICAgICBpZiAocHJvcC5wZlZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICBwcm9wLnBmVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0NvbG9yKSB7XG4gICAgICAgICAgcHJvcC5zdHJWYWx1ZSA9ICdyZ2IoJyArIHZhbHVlLmpvaW4oJywnKSArICcpJztcbiAgICAgICAgfSBlbHNlIGlmIChpc011bHRpKSB7XG4gICAgICAgICAgcHJvcC5zdHJWYWx1ZSA9IHZhbHVlLmpvaW4oJyAnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9wLnN0clZhbHVlID0gJycgKyB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXBkYXRlU3R5bGVIaW50cyhlbGUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNoZWNrVHJpZ2dlcnMoZWxlLCBuYW1lLCBvbGRWYWx1ZSwgdmFsdWUpO1xuICAgIH1cbiAgfTtcblxuICBzdHlmbiQ3LnJlbW92ZUFsbEJ5cGFzc2VzID0gZnVuY3Rpb24gKGVsZXMsIHVwZGF0ZVRyYW5zaXRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMucmVtb3ZlQnlwYXNzZXMoZWxlcywgdGhpcy5wcm9wZXJ0eU5hbWVzLCB1cGRhdGVUcmFuc2l0aW9ucyk7XG4gIH07XG5cbiAgc3R5Zm4kNy5yZW1vdmVCeXBhc3NlcyA9IGZ1bmN0aW9uIChlbGVzLCBwcm9wcywgdXBkYXRlVHJhbnNpdGlvbnMpIHtcbiAgICB2YXIgaXNCeXBhc3MgPSB0cnVlO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBlbGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgZWxlID0gZWxlc1tqXTtcbiAgICAgIHZhciBkaWZmUHJvcHMgPSB7fTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbmFtZSA9IHByb3BzW2ldO1xuICAgICAgICB2YXIgcHJvcCA9IHRoaXMucHJvcGVydGllc1tuYW1lXTtcbiAgICAgICAgdmFyIHByZXZQcm9wID0gZWxlLnBzdHlsZShwcm9wLm5hbWUpO1xuXG4gICAgICAgIGlmICghcHJldlByb3AgfHwgIXByZXZQcm9wLmJ5cGFzcykge1xuICAgICAgICAgIC8vIGlmIGEgYnlwYXNzIGRvZXNuJ3QgZXhpc3QgZm9yIHRoZSBwcm9wLCBub3RoaW5nIG5lZWRzIHRvIGJlIHJlbW92ZWRcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2YWx1ZSA9ICcnOyAvLyBlbXB0eSA9PiByZW1vdmUgYnlwYXNzXG5cbiAgICAgICAgdmFyIHBhcnNlZFByb3AgPSB0aGlzLnBhcnNlKG5hbWUsIHZhbHVlLCB0cnVlKTtcbiAgICAgICAgdmFyIGRpZmZQcm9wID0gZGlmZlByb3BzW3Byb3AubmFtZV0gPSB7XG4gICAgICAgICAgcHJldjogcHJldlByb3BcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hcHBseVBhcnNlZFByb3BlcnR5KGVsZSwgcGFyc2VkUHJvcCk7XG4gICAgICAgIGRpZmZQcm9wLm5leHQgPSBlbGUucHN0eWxlKHByb3AubmFtZSk7XG4gICAgICB9IC8vIGZvciBwcm9wc1xuXG5cbiAgICAgIHRoaXMudXBkYXRlU3R5bGVIaW50cyhlbGUpO1xuXG4gICAgICBpZiAodXBkYXRlVHJhbnNpdGlvbnMpIHtcbiAgICAgICAgdGhpcy51cGRhdGVUcmFuc2l0aW9ucyhlbGUsIGRpZmZQcm9wcywgaXNCeXBhc3MpO1xuICAgICAgfVxuICAgIH0gLy8gZm9yIGVsZXNcblxuICB9O1xuXG4gIHZhciBzdHlmbiQ2ID0ge307IC8vIGdldHMgd2hhdCBhbiBlbSBzaXplIGNvcnJlc3BvbmRzIHRvIGluIHBpeGVscyByZWxhdGl2ZSB0byBhIGRvbSBlbGVtZW50XG5cbiAgc3R5Zm4kNi5nZXRFbVNpemVJblBpeGVscyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHggPSB0aGlzLmNvbnRhaW5lckNzcygnZm9udC1zaXplJyk7XG5cbiAgICBpZiAocHggIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHBhcnNlRmxvYXQocHgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gMTsgLy8gZm9yIGhlYWRsZXNzXG4gICAgfVxuICB9OyAvLyBnZXRzIGNzcyBwcm9wZXJ0eSBmcm9tIHRoZSBjb3JlIGNvbnRhaW5lclxuXG5cbiAgc3R5Zm4kNi5jb250YWluZXJDc3MgPSBmdW5jdGlvbiAocHJvcE5hbWUpIHtcbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgIHZhciBkb21FbGVtZW50ID0gY3kuY29udGFpbmVyKCk7XG5cbiAgICBpZiAod2luZG93JDEgJiYgZG9tRWxlbWVudCAmJiB3aW5kb3ckMS5nZXRDb21wdXRlZFN0eWxlKSB7XG4gICAgICByZXR1cm4gd2luZG93JDEuZ2V0Q29tcHV0ZWRTdHlsZShkb21FbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BOYW1lKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHN0eWZuJDUgPSB7fTsgLy8gZ2V0cyB0aGUgcmVuZGVyZWQgc3R5bGUgZm9yIGFuIGVsZW1lbnRcblxuICBzdHlmbiQ1LmdldFJlbmRlcmVkU3R5bGUgPSBmdW5jdGlvbiAoZWxlLCBwcm9wKSB7XG4gICAgaWYgKHByb3ApIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFN0eWxlUHJvcGVydHlWYWx1ZShlbGUsIHByb3AsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRSYXdTdHlsZShlbGUsIHRydWUpO1xuICAgIH1cbiAgfTsgLy8gZ2V0cyB0aGUgcmF3IHN0eWxlIGZvciBhbiBlbGVtZW50XG5cblxuICBzdHlmbiQ1LmdldFJhd1N0eWxlID0gZnVuY3Rpb24gKGVsZSwgaXNSZW5kZXJlZFZhbCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBlbGUgPSBlbGVbMF07IC8vIGluc3VyZSBpdCdzIGFuIGVsZW1lbnRcblxuICAgIGlmIChlbGUpIHtcbiAgICAgIHZhciByc3R5bGUgPSB7fTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLnByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHByb3AgPSBzZWxmLnByb3BlcnRpZXNbaV07XG4gICAgICAgIHZhciB2YWwgPSBzZWxmLmdldFN0eWxlUHJvcGVydHlWYWx1ZShlbGUsIHByb3AubmFtZSwgaXNSZW5kZXJlZFZhbCk7XG5cbiAgICAgICAgaWYgKHZhbCAhPSBudWxsKSB7XG4gICAgICAgICAgcnN0eWxlW3Byb3AubmFtZV0gPSB2YWw7XG4gICAgICAgICAgcnN0eWxlW2Rhc2gyY2FtZWwocHJvcC5uYW1lKV0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJzdHlsZTtcbiAgICB9XG4gIH07XG5cbiAgc3R5Zm4kNS5nZXRJbmRleGVkU3R5bGUgPSBmdW5jdGlvbiAoZWxlLCBwcm9wZXJ0eSwgc3VicHJvcGVydHksIGluZGV4KSB7XG4gICAgdmFyIHBzdHlsZSA9IGVsZS5wc3R5bGUocHJvcGVydHkpW3N1YnByb3BlcnR5XVtpbmRleF07XG4gICAgcmV0dXJuIHBzdHlsZSAhPSBudWxsID8gcHN0eWxlIDogZWxlLmN5KCkuc3R5bGUoKS5nZXREZWZhdWx0UHJvcGVydHkocHJvcGVydHkpW3N1YnByb3BlcnR5XVswXTtcbiAgfTtcblxuICBzdHlmbiQ1LmdldFN0eWxlUHJvcGVydHlWYWx1ZSA9IGZ1bmN0aW9uIChlbGUsIHByb3BOYW1lLCBpc1JlbmRlcmVkVmFsKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGVsZSA9IGVsZVswXTsgLy8gaW5zdXJlIGl0J3MgYW4gZWxlbWVudFxuXG4gICAgaWYgKGVsZSkge1xuICAgICAgdmFyIHByb3AgPSBzZWxmLnByb3BlcnRpZXNbcHJvcE5hbWVdO1xuXG4gICAgICBpZiAocHJvcC5hbGlhcykge1xuICAgICAgICBwcm9wID0gcHJvcC5wb2ludHNUbztcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGUgPSBwcm9wLnR5cGU7XG4gICAgICB2YXIgc3R5bGVQcm9wID0gZWxlLnBzdHlsZShwcm9wLm5hbWUpO1xuXG4gICAgICBpZiAoc3R5bGVQcm9wKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHN0eWxlUHJvcC52YWx1ZSxcbiAgICAgICAgICAgIHVuaXRzID0gc3R5bGVQcm9wLnVuaXRzLFxuICAgICAgICAgICAgc3RyVmFsdWUgPSBzdHlsZVByb3Auc3RyVmFsdWU7XG5cbiAgICAgICAgaWYgKGlzUmVuZGVyZWRWYWwgJiYgdHlwZS5udW1iZXIgJiYgdmFsdWUgIT0gbnVsbCAmJiBudW1iZXIkMSh2YWx1ZSkpIHtcbiAgICAgICAgICB2YXIgem9vbSA9IGVsZS5jeSgpLnpvb20oKTtcblxuICAgICAgICAgIHZhciBnZXRSZW5kZXJlZFZhbHVlID0gZnVuY3Rpb24gZ2V0UmVuZGVyZWRWYWx1ZSh2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWwgKiB6b29tO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICB2YXIgZ2V0VmFsdWVTdHJpbmdXaXRoVW5pdHMgPSBmdW5jdGlvbiBnZXRWYWx1ZVN0cmluZ1dpdGhVbml0cyh2YWwsIHVuaXRzKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0UmVuZGVyZWRWYWx1ZSh2YWwpICsgdW5pdHM7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHZhciBpc0FycmF5VmFsdWUgPSBhcnJheSh2YWx1ZSk7XG4gICAgICAgICAgdmFyIGhhdmVVbml0cyA9IGlzQXJyYXlWYWx1ZSA/IHVuaXRzLmV2ZXJ5KGZ1bmN0aW9uICh1KSB7XG4gICAgICAgICAgICByZXR1cm4gdSAhPSBudWxsO1xuICAgICAgICAgIH0pIDogdW5pdHMgIT0gbnVsbDtcblxuICAgICAgICAgIGlmIChoYXZlVW5pdHMpIHtcbiAgICAgICAgICAgIGlmIChpc0FycmF5VmFsdWUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm1hcChmdW5jdGlvbiAodiwgaSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRWYWx1ZVN0cmluZ1dpdGhVbml0cyh2LCB1bml0c1tpXSk7XG4gICAgICAgICAgICAgIH0pLmpvaW4oJyAnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBnZXRWYWx1ZVN0cmluZ1dpdGhVbml0cyh2YWx1ZSwgdW5pdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoaXNBcnJheVZhbHVlKSB7XG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nKHYpID8gdiA6ICcnICsgZ2V0UmVuZGVyZWRWYWx1ZSh2KTtcbiAgICAgICAgICAgICAgfSkuam9pbignICcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuICcnICsgZ2V0UmVuZGVyZWRWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHN0clZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gc3RyVmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9O1xuXG4gIHN0eWZuJDUuZ2V0QW5pbWF0aW9uU3RhcnRTdHlsZSA9IGZ1bmN0aW9uIChlbGUsIGFuaVByb3BzKSB7XG4gICAgdmFyIHJzdHlsZSA9IHt9O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbmlQcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGFuaVByb3AgPSBhbmlQcm9wc1tpXTtcbiAgICAgIHZhciBuYW1lID0gYW5pUHJvcC5uYW1lO1xuICAgICAgdmFyIHN0eWxlUHJvcCA9IGVsZS5wc3R5bGUobmFtZSk7XG5cbiAgICAgIGlmIChzdHlsZVByb3AgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyB0aGVuIG1ha2UgYSBwcm9wIG9mIGl0XG4gICAgICAgIGlmIChwbGFpbk9iamVjdChzdHlsZVByb3ApKSB7XG4gICAgICAgICAgc3R5bGVQcm9wID0gdGhpcy5wYXJzZShuYW1lLCBzdHlsZVByb3Auc3RyVmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0eWxlUHJvcCA9IHRoaXMucGFyc2UobmFtZSwgc3R5bGVQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc3R5bGVQcm9wKSB7XG4gICAgICAgIHJzdHlsZVtuYW1lXSA9IHN0eWxlUHJvcDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcnN0eWxlO1xuICB9O1xuXG4gIHN0eWZuJDUuZ2V0UHJvcHNMaXN0ID0gZnVuY3Rpb24gKHByb3BzT2JqKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciByc3R5bGUgPSBbXTtcbiAgICB2YXIgc3R5bGUgPSBwcm9wc09iajtcbiAgICB2YXIgcHJvcHMgPSBzZWxmLnByb3BlcnRpZXM7XG5cbiAgICBpZiAoc3R5bGUpIHtcbiAgICAgIHZhciBuYW1lcyA9IE9iamVjdC5rZXlzKHN0eWxlKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbmFtZSA9IG5hbWVzW2ldO1xuICAgICAgICB2YXIgdmFsID0gc3R5bGVbbmFtZV07XG4gICAgICAgIHZhciBwcm9wID0gcHJvcHNbbmFtZV0gfHwgcHJvcHNbY2FtZWwyZGFzaChuYW1lKV07XG4gICAgICAgIHZhciBzdHlsZVByb3AgPSB0aGlzLnBhcnNlKHByb3AubmFtZSwgdmFsKTtcblxuICAgICAgICBpZiAoc3R5bGVQcm9wKSB7XG4gICAgICAgICAgcnN0eWxlLnB1c2goc3R5bGVQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByc3R5bGU7XG4gIH07XG5cbiAgc3R5Zm4kNS5nZXROb25EZWZhdWx0UHJvcGVydGllc0hhc2ggPSBmdW5jdGlvbiAoZWxlLCBwcm9wTmFtZXMsIHNlZWQpIHtcbiAgICB2YXIgaGFzaCA9IHNlZWQuc2xpY2UoKTtcbiAgICB2YXIgbmFtZSwgdmFsLCBzdHJWYWwsIGNoVmFsO1xuICAgIHZhciBpLCBqO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHByb3BOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgbmFtZSA9IHByb3BOYW1lc1tpXTtcbiAgICAgIHZhbCA9IGVsZS5wc3R5bGUobmFtZSwgZmFsc2UpO1xuXG4gICAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKHZhbC5wZlZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgaGFzaFswXSA9IGhhc2hJbnQoY2hWYWwsIGhhc2hbMF0pO1xuICAgICAgICBoYXNoWzFdID0gaGFzaEludEFsdChjaFZhbCwgaGFzaFsxXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHJWYWwgPSB2YWwuc3RyVmFsdWU7XG5cbiAgICAgICAgZm9yIChqID0gMDsgaiA8IHN0clZhbC5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGNoVmFsID0gc3RyVmFsLmNoYXJDb2RlQXQoaik7XG4gICAgICAgICAgaGFzaFswXSA9IGhhc2hJbnQoY2hWYWwsIGhhc2hbMF0pO1xuICAgICAgICAgIGhhc2hbMV0gPSBoYXNoSW50QWx0KGNoVmFsLCBoYXNoWzFdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBoYXNoO1xuICB9O1xuXG4gIHN0eWZuJDUuZ2V0UHJvcGVydGllc0hhc2ggPSBzdHlmbiQ1LmdldE5vbkRlZmF1bHRQcm9wZXJ0aWVzSGFzaDtcblxuICB2YXIgc3R5Zm4kNCA9IHt9O1xuXG4gIHN0eWZuJDQuYXBwZW5kRnJvbUpzb24gPSBmdW5jdGlvbiAoanNvbikge1xuICAgIHZhciBzdHlsZSA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGpzb24ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjb250ZXh0ID0ganNvbltpXTtcbiAgICAgIHZhciBzZWxlY3RvciA9IGNvbnRleHQuc2VsZWN0b3I7XG4gICAgICB2YXIgcHJvcHMgPSBjb250ZXh0LnN0eWxlIHx8IGNvbnRleHQuY3NzO1xuICAgICAgdmFyIG5hbWVzID0gT2JqZWN0LmtleXMocHJvcHMpO1xuICAgICAgc3R5bGUuc2VsZWN0b3Ioc2VsZWN0b3IpOyAvLyBhcHBseSBzZWxlY3RvclxuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5hbWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBuYW1lID0gbmFtZXNbal07XG4gICAgICAgIHZhciB2YWx1ZSA9IHByb3BzW25hbWVdO1xuICAgICAgICBzdHlsZS5jc3MobmFtZSwgdmFsdWUpOyAvLyBhcHBseSBwcm9wZXJ0eVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdHlsZTtcbiAgfTsgLy8gYWNjZXNzaWJsZSBjeS5zdHlsZSgpIGZ1bmN0aW9uXG5cblxuICBzdHlmbiQ0LmZyb21Kc29uID0gZnVuY3Rpb24gKGpzb24pIHtcbiAgICB2YXIgc3R5bGUgPSB0aGlzO1xuICAgIHN0eWxlLnJlc2V0VG9EZWZhdWx0KCk7XG4gICAgc3R5bGUuYXBwZW5kRnJvbUpzb24oanNvbik7XG4gICAgcmV0dXJuIHN0eWxlO1xuICB9OyAvLyBnZXQganNvbiBmcm9tIGN5LnN0eWxlKCkgYXBpXG5cblxuICBzdHlmbiQ0Lmpzb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGpzb24gPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSB0aGlzLmRlZmF1bHRMZW5ndGg7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY3h0ID0gdGhpc1tpXTtcbiAgICAgIHZhciBzZWxlY3RvciA9IGN4dC5zZWxlY3RvcjtcbiAgICAgIHZhciBwcm9wcyA9IGN4dC5wcm9wZXJ0aWVzO1xuICAgICAgdmFyIGNzcyA9IHt9O1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHByb3BzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBwcm9wID0gcHJvcHNbal07XG4gICAgICAgIGNzc1twcm9wLm5hbWVdID0gcHJvcC5zdHJWYWx1ZTtcbiAgICAgIH1cblxuICAgICAganNvbi5wdXNoKHtcbiAgICAgICAgc2VsZWN0b3I6ICFzZWxlY3RvciA/ICdjb3JlJyA6IHNlbGVjdG9yLnRvU3RyaW5nKCksXG4gICAgICAgIHN0eWxlOiBjc3NcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBqc29uO1xuICB9O1xuXG4gIHZhciBzdHlmbiQzID0ge307XG5cbiAgc3R5Zm4kMy5hcHBlbmRGcm9tU3RyaW5nID0gZnVuY3Rpb24gKHN0cmluZykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgc3R5bGUgPSB0aGlzO1xuICAgIHZhciByZW1haW5pbmcgPSAnJyArIHN0cmluZztcbiAgICB2YXIgc2VsQW5kQmxvY2tTdHI7XG4gICAgdmFyIGJsb2NrUmVtO1xuICAgIHZhciBwcm9wQW5kVmFsU3RyOyAvLyByZW1vdmUgY29tbWVudHMgZnJvbSB0aGUgc3R5bGUgc3RyaW5nXG5cbiAgICByZW1haW5pbmcgPSByZW1haW5pbmcucmVwbGFjZSgvWy9dWypdKFxcc3wuKSs/WypdWy9dL2csICcnKTtcblxuICAgIGZ1bmN0aW9uIHJlbW92ZVNlbEFuZEJsb2NrRnJvbVJlbWFpbmluZygpIHtcbiAgICAgIC8vIHJlbW92ZSB0aGUgcGFyc2VkIHNlbGVjdG9yIGFuZCBibG9jayBmcm9tIHRoZSByZW1haW5pbmcgdGV4dCB0byBwYXJzZVxuICAgICAgaWYgKHJlbWFpbmluZy5sZW5ndGggPiBzZWxBbmRCbG9ja1N0ci5sZW5ndGgpIHtcbiAgICAgICAgcmVtYWluaW5nID0gcmVtYWluaW5nLnN1YnN0cihzZWxBbmRCbG9ja1N0ci5sZW5ndGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVtYWluaW5nID0gJyc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlUHJvcEFuZFZhbEZyb21SZW0oKSB7XG4gICAgICAvLyByZW1vdmUgdGhlIHBhcnNlZCBwcm9wZXJ0eSBhbmQgdmFsdWUgZnJvbSB0aGUgcmVtYWluaW5nIGJsb2NrIHRleHQgdG8gcGFyc2VcbiAgICAgIGlmIChibG9ja1JlbS5sZW5ndGggPiBwcm9wQW5kVmFsU3RyLmxlbmd0aCkge1xuICAgICAgICBibG9ja1JlbSA9IGJsb2NrUmVtLnN1YnN0cihwcm9wQW5kVmFsU3RyLmxlbmd0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBibG9ja1JlbSA9ICcnO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoOzspIHtcbiAgICAgIHZhciBub3RoaW5nTGVmdFRvUGFyc2UgPSByZW1haW5pbmcubWF0Y2goL15cXHMqJC8pO1xuXG4gICAgICBpZiAobm90aGluZ0xlZnRUb1BhcnNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2VsQW5kQmxvY2sgPSByZW1haW5pbmcubWF0Y2goL15cXHMqKCg/Oi58XFxzKSs/KVxccypcXHsoKD86LnxcXHMpKz8pXFx9Lyk7XG5cbiAgICAgIGlmICghc2VsQW5kQmxvY2spIHtcbiAgICAgICAgd2FybignSGFsdGluZyBzdHlsZXNoZWV0IHBhcnNpbmc6IFN0cmluZyBzdHlsZXNoZWV0IGNvbnRhaW5zIG1vcmUgdG8gcGFyc2UgYnV0IG5vIHNlbGVjdG9yIGFuZCBibG9jayBmb3VuZCBpbjogJyArIHJlbWFpbmluZyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBzZWxBbmRCbG9ja1N0ciA9IHNlbEFuZEJsb2NrWzBdOyAvLyBwYXJzZSB0aGUgc2VsZWN0b3JcblxuICAgICAgdmFyIHNlbGVjdG9yU3RyID0gc2VsQW5kQmxvY2tbMV07XG5cbiAgICAgIGlmIChzZWxlY3RvclN0ciAhPT0gJ2NvcmUnKSB7XG4gICAgICAgIHZhciBzZWxlY3RvciA9IG5ldyBTZWxlY3RvcihzZWxlY3RvclN0cik7XG5cbiAgICAgICAgaWYgKHNlbGVjdG9yLmludmFsaWQpIHtcbiAgICAgICAgICB3YXJuKCdTa2lwcGluZyBwYXJzaW5nIG9mIGJsb2NrOiBJbnZhbGlkIHNlbGVjdG9yIGZvdW5kIGluIHN0cmluZyBzdHlsZXNoZWV0OiAnICsgc2VsZWN0b3JTdHIpOyAvLyBza2lwIHRoaXMgc2VsZWN0b3IgYW5kIGJsb2NrXG5cbiAgICAgICAgICByZW1vdmVTZWxBbmRCbG9ja0Zyb21SZW1haW5pbmcoKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBwYXJzZSB0aGUgYmxvY2sgb2YgcHJvcGVydGllcyBhbmQgdmFsdWVzXG5cblxuICAgICAgdmFyIGJsb2NrU3RyID0gc2VsQW5kQmxvY2tbMl07XG4gICAgICB2YXIgaW52YWxpZEJsb2NrID0gZmFsc2U7XG4gICAgICBibG9ja1JlbSA9IGJsb2NrU3RyO1xuICAgICAgdmFyIHByb3BzID0gW107XG5cbiAgICAgIGZvciAoOzspIHtcbiAgICAgICAgdmFyIF9ub3RoaW5nTGVmdFRvUGFyc2UgPSBibG9ja1JlbS5tYXRjaCgvXlxccyokLyk7XG5cbiAgICAgICAgaWYgKF9ub3RoaW5nTGVmdFRvUGFyc2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcm9wQW5kVmFsID0gYmxvY2tSZW0ubWF0Y2goL15cXHMqKC4rPylcXHMqOlxccyooLis/KSg/Olxccyo7fFxccyokKS8pO1xuXG4gICAgICAgIGlmICghcHJvcEFuZFZhbCkge1xuICAgICAgICAgIHdhcm4oJ1NraXBwaW5nIHBhcnNpbmcgb2YgYmxvY2s6IEludmFsaWQgZm9ybWF0dGluZyBvZiBzdHlsZSBwcm9wZXJ0eSBhbmQgdmFsdWUgZGVmaW5pdGlvbnMgZm91bmQgaW46JyArIGJsb2NrU3RyKTtcbiAgICAgICAgICBpbnZhbGlkQmxvY2sgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvcEFuZFZhbFN0ciA9IHByb3BBbmRWYWxbMF07XG4gICAgICAgIHZhciBwcm9wU3RyID0gcHJvcEFuZFZhbFsxXTtcbiAgICAgICAgdmFyIHZhbFN0ciA9IHByb3BBbmRWYWxbMl07XG4gICAgICAgIHZhciBwcm9wID0gc2VsZi5wcm9wZXJ0aWVzW3Byb3BTdHJdO1xuXG4gICAgICAgIGlmICghcHJvcCkge1xuICAgICAgICAgIHdhcm4oJ1NraXBwaW5nIHByb3BlcnR5OiBJbnZhbGlkIHByb3BlcnR5IG5hbWUgaW46ICcgKyBwcm9wQW5kVmFsU3RyKTsgLy8gc2tpcCB0aGlzIHByb3BlcnR5IGluIHRoZSBibG9ja1xuXG4gICAgICAgICAgcmVtb3ZlUHJvcEFuZFZhbEZyb21SZW0oKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXJzZWRQcm9wID0gc3R5bGUucGFyc2UocHJvcFN0ciwgdmFsU3RyKTtcblxuICAgICAgICBpZiAoIXBhcnNlZFByb3ApIHtcbiAgICAgICAgICB3YXJuKCdTa2lwcGluZyBwcm9wZXJ0eTogSW52YWxpZCBwcm9wZXJ0eSBkZWZpbml0aW9uIGluOiAnICsgcHJvcEFuZFZhbFN0cik7IC8vIHNraXAgdGhpcyBwcm9wZXJ0eSBpbiB0aGUgYmxvY2tcblxuICAgICAgICAgIHJlbW92ZVByb3BBbmRWYWxGcm9tUmVtKCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBwcm9wcy5wdXNoKHtcbiAgICAgICAgICBuYW1lOiBwcm9wU3RyLFxuICAgICAgICAgIHZhbDogdmFsU3RyXG4gICAgICAgIH0pO1xuICAgICAgICByZW1vdmVQcm9wQW5kVmFsRnJvbVJlbSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW52YWxpZEJsb2NrKSB7XG4gICAgICAgIHJlbW92ZVNlbEFuZEJsb2NrRnJvbVJlbWFpbmluZygpO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gLy8gcHV0IHRoZSBwYXJzZWQgYmxvY2sgaW4gdGhlIHN0eWxlXG5cblxuICAgICAgc3R5bGUuc2VsZWN0b3Ioc2VsZWN0b3JTdHIpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBfcHJvcCA9IHByb3BzW2ldO1xuICAgICAgICBzdHlsZS5jc3MoX3Byb3AubmFtZSwgX3Byb3AudmFsKTtcbiAgICAgIH1cblxuICAgICAgcmVtb3ZlU2VsQW5kQmxvY2tGcm9tUmVtYWluaW5nKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0eWxlO1xuICB9O1xuXG4gIHN0eWZuJDMuZnJvbVN0cmluZyA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICB2YXIgc3R5bGUgPSB0aGlzO1xuICAgIHN0eWxlLnJlc2V0VG9EZWZhdWx0KCk7XG4gICAgc3R5bGUuYXBwZW5kRnJvbVN0cmluZyhzdHJpbmcpO1xuICAgIHJldHVybiBzdHlsZTtcbiAgfTtcblxuICB2YXIgc3R5Zm4kMiA9IHt9O1xuXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG51bWJlciQxID0gbnVtYmVyO1xuICAgIHZhciByZ2JhID0gcmdiYU5vQmFja1JlZnM7XG4gICAgdmFyIGhzbGEgPSBoc2xhTm9CYWNrUmVmcztcbiAgICB2YXIgaGV4MyQxID0gaGV4MztcbiAgICB2YXIgaGV4NiQxID0gaGV4NjtcblxuICAgIHZhciBkYXRhID0gZnVuY3Rpb24gZGF0YShwcmVmaXgpIHtcbiAgICAgIHJldHVybiAnXicgKyBwcmVmaXggKyAnXFxcXHMqXFxcXChcXFxccyooW1xcXFx3XFxcXC5dKylcXFxccypcXFxcKSQnO1xuICAgIH07XG5cbiAgICB2YXIgbWFwRGF0YSA9IGZ1bmN0aW9uIG1hcERhdGEocHJlZml4KSB7XG4gICAgICB2YXIgbWFwQXJnID0gbnVtYmVyJDEgKyAnfFxcXFx3K3wnICsgcmdiYSArICd8JyArIGhzbGEgKyAnfCcgKyBoZXgzJDEgKyAnfCcgKyBoZXg2JDE7XG4gICAgICByZXR1cm4gJ14nICsgcHJlZml4ICsgJ1xcXFxzKlxcXFwoKFtcXFxcd1xcXFwuXSspXFxcXHMqXFxcXCxcXFxccyooJyArIG51bWJlciQxICsgJylcXFxccypcXFxcLFxcXFxzKignICsgbnVtYmVyJDEgKyAnKVxcXFxzKixcXFxccyooJyArIG1hcEFyZyArICcpXFxcXHMqXFxcXCxcXFxccyooJyArIG1hcEFyZyArICcpXFxcXCkkJztcbiAgICB9O1xuXG4gICAgdmFyIHVybFJlZ2V4ZXMgPSBbJ151cmxcXFxccypcXFxcKFxcXFxzKltcXCdcIl0/KC4rPylbXFwnXCJdP1xcXFxzKlxcXFwpJCcsICdeKG5vbmUpJCcsICdeKC4rKSQnXTsgLy8gZWFjaCB2aXN1YWwgc3R5bGUgcHJvcGVydHkgaGFzIGEgdHlwZSBhbmQgbmVlZHMgdG8gYmUgdmFsaWRhdGVkIGFjY29yZGluZyB0byBpdFxuXG4gICAgc3R5Zm4kMi50eXBlcyA9IHtcbiAgICAgIHRpbWU6IHtcbiAgICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgICBtaW46IDAsXG4gICAgICAgIHVuaXRzOiAnc3xtcycsXG4gICAgICAgIGltcGxpY2l0VW5pdHM6ICdtcydcbiAgICAgIH0sXG4gICAgICBwZXJjZW50OiB7XG4gICAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgICAgbWluOiAwLFxuICAgICAgICBtYXg6IDEwMCxcbiAgICAgICAgdW5pdHM6ICclJyxcbiAgICAgICAgaW1wbGljaXRVbml0czogJyUnXG4gICAgICB9LFxuICAgICAgcGVyY2VudGFnZXM6IHtcbiAgICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgICBtaW46IDAsXG4gICAgICAgIG1heDogMTAwLFxuICAgICAgICB1bml0czogJyUnLFxuICAgICAgICBpbXBsaWNpdFVuaXRzOiAnJScsXG4gICAgICAgIG11bHRpcGxlOiB0cnVlXG4gICAgICB9LFxuICAgICAgemVyb09uZU51bWJlcjoge1xuICAgICAgICBudW1iZXI6IHRydWUsXG4gICAgICAgIG1pbjogMCxcbiAgICAgICAgbWF4OiAxLFxuICAgICAgICB1bml0bGVzczogdHJ1ZVxuICAgICAgfSxcbiAgICAgIHplcm9PbmVOdW1iZXJzOiB7XG4gICAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgICAgbWluOiAwLFxuICAgICAgICBtYXg6IDEsXG4gICAgICAgIHVuaXRsZXNzOiB0cnVlLFxuICAgICAgICBtdWx0aXBsZTogdHJ1ZVxuICAgICAgfSxcbiAgICAgIG5PbmVPbmVOdW1iZXI6IHtcbiAgICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgICBtaW46IC0xLFxuICAgICAgICBtYXg6IDEsXG4gICAgICAgIHVuaXRsZXNzOiB0cnVlXG4gICAgICB9LFxuICAgICAgbm9uTmVnYXRpdmVJbnQ6IHtcbiAgICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgICBtaW46IDAsXG4gICAgICAgIGludGVnZXI6IHRydWUsXG4gICAgICAgIHVuaXRsZXNzOiB0cnVlXG4gICAgICB9LFxuICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgZW51bXM6IFsncGFyZW50JywgJ29yaWdpbiddXG4gICAgICB9LFxuICAgICAgbm9kZVNpemU6IHtcbiAgICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgICBtaW46IDAsXG4gICAgICAgIGVudW1zOiBbJ2xhYmVsJ11cbiAgICAgIH0sXG4gICAgICBudW1iZXI6IHtcbiAgICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgICB1bml0bGVzczogdHJ1ZVxuICAgICAgfSxcbiAgICAgIG51bWJlcnM6IHtcbiAgICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgICB1bml0bGVzczogdHJ1ZSxcbiAgICAgICAgbXVsdGlwbGU6IHRydWVcbiAgICAgIH0sXG4gICAgICBwb3NpdGl2ZU51bWJlcjoge1xuICAgICAgICBudW1iZXI6IHRydWUsXG4gICAgICAgIHVuaXRsZXNzOiB0cnVlLFxuICAgICAgICBtaW46IDAsXG4gICAgICAgIHN0cmljdE1pbjogdHJ1ZVxuICAgICAgfSxcbiAgICAgIHNpemU6IHtcbiAgICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgICBtaW46IDBcbiAgICAgIH0sXG4gICAgICBiaWRpcmVjdGlvbmFsU2l6ZToge1xuICAgICAgICBudW1iZXI6IHRydWVcbiAgICAgIH0sXG4gICAgICAvLyBhbGxvd3MgbmVnYXRpdmVcbiAgICAgIGJpZGlyZWN0aW9uYWxTaXplTWF5YmVQZXJjZW50OiB7XG4gICAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgICAgYWxsb3dQZXJjZW50OiB0cnVlXG4gICAgICB9LFxuICAgICAgLy8gYWxsb3dzIG5lZ2F0aXZlXG4gICAgICBiaWRpcmVjdGlvbmFsU2l6ZXM6IHtcbiAgICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgICBtdWx0aXBsZTogdHJ1ZVxuICAgICAgfSxcbiAgICAgIC8vIGFsbG93cyBuZWdhdGl2ZVxuICAgICAgc2l6ZU1heWJlUGVyY2VudDoge1xuICAgICAgICBudW1iZXI6IHRydWUsXG4gICAgICAgIG1pbjogMCxcbiAgICAgICAgYWxsb3dQZXJjZW50OiB0cnVlXG4gICAgICB9LFxuICAgICAgYXhpc0RpcmVjdGlvbjoge1xuICAgICAgICBlbnVtczogWydob3Jpem9udGFsJywgJ2xlZnR3YXJkJywgJ3JpZ2h0d2FyZCcsICd2ZXJ0aWNhbCcsICd1cHdhcmQnLCAnZG93bndhcmQnLCAnYXV0byddXG4gICAgICB9LFxuICAgICAgcGFkZGluZ1JlbGF0aXZlVG86IHtcbiAgICAgICAgZW51bXM6IFsnd2lkdGgnLCAnaGVpZ2h0JywgJ2F2ZXJhZ2UnLCAnbWluJywgJ21heCddXG4gICAgICB9LFxuICAgICAgYmdXSDoge1xuICAgICAgICBudW1iZXI6IHRydWUsXG4gICAgICAgIG1pbjogMCxcbiAgICAgICAgYWxsb3dQZXJjZW50OiB0cnVlLFxuICAgICAgICBlbnVtczogWydhdXRvJ10sXG4gICAgICAgIG11bHRpcGxlOiB0cnVlXG4gICAgICB9LFxuICAgICAgYmdQb3M6IHtcbiAgICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgICBhbGxvd1BlcmNlbnQ6IHRydWUsXG4gICAgICAgIG11bHRpcGxlOiB0cnVlXG4gICAgICB9LFxuICAgICAgYmdSZWxhdGl2ZVRvOiB7XG4gICAgICAgIGVudW1zOiBbJ2lubmVyJywgJ2luY2x1ZGUtcGFkZGluZyddLFxuICAgICAgICBtdWx0aXBsZTogdHJ1ZVxuICAgICAgfSxcbiAgICAgIGJnUmVwZWF0OiB7XG4gICAgICAgIGVudW1zOiBbJ3JlcGVhdCcsICdyZXBlYXQteCcsICdyZXBlYXQteScsICduby1yZXBlYXQnXSxcbiAgICAgICAgbXVsdGlwbGU6IHRydWVcbiAgICAgIH0sXG4gICAgICBiZ0ZpdDoge1xuICAgICAgICBlbnVtczogWydub25lJywgJ2NvbnRhaW4nLCAnY292ZXInXSxcbiAgICAgICAgbXVsdGlwbGU6IHRydWVcbiAgICAgIH0sXG4gICAgICBiZ0Nyb3NzT3JpZ2luOiB7XG4gICAgICAgIGVudW1zOiBbJ2Fub255bW91cycsICd1c2UtY3JlZGVudGlhbHMnLCAnbnVsbCddLFxuICAgICAgICBtdWx0aXBsZTogdHJ1ZVxuICAgICAgfSxcbiAgICAgIGJnQ2xpcDoge1xuICAgICAgICBlbnVtczogWydub25lJywgJ25vZGUnXSxcbiAgICAgICAgbXVsdGlwbGU6IHRydWVcbiAgICAgIH0sXG4gICAgICBiZ0NvbnRhaW5tZW50OiB7XG4gICAgICAgIGVudW1zOiBbJ2luc2lkZScsICdvdmVyJ10sXG4gICAgICAgIG11bHRpcGxlOiB0cnVlXG4gICAgICB9LFxuICAgICAgY29sb3I6IHtcbiAgICAgICAgY29sb3I6IHRydWVcbiAgICAgIH0sXG4gICAgICBjb2xvcnM6IHtcbiAgICAgICAgY29sb3I6IHRydWUsXG4gICAgICAgIG11bHRpcGxlOiB0cnVlXG4gICAgICB9LFxuICAgICAgZmlsbDoge1xuICAgICAgICBlbnVtczogWydzb2xpZCcsICdsaW5lYXItZ3JhZGllbnQnLCAncmFkaWFsLWdyYWRpZW50J11cbiAgICAgIH0sXG4gICAgICBib29sOiB7XG4gICAgICAgIGVudW1zOiBbJ3llcycsICdubyddXG4gICAgICB9LFxuICAgICAgYm9vbHM6IHtcbiAgICAgICAgZW51bXM6IFsneWVzJywgJ25vJ10sXG4gICAgICAgIG11bHRpcGxlOiB0cnVlXG4gICAgICB9LFxuICAgICAgbGluZVN0eWxlOiB7XG4gICAgICAgIGVudW1zOiBbJ3NvbGlkJywgJ2RvdHRlZCcsICdkYXNoZWQnXVxuICAgICAgfSxcbiAgICAgIGxpbmVDYXA6IHtcbiAgICAgICAgZW51bXM6IFsnYnV0dCcsICdyb3VuZCcsICdzcXVhcmUnXVxuICAgICAgfSxcbiAgICAgIGJvcmRlclN0eWxlOiB7XG4gICAgICAgIGVudW1zOiBbJ3NvbGlkJywgJ2RvdHRlZCcsICdkYXNoZWQnLCAnZG91YmxlJ11cbiAgICAgIH0sXG4gICAgICBjdXJ2ZVN0eWxlOiB7XG4gICAgICAgIGVudW1zOiBbJ2JlemllcicsICd1bmJ1bmRsZWQtYmV6aWVyJywgJ2hheXN0YWNrJywgJ3NlZ21lbnRzJywgJ3N0cmFpZ2h0JywgJ3N0cmFpZ2h0LXRyaWFuZ2xlJywgJ3RheGknXVxuICAgICAgfSxcbiAgICAgIGZvbnRGYW1pbHk6IHtcbiAgICAgICAgcmVnZXg6ICdeKFtcXFxcdy0gXFxcXFwiXSsoPzpcXFxccyosXFxcXHMqW1xcXFx3LSBcXFxcXCJdKykqKSQnXG4gICAgICB9LFxuICAgICAgZm9udFN0eWxlOiB7XG4gICAgICAgIGVudW1zOiBbJ2l0YWxpYycsICdub3JtYWwnLCAnb2JsaXF1ZSddXG4gICAgICB9LFxuICAgICAgZm9udFdlaWdodDoge1xuICAgICAgICBlbnVtczogWydub3JtYWwnLCAnYm9sZCcsICdib2xkZXInLCAnbGlnaHRlcicsICcxMDAnLCAnMjAwJywgJzMwMCcsICc0MDAnLCAnNTAwJywgJzYwMCcsICc4MDAnLCAnOTAwJywgMTAwLCAyMDAsIDMwMCwgNDAwLCA1MDAsIDYwMCwgNzAwLCA4MDAsIDkwMF1cbiAgICAgIH0sXG4gICAgICB0ZXh0RGVjb3JhdGlvbjoge1xuICAgICAgICBlbnVtczogWydub25lJywgJ3VuZGVybGluZScsICdvdmVybGluZScsICdsaW5lLXRocm91Z2gnXVxuICAgICAgfSxcbiAgICAgIHRleHRUcmFuc2Zvcm06IHtcbiAgICAgICAgZW51bXM6IFsnbm9uZScsICd1cHBlcmNhc2UnLCAnbG93ZXJjYXNlJ11cbiAgICAgIH0sXG4gICAgICB0ZXh0V3JhcDoge1xuICAgICAgICBlbnVtczogWydub25lJywgJ3dyYXAnLCAnZWxsaXBzaXMnXVxuICAgICAgfSxcbiAgICAgIHRleHRPdmVyZmxvd1dyYXA6IHtcbiAgICAgICAgZW51bXM6IFsnd2hpdGVzcGFjZScsICdhbnl3aGVyZSddXG4gICAgICB9LFxuICAgICAgdGV4dEJhY2tncm91bmRTaGFwZToge1xuICAgICAgICBlbnVtczogWydyZWN0YW5nbGUnLCAncm91bmRyZWN0YW5nbGUnLCAncm91bmQtcmVjdGFuZ2xlJ11cbiAgICAgIH0sXG4gICAgICBub2RlU2hhcGU6IHtcbiAgICAgICAgZW51bXM6IFsncmVjdGFuZ2xlJywgJ3JvdW5kcmVjdGFuZ2xlJywgJ3JvdW5kLXJlY3RhbmdsZScsICdjdXRyZWN0YW5nbGUnLCAnY3V0LXJlY3RhbmdsZScsICdib3R0b21yb3VuZHJlY3RhbmdsZScsICdib3R0b20tcm91bmQtcmVjdGFuZ2xlJywgJ2JhcnJlbCcsICdlbGxpcHNlJywgJ3RyaWFuZ2xlJywgJ3JvdW5kLXRyaWFuZ2xlJywgJ3NxdWFyZScsICdwZW50YWdvbicsICdyb3VuZC1wZW50YWdvbicsICdoZXhhZ29uJywgJ3JvdW5kLWhleGFnb24nLCAnY29uY2F2ZWhleGFnb24nLCAnY29uY2F2ZS1oZXhhZ29uJywgJ2hlcHRhZ29uJywgJ3JvdW5kLWhlcHRhZ29uJywgJ29jdGFnb24nLCAncm91bmQtb2N0YWdvbicsICd0YWcnLCAncm91bmQtdGFnJywgJ3N0YXInLCAnZGlhbW9uZCcsICdyb3VuZC1kaWFtb25kJywgJ3ZlZScsICdyaG9tYm9pZCcsICdwb2x5Z29uJ11cbiAgICAgIH0sXG4gICAgICBvdmVybGF5U2hhcGU6IHtcbiAgICAgICAgZW51bXM6IFsncm91bmRyZWN0YW5nbGUnLCAncm91bmQtcmVjdGFuZ2xlJywgJ2VsbGlwc2UnXVxuICAgICAgfSxcbiAgICAgIGNvbXBvdW5kSW5jbHVkZUxhYmVsczoge1xuICAgICAgICBlbnVtczogWydpbmNsdWRlJywgJ2V4Y2x1ZGUnXVxuICAgICAgfSxcbiAgICAgIGFycm93U2hhcGU6IHtcbiAgICAgICAgZW51bXM6IFsndGVlJywgJ3RyaWFuZ2xlJywgJ3RyaWFuZ2xlLXRlZScsICdjaXJjbGUtdHJpYW5nbGUnLCAndHJpYW5nbGUtY3Jvc3MnLCAndHJpYW5nbGUtYmFja2N1cnZlJywgJ3ZlZScsICdzcXVhcmUnLCAnY2lyY2xlJywgJ2RpYW1vbmQnLCAnY2hldnJvbicsICdub25lJ11cbiAgICAgIH0sXG4gICAgICBhcnJvd0ZpbGw6IHtcbiAgICAgICAgZW51bXM6IFsnZmlsbGVkJywgJ2hvbGxvdyddXG4gICAgICB9LFxuICAgICAgZGlzcGxheToge1xuICAgICAgICBlbnVtczogWydlbGVtZW50JywgJ25vbmUnXVxuICAgICAgfSxcbiAgICAgIHZpc2liaWxpdHk6IHtcbiAgICAgICAgZW51bXM6IFsnaGlkZGVuJywgJ3Zpc2libGUnXVxuICAgICAgfSxcbiAgICAgIHpDb21wb3VuZERlcHRoOiB7XG4gICAgICAgIGVudW1zOiBbJ2JvdHRvbScsICdvcnBoYW4nLCAnYXV0bycsICd0b3AnXVxuICAgICAgfSxcbiAgICAgIHpJbmRleENvbXBhcmU6IHtcbiAgICAgICAgZW51bXM6IFsnYXV0bycsICdtYW51YWwnXVxuICAgICAgfSxcbiAgICAgIHZhbGlnbjoge1xuICAgICAgICBlbnVtczogWyd0b3AnLCAnY2VudGVyJywgJ2JvdHRvbSddXG4gICAgICB9LFxuICAgICAgaGFsaWduOiB7XG4gICAgICAgIGVudW1zOiBbJ2xlZnQnLCAnY2VudGVyJywgJ3JpZ2h0J11cbiAgICAgIH0sXG4gICAgICBqdXN0aWZpY2F0aW9uOiB7XG4gICAgICAgIGVudW1zOiBbJ2xlZnQnLCAnY2VudGVyJywgJ3JpZ2h0JywgJ2F1dG8nXVxuICAgICAgfSxcbiAgICAgIHRleHQ6IHtcbiAgICAgICAgc3RyaW5nOiB0cnVlXG4gICAgICB9LFxuICAgICAgZGF0YToge1xuICAgICAgICBtYXBwaW5nOiB0cnVlLFxuICAgICAgICByZWdleDogZGF0YSgnZGF0YScpXG4gICAgICB9LFxuICAgICAgbGF5b3V0RGF0YToge1xuICAgICAgICBtYXBwaW5nOiB0cnVlLFxuICAgICAgICByZWdleDogZGF0YSgnbGF5b3V0RGF0YScpXG4gICAgICB9LFxuICAgICAgc2NyYXRjaDoge1xuICAgICAgICBtYXBwaW5nOiB0cnVlLFxuICAgICAgICByZWdleDogZGF0YSgnc2NyYXRjaCcpXG4gICAgICB9LFxuICAgICAgbWFwRGF0YToge1xuICAgICAgICBtYXBwaW5nOiB0cnVlLFxuICAgICAgICByZWdleDogbWFwRGF0YSgnbWFwRGF0YScpXG4gICAgICB9LFxuICAgICAgbWFwTGF5b3V0RGF0YToge1xuICAgICAgICBtYXBwaW5nOiB0cnVlLFxuICAgICAgICByZWdleDogbWFwRGF0YSgnbWFwTGF5b3V0RGF0YScpXG4gICAgICB9LFxuICAgICAgbWFwU2NyYXRjaDoge1xuICAgICAgICBtYXBwaW5nOiB0cnVlLFxuICAgICAgICByZWdleDogbWFwRGF0YSgnbWFwU2NyYXRjaCcpXG4gICAgICB9LFxuICAgICAgZm46IHtcbiAgICAgICAgbWFwcGluZzogdHJ1ZSxcbiAgICAgICAgZm46IHRydWVcbiAgICAgIH0sXG4gICAgICB1cmw6IHtcbiAgICAgICAgcmVnZXhlczogdXJsUmVnZXhlcyxcbiAgICAgICAgc2luZ2xlUmVnZXhNYXRjaFZhbHVlOiB0cnVlXG4gICAgICB9LFxuICAgICAgdXJsczoge1xuICAgICAgICByZWdleGVzOiB1cmxSZWdleGVzLFxuICAgICAgICBzaW5nbGVSZWdleE1hdGNoVmFsdWU6IHRydWUsXG4gICAgICAgIG11bHRpcGxlOiB0cnVlXG4gICAgICB9LFxuICAgICAgcHJvcExpc3Q6IHtcbiAgICAgICAgcHJvcExpc3Q6IHRydWVcbiAgICAgIH0sXG4gICAgICBhbmdsZToge1xuICAgICAgICBudW1iZXI6IHRydWUsXG4gICAgICAgIHVuaXRzOiAnZGVnfHJhZCcsXG4gICAgICAgIGltcGxpY2l0VW5pdHM6ICdyYWQnXG4gICAgICB9LFxuICAgICAgdGV4dFJvdGF0aW9uOiB7XG4gICAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgICAgdW5pdHM6ICdkZWd8cmFkJyxcbiAgICAgICAgaW1wbGljaXRVbml0czogJ3JhZCcsXG4gICAgICAgIGVudW1zOiBbJ25vbmUnLCAnYXV0b3JvdGF0ZSddXG4gICAgICB9LFxuICAgICAgcG9seWdvblBvaW50TGlzdDoge1xuICAgICAgICBudW1iZXI6IHRydWUsXG4gICAgICAgIG11bHRpcGxlOiB0cnVlLFxuICAgICAgICBldmVuTXVsdGlwbGU6IHRydWUsXG4gICAgICAgIG1pbjogLTEsXG4gICAgICAgIG1heDogMSxcbiAgICAgICAgdW5pdGxlc3M6IHRydWVcbiAgICAgIH0sXG4gICAgICBlZGdlRGlzdGFuY2VzOiB7XG4gICAgICAgIGVudW1zOiBbJ2ludGVyc2VjdGlvbicsICdub2RlLXBvc2l0aW9uJ11cbiAgICAgIH0sXG4gICAgICBlZGdlRW5kcG9pbnQ6IHtcbiAgICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgICBtdWx0aXBsZTogdHJ1ZSxcbiAgICAgICAgdW5pdHM6ICclfHB4fGVtfGRlZ3xyYWQnLFxuICAgICAgICBpbXBsaWNpdFVuaXRzOiAncHgnLFxuICAgICAgICBlbnVtczogWydpbnNpZGUtdG8tbm9kZScsICdvdXRzaWRlLXRvLW5vZGUnLCAnb3V0c2lkZS10by1ub2RlLW9yLWxhYmVsJywgJ291dHNpZGUtdG8tbGluZScsICdvdXRzaWRlLXRvLWxpbmUtb3ItbGFiZWwnXSxcbiAgICAgICAgc2luZ2xlRW51bTogdHJ1ZSxcbiAgICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uIHZhbGlkYXRlKHZhbEFyciwgdW5pdHNBcnIpIHtcbiAgICAgICAgICBzd2l0Y2ggKHZhbEFyci5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgLy8gY2FuIGJlICUgb3IgcHggb25seVxuICAgICAgICAgICAgICByZXR1cm4gdW5pdHNBcnJbMF0gIT09ICdkZWcnICYmIHVuaXRzQXJyWzBdICE9PSAncmFkJyAmJiB1bml0c0FyclsxXSAhPT0gJ2RlZycgJiYgdW5pdHNBcnJbMV0gIT09ICdyYWQnO1xuXG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIC8vIGNhbiBiZSBlbnVtLCBkZWcsIG9yIHJhZCBvbmx5XG4gICAgICAgICAgICAgIHJldHVybiBzdHJpbmcodmFsQXJyWzBdKSB8fCB1bml0c0FyclswXSA9PT0gJ2RlZycgfHwgdW5pdHNBcnJbMF0gPT09ICdyYWQnO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZWFzaW5nOiB7XG4gICAgICAgIHJlZ2V4ZXM6IFsnXihzcHJpbmcpXFxcXHMqXFxcXChcXFxccyooJyArIG51bWJlciQxICsgJylcXFxccyosXFxcXHMqKCcgKyBudW1iZXIkMSArICcpXFxcXHMqXFxcXCkkJywgJ14oY3ViaWMtYmV6aWVyKVxcXFxzKlxcXFwoXFxcXHMqKCcgKyBudW1iZXIkMSArICcpXFxcXHMqLFxcXFxzKignICsgbnVtYmVyJDEgKyAnKVxcXFxzKixcXFxccyooJyArIG51bWJlciQxICsgJylcXFxccyosXFxcXHMqKCcgKyBudW1iZXIkMSArICcpXFxcXHMqXFxcXCkkJ10sXG4gICAgICAgIGVudW1zOiBbJ2xpbmVhcicsICdlYXNlJywgJ2Vhc2UtaW4nLCAnZWFzZS1vdXQnLCAnZWFzZS1pbi1vdXQnLCAnZWFzZS1pbi1zaW5lJywgJ2Vhc2Utb3V0LXNpbmUnLCAnZWFzZS1pbi1vdXQtc2luZScsICdlYXNlLWluLXF1YWQnLCAnZWFzZS1vdXQtcXVhZCcsICdlYXNlLWluLW91dC1xdWFkJywgJ2Vhc2UtaW4tY3ViaWMnLCAnZWFzZS1vdXQtY3ViaWMnLCAnZWFzZS1pbi1vdXQtY3ViaWMnLCAnZWFzZS1pbi1xdWFydCcsICdlYXNlLW91dC1xdWFydCcsICdlYXNlLWluLW91dC1xdWFydCcsICdlYXNlLWluLXF1aW50JywgJ2Vhc2Utb3V0LXF1aW50JywgJ2Vhc2UtaW4tb3V0LXF1aW50JywgJ2Vhc2UtaW4tZXhwbycsICdlYXNlLW91dC1leHBvJywgJ2Vhc2UtaW4tb3V0LWV4cG8nLCAnZWFzZS1pbi1jaXJjJywgJ2Vhc2Utb3V0LWNpcmMnLCAnZWFzZS1pbi1vdXQtY2lyYyddXG4gICAgICB9LFxuICAgICAgZ3JhZGllbnREaXJlY3Rpb246IHtcbiAgICAgICAgZW51bXM6IFsndG8tYm90dG9tJywgJ3RvLXRvcCcsICd0by1sZWZ0JywgJ3RvLXJpZ2h0JywgJ3RvLWJvdHRvbS1yaWdodCcsICd0by1ib3R0b20tbGVmdCcsICd0by10b3AtcmlnaHQnLCAndG8tdG9wLWxlZnQnLCAndG8tcmlnaHQtYm90dG9tJywgJ3RvLWxlZnQtYm90dG9tJywgJ3RvLXJpZ2h0LXRvcCcsICd0by1sZWZ0LXRvcCcgLy8gZGlmZmVyZW50IG9yZGVyXG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICBib3VuZHNFeHBhbnNpb246IHtcbiAgICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgICBtdWx0aXBsZTogdHJ1ZSxcbiAgICAgICAgbWluOiAwLFxuICAgICAgICB2YWxpZGF0ZTogZnVuY3Rpb24gdmFsaWRhdGUodmFsQXJyKSB7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IHZhbEFyci5sZW5ndGg7XG4gICAgICAgICAgcmV0dXJuIGxlbmd0aCA9PT0gMSB8fCBsZW5ndGggPT09IDIgfHwgbGVuZ3RoID09PSA0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgZGlmZiA9IHtcbiAgICAgIHplcm9Ob25aZXJvOiBmdW5jdGlvbiB6ZXJvTm9uWmVybyh2YWwxLCB2YWwyKSB7XG4gICAgICAgIGlmICgodmFsMSA9PSBudWxsIHx8IHZhbDIgPT0gbnVsbCkgJiYgdmFsMSAhPT0gdmFsMikge1xuICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBudWxsIGNhc2VzIGNvdWxkIHJlcHJlc2VudCBhbnkgdmFsdWVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWwxID09IDAgJiYgdmFsMiAhPSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsMSAhPSAwICYmIHZhbDIgPT0gMCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGFueTogZnVuY3Rpb24gYW55KHZhbDEsIHZhbDIpIHtcbiAgICAgICAgcmV0dXJuIHZhbDEgIT0gdmFsMjtcbiAgICAgIH0sXG4gICAgICBlbXB0eU5vbkVtcHR5OiBmdW5jdGlvbiBlbXB0eU5vbkVtcHR5KHN0cjEsIHN0cjIpIHtcbiAgICAgICAgdmFyIGVtcHR5MSA9IGVtcHR5U3RyaW5nKHN0cjEpO1xuICAgICAgICB2YXIgZW1wdHkyID0gZW1wdHlTdHJpbmcoc3RyMik7XG4gICAgICAgIHJldHVybiBlbXB0eTEgJiYgIWVtcHR5MiB8fCAhZW1wdHkxICYmIGVtcHR5MjtcbiAgICAgIH1cbiAgICB9OyAvLyBkZWZpbmUgdmlzdWFsIHN0eWxlIHByb3BlcnRpZXNcbiAgICAvL1xuICAgIC8vIC0gbi5iLiBhZGRpbmcgYSBuZXcgZ3JvdXAgb2YgcHJvcHMgbWF5IHJlcXVpcmUgdXBkYXRlcyB0byB1cGRhdGVTdHlsZUhpbnRzKClcbiAgICAvLyAtIGFkZGluZyBuZXcgcHJvcHMgdG8gYW4gZXhpc3RpbmcgZ3JvdXAgZ2V0cyBoYW5kbGVkIGF1dG9tYXRpY2FsbHlcblxuICAgIHZhciB0ID0gc3R5Zm4kMi50eXBlcztcbiAgICB2YXIgbWFpbkxhYmVsID0gW3tcbiAgICAgIG5hbWU6ICdsYWJlbCcsXG4gICAgICB0eXBlOiB0LnRleHQsXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnksXG4gICAgICB0cmlnZ2Vyc1pPcmRlcjogZGlmZi5lbXB0eU5vbkVtcHR5XG4gICAgfSwge1xuICAgICAgbmFtZTogJ3RleHQtcm90YXRpb24nLFxuICAgICAgdHlwZTogdC50ZXh0Um90YXRpb24sXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAndGV4dC1tYXJnaW4teCcsXG4gICAgICB0eXBlOiB0LmJpZGlyZWN0aW9uYWxTaXplLFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfSwge1xuICAgICAgbmFtZTogJ3RleHQtbWFyZ2luLXknLFxuICAgICAgdHlwZTogdC5iaWRpcmVjdGlvbmFsU2l6ZSxcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH1dO1xuICAgIHZhciBzb3VyY2VMYWJlbCA9IFt7XG4gICAgICBuYW1lOiAnc291cmNlLWxhYmVsJyxcbiAgICAgIHR5cGU6IHQudGV4dCxcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdzb3VyY2UtdGV4dC1yb3RhdGlvbicsXG4gICAgICB0eXBlOiB0LnRleHRSb3RhdGlvbixcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdzb3VyY2UtdGV4dC1tYXJnaW4teCcsXG4gICAgICB0eXBlOiB0LmJpZGlyZWN0aW9uYWxTaXplLFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfSwge1xuICAgICAgbmFtZTogJ3NvdXJjZS10ZXh0LW1hcmdpbi15JyxcbiAgICAgIHR5cGU6IHQuYmlkaXJlY3Rpb25hbFNpemUsXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnc291cmNlLXRleHQtb2Zmc2V0JyxcbiAgICAgIHR5cGU6IHQuc2l6ZSxcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH1dO1xuICAgIHZhciB0YXJnZXRMYWJlbCA9IFt7XG4gICAgICBuYW1lOiAndGFyZ2V0LWxhYmVsJyxcbiAgICAgIHR5cGU6IHQudGV4dCxcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICd0YXJnZXQtdGV4dC1yb3RhdGlvbicsXG4gICAgICB0eXBlOiB0LnRleHRSb3RhdGlvbixcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICd0YXJnZXQtdGV4dC1tYXJnaW4teCcsXG4gICAgICB0eXBlOiB0LmJpZGlyZWN0aW9uYWxTaXplLFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfSwge1xuICAgICAgbmFtZTogJ3RhcmdldC10ZXh0LW1hcmdpbi15JyxcbiAgICAgIHR5cGU6IHQuYmlkaXJlY3Rpb25hbFNpemUsXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAndGFyZ2V0LXRleHQtb2Zmc2V0JyxcbiAgICAgIHR5cGU6IHQuc2l6ZSxcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH1dO1xuICAgIHZhciBsYWJlbERpbWVuc2lvbnMgPSBbe1xuICAgICAgbmFtZTogJ2ZvbnQtZmFtaWx5JyxcbiAgICAgIHR5cGU6IHQuZm9udEZhbWlseSxcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdmb250LXN0eWxlJyxcbiAgICAgIHR5cGU6IHQuZm9udFN0eWxlLFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfSwge1xuICAgICAgbmFtZTogJ2ZvbnQtd2VpZ2h0JyxcbiAgICAgIHR5cGU6IHQuZm9udFdlaWdodCxcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdmb250LXNpemUnLFxuICAgICAgdHlwZTogdC5zaXplLFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfSwge1xuICAgICAgbmFtZTogJ3RleHQtdHJhbnNmb3JtJyxcbiAgICAgIHR5cGU6IHQudGV4dFRyYW5zZm9ybSxcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICd0ZXh0LXdyYXAnLFxuICAgICAgdHlwZTogdC50ZXh0V3JhcCxcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICd0ZXh0LW92ZXJmbG93LXdyYXAnLFxuICAgICAgdHlwZTogdC50ZXh0T3ZlcmZsb3dXcmFwLFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfSwge1xuICAgICAgbmFtZTogJ3RleHQtbWF4LXdpZHRoJyxcbiAgICAgIHR5cGU6IHQuc2l6ZSxcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICd0ZXh0LW91dGxpbmUtd2lkdGgnLFxuICAgICAgdHlwZTogdC5zaXplLFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfSwge1xuICAgICAgbmFtZTogJ2xpbmUtaGVpZ2h0JyxcbiAgICAgIHR5cGU6IHQucG9zaXRpdmVOdW1iZXIsXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9XTtcbiAgICB2YXIgY29tbW9uTGFiZWwgPSBbe1xuICAgICAgbmFtZTogJ3RleHQtdmFsaWduJyxcbiAgICAgIHR5cGU6IHQudmFsaWduLFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfSwge1xuICAgICAgbmFtZTogJ3RleHQtaGFsaWduJyxcbiAgICAgIHR5cGU6IHQuaGFsaWduLFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfSwge1xuICAgICAgbmFtZTogJ2NvbG9yJyxcbiAgICAgIHR5cGU6IHQuY29sb3JcbiAgICB9LCB7XG4gICAgICBuYW1lOiAndGV4dC1vdXRsaW5lLWNvbG9yJyxcbiAgICAgIHR5cGU6IHQuY29sb3JcbiAgICB9LCB7XG4gICAgICBuYW1lOiAndGV4dC1vdXRsaW5lLW9wYWNpdHknLFxuICAgICAgdHlwZTogdC56ZXJvT25lTnVtYmVyXG4gICAgfSwge1xuICAgICAgbmFtZTogJ3RleHQtYmFja2dyb3VuZC1jb2xvcicsXG4gICAgICB0eXBlOiB0LmNvbG9yXG4gICAgfSwge1xuICAgICAgbmFtZTogJ3RleHQtYmFja2dyb3VuZC1vcGFjaXR5JyxcbiAgICAgIHR5cGU6IHQuemVyb09uZU51bWJlclxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICd0ZXh0LWJhY2tncm91bmQtcGFkZGluZycsXG4gICAgICB0eXBlOiB0LnNpemUsXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAndGV4dC1ib3JkZXItb3BhY2l0eScsXG4gICAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXJcbiAgICB9LCB7XG4gICAgICBuYW1lOiAndGV4dC1ib3JkZXItY29sb3InLFxuICAgICAgdHlwZTogdC5jb2xvclxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICd0ZXh0LWJvcmRlci13aWR0aCcsXG4gICAgICB0eXBlOiB0LnNpemUsXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAndGV4dC1ib3JkZXItc3R5bGUnLFxuICAgICAgdHlwZTogdC5ib3JkZXJTdHlsZSxcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICd0ZXh0LWJhY2tncm91bmQtc2hhcGUnLFxuICAgICAgdHlwZTogdC50ZXh0QmFja2dyb3VuZFNoYXBlLFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfSwge1xuICAgICAgbmFtZTogJ3RleHQtanVzdGlmaWNhdGlvbicsXG4gICAgICB0eXBlOiB0Lmp1c3RpZmljYXRpb25cbiAgICB9XTtcbiAgICB2YXIgYmVoYXZpb3IgPSBbe1xuICAgICAgbmFtZTogJ2V2ZW50cycsXG4gICAgICB0eXBlOiB0LmJvb2xcbiAgICB9LCB7XG4gICAgICBuYW1lOiAndGV4dC1ldmVudHMnLFxuICAgICAgdHlwZTogdC5ib29sXG4gICAgfV07XG4gICAgdmFyIHZpc2liaWxpdHkgPSBbe1xuICAgICAgbmFtZTogJ2Rpc3BsYXknLFxuICAgICAgdHlwZTogdC5kaXNwbGF5LFxuICAgICAgdHJpZ2dlcnNaT3JkZXI6IGRpZmYuYW55LFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55LFxuICAgICAgdHJpZ2dlcnNCb3VuZHNPZlBhcmFsbGVsQmV6aWVyczogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICd2aXNpYmlsaXR5JyxcbiAgICAgIHR5cGU6IHQudmlzaWJpbGl0eSxcbiAgICAgIHRyaWdnZXJzWk9yZGVyOiBkaWZmLmFueVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdvcGFjaXR5JyxcbiAgICAgIHR5cGU6IHQuemVyb09uZU51bWJlcixcbiAgICAgIHRyaWdnZXJzWk9yZGVyOiBkaWZmLnplcm9Ob25aZXJvXG4gICAgfSwge1xuICAgICAgbmFtZTogJ3RleHQtb3BhY2l0eScsXG4gICAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXJcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnbWluLXpvb21lZC1mb250LXNpemUnLFxuICAgICAgdHlwZTogdC5zaXplXG4gICAgfSwge1xuICAgICAgbmFtZTogJ3otY29tcG91bmQtZGVwdGgnLFxuICAgICAgdHlwZTogdC56Q29tcG91bmREZXB0aCxcbiAgICAgIHRyaWdnZXJzWk9yZGVyOiBkaWZmLmFueVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICd6LWluZGV4LWNvbXBhcmUnLFxuICAgICAgdHlwZTogdC56SW5kZXhDb21wYXJlLFxuICAgICAgdHJpZ2dlcnNaT3JkZXI6IGRpZmYuYW55XG4gICAgfSwge1xuICAgICAgbmFtZTogJ3otaW5kZXgnLFxuICAgICAgdHlwZTogdC5ub25OZWdhdGl2ZUludCxcbiAgICAgIHRyaWdnZXJzWk9yZGVyOiBkaWZmLmFueVxuICAgIH1dO1xuICAgIHZhciBvdmVybGF5ID0gW3tcbiAgICAgIG5hbWU6ICdvdmVybGF5LXBhZGRpbmcnLFxuICAgICAgdHlwZTogdC5zaXplLFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfSwge1xuICAgICAgbmFtZTogJ292ZXJsYXktY29sb3InLFxuICAgICAgdHlwZTogdC5jb2xvclxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdvdmVybGF5LW9wYWNpdHknLFxuICAgICAgdHlwZTogdC56ZXJvT25lTnVtYmVyLFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuemVyb05vblplcm9cbiAgICB9LCB7XG4gICAgICBuYW1lOiAnb3ZlcmxheS1zaGFwZScsXG4gICAgICB0eXBlOiB0Lm92ZXJsYXlTaGFwZSxcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH1dO1xuICAgIHZhciB1bmRlcmxheSA9IFt7XG4gICAgICBuYW1lOiAndW5kZXJsYXktcGFkZGluZycsXG4gICAgICB0eXBlOiB0LnNpemUsXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAndW5kZXJsYXktY29sb3InLFxuICAgICAgdHlwZTogdC5jb2xvclxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICd1bmRlcmxheS1vcGFjaXR5JyxcbiAgICAgIHR5cGU6IHQuemVyb09uZU51bWJlcixcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLnplcm9Ob25aZXJvXG4gICAgfSwge1xuICAgICAgbmFtZTogJ3VuZGVybGF5LXNoYXBlJyxcbiAgICAgIHR5cGU6IHQub3ZlcmxheVNoYXBlLFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfV07XG4gICAgdmFyIHRyYW5zaXRpb24gPSBbe1xuICAgICAgbmFtZTogJ3RyYW5zaXRpb24tcHJvcGVydHknLFxuICAgICAgdHlwZTogdC5wcm9wTGlzdFxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICd0cmFuc2l0aW9uLWR1cmF0aW9uJyxcbiAgICAgIHR5cGU6IHQudGltZVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICd0cmFuc2l0aW9uLWRlbGF5JyxcbiAgICAgIHR5cGU6IHQudGltZVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICd0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbicsXG4gICAgICB0eXBlOiB0LmVhc2luZ1xuICAgIH1dO1xuXG4gICAgdmFyIG5vZGVTaXplSGFzaE92ZXJyaWRlID0gZnVuY3Rpb24gbm9kZVNpemVIYXNoT3ZlcnJpZGUoZWxlLCBwYXJzZWRQcm9wKSB7XG4gICAgICBpZiAocGFyc2VkUHJvcC52YWx1ZSA9PT0gJ2xhYmVsJykge1xuICAgICAgICByZXR1cm4gLWVsZS5wb29sSW5kZXgoKTsgLy8gbm8gaGFzaCBrZXkgaGl0cyBpcyB1c2luZyBsYWJlbCBzaXplIChoaXRyYXRlIGZvciBwZXJmIHByb2JhYmx5IGxvdyBhbnl3YXkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcGFyc2VkUHJvcC5wZlZhbHVlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgbm9kZUJvZHkgPSBbe1xuICAgICAgbmFtZTogJ2hlaWdodCcsXG4gICAgICB0eXBlOiB0Lm5vZGVTaXplLFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55LFxuICAgICAgaGFzaE92ZXJyaWRlOiBub2RlU2l6ZUhhc2hPdmVycmlkZVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICd3aWR0aCcsXG4gICAgICB0eXBlOiB0Lm5vZGVTaXplLFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55LFxuICAgICAgaGFzaE92ZXJyaWRlOiBub2RlU2l6ZUhhc2hPdmVycmlkZVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdzaGFwZScsXG4gICAgICB0eXBlOiB0Lm5vZGVTaGFwZSxcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdzaGFwZS1wb2x5Z29uLXBvaW50cycsXG4gICAgICB0eXBlOiB0LnBvbHlnb25Qb2ludExpc3QsXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnYmFja2dyb3VuZC1jb2xvcicsXG4gICAgICB0eXBlOiB0LmNvbG9yXG4gICAgfSwge1xuICAgICAgbmFtZTogJ2JhY2tncm91bmQtZmlsbCcsXG4gICAgICB0eXBlOiB0LmZpbGxcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnYmFja2dyb3VuZC1vcGFjaXR5JyxcbiAgICAgIHR5cGU6IHQuemVyb09uZU51bWJlclxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdiYWNrZ3JvdW5kLWJsYWNrZW4nLFxuICAgICAgdHlwZTogdC5uT25lT25lTnVtYmVyXG4gICAgfSwge1xuICAgICAgbmFtZTogJ2JhY2tncm91bmQtZ3JhZGllbnQtc3RvcC1jb2xvcnMnLFxuICAgICAgdHlwZTogdC5jb2xvcnNcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnYmFja2dyb3VuZC1ncmFkaWVudC1zdG9wLXBvc2l0aW9ucycsXG4gICAgICB0eXBlOiB0LnBlcmNlbnRhZ2VzXG4gICAgfSwge1xuICAgICAgbmFtZTogJ2JhY2tncm91bmQtZ3JhZGllbnQtZGlyZWN0aW9uJyxcbiAgICAgIHR5cGU6IHQuZ3JhZGllbnREaXJlY3Rpb25cbiAgICB9LCB7XG4gICAgICBuYW1lOiAncGFkZGluZycsXG4gICAgICB0eXBlOiB0LnNpemVNYXliZVBlcmNlbnQsXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAncGFkZGluZy1yZWxhdGl2ZS10bycsXG4gICAgICB0eXBlOiB0LnBhZGRpbmdSZWxhdGl2ZVRvLFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfSwge1xuICAgICAgbmFtZTogJ2JvdW5kcy1leHBhbnNpb24nLFxuICAgICAgdHlwZTogdC5ib3VuZHNFeHBhbnNpb24sXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9XTtcbiAgICB2YXIgbm9kZUJvcmRlciA9IFt7XG4gICAgICBuYW1lOiAnYm9yZGVyLWNvbG9yJyxcbiAgICAgIHR5cGU6IHQuY29sb3JcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnYm9yZGVyLW9wYWNpdHknLFxuICAgICAgdHlwZTogdC56ZXJvT25lTnVtYmVyXG4gICAgfSwge1xuICAgICAgbmFtZTogJ2JvcmRlci13aWR0aCcsXG4gICAgICB0eXBlOiB0LnNpemUsXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnYm9yZGVyLXN0eWxlJyxcbiAgICAgIHR5cGU6IHQuYm9yZGVyU3R5bGVcbiAgICB9XTtcbiAgICB2YXIgYmFja2dyb3VuZEltYWdlID0gW3tcbiAgICAgIG5hbWU6ICdiYWNrZ3JvdW5kLWltYWdlJyxcbiAgICAgIHR5cGU6IHQudXJsc1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdiYWNrZ3JvdW5kLWltYWdlLWNyb3Nzb3JpZ2luJyxcbiAgICAgIHR5cGU6IHQuYmdDcm9zc09yaWdpblxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdiYWNrZ3JvdW5kLWltYWdlLW9wYWNpdHknLFxuICAgICAgdHlwZTogdC56ZXJvT25lTnVtYmVyc1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdiYWNrZ3JvdW5kLWltYWdlLWNvbnRhaW5tZW50JyxcbiAgICAgIHR5cGU6IHQuYmdDb250YWlubWVudFxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdiYWNrZ3JvdW5kLWltYWdlLXNtb290aGluZycsXG4gICAgICB0eXBlOiB0LmJvb2xzXG4gICAgfSwge1xuICAgICAgbmFtZTogJ2JhY2tncm91bmQtcG9zaXRpb24teCcsXG4gICAgICB0eXBlOiB0LmJnUG9zXG4gICAgfSwge1xuICAgICAgbmFtZTogJ2JhY2tncm91bmQtcG9zaXRpb24teScsXG4gICAgICB0eXBlOiB0LmJnUG9zXG4gICAgfSwge1xuICAgICAgbmFtZTogJ2JhY2tncm91bmQtd2lkdGgtcmVsYXRpdmUtdG8nLFxuICAgICAgdHlwZTogdC5iZ1JlbGF0aXZlVG9cbiAgICB9LCB7XG4gICAgICBuYW1lOiAnYmFja2dyb3VuZC1oZWlnaHQtcmVsYXRpdmUtdG8nLFxuICAgICAgdHlwZTogdC5iZ1JlbGF0aXZlVG9cbiAgICB9LCB7XG4gICAgICBuYW1lOiAnYmFja2dyb3VuZC1yZXBlYXQnLFxuICAgICAgdHlwZTogdC5iZ1JlcGVhdFxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdiYWNrZ3JvdW5kLWZpdCcsXG4gICAgICB0eXBlOiB0LmJnRml0XG4gICAgfSwge1xuICAgICAgbmFtZTogJ2JhY2tncm91bmQtY2xpcCcsXG4gICAgICB0eXBlOiB0LmJnQ2xpcFxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdiYWNrZ3JvdW5kLXdpZHRoJyxcbiAgICAgIHR5cGU6IHQuYmdXSFxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdiYWNrZ3JvdW5kLWhlaWdodCcsXG4gICAgICB0eXBlOiB0LmJnV0hcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnYmFja2dyb3VuZC1vZmZzZXQteCcsXG4gICAgICB0eXBlOiB0LmJnUG9zXG4gICAgfSwge1xuICAgICAgbmFtZTogJ2JhY2tncm91bmQtb2Zmc2V0LXknLFxuICAgICAgdHlwZTogdC5iZ1Bvc1xuICAgIH1dO1xuICAgIHZhciBjb21wb3VuZCA9IFt7XG4gICAgICBuYW1lOiAncG9zaXRpb24nLFxuICAgICAgdHlwZTogdC5wb3NpdGlvbixcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdjb21wb3VuZC1zaXppbmctd3J0LWxhYmVscycsXG4gICAgICB0eXBlOiB0LmNvbXBvdW5kSW5jbHVkZUxhYmVscyxcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdtaW4td2lkdGgnLFxuICAgICAgdHlwZTogdC5zaXplLFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfSwge1xuICAgICAgbmFtZTogJ21pbi13aWR0aC1iaWFzLWxlZnQnLFxuICAgICAgdHlwZTogdC5zaXplTWF5YmVQZXJjZW50LFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfSwge1xuICAgICAgbmFtZTogJ21pbi13aWR0aC1iaWFzLXJpZ2h0JyxcbiAgICAgIHR5cGU6IHQuc2l6ZU1heWJlUGVyY2VudCxcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdtaW4taGVpZ2h0JyxcbiAgICAgIHR5cGU6IHQuc2l6ZSxcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdtaW4taGVpZ2h0LWJpYXMtdG9wJyxcbiAgICAgIHR5cGU6IHQuc2l6ZU1heWJlUGVyY2VudCxcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdtaW4taGVpZ2h0LWJpYXMtYm90dG9tJyxcbiAgICAgIHR5cGU6IHQuc2l6ZU1heWJlUGVyY2VudCxcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH1dO1xuICAgIHZhciBlZGdlTGluZSA9IFt7XG4gICAgICBuYW1lOiAnbGluZS1zdHlsZScsXG4gICAgICB0eXBlOiB0LmxpbmVTdHlsZVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdsaW5lLWNvbG9yJyxcbiAgICAgIHR5cGU6IHQuY29sb3JcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnbGluZS1maWxsJyxcbiAgICAgIHR5cGU6IHQuZmlsbFxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdsaW5lLWNhcCcsXG4gICAgICB0eXBlOiB0LmxpbmVDYXBcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnbGluZS1vcGFjaXR5JyxcbiAgICAgIHR5cGU6IHQuemVyb09uZU51bWJlclxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdsaW5lLWRhc2gtcGF0dGVybicsXG4gICAgICB0eXBlOiB0Lm51bWJlcnNcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnbGluZS1kYXNoLW9mZnNldCcsXG4gICAgICB0eXBlOiB0Lm51bWJlclxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdsaW5lLWdyYWRpZW50LXN0b3AtY29sb3JzJyxcbiAgICAgIHR5cGU6IHQuY29sb3JzXG4gICAgfSwge1xuICAgICAgbmFtZTogJ2xpbmUtZ3JhZGllbnQtc3RvcC1wb3NpdGlvbnMnLFxuICAgICAgdHlwZTogdC5wZXJjZW50YWdlc1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdjdXJ2ZS1zdHlsZScsXG4gICAgICB0eXBlOiB0LmN1cnZlU3R5bGUsXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnksXG4gICAgICB0cmlnZ2Vyc0JvdW5kc09mUGFyYWxsZWxCZXppZXJzOiB0cnVlXG4gICAgfSwge1xuICAgICAgbmFtZTogJ2hheXN0YWNrLXJhZGl1cycsXG4gICAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXIsXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnc291cmNlLWVuZHBvaW50JyxcbiAgICAgIHR5cGU6IHQuZWRnZUVuZHBvaW50LFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfSwge1xuICAgICAgbmFtZTogJ3RhcmdldC1lbmRwb2ludCcsXG4gICAgICB0eXBlOiB0LmVkZ2VFbmRwb2ludCxcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdjb250cm9sLXBvaW50LXN0ZXAtc2l6ZScsXG4gICAgICB0eXBlOiB0LnNpemUsXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnY29udHJvbC1wb2ludC1kaXN0YW5jZXMnLFxuICAgICAgdHlwZTogdC5iaWRpcmVjdGlvbmFsU2l6ZXMsXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnY29udHJvbC1wb2ludC13ZWlnaHRzJyxcbiAgICAgIHR5cGU6IHQubnVtYmVycyxcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdzZWdtZW50LWRpc3RhbmNlcycsXG4gICAgICB0eXBlOiB0LmJpZGlyZWN0aW9uYWxTaXplcyxcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdzZWdtZW50LXdlaWdodHMnLFxuICAgICAgdHlwZTogdC5udW1iZXJzLFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfSwge1xuICAgICAgbmFtZTogJ3RheGktdHVybicsXG4gICAgICB0eXBlOiB0LmJpZGlyZWN0aW9uYWxTaXplTWF5YmVQZXJjZW50LFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfSwge1xuICAgICAgbmFtZTogJ3RheGktdHVybi1taW4tZGlzdGFuY2UnLFxuICAgICAgdHlwZTogdC5zaXplLFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfSwge1xuICAgICAgbmFtZTogJ3RheGktZGlyZWN0aW9uJyxcbiAgICAgIHR5cGU6IHQuYXhpc0RpcmVjdGlvbixcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdlZGdlLWRpc3RhbmNlcycsXG4gICAgICB0eXBlOiB0LmVkZ2VEaXN0YW5jZXMsXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnYXJyb3ctc2NhbGUnLFxuICAgICAgdHlwZTogdC5wb3NpdGl2ZU51bWJlcixcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdsb29wLWRpcmVjdGlvbicsXG4gICAgICB0eXBlOiB0LmFuZ2xlLFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfSwge1xuICAgICAgbmFtZTogJ2xvb3Atc3dlZXAnLFxuICAgICAgdHlwZTogdC5hbmdsZSxcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdzb3VyY2UtZGlzdGFuY2UtZnJvbS1ub2RlJyxcbiAgICAgIHR5cGU6IHQuc2l6ZSxcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICd0YXJnZXQtZGlzdGFuY2UtZnJvbS1ub2RlJyxcbiAgICAgIHR5cGU6IHQuc2l6ZSxcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH1dO1xuICAgIHZhciBnaG9zdCA9IFt7XG4gICAgICBuYW1lOiAnZ2hvc3QnLFxuICAgICAgdHlwZTogdC5ib29sLFxuICAgICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gICAgfSwge1xuICAgICAgbmFtZTogJ2dob3N0LW9mZnNldC14JyxcbiAgICAgIHR5cGU6IHQuYmlkaXJlY3Rpb25hbFNpemUsXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnZ2hvc3Qtb2Zmc2V0LXknLFxuICAgICAgdHlwZTogdC5iaWRpcmVjdGlvbmFsU2l6ZSxcbiAgICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdnaG9zdC1vcGFjaXR5JyxcbiAgICAgIHR5cGU6IHQuemVyb09uZU51bWJlclxuICAgIH1dO1xuICAgIHZhciBjb3JlID0gW3tcbiAgICAgIG5hbWU6ICdzZWxlY3Rpb24tYm94LWNvbG9yJyxcbiAgICAgIHR5cGU6IHQuY29sb3JcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnc2VsZWN0aW9uLWJveC1vcGFjaXR5JyxcbiAgICAgIHR5cGU6IHQuemVyb09uZU51bWJlclxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdzZWxlY3Rpb24tYm94LWJvcmRlci1jb2xvcicsXG4gICAgICB0eXBlOiB0LmNvbG9yXG4gICAgfSwge1xuICAgICAgbmFtZTogJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLXdpZHRoJyxcbiAgICAgIHR5cGU6IHQuc2l6ZVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdhY3RpdmUtYmctY29sb3InLFxuICAgICAgdHlwZTogdC5jb2xvclxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdhY3RpdmUtYmctb3BhY2l0eScsXG4gICAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXJcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnYWN0aXZlLWJnLXNpemUnLFxuICAgICAgdHlwZTogdC5zaXplXG4gICAgfSwge1xuICAgICAgbmFtZTogJ291dHNpZGUtdGV4dHVyZS1iZy1jb2xvcicsXG4gICAgICB0eXBlOiB0LmNvbG9yXG4gICAgfSwge1xuICAgICAgbmFtZTogJ291dHNpZGUtdGV4dHVyZS1iZy1vcGFjaXR5JyxcbiAgICAgIHR5cGU6IHQuemVyb09uZU51bWJlclxuICAgIH1dOyAvLyBwaWUgYmFja2dyb3VuZHMgZm9yIG5vZGVzXG5cbiAgICB2YXIgcGllID0gW107XG4gICAgc3R5Zm4kMi5waWVCYWNrZ3JvdW5kTiA9IDE2OyAvLyBiZWNhdXNlIHRoZSBwaWUgcHJvcGVydGllcyBhcmUgbnVtYmVyZWQsIGdpdmUgYWNjZXNzIHRvIGEgY29uc3RhbnQgTiAoZm9yIHJlbmRlcmVyIHVzZSlcblxuICAgIHBpZS5wdXNoKHtcbiAgICAgIG5hbWU6ICdwaWUtc2l6ZScsXG4gICAgICB0eXBlOiB0LnNpemVNYXliZVBlcmNlbnRcbiAgICB9KTtcblxuICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IHN0eWZuJDIucGllQmFja2dyb3VuZE47IGkrKykge1xuICAgICAgcGllLnB1c2goe1xuICAgICAgICBuYW1lOiAncGllLScgKyBpICsgJy1iYWNrZ3JvdW5kLWNvbG9yJyxcbiAgICAgICAgdHlwZTogdC5jb2xvclxuICAgICAgfSk7XG4gICAgICBwaWUucHVzaCh7XG4gICAgICAgIG5hbWU6ICdwaWUtJyArIGkgKyAnLWJhY2tncm91bmQtc2l6ZScsXG4gICAgICAgIHR5cGU6IHQucGVyY2VudFxuICAgICAgfSk7XG4gICAgICBwaWUucHVzaCh7XG4gICAgICAgIG5hbWU6ICdwaWUtJyArIGkgKyAnLWJhY2tncm91bmQtb3BhY2l0eScsXG4gICAgICAgIHR5cGU6IHQuemVyb09uZU51bWJlclxuICAgICAgfSk7XG4gICAgfSAvLyBlZGdlIGFycm93c1xuXG5cbiAgICB2YXIgZWRnZUFycm93ID0gW107XG4gICAgdmFyIGFycm93UHJlZml4ZXMgPSBzdHlmbiQyLmFycm93UHJlZml4ZXMgPSBbJ3NvdXJjZScsICdtaWQtc291cmNlJywgJ3RhcmdldCcsICdtaWQtdGFyZ2V0J107XG4gICAgW3tcbiAgICAgIG5hbWU6ICdhcnJvdy1zaGFwZScsXG4gICAgICB0eXBlOiB0LmFycm93U2hhcGUsXG4gICAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnYXJyb3ctY29sb3InLFxuICAgICAgdHlwZTogdC5jb2xvclxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdhcnJvdy1maWxsJyxcbiAgICAgIHR5cGU6IHQuYXJyb3dGaWxsXG4gICAgfV0uZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgYXJyb3dQcmVmaXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBwcmVmaXggKyAnLScgKyBwcm9wLm5hbWU7XG4gICAgICAgIHZhciB0eXBlID0gcHJvcC50eXBlLFxuICAgICAgICAgICAgdHJpZ2dlcnNCb3VuZHMgPSBwcm9wLnRyaWdnZXJzQm91bmRzO1xuICAgICAgICBlZGdlQXJyb3cucHVzaCh7XG4gICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgIHRyaWdnZXJzQm91bmRzOiB0cmlnZ2Vyc0JvdW5kc1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0sIHt9KTtcbiAgICB2YXIgcHJvcHMgPSBzdHlmbiQyLnByb3BlcnRpZXMgPSBbXS5jb25jYXQoYmVoYXZpb3IsIHRyYW5zaXRpb24sIHZpc2liaWxpdHksIG92ZXJsYXksIHVuZGVybGF5LCBnaG9zdCwgY29tbW9uTGFiZWwsIGxhYmVsRGltZW5zaW9ucywgbWFpbkxhYmVsLCBzb3VyY2VMYWJlbCwgdGFyZ2V0TGFiZWwsIG5vZGVCb2R5LCBub2RlQm9yZGVyLCBiYWNrZ3JvdW5kSW1hZ2UsIHBpZSwgY29tcG91bmQsIGVkZ2VMaW5lLCBlZGdlQXJyb3csIGNvcmUpO1xuICAgIHZhciBwcm9wR3JvdXBzID0gc3R5Zm4kMi5wcm9wZXJ0eUdyb3VwcyA9IHtcbiAgICAgIC8vIGNvbW1vbiB0byBhbGwgZWxlc1xuICAgICAgYmVoYXZpb3I6IGJlaGF2aW9yLFxuICAgICAgdHJhbnNpdGlvbjogdHJhbnNpdGlvbixcbiAgICAgIHZpc2liaWxpdHk6IHZpc2liaWxpdHksXG4gICAgICBvdmVybGF5OiBvdmVybGF5LFxuICAgICAgdW5kZXJsYXk6IHVuZGVybGF5LFxuICAgICAgZ2hvc3Q6IGdob3N0LFxuICAgICAgLy8gbGFiZWxzXG4gICAgICBjb21tb25MYWJlbDogY29tbW9uTGFiZWwsXG4gICAgICBsYWJlbERpbWVuc2lvbnM6IGxhYmVsRGltZW5zaW9ucyxcbiAgICAgIG1haW5MYWJlbDogbWFpbkxhYmVsLFxuICAgICAgc291cmNlTGFiZWw6IHNvdXJjZUxhYmVsLFxuICAgICAgdGFyZ2V0TGFiZWw6IHRhcmdldExhYmVsLFxuICAgICAgLy8gbm9kZSBwcm9wc1xuICAgICAgbm9kZUJvZHk6IG5vZGVCb2R5LFxuICAgICAgbm9kZUJvcmRlcjogbm9kZUJvcmRlcixcbiAgICAgIGJhY2tncm91bmRJbWFnZTogYmFja2dyb3VuZEltYWdlLFxuICAgICAgcGllOiBwaWUsXG4gICAgICBjb21wb3VuZDogY29tcG91bmQsXG4gICAgICAvLyBlZGdlIHByb3BzXG4gICAgICBlZGdlTGluZTogZWRnZUxpbmUsXG4gICAgICBlZGdlQXJyb3c6IGVkZ2VBcnJvdyxcbiAgICAgIGNvcmU6IGNvcmVcbiAgICB9O1xuICAgIHZhciBwcm9wR3JvdXBOYW1lcyA9IHN0eWZuJDIucHJvcGVydHlHcm91cE5hbWVzID0ge307XG4gICAgdmFyIHByb3BHcm91cEtleXMgPSBzdHlmbiQyLnByb3BlcnR5R3JvdXBLZXlzID0gT2JqZWN0LmtleXMocHJvcEdyb3Vwcyk7XG4gICAgcHJvcEdyb3VwS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHByb3BHcm91cE5hbWVzW2tleV0gPSBwcm9wR3JvdXBzW2tleV0ubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgIHJldHVybiBwcm9wLm5hbWU7XG4gICAgICB9KTtcbiAgICAgIHByb3BHcm91cHNba2V5XS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgIHJldHVybiBwcm9wLmdyb3VwS2V5ID0ga2V5O1xuICAgICAgfSk7XG4gICAgfSk7IC8vIGRlZmluZSBhbGlhc2VzXG5cbiAgICB2YXIgYWxpYXNlcyA9IHN0eWZuJDIuYWxpYXNlcyA9IFt7XG4gICAgICBuYW1lOiAnY29udGVudCcsXG4gICAgICBwb2ludHNUbzogJ2xhYmVsJ1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdjb250cm9sLXBvaW50LWRpc3RhbmNlJyxcbiAgICAgIHBvaW50c1RvOiAnY29udHJvbC1wb2ludC1kaXN0YW5jZXMnXG4gICAgfSwge1xuICAgICAgbmFtZTogJ2NvbnRyb2wtcG9pbnQtd2VpZ2h0JyxcbiAgICAgIHBvaW50c1RvOiAnY29udHJvbC1wb2ludC13ZWlnaHRzJ1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdlZGdlLXRleHQtcm90YXRpb24nLFxuICAgICAgcG9pbnRzVG86ICd0ZXh0LXJvdGF0aW9uJ1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdwYWRkaW5nLWxlZnQnLFxuICAgICAgcG9pbnRzVG86ICdwYWRkaW5nJ1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdwYWRkaW5nLXJpZ2h0JyxcbiAgICAgIHBvaW50c1RvOiAncGFkZGluZydcbiAgICB9LCB7XG4gICAgICBuYW1lOiAncGFkZGluZy10b3AnLFxuICAgICAgcG9pbnRzVG86ICdwYWRkaW5nJ1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdwYWRkaW5nLWJvdHRvbScsXG4gICAgICBwb2ludHNUbzogJ3BhZGRpbmcnXG4gICAgfV07IC8vIGxpc3Qgb2YgcHJvcGVydHkgbmFtZXNcblxuICAgIHN0eWZuJDIucHJvcGVydHlOYW1lcyA9IHByb3BzLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgcmV0dXJuIHAubmFtZTtcbiAgICB9KTsgLy8gYWxsb3cgYWNjZXNzIG9mIHByb3BlcnRpZXMgYnkgbmFtZSAoIGUuZy4gc3R5bGUucHJvcGVydGllcy5oZWlnaHQgKVxuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHByb3BzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIHByb3AgPSBwcm9wc1tfaV07XG4gICAgICBwcm9wc1twcm9wLm5hbWVdID0gcHJvcDsgLy8gYWxsb3cgbG9va3VwIGJ5IG5hbWVcbiAgICB9IC8vIG1hcCBhbGlhc2VzXG5cblxuICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGFsaWFzZXMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgdmFyIGFsaWFzID0gYWxpYXNlc1tfaTJdO1xuICAgICAgdmFyIHBvaW50c1RvUHJvcCA9IHByb3BzW2FsaWFzLnBvaW50c1RvXTtcbiAgICAgIHZhciBhbGlhc1Byb3AgPSB7XG4gICAgICAgIG5hbWU6IGFsaWFzLm5hbWUsXG4gICAgICAgIGFsaWFzOiB0cnVlLFxuICAgICAgICBwb2ludHNUbzogcG9pbnRzVG9Qcm9wXG4gICAgICB9OyAvLyBhZGQgYWxpYXMgcHJvcCBmb3IgcGFyc2luZ1xuXG4gICAgICBwcm9wcy5wdXNoKGFsaWFzUHJvcCk7XG4gICAgICBwcm9wc1thbGlhcy5uYW1lXSA9IGFsaWFzUHJvcDsgLy8gYWxsb3cgbG9va3VwIGJ5IG5hbWVcbiAgICB9XG4gIH0pKCk7XG5cbiAgc3R5Zm4kMi5nZXREZWZhdWx0UHJvcGVydHkgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiB0aGlzLmdldERlZmF1bHRQcm9wZXJ0aWVzKClbbmFtZV07XG4gIH07XG5cbiAgc3R5Zm4kMi5nZXREZWZhdWx0UHJvcGVydGllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuXG4gICAgaWYgKF9wLmRlZmF1bHRQcm9wZXJ0aWVzICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBfcC5kZWZhdWx0UHJvcGVydGllcztcbiAgICB9XG5cbiAgICB2YXIgcmF3UHJvcHMgPSBleHRlbmQoe1xuICAgICAgLy8gY29yZSBwcm9wc1xuICAgICAgJ3NlbGVjdGlvbi1ib3gtY29sb3InOiAnI2RkZCcsXG4gICAgICAnc2VsZWN0aW9uLWJveC1vcGFjaXR5JzogMC42NSxcbiAgICAgICdzZWxlY3Rpb24tYm94LWJvcmRlci1jb2xvcic6ICcjYWFhJyxcbiAgICAgICdzZWxlY3Rpb24tYm94LWJvcmRlci13aWR0aCc6IDEsXG4gICAgICAnYWN0aXZlLWJnLWNvbG9yJzogJ2JsYWNrJyxcbiAgICAgICdhY3RpdmUtYmctb3BhY2l0eSc6IDAuMTUsXG4gICAgICAnYWN0aXZlLWJnLXNpemUnOiAzMCxcbiAgICAgICdvdXRzaWRlLXRleHR1cmUtYmctY29sb3InOiAnIzAwMCcsXG4gICAgICAnb3V0c2lkZS10ZXh0dXJlLWJnLW9wYWNpdHknOiAwLjEyNSxcbiAgICAgIC8vIGNvbW1vbiBub2RlL2VkZ2UgcHJvcHNcbiAgICAgICdldmVudHMnOiAneWVzJyxcbiAgICAgICd0ZXh0LWV2ZW50cyc6ICdubycsXG4gICAgICAndGV4dC12YWxpZ24nOiAndG9wJyxcbiAgICAgICd0ZXh0LWhhbGlnbic6ICdjZW50ZXInLFxuICAgICAgJ3RleHQtanVzdGlmaWNhdGlvbic6ICdhdXRvJyxcbiAgICAgICdsaW5lLWhlaWdodCc6IDEsXG4gICAgICAnY29sb3InOiAnIzAwMCcsXG4gICAgICAndGV4dC1vdXRsaW5lLWNvbG9yJzogJyMwMDAnLFxuICAgICAgJ3RleHQtb3V0bGluZS13aWR0aCc6IDAsXG4gICAgICAndGV4dC1vdXRsaW5lLW9wYWNpdHknOiAxLFxuICAgICAgJ3RleHQtb3BhY2l0eSc6IDEsXG4gICAgICAndGV4dC1kZWNvcmF0aW9uJzogJ25vbmUnLFxuICAgICAgJ3RleHQtdHJhbnNmb3JtJzogJ25vbmUnLFxuICAgICAgJ3RleHQtd3JhcCc6ICdub25lJyxcbiAgICAgICd0ZXh0LW92ZXJmbG93LXdyYXAnOiAnd2hpdGVzcGFjZScsXG4gICAgICAndGV4dC1tYXgtd2lkdGgnOiA5OTk5LFxuICAgICAgJ3RleHQtYmFja2dyb3VuZC1jb2xvcic6ICcjMDAwJyxcbiAgICAgICd0ZXh0LWJhY2tncm91bmQtb3BhY2l0eSc6IDAsXG4gICAgICAndGV4dC1iYWNrZ3JvdW5kLXNoYXBlJzogJ3JlY3RhbmdsZScsXG4gICAgICAndGV4dC1iYWNrZ3JvdW5kLXBhZGRpbmcnOiAwLFxuICAgICAgJ3RleHQtYm9yZGVyLW9wYWNpdHknOiAwLFxuICAgICAgJ3RleHQtYm9yZGVyLXdpZHRoJzogMCxcbiAgICAgICd0ZXh0LWJvcmRlci1zdHlsZSc6ICdzb2xpZCcsXG4gICAgICAndGV4dC1ib3JkZXItY29sb3InOiAnIzAwMCcsXG4gICAgICAnZm9udC1mYW1pbHknOiAnSGVsdmV0aWNhIE5ldWUsIEhlbHZldGljYSwgc2Fucy1zZXJpZicsXG4gICAgICAnZm9udC1zdHlsZSc6ICdub3JtYWwnLFxuICAgICAgJ2ZvbnQtd2VpZ2h0JzogJ25vcm1hbCcsXG4gICAgICAnZm9udC1zaXplJzogMTYsXG4gICAgICAnbWluLXpvb21lZC1mb250LXNpemUnOiAwLFxuICAgICAgJ3RleHQtcm90YXRpb24nOiAnbm9uZScsXG4gICAgICAnc291cmNlLXRleHQtcm90YXRpb24nOiAnbm9uZScsXG4gICAgICAndGFyZ2V0LXRleHQtcm90YXRpb24nOiAnbm9uZScsXG4gICAgICAndmlzaWJpbGl0eSc6ICd2aXNpYmxlJyxcbiAgICAgICdkaXNwbGF5JzogJ2VsZW1lbnQnLFxuICAgICAgJ29wYWNpdHknOiAxLFxuICAgICAgJ3otY29tcG91bmQtZGVwdGgnOiAnYXV0bycsXG4gICAgICAnei1pbmRleC1jb21wYXJlJzogJ2F1dG8nLFxuICAgICAgJ3otaW5kZXgnOiAwLFxuICAgICAgJ2xhYmVsJzogJycsXG4gICAgICAndGV4dC1tYXJnaW4teCc6IDAsXG4gICAgICAndGV4dC1tYXJnaW4teSc6IDAsXG4gICAgICAnc291cmNlLWxhYmVsJzogJycsXG4gICAgICAnc291cmNlLXRleHQtb2Zmc2V0JzogMCxcbiAgICAgICdzb3VyY2UtdGV4dC1tYXJnaW4teCc6IDAsXG4gICAgICAnc291cmNlLXRleHQtbWFyZ2luLXknOiAwLFxuICAgICAgJ3RhcmdldC1sYWJlbCc6ICcnLFxuICAgICAgJ3RhcmdldC10ZXh0LW9mZnNldCc6IDAsXG4gICAgICAndGFyZ2V0LXRleHQtbWFyZ2luLXgnOiAwLFxuICAgICAgJ3RhcmdldC10ZXh0LW1hcmdpbi15JzogMCxcbiAgICAgICdvdmVybGF5LW9wYWNpdHknOiAwLFxuICAgICAgJ292ZXJsYXktY29sb3InOiAnIzAwMCcsXG4gICAgICAnb3ZlcmxheS1wYWRkaW5nJzogMTAsXG4gICAgICAnb3ZlcmxheS1zaGFwZSc6ICdyb3VuZC1yZWN0YW5nbGUnLFxuICAgICAgJ3VuZGVybGF5LW9wYWNpdHknOiAwLFxuICAgICAgJ3VuZGVybGF5LWNvbG9yJzogJyMwMDAnLFxuICAgICAgJ3VuZGVybGF5LXBhZGRpbmcnOiAxMCxcbiAgICAgICd1bmRlcmxheS1zaGFwZSc6ICdyb3VuZC1yZWN0YW5nbGUnLFxuICAgICAgJ3RyYW5zaXRpb24tcHJvcGVydHknOiAnbm9uZScsXG4gICAgICAndHJhbnNpdGlvbi1kdXJhdGlvbic6IDAsXG4gICAgICAndHJhbnNpdGlvbi1kZWxheSc6IDAsXG4gICAgICAndHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb24nOiAnbGluZWFyJyxcbiAgICAgIC8vIG5vZGUgcHJvcHNcbiAgICAgICdiYWNrZ3JvdW5kLWJsYWNrZW4nOiAwLFxuICAgICAgJ2JhY2tncm91bmQtY29sb3InOiAnIzk5OScsXG4gICAgICAnYmFja2dyb3VuZC1maWxsJzogJ3NvbGlkJyxcbiAgICAgICdiYWNrZ3JvdW5kLW9wYWNpdHknOiAxLFxuICAgICAgJ2JhY2tncm91bmQtaW1hZ2UnOiAnbm9uZScsXG4gICAgICAnYmFja2dyb3VuZC1pbWFnZS1jcm9zc29yaWdpbic6ICdhbm9ueW1vdXMnLFxuICAgICAgJ2JhY2tncm91bmQtaW1hZ2Utb3BhY2l0eSc6IDEsXG4gICAgICAnYmFja2dyb3VuZC1pbWFnZS1jb250YWlubWVudCc6ICdpbnNpZGUnLFxuICAgICAgJ2JhY2tncm91bmQtaW1hZ2Utc21vb3RoaW5nJzogJ3llcycsXG4gICAgICAnYmFja2dyb3VuZC1wb3NpdGlvbi14JzogJzUwJScsXG4gICAgICAnYmFja2dyb3VuZC1wb3NpdGlvbi15JzogJzUwJScsXG4gICAgICAnYmFja2dyb3VuZC1vZmZzZXQteCc6IDAsXG4gICAgICAnYmFja2dyb3VuZC1vZmZzZXQteSc6IDAsXG4gICAgICAnYmFja2dyb3VuZC13aWR0aC1yZWxhdGl2ZS10byc6ICdpbmNsdWRlLXBhZGRpbmcnLFxuICAgICAgJ2JhY2tncm91bmQtaGVpZ2h0LXJlbGF0aXZlLXRvJzogJ2luY2x1ZGUtcGFkZGluZycsXG4gICAgICAnYmFja2dyb3VuZC1yZXBlYXQnOiAnbm8tcmVwZWF0JyxcbiAgICAgICdiYWNrZ3JvdW5kLWZpdCc6ICdub25lJyxcbiAgICAgICdiYWNrZ3JvdW5kLWNsaXAnOiAnbm9kZScsXG4gICAgICAnYmFja2dyb3VuZC13aWR0aCc6ICdhdXRvJyxcbiAgICAgICdiYWNrZ3JvdW5kLWhlaWdodCc6ICdhdXRvJyxcbiAgICAgICdib3JkZXItY29sb3InOiAnIzAwMCcsXG4gICAgICAnYm9yZGVyLW9wYWNpdHknOiAxLFxuICAgICAgJ2JvcmRlci13aWR0aCc6IDAsXG4gICAgICAnYm9yZGVyLXN0eWxlJzogJ3NvbGlkJyxcbiAgICAgICdoZWlnaHQnOiAzMCxcbiAgICAgICd3aWR0aCc6IDMwLFxuICAgICAgJ3NoYXBlJzogJ2VsbGlwc2UnLFxuICAgICAgJ3NoYXBlLXBvbHlnb24tcG9pbnRzJzogJy0xLCAtMSwgICAxLCAtMSwgICAxLCAxLCAgIC0xLCAxJyxcbiAgICAgICdib3VuZHMtZXhwYW5zaW9uJzogMCxcbiAgICAgIC8vIG5vZGUgZ3JhZGllbnRcbiAgICAgICdiYWNrZ3JvdW5kLWdyYWRpZW50LWRpcmVjdGlvbic6ICd0by1ib3R0b20nLFxuICAgICAgJ2JhY2tncm91bmQtZ3JhZGllbnQtc3RvcC1jb2xvcnMnOiAnIzk5OScsXG4gICAgICAnYmFja2dyb3VuZC1ncmFkaWVudC1zdG9wLXBvc2l0aW9ucyc6ICcwJScsXG4gICAgICAvLyBnaG9zdCBwcm9wc1xuICAgICAgJ2dob3N0JzogJ25vJyxcbiAgICAgICdnaG9zdC1vZmZzZXQteSc6IDAsXG4gICAgICAnZ2hvc3Qtb2Zmc2V0LXgnOiAwLFxuICAgICAgJ2dob3N0LW9wYWNpdHknOiAwLFxuICAgICAgLy8gY29tcG91bmQgcHJvcHNcbiAgICAgICdwYWRkaW5nJzogMCxcbiAgICAgICdwYWRkaW5nLXJlbGF0aXZlLXRvJzogJ3dpZHRoJyxcbiAgICAgICdwb3NpdGlvbic6ICdvcmlnaW4nLFxuICAgICAgJ2NvbXBvdW5kLXNpemluZy13cnQtbGFiZWxzJzogJ2luY2x1ZGUnLFxuICAgICAgJ21pbi13aWR0aCc6IDAsXG4gICAgICAnbWluLXdpZHRoLWJpYXMtbGVmdCc6IDAsXG4gICAgICAnbWluLXdpZHRoLWJpYXMtcmlnaHQnOiAwLFxuICAgICAgJ21pbi1oZWlnaHQnOiAwLFxuICAgICAgJ21pbi1oZWlnaHQtYmlhcy10b3AnOiAwLFxuICAgICAgJ21pbi1oZWlnaHQtYmlhcy1ib3R0b20nOiAwXG4gICAgfSwge1xuICAgICAgLy8gbm9kZSBwaWUgYmdcbiAgICAgICdwaWUtc2l6ZSc6ICcxMDAlJ1xuICAgIH0sIFt7XG4gICAgICBuYW1lOiAncGllLXt7aX19LWJhY2tncm91bmQtY29sb3InLFxuICAgICAgdmFsdWU6ICdibGFjaydcbiAgICB9LCB7XG4gICAgICBuYW1lOiAncGllLXt7aX19LWJhY2tncm91bmQtc2l6ZScsXG4gICAgICB2YWx1ZTogJzAlJ1xuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdwaWUte3tpfX0tYmFja2dyb3VuZC1vcGFjaXR5JyxcbiAgICAgIHZhbHVlOiAxXG4gICAgfV0ucmVkdWNlKGZ1bmN0aW9uIChjc3MsIHByb3ApIHtcbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IHN0eWZuJDIucGllQmFja2dyb3VuZE47IGkrKykge1xuICAgICAgICB2YXIgbmFtZSA9IHByb3AubmFtZS5yZXBsYWNlKCd7e2l9fScsIGkpO1xuICAgICAgICB2YXIgdmFsID0gcHJvcC52YWx1ZTtcbiAgICAgICAgY3NzW25hbWVdID0gdmFsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY3NzO1xuICAgIH0sIHt9KSwge1xuICAgICAgLy8gZWRnZSBwcm9wc1xuICAgICAgJ2xpbmUtc3R5bGUnOiAnc29saWQnLFxuICAgICAgJ2xpbmUtY29sb3InOiAnIzk5OScsXG4gICAgICAnbGluZS1maWxsJzogJ3NvbGlkJyxcbiAgICAgICdsaW5lLWNhcCc6ICdidXR0JyxcbiAgICAgICdsaW5lLW9wYWNpdHknOiAxLFxuICAgICAgJ2xpbmUtZ3JhZGllbnQtc3RvcC1jb2xvcnMnOiAnIzk5OScsXG4gICAgICAnbGluZS1ncmFkaWVudC1zdG9wLXBvc2l0aW9ucyc6ICcwJScsXG4gICAgICAnY29udHJvbC1wb2ludC1zdGVwLXNpemUnOiA0MCxcbiAgICAgICdjb250cm9sLXBvaW50LXdlaWdodHMnOiAwLjUsXG4gICAgICAnc2VnbWVudC13ZWlnaHRzJzogMC41LFxuICAgICAgJ3NlZ21lbnQtZGlzdGFuY2VzJzogMjAsXG4gICAgICAndGF4aS10dXJuJzogJzUwJScsXG4gICAgICAndGF4aS10dXJuLW1pbi1kaXN0YW5jZSc6IDEwLFxuICAgICAgJ3RheGktZGlyZWN0aW9uJzogJ2F1dG8nLFxuICAgICAgJ2VkZ2UtZGlzdGFuY2VzJzogJ2ludGVyc2VjdGlvbicsXG4gICAgICAnY3VydmUtc3R5bGUnOiAnaGF5c3RhY2snLFxuICAgICAgJ2hheXN0YWNrLXJhZGl1cyc6IDAsXG4gICAgICAnYXJyb3ctc2NhbGUnOiAxLFxuICAgICAgJ2xvb3AtZGlyZWN0aW9uJzogJy00NWRlZycsXG4gICAgICAnbG9vcC1zd2VlcCc6ICctOTBkZWcnLFxuICAgICAgJ3NvdXJjZS1kaXN0YW5jZS1mcm9tLW5vZGUnOiAwLFxuICAgICAgJ3RhcmdldC1kaXN0YW5jZS1mcm9tLW5vZGUnOiAwLFxuICAgICAgJ3NvdXJjZS1lbmRwb2ludCc6ICdvdXRzaWRlLXRvLW5vZGUnLFxuICAgICAgJ3RhcmdldC1lbmRwb2ludCc6ICdvdXRzaWRlLXRvLW5vZGUnLFxuICAgICAgJ2xpbmUtZGFzaC1wYXR0ZXJuJzogWzYsIDNdLFxuICAgICAgJ2xpbmUtZGFzaC1vZmZzZXQnOiAwXG4gICAgfSwgW3tcbiAgICAgIG5hbWU6ICdhcnJvdy1zaGFwZScsXG4gICAgICB2YWx1ZTogJ25vbmUnXG4gICAgfSwge1xuICAgICAgbmFtZTogJ2Fycm93LWNvbG9yJyxcbiAgICAgIHZhbHVlOiAnIzk5OSdcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnYXJyb3ctZmlsbCcsXG4gICAgICB2YWx1ZTogJ2ZpbGxlZCdcbiAgICB9XS5yZWR1Y2UoZnVuY3Rpb24gKGNzcywgcHJvcCkge1xuICAgICAgc3R5Zm4kMi5hcnJvd1ByZWZpeGVzLmZvckVhY2goZnVuY3Rpb24gKHByZWZpeCkge1xuICAgICAgICB2YXIgbmFtZSA9IHByZWZpeCArICctJyArIHByb3AubmFtZTtcbiAgICAgICAgdmFyIHZhbCA9IHByb3AudmFsdWU7XG4gICAgICAgIGNzc1tuYW1lXSA9IHZhbDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNzcztcbiAgICB9LCB7fSkpO1xuICAgIHZhciBwYXJzZWRQcm9wcyA9IHt9O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwcm9wID0gdGhpcy5wcm9wZXJ0aWVzW2ldO1xuXG4gICAgICBpZiAocHJvcC5wb2ludHNUbykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5hbWUgPSBwcm9wLm5hbWU7XG4gICAgICB2YXIgdmFsID0gcmF3UHJvcHNbbmFtZV07XG4gICAgICB2YXIgcGFyc2VkUHJvcCA9IHRoaXMucGFyc2UobmFtZSwgdmFsKTtcbiAgICAgIHBhcnNlZFByb3BzW25hbWVdID0gcGFyc2VkUHJvcDtcbiAgICB9XG5cbiAgICBfcC5kZWZhdWx0UHJvcGVydGllcyA9IHBhcnNlZFByb3BzO1xuICAgIHJldHVybiBfcC5kZWZhdWx0UHJvcGVydGllcztcbiAgfTtcblxuICBzdHlmbiQyLmFkZERlZmF1bHRTdHlsZXNoZWV0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2VsZWN0b3IoJzpwYXJlbnQnKS5jc3Moe1xuICAgICAgJ3NoYXBlJzogJ3JlY3RhbmdsZScsXG4gICAgICAncGFkZGluZyc6IDEwLFxuICAgICAgJ2JhY2tncm91bmQtY29sb3InOiAnI2VlZScsXG4gICAgICAnYm9yZGVyLWNvbG9yJzogJyNjY2MnLFxuICAgICAgJ2JvcmRlci13aWR0aCc6IDFcbiAgICB9KS5zZWxlY3RvcignZWRnZScpLmNzcyh7XG4gICAgICAnd2lkdGgnOiAzXG4gICAgfSkuc2VsZWN0b3IoJzpsb29wJykuY3NzKHtcbiAgICAgICdjdXJ2ZS1zdHlsZSc6ICdiZXppZXInXG4gICAgfSkuc2VsZWN0b3IoJ2VkZ2U6Y29tcG91bmQnKS5jc3Moe1xuICAgICAgJ2N1cnZlLXN0eWxlJzogJ2JlemllcicsXG4gICAgICAnc291cmNlLWVuZHBvaW50JzogJ291dHNpZGUtdG8tbGluZScsXG4gICAgICAndGFyZ2V0LWVuZHBvaW50JzogJ291dHNpZGUtdG8tbGluZSdcbiAgICB9KS5zZWxlY3RvcignOnNlbGVjdGVkJykuY3NzKHtcbiAgICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogJyMwMTY5RDknLFxuICAgICAgJ2xpbmUtY29sb3InOiAnIzAxNjlEOScsXG4gICAgICAnc291cmNlLWFycm93LWNvbG9yJzogJyMwMTY5RDknLFxuICAgICAgJ3RhcmdldC1hcnJvdy1jb2xvcic6ICcjMDE2OUQ5JyxcbiAgICAgICdtaWQtc291cmNlLWFycm93LWNvbG9yJzogJyMwMTY5RDknLFxuICAgICAgJ21pZC10YXJnZXQtYXJyb3ctY29sb3InOiAnIzAxNjlEOSdcbiAgICB9KS5zZWxlY3RvcignOnBhcmVudDpzZWxlY3RlZCcpLmNzcyh7XG4gICAgICAnYmFja2dyb3VuZC1jb2xvcic6ICcjQ0NFMUY5JyxcbiAgICAgICdib3JkZXItY29sb3InOiAnI2FlYzhlNSdcbiAgICB9KS5zZWxlY3RvcignOmFjdGl2ZScpLmNzcyh7XG4gICAgICAnb3ZlcmxheS1jb2xvcic6ICdibGFjaycsXG4gICAgICAnb3ZlcmxheS1wYWRkaW5nJzogMTAsXG4gICAgICAnb3ZlcmxheS1vcGFjaXR5JzogMC4yNVxuICAgIH0pO1xuICAgIHRoaXMuZGVmYXVsdExlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICB9O1xuXG4gIHZhciBzdHlmbiQxID0ge307IC8vIGEgY2FjaGluZyBsYXllciBmb3IgcHJvcGVydHkgcGFyc2luZ1xuXG4gIHN0eWZuJDEucGFyc2UgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIHByb3BJc0J5cGFzcywgcHJvcElzRmxhdCkge1xuICAgIHZhciBzZWxmID0gdGhpczsgLy8gZnVuY3Rpb24gdmFsdWVzIGNhbid0IGJlIGNhY2hlZCBpbiBhbGwgY2FzZXMsIGFuZCB0aGVyZSBpc24ndCBtdWNoIGJlbmVmaXQgb2YgY2FjaGluZyB0aGVtIGFueXdheVxuXG4gICAgaWYgKGZuJDYodmFsdWUpKSB7XG4gICAgICByZXR1cm4gc2VsZi5wYXJzZUltcGxXYXJuKG5hbWUsIHZhbHVlLCBwcm9wSXNCeXBhc3MsIHByb3BJc0ZsYXQpO1xuICAgIH1cblxuICAgIHZhciBmbGF0S2V5ID0gcHJvcElzRmxhdCA9PT0gJ21hcHBpbmcnIHx8IHByb3BJc0ZsYXQgPT09IHRydWUgfHwgcHJvcElzRmxhdCA9PT0gZmFsc2UgfHwgcHJvcElzRmxhdCA9PSBudWxsID8gJ2RvbnRjYXJlJyA6IHByb3BJc0ZsYXQ7XG4gICAgdmFyIGJ5cGFzc0tleSA9IHByb3BJc0J5cGFzcyA/ICd0JyA6ICdmJztcbiAgICB2YXIgdmFsdWVLZXkgPSAnJyArIHZhbHVlO1xuICAgIHZhciBhcmdIYXNoID0gaGFzaFN0cmluZ3MobmFtZSwgdmFsdWVLZXksIGJ5cGFzc0tleSwgZmxhdEtleSk7XG4gICAgdmFyIHByb3BDYWNoZSA9IHNlbGYucHJvcENhY2hlID0gc2VsZi5wcm9wQ2FjaGUgfHwgW107XG4gICAgdmFyIHJldDtcblxuICAgIGlmICghKHJldCA9IHByb3BDYWNoZVthcmdIYXNoXSkpIHtcbiAgICAgIHJldCA9IHByb3BDYWNoZVthcmdIYXNoXSA9IHNlbGYucGFyc2VJbXBsV2FybihuYW1lLCB2YWx1ZSwgcHJvcElzQnlwYXNzLCBwcm9wSXNGbGF0KTtcbiAgICB9IC8vIC0gYnlwYXNzZXMgY2FuJ3QgYmUgc2hhcmVkIGIvYyB0aGUgdmFsdWUgY2FuIGJlIGNoYW5nZWQgYnkgYW5pbWF0aW9ucyBvciBvdGhlcndpc2Ugb3ZlcnJpZGRlblxuICAgIC8vIC0gbWFwcGluZ3MgY2FuJ3QgYmUgc2hhcmVkIGIvYyBtYXBwaW5ncyBhcmUgcGVyLWVsZW1lbnRcblxuXG4gICAgaWYgKHByb3BJc0J5cGFzcyB8fCBwcm9wSXNGbGF0ID09PSAnbWFwcGluZycpIHtcbiAgICAgIC8vIG5lZWQgYSBjb3B5IHNpbmNlIHByb3BzIGFyZSBtdXRhdGVkIGxhdGVyIGluIHRoZWlyIGxpZmVjeWNsZXNcbiAgICAgIHJldCA9IGNvcHkocmV0KTtcblxuICAgICAgaWYgKHJldCkge1xuICAgICAgICByZXQudmFsdWUgPSBjb3B5KHJldC52YWx1ZSk7IC8vIGJlY2F1c2UgaXQgY291bGQgYmUgYW4gYXJyYXksIGUuZy4gY29sb3VyXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICBzdHlmbiQxLnBhcnNlSW1wbFdhcm4gPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIHByb3BJc0J5cGFzcywgcHJvcElzRmxhdCkge1xuICAgIHZhciBwcm9wID0gdGhpcy5wYXJzZUltcGwobmFtZSwgdmFsdWUsIHByb3BJc0J5cGFzcywgcHJvcElzRmxhdCk7XG5cbiAgICBpZiAoIXByb3AgJiYgdmFsdWUgIT0gbnVsbCkge1xuICAgICAgd2FybihcIlRoZSBzdHlsZSBwcm9wZXJ0eSBgXCIuY29uY2F0KG5hbWUsIFwiOiBcIikuY29uY2F0KHZhbHVlLCBcImAgaXMgaW52YWxpZFwiKSk7XG4gICAgfVxuXG4gICAgaWYgKHByb3AgJiYgKHByb3AubmFtZSA9PT0gJ3dpZHRoJyB8fCBwcm9wLm5hbWUgPT09ICdoZWlnaHQnKSAmJiB2YWx1ZSA9PT0gJ2xhYmVsJykge1xuICAgICAgd2FybignVGhlIHN0eWxlIHZhbHVlIG9mIGBsYWJlbGAgaXMgZGVwcmVjYXRlZCBmb3IgYCcgKyBwcm9wLm5hbWUgKyAnYCcpO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9wO1xuICB9OyAvLyBwYXJzZSBhIHByb3BlcnR5OyByZXR1cm4gbnVsbCBvbiBpbnZhbGlkOyByZXR1cm4gcGFyc2VkIHByb3BlcnR5IG90aGVyd2lzZVxuICAvLyBmaWVsZHMgOlxuICAvLyAtIG5hbWUgOiB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHlcbiAgLy8gLSB2YWx1ZSA6IHRoZSBwYXJzZWQsIG5hdGl2ZS10eXBlZCB2YWx1ZSBvZiB0aGUgcHJvcGVydHlcbiAgLy8gLSBzdHJWYWx1ZSA6IGEgc3RyaW5nIHZhbHVlIHRoYXQgcmVwcmVzZW50cyB0aGUgcHJvcGVydHkgdmFsdWUgaW4gdmFsaWQgY3NzXG4gIC8vIC0gYnlwYXNzIDogdHJ1ZSBpZmYgdGhlIHByb3BlcnR5IGlzIGEgYnlwYXNzIHByb3BlcnR5XG5cblxuICBzdHlmbiQxLnBhcnNlSW1wbCA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgcHJvcElzQnlwYXNzLCBwcm9wSXNGbGF0KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIG5hbWUgPSBjYW1lbDJkYXNoKG5hbWUpOyAvLyBtYWtlIHN1cmUgdGhlIHByb3BlcnR5IG5hbWUgaXMgaW4gZGFzaCBmb3JtIChlLmcuICdwcm9wZXJ0eS1uYW1lJyBub3QgJ3Byb3BlcnR5TmFtZScpXG5cbiAgICB2YXIgcHJvcGVydHkgPSBzZWxmLnByb3BlcnRpZXNbbmFtZV07XG4gICAgdmFyIHBhc3NlZFZhbHVlID0gdmFsdWU7XG4gICAgdmFyIHR5cGVzID0gc2VsZi50eXBlcztcblxuICAgIGlmICghcHJvcGVydHkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gLy8gcmV0dXJuIG51bGwgb24gcHJvcGVydHkgb2YgdW5rbm93biBuYW1lXG5cblxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IC8vIGNhbid0IGFzc2lnbiB1bmRlZmluZWRcbiAgICAvLyB0aGUgcHJvcGVydHkgbWF5IGJlIGFuIGFsaWFzXG5cblxuICAgIGlmIChwcm9wZXJ0eS5hbGlhcykge1xuICAgICAgcHJvcGVydHkgPSBwcm9wZXJ0eS5wb2ludHNUbztcbiAgICAgIG5hbWUgPSBwcm9wZXJ0eS5uYW1lO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZUlzU3RyaW5nID0gc3RyaW5nKHZhbHVlKTtcblxuICAgIGlmICh2YWx1ZUlzU3RyaW5nKSB7XG4gICAgICAvLyB0cmltIHRoZSB2YWx1ZSB0byBtYWtlIHBhcnNpbmcgZWFzaWVyXG4gICAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKTtcbiAgICB9XG5cbiAgICB2YXIgdHlwZSA9IHByb3BlcnR5LnR5cGU7XG5cbiAgICBpZiAoIXR5cGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gLy8gbm8gdHlwZSwgbm8gbHVja1xuICAgIC8vIGNoZWNrIGlmIGJ5cGFzcyBpcyBudWxsIG9yIGVtcHR5IHN0cmluZyAoaS5lLiBpbmRpY2F0aW9uIHRvIGRlbGV0ZSBieXBhc3MgcHJvcGVydHkpXG5cblxuICAgIGlmIChwcm9wSXNCeXBhc3MgJiYgKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gbnVsbCkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgYnlwYXNzOiB0cnVlLFxuICAgICAgICBkZWxldGVCeXBhc3M6IHRydWVcbiAgICAgIH07XG4gICAgfSAvLyBjaGVjayBpZiB2YWx1ZSBpcyBhIGZ1bmN0aW9uIHVzZWQgYXMgYSBtYXBwZXJcblxuXG4gICAgaWYgKGZuJDYodmFsdWUpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIHN0clZhbHVlOiAnZm4nLFxuICAgICAgICBtYXBwZWQ6IHR5cGVzLmZuLFxuICAgICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgICAgfTtcbiAgICB9IC8vIGNoZWNrIGlmIHZhbHVlIGlzIG1hcHBlZFxuXG5cbiAgICB2YXIgZGF0YSwgbWFwRGF0YTtcblxuICAgIGlmICghdmFsdWVJc1N0cmluZyB8fCBwcm9wSXNGbGF0IHx8IHZhbHVlLmxlbmd0aCA8IDcgfHwgdmFsdWVbMV0gIT09ICdhJykgOyBlbHNlIGlmICh2YWx1ZS5sZW5ndGggPj0gNyAmJiB2YWx1ZVswXSA9PT0gJ2QnICYmIChkYXRhID0gbmV3IFJlZ0V4cCh0eXBlcy5kYXRhLnJlZ2V4KS5leGVjKHZhbHVlKSkpIHtcbiAgICAgIGlmIChwcm9wSXNCeXBhc3MpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSAvLyBtYXBwZXJzIG5vdCBhbGxvd2VkIGluIGJ5cGFzc1xuXG5cbiAgICAgIHZhciBtYXBwZWQgPSB0eXBlcy5kYXRhO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgdmFsdWU6IGRhdGEsXG4gICAgICAgIHN0clZhbHVlOiAnJyArIHZhbHVlLFxuICAgICAgICBtYXBwZWQ6IG1hcHBlZCxcbiAgICAgICAgZmllbGQ6IGRhdGFbMV0sXG4gICAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodmFsdWUubGVuZ3RoID49IDEwICYmIHZhbHVlWzBdID09PSAnbScgJiYgKG1hcERhdGEgPSBuZXcgUmVnRXhwKHR5cGVzLm1hcERhdGEucmVnZXgpLmV4ZWModmFsdWUpKSkge1xuICAgICAgaWYgKHByb3BJc0J5cGFzcykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IC8vIG1hcHBlcnMgbm90IGFsbG93ZWQgaW4gYnlwYXNzXG5cblxuICAgICAgaWYgKHR5cGUubXVsdGlwbGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSAvLyBpbXBvc3NpYmxlIHRvIG1hcCB0byBudW1cblxuXG4gICAgICB2YXIgX21hcHBlZCA9IHR5cGVzLm1hcERhdGE7IC8vIHdlIGNhbiBtYXAgb25seSBpZiB0aGUgdHlwZSBpcyBhIGNvbG91ciBvciBhIG51bWJlclxuXG4gICAgICBpZiAoISh0eXBlLmNvbG9yIHx8IHR5cGUubnVtYmVyKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZU1pbiA9IHRoaXMucGFyc2UobmFtZSwgbWFwRGF0YVs0XSk7IC8vIHBhcnNlIHRvIHZhbGlkYXRlXG5cbiAgICAgIGlmICghdmFsdWVNaW4gfHwgdmFsdWVNaW4ubWFwcGVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gLy8gY2FuJ3QgYmUgaW52YWxpZCBvciBtYXBwZWRcblxuXG4gICAgICB2YXIgdmFsdWVNYXggPSB0aGlzLnBhcnNlKG5hbWUsIG1hcERhdGFbNV0pOyAvLyBwYXJzZSB0byB2YWxpZGF0ZVxuXG4gICAgICBpZiAoIXZhbHVlTWF4IHx8IHZhbHVlTWF4Lm1hcHBlZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IC8vIGNhbid0IGJlIGludmFsaWQgb3IgbWFwcGVkXG4gICAgICAvLyBjaGVjayBpZiB2YWx1ZU1pbiBhbmQgdmFsdWVNYXggYXJlIHRoZSBzYW1lXG5cblxuICAgICAgaWYgKHZhbHVlTWluLnBmVmFsdWUgPT09IHZhbHVlTWF4LnBmVmFsdWUgfHwgdmFsdWVNaW4uc3RyVmFsdWUgPT09IHZhbHVlTWF4LnN0clZhbHVlKSB7XG4gICAgICAgIHdhcm4oJ2AnICsgbmFtZSArICc6ICcgKyB2YWx1ZSArICdgIGlzIG5vdCBhIHZhbGlkIG1hcHBlciBiZWNhdXNlIHRoZSBvdXRwdXQgcmFuZ2UgaXMgemVybzsgY29udmVydGluZyB0byBgJyArIG5hbWUgKyAnOiAnICsgdmFsdWVNaW4uc3RyVmFsdWUgKyAnYCcpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZShuYW1lLCB2YWx1ZU1pbi5zdHJWYWx1ZSk7IC8vIGNhbid0IG1ha2UgbXVjaCBvZiBhIG1hcHBlciB3aXRob3V0IGEgcmFuZ2VcbiAgICAgIH0gZWxzZSBpZiAodHlwZS5jb2xvcikge1xuICAgICAgICB2YXIgYzEgPSB2YWx1ZU1pbi52YWx1ZTtcbiAgICAgICAgdmFyIGMyID0gdmFsdWVNYXgudmFsdWU7XG4gICAgICAgIHZhciBzYW1lID0gYzFbMF0gPT09IGMyWzBdIC8vIHJlZFxuICAgICAgICAmJiBjMVsxXSA9PT0gYzJbMV0gLy8gZ3JlZW5cbiAgICAgICAgJiYgYzFbMl0gPT09IGMyWzJdIC8vIGJsdWVcbiAgICAgICAgJiYgKCAvLyBvcHRpb25hbCBhbHBoYVxuICAgICAgICBjMVszXSA9PT0gYzJbM10gLy8gc2FtZSBhbHBoYSBvdXRyaWdodFxuICAgICAgICB8fCAoYzFbM10gPT0gbnVsbCB8fCBjMVszXSA9PT0gMSAvLyBmdWxsIG9wYWNpdHkgZm9yIGNvbG91ciAxP1xuICAgICAgICApICYmIChjMlszXSA9PSBudWxsIHx8IGMyWzNdID09PSAxKSAvLyBmdWxsIG9wYWNpdHkgZm9yIGNvbG91ciAyP1xuICAgICAgICApO1xuXG4gICAgICAgIGlmIChzYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IC8vIGNhbid0IG1ha2UgYSBtYXBwZXIgd2l0aG91dCBhIHJhbmdlXG5cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgdmFsdWU6IG1hcERhdGEsXG4gICAgICAgIHN0clZhbHVlOiAnJyArIHZhbHVlLFxuICAgICAgICBtYXBwZWQ6IF9tYXBwZWQsXG4gICAgICAgIGZpZWxkOiBtYXBEYXRhWzFdLFxuICAgICAgICBmaWVsZE1pbjogcGFyc2VGbG9hdChtYXBEYXRhWzJdKSxcbiAgICAgICAgLy8gbWluICYgbWF4IGFyZSBudW1lcmljXG4gICAgICAgIGZpZWxkTWF4OiBwYXJzZUZsb2F0KG1hcERhdGFbM10pLFxuICAgICAgICB2YWx1ZU1pbjogdmFsdWVNaW4udmFsdWUsXG4gICAgICAgIHZhbHVlTWF4OiB2YWx1ZU1heC52YWx1ZSxcbiAgICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3NcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHR5cGUubXVsdGlwbGUgJiYgcHJvcElzRmxhdCAhPT0gJ211bHRpcGxlJykge1xuICAgICAgdmFyIHZhbHM7XG5cbiAgICAgIGlmICh2YWx1ZUlzU3RyaW5nKSB7XG4gICAgICAgIHZhbHMgPSB2YWx1ZS5zcGxpdCgvXFxzKy8pO1xuICAgICAgfSBlbHNlIGlmIChhcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdmFscyA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFscyA9IFt2YWx1ZV07XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlLmV2ZW5NdWx0aXBsZSAmJiB2YWxzLmxlbmd0aCAlIDIgIT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWxBcnIgPSBbXTtcbiAgICAgIHZhciB1bml0c0FyciA9IFtdO1xuICAgICAgdmFyIHBmVmFsQXJyID0gW107XG4gICAgICB2YXIgc3RyVmFsID0gJyc7XG4gICAgICB2YXIgaGFzRW51bSA9IGZhbHNlO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHAgPSBzZWxmLnBhcnNlKG5hbWUsIHZhbHNbaV0sIHByb3BJc0J5cGFzcywgJ211bHRpcGxlJyk7XG4gICAgICAgIGhhc0VudW0gPSBoYXNFbnVtIHx8IHN0cmluZyhwLnZhbHVlKTtcbiAgICAgICAgdmFsQXJyLnB1c2gocC52YWx1ZSk7XG4gICAgICAgIHBmVmFsQXJyLnB1c2gocC5wZlZhbHVlICE9IG51bGwgPyBwLnBmVmFsdWUgOiBwLnZhbHVlKTtcbiAgICAgICAgdW5pdHNBcnIucHVzaChwLnVuaXRzKTtcbiAgICAgICAgc3RyVmFsICs9IChpID4gMCA/ICcgJyA6ICcnKSArIHAuc3RyVmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlLnZhbGlkYXRlICYmICF0eXBlLnZhbGlkYXRlKHZhbEFyciwgdW5pdHNBcnIpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZS5zaW5nbGVFbnVtICYmIGhhc0VudW0pIHtcbiAgICAgICAgaWYgKHZhbEFyci5sZW5ndGggPT09IDEgJiYgc3RyaW5nKHZhbEFyclswXSkpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWxBcnJbMF0sXG4gICAgICAgICAgICBzdHJWYWx1ZTogdmFsQXJyWzBdLFxuICAgICAgICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3NcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIHZhbHVlOiB2YWxBcnIsXG4gICAgICAgIHBmVmFsdWU6IHBmVmFsQXJyLFxuICAgICAgICBzdHJWYWx1ZTogc3RyVmFsLFxuICAgICAgICBieXBhc3M6IHByb3BJc0J5cGFzcyxcbiAgICAgICAgdW5pdHM6IHVuaXRzQXJyXG4gICAgICB9O1xuICAgIH0gLy8gc2V2ZXJhbCB0eXBlcyBhbHNvIGFsbG93IGVudW1zXG5cblxuICAgIHZhciBjaGVja0VudW1zID0gZnVuY3Rpb24gY2hlY2tFbnVtcygpIHtcbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB0eXBlLmVudW1zLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgZW4gPSB0eXBlLmVudW1zW19pXTtcblxuICAgICAgICBpZiAoZW4gPT09IHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBzdHJWYWx1ZTogJycgKyB2YWx1ZSxcbiAgICAgICAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9OyAvLyBjaGVjayB0aGUgdHlwZSBhbmQgcmV0dXJuIHRoZSBhcHByb3ByaWF0ZSBvYmplY3RcblxuXG4gICAgaWYgKHR5cGUubnVtYmVyKSB7XG4gICAgICB2YXIgdW5pdHM7XG4gICAgICB2YXIgaW1wbGljaXRVbml0cyA9ICdweCc7IC8vIG5vdCBzZXQgPT4gcHhcblxuICAgICAgaWYgKHR5cGUudW5pdHMpIHtcbiAgICAgICAgLy8gdXNlIHNwZWNpZmllZCB1bml0cyBpZiBzZXRcbiAgICAgICAgdW5pdHMgPSB0eXBlLnVuaXRzO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZS5pbXBsaWNpdFVuaXRzKSB7XG4gICAgICAgIGltcGxpY2l0VW5pdHMgPSB0eXBlLmltcGxpY2l0VW5pdHM7XG4gICAgICB9XG5cbiAgICAgIGlmICghdHlwZS51bml0bGVzcykge1xuICAgICAgICBpZiAodmFsdWVJc1N0cmluZykge1xuICAgICAgICAgIHZhciB1bml0c1JlZ2V4ID0gJ3B4fGVtJyArICh0eXBlLmFsbG93UGVyY2VudCA/ICd8XFxcXCUnIDogJycpO1xuXG4gICAgICAgICAgaWYgKHVuaXRzKSB7XG4gICAgICAgICAgICB1bml0c1JlZ2V4ID0gdW5pdHM7XG4gICAgICAgICAgfSAvLyBvbmx5IGFsbG93IGV4cGxpY2l0IHVuaXRzIGlmIHNvIHNldFxuXG5cbiAgICAgICAgICB2YXIgbWF0Y2ggPSB2YWx1ZS5tYXRjaCgnXignICsgbnVtYmVyICsgJykoJyArIHVuaXRzUmVnZXggKyAnKT8nICsgJyQnKTtcblxuICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgdmFsdWUgPSBtYXRjaFsxXTtcbiAgICAgICAgICAgIHVuaXRzID0gbWF0Y2hbMl0gfHwgaW1wbGljaXRVbml0cztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIXVuaXRzIHx8IHR5cGUuaW1wbGljaXRVbml0cykge1xuICAgICAgICAgIHVuaXRzID0gaW1wbGljaXRVbml0czsgLy8gaW1wbGljaXRseSBweCBpZiB1bnNwZWNpZmllZFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7IC8vIGlmIG5vdCBhIG51bWJlciBhbmQgZW51bXMgbm90IGFsbG93ZWQsIHRoZW4gdGhlIHZhbHVlIGlzIGludmFsaWRcblxuICAgICAgaWYgKGlzTmFOKHZhbHVlKSAmJiB0eXBlLmVudW1zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IC8vIGNoZWNrIGlmIHRoaXMgbnVtYmVyIHR5cGUgYWxzbyBhY2NlcHRzIHNwZWNpYWwga2V5d29yZHMgaW4gcGxhY2Ugb2YgbnVtYmVyc1xuICAgICAgLy8gKGkuZS4gYGxlZnRgLCBgYXV0b2AsIGV0YylcblxuXG4gICAgICBpZiAoaXNOYU4odmFsdWUpICYmIHR5cGUuZW51bXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YWx1ZSA9IHBhc3NlZFZhbHVlO1xuICAgICAgICByZXR1cm4gY2hlY2tFbnVtcygpO1xuICAgICAgfSAvLyBjaGVjayBpZiB2YWx1ZSBtdXN0IGJlIGFuIGludGVnZXJcblxuXG4gICAgICBpZiAodHlwZS5pbnRlZ2VyICYmICFpbnRlZ2VyKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gLy8gY2hlY2sgdmFsdWUgaXMgd2l0aGluIHJhbmdlXG5cblxuICAgICAgaWYgKHR5cGUubWluICE9PSB1bmRlZmluZWQgJiYgKHZhbHVlIDwgdHlwZS5taW4gfHwgdHlwZS5zdHJpY3RNaW4gJiYgdmFsdWUgPT09IHR5cGUubWluKSB8fCB0eXBlLm1heCAhPT0gdW5kZWZpbmVkICYmICh2YWx1ZSA+IHR5cGUubWF4IHx8IHR5cGUuc3RyaWN0TWF4ICYmIHZhbHVlID09PSB0eXBlLm1heCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXQgPSB7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgc3RyVmFsdWU6ICcnICsgdmFsdWUgKyAodW5pdHMgPyB1bml0cyA6ICcnKSxcbiAgICAgICAgdW5pdHM6IHVuaXRzLFxuICAgICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgICAgfTsgLy8gbm9ybWFsaXNlIHZhbHVlIGluIHBpeGVsc1xuXG4gICAgICBpZiAodHlwZS51bml0bGVzcyB8fCB1bml0cyAhPT0gJ3B4JyAmJiB1bml0cyAhPT0gJ2VtJykge1xuICAgICAgICByZXQucGZWYWx1ZSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0LnBmVmFsdWUgPSB1bml0cyA9PT0gJ3B4JyB8fCAhdW5pdHMgPyB2YWx1ZSA6IHRoaXMuZ2V0RW1TaXplSW5QaXhlbHMoKSAqIHZhbHVlO1xuICAgICAgfSAvLyBub3JtYWxpc2UgdmFsdWUgaW4gbXNcblxuXG4gICAgICBpZiAodW5pdHMgPT09ICdtcycgfHwgdW5pdHMgPT09ICdzJykge1xuICAgICAgICByZXQucGZWYWx1ZSA9IHVuaXRzID09PSAnbXMnID8gdmFsdWUgOiAxMDAwICogdmFsdWU7XG4gICAgICB9IC8vIG5vcm1hbGlzZSB2YWx1ZSBpbiByYWRcblxuXG4gICAgICBpZiAodW5pdHMgPT09ICdkZWcnIHx8IHVuaXRzID09PSAncmFkJykge1xuICAgICAgICByZXQucGZWYWx1ZSA9IHVuaXRzID09PSAncmFkJyA/IHZhbHVlIDogZGVnMnJhZCh2YWx1ZSk7XG4gICAgICB9IC8vIG5vcm1hbGl6ZSB2YWx1ZSBpbiAlXG5cblxuICAgICAgaWYgKHVuaXRzID09PSAnJScpIHtcbiAgICAgICAgcmV0LnBmVmFsdWUgPSB2YWx1ZSAvIDEwMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9IGVsc2UgaWYgKHR5cGUucHJvcExpc3QpIHtcbiAgICAgIHZhciBwcm9wcyA9IFtdO1xuICAgICAgdmFyIHByb3BzU3RyID0gJycgKyB2YWx1ZTtcblxuICAgICAgaWYgKHByb3BzU3RyID09PSAnbm9uZScpIDsgZWxzZSB7XG4gICAgICAgIC8vIGdvIG92ZXIgZWFjaCBwcm9wXG4gICAgICAgIHZhciBwcm9wc1NwbGl0ID0gcHJvcHNTdHIuc3BsaXQoL1xccyosXFxzKnxcXHMrLyk7XG5cbiAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgcHJvcHNTcGxpdC5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgICAgdmFyIHByb3BOYW1lID0gcHJvcHNTcGxpdFtfaTJdLnRyaW0oKTtcblxuICAgICAgICAgIGlmIChzZWxmLnByb3BlcnRpZXNbcHJvcE5hbWVdKSB7XG4gICAgICAgICAgICBwcm9wcy5wdXNoKHByb3BOYW1lKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2FybignYCcgKyBwcm9wTmFtZSArICdgIGlzIG5vdCBhIHZhbGlkIHByb3BlcnR5IG5hbWUnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvcHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgdmFsdWU6IHByb3BzLFxuICAgICAgICBzdHJWYWx1ZTogcHJvcHMubGVuZ3RoID09PSAwID8gJ25vbmUnIDogcHJvcHMuam9pbignICcpLFxuICAgICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHR5cGUuY29sb3IpIHtcbiAgICAgIHZhciB0dXBsZSA9IGNvbG9yMnR1cGxlKHZhbHVlKTtcblxuICAgICAgaWYgKCF0dXBsZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgdmFsdWU6IHR1cGxlLFxuICAgICAgICBwZlZhbHVlOiB0dXBsZSxcbiAgICAgICAgc3RyVmFsdWU6ICdyZ2IoJyArIHR1cGxlWzBdICsgJywnICsgdHVwbGVbMV0gKyAnLCcgKyB0dXBsZVsyXSArICcpJyxcbiAgICAgICAgLy8gbi5iLiBubyBzcGFjZXMgYi9jIG9mIG11bHRpcGxlIHN1cHBvcnRcbiAgICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3NcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICh0eXBlLnJlZ2V4IHx8IHR5cGUucmVnZXhlcykge1xuICAgICAgLy8gZmlyc3QgY2hlY2sgZW51bXNcbiAgICAgIGlmICh0eXBlLmVudW1zKSB7XG4gICAgICAgIHZhciBlbnVtUHJvcCA9IGNoZWNrRW51bXMoKTtcblxuICAgICAgICBpZiAoZW51bVByb3ApIHtcbiAgICAgICAgICByZXR1cm4gZW51bVByb3A7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHJlZ2V4ZXMgPSB0eXBlLnJlZ2V4ZXMgPyB0eXBlLnJlZ2V4ZXMgOiBbdHlwZS5yZWdleF07XG5cbiAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IHJlZ2V4ZXMubGVuZ3RoOyBfaTMrKykge1xuICAgICAgICB2YXIgcmVnZXggPSBuZXcgUmVnRXhwKHJlZ2V4ZXNbX2kzXSk7IC8vIG1ha2UgYSByZWdleCBmcm9tIHRoZSB0eXBlIHN0cmluZ1xuXG4gICAgICAgIHZhciBtID0gcmVnZXguZXhlYyh2YWx1ZSk7XG5cbiAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAvLyByZWdleCBtYXRjaGVzXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICB2YWx1ZTogdHlwZS5zaW5nbGVSZWdleE1hdGNoVmFsdWUgPyBtWzFdIDogbSxcbiAgICAgICAgICAgIHN0clZhbHVlOiAnJyArIHZhbHVlLFxuICAgICAgICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3NcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsOyAvLyBkaWRuJ3QgbWF0Y2ggYW55XG4gICAgfSBlbHNlIGlmICh0eXBlLnN0cmluZykge1xuICAgICAgLy8ganVzdCByZXR1cm5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIHZhbHVlOiAnJyArIHZhbHVlLFxuICAgICAgICBzdHJWYWx1ZTogJycgKyB2YWx1ZSxcbiAgICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3NcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICh0eXBlLmVudW1zKSB7XG4gICAgICAvLyBjaGVjayBlbnVtcyBsYXN0IGJlY2F1c2UgaXQncyBhIGNvbWJvIHR5cGUgaW4gb3RoZXJzXG4gICAgICByZXR1cm4gY2hlY2tFbnVtcygpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDsgLy8gbm90IGEgdHlwZSB3ZSBjYW4gaGFuZGxlXG4gICAgfVxuICB9O1xuXG4gIHZhciBTdHlsZSA9IGZ1bmN0aW9uIFN0eWxlKGN5KSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFN0eWxlKSkge1xuICAgICAgcmV0dXJuIG5ldyBTdHlsZShjeSk7XG4gICAgfVxuXG4gICAgaWYgKCFjb3JlKGN5KSkge1xuICAgICAgZXJyb3IoJ0Egc3R5bGUgbXVzdCBoYXZlIGEgY29yZSByZWZlcmVuY2UnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9wcml2YXRlID0ge1xuICAgICAgY3k6IGN5LFxuICAgICAgY29yZVN0eWxlOiB7fVxuICAgIH07XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICAgIHRoaXMucmVzZXRUb0RlZmF1bHQoKTtcbiAgfTtcblxuICB2YXIgc3R5Zm4gPSBTdHlsZS5wcm90b3R5cGU7XG5cbiAgc3R5Zm4uaW5zdGFuY2VTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICdzdHlsZSc7XG4gIH07IC8vIHJlbW92ZSBhbGwgY29udGV4dHNcblxuXG4gIHN0eWZuLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgdmFyIGN5ID0gX3AuY3k7XG4gICAgdmFyIGVsZXMgPSBjeS5lbGVtZW50cygpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzW2ldID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICBfcC5jb250ZXh0U3R5bGVzID0ge307XG4gICAgX3AucHJvcERpZmZzID0ge307XG4gICAgdGhpcy5jbGVhbkVsZW1lbnRzKGVsZXMsIHRydWUpO1xuICAgIGVsZXMuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICB2YXIgZWxlX3AgPSBlbGVbMF0uX3ByaXZhdGU7XG4gICAgICBlbGVfcC5zdHlsZURpcnR5ID0gdHJ1ZTtcbiAgICAgIGVsZV9wLmFwcGxpZWRJbml0U3R5bGUgPSBmYWxzZTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfTtcblxuICBzdHlmbi5yZXNldFRvRGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNsZWFyKCk7XG4gICAgdGhpcy5hZGREZWZhdWx0U3R5bGVzaGVldCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9OyAvLyBidWlsZHMgYSBzdHlsZSBvYmplY3QgZm9yIHRoZSAnY29yZScgc2VsZWN0b3JcblxuXG4gIHN0eWZuLmNvcmUgPSBmdW5jdGlvbiAocHJvcE5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5jb3JlU3R5bGVbcHJvcE5hbWVdIHx8IHRoaXMuZ2V0RGVmYXVsdFByb3BlcnR5KHByb3BOYW1lKTtcbiAgfTsgLy8gY3JlYXRlIGEgbmV3IGNvbnRleHQgZnJvbSB0aGUgc3BlY2lmaWVkIHNlbGVjdG9yIHN0cmluZyBhbmQgc3dpdGNoIHRvIHRoYXQgY29udGV4dFxuXG5cbiAgc3R5Zm4uc2VsZWN0b3IgPSBmdW5jdGlvbiAoc2VsZWN0b3JTdHIpIHtcbiAgICAvLyAnY29yZScgaXMgYSBzcGVjaWFsIGNhc2UgYW5kIGRvZXMgbm90IG5lZWQgYSBzZWxlY3RvclxuICAgIHZhciBzZWxlY3RvciA9IHNlbGVjdG9yU3RyID09PSAnY29yZScgPyBudWxsIDogbmV3IFNlbGVjdG9yKHNlbGVjdG9yU3RyKTtcbiAgICB2YXIgaSA9IHRoaXMubGVuZ3RoKys7IC8vIG5ldyBjb250ZXh0IG1lYW5zIG5ldyBpbmRleFxuXG4gICAgdGhpc1tpXSA9IHtcbiAgICAgIHNlbGVjdG9yOiBzZWxlY3RvcixcbiAgICAgIHByb3BlcnRpZXM6IFtdLFxuICAgICAgbWFwcGVkUHJvcGVydGllczogW10sXG4gICAgICBpbmRleDogaVxuICAgIH07XG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH07IC8vIGFkZCBvbmUgb3IgbWFueSBjc3MgcnVsZXMgdG8gdGhlIGN1cnJlbnQgY29udGV4dFxuXG5cbiAgc3R5Zm4uY3NzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcblxuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIG1hcCA9IGFyZ3NbMF07XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwcm9wID0gc2VsZi5wcm9wZXJ0aWVzW2ldO1xuICAgICAgICB2YXIgbWFwVmFsID0gbWFwW3Byb3AubmFtZV07XG5cbiAgICAgICAgaWYgKG1hcFZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbWFwVmFsID0gbWFwW2Rhc2gyY2FtZWwocHJvcC5uYW1lKV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWFwVmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLmNzc1J1bGUocHJvcC5uYW1lLCBtYXBWYWwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhcmdzLmxlbmd0aCA9PT0gMikge1xuICAgICAgdGhpcy5jc3NSdWxlKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIH0gLy8gZG8gbm90aGluZyBpZiBhcmdzIGFyZSBpbnZhbGlkXG5cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9O1xuXG4gIHN0eWZuLnN0eWxlID0gc3R5Zm4uY3NzOyAvLyBhZGQgYSBzaW5nbGUgY3NzIHJ1bGUgdG8gdGhlIGN1cnJlbnQgY29udGV4dFxuXG4gIHN0eWZuLmNzc1J1bGUgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAvLyBuYW1lLXZhbHVlIHBhaXJcbiAgICB2YXIgcHJvcGVydHkgPSB0aGlzLnBhcnNlKG5hbWUsIHZhbHVlKTsgLy8gYWRkIHByb3BlcnR5IHRvIGN1cnJlbnQgY29udGV4dCBpZiB2YWxpZFxuXG4gICAgaWYgKHByb3BlcnR5KSB7XG4gICAgICB2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTtcbiAgICAgIHRoaXNbaV0ucHJvcGVydGllcy5wdXNoKHByb3BlcnR5KTtcbiAgICAgIHRoaXNbaV0ucHJvcGVydGllc1twcm9wZXJ0eS5uYW1lXSA9IHByb3BlcnR5OyAvLyBhbGxvdyBhY2Nlc3MgYnkgbmFtZSBhcyB3ZWxsXG5cbiAgICAgIGlmIChwcm9wZXJ0eS5uYW1lLm1hdGNoKC9waWUtKFxcZCspLWJhY2tncm91bmQtc2l6ZS8pICYmIHByb3BlcnR5LnZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGUuaGFzUGllID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb3BlcnR5Lm1hcHBlZCkge1xuICAgICAgICB0aGlzW2ldLm1hcHBlZFByb3BlcnRpZXMucHVzaChwcm9wZXJ0eSk7XG4gICAgICB9IC8vIGFkZCB0byBjb3JlIHN0eWxlIGlmIG5lY2Vzc2FyeVxuXG5cbiAgICAgIHZhciBjdXJyZW50U2VsZWN0b3JJc0NvcmUgPSAhdGhpc1tpXS5zZWxlY3RvcjtcblxuICAgICAgaWYgKGN1cnJlbnRTZWxlY3RvcklzQ29yZSkge1xuICAgICAgICB0aGlzLl9wcml2YXRlLmNvcmVTdHlsZVtwcm9wZXJ0eS5uYW1lXSA9IHByb3BlcnR5O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9O1xuXG4gIHN0eWZuLmFwcGVuZCA9IGZ1bmN0aW9uIChzdHlsZSkge1xuICAgIGlmIChzdHlsZXNoZWV0KHN0eWxlKSkge1xuICAgICAgc3R5bGUuYXBwZW5kVG9TdHlsZSh0aGlzKTtcbiAgICB9IGVsc2UgaWYgKGFycmF5KHN0eWxlKSkge1xuICAgICAgdGhpcy5hcHBlbmRGcm9tSnNvbihzdHlsZSk7XG4gICAgfSBlbHNlIGlmIChzdHJpbmcoc3R5bGUpKSB7XG4gICAgICB0aGlzLmFwcGVuZEZyb21TdHJpbmcoc3R5bGUpO1xuICAgIH0gLy8geW91IHByb2JhYmx5IHdvdWxkbid0IHdhbnQgdG8gYXBwZW5kIGEgU3R5bGUsIHNpbmNlIHlvdSdkIGR1cGxpY2F0ZSB0aGUgZGVmYXVsdCBwYXJ0c1xuXG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTsgLy8gc3RhdGljIGZ1bmN0aW9uXG5cblxuICBTdHlsZS5mcm9tSnNvbiA9IGZ1bmN0aW9uIChjeSwganNvbikge1xuICAgIHZhciBzdHlsZSA9IG5ldyBTdHlsZShjeSk7XG4gICAgc3R5bGUuZnJvbUpzb24oanNvbik7XG4gICAgcmV0dXJuIHN0eWxlO1xuICB9O1xuXG4gIFN0eWxlLmZyb21TdHJpbmcgPSBmdW5jdGlvbiAoY3ksIHN0cmluZykge1xuICAgIHJldHVybiBuZXcgU3R5bGUoY3kpLmZyb21TdHJpbmcoc3RyaW5nKTtcbiAgfTtcblxuICBbc3R5Zm4kOCwgc3R5Zm4kNywgc3R5Zm4kNiwgc3R5Zm4kNSwgc3R5Zm4kNCwgc3R5Zm4kMywgc3R5Zm4kMiwgc3R5Zm4kMV0uZm9yRWFjaChmdW5jdGlvbiAocHJvcHMpIHtcbiAgICBleHRlbmQoc3R5Zm4sIHByb3BzKTtcbiAgfSk7XG4gIFN0eWxlLnR5cGVzID0gc3R5Zm4udHlwZXM7XG4gIFN0eWxlLnByb3BlcnRpZXMgPSBzdHlmbi5wcm9wZXJ0aWVzO1xuICBTdHlsZS5wcm9wZXJ0eUdyb3VwcyA9IHN0eWZuLnByb3BlcnR5R3JvdXBzO1xuICBTdHlsZS5wcm9wZXJ0eUdyb3VwTmFtZXMgPSBzdHlmbi5wcm9wZXJ0eUdyb3VwTmFtZXM7XG4gIFN0eWxlLnByb3BlcnR5R3JvdXBLZXlzID0gc3R5Zm4ucHJvcGVydHlHcm91cEtleXM7XG5cbiAgdmFyIGNvcmVmbiQyID0ge1xuICAgIHN0eWxlOiBmdW5jdGlvbiBzdHlsZShuZXdTdHlsZSkge1xuICAgICAgaWYgKG5ld1N0eWxlKSB7XG4gICAgICAgIHZhciBzID0gdGhpcy5zZXRTdHlsZShuZXdTdHlsZSk7XG4gICAgICAgIHMudXBkYXRlKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnN0eWxlO1xuICAgIH0sXG4gICAgc2V0U3R5bGU6IGZ1bmN0aW9uIHNldFN0eWxlKHN0eWxlKSB7XG4gICAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuXG4gICAgICBpZiAoc3R5bGVzaGVldChzdHlsZSkpIHtcbiAgICAgICAgX3Auc3R5bGUgPSBzdHlsZS5nZW5lcmF0ZVN0eWxlKHRoaXMpO1xuICAgICAgfSBlbHNlIGlmIChhcnJheShzdHlsZSkpIHtcbiAgICAgICAgX3Auc3R5bGUgPSBTdHlsZS5mcm9tSnNvbih0aGlzLCBzdHlsZSk7XG4gICAgICB9IGVsc2UgaWYgKHN0cmluZyhzdHlsZSkpIHtcbiAgICAgICAgX3Auc3R5bGUgPSBTdHlsZS5mcm9tU3RyaW5nKHRoaXMsIHN0eWxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9wLnN0eWxlID0gU3R5bGUodGhpcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfcC5zdHlsZTtcbiAgICB9LFxuICAgIC8vIGUuZy4gY3kuZGF0YSgpIGNoYW5nZWQgPT4gcmVjYWxjIGVsZSBtYXBwZXJzXG4gICAgdXBkYXRlU3R5bGU6IGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKCkge1xuICAgICAgdGhpcy5tdXRhYmxlRWxlbWVudHMoKS51cGRhdGVTdHlsZSgpOyAvLyBqdXN0IHNlbmQgdG8gYWxsIGVsZXNcbiAgICB9XG4gIH07XG5cbiAgdmFyIGRlZmF1bHRTZWxlY3Rpb25UeXBlID0gJ3NpbmdsZSc7XG4gIHZhciBjb3JlZm4kMSA9IHtcbiAgICBhdXRvbG9jazogZnVuY3Rpb24gYXV0b2xvY2soYm9vbCkge1xuICAgICAgaWYgKGJvb2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlLmF1dG9sb2NrID0gYm9vbCA/IHRydWUgOiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmF1dG9sb2NrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuICAgIGF1dG91bmdyYWJpZnk6IGZ1bmN0aW9uIGF1dG91bmdyYWJpZnkoYm9vbCkge1xuICAgICAgaWYgKGJvb2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlLmF1dG91bmdyYWJpZnkgPSBib29sID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuYXV0b3VuZ3JhYmlmeTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcbiAgICBhdXRvdW5zZWxlY3RpZnk6IGZ1bmN0aW9uIGF1dG91bnNlbGVjdGlmeShib29sKSB7XG4gICAgICBpZiAoYm9vbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGUuYXV0b3Vuc2VsZWN0aWZ5ID0gYm9vbCA/IHRydWUgOiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmF1dG91bnNlbGVjdGlmeTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcbiAgICBzZWxlY3Rpb25UeXBlOiBmdW5jdGlvbiBzZWxlY3Rpb25UeXBlKHNlbFR5cGUpIHtcbiAgICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICAgIGlmIChfcC5zZWxlY3Rpb25UeXBlID09IG51bGwpIHtcbiAgICAgICAgX3Auc2VsZWN0aW9uVHlwZSA9IGRlZmF1bHRTZWxlY3Rpb25UeXBlO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChzZWxUeXBlID09PSAnYWRkaXRpdmUnIHx8IHNlbFR5cGUgPT09ICdzaW5nbGUnKSB7XG4gICAgICAgICAgX3Auc2VsZWN0aW9uVHlwZSA9IHNlbFR5cGU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBfcC5zZWxlY3Rpb25UeXBlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHBhbm5pbmdFbmFibGVkOiBmdW5jdGlvbiBwYW5uaW5nRW5hYmxlZChib29sKSB7XG4gICAgICBpZiAoYm9vbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQgPSBib29sID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG4gICAgdXNlclBhbm5pbmdFbmFibGVkOiBmdW5jdGlvbiB1c2VyUGFubmluZ0VuYWJsZWQoYm9vbCkge1xuICAgICAgaWYgKGJvb2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLl9wcml2YXRlLnVzZXJQYW5uaW5nRW5hYmxlZCA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS51c2VyUGFubmluZ0VuYWJsZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG4gICAgem9vbWluZ0VuYWJsZWQ6IGZ1bmN0aW9uIHpvb21pbmdFbmFibGVkKGJvb2wpIHtcbiAgICAgIGlmIChib29sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZS56b29taW5nRW5hYmxlZCA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS56b29taW5nRW5hYmxlZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcbiAgICB1c2VyWm9vbWluZ0VuYWJsZWQ6IGZ1bmN0aW9uIHVzZXJab29taW5nRW5hYmxlZChib29sKSB7XG4gICAgICBpZiAoYm9vbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGUudXNlclpvb21pbmdFbmFibGVkID0gYm9vbCA/IHRydWUgOiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnVzZXJab29taW5nRW5hYmxlZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcbiAgICBib3hTZWxlY3Rpb25FbmFibGVkOiBmdW5jdGlvbiBib3hTZWxlY3Rpb25FbmFibGVkKGJvb2wpIHtcbiAgICAgIGlmIChib29sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZS5ib3hTZWxlY3Rpb25FbmFibGVkID0gYm9vbCA/IHRydWUgOiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmJveFNlbGVjdGlvbkVuYWJsZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG4gICAgcGFuOiBmdW5jdGlvbiBwYW4oKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHZhciBwYW4gPSB0aGlzLl9wcml2YXRlLnBhbjtcbiAgICAgIHZhciBkaW0sIHZhbCwgZGltcywgeCwgeTtcblxuICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgLy8gLnBhbigpXG4gICAgICAgICAgcmV0dXJuIHBhbjtcblxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKHN0cmluZyhhcmdzWzBdKSkge1xuICAgICAgICAgICAgLy8gLnBhbigneCcpXG4gICAgICAgICAgICBkaW0gPSBhcmdzWzBdO1xuICAgICAgICAgICAgcmV0dXJuIHBhbltkaW1dO1xuICAgICAgICAgIH0gZWxzZSBpZiAocGxhaW5PYmplY3QoYXJnc1swXSkpIHtcbiAgICAgICAgICAgIC8vIC5wYW4oeyB4OiAwLCB5OiAxMDAgfSlcbiAgICAgICAgICAgIGlmICghdGhpcy5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZCkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGltcyA9IGFyZ3NbMF07XG4gICAgICAgICAgICB4ID0gZGltcy54O1xuICAgICAgICAgICAgeSA9IGRpbXMueTtcblxuICAgICAgICAgICAgaWYgKG51bWJlciQxKHgpKSB7XG4gICAgICAgICAgICAgIHBhbi54ID0geDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG51bWJlciQxKHkpKSB7XG4gICAgICAgICAgICAgIHBhbi55ID0geTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5lbWl0KCdwYW4gdmlld3BvcnQnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgLy8gLnBhbigneCcsIDEwMClcbiAgICAgICAgICBpZiAoIXRoaXMuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRpbSA9IGFyZ3NbMF07XG4gICAgICAgICAgdmFsID0gYXJnc1sxXTtcblxuICAgICAgICAgIGlmICgoZGltID09PSAneCcgfHwgZGltID09PSAneScpICYmIG51bWJlciQxKHZhbCkpIHtcbiAgICAgICAgICAgIHBhbltkaW1dID0gdmFsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuZW1pdCgncGFuIHZpZXdwb3J0Jyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIGludmFsaWRcbiAgICAgIH1cblxuICAgICAgdGhpcy5ub3RpZnkoJ3ZpZXdwb3J0Jyk7XG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuICAgIHBhbkJ5OiBmdW5jdGlvbiBwYW5CeShhcmcwLCBhcmcxKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHZhciBwYW4gPSB0aGlzLl9wcml2YXRlLnBhbjtcbiAgICAgIHZhciBkaW0sIHZhbCwgZGltcywgeCwgeTtcblxuICAgICAgaWYgKCF0aGlzLl9wcml2YXRlLnBhbm5pbmdFbmFibGVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAocGxhaW5PYmplY3QoYXJnMCkpIHtcbiAgICAgICAgICAgIC8vIC5wYW5CeSh7IHg6IDAsIHk6IDEwMCB9KVxuICAgICAgICAgICAgZGltcyA9IGFyZ3NbMF07XG4gICAgICAgICAgICB4ID0gZGltcy54O1xuICAgICAgICAgICAgeSA9IGRpbXMueTtcblxuICAgICAgICAgICAgaWYgKG51bWJlciQxKHgpKSB7XG4gICAgICAgICAgICAgIHBhbi54ICs9IHg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChudW1iZXIkMSh5KSkge1xuICAgICAgICAgICAgICBwYW4ueSArPSB5O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3BhbiB2aWV3cG9ydCcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAvLyAucGFuQnkoJ3gnLCAxMDApXG4gICAgICAgICAgZGltID0gYXJnMDtcbiAgICAgICAgICB2YWwgPSBhcmcxO1xuXG4gICAgICAgICAgaWYgKChkaW0gPT09ICd4JyB8fCBkaW0gPT09ICd5JykgJiYgbnVtYmVyJDEodmFsKSkge1xuICAgICAgICAgICAgcGFuW2RpbV0gKz0gdmFsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuZW1pdCgncGFuIHZpZXdwb3J0Jyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIGludmFsaWRcbiAgICAgIH1cblxuICAgICAgdGhpcy5ub3RpZnkoJ3ZpZXdwb3J0Jyk7XG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuICAgIGZpdDogZnVuY3Rpb24gZml0KGVsZW1lbnRzLCBwYWRkaW5nKSB7XG4gICAgICB2YXIgdmlld3BvcnRTdGF0ZSA9IHRoaXMuZ2V0Rml0Vmlld3BvcnQoZWxlbWVudHMsIHBhZGRpbmcpO1xuXG4gICAgICBpZiAodmlld3BvcnRTdGF0ZSkge1xuICAgICAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgICAgICBfcC56b29tID0gdmlld3BvcnRTdGF0ZS56b29tO1xuICAgICAgICBfcC5wYW4gPSB2aWV3cG9ydFN0YXRlLnBhbjtcbiAgICAgICAgdGhpcy5lbWl0KCdwYW4gem9vbSB2aWV3cG9ydCcpO1xuICAgICAgICB0aGlzLm5vdGlmeSgndmlld3BvcnQnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcbiAgICBnZXRGaXRWaWV3cG9ydDogZnVuY3Rpb24gZ2V0Rml0Vmlld3BvcnQoZWxlbWVudHMsIHBhZGRpbmcpIHtcbiAgICAgIGlmIChudW1iZXIkMShlbGVtZW50cykgJiYgcGFkZGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIGVsZW1lbnRzIGlzIG9wdGlvbmFsXG4gICAgICAgIHBhZGRpbmcgPSBlbGVtZW50cztcbiAgICAgICAgZWxlbWVudHMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZCB8fCAhdGhpcy5fcHJpdmF0ZS56b29taW5nRW5hYmxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBiYjtcblxuICAgICAgaWYgKHN0cmluZyhlbGVtZW50cykpIHtcbiAgICAgICAgdmFyIHNlbCA9IGVsZW1lbnRzO1xuICAgICAgICBlbGVtZW50cyA9IHRoaXMuJChzZWwpO1xuICAgICAgfSBlbHNlIGlmIChib3VuZGluZ0JveChlbGVtZW50cykpIHtcbiAgICAgICAgLy8gYXNzdW1lIGJiXG4gICAgICAgIHZhciBiYmUgPSBlbGVtZW50cztcbiAgICAgICAgYmIgPSB7XG4gICAgICAgICAgeDE6IGJiZS54MSxcbiAgICAgICAgICB5MTogYmJlLnkxLFxuICAgICAgICAgIHgyOiBiYmUueDIsXG4gICAgICAgICAgeTI6IGJiZS55MlxuICAgICAgICB9O1xuICAgICAgICBiYi53ID0gYmIueDIgLSBiYi54MTtcbiAgICAgICAgYmIuaCA9IGJiLnkyIC0gYmIueTE7XG4gICAgICB9IGVsc2UgaWYgKCFlbGVtZW50T3JDb2xsZWN0aW9uKGVsZW1lbnRzKSkge1xuICAgICAgICBlbGVtZW50cyA9IHRoaXMubXV0YWJsZUVsZW1lbnRzKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbGVtZW50T3JDb2xsZWN0aW9uKGVsZW1lbnRzKSAmJiBlbGVtZW50cy5lbXB0eSgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gY2FuJ3QgZml0IHRvIG5vdGhpbmdcblxuXG4gICAgICBiYiA9IGJiIHx8IGVsZW1lbnRzLmJvdW5kaW5nQm94KCk7XG4gICAgICB2YXIgdyA9IHRoaXMud2lkdGgoKTtcbiAgICAgIHZhciBoID0gdGhpcy5oZWlnaHQoKTtcbiAgICAgIHZhciB6b29tO1xuICAgICAgcGFkZGluZyA9IG51bWJlciQxKHBhZGRpbmcpID8gcGFkZGluZyA6IDA7XG5cbiAgICAgIGlmICghaXNOYU4odykgJiYgIWlzTmFOKGgpICYmIHcgPiAwICYmIGggPiAwICYmICFpc05hTihiYi53KSAmJiAhaXNOYU4oYmIuaCkgJiYgYmIudyA+IDAgJiYgYmIuaCA+IDApIHtcbiAgICAgICAgem9vbSA9IE1hdGgubWluKCh3IC0gMiAqIHBhZGRpbmcpIC8gYmIudywgKGggLSAyICogcGFkZGluZykgLyBiYi5oKTsgLy8gY3JvcCB6b29tXG5cbiAgICAgICAgem9vbSA9IHpvb20gPiB0aGlzLl9wcml2YXRlLm1heFpvb20gPyB0aGlzLl9wcml2YXRlLm1heFpvb20gOiB6b29tO1xuICAgICAgICB6b29tID0gem9vbSA8IHRoaXMuX3ByaXZhdGUubWluWm9vbSA/IHRoaXMuX3ByaXZhdGUubWluWm9vbSA6IHpvb207XG4gICAgICAgIHZhciBwYW4gPSB7XG4gICAgICAgICAgLy8gbm93IHBhbiB0byBtaWRkbGVcbiAgICAgICAgICB4OiAodyAtIHpvb20gKiAoYmIueDEgKyBiYi54MikpIC8gMixcbiAgICAgICAgICB5OiAoaCAtIHpvb20gKiAoYmIueTEgKyBiYi55MikpIC8gMlxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHpvb206IHpvb20sXG4gICAgICAgICAgcGFuOiBwYW5cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH0sXG4gICAgem9vbVJhbmdlOiBmdW5jdGlvbiB6b29tUmFuZ2UobWluLCBtYXgpIHtcbiAgICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICAgIGlmIChtYXggPT0gbnVsbCkge1xuICAgICAgICB2YXIgb3B0cyA9IG1pbjtcbiAgICAgICAgbWluID0gb3B0cy5taW47XG4gICAgICAgIG1heCA9IG9wdHMubWF4O1xuICAgICAgfVxuXG4gICAgICBpZiAobnVtYmVyJDEobWluKSAmJiBudW1iZXIkMShtYXgpICYmIG1pbiA8PSBtYXgpIHtcbiAgICAgICAgX3AubWluWm9vbSA9IG1pbjtcbiAgICAgICAgX3AubWF4Wm9vbSA9IG1heDtcbiAgICAgIH0gZWxzZSBpZiAobnVtYmVyJDEobWluKSAmJiBtYXggPT09IHVuZGVmaW5lZCAmJiBtaW4gPD0gX3AubWF4Wm9vbSkge1xuICAgICAgICBfcC5taW5ab29tID0gbWluO1xuICAgICAgfSBlbHNlIGlmIChudW1iZXIkMShtYXgpICYmIG1pbiA9PT0gdW5kZWZpbmVkICYmIG1heCA+PSBfcC5taW5ab29tKSB7XG4gICAgICAgIF9wLm1heFpvb20gPSBtYXg7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgbWluWm9vbTogZnVuY3Rpb24gbWluWm9vbSh6b29tKSB7XG4gICAgICBpZiAoem9vbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLm1pblpvb207XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy56b29tUmFuZ2Uoe1xuICAgICAgICAgIG1pbjogem9vbVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG1heFpvb206IGZ1bmN0aW9uIG1heFpvb20oem9vbSkge1xuICAgICAgaWYgKHpvb20gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5tYXhab29tO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuem9vbVJhbmdlKHtcbiAgICAgICAgICBtYXg6IHpvb21cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXRab29tZWRWaWV3cG9ydDogZnVuY3Rpb24gZ2V0Wm9vbWVkVmlld3BvcnQocGFyYW1zKSB7XG4gICAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgICAgdmFyIGN1cnJlbnRQYW4gPSBfcC5wYW47XG4gICAgICB2YXIgY3VycmVudFpvb20gPSBfcC56b29tO1xuICAgICAgdmFyIHBvczsgLy8gaW4gcmVuZGVyZWQgcHhcblxuICAgICAgdmFyIHpvb207XG4gICAgICB2YXIgYmFpbCA9IGZhbHNlO1xuXG4gICAgICBpZiAoIV9wLnpvb21pbmdFbmFibGVkKSB7XG4gICAgICAgIC8vIHpvb21pbmcgZGlzYWJsZWRcbiAgICAgICAgYmFpbCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChudW1iZXIkMShwYXJhbXMpKSB7XG4gICAgICAgIC8vIHRoZW4gc2V0IHRoZSB6b29tXG4gICAgICAgIHpvb20gPSBwYXJhbXM7XG4gICAgICB9IGVsc2UgaWYgKHBsYWluT2JqZWN0KHBhcmFtcykpIHtcbiAgICAgICAgLy8gdGhlbiB6b29tIGFib3V0IGEgcG9pbnRcbiAgICAgICAgem9vbSA9IHBhcmFtcy5sZXZlbDtcblxuICAgICAgICBpZiAocGFyYW1zLnBvc2l0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICBwb3MgPSBtb2RlbFRvUmVuZGVyZWRQb3NpdGlvbihwYXJhbXMucG9zaXRpb24sIGN1cnJlbnRab29tLCBjdXJyZW50UGFuKTtcbiAgICAgICAgfSBlbHNlIGlmIChwYXJhbXMucmVuZGVyZWRQb3NpdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgcG9zID0gcGFyYW1zLnJlbmRlcmVkUG9zaXRpb247XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zICE9IG51bGwgJiYgIV9wLnBhbm5pbmdFbmFibGVkKSB7XG4gICAgICAgICAgLy8gcGFubmluZyBkaXNhYmxlZFxuICAgICAgICAgIGJhaWwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IC8vIGNyb3Agem9vbVxuXG5cbiAgICAgIHpvb20gPSB6b29tID4gX3AubWF4Wm9vbSA/IF9wLm1heFpvb20gOiB6b29tO1xuICAgICAgem9vbSA9IHpvb20gPCBfcC5taW5ab29tID8gX3AubWluWm9vbSA6IHpvb207IC8vIGNhbid0IHpvb20gd2l0aCBpbnZhbGlkIHBhcmFtc1xuXG4gICAgICBpZiAoYmFpbCB8fCAhbnVtYmVyJDEoem9vbSkgfHwgem9vbSA9PT0gY3VycmVudFpvb20gfHwgcG9zICE9IG51bGwgJiYgKCFudW1iZXIkMShwb3MueCkgfHwgIW51bWJlciQxKHBvcy55KSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmIChwb3MgIT0gbnVsbCkge1xuICAgICAgICAvLyBzZXQgem9vbSBhYm91dCBwb3NpdGlvblxuICAgICAgICB2YXIgcGFuMSA9IGN1cnJlbnRQYW47XG4gICAgICAgIHZhciB6b29tMSA9IGN1cnJlbnRab29tO1xuICAgICAgICB2YXIgem9vbTIgPSB6b29tO1xuICAgICAgICB2YXIgcGFuMiA9IHtcbiAgICAgICAgICB4OiAtem9vbTIgLyB6b29tMSAqIChwb3MueCAtIHBhbjEueCkgKyBwb3MueCxcbiAgICAgICAgICB5OiAtem9vbTIgLyB6b29tMSAqIChwb3MueSAtIHBhbjEueSkgKyBwb3MueVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHpvb21lZDogdHJ1ZSxcbiAgICAgICAgICBwYW5uZWQ6IHRydWUsXG4gICAgICAgICAgem9vbTogem9vbTIsXG4gICAgICAgICAgcGFuOiBwYW4yXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBqdXN0IHNldCB0aGUgem9vbVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHpvb21lZDogdHJ1ZSxcbiAgICAgICAgICBwYW5uZWQ6IGZhbHNlLFxuICAgICAgICAgIHpvb206IHpvb20sXG4gICAgICAgICAgcGFuOiBjdXJyZW50UGFuXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcbiAgICB6b29tOiBmdW5jdGlvbiB6b29tKHBhcmFtcykge1xuICAgICAgaWYgKHBhcmFtcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIGdldFxuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS56b29tO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc2V0XG4gICAgICAgIHZhciB2cCA9IHRoaXMuZ2V0Wm9vbWVkVmlld3BvcnQocGFyYW1zKTtcbiAgICAgICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcblxuICAgICAgICBpZiAodnAgPT0gbnVsbCB8fCAhdnAuem9vbWVkKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBfcC56b29tID0gdnAuem9vbTtcblxuICAgICAgICBpZiAodnAucGFubmVkKSB7XG4gICAgICAgICAgX3AucGFuLnggPSB2cC5wYW4ueDtcbiAgICAgICAgICBfcC5wYW4ueSA9IHZwLnBhbi55O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lbWl0KCd6b29tJyArICh2cC5wYW5uZWQgPyAnIHBhbicgOiAnJykgKyAnIHZpZXdwb3J0Jyk7XG4gICAgICAgIHRoaXMubm90aWZ5KCd2aWV3cG9ydCcpO1xuICAgICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICAgIH1cbiAgICB9LFxuICAgIHZpZXdwb3J0OiBmdW5jdGlvbiB2aWV3cG9ydChvcHRzKSB7XG4gICAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgICAgdmFyIHpvb21EZWZkID0gdHJ1ZTtcbiAgICAgIHZhciBwYW5EZWZkID0gdHJ1ZTtcbiAgICAgIHZhciBldmVudHMgPSBbXTsgLy8gdG8gdHJpZ2dlclxuXG4gICAgICB2YXIgem9vbUZhaWxlZCA9IGZhbHNlO1xuICAgICAgdmFyIHBhbkZhaWxlZCA9IGZhbHNlO1xuXG4gICAgICBpZiAoIW9wdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGlmICghbnVtYmVyJDEob3B0cy56b29tKSkge1xuICAgICAgICB6b29tRGVmZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXBsYWluT2JqZWN0KG9wdHMucGFuKSkge1xuICAgICAgICBwYW5EZWZkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICghem9vbURlZmQgJiYgIXBhbkRlZmQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGlmICh6b29tRGVmZCkge1xuICAgICAgICB2YXIgeiA9IG9wdHMuem9vbTtcblxuICAgICAgICBpZiAoeiA8IF9wLm1pblpvb20gfHwgeiA+IF9wLm1heFpvb20gfHwgIV9wLnpvb21pbmdFbmFibGVkKSB7XG4gICAgICAgICAgem9vbUZhaWxlZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3Auem9vbSA9IHo7XG4gICAgICAgICAgZXZlbnRzLnB1c2goJ3pvb20nKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocGFuRGVmZCAmJiAoIXpvb21GYWlsZWQgfHwgIW9wdHMuY2FuY2VsT25GYWlsZWRab29tKSAmJiBfcC5wYW5uaW5nRW5hYmxlZCkge1xuICAgICAgICB2YXIgcCA9IG9wdHMucGFuO1xuXG4gICAgICAgIGlmIChudW1iZXIkMShwLngpKSB7XG4gICAgICAgICAgX3AucGFuLnggPSBwLng7XG4gICAgICAgICAgcGFuRmFpbGVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobnVtYmVyJDEocC55KSkge1xuICAgICAgICAgIF9wLnBhbi55ID0gcC55O1xuICAgICAgICAgIHBhbkZhaWxlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFwYW5GYWlsZWQpIHtcbiAgICAgICAgICBldmVudHMucHVzaCgncGFuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGV2ZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGV2ZW50cy5wdXNoKCd2aWV3cG9ydCcpO1xuICAgICAgICB0aGlzLmVtaXQoZXZlbnRzLmpvaW4oJyAnKSk7XG4gICAgICAgIHRoaXMubm90aWZ5KCd2aWV3cG9ydCcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuICAgIGNlbnRlcjogZnVuY3Rpb24gY2VudGVyKGVsZW1lbnRzKSB7XG4gICAgICB2YXIgcGFuID0gdGhpcy5nZXRDZW50ZXJQYW4oZWxlbWVudHMpO1xuXG4gICAgICBpZiAocGFuKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGUucGFuID0gcGFuO1xuICAgICAgICB0aGlzLmVtaXQoJ3BhbiB2aWV3cG9ydCcpO1xuICAgICAgICB0aGlzLm5vdGlmeSgndmlld3BvcnQnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcbiAgICBnZXRDZW50ZXJQYW46IGZ1bmN0aW9uIGdldENlbnRlclBhbihlbGVtZW50cywgem9vbSkge1xuICAgICAgaWYgKCF0aGlzLl9wcml2YXRlLnBhbm5pbmdFbmFibGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0cmluZyhlbGVtZW50cykpIHtcbiAgICAgICAgdmFyIHNlbGVjdG9yID0gZWxlbWVudHM7XG4gICAgICAgIGVsZW1lbnRzID0gdGhpcy5tdXRhYmxlRWxlbWVudHMoKS5maWx0ZXIoc2VsZWN0b3IpO1xuICAgICAgfSBlbHNlIGlmICghZWxlbWVudE9yQ29sbGVjdGlvbihlbGVtZW50cykpIHtcbiAgICAgICAgZWxlbWVudHMgPSB0aGlzLm11dGFibGVFbGVtZW50cygpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWxlbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gY2FuJ3QgY2VudHJlIHBhbiB0byBub3RoaW5nXG5cblxuICAgICAgdmFyIGJiID0gZWxlbWVudHMuYm91bmRpbmdCb3goKTtcbiAgICAgIHZhciB3ID0gdGhpcy53aWR0aCgpO1xuICAgICAgdmFyIGggPSB0aGlzLmhlaWdodCgpO1xuICAgICAgem9vbSA9IHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3ByaXZhdGUuem9vbSA6IHpvb207XG4gICAgICB2YXIgcGFuID0ge1xuICAgICAgICAvLyBtaWRkbGVcbiAgICAgICAgeDogKHcgLSB6b29tICogKGJiLngxICsgYmIueDIpKSAvIDIsXG4gICAgICAgIHk6IChoIC0gem9vbSAqIChiYi55MSArIGJiLnkyKSkgLyAyXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHBhbjtcbiAgICB9LFxuICAgIHJlc2V0OiBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgIGlmICghdGhpcy5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZCB8fCAhdGhpcy5fcHJpdmF0ZS56b29taW5nRW5hYmxlZCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdGhpcy52aWV3cG9ydCh7XG4gICAgICAgIHBhbjoge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMFxuICAgICAgICB9LFxuICAgICAgICB6b29tOiAxXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG4gICAgaW52YWxpZGF0ZVNpemU6IGZ1bmN0aW9uIGludmFsaWRhdGVTaXplKCkge1xuICAgICAgdGhpcy5fcHJpdmF0ZS5zaXplQ2FjaGUgPSBudWxsO1xuICAgIH0sXG4gICAgc2l6ZTogZnVuY3Rpb24gc2l6ZSgpIHtcbiAgICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgICB2YXIgY29udGFpbmVyID0gX3AuY29udGFpbmVyO1xuICAgICAgcmV0dXJuIF9wLnNpemVDYWNoZSA9IF9wLnNpemVDYWNoZSB8fCAoY29udGFpbmVyID8gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3R5bGUgPSB3aW5kb3ckMS5nZXRDb21wdXRlZFN0eWxlKGNvbnRhaW5lcik7XG5cbiAgICAgICAgdmFyIHZhbCA9IGZ1bmN0aW9uIHZhbChuYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShuYW1lKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB3aWR0aDogY29udGFpbmVyLmNsaWVudFdpZHRoIC0gdmFsKCdwYWRkaW5nLWxlZnQnKSAtIHZhbCgncGFkZGluZy1yaWdodCcpLFxuICAgICAgICAgIGhlaWdodDogY29udGFpbmVyLmNsaWVudEhlaWdodCAtIHZhbCgncGFkZGluZy10b3AnKSAtIHZhbCgncGFkZGluZy1ib3R0b20nKVxuICAgICAgICB9O1xuICAgICAgfSgpIDoge1xuICAgICAgICAvLyBmYWxsYmFjayBpZiBubyBjb250YWluZXIgKG5vdCAwIGIvYyBjYW4gYmUgdXNlZCBmb3IgZGl2aWRpbmcgZXRjKVxuICAgICAgICB3aWR0aDogMSxcbiAgICAgICAgaGVpZ2h0OiAxXG4gICAgICB9KTtcbiAgICB9LFxuICAgIHdpZHRoOiBmdW5jdGlvbiB3aWR0aCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNpemUoKS53aWR0aDtcbiAgICB9LFxuICAgIGhlaWdodDogZnVuY3Rpb24gaGVpZ2h0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2l6ZSgpLmhlaWdodDtcbiAgICB9LFxuICAgIGV4dGVudDogZnVuY3Rpb24gZXh0ZW50KCkge1xuICAgICAgdmFyIHBhbiA9IHRoaXMuX3ByaXZhdGUucGFuO1xuICAgICAgdmFyIHpvb20gPSB0aGlzLl9wcml2YXRlLnpvb207XG4gICAgICB2YXIgcmIgPSB0aGlzLnJlbmRlcmVkRXh0ZW50KCk7XG4gICAgICB2YXIgYiA9IHtcbiAgICAgICAgeDE6IChyYi54MSAtIHBhbi54KSAvIHpvb20sXG4gICAgICAgIHgyOiAocmIueDIgLSBwYW4ueCkgLyB6b29tLFxuICAgICAgICB5MTogKHJiLnkxIC0gcGFuLnkpIC8gem9vbSxcbiAgICAgICAgeTI6IChyYi55MiAtIHBhbi55KSAvIHpvb21cbiAgICAgIH07XG4gICAgICBiLncgPSBiLngyIC0gYi54MTtcbiAgICAgIGIuaCA9IGIueTIgLSBiLnkxO1xuICAgICAgcmV0dXJuIGI7XG4gICAgfSxcbiAgICByZW5kZXJlZEV4dGVudDogZnVuY3Rpb24gcmVuZGVyZWRFeHRlbnQoKSB7XG4gICAgICB2YXIgd2lkdGggPSB0aGlzLndpZHRoKCk7XG4gICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5oZWlnaHQoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHgxOiAwLFxuICAgICAgICB5MTogMCxcbiAgICAgICAgeDI6IHdpZHRoLFxuICAgICAgICB5MjogaGVpZ2h0LFxuICAgICAgICB3OiB3aWR0aCxcbiAgICAgICAgaDogaGVpZ2h0XG4gICAgICB9O1xuICAgIH0sXG4gICAgbXVsdGlDbGlja0RlYm91bmNlVGltZTogZnVuY3Rpb24gbXVsdGlDbGlja0RlYm91bmNlVGltZShfaW50KSB7XG4gICAgICBpZiAoX2ludCkgdGhpcy5fcHJpdmF0ZS5tdWx0aUNsaWNrRGVib3VuY2VUaW1lID0gX2ludDtlbHNlIHJldHVybiB0aGlzLl9wcml2YXRlLm11bHRpQ2xpY2tEZWJvdW5jZVRpbWU7XG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9XG4gIH07IC8vIGFsaWFzZXNcblxuICBjb3JlZm4kMS5jZW50cmUgPSBjb3JlZm4kMS5jZW50ZXI7IC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cbiAgY29yZWZuJDEuYXV0b2xvY2tOb2RlcyA9IGNvcmVmbiQxLmF1dG9sb2NrO1xuICBjb3JlZm4kMS5hdXRvdW5ncmFiaWZ5Tm9kZXMgPSBjb3JlZm4kMS5hdXRvdW5ncmFiaWZ5O1xuXG4gIHZhciBmbiA9IHtcbiAgICBkYXRhOiBkZWZpbmUuZGF0YSh7XG4gICAgICBmaWVsZDogJ2RhdGEnLFxuICAgICAgYmluZGluZ0V2ZW50OiAnZGF0YScsXG4gICAgICBhbGxvd0JpbmRpbmc6IHRydWUsXG4gICAgICBhbGxvd1NldHRpbmc6IHRydWUsXG4gICAgICBzZXR0aW5nRXZlbnQ6ICdkYXRhJyxcbiAgICAgIHNldHRpbmdUcmlnZ2Vyc0V2ZW50OiB0cnVlLFxuICAgICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgICAgYWxsb3dHZXR0aW5nOiB0cnVlLFxuICAgICAgdXBkYXRlU3R5bGU6IHRydWVcbiAgICB9KSxcbiAgICByZW1vdmVEYXRhOiBkZWZpbmUucmVtb3ZlRGF0YSh7XG4gICAgICBmaWVsZDogJ2RhdGEnLFxuICAgICAgZXZlbnQ6ICdkYXRhJyxcbiAgICAgIHRyaWdnZXJGbk5hbWU6ICd0cmlnZ2VyJyxcbiAgICAgIHRyaWdnZXJFdmVudDogdHJ1ZSxcbiAgICAgIHVwZGF0ZVN0eWxlOiB0cnVlXG4gICAgfSksXG4gICAgc2NyYXRjaDogZGVmaW5lLmRhdGEoe1xuICAgICAgZmllbGQ6ICdzY3JhdGNoJyxcbiAgICAgIGJpbmRpbmdFdmVudDogJ3NjcmF0Y2gnLFxuICAgICAgYWxsb3dCaW5kaW5nOiB0cnVlLFxuICAgICAgYWxsb3dTZXR0aW5nOiB0cnVlLFxuICAgICAgc2V0dGluZ0V2ZW50OiAnc2NyYXRjaCcsXG4gICAgICBzZXR0aW5nVHJpZ2dlcnNFdmVudDogdHJ1ZSxcbiAgICAgIHRyaWdnZXJGbk5hbWU6ICd0cmlnZ2VyJyxcbiAgICAgIGFsbG93R2V0dGluZzogdHJ1ZSxcbiAgICAgIHVwZGF0ZVN0eWxlOiB0cnVlXG4gICAgfSksXG4gICAgcmVtb3ZlU2NyYXRjaDogZGVmaW5lLnJlbW92ZURhdGEoe1xuICAgICAgZmllbGQ6ICdzY3JhdGNoJyxcbiAgICAgIGV2ZW50OiAnc2NyYXRjaCcsXG4gICAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgICB0cmlnZ2VyRXZlbnQ6IHRydWUsXG4gICAgICB1cGRhdGVTdHlsZTogdHJ1ZVxuICAgIH0pXG4gIH07IC8vIGFsaWFzZXNcblxuICBmbi5hdHRyID0gZm4uZGF0YTtcbiAgZm4ucmVtb3ZlQXR0ciA9IGZuLnJlbW92ZURhdGE7XG5cbiAgdmFyIENvcmUgPSBmdW5jdGlvbiBDb3JlKG9wdHMpIHtcbiAgICB2YXIgY3kgPSB0aGlzO1xuICAgIG9wdHMgPSBleHRlbmQoe30sIG9wdHMpO1xuICAgIHZhciBjb250YWluZXIgPSBvcHRzLmNvbnRhaW5lcjsgLy8gYWxsb3cgZm9yIHBhc3NpbmcgYSB3cmFwcGVkIGpxdWVyeSBvYmplY3RcbiAgICAvLyBlLmcuIGN5dG9zY2FwZSh7IGNvbnRhaW5lcjogJCgnI2N5JykgfSlcblxuICAgIGlmIChjb250YWluZXIgJiYgIWh0bWxFbGVtZW50KGNvbnRhaW5lcikgJiYgaHRtbEVsZW1lbnQoY29udGFpbmVyWzBdKSkge1xuICAgICAgY29udGFpbmVyID0gY29udGFpbmVyWzBdO1xuICAgIH1cblxuICAgIHZhciByZWcgPSBjb250YWluZXIgPyBjb250YWluZXIuX2N5cmVnIDogbnVsbDsgLy8gZS5nLiBhbHJlYWR5IHJlZ2lzdGVyZWQgc29tZSBpbmZvIChlLmcuIHJlYWRpZXMpIHZpYSBqcXVlcnlcblxuICAgIHJlZyA9IHJlZyB8fCB7fTtcblxuICAgIGlmIChyZWcgJiYgcmVnLmN5KSB7XG4gICAgICByZWcuY3kuZGVzdHJveSgpO1xuICAgICAgcmVnID0ge307IC8vIG9sZCBpbnN0YW5jZSA9PiByZXBsYWNlIHJlZyBjb21wbGV0ZWx5XG4gICAgfVxuXG4gICAgdmFyIHJlYWRpZXMgPSByZWcucmVhZGllcyA9IHJlZy5yZWFkaWVzIHx8IFtdO1xuXG4gICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgY29udGFpbmVyLl9jeXJlZyA9IHJlZztcbiAgICB9IC8vIG1ha2Ugc3VyZSBjb250YWluZXIgYXNzb2MnZCByZWcgcG9pbnRzIHRvIHRoaXMgY3lcblxuXG4gICAgcmVnLmN5ID0gY3k7XG4gICAgdmFyIGhlYWQgPSB3aW5kb3ckMSAhPT0gdW5kZWZpbmVkICYmIGNvbnRhaW5lciAhPT0gdW5kZWZpbmVkICYmICFvcHRzLmhlYWRsZXNzO1xuICAgIHZhciBvcHRpb25zID0gb3B0cztcbiAgICBvcHRpb25zLmxheW91dCA9IGV4dGVuZCh7XG4gICAgICBuYW1lOiBoZWFkID8gJ2dyaWQnIDogJ251bGwnXG4gICAgfSwgb3B0aW9ucy5sYXlvdXQpO1xuICAgIG9wdGlvbnMucmVuZGVyZXIgPSBleHRlbmQoe1xuICAgICAgbmFtZTogaGVhZCA/ICdjYW52YXMnIDogJ251bGwnXG4gICAgfSwgb3B0aW9ucy5yZW5kZXJlcik7XG5cbiAgICB2YXIgZGVmVmFsID0gZnVuY3Rpb24gZGVmVmFsKGRlZiwgdmFsLCBhbHRWYWwpIHtcbiAgICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgfSBlbHNlIGlmIChhbHRWYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gYWx0VmFsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRlZjtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZSA9IHtcbiAgICAgIGNvbnRhaW5lcjogY29udGFpbmVyLFxuICAgICAgLy8gaHRtbCBkb20gZWxlIGNvbnRhaW5lclxuICAgICAgcmVhZHk6IGZhbHNlLFxuICAgICAgLy8gd2hldGhlciByZWFkeSBoYXMgYmVlbiB0cmlnZ2VyZWRcbiAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAvLyBjYWNoZWQgb3B0aW9uc1xuICAgICAgZWxlbWVudHM6IG5ldyBDb2xsZWN0aW9uKHRoaXMpLFxuICAgICAgLy8gZWxlbWVudHMgaW4gdGhlIGdyYXBoXG4gICAgICBsaXN0ZW5lcnM6IFtdLFxuICAgICAgLy8gbGlzdCBvZiBsaXN0ZW5lcnNcbiAgICAgIGFuaUVsZXM6IG5ldyBDb2xsZWN0aW9uKHRoaXMpLFxuICAgICAgLy8gZWxlbWVudHMgYmVpbmcgYW5pbWF0ZWRcbiAgICAgIGRhdGE6IG9wdGlvbnMuZGF0YSB8fCB7fSxcbiAgICAgIC8vIGRhdGEgZm9yIHRoZSBjb3JlXG4gICAgICBzY3JhdGNoOiB7fSxcbiAgICAgIC8vIHNjcmF0Y2ggb2JqZWN0IGZvciBjb3JlXG4gICAgICBsYXlvdXQ6IG51bGwsXG4gICAgICByZW5kZXJlcjogbnVsbCxcbiAgICAgIGRlc3Ryb3llZDogZmFsc2UsXG4gICAgICAvLyB3aGV0aGVyIGRlc3Ryb3kgd2FzIGNhbGxlZFxuICAgICAgbm90aWZpY2F0aW9uc0VuYWJsZWQ6IHRydWUsXG4gICAgICAvLyB3aGV0aGVyIG5vdGlmaWNhdGlvbnMgYXJlIHNlbnQgdG8gdGhlIHJlbmRlcmVyXG4gICAgICBtaW5ab29tOiAxZS01MCxcbiAgICAgIG1heFpvb206IDFlNTAsXG4gICAgICB6b29taW5nRW5hYmxlZDogZGVmVmFsKHRydWUsIG9wdGlvbnMuem9vbWluZ0VuYWJsZWQpLFxuICAgICAgdXNlclpvb21pbmdFbmFibGVkOiBkZWZWYWwodHJ1ZSwgb3B0aW9ucy51c2VyWm9vbWluZ0VuYWJsZWQpLFxuICAgICAgcGFubmluZ0VuYWJsZWQ6IGRlZlZhbCh0cnVlLCBvcHRpb25zLnBhbm5pbmdFbmFibGVkKSxcbiAgICAgIHVzZXJQYW5uaW5nRW5hYmxlZDogZGVmVmFsKHRydWUsIG9wdGlvbnMudXNlclBhbm5pbmdFbmFibGVkKSxcbiAgICAgIGJveFNlbGVjdGlvbkVuYWJsZWQ6IGRlZlZhbCh0cnVlLCBvcHRpb25zLmJveFNlbGVjdGlvbkVuYWJsZWQpLFxuICAgICAgYXV0b2xvY2s6IGRlZlZhbChmYWxzZSwgb3B0aW9ucy5hdXRvbG9jaywgb3B0aW9ucy5hdXRvbG9ja05vZGVzKSxcbiAgICAgIGF1dG91bmdyYWJpZnk6IGRlZlZhbChmYWxzZSwgb3B0aW9ucy5hdXRvdW5ncmFiaWZ5LCBvcHRpb25zLmF1dG91bmdyYWJpZnlOb2RlcyksXG4gICAgICBhdXRvdW5zZWxlY3RpZnk6IGRlZlZhbChmYWxzZSwgb3B0aW9ucy5hdXRvdW5zZWxlY3RpZnkpLFxuICAgICAgc3R5bGVFbmFibGVkOiBvcHRpb25zLnN0eWxlRW5hYmxlZCA9PT0gdW5kZWZpbmVkID8gaGVhZCA6IG9wdGlvbnMuc3R5bGVFbmFibGVkLFxuICAgICAgem9vbTogbnVtYmVyJDEob3B0aW9ucy56b29tKSA/IG9wdGlvbnMuem9vbSA6IDEsXG4gICAgICBwYW46IHtcbiAgICAgICAgeDogcGxhaW5PYmplY3Qob3B0aW9ucy5wYW4pICYmIG51bWJlciQxKG9wdGlvbnMucGFuLngpID8gb3B0aW9ucy5wYW4ueCA6IDAsXG4gICAgICAgIHk6IHBsYWluT2JqZWN0KG9wdGlvbnMucGFuKSAmJiBudW1iZXIkMShvcHRpb25zLnBhbi55KSA/IG9wdGlvbnMucGFuLnkgOiAwXG4gICAgICB9LFxuICAgICAgYW5pbWF0aW9uOiB7XG4gICAgICAgIC8vIG9iamVjdCBmb3IgY3VycmVudGx5LXJ1bm5pbmcgYW5pbWF0aW9uc1xuICAgICAgICBjdXJyZW50OiBbXSxcbiAgICAgICAgcXVldWU6IFtdXG4gICAgICB9LFxuICAgICAgaGFzQ29tcG91bmROb2RlczogZmFsc2UsXG4gICAgICBtdWx0aUNsaWNrRGVib3VuY2VUaW1lOiBkZWZWYWwoMjUwLCBvcHRpb25zLm11bHRpQ2xpY2tEZWJvdW5jZVRpbWUpXG4gICAgfTtcblxuICAgIHRoaXMuY3JlYXRlRW1pdHRlcigpOyAvLyBzZXQgc2VsZWN0aW9uIHR5cGVcblxuICAgIHRoaXMuc2VsZWN0aW9uVHlwZShvcHRpb25zLnNlbGVjdGlvblR5cGUpOyAvLyBpbml0IHpvb20gYm91bmRzXG5cbiAgICB0aGlzLnpvb21SYW5nZSh7XG4gICAgICBtaW46IG9wdGlvbnMubWluWm9vbSxcbiAgICAgIG1heDogb3B0aW9ucy5tYXhab29tXG4gICAgfSk7XG5cbiAgICB2YXIgbG9hZEV4dERhdGEgPSBmdW5jdGlvbiBsb2FkRXh0RGF0YShleHREYXRhLCBuZXh0KSB7XG4gICAgICB2YXIgYW55SXNQcm9taXNlID0gZXh0RGF0YS5zb21lKHByb21pc2UpO1xuXG4gICAgICBpZiAoYW55SXNQcm9taXNlKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlJDEuYWxsKGV4dERhdGEpLnRoZW4obmV4dCk7IC8vIGxvYWQgYWxsIGRhdGEgYXN5bmNocm9ub3VzbHksIHRoZW4gZXhlYyByZXN0IG9mIGluaXRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHQoZXh0RGF0YSk7IC8vIGV4ZWMgc3luY2hyb25vdXNseSBmb3IgY29udmVuaWVuY2VcbiAgICAgIH1cbiAgICB9OyAvLyBzdGFydCB3aXRoIHRoZSBkZWZhdWx0IHN0eWxlc2hlZXQgc28gd2UgaGF2ZSBzb21ldGhpbmcgYmVmb3JlIGxvYWRpbmcgYW4gZXh0ZXJuYWwgc3R5bGVzaGVldFxuXG5cbiAgICBpZiAoX3Auc3R5bGVFbmFibGVkKSB7XG4gICAgICBjeS5zZXRTdHlsZShbXSk7XG4gICAgfSAvLyBjcmVhdGUgdGhlIHJlbmRlcmVyXG5cblxuICAgIHZhciByZW5kZXJlck9wdGlvbnMgPSBleHRlbmQoe30sIG9wdGlvbnMsIG9wdGlvbnMucmVuZGVyZXIpOyAvLyBhbGxvdyByZW5kZXJpbmcgaGludHMgaW4gdG9wIGxldmVsIG9wdGlvbnNcblxuICAgIGN5LmluaXRSZW5kZXJlcihyZW5kZXJlck9wdGlvbnMpO1xuXG4gICAgdmFyIHNldEVsZXNBbmRMYXlvdXQgPSBmdW5jdGlvbiBzZXRFbGVzQW5kTGF5b3V0KGVsZW1lbnRzLCBvbmxvYWQsIG9uZG9uZSkge1xuICAgICAgY3kubm90aWZpY2F0aW9ucyhmYWxzZSk7IC8vIHJlbW92ZSBvbGQgZWxlbWVudHNcblxuICAgICAgdmFyIG9sZEVsZXMgPSBjeS5tdXRhYmxlRWxlbWVudHMoKTtcblxuICAgICAgaWYgKG9sZEVsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBvbGRFbGVzLnJlbW92ZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWxlbWVudHMgIT0gbnVsbCkge1xuICAgICAgICBpZiAocGxhaW5PYmplY3QoZWxlbWVudHMpIHx8IGFycmF5KGVsZW1lbnRzKSkge1xuICAgICAgICAgIGN5LmFkZChlbGVtZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY3kub25lKCdsYXlvdXRyZWFkeScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGN5Lm5vdGlmaWNhdGlvbnModHJ1ZSk7XG4gICAgICAgIGN5LmVtaXQoZSk7IC8vIHdlIG1pc3NlZCB0aGlzIGV2ZW50IGJ5IHR1cm5pbmcgbm90aWZpY2F0aW9ucyBvZmYsIHNvIHBhc3MgaXQgb25cblxuICAgICAgICBjeS5vbmUoJ2xvYWQnLCBvbmxvYWQpO1xuICAgICAgICBjeS5lbWl0QW5kTm90aWZ5KCdsb2FkJyk7XG4gICAgICB9KS5vbmUoJ2xheW91dHN0b3AnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN5Lm9uZSgnZG9uZScsIG9uZG9uZSk7XG4gICAgICAgIGN5LmVtaXQoJ2RvbmUnKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIGxheW91dE9wdHMgPSBleHRlbmQoe30sIGN5Ll9wcml2YXRlLm9wdGlvbnMubGF5b3V0KTtcbiAgICAgIGxheW91dE9wdHMuZWxlcyA9IGN5LmVsZW1lbnRzKCk7XG4gICAgICBjeS5sYXlvdXQobGF5b3V0T3B0cykucnVuKCk7XG4gICAgfTtcblxuICAgIGxvYWRFeHREYXRhKFtvcHRpb25zLnN0eWxlLCBvcHRpb25zLmVsZW1lbnRzXSwgZnVuY3Rpb24gKHRoZW5zKSB7XG4gICAgICB2YXIgaW5pdFN0eWxlID0gdGhlbnNbMF07XG4gICAgICB2YXIgaW5pdEVsZXMgPSB0aGVuc1sxXTsgLy8gaW5pdCBzdHlsZVxuXG4gICAgICBpZiAoX3Auc3R5bGVFbmFibGVkKSB7XG4gICAgICAgIGN5LnN0eWxlKCkuYXBwZW5kKGluaXRTdHlsZSk7XG4gICAgICB9IC8vIGluaXRpYWwgbG9hZFxuXG5cbiAgICAgIHNldEVsZXNBbmRMYXlvdXQoaW5pdEVsZXMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gb25yZWFkeVxuICAgICAgICBjeS5zdGFydEFuaW1hdGlvbkxvb3AoKTtcbiAgICAgICAgX3AucmVhZHkgPSB0cnVlOyAvLyBpZiBhIHJlYWR5IGNhbGxiYWNrIGlzIHNwZWNpZmllZCBhcyBhbiBvcHRpb24sIHRoZSBiaW5kIGl0XG5cbiAgICAgICAgaWYgKGZuJDYob3B0aW9ucy5yZWFkeSkpIHtcbiAgICAgICAgICBjeS5vbigncmVhZHknLCBvcHRpb25zLnJlYWR5KTtcbiAgICAgICAgfSAvLyBiaW5kIGFsbCB0aGUgcmVhZHkgaGFuZGxlcnMgcmVnaXN0ZXJlZCBiZWZvcmUgY3JlYXRpbmcgdGhpcyBpbnN0YW5jZVxuXG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWFkaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGZuID0gcmVhZGllc1tpXTtcbiAgICAgICAgICBjeS5vbigncmVhZHknLCBmbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVnKSB7XG4gICAgICAgICAgcmVnLnJlYWRpZXMgPSBbXTtcbiAgICAgICAgfSAvLyBjbGVhciBiL2Mgd2UndmUgYm91bmQgdGhlbSBhbGwgYW5kIGRvbid0IHdhbnQgdG8ga2VlcCBpdCBhcm91bmQgaW4gY2FzZSBhIG5ldyBjb3JlIHVzZXMgdGhlIHNhbWUgZGl2IGV0Y1xuXG5cbiAgICAgICAgY3kuZW1pdCgncmVhZHknKTtcbiAgICAgIH0sIG9wdGlvbnMuZG9uZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGNvcmVmbiA9IENvcmUucHJvdG90eXBlOyAvLyBzaG9ydCBhbGlhc1xuXG4gIGV4dGVuZChjb3JlZm4sIHtcbiAgICBpbnN0YW5jZVN0cmluZzogZnVuY3Rpb24gaW5zdGFuY2VTdHJpbmcoKSB7XG4gICAgICByZXR1cm4gJ2NvcmUnO1xuICAgIH0sXG4gICAgaXNSZWFkeTogZnVuY3Rpb24gaXNSZWFkeSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnJlYWR5O1xuICAgIH0sXG4gICAgZGVzdHJveWVkOiBmdW5jdGlvbiBkZXN0cm95ZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5kZXN0cm95ZWQ7XG4gICAgfSxcbiAgICByZWFkeTogZnVuY3Rpb24gcmVhZHkoZm4pIHtcbiAgICAgIGlmICh0aGlzLmlzUmVhZHkoKSkge1xuICAgICAgICB0aGlzLmVtaXR0ZXIoKS5lbWl0KCdyZWFkeScsIFtdLCBmbik7IC8vIGp1c3QgY2FsbHMgZm4gYXMgdGhvdWdoIHRyaWdnZXJlZCB2aWEgcmVhZHkgZXZlbnRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub24oJ3JlYWR5JywgZm4pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB2YXIgY3kgPSB0aGlzO1xuICAgICAgaWYgKGN5LmRlc3Ryb3llZCgpKSByZXR1cm47XG4gICAgICBjeS5zdG9wQW5pbWF0aW9uTG9vcCgpO1xuICAgICAgY3kuZGVzdHJveVJlbmRlcmVyKCk7XG4gICAgICB0aGlzLmVtaXQoJ2Rlc3Ryb3knKTtcbiAgICAgIGN5Ll9wcml2YXRlLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICByZXR1cm4gY3k7XG4gICAgfSxcbiAgICBoYXNFbGVtZW50V2l0aElkOiBmdW5jdGlvbiBoYXNFbGVtZW50V2l0aElkKGlkKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5lbGVtZW50cy5oYXNFbGVtZW50V2l0aElkKGlkKTtcbiAgICB9LFxuICAgIGdldEVsZW1lbnRCeUlkOiBmdW5jdGlvbiBnZXRFbGVtZW50QnlJZChpZCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuZWxlbWVudHMuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICAgIH0sXG4gICAgaGFzQ29tcG91bmROb2RlczogZnVuY3Rpb24gaGFzQ29tcG91bmROb2RlcygpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmhhc0NvbXBvdW5kTm9kZXM7XG4gICAgfSxcbiAgICBoZWFkbGVzczogZnVuY3Rpb24gaGVhZGxlc3MoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5yZW5kZXJlci5pc0hlYWRsZXNzKCk7XG4gICAgfSxcbiAgICBzdHlsZUVuYWJsZWQ6IGZ1bmN0aW9uIHN0eWxlRW5hYmxlZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnN0eWxlRW5hYmxlZDtcbiAgICB9LFxuICAgIGFkZFRvUG9vbDogZnVuY3Rpb24gYWRkVG9Qb29sKGVsZXMpIHtcbiAgICAgIHRoaXMuX3ByaXZhdGUuZWxlbWVudHMubWVyZ2UoZWxlcyk7XG5cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG4gICAgcmVtb3ZlRnJvbVBvb2w6IGZ1bmN0aW9uIHJlbW92ZUZyb21Qb29sKGVsZXMpIHtcbiAgICAgIHRoaXMuX3ByaXZhdGUuZWxlbWVudHMudW5tZXJnZShlbGVzKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBjb250YWluZXI6IGZ1bmN0aW9uIGNvbnRhaW5lcigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmNvbnRhaW5lciB8fCBudWxsO1xuICAgIH0sXG4gICAgbW91bnQ6IGZ1bmN0aW9uIG1vdW50KGNvbnRhaW5lcikge1xuICAgICAgaWYgKGNvbnRhaW5lciA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGN5ID0gdGhpcztcbiAgICAgIHZhciBfcCA9IGN5Ll9wcml2YXRlO1xuICAgICAgdmFyIG9wdGlvbnMgPSBfcC5vcHRpb25zO1xuXG4gICAgICBpZiAoIWh0bWxFbGVtZW50KGNvbnRhaW5lcikgJiYgaHRtbEVsZW1lbnQoY29udGFpbmVyWzBdKSkge1xuICAgICAgICBjb250YWluZXIgPSBjb250YWluZXJbMF07XG4gICAgICB9XG5cbiAgICAgIGN5LnN0b3BBbmltYXRpb25Mb29wKCk7XG4gICAgICBjeS5kZXN0cm95UmVuZGVyZXIoKTtcbiAgICAgIF9wLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgIF9wLnN0eWxlRW5hYmxlZCA9IHRydWU7XG4gICAgICBjeS5pbnZhbGlkYXRlU2l6ZSgpO1xuICAgICAgY3kuaW5pdFJlbmRlcmVyKGV4dGVuZCh7fSwgb3B0aW9ucywgb3B0aW9ucy5yZW5kZXJlciwge1xuICAgICAgICAvLyBhbGxvdyBjdXN0b20gcmVuZGVyZXIgbmFtZSB0byBiZSByZS11c2VkLCBvdGhlcndpc2UgdXNlIGNhbnZhc1xuICAgICAgICBuYW1lOiBvcHRpb25zLnJlbmRlcmVyLm5hbWUgPT09ICdudWxsJyA/ICdjYW52YXMnIDogb3B0aW9ucy5yZW5kZXJlci5uYW1lXG4gICAgICB9KSk7XG4gICAgICBjeS5zdGFydEFuaW1hdGlvbkxvb3AoKTtcbiAgICAgIGN5LnN0eWxlKG9wdGlvbnMuc3R5bGUpO1xuICAgICAgY3kuZW1pdCgnbW91bnQnKTtcbiAgICAgIHJldHVybiBjeTtcbiAgICB9LFxuICAgIHVubW91bnQ6IGZ1bmN0aW9uIHVubW91bnQoKSB7XG4gICAgICB2YXIgY3kgPSB0aGlzO1xuICAgICAgY3kuc3RvcEFuaW1hdGlvbkxvb3AoKTtcbiAgICAgIGN5LmRlc3Ryb3lSZW5kZXJlcigpO1xuICAgICAgY3kuaW5pdFJlbmRlcmVyKHtcbiAgICAgICAgbmFtZTogJ251bGwnXG4gICAgICB9KTtcbiAgICAgIGN5LmVtaXQoJ3VubW91bnQnKTtcbiAgICAgIHJldHVybiBjeTtcbiAgICB9LFxuICAgIG9wdGlvbnM6IGZ1bmN0aW9uIG9wdGlvbnMoKSB7XG4gICAgICByZXR1cm4gY29weSh0aGlzLl9wcml2YXRlLm9wdGlvbnMpO1xuICAgIH0sXG4gICAganNvbjogZnVuY3Rpb24ganNvbihvYmopIHtcbiAgICAgIHZhciBjeSA9IHRoaXM7XG4gICAgICB2YXIgX3AgPSBjeS5fcHJpdmF0ZTtcbiAgICAgIHZhciBlbGVzID0gY3kubXV0YWJsZUVsZW1lbnRzKCk7XG5cbiAgICAgIHZhciBnZXRGcmVzaFJlZiA9IGZ1bmN0aW9uIGdldEZyZXNoUmVmKGVsZSkge1xuICAgICAgICByZXR1cm4gY3kuZ2V0RWxlbWVudEJ5SWQoZWxlLmlkKCkpO1xuICAgICAgfTtcblxuICAgICAgaWYgKHBsYWluT2JqZWN0KG9iaikpIHtcbiAgICAgICAgLy8gc2V0XG4gICAgICAgIGN5LnN0YXJ0QmF0Y2goKTtcblxuICAgICAgICBpZiAob2JqLmVsZW1lbnRzKSB7XG4gICAgICAgICAgdmFyIGlkSW5Kc29uID0ge307XG5cbiAgICAgICAgICB2YXIgdXBkYXRlRWxlcyA9IGZ1bmN0aW9uIHVwZGF0ZUVsZXMoanNvbnMsIGdyKSB7XG4gICAgICAgICAgICB2YXIgdG9BZGQgPSBbXTtcbiAgICAgICAgICAgIHZhciB0b01vZCA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGpzb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBqc29uID0ganNvbnNbaV07XG5cbiAgICAgICAgICAgICAgaWYgKCFqc29uLmRhdGEuaWQpIHtcbiAgICAgICAgICAgICAgICB3YXJuKCdjeS5qc29uKCkgY2Fubm90IGhhbmRsZSBlbGVtZW50cyB3aXRob3V0IGFuIElEIGF0dHJpYnV0ZScpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIGlkID0gJycgKyBqc29uLmRhdGEuaWQ7IC8vIGlkIG11c3QgYmUgc3RyaW5nXG5cbiAgICAgICAgICAgICAgdmFyIGVsZSA9IGN5LmdldEVsZW1lbnRCeUlkKGlkKTtcbiAgICAgICAgICAgICAgaWRJbkpzb25baWRdID0gdHJ1ZTtcblxuICAgICAgICAgICAgICBpZiAoZWxlLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIGV4aXN0aW5nIGVsZW1lbnQgc2hvdWxkIGJlIHVwZGF0ZWRcbiAgICAgICAgICAgICAgICB0b01vZC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIGVsZTogZWxlLFxuICAgICAgICAgICAgICAgICAganNvbjoganNvblxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSBzaG91bGQgYmUgYWRkZWRcbiAgICAgICAgICAgICAgICBpZiAoZ3IpIHtcbiAgICAgICAgICAgICAgICAgIGpzb24uZ3JvdXAgPSBncjtcbiAgICAgICAgICAgICAgICAgIHRvQWRkLnB1c2goanNvbik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRvQWRkLnB1c2goanNvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN5LmFkZCh0b0FkZCk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB0b01vZC5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgdmFyIF90b01vZCRfaSA9IHRvTW9kW19pXSxcbiAgICAgICAgICAgICAgICAgIF9lbGUgPSBfdG9Nb2QkX2kuZWxlLFxuICAgICAgICAgICAgICAgICAgX2pzb24gPSBfdG9Nb2QkX2kuanNvbjtcblxuICAgICAgICAgICAgICBfZWxlLmpzb24oX2pzb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAoYXJyYXkob2JqLmVsZW1lbnRzKSkge1xuICAgICAgICAgICAgLy8gZWxlbWVudHM6IFtdXG4gICAgICAgICAgICB1cGRhdGVFbGVzKG9iai5lbGVtZW50cyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGVsZW1lbnRzOiB7IG5vZGVzOiBbXSwgZWRnZXM6IFtdIH1cbiAgICAgICAgICAgIHZhciBncnMgPSBbJ25vZGVzJywgJ2VkZ2VzJ107XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBnciA9IGdyc1tpXTtcbiAgICAgICAgICAgICAgdmFyIGVsZW1lbnRzID0gb2JqLmVsZW1lbnRzW2dyXTtcblxuICAgICAgICAgICAgICBpZiAoYXJyYXkoZWxlbWVudHMpKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlRWxlcyhlbGVtZW50cywgZ3IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHBhcmVudHNUb1JlbW92ZSA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICAgICAgICBlbGVzLmZpbHRlcihmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gIWlkSW5Kc29uW2VsZS5pZCgpXTtcbiAgICAgICAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgICAgIGlmIChlbGUuaXNQYXJlbnQoKSkge1xuICAgICAgICAgICAgICBwYXJlbnRzVG9SZW1vdmUubWVyZ2UoZWxlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVsZS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTsgLy8gc28gdGhhdCBjaGlsZHJlbiBhcmUgbm90IHJlbW92ZWQgdy9wYXJlbnRcblxuICAgICAgICAgIHBhcmVudHNUb1JlbW92ZS5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGUuY2hpbGRyZW4oKS5tb3ZlKHtcbiAgICAgICAgICAgICAgcGFyZW50OiBudWxsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTsgLy8gaW50ZXJtZWRpYXRlIHBhcmVudHMgbWF5IGJlIG1vdmVkIGJ5IHByaW9yIGxpbmUsIHNvIG1ha2Ugc3VyZSB3ZSByZW1vdmUgYnkgZnJlc2ggcmVmc1xuXG4gICAgICAgICAgcGFyZW50c1RvUmVtb3ZlLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEZyZXNoUmVmKGVsZSkucmVtb3ZlKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob2JqLnN0eWxlKSB7XG4gICAgICAgICAgY3kuc3R5bGUob2JqLnN0eWxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvYmouem9vbSAhPSBudWxsICYmIG9iai56b29tICE9PSBfcC56b29tKSB7XG4gICAgICAgICAgY3kuem9vbShvYmouem9vbSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob2JqLnBhbikge1xuICAgICAgICAgIGlmIChvYmoucGFuLnggIT09IF9wLnBhbi54IHx8IG9iai5wYW4ueSAhPT0gX3AucGFuLnkpIHtcbiAgICAgICAgICAgIGN5LnBhbihvYmoucGFuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob2JqLmRhdGEpIHtcbiAgICAgICAgICBjeS5kYXRhKG9iai5kYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmaWVsZHMgPSBbJ21pblpvb20nLCAnbWF4Wm9vbScsICd6b29taW5nRW5hYmxlZCcsICd1c2VyWm9vbWluZ0VuYWJsZWQnLCAncGFubmluZ0VuYWJsZWQnLCAndXNlclBhbm5pbmdFbmFibGVkJywgJ2JveFNlbGVjdGlvbkVuYWJsZWQnLCAnYXV0b2xvY2snLCAnYXV0b3VuZ3JhYmlmeScsICdhdXRvdW5zZWxlY3RpZnknLCAnbXVsdGlDbGlja0RlYm91bmNlVGltZSddO1xuXG4gICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGZpZWxkcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgICAgdmFyIGYgPSBmaWVsZHNbX2kyXTtcblxuICAgICAgICAgIGlmIChvYmpbZl0gIT0gbnVsbCkge1xuICAgICAgICAgICAgY3lbZl0ob2JqW2ZdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjeS5lbmRCYXRjaCgpO1xuICAgICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGdldFxuICAgICAgICB2YXIgZmxhdCA9ICEhb2JqO1xuICAgICAgICB2YXIganNvbiA9IHt9O1xuXG4gICAgICAgIGlmIChmbGF0KSB7XG4gICAgICAgICAganNvbi5lbGVtZW50cyA9IHRoaXMuZWxlbWVudHMoKS5tYXAoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZS5qc29uKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAganNvbi5lbGVtZW50cyA9IHt9O1xuICAgICAgICAgIGVsZXMuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSBlbGUuZ3JvdXAoKTtcblxuICAgICAgICAgICAgaWYgKCFqc29uLmVsZW1lbnRzW2dyb3VwXSkge1xuICAgICAgICAgICAgICBqc29uLmVsZW1lbnRzW2dyb3VwXSA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBqc29uLmVsZW1lbnRzW2dyb3VwXS5wdXNoKGVsZS5qc29uKCkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGUuc3R5bGVFbmFibGVkKSB7XG4gICAgICAgICAganNvbi5zdHlsZSA9IGN5LnN0eWxlKCkuanNvbigpO1xuICAgICAgICB9XG5cbiAgICAgICAganNvbi5kYXRhID0gY29weShjeS5kYXRhKCkpO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IF9wLm9wdGlvbnM7XG4gICAgICAgIGpzb24uem9vbWluZ0VuYWJsZWQgPSBfcC56b29taW5nRW5hYmxlZDtcbiAgICAgICAganNvbi51c2VyWm9vbWluZ0VuYWJsZWQgPSBfcC51c2VyWm9vbWluZ0VuYWJsZWQ7XG4gICAgICAgIGpzb24uem9vbSA9IF9wLnpvb207XG4gICAgICAgIGpzb24ubWluWm9vbSA9IF9wLm1pblpvb207XG4gICAgICAgIGpzb24ubWF4Wm9vbSA9IF9wLm1heFpvb207XG4gICAgICAgIGpzb24ucGFubmluZ0VuYWJsZWQgPSBfcC5wYW5uaW5nRW5hYmxlZDtcbiAgICAgICAganNvbi51c2VyUGFubmluZ0VuYWJsZWQgPSBfcC51c2VyUGFubmluZ0VuYWJsZWQ7XG4gICAgICAgIGpzb24ucGFuID0gY29weShfcC5wYW4pO1xuICAgICAgICBqc29uLmJveFNlbGVjdGlvbkVuYWJsZWQgPSBfcC5ib3hTZWxlY3Rpb25FbmFibGVkO1xuICAgICAgICBqc29uLnJlbmRlcmVyID0gY29weShvcHRpb25zLnJlbmRlcmVyKTtcbiAgICAgICAganNvbi5oaWRlRWRnZXNPblZpZXdwb3J0ID0gb3B0aW9ucy5oaWRlRWRnZXNPblZpZXdwb3J0O1xuICAgICAgICBqc29uLnRleHR1cmVPblZpZXdwb3J0ID0gb3B0aW9ucy50ZXh0dXJlT25WaWV3cG9ydDtcbiAgICAgICAganNvbi53aGVlbFNlbnNpdGl2aXR5ID0gb3B0aW9ucy53aGVlbFNlbnNpdGl2aXR5O1xuICAgICAgICBqc29uLm1vdGlvbkJsdXIgPSBvcHRpb25zLm1vdGlvbkJsdXI7XG4gICAgICAgIGpzb24ubXVsdGlDbGlja0RlYm91bmNlVGltZSA9IG9wdGlvbnMubXVsdGlDbGlja0RlYm91bmNlVGltZTtcbiAgICAgICAgcmV0dXJuIGpzb247XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgY29yZWZuLiRpZCA9IGNvcmVmbi5nZXRFbGVtZW50QnlJZDtcbiAgW2NvcmVmbiQ5LCBjb3JlZm4kOCwgZWxlc2ZuLCBjb3JlZm4kNywgY29yZWZuJDYsIGNvcmVmbiQ1LCBjb3JlZm4kNCwgY29yZWZuJDMsIGNvcmVmbiQyLCBjb3JlZm4kMSwgZm5dLmZvckVhY2goZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgZXh0ZW5kKGNvcmVmbiwgcHJvcHMpO1xuICB9KTtcblxuICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXG4gIHZhciBkZWZhdWx0cyQ3ID0ge1xuICAgIGZpdDogdHJ1ZSxcbiAgICAvLyB3aGV0aGVyIHRvIGZpdCB0aGUgdmlld3BvcnQgdG8gdGhlIGdyYXBoXG4gICAgZGlyZWN0ZWQ6IGZhbHNlLFxuICAgIC8vIHdoZXRoZXIgdGhlIHRyZWUgaXMgZGlyZWN0ZWQgZG93bndhcmRzIChvciBlZGdlcyBjYW4gcG9pbnQgaW4gYW55IGRpcmVjdGlvbiBpZiBmYWxzZSlcbiAgICBwYWRkaW5nOiAzMCxcbiAgICAvLyBwYWRkaW5nIG9uIGZpdFxuICAgIGNpcmNsZTogZmFsc2UsXG4gICAgLy8gcHV0IGRlcHRocyBpbiBjb25jZW50cmljIGNpcmNsZXMgaWYgdHJ1ZSwgcHV0IGRlcHRocyB0b3AgZG93biBpZiBmYWxzZVxuICAgIGdyaWQ6IGZhbHNlLFxuICAgIC8vIHdoZXRoZXIgdG8gY3JlYXRlIGFuIGV2ZW4gZ3JpZCBpbnRvIHdoaWNoIHRoZSBEQUcgaXMgcGxhY2VkIChjaXJjbGU6ZmFsc2Ugb25seSlcbiAgICBzcGFjaW5nRmFjdG9yOiAxLjc1LFxuICAgIC8vIHBvc2l0aXZlIHNwYWNpbmcgZmFjdG9yLCBsYXJnZXIgPT4gbW9yZSBzcGFjZSBiZXR3ZWVuIG5vZGVzIChOLkIuIG4vYSBpZiBjYXVzZXMgb3ZlcmxhcClcbiAgICBib3VuZGluZ0JveDogdW5kZWZpbmVkLFxuICAgIC8vIGNvbnN0cmFpbiBsYXlvdXQgYm91bmRzOyB7IHgxLCB5MSwgeDIsIHkyIH0gb3IgeyB4MSwgeTEsIHcsIGggfVxuICAgIGF2b2lkT3ZlcmxhcDogdHJ1ZSxcbiAgICAvLyBwcmV2ZW50cyBub2RlIG92ZXJsYXAsIG1heSBvdmVyZmxvdyBib3VuZGluZ0JveCBpZiBub3QgZW5vdWdoIHNwYWNlXG4gICAgbm9kZURpbWVuc2lvbnNJbmNsdWRlTGFiZWxzOiBmYWxzZSxcbiAgICAvLyBFeGNsdWRlcyB0aGUgbGFiZWwgd2hlbiBjYWxjdWxhdGluZyBub2RlIGJvdW5kaW5nIGJveGVzIGZvciB0aGUgbGF5b3V0IGFsZ29yaXRobVxuICAgIHJvb3RzOiB1bmRlZmluZWQsXG4gICAgLy8gdGhlIHJvb3RzIG9mIHRoZSB0cmVlc1xuICAgIGRlcHRoU29ydDogdW5kZWZpbmVkLFxuICAgIC8vIGEgc29ydGluZyBmdW5jdGlvbiB0byBvcmRlciBub2RlcyBhdCBlcXVhbCBkZXB0aC4gZS5nLiBmdW5jdGlvbihhLCBiKXsgcmV0dXJuIGEuZGF0YSgnd2VpZ2h0JykgLSBiLmRhdGEoJ3dlaWdodCcpIH1cbiAgICBhbmltYXRlOiBmYWxzZSxcbiAgICAvLyB3aGV0aGVyIHRvIHRyYW5zaXRpb24gdGhlIG5vZGUgcG9zaXRpb25zXG4gICAgYW5pbWF0aW9uRHVyYXRpb246IDUwMCxcbiAgICAvLyBkdXJhdGlvbiBvZiBhbmltYXRpb24gaW4gbXMgaWYgZW5hYmxlZFxuICAgIGFuaW1hdGlvbkVhc2luZzogdW5kZWZpbmVkLFxuICAgIC8vIGVhc2luZyBvZiBhbmltYXRpb24gaWYgZW5hYmxlZCxcbiAgICBhbmltYXRlRmlsdGVyOiBmdW5jdGlvbiBhbmltYXRlRmlsdGVyKG5vZGUsIGkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgLy8gYSBmdW5jdGlvbiB0aGF0IGRldGVybWluZXMgd2hldGhlciB0aGUgbm9kZSBzaG91bGQgYmUgYW5pbWF0ZWQuICBBbGwgbm9kZXMgYW5pbWF0ZWQgYnkgZGVmYXVsdCBvbiBhbmltYXRlIGVuYWJsZWQuICBOb24tYW5pbWF0ZWQgbm9kZXMgYXJlIHBvc2l0aW9uZWQgaW1tZWRpYXRlbHkgd2hlbiB0aGUgbGF5b3V0IHN0YXJ0c1xuICAgIHJlYWR5OiB1bmRlZmluZWQsXG4gICAgLy8gY2FsbGJhY2sgb24gbGF5b3V0cmVhZHlcbiAgICBzdG9wOiB1bmRlZmluZWQsXG4gICAgLy8gY2FsbGJhY2sgb24gbGF5b3V0c3RvcFxuICAgIHRyYW5zZm9ybTogZnVuY3Rpb24gdHJhbnNmb3JtKG5vZGUsIHBvc2l0aW9uKSB7XG4gICAgICByZXR1cm4gcG9zaXRpb247XG4gICAgfSAvLyB0cmFuc2Zvcm0gYSBnaXZlbiBub2RlIHBvc2l0aW9uLiBVc2VmdWwgZm9yIGNoYW5naW5nIGZsb3cgZGlyZWN0aW9uIGluIGRpc2NyZXRlIGxheW91dHNcblxuICB9O1xuICB2YXIgZGVwcmVjYXRlZE9wdGlvbkRlZmF1bHRzID0ge1xuICAgIG1heGltYWw6IGZhbHNlLFxuICAgIC8vIHdoZXRoZXIgdG8gc2hpZnQgbm9kZXMgZG93biB0aGVpciBuYXR1cmFsIEJGUyBkZXB0aHMgaW4gb3JkZXIgdG8gYXZvaWQgdXB3YXJkcyBlZGdlcyAoREFHUyBvbmx5KTsgc2V0dGluZyBhY3ljbGljIHRvIHRydWUgc2V0cyBtYXhpbWFsIHRvIHRydWUgYWxzb1xuICAgIGFjeWNsaWM6IGZhbHNlIC8vIHdoZXRoZXIgdGhlIHRyZWUgaXMgYWN5Y2xpYyBhbmQgdGh1cyBhIG5vZGUgY291bGQgYmUgc2hpZnRlZCAoZHVlIHRvIHRoZSBtYXhpbWFsIG9wdGlvbikgbXVsdGlwbGUgdGltZXMgd2l0aG91dCBjYXVzaW5nIGFuIGluZmluaXRlIGxvb3A7IHNldHRpbmcgdG8gdHJ1ZSBzZXRzIG1heGltYWwgdG8gdHJ1ZSBhbHNvOyBpZiB5b3UgYXJlIHVuY2VydGFpbiB3aGV0aGVyIGEgdHJlZSBpcyBhY3ljbGljLCBzZXQgdG8gZmFsc2UgdG8gYXZvaWQgcG90ZW50aWFsIGluZmluaXRlIGxvb3BzXG5cbiAgfTtcbiAgLyogZXNsaW50LWVuYWJsZSAqL1xuXG4gIHZhciBnZXRJbmZvID0gZnVuY3Rpb24gZ2V0SW5mbyhlbGUpIHtcbiAgICByZXR1cm4gZWxlLnNjcmF0Y2goJ2JyZWFkdGhmaXJzdCcpO1xuICB9O1xuXG4gIHZhciBzZXRJbmZvID0gZnVuY3Rpb24gc2V0SW5mbyhlbGUsIG9iaikge1xuICAgIHJldHVybiBlbGUuc2NyYXRjaCgnYnJlYWR0aGZpcnN0Jywgb2JqKTtcbiAgfTtcblxuICBmdW5jdGlvbiBCcmVhZHRoRmlyc3RMYXlvdXQob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IGV4dGVuZCh7fSwgZGVmYXVsdHMkNywgZGVwcmVjYXRlZE9wdGlvbkRlZmF1bHRzLCBvcHRpb25zKTtcbiAgfVxuXG4gIEJyZWFkdGhGaXJzdExheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwYXJhbXMgPSB0aGlzLm9wdGlvbnM7XG4gICAgdmFyIG9wdGlvbnMgPSBwYXJhbXM7XG4gICAgdmFyIGN5ID0gcGFyYW1zLmN5O1xuICAgIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuICAgIHZhciBub2RlcyA9IGVsZXMubm9kZXMoKS5maWx0ZXIoZnVuY3Rpb24gKG4pIHtcbiAgICAgIHJldHVybiAhbi5pc1BhcmVudCgpO1xuICAgIH0pO1xuICAgIHZhciBncmFwaCA9IGVsZXM7XG4gICAgdmFyIGRpcmVjdGVkID0gb3B0aW9ucy5kaXJlY3RlZDtcbiAgICB2YXIgbWF4aW1hbCA9IG9wdGlvbnMuYWN5Y2xpYyB8fCBvcHRpb25zLm1heGltYWwgfHwgb3B0aW9ucy5tYXhpbWFsQWRqdXN0bWVudHMgPiAwOyAvLyBtYXhpbWFsQWRqdXN0bWVudHMgZm9yIGNvbXBhdC4gdy8gb2xkIGNvZGU7IGFsc28sIHNldHRpbmcgYWN5Y2xpYyB0byB0cnVlIHNldHMgbWF4aW1hbCB0byB0cnVlXG5cbiAgICB2YXIgYmIgPSBtYWtlQm91bmRpbmdCb3gob3B0aW9ucy5ib3VuZGluZ0JveCA/IG9wdGlvbnMuYm91bmRpbmdCb3ggOiB7XG4gICAgICB4MTogMCxcbiAgICAgIHkxOiAwLFxuICAgICAgdzogY3kud2lkdGgoKSxcbiAgICAgIGg6IGN5LmhlaWdodCgpXG4gICAgfSk7XG4gICAgdmFyIHJvb3RzO1xuXG4gICAgaWYgKGVsZW1lbnRPckNvbGxlY3Rpb24ob3B0aW9ucy5yb290cykpIHtcbiAgICAgIHJvb3RzID0gb3B0aW9ucy5yb290cztcbiAgICB9IGVsc2UgaWYgKGFycmF5KG9wdGlvbnMucm9vdHMpKSB7XG4gICAgICB2YXIgcm9vdHNBcnJheSA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdGlvbnMucm9vdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGlkID0gb3B0aW9ucy5yb290c1tpXTtcbiAgICAgICAgdmFyIGVsZSA9IGN5LmdldEVsZW1lbnRCeUlkKGlkKTtcbiAgICAgICAgcm9vdHNBcnJheS5wdXNoKGVsZSk7XG4gICAgICB9XG5cbiAgICAgIHJvb3RzID0gY3kuY29sbGVjdGlvbihyb290c0FycmF5KTtcbiAgICB9IGVsc2UgaWYgKHN0cmluZyhvcHRpb25zLnJvb3RzKSkge1xuICAgICAgcm9vdHMgPSBjeS4kKG9wdGlvbnMucm9vdHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZGlyZWN0ZWQpIHtcbiAgICAgICAgcm9vdHMgPSBub2Rlcy5yb290cygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudHMgPSBlbGVzLmNvbXBvbmVudHMoKTtcbiAgICAgICAgcm9vdHMgPSBjeS5jb2xsZWN0aW9uKCk7XG5cbiAgICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoX2kpIHtcbiAgICAgICAgICB2YXIgY29tcCA9IGNvbXBvbmVudHNbX2ldO1xuICAgICAgICAgIHZhciBtYXhEZWdyZWUgPSBjb21wLm1heERlZ3JlZShmYWxzZSk7XG4gICAgICAgICAgdmFyIGNvbXBSb290cyA9IGNvbXAuZmlsdGVyKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGUuZGVncmVlKGZhbHNlKSA9PT0gbWF4RGVncmVlO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJvb3RzID0gcm9vdHMuYWRkKGNvbXBSb290cyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGNvbXBvbmVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgX2xvb3AoX2kpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRlcHRocyA9IFtdO1xuICAgIHZhciBmb3VuZEJ5QmZzID0ge307XG5cbiAgICB2YXIgYWRkVG9EZXB0aCA9IGZ1bmN0aW9uIGFkZFRvRGVwdGgoZWxlLCBkKSB7XG4gICAgICBpZiAoZGVwdGhzW2RdID09IG51bGwpIHtcbiAgICAgICAgZGVwdGhzW2RdID0gW107XG4gICAgICB9XG5cbiAgICAgIHZhciBpID0gZGVwdGhzW2RdLmxlbmd0aDtcbiAgICAgIGRlcHRoc1tkXS5wdXNoKGVsZSk7XG4gICAgICBzZXRJbmZvKGVsZSwge1xuICAgICAgICBpbmRleDogaSxcbiAgICAgICAgZGVwdGg6IGRcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB2YXIgY2hhbmdlRGVwdGggPSBmdW5jdGlvbiBjaGFuZ2VEZXB0aChlbGUsIG5ld0RlcHRoKSB7XG4gICAgICB2YXIgX2dldEluZm8gPSBnZXRJbmZvKGVsZSksXG4gICAgICAgICAgZGVwdGggPSBfZ2V0SW5mby5kZXB0aCxcbiAgICAgICAgICBpbmRleCA9IF9nZXRJbmZvLmluZGV4O1xuXG4gICAgICBkZXB0aHNbZGVwdGhdW2luZGV4XSA9IG51bGw7XG4gICAgICBhZGRUb0RlcHRoKGVsZSwgbmV3RGVwdGgpO1xuICAgIH07IC8vIGZpbmQgdGhlIGRlcHRocyBvZiB0aGUgbm9kZXNcblxuXG4gICAgZ3JhcGguYmZzKHtcbiAgICAgIHJvb3RzOiByb290cyxcbiAgICAgIGRpcmVjdGVkOiBvcHRpb25zLmRpcmVjdGVkLFxuICAgICAgdmlzaXQ6IGZ1bmN0aW9uIHZpc2l0KG5vZGUsIGVkZ2UsIHBOb2RlLCBpLCBkZXB0aCkge1xuICAgICAgICB2YXIgZWxlID0gbm9kZVswXTtcbiAgICAgICAgdmFyIGlkID0gZWxlLmlkKCk7XG4gICAgICAgIGFkZFRvRGVwdGgoZWxlLCBkZXB0aCk7XG4gICAgICAgIGZvdW5kQnlCZnNbaWRdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTsgLy8gY2hlY2sgZm9yIG5vZGVzIG5vdCBmb3VuZCBieSBiZnNcblxuICAgIHZhciBvcnBoYW5Ob2RlcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbm9kZXMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgdmFyIF9lbGUgPSBub2Rlc1tfaTJdO1xuXG4gICAgICBpZiAoZm91bmRCeUJmc1tfZWxlLmlkKCldKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3JwaGFuTm9kZXMucHVzaChfZWxlKTtcbiAgICAgIH1cbiAgICB9IC8vIGFzc2lnbiB0aGUgbm9kZXMgYSBkZXB0aCBhbmQgaW5kZXhcblxuXG4gICAgdmFyIGFzc2lnbkRlcHRoc0F0ID0gZnVuY3Rpb24gYXNzaWduRGVwdGhzQXQoaSkge1xuICAgICAgdmFyIGVsZXMgPSBkZXB0aHNbaV07XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZWxlcy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgX2VsZTIgPSBlbGVzW2pdO1xuXG4gICAgICAgIGlmIChfZWxlMiA9PSBudWxsKSB7XG4gICAgICAgICAgZWxlcy5zcGxpY2UoaiwgMSk7XG4gICAgICAgICAgai0tO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0SW5mbyhfZWxlMiwge1xuICAgICAgICAgIGRlcHRoOiBpLFxuICAgICAgICAgIGluZGV4OiBqXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgYXNzaWduRGVwdGhzID0gZnVuY3Rpb24gYXNzaWduRGVwdGhzKCkge1xuICAgICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgZGVwdGhzLmxlbmd0aDsgX2kzKyspIHtcbiAgICAgICAgYXNzaWduRGVwdGhzQXQoX2kzKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGFkanVzdE1heGltYWxseSA9IGZ1bmN0aW9uIGFkanVzdE1heGltYWxseShlbGUsIHNoaWZ0ZWQpIHtcbiAgICAgIHZhciBlSW5mbyA9IGdldEluZm8oZWxlKTtcbiAgICAgIHZhciBpbmNvbWVycyA9IGVsZS5pbmNvbWVycygpLmZpbHRlcihmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgcmV0dXJuIGVsLmlzTm9kZSgpICYmIGVsZXMuaGFzKGVsKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIG1heERlcHRoID0gLTE7XG4gICAgICB2YXIgaWQgPSBlbGUuaWQoKTtcblxuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBpbmNvbWVycy5sZW5ndGg7IGsrKykge1xuICAgICAgICB2YXIgaW5jbXIgPSBpbmNvbWVyc1trXTtcbiAgICAgICAgdmFyIGlJbmZvID0gZ2V0SW5mbyhpbmNtcik7XG4gICAgICAgIG1heERlcHRoID0gTWF0aC5tYXgobWF4RGVwdGgsIGlJbmZvLmRlcHRoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVJbmZvLmRlcHRoIDw9IG1heERlcHRoKSB7XG4gICAgICAgIGlmICghb3B0aW9ucy5hY3ljbGljICYmIHNoaWZ0ZWRbaWRdKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmV3RGVwdGggPSBtYXhEZXB0aCArIDE7XG4gICAgICAgIGNoYW5nZURlcHRoKGVsZSwgbmV3RGVwdGgpO1xuICAgICAgICBzaGlmdGVkW2lkXSA9IG5ld0RlcHRoO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07IC8vIGZvciB0aGUgZGlyZWN0ZWQgY2FzZSwgdHJ5IHRvIG1ha2UgdGhlIGVkZ2VzIGFsbCBnbyBkb3duIChpLmUuIGRlcHRoIGkgPT4gZGVwdGggaSArIDEpXG5cblxuICAgIGlmIChkaXJlY3RlZCAmJiBtYXhpbWFsKSB7XG4gICAgICB2YXIgUSA9IFtdO1xuICAgICAgdmFyIHNoaWZ0ZWQgPSB7fTtcblxuICAgICAgdmFyIGVucXVldWUgPSBmdW5jdGlvbiBlbnF1ZXVlKG4pIHtcbiAgICAgICAgcmV0dXJuIFEucHVzaChuKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBkZXF1ZXVlID0gZnVuY3Rpb24gZGVxdWV1ZSgpIHtcbiAgICAgICAgcmV0dXJuIFEuc2hpZnQoKTtcbiAgICAgIH07XG5cbiAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgcmV0dXJuIFEucHVzaChuKTtcbiAgICAgIH0pO1xuXG4gICAgICB3aGlsZSAoUS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBfZWxlMyA9IGRlcXVldWUoKTtcblxuICAgICAgICB2YXIgZGlkU2hpZnQgPSBhZGp1c3RNYXhpbWFsbHkoX2VsZTMsIHNoaWZ0ZWQpO1xuXG4gICAgICAgIGlmIChkaWRTaGlmdCkge1xuICAgICAgICAgIF9lbGUzLm91dGdvZXJzKCkuZmlsdGVyKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgcmV0dXJuIGVsLmlzTm9kZSgpICYmIGVsZXMuaGFzKGVsKTtcbiAgICAgICAgICB9KS5mb3JFYWNoKGVucXVldWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGRpZFNoaWZ0ID09PSBudWxsKSB7XG4gICAgICAgICAgd2FybignRGV0ZWN0ZWQgZG91YmxlIG1heGltYWwgc2hpZnQgZm9yIG5vZGUgYCcgKyBfZWxlMy5pZCgpICsgJ2AuICBCYWlsaW5nIG1heGltYWwgYWRqdXN0bWVudCBkdWUgdG8gY3ljbGUuICBVc2UgYG9wdGlvbnMubWF4aW1hbDogdHJ1ZWAgb25seSBvbiBEQUdzLicpO1xuICAgICAgICAgIGJyZWFrOyAvLyBleGl0IG9uIGZhaWx1cmVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGFzc2lnbkRlcHRocygpOyAvLyBjbGVhciBob2xlc1xuICAgIC8vIGZpbmQgbWluIGRpc3RhbmNlIHdlIG5lZWQgdG8gbGVhdmUgYmV0d2VlbiBub2Rlc1xuXG4gICAgdmFyIG1pbkRpc3RhbmNlID0gMDtcblxuICAgIGlmIChvcHRpb25zLmF2b2lkT3ZlcmxhcCkge1xuICAgICAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgbm9kZXMubGVuZ3RoOyBfaTQrKykge1xuICAgICAgICB2YXIgbiA9IG5vZGVzW19pNF07XG4gICAgICAgIHZhciBuYmIgPSBuLmxheW91dERpbWVuc2lvbnMob3B0aW9ucyk7XG4gICAgICAgIHZhciB3ID0gbmJiLnc7XG4gICAgICAgIHZhciBoID0gbmJiLmg7XG4gICAgICAgIG1pbkRpc3RhbmNlID0gTWF0aC5tYXgobWluRGlzdGFuY2UsIHcsIGgpO1xuICAgICAgfVxuICAgIH0gLy8gZ2V0IHRoZSB3ZWlnaHRlZCBwZXJjZW50IGZvciBhbiBlbGVtZW50IGJhc2VkIG9uIGl0cyBjb25uZWN0aXZpdHkgdG8gb3RoZXIgbGV2ZWxzXG5cblxuICAgIHZhciBjYWNoZWRXZWlnaHRlZFBlcmNlbnQgPSB7fTtcblxuICAgIHZhciBnZXRXZWlnaHRlZFBlcmNlbnQgPSBmdW5jdGlvbiBnZXRXZWlnaHRlZFBlcmNlbnQoZWxlKSB7XG4gICAgICBpZiAoY2FjaGVkV2VpZ2h0ZWRQZXJjZW50W2VsZS5pZCgpXSkge1xuICAgICAgICByZXR1cm4gY2FjaGVkV2VpZ2h0ZWRQZXJjZW50W2VsZS5pZCgpXTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVsZURlcHRoID0gZ2V0SW5mbyhlbGUpLmRlcHRoO1xuICAgICAgdmFyIG5laWdoYm9ycyA9IGVsZS5uZWlnaGJvcmhvb2QoKTtcbiAgICAgIHZhciBwZXJjZW50ID0gMDtcbiAgICAgIHZhciBzYW1wbGVzID0gMDtcblxuICAgICAgZm9yICh2YXIgX2k1ID0gMDsgX2k1IDwgbmVpZ2hib3JzLmxlbmd0aDsgX2k1KyspIHtcbiAgICAgICAgdmFyIG5laWdoYm9yID0gbmVpZ2hib3JzW19pNV07XG5cbiAgICAgICAgaWYgKG5laWdoYm9yLmlzRWRnZSgpIHx8IG5laWdoYm9yLmlzUGFyZW50KCkgfHwgIW5vZGVzLmhhcyhuZWlnaGJvcikpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBiZiA9IGdldEluZm8obmVpZ2hib3IpO1xuXG4gICAgICAgIGlmIChiZiA9PSBudWxsKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW5kZXggPSBiZi5pbmRleDtcbiAgICAgICAgdmFyIGRlcHRoID0gYmYuZGVwdGg7IC8vIHVuYXNzaWduZWQgbmVpZ2hib3VycyBzaG91bGRuJ3QgYWZmZWN0IHRoZSBvcmRlcmluZ1xuXG4gICAgICAgIGlmIChpbmRleCA9PSBudWxsIHx8IGRlcHRoID09IG51bGwpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuRGVwdGggPSBkZXB0aHNbZGVwdGhdLmxlbmd0aDtcblxuICAgICAgICBpZiAoZGVwdGggPCBlbGVEZXB0aCkge1xuICAgICAgICAgIC8vIG9ubHkgZ2V0IGluZmx1ZW5jZWQgYnkgZWxlbWVudHMgYWJvdmVcbiAgICAgICAgICBwZXJjZW50ICs9IGluZGV4IC8gbkRlcHRoO1xuICAgICAgICAgIHNhbXBsZXMrKztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzYW1wbGVzID0gTWF0aC5tYXgoMSwgc2FtcGxlcyk7XG4gICAgICBwZXJjZW50ID0gcGVyY2VudCAvIHNhbXBsZXM7XG5cbiAgICAgIGlmIChzYW1wbGVzID09PSAwKSB7XG4gICAgICAgIC8vIHB1dCBsb25lIG5vZGVzIGF0IHRoZSBzdGFydFxuICAgICAgICBwZXJjZW50ID0gMDtcbiAgICAgIH1cblxuICAgICAgY2FjaGVkV2VpZ2h0ZWRQZXJjZW50W2VsZS5pZCgpXSA9IHBlcmNlbnQ7XG4gICAgICByZXR1cm4gcGVyY2VudDtcbiAgICB9OyAvLyByZWFycmFuZ2UgdGhlIGluZGljZXMgaW4gZWFjaCBkZXB0aCBsZXZlbCBiYXNlZCBvbiBjb25uZWN0aXZpdHlcblxuXG4gICAgdmFyIHNvcnRGbiA9IGZ1bmN0aW9uIHNvcnRGbihhLCBiKSB7XG4gICAgICB2YXIgYXBjdCA9IGdldFdlaWdodGVkUGVyY2VudChhKTtcbiAgICAgIHZhciBicGN0ID0gZ2V0V2VpZ2h0ZWRQZXJjZW50KGIpO1xuICAgICAgdmFyIGRpZmYgPSBhcGN0IC0gYnBjdDtcblxuICAgICAgaWYgKGRpZmYgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGFzY2VuZGluZyhhLmlkKCksIGIuaWQoKSk7IC8vIG1ha2Ugc3VyZSBzb3J0IGRvZXNuJ3QgaGF2ZSBkb24ndC1jYXJlIGNvbXBhcmlzb25zXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZGlmZjtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKG9wdGlvbnMuZGVwdGhTb3J0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHNvcnRGbiA9IG9wdGlvbnMuZGVwdGhTb3J0O1xuICAgIH0gLy8gc29ydCBlYWNoIGxldmVsIHRvIG1ha2UgY29ubmVjdGVkIG5vZGVzIGNsb3NlclxuXG5cbiAgICBmb3IgKHZhciBfaTYgPSAwOyBfaTYgPCBkZXB0aHMubGVuZ3RoOyBfaTYrKykge1xuICAgICAgZGVwdGhzW19pNl0uc29ydChzb3J0Rm4pO1xuXG4gICAgICBhc3NpZ25EZXB0aHNBdChfaTYpO1xuICAgIH0gLy8gYXNzaWduIG9ycGhhbiBub2RlcyB0byBhIG5ldyB0b3AtbGV2ZWwgZGVwdGhcblxuXG4gICAgdmFyIG9ycGhhbkRlcHRoID0gW107XG5cbiAgICBmb3IgKHZhciBfaTcgPSAwOyBfaTcgPCBvcnBoYW5Ob2Rlcy5sZW5ndGg7IF9pNysrKSB7XG4gICAgICBvcnBoYW5EZXB0aC5wdXNoKG9ycGhhbk5vZGVzW19pN10pO1xuICAgIH1cblxuICAgIGRlcHRocy51bnNoaWZ0KG9ycGhhbkRlcHRoKTtcbiAgICBhc3NpZ25EZXB0aHMoKTtcbiAgICB2YXIgYmlnZ2VzdERlcHRoU2l6ZSA9IDA7XG5cbiAgICBmb3IgKHZhciBfaTggPSAwOyBfaTggPCBkZXB0aHMubGVuZ3RoOyBfaTgrKykge1xuICAgICAgYmlnZ2VzdERlcHRoU2l6ZSA9IE1hdGgubWF4KGRlcHRoc1tfaThdLmxlbmd0aCwgYmlnZ2VzdERlcHRoU2l6ZSk7XG4gICAgfVxuXG4gICAgdmFyIGNlbnRlciA9IHtcbiAgICAgIHg6IGJiLngxICsgYmIudyAvIDIsXG4gICAgICB5OiBiYi54MSArIGJiLmggLyAyXG4gICAgfTtcbiAgICB2YXIgbWF4RGVwdGhTaXplID0gZGVwdGhzLnJlZHVjZShmdW5jdGlvbiAobWF4LCBlbGVzKSB7XG4gICAgICByZXR1cm4gTWF0aC5tYXgobWF4LCBlbGVzLmxlbmd0aCk7XG4gICAgfSwgMCk7XG5cbiAgICB2YXIgZ2V0UG9zaXRpb24gPSBmdW5jdGlvbiBnZXRQb3NpdGlvbihlbGUpIHtcbiAgICAgIHZhciBfZ2V0SW5mbzIgPSBnZXRJbmZvKGVsZSksXG4gICAgICAgICAgZGVwdGggPSBfZ2V0SW5mbzIuZGVwdGgsXG4gICAgICAgICAgaW5kZXggPSBfZ2V0SW5mbzIuaW5kZXg7XG5cbiAgICAgIHZhciBkZXB0aFNpemUgPSBkZXB0aHNbZGVwdGhdLmxlbmd0aDtcbiAgICAgIHZhciBkaXN0YW5jZVggPSBNYXRoLm1heChiYi53IC8gKChvcHRpb25zLmdyaWQgPyBtYXhEZXB0aFNpemUgOiBkZXB0aFNpemUpICsgMSksIG1pbkRpc3RhbmNlKTtcbiAgICAgIHZhciBkaXN0YW5jZVkgPSBNYXRoLm1heChiYi5oIC8gKGRlcHRocy5sZW5ndGggKyAxKSwgbWluRGlzdGFuY2UpO1xuICAgICAgdmFyIHJhZGl1c1N0ZXBTaXplID0gTWF0aC5taW4oYmIudyAvIDIgLyBkZXB0aHMubGVuZ3RoLCBiYi5oIC8gMiAvIGRlcHRocy5sZW5ndGgpO1xuICAgICAgcmFkaXVzU3RlcFNpemUgPSBNYXRoLm1heChyYWRpdXNTdGVwU2l6ZSwgbWluRGlzdGFuY2UpO1xuXG4gICAgICBpZiAoIW9wdGlvbnMuY2lyY2xlKSB7XG4gICAgICAgIHZhciBlcG9zID0ge1xuICAgICAgICAgIHg6IGNlbnRlci54ICsgKGluZGV4ICsgMSAtIChkZXB0aFNpemUgKyAxKSAvIDIpICogZGlzdGFuY2VYLFxuICAgICAgICAgIHk6IChkZXB0aCArIDEpICogZGlzdGFuY2VZXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlcG9zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJhZGl1cyA9IHJhZGl1c1N0ZXBTaXplICogZGVwdGggKyByYWRpdXNTdGVwU2l6ZSAtIChkZXB0aHMubGVuZ3RoID4gMCAmJiBkZXB0aHNbMF0ubGVuZ3RoIDw9IDMgPyByYWRpdXNTdGVwU2l6ZSAvIDIgOiAwKTtcbiAgICAgICAgdmFyIHRoZXRhID0gMiAqIE1hdGguUEkgLyBkZXB0aHNbZGVwdGhdLmxlbmd0aCAqIGluZGV4O1xuXG4gICAgICAgIGlmIChkZXB0aCA9PT0gMCAmJiBkZXB0aHNbMF0ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgcmFkaXVzID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogY2VudGVyLnggKyByYWRpdXMgKiBNYXRoLmNvcyh0aGV0YSksXG4gICAgICAgICAgeTogY2VudGVyLnkgKyByYWRpdXMgKiBNYXRoLnNpbih0aGV0YSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZWxlcy5ub2RlcygpLmxheW91dFBvc2l0aW9ucyh0aGlzLCBvcHRpb25zLCBnZXRQb3NpdGlvbik7XG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH07XG5cbiAgdmFyIGRlZmF1bHRzJDYgPSB7XG4gICAgZml0OiB0cnVlLFxuICAgIC8vIHdoZXRoZXIgdG8gZml0IHRoZSB2aWV3cG9ydCB0byB0aGUgZ3JhcGhcbiAgICBwYWRkaW5nOiAzMCxcbiAgICAvLyB0aGUgcGFkZGluZyBvbiBmaXRcbiAgICBib3VuZGluZ0JveDogdW5kZWZpbmVkLFxuICAgIC8vIGNvbnN0cmFpbiBsYXlvdXQgYm91bmRzOyB7IHgxLCB5MSwgeDIsIHkyIH0gb3IgeyB4MSwgeTEsIHcsIGggfVxuICAgIGF2b2lkT3ZlcmxhcDogdHJ1ZSxcbiAgICAvLyBwcmV2ZW50cyBub2RlIG92ZXJsYXAsIG1heSBvdmVyZmxvdyBib3VuZGluZ0JveCBhbmQgcmFkaXVzIGlmIG5vdCBlbm91Z2ggc3BhY2VcbiAgICBub2RlRGltZW5zaW9uc0luY2x1ZGVMYWJlbHM6IGZhbHNlLFxuICAgIC8vIEV4Y2x1ZGVzIHRoZSBsYWJlbCB3aGVuIGNhbGN1bGF0aW5nIG5vZGUgYm91bmRpbmcgYm94ZXMgZm9yIHRoZSBsYXlvdXQgYWxnb3JpdGhtXG4gICAgc3BhY2luZ0ZhY3RvcjogdW5kZWZpbmVkLFxuICAgIC8vIEFwcGxpZXMgYSBtdWx0aXBsaWNhdGl2ZSBmYWN0b3IgKD4wKSB0byBleHBhbmQgb3IgY29tcHJlc3MgdGhlIG92ZXJhbGwgYXJlYSB0aGF0IHRoZSBub2RlcyB0YWtlIHVwXG4gICAgcmFkaXVzOiB1bmRlZmluZWQsXG4gICAgLy8gdGhlIHJhZGl1cyBvZiB0aGUgY2lyY2xlXG4gICAgc3RhcnRBbmdsZTogMyAvIDIgKiBNYXRoLlBJLFxuICAgIC8vIHdoZXJlIG5vZGVzIHN0YXJ0IGluIHJhZGlhbnNcbiAgICBzd2VlcDogdW5kZWZpbmVkLFxuICAgIC8vIGhvdyBtYW55IHJhZGlhbnMgc2hvdWxkIGJlIGJldHdlZW4gdGhlIGZpcnN0IGFuZCBsYXN0IG5vZGUgKGRlZmF1bHRzIHRvIGZ1bGwgY2lyY2xlKVxuICAgIGNsb2Nrd2lzZTogdHJ1ZSxcbiAgICAvLyB3aGV0aGVyIHRoZSBsYXlvdXQgc2hvdWxkIGdvIGNsb2Nrd2lzZSAodHJ1ZSkgb3IgY291bnRlcmNsb2Nrd2lzZS9hbnRpY2xvY2t3aXNlIChmYWxzZSlcbiAgICBzb3J0OiB1bmRlZmluZWQsXG4gICAgLy8gYSBzb3J0aW5nIGZ1bmN0aW9uIHRvIG9yZGVyIHRoZSBub2RlczsgZS5nLiBmdW5jdGlvbihhLCBiKXsgcmV0dXJuIGEuZGF0YSgnd2VpZ2h0JykgLSBiLmRhdGEoJ3dlaWdodCcpIH1cbiAgICBhbmltYXRlOiBmYWxzZSxcbiAgICAvLyB3aGV0aGVyIHRvIHRyYW5zaXRpb24gdGhlIG5vZGUgcG9zaXRpb25zXG4gICAgYW5pbWF0aW9uRHVyYXRpb246IDUwMCxcbiAgICAvLyBkdXJhdGlvbiBvZiBhbmltYXRpb24gaW4gbXMgaWYgZW5hYmxlZFxuICAgIGFuaW1hdGlvbkVhc2luZzogdW5kZWZpbmVkLFxuICAgIC8vIGVhc2luZyBvZiBhbmltYXRpb24gaWYgZW5hYmxlZFxuICAgIGFuaW1hdGVGaWx0ZXI6IGZ1bmN0aW9uIGFuaW1hdGVGaWx0ZXIobm9kZSwgaSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICAvLyBhIGZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBub2RlIHNob3VsZCBiZSBhbmltYXRlZC4gIEFsbCBub2RlcyBhbmltYXRlZCBieSBkZWZhdWx0IG9uIGFuaW1hdGUgZW5hYmxlZC4gIE5vbi1hbmltYXRlZCBub2RlcyBhcmUgcG9zaXRpb25lZCBpbW1lZGlhdGVseSB3aGVuIHRoZSBsYXlvdXQgc3RhcnRzXG4gICAgcmVhZHk6IHVuZGVmaW5lZCxcbiAgICAvLyBjYWxsYmFjayBvbiBsYXlvdXRyZWFkeVxuICAgIHN0b3A6IHVuZGVmaW5lZCxcbiAgICAvLyBjYWxsYmFjayBvbiBsYXlvdXRzdG9wXG4gICAgdHJhbnNmb3JtOiBmdW5jdGlvbiB0cmFuc2Zvcm0obm9kZSwgcG9zaXRpb24pIHtcbiAgICAgIHJldHVybiBwb3NpdGlvbjtcbiAgICB9IC8vIHRyYW5zZm9ybSBhIGdpdmVuIG5vZGUgcG9zaXRpb24uIFVzZWZ1bCBmb3IgY2hhbmdpbmcgZmxvdyBkaXJlY3Rpb24gaW4gZGlzY3JldGUgbGF5b3V0cyBcblxuICB9O1xuXG4gIGZ1bmN0aW9uIENpcmNsZUxheW91dChvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gZXh0ZW5kKHt9LCBkZWZhdWx0cyQ2LCBvcHRpb25zKTtcbiAgfVxuXG4gIENpcmNsZUxheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwYXJhbXMgPSB0aGlzLm9wdGlvbnM7XG4gICAgdmFyIG9wdGlvbnMgPSBwYXJhbXM7XG4gICAgdmFyIGN5ID0gcGFyYW1zLmN5O1xuICAgIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuICAgIHZhciBjbG9ja3dpc2UgPSBvcHRpb25zLmNvdW50ZXJjbG9ja3dpc2UgIT09IHVuZGVmaW5lZCA/ICFvcHRpb25zLmNvdW50ZXJjbG9ja3dpc2UgOiBvcHRpb25zLmNsb2Nrd2lzZTtcbiAgICB2YXIgbm9kZXMgPSBlbGVzLm5vZGVzKCkubm90KCc6cGFyZW50Jyk7XG5cbiAgICBpZiAob3B0aW9ucy5zb3J0KSB7XG4gICAgICBub2RlcyA9IG5vZGVzLnNvcnQob3B0aW9ucy5zb3J0KTtcbiAgICB9XG5cbiAgICB2YXIgYmIgPSBtYWtlQm91bmRpbmdCb3gob3B0aW9ucy5ib3VuZGluZ0JveCA/IG9wdGlvbnMuYm91bmRpbmdCb3ggOiB7XG4gICAgICB4MTogMCxcbiAgICAgIHkxOiAwLFxuICAgICAgdzogY3kud2lkdGgoKSxcbiAgICAgIGg6IGN5LmhlaWdodCgpXG4gICAgfSk7XG4gICAgdmFyIGNlbnRlciA9IHtcbiAgICAgIHg6IGJiLngxICsgYmIudyAvIDIsXG4gICAgICB5OiBiYi55MSArIGJiLmggLyAyXG4gICAgfTtcbiAgICB2YXIgc3dlZXAgPSBvcHRpb25zLnN3ZWVwID09PSB1bmRlZmluZWQgPyAyICogTWF0aC5QSSAtIDIgKiBNYXRoLlBJIC8gbm9kZXMubGVuZ3RoIDogb3B0aW9ucy5zd2VlcDtcbiAgICB2YXIgZFRoZXRhID0gc3dlZXAgLyBNYXRoLm1heCgxLCBub2Rlcy5sZW5ndGggLSAxKTtcbiAgICB2YXIgcjtcbiAgICB2YXIgbWluRGlzdGFuY2UgPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG4gPSBub2Rlc1tpXTtcbiAgICAgIHZhciBuYmIgPSBuLmxheW91dERpbWVuc2lvbnMob3B0aW9ucyk7XG4gICAgICB2YXIgdyA9IG5iYi53O1xuICAgICAgdmFyIGggPSBuYmIuaDtcbiAgICAgIG1pbkRpc3RhbmNlID0gTWF0aC5tYXgobWluRGlzdGFuY2UsIHcsIGgpO1xuICAgIH1cblxuICAgIGlmIChudW1iZXIkMShvcHRpb25zLnJhZGl1cykpIHtcbiAgICAgIHIgPSBvcHRpb25zLnJhZGl1cztcbiAgICB9IGVsc2UgaWYgKG5vZGVzLmxlbmd0aCA8PSAxKSB7XG4gICAgICByID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgciA9IE1hdGgubWluKGJiLmgsIGJiLncpIC8gMiAtIG1pbkRpc3RhbmNlO1xuICAgIH0gLy8gY2FsY3VsYXRlIHRoZSByYWRpdXNcblxuXG4gICAgaWYgKG5vZGVzLmxlbmd0aCA+IDEgJiYgb3B0aW9ucy5hdm9pZE92ZXJsYXApIHtcbiAgICAgIC8vIGJ1dCBvbmx5IGlmIG1vcmUgdGhhbiBvbmUgbm9kZSAoY2FuJ3Qgb3ZlcmxhcClcbiAgICAgIG1pbkRpc3RhbmNlICo9IDEuNzU7IC8vIGp1c3QgdG8gaGF2ZSBzb21lIG5pY2Ugc3BhY2luZ1xuXG4gICAgICB2YXIgZGNvcyA9IE1hdGguY29zKGRUaGV0YSkgLSBNYXRoLmNvcygwKTtcbiAgICAgIHZhciBkc2luID0gTWF0aC5zaW4oZFRoZXRhKSAtIE1hdGguc2luKDApO1xuICAgICAgdmFyIHJNaW4gPSBNYXRoLnNxcnQobWluRGlzdGFuY2UgKiBtaW5EaXN0YW5jZSAvIChkY29zICogZGNvcyArIGRzaW4gKiBkc2luKSk7IC8vIHMudC4gbm8gbm9kZXMgb3ZlcmxhcHBpbmdcblxuICAgICAgciA9IE1hdGgubWF4KHJNaW4sIHIpO1xuICAgIH1cblxuICAgIHZhciBnZXRQb3MgPSBmdW5jdGlvbiBnZXRQb3MoZWxlLCBpKSB7XG4gICAgICB2YXIgdGhldGEgPSBvcHRpb25zLnN0YXJ0QW5nbGUgKyBpICogZFRoZXRhICogKGNsb2Nrd2lzZSA/IDEgOiAtMSk7XG4gICAgICB2YXIgcnggPSByICogTWF0aC5jb3ModGhldGEpO1xuICAgICAgdmFyIHJ5ID0gciAqIE1hdGguc2luKHRoZXRhKTtcbiAgICAgIHZhciBwb3MgPSB7XG4gICAgICAgIHg6IGNlbnRlci54ICsgcngsXG4gICAgICAgIHk6IGNlbnRlci55ICsgcnlcbiAgICAgIH07XG4gICAgICByZXR1cm4gcG9zO1xuICAgIH07XG5cbiAgICBlbGVzLm5vZGVzKCkubGF5b3V0UG9zaXRpb25zKHRoaXMsIG9wdGlvbnMsIGdldFBvcyk7XG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH07XG5cbiAgdmFyIGRlZmF1bHRzJDUgPSB7XG4gICAgZml0OiB0cnVlLFxuICAgIC8vIHdoZXRoZXIgdG8gZml0IHRoZSB2aWV3cG9ydCB0byB0aGUgZ3JhcGhcbiAgICBwYWRkaW5nOiAzMCxcbiAgICAvLyB0aGUgcGFkZGluZyBvbiBmaXRcbiAgICBzdGFydEFuZ2xlOiAzIC8gMiAqIE1hdGguUEksXG4gICAgLy8gd2hlcmUgbm9kZXMgc3RhcnQgaW4gcmFkaWFuc1xuICAgIHN3ZWVwOiB1bmRlZmluZWQsXG4gICAgLy8gaG93IG1hbnkgcmFkaWFucyBzaG91bGQgYmUgYmV0d2VlbiB0aGUgZmlyc3QgYW5kIGxhc3Qgbm9kZSAoZGVmYXVsdHMgdG8gZnVsbCBjaXJjbGUpXG4gICAgY2xvY2t3aXNlOiB0cnVlLFxuICAgIC8vIHdoZXRoZXIgdGhlIGxheW91dCBzaG91bGQgZ28gY2xvY2t3aXNlICh0cnVlKSBvciBjb3VudGVyY2xvY2t3aXNlL2FudGljbG9ja3dpc2UgKGZhbHNlKVxuICAgIGVxdWlkaXN0YW50OiBmYWxzZSxcbiAgICAvLyB3aGV0aGVyIGxldmVscyBoYXZlIGFuIGVxdWFsIHJhZGlhbCBkaXN0YW5jZSBiZXR3ZW4gdGhlbSwgbWF5IGNhdXNlIGJvdW5kaW5nIGJveCBvdmVyZmxvd1xuICAgIG1pbk5vZGVTcGFjaW5nOiAxMCxcbiAgICAvLyBtaW4gc3BhY2luZyBiZXR3ZWVuIG91dHNpZGUgb2Ygbm9kZXMgKHVzZWQgZm9yIHJhZGl1cyBhZGp1c3RtZW50KVxuICAgIGJvdW5kaW5nQm94OiB1bmRlZmluZWQsXG4gICAgLy8gY29uc3RyYWluIGxheW91dCBib3VuZHM7IHsgeDEsIHkxLCB4MiwgeTIgfSBvciB7IHgxLCB5MSwgdywgaCB9XG4gICAgYXZvaWRPdmVybGFwOiB0cnVlLFxuICAgIC8vIHByZXZlbnRzIG5vZGUgb3ZlcmxhcCwgbWF5IG92ZXJmbG93IGJvdW5kaW5nQm94IGlmIG5vdCBlbm91Z2ggc3BhY2VcbiAgICBub2RlRGltZW5zaW9uc0luY2x1ZGVMYWJlbHM6IGZhbHNlLFxuICAgIC8vIEV4Y2x1ZGVzIHRoZSBsYWJlbCB3aGVuIGNhbGN1bGF0aW5nIG5vZGUgYm91bmRpbmcgYm94ZXMgZm9yIHRoZSBsYXlvdXQgYWxnb3JpdGhtXG4gICAgaGVpZ2h0OiB1bmRlZmluZWQsXG4gICAgLy8gaGVpZ2h0IG9mIGxheW91dCBhcmVhIChvdmVycmlkZXMgY29udGFpbmVyIGhlaWdodClcbiAgICB3aWR0aDogdW5kZWZpbmVkLFxuICAgIC8vIHdpZHRoIG9mIGxheW91dCBhcmVhIChvdmVycmlkZXMgY29udGFpbmVyIHdpZHRoKVxuICAgIHNwYWNpbmdGYWN0b3I6IHVuZGVmaW5lZCxcbiAgICAvLyBBcHBsaWVzIGEgbXVsdGlwbGljYXRpdmUgZmFjdG9yICg+MCkgdG8gZXhwYW5kIG9yIGNvbXByZXNzIHRoZSBvdmVyYWxsIGFyZWEgdGhhdCB0aGUgbm9kZXMgdGFrZSB1cFxuICAgIGNvbmNlbnRyaWM6IGZ1bmN0aW9uIGNvbmNlbnRyaWMobm9kZSkge1xuICAgICAgLy8gcmV0dXJucyBudW1lcmljIHZhbHVlIGZvciBlYWNoIG5vZGUsIHBsYWNpbmcgaGlnaGVyIG5vZGVzIGluIGxldmVscyB0b3dhcmRzIHRoZSBjZW50cmVcbiAgICAgIHJldHVybiBub2RlLmRlZ3JlZSgpO1xuICAgIH0sXG4gICAgbGV2ZWxXaWR0aDogZnVuY3Rpb24gbGV2ZWxXaWR0aChub2Rlcykge1xuICAgICAgLy8gdGhlIHZhcmlhdGlvbiBvZiBjb25jZW50cmljIHZhbHVlcyBpbiBlYWNoIGxldmVsXG4gICAgICByZXR1cm4gbm9kZXMubWF4RGVncmVlKCkgLyA0O1xuICAgIH0sXG4gICAgYW5pbWF0ZTogZmFsc2UsXG4gICAgLy8gd2hldGhlciB0byB0cmFuc2l0aW9uIHRoZSBub2RlIHBvc2l0aW9uc1xuICAgIGFuaW1hdGlvbkR1cmF0aW9uOiA1MDAsXG4gICAgLy8gZHVyYXRpb24gb2YgYW5pbWF0aW9uIGluIG1zIGlmIGVuYWJsZWRcbiAgICBhbmltYXRpb25FYXNpbmc6IHVuZGVmaW5lZCxcbiAgICAvLyBlYXNpbmcgb2YgYW5pbWF0aW9uIGlmIGVuYWJsZWRcbiAgICBhbmltYXRlRmlsdGVyOiBmdW5jdGlvbiBhbmltYXRlRmlsdGVyKG5vZGUsIGkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgLy8gYSBmdW5jdGlvbiB0aGF0IGRldGVybWluZXMgd2hldGhlciB0aGUgbm9kZSBzaG91bGQgYmUgYW5pbWF0ZWQuICBBbGwgbm9kZXMgYW5pbWF0ZWQgYnkgZGVmYXVsdCBvbiBhbmltYXRlIGVuYWJsZWQuICBOb24tYW5pbWF0ZWQgbm9kZXMgYXJlIHBvc2l0aW9uZWQgaW1tZWRpYXRlbHkgd2hlbiB0aGUgbGF5b3V0IHN0YXJ0c1xuICAgIHJlYWR5OiB1bmRlZmluZWQsXG4gICAgLy8gY2FsbGJhY2sgb24gbGF5b3V0cmVhZHlcbiAgICBzdG9wOiB1bmRlZmluZWQsXG4gICAgLy8gY2FsbGJhY2sgb24gbGF5b3V0c3RvcFxuICAgIHRyYW5zZm9ybTogZnVuY3Rpb24gdHJhbnNmb3JtKG5vZGUsIHBvc2l0aW9uKSB7XG4gICAgICByZXR1cm4gcG9zaXRpb247XG4gICAgfSAvLyB0cmFuc2Zvcm0gYSBnaXZlbiBub2RlIHBvc2l0aW9uLiBVc2VmdWwgZm9yIGNoYW5naW5nIGZsb3cgZGlyZWN0aW9uIGluIGRpc2NyZXRlIGxheW91dHNcblxuICB9O1xuXG4gIGZ1bmN0aW9uIENvbmNlbnRyaWNMYXlvdXQob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IGV4dGVuZCh7fSwgZGVmYXVsdHMkNSwgb3B0aW9ucyk7XG4gIH1cblxuICBDb25jZW50cmljTGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBhcmFtcyA9IHRoaXMub3B0aW9ucztcbiAgICB2YXIgb3B0aW9ucyA9IHBhcmFtcztcbiAgICB2YXIgY2xvY2t3aXNlID0gb3B0aW9ucy5jb3VudGVyY2xvY2t3aXNlICE9PSB1bmRlZmluZWQgPyAhb3B0aW9ucy5jb3VudGVyY2xvY2t3aXNlIDogb3B0aW9ucy5jbG9ja3dpc2U7XG4gICAgdmFyIGN5ID0gcGFyYW1zLmN5O1xuICAgIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuICAgIHZhciBub2RlcyA9IGVsZXMubm9kZXMoKS5ub3QoJzpwYXJlbnQnKTtcbiAgICB2YXIgYmIgPSBtYWtlQm91bmRpbmdCb3gob3B0aW9ucy5ib3VuZGluZ0JveCA/IG9wdGlvbnMuYm91bmRpbmdCb3ggOiB7XG4gICAgICB4MTogMCxcbiAgICAgIHkxOiAwLFxuICAgICAgdzogY3kud2lkdGgoKSxcbiAgICAgIGg6IGN5LmhlaWdodCgpXG4gICAgfSk7XG4gICAgdmFyIGNlbnRlciA9IHtcbiAgICAgIHg6IGJiLngxICsgYmIudyAvIDIsXG4gICAgICB5OiBiYi55MSArIGJiLmggLyAyXG4gICAgfTtcbiAgICB2YXIgbm9kZVZhbHVlcyA9IFtdOyAvLyB7IG5vZGUsIHZhbHVlIH1cblxuICAgIHZhciBtYXhOb2RlU2l6ZSA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgdmFyIHZhbHVlID0gdm9pZCAwOyAvLyBjYWxjdWxhdGUgdGhlIG5vZGUgdmFsdWVcblxuICAgICAgdmFsdWUgPSBvcHRpb25zLmNvbmNlbnRyaWMobm9kZSk7XG4gICAgICBub2RlVmFsdWVzLnB1c2goe1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIG5vZGU6IG5vZGVcbiAgICAgIH0pOyAvLyBmb3Igc3R5bGUgbWFwcGluZ1xuXG4gICAgICBub2RlLl9wcml2YXRlLnNjcmF0Y2guY29uY2VudHJpYyA9IHZhbHVlO1xuICAgIH0gLy8gaW4gY2FzZSB3ZSB1c2VkIHRoZSBgY29uY2VudHJpY2AgaW4gc3R5bGVcblxuXG4gICAgbm9kZXMudXBkYXRlU3R5bGUoKTsgLy8gY2FsY3VsYXRlIG1heCBzaXplIG5vdyBiYXNlZCBvbiBwb3RlbnRpYWxseSB1cGRhdGVkIG1hcHBlcnNcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBub2Rlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfbm9kZSA9IG5vZGVzW19pXTtcblxuICAgICAgdmFyIG5iYiA9IF9ub2RlLmxheW91dERpbWVuc2lvbnMob3B0aW9ucyk7XG5cbiAgICAgIG1heE5vZGVTaXplID0gTWF0aC5tYXgobWF4Tm9kZVNpemUsIG5iYi53LCBuYmIuaCk7XG4gICAgfSAvLyBzb3J0IG5vZGUgdmFsdWVzIGluIGRlc2NyZWFzaW5nIG9yZGVyXG5cblxuICAgIG5vZGVWYWx1ZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGIudmFsdWUgLSBhLnZhbHVlO1xuICAgIH0pO1xuICAgIHZhciBsZXZlbFdpZHRoID0gb3B0aW9ucy5sZXZlbFdpZHRoKG5vZGVzKTsgLy8gcHV0IHRoZSB2YWx1ZXMgaW50byBsZXZlbHNcblxuICAgIHZhciBsZXZlbHMgPSBbW11dO1xuICAgIHZhciBjdXJyZW50TGV2ZWwgPSBsZXZlbHNbMF07XG5cbiAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBub2RlVmFsdWVzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgIHZhciB2YWwgPSBub2RlVmFsdWVzW19pMl07XG5cbiAgICAgIGlmIChjdXJyZW50TGV2ZWwubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgZGlmZiA9IE1hdGguYWJzKGN1cnJlbnRMZXZlbFswXS52YWx1ZSAtIHZhbC52YWx1ZSk7XG5cbiAgICAgICAgaWYgKGRpZmYgPj0gbGV2ZWxXaWR0aCkge1xuICAgICAgICAgIGN1cnJlbnRMZXZlbCA9IFtdO1xuICAgICAgICAgIGxldmVscy5wdXNoKGN1cnJlbnRMZXZlbCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY3VycmVudExldmVsLnB1c2godmFsKTtcbiAgICB9IC8vIGNyZWF0ZSBwb3NpdGlvbnMgZnJvbSBsZXZlbHNcblxuXG4gICAgdmFyIG1pbkRpc3QgPSBtYXhOb2RlU2l6ZSArIG9wdGlvbnMubWluTm9kZVNwYWNpbmc7IC8vIG1pbiBkaXN0IGJldHdlZW4gbm9kZXNcblxuICAgIGlmICghb3B0aW9ucy5hdm9pZE92ZXJsYXApIHtcbiAgICAgIC8vIHRoZW4gc3RyaWN0bHkgY29uc3RyYWluIHRvIGJiXG4gICAgICB2YXIgZmlyc3RMdmxIYXNNdWx0aSA9IGxldmVscy5sZW5ndGggPiAwICYmIGxldmVsc1swXS5sZW5ndGggPiAxO1xuICAgICAgdmFyIG1heFIgPSBNYXRoLm1pbihiYi53LCBiYi5oKSAvIDIgLSBtaW5EaXN0O1xuICAgICAgdmFyIHJTdGVwID0gbWF4UiAvIChsZXZlbHMubGVuZ3RoICsgZmlyc3RMdmxIYXNNdWx0aSA/IDEgOiAwKTtcbiAgICAgIG1pbkRpc3QgPSBNYXRoLm1pbihtaW5EaXN0LCByU3RlcCk7XG4gICAgfSAvLyBmaW5kIHRoZSBtZXRyaWNzIGZvciBlYWNoIGxldmVsXG5cblxuICAgIHZhciByID0gMDtcblxuICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IGxldmVscy5sZW5ndGg7IF9pMysrKSB7XG4gICAgICB2YXIgbGV2ZWwgPSBsZXZlbHNbX2kzXTtcbiAgICAgIHZhciBzd2VlcCA9IG9wdGlvbnMuc3dlZXAgPT09IHVuZGVmaW5lZCA/IDIgKiBNYXRoLlBJIC0gMiAqIE1hdGguUEkgLyBsZXZlbC5sZW5ndGggOiBvcHRpb25zLnN3ZWVwO1xuICAgICAgdmFyIGRUaGV0YSA9IGxldmVsLmRUaGV0YSA9IHN3ZWVwIC8gTWF0aC5tYXgoMSwgbGV2ZWwubGVuZ3RoIC0gMSk7IC8vIGNhbGN1bGF0ZSB0aGUgcmFkaXVzXG5cbiAgICAgIGlmIChsZXZlbC5sZW5ndGggPiAxICYmIG9wdGlvbnMuYXZvaWRPdmVybGFwKSB7XG4gICAgICAgIC8vIGJ1dCBvbmx5IGlmIG1vcmUgdGhhbiBvbmUgbm9kZSAoY2FuJ3Qgb3ZlcmxhcClcbiAgICAgICAgdmFyIGRjb3MgPSBNYXRoLmNvcyhkVGhldGEpIC0gTWF0aC5jb3MoMCk7XG4gICAgICAgIHZhciBkc2luID0gTWF0aC5zaW4oZFRoZXRhKSAtIE1hdGguc2luKDApO1xuICAgICAgICB2YXIgck1pbiA9IE1hdGguc3FydChtaW5EaXN0ICogbWluRGlzdCAvIChkY29zICogZGNvcyArIGRzaW4gKiBkc2luKSk7IC8vIHMudC4gbm8gbm9kZXMgb3ZlcmxhcHBpbmdcblxuICAgICAgICByID0gTWF0aC5tYXgock1pbiwgcik7XG4gICAgICB9XG5cbiAgICAgIGxldmVsLnIgPSByO1xuICAgICAgciArPSBtaW5EaXN0O1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmVxdWlkaXN0YW50KSB7XG4gICAgICB2YXIgckRlbHRhTWF4ID0gMDtcbiAgICAgIHZhciBfciA9IDA7XG5cbiAgICAgIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IGxldmVscy5sZW5ndGg7IF9pNCsrKSB7XG4gICAgICAgIHZhciBfbGV2ZWwgPSBsZXZlbHNbX2k0XTtcbiAgICAgICAgdmFyIHJEZWx0YSA9IF9sZXZlbC5yIC0gX3I7XG4gICAgICAgIHJEZWx0YU1heCA9IE1hdGgubWF4KHJEZWx0YU1heCwgckRlbHRhKTtcbiAgICAgIH1cblxuICAgICAgX3IgPSAwO1xuXG4gICAgICBmb3IgKHZhciBfaTUgPSAwOyBfaTUgPCBsZXZlbHMubGVuZ3RoOyBfaTUrKykge1xuICAgICAgICB2YXIgX2xldmVsMiA9IGxldmVsc1tfaTVdO1xuXG4gICAgICAgIGlmIChfaTUgPT09IDApIHtcbiAgICAgICAgICBfciA9IF9sZXZlbDIucjtcbiAgICAgICAgfVxuXG4gICAgICAgIF9sZXZlbDIuciA9IF9yO1xuICAgICAgICBfciArPSByRGVsdGFNYXg7XG4gICAgICB9XG4gICAgfSAvLyBjYWxjdWxhdGUgdGhlIG5vZGUgcG9zaXRpb25zXG5cblxuICAgIHZhciBwb3MgPSB7fTsgLy8gaWQgPT4gcG9zaXRpb25cblxuICAgIGZvciAodmFyIF9pNiA9IDA7IF9pNiA8IGxldmVscy5sZW5ndGg7IF9pNisrKSB7XG4gICAgICB2YXIgX2xldmVsMyA9IGxldmVsc1tfaTZdO1xuICAgICAgdmFyIF9kVGhldGEgPSBfbGV2ZWwzLmRUaGV0YTtcbiAgICAgIHZhciBfcjIgPSBfbGV2ZWwzLnI7XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgX2xldmVsMy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgX3ZhbCA9IF9sZXZlbDNbal07XG4gICAgICAgIHZhciB0aGV0YSA9IG9wdGlvbnMuc3RhcnRBbmdsZSArIChjbG9ja3dpc2UgPyAxIDogLTEpICogX2RUaGV0YSAqIGo7XG4gICAgICAgIHZhciBwID0ge1xuICAgICAgICAgIHg6IGNlbnRlci54ICsgX3IyICogTWF0aC5jb3ModGhldGEpLFxuICAgICAgICAgIHk6IGNlbnRlci55ICsgX3IyICogTWF0aC5zaW4odGhldGEpXG4gICAgICAgIH07XG4gICAgICAgIHBvc1tfdmFsLm5vZGUuaWQoKV0gPSBwO1xuICAgICAgfVxuICAgIH0gLy8gcG9zaXRpb24gdGhlIG5vZGVzXG5cblxuICAgIGVsZXMubm9kZXMoKS5sYXlvdXRQb3NpdGlvbnModGhpcywgb3B0aW9ucywgZnVuY3Rpb24gKGVsZSkge1xuICAgICAgdmFyIGlkID0gZWxlLmlkKCk7XG4gICAgICByZXR1cm4gcG9zW2lkXTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfTtcblxuICAvKlxuICBUaGUgQ29TRSBsYXlvdXQgd2FzIHdyaXR0ZW4gYnkgR2VyYXJkbyBIdWNrLlxuICBodHRwczovL3d3dy5saW5rZWRpbi5jb20vaW4vZ2VyYXJkb2h1Y2svXG5cbiAgQmFzZWQgb24gdGhlIGZvbGxvd2luZyBhcnRpY2xlOlxuICBodHRwOi8vZGwuYWNtLm9yZy9jaXRhdGlvbi5jZm0/aWQ9MTQ5ODA0N1xuXG4gIE1vZGlmaWNhdGlvbnMgdHJhY2tlZCBvbiBHaXRodWIuXG4gICovXG4gIHZhciBERUJVRztcbiAgLyoqXG4gICAqIEBicmllZiA6ICBkZWZhdWx0IGxheW91dCBvcHRpb25zXG4gICAqL1xuXG4gIHZhciBkZWZhdWx0cyQ0ID0ge1xuICAgIC8vIENhbGxlZCBvbiBgbGF5b3V0cmVhZHlgXG4gICAgcmVhZHk6IGZ1bmN0aW9uIHJlYWR5KCkge30sXG4gICAgLy8gQ2FsbGVkIG9uIGBsYXlvdXRzdG9wYFxuICAgIHN0b3A6IGZ1bmN0aW9uIHN0b3AoKSB7fSxcbiAgICAvLyBXaGV0aGVyIHRvIGFuaW1hdGUgd2hpbGUgcnVubmluZyB0aGUgbGF5b3V0XG4gICAgLy8gdHJ1ZSA6IEFuaW1hdGUgY29udGludW91c2x5IGFzIHRoZSBsYXlvdXQgaXMgcnVubmluZ1xuICAgIC8vIGZhbHNlIDogSnVzdCBzaG93IHRoZSBlbmQgcmVzdWx0XG4gICAgLy8gJ2VuZCcgOiBBbmltYXRlIHdpdGggdGhlIGVuZCByZXN1bHQsIGZyb20gdGhlIGluaXRpYWwgcG9zaXRpb25zIHRvIHRoZSBlbmQgcG9zaXRpb25zXG4gICAgYW5pbWF0ZTogdHJ1ZSxcbiAgICAvLyBFYXNpbmcgb2YgdGhlIGFuaW1hdGlvbiBmb3IgYW5pbWF0ZTonZW5kJ1xuICAgIGFuaW1hdGlvbkVhc2luZzogdW5kZWZpbmVkLFxuICAgIC8vIFRoZSBkdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uIGZvciBhbmltYXRlOidlbmQnXG4gICAgYW5pbWF0aW9uRHVyYXRpb246IHVuZGVmaW5lZCxcbiAgICAvLyBBIGZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBub2RlIHNob3VsZCBiZSBhbmltYXRlZFxuICAgIC8vIEFsbCBub2RlcyBhbmltYXRlZCBieSBkZWZhdWx0IG9uIGFuaW1hdGUgZW5hYmxlZFxuICAgIC8vIE5vbi1hbmltYXRlZCBub2RlcyBhcmUgcG9zaXRpb25lZCBpbW1lZGlhdGVseSB3aGVuIHRoZSBsYXlvdXQgc3RhcnRzXG4gICAgYW5pbWF0ZUZpbHRlcjogZnVuY3Rpb24gYW5pbWF0ZUZpbHRlcihub2RlLCBpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIC8vIFRoZSBsYXlvdXQgYW5pbWF0ZXMgb25seSBhZnRlciB0aGlzIG1hbnkgbWlsbGlzZWNvbmRzIGZvciBhbmltYXRlOnRydWVcbiAgICAvLyAocHJldmVudHMgZmxhc2hpbmcgb24gZmFzdCBydW5zKVxuICAgIGFuaW1hdGlvblRocmVzaG9sZDogMjUwLFxuICAgIC8vIE51bWJlciBvZiBpdGVyYXRpb25zIGJldHdlZW4gY29uc2VjdXRpdmUgc2NyZWVuIHBvc2l0aW9ucyB1cGRhdGVcbiAgICByZWZyZXNoOiAyMCxcbiAgICAvLyBXaGV0aGVyIHRvIGZpdCB0aGUgbmV0d29yayB2aWV3IGFmdGVyIHdoZW4gZG9uZVxuICAgIGZpdDogdHJ1ZSxcbiAgICAvLyBQYWRkaW5nIG9uIGZpdFxuICAgIHBhZGRpbmc6IDMwLFxuICAgIC8vIENvbnN0cmFpbiBsYXlvdXQgYm91bmRzOyB7IHgxLCB5MSwgeDIsIHkyIH0gb3IgeyB4MSwgeTEsIHcsIGggfVxuICAgIGJvdW5kaW5nQm94OiB1bmRlZmluZWQsXG4gICAgLy8gRXhjbHVkZXMgdGhlIGxhYmVsIHdoZW4gY2FsY3VsYXRpbmcgbm9kZSBib3VuZGluZyBib3hlcyBmb3IgdGhlIGxheW91dCBhbGdvcml0aG1cbiAgICBub2RlRGltZW5zaW9uc0luY2x1ZGVMYWJlbHM6IGZhbHNlLFxuICAgIC8vIFJhbmRvbWl6ZSB0aGUgaW5pdGlhbCBwb3NpdGlvbnMgb2YgdGhlIG5vZGVzICh0cnVlKSBvciB1c2UgZXhpc3RpbmcgcG9zaXRpb25zIChmYWxzZSlcbiAgICByYW5kb21pemU6IGZhbHNlLFxuICAgIC8vIEV4dHJhIHNwYWNpbmcgYmV0d2VlbiBjb21wb25lbnRzIGluIG5vbi1jb21wb3VuZCBncmFwaHNcbiAgICBjb21wb25lbnRTcGFjaW5nOiA0MCxcbiAgICAvLyBOb2RlIHJlcHVsc2lvbiAobm9uIG92ZXJsYXBwaW5nKSBtdWx0aXBsaWVyXG4gICAgbm9kZVJlcHVsc2lvbjogZnVuY3Rpb24gbm9kZVJlcHVsc2lvbihub2RlKSB7XG4gICAgICByZXR1cm4gMjA0ODtcbiAgICB9LFxuICAgIC8vIE5vZGUgcmVwdWxzaW9uIChvdmVybGFwcGluZykgbXVsdGlwbGllclxuICAgIG5vZGVPdmVybGFwOiA0LFxuICAgIC8vIElkZWFsIGVkZ2UgKG5vbiBuZXN0ZWQpIGxlbmd0aFxuICAgIGlkZWFsRWRnZUxlbmd0aDogZnVuY3Rpb24gaWRlYWxFZGdlTGVuZ3RoKGVkZ2UpIHtcbiAgICAgIHJldHVybiAzMjtcbiAgICB9LFxuICAgIC8vIERpdmlzb3IgdG8gY29tcHV0ZSBlZGdlIGZvcmNlc1xuICAgIGVkZ2VFbGFzdGljaXR5OiBmdW5jdGlvbiBlZGdlRWxhc3RpY2l0eShlZGdlKSB7XG4gICAgICByZXR1cm4gMzI7XG4gICAgfSxcbiAgICAvLyBOZXN0aW5nIGZhY3RvciAobXVsdGlwbGllcikgdG8gY29tcHV0ZSBpZGVhbCBlZGdlIGxlbmd0aCBmb3IgbmVzdGVkIGVkZ2VzXG4gICAgbmVzdGluZ0ZhY3RvcjogMS4yLFxuICAgIC8vIEdyYXZpdHkgZm9yY2UgKGNvbnN0YW50KVxuICAgIGdyYXZpdHk6IDEsXG4gICAgLy8gTWF4aW11bSBudW1iZXIgb2YgaXRlcmF0aW9ucyB0byBwZXJmb3JtXG4gICAgbnVtSXRlcjogMTAwMCxcbiAgICAvLyBJbml0aWFsIHRlbXBlcmF0dXJlIChtYXhpbXVtIG5vZGUgZGlzcGxhY2VtZW50KVxuICAgIGluaXRpYWxUZW1wOiAxMDAwLFxuICAgIC8vIENvb2xpbmcgZmFjdG9yIChob3cgdGhlIHRlbXBlcmF0dXJlIGlzIHJlZHVjZWQgYmV0d2VlbiBjb25zZWN1dGl2ZSBpdGVyYXRpb25zXG4gICAgY29vbGluZ0ZhY3RvcjogMC45OSxcbiAgICAvLyBMb3dlciB0ZW1wZXJhdHVyZSB0aHJlc2hvbGQgKGJlbG93IHRoaXMgcG9pbnQgdGhlIGxheW91dCB3aWxsIGVuZClcbiAgICBtaW5UZW1wOiAxLjBcbiAgfTtcbiAgLyoqXG4gICAqIEBicmllZiAgICAgICA6IGNvbnN0cnVjdG9yXG4gICAqIEBhcmcgb3B0aW9ucyA6IG9iamVjdCBjb250YWluaW5nIGxheW91dCBvcHRpb25zXG4gICAqL1xuXG4gIGZ1bmN0aW9uIENvc2VMYXlvdXQob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IGV4dGVuZCh7fSwgZGVmYXVsdHMkNCwgb3B0aW9ucyk7XG4gICAgdGhpcy5vcHRpb25zLmxheW91dCA9IHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEBicmllZiA6IHJ1bnMgdGhlIGxheW91dFxuICAgKi9cblxuXG4gIENvc2VMYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICB2YXIgY3kgPSBvcHRpb25zLmN5O1xuICAgIHZhciBsYXlvdXQgPSB0aGlzO1xuICAgIGxheW91dC5zdG9wcGVkID0gZmFsc2U7XG5cbiAgICBpZiAob3B0aW9ucy5hbmltYXRlID09PSB0cnVlIHx8IG9wdGlvbnMuYW5pbWF0ZSA9PT0gZmFsc2UpIHtcbiAgICAgIGxheW91dC5lbWl0KHtcbiAgICAgICAgdHlwZTogJ2xheW91dHN0YXJ0JyxcbiAgICAgICAgbGF5b3V0OiBsYXlvdXRcbiAgICAgIH0pO1xuICAgIH0gLy8gU2V0IERFQlVHIC0gR2xvYmFsIHZhcmlhYmxlXG5cblxuICAgIGlmICh0cnVlID09PSBvcHRpb25zLmRlYnVnKSB7XG4gICAgICBERUJVRyA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIERFQlVHID0gZmFsc2U7XG4gICAgfSAvLyBJbml0aWFsaXplIGxheW91dCBpbmZvXG5cblxuICAgIHZhciBsYXlvdXRJbmZvID0gY3JlYXRlTGF5b3V0SW5mbyhjeSwgbGF5b3V0LCBvcHRpb25zKTsgLy8gU2hvdyBMYXlvdXRJbmZvIGNvbnRlbnRzIGlmIGRlYnVnZ2luZ1xuXG4gICAgaWYgKERFQlVHKSB7XG4gICAgICBwcmludExheW91dEluZm8obGF5b3V0SW5mbyk7XG4gICAgfSAvLyBJZiByZXF1aXJlZCwgcmFuZG9taXplIG5vZGUgcG9zaXRpb25zXG5cblxuICAgIGlmIChvcHRpb25zLnJhbmRvbWl6ZSkge1xuICAgICAgcmFuZG9taXplUG9zaXRpb25zKGxheW91dEluZm8pO1xuICAgIH1cblxuICAgIHZhciBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZU5vdygpO1xuXG4gICAgdmFyIHJlZnJlc2ggPSBmdW5jdGlvbiByZWZyZXNoKCkge1xuICAgICAgcmVmcmVzaFBvc2l0aW9ucyhsYXlvdXRJbmZvLCBjeSwgb3B0aW9ucyk7IC8vIEZpdCB0aGUgZ3JhcGggaWYgbmVjZXNzYXJ5XG5cbiAgICAgIGlmICh0cnVlID09PSBvcHRpb25zLmZpdCkge1xuICAgICAgICBjeS5maXQob3B0aW9ucy5wYWRkaW5nKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIG1haW5Mb29wID0gZnVuY3Rpb24gbWFpbkxvb3AoaSkge1xuICAgICAgaWYgKGxheW91dC5zdG9wcGVkIHx8IGkgPj0gb3B0aW9ucy5udW1JdGVyKSB7XG4gICAgICAgIC8vIGxvZ0RlYnVnKFwiTGF5b3V0IG1hbnVhbGx5IHN0b3BwZWQuIFN0b3BwaW5nIGNvbXB1dGF0aW9uIGluIHN0ZXAgXCIgKyBpKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSAvLyBEbyBvbmUgc3RlcCBpbiB0aGUgcGhpc2ljYWwgc2ltdWxhdGlvblxuXG5cbiAgICAgIHN0ZXAobGF5b3V0SW5mbywgb3B0aW9ucyk7IC8vIFVwZGF0ZSB0ZW1wZXJhdHVyZVxuXG4gICAgICBsYXlvdXRJbmZvLnRlbXBlcmF0dXJlID0gbGF5b3V0SW5mby50ZW1wZXJhdHVyZSAqIG9wdGlvbnMuY29vbGluZ0ZhY3RvcjsgLy8gbG9nRGVidWcoXCJOZXcgdGVtcGVyYXR1cmU6IFwiICsgbGF5b3V0SW5mby50ZW1wZXJhdHVyZSk7XG5cbiAgICAgIGlmIChsYXlvdXRJbmZvLnRlbXBlcmF0dXJlIDwgb3B0aW9ucy5taW5UZW1wKSB7XG4gICAgICAgIC8vIGxvZ0RlYnVnKFwiVGVtcGVyYXR1cmUgZHJvcCBiZWxvdyBtaW5pbXVtIHRocmVzaG9sZC4gU3RvcHBpbmcgY29tcHV0YXRpb24gaW4gc3RlcCBcIiArIGkpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICB2YXIgZG9uZSA9IGZ1bmN0aW9uIGRvbmUoKSB7XG4gICAgICBpZiAob3B0aW9ucy5hbmltYXRlID09PSB0cnVlIHx8IG9wdGlvbnMuYW5pbWF0ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmVmcmVzaCgpOyAvLyBMYXlvdXQgaGFzIGZpbmlzaGVkXG5cbiAgICAgICAgbGF5b3V0Lm9uZSgnbGF5b3V0c3RvcCcsIG9wdGlvbnMuc3RvcCk7XG4gICAgICAgIGxheW91dC5lbWl0KHtcbiAgICAgICAgICB0eXBlOiAnbGF5b3V0c3RvcCcsXG4gICAgICAgICAgbGF5b3V0OiBsYXlvdXRcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbm9kZXMgPSBvcHRpb25zLmVsZXMubm9kZXMoKTtcbiAgICAgICAgdmFyIGdldFNjYWxlZFBvcyA9IGdldFNjYWxlSW5Cb3VuZHNGbihsYXlvdXRJbmZvLCBvcHRpb25zLCBub2Rlcyk7XG4gICAgICAgIG5vZGVzLmxheW91dFBvc2l0aW9ucyhsYXlvdXQsIG9wdGlvbnMsIGdldFNjYWxlZFBvcyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbG9vcFJldCA9IHRydWU7XG5cbiAgICBpZiAob3B0aW9ucy5hbmltYXRlID09PSB0cnVlKSB7XG4gICAgICB2YXIgZnJhbWUgPSBmdW5jdGlvbiBmcmFtZSgpIHtcbiAgICAgICAgdmFyIGYgPSAwO1xuXG4gICAgICAgIHdoaWxlIChsb29wUmV0ICYmIGYgPCBvcHRpb25zLnJlZnJlc2gpIHtcbiAgICAgICAgICBsb29wUmV0ID0gbWFpbkxvb3AoaSk7XG4gICAgICAgICAgaSsrO1xuICAgICAgICAgIGYrKztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbG9vcFJldCkge1xuICAgICAgICAgIC8vIGl0J3MgZG9uZVxuICAgICAgICAgIHNlcGFyYXRlQ29tcG9uZW50cyhsYXlvdXRJbmZvLCBvcHRpb25zKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG5vdyA9IHBlcmZvcm1hbmNlTm93KCk7XG5cbiAgICAgICAgICBpZiAobm93IC0gc3RhcnRUaW1lID49IG9wdGlvbnMuYW5pbWF0aW9uVGhyZXNob2xkKSB7XG4gICAgICAgICAgICByZWZyZXNoKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZyYW1lKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZnJhbWUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2hpbGUgKGxvb3BSZXQpIHtcbiAgICAgICAgbG9vcFJldCA9IG1haW5Mb29wKGkpO1xuICAgICAgICBpKys7XG4gICAgICB9XG5cbiAgICAgIHNlcGFyYXRlQ29tcG9uZW50cyhsYXlvdXRJbmZvLCBvcHRpb25zKTtcbiAgICAgIGRvbmUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfTtcbiAgLyoqXG4gICAqIEBicmllZiA6IGNhbGxlZCBvbiBjb250aW51b3VzIGxheW91dHMgdG8gc3RvcCB0aGVtIGJlZm9yZSB0aGV5IGZpbmlzaFxuICAgKi9cblxuXG4gIENvc2VMYXlvdXQucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zdG9wcGVkID0gdHJ1ZTtcblxuICAgIGlmICh0aGlzLnRocmVhZCkge1xuICAgICAgdGhpcy50aHJlYWQuc3RvcCgpO1xuICAgIH1cblxuICAgIHRoaXMuZW1pdCgnbGF5b3V0c3RvcCcpO1xuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9O1xuXG4gIENvc2VMYXlvdXQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMudGhyZWFkKSB7XG4gICAgICB0aGlzLnRocmVhZC5zdG9wKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH07XG4gIC8qKlxuICAgKiBAYnJpZWYgICAgIDogQ3JlYXRlcyBhbiBvYmplY3Qgd2hpY2ggaXMgY29udGFpbnMgYWxsIHRoZSBkYXRhXG4gICAqICAgICAgICAgICAgICB1c2VkIGluIHRoZSBsYXlvdXQgcHJvY2Vzc1xuICAgKiBAYXJnIGN5ICAgIDogY3l0b3NjYXBlLmpzIG9iamVjdFxuICAgKiBAcmV0dXJuICAgIDogbGF5b3V0SW5mbyBvYmplY3QgaW5pdGlhbGl6ZWRcbiAgICovXG5cblxuICB2YXIgY3JlYXRlTGF5b3V0SW5mbyA9IGZ1bmN0aW9uIGNyZWF0ZUxheW91dEluZm8oY3ksIGxheW91dCwgb3B0aW9ucykge1xuICAgIC8vIFNob3J0Y3V0XG4gICAgdmFyIGVkZ2VzID0gb3B0aW9ucy5lbGVzLmVkZ2VzKCk7XG4gICAgdmFyIG5vZGVzID0gb3B0aW9ucy5lbGVzLm5vZGVzKCk7XG4gICAgdmFyIGxheW91dEluZm8gPSB7XG4gICAgICBpc0NvbXBvdW5kOiBjeS5oYXNDb21wb3VuZE5vZGVzKCksXG4gICAgICBsYXlvdXROb2RlczogW10sXG4gICAgICBpZFRvSW5kZXg6IHt9LFxuICAgICAgbm9kZVNpemU6IG5vZGVzLnNpemUoKSxcbiAgICAgIGdyYXBoU2V0OiBbXSxcbiAgICAgIGluZGV4VG9HcmFwaDogW10sXG4gICAgICBsYXlvdXRFZGdlczogW10sXG4gICAgICBlZGdlU2l6ZTogZWRnZXMuc2l6ZSgpLFxuICAgICAgdGVtcGVyYXR1cmU6IG9wdGlvbnMuaW5pdGlhbFRlbXAsXG4gICAgICBjbGllbnRXaWR0aDogY3kud2lkdGgoKSxcbiAgICAgIGNsaWVudEhlaWdodDogY3kud2lkdGgoKSxcbiAgICAgIGJvdW5kaW5nQm94OiBtYWtlQm91bmRpbmdCb3gob3B0aW9ucy5ib3VuZGluZ0JveCA/IG9wdGlvbnMuYm91bmRpbmdCb3ggOiB7XG4gICAgICAgIHgxOiAwLFxuICAgICAgICB5MTogMCxcbiAgICAgICAgdzogY3kud2lkdGgoKSxcbiAgICAgICAgaDogY3kuaGVpZ2h0KClcbiAgICAgIH0pXG4gICAgfTtcbiAgICB2YXIgY29tcG9uZW50cyA9IG9wdGlvbnMuZWxlcy5jb21wb25lbnRzKCk7XG4gICAgdmFyIGlkMmNtcHRJZCA9IHt9O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21wb25lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY29tcG9uZW50ID0gY29tcG9uZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb21wb25lbnQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSBjb21wb25lbnRbal07XG4gICAgICAgIGlkMmNtcHRJZFtub2RlLmlkKCldID0gaTtcbiAgICAgIH1cbiAgICB9IC8vIEl0ZXJhdGUgb3ZlciBhbGwgbm9kZXMsIGNyZWF0aW5nIGxheW91dCBub2Rlc1xuXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8ubm9kZVNpemU7IGkrKykge1xuICAgICAgdmFyIG4gPSBub2Rlc1tpXTtcbiAgICAgIHZhciBuYmIgPSBuLmxheW91dERpbWVuc2lvbnMob3B0aW9ucyk7XG4gICAgICB2YXIgdGVtcE5vZGUgPSB7fTtcbiAgICAgIHRlbXBOb2RlLmlzTG9ja2VkID0gbi5sb2NrZWQoKTtcbiAgICAgIHRlbXBOb2RlLmlkID0gbi5kYXRhKCdpZCcpO1xuICAgICAgdGVtcE5vZGUucGFyZW50SWQgPSBuLmRhdGEoJ3BhcmVudCcpO1xuICAgICAgdGVtcE5vZGUuY21wdElkID0gaWQyY21wdElkW24uaWQoKV07XG4gICAgICB0ZW1wTm9kZS5jaGlsZHJlbiA9IFtdO1xuICAgICAgdGVtcE5vZGUucG9zaXRpb25YID0gbi5wb3NpdGlvbigneCcpO1xuICAgICAgdGVtcE5vZGUucG9zaXRpb25ZID0gbi5wb3NpdGlvbigneScpO1xuICAgICAgdGVtcE5vZGUub2Zmc2V0WCA9IDA7XG4gICAgICB0ZW1wTm9kZS5vZmZzZXRZID0gMDtcbiAgICAgIHRlbXBOb2RlLmhlaWdodCA9IG5iYi53O1xuICAgICAgdGVtcE5vZGUud2lkdGggPSBuYmIuaDtcbiAgICAgIHRlbXBOb2RlLm1heFggPSB0ZW1wTm9kZS5wb3NpdGlvblggKyB0ZW1wTm9kZS53aWR0aCAvIDI7XG4gICAgICB0ZW1wTm9kZS5taW5YID0gdGVtcE5vZGUucG9zaXRpb25YIC0gdGVtcE5vZGUud2lkdGggLyAyO1xuICAgICAgdGVtcE5vZGUubWF4WSA9IHRlbXBOb2RlLnBvc2l0aW9uWSArIHRlbXBOb2RlLmhlaWdodCAvIDI7XG4gICAgICB0ZW1wTm9kZS5taW5ZID0gdGVtcE5vZGUucG9zaXRpb25ZIC0gdGVtcE5vZGUuaGVpZ2h0IC8gMjtcbiAgICAgIHRlbXBOb2RlLnBhZExlZnQgPSBwYXJzZUZsb2F0KG4uc3R5bGUoJ3BhZGRpbmcnKSk7XG4gICAgICB0ZW1wTm9kZS5wYWRSaWdodCA9IHBhcnNlRmxvYXQobi5zdHlsZSgncGFkZGluZycpKTtcbiAgICAgIHRlbXBOb2RlLnBhZFRvcCA9IHBhcnNlRmxvYXQobi5zdHlsZSgncGFkZGluZycpKTtcbiAgICAgIHRlbXBOb2RlLnBhZEJvdHRvbSA9IHBhcnNlRmxvYXQobi5zdHlsZSgncGFkZGluZycpKTsgLy8gZm9yY2VzXG5cbiAgICAgIHRlbXBOb2RlLm5vZGVSZXB1bHNpb24gPSBmbiQ2KG9wdGlvbnMubm9kZVJlcHVsc2lvbikgPyBvcHRpb25zLm5vZGVSZXB1bHNpb24obikgOiBvcHRpb25zLm5vZGVSZXB1bHNpb247IC8vIEFkZCBuZXcgbm9kZVxuXG4gICAgICBsYXlvdXRJbmZvLmxheW91dE5vZGVzLnB1c2godGVtcE5vZGUpOyAvLyBBZGQgZW50cnkgdG8gaWQtaW5kZXggbWFwXG5cbiAgICAgIGxheW91dEluZm8uaWRUb0luZGV4W3RlbXBOb2RlLmlkXSA9IGk7XG4gICAgfSAvLyBJbmxpbmUgaW1wbGVtZW50YXRpb24gb2YgYSBxdWV1ZSwgdXNlZCBmb3IgdHJhdmVyc2luZyB0aGUgZ3JhcGggaW4gQkZTIG9yZGVyXG5cblxuICAgIHZhciBxdWV1ZSA9IFtdO1xuICAgIHZhciBzdGFydCA9IDA7IC8vIFBvaW50cyB0byB0aGUgc3RhcnQgdGhlIHF1ZXVlXG5cbiAgICB2YXIgZW5kID0gLTE7IC8vIFBvaW50cyB0byB0aGUgZW5kIG9mIHRoZSBxdWV1ZVxuXG4gICAgdmFyIHRlbXBHcmFwaCA9IFtdOyAvLyBTZWNvbmQgcGFzcyB0byBhZGQgY2hpbGQgaW5mb3JtYXRpb24gYW5kXG4gICAgLy8gaW5pdGlhbGl6ZSBxdWV1ZSBmb3IgaGllcmFyY2hpY2FsIHRyYXZlcnNhbFxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLm5vZGVTaXplOyBpKyspIHtcbiAgICAgIHZhciBuID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tpXTtcbiAgICAgIHZhciBwX2lkID0gbi5wYXJlbnRJZDsgLy8gQ2hlY2sgaWYgbm9kZSBuIGhhcyBhIHBhcmVudCBub2RlXG5cbiAgICAgIGlmIChudWxsICE9IHBfaWQpIHtcbiAgICAgICAgLy8gQWRkIG5vZGUgSWQgdG8gcGFyZW50J3MgbGlzdCBvZiBjaGlsZHJlblxuICAgICAgICBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W3BfaWRdXS5jaGlsZHJlbi5wdXNoKG4uaWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWYgYSBub2RlIGRvZXNuJ3QgaGF2ZSBhIHBhcmVudCwgdGhlbiBpdCdzIGluIHRoZSByb290IGdyYXBoXG4gICAgICAgIHF1ZXVlWysrZW5kXSA9IG4uaWQ7XG4gICAgICAgIHRlbXBHcmFwaC5wdXNoKG4uaWQpO1xuICAgICAgfVxuICAgIH0gLy8gQWRkIHJvb3QgZ3JhcGggdG8gZ3JhcGhTZXRcblxuXG4gICAgbGF5b3V0SW5mby5ncmFwaFNldC5wdXNoKHRlbXBHcmFwaCk7IC8vIFRyYXZlcnNlIHRoZSBncmFwaCwgbGV2ZWwgYnkgbGV2ZWwsXG5cbiAgICB3aGlsZSAoc3RhcnQgPD0gZW5kKSB7XG4gICAgICAvLyBHZXQgdGhlIG5vZGUgdG8gdmlzaXQgYW5kIHJlbW92ZSBpdCBmcm9tIHF1ZXVlXG4gICAgICB2YXIgbm9kZV9pZCA9IHF1ZXVlW3N0YXJ0KytdO1xuICAgICAgdmFyIG5vZGVfaXggPSBsYXlvdXRJbmZvLmlkVG9JbmRleFtub2RlX2lkXTtcbiAgICAgIHZhciBub2RlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tub2RlX2l4XTtcbiAgICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG5cbiAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIEFkZCBjaGlsZHJlbiBub2RlcyBhcyBhIG5ldyBncmFwaCB0byBncmFwaCBzZXRcbiAgICAgICAgbGF5b3V0SW5mby5ncmFwaFNldC5wdXNoKGNoaWxkcmVuKTsgLy8gQWRkIGNoaWxkcmVuIHRvIHF1ZSBxdWV1ZSB0byBiZSB2aXNpdGVkXG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHF1ZXVlWysrZW5kXSA9IGNoaWxkcmVuW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBDcmVhdGUgaW5kZXhUb0dyYXBoIG1hcFxuXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8uZ3JhcGhTZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBncmFwaCA9IGxheW91dEluZm8uZ3JhcGhTZXRbaV07XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZ3JhcGgubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIGluZGV4ID0gbGF5b3V0SW5mby5pZFRvSW5kZXhbZ3JhcGhbal1dO1xuICAgICAgICBsYXlvdXRJbmZvLmluZGV4VG9HcmFwaFtpbmRleF0gPSBpO1xuICAgICAgfVxuICAgIH0gLy8gSXRlcmF0ZSBvdmVyIGFsbCBlZGdlcywgY3JlYXRpbmcgTGF5b3V0IEVkZ2VzXG5cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5lZGdlU2l6ZTsgaSsrKSB7XG4gICAgICB2YXIgZSA9IGVkZ2VzW2ldO1xuICAgICAgdmFyIHRlbXBFZGdlID0ge307XG4gICAgICB0ZW1wRWRnZS5pZCA9IGUuZGF0YSgnaWQnKTtcbiAgICAgIHRlbXBFZGdlLnNvdXJjZUlkID0gZS5kYXRhKCdzb3VyY2UnKTtcbiAgICAgIHRlbXBFZGdlLnRhcmdldElkID0gZS5kYXRhKCd0YXJnZXQnKTsgLy8gQ29tcHV0ZSBpZGVhbCBsZW5ndGhcblxuICAgICAgdmFyIGlkZWFsTGVuZ3RoID0gZm4kNihvcHRpb25zLmlkZWFsRWRnZUxlbmd0aCkgPyBvcHRpb25zLmlkZWFsRWRnZUxlbmd0aChlKSA6IG9wdGlvbnMuaWRlYWxFZGdlTGVuZ3RoO1xuICAgICAgdmFyIGVsYXN0aWNpdHkgPSBmbiQ2KG9wdGlvbnMuZWRnZUVsYXN0aWNpdHkpID8gb3B0aW9ucy5lZGdlRWxhc3RpY2l0eShlKSA6IG9wdGlvbnMuZWRnZUVsYXN0aWNpdHk7IC8vIENoZWNrIGlmIGl0J3MgYW4gaW50ZXIgZ3JhcGggZWRnZVxuXG4gICAgICB2YXIgc291cmNlSXggPSBsYXlvdXRJbmZvLmlkVG9JbmRleFt0ZW1wRWRnZS5zb3VyY2VJZF07XG4gICAgICB2YXIgdGFyZ2V0SXggPSBsYXlvdXRJbmZvLmlkVG9JbmRleFt0ZW1wRWRnZS50YXJnZXRJZF07XG4gICAgICB2YXIgc291cmNlR3JhcGggPSBsYXlvdXRJbmZvLmluZGV4VG9HcmFwaFtzb3VyY2VJeF07XG4gICAgICB2YXIgdGFyZ2V0R3JhcGggPSBsYXlvdXRJbmZvLmluZGV4VG9HcmFwaFt0YXJnZXRJeF07XG5cbiAgICAgIGlmIChzb3VyY2VHcmFwaCAhPSB0YXJnZXRHcmFwaCkge1xuICAgICAgICAvLyBGaW5kIGxvd2VzdCBjb21tb24gZ3JhcGggYW5jZXN0b3JcbiAgICAgICAgdmFyIGxjYSA9IGZpbmRMQ0EodGVtcEVkZ2Uuc291cmNlSWQsIHRlbXBFZGdlLnRhcmdldElkLCBsYXlvdXRJbmZvKTsgLy8gQ29tcHV0ZSBzdW0gb2Ygbm9kZSBkZXB0aHMsIHJlbGF0aXZlIHRvIGxjYSBncmFwaFxuXG4gICAgICAgIHZhciBsY2FHcmFwaCA9IGxheW91dEluZm8uZ3JhcGhTZXRbbGNhXTtcbiAgICAgICAgdmFyIGRlcHRoID0gMDsgLy8gU291cmNlIGRlcHRoXG5cbiAgICAgICAgdmFyIHRlbXBOb2RlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tzb3VyY2VJeF07XG5cbiAgICAgICAgd2hpbGUgKC0xID09PSBsY2FHcmFwaC5pbmRleE9mKHRlbXBOb2RlLmlkKSkge1xuICAgICAgICAgIHRlbXBOb2RlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFt0ZW1wTm9kZS5wYXJlbnRJZF1dO1xuICAgICAgICAgIGRlcHRoKys7XG4gICAgICAgIH0gLy8gVGFyZ2V0IGRlcHRoXG5cblxuICAgICAgICB0ZW1wTm9kZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbdGFyZ2V0SXhdO1xuXG4gICAgICAgIHdoaWxlICgtMSA9PT0gbGNhR3JhcGguaW5kZXhPZih0ZW1wTm9kZS5pZCkpIHtcbiAgICAgICAgICB0ZW1wTm9kZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbdGVtcE5vZGUucGFyZW50SWRdXTtcbiAgICAgICAgICBkZXB0aCsrO1xuICAgICAgICB9IC8vIGxvZ0RlYnVnKCdMQ0Egb2Ygbm9kZXMgJyArIHRlbXBFZGdlLnNvdXJjZUlkICsgJyBhbmQgJyArIHRlbXBFZGdlLnRhcmdldElkICtcbiAgICAgICAgLy8gIFwiLiBJbmRleDogXCIgKyBsY2EgKyBcIiBDb250ZW50czogXCIgKyBsY2FHcmFwaC50b1N0cmluZygpICtcbiAgICAgICAgLy8gIFwiLiBEZXB0aDogXCIgKyBkZXB0aCk7XG4gICAgICAgIC8vIFVwZGF0ZSBpZGVhbExlbmd0aFxuXG5cbiAgICAgICAgaWRlYWxMZW5ndGggKj0gZGVwdGggKiBvcHRpb25zLm5lc3RpbmdGYWN0b3I7XG4gICAgICB9XG5cbiAgICAgIHRlbXBFZGdlLmlkZWFsTGVuZ3RoID0gaWRlYWxMZW5ndGg7XG4gICAgICB0ZW1wRWRnZS5lbGFzdGljaXR5ID0gZWxhc3RpY2l0eTtcbiAgICAgIGxheW91dEluZm8ubGF5b3V0RWRnZXMucHVzaCh0ZW1wRWRnZSk7XG4gICAgfSAvLyBGaW5hbGx5LCByZXR1cm4gbGF5b3V0SW5mbyBvYmplY3RcblxuXG4gICAgcmV0dXJuIGxheW91dEluZm87XG4gIH07XG4gIC8qKlxuICAgKiBAYnJpZWYgOiBUaGlzIGZ1bmN0aW9uIGZpbmRzIHRoZSBpbmRleCBvZiB0aGUgbG93ZXN0IGNvbW1vblxuICAgKiAgICAgICAgICBncmFwaCBhbmNlc3RvciBiZXR3ZWVuIDIgbm9kZXMgaW4gdGhlIHN1YnRyZWVcbiAgICogICAgICAgICAgKGZyb20gdGhlIGdyYXBoIGhpZXJhcmNoeSBpbmR1Y2VkIHRyZWUpIHdob3NlXG4gICAqICAgICAgICAgIHJvb3QgaXMgZ3JhcGhJeFxuICAgKlxuICAgKiBAYXJnIG5vZGUxOiBub2RlMSdzIElEXG4gICAqIEBhcmcgbm9kZTI6IG5vZGUyJ3MgSURcbiAgICogQGFyZyBsYXlvdXRJbmZvOiBsYXlvdXRJbmZvIG9iamVjdFxuICAgKlxuICAgKi9cblxuXG4gIHZhciBmaW5kTENBID0gZnVuY3Rpb24gZmluZExDQShub2RlMSwgbm9kZTIsIGxheW91dEluZm8pIHtcbiAgICAvLyBGaW5kIHRoZWlyIGNvbW1vbiBhbmNlc3Rlciwgc3RhcnRpbmcgZnJvbSB0aGUgcm9vdCBncmFwaFxuICAgIHZhciByZXMgPSBmaW5kTENBX2F1eChub2RlMSwgbm9kZTIsIDAsIGxheW91dEluZm8pO1xuXG4gICAgaWYgKDIgPiByZXMuY291bnQpIHtcbiAgICAgIC8vIElmIGF1eCBmdW5jdGlvbiBjb3VsZG4ndCBmaW5kIHRoZSBjb21tb24gYW5jZXN0ZXIsXG4gICAgICAvLyB0aGVuIGl0IGlzIHRoZSByb290IGdyYXBoXG4gICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJlcy5ncmFwaDtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBAYnJpZWYgICAgICAgICAgOiBBdXhpbGlhcnkgZnVuY3Rpb24gdXNlZCBmb3IgTENBIGNvbXB1dGF0aW9uXG4gICAqXG4gICAqIEBhcmcgbm9kZTEgICAgICA6IG5vZGUxJ3MgSURcbiAgICogQGFyZyBub2RlMiAgICAgIDogbm9kZTIncyBJRFxuICAgKiBAYXJnIGdyYXBoSXggICAgOiBzdWJncmFwaCBpbmRleFxuICAgKiBAYXJnIGxheW91dEluZm8gOiBsYXlvdXRJbmZvIG9iamVjdFxuICAgKlxuICAgKiBAcmV0dXJuICAgICAgICAgOiBvYmplY3Qgb2YgdGhlIGZvcm0ge2NvdW50OiBYLCBncmFwaDogWX0sIHdoZXJlOlxuICAgKiAgICAgICAgICAgICAgICAgICBYIGlzIHRoZSBudW1iZXIgb2YgYW5jZXN0b3JzIChtYXg6IDIpIGZvdW5kIGluXG4gICAqICAgICAgICAgICAgICAgICAgIGdyYXBoSXggKGFuZCBpdCdzIHN1YmdyYXBocyksXG4gICAqICAgICAgICAgICAgICAgICAgIFkgaXMgdGhlIGdyYXBoIGluZGV4IG9mIHRoZSBsb3dlc3QgZ3JhcGggY29udGFpbmluZ1xuICAgKiAgICAgICAgICAgICAgICAgICBhbGwgWCBub2Rlc1xuICAgKi9cblxuXG4gIHZhciBmaW5kTENBX2F1eCA9IGZ1bmN0aW9uIGZpbmRMQ0FfYXV4KG5vZGUxLCBub2RlMiwgZ3JhcGhJeCwgbGF5b3V0SW5mbykge1xuICAgIHZhciBncmFwaCA9IGxheW91dEluZm8uZ3JhcGhTZXRbZ3JhcGhJeF07IC8vIElmIGJvdGggbm9kZXMgYmVsb25ncyB0byBncmFwaEl4XG5cbiAgICBpZiAoLTEgPCBncmFwaC5pbmRleE9mKG5vZGUxKSAmJiAtMSA8IGdyYXBoLmluZGV4T2Yobm9kZTIpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb3VudDogMixcbiAgICAgICAgZ3JhcGg6IGdyYXBoSXhcbiAgICAgIH07XG4gICAgfSAvLyBNYWtlIHJlY3Vyc2l2ZSBjYWxscyBmb3IgYWxsIHN1YmdyYXBoc1xuXG5cbiAgICB2YXIgYyA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyYXBoLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbm9kZUlkID0gZ3JhcGhbaV07XG4gICAgICB2YXIgbm9kZUl4ID0gbGF5b3V0SW5mby5pZFRvSW5kZXhbbm9kZUlkXTtcbiAgICAgIHZhciBjaGlsZHJlbiA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbm9kZUl4XS5jaGlsZHJlbjsgLy8gSWYgdGhlIG5vZGUgaGFzIG5vIGNoaWxkLCBza2lwIGl0XG5cbiAgICAgIGlmICgwID09PSBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBjaGlsZEdyYXBoSXggPSBsYXlvdXRJbmZvLmluZGV4VG9HcmFwaFtsYXlvdXRJbmZvLmlkVG9JbmRleFtjaGlsZHJlblswXV1dO1xuICAgICAgdmFyIHJlc3VsdCA9IGZpbmRMQ0FfYXV4KG5vZGUxLCBub2RlMiwgY2hpbGRHcmFwaEl4LCBsYXlvdXRJbmZvKTtcblxuICAgICAgaWYgKDAgPT09IHJlc3VsdC5jb3VudCkge1xuICAgICAgICAvLyBOZWl0aGVyIG5vZGUxIG5vciBub2RlMiBhcmUgcHJlc2VudCBpbiB0aGlzIHN1YmdyYXBoXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIGlmICgxID09PSByZXN1bHQuY291bnQpIHtcbiAgICAgICAgLy8gT25lIG9mIChub2RlMSwgbm9kZTIpIGlzIHByZXNlbnQgaW4gdGhpcyBzdWJncmFwaFxuICAgICAgICBjKys7XG5cbiAgICAgICAgaWYgKDIgPT09IGMpIHtcbiAgICAgICAgICAvLyBXZSd2ZSBhbHJlYWR5IGZvdW5kIGJvdGggbm9kZXMsIG5vIG5lZWQgdG8ga2VlcCBzZWFyY2hpbmdcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQm90aCBub2RlcyBhcmUgcHJlc2VudCBpbiB0aGlzIHN1YmdyYXBoXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvdW50OiBjLFxuICAgICAgZ3JhcGg6IGdyYXBoSXhcbiAgICB9O1xuICB9O1xuICAvKipcbiAgICogQGJyaWVmOiBwcmludHNMYXlvdXRJbmZvIGludG8ganMgY29uc29sZVxuICAgKiAgICAgICAgIE9ubHkgdXNlZCBmb3IgZGViYnVnaW5nXG4gICAqL1xuXG5cbnZhciBwcmludExheW91dEluZm87IFxuICAvKipcbiAgICogQGJyaWVmIDogUmFuZG9taXplcyB0aGUgcG9zaXRpb24gb2YgYWxsIG5vZGVzXG4gICAqL1xuXG5cbiAgdmFyIHJhbmRvbWl6ZVBvc2l0aW9ucyA9IGZ1bmN0aW9uIHJhbmRvbWl6ZVBvc2l0aW9ucyhsYXlvdXRJbmZvLCBjeSkge1xuICAgIHZhciB3aWR0aCA9IGxheW91dEluZm8uY2xpZW50V2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IGxheW91dEluZm8uY2xpZW50SGVpZ2h0O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLm5vZGVTaXplOyBpKyspIHtcbiAgICAgIHZhciBuID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tpXTsgLy8gTm8gbmVlZCB0byByYW5kb21pemUgY29tcG91bmQgbm9kZXMgb3IgbG9ja2VkIG5vZGVzXG5cbiAgICAgIGlmICgwID09PSBuLmNoaWxkcmVuLmxlbmd0aCAmJiAhbi5pc0xvY2tlZCkge1xuICAgICAgICBuLnBvc2l0aW9uWCA9IE1hdGgucmFuZG9tKCkgKiB3aWR0aDtcbiAgICAgICAgbi5wb3NpdGlvblkgPSBNYXRoLnJhbmRvbSgpICogaGVpZ2h0O1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgZ2V0U2NhbGVJbkJvdW5kc0ZuID0gZnVuY3Rpb24gZ2V0U2NhbGVJbkJvdW5kc0ZuKGxheW91dEluZm8sIG9wdGlvbnMsIG5vZGVzKSB7XG4gICAgdmFyIGJiID0gbGF5b3V0SW5mby5ib3VuZGluZ0JveDtcbiAgICB2YXIgY29zZUJCID0ge1xuICAgICAgeDE6IEluZmluaXR5LFxuICAgICAgeDI6IC1JbmZpbml0eSxcbiAgICAgIHkxOiBJbmZpbml0eSxcbiAgICAgIHkyOiAtSW5maW5pdHlcbiAgICB9O1xuXG4gICAgaWYgKG9wdGlvbnMuYm91bmRpbmdCb3gpIHtcbiAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIGxub2RlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFtub2RlLmRhdGEoJ2lkJyldXTtcbiAgICAgICAgY29zZUJCLngxID0gTWF0aC5taW4oY29zZUJCLngxLCBsbm9kZS5wb3NpdGlvblgpO1xuICAgICAgICBjb3NlQkIueDIgPSBNYXRoLm1heChjb3NlQkIueDIsIGxub2RlLnBvc2l0aW9uWCk7XG4gICAgICAgIGNvc2VCQi55MSA9IE1hdGgubWluKGNvc2VCQi55MSwgbG5vZGUucG9zaXRpb25ZKTtcbiAgICAgICAgY29zZUJCLnkyID0gTWF0aC5tYXgoY29zZUJCLnkyLCBsbm9kZS5wb3NpdGlvblkpO1xuICAgICAgfSk7XG4gICAgICBjb3NlQkIudyA9IGNvc2VCQi54MiAtIGNvc2VCQi54MTtcbiAgICAgIGNvc2VCQi5oID0gY29zZUJCLnkyIC0gY29zZUJCLnkxO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoZWxlLCBpKSB7XG4gICAgICB2YXIgbG5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W2VsZS5kYXRhKCdpZCcpXV07XG5cbiAgICAgIGlmIChvcHRpb25zLmJvdW5kaW5nQm94KSB7XG4gICAgICAgIC8vIHRoZW4gYWRkIGV4dHJhIGJvdW5kaW5nIGJveCBjb25zdHJhaW50XG4gICAgICAgIHZhciBwY3RYID0gKGxub2RlLnBvc2l0aW9uWCAtIGNvc2VCQi54MSkgLyBjb3NlQkIudztcbiAgICAgICAgdmFyIHBjdFkgPSAobG5vZGUucG9zaXRpb25ZIC0gY29zZUJCLnkxKSAvIGNvc2VCQi5oO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IGJiLngxICsgcGN0WCAqIGJiLncsXG4gICAgICAgICAgeTogYmIueTEgKyBwY3RZICogYmIuaFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiBsbm9kZS5wb3NpdGlvblgsXG4gICAgICAgICAgeTogbG5vZGUucG9zaXRpb25ZXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbiAgLyoqXG4gICAqIEBicmllZiAgICAgICAgICA6IFVwZGF0ZXMgdGhlIHBvc2l0aW9ucyBvZiBub2RlcyBpbiB0aGUgbmV0d29ya1xuICAgKiBAYXJnIGxheW91dEluZm8gOiBMYXlvdXRJbmZvIG9iamVjdFxuICAgKiBAYXJnIGN5ICAgICAgICAgOiBDeXRvc2NhcGUgb2JqZWN0XG4gICAqIEBhcmcgb3B0aW9ucyAgICA6IExheW91dCBvcHRpb25zXG4gICAqL1xuXG5cbiAgdmFyIHJlZnJlc2hQb3NpdGlvbnMgPSBmdW5jdGlvbiByZWZyZXNoUG9zaXRpb25zKGxheW91dEluZm8sIGN5LCBvcHRpb25zKSB7XG4gICAgLy8gdmFyIHMgPSAnUmVmcmVzaGluZyBwb3NpdGlvbnMnO1xuICAgIC8vIGxvZ0RlYnVnKHMpO1xuICAgIHZhciBsYXlvdXQgPSBvcHRpb25zLmxheW91dDtcbiAgICB2YXIgbm9kZXMgPSBvcHRpb25zLmVsZXMubm9kZXMoKTtcbiAgICB2YXIgZ2V0U2NhbGVkUG9zID0gZ2V0U2NhbGVJbkJvdW5kc0ZuKGxheW91dEluZm8sIG9wdGlvbnMsIG5vZGVzKTtcbiAgICBub2Rlcy5wb3NpdGlvbnMoZ2V0U2NhbGVkUG9zKTsgLy8gVHJpZ2dlciBsYXlvdXRSZWFkeSBvbmx5IG9uIGZpcnN0IGNhbGxcblxuICAgIGlmICh0cnVlICE9PSBsYXlvdXRJbmZvLnJlYWR5KSB7XG4gICAgICAvLyBzID0gJ1RyaWdnZXJpbmcgbGF5b3V0cmVhZHknO1xuICAgICAgLy8gbG9nRGVidWcocyk7XG4gICAgICBsYXlvdXRJbmZvLnJlYWR5ID0gdHJ1ZTtcbiAgICAgIGxheW91dC5vbmUoJ2xheW91dHJlYWR5Jywgb3B0aW9ucy5yZWFkeSk7XG4gICAgICBsYXlvdXQuZW1pdCh7XG4gICAgICAgIHR5cGU6ICdsYXlvdXRyZWFkeScsXG4gICAgICAgIGxheW91dDogdGhpc1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogQGJyaWVmIDogTG9ncyBhIGRlYnVnIG1lc3NhZ2UgaW4gSlMgY29uc29sZSwgaWYgREVCVUcgaXMgT05cbiAgICovXG4gIC8vIHZhciBsb2dEZWJ1ZyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgLy8gICBpZiAoREVCVUcpIHtcbiAgLy8gICAgIGNvbnNvbGUuZGVidWcodGV4dCk7XG4gIC8vICAgfVxuICAvLyB9O1xuXG4gIC8qKlxuICAgKiBAYnJpZWYgICAgICAgICAgOiBQZXJmb3JtcyBvbmUgaXRlcmF0aW9uIG9mIHRoZSBwaHlzaWNhbCBzaW11bGF0aW9uXG4gICAqIEBhcmcgbGF5b3V0SW5mbyA6IExheW91dEluZm8gb2JqZWN0IGFscmVhZHkgaW5pdGlhbGl6ZWRcbiAgICogQGFyZyBjeSAgICAgICAgIDogQ3l0b3NjYXBlIG9iamVjdFxuICAgKiBAYXJnIG9wdGlvbnMgICAgOiBMYXlvdXQgb3B0aW9uc1xuICAgKi9cblxuXG4gIHZhciBzdGVwID0gZnVuY3Rpb24gc3RlcChsYXlvdXRJbmZvLCBvcHRpb25zLCBfc3RlcCkge1xuICAgIC8vIHZhciBzID0gXCJcXG5cXG4jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXCI7XG4gICAgLy8gcyArPSBcIlxcblNURVA6IFwiICsgc3RlcDtcbiAgICAvLyBzICs9IFwiXFxuIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xcblwiO1xuICAgIC8vIGxvZ0RlYnVnKHMpO1xuICAgIC8vIENhbGN1bGF0ZSBub2RlIHJlcHVsc2lvbnNcbiAgICBjYWxjdWxhdGVOb2RlRm9yY2VzKGxheW91dEluZm8sIG9wdGlvbnMpOyAvLyBDYWxjdWxhdGUgZWRnZSBmb3JjZXNcblxuICAgIGNhbGN1bGF0ZUVkZ2VGb3JjZXMobGF5b3V0SW5mbyk7IC8vIENhbGN1bGF0ZSBncmF2aXR5IGZvcmNlc1xuXG4gICAgY2FsY3VsYXRlR3Jhdml0eUZvcmNlcyhsYXlvdXRJbmZvLCBvcHRpb25zKTsgLy8gUHJvcGFnYXRlIGZvcmNlcyBmcm9tIHBhcmVudCB0byBjaGlsZFxuXG4gICAgcHJvcGFnYXRlRm9yY2VzKGxheW91dEluZm8pOyAvLyBVcGRhdGUgcG9zaXRpb25zIGJhc2VkIG9uIGNhbGN1bGF0ZWQgZm9yY2VzXG5cbiAgICB1cGRhdGVQb3NpdGlvbnMobGF5b3V0SW5mbyk7XG4gIH07XG4gIC8qKlxuICAgKiBAYnJpZWYgOiBDb21wdXRlcyB0aGUgbm9kZSByZXB1bHNpb24gZm9yY2VzXG4gICAqL1xuXG5cbiAgdmFyIGNhbGN1bGF0ZU5vZGVGb3JjZXMgPSBmdW5jdGlvbiBjYWxjdWxhdGVOb2RlRm9yY2VzKGxheW91dEluZm8sIG9wdGlvbnMpIHtcbiAgICAvLyBHbyB0aHJvdWdoIGVhY2ggb2YgdGhlIGdyYXBocyBpbiBncmFwaFNldFxuICAgIC8vIE5vZGVzIG9ubHkgcmVwZWwgZWFjaCBvdGhlciBpZiB0aGV5IGJlbG9uZyB0byB0aGUgc2FtZSBncmFwaFxuICAgIC8vIHZhciBzID0gJ2NhbGN1bGF0ZU5vZGVGb3JjZXMnO1xuICAgIC8vIGxvZ0RlYnVnKHMpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5ncmFwaFNldC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGdyYXBoID0gbGF5b3V0SW5mby5ncmFwaFNldFtpXTtcbiAgICAgIHZhciBudW1Ob2RlcyA9IGdyYXBoLmxlbmd0aDsgLy8gcyA9IFwiU2V0OiBcIiArIGdyYXBoLnRvU3RyaW5nKCk7XG4gICAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICAgIC8vIE5vdyBnZXQgYWxsIHRoZSBwYWlycyBvZiBub2Rlc1xuICAgICAgLy8gT25seSBnZXQgZWFjaCBwYWlyIG9uY2UsIChBLCBCKSA9IChCLCBBKVxuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG51bU5vZGVzOyBqKyspIHtcbiAgICAgICAgdmFyIG5vZGUxID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFtncmFwaFtqXV1dO1xuXG4gICAgICAgIGZvciAodmFyIGsgPSBqICsgMTsgayA8IG51bU5vZGVzOyBrKyspIHtcbiAgICAgICAgICB2YXIgbm9kZTIgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W2dyYXBoW2tdXV07XG4gICAgICAgICAgbm9kZVJlcHVsc2lvbihub2RlMSwgbm9kZTIsIGxheW91dEluZm8sIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciByYW5kb21EaXN0YW5jZSA9IGZ1bmN0aW9uIHJhbmRvbURpc3RhbmNlKG1heCkge1xuICAgIHJldHVybiAtbWF4ICsgMiAqIG1heCAqIE1hdGgucmFuZG9tKCk7XG4gIH07XG4gIC8qKlxuICAgKiBAYnJpZWYgOiBDb21wdXRlIHRoZSBub2RlIHJlcHVsc2lvbiBmb3JjZXMgYmV0d2VlbiBhIHBhaXIgb2Ygbm9kZXNcbiAgICovXG5cblxuICB2YXIgbm9kZVJlcHVsc2lvbiA9IGZ1bmN0aW9uIG5vZGVSZXB1bHNpb24obm9kZTEsIG5vZGUyLCBsYXlvdXRJbmZvLCBvcHRpb25zKSB7XG4gICAgLy8gdmFyIHMgPSBcIk5vZGUgcmVwdWxzaW9uLiBOb2RlMTogXCIgKyBub2RlMS5pZCArIFwiIE5vZGUyOiBcIiArIG5vZGUyLmlkO1xuICAgIHZhciBjbXB0SWQxID0gbm9kZTEuY21wdElkO1xuICAgIHZhciBjbXB0SWQyID0gbm9kZTIuY21wdElkO1xuXG4gICAgaWYgKGNtcHRJZDEgIT09IGNtcHRJZDIgJiYgIWxheW91dEluZm8uaXNDb21wb3VuZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gR2V0IGRpcmVjdGlvbiBvZiBsaW5lIGNvbm5lY3RpbmcgYm90aCBub2RlIGNlbnRlcnNcblxuXG4gICAgdmFyIGRpcmVjdGlvblggPSBub2RlMi5wb3NpdGlvblggLSBub2RlMS5wb3NpdGlvblg7XG4gICAgdmFyIGRpcmVjdGlvblkgPSBub2RlMi5wb3NpdGlvblkgLSBub2RlMS5wb3NpdGlvblk7XG4gICAgdmFyIG1heFJhbmREaXN0ID0gMTsgLy8gcyArPSBcIlxcbmRpcmVjdGlvblg6IFwiICsgZGlyZWN0aW9uWCArIFwiLCBkaXJlY3Rpb25ZOiBcIiArIGRpcmVjdGlvblk7XG4gICAgLy8gSWYgYm90aCBjZW50ZXJzIGFyZSB0aGUgc2FtZSwgYXBwbHkgYSByYW5kb20gZm9yY2VcblxuICAgIGlmICgwID09PSBkaXJlY3Rpb25YICYmIDAgPT09IGRpcmVjdGlvblkpIHtcbiAgICAgIGRpcmVjdGlvblggPSByYW5kb21EaXN0YW5jZShtYXhSYW5kRGlzdCk7XG4gICAgICBkaXJlY3Rpb25ZID0gcmFuZG9tRGlzdGFuY2UobWF4UmFuZERpc3QpO1xuICAgIH1cblxuICAgIHZhciBvdmVybGFwID0gbm9kZXNPdmVybGFwKG5vZGUxLCBub2RlMiwgZGlyZWN0aW9uWCwgZGlyZWN0aW9uWSk7XG5cbiAgICBpZiAob3ZlcmxhcCA+IDApIHtcbiAgICAgIC8vIHMgKz0gXCJcXG5Ob2RlcyBETyBvdmVybGFwLlwiO1xuICAgICAgLy8gcyArPSBcIlxcbk92ZXJsYXA6IFwiICsgb3ZlcmxhcDtcbiAgICAgIC8vIElmIG5vZGVzIG92ZXJsYXAsIHJlcHVsc2lvbiBmb3JjZSBpcyBwcm9wb3J0aW9uYWxcbiAgICAgIC8vIHRvIHRoZSBvdmVybGFwXG4gICAgICB2YXIgZm9yY2UgPSBvcHRpb25zLm5vZGVPdmVybGFwICogb3ZlcmxhcDsgLy8gQ29tcHV0ZSB0aGUgbW9kdWxlIGFuZCBjb21wb25lbnRzIG9mIHRoZSBmb3JjZSB2ZWN0b3JcblxuICAgICAgdmFyIGRpc3RhbmNlID0gTWF0aC5zcXJ0KGRpcmVjdGlvblggKiBkaXJlY3Rpb25YICsgZGlyZWN0aW9uWSAqIGRpcmVjdGlvblkpOyAvLyBzICs9IFwiXFxuRGlzdGFuY2U6IFwiICsgZGlzdGFuY2U7XG5cbiAgICAgIHZhciBmb3JjZVggPSBmb3JjZSAqIGRpcmVjdGlvblggLyBkaXN0YW5jZTtcbiAgICAgIHZhciBmb3JjZVkgPSBmb3JjZSAqIGRpcmVjdGlvblkgLyBkaXN0YW5jZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcyArPSBcIlxcbk5vZGVzIGRvIE5PVCBvdmVybGFwLlwiO1xuICAgICAgLy8gSWYgdGhlcmUncyBubyBvdmVybGFwLCBmb3JjZSBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsXG4gICAgICAvLyB0byBzcXVhcmVkIGRpc3RhbmNlXG4gICAgICAvLyBHZXQgY2xpcHBpbmcgcG9pbnRzIGZvciBib3RoIG5vZGVzXG4gICAgICB2YXIgcG9pbnQxID0gZmluZENsaXBwaW5nUG9pbnQobm9kZTEsIGRpcmVjdGlvblgsIGRpcmVjdGlvblkpO1xuICAgICAgdmFyIHBvaW50MiA9IGZpbmRDbGlwcGluZ1BvaW50KG5vZGUyLCAtMSAqIGRpcmVjdGlvblgsIC0xICogZGlyZWN0aW9uWSk7IC8vIFVzZSBjbGlwcGluZyBwb2ludHMgdG8gY29tcHV0ZSBkaXN0YW5jZVxuXG4gICAgICB2YXIgZGlzdGFuY2VYID0gcG9pbnQyLnggLSBwb2ludDEueDtcbiAgICAgIHZhciBkaXN0YW5jZVkgPSBwb2ludDIueSAtIHBvaW50MS55O1xuICAgICAgdmFyIGRpc3RhbmNlU3FyID0gZGlzdGFuY2VYICogZGlzdGFuY2VYICsgZGlzdGFuY2VZICogZGlzdGFuY2VZO1xuICAgICAgdmFyIGRpc3RhbmNlID0gTWF0aC5zcXJ0KGRpc3RhbmNlU3FyKTsgLy8gcyArPSBcIlxcbkRpc3RhbmNlOiBcIiArIGRpc3RhbmNlO1xuICAgICAgLy8gQ29tcHV0ZSB0aGUgbW9kdWxlIGFuZCBjb21wb25lbnRzIG9mIHRoZSBmb3JjZSB2ZWN0b3JcblxuICAgICAgdmFyIGZvcmNlID0gKG5vZGUxLm5vZGVSZXB1bHNpb24gKyBub2RlMi5ub2RlUmVwdWxzaW9uKSAvIGRpc3RhbmNlU3FyO1xuICAgICAgdmFyIGZvcmNlWCA9IGZvcmNlICogZGlzdGFuY2VYIC8gZGlzdGFuY2U7XG4gICAgICB2YXIgZm9yY2VZID0gZm9yY2UgKiBkaXN0YW5jZVkgLyBkaXN0YW5jZTtcbiAgICB9IC8vIEFwcGx5IGZvcmNlXG5cblxuICAgIGlmICghbm9kZTEuaXNMb2NrZWQpIHtcbiAgICAgIG5vZGUxLm9mZnNldFggLT0gZm9yY2VYO1xuICAgICAgbm9kZTEub2Zmc2V0WSAtPSBmb3JjZVk7XG4gICAgfVxuXG4gICAgaWYgKCFub2RlMi5pc0xvY2tlZCkge1xuICAgICAgbm9kZTIub2Zmc2V0WCArPSBmb3JjZVg7XG4gICAgICBub2RlMi5vZmZzZXRZICs9IGZvcmNlWTtcbiAgICB9IC8vIHMgKz0gXCJcXG5Gb3JjZVg6IFwiICsgZm9yY2VYICsgXCIgRm9yY2VZOiBcIiArIGZvcmNlWTtcbiAgICAvLyBsb2dEZWJ1ZyhzKTtcblxuXG4gICAgcmV0dXJuO1xuICB9O1xuICAvKipcbiAgICogQGJyaWVmICA6IERldGVybWluZXMgd2hldGhlciB0d28gbm9kZXMgb3ZlcmxhcCBvciBub3RcbiAgICogQHJldHVybiA6IEFtb3VudCBvZiBvdmVybGFwcGluZyAoMCA9PiBubyBvdmVybGFwKVxuICAgKi9cblxuXG4gIHZhciBub2Rlc092ZXJsYXAgPSBmdW5jdGlvbiBub2Rlc092ZXJsYXAobm9kZTEsIG5vZGUyLCBkWCwgZFkpIHtcbiAgICBpZiAoZFggPiAwKSB7XG4gICAgICB2YXIgb3ZlcmxhcFggPSBub2RlMS5tYXhYIC0gbm9kZTIubWluWDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG92ZXJsYXBYID0gbm9kZTIubWF4WCAtIG5vZGUxLm1pblg7XG4gICAgfVxuXG4gICAgaWYgKGRZID4gMCkge1xuICAgICAgdmFyIG92ZXJsYXBZID0gbm9kZTEubWF4WSAtIG5vZGUyLm1pblk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBvdmVybGFwWSA9IG5vZGUyLm1heFkgLSBub2RlMS5taW5ZO1xuICAgIH1cblxuICAgIGlmIChvdmVybGFwWCA+PSAwICYmIG92ZXJsYXBZID49IDApIHtcbiAgICAgIHJldHVybiBNYXRoLnNxcnQob3ZlcmxhcFggKiBvdmVybGFwWCArIG92ZXJsYXBZICogb3ZlcmxhcFkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBAYnJpZWYgOiBGaW5kcyB0aGUgcG9pbnQgaW4gd2hpY2ggYW4gZWRnZSAoZGlyZWN0aW9uIGRYLCBkWSkgaW50ZXJzZWN0c1xuICAgKiAgICAgICAgICB0aGUgcmVjdGFuZ3VsYXIgYm91bmRpbmcgYm94IG9mIGl0J3Mgc291cmNlL3RhcmdldCBub2RlXG4gICAqL1xuXG5cbiAgdmFyIGZpbmRDbGlwcGluZ1BvaW50ID0gZnVuY3Rpb24gZmluZENsaXBwaW5nUG9pbnQobm9kZSwgZFgsIGRZKSB7XG4gICAgLy8gU2hvcmN1dHNcbiAgICB2YXIgWCA9IG5vZGUucG9zaXRpb25YO1xuICAgIHZhciBZID0gbm9kZS5wb3NpdGlvblk7XG4gICAgdmFyIEggPSBub2RlLmhlaWdodCB8fCAxO1xuICAgIHZhciBXID0gbm9kZS53aWR0aCB8fCAxO1xuICAgIHZhciBkaXJTbG9wZSA9IGRZIC8gZFg7XG4gICAgdmFyIG5vZGVTbG9wZSA9IEggLyBXOyAvLyB2YXIgcyA9ICdDb21wdXRpbmcgY2xpcHBpbmcgcG9pbnQgb2Ygbm9kZSAnICsgbm9kZS5pZCArXG4gICAgLy8gICBcIiAuIEhlaWdodDogIFwiICsgSCArIFwiLCBXaWR0aDogXCIgKyBXICtcbiAgICAvLyAgIFwiXFxuRGlyZWN0aW9uIFwiICsgZFggKyBcIiwgXCIgKyBkWTtcbiAgICAvL1xuICAgIC8vIENvbXB1dGUgaW50ZXJzZWN0aW9uXG5cbiAgICB2YXIgcmVzID0ge307IC8vIENhc2U6IFZlcnRpY2FsIGRpcmVjdGlvbiAodXApXG5cbiAgICBpZiAoMCA9PT0gZFggJiYgMCA8IGRZKSB7XG4gICAgICByZXMueCA9IFg7IC8vIHMgKz0gXCJcXG5VcCBkaXJlY3Rpb25cIjtcblxuICAgICAgcmVzLnkgPSBZICsgSCAvIDI7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0gLy8gQ2FzZTogVmVydGljYWwgZGlyZWN0aW9uIChkb3duKVxuXG5cbiAgICBpZiAoMCA9PT0gZFggJiYgMCA+IGRZKSB7XG4gICAgICByZXMueCA9IFg7XG4gICAgICByZXMueSA9IFkgKyBIIC8gMjsgLy8gcyArPSBcIlxcbkRvd24gZGlyZWN0aW9uXCI7XG5cbiAgICAgIHJldHVybiByZXM7XG4gICAgfSAvLyBDYXNlOiBJbnRlcnNlY3RzIHRoZSByaWdodCBib3JkZXJcblxuXG4gICAgaWYgKDAgPCBkWCAmJiAtMSAqIG5vZGVTbG9wZSA8PSBkaXJTbG9wZSAmJiBkaXJTbG9wZSA8PSBub2RlU2xvcGUpIHtcbiAgICAgIHJlcy54ID0gWCArIFcgLyAyO1xuICAgICAgcmVzLnkgPSBZICsgVyAqIGRZIC8gMiAvIGRYOyAvLyBzICs9IFwiXFxuUmlnaHRib3JkZXJcIjtcblxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9IC8vIENhc2U6IEludGVyc2VjdHMgdGhlIGxlZnQgYm9yZGVyXG5cblxuICAgIGlmICgwID4gZFggJiYgLTEgKiBub2RlU2xvcGUgPD0gZGlyU2xvcGUgJiYgZGlyU2xvcGUgPD0gbm9kZVNsb3BlKSB7XG4gICAgICByZXMueCA9IFggLSBXIC8gMjtcbiAgICAgIHJlcy55ID0gWSAtIFcgKiBkWSAvIDIgLyBkWDsgLy8gcyArPSBcIlxcbkxlZnRib3JkZXJcIjtcblxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9IC8vIENhc2U6IEludGVyc2VjdHMgdGhlIHRvcCBib3JkZXJcblxuXG4gICAgaWYgKDAgPCBkWSAmJiAoZGlyU2xvcGUgPD0gLTEgKiBub2RlU2xvcGUgfHwgZGlyU2xvcGUgPj0gbm9kZVNsb3BlKSkge1xuICAgICAgcmVzLnggPSBYICsgSCAqIGRYIC8gMiAvIGRZO1xuICAgICAgcmVzLnkgPSBZICsgSCAvIDI7IC8vIHMgKz0gXCJcXG5Ub3AgYm9yZGVyXCI7XG5cbiAgICAgIHJldHVybiByZXM7XG4gICAgfSAvLyBDYXNlOiBJbnRlcnNlY3RzIHRoZSBib3R0b20gYm9yZGVyXG5cblxuICAgIGlmICgwID4gZFkgJiYgKGRpclNsb3BlIDw9IC0xICogbm9kZVNsb3BlIHx8IGRpclNsb3BlID49IG5vZGVTbG9wZSkpIHtcbiAgICAgIHJlcy54ID0gWCAtIEggKiBkWCAvIDIgLyBkWTtcbiAgICAgIHJlcy55ID0gWSAtIEggLyAyOyAvLyBzICs9IFwiXFxuQm90dG9tIGJvcmRlclwiO1xuXG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0gLy8gcyArPSBcIlxcbkNsaXBwaW5nIHBvaW50IGZvdW5kIGF0IFwiICsgcmVzLnggKyBcIiwgXCIgKyByZXMueTtcbiAgICAvLyBsb2dEZWJ1ZyhzKTtcblxuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcbiAgLyoqXG4gICAqIEBicmllZiA6IENhbGN1bGF0ZXMgYWxsIGVkZ2UgZm9yY2VzXG4gICAqL1xuXG5cbiAgdmFyIGNhbGN1bGF0ZUVkZ2VGb3JjZXMgPSBmdW5jdGlvbiBjYWxjdWxhdGVFZGdlRm9yY2VzKGxheW91dEluZm8sIG9wdGlvbnMpIHtcbiAgICAvLyBJdGVyYXRlIG92ZXIgYWxsIGVkZ2VzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLmVkZ2VTaXplOyBpKyspIHtcbiAgICAgIC8vIEdldCBlZGdlLCBzb3VyY2UgJiB0YXJnZXQgbm9kZXNcbiAgICAgIHZhciBlZGdlID0gbGF5b3V0SW5mby5sYXlvdXRFZGdlc1tpXTtcbiAgICAgIHZhciBzb3VyY2VJeCA9IGxheW91dEluZm8uaWRUb0luZGV4W2VkZ2Uuc291cmNlSWRdO1xuICAgICAgdmFyIHNvdXJjZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbc291cmNlSXhdO1xuICAgICAgdmFyIHRhcmdldEl4ID0gbGF5b3V0SW5mby5pZFRvSW5kZXhbZWRnZS50YXJnZXRJZF07XG4gICAgICB2YXIgdGFyZ2V0ID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1t0YXJnZXRJeF07IC8vIEdldCBkaXJlY3Rpb24gb2YgbGluZSBjb25uZWN0aW5nIGJvdGggbm9kZSBjZW50ZXJzXG5cbiAgICAgIHZhciBkaXJlY3Rpb25YID0gdGFyZ2V0LnBvc2l0aW9uWCAtIHNvdXJjZS5wb3NpdGlvblg7XG4gICAgICB2YXIgZGlyZWN0aW9uWSA9IHRhcmdldC5wb3NpdGlvblkgLSBzb3VyY2UucG9zaXRpb25ZOyAvLyBJZiBib3RoIGNlbnRlcnMgYXJlIHRoZSBzYW1lLCBkbyBub3RoaW5nLlxuICAgICAgLy8gQSByYW5kb20gZm9yY2UgaGFzIGFscmVhZHkgYmVlbiBhcHBsaWVkIGFzIG5vZGUgcmVwdWxzaW9uXG5cbiAgICAgIGlmICgwID09PSBkaXJlY3Rpb25YICYmIDAgPT09IGRpcmVjdGlvblkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIEdldCBjbGlwcGluZyBwb2ludHMgZm9yIGJvdGggbm9kZXNcblxuXG4gICAgICB2YXIgcG9pbnQxID0gZmluZENsaXBwaW5nUG9pbnQoc291cmNlLCBkaXJlY3Rpb25YLCBkaXJlY3Rpb25ZKTtcbiAgICAgIHZhciBwb2ludDIgPSBmaW5kQ2xpcHBpbmdQb2ludCh0YXJnZXQsIC0xICogZGlyZWN0aW9uWCwgLTEgKiBkaXJlY3Rpb25ZKTtcbiAgICAgIHZhciBseCA9IHBvaW50Mi54IC0gcG9pbnQxLng7XG4gICAgICB2YXIgbHkgPSBwb2ludDIueSAtIHBvaW50MS55O1xuICAgICAgdmFyIGwgPSBNYXRoLnNxcnQobHggKiBseCArIGx5ICogbHkpO1xuICAgICAgdmFyIGZvcmNlID0gTWF0aC5wb3coZWRnZS5pZGVhbExlbmd0aCAtIGwsIDIpIC8gZWRnZS5lbGFzdGljaXR5O1xuXG4gICAgICBpZiAoMCAhPT0gbCkge1xuICAgICAgICB2YXIgZm9yY2VYID0gZm9yY2UgKiBseCAvIGw7XG4gICAgICAgIHZhciBmb3JjZVkgPSBmb3JjZSAqIGx5IC8gbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBmb3JjZVggPSAwO1xuICAgICAgICB2YXIgZm9yY2VZID0gMDtcbiAgICAgIH0gLy8gQWRkIHRoaXMgZm9yY2UgdG8gdGFyZ2V0IGFuZCBzb3VyY2Ugbm9kZXNcblxuXG4gICAgICBpZiAoIXNvdXJjZS5pc0xvY2tlZCkge1xuICAgICAgICBzb3VyY2Uub2Zmc2V0WCArPSBmb3JjZVg7XG4gICAgICAgIHNvdXJjZS5vZmZzZXRZICs9IGZvcmNlWTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0YXJnZXQuaXNMb2NrZWQpIHtcbiAgICAgICAgdGFyZ2V0Lm9mZnNldFggLT0gZm9yY2VYO1xuICAgICAgICB0YXJnZXQub2Zmc2V0WSAtPSBmb3JjZVk7XG4gICAgICB9IC8vIHZhciBzID0gJ0VkZ2UgZm9yY2UgYmV0d2VlbiBub2RlcyAnICsgc291cmNlLmlkICsgJyBhbmQgJyArIHRhcmdldC5pZDtcbiAgICAgIC8vIHMgKz0gXCJcXG5EaXN0YW5jZTogXCIgKyBsICsgXCIgRm9yY2U6IChcIiArIGZvcmNlWCArIFwiLCBcIiArIGZvcmNlWSArIFwiKVwiO1xuICAgICAgLy8gbG9nRGVidWcocyk7XG5cbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBAYnJpZWYgOiBDb21wdXRlcyBncmF2aXR5IGZvcmNlcyBmb3IgYWxsIG5vZGVzXG4gICAqL1xuXG5cbiAgdmFyIGNhbGN1bGF0ZUdyYXZpdHlGb3JjZXMgPSBmdW5jdGlvbiBjYWxjdWxhdGVHcmF2aXR5Rm9yY2VzKGxheW91dEluZm8sIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5ncmF2aXR5ID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGRpc3RUaHJlc2hvbGQgPSAxOyAvLyB2YXIgcyA9ICdjYWxjdWxhdGVHcmF2aXR5Rm9yY2VzJztcbiAgICAvLyBsb2dEZWJ1ZyhzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5ncmFwaFNldC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGdyYXBoID0gbGF5b3V0SW5mby5ncmFwaFNldFtpXTtcbiAgICAgIHZhciBudW1Ob2RlcyA9IGdyYXBoLmxlbmd0aDsgLy8gcyA9IFwiU2V0OiBcIiArIGdyYXBoLnRvU3RyaW5nKCk7XG4gICAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICAgIC8vIENvbXB1dGUgZ3JhcGggY2VudGVyXG5cbiAgICAgIGlmICgwID09PSBpKSB7XG4gICAgICAgIHZhciBjZW50ZXJYID0gbGF5b3V0SW5mby5jbGllbnRIZWlnaHQgLyAyO1xuICAgICAgICB2YXIgY2VudGVyWSA9IGxheW91dEluZm8uY2xpZW50V2lkdGggLyAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gR2V0IFBhcmVudCBub2RlIGZvciB0aGlzIGdyYXBoLCBhbmQgdXNlIGl0cyBwb3NpdGlvbiBhcyBjZW50ZXJcbiAgICAgICAgdmFyIHRlbXAgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W2dyYXBoWzBdXV07XG4gICAgICAgIHZhciBwYXJlbnQgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W3RlbXAucGFyZW50SWRdXTtcbiAgICAgICAgdmFyIGNlbnRlclggPSBwYXJlbnQucG9zaXRpb25YO1xuICAgICAgICB2YXIgY2VudGVyWSA9IHBhcmVudC5wb3NpdGlvblk7XG4gICAgICB9IC8vIHMgPSBcIkNlbnRlciBmb3VuZCBhdDogXCIgKyBjZW50ZXJYICsgXCIsIFwiICsgY2VudGVyWTtcbiAgICAgIC8vIGxvZ0RlYnVnKHMpO1xuICAgICAgLy8gQXBwbHkgZm9yY2UgdG8gYWxsIG5vZGVzIGluIGdyYXBoXG5cblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1Ob2RlczsgaisrKSB7XG4gICAgICAgIHZhciBub2RlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFtncmFwaFtqXV1dOyAvLyBzID0gXCJOb2RlOiBcIiArIG5vZGUuaWQ7XG5cbiAgICAgICAgaWYgKG5vZGUuaXNMb2NrZWQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkeCA9IGNlbnRlclggLSBub2RlLnBvc2l0aW9uWDtcbiAgICAgICAgdmFyIGR5ID0gY2VudGVyWSAtIG5vZGUucG9zaXRpb25ZO1xuICAgICAgICB2YXIgZCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cbiAgICAgICAgaWYgKGQgPiBkaXN0VGhyZXNob2xkKSB7XG4gICAgICAgICAgdmFyIGZ4ID0gb3B0aW9ucy5ncmF2aXR5ICogZHggLyBkO1xuICAgICAgICAgIHZhciBmeSA9IG9wdGlvbnMuZ3Jhdml0eSAqIGR5IC8gZDtcbiAgICAgICAgICBub2RlLm9mZnNldFggKz0gZng7XG4gICAgICAgICAgbm9kZS5vZmZzZXRZICs9IGZ5OyAvLyBzICs9IFwiOiBBcHBsaWVkIGZvcmNlOiBcIiArIGZ4ICsgXCIsIFwiICsgZnk7XG4gICAgICAgIH0gLy8gbG9nRGVidWcocyk7XG5cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBAYnJpZWYgICAgICAgICAgOiBUaGlzIGZ1bmN0aW9uIHByb3BhZ2F0ZXMgdGhlIGV4aXN0aW5nIG9mZnNldHMgZnJvbVxuICAgKiAgICAgICAgICAgICAgICAgICBwYXJlbnQgbm9kZXMgdG8gaXRzIGRlc2NlbmRlbnRzLlxuICAgKiBAYXJnIGxheW91dEluZm8gOiBsYXlvdXRJbmZvIE9iamVjdFxuICAgKiBAYXJnIGN5ICAgICAgICAgOiBjeXRvc2NhcGUgT2JqZWN0XG4gICAqIEBhcmcgb3B0aW9ucyAgICA6IExheW91dCBvcHRpb25zXG4gICAqL1xuXG5cbiAgdmFyIHByb3BhZ2F0ZUZvcmNlcyA9IGZ1bmN0aW9uIHByb3BhZ2F0ZUZvcmNlcyhsYXlvdXRJbmZvLCBvcHRpb25zKSB7XG4gICAgLy8gSW5saW5lIGltcGxlbWVudGF0aW9uIG9mIGEgcXVldWUsIHVzZWQgZm9yIHRyYXZlcnNpbmcgdGhlIGdyYXBoIGluIEJGUyBvcmRlclxuICAgIHZhciBxdWV1ZSA9IFtdO1xuICAgIHZhciBzdGFydCA9IDA7IC8vIFBvaW50cyB0byB0aGUgc3RhcnQgdGhlIHF1ZXVlXG5cbiAgICB2YXIgZW5kID0gLTE7IC8vIFBvaW50cyB0byB0aGUgZW5kIG9mIHRoZSBxdWV1ZVxuICAgIC8vIGxvZ0RlYnVnKCdwcm9wYWdhdGVGb3JjZXMnKTtcbiAgICAvLyBTdGFydCBieSB2aXNpdGluZyB0aGUgbm9kZXMgaW4gdGhlIHJvb3QgZ3JhcGhcblxuICAgIHF1ZXVlLnB1c2guYXBwbHkocXVldWUsIGxheW91dEluZm8uZ3JhcGhTZXRbMF0pO1xuICAgIGVuZCArPSBsYXlvdXRJbmZvLmdyYXBoU2V0WzBdLmxlbmd0aDsgLy8gVHJhdmVyc2UgdGhlIGdyYXBoLCBsZXZlbCBieSBsZXZlbCxcblxuICAgIHdoaWxlIChzdGFydCA8PSBlbmQpIHtcbiAgICAgIC8vIEdldCB0aGUgbm9kZSB0byB2aXNpdCBhbmQgcmVtb3ZlIGl0IGZyb20gcXVldWVcbiAgICAgIHZhciBub2RlSWQgPSBxdWV1ZVtzdGFydCsrXTtcbiAgICAgIHZhciBub2RlSW5kZXggPSBsYXlvdXRJbmZvLmlkVG9JbmRleFtub2RlSWRdO1xuICAgICAgdmFyIG5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW25vZGVJbmRleF07XG4gICAgICB2YXIgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuOyAvLyBXZSBvbmx5IG5lZWQgdG8gcHJvY2VzcyB0aGUgbm9kZSBpZiBpdCdzIGNvbXBvdW5kXG5cbiAgICAgIGlmICgwIDwgY2hpbGRyZW4ubGVuZ3RoICYmICFub2RlLmlzTG9ja2VkKSB7XG4gICAgICAgIHZhciBvZmZYID0gbm9kZS5vZmZzZXRYO1xuICAgICAgICB2YXIgb2ZmWSA9IG5vZGUub2Zmc2V0WTsgLy8gdmFyIHMgPSBcIlByb3BhZ2F0aW5nIG9mZnNldCBmcm9tIHBhcmVudCBub2RlIDogXCIgKyBub2RlLmlkICtcbiAgICAgICAgLy8gICBcIi4gT2Zmc2V0WDogXCIgKyBvZmZYICsgXCIuIE9mZnNldFk6IFwiICsgb2ZmWTtcbiAgICAgICAgLy8gcyArPSBcIlxcbiBDaGlsZHJlbjogXCIgKyBjaGlsZHJlbi50b1N0cmluZygpO1xuICAgICAgICAvLyBsb2dEZWJ1ZyhzKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbY2hpbGRyZW5baV1dXTsgLy8gUHJvcGFnYXRlIG9mZnNldFxuXG4gICAgICAgICAgY2hpbGROb2RlLm9mZnNldFggKz0gb2ZmWDtcbiAgICAgICAgICBjaGlsZE5vZGUub2Zmc2V0WSArPSBvZmZZOyAvLyBBZGQgY2hpbGRyZW4gdG8gcXVldWUgdG8gYmUgdmlzaXRlZFxuXG4gICAgICAgICAgcXVldWVbKytlbmRdID0gY2hpbGRyZW5baV07XG4gICAgICAgIH0gLy8gUmVzZXQgcGFyZW50IG9mZnNldHNcblxuXG4gICAgICAgIG5vZGUub2Zmc2V0WCA9IDA7XG4gICAgICAgIG5vZGUub2Zmc2V0WSA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogQGJyaWVmIDogVXBkYXRlcyB0aGUgbGF5b3V0IG1vZGVsIHBvc2l0aW9ucywgYmFzZWQgb25cbiAgICogICAgICAgICAgdGhlIGFjY3VtdWxhdGVkIGZvcmNlc1xuICAgKi9cblxuXG4gIHZhciB1cGRhdGVQb3NpdGlvbnMgPSBmdW5jdGlvbiB1cGRhdGVQb3NpdGlvbnMobGF5b3V0SW5mbywgb3B0aW9ucykge1xuICAgIC8vIHZhciBzID0gJ1VwZGF0aW5nIHBvc2l0aW9ucyc7XG4gICAgLy8gbG9nRGVidWcocyk7XG4gICAgLy8gUmVzZXQgYm91bmRhcmllcyBmb3IgY29tcG91bmQgbm9kZXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8ubm9kZVNpemU7IGkrKykge1xuICAgICAgdmFyIG4gPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2ldO1xuXG4gICAgICBpZiAoMCA8IG4uY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIC8vIGxvZ0RlYnVnKFwiUmVzZXR0aW5nIGJvdW5kYXJpZXMgb2YgY29tcG91bmQgbm9kZTogXCIgKyBuLmlkKTtcbiAgICAgICAgbi5tYXhYID0gdW5kZWZpbmVkO1xuICAgICAgICBuLm1pblggPSB1bmRlZmluZWQ7XG4gICAgICAgIG4ubWF4WSA9IHVuZGVmaW5lZDtcbiAgICAgICAgbi5taW5ZID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5ub2RlU2l6ZTsgaSsrKSB7XG4gICAgICB2YXIgbiA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbaV07XG5cbiAgICAgIGlmICgwIDwgbi5jaGlsZHJlbi5sZW5ndGggfHwgbi5pc0xvY2tlZCkge1xuICAgICAgICAvLyBObyBuZWVkIHRvIHNldCBjb21wb3VuZCBvciBsb2NrZWQgbm9kZSBwb3NpdGlvblxuICAgICAgICAvLyBsb2dEZWJ1ZyhcIlNraXBwaW5nIHBvc2l0aW9uIHVwZGF0ZSBvZiBub2RlOiBcIiArIG4uaWQpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8gcyA9IFwiTm9kZTogXCIgKyBuLmlkICsgXCIgUHJldmlvdXMgcG9zaXRpb246IChcIiArXG4gICAgICAvLyBuLnBvc2l0aW9uWCArIFwiLCBcIiArIG4ucG9zaXRpb25ZICsgXCIpLlwiO1xuICAgICAgLy8gTGltaXQgZGlzcGxhY2VtZW50IGluIG9yZGVyIHRvIGltcHJvdmUgc3RhYmlsaXR5XG5cblxuICAgICAgdmFyIHRlbXBGb3JjZSA9IGxpbWl0Rm9yY2Uobi5vZmZzZXRYLCBuLm9mZnNldFksIGxheW91dEluZm8udGVtcGVyYXR1cmUpO1xuICAgICAgbi5wb3NpdGlvblggKz0gdGVtcEZvcmNlLng7XG4gICAgICBuLnBvc2l0aW9uWSArPSB0ZW1wRm9yY2UueTtcbiAgICAgIG4ub2Zmc2V0WCA9IDA7XG4gICAgICBuLm9mZnNldFkgPSAwO1xuICAgICAgbi5taW5YID0gbi5wb3NpdGlvblggLSBuLndpZHRoO1xuICAgICAgbi5tYXhYID0gbi5wb3NpdGlvblggKyBuLndpZHRoO1xuICAgICAgbi5taW5ZID0gbi5wb3NpdGlvblkgLSBuLmhlaWdodDtcbiAgICAgIG4ubWF4WSA9IG4ucG9zaXRpb25ZICsgbi5oZWlnaHQ7IC8vIHMgKz0gXCIgTmV3IFBvc2l0aW9uOiAoXCIgKyBuLnBvc2l0aW9uWCArIFwiLCBcIiArIG4ucG9zaXRpb25ZICsgXCIpLlwiO1xuICAgICAgLy8gbG9nRGVidWcocyk7XG4gICAgICAvLyBVcGRhdGUgYW5jZXN0cnkgYm91ZGFyaWVzXG5cbiAgICAgIHVwZGF0ZUFuY2VzdHJ5Qm91bmRhcmllcyhuLCBsYXlvdXRJbmZvKTtcbiAgICB9IC8vIFVwZGF0ZSBzaXplLCBwb3NpdGlvbiBvZiBjb21wdW5kIG5vZGVzXG5cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5ub2RlU2l6ZTsgaSsrKSB7XG4gICAgICB2YXIgbiA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbaV07XG5cbiAgICAgIGlmICgwIDwgbi5jaGlsZHJlbi5sZW5ndGggJiYgIW4uaXNMb2NrZWQpIHtcbiAgICAgICAgbi5wb3NpdGlvblggPSAobi5tYXhYICsgbi5taW5YKSAvIDI7XG4gICAgICAgIG4ucG9zaXRpb25ZID0gKG4ubWF4WSArIG4ubWluWSkgLyAyO1xuICAgICAgICBuLndpZHRoID0gbi5tYXhYIC0gbi5taW5YO1xuICAgICAgICBuLmhlaWdodCA9IG4ubWF4WSAtIG4ubWluWTsgLy8gcyA9IFwiVXBkYXRpbmcgcG9zaXRpb24sIHNpemUgb2YgY29tcG91bmQgbm9kZSBcIiArIG4uaWQ7XG4gICAgICAgIC8vIHMgKz0gXCJcXG5Qb3NpdGlvblg6IFwiICsgbi5wb3NpdGlvblggKyBcIiwgUG9zaXRpb25ZOiBcIiArIG4ucG9zaXRpb25ZO1xuICAgICAgICAvLyBzICs9IFwiXFxuV2lkdGg6IFwiICsgbi53aWR0aCArIFwiLCBIZWlnaHQ6IFwiICsgbi5oZWlnaHQ7XG4gICAgICAgIC8vIGxvZ0RlYnVnKHMpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIEBicmllZiA6IExpbWl0cyBhIGZvcmNlIChmb3JjZVgsIGZvcmNlWSkgdG8gYmUgbm90XG4gICAqICAgICAgICAgIGdyZWF0ZXIgKGluIG1vZHVsbykgdGhhbiBtYXguXG4gICA4ICAgICAgICAgIFByZXNlcnZlcyBmb3JjZSBkaXJlY3Rpb24uXG4gICAgKi9cblxuXG4gIHZhciBsaW1pdEZvcmNlID0gZnVuY3Rpb24gbGltaXRGb3JjZShmb3JjZVgsIGZvcmNlWSwgbWF4KSB7XG4gICAgLy8gdmFyIHMgPSBcIkxpbWl0aW5nIGZvcmNlOiAoXCIgKyBmb3JjZVggKyBcIiwgXCIgKyBmb3JjZVkgKyBcIikuIE1heDogXCIgKyBtYXg7XG4gICAgdmFyIGZvcmNlID0gTWF0aC5zcXJ0KGZvcmNlWCAqIGZvcmNlWCArIGZvcmNlWSAqIGZvcmNlWSk7XG5cbiAgICBpZiAoZm9yY2UgPiBtYXgpIHtcbiAgICAgIHZhciByZXMgPSB7XG4gICAgICAgIHg6IG1heCAqIGZvcmNlWCAvIGZvcmNlLFxuICAgICAgICB5OiBtYXggKiBmb3JjZVkgLyBmb3JjZVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHJlcyA9IHtcbiAgICAgICAgeDogZm9yY2VYLFxuICAgICAgICB5OiBmb3JjZVlcbiAgICAgIH07XG4gICAgfSAvLyBzICs9IFwiLlxcblJlc3VsdDogKFwiICsgcmVzLnggKyBcIiwgXCIgKyByZXMueSArIFwiKVwiO1xuICAgIC8vIGxvZ0RlYnVnKHMpO1xuXG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuICAvKipcbiAgICogQGJyaWVmIDogRnVuY3Rpb24gdXNlZCBmb3Iga2VlcGluZyB0cmFjayBvZiBjb21wb3VuZCBub2RlXG4gICAqICAgICAgICAgIHNpemVzLCBzaW5jZSB0aGV5IHNob3VsZCBib3VuZCBhbGwgdGhlaXIgc3Vibm9kZXMuXG4gICAqL1xuXG5cbiAgdmFyIHVwZGF0ZUFuY2VzdHJ5Qm91bmRhcmllcyA9IGZ1bmN0aW9uIHVwZGF0ZUFuY2VzdHJ5Qm91bmRhcmllcyhub2RlLCBsYXlvdXRJbmZvKSB7XG4gICAgLy8gdmFyIHMgPSBcIlByb3BhZ2F0aW5nIG5ldyBwb3NpdGlvbi9zaXplIG9mIG5vZGUgXCIgKyBub2RlLmlkO1xuICAgIHZhciBwYXJlbnRJZCA9IG5vZGUucGFyZW50SWQ7XG5cbiAgICBpZiAobnVsbCA9PSBwYXJlbnRJZCkge1xuICAgICAgLy8gSWYgdGhlcmUncyBubyBwYXJlbnQsIHdlIGFyZSBkb25lXG4gICAgICAvLyBzICs9IFwiLiBObyBwYXJlbnQgbm9kZS5cIjtcbiAgICAgIC8vIGxvZ0RlYnVnKHMpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gR2V0IFBhcmVudCBOb2RlXG5cblxuICAgIHZhciBwID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFtwYXJlbnRJZF1dO1xuICAgIHZhciBmbGFnID0gZmFsc2U7IC8vIE1heFhcblxuICAgIGlmIChudWxsID09IHAubWF4WCB8fCBub2RlLm1heFggKyBwLnBhZFJpZ2h0ID4gcC5tYXhYKSB7XG4gICAgICBwLm1heFggPSBub2RlLm1heFggKyBwLnBhZFJpZ2h0O1xuICAgICAgZmxhZyA9IHRydWU7IC8vIHMgKz0gXCJcXG5OZXcgbWF4WCBmb3IgcGFyZW50IG5vZGUgXCIgKyBwLmlkICsgXCI6IFwiICsgcC5tYXhYO1xuICAgIH0gLy8gTWluWFxuXG5cbiAgICBpZiAobnVsbCA9PSBwLm1pblggfHwgbm9kZS5taW5YIC0gcC5wYWRMZWZ0IDwgcC5taW5YKSB7XG4gICAgICBwLm1pblggPSBub2RlLm1pblggLSBwLnBhZExlZnQ7XG4gICAgICBmbGFnID0gdHJ1ZTsgLy8gcyArPSBcIlxcbk5ldyBtaW5YIGZvciBwYXJlbnQgbm9kZSBcIiArIHAuaWQgKyBcIjogXCIgKyBwLm1pblg7XG4gICAgfSAvLyBNYXhZXG5cblxuICAgIGlmIChudWxsID09IHAubWF4WSB8fCBub2RlLm1heFkgKyBwLnBhZEJvdHRvbSA+IHAubWF4WSkge1xuICAgICAgcC5tYXhZID0gbm9kZS5tYXhZICsgcC5wYWRCb3R0b207XG4gICAgICBmbGFnID0gdHJ1ZTsgLy8gcyArPSBcIlxcbk5ldyBtYXhZIGZvciBwYXJlbnQgbm9kZSBcIiArIHAuaWQgKyBcIjogXCIgKyBwLm1heFk7XG4gICAgfSAvLyBNaW5ZXG5cblxuICAgIGlmIChudWxsID09IHAubWluWSB8fCBub2RlLm1pblkgLSBwLnBhZFRvcCA8IHAubWluWSkge1xuICAgICAgcC5taW5ZID0gbm9kZS5taW5ZIC0gcC5wYWRUb3A7XG4gICAgICBmbGFnID0gdHJ1ZTsgLy8gcyArPSBcIlxcbk5ldyBtaW5ZIGZvciBwYXJlbnQgbm9kZSBcIiArIHAuaWQgKyBcIjogXCIgKyBwLm1pblk7XG4gICAgfSAvLyBJZiB1cGRhdGVkIGJvdW5kYXJpZXMsIHByb3BhZ2F0ZSBjaGFuZ2VzIHVwd2FyZFxuXG5cbiAgICBpZiAoZmxhZykge1xuICAgICAgLy8gbG9nRGVidWcocyk7XG4gICAgICByZXR1cm4gdXBkYXRlQW5jZXN0cnlCb3VuZGFyaWVzKHAsIGxheW91dEluZm8pO1xuICAgIH0gLy8gcyArPSBcIi4gTm8gY2hhbmdlcyBpbiBib3VuZGFyaWVzL3Bvc2l0aW9uIG9mIHBhcmVudCBub2RlIFwiICsgcC5pZDtcbiAgICAvLyBsb2dEZWJ1ZyhzKTtcblxuXG4gICAgcmV0dXJuO1xuICB9O1xuXG4gIHZhciBzZXBhcmF0ZUNvbXBvbmVudHMgPSBmdW5jdGlvbiBzZXBhcmF0ZUNvbXBvbmVudHMobGF5b3V0SW5mbywgb3B0aW9ucykge1xuICAgIHZhciBub2RlcyA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXM7XG4gICAgdmFyIGNvbXBvbmVudHMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICB2YXIgY2lkID0gbm9kZS5jbXB0SWQ7XG4gICAgICB2YXIgY29tcG9uZW50ID0gY29tcG9uZW50c1tjaWRdID0gY29tcG9uZW50c1tjaWRdIHx8IFtdO1xuICAgICAgY29tcG9uZW50LnB1c2gobm9kZSk7XG4gICAgfVxuXG4gICAgdmFyIHRvdGFsQSA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbXBvbmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gY29tcG9uZW50c1tpXTtcblxuICAgICAgaWYgKCFjKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjLngxID0gSW5maW5pdHk7XG4gICAgICBjLngyID0gLUluZmluaXR5O1xuICAgICAgYy55MSA9IEluZmluaXR5O1xuICAgICAgYy55MiA9IC1JbmZpbml0eTtcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBuID0gY1tqXTtcbiAgICAgICAgYy54MSA9IE1hdGgubWluKGMueDEsIG4ucG9zaXRpb25YIC0gbi53aWR0aCAvIDIpO1xuICAgICAgICBjLngyID0gTWF0aC5tYXgoYy54Miwgbi5wb3NpdGlvblggKyBuLndpZHRoIC8gMik7XG4gICAgICAgIGMueTEgPSBNYXRoLm1pbihjLnkxLCBuLnBvc2l0aW9uWSAtIG4uaGVpZ2h0IC8gMik7XG4gICAgICAgIGMueTIgPSBNYXRoLm1heChjLnkyLCBuLnBvc2l0aW9uWSArIG4uaGVpZ2h0IC8gMik7XG4gICAgICB9XG5cbiAgICAgIGMudyA9IGMueDIgLSBjLngxO1xuICAgICAgYy5oID0gYy55MiAtIGMueTE7XG4gICAgICB0b3RhbEEgKz0gYy53ICogYy5oO1xuICAgIH1cblxuICAgIGNvbXBvbmVudHMuc29ydChmdW5jdGlvbiAoYzEsIGMyKSB7XG4gICAgICByZXR1cm4gYzIudyAqIGMyLmggLSBjMS53ICogYzEuaDtcbiAgICB9KTtcbiAgICB2YXIgeCA9IDA7XG4gICAgdmFyIHkgPSAwO1xuICAgIHZhciB1c2VkVyA9IDA7XG4gICAgdmFyIHJvd0ggPSAwO1xuICAgIHZhciBtYXhSb3dXID0gTWF0aC5zcXJ0KHRvdGFsQSkgKiBsYXlvdXRJbmZvLmNsaWVudFdpZHRoIC8gbGF5b3V0SW5mby5jbGllbnRIZWlnaHQ7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbXBvbmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gY29tcG9uZW50c1tpXTtcblxuICAgICAgaWYgKCFjKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIG4gPSBjW2pdO1xuXG4gICAgICAgIGlmICghbi5pc0xvY2tlZCkge1xuICAgICAgICAgIG4ucG9zaXRpb25YICs9IHggLSBjLngxO1xuICAgICAgICAgIG4ucG9zaXRpb25ZICs9IHkgLSBjLnkxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHggKz0gYy53ICsgb3B0aW9ucy5jb21wb25lbnRTcGFjaW5nO1xuICAgICAgdXNlZFcgKz0gYy53ICsgb3B0aW9ucy5jb21wb25lbnRTcGFjaW5nO1xuICAgICAgcm93SCA9IE1hdGgubWF4KHJvd0gsIGMuaCk7XG5cbiAgICAgIGlmICh1c2VkVyA+IG1heFJvd1cpIHtcbiAgICAgICAgeSArPSByb3dIICsgb3B0aW9ucy5jb21wb25lbnRTcGFjaW5nO1xuICAgICAgICB4ID0gMDtcbiAgICAgICAgdXNlZFcgPSAwO1xuICAgICAgICByb3dIID0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIGRlZmF1bHRzJDMgPSB7XG4gICAgZml0OiB0cnVlLFxuICAgIC8vIHdoZXRoZXIgdG8gZml0IHRoZSB2aWV3cG9ydCB0byB0aGUgZ3JhcGhcbiAgICBwYWRkaW5nOiAzMCxcbiAgICAvLyBwYWRkaW5nIHVzZWQgb24gZml0XG4gICAgYm91bmRpbmdCb3g6IHVuZGVmaW5lZCxcbiAgICAvLyBjb25zdHJhaW4gbGF5b3V0IGJvdW5kczsgeyB4MSwgeTEsIHgyLCB5MiB9IG9yIHsgeDEsIHkxLCB3LCBoIH1cbiAgICBhdm9pZE92ZXJsYXA6IHRydWUsXG4gICAgLy8gcHJldmVudHMgbm9kZSBvdmVybGFwLCBtYXkgb3ZlcmZsb3cgYm91bmRpbmdCb3ggaWYgbm90IGVub3VnaCBzcGFjZVxuICAgIGF2b2lkT3ZlcmxhcFBhZGRpbmc6IDEwLFxuICAgIC8vIGV4dHJhIHNwYWNpbmcgYXJvdW5kIG5vZGVzIHdoZW4gYXZvaWRPdmVybGFwOiB0cnVlXG4gICAgbm9kZURpbWVuc2lvbnNJbmNsdWRlTGFiZWxzOiBmYWxzZSxcbiAgICAvLyBFeGNsdWRlcyB0aGUgbGFiZWwgd2hlbiBjYWxjdWxhdGluZyBub2RlIGJvdW5kaW5nIGJveGVzIGZvciB0aGUgbGF5b3V0IGFsZ29yaXRobVxuICAgIHNwYWNpbmdGYWN0b3I6IHVuZGVmaW5lZCxcbiAgICAvLyBBcHBsaWVzIGEgbXVsdGlwbGljYXRpdmUgZmFjdG9yICg+MCkgdG8gZXhwYW5kIG9yIGNvbXByZXNzIHRoZSBvdmVyYWxsIGFyZWEgdGhhdCB0aGUgbm9kZXMgdGFrZSB1cFxuICAgIGNvbmRlbnNlOiBmYWxzZSxcbiAgICAvLyB1c2VzIGFsbCBhdmFpbGFibGUgc3BhY2Ugb24gZmFsc2UsIHVzZXMgbWluaW1hbCBzcGFjZSBvbiB0cnVlXG4gICAgcm93czogdW5kZWZpbmVkLFxuICAgIC8vIGZvcmNlIG51bSBvZiByb3dzIGluIHRoZSBncmlkXG4gICAgY29sczogdW5kZWZpbmVkLFxuICAgIC8vIGZvcmNlIG51bSBvZiBjb2x1bW5zIGluIHRoZSBncmlkXG4gICAgcG9zaXRpb246IGZ1bmN0aW9uIHBvc2l0aW9uKG5vZGUpIHt9LFxuICAgIC8vIHJldHVybnMgeyByb3csIGNvbCB9IGZvciBlbGVtZW50XG4gICAgc29ydDogdW5kZWZpbmVkLFxuICAgIC8vIGEgc29ydGluZyBmdW5jdGlvbiB0byBvcmRlciB0aGUgbm9kZXM7IGUuZy4gZnVuY3Rpb24oYSwgYil7IHJldHVybiBhLmRhdGEoJ3dlaWdodCcpIC0gYi5kYXRhKCd3ZWlnaHQnKSB9XG4gICAgYW5pbWF0ZTogZmFsc2UsXG4gICAgLy8gd2hldGhlciB0byB0cmFuc2l0aW9uIHRoZSBub2RlIHBvc2l0aW9uc1xuICAgIGFuaW1hdGlvbkR1cmF0aW9uOiA1MDAsXG4gICAgLy8gZHVyYXRpb24gb2YgYW5pbWF0aW9uIGluIG1zIGlmIGVuYWJsZWRcbiAgICBhbmltYXRpb25FYXNpbmc6IHVuZGVmaW5lZCxcbiAgICAvLyBlYXNpbmcgb2YgYW5pbWF0aW9uIGlmIGVuYWJsZWRcbiAgICBhbmltYXRlRmlsdGVyOiBmdW5jdGlvbiBhbmltYXRlRmlsdGVyKG5vZGUsIGkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgLy8gYSBmdW5jdGlvbiB0aGF0IGRldGVybWluZXMgd2hldGhlciB0aGUgbm9kZSBzaG91bGQgYmUgYW5pbWF0ZWQuICBBbGwgbm9kZXMgYW5pbWF0ZWQgYnkgZGVmYXVsdCBvbiBhbmltYXRlIGVuYWJsZWQuICBOb24tYW5pbWF0ZWQgbm9kZXMgYXJlIHBvc2l0aW9uZWQgaW1tZWRpYXRlbHkgd2hlbiB0aGUgbGF5b3V0IHN0YXJ0c1xuICAgIHJlYWR5OiB1bmRlZmluZWQsXG4gICAgLy8gY2FsbGJhY2sgb24gbGF5b3V0cmVhZHlcbiAgICBzdG9wOiB1bmRlZmluZWQsXG4gICAgLy8gY2FsbGJhY2sgb24gbGF5b3V0c3RvcFxuICAgIHRyYW5zZm9ybTogZnVuY3Rpb24gdHJhbnNmb3JtKG5vZGUsIHBvc2l0aW9uKSB7XG4gICAgICByZXR1cm4gcG9zaXRpb247XG4gICAgfSAvLyB0cmFuc2Zvcm0gYSBnaXZlbiBub2RlIHBvc2l0aW9uLiBVc2VmdWwgZm9yIGNoYW5naW5nIGZsb3cgZGlyZWN0aW9uIGluIGRpc2NyZXRlIGxheW91dHMgXG5cbiAgfTtcblxuICBmdW5jdGlvbiBHcmlkTGF5b3V0KG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBleHRlbmQoe30sIGRlZmF1bHRzJDMsIG9wdGlvbnMpO1xuICB9XG5cbiAgR3JpZExheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwYXJhbXMgPSB0aGlzLm9wdGlvbnM7XG4gICAgdmFyIG9wdGlvbnMgPSBwYXJhbXM7XG4gICAgdmFyIGN5ID0gcGFyYW1zLmN5O1xuICAgIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuICAgIHZhciBub2RlcyA9IGVsZXMubm9kZXMoKS5ub3QoJzpwYXJlbnQnKTtcblxuICAgIGlmIChvcHRpb25zLnNvcnQpIHtcbiAgICAgIG5vZGVzID0gbm9kZXMuc29ydChvcHRpb25zLnNvcnQpO1xuICAgIH1cblxuICAgIHZhciBiYiA9IG1ha2VCb3VuZGluZ0JveChvcHRpb25zLmJvdW5kaW5nQm94ID8gb3B0aW9ucy5ib3VuZGluZ0JveCA6IHtcbiAgICAgIHgxOiAwLFxuICAgICAgeTE6IDAsXG4gICAgICB3OiBjeS53aWR0aCgpLFxuICAgICAgaDogY3kuaGVpZ2h0KClcbiAgICB9KTtcblxuICAgIGlmIChiYi5oID09PSAwIHx8IGJiLncgPT09IDApIHtcbiAgICAgIGVsZXMubm9kZXMoKS5sYXlvdXRQb3NpdGlvbnModGhpcywgb3B0aW9ucywgZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IGJiLngxLFxuICAgICAgICAgIHk6IGJiLnkxXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gd2lkdGgvaGVpZ2h0ICogc3BsaXRzXjIgPSBjZWxscyB3aGVyZSBzcGxpdHMgaXMgbnVtYmVyIG9mIHRpbWVzIHRvIHNwbGl0IHdpZHRoXG4gICAgICB2YXIgY2VsbHMgPSBub2Rlcy5zaXplKCk7XG4gICAgICB2YXIgc3BsaXRzID0gTWF0aC5zcXJ0KGNlbGxzICogYmIuaCAvIGJiLncpO1xuICAgICAgdmFyIHJvd3MgPSBNYXRoLnJvdW5kKHNwbGl0cyk7XG4gICAgICB2YXIgY29scyA9IE1hdGgucm91bmQoYmIudyAvIGJiLmggKiBzcGxpdHMpO1xuXG4gICAgICB2YXIgc21hbGwgPSBmdW5jdGlvbiBzbWFsbCh2YWwpIHtcbiAgICAgICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIE1hdGgubWluKHJvd3MsIGNvbHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBtaW4gPSBNYXRoLm1pbihyb3dzLCBjb2xzKTtcblxuICAgICAgICAgIGlmIChtaW4gPT0gcm93cykge1xuICAgICAgICAgICAgcm93cyA9IHZhbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29scyA9IHZhbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciBsYXJnZSA9IGZ1bmN0aW9uIGxhcmdlKHZhbCkge1xuICAgICAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gTWF0aC5tYXgocm93cywgY29scyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG1heCA9IE1hdGgubWF4KHJvd3MsIGNvbHMpO1xuXG4gICAgICAgICAgaWYgKG1heCA9PSByb3dzKSB7XG4gICAgICAgICAgICByb3dzID0gdmFsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2xzID0gdmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdmFyIG9Sb3dzID0gb3B0aW9ucy5yb3dzO1xuICAgICAgdmFyIG9Db2xzID0gb3B0aW9ucy5jb2xzICE9IG51bGwgPyBvcHRpb25zLmNvbHMgOiBvcHRpb25zLmNvbHVtbnM7IC8vIGlmIHJvd3Mgb3IgY29sdW1ucyB3ZXJlIHNldCBpbiBvcHRpb25zLCB1c2UgdGhvc2UgdmFsdWVzXG5cbiAgICAgIGlmIChvUm93cyAhPSBudWxsICYmIG9Db2xzICE9IG51bGwpIHtcbiAgICAgICAgcm93cyA9IG9Sb3dzO1xuICAgICAgICBjb2xzID0gb0NvbHM7XG4gICAgICB9IGVsc2UgaWYgKG9Sb3dzICE9IG51bGwgJiYgb0NvbHMgPT0gbnVsbCkge1xuICAgICAgICByb3dzID0gb1Jvd3M7XG4gICAgICAgIGNvbHMgPSBNYXRoLmNlaWwoY2VsbHMgLyByb3dzKTtcbiAgICAgIH0gZWxzZSBpZiAob1Jvd3MgPT0gbnVsbCAmJiBvQ29scyAhPSBudWxsKSB7XG4gICAgICAgIGNvbHMgPSBvQ29scztcbiAgICAgICAgcm93cyA9IE1hdGguY2VpbChjZWxscyAvIGNvbHMpO1xuICAgICAgfSAvLyBvdGhlcndpc2UgdXNlIHRoZSBhdXRvbWF0aWMgdmFsdWVzIGFuZCBhZGp1c3QgYWNjb3JkaW5nbHlcbiAgICAgIC8vIGlmIHJvdW5kaW5nIHdhcyB1cCwgc2VlIGlmIHdlIGNhbiByZWR1Y2Ugcm93cyBvciBjb2x1bW5zXG4gICAgICBlbHNlIGlmIChjb2xzICogcm93cyA+IGNlbGxzKSB7XG4gICAgICAgIHZhciBzbSA9IHNtYWxsKCk7XG4gICAgICAgIHZhciBsZyA9IGxhcmdlKCk7IC8vIHJlZHVjaW5nIHRoZSBzbWFsbCBzaWRlIHRha2VzIGF3YXkgdGhlIG1vc3QgY2VsbHMsIHNvIHRyeSBpdCBmaXJzdFxuXG4gICAgICAgIGlmICgoc20gLSAxKSAqIGxnID49IGNlbGxzKSB7XG4gICAgICAgICAgc21hbGwoc20gLSAxKTtcbiAgICAgICAgfSBlbHNlIGlmICgobGcgLSAxKSAqIHNtID49IGNlbGxzKSB7XG4gICAgICAgICAgbGFyZ2UobGcgLSAxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaWYgcm91bmRpbmcgd2FzIHRvbyBsb3csIGFkZCByb3dzIG9yIGNvbHVtbnNcbiAgICAgICAgd2hpbGUgKGNvbHMgKiByb3dzIDwgY2VsbHMpIHtcbiAgICAgICAgICB2YXIgX3NtID0gc21hbGwoKTtcblxuICAgICAgICAgIHZhciBfbGcgPSBsYXJnZSgpOyAvLyB0cnkgdG8gYWRkIHRvIGxhcmdlciBzaWRlIGZpcnN0IChhZGRzIGxlc3MgaW4gbXVsdGlwbGljYXRpb24pXG5cblxuICAgICAgICAgIGlmICgoX2xnICsgMSkgKiBfc20gPj0gY2VsbHMpIHtcbiAgICAgICAgICAgIGxhcmdlKF9sZyArIDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzbWFsbChfc20gKyAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGNlbGxXaWR0aCA9IGJiLncgLyBjb2xzO1xuICAgICAgdmFyIGNlbGxIZWlnaHQgPSBiYi5oIC8gcm93cztcblxuICAgICAgaWYgKG9wdGlvbnMuY29uZGVuc2UpIHtcbiAgICAgICAgY2VsbFdpZHRoID0gMDtcbiAgICAgICAgY2VsbEhlaWdodCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmF2b2lkT3ZlcmxhcCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICB2YXIgcG9zID0gbm9kZS5fcHJpdmF0ZS5wb3NpdGlvbjtcblxuICAgICAgICAgIGlmIChwb3MueCA9PSBudWxsIHx8IHBvcy55ID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIGZvciBiYlxuICAgICAgICAgICAgcG9zLnggPSAwO1xuICAgICAgICAgICAgcG9zLnkgPSAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBuYmIgPSBub2RlLmxheW91dERpbWVuc2lvbnMob3B0aW9ucyk7XG4gICAgICAgICAgdmFyIHAgPSBvcHRpb25zLmF2b2lkT3ZlcmxhcFBhZGRpbmc7XG4gICAgICAgICAgdmFyIHcgPSBuYmIudyArIHA7XG4gICAgICAgICAgdmFyIGggPSBuYmIuaCArIHA7XG4gICAgICAgICAgY2VsbFdpZHRoID0gTWF0aC5tYXgoY2VsbFdpZHRoLCB3KTtcbiAgICAgICAgICBjZWxsSGVpZ2h0ID0gTWF0aC5tYXgoY2VsbEhlaWdodCwgaCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGNlbGxVc2VkID0ge307IC8vIGUuZy4gJ2MtMC0yJyA9PiB0cnVlXG5cbiAgICAgIHZhciB1c2VkID0gZnVuY3Rpb24gdXNlZChyb3csIGNvbCkge1xuICAgICAgICByZXR1cm4gY2VsbFVzZWRbJ2MtJyArIHJvdyArICctJyArIGNvbF0gPyB0cnVlIDogZmFsc2U7XG4gICAgICB9O1xuXG4gICAgICB2YXIgdXNlID0gZnVuY3Rpb24gdXNlKHJvdywgY29sKSB7XG4gICAgICAgIGNlbGxVc2VkWydjLScgKyByb3cgKyAnLScgKyBjb2xdID0gdHJ1ZTtcbiAgICAgIH07IC8vIHRvIGtlZXAgdHJhY2sgb2YgY3VycmVudCBjZWxsIHBvc2l0aW9uXG5cblxuICAgICAgdmFyIHJvdyA9IDA7XG4gICAgICB2YXIgY29sID0gMDtcblxuICAgICAgdmFyIG1vdmVUb05leHRDZWxsID0gZnVuY3Rpb24gbW92ZVRvTmV4dENlbGwoKSB7XG4gICAgICAgIGNvbCsrO1xuXG4gICAgICAgIGlmIChjb2wgPj0gY29scykge1xuICAgICAgICAgIGNvbCA9IDA7XG4gICAgICAgICAgcm93Kys7XG4gICAgICAgIH1cbiAgICAgIH07IC8vIGdldCBhIGNhY2hlIG9mIGFsbCB0aGUgbWFudWFsIHBvc2l0aW9uc1xuXG5cbiAgICAgIHZhciBpZDJtYW5Qb3MgPSB7fTtcblxuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG5vZGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgX25vZGUgPSBub2Rlc1tfaV07XG4gICAgICAgIHZhciByY1BvcyA9IG9wdGlvbnMucG9zaXRpb24oX25vZGUpO1xuXG4gICAgICAgIGlmIChyY1BvcyAmJiAocmNQb3Mucm93ICE9PSB1bmRlZmluZWQgfHwgcmNQb3MuY29sICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgLy8gbXVzdCBoYXZlIGF0IGxlYXN0IHJvdyBvciBjb2wgZGVmJ2RcbiAgICAgICAgICB2YXIgX3BvcyA9IHtcbiAgICAgICAgICAgIHJvdzogcmNQb3Mucm93LFxuICAgICAgICAgICAgY29sOiByY1Bvcy5jb2xcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKF9wb3MuY29sID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIGZpbmQgdW51c2VkIGNvbFxuICAgICAgICAgICAgX3Bvcy5jb2wgPSAwO1xuXG4gICAgICAgICAgICB3aGlsZSAodXNlZChfcG9zLnJvdywgX3Bvcy5jb2wpKSB7XG4gICAgICAgICAgICAgIF9wb3MuY29sKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChfcG9zLnJvdyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBmaW5kIHVudXNlZCByb3dcbiAgICAgICAgICAgIF9wb3Mucm93ID0gMDtcblxuICAgICAgICAgICAgd2hpbGUgKHVzZWQoX3Bvcy5yb3csIF9wb3MuY29sKSkge1xuICAgICAgICAgICAgICBfcG9zLnJvdysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlkMm1hblBvc1tfbm9kZS5pZCgpXSA9IF9wb3M7XG4gICAgICAgICAgdXNlKF9wb3Mucm93LCBfcG9zLmNvbCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGdldFBvcyA9IGZ1bmN0aW9uIGdldFBvcyhlbGVtZW50LCBpKSB7XG4gICAgICAgIHZhciB4LCB5O1xuXG4gICAgICAgIGlmIChlbGVtZW50LmxvY2tlZCgpIHx8IGVsZW1lbnQuaXNQYXJlbnQoKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSAvLyBzZWUgaWYgd2UgaGF2ZSBhIG1hbnVhbCBwb3NpdGlvbiBzZXRcblxuXG4gICAgICAgIHZhciByY1BvcyA9IGlkMm1hblBvc1tlbGVtZW50LmlkKCldO1xuXG4gICAgICAgIGlmIChyY1Bvcykge1xuICAgICAgICAgIHggPSByY1Bvcy5jb2wgKiBjZWxsV2lkdGggKyBjZWxsV2lkdGggLyAyICsgYmIueDE7XG4gICAgICAgICAgeSA9IHJjUG9zLnJvdyAqIGNlbGxIZWlnaHQgKyBjZWxsSGVpZ2h0IC8gMiArIGJiLnkxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG90aGVyd2lzZSBzZXQgYXV0b21hdGljYWxseVxuICAgICAgICAgIHdoaWxlICh1c2VkKHJvdywgY29sKSkge1xuICAgICAgICAgICAgbW92ZVRvTmV4dENlbGwoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB4ID0gY29sICogY2VsbFdpZHRoICsgY2VsbFdpZHRoIC8gMiArIGJiLngxO1xuICAgICAgICAgIHkgPSByb3cgKiBjZWxsSGVpZ2h0ICsgY2VsbEhlaWdodCAvIDIgKyBiYi55MTtcbiAgICAgICAgICB1c2Uocm93LCBjb2wpO1xuICAgICAgICAgIG1vdmVUb05leHRDZWxsKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgeTogeVxuICAgICAgICB9O1xuICAgICAgfTtcblxuICAgICAgbm9kZXMubGF5b3V0UG9zaXRpb25zKHRoaXMsIG9wdGlvbnMsIGdldFBvcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH07XG5cbiAgdmFyIGRlZmF1bHRzJDIgPSB7XG4gICAgcmVhZHk6IGZ1bmN0aW9uIHJlYWR5KCkge30sXG4gICAgLy8gb24gbGF5b3V0cmVhZHlcbiAgICBzdG9wOiBmdW5jdGlvbiBzdG9wKCkge30gLy8gb24gbGF5b3V0c3RvcFxuXG4gIH07IC8vIGNvbnN0cnVjdG9yXG4gIC8vIG9wdGlvbnMgOiBvYmplY3QgY29udGFpbmluZyBsYXlvdXQgb3B0aW9uc1xuXG4gIGZ1bmN0aW9uIE51bGxMYXlvdXQob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IGV4dGVuZCh7fSwgZGVmYXVsdHMkMiwgb3B0aW9ucyk7XG4gIH0gLy8gcnVucyB0aGUgbGF5b3V0XG5cblxuICBOdWxsTGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgdmFyIGVsZXMgPSBvcHRpb25zLmVsZXM7IC8vIGVsZW1lbnRzIHRvIGNvbnNpZGVyIGluIHRoZSBsYXlvdXRcblxuICAgIHZhciBsYXlvdXQgPSB0aGlzOyAvLyBjeSBpcyBhdXRvbWF0aWNhbGx5IHBvcHVsYXRlZCBmb3IgdXMgaW4gdGhlIGNvbnN0cnVjdG9yXG4gICAgLy8gKGRpc2FibGUgZXNsaW50IGZvciBuZXh0IGxpbmUgYXMgdGhpcyBzZXJ2ZXMgYXMgZXhhbXBsZSBsYXlvdXQgY29kZSB0byBleHRlcm5hbCBkZXZlbG9wZXJzKVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuXG4gICAgb3B0aW9ucy5jeTtcbiAgICBsYXlvdXQuZW1pdCgnbGF5b3V0c3RhcnQnKTsgLy8gcHV0cyBhbGwgbm9kZXMgYXQgKDAsIDApXG4gICAgLy8gbi5iLiBtb3N0IGxheW91dHMgd291bGQgdXNlIGxheW91dFBvc2l0aW9ucygpLCBpbnN0ZWFkIG9mIHBvc2l0aW9ucygpIGFuZCBtYW51YWwgZXZlbnRzXG5cbiAgICBlbGVzLm5vZGVzKCkucG9zaXRpb25zKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH07XG4gICAgfSk7IC8vIHRyaWdnZXIgbGF5b3V0cmVhZHkgd2hlbiBlYWNoIG5vZGUgaGFzIGhhZCBpdHMgcG9zaXRpb24gc2V0IGF0IGxlYXN0IG9uY2VcblxuICAgIGxheW91dC5vbmUoJ2xheW91dHJlYWR5Jywgb3B0aW9ucy5yZWFkeSk7XG4gICAgbGF5b3V0LmVtaXQoJ2xheW91dHJlYWR5Jyk7IC8vIHRyaWdnZXIgbGF5b3V0c3RvcCB3aGVuIHRoZSBsYXlvdXQgc3RvcHMgKGUuZy4gZmluaXNoZXMpXG5cbiAgICBsYXlvdXQub25lKCdsYXlvdXRzdG9wJywgb3B0aW9ucy5zdG9wKTtcbiAgICBsYXlvdXQuZW1pdCgnbGF5b3V0c3RvcCcpO1xuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9OyAvLyBjYWxsZWQgb24gY29udGludW91cyBsYXlvdXRzIHRvIHN0b3AgdGhlbSBiZWZvcmUgdGhleSBmaW5pc2hcblxuXG4gIE51bGxMYXlvdXQucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH07XG5cbiAgdmFyIGRlZmF1bHRzJDEgPSB7XG4gICAgcG9zaXRpb25zOiB1bmRlZmluZWQsXG4gICAgLy8gbWFwIG9mIChub2RlIGlkKSA9PiAocG9zaXRpb24gb2JqKTsgb3IgZnVuY3Rpb24obm9kZSl7IHJldHVybiBzb21Qb3M7IH1cbiAgICB6b29tOiB1bmRlZmluZWQsXG4gICAgLy8gdGhlIHpvb20gbGV2ZWwgdG8gc2V0IChwcm9iIHdhbnQgZml0ID0gZmFsc2UgaWYgc2V0KVxuICAgIHBhbjogdW5kZWZpbmVkLFxuICAgIC8vIHRoZSBwYW4gbGV2ZWwgdG8gc2V0IChwcm9iIHdhbnQgZml0ID0gZmFsc2UgaWYgc2V0KVxuICAgIGZpdDogdHJ1ZSxcbiAgICAvLyB3aGV0aGVyIHRvIGZpdCB0byB2aWV3cG9ydFxuICAgIHBhZGRpbmc6IDMwLFxuICAgIC8vIHBhZGRpbmcgb24gZml0XG4gICAgYW5pbWF0ZTogZmFsc2UsXG4gICAgLy8gd2hldGhlciB0byB0cmFuc2l0aW9uIHRoZSBub2RlIHBvc2l0aW9uc1xuICAgIGFuaW1hdGlvbkR1cmF0aW9uOiA1MDAsXG4gICAgLy8gZHVyYXRpb24gb2YgYW5pbWF0aW9uIGluIG1zIGlmIGVuYWJsZWRcbiAgICBhbmltYXRpb25FYXNpbmc6IHVuZGVmaW5lZCxcbiAgICAvLyBlYXNpbmcgb2YgYW5pbWF0aW9uIGlmIGVuYWJsZWRcbiAgICBhbmltYXRlRmlsdGVyOiBmdW5jdGlvbiBhbmltYXRlRmlsdGVyKG5vZGUsIGkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgLy8gYSBmdW5jdGlvbiB0aGF0IGRldGVybWluZXMgd2hldGhlciB0aGUgbm9kZSBzaG91bGQgYmUgYW5pbWF0ZWQuICBBbGwgbm9kZXMgYW5pbWF0ZWQgYnkgZGVmYXVsdCBvbiBhbmltYXRlIGVuYWJsZWQuICBOb24tYW5pbWF0ZWQgbm9kZXMgYXJlIHBvc2l0aW9uZWQgaW1tZWRpYXRlbHkgd2hlbiB0aGUgbGF5b3V0IHN0YXJ0c1xuICAgIHJlYWR5OiB1bmRlZmluZWQsXG4gICAgLy8gY2FsbGJhY2sgb24gbGF5b3V0cmVhZHlcbiAgICBzdG9wOiB1bmRlZmluZWQsXG4gICAgLy8gY2FsbGJhY2sgb24gbGF5b3V0c3RvcFxuICAgIHRyYW5zZm9ybTogZnVuY3Rpb24gdHJhbnNmb3JtKG5vZGUsIHBvc2l0aW9uKSB7XG4gICAgICByZXR1cm4gcG9zaXRpb247XG4gICAgfSAvLyB0cmFuc2Zvcm0gYSBnaXZlbiBub2RlIHBvc2l0aW9uLiBVc2VmdWwgZm9yIGNoYW5naW5nIGZsb3cgZGlyZWN0aW9uIGluIGRpc2NyZXRlIGxheW91dHNcblxuICB9O1xuXG4gIGZ1bmN0aW9uIFByZXNldExheW91dChvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gZXh0ZW5kKHt9LCBkZWZhdWx0cyQxLCBvcHRpb25zKTtcbiAgfVxuXG4gIFByZXNldExheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuICAgIHZhciBub2RlcyA9IGVsZXMubm9kZXMoKTtcbiAgICB2YXIgcG9zSXNGbiA9IGZuJDYob3B0aW9ucy5wb3NpdGlvbnMpO1xuXG4gICAgZnVuY3Rpb24gZ2V0UG9zaXRpb24obm9kZSkge1xuICAgICAgaWYgKG9wdGlvbnMucG9zaXRpb25zID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGNvcHlQb3NpdGlvbihub2RlLnBvc2l0aW9uKCkpO1xuICAgICAgfVxuXG4gICAgICBpZiAocG9zSXNGbikge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5wb3NpdGlvbnMobm9kZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBwb3MgPSBvcHRpb25zLnBvc2l0aW9uc1tub2RlLl9wcml2YXRlLmRhdGEuaWRdO1xuXG4gICAgICBpZiAocG9zID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuXG4gICAgbm9kZXMubGF5b3V0UG9zaXRpb25zKHRoaXMsIG9wdGlvbnMsIGZ1bmN0aW9uIChub2RlLCBpKSB7XG4gICAgICB2YXIgcG9zaXRpb24gPSBnZXRQb3NpdGlvbihub2RlKTtcblxuICAgICAgaWYgKG5vZGUubG9ja2VkKCkgfHwgcG9zaXRpb24gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwb3NpdGlvbjtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfTtcblxuICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgZml0OiB0cnVlLFxuICAgIC8vIHdoZXRoZXIgdG8gZml0IHRvIHZpZXdwb3J0XG4gICAgcGFkZGluZzogMzAsXG4gICAgLy8gZml0IHBhZGRpbmdcbiAgICBib3VuZGluZ0JveDogdW5kZWZpbmVkLFxuICAgIC8vIGNvbnN0cmFpbiBsYXlvdXQgYm91bmRzOyB7IHgxLCB5MSwgeDIsIHkyIH0gb3IgeyB4MSwgeTEsIHcsIGggfVxuICAgIGFuaW1hdGU6IGZhbHNlLFxuICAgIC8vIHdoZXRoZXIgdG8gdHJhbnNpdGlvbiB0aGUgbm9kZSBwb3NpdGlvbnNcbiAgICBhbmltYXRpb25EdXJhdGlvbjogNTAwLFxuICAgIC8vIGR1cmF0aW9uIG9mIGFuaW1hdGlvbiBpbiBtcyBpZiBlbmFibGVkXG4gICAgYW5pbWF0aW9uRWFzaW5nOiB1bmRlZmluZWQsXG4gICAgLy8gZWFzaW5nIG9mIGFuaW1hdGlvbiBpZiBlbmFibGVkXG4gICAgYW5pbWF0ZUZpbHRlcjogZnVuY3Rpb24gYW5pbWF0ZUZpbHRlcihub2RlLCBpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIC8vIGEgZnVuY3Rpb24gdGhhdCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG5vZGUgc2hvdWxkIGJlIGFuaW1hdGVkLiAgQWxsIG5vZGVzIGFuaW1hdGVkIGJ5IGRlZmF1bHQgb24gYW5pbWF0ZSBlbmFibGVkLiAgTm9uLWFuaW1hdGVkIG5vZGVzIGFyZSBwb3NpdGlvbmVkIGltbWVkaWF0ZWx5IHdoZW4gdGhlIGxheW91dCBzdGFydHNcbiAgICByZWFkeTogdW5kZWZpbmVkLFxuICAgIC8vIGNhbGxiYWNrIG9uIGxheW91dHJlYWR5XG4gICAgc3RvcDogdW5kZWZpbmVkLFxuICAgIC8vIGNhbGxiYWNrIG9uIGxheW91dHN0b3BcbiAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uIHRyYW5zZm9ybShub2RlLCBwb3NpdGlvbikge1xuICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgIH0gLy8gdHJhbnNmb3JtIGEgZ2l2ZW4gbm9kZSBwb3NpdGlvbi4gVXNlZnVsIGZvciBjaGFuZ2luZyBmbG93IGRpcmVjdGlvbiBpbiBkaXNjcmV0ZSBsYXlvdXRzIFxuXG4gIH07XG5cbiAgZnVuY3Rpb24gUmFuZG9tTGF5b3V0KG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBleHRlbmQoe30sIGRlZmF1bHRzLCBvcHRpb25zKTtcbiAgfVxuXG4gIFJhbmRvbUxheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIHZhciBjeSA9IG9wdGlvbnMuY3k7XG4gICAgdmFyIGVsZXMgPSBvcHRpb25zLmVsZXM7XG4gICAgdmFyIGJiID0gbWFrZUJvdW5kaW5nQm94KG9wdGlvbnMuYm91bmRpbmdCb3ggPyBvcHRpb25zLmJvdW5kaW5nQm94IDoge1xuICAgICAgeDE6IDAsXG4gICAgICB5MTogMCxcbiAgICAgIHc6IGN5LndpZHRoKCksXG4gICAgICBoOiBjeS5oZWlnaHQoKVxuICAgIH0pO1xuXG4gICAgdmFyIGdldFBvcyA9IGZ1bmN0aW9uIGdldFBvcyhub2RlLCBpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBiYi54MSArIE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIGJiLncpLFxuICAgICAgICB5OiBiYi55MSArIE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIGJiLmgpXG4gICAgICB9O1xuICAgIH07XG5cbiAgICBlbGVzLm5vZGVzKCkubGF5b3V0UG9zaXRpb25zKHRoaXMsIG9wdGlvbnMsIGdldFBvcyk7XG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH07XG5cbiAgdmFyIGxheW91dCA9IFt7XG4gICAgbmFtZTogJ2JyZWFkdGhmaXJzdCcsXG4gICAgaW1wbDogQnJlYWR0aEZpcnN0TGF5b3V0XG4gIH0sIHtcbiAgICBuYW1lOiAnY2lyY2xlJyxcbiAgICBpbXBsOiBDaXJjbGVMYXlvdXRcbiAgfSwge1xuICAgIG5hbWU6ICdjb25jZW50cmljJyxcbiAgICBpbXBsOiBDb25jZW50cmljTGF5b3V0XG4gIH0sIHtcbiAgICBuYW1lOiAnY29zZScsXG4gICAgaW1wbDogQ29zZUxheW91dFxuICB9LCB7XG4gICAgbmFtZTogJ2dyaWQnLFxuICAgIGltcGw6IEdyaWRMYXlvdXRcbiAgfSwge1xuICAgIG5hbWU6ICdudWxsJyxcbiAgICBpbXBsOiBOdWxsTGF5b3V0XG4gIH0sIHtcbiAgICBuYW1lOiAncHJlc2V0JyxcbiAgICBpbXBsOiBQcmVzZXRMYXlvdXRcbiAgfSwge1xuICAgIG5hbWU6ICdyYW5kb20nLFxuICAgIGltcGw6IFJhbmRvbUxheW91dFxuICB9XTtcblxuICBmdW5jdGlvbiBOdWxsUmVuZGVyZXIob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5ub3RpZmljYXRpb25zID0gMDsgLy8gZm9yIHRlc3RpbmdcbiAgfVxuXG4gIHZhciBub29wID0gZnVuY3Rpb24gbm9vcCgpIHt9O1xuXG4gIHZhciB0aHJvd0ltZ0VyciA9IGZ1bmN0aW9uIHRocm93SW1nRXJyKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQSBoZWFkbGVzcyBpbnN0YW5jZSBjYW4gbm90IHJlbmRlciBpbWFnZXMnKTtcbiAgfTtcblxuICBOdWxsUmVuZGVyZXIucHJvdG90eXBlID0ge1xuICAgIHJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZTogbm9vcCxcbiAgICBub3RpZnk6IGZ1bmN0aW9uIG5vdGlmeSgpIHtcbiAgICAgIHRoaXMubm90aWZpY2F0aW9ucysrO1xuICAgIH0sXG4gICAgaW5pdDogbm9vcCxcbiAgICBpc0hlYWRsZXNzOiBmdW5jdGlvbiBpc0hlYWRsZXNzKCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBwbmc6IHRocm93SW1nRXJyLFxuICAgIGpwZzogdGhyb3dJbWdFcnJcbiAgfTtcblxuICB2YXIgQlJwJGYgPSB7fTtcbiAgQlJwJGYuYXJyb3dTaGFwZVdpZHRoID0gMC4zO1xuXG4gIEJScCRmLnJlZ2lzdGVyQXJyb3dTaGFwZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFycm93U2hhcGVzID0gdGhpcy5hcnJvd1NoYXBlcyA9IHt9O1xuICAgIHZhciByZW5kZXJlciA9IHRoaXM7IC8vIENvbnRyYWN0IGZvciBhcnJvdyBzaGFwZXM6XG4gICAgLy8gMCwgMCBpcyBhcnJvdyB0aXBcbiAgICAvLyAoMCwgMSkgaXMgZGlyZWN0aW9uIHRvd2FyZHMgbm9kZVxuICAgIC8vICgxLCAwKSBpcyByaWdodFxuICAgIC8vXG4gICAgLy8gZnVuY3Rpb25hbCBhcGk6XG4gICAgLy8gY29sbGlkZTogY2hlY2sgeCwgeSBpbiBzaGFwZVxuICAgIC8vIHJvdWdoQ29sbGlkZTogY2FsbGVkIGJlZm9yZSBjb2xsaWRlLCBubyBmYWxzZSBuZWdhdGl2ZXNcbiAgICAvLyBkcmF3OiBkcmF3XG4gICAgLy8gc3BhY2luZzogZGlzdChhcnJvd1RpcCwgbm9kZUJvdW5kYXJ5KVxuICAgIC8vIGdhcDogZGlzdChlZGdlVGlwLCBub2RlQm91bmRhcnkpLCBlZGdlVGlwIG1heSAhPSBhcnJvd1RpcFxuXG4gICAgdmFyIGJiQ29sbGlkZSA9IGZ1bmN0aW9uIGJiQ29sbGlkZSh4LCB5LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24sIGVkZ2VXaWR0aCwgcGFkZGluZykge1xuICAgICAgdmFyIHgxID0gdHJhbnNsYXRpb24ueCAtIHNpemUgLyAyIC0gcGFkZGluZztcbiAgICAgIHZhciB4MiA9IHRyYW5zbGF0aW9uLnggKyBzaXplIC8gMiArIHBhZGRpbmc7XG4gICAgICB2YXIgeTEgPSB0cmFuc2xhdGlvbi55IC0gc2l6ZSAvIDIgLSBwYWRkaW5nO1xuICAgICAgdmFyIHkyID0gdHJhbnNsYXRpb24ueSArIHNpemUgLyAyICsgcGFkZGluZztcbiAgICAgIHZhciBpbnNpZGUgPSB4MSA8PSB4ICYmIHggPD0geDIgJiYgeTEgPD0geSAmJiB5IDw9IHkyO1xuICAgICAgcmV0dXJuIGluc2lkZTtcbiAgICB9O1xuXG4gICAgdmFyIHRyYW5zZm9ybSA9IGZ1bmN0aW9uIHRyYW5zZm9ybSh4LCB5LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pIHtcbiAgICAgIHZhciB4Um90YXRlZCA9IHggKiBNYXRoLmNvcyhhbmdsZSkgLSB5ICogTWF0aC5zaW4oYW5nbGUpO1xuICAgICAgdmFyIHlSb3RhdGVkID0geCAqIE1hdGguc2luKGFuZ2xlKSArIHkgKiBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICB2YXIgeFNjYWxlZCA9IHhSb3RhdGVkICogc2l6ZTtcbiAgICAgIHZhciB5U2NhbGVkID0geVJvdGF0ZWQgKiBzaXplO1xuICAgICAgdmFyIHhUcmFuc2xhdGVkID0geFNjYWxlZCArIHRyYW5zbGF0aW9uLng7XG4gICAgICB2YXIgeVRyYW5zbGF0ZWQgPSB5U2NhbGVkICsgdHJhbnNsYXRpb24ueTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHhUcmFuc2xhdGVkLFxuICAgICAgICB5OiB5VHJhbnNsYXRlZFxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIHRyYW5zZm9ybVBvaW50cyA9IGZ1bmN0aW9uIHRyYW5zZm9ybVBvaW50cyhwdHMsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbikge1xuICAgICAgdmFyIHJldFB0cyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHB0cy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICB2YXIgeCA9IHB0c1tpXTtcbiAgICAgICAgdmFyIHkgPSBwdHNbaSArIDFdO1xuICAgICAgICByZXRQdHMucHVzaCh0cmFuc2Zvcm0oeCwgeSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXRQdHM7XG4gICAgfTtcblxuICAgIHZhciBwb2ludHNUb0FyciA9IGZ1bmN0aW9uIHBvaW50c1RvQXJyKHB0cykge1xuICAgICAgdmFyIHJldCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHB0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcCA9IHB0c1tpXTtcbiAgICAgICAgcmV0LnB1c2gocC54LCBwLnkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH07XG5cbiAgICB2YXIgc3RhbmRhcmRHYXAgPSBmdW5jdGlvbiBzdGFuZGFyZEdhcChlZGdlKSB7XG4gICAgICByZXR1cm4gZWRnZS5wc3R5bGUoJ3dpZHRoJykucGZWYWx1ZSAqIGVkZ2UucHN0eWxlKCdhcnJvdy1zY2FsZScpLnBmVmFsdWUgKiAyO1xuICAgIH07XG5cbiAgICB2YXIgZGVmaW5lQXJyb3dTaGFwZSA9IGZ1bmN0aW9uIGRlZmluZUFycm93U2hhcGUobmFtZSwgZGVmbikge1xuICAgICAgaWYgKHN0cmluZyhkZWZuKSkge1xuICAgICAgICBkZWZuID0gYXJyb3dTaGFwZXNbZGVmbl07XG4gICAgICB9XG5cbiAgICAgIGFycm93U2hhcGVzW25hbWVdID0gZXh0ZW5kKHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgcG9pbnRzOiBbLTAuMTUsIC0wLjMsIDAuMTUsIC0wLjMsIDAuMTUsIDAuMywgLTAuMTUsIDAuM10sXG4gICAgICAgIGNvbGxpZGU6IGZ1bmN0aW9uIGNvbGxpZGUoeCwgeSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uLCBwYWRkaW5nKSB7XG4gICAgICAgICAgdmFyIHBvaW50cyA9IHBvaW50c1RvQXJyKHRyYW5zZm9ybVBvaW50cyh0aGlzLnBvaW50cywgc2l6ZSArIDIgKiBwYWRkaW5nLCBhbmdsZSwgdHJhbnNsYXRpb24pKTtcbiAgICAgICAgICB2YXIgaW5zaWRlID0gcG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKHgsIHksIHBvaW50cyk7XG4gICAgICAgICAgcmV0dXJuIGluc2lkZTtcbiAgICAgICAgfSxcbiAgICAgICAgcm91Z2hDb2xsaWRlOiBiYkNvbGxpZGUsXG4gICAgICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY29udGV4dCwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uKSB7XG4gICAgICAgICAgdmFyIHBvaW50cyA9IHRyYW5zZm9ybVBvaW50cyh0aGlzLnBvaW50cywgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uKTtcbiAgICAgICAgICByZW5kZXJlci5hcnJvd1NoYXBlSW1wbCgncG9seWdvbicpKGNvbnRleHQsIHBvaW50cyk7XG4gICAgICAgIH0sXG4gICAgICAgIHNwYWNpbmc6IGZ1bmN0aW9uIHNwYWNpbmcoZWRnZSkge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9LFxuICAgICAgICBnYXA6IHN0YW5kYXJkR2FwXG4gICAgICB9LCBkZWZuKTtcbiAgICB9O1xuXG4gICAgZGVmaW5lQXJyb3dTaGFwZSgnbm9uZScsIHtcbiAgICAgIGNvbGxpZGU6IGZhbHNpZnksXG4gICAgICByb3VnaENvbGxpZGU6IGZhbHNpZnksXG4gICAgICBkcmF3OiBub29wJDEsXG4gICAgICBzcGFjaW5nOiB6ZXJvaWZ5LFxuICAgICAgZ2FwOiB6ZXJvaWZ5XG4gICAgfSk7XG4gICAgZGVmaW5lQXJyb3dTaGFwZSgndHJpYW5nbGUnLCB7XG4gICAgICBwb2ludHM6IFstMC4xNSwgLTAuMywgMCwgMCwgMC4xNSwgLTAuM11cbiAgICB9KTtcbiAgICBkZWZpbmVBcnJvd1NoYXBlKCdhcnJvdycsICd0cmlhbmdsZScpO1xuICAgIGRlZmluZUFycm93U2hhcGUoJ3RyaWFuZ2xlLWJhY2tjdXJ2ZScsIHtcbiAgICAgIHBvaW50czogYXJyb3dTaGFwZXNbJ3RyaWFuZ2xlJ10ucG9pbnRzLFxuICAgICAgY29udHJvbFBvaW50OiBbMCwgLTAuMTVdLFxuICAgICAgcm91Z2hDb2xsaWRlOiBiYkNvbGxpZGUsXG4gICAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNvbnRleHQsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiwgZWRnZVdpZHRoKSB7XG4gICAgICAgIHZhciBwdHNUcmFucyA9IHRyYW5zZm9ybVBvaW50cyh0aGlzLnBvaW50cywgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uKTtcbiAgICAgICAgdmFyIGN0cmxQdCA9IHRoaXMuY29udHJvbFBvaW50O1xuICAgICAgICB2YXIgY3RybFB0VHJhbnMgPSB0cmFuc2Zvcm0oY3RybFB0WzBdLCBjdHJsUHRbMV0sIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbik7XG4gICAgICAgIHJlbmRlcmVyLmFycm93U2hhcGVJbXBsKHRoaXMubmFtZSkoY29udGV4dCwgcHRzVHJhbnMsIGN0cmxQdFRyYW5zKTtcbiAgICAgIH0sXG4gICAgICBnYXA6IGZ1bmN0aW9uIGdhcChlZGdlKSB7XG4gICAgICAgIHJldHVybiBzdGFuZGFyZEdhcChlZGdlKSAqIDAuODtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBkZWZpbmVBcnJvd1NoYXBlKCd0cmlhbmdsZS10ZWUnLCB7XG4gICAgICBwb2ludHM6IFswLCAwLCAwLjE1LCAtMC4zLCAtMC4xNSwgLTAuMywgMCwgMF0sXG4gICAgICBwb2ludHNUZWU6IFstMC4xNSwgLTAuNCwgLTAuMTUsIC0wLjUsIDAuMTUsIC0wLjUsIDAuMTUsIC0wLjRdLFxuICAgICAgY29sbGlkZTogZnVuY3Rpb24gY29sbGlkZSh4LCB5LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24sIGVkZ2VXaWR0aCwgcGFkZGluZykge1xuICAgICAgICB2YXIgdHJpUHRzID0gcG9pbnRzVG9BcnIodHJhbnNmb3JtUG9pbnRzKHRoaXMucG9pbnRzLCBzaXplICsgMiAqIHBhZGRpbmcsIGFuZ2xlLCB0cmFuc2xhdGlvbikpO1xuICAgICAgICB2YXIgdGVlUHRzID0gcG9pbnRzVG9BcnIodHJhbnNmb3JtUG9pbnRzKHRoaXMucG9pbnRzVGVlLCBzaXplICsgMiAqIHBhZGRpbmcsIGFuZ2xlLCB0cmFuc2xhdGlvbikpO1xuICAgICAgICB2YXIgaW5zaWRlID0gcG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKHgsIHksIHRyaVB0cykgfHwgcG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKHgsIHksIHRlZVB0cyk7XG4gICAgICAgIHJldHVybiBpbnNpZGU7XG4gICAgICB9LFxuICAgICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjb250ZXh0LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24sIGVkZ2VXaWR0aCkge1xuICAgICAgICB2YXIgdHJpUHRzID0gdHJhbnNmb3JtUG9pbnRzKHRoaXMucG9pbnRzLCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pO1xuICAgICAgICB2YXIgdGVlUHRzID0gdHJhbnNmb3JtUG9pbnRzKHRoaXMucG9pbnRzVGVlLCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pO1xuICAgICAgICByZW5kZXJlci5hcnJvd1NoYXBlSW1wbCh0aGlzLm5hbWUpKGNvbnRleHQsIHRyaVB0cywgdGVlUHRzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBkZWZpbmVBcnJvd1NoYXBlKCdjaXJjbGUtdHJpYW5nbGUnLCB7XG4gICAgICByYWRpdXM6IDAuMTUsXG4gICAgICBwb2ludHNUcjogWzAsIC0wLjE1LCAwLjE1LCAtMC40NSwgLTAuMTUsIC0wLjQ1LCAwLCAtMC4xNV0sXG4gICAgICBjb2xsaWRlOiBmdW5jdGlvbiBjb2xsaWRlKHgsIHksIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiwgZWRnZVdpZHRoLCBwYWRkaW5nKSB7XG4gICAgICAgIHZhciB0ID0gdHJhbnNsYXRpb247XG4gICAgICAgIHZhciBjaXJjbGVJbnNpZGUgPSBNYXRoLnBvdyh0LnggLSB4LCAyKSArIE1hdGgucG93KHQueSAtIHksIDIpIDw9IE1hdGgucG93KChzaXplICsgMiAqIHBhZGRpbmcpICogdGhpcy5yYWRpdXMsIDIpO1xuICAgICAgICB2YXIgdHJpUHRzID0gcG9pbnRzVG9BcnIodHJhbnNmb3JtUG9pbnRzKHRoaXMucG9pbnRzLCBzaXplICsgMiAqIHBhZGRpbmcsIGFuZ2xlLCB0cmFuc2xhdGlvbikpO1xuICAgICAgICByZXR1cm4gcG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKHgsIHksIHRyaVB0cykgfHwgY2lyY2xlSW5zaWRlO1xuICAgICAgfSxcbiAgICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY29udGV4dCwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uLCBlZGdlV2lkdGgpIHtcbiAgICAgICAgdmFyIHRyaVB0cyA9IHRyYW5zZm9ybVBvaW50cyh0aGlzLnBvaW50c1RyLCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pO1xuICAgICAgICByZW5kZXJlci5hcnJvd1NoYXBlSW1wbCh0aGlzLm5hbWUpKGNvbnRleHQsIHRyaVB0cywgdHJhbnNsYXRpb24ueCwgdHJhbnNsYXRpb24ueSwgdGhpcy5yYWRpdXMgKiBzaXplKTtcbiAgICAgIH0sXG4gICAgICBzcGFjaW5nOiBmdW5jdGlvbiBzcGFjaW5nKGVkZ2UpIHtcbiAgICAgICAgcmV0dXJuIHJlbmRlcmVyLmdldEFycm93V2lkdGgoZWRnZS5wc3R5bGUoJ3dpZHRoJykucGZWYWx1ZSwgZWRnZS5wc3R5bGUoJ2Fycm93LXNjYWxlJykudmFsdWUpICogdGhpcy5yYWRpdXM7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZGVmaW5lQXJyb3dTaGFwZSgndHJpYW5nbGUtY3Jvc3MnLCB7XG4gICAgICBwb2ludHM6IFswLCAwLCAwLjE1LCAtMC4zLCAtMC4xNSwgLTAuMywgMCwgMF0sXG4gICAgICBiYXNlQ3Jvc3NMaW5lUHRzOiBbLTAuMTUsIC0wLjQsIC8vIGZpcnN0IGhhbGYgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAgLTAuMTUsIC0wLjQsIDAuMTUsIC0wLjQsIC8vIHNlY29uZCBoYWxmIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgIDAuMTUsIC0wLjRdLFxuICAgICAgY3Jvc3NMaW5lUHRzOiBmdW5jdGlvbiBjcm9zc0xpbmVQdHMoc2l6ZSwgZWRnZVdpZHRoKSB7XG4gICAgICAgIC8vIHNoaWZ0IHBvaW50cyBzbyB0aGF0IHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBjcm9zcyBwb2ludHMgbWF0Y2hlcyBlZGdlIHdpZHRoXG4gICAgICAgIHZhciBwID0gdGhpcy5iYXNlQ3Jvc3NMaW5lUHRzLnNsaWNlKCk7XG4gICAgICAgIHZhciBzaGlmdEZhY3RvciA9IGVkZ2VXaWR0aCAvIHNpemU7XG4gICAgICAgIHZhciB5MCA9IDM7XG4gICAgICAgIHZhciB5MSA9IDU7XG4gICAgICAgIHBbeTBdID0gcFt5MF0gLSBzaGlmdEZhY3RvcjtcbiAgICAgICAgcFt5MV0gPSBwW3kxXSAtIHNoaWZ0RmFjdG9yO1xuICAgICAgICByZXR1cm4gcDtcbiAgICAgIH0sXG4gICAgICBjb2xsaWRlOiBmdW5jdGlvbiBjb2xsaWRlKHgsIHksIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiwgZWRnZVdpZHRoLCBwYWRkaW5nKSB7XG4gICAgICAgIHZhciB0cmlQdHMgPSBwb2ludHNUb0Fycih0cmFuc2Zvcm1Qb2ludHModGhpcy5wb2ludHMsIHNpemUgKyAyICogcGFkZGluZywgYW5nbGUsIHRyYW5zbGF0aW9uKSk7XG4gICAgICAgIHZhciB0ZWVQdHMgPSBwb2ludHNUb0Fycih0cmFuc2Zvcm1Qb2ludHModGhpcy5jcm9zc0xpbmVQdHMoc2l6ZSwgZWRnZVdpZHRoKSwgc2l6ZSArIDIgKiBwYWRkaW5nLCBhbmdsZSwgdHJhbnNsYXRpb24pKTtcbiAgICAgICAgdmFyIGluc2lkZSA9IHBvaW50SW5zaWRlUG9seWdvblBvaW50cyh4LCB5LCB0cmlQdHMpIHx8IHBvaW50SW5zaWRlUG9seWdvblBvaW50cyh4LCB5LCB0ZWVQdHMpO1xuICAgICAgICByZXR1cm4gaW5zaWRlO1xuICAgICAgfSxcbiAgICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY29udGV4dCwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uLCBlZGdlV2lkdGgpIHtcbiAgICAgICAgdmFyIHRyaVB0cyA9IHRyYW5zZm9ybVBvaW50cyh0aGlzLnBvaW50cywgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uKTtcbiAgICAgICAgdmFyIGNyb3NzTGluZVB0cyA9IHRyYW5zZm9ybVBvaW50cyh0aGlzLmNyb3NzTGluZVB0cyhzaXplLCBlZGdlV2lkdGgpLCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pO1xuICAgICAgICByZW5kZXJlci5hcnJvd1NoYXBlSW1wbCh0aGlzLm5hbWUpKGNvbnRleHQsIHRyaVB0cywgY3Jvc3NMaW5lUHRzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBkZWZpbmVBcnJvd1NoYXBlKCd2ZWUnLCB7XG4gICAgICBwb2ludHM6IFstMC4xNSwgLTAuMywgMCwgMCwgMC4xNSwgLTAuMywgMCwgLTAuMTVdLFxuICAgICAgZ2FwOiBmdW5jdGlvbiBnYXAoZWRnZSkge1xuICAgICAgICByZXR1cm4gc3RhbmRhcmRHYXAoZWRnZSkgKiAwLjUyNTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBkZWZpbmVBcnJvd1NoYXBlKCdjaXJjbGUnLCB7XG4gICAgICByYWRpdXM6IDAuMTUsXG4gICAgICBjb2xsaWRlOiBmdW5jdGlvbiBjb2xsaWRlKHgsIHksIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiwgZWRnZVdpZHRoLCBwYWRkaW5nKSB7XG4gICAgICAgIHZhciB0ID0gdHJhbnNsYXRpb247XG4gICAgICAgIHZhciBpbnNpZGUgPSBNYXRoLnBvdyh0LnggLSB4LCAyKSArIE1hdGgucG93KHQueSAtIHksIDIpIDw9IE1hdGgucG93KChzaXplICsgMiAqIHBhZGRpbmcpICogdGhpcy5yYWRpdXMsIDIpO1xuICAgICAgICByZXR1cm4gaW5zaWRlO1xuICAgICAgfSxcbiAgICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY29udGV4dCwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uLCBlZGdlV2lkdGgpIHtcbiAgICAgICAgcmVuZGVyZXIuYXJyb3dTaGFwZUltcGwodGhpcy5uYW1lKShjb250ZXh0LCB0cmFuc2xhdGlvbi54LCB0cmFuc2xhdGlvbi55LCB0aGlzLnJhZGl1cyAqIHNpemUpO1xuICAgICAgfSxcbiAgICAgIHNwYWNpbmc6IGZ1bmN0aW9uIHNwYWNpbmcoZWRnZSkge1xuICAgICAgICByZXR1cm4gcmVuZGVyZXIuZ2V0QXJyb3dXaWR0aChlZGdlLnBzdHlsZSgnd2lkdGgnKS5wZlZhbHVlLCBlZGdlLnBzdHlsZSgnYXJyb3ctc2NhbGUnKS52YWx1ZSkgKiB0aGlzLnJhZGl1cztcbiAgICAgIH1cbiAgICB9KTtcbiAgICBkZWZpbmVBcnJvd1NoYXBlKCd0ZWUnLCB7XG4gICAgICBwb2ludHM6IFstMC4xNSwgMCwgLTAuMTUsIC0wLjEsIDAuMTUsIC0wLjEsIDAuMTUsIDBdLFxuICAgICAgc3BhY2luZzogZnVuY3Rpb24gc3BhY2luZyhlZGdlKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfSxcbiAgICAgIGdhcDogZnVuY3Rpb24gZ2FwKGVkZ2UpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZGVmaW5lQXJyb3dTaGFwZSgnc3F1YXJlJywge1xuICAgICAgcG9pbnRzOiBbLTAuMTUsIDAuMDAsIDAuMTUsIDAuMDAsIDAuMTUsIC0wLjMsIC0wLjE1LCAtMC4zXVxuICAgIH0pO1xuICAgIGRlZmluZUFycm93U2hhcGUoJ2RpYW1vbmQnLCB7XG4gICAgICBwb2ludHM6IFstMC4xNSwgLTAuMTUsIDAsIC0wLjMsIDAuMTUsIC0wLjE1LCAwLCAwXSxcbiAgICAgIGdhcDogZnVuY3Rpb24gZ2FwKGVkZ2UpIHtcbiAgICAgICAgcmV0dXJuIGVkZ2UucHN0eWxlKCd3aWR0aCcpLnBmVmFsdWUgKiBlZGdlLnBzdHlsZSgnYXJyb3ctc2NhbGUnKS52YWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBkZWZpbmVBcnJvd1NoYXBlKCdjaGV2cm9uJywge1xuICAgICAgcG9pbnRzOiBbMCwgMCwgLTAuMTUsIC0wLjE1LCAtMC4xLCAtMC4yLCAwLCAtMC4xLCAwLjEsIC0wLjIsIDAuMTUsIC0wLjE1XSxcbiAgICAgIGdhcDogZnVuY3Rpb24gZ2FwKGVkZ2UpIHtcbiAgICAgICAgcmV0dXJuIDAuOTUgKiBlZGdlLnBzdHlsZSgnd2lkdGgnKS5wZlZhbHVlICogZWRnZS5wc3R5bGUoJ2Fycm93LXNjYWxlJykudmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIEJScCRlID0ge307IC8vIFByb2plY3QgbW91c2VcblxuICBCUnAkZS5wcm9qZWN0SW50b1ZpZXdwb3J0ID0gZnVuY3Rpb24gKGNsaWVudFgsIGNsaWVudFkpIHtcbiAgICB2YXIgY3kgPSB0aGlzLmN5O1xuICAgIHZhciBvZmZzZXRzID0gdGhpcy5maW5kQ29udGFpbmVyQ2xpZW50Q29vcmRzKCk7XG4gICAgdmFyIG9mZnNldExlZnQgPSBvZmZzZXRzWzBdO1xuICAgIHZhciBvZmZzZXRUb3AgPSBvZmZzZXRzWzFdO1xuICAgIHZhciBzY2FsZSA9IG9mZnNldHNbNF07XG4gICAgdmFyIHBhbiA9IGN5LnBhbigpO1xuICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuICAgIHZhciB4ID0gKChjbGllbnRYIC0gb2Zmc2V0TGVmdCkgLyBzY2FsZSAtIHBhbi54KSAvIHpvb207XG4gICAgdmFyIHkgPSAoKGNsaWVudFkgLSBvZmZzZXRUb3ApIC8gc2NhbGUgLSBwYW4ueSkgLyB6b29tO1xuICAgIHJldHVybiBbeCwgeV07XG4gIH07XG5cbiAgQlJwJGUuZmluZENvbnRhaW5lckNsaWVudENvb3JkcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5jb250YWluZXJCQikge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyQkI7XG4gICAgfVxuXG4gICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgIHZhciByZWN0ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHZhciBzdHlsZSA9IHdpbmRvdyQxLmdldENvbXB1dGVkU3R5bGUoY29udGFpbmVyKTtcblxuICAgIHZhciBzdHlsZVZhbHVlID0gZnVuY3Rpb24gc3R5bGVWYWx1ZShuYW1lKSB7XG4gICAgICByZXR1cm4gcGFyc2VGbG9hdChzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKG5hbWUpKTtcbiAgICB9O1xuXG4gICAgdmFyIHBhZGRpbmcgPSB7XG4gICAgICBsZWZ0OiBzdHlsZVZhbHVlKCdwYWRkaW5nLWxlZnQnKSxcbiAgICAgIHJpZ2h0OiBzdHlsZVZhbHVlKCdwYWRkaW5nLXJpZ2h0JyksXG4gICAgICB0b3A6IHN0eWxlVmFsdWUoJ3BhZGRpbmctdG9wJyksXG4gICAgICBib3R0b206IHN0eWxlVmFsdWUoJ3BhZGRpbmctYm90dG9tJylcbiAgICB9O1xuICAgIHZhciBib3JkZXIgPSB7XG4gICAgICBsZWZ0OiBzdHlsZVZhbHVlKCdib3JkZXItbGVmdC13aWR0aCcpLFxuICAgICAgcmlnaHQ6IHN0eWxlVmFsdWUoJ2JvcmRlci1yaWdodC13aWR0aCcpLFxuICAgICAgdG9wOiBzdHlsZVZhbHVlKCdib3JkZXItdG9wLXdpZHRoJyksXG4gICAgICBib3R0b206IHN0eWxlVmFsdWUoJ2JvcmRlci1ib3R0b20td2lkdGgnKVxuICAgIH07XG4gICAgdmFyIGNsaWVudFdpZHRoID0gY29udGFpbmVyLmNsaWVudFdpZHRoO1xuICAgIHZhciBjbGllbnRIZWlnaHQgPSBjb250YWluZXIuY2xpZW50SGVpZ2h0O1xuICAgIHZhciBwYWRkaW5nSG9yID0gcGFkZGluZy5sZWZ0ICsgcGFkZGluZy5yaWdodDtcbiAgICB2YXIgcGFkZGluZ1ZlciA9IHBhZGRpbmcudG9wICsgcGFkZGluZy5ib3R0b207XG4gICAgdmFyIGJvcmRlckhvciA9IGJvcmRlci5sZWZ0ICsgYm9yZGVyLnJpZ2h0O1xuICAgIHZhciBzY2FsZSA9IHJlY3Qud2lkdGggLyAoY2xpZW50V2lkdGggKyBib3JkZXJIb3IpO1xuICAgIHZhciB1bnNjYWxlZFcgPSBjbGllbnRXaWR0aCAtIHBhZGRpbmdIb3I7XG4gICAgdmFyIHVuc2NhbGVkSCA9IGNsaWVudEhlaWdodCAtIHBhZGRpbmdWZXI7XG4gICAgdmFyIGxlZnQgPSByZWN0LmxlZnQgKyBwYWRkaW5nLmxlZnQgKyBib3JkZXIubGVmdDtcbiAgICB2YXIgdG9wID0gcmVjdC50b3AgKyBwYWRkaW5nLnRvcCArIGJvcmRlci50b3A7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyQkIgPSBbbGVmdCwgdG9wLCB1bnNjYWxlZFcsIHVuc2NhbGVkSCwgc2NhbGVdO1xuICB9O1xuXG4gIEJScCRlLmludmFsaWRhdGVDb250YWluZXJDbGllbnRDb29yZHNDYWNoZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNvbnRhaW5lckJCID0gbnVsbDtcbiAgfTtcblxuICBCUnAkZS5maW5kTmVhcmVzdEVsZW1lbnQgPSBmdW5jdGlvbiAoeCwgeSwgaW50ZXJhY3RpdmVFbGVtZW50c09ubHksIGlzVG91Y2gpIHtcbiAgICByZXR1cm4gdGhpcy5maW5kTmVhcmVzdEVsZW1lbnRzKHgsIHksIGludGVyYWN0aXZlRWxlbWVudHNPbmx5LCBpc1RvdWNoKVswXTtcbiAgfTtcblxuICBCUnAkZS5maW5kTmVhcmVzdEVsZW1lbnRzID0gZnVuY3Rpb24gKHgsIHksIGludGVyYWN0aXZlRWxlbWVudHNPbmx5LCBpc1RvdWNoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciByID0gdGhpcztcbiAgICB2YXIgZWxlcyA9IHIuZ2V0Q2FjaGVkWlNvcnRlZEVsZXMoKTtcbiAgICB2YXIgbmVhciA9IFtdOyAvLyAxIG5vZGUgbWF4LCAxIGVkZ2UgbWF4XG5cbiAgICB2YXIgem9vbSA9IHIuY3kuem9vbSgpO1xuICAgIHZhciBoYXNDb21wb3VuZHMgPSByLmN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcbiAgICB2YXIgZWRnZVRocmVzaG9sZCA9IChpc1RvdWNoID8gMjQgOiA4KSAvIHpvb207XG4gICAgdmFyIG5vZGVUaHJlc2hvbGQgPSAoaXNUb3VjaCA/IDggOiAyKSAvIHpvb207XG4gICAgdmFyIGxhYmVsVGhyZXNob2xkID0gKGlzVG91Y2ggPyA4IDogMikgLyB6b29tO1xuICAgIHZhciBtaW5TcURpc3QgPSBJbmZpbml0eTtcbiAgICB2YXIgbmVhckVkZ2U7XG4gICAgdmFyIG5lYXJOb2RlO1xuXG4gICAgaWYgKGludGVyYWN0aXZlRWxlbWVudHNPbmx5KSB7XG4gICAgICBlbGVzID0gZWxlcy5pbnRlcmFjdGl2ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRFbGUoZWxlLCBzcURpc3QpIHtcbiAgICAgIGlmIChlbGUuaXNOb2RlKCkpIHtcbiAgICAgICAgaWYgKG5lYXJOb2RlKSB7XG4gICAgICAgICAgcmV0dXJuOyAvLyBjYW4ndCByZXBsYWNlIG5vZGVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZWFyTm9kZSA9IGVsZTtcbiAgICAgICAgICBuZWFyLnB1c2goZWxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZWxlLmlzRWRnZSgpICYmIChzcURpc3QgPT0gbnVsbCB8fCBzcURpc3QgPCBtaW5TcURpc3QpKSB7XG4gICAgICAgIGlmIChuZWFyRWRnZSkge1xuICAgICAgICAgIC8vIHRoZW4gcmVwbGFjZSBleGlzdGluZyBlZGdlXG4gICAgICAgICAgLy8gY2FuIHJlcGxhY2Ugb25seSBpZiBzYW1lIHotaW5kZXhcbiAgICAgICAgICBpZiAobmVhckVkZ2UucHN0eWxlKCd6LWNvbXBvdW5kLWRlcHRoJykudmFsdWUgPT09IGVsZS5wc3R5bGUoJ3otY29tcG91bmQtZGVwdGgnKS52YWx1ZSAmJiBuZWFyRWRnZS5wc3R5bGUoJ3otY29tcG91bmQtZGVwdGgnKS52YWx1ZSA9PT0gZWxlLnBzdHlsZSgnei1jb21wb3VuZC1kZXB0aCcpLnZhbHVlKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5lYXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgaWYgKG5lYXJbaV0uaXNFZGdlKCkpIHtcbiAgICAgICAgICAgICAgICBuZWFyW2ldID0gZWxlO1xuICAgICAgICAgICAgICAgIG5lYXJFZGdlID0gZWxlO1xuICAgICAgICAgICAgICAgIG1pblNxRGlzdCA9IHNxRGlzdCAhPSBudWxsID8gc3FEaXN0IDogbWluU3FEaXN0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5lYXIucHVzaChlbGUpO1xuICAgICAgICAgIG5lYXJFZGdlID0gZWxlO1xuICAgICAgICAgIG1pblNxRGlzdCA9IHNxRGlzdCAhPSBudWxsID8gc3FEaXN0IDogbWluU3FEaXN0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tOb2RlKG5vZGUpIHtcbiAgICAgIHZhciB3aWR0aCA9IG5vZGUub3V0ZXJXaWR0aCgpICsgMiAqIG5vZGVUaHJlc2hvbGQ7XG4gICAgICB2YXIgaGVpZ2h0ID0gbm9kZS5vdXRlckhlaWdodCgpICsgMiAqIG5vZGVUaHJlc2hvbGQ7XG4gICAgICB2YXIgaHcgPSB3aWR0aCAvIDI7XG4gICAgICB2YXIgaGggPSBoZWlnaHQgLyAyO1xuICAgICAgdmFyIHBvcyA9IG5vZGUucG9zaXRpb24oKTtcblxuICAgICAgaWYgKHBvcy54IC0gaHcgPD0geCAmJiB4IDw9IHBvcy54ICsgaHcgLy8gYmIgY2hlY2sgeFxuICAgICAgJiYgcG9zLnkgLSBoaCA8PSB5ICYmIHkgPD0gcG9zLnkgKyBoaCAvLyBiYiBjaGVjayB5XG4gICAgICApIHtcbiAgICAgICAgdmFyIHNoYXBlID0gci5ub2RlU2hhcGVzW3NlbGYuZ2V0Tm9kZVNoYXBlKG5vZGUpXTtcblxuICAgICAgICBpZiAoc2hhcGUuY2hlY2tQb2ludCh4LCB5LCAwLCB3aWR0aCwgaGVpZ2h0LCBwb3MueCwgcG9zLnkpKSB7XG4gICAgICAgICAgYWRkRWxlKG5vZGUsIDApO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tFZGdlKGVkZ2UpIHtcbiAgICAgIHZhciBfcCA9IGVkZ2UuX3ByaXZhdGU7XG4gICAgICB2YXIgcnMgPSBfcC5yc2NyYXRjaDtcbiAgICAgIHZhciBzdHlsZVdpZHRoID0gZWRnZS5wc3R5bGUoJ3dpZHRoJykucGZWYWx1ZTtcbiAgICAgIHZhciBzY2FsZSA9IGVkZ2UucHN0eWxlKCdhcnJvdy1zY2FsZScpLnZhbHVlO1xuICAgICAgdmFyIHdpZHRoID0gc3R5bGVXaWR0aCAvIDIgKyBlZGdlVGhyZXNob2xkOyAvLyBtb3JlIGxpa2UgYSBkaXN0YW5jZSByYWRpdXMgZnJvbSBjZW50cmVcblxuICAgICAgdmFyIHdpZHRoU3EgPSB3aWR0aCAqIHdpZHRoO1xuICAgICAgdmFyIHdpZHRoMiA9IHdpZHRoICogMjtcbiAgICAgIHZhciBzcmMgPSBfcC5zb3VyY2U7XG4gICAgICB2YXIgdGd0ID0gX3AudGFyZ2V0O1xuICAgICAgdmFyIHNxRGlzdDtcblxuICAgICAgaWYgKHJzLmVkZ2VUeXBlID09PSAnc2VnbWVudHMnIHx8IHJzLmVkZ2VUeXBlID09PSAnc3RyYWlnaHQnIHx8IHJzLmVkZ2VUeXBlID09PSAnaGF5c3RhY2snKSB7XG4gICAgICAgIHZhciBwdHMgPSBycy5hbGxwdHM7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgKyAzIDwgcHRzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgaWYgKGluTGluZVZpY2luaXR5KHgsIHksIHB0c1tpXSwgcHRzW2kgKyAxXSwgcHRzW2kgKyAyXSwgcHRzW2kgKyAzXSwgd2lkdGgyKSAmJiB3aWR0aFNxID4gKHNxRGlzdCA9IHNxZGlzdFRvRmluaXRlTGluZSh4LCB5LCBwdHNbaV0sIHB0c1tpICsgMV0sIHB0c1tpICsgMl0sIHB0c1tpICsgM10pKSkge1xuICAgICAgICAgICAgYWRkRWxlKGVkZ2UsIHNxRGlzdCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocnMuZWRnZVR5cGUgPT09ICdiZXppZXInIHx8IHJzLmVkZ2VUeXBlID09PSAnbXVsdGliZXppZXInIHx8IHJzLmVkZ2VUeXBlID09PSAnc2VsZicgfHwgcnMuZWRnZVR5cGUgPT09ICdjb21wb3VuZCcpIHtcbiAgICAgICAgdmFyIHB0cyA9IHJzLmFsbHB0cztcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSArIDUgPCBycy5hbGxwdHMubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgICAgICBpZiAoaW5CZXppZXJWaWNpbml0eSh4LCB5LCBwdHNbaV0sIHB0c1tpICsgMV0sIHB0c1tpICsgMl0sIHB0c1tpICsgM10sIHB0c1tpICsgNF0sIHB0c1tpICsgNV0sIHdpZHRoMikgJiYgd2lkdGhTcSA+IChzcURpc3QgPSBzcWRpc3RUb1F1YWRyYXRpY0Jlemllcih4LCB5LCBwdHNbaV0sIHB0c1tpICsgMV0sIHB0c1tpICsgMl0sIHB0c1tpICsgM10sIHB0c1tpICsgNF0sIHB0c1tpICsgNV0pKSkge1xuICAgICAgICAgICAgYWRkRWxlKGVkZ2UsIHNxRGlzdCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gaWYgd2UncmUgY2xvc2UgdG8gdGhlIGVkZ2UgYnV0IGRpZG4ndCBoaXQgaXQsIG1heWJlIHdlIGhpdCBpdHMgYXJyb3dzXG5cblxuICAgICAgdmFyIHNyYyA9IHNyYyB8fCBfcC5zb3VyY2U7XG4gICAgICB2YXIgdGd0ID0gdGd0IHx8IF9wLnRhcmdldDtcbiAgICAgIHZhciBhclNpemUgPSBzZWxmLmdldEFycm93V2lkdGgoc3R5bGVXaWR0aCwgc2NhbGUpO1xuICAgICAgdmFyIGFycm93cyA9IFt7XG4gICAgICAgIG5hbWU6ICdzb3VyY2UnLFxuICAgICAgICB4OiBycy5hcnJvd1N0YXJ0WCxcbiAgICAgICAgeTogcnMuYXJyb3dTdGFydFksXG4gICAgICAgIGFuZ2xlOiBycy5zcmNBcnJvd0FuZ2xlXG4gICAgICB9LCB7XG4gICAgICAgIG5hbWU6ICd0YXJnZXQnLFxuICAgICAgICB4OiBycy5hcnJvd0VuZFgsXG4gICAgICAgIHk6IHJzLmFycm93RW5kWSxcbiAgICAgICAgYW5nbGU6IHJzLnRndEFycm93QW5nbGVcbiAgICAgIH0sIHtcbiAgICAgICAgbmFtZTogJ21pZC1zb3VyY2UnLFxuICAgICAgICB4OiBycy5taWRYLFxuICAgICAgICB5OiBycy5taWRZLFxuICAgICAgICBhbmdsZTogcnMubWlkc3JjQXJyb3dBbmdsZVxuICAgICAgfSwge1xuICAgICAgICBuYW1lOiAnbWlkLXRhcmdldCcsXG4gICAgICAgIHg6IHJzLm1pZFgsXG4gICAgICAgIHk6IHJzLm1pZFksXG4gICAgICAgIGFuZ2xlOiBycy5taWR0Z3RBcnJvd0FuZ2xlXG4gICAgICB9XTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGFyID0gYXJyb3dzW2ldO1xuICAgICAgICB2YXIgc2hhcGUgPSByLmFycm93U2hhcGVzW2VkZ2UucHN0eWxlKGFyLm5hbWUgKyAnLWFycm93LXNoYXBlJykudmFsdWVdO1xuICAgICAgICB2YXIgZWRnZVdpZHRoID0gZWRnZS5wc3R5bGUoJ3dpZHRoJykucGZWYWx1ZTtcblxuICAgICAgICBpZiAoc2hhcGUucm91Z2hDb2xsaWRlKHgsIHksIGFyU2l6ZSwgYXIuYW5nbGUsIHtcbiAgICAgICAgICB4OiBhci54LFxuICAgICAgICAgIHk6IGFyLnlcbiAgICAgICAgfSwgZWRnZVdpZHRoLCBlZGdlVGhyZXNob2xkKSAmJiBzaGFwZS5jb2xsaWRlKHgsIHksIGFyU2l6ZSwgYXIuYW5nbGUsIHtcbiAgICAgICAgICB4OiBhci54LFxuICAgICAgICAgIHk6IGFyLnlcbiAgICAgICAgfSwgZWRnZVdpZHRoLCBlZGdlVGhyZXNob2xkKSkge1xuICAgICAgICAgIGFkZEVsZShlZGdlKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBmb3IgY29tcG91bmQgZ3JhcGhzLCBoaXR0aW5nIGVkZ2UgbWF5IGFjdHVhbGx5IHdhbnQgYSBjb25uZWN0ZWQgbm9kZSBpbnN0ZWFkIChiL2MgZWRnZSBtYXkgaGF2ZSBncmVhdGVyIHotaW5kZXggcHJlY2VkZW5jZSlcblxuXG4gICAgICBpZiAoaGFzQ29tcG91bmRzICYmIG5lYXIubGVuZ3RoID4gMCkge1xuICAgICAgICBjaGVja05vZGUoc3JjKTtcbiAgICAgICAgY2hlY2tOb2RlKHRndCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJlcHJvcChvYmosIG5hbWUsIHByZSkge1xuICAgICAgcmV0dXJuIGdldFByZWZpeGVkUHJvcGVydHkob2JqLCBuYW1lLCBwcmUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrTGFiZWwoZWxlLCBwcmVmaXgpIHtcbiAgICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICAgIHZhciB0aCA9IGxhYmVsVGhyZXNob2xkO1xuICAgICAgdmFyIHByZWZpeERhc2g7XG5cbiAgICAgIGlmIChwcmVmaXgpIHtcbiAgICAgICAgcHJlZml4RGFzaCA9IHByZWZpeCArICctJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByZWZpeERhc2ggPSAnJztcbiAgICAgIH1cblxuICAgICAgZWxlLmJvdW5kaW5nQm94KCk7XG4gICAgICB2YXIgYmIgPSBfcC5sYWJlbEJvdW5kc1twcmVmaXggfHwgJ21haW4nXTtcbiAgICAgIHZhciB0ZXh0ID0gZWxlLnBzdHlsZShwcmVmaXhEYXNoICsgJ2xhYmVsJykudmFsdWU7XG4gICAgICB2YXIgZXZlbnRzRW5hYmxlZCA9IGVsZS5wc3R5bGUoJ3RleHQtZXZlbnRzJykuc3RyVmFsdWUgPT09ICd5ZXMnO1xuXG4gICAgICBpZiAoIWV2ZW50c0VuYWJsZWQgfHwgIXRleHQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgbHggPSBwcmVwcm9wKF9wLnJzY3JhdGNoLCAnbGFiZWxYJywgcHJlZml4KTtcbiAgICAgIHZhciBseSA9IHByZXByb3AoX3AucnNjcmF0Y2gsICdsYWJlbFknLCBwcmVmaXgpO1xuICAgICAgdmFyIHRoZXRhID0gcHJlcHJvcChfcC5yc2NyYXRjaCwgJ2xhYmVsQW5nbGUnLCBwcmVmaXgpO1xuICAgICAgdmFyIG94ID0gZWxlLnBzdHlsZShwcmVmaXhEYXNoICsgJ3RleHQtbWFyZ2luLXgnKS5wZlZhbHVlO1xuICAgICAgdmFyIG95ID0gZWxlLnBzdHlsZShwcmVmaXhEYXNoICsgJ3RleHQtbWFyZ2luLXknKS5wZlZhbHVlO1xuICAgICAgdmFyIGx4MSA9IGJiLngxIC0gdGggLSBveDsgLy8gKC1veCwgLW95KSBhcyBiYiBhbHJlYWR5IGluY2x1ZGVzIG1hcmdpblxuXG4gICAgICB2YXIgbHgyID0gYmIueDIgKyB0aCAtIG94OyAvLyBhbmQgcm90YXRpb24gaXMgYWJvdXQgKGx4LCBseSlcblxuICAgICAgdmFyIGx5MSA9IGJiLnkxIC0gdGggLSBveTtcbiAgICAgIHZhciBseTIgPSBiYi55MiArIHRoIC0gb3k7XG5cbiAgICAgIGlmICh0aGV0YSkge1xuICAgICAgICB2YXIgY29zID0gTWF0aC5jb3ModGhldGEpO1xuICAgICAgICB2YXIgc2luID0gTWF0aC5zaW4odGhldGEpO1xuXG4gICAgICAgIHZhciByb3RhdGUgPSBmdW5jdGlvbiByb3RhdGUoeCwgeSkge1xuICAgICAgICAgIHggPSB4IC0gbHg7XG4gICAgICAgICAgeSA9IHkgLSBseTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogeCAqIGNvcyAtIHkgKiBzaW4gKyBseCxcbiAgICAgICAgICAgIHk6IHggKiBzaW4gKyB5ICogY29zICsgbHlcbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBweDF5MSA9IHJvdGF0ZShseDEsIGx5MSk7XG4gICAgICAgIHZhciBweDF5MiA9IHJvdGF0ZShseDEsIGx5Mik7XG4gICAgICAgIHZhciBweDJ5MSA9IHJvdGF0ZShseDIsIGx5MSk7XG4gICAgICAgIHZhciBweDJ5MiA9IHJvdGF0ZShseDIsIGx5Mik7XG4gICAgICAgIHZhciBwb2ludHMgPSBbLy8gd2l0aCB0aGUgbWFyZ2luIGFkZGVkIGFmdGVyIHRoZSByb3RhdGlvbiBpcyBhcHBsaWVkXG4gICAgICAgIHB4MXkxLnggKyBveCwgcHgxeTEueSArIG95LCBweDJ5MS54ICsgb3gsIHB4MnkxLnkgKyBveSwgcHgyeTIueCArIG94LCBweDJ5Mi55ICsgb3ksIHB4MXkyLnggKyBveCwgcHgxeTIueSArIG95XTtcblxuICAgICAgICBpZiAocG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKHgsIHksIHBvaW50cykpIHtcbiAgICAgICAgICBhZGRFbGUoZWxlKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZG8gYSBjaGVhcGVyIGJiIGNoZWNrXG4gICAgICAgIGlmIChpbkJvdW5kaW5nQm94KGJiLCB4LCB5KSkge1xuICAgICAgICAgIGFkZEVsZShlbGUpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IGVsZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIC8vIHJldmVyc2Ugb3JkZXIgZm9yIHByZWNlZGVuY2VcbiAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuXG4gICAgICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgICAgIGNoZWNrTm9kZShlbGUpIHx8IGNoZWNrTGFiZWwoZWxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHRoZW4gZWRnZVxuICAgICAgICBjaGVja0VkZ2UoZWxlKSB8fCBjaGVja0xhYmVsKGVsZSkgfHwgY2hlY2tMYWJlbChlbGUsICdzb3VyY2UnKSB8fCBjaGVja0xhYmVsKGVsZSwgJ3RhcmdldCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZWFyO1xuICB9OyAvLyAnR2l2ZSBtZSBldmVyeXRoaW5nIGZyb20gdGhpcyBib3gnXG5cblxuICBCUnAkZS5nZXRBbGxJbkJveCA9IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5Mikge1xuICAgIHZhciBlbGVzID0gdGhpcy5nZXRDYWNoZWRaU29ydGVkRWxlcygpLmludGVyYWN0aXZlO1xuICAgIHZhciBib3ggPSBbXTtcbiAgICB2YXIgeDFjID0gTWF0aC5taW4oeDEsIHgyKTtcbiAgICB2YXIgeDJjID0gTWF0aC5tYXgoeDEsIHgyKTtcbiAgICB2YXIgeTFjID0gTWF0aC5taW4oeTEsIHkyKTtcbiAgICB2YXIgeTJjID0gTWF0aC5tYXgoeTEsIHkyKTtcbiAgICB4MSA9IHgxYztcbiAgICB4MiA9IHgyYztcbiAgICB5MSA9IHkxYztcbiAgICB5MiA9IHkyYztcbiAgICB2YXIgYm94QmIgPSBtYWtlQm91bmRpbmdCb3goe1xuICAgICAgeDE6IHgxLFxuICAgICAgeTE6IHkxLFxuICAgICAgeDI6IHgyLFxuICAgICAgeTI6IHkyXG4gICAgfSk7XG5cbiAgICBmb3IgKHZhciBlID0gMDsgZSA8IGVsZXMubGVuZ3RoOyBlKyspIHtcbiAgICAgIHZhciBlbGUgPSBlbGVzW2VdO1xuXG4gICAgICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgICAgIHZhciBub2RlID0gZWxlO1xuICAgICAgICB2YXIgbm9kZUJiID0gbm9kZS5ib3VuZGluZ0JveCh7XG4gICAgICAgICAgaW5jbHVkZU5vZGVzOiB0cnVlLFxuICAgICAgICAgIGluY2x1ZGVFZGdlczogZmFsc2UsXG4gICAgICAgICAgaW5jbHVkZUxhYmVsczogZmFsc2VcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGJvdW5kaW5nQm94ZXNJbnRlcnNlY3QoYm94QmIsIG5vZGVCYikgJiYgIWJvdW5kaW5nQm94SW5Cb3VuZGluZ0JveChub2RlQmIsIGJveEJiKSkge1xuICAgICAgICAgIGJveC5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZWRnZSA9IGVsZTtcbiAgICAgICAgdmFyIF9wID0gZWRnZS5fcHJpdmF0ZTtcbiAgICAgICAgdmFyIHJzID0gX3AucnNjcmF0Y2g7XG5cbiAgICAgICAgaWYgKHJzLnN0YXJ0WCAhPSBudWxsICYmIHJzLnN0YXJ0WSAhPSBudWxsICYmICFpbkJvdW5kaW5nQm94KGJveEJiLCBycy5zdGFydFgsIHJzLnN0YXJ0WSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChycy5lbmRYICE9IG51bGwgJiYgcnMuZW5kWSAhPSBudWxsICYmICFpbkJvdW5kaW5nQm94KGJveEJiLCBycy5lbmRYLCBycy5lbmRZKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJzLmVkZ2VUeXBlID09PSAnYmV6aWVyJyB8fCBycy5lZGdlVHlwZSA9PT0gJ211bHRpYmV6aWVyJyB8fCBycy5lZGdlVHlwZSA9PT0gJ3NlbGYnIHx8IHJzLmVkZ2VUeXBlID09PSAnY29tcG91bmQnIHx8IHJzLmVkZ2VUeXBlID09PSAnc2VnbWVudHMnIHx8IHJzLmVkZ2VUeXBlID09PSAnaGF5c3RhY2snKSB7XG4gICAgICAgICAgdmFyIHB0cyA9IF9wLnJzdHlsZS5iZXppZXJQdHMgfHwgX3AucnN0eWxlLmxpbmVQdHMgfHwgX3AucnN0eWxlLmhheXN0YWNrUHRzO1xuICAgICAgICAgIHZhciBhbGxJbnNpZGUgPSB0cnVlO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghcG9pbnRJbkJvdW5kaW5nQm94KGJveEJiLCBwdHNbaV0pKSB7XG4gICAgICAgICAgICAgIGFsbEluc2lkZSA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYWxsSW5zaWRlKSB7XG4gICAgICAgICAgICBib3gucHVzaChlZGdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocnMuZWRnZVR5cGUgPT09ICdoYXlzdGFjaycgfHwgcnMuZWRnZVR5cGUgPT09ICdzdHJhaWdodCcpIHtcbiAgICAgICAgICBib3gucHVzaChlZGdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBib3g7XG4gIH07XG5cbiAgdmFyIEJScCRkID0ge307XG5cbiAgQlJwJGQuY2FsY3VsYXRlQXJyb3dBbmdsZXMgPSBmdW5jdGlvbiAoZWRnZSkge1xuICAgIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgdmFyIGlzSGF5c3RhY2sgPSBycy5lZGdlVHlwZSA9PT0gJ2hheXN0YWNrJztcbiAgICB2YXIgaXNCZXppZXIgPSBycy5lZGdlVHlwZSA9PT0gJ2Jlemllcic7XG4gICAgdmFyIGlzTXVsdGliZXppZXIgPSBycy5lZGdlVHlwZSA9PT0gJ211bHRpYmV6aWVyJztcbiAgICB2YXIgaXNTZWdtZW50cyA9IHJzLmVkZ2VUeXBlID09PSAnc2VnbWVudHMnO1xuICAgIHZhciBpc0NvbXBvdW5kID0gcnMuZWRnZVR5cGUgPT09ICdjb21wb3VuZCc7XG4gICAgdmFyIGlzU2VsZiA9IHJzLmVkZ2VUeXBlID09PSAnc2VsZic7IC8vIERpc3BsYWNlbWVudCBnaXZlcyBkaXJlY3Rpb24gZm9yIGFycm93aGVhZCBvcmllbnRhdGlvblxuXG4gICAgdmFyIGRpc3BYLCBkaXNwWTtcbiAgICB2YXIgc3RhcnRYLCBzdGFydFksIGVuZFgsIGVuZFksIG1pZFgsIG1pZFk7XG5cbiAgICBpZiAoaXNIYXlzdGFjaykge1xuICAgICAgc3RhcnRYID0gcnMuaGF5c3RhY2tQdHNbMF07XG4gICAgICBzdGFydFkgPSBycy5oYXlzdGFja1B0c1sxXTtcbiAgICAgIGVuZFggPSBycy5oYXlzdGFja1B0c1syXTtcbiAgICAgIGVuZFkgPSBycy5oYXlzdGFja1B0c1szXTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnRYID0gcnMuYXJyb3dTdGFydFg7XG4gICAgICBzdGFydFkgPSBycy5hcnJvd1N0YXJ0WTtcbiAgICAgIGVuZFggPSBycy5hcnJvd0VuZFg7XG4gICAgICBlbmRZID0gcnMuYXJyb3dFbmRZO1xuICAgIH1cblxuICAgIG1pZFggPSBycy5taWRYO1xuICAgIG1pZFkgPSBycy5taWRZOyAvLyBzb3VyY2VcbiAgICAvL1xuXG4gICAgaWYgKGlzU2VnbWVudHMpIHtcbiAgICAgIGRpc3BYID0gc3RhcnRYIC0gcnMuc2VncHRzWzBdO1xuICAgICAgZGlzcFkgPSBzdGFydFkgLSBycy5zZWdwdHNbMV07XG4gICAgfSBlbHNlIGlmIChpc011bHRpYmV6aWVyIHx8IGlzQ29tcG91bmQgfHwgaXNTZWxmIHx8IGlzQmV6aWVyKSB7XG4gICAgICB2YXIgcHRzID0gcnMuYWxscHRzO1xuICAgICAgdmFyIGJYID0gcWJlemllckF0KHB0c1swXSwgcHRzWzJdLCBwdHNbNF0sIDAuMSk7XG4gICAgICB2YXIgYlkgPSBxYmV6aWVyQXQocHRzWzFdLCBwdHNbM10sIHB0c1s1XSwgMC4xKTtcbiAgICAgIGRpc3BYID0gc3RhcnRYIC0gYlg7XG4gICAgICBkaXNwWSA9IHN0YXJ0WSAtIGJZO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaXNwWCA9IHN0YXJ0WCAtIG1pZFg7XG4gICAgICBkaXNwWSA9IHN0YXJ0WSAtIG1pZFk7XG4gICAgfVxuXG4gICAgcnMuc3JjQXJyb3dBbmdsZSA9IGdldEFuZ2xlRnJvbURpc3AoZGlzcFgsIGRpc3BZKTsgLy8gbWlkIHRhcmdldFxuICAgIC8vXG5cbiAgICB2YXIgbWlkWCA9IHJzLm1pZFg7XG4gICAgdmFyIG1pZFkgPSBycy5taWRZO1xuXG4gICAgaWYgKGlzSGF5c3RhY2spIHtcbiAgICAgIG1pZFggPSAoc3RhcnRYICsgZW5kWCkgLyAyO1xuICAgICAgbWlkWSA9IChzdGFydFkgKyBlbmRZKSAvIDI7XG4gICAgfVxuXG4gICAgZGlzcFggPSBlbmRYIC0gc3RhcnRYO1xuICAgIGRpc3BZID0gZW5kWSAtIHN0YXJ0WTtcblxuICAgIGlmIChpc1NlZ21lbnRzKSB7XG4gICAgICB2YXIgcHRzID0gcnMuYWxscHRzO1xuXG4gICAgICBpZiAocHRzLmxlbmd0aCAvIDIgJSAyID09PSAwKSB7XG4gICAgICAgIHZhciBpMiA9IHB0cy5sZW5ndGggLyAyO1xuICAgICAgICB2YXIgaTEgPSBpMiAtIDI7XG4gICAgICAgIGRpc3BYID0gcHRzW2kyXSAtIHB0c1tpMV07XG4gICAgICAgIGRpc3BZID0gcHRzW2kyICsgMV0gLSBwdHNbaTEgKyAxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpMiA9IHB0cy5sZW5ndGggLyAyIC0gMTtcbiAgICAgICAgdmFyIGkxID0gaTIgLSAyO1xuICAgICAgICB2YXIgaTMgPSBpMiArIDI7XG4gICAgICAgIGRpc3BYID0gcHRzW2kyXSAtIHB0c1tpMV07XG4gICAgICAgIGRpc3BZID0gcHRzW2kyICsgMV0gLSBwdHNbaTEgKyAxXTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzTXVsdGliZXppZXIgfHwgaXNDb21wb3VuZCB8fCBpc1NlbGYpIHtcbiAgICAgIHZhciBwdHMgPSBycy5hbGxwdHM7XG4gICAgICB2YXIgY3B0cyA9IHJzLmN0cmxwdHM7XG4gICAgICB2YXIgYnAweCwgYnAweTtcbiAgICAgIHZhciBicDF4LCBicDF5O1xuXG4gICAgICBpZiAoY3B0cy5sZW5ndGggLyAyICUgMiA9PT0gMCkge1xuICAgICAgICB2YXIgcDAgPSBwdHMubGVuZ3RoIC8gMiAtIDE7IC8vIHN0YXJ0cHRcblxuICAgICAgICB2YXIgaWMgPSBwMCArIDI7XG4gICAgICAgIHZhciBwMSA9IGljICsgMjtcbiAgICAgICAgYnAweCA9IHFiZXppZXJBdChwdHNbcDBdLCBwdHNbaWNdLCBwdHNbcDFdLCAwLjApO1xuICAgICAgICBicDB5ID0gcWJlemllckF0KHB0c1twMCArIDFdLCBwdHNbaWMgKyAxXSwgcHRzW3AxICsgMV0sIDAuMCk7XG4gICAgICAgIGJwMXggPSBxYmV6aWVyQXQocHRzW3AwXSwgcHRzW2ljXSwgcHRzW3AxXSwgMC4wMDAxKTtcbiAgICAgICAgYnAxeSA9IHFiZXppZXJBdChwdHNbcDAgKyAxXSwgcHRzW2ljICsgMV0sIHB0c1twMSArIDFdLCAwLjAwMDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGljID0gcHRzLmxlbmd0aCAvIDIgLSAxOyAvLyBjdHJwdFxuXG4gICAgICAgIHZhciBwMCA9IGljIC0gMjsgLy8gc3RhcnRwdFxuXG4gICAgICAgIHZhciBwMSA9IGljICsgMjsgLy8gZW5kcHRcblxuICAgICAgICBicDB4ID0gcWJlemllckF0KHB0c1twMF0sIHB0c1tpY10sIHB0c1twMV0sIDAuNDk5OSk7XG4gICAgICAgIGJwMHkgPSBxYmV6aWVyQXQocHRzW3AwICsgMV0sIHB0c1tpYyArIDFdLCBwdHNbcDEgKyAxXSwgMC40OTk5KTtcbiAgICAgICAgYnAxeCA9IHFiZXppZXJBdChwdHNbcDBdLCBwdHNbaWNdLCBwdHNbcDFdLCAwLjUpO1xuICAgICAgICBicDF5ID0gcWJlemllckF0KHB0c1twMCArIDFdLCBwdHNbaWMgKyAxXSwgcHRzW3AxICsgMV0sIDAuNSk7XG4gICAgICB9XG5cbiAgICAgIGRpc3BYID0gYnAxeCAtIGJwMHg7XG4gICAgICBkaXNwWSA9IGJwMXkgLSBicDB5O1xuICAgIH1cblxuICAgIHJzLm1pZHRndEFycm93QW5nbGUgPSBnZXRBbmdsZUZyb21EaXNwKGRpc3BYLCBkaXNwWSk7XG4gICAgcnMubWlkRGlzcFggPSBkaXNwWDtcbiAgICBycy5taWREaXNwWSA9IGRpc3BZOyAvLyBtaWQgc291cmNlXG4gICAgLy9cblxuICAgIGRpc3BYICo9IC0xO1xuICAgIGRpc3BZICo9IC0xO1xuXG4gICAgaWYgKGlzU2VnbWVudHMpIHtcbiAgICAgIHZhciBwdHMgPSBycy5hbGxwdHM7XG5cbiAgICAgIGlmIChwdHMubGVuZ3RoIC8gMiAlIDIgPT09IDApIDsgZWxzZSB7XG4gICAgICAgIHZhciBpMiA9IHB0cy5sZW5ndGggLyAyIC0gMTtcbiAgICAgICAgdmFyIGkzID0gaTIgKyAyO1xuICAgICAgICBkaXNwWCA9IC0ocHRzW2kzXSAtIHB0c1tpMl0pO1xuICAgICAgICBkaXNwWSA9IC0ocHRzW2kzICsgMV0gLSBwdHNbaTIgKyAxXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcnMubWlkc3JjQXJyb3dBbmdsZSA9IGdldEFuZ2xlRnJvbURpc3AoZGlzcFgsIGRpc3BZKTsgLy8gdGFyZ2V0XG4gICAgLy9cblxuICAgIGlmIChpc1NlZ21lbnRzKSB7XG4gICAgICBkaXNwWCA9IGVuZFggLSBycy5zZWdwdHNbcnMuc2VncHRzLmxlbmd0aCAtIDJdO1xuICAgICAgZGlzcFkgPSBlbmRZIC0gcnMuc2VncHRzW3JzLnNlZ3B0cy5sZW5ndGggLSAxXTtcbiAgICB9IGVsc2UgaWYgKGlzTXVsdGliZXppZXIgfHwgaXNDb21wb3VuZCB8fCBpc1NlbGYgfHwgaXNCZXppZXIpIHtcbiAgICAgIHZhciBwdHMgPSBycy5hbGxwdHM7XG4gICAgICB2YXIgbCA9IHB0cy5sZW5ndGg7XG4gICAgICB2YXIgYlggPSBxYmV6aWVyQXQocHRzW2wgLSA2XSwgcHRzW2wgLSA0XSwgcHRzW2wgLSAyXSwgMC45KTtcbiAgICAgIHZhciBiWSA9IHFiZXppZXJBdChwdHNbbCAtIDVdLCBwdHNbbCAtIDNdLCBwdHNbbCAtIDFdLCAwLjkpO1xuICAgICAgZGlzcFggPSBlbmRYIC0gYlg7XG4gICAgICBkaXNwWSA9IGVuZFkgLSBiWTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGlzcFggPSBlbmRYIC0gbWlkWDtcbiAgICAgIGRpc3BZID0gZW5kWSAtIG1pZFk7XG4gICAgfVxuXG4gICAgcnMudGd0QXJyb3dBbmdsZSA9IGdldEFuZ2xlRnJvbURpc3AoZGlzcFgsIGRpc3BZKTtcbiAgfTtcblxuICBCUnAkZC5nZXRBcnJvd1dpZHRoID0gQlJwJGQuZ2V0QXJyb3dIZWlnaHQgPSBmdW5jdGlvbiAoZWRnZVdpZHRoLCBzY2FsZSkge1xuICAgIHZhciBjYWNoZSA9IHRoaXMuYXJyb3dXaWR0aENhY2hlID0gdGhpcy5hcnJvd1dpZHRoQ2FjaGUgfHwge307XG4gICAgdmFyIGNhY2hlZFZhbCA9IGNhY2hlW2VkZ2VXaWR0aCArICcsICcgKyBzY2FsZV07XG5cbiAgICBpZiAoY2FjaGVkVmFsKSB7XG4gICAgICByZXR1cm4gY2FjaGVkVmFsO1xuICAgIH1cblxuICAgIGNhY2hlZFZhbCA9IE1hdGgubWF4KE1hdGgucG93KGVkZ2VXaWR0aCAqIDEzLjM3LCAwLjkpLCAyOSkgKiBzY2FsZTtcbiAgICBjYWNoZVtlZGdlV2lkdGggKyAnLCAnICsgc2NhbGVdID0gY2FjaGVkVmFsO1xuICAgIHJldHVybiBjYWNoZWRWYWw7XG4gIH07XG5cbiAgdmFyIEJScCRjID0ge307XG5cbiAgQlJwJGMuZmluZEhheXN0YWNrUG9pbnRzID0gZnVuY3Rpb24gKGVkZ2VzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tpXTtcbiAgICAgIHZhciBfcCA9IGVkZ2UuX3ByaXZhdGU7XG4gICAgICB2YXIgcnMgPSBfcC5yc2NyYXRjaDtcblxuICAgICAgaWYgKCFycy5oYXlzdGFjaykge1xuICAgICAgICB2YXIgYW5nbGUgPSBNYXRoLnJhbmRvbSgpICogMiAqIE1hdGguUEk7XG4gICAgICAgIHJzLnNvdXJjZSA9IHtcbiAgICAgICAgICB4OiBNYXRoLmNvcyhhbmdsZSksXG4gICAgICAgICAgeTogTWF0aC5zaW4oYW5nbGUpXG4gICAgICAgIH07XG4gICAgICAgIGFuZ2xlID0gTWF0aC5yYW5kb20oKSAqIDIgKiBNYXRoLlBJO1xuICAgICAgICBycy50YXJnZXQgPSB7XG4gICAgICAgICAgeDogTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICAgIHk6IE1hdGguc2luKGFuZ2xlKVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB2YXIgc3JjID0gX3Auc291cmNlO1xuICAgICAgdmFyIHRndCA9IF9wLnRhcmdldDtcbiAgICAgIHZhciBzcmNQb3MgPSBzcmMucG9zaXRpb24oKTtcbiAgICAgIHZhciB0Z3RQb3MgPSB0Z3QucG9zaXRpb24oKTtcbiAgICAgIHZhciBzcmNXID0gc3JjLndpZHRoKCk7XG4gICAgICB2YXIgdGd0VyA9IHRndC53aWR0aCgpO1xuICAgICAgdmFyIHNyY0ggPSBzcmMuaGVpZ2h0KCk7XG4gICAgICB2YXIgdGd0SCA9IHRndC5oZWlnaHQoKTtcbiAgICAgIHZhciByYWRpdXMgPSBlZGdlLnBzdHlsZSgnaGF5c3RhY2stcmFkaXVzJykudmFsdWU7XG4gICAgICB2YXIgaGFsZlJhZGl1cyA9IHJhZGl1cyAvIDI7IC8vIGIvYyBoYXZlIHRvIGhhbGYgd2lkdGgvaGVpZ2h0XG5cbiAgICAgIHJzLmhheXN0YWNrUHRzID0gcnMuYWxscHRzID0gW3JzLnNvdXJjZS54ICogc3JjVyAqIGhhbGZSYWRpdXMgKyBzcmNQb3MueCwgcnMuc291cmNlLnkgKiBzcmNIICogaGFsZlJhZGl1cyArIHNyY1Bvcy55LCBycy50YXJnZXQueCAqIHRndFcgKiBoYWxmUmFkaXVzICsgdGd0UG9zLngsIHJzLnRhcmdldC55ICogdGd0SCAqIGhhbGZSYWRpdXMgKyB0Z3RQb3MueV07XG4gICAgICBycy5taWRYID0gKHJzLmFsbHB0c1swXSArIHJzLmFsbHB0c1syXSkgLyAyO1xuICAgICAgcnMubWlkWSA9IChycy5hbGxwdHNbMV0gKyBycy5hbGxwdHNbM10pIC8gMjsgLy8gYWx3YXlzIG92ZXJyaWRlIGFzIGhheXN0YWNrIGluIGNhc2Ugc2V0IHRvIGRpZmZlcmVudCB0eXBlIHByZXZpb3VzbHlcblxuICAgICAgcnMuZWRnZVR5cGUgPSAnaGF5c3RhY2snO1xuICAgICAgcnMuaGF5c3RhY2sgPSB0cnVlO1xuICAgICAgdGhpcy5zdG9yZUVkZ2VQcm9qZWN0aW9ucyhlZGdlKTtcbiAgICAgIHRoaXMuY2FsY3VsYXRlQXJyb3dBbmdsZXMoZWRnZSk7XG4gICAgICB0aGlzLnJlY2FsY3VsYXRlRWRnZUxhYmVsUHJvamVjdGlvbnMoZWRnZSk7XG4gICAgICB0aGlzLmNhbGN1bGF0ZUxhYmVsQW5nbGVzKGVkZ2UpO1xuICAgIH1cbiAgfTtcblxuICBCUnAkYy5maW5kU2VnbWVudHNQb2ludHMgPSBmdW5jdGlvbiAoZWRnZSwgcGFpckluZm8pIHtcbiAgICAvLyBTZWdtZW50cyAobXVsdGlwbGUgc3RyYWlnaHQgbGluZXMpXG4gICAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICB2YXIgcG9zUHRzID0gcGFpckluZm8ucG9zUHRzLFxuICAgICAgICBpbnRlcnNlY3Rpb25QdHMgPSBwYWlySW5mby5pbnRlcnNlY3Rpb25QdHMsXG4gICAgICAgIHZlY3Rvck5vcm1JbnZlcnNlID0gcGFpckluZm8udmVjdG9yTm9ybUludmVyc2U7XG4gICAgdmFyIGVkZ2VEaXN0YW5jZXMgPSBlZGdlLnBzdHlsZSgnZWRnZS1kaXN0YW5jZXMnKS52YWx1ZTtcbiAgICB2YXIgc2VnbWVudFdzID0gZWRnZS5wc3R5bGUoJ3NlZ21lbnQtd2VpZ2h0cycpO1xuICAgIHZhciBzZWdtZW50RHMgPSBlZGdlLnBzdHlsZSgnc2VnbWVudC1kaXN0YW5jZXMnKTtcbiAgICB2YXIgc2VnbWVudHNOID0gTWF0aC5taW4oc2VnbWVudFdzLnBmVmFsdWUubGVuZ3RoLCBzZWdtZW50RHMucGZWYWx1ZS5sZW5ndGgpO1xuICAgIHJzLmVkZ2VUeXBlID0gJ3NlZ21lbnRzJztcbiAgICBycy5zZWdwdHMgPSBbXTtcblxuICAgIGZvciAodmFyIHMgPSAwOyBzIDwgc2VnbWVudHNOOyBzKyspIHtcbiAgICAgIHZhciB3ID0gc2VnbWVudFdzLnBmVmFsdWVbc107XG4gICAgICB2YXIgZCA9IHNlZ21lbnREcy5wZlZhbHVlW3NdO1xuICAgICAgdmFyIHcxID0gMSAtIHc7XG4gICAgICB2YXIgdzIgPSB3O1xuICAgICAgdmFyIG1pZHB0UHRzID0gZWRnZURpc3RhbmNlcyA9PT0gJ25vZGUtcG9zaXRpb24nID8gcG9zUHRzIDogaW50ZXJzZWN0aW9uUHRzO1xuICAgICAgdmFyIGFkanVzdGVkTWlkcHQgPSB7XG4gICAgICAgIHg6IG1pZHB0UHRzLngxICogdzEgKyBtaWRwdFB0cy54MiAqIHcyLFxuICAgICAgICB5OiBtaWRwdFB0cy55MSAqIHcxICsgbWlkcHRQdHMueTIgKiB3MlxuICAgICAgfTtcbiAgICAgIHJzLnNlZ3B0cy5wdXNoKGFkanVzdGVkTWlkcHQueCArIHZlY3Rvck5vcm1JbnZlcnNlLnggKiBkLCBhZGp1c3RlZE1pZHB0LnkgKyB2ZWN0b3JOb3JtSW52ZXJzZS55ICogZCk7XG4gICAgfVxuICB9O1xuXG4gIEJScCRjLmZpbmRMb29wUG9pbnRzID0gZnVuY3Rpb24gKGVkZ2UsIHBhaXJJbmZvLCBpLCBlZGdlSXNVbmJ1bmRsZWQpIHtcbiAgICAvLyBTZWxmLWVkZ2VcbiAgICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICAgIHZhciBkaXJDb3VudHMgPSBwYWlySW5mby5kaXJDb3VudHMsXG4gICAgICAgIHNyY1BvcyA9IHBhaXJJbmZvLnNyY1BvcztcbiAgICB2YXIgY3RybHB0RGlzdHMgPSBlZGdlLnBzdHlsZSgnY29udHJvbC1wb2ludC1kaXN0YW5jZXMnKTtcbiAgICB2YXIgY3RybHB0RGlzdCA9IGN0cmxwdERpc3RzID8gY3RybHB0RGlzdHMucGZWYWx1ZVswXSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgbG9vcERpciA9IGVkZ2UucHN0eWxlKCdsb29wLWRpcmVjdGlvbicpLnBmVmFsdWU7XG4gICAgdmFyIGxvb3BTd3AgPSBlZGdlLnBzdHlsZSgnbG9vcC1zd2VlcCcpLnBmVmFsdWU7XG4gICAgdmFyIHN0ZXBTaXplID0gZWRnZS5wc3R5bGUoJ2NvbnRyb2wtcG9pbnQtc3RlcC1zaXplJykucGZWYWx1ZTtcbiAgICBycy5lZGdlVHlwZSA9ICdzZWxmJztcbiAgICB2YXIgaiA9IGk7XG4gICAgdmFyIGxvb3BEaXN0ID0gc3RlcFNpemU7XG5cbiAgICBpZiAoZWRnZUlzVW5idW5kbGVkKSB7XG4gICAgICBqID0gMDtcbiAgICAgIGxvb3BEaXN0ID0gY3RybHB0RGlzdDtcbiAgICB9XG5cbiAgICB2YXIgbG9vcEFuZ2xlID0gbG9vcERpciAtIE1hdGguUEkgLyAyO1xuICAgIHZhciBvdXRBbmdsZSA9IGxvb3BBbmdsZSAtIGxvb3BTd3AgLyAyO1xuICAgIHZhciBpbkFuZ2xlID0gbG9vcEFuZ2xlICsgbG9vcFN3cCAvIDI7IC8vIGluY3JlYXNlIGJ5IHN0ZXAgc2l6ZSBmb3Igb3ZlcmxhcHBpbmcgbG9vcHMsIGtleWVkIG9uIGRpcmVjdGlvbiBhbmQgc3dlZXAgdmFsdWVzXG5cbiAgICB2YXIgZGMgPSBTdHJpbmcobG9vcERpciArICdfJyArIGxvb3BTd3ApO1xuICAgIGogPSBkaXJDb3VudHNbZGNdID09PSB1bmRlZmluZWQgPyBkaXJDb3VudHNbZGNdID0gMCA6ICsrZGlyQ291bnRzW2RjXTtcbiAgICBycy5jdHJscHRzID0gW3NyY1Bvcy54ICsgTWF0aC5jb3Mob3V0QW5nbGUpICogMS40ICogbG9vcERpc3QgKiAoaiAvIDMgKyAxKSwgc3JjUG9zLnkgKyBNYXRoLnNpbihvdXRBbmdsZSkgKiAxLjQgKiBsb29wRGlzdCAqIChqIC8gMyArIDEpLCBzcmNQb3MueCArIE1hdGguY29zKGluQW5nbGUpICogMS40ICogbG9vcERpc3QgKiAoaiAvIDMgKyAxKSwgc3JjUG9zLnkgKyBNYXRoLnNpbihpbkFuZ2xlKSAqIDEuNCAqIGxvb3BEaXN0ICogKGogLyAzICsgMSldO1xuICB9O1xuXG4gIEJScCRjLmZpbmRDb21wb3VuZExvb3BQb2ludHMgPSBmdW5jdGlvbiAoZWRnZSwgcGFpckluZm8sIGksIGVkZ2VJc1VuYnVuZGxlZCkge1xuICAgIC8vIENvbXBvdW5kIGVkZ2VcbiAgICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICAgIHJzLmVkZ2VUeXBlID0gJ2NvbXBvdW5kJztcbiAgICB2YXIgc3JjUG9zID0gcGFpckluZm8uc3JjUG9zLFxuICAgICAgICB0Z3RQb3MgPSBwYWlySW5mby50Z3RQb3MsXG4gICAgICAgIHNyY1cgPSBwYWlySW5mby5zcmNXLFxuICAgICAgICBzcmNIID0gcGFpckluZm8uc3JjSCxcbiAgICAgICAgdGd0VyA9IHBhaXJJbmZvLnRndFcsXG4gICAgICAgIHRndEggPSBwYWlySW5mby50Z3RIO1xuICAgIHZhciBzdGVwU2l6ZSA9IGVkZ2UucHN0eWxlKCdjb250cm9sLXBvaW50LXN0ZXAtc2l6ZScpLnBmVmFsdWU7XG4gICAgdmFyIGN0cmxwdERpc3RzID0gZWRnZS5wc3R5bGUoJ2NvbnRyb2wtcG9pbnQtZGlzdGFuY2VzJyk7XG4gICAgdmFyIGN0cmxwdERpc3QgPSBjdHJscHREaXN0cyA/IGN0cmxwdERpc3RzLnBmVmFsdWVbMF0gOiB1bmRlZmluZWQ7XG4gICAgdmFyIGogPSBpO1xuICAgIHZhciBsb29wRGlzdCA9IHN0ZXBTaXplO1xuXG4gICAgaWYgKGVkZ2VJc1VuYnVuZGxlZCkge1xuICAgICAgaiA9IDA7XG4gICAgICBsb29wRGlzdCA9IGN0cmxwdERpc3Q7XG4gICAgfVxuXG4gICAgdmFyIGxvb3BXID0gNTA7XG4gICAgdmFyIGxvb3BhUG9zID0ge1xuICAgICAgeDogc3JjUG9zLnggLSBzcmNXIC8gMixcbiAgICAgIHk6IHNyY1Bvcy55IC0gc3JjSCAvIDJcbiAgICB9O1xuICAgIHZhciBsb29wYlBvcyA9IHtcbiAgICAgIHg6IHRndFBvcy54IC0gdGd0VyAvIDIsXG4gICAgICB5OiB0Z3RQb3MueSAtIHRndEggLyAyXG4gICAgfTtcbiAgICB2YXIgbG9vcFBvcyA9IHtcbiAgICAgIHg6IE1hdGgubWluKGxvb3BhUG9zLngsIGxvb3BiUG9zLngpLFxuICAgICAgeTogTWF0aC5taW4obG9vcGFQb3MueSwgbG9vcGJQb3MueSlcbiAgICB9OyAvLyBhdm9pZHMgY2FzZXMgd2l0aCBpbXBvc3NpYmxlIGJlemllcnNcblxuICAgIHZhciBtaW5Db21wb3VuZFN0cmV0Y2ggPSAwLjU7XG4gICAgdmFyIGNvbXBvdW5kU3RyZXRjaEEgPSBNYXRoLm1heChtaW5Db21wb3VuZFN0cmV0Y2gsIE1hdGgubG9nKHNyY1cgKiAwLjAxKSk7XG4gICAgdmFyIGNvbXBvdW5kU3RyZXRjaEIgPSBNYXRoLm1heChtaW5Db21wb3VuZFN0cmV0Y2gsIE1hdGgubG9nKHRndFcgKiAwLjAxKSk7XG4gICAgcnMuY3RybHB0cyA9IFtsb29wUG9zLngsIGxvb3BQb3MueSAtICgxICsgTWF0aC5wb3cobG9vcFcsIDEuMTIpIC8gMTAwKSAqIGxvb3BEaXN0ICogKGogLyAzICsgMSkgKiBjb21wb3VuZFN0cmV0Y2hBLCBsb29wUG9zLnggLSAoMSArIE1hdGgucG93KGxvb3BXLCAxLjEyKSAvIDEwMCkgKiBsb29wRGlzdCAqIChqIC8gMyArIDEpICogY29tcG91bmRTdHJldGNoQiwgbG9vcFBvcy55XTtcbiAgfTtcblxuICBCUnAkYy5maW5kU3RyYWlnaHRFZGdlUG9pbnRzID0gZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAvLyBTdHJhaWdodCBlZGdlIHdpdGhpbiBidW5kbGVcbiAgICBlZGdlLl9wcml2YXRlLnJzY3JhdGNoLmVkZ2VUeXBlID0gJ3N0cmFpZ2h0JztcbiAgfTtcblxuICBCUnAkYy5maW5kQmV6aWVyUG9pbnRzID0gZnVuY3Rpb24gKGVkZ2UsIHBhaXJJbmZvLCBpLCBlZGdlSXNVbmJ1bmRsZWQsIGVkZ2VJc1N3YXBwZWQpIHtcbiAgICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICAgIHZhciB2ZWN0b3JOb3JtSW52ZXJzZSA9IHBhaXJJbmZvLnZlY3Rvck5vcm1JbnZlcnNlLFxuICAgICAgICBwb3NQdHMgPSBwYWlySW5mby5wb3NQdHMsXG4gICAgICAgIGludGVyc2VjdGlvblB0cyA9IHBhaXJJbmZvLmludGVyc2VjdGlvblB0cztcbiAgICB2YXIgZWRnZURpc3RhbmNlcyA9IGVkZ2UucHN0eWxlKCdlZGdlLWRpc3RhbmNlcycpLnZhbHVlO1xuICAgIHZhciBzdGVwU2l6ZSA9IGVkZ2UucHN0eWxlKCdjb250cm9sLXBvaW50LXN0ZXAtc2l6ZScpLnBmVmFsdWU7XG4gICAgdmFyIGN0cmxwdERpc3RzID0gZWRnZS5wc3R5bGUoJ2NvbnRyb2wtcG9pbnQtZGlzdGFuY2VzJyk7XG4gICAgdmFyIGN0cmxwdFdzID0gZWRnZS5wc3R5bGUoJ2NvbnRyb2wtcG9pbnQtd2VpZ2h0cycpO1xuICAgIHZhciBiZXppZXJOID0gY3RybHB0RGlzdHMgJiYgY3RybHB0V3MgPyBNYXRoLm1pbihjdHJscHREaXN0cy52YWx1ZS5sZW5ndGgsIGN0cmxwdFdzLnZhbHVlLmxlbmd0aCkgOiAxO1xuICAgIHZhciBjdHJscHREaXN0ID0gY3RybHB0RGlzdHMgPyBjdHJscHREaXN0cy5wZlZhbHVlWzBdIDogdW5kZWZpbmVkO1xuICAgIHZhciBjdHJscHRXZWlnaHQgPSBjdHJscHRXcy52YWx1ZVswXTsgLy8gKE11bHRpKWJlemllclxuXG4gICAgdmFyIG11bHRpID0gZWRnZUlzVW5idW5kbGVkO1xuICAgIHJzLmVkZ2VUeXBlID0gbXVsdGkgPyAnbXVsdGliZXppZXInIDogJ2Jlemllcic7XG4gICAgcnMuY3RybHB0cyA9IFtdO1xuXG4gICAgZm9yICh2YXIgYiA9IDA7IGIgPCBiZXppZXJOOyBiKyspIHtcbiAgICAgIHZhciBub3JtY3RybHB0RGlzdCA9ICgwLjUgLSBwYWlySW5mby5lbGVzLmxlbmd0aCAvIDIgKyBpKSAqIHN0ZXBTaXplICogKGVkZ2VJc1N3YXBwZWQgPyAtMSA6IDEpO1xuICAgICAgdmFyIG1hbmN0cmxwdERpc3QgPSB2b2lkIDA7XG4gICAgICB2YXIgc2lnbiA9IHNpZ251bShub3JtY3RybHB0RGlzdCk7XG5cbiAgICAgIGlmIChtdWx0aSkge1xuICAgICAgICBjdHJscHREaXN0ID0gY3RybHB0RGlzdHMgPyBjdHJscHREaXN0cy5wZlZhbHVlW2JdIDogc3RlcFNpemU7IC8vIGZhbGwgYmFjayBvbiBzdGVwIHNpemVcblxuICAgICAgICBjdHJscHRXZWlnaHQgPSBjdHJscHRXcy52YWx1ZVtiXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVkZ2VJc1VuYnVuZGxlZCkge1xuICAgICAgICAvLyBtdWx0aSBvciBzaW5nbGUgdW5idW5kbGVkXG4gICAgICAgIG1hbmN0cmxwdERpc3QgPSBjdHJscHREaXN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWFuY3RybHB0RGlzdCA9IGN0cmxwdERpc3QgIT09IHVuZGVmaW5lZCA/IHNpZ24gKiBjdHJscHREaXN0IDogdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGlzdGFuY2VGcm9tTWlkcG9pbnQgPSBtYW5jdHJscHREaXN0ICE9PSB1bmRlZmluZWQgPyBtYW5jdHJscHREaXN0IDogbm9ybWN0cmxwdERpc3Q7XG4gICAgICB2YXIgdzEgPSAxIC0gY3RybHB0V2VpZ2h0O1xuICAgICAgdmFyIHcyID0gY3RybHB0V2VpZ2h0O1xuICAgICAgdmFyIG1pZHB0UHRzID0gZWRnZURpc3RhbmNlcyA9PT0gJ25vZGUtcG9zaXRpb24nID8gcG9zUHRzIDogaW50ZXJzZWN0aW9uUHRzO1xuICAgICAgdmFyIGFkanVzdGVkTWlkcHQgPSB7XG4gICAgICAgIHg6IG1pZHB0UHRzLngxICogdzEgKyBtaWRwdFB0cy54MiAqIHcyLFxuICAgICAgICB5OiBtaWRwdFB0cy55MSAqIHcxICsgbWlkcHRQdHMueTIgKiB3MlxuICAgICAgfTtcbiAgICAgIHJzLmN0cmxwdHMucHVzaChhZGp1c3RlZE1pZHB0LnggKyB2ZWN0b3JOb3JtSW52ZXJzZS54ICogZGlzdGFuY2VGcm9tTWlkcG9pbnQsIGFkanVzdGVkTWlkcHQueSArIHZlY3Rvck5vcm1JbnZlcnNlLnkgKiBkaXN0YW5jZUZyb21NaWRwb2ludCk7XG4gICAgfVxuICB9O1xuXG4gIEJScCRjLmZpbmRUYXhpUG9pbnRzID0gZnVuY3Rpb24gKGVkZ2UsIHBhaXJJbmZvKSB7XG4gICAgLy8gVGF4aWNhYiBnZW9tZXRyeSB3aXRoIHR3byB0dXJucyBtYXhpbXVtXG4gICAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICBycy5lZGdlVHlwZSA9ICdzZWdtZW50cyc7XG4gICAgdmFyIFZFUlRJQ0FMID0gJ3ZlcnRpY2FsJztcbiAgICB2YXIgSE9SSVpPTlRBTCA9ICdob3Jpem9udGFsJztcbiAgICB2YXIgTEVGVFdBUkQgPSAnbGVmdHdhcmQnO1xuICAgIHZhciBSSUdIVFdBUkQgPSAncmlnaHR3YXJkJztcbiAgICB2YXIgRE9XTldBUkQgPSAnZG93bndhcmQnO1xuICAgIHZhciBVUFdBUkQgPSAndXB3YXJkJztcbiAgICB2YXIgQVVUTyA9ICdhdXRvJztcbiAgICB2YXIgcG9zUHRzID0gcGFpckluZm8ucG9zUHRzLFxuICAgICAgICBzcmNXID0gcGFpckluZm8uc3JjVyxcbiAgICAgICAgc3JjSCA9IHBhaXJJbmZvLnNyY0gsXG4gICAgICAgIHRndFcgPSBwYWlySW5mby50Z3RXLFxuICAgICAgICB0Z3RIID0gcGFpckluZm8udGd0SDtcbiAgICB2YXIgZWRnZURpc3RhbmNlcyA9IGVkZ2UucHN0eWxlKCdlZGdlLWRpc3RhbmNlcycpLnZhbHVlO1xuICAgIHZhciBkSW5jbHVkZXNOb2RlQm9keSA9IGVkZ2VEaXN0YW5jZXMgIT09ICdub2RlLXBvc2l0aW9uJztcbiAgICB2YXIgdGF4aURpciA9IGVkZ2UucHN0eWxlKCd0YXhpLWRpcmVjdGlvbicpLnZhbHVlO1xuICAgIHZhciByYXdUYXhpRGlyID0gdGF4aURpcjsgLy8gdW5wcm9jZXNzZWQgdmFsdWVcblxuICAgIHZhciB0YXhpVHVybiA9IGVkZ2UucHN0eWxlKCd0YXhpLXR1cm4nKTtcbiAgICB2YXIgdHVybklzUGVyY2VudCA9IHRheGlUdXJuLnVuaXRzID09PSAnJSc7XG4gICAgdmFyIHRheGlUdXJuUGZWYWwgPSB0YXhpVHVybi5wZlZhbHVlO1xuICAgIHZhciB0dXJuSXNOZWdhdGl2ZSA9IHRheGlUdXJuUGZWYWwgPCAwOyAvLyBpLmUuIGZyb20gdGFyZ2V0IHNpZGVcblxuICAgIHZhciBtaW5EID0gZWRnZS5wc3R5bGUoJ3RheGktdHVybi1taW4tZGlzdGFuY2UnKS5wZlZhbHVlO1xuICAgIHZhciBkdyA9IGRJbmNsdWRlc05vZGVCb2R5ID8gKHNyY1cgKyB0Z3RXKSAvIDIgOiAwO1xuICAgIHZhciBkaCA9IGRJbmNsdWRlc05vZGVCb2R5ID8gKHNyY0ggKyB0Z3RIKSAvIDIgOiAwO1xuICAgIHZhciBwZHggPSBwb3NQdHMueDIgLSBwb3NQdHMueDE7XG4gICAgdmFyIHBkeSA9IHBvc1B0cy55MiAtIHBvc1B0cy55MTsgLy8gdGFrZSBhd2F5IHRoZSBlZmZlY3RpdmUgdy9oIGZyb20gdGhlIG1hZ25pdHVkZSBvZiB0aGUgZGVsdGEgdmFsdWVcblxuICAgIHZhciBzdWJEV0ggPSBmdW5jdGlvbiBzdWJEV0goZHh5LCBkd2gpIHtcbiAgICAgIGlmIChkeHkgPiAwKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heChkeHkgLSBkd2gsIDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKGR4eSArIGR3aCwgMCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBkeCA9IHN1YkRXSChwZHgsIGR3KTtcbiAgICB2YXIgZHkgPSBzdWJEV0gocGR5LCBkaCk7XG4gICAgdmFyIGlzRXhwbGljaXREaXIgPSBmYWxzZTtcblxuICAgIGlmIChyYXdUYXhpRGlyID09PSBBVVRPKSB7XG4gICAgICB0YXhpRGlyID0gTWF0aC5hYnMoZHgpID4gTWF0aC5hYnMoZHkpID8gSE9SSVpPTlRBTCA6IFZFUlRJQ0FMO1xuICAgIH0gZWxzZSBpZiAocmF3VGF4aURpciA9PT0gVVBXQVJEIHx8IHJhd1RheGlEaXIgPT09IERPV05XQVJEKSB7XG4gICAgICB0YXhpRGlyID0gVkVSVElDQUw7XG4gICAgICBpc0V4cGxpY2l0RGlyID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHJhd1RheGlEaXIgPT09IExFRlRXQVJEIHx8IHJhd1RheGlEaXIgPT09IFJJR0hUV0FSRCkge1xuICAgICAgdGF4aURpciA9IEhPUklaT05UQUw7XG4gICAgICBpc0V4cGxpY2l0RGlyID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgaXNWZXJ0ID0gdGF4aURpciA9PT0gVkVSVElDQUw7XG4gICAgdmFyIGwgPSBpc1ZlcnQgPyBkeSA6IGR4O1xuICAgIHZhciBwbCA9IGlzVmVydCA/IHBkeSA6IHBkeDtcbiAgICB2YXIgc2duTCA9IHNpZ251bShwbCk7XG4gICAgdmFyIGZvcmNlZERpciA9IGZhbHNlO1xuXG4gICAgaWYgKCEoaXNFeHBsaWNpdERpciAmJiAodHVybklzUGVyY2VudCB8fCB0dXJuSXNOZWdhdGl2ZSkpIC8vIGZvcmNpbmcgaW4gdGhpcyBjYXNlIHdvdWxkIGNhdXNlIHdlaXJkIGdyb3dpbmcgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvblxuICAgICYmIChyYXdUYXhpRGlyID09PSBET1dOV0FSRCAmJiBwbCA8IDAgfHwgcmF3VGF4aURpciA9PT0gVVBXQVJEICYmIHBsID4gMCB8fCByYXdUYXhpRGlyID09PSBMRUZUV0FSRCAmJiBwbCA+IDAgfHwgcmF3VGF4aURpciA9PT0gUklHSFRXQVJEICYmIHBsIDwgMCkpIHtcbiAgICAgIHNnbkwgKj0gLTE7XG4gICAgICBsID0gc2duTCAqIE1hdGguYWJzKGwpO1xuICAgICAgZm9yY2VkRGlyID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgZDtcblxuICAgIGlmICh0dXJuSXNQZXJjZW50KSB7XG4gICAgICB2YXIgcCA9IHRheGlUdXJuUGZWYWwgPCAwID8gMSArIHRheGlUdXJuUGZWYWwgOiB0YXhpVHVyblBmVmFsO1xuICAgICAgZCA9IHAgKiBsO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgayA9IHRheGlUdXJuUGZWYWwgPCAwID8gbCA6IDA7XG4gICAgICBkID0gayArIHRheGlUdXJuUGZWYWwgKiBzZ25MO1xuICAgIH1cblxuICAgIHZhciBnZXRJc1Rvb0Nsb3NlID0gZnVuY3Rpb24gZ2V0SXNUb29DbG9zZShkKSB7XG4gICAgICByZXR1cm4gTWF0aC5hYnMoZCkgPCBtaW5EIHx8IE1hdGguYWJzKGQpID49IE1hdGguYWJzKGwpO1xuICAgIH07XG5cbiAgICB2YXIgaXNUb29DbG9zZVNyYyA9IGdldElzVG9vQ2xvc2UoZCk7XG4gICAgdmFyIGlzVG9vQ2xvc2VUZ3QgPSBnZXRJc1Rvb0Nsb3NlKE1hdGguYWJzKGwpIC0gTWF0aC5hYnMoZCkpO1xuICAgIHZhciBpc1Rvb0Nsb3NlID0gaXNUb29DbG9zZVNyYyB8fCBpc1Rvb0Nsb3NlVGd0O1xuXG4gICAgaWYgKGlzVG9vQ2xvc2UgJiYgIWZvcmNlZERpcikge1xuICAgICAgLy8gbm9uLWlkZWFsIHJvdXRpbmdcbiAgICAgIGlmIChpc1ZlcnQpIHtcbiAgICAgICAgLy8gdmVydGljYWwgZmFsbGJhY2tzXG4gICAgICAgIHZhciBsU2hhcGVJbnNpZGVTcmMgPSBNYXRoLmFicyhwbCkgPD0gc3JjSCAvIDI7XG4gICAgICAgIHZhciBsU2hhcGVJbnNpZGVUZ3QgPSBNYXRoLmFicyhwZHgpIDw9IHRndFcgLyAyO1xuXG4gICAgICAgIGlmIChsU2hhcGVJbnNpZGVTcmMpIHtcbiAgICAgICAgICAvLyBob3Jpem9udGFsIFotc2hhcGUgKGRpcmVjdGlvbiBub3QgcmVzcGVjdGVkKVxuICAgICAgICAgIHZhciB4ID0gKHBvc1B0cy54MSArIHBvc1B0cy54MikgLyAyO1xuICAgICAgICAgIHZhciB5MSA9IHBvc1B0cy55MSxcbiAgICAgICAgICAgICAgeTIgPSBwb3NQdHMueTI7XG4gICAgICAgICAgcnMuc2VncHRzID0gW3gsIHkxLCB4LCB5Ml07XG4gICAgICAgIH0gZWxzZSBpZiAobFNoYXBlSW5zaWRlVGd0KSB7XG4gICAgICAgICAgLy8gdmVydGljYWwgWi1zaGFwZSAoZGlzdGFuY2Ugbm90IHJlc3BlY3RlZClcbiAgICAgICAgICB2YXIgeSA9IChwb3NQdHMueTEgKyBwb3NQdHMueTIpIC8gMjtcbiAgICAgICAgICB2YXIgeDEgPSBwb3NQdHMueDEsXG4gICAgICAgICAgICAgIHgyID0gcG9zUHRzLngyO1xuICAgICAgICAgIHJzLnNlZ3B0cyA9IFt4MSwgeSwgeDIsIHldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEwtc2hhcGUgZmFsbGJhY2sgKHR1cm4gZGlzdGFuY2Ugbm90IHJlc3BlY3RlZCwgYnV0IHdvcmtzIHdlbGwgd2l0aCB0cmVlIHNpYmxpbmdzKVxuICAgICAgICAgIHJzLnNlZ3B0cyA9IFtwb3NQdHMueDEsIHBvc1B0cy55Ml07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGhvcml6b250YWwgZmFsbGJhY2tzXG4gICAgICAgIHZhciBfbFNoYXBlSW5zaWRlU3JjID0gTWF0aC5hYnMocGwpIDw9IHNyY1cgLyAyO1xuXG4gICAgICAgIHZhciBfbFNoYXBlSW5zaWRlVGd0ID0gTWF0aC5hYnMocGR5KSA8PSB0Z3RIIC8gMjtcblxuICAgICAgICBpZiAoX2xTaGFwZUluc2lkZVNyYykge1xuICAgICAgICAgIC8vIHZlcnRpY2FsIFotc2hhcGUgKGRpcmVjdGlvbiBub3QgcmVzcGVjdGVkKVxuICAgICAgICAgIHZhciBfeSA9IChwb3NQdHMueTEgKyBwb3NQdHMueTIpIC8gMjtcblxuICAgICAgICAgIHZhciBfeCA9IHBvc1B0cy54MSxcbiAgICAgICAgICAgICAgX3gyID0gcG9zUHRzLngyO1xuICAgICAgICAgIHJzLnNlZ3B0cyA9IFtfeCwgX3ksIF94MiwgX3ldO1xuICAgICAgICB9IGVsc2UgaWYgKF9sU2hhcGVJbnNpZGVUZ3QpIHtcbiAgICAgICAgICAvLyBob3Jpem9udGFsIFotc2hhcGUgKHR1cm4gZGlzdGFuY2Ugbm90IHJlc3BlY3RlZClcbiAgICAgICAgICB2YXIgX3gzID0gKHBvc1B0cy54MSArIHBvc1B0cy54MikgLyAyO1xuXG4gICAgICAgICAgdmFyIF95MiA9IHBvc1B0cy55MSxcbiAgICAgICAgICAgICAgX3kzID0gcG9zUHRzLnkyO1xuICAgICAgICAgIHJzLnNlZ3B0cyA9IFtfeDMsIF95MiwgX3gzLCBfeTNdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEwtc2hhcGUgKHR1cm4gZGlzdGFuY2Ugbm90IHJlc3BlY3RlZCwgYnV0IHdvcmtzIHdlbGwgZm9yIHRyZWUgc2libGluZ3MpXG4gICAgICAgICAgcnMuc2VncHRzID0gW3Bvc1B0cy54MiwgcG9zUHRzLnkxXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZGVhbCByb3V0aW5nXG4gICAgICBpZiAoaXNWZXJ0KSB7XG4gICAgICAgIHZhciBfeTQgPSBwb3NQdHMueTEgKyBkICsgKGRJbmNsdWRlc05vZGVCb2R5ID8gc3JjSCAvIDIgKiBzZ25MIDogMCk7XG5cbiAgICAgICAgdmFyIF94NCA9IHBvc1B0cy54MSxcbiAgICAgICAgICAgIF94NSA9IHBvc1B0cy54MjtcbiAgICAgICAgcnMuc2VncHRzID0gW194NCwgX3k0LCBfeDUsIF95NF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBob3Jpem9udGFsXG4gICAgICAgIHZhciBfeDYgPSBwb3NQdHMueDEgKyBkICsgKGRJbmNsdWRlc05vZGVCb2R5ID8gc3JjVyAvIDIgKiBzZ25MIDogMCk7XG5cbiAgICAgICAgdmFyIF95NSA9IHBvc1B0cy55MSxcbiAgICAgICAgICAgIF95NiA9IHBvc1B0cy55MjtcbiAgICAgICAgcnMuc2VncHRzID0gW194NiwgX3k1LCBfeDYsIF95Nl07XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEJScCRjLnRyeVRvQ29ycmVjdEludmFsaWRQb2ludHMgPSBmdW5jdGlvbiAoZWRnZSwgcGFpckluZm8pIHtcbiAgICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoOyAvLyBjYW4gb25seSBjb3JyZWN0IGJlemllcnMgZm9yIG5vdy4uLlxuXG4gICAgaWYgKHJzLmVkZ2VUeXBlID09PSAnYmV6aWVyJykge1xuICAgICAgdmFyIHNyY1BvcyA9IHBhaXJJbmZvLnNyY1BvcyxcbiAgICAgICAgICB0Z3RQb3MgPSBwYWlySW5mby50Z3RQb3MsXG4gICAgICAgICAgc3JjVyA9IHBhaXJJbmZvLnNyY1csXG4gICAgICAgICAgc3JjSCA9IHBhaXJJbmZvLnNyY0gsXG4gICAgICAgICAgdGd0VyA9IHBhaXJJbmZvLnRndFcsXG4gICAgICAgICAgdGd0SCA9IHBhaXJJbmZvLnRndEgsXG4gICAgICAgICAgc3JjU2hhcGUgPSBwYWlySW5mby5zcmNTaGFwZSxcbiAgICAgICAgICB0Z3RTaGFwZSA9IHBhaXJJbmZvLnRndFNoYXBlO1xuICAgICAgdmFyIGJhZFN0YXJ0ID0gIW51bWJlciQxKHJzLnN0YXJ0WCkgfHwgIW51bWJlciQxKHJzLnN0YXJ0WSk7XG4gICAgICB2YXIgYmFkQVN0YXJ0ID0gIW51bWJlciQxKHJzLmFycm93U3RhcnRYKSB8fCAhbnVtYmVyJDEocnMuYXJyb3dTdGFydFkpO1xuICAgICAgdmFyIGJhZEVuZCA9ICFudW1iZXIkMShycy5lbmRYKSB8fCAhbnVtYmVyJDEocnMuZW5kWSk7XG4gICAgICB2YXIgYmFkQUVuZCA9ICFudW1iZXIkMShycy5hcnJvd0VuZFgpIHx8ICFudW1iZXIkMShycy5hcnJvd0VuZFkpO1xuICAgICAgdmFyIG1pbkNwQURpc3RGYWN0b3IgPSAzO1xuICAgICAgdmFyIGFycm93VyA9IHRoaXMuZ2V0QXJyb3dXaWR0aChlZGdlLnBzdHlsZSgnd2lkdGgnKS5wZlZhbHVlLCBlZGdlLnBzdHlsZSgnYXJyb3ctc2NhbGUnKS52YWx1ZSkgKiB0aGlzLmFycm93U2hhcGVXaWR0aDtcbiAgICAgIHZhciBtaW5DcEFEaXN0ID0gbWluQ3BBRGlzdEZhY3RvciAqIGFycm93VztcbiAgICAgIHZhciBzdGFydEFDcERpc3QgPSBkaXN0KHtcbiAgICAgICAgeDogcnMuY3RybHB0c1swXSxcbiAgICAgICAgeTogcnMuY3RybHB0c1sxXVxuICAgICAgfSwge1xuICAgICAgICB4OiBycy5zdGFydFgsXG4gICAgICAgIHk6IHJzLnN0YXJ0WVxuICAgICAgfSk7XG4gICAgICB2YXIgY2xvc2VTdGFydEFDcCA9IHN0YXJ0QUNwRGlzdCA8IG1pbkNwQURpc3Q7XG4gICAgICB2YXIgZW5kQUNwRGlzdCA9IGRpc3Qoe1xuICAgICAgICB4OiBycy5jdHJscHRzWzBdLFxuICAgICAgICB5OiBycy5jdHJscHRzWzFdXG4gICAgICB9LCB7XG4gICAgICAgIHg6IHJzLmVuZFgsXG4gICAgICAgIHk6IHJzLmVuZFlcbiAgICAgIH0pO1xuICAgICAgdmFyIGNsb3NlRW5kQUNwID0gZW5kQUNwRGlzdCA8IG1pbkNwQURpc3Q7XG4gICAgICB2YXIgb3ZlcmxhcHBpbmcgPSBmYWxzZTtcblxuICAgICAgaWYgKGJhZFN0YXJ0IHx8IGJhZEFTdGFydCB8fCBjbG9zZVN0YXJ0QUNwKSB7XG4gICAgICAgIG92ZXJsYXBwaW5nID0gdHJ1ZTsgLy8gcHJvamVjdCBjb250cm9sIHBvaW50IGFsb25nIGxpbmUgZnJvbSBzcmMgY2VudHJlIHRvIG91dHNpZGUgdGhlIHNyYyBzaGFwZVxuICAgICAgICAvLyAob3RoZXJ3aXNlIGludGVyc2VjdGlvbiB3aWxsIHlpZWxkIG5vdGhpbmcpXG5cbiAgICAgICAgdmFyIGNwRCA9IHtcbiAgICAgICAgICAvLyBkZWx0YVxuICAgICAgICAgIHg6IHJzLmN0cmxwdHNbMF0gLSBzcmNQb3MueCxcbiAgICAgICAgICB5OiBycy5jdHJscHRzWzFdIC0gc3JjUG9zLnlcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGNwTCA9IE1hdGguc3FydChjcEQueCAqIGNwRC54ICsgY3BELnkgKiBjcEQueSk7IC8vIGxlbmd0aCBvZiBsaW5lXG5cbiAgICAgICAgdmFyIGNwTSA9IHtcbiAgICAgICAgICAvLyBub3JtYWxpc2VkIGRlbHRhXG4gICAgICAgICAgeDogY3BELnggLyBjcEwsXG4gICAgICAgICAgeTogY3BELnkgLyBjcExcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHJhZGl1cyA9IE1hdGgubWF4KHNyY1csIHNyY0gpO1xuICAgICAgICB2YXIgY3BQcm9qID0ge1xuICAgICAgICAgIC8vICoyIHJhZGl1cyBndWFyYW50ZWVzIG91dHNpZGUgc2hhcGVcbiAgICAgICAgICB4OiBycy5jdHJscHRzWzBdICsgY3BNLnggKiAyICogcmFkaXVzLFxuICAgICAgICAgIHk6IHJzLmN0cmxwdHNbMV0gKyBjcE0ueSAqIDIgKiByYWRpdXNcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHNyY0N0cmxQdEludG4gPSBzcmNTaGFwZS5pbnRlcnNlY3RMaW5lKHNyY1Bvcy54LCBzcmNQb3MueSwgc3JjVywgc3JjSCwgY3BQcm9qLngsIGNwUHJvai55LCAwKTtcblxuICAgICAgICBpZiAoY2xvc2VTdGFydEFDcCkge1xuICAgICAgICAgIHJzLmN0cmxwdHNbMF0gPSBycy5jdHJscHRzWzBdICsgY3BNLnggKiAobWluQ3BBRGlzdCAtIHN0YXJ0QUNwRGlzdCk7XG4gICAgICAgICAgcnMuY3RybHB0c1sxXSA9IHJzLmN0cmxwdHNbMV0gKyBjcE0ueSAqIChtaW5DcEFEaXN0IC0gc3RhcnRBQ3BEaXN0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBycy5jdHJscHRzWzBdID0gc3JjQ3RybFB0SW50blswXSArIGNwTS54ICogbWluQ3BBRGlzdDtcbiAgICAgICAgICBycy5jdHJscHRzWzFdID0gc3JjQ3RybFB0SW50blsxXSArIGNwTS55ICogbWluQ3BBRGlzdDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYmFkRW5kIHx8IGJhZEFFbmQgfHwgY2xvc2VFbmRBQ3ApIHtcbiAgICAgICAgb3ZlcmxhcHBpbmcgPSB0cnVlOyAvLyBwcm9qZWN0IGNvbnRyb2wgcG9pbnQgYWxvbmcgbGluZSBmcm9tIHRndCBjZW50cmUgdG8gb3V0c2lkZSB0aGUgdGd0IHNoYXBlXG4gICAgICAgIC8vIChvdGhlcndpc2UgaW50ZXJzZWN0aW9uIHdpbGwgeWllbGQgbm90aGluZylcblxuICAgICAgICB2YXIgX2NwRCA9IHtcbiAgICAgICAgICAvLyBkZWx0YVxuICAgICAgICAgIHg6IHJzLmN0cmxwdHNbMF0gLSB0Z3RQb3MueCxcbiAgICAgICAgICB5OiBycy5jdHJscHRzWzFdIC0gdGd0UG9zLnlcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgX2NwTCA9IE1hdGguc3FydChfY3BELnggKiBfY3BELnggKyBfY3BELnkgKiBfY3BELnkpOyAvLyBsZW5ndGggb2YgbGluZVxuXG5cbiAgICAgICAgdmFyIF9jcE0gPSB7XG4gICAgICAgICAgLy8gbm9ybWFsaXNlZCBkZWx0YVxuICAgICAgICAgIHg6IF9jcEQueCAvIF9jcEwsXG4gICAgICAgICAgeTogX2NwRC55IC8gX2NwTFxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBfcmFkaXVzID0gTWF0aC5tYXgoc3JjVywgc3JjSCk7XG5cbiAgICAgICAgdmFyIF9jcFByb2ogPSB7XG4gICAgICAgICAgLy8gKjIgcmFkaXVzIGd1YXJhbnRlZXMgb3V0c2lkZSBzaGFwZVxuICAgICAgICAgIHg6IHJzLmN0cmxwdHNbMF0gKyBfY3BNLnggKiAyICogX3JhZGl1cyxcbiAgICAgICAgICB5OiBycy5jdHJscHRzWzFdICsgX2NwTS55ICogMiAqIF9yYWRpdXNcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHRndEN0cmxQdEludG4gPSB0Z3RTaGFwZS5pbnRlcnNlY3RMaW5lKHRndFBvcy54LCB0Z3RQb3MueSwgdGd0VywgdGd0SCwgX2NwUHJvai54LCBfY3BQcm9qLnksIDApO1xuXG4gICAgICAgIGlmIChjbG9zZUVuZEFDcCkge1xuICAgICAgICAgIHJzLmN0cmxwdHNbMF0gPSBycy5jdHJscHRzWzBdICsgX2NwTS54ICogKG1pbkNwQURpc3QgLSBlbmRBQ3BEaXN0KTtcbiAgICAgICAgICBycy5jdHJscHRzWzFdID0gcnMuY3RybHB0c1sxXSArIF9jcE0ueSAqIChtaW5DcEFEaXN0IC0gZW5kQUNwRGlzdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcnMuY3RybHB0c1swXSA9IHRndEN0cmxQdEludG5bMF0gKyBfY3BNLnggKiBtaW5DcEFEaXN0O1xuICAgICAgICAgIHJzLmN0cmxwdHNbMV0gPSB0Z3RDdHJsUHRJbnRuWzFdICsgX2NwTS55ICogbWluQ3BBRGlzdDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob3ZlcmxhcHBpbmcpIHtcbiAgICAgICAgLy8gcmVjYWxjIGVuZHB0c1xuICAgICAgICB0aGlzLmZpbmRFbmRwb2ludHMoZWRnZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEJScCRjLnN0b3JlQWxscHRzID0gZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuXG4gICAgaWYgKHJzLmVkZ2VUeXBlID09PSAnbXVsdGliZXppZXInIHx8IHJzLmVkZ2VUeXBlID09PSAnYmV6aWVyJyB8fCBycy5lZGdlVHlwZSA9PT0gJ3NlbGYnIHx8IHJzLmVkZ2VUeXBlID09PSAnY29tcG91bmQnKSB7XG4gICAgICBycy5hbGxwdHMgPSBbXTtcbiAgICAgIHJzLmFsbHB0cy5wdXNoKHJzLnN0YXJ0WCwgcnMuc3RhcnRZKTtcblxuICAgICAgZm9yICh2YXIgYiA9IDA7IGIgKyAxIDwgcnMuY3RybHB0cy5sZW5ndGg7IGIgKz0gMikge1xuICAgICAgICAvLyBjdHJsIHB0IGl0c2VsZlxuICAgICAgICBycy5hbGxwdHMucHVzaChycy5jdHJscHRzW2JdLCBycy5jdHJscHRzW2IgKyAxXSk7IC8vIHRoZSBtaWRwdCBiZXR3ZWVuIGN0cmxwdHMgYXMgaW50ZXJtZWRpYXRlIGRlc3RpbmF0aW9uIHB0c1xuXG4gICAgICAgIGlmIChiICsgMyA8IHJzLmN0cmxwdHMubGVuZ3RoKSB7XG4gICAgICAgICAgcnMuYWxscHRzLnB1c2goKHJzLmN0cmxwdHNbYl0gKyBycy5jdHJscHRzW2IgKyAyXSkgLyAyLCAocnMuY3RybHB0c1tiICsgMV0gKyBycy5jdHJscHRzW2IgKyAzXSkgLyAyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBycy5hbGxwdHMucHVzaChycy5lbmRYLCBycy5lbmRZKTtcbiAgICAgIHZhciBtLCBtdDtcblxuICAgICAgaWYgKHJzLmN0cmxwdHMubGVuZ3RoIC8gMiAlIDIgPT09IDApIHtcbiAgICAgICAgbSA9IHJzLmFsbHB0cy5sZW5ndGggLyAyIC0gMTtcbiAgICAgICAgcnMubWlkWCA9IHJzLmFsbHB0c1ttXTtcbiAgICAgICAgcnMubWlkWSA9IHJzLmFsbHB0c1ttICsgMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtID0gcnMuYWxscHRzLmxlbmd0aCAvIDIgLSAzO1xuICAgICAgICBtdCA9IDAuNTtcbiAgICAgICAgcnMubWlkWCA9IHFiZXppZXJBdChycy5hbGxwdHNbbV0sIHJzLmFsbHB0c1ttICsgMl0sIHJzLmFsbHB0c1ttICsgNF0sIG10KTtcbiAgICAgICAgcnMubWlkWSA9IHFiZXppZXJBdChycy5hbGxwdHNbbSArIDFdLCBycy5hbGxwdHNbbSArIDNdLCBycy5hbGxwdHNbbSArIDVdLCBtdCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChycy5lZGdlVHlwZSA9PT0gJ3N0cmFpZ2h0Jykge1xuICAgICAgLy8gbmVlZCB0byBjYWxjIHRoZXNlIGFmdGVyIGVuZHB0c1xuICAgICAgcnMuYWxscHRzID0gW3JzLnN0YXJ0WCwgcnMuc3RhcnRZLCBycy5lbmRYLCBycy5lbmRZXTsgLy8gZGVmYXVsdCBtaWRwdCBmb3IgbGFiZWxzIGV0Y1xuXG4gICAgICBycy5taWRYID0gKHJzLnN0YXJ0WCArIHJzLmVuZFggKyBycy5hcnJvd1N0YXJ0WCArIHJzLmFycm93RW5kWCkgLyA0O1xuICAgICAgcnMubWlkWSA9IChycy5zdGFydFkgKyBycy5lbmRZICsgcnMuYXJyb3dTdGFydFkgKyBycy5hcnJvd0VuZFkpIC8gNDtcbiAgICB9IGVsc2UgaWYgKHJzLmVkZ2VUeXBlID09PSAnc2VnbWVudHMnKSB7XG4gICAgICBycy5hbGxwdHMgPSBbXTtcbiAgICAgIHJzLmFsbHB0cy5wdXNoKHJzLnN0YXJ0WCwgcnMuc3RhcnRZKTtcbiAgICAgIHJzLmFsbHB0cy5wdXNoLmFwcGx5KHJzLmFsbHB0cywgcnMuc2VncHRzKTtcbiAgICAgIHJzLmFsbHB0cy5wdXNoKHJzLmVuZFgsIHJzLmVuZFkpO1xuXG4gICAgICBpZiAocnMuc2VncHRzLmxlbmd0aCAlIDQgPT09IDApIHtcbiAgICAgICAgdmFyIGkyID0gcnMuc2VncHRzLmxlbmd0aCAvIDI7XG4gICAgICAgIHZhciBpMSA9IGkyIC0gMjtcbiAgICAgICAgcnMubWlkWCA9IChycy5zZWdwdHNbaTFdICsgcnMuc2VncHRzW2kyXSkgLyAyO1xuICAgICAgICBycy5taWRZID0gKHJzLnNlZ3B0c1tpMSArIDFdICsgcnMuc2VncHRzW2kyICsgMV0pIC8gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfaSA9IHJzLnNlZ3B0cy5sZW5ndGggLyAyIC0gMTtcblxuICAgICAgICBycy5taWRYID0gcnMuc2VncHRzW19pXTtcbiAgICAgICAgcnMubWlkWSA9IHJzLnNlZ3B0c1tfaSArIDFdO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBCUnAkYy5jaGVja0ZvckludmFsaWRFZGdlV2FybmluZyA9IGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgdmFyIHJzID0gZWRnZVswXS5fcHJpdmF0ZS5yc2NyYXRjaDtcblxuICAgIGlmIChycy5ub2Rlc092ZXJsYXAgfHwgbnVtYmVyJDEocnMuc3RhcnRYKSAmJiBudW1iZXIkMShycy5zdGFydFkpICYmIG51bWJlciQxKHJzLmVuZFgpICYmIG51bWJlciQxKHJzLmVuZFkpKSB7XG4gICAgICBycy5sb2dnZWRFcnIgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFycy5sb2dnZWRFcnIpIHtcbiAgICAgICAgcnMubG9nZ2VkRXJyID0gdHJ1ZTtcbiAgICAgICAgd2FybignRWRnZSBgJyArIGVkZ2UuaWQoKSArICdgIGhhcyBpbnZhbGlkIGVuZHBvaW50cyBhbmQgc28gaXQgaXMgaW1wb3NzaWJsZSB0byBkcmF3LiAgQWRqdXN0IHlvdXIgZWRnZSBzdHlsZSAoZS5nLiBjb250cm9sIHBvaW50cykgYWNjb3JkaW5nbHkgb3IgdXNlIGFuIGFsdGVybmF0aXZlIGVkZ2UgdHlwZS4gIFRoaXMgaXMgZXhwZWN0ZWQgYmVoYXZpb3VyIHdoZW4gdGhlIHNvdXJjZSBub2RlIGFuZCB0aGUgdGFyZ2V0IG5vZGUgb3ZlcmxhcC4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgQlJwJGMuZmluZEVkZ2VDb250cm9sUG9pbnRzID0gZnVuY3Rpb24gKGVkZ2VzKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGlmICghZWRnZXMgfHwgZWRnZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHIgPSB0aGlzO1xuICAgIHZhciBjeSA9IHIuY3k7XG4gICAgdmFyIGhhc0NvbXBvdW5kcyA9IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcbiAgICB2YXIgaGFzaFRhYmxlID0ge1xuICAgICAgbWFwOiBuZXcgTWFwJDIoKSxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KHBhaXJJZCkge1xuICAgICAgICB2YXIgbWFwMiA9IHRoaXMubWFwLmdldChwYWlySWRbMF0pO1xuXG4gICAgICAgIGlmIChtYXAyICE9IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbWFwMi5nZXQocGFpcklkWzFdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHBhaXJJZCwgdmFsKSB7XG4gICAgICAgIHZhciBtYXAyID0gdGhpcy5tYXAuZ2V0KHBhaXJJZFswXSk7XG5cbiAgICAgICAgaWYgKG1hcDIgPT0gbnVsbCkge1xuICAgICAgICAgIG1hcDIgPSBuZXcgTWFwJDIoKTtcbiAgICAgICAgICB0aGlzLm1hcC5zZXQocGFpcklkWzBdLCBtYXAyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1hcDIuc2V0KHBhaXJJZFsxXSwgdmFsKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBwYWlySWRzID0gW107XG4gICAgdmFyIGhheXN0YWNrRWRnZXMgPSBbXTsgLy8gY3JlYXRlIGEgdGFibGUgb2YgZWRnZSAoc3JjLCB0Z3QpID0+IGxpc3Qgb2YgZWRnZXMgYmV0d2VlbiB0aGVtXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWRnZSA9IGVkZ2VzW2ldO1xuICAgICAgdmFyIF9wID0gZWRnZS5fcHJpdmF0ZTtcbiAgICAgIHZhciBjdXJ2ZVN0eWxlID0gZWRnZS5wc3R5bGUoJ2N1cnZlLXN0eWxlJykudmFsdWU7IC8vIGlnbm9yZSBlZGdlcyB3aG8gYXJlIG5vdCB0byBiZSBkaXNwbGF5ZWRcbiAgICAgIC8vIHRoZXkgc2hvdWxkbid0IHRha2UgdXAgc3BhY2VcblxuICAgICAgaWYgKGVkZ2UucmVtb3ZlZCgpIHx8ICFlZGdlLnRha2VzVXBTcGFjZSgpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoY3VydmVTdHlsZSA9PT0gJ2hheXN0YWNrJykge1xuICAgICAgICBoYXlzdGFja0VkZ2VzLnB1c2goZWRnZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWRnZUlzVW5idW5kbGVkID0gY3VydmVTdHlsZSA9PT0gJ3VuYnVuZGxlZC1iZXppZXInIHx8IGN1cnZlU3R5bGUgPT09ICdzZWdtZW50cycgfHwgY3VydmVTdHlsZSA9PT0gJ3N0cmFpZ2h0JyB8fCBjdXJ2ZVN0eWxlID09PSAnc3RyYWlnaHQtdHJpYW5nbGUnIHx8IGN1cnZlU3R5bGUgPT09ICd0YXhpJztcbiAgICAgIHZhciBlZGdlSXNCZXppZXIgPSBjdXJ2ZVN0eWxlID09PSAndW5idW5kbGVkLWJlemllcicgfHwgY3VydmVTdHlsZSA9PT0gJ2Jlemllcic7XG4gICAgICB2YXIgc3JjID0gX3Auc291cmNlO1xuICAgICAgdmFyIHRndCA9IF9wLnRhcmdldDtcbiAgICAgIHZhciBzcmNJbmRleCA9IHNyYy5wb29sSW5kZXgoKTtcbiAgICAgIHZhciB0Z3RJbmRleCA9IHRndC5wb29sSW5kZXgoKTtcbiAgICAgIHZhciBwYWlySWQgPSBbc3JjSW5kZXgsIHRndEluZGV4XS5zb3J0KCk7XG4gICAgICB2YXIgdGFibGVFbnRyeSA9IGhhc2hUYWJsZS5nZXQocGFpcklkKTtcblxuICAgICAgaWYgKHRhYmxlRW50cnkgPT0gbnVsbCkge1xuICAgICAgICB0YWJsZUVudHJ5ID0ge1xuICAgICAgICAgIGVsZXM6IFtdXG4gICAgICAgIH07XG4gICAgICAgIGhhc2hUYWJsZS5zZXQocGFpcklkLCB0YWJsZUVudHJ5KTtcbiAgICAgICAgcGFpcklkcy5wdXNoKHBhaXJJZCk7XG4gICAgICB9XG5cbiAgICAgIHRhYmxlRW50cnkuZWxlcy5wdXNoKGVkZ2UpO1xuXG4gICAgICBpZiAoZWRnZUlzVW5idW5kbGVkKSB7XG4gICAgICAgIHRhYmxlRW50cnkuaGFzVW5idW5kbGVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVkZ2VJc0Jlemllcikge1xuICAgICAgICB0YWJsZUVudHJ5Lmhhc0JlemllciA9IHRydWU7XG4gICAgICB9XG4gICAgfSAvLyBmb3IgZWFjaCBwYWlyIChzcmMsIHRndCksIGNyZWF0ZSB0aGUgY3RybCBwdHNcbiAgICAvLyBOZXN0ZWQgZm9yIGxvb3AgaXMgT0s7IHRvdGFsIG51bWJlciBvZiBpdGVyYXRpb25zIGZvciBib3RoIGxvb3BzID0gZWRnZUNvdW50XG5cblxuICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKHApIHtcbiAgICAgIHZhciBwYWlySWQgPSBwYWlySWRzW3BdO1xuICAgICAgdmFyIHBhaXJJbmZvID0gaGFzaFRhYmxlLmdldChwYWlySWQpO1xuICAgICAgdmFyIHN3YXBwZWRwYWlySW5mbyA9IHZvaWQgMDtcblxuICAgICAgaWYgKCFwYWlySW5mby5oYXNVbmJ1bmRsZWQpIHtcbiAgICAgICAgdmFyIHBsbEVkZ2VzID0gcGFpckluZm8uZWxlc1swXS5wYXJhbGxlbEVkZ2VzKCkuZmlsdGVyKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgcmV0dXJuIGUuaXNCdW5kbGVkQmV6aWVyKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBjbGVhckFycmF5KHBhaXJJbmZvLmVsZXMpO1xuICAgICAgICBwbGxFZGdlcy5mb3JFYWNoKGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgICAgcmV0dXJuIHBhaXJJbmZvLmVsZXMucHVzaChlZGdlKTtcbiAgICAgICAgfSk7IC8vIGZvciBlYWNoIHBhaXIgaWQsIHRoZSBlZGdlcyBzaG91bGQgYmUgc29ydGVkIGJ5IGluZGV4XG5cbiAgICAgICAgcGFpckluZm8uZWxlcy5zb3J0KGZ1bmN0aW9uIChlZGdlMSwgZWRnZTIpIHtcbiAgICAgICAgICByZXR1cm4gZWRnZTEucG9vbEluZGV4KCkgLSBlZGdlMi5wb29sSW5kZXgoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBmaXJzdEVkZ2UgPSBwYWlySW5mby5lbGVzWzBdO1xuICAgICAgdmFyIHNyYyA9IGZpcnN0RWRnZS5zb3VyY2UoKTtcbiAgICAgIHZhciB0Z3QgPSBmaXJzdEVkZ2UudGFyZ2V0KCk7IC8vIG1ha2Ugc3VyZSBzcmMvdGd0IGRpc3RpbmN0aW9uIGlzIGNvbnNpc3RlbnQgdy5yLnQuIHBhaXJJZFxuXG4gICAgICBpZiAoc3JjLnBvb2xJbmRleCgpID4gdGd0LnBvb2xJbmRleCgpKSB7XG4gICAgICAgIHZhciB0ZW1wID0gc3JjO1xuICAgICAgICBzcmMgPSB0Z3Q7XG4gICAgICAgIHRndCA9IHRlbXA7XG4gICAgICB9XG5cbiAgICAgIHZhciBzcmNQb3MgPSBwYWlySW5mby5zcmNQb3MgPSBzcmMucG9zaXRpb24oKTtcbiAgICAgIHZhciB0Z3RQb3MgPSBwYWlySW5mby50Z3RQb3MgPSB0Z3QucG9zaXRpb24oKTtcbiAgICAgIHZhciBzcmNXID0gcGFpckluZm8uc3JjVyA9IHNyYy5vdXRlcldpZHRoKCk7XG4gICAgICB2YXIgc3JjSCA9IHBhaXJJbmZvLnNyY0ggPSBzcmMub3V0ZXJIZWlnaHQoKTtcbiAgICAgIHZhciB0Z3RXID0gcGFpckluZm8udGd0VyA9IHRndC5vdXRlcldpZHRoKCk7XG4gICAgICB2YXIgdGd0SCA9IHBhaXJJbmZvLnRndEggPSB0Z3Qub3V0ZXJIZWlnaHQoKTtcblxuICAgICAgdmFyIHNyY1NoYXBlID0gcGFpckluZm8uc3JjU2hhcGUgPSByLm5vZGVTaGFwZXNbX3RoaXMuZ2V0Tm9kZVNoYXBlKHNyYyldO1xuXG4gICAgICB2YXIgdGd0U2hhcGUgPSBwYWlySW5mby50Z3RTaGFwZSA9IHIubm9kZVNoYXBlc1tfdGhpcy5nZXROb2RlU2hhcGUodGd0KV07XG5cbiAgICAgIHBhaXJJbmZvLmRpckNvdW50cyA9IHtcbiAgICAgICAgJ25vcnRoJzogMCxcbiAgICAgICAgJ3dlc3QnOiAwLFxuICAgICAgICAnc291dGgnOiAwLFxuICAgICAgICAnZWFzdCc6IDAsXG4gICAgICAgICdub3J0aHdlc3QnOiAwLFxuICAgICAgICAnc291dGh3ZXN0JzogMCxcbiAgICAgICAgJ25vcnRoZWFzdCc6IDAsXG4gICAgICAgICdzb3V0aGVhc3QnOiAwXG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBwYWlySW5mby5lbGVzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgdmFyIF9lZGdlID0gcGFpckluZm8uZWxlc1tfaTJdO1xuICAgICAgICB2YXIgcnMgPSBfZWRnZVswXS5fcHJpdmF0ZS5yc2NyYXRjaDtcblxuICAgICAgICB2YXIgX2N1cnZlU3R5bGUgPSBfZWRnZS5wc3R5bGUoJ2N1cnZlLXN0eWxlJykudmFsdWU7XG5cbiAgICAgICAgdmFyIF9lZGdlSXNVbmJ1bmRsZWQgPSBfY3VydmVTdHlsZSA9PT0gJ3VuYnVuZGxlZC1iZXppZXInIHx8IF9jdXJ2ZVN0eWxlID09PSAnc2VnbWVudHMnIHx8IF9jdXJ2ZVN0eWxlID09PSAndGF4aSc7IC8vIHdoZXRoZXIgdGhlIG5vcm1hbGlzZWQgcGFpciBvcmRlciBpcyB0aGUgcmV2ZXJzZSBvZiB0aGUgZWRnZSdzIHNyYy10Z3Qgb3JkZXJcblxuXG4gICAgICAgIHZhciBlZGdlSXNTd2FwcGVkID0gIXNyYy5zYW1lKF9lZGdlLnNvdXJjZSgpKTtcblxuICAgICAgICBpZiAoIXBhaXJJbmZvLmNhbGN1bGF0ZWRJbnRlcnNlY3Rpb24gJiYgc3JjICE9PSB0Z3QgJiYgKHBhaXJJbmZvLmhhc0JlemllciB8fCBwYWlySW5mby5oYXNVbmJ1bmRsZWQpKSB7XG4gICAgICAgICAgcGFpckluZm8uY2FsY3VsYXRlZEludGVyc2VjdGlvbiA9IHRydWU7IC8vIHB0IG91dHNpZGUgc3JjIHNoYXBlIHRvIGNhbGMgZGlzdGFuY2UvZGlzcGxhY2VtZW50IGZyb20gc3JjIHRvIHRndFxuXG4gICAgICAgICAgdmFyIHNyY091dHNpZGUgPSBzcmNTaGFwZS5pbnRlcnNlY3RMaW5lKHNyY1Bvcy54LCBzcmNQb3MueSwgc3JjVywgc3JjSCwgdGd0UG9zLngsIHRndFBvcy55LCAwKTtcbiAgICAgICAgICB2YXIgc3JjSW50biA9IHBhaXJJbmZvLnNyY0ludG4gPSBzcmNPdXRzaWRlOyAvLyBwdCBvdXRzaWRlIHRndCBzaGFwZSB0byBjYWxjIGRpc3RhbmNlL2Rpc3BsYWNlbWVudCBmcm9tIHNyYyB0byB0Z3RcblxuICAgICAgICAgIHZhciB0Z3RPdXRzaWRlID0gdGd0U2hhcGUuaW50ZXJzZWN0TGluZSh0Z3RQb3MueCwgdGd0UG9zLnksIHRndFcsIHRndEgsIHNyY1Bvcy54LCBzcmNQb3MueSwgMCk7XG4gICAgICAgICAgdmFyIHRndEludG4gPSBwYWlySW5mby50Z3RJbnRuID0gdGd0T3V0c2lkZTtcbiAgICAgICAgICB2YXIgaW50ZXJzZWN0aW9uUHRzID0gcGFpckluZm8uaW50ZXJzZWN0aW9uUHRzID0ge1xuICAgICAgICAgICAgeDE6IHNyY091dHNpZGVbMF0sXG4gICAgICAgICAgICB4MjogdGd0T3V0c2lkZVswXSxcbiAgICAgICAgICAgIHkxOiBzcmNPdXRzaWRlWzFdLFxuICAgICAgICAgICAgeTI6IHRndE91dHNpZGVbMV1cbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciBwb3NQdHMgPSBwYWlySW5mby5wb3NQdHMgPSB7XG4gICAgICAgICAgICB4MTogc3JjUG9zLngsXG4gICAgICAgICAgICB4MjogdGd0UG9zLngsXG4gICAgICAgICAgICB5MTogc3JjUG9zLnksXG4gICAgICAgICAgICB5MjogdGd0UG9zLnlcbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciBkeSA9IHRndE91dHNpZGVbMV0gLSBzcmNPdXRzaWRlWzFdO1xuICAgICAgICAgIHZhciBkeCA9IHRndE91dHNpZGVbMF0gLSBzcmNPdXRzaWRlWzBdO1xuICAgICAgICAgIHZhciBsID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgICAgICB2YXIgdmVjdG9yID0gcGFpckluZm8udmVjdG9yID0ge1xuICAgICAgICAgICAgeDogZHgsXG4gICAgICAgICAgICB5OiBkeVxuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIHZlY3Rvck5vcm0gPSBwYWlySW5mby52ZWN0b3JOb3JtID0ge1xuICAgICAgICAgICAgeDogdmVjdG9yLnggLyBsLFxuICAgICAgICAgICAgeTogdmVjdG9yLnkgLyBsXG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgdmVjdG9yTm9ybUludmVyc2UgPSB7XG4gICAgICAgICAgICB4OiAtdmVjdG9yTm9ybS55LFxuICAgICAgICAgICAgeTogdmVjdG9yTm9ybS54XG4gICAgICAgICAgfTsgLy8gaWYgbm9kZSBzaGFwZXMgb3ZlcmxhcCwgdGhlbiBubyBjdHJsIHB0cyB0byBkcmF3XG5cbiAgICAgICAgICBwYWlySW5mby5ub2Rlc092ZXJsYXAgPSAhbnVtYmVyJDEobCkgfHwgdGd0U2hhcGUuY2hlY2tQb2ludChzcmNPdXRzaWRlWzBdLCBzcmNPdXRzaWRlWzFdLCAwLCB0Z3RXLCB0Z3RILCB0Z3RQb3MueCwgdGd0UG9zLnkpIHx8IHNyY1NoYXBlLmNoZWNrUG9pbnQodGd0T3V0c2lkZVswXSwgdGd0T3V0c2lkZVsxXSwgMCwgc3JjVywgc3JjSCwgc3JjUG9zLngsIHNyY1Bvcy55KTtcbiAgICAgICAgICBwYWlySW5mby52ZWN0b3JOb3JtSW52ZXJzZSA9IHZlY3Rvck5vcm1JbnZlcnNlO1xuICAgICAgICAgIHN3YXBwZWRwYWlySW5mbyA9IHtcbiAgICAgICAgICAgIG5vZGVzT3ZlcmxhcDogcGFpckluZm8ubm9kZXNPdmVybGFwLFxuICAgICAgICAgICAgZGlyQ291bnRzOiBwYWlySW5mby5kaXJDb3VudHMsXG4gICAgICAgICAgICBjYWxjdWxhdGVkSW50ZXJzZWN0aW9uOiB0cnVlLFxuICAgICAgICAgICAgaGFzQmV6aWVyOiBwYWlySW5mby5oYXNCZXppZXIsXG4gICAgICAgICAgICBoYXNVbmJ1bmRsZWQ6IHBhaXJJbmZvLmhhc1VuYnVuZGxlZCxcbiAgICAgICAgICAgIGVsZXM6IHBhaXJJbmZvLmVsZXMsXG4gICAgICAgICAgICBzcmNQb3M6IHRndFBvcyxcbiAgICAgICAgICAgIHRndFBvczogc3JjUG9zLFxuICAgICAgICAgICAgc3JjVzogdGd0VyxcbiAgICAgICAgICAgIHNyY0g6IHRndEgsXG4gICAgICAgICAgICB0Z3RXOiBzcmNXLFxuICAgICAgICAgICAgdGd0SDogc3JjSCxcbiAgICAgICAgICAgIHNyY0ludG46IHRndEludG4sXG4gICAgICAgICAgICB0Z3RJbnRuOiBzcmNJbnRuLFxuICAgICAgICAgICAgc3JjU2hhcGU6IHRndFNoYXBlLFxuICAgICAgICAgICAgdGd0U2hhcGU6IHNyY1NoYXBlLFxuICAgICAgICAgICAgcG9zUHRzOiB7XG4gICAgICAgICAgICAgIHgxOiBwb3NQdHMueDIsXG4gICAgICAgICAgICAgIHkxOiBwb3NQdHMueTIsXG4gICAgICAgICAgICAgIHgyOiBwb3NQdHMueDEsXG4gICAgICAgICAgICAgIHkyOiBwb3NQdHMueTFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbnRlcnNlY3Rpb25QdHM6IHtcbiAgICAgICAgICAgICAgeDE6IGludGVyc2VjdGlvblB0cy54MixcbiAgICAgICAgICAgICAgeTE6IGludGVyc2VjdGlvblB0cy55MixcbiAgICAgICAgICAgICAgeDI6IGludGVyc2VjdGlvblB0cy54MSxcbiAgICAgICAgICAgICAgeTI6IGludGVyc2VjdGlvblB0cy55MVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZlY3Rvcjoge1xuICAgICAgICAgICAgICB4OiAtdmVjdG9yLngsXG4gICAgICAgICAgICAgIHk6IC12ZWN0b3IueVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZlY3Rvck5vcm06IHtcbiAgICAgICAgICAgICAgeDogLXZlY3Rvck5vcm0ueCxcbiAgICAgICAgICAgICAgeTogLXZlY3Rvck5vcm0ueVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZlY3Rvck5vcm1JbnZlcnNlOiB7XG4gICAgICAgICAgICAgIHg6IC12ZWN0b3JOb3JtSW52ZXJzZS54LFxuICAgICAgICAgICAgICB5OiAtdmVjdG9yTm9ybUludmVyc2UueVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGFzc2VkUGFpckluZm8gPSBlZGdlSXNTd2FwcGVkID8gc3dhcHBlZHBhaXJJbmZvIDogcGFpckluZm87XG4gICAgICAgIHJzLm5vZGVzT3ZlcmxhcCA9IHBhc3NlZFBhaXJJbmZvLm5vZGVzT3ZlcmxhcDtcbiAgICAgICAgcnMuc3JjSW50biA9IHBhc3NlZFBhaXJJbmZvLnNyY0ludG47XG4gICAgICAgIHJzLnRndEludG4gPSBwYXNzZWRQYWlySW5mby50Z3RJbnRuO1xuXG4gICAgICAgIGlmIChoYXNDb21wb3VuZHMgJiYgKHNyYy5pc1BhcmVudCgpIHx8IHNyYy5pc0NoaWxkKCkgfHwgdGd0LmlzUGFyZW50KCkgfHwgdGd0LmlzQ2hpbGQoKSkgJiYgKHNyYy5wYXJlbnRzKCkuYW55U2FtZSh0Z3QpIHx8IHRndC5wYXJlbnRzKCkuYW55U2FtZShzcmMpIHx8IHNyYy5zYW1lKHRndCkgJiYgc3JjLmlzUGFyZW50KCkpKSB7XG4gICAgICAgICAgX3RoaXMuZmluZENvbXBvdW5kTG9vcFBvaW50cyhfZWRnZSwgcGFzc2VkUGFpckluZm8sIF9pMiwgX2VkZ2VJc1VuYnVuZGxlZCk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3JjID09PSB0Z3QpIHtcbiAgICAgICAgICBfdGhpcy5maW5kTG9vcFBvaW50cyhfZWRnZSwgcGFzc2VkUGFpckluZm8sIF9pMiwgX2VkZ2VJc1VuYnVuZGxlZCk7XG4gICAgICAgIH0gZWxzZSBpZiAoX2N1cnZlU3R5bGUgPT09ICdzZWdtZW50cycpIHtcbiAgICAgICAgICBfdGhpcy5maW5kU2VnbWVudHNQb2ludHMoX2VkZ2UsIHBhc3NlZFBhaXJJbmZvKTtcbiAgICAgICAgfSBlbHNlIGlmIChfY3VydmVTdHlsZSA9PT0gJ3RheGknKSB7XG4gICAgICAgICAgX3RoaXMuZmluZFRheGlQb2ludHMoX2VkZ2UsIHBhc3NlZFBhaXJJbmZvKTtcbiAgICAgICAgfSBlbHNlIGlmIChfY3VydmVTdHlsZSA9PT0gJ3N0cmFpZ2h0JyB8fCAhX2VkZ2VJc1VuYnVuZGxlZCAmJiBwYWlySW5mby5lbGVzLmxlbmd0aCAlIDIgPT09IDEgJiYgX2kyID09PSBNYXRoLmZsb29yKHBhaXJJbmZvLmVsZXMubGVuZ3RoIC8gMikpIHtcbiAgICAgICAgICBfdGhpcy5maW5kU3RyYWlnaHRFZGdlUG9pbnRzKF9lZGdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpcy5maW5kQmV6aWVyUG9pbnRzKF9lZGdlLCBwYXNzZWRQYWlySW5mbywgX2kyLCBfZWRnZUlzVW5idW5kbGVkLCBlZGdlSXNTd2FwcGVkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzLmZpbmRFbmRwb2ludHMoX2VkZ2UpO1xuXG4gICAgICAgIF90aGlzLnRyeVRvQ29ycmVjdEludmFsaWRQb2ludHMoX2VkZ2UsIHBhc3NlZFBhaXJJbmZvKTtcblxuICAgICAgICBfdGhpcy5jaGVja0ZvckludmFsaWRFZGdlV2FybmluZyhfZWRnZSk7XG5cbiAgICAgICAgX3RoaXMuc3RvcmVBbGxwdHMoX2VkZ2UpO1xuXG4gICAgICAgIF90aGlzLnN0b3JlRWRnZVByb2plY3Rpb25zKF9lZGdlKTtcblxuICAgICAgICBfdGhpcy5jYWxjdWxhdGVBcnJvd0FuZ2xlcyhfZWRnZSk7XG5cbiAgICAgICAgX3RoaXMucmVjYWxjdWxhdGVFZGdlTGFiZWxQcm9qZWN0aW9ucyhfZWRnZSk7XG5cbiAgICAgICAgX3RoaXMuY2FsY3VsYXRlTGFiZWxBbmdsZXMoX2VkZ2UpO1xuICAgICAgfSAvLyBmb3IgcGFpciBlZGdlc1xuXG4gICAgfTtcblxuICAgIGZvciAodmFyIHAgPSAwOyBwIDwgcGFpcklkcy5sZW5ndGg7IHArKykge1xuICAgICAgX2xvb3AocCk7XG4gICAgfSAvLyBmb3IgcGFpciBpZHNcbiAgICAvLyBoYXlzdGFja3MgYXZvaWQgdGhlIGV4cGVuc2Ugb2YgcGFpckluZm8gc3R1ZmYgKGludGVyc2VjdGlvbnMgZXRjLilcblxuXG4gICAgdGhpcy5maW5kSGF5c3RhY2tQb2ludHMoaGF5c3RhY2tFZGdlcyk7XG4gIH07XG5cbiAgZnVuY3Rpb24gZ2V0UHRzKHB0cykge1xuICAgIHZhciByZXRQdHMgPSBbXTtcblxuICAgIGlmIChwdHMgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHRzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICB2YXIgeCA9IHB0c1tpXTtcbiAgICAgIHZhciB5ID0gcHRzW2kgKyAxXTtcbiAgICAgIHJldFB0cy5wdXNoKHtcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldFB0cztcbiAgfVxuXG4gIEJScCRjLmdldFNlZ21lbnRQb2ludHMgPSBmdW5jdGlvbiAoZWRnZSkge1xuICAgIHZhciBycyA9IGVkZ2VbMF0uX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgdmFyIHR5cGUgPSBycy5lZGdlVHlwZTtcblxuICAgIGlmICh0eXBlID09PSAnc2VnbWVudHMnKSB7XG4gICAgICB0aGlzLnJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZShlZGdlKTtcbiAgICAgIHJldHVybiBnZXRQdHMocnMuc2VncHRzKTtcbiAgICB9XG4gIH07XG5cbiAgQlJwJGMuZ2V0Q29udHJvbFBvaW50cyA9IGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgdmFyIHJzID0gZWRnZVswXS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICB2YXIgdHlwZSA9IHJzLmVkZ2VUeXBlO1xuXG4gICAgaWYgKHR5cGUgPT09ICdiZXppZXInIHx8IHR5cGUgPT09ICdtdWx0aWJlemllcicgfHwgdHlwZSA9PT0gJ3NlbGYnIHx8IHR5cGUgPT09ICdjb21wb3VuZCcpIHtcbiAgICAgIHRoaXMucmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlKGVkZ2UpO1xuICAgICAgcmV0dXJuIGdldFB0cyhycy5jdHJscHRzKTtcbiAgICB9XG4gIH07XG5cbiAgQlJwJGMuZ2V0RWRnZU1pZHBvaW50ID0gZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICB2YXIgcnMgPSBlZGdlWzBdLl9wcml2YXRlLnJzY3JhdGNoO1xuICAgIHRoaXMucmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlKGVkZ2UpO1xuICAgIHJldHVybiB7XG4gICAgICB4OiBycy5taWRYLFxuICAgICAgeTogcnMubWlkWVxuICAgIH07XG4gIH07XG5cbiAgdmFyIEJScCRiID0ge307XG5cbiAgQlJwJGIubWFudWFsRW5kcHRUb1B4ID0gZnVuY3Rpb24gKG5vZGUsIHByb3ApIHtcbiAgICB2YXIgciA9IHRoaXM7XG4gICAgdmFyIG5wb3MgPSBub2RlLnBvc2l0aW9uKCk7XG4gICAgdmFyIHcgPSBub2RlLm91dGVyV2lkdGgoKTtcbiAgICB2YXIgaCA9IG5vZGUub3V0ZXJIZWlnaHQoKTtcblxuICAgIGlmIChwcm9wLnZhbHVlLmxlbmd0aCA9PT0gMikge1xuICAgICAgdmFyIHAgPSBbcHJvcC5wZlZhbHVlWzBdLCBwcm9wLnBmVmFsdWVbMV1dO1xuXG4gICAgICBpZiAocHJvcC51bml0c1swXSA9PT0gJyUnKSB7XG4gICAgICAgIHBbMF0gPSBwWzBdICogdztcbiAgICAgIH1cblxuICAgICAgaWYgKHByb3AudW5pdHNbMV0gPT09ICclJykge1xuICAgICAgICBwWzFdID0gcFsxXSAqIGg7XG4gICAgICB9XG5cbiAgICAgIHBbMF0gKz0gbnBvcy54O1xuICAgICAgcFsxXSArPSBucG9zLnk7XG4gICAgICByZXR1cm4gcDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFuZ2xlID0gcHJvcC5wZlZhbHVlWzBdO1xuICAgICAgYW5nbGUgPSAtTWF0aC5QSSAvIDIgKyBhbmdsZTsgLy8gc3RhcnQgYXQgMTIgbydjbG9ja1xuXG4gICAgICB2YXIgbCA9IDIgKiBNYXRoLm1heCh3LCBoKTtcbiAgICAgIHZhciBfcCA9IFtucG9zLnggKyBNYXRoLmNvcyhhbmdsZSkgKiBsLCBucG9zLnkgKyBNYXRoLnNpbihhbmdsZSkgKiBsXTtcbiAgICAgIHJldHVybiByLm5vZGVTaGFwZXNbdGhpcy5nZXROb2RlU2hhcGUobm9kZSldLmludGVyc2VjdExpbmUobnBvcy54LCBucG9zLnksIHcsIGgsIF9wWzBdLCBfcFsxXSwgMCk7XG4gICAgfVxuICB9O1xuXG4gIEJScCRiLmZpbmRFbmRwb2ludHMgPSBmdW5jdGlvbiAoZWRnZSkge1xuICAgIHZhciByID0gdGhpcztcbiAgICB2YXIgaW50ZXJzZWN0O1xuICAgIHZhciBzb3VyY2UgPSBlZGdlLnNvdXJjZSgpWzBdO1xuICAgIHZhciB0YXJnZXQgPSBlZGdlLnRhcmdldCgpWzBdO1xuICAgIHZhciBzcmNQb3MgPSBzb3VyY2UucG9zaXRpb24oKTtcbiAgICB2YXIgdGd0UG9zID0gdGFyZ2V0LnBvc2l0aW9uKCk7XG4gICAgdmFyIHRndEFyU2hhcGUgPSBlZGdlLnBzdHlsZSgndGFyZ2V0LWFycm93LXNoYXBlJykudmFsdWU7XG4gICAgdmFyIHNyY0FyU2hhcGUgPSBlZGdlLnBzdHlsZSgnc291cmNlLWFycm93LXNoYXBlJykudmFsdWU7XG4gICAgdmFyIHRndERpc3QgPSBlZGdlLnBzdHlsZSgndGFyZ2V0LWRpc3RhbmNlLWZyb20tbm9kZScpLnBmVmFsdWU7XG4gICAgdmFyIHNyY0Rpc3QgPSBlZGdlLnBzdHlsZSgnc291cmNlLWRpc3RhbmNlLWZyb20tbm9kZScpLnBmVmFsdWU7XG4gICAgdmFyIGN1cnZlU3R5bGUgPSBlZGdlLnBzdHlsZSgnY3VydmUtc3R5bGUnKS52YWx1ZTtcbiAgICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICAgIHZhciBldCA9IHJzLmVkZ2VUeXBlO1xuICAgIHZhciB0YXhpID0gY3VydmVTdHlsZSA9PT0gJ3RheGknO1xuICAgIHZhciBzZWxmID0gZXQgPT09ICdzZWxmJyB8fCBldCA9PT0gJ2NvbXBvdW5kJztcbiAgICB2YXIgYmV6aWVyID0gZXQgPT09ICdiZXppZXInIHx8IGV0ID09PSAnbXVsdGliZXppZXInIHx8IHNlbGY7XG4gICAgdmFyIG11bHRpID0gZXQgIT09ICdiZXppZXInO1xuICAgIHZhciBsaW5lcyA9IGV0ID09PSAnc3RyYWlnaHQnIHx8IGV0ID09PSAnc2VnbWVudHMnO1xuICAgIHZhciBzZWdtZW50cyA9IGV0ID09PSAnc2VnbWVudHMnO1xuICAgIHZhciBoYXNFbmRwdHMgPSBiZXppZXIgfHwgbXVsdGkgfHwgbGluZXM7XG4gICAgdmFyIG92ZXJyaWRlRW5kcHRzID0gc2VsZiB8fCB0YXhpO1xuICAgIHZhciBzcmNNYW5FbmRwdCA9IGVkZ2UucHN0eWxlKCdzb3VyY2UtZW5kcG9pbnQnKTtcbiAgICB2YXIgc3JjTWFuRW5kcHRWYWwgPSBvdmVycmlkZUVuZHB0cyA/ICdvdXRzaWRlLXRvLW5vZGUnIDogc3JjTWFuRW5kcHQudmFsdWU7XG4gICAgdmFyIHRndE1hbkVuZHB0ID0gZWRnZS5wc3R5bGUoJ3RhcmdldC1lbmRwb2ludCcpO1xuICAgIHZhciB0Z3RNYW5FbmRwdFZhbCA9IG92ZXJyaWRlRW5kcHRzID8gJ291dHNpZGUtdG8tbm9kZScgOiB0Z3RNYW5FbmRwdC52YWx1ZTtcbiAgICBycy5zcmNNYW5FbmRwdCA9IHNyY01hbkVuZHB0O1xuICAgIHJzLnRndE1hbkVuZHB0ID0gdGd0TWFuRW5kcHQ7XG4gICAgdmFyIHAxOyAvLyBsYXN0IGtub3duIHBvaW50IG9mIGVkZ2Ugb24gdGFyZ2V0IHNpZGVcblxuICAgIHZhciBwMjsgLy8gbGFzdCBrbm93biBwb2ludCBvZiBlZGdlIG9uIHNvdXJjZSBzaWRlXG5cbiAgICB2YXIgcDFfaTsgLy8gcG9pbnQgdG8gaW50ZXJzZWN0IHdpdGggdGFyZ2V0IHNoYXBlXG5cbiAgICB2YXIgcDJfaTsgLy8gcG9pbnQgdG8gaW50ZXJzZWN0IHdpdGggc291cmNlIHNoYXBlXG5cbiAgICBpZiAoYmV6aWVyKSB7XG4gICAgICB2YXIgY3BTdGFydCA9IFtycy5jdHJscHRzWzBdLCBycy5jdHJscHRzWzFdXTtcbiAgICAgIHZhciBjcEVuZCA9IG11bHRpID8gW3JzLmN0cmxwdHNbcnMuY3RybHB0cy5sZW5ndGggLSAyXSwgcnMuY3RybHB0c1tycy5jdHJscHRzLmxlbmd0aCAtIDFdXSA6IGNwU3RhcnQ7XG4gICAgICBwMSA9IGNwRW5kO1xuICAgICAgcDIgPSBjcFN0YXJ0O1xuICAgIH0gZWxzZSBpZiAobGluZXMpIHtcbiAgICAgIHZhciBzcmNBcnJvd0Zyb21QdCA9ICFzZWdtZW50cyA/IFt0Z3RQb3MueCwgdGd0UG9zLnldIDogcnMuc2VncHRzLnNsaWNlKDAsIDIpO1xuICAgICAgdmFyIHRndEFycm93RnJvbVB0ID0gIXNlZ21lbnRzID8gW3NyY1Bvcy54LCBzcmNQb3MueV0gOiBycy5zZWdwdHMuc2xpY2UocnMuc2VncHRzLmxlbmd0aCAtIDIpO1xuICAgICAgcDEgPSB0Z3RBcnJvd0Zyb21QdDtcbiAgICAgIHAyID0gc3JjQXJyb3dGcm9tUHQ7XG4gICAgfVxuXG4gICAgaWYgKHRndE1hbkVuZHB0VmFsID09PSAnaW5zaWRlLXRvLW5vZGUnKSB7XG4gICAgICBpbnRlcnNlY3QgPSBbdGd0UG9zLngsIHRndFBvcy55XTtcbiAgICB9IGVsc2UgaWYgKHRndE1hbkVuZHB0LnVuaXRzKSB7XG4gICAgICBpbnRlcnNlY3QgPSB0aGlzLm1hbnVhbEVuZHB0VG9QeCh0YXJnZXQsIHRndE1hbkVuZHB0KTtcbiAgICB9IGVsc2UgaWYgKHRndE1hbkVuZHB0VmFsID09PSAnb3V0c2lkZS10by1saW5lJykge1xuICAgICAgaW50ZXJzZWN0ID0gcnMudGd0SW50bjsgLy8gdXNlIGNhY2hlZCB2YWx1ZSBmcm9tIGN0cmxwdCBjYWxjXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0Z3RNYW5FbmRwdFZhbCA9PT0gJ291dHNpZGUtdG8tbm9kZScgfHwgdGd0TWFuRW5kcHRWYWwgPT09ICdvdXRzaWRlLXRvLW5vZGUtb3ItbGFiZWwnKSB7XG4gICAgICAgIHAxX2kgPSBwMTtcbiAgICAgIH0gZWxzZSBpZiAodGd0TWFuRW5kcHRWYWwgPT09ICdvdXRzaWRlLXRvLWxpbmUnIHx8IHRndE1hbkVuZHB0VmFsID09PSAnb3V0c2lkZS10by1saW5lLW9yLWxhYmVsJykge1xuICAgICAgICBwMV9pID0gW3NyY1Bvcy54LCBzcmNQb3MueV07XG4gICAgICB9XG5cbiAgICAgIGludGVyc2VjdCA9IHIubm9kZVNoYXBlc1t0aGlzLmdldE5vZGVTaGFwZSh0YXJnZXQpXS5pbnRlcnNlY3RMaW5lKHRndFBvcy54LCB0Z3RQb3MueSwgdGFyZ2V0Lm91dGVyV2lkdGgoKSwgdGFyZ2V0Lm91dGVySGVpZ2h0KCksIHAxX2lbMF0sIHAxX2lbMV0sIDApO1xuXG4gICAgICBpZiAodGd0TWFuRW5kcHRWYWwgPT09ICdvdXRzaWRlLXRvLW5vZGUtb3ItbGFiZWwnIHx8IHRndE1hbkVuZHB0VmFsID09PSAnb3V0c2lkZS10by1saW5lLW9yLWxhYmVsJykge1xuICAgICAgICB2YXIgdHJzID0gdGFyZ2V0Ll9wcml2YXRlLnJzY3JhdGNoO1xuICAgICAgICB2YXIgbHcgPSB0cnMubGFiZWxXaWR0aDtcbiAgICAgICAgdmFyIGxoID0gdHJzLmxhYmVsSGVpZ2h0O1xuICAgICAgICB2YXIgbHggPSB0cnMubGFiZWxYO1xuICAgICAgICB2YXIgbHkgPSB0cnMubGFiZWxZO1xuICAgICAgICB2YXIgbHcyID0gbHcgLyAyO1xuICAgICAgICB2YXIgbGgyID0gbGggLyAyO1xuICAgICAgICB2YXIgdmEgPSB0YXJnZXQucHN0eWxlKCd0ZXh0LXZhbGlnbicpLnZhbHVlO1xuXG4gICAgICAgIGlmICh2YSA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICBseSAtPSBsaDI7XG4gICAgICAgIH0gZWxzZSBpZiAodmEgPT09ICdib3R0b20nKSB7XG4gICAgICAgICAgbHkgKz0gbGgyO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGhhID0gdGFyZ2V0LnBzdHlsZSgndGV4dC1oYWxpZ24nKS52YWx1ZTtcblxuICAgICAgICBpZiAoaGEgPT09ICdsZWZ0Jykge1xuICAgICAgICAgIGx4IC09IGx3MjtcbiAgICAgICAgfSBlbHNlIGlmIChoYSA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgIGx4ICs9IGx3MjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsYWJlbEludGVyc2VjdCA9IHBvbHlnb25JbnRlcnNlY3RMaW5lKHAxX2lbMF0sIHAxX2lbMV0sIFtseCAtIGx3MiwgbHkgLSBsaDIsIGx4ICsgbHcyLCBseSAtIGxoMiwgbHggKyBsdzIsIGx5ICsgbGgyLCBseCAtIGx3MiwgbHkgKyBsaDJdLCB0Z3RQb3MueCwgdGd0UG9zLnkpO1xuXG4gICAgICAgIGlmIChsYWJlbEludGVyc2VjdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIHJlZlB0ID0gc3JjUG9zO1xuICAgICAgICAgIHZhciBpbnRTcWRpc3QgPSBzcWRpc3QocmVmUHQsIGFycmF5MnBvaW50KGludGVyc2VjdCkpO1xuICAgICAgICAgIHZhciBsYWJJbnRTcWRpc3QgPSBzcWRpc3QocmVmUHQsIGFycmF5MnBvaW50KGxhYmVsSW50ZXJzZWN0KSk7XG4gICAgICAgICAgdmFyIG1pblNxRGlzdCA9IGludFNxZGlzdDtcblxuICAgICAgICAgIGlmIChsYWJJbnRTcWRpc3QgPCBpbnRTcWRpc3QpIHtcbiAgICAgICAgICAgIGludGVyc2VjdCA9IGxhYmVsSW50ZXJzZWN0O1xuICAgICAgICAgICAgbWluU3FEaXN0ID0gbGFiSW50U3FkaXN0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChsYWJlbEludGVyc2VjdC5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICB2YXIgbGFiSW50MlNxRGlzdCA9IHNxZGlzdChyZWZQdCwge1xuICAgICAgICAgICAgICB4OiBsYWJlbEludGVyc2VjdFsyXSxcbiAgICAgICAgICAgICAgeTogbGFiZWxJbnRlcnNlY3RbM11cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAobGFiSW50MlNxRGlzdCA8IG1pblNxRGlzdCkge1xuICAgICAgICAgICAgICBpbnRlcnNlY3QgPSBbbGFiZWxJbnRlcnNlY3RbMl0sIGxhYmVsSW50ZXJzZWN0WzNdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYXJyb3dFbmQgPSBzaG9ydGVuSW50ZXJzZWN0aW9uKGludGVyc2VjdCwgcDEsIHIuYXJyb3dTaGFwZXNbdGd0QXJTaGFwZV0uc3BhY2luZyhlZGdlKSArIHRndERpc3QpO1xuICAgIHZhciBlZGdlRW5kID0gc2hvcnRlbkludGVyc2VjdGlvbihpbnRlcnNlY3QsIHAxLCByLmFycm93U2hhcGVzW3RndEFyU2hhcGVdLmdhcChlZGdlKSArIHRndERpc3QpO1xuICAgIHJzLmVuZFggPSBlZGdlRW5kWzBdO1xuICAgIHJzLmVuZFkgPSBlZGdlRW5kWzFdO1xuICAgIHJzLmFycm93RW5kWCA9IGFycm93RW5kWzBdO1xuICAgIHJzLmFycm93RW5kWSA9IGFycm93RW5kWzFdO1xuXG4gICAgaWYgKHNyY01hbkVuZHB0VmFsID09PSAnaW5zaWRlLXRvLW5vZGUnKSB7XG4gICAgICBpbnRlcnNlY3QgPSBbc3JjUG9zLngsIHNyY1Bvcy55XTtcbiAgICB9IGVsc2UgaWYgKHNyY01hbkVuZHB0LnVuaXRzKSB7XG4gICAgICBpbnRlcnNlY3QgPSB0aGlzLm1hbnVhbEVuZHB0VG9QeChzb3VyY2UsIHNyY01hbkVuZHB0KTtcbiAgICB9IGVsc2UgaWYgKHNyY01hbkVuZHB0VmFsID09PSAnb3V0c2lkZS10by1saW5lJykge1xuICAgICAgaW50ZXJzZWN0ID0gcnMuc3JjSW50bjsgLy8gdXNlIGNhY2hlZCB2YWx1ZSBmcm9tIGN0cmxwdCBjYWxjXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzcmNNYW5FbmRwdFZhbCA9PT0gJ291dHNpZGUtdG8tbm9kZScgfHwgc3JjTWFuRW5kcHRWYWwgPT09ICdvdXRzaWRlLXRvLW5vZGUtb3ItbGFiZWwnKSB7XG4gICAgICAgIHAyX2kgPSBwMjtcbiAgICAgIH0gZWxzZSBpZiAoc3JjTWFuRW5kcHRWYWwgPT09ICdvdXRzaWRlLXRvLWxpbmUnIHx8IHNyY01hbkVuZHB0VmFsID09PSAnb3V0c2lkZS10by1saW5lLW9yLWxhYmVsJykge1xuICAgICAgICBwMl9pID0gW3RndFBvcy54LCB0Z3RQb3MueV07XG4gICAgICB9XG5cbiAgICAgIGludGVyc2VjdCA9IHIubm9kZVNoYXBlc1t0aGlzLmdldE5vZGVTaGFwZShzb3VyY2UpXS5pbnRlcnNlY3RMaW5lKHNyY1Bvcy54LCBzcmNQb3MueSwgc291cmNlLm91dGVyV2lkdGgoKSwgc291cmNlLm91dGVySGVpZ2h0KCksIHAyX2lbMF0sIHAyX2lbMV0sIDApO1xuXG4gICAgICBpZiAoc3JjTWFuRW5kcHRWYWwgPT09ICdvdXRzaWRlLXRvLW5vZGUtb3ItbGFiZWwnIHx8IHNyY01hbkVuZHB0VmFsID09PSAnb3V0c2lkZS10by1saW5lLW9yLWxhYmVsJykge1xuICAgICAgICB2YXIgc3JzID0gc291cmNlLl9wcml2YXRlLnJzY3JhdGNoO1xuICAgICAgICB2YXIgX2x3ID0gc3JzLmxhYmVsV2lkdGg7XG4gICAgICAgIHZhciBfbGggPSBzcnMubGFiZWxIZWlnaHQ7XG4gICAgICAgIHZhciBfbHggPSBzcnMubGFiZWxYO1xuICAgICAgICB2YXIgX2x5ID0gc3JzLmxhYmVsWTtcblxuICAgICAgICB2YXIgX2x3MiA9IF9sdyAvIDI7XG5cbiAgICAgICAgdmFyIF9saDIgPSBfbGggLyAyO1xuXG4gICAgICAgIHZhciBfdmEgPSBzb3VyY2UucHN0eWxlKCd0ZXh0LXZhbGlnbicpLnZhbHVlO1xuXG4gICAgICAgIGlmIChfdmEgPT09ICd0b3AnKSB7XG4gICAgICAgICAgX2x5IC09IF9saDI7XG4gICAgICAgIH0gZWxzZSBpZiAoX3ZhID09PSAnYm90dG9tJykge1xuICAgICAgICAgIF9seSArPSBfbGgyO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9oYSA9IHNvdXJjZS5wc3R5bGUoJ3RleHQtaGFsaWduJykudmFsdWU7XG5cbiAgICAgICAgaWYgKF9oYSA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgX2x4IC09IF9sdzI7XG4gICAgICAgIH0gZWxzZSBpZiAoX2hhID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgX2x4ICs9IF9sdzI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX2xhYmVsSW50ZXJzZWN0ID0gcG9seWdvbkludGVyc2VjdExpbmUocDJfaVswXSwgcDJfaVsxXSwgW19seCAtIF9sdzIsIF9seSAtIF9saDIsIF9seCArIF9sdzIsIF9seSAtIF9saDIsIF9seCArIF9sdzIsIF9seSArIF9saDIsIF9seCAtIF9sdzIsIF9seSArIF9saDJdLCBzcmNQb3MueCwgc3JjUG9zLnkpO1xuXG4gICAgICAgIGlmIChfbGFiZWxJbnRlcnNlY3QubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciBfcmVmUHQgPSB0Z3RQb3M7XG5cbiAgICAgICAgICB2YXIgX2ludFNxZGlzdCA9IHNxZGlzdChfcmVmUHQsIGFycmF5MnBvaW50KGludGVyc2VjdCkpO1xuXG4gICAgICAgICAgdmFyIF9sYWJJbnRTcWRpc3QgPSBzcWRpc3QoX3JlZlB0LCBhcnJheTJwb2ludChfbGFiZWxJbnRlcnNlY3QpKTtcblxuICAgICAgICAgIHZhciBfbWluU3FEaXN0ID0gX2ludFNxZGlzdDtcblxuICAgICAgICAgIGlmIChfbGFiSW50U3FkaXN0IDwgX2ludFNxZGlzdCkge1xuICAgICAgICAgICAgaW50ZXJzZWN0ID0gW19sYWJlbEludGVyc2VjdFswXSwgX2xhYmVsSW50ZXJzZWN0WzFdXTtcbiAgICAgICAgICAgIF9taW5TcURpc3QgPSBfbGFiSW50U3FkaXN0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChfbGFiZWxJbnRlcnNlY3QubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgdmFyIF9sYWJJbnQyU3FEaXN0ID0gc3FkaXN0KF9yZWZQdCwge1xuICAgICAgICAgICAgICB4OiBfbGFiZWxJbnRlcnNlY3RbMl0sXG4gICAgICAgICAgICAgIHk6IF9sYWJlbEludGVyc2VjdFszXVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChfbGFiSW50MlNxRGlzdCA8IF9taW5TcURpc3QpIHtcbiAgICAgICAgICAgICAgaW50ZXJzZWN0ID0gW19sYWJlbEludGVyc2VjdFsyXSwgX2xhYmVsSW50ZXJzZWN0WzNdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYXJyb3dTdGFydCA9IHNob3J0ZW5JbnRlcnNlY3Rpb24oaW50ZXJzZWN0LCBwMiwgci5hcnJvd1NoYXBlc1tzcmNBclNoYXBlXS5zcGFjaW5nKGVkZ2UpICsgc3JjRGlzdCk7XG4gICAgdmFyIGVkZ2VTdGFydCA9IHNob3J0ZW5JbnRlcnNlY3Rpb24oaW50ZXJzZWN0LCBwMiwgci5hcnJvd1NoYXBlc1tzcmNBclNoYXBlXS5nYXAoZWRnZSkgKyBzcmNEaXN0KTtcbiAgICBycy5zdGFydFggPSBlZGdlU3RhcnRbMF07XG4gICAgcnMuc3RhcnRZID0gZWRnZVN0YXJ0WzFdO1xuICAgIHJzLmFycm93U3RhcnRYID0gYXJyb3dTdGFydFswXTtcbiAgICBycy5hcnJvd1N0YXJ0WSA9IGFycm93U3RhcnRbMV07XG5cbiAgICBpZiAoaGFzRW5kcHRzKSB7XG4gICAgICBpZiAoIW51bWJlciQxKHJzLnN0YXJ0WCkgfHwgIW51bWJlciQxKHJzLnN0YXJ0WSkgfHwgIW51bWJlciQxKHJzLmVuZFgpIHx8ICFudW1iZXIkMShycy5lbmRZKSkge1xuICAgICAgICBycy5iYWRMaW5lID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJzLmJhZExpbmUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgQlJwJGIuZ2V0U291cmNlRW5kcG9pbnQgPSBmdW5jdGlvbiAoZWRnZSkge1xuICAgIHZhciBycyA9IGVkZ2VbMF0uX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgdGhpcy5yZWNhbGN1bGF0ZVJlbmRlcmVkU3R5bGUoZWRnZSk7XG5cbiAgICBzd2l0Y2ggKHJzLmVkZ2VUeXBlKSB7XG4gICAgICBjYXNlICdoYXlzdGFjayc6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogcnMuaGF5c3RhY2tQdHNbMF0sXG4gICAgICAgICAgeTogcnMuaGF5c3RhY2tQdHNbMV1cbiAgICAgICAgfTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiBycy5hcnJvd1N0YXJ0WCxcbiAgICAgICAgICB5OiBycy5hcnJvd1N0YXJ0WVxuICAgICAgICB9O1xuICAgIH1cbiAgfTtcblxuICBCUnAkYi5nZXRUYXJnZXRFbmRwb2ludCA9IGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgdmFyIHJzID0gZWRnZVswXS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICB0aGlzLnJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZShlZGdlKTtcblxuICAgIHN3aXRjaCAocnMuZWRnZVR5cGUpIHtcbiAgICAgIGNhc2UgJ2hheXN0YWNrJzpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiBycy5oYXlzdGFja1B0c1syXSxcbiAgICAgICAgICB5OiBycy5oYXlzdGFja1B0c1szXVxuICAgICAgICB9O1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IHJzLmFycm93RW5kWCxcbiAgICAgICAgICB5OiBycy5hcnJvd0VuZFlcbiAgICAgICAgfTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIEJScCRhID0ge307XG5cbiAgZnVuY3Rpb24gcHVzaEJlemllclB0cyhyLCBlZGdlLCBwdHMpIHtcbiAgICB2YXIgcWJlemllckF0JDEgPSBmdW5jdGlvbiBxYmV6aWVyQXQkMShwMSwgcDIsIHAzLCB0KSB7XG4gICAgICByZXR1cm4gcWJlemllckF0KHAxLCBwMiwgcDMsIHQpO1xuICAgIH07XG5cbiAgICB2YXIgX3AgPSBlZGdlLl9wcml2YXRlO1xuICAgIHZhciBicHRzID0gX3AucnN0eWxlLmJlemllclB0cztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgci5iZXppZXJQcm9qUGN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHAgPSByLmJlemllclByb2pQY3RzW2ldO1xuICAgICAgYnB0cy5wdXNoKHtcbiAgICAgICAgeDogcWJlemllckF0JDEocHRzWzBdLCBwdHNbMl0sIHB0c1s0XSwgcCksXG4gICAgICAgIHk6IHFiZXppZXJBdCQxKHB0c1sxXSwgcHRzWzNdLCBwdHNbNV0sIHApXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBCUnAkYS5zdG9yZUVkZ2VQcm9qZWN0aW9ucyA9IGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgdmFyIF9wID0gZWRnZS5fcHJpdmF0ZTtcbiAgICB2YXIgcnMgPSBfcC5yc2NyYXRjaDtcbiAgICB2YXIgZXQgPSBycy5lZGdlVHlwZTsgLy8gY2xlYXIgdGhlIGNhY2hlZCBwb2ludHMgc3RhdGVcblxuICAgIF9wLnJzdHlsZS5iZXppZXJQdHMgPSBudWxsO1xuICAgIF9wLnJzdHlsZS5saW5lUHRzID0gbnVsbDtcbiAgICBfcC5yc3R5bGUuaGF5c3RhY2tQdHMgPSBudWxsO1xuXG4gICAgaWYgKGV0ID09PSAnbXVsdGliZXppZXInIHx8IGV0ID09PSAnYmV6aWVyJyB8fCBldCA9PT0gJ3NlbGYnIHx8IGV0ID09PSAnY29tcG91bmQnKSB7XG4gICAgICBfcC5yc3R5bGUuYmV6aWVyUHRzID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpICsgNSA8IHJzLmFsbHB0cy5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgICBwdXNoQmV6aWVyUHRzKHRoaXMsIGVkZ2UsIHJzLmFsbHB0cy5zbGljZShpLCBpICsgNikpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZXQgPT09ICdzZWdtZW50cycpIHtcbiAgICAgIHZhciBscHRzID0gX3AucnN0eWxlLmxpbmVQdHMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgKyAxIDwgcnMuYWxscHRzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIGxwdHMucHVzaCh7XG4gICAgICAgICAgeDogcnMuYWxscHRzW2ldLFxuICAgICAgICAgIHk6IHJzLmFsbHB0c1tpICsgMV1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChldCA9PT0gJ2hheXN0YWNrJykge1xuICAgICAgdmFyIGhwdHMgPSBycy5oYXlzdGFja1B0cztcbiAgICAgIF9wLnJzdHlsZS5oYXlzdGFja1B0cyA9IFt7XG4gICAgICAgIHg6IGhwdHNbMF0sXG4gICAgICAgIHk6IGhwdHNbMV1cbiAgICAgIH0sIHtcbiAgICAgICAgeDogaHB0c1syXSxcbiAgICAgICAgeTogaHB0c1szXVxuICAgICAgfV07XG4gICAgfVxuXG4gICAgX3AucnN0eWxlLmFycm93V2lkdGggPSB0aGlzLmdldEFycm93V2lkdGgoZWRnZS5wc3R5bGUoJ3dpZHRoJykucGZWYWx1ZSwgZWRnZS5wc3R5bGUoJ2Fycm93LXNjYWxlJykudmFsdWUpICogdGhpcy5hcnJvd1NoYXBlV2lkdGg7XG4gIH07XG5cbiAgQlJwJGEucmVjYWxjdWxhdGVFZGdlUHJvamVjdGlvbnMgPSBmdW5jdGlvbiAoZWRnZXMpIHtcbiAgICB0aGlzLmZpbmRFZGdlQ29udHJvbFBvaW50cyhlZGdlcyk7XG4gIH07XG5cbiAgLyogZ2xvYmFsIGRvY3VtZW50ICovXG5cbiAgdmFyIEJScCQ5ID0ge307XG5cbiAgQlJwJDkucmVjYWxjdWxhdGVOb2RlTGFiZWxQcm9qZWN0aW9uID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICB2YXIgY29udGVudCA9IG5vZGUucHN0eWxlKCdsYWJlbCcpLnN0clZhbHVlO1xuXG4gICAgaWYgKGVtcHR5U3RyaW5nKGNvbnRlbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHRleHRYLCB0ZXh0WTtcbiAgICB2YXIgX3AgPSBub2RlLl9wcml2YXRlO1xuICAgIHZhciBub2RlV2lkdGggPSBub2RlLndpZHRoKCk7XG4gICAgdmFyIG5vZGVIZWlnaHQgPSBub2RlLmhlaWdodCgpO1xuICAgIHZhciBwYWRkaW5nID0gbm9kZS5wYWRkaW5nKCk7XG4gICAgdmFyIG5vZGVQb3MgPSBub2RlLnBvc2l0aW9uKCk7XG4gICAgdmFyIHRleHRIYWxpZ24gPSBub2RlLnBzdHlsZSgndGV4dC1oYWxpZ24nKS5zdHJWYWx1ZTtcbiAgICB2YXIgdGV4dFZhbGlnbiA9IG5vZGUucHN0eWxlKCd0ZXh0LXZhbGlnbicpLnN0clZhbHVlO1xuICAgIHZhciBycyA9IF9wLnJzY3JhdGNoO1xuICAgIHZhciByc3R5bGUgPSBfcC5yc3R5bGU7XG5cbiAgICBzd2l0Y2ggKHRleHRIYWxpZ24pIHtcbiAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICB0ZXh0WCA9IG5vZGVQb3MueCAtIG5vZGVXaWR0aCAvIDIgLSBwYWRkaW5nO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICB0ZXh0WCA9IG5vZGVQb3MueCArIG5vZGVXaWR0aCAvIDIgKyBwYWRkaW5nO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gZS5nLiBjZW50ZXJcbiAgICAgICAgdGV4dFggPSBub2RlUG9zLng7XG4gICAgfVxuXG4gICAgc3dpdGNoICh0ZXh0VmFsaWduKSB7XG4gICAgICBjYXNlICd0b3AnOlxuICAgICAgICB0ZXh0WSA9IG5vZGVQb3MueSAtIG5vZGVIZWlnaHQgLyAyIC0gcGFkZGluZztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgIHRleHRZID0gbm9kZVBvcy55ICsgbm9kZUhlaWdodCAvIDIgKyBwYWRkaW5nO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gZS5nLiBtaWRkbGVcbiAgICAgICAgdGV4dFkgPSBub2RlUG9zLnk7XG4gICAgfVxuXG4gICAgcnMubGFiZWxYID0gdGV4dFg7XG4gICAgcnMubGFiZWxZID0gdGV4dFk7XG4gICAgcnN0eWxlLmxhYmVsWCA9IHRleHRYO1xuICAgIHJzdHlsZS5sYWJlbFkgPSB0ZXh0WTtcbiAgICB0aGlzLmNhbGN1bGF0ZUxhYmVsQW5nbGVzKG5vZGUpO1xuICAgIHRoaXMuYXBwbHlMYWJlbERpbWVuc2lvbnMobm9kZSk7XG4gIH07XG5cbiAgdmFyIGxpbmVBbmdsZUZyb21EZWx0YSA9IGZ1bmN0aW9uIGxpbmVBbmdsZUZyb21EZWx0YShkeCwgZHkpIHtcbiAgICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4oZHkgLyBkeCk7XG5cbiAgICBpZiAoZHggPT09IDAgJiYgYW5nbGUgPCAwKSB7XG4gICAgICBhbmdsZSA9IGFuZ2xlICogLTE7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFuZ2xlO1xuICB9O1xuXG4gIHZhciBsaW5lQW5nbGUgPSBmdW5jdGlvbiBsaW5lQW5nbGUocDAsIHAxKSB7XG4gICAgdmFyIGR4ID0gcDEueCAtIHAwLng7XG4gICAgdmFyIGR5ID0gcDEueSAtIHAwLnk7XG4gICAgcmV0dXJuIGxpbmVBbmdsZUZyb21EZWx0YShkeCwgZHkpO1xuICB9O1xuXG4gIHZhciBiZXppZXJBbmdsZSA9IGZ1bmN0aW9uIGJlemllckFuZ2xlKHAwLCBwMSwgcDIsIHQpIHtcbiAgICB2YXIgdDAgPSBib3VuZCgwLCB0IC0gMC4wMDEsIDEpO1xuICAgIHZhciB0MSA9IGJvdW5kKDAsIHQgKyAwLjAwMSwgMSk7XG4gICAgdmFyIGxwMCA9IHFiZXppZXJQdEF0KHAwLCBwMSwgcDIsIHQwKTtcbiAgICB2YXIgbHAxID0gcWJlemllclB0QXQocDAsIHAxLCBwMiwgdDEpO1xuICAgIHJldHVybiBsaW5lQW5nbGUobHAwLCBscDEpO1xuICB9O1xuXG4gIEJScCQ5LnJlY2FsY3VsYXRlRWRnZUxhYmVsUHJvamVjdGlvbnMgPSBmdW5jdGlvbiAoZWRnZSkge1xuICAgIHZhciBwO1xuICAgIHZhciBfcCA9IGVkZ2UuX3ByaXZhdGU7XG4gICAgdmFyIHJzID0gX3AucnNjcmF0Y2g7XG4gICAgdmFyIHIgPSB0aGlzO1xuICAgIHZhciBjb250ZW50ID0ge1xuICAgICAgbWlkOiBlZGdlLnBzdHlsZSgnbGFiZWwnKS5zdHJWYWx1ZSxcbiAgICAgIHNvdXJjZTogZWRnZS5wc3R5bGUoJ3NvdXJjZS1sYWJlbCcpLnN0clZhbHVlLFxuICAgICAgdGFyZ2V0OiBlZGdlLnBzdHlsZSgndGFyZ2V0LWxhYmVsJykuc3RyVmFsdWVcbiAgICB9O1xuXG4gICAgaWYgKGNvbnRlbnQubWlkIHx8IGNvbnRlbnQuc291cmNlIHx8IGNvbnRlbnQudGFyZ2V0KSA7IGVsc2Uge1xuICAgICAgcmV0dXJuOyAvLyBubyBsYWJlbHMgPT4gbm8gY2FsY3NcbiAgICB9IC8vIGFkZCBjZW50ZXIgcG9pbnQgdG8gc3R5bGUgc28gYm91bmRpbmcgYm94IGNhbGN1bGF0aW9ucyBjYW4gdXNlIGl0XG4gICAgLy9cblxuXG4gICAgcCA9IHtcbiAgICAgIHg6IHJzLm1pZFgsXG4gICAgICB5OiBycy5taWRZXG4gICAgfTtcblxuICAgIHZhciBzZXRScyA9IGZ1bmN0aW9uIHNldFJzKHByb3BOYW1lLCBwcmVmaXgsIHZhbHVlKSB7XG4gICAgICBzZXRQcmVmaXhlZFByb3BlcnR5KF9wLnJzY3JhdGNoLCBwcm9wTmFtZSwgcHJlZml4LCB2YWx1ZSk7XG4gICAgICBzZXRQcmVmaXhlZFByb3BlcnR5KF9wLnJzdHlsZSwgcHJvcE5hbWUsIHByZWZpeCwgdmFsdWUpO1xuICAgIH07XG5cbiAgICBzZXRScygnbGFiZWxYJywgbnVsbCwgcC54KTtcbiAgICBzZXRScygnbGFiZWxZJywgbnVsbCwgcC55KTtcbiAgICB2YXIgbWlkQW5nbGUgPSBsaW5lQW5nbGVGcm9tRGVsdGEocnMubWlkRGlzcFgsIHJzLm1pZERpc3BZKTtcbiAgICBzZXRScygnbGFiZWxBdXRvQW5nbGUnLCBudWxsLCBtaWRBbmdsZSk7XG5cbiAgICB2YXIgY3JlYXRlQ29udHJvbFBvaW50SW5mbyA9IGZ1bmN0aW9uIGNyZWF0ZUNvbnRyb2xQb2ludEluZm8oKSB7XG4gICAgICBpZiAoY3JlYXRlQ29udHJvbFBvaW50SW5mby5jYWNoZSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQ29udHJvbFBvaW50SW5mby5jYWNoZTtcbiAgICAgIH0gLy8gdXNlIGNhY2hlIHNvIG9ubHkgMXggcGVyIGVkZ2VcblxuXG4gICAgICB2YXIgY3RybHB0cyA9IFtdOyAvLyBzdG9yZSBlYWNoIGN0cmxwdCBpbmZvIGluaXRcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgKyA1IDwgcnMuYWxscHRzLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICAgIHZhciBwMCA9IHtcbiAgICAgICAgICB4OiBycy5hbGxwdHNbaV0sXG4gICAgICAgICAgeTogcnMuYWxscHRzW2kgKyAxXVxuICAgICAgICB9O1xuICAgICAgICB2YXIgcDEgPSB7XG4gICAgICAgICAgeDogcnMuYWxscHRzW2kgKyAyXSxcbiAgICAgICAgICB5OiBycy5hbGxwdHNbaSArIDNdXG4gICAgICAgIH07IC8vIGN0cmxwdFxuXG4gICAgICAgIHZhciBwMiA9IHtcbiAgICAgICAgICB4OiBycy5hbGxwdHNbaSArIDRdLFxuICAgICAgICAgIHk6IHJzLmFsbHB0c1tpICsgNV1cbiAgICAgICAgfTtcbiAgICAgICAgY3RybHB0cy5wdXNoKHtcbiAgICAgICAgICBwMDogcDAsXG4gICAgICAgICAgcDE6IHAxLFxuICAgICAgICAgIHAyOiBwMixcbiAgICAgICAgICBzdGFydERpc3Q6IDAsXG4gICAgICAgICAgbGVuZ3RoOiAwLFxuICAgICAgICAgIHNlZ21lbnRzOiBbXVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGJwdHMgPSBfcC5yc3R5bGUuYmV6aWVyUHRzO1xuICAgICAgdmFyIG5Qcm9qcyA9IHIuYmV6aWVyUHJvalBjdHMubGVuZ3RoO1xuXG4gICAgICBmdW5jdGlvbiBhZGRTZWdtZW50KGNwLCBwMCwgcDEsIHQwLCB0MSkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gZGlzdChwMCwgcDEpO1xuICAgICAgICB2YXIgcHJldlNlZ21lbnQgPSBjcC5zZWdtZW50c1tjcC5zZWdtZW50cy5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIHNlZ21lbnQgPSB7XG4gICAgICAgICAgcDA6IHAwLFxuICAgICAgICAgIHAxOiBwMSxcbiAgICAgICAgICB0MDogdDAsXG4gICAgICAgICAgdDE6IHQxLFxuICAgICAgICAgIHN0YXJ0RGlzdDogcHJldlNlZ21lbnQgPyBwcmV2U2VnbWVudC5zdGFydERpc3QgKyBwcmV2U2VnbWVudC5sZW5ndGggOiAwLFxuICAgICAgICAgIGxlbmd0aDogbGVuZ3RoXG4gICAgICAgIH07XG4gICAgICAgIGNwLnNlZ21lbnRzLnB1c2goc2VnbWVudCk7XG4gICAgICAgIGNwLmxlbmd0aCArPSBsZW5ndGg7XG4gICAgICB9IC8vIHVwZGF0ZSBlYWNoIGN0cmxwdCB3aXRoIHNlZ21lbnQgaW5mb1xuXG5cbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBjdHJscHRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgY3AgPSBjdHJscHRzW19pXTtcbiAgICAgICAgdmFyIHByZXZDcCA9IGN0cmxwdHNbX2kgLSAxXTtcblxuICAgICAgICBpZiAocHJldkNwKSB7XG4gICAgICAgICAgY3Auc3RhcnREaXN0ID0gcHJldkNwLnN0YXJ0RGlzdCArIHByZXZDcC5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBhZGRTZWdtZW50KGNwLCBjcC5wMCwgYnB0c1tfaSAqIG5Qcm9qc10sIDAsIHIuYmV6aWVyUHJvalBjdHNbMF0pOyAvLyBmaXJzdFxuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgblByb2pzIC0gMTsgaisrKSB7XG4gICAgICAgICAgYWRkU2VnbWVudChjcCwgYnB0c1tfaSAqIG5Qcm9qcyArIGpdLCBicHRzW19pICogblByb2pzICsgaiArIDFdLCByLmJlemllclByb2pQY3RzW2pdLCByLmJlemllclByb2pQY3RzW2ogKyAxXSk7XG4gICAgICAgIH1cblxuICAgICAgICBhZGRTZWdtZW50KGNwLCBicHRzW19pICogblByb2pzICsgblByb2pzIC0gMV0sIGNwLnAyLCByLmJlemllclByb2pQY3RzW25Qcm9qcyAtIDFdLCAxKTsgLy8gbGFzdFxuICAgICAgfVxuXG4gICAgICByZXR1cm4gY3JlYXRlQ29udHJvbFBvaW50SW5mby5jYWNoZSA9IGN0cmxwdHM7XG4gICAgfTtcblxuICAgIHZhciBjYWxjdWxhdGVFbmRQcm9qZWN0aW9uID0gZnVuY3Rpb24gY2FsY3VsYXRlRW5kUHJvamVjdGlvbihwcmVmaXgpIHtcbiAgICAgIHZhciBhbmdsZTtcbiAgICAgIHZhciBpc1NyYyA9IHByZWZpeCA9PT0gJ3NvdXJjZSc7XG5cbiAgICAgIGlmICghY29udGVudFtwcmVmaXhdKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIG9mZnNldCA9IGVkZ2UucHN0eWxlKHByZWZpeCArICctdGV4dC1vZmZzZXQnKS5wZlZhbHVlO1xuXG4gICAgICBzd2l0Y2ggKHJzLmVkZ2VUeXBlKSB7XG4gICAgICAgIGNhc2UgJ3NlbGYnOlxuICAgICAgICBjYXNlICdjb21wb3VuZCc6XG4gICAgICAgIGNhc2UgJ2Jlemllcic6XG4gICAgICAgIGNhc2UgJ211bHRpYmV6aWVyJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgY3BzID0gY3JlYXRlQ29udHJvbFBvaW50SW5mbygpO1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkO1xuICAgICAgICAgICAgdmFyIHN0YXJ0RGlzdCA9IDA7XG4gICAgICAgICAgICB2YXIgdG90YWxEaXN0ID0gMDsgLy8gZmluZCB0aGUgc2VnbWVudCB3ZSdyZSBvblxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YXIgX2NwID0gY3BzW2lzU3JjID8gaSA6IGNwcy5sZW5ndGggLSAxIC0gaV07XG5cbiAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBfY3Auc2VnbWVudHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgX3NlZyA9IF9jcC5zZWdtZW50c1tpc1NyYyA/IGogOiBfY3Auc2VnbWVudHMubGVuZ3RoIC0gMSAtIGpdO1xuICAgICAgICAgICAgICAgIHZhciBsYXN0U2VnID0gaSA9PT0gY3BzLmxlbmd0aCAtIDEgJiYgaiA9PT0gX2NwLnNlZ21lbnRzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgc3RhcnREaXN0ID0gdG90YWxEaXN0O1xuICAgICAgICAgICAgICAgIHRvdGFsRGlzdCArPSBfc2VnLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIGlmICh0b3RhbERpc3QgPj0gb2Zmc2V0IHx8IGxhc3RTZWcpIHtcbiAgICAgICAgICAgICAgICAgIHNlbGVjdGVkID0ge1xuICAgICAgICAgICAgICAgICAgICBjcDogX2NwLFxuICAgICAgICAgICAgICAgICAgICBzZWdtZW50OiBfc2VnXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGNwID0gc2VsZWN0ZWQuY3A7XG4gICAgICAgICAgICB2YXIgc2VnID0gc2VsZWN0ZWQuc2VnbWVudDtcbiAgICAgICAgICAgIHZhciB0U2VnbWVudCA9IChvZmZzZXQgLSBzdGFydERpc3QpIC8gc2VnLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBzZWdEdCA9IHNlZy50MSAtIHNlZy50MDtcbiAgICAgICAgICAgIHZhciB0ID0gaXNTcmMgPyBzZWcudDAgKyBzZWdEdCAqIHRTZWdtZW50IDogc2VnLnQxIC0gc2VnRHQgKiB0U2VnbWVudDtcbiAgICAgICAgICAgIHQgPSBib3VuZCgwLCB0LCAxKTtcbiAgICAgICAgICAgIHAgPSBxYmV6aWVyUHRBdChjcC5wMCwgY3AucDEsIGNwLnAyLCB0KTtcbiAgICAgICAgICAgIGFuZ2xlID0gYmV6aWVyQW5nbGUoY3AucDAsIGNwLnAxLCBjcC5wMiwgdCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnc3RyYWlnaHQnOlxuICAgICAgICBjYXNlICdzZWdtZW50cyc6XG4gICAgICAgIGNhc2UgJ2hheXN0YWNrJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgZCA9IDAsXG4gICAgICAgICAgICAgICAgZGksXG4gICAgICAgICAgICAgICAgZDA7XG4gICAgICAgICAgICB2YXIgcDAsIHAxO1xuICAgICAgICAgICAgdmFyIGwgPSBycy5hbGxwdHMubGVuZ3RoO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgKyAzIDwgbDsgX2kyICs9IDIpIHtcbiAgICAgICAgICAgICAgaWYgKGlzU3JjKSB7XG4gICAgICAgICAgICAgICAgcDAgPSB7XG4gICAgICAgICAgICAgICAgICB4OiBycy5hbGxwdHNbX2kyXSxcbiAgICAgICAgICAgICAgICAgIHk6IHJzLmFsbHB0c1tfaTIgKyAxXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcDEgPSB7XG4gICAgICAgICAgICAgICAgICB4OiBycy5hbGxwdHNbX2kyICsgMl0sXG4gICAgICAgICAgICAgICAgICB5OiBycy5hbGxwdHNbX2kyICsgM11cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHAwID0ge1xuICAgICAgICAgICAgICAgICAgeDogcnMuYWxscHRzW2wgLSAyIC0gX2kyXSxcbiAgICAgICAgICAgICAgICAgIHk6IHJzLmFsbHB0c1tsIC0gMSAtIF9pMl1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHAxID0ge1xuICAgICAgICAgICAgICAgICAgeDogcnMuYWxscHRzW2wgLSA0IC0gX2kyXSxcbiAgICAgICAgICAgICAgICAgIHk6IHJzLmFsbHB0c1tsIC0gMyAtIF9pMl1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZGkgPSBkaXN0KHAwLCBwMSk7XG4gICAgICAgICAgICAgIGQwID0gZDtcbiAgICAgICAgICAgICAgZCArPSBkaTtcblxuICAgICAgICAgICAgICBpZiAoZCA+PSBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcEQgPSBvZmZzZXQgLSBkMDtcblxuICAgICAgICAgICAgdmFyIF90ID0gcEQgLyBkaTtcblxuICAgICAgICAgICAgX3QgPSBib3VuZCgwLCBfdCwgMSk7XG4gICAgICAgICAgICBwID0gbGluZUF0KHAwLCBwMSwgX3QpO1xuICAgICAgICAgICAgYW5nbGUgPSBsaW5lQW5nbGUocDAsIHAxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2V0UnMoJ2xhYmVsWCcsIHByZWZpeCwgcC54KTtcbiAgICAgIHNldFJzKCdsYWJlbFknLCBwcmVmaXgsIHAueSk7XG4gICAgICBzZXRScygnbGFiZWxBdXRvQW5nbGUnLCBwcmVmaXgsIGFuZ2xlKTtcbiAgICB9O1xuXG4gICAgY2FsY3VsYXRlRW5kUHJvamVjdGlvbignc291cmNlJyk7XG4gICAgY2FsY3VsYXRlRW5kUHJvamVjdGlvbigndGFyZ2V0Jyk7XG4gICAgdGhpcy5hcHBseUxhYmVsRGltZW5zaW9ucyhlZGdlKTtcbiAgfTtcblxuICBCUnAkOS5hcHBseUxhYmVsRGltZW5zaW9ucyA9IGZ1bmN0aW9uIChlbGUpIHtcbiAgICB0aGlzLmFwcGx5UHJlZml4ZWRMYWJlbERpbWVuc2lvbnMoZWxlKTtcblxuICAgIGlmIChlbGUuaXNFZGdlKCkpIHtcbiAgICAgIHRoaXMuYXBwbHlQcmVmaXhlZExhYmVsRGltZW5zaW9ucyhlbGUsICdzb3VyY2UnKTtcbiAgICAgIHRoaXMuYXBwbHlQcmVmaXhlZExhYmVsRGltZW5zaW9ucyhlbGUsICd0YXJnZXQnKTtcbiAgICB9XG4gIH07XG5cbiAgQlJwJDkuYXBwbHlQcmVmaXhlZExhYmVsRGltZW5zaW9ucyA9IGZ1bmN0aW9uIChlbGUsIHByZWZpeCkge1xuICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICB2YXIgdGV4dCA9IHRoaXMuZ2V0TGFiZWxUZXh0KGVsZSwgcHJlZml4KTtcbiAgICB2YXIgbGFiZWxEaW1zID0gdGhpcy5jYWxjdWxhdGVMYWJlbERpbWVuc2lvbnMoZWxlLCB0ZXh0KTtcbiAgICB2YXIgbGluZUhlaWdodCA9IGVsZS5wc3R5bGUoJ2xpbmUtaGVpZ2h0JykucGZWYWx1ZTtcbiAgICB2YXIgdGV4dFdyYXAgPSBlbGUucHN0eWxlKCd0ZXh0LXdyYXAnKS5zdHJWYWx1ZTtcbiAgICB2YXIgbGluZXMgPSBnZXRQcmVmaXhlZFByb3BlcnR5KF9wLnJzY3JhdGNoLCAnbGFiZWxXcmFwQ2FjaGVkTGluZXMnLCBwcmVmaXgpIHx8IFtdO1xuICAgIHZhciBudW1MaW5lcyA9IHRleHRXcmFwICE9PSAnd3JhcCcgPyAxIDogTWF0aC5tYXgobGluZXMubGVuZ3RoLCAxKTtcbiAgICB2YXIgbm9ybVBlckxpbmVIZWlnaHQgPSBsYWJlbERpbXMuaGVpZ2h0IC8gbnVtTGluZXM7XG4gICAgdmFyIGxhYmVsTGluZUhlaWdodCA9IG5vcm1QZXJMaW5lSGVpZ2h0ICogbGluZUhlaWdodDtcbiAgICB2YXIgd2lkdGggPSBsYWJlbERpbXMud2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IGxhYmVsRGltcy5oZWlnaHQgKyAobnVtTGluZXMgLSAxKSAqIChsaW5lSGVpZ2h0IC0gMSkgKiBub3JtUGVyTGluZUhlaWdodDtcbiAgICBzZXRQcmVmaXhlZFByb3BlcnR5KF9wLnJzdHlsZSwgJ2xhYmVsV2lkdGgnLCBwcmVmaXgsIHdpZHRoKTtcbiAgICBzZXRQcmVmaXhlZFByb3BlcnR5KF9wLnJzY3JhdGNoLCAnbGFiZWxXaWR0aCcsIHByZWZpeCwgd2lkdGgpO1xuICAgIHNldFByZWZpeGVkUHJvcGVydHkoX3AucnN0eWxlLCAnbGFiZWxIZWlnaHQnLCBwcmVmaXgsIGhlaWdodCk7XG4gICAgc2V0UHJlZml4ZWRQcm9wZXJ0eShfcC5yc2NyYXRjaCwgJ2xhYmVsSGVpZ2h0JywgcHJlZml4LCBoZWlnaHQpO1xuICAgIHNldFByZWZpeGVkUHJvcGVydHkoX3AucnNjcmF0Y2gsICdsYWJlbExpbmVIZWlnaHQnLCBwcmVmaXgsIGxhYmVsTGluZUhlaWdodCk7XG4gIH07XG5cbiAgQlJwJDkuZ2V0TGFiZWxUZXh0ID0gZnVuY3Rpb24gKGVsZSwgcHJlZml4KSB7XG4gICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgIHZhciBwZmQgPSBwcmVmaXggPyBwcmVmaXggKyAnLScgOiAnJztcbiAgICB2YXIgdGV4dCA9IGVsZS5wc3R5bGUocGZkICsgJ2xhYmVsJykuc3RyVmFsdWU7XG4gICAgdmFyIHRleHRUcmFuc2Zvcm0gPSBlbGUucHN0eWxlKCd0ZXh0LXRyYW5zZm9ybScpLnZhbHVlO1xuXG4gICAgdmFyIHJzY3JhdGNoID0gZnVuY3Rpb24gcnNjcmF0Y2gocHJvcE5hbWUsIHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgc2V0UHJlZml4ZWRQcm9wZXJ0eShfcC5yc2NyYXRjaCwgcHJvcE5hbWUsIHByZWZpeCwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZ2V0UHJlZml4ZWRQcm9wZXJ0eShfcC5yc2NyYXRjaCwgcHJvcE5hbWUsIHByZWZpeCk7XG4gICAgICB9XG4gICAgfTsgLy8gZm9yIGVtcHR5IHRleHQsIHNraXAgYWxsIHByb2Nlc3NpbmdcblxuXG4gICAgaWYgKCF0ZXh0KSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgaWYgKHRleHRUcmFuc2Zvcm0gPT0gJ25vbmUnKSA7IGVsc2UgaWYgKHRleHRUcmFuc2Zvcm0gPT0gJ3VwcGVyY2FzZScpIHtcbiAgICAgIHRleHQgPSB0ZXh0LnRvVXBwZXJDYXNlKCk7XG4gICAgfSBlbHNlIGlmICh0ZXh0VHJhbnNmb3JtID09ICdsb3dlcmNhc2UnKSB7XG4gICAgICB0ZXh0ID0gdGV4dC50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIHZhciB3cmFwU3R5bGUgPSBlbGUucHN0eWxlKCd0ZXh0LXdyYXAnKS52YWx1ZTtcblxuICAgIGlmICh3cmFwU3R5bGUgPT09ICd3cmFwJykge1xuICAgICAgdmFyIGxhYmVsS2V5ID0gcnNjcmF0Y2goJ2xhYmVsS2V5Jyk7IC8vIHNhdmUgcmVjYWxjIGlmIHRoZSBsYWJlbCBpcyB0aGUgc2FtZSBhcyBiZWZvcmVcblxuICAgICAgaWYgKGxhYmVsS2V5ICE9IG51bGwgJiYgcnNjcmF0Y2goJ2xhYmVsV3JhcEtleScpID09PSBsYWJlbEtleSkge1xuICAgICAgICByZXR1cm4gcnNjcmF0Y2goJ2xhYmVsV3JhcENhY2hlZFRleHQnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHp3c3AgPSBcIlxcdTIwMEJcIjtcbiAgICAgIHZhciBsaW5lcyA9IHRleHQuc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIG1heFcgPSBlbGUucHN0eWxlKCd0ZXh0LW1heC13aWR0aCcpLnBmVmFsdWU7XG4gICAgICB2YXIgb3ZlcmZsb3cgPSBlbGUucHN0eWxlKCd0ZXh0LW92ZXJmbG93LXdyYXAnKS52YWx1ZTtcbiAgICAgIHZhciBvdmVyZmxvd0FueSA9IG92ZXJmbG93ID09PSAnYW55d2hlcmUnO1xuICAgICAgdmFyIHdyYXBwZWRMaW5lcyA9IFtdO1xuICAgICAgdmFyIHdvcmRzUmVnZXggPSAvW1xcc1xcdTIwMGJdKy87XG4gICAgICB2YXIgd29yZFNlcGFyYXRvciA9IG92ZXJmbG93QW55ID8gJycgOiAnICc7XG5cbiAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgbGluZXMubGVuZ3RoOyBsKyspIHtcbiAgICAgICAgdmFyIGxpbmUgPSBsaW5lc1tsXTtcbiAgICAgICAgdmFyIGxpbmVEaW1zID0gdGhpcy5jYWxjdWxhdGVMYWJlbERpbWVuc2lvbnMoZWxlLCBsaW5lKTtcbiAgICAgICAgdmFyIGxpbmVXID0gbGluZURpbXMud2lkdGg7XG5cbiAgICAgICAgaWYgKG92ZXJmbG93QW55KSB7XG4gICAgICAgICAgdmFyIHByb2Nlc3NlZExpbmUgPSBsaW5lLnNwbGl0KCcnKS5qb2luKHp3c3ApO1xuICAgICAgICAgIGxpbmUgPSBwcm9jZXNzZWRMaW5lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpbmVXID4gbWF4Vykge1xuICAgICAgICAgIC8vIGxpbmUgaXMgdG9vIGxvbmdcbiAgICAgICAgICB2YXIgd29yZHMgPSBsaW5lLnNwbGl0KHdvcmRzUmVnZXgpO1xuICAgICAgICAgIHZhciBzdWJsaW5lID0gJyc7XG5cbiAgICAgICAgICBmb3IgKHZhciB3ID0gMDsgdyA8IHdvcmRzLmxlbmd0aDsgdysrKSB7XG4gICAgICAgICAgICB2YXIgd29yZCA9IHdvcmRzW3ddO1xuICAgICAgICAgICAgdmFyIHRlc3RMaW5lID0gc3VibGluZS5sZW5ndGggPT09IDAgPyB3b3JkIDogc3VibGluZSArIHdvcmRTZXBhcmF0b3IgKyB3b3JkO1xuICAgICAgICAgICAgdmFyIHRlc3REaW1zID0gdGhpcy5jYWxjdWxhdGVMYWJlbERpbWVuc2lvbnMoZWxlLCB0ZXN0TGluZSk7XG4gICAgICAgICAgICB2YXIgdGVzdFcgPSB0ZXN0RGltcy53aWR0aDtcblxuICAgICAgICAgICAgaWYgKHRlc3RXIDw9IG1heFcpIHtcbiAgICAgICAgICAgICAgLy8gd29yZCBmaXRzIG9uIGN1cnJlbnQgbGluZVxuICAgICAgICAgICAgICBzdWJsaW5lICs9IHdvcmQgKyB3b3JkU2VwYXJhdG9yO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gd29yZCBzdGFydHMgbmV3IGxpbmVcbiAgICAgICAgICAgICAgaWYgKHN1YmxpbmUpIHtcbiAgICAgICAgICAgICAgICB3cmFwcGVkTGluZXMucHVzaChzdWJsaW5lKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHN1YmxpbmUgPSB3b3JkICsgd29yZFNlcGFyYXRvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIGlmIHRoZXJlJ3MgcmVtYWluaW5nIHRleHQsIHB1dCBpdCBpbiBhIHdyYXBwZWQgbGluZVxuXG5cbiAgICAgICAgICBpZiAoIXN1YmxpbmUubWF0Y2goL15bXFxzXFx1MjAwYl0rJC8pKSB7XG4gICAgICAgICAgICB3cmFwcGVkTGluZXMucHVzaChzdWJsaW5lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbGluZSBpcyBhbHJlYWR5IHNob3J0IGVub3VnaFxuICAgICAgICAgIHdyYXBwZWRMaW5lcy5wdXNoKGxpbmUpO1xuICAgICAgICB9XG4gICAgICB9IC8vIGZvclxuXG5cbiAgICAgIHJzY3JhdGNoKCdsYWJlbFdyYXBDYWNoZWRMaW5lcycsIHdyYXBwZWRMaW5lcyk7XG4gICAgICB0ZXh0ID0gcnNjcmF0Y2goJ2xhYmVsV3JhcENhY2hlZFRleHQnLCB3cmFwcGVkTGluZXMuam9pbignXFxuJykpO1xuICAgICAgcnNjcmF0Y2goJ2xhYmVsV3JhcEtleScsIGxhYmVsS2V5KTtcbiAgICB9IGVsc2UgaWYgKHdyYXBTdHlsZSA9PT0gJ2VsbGlwc2lzJykge1xuICAgICAgdmFyIF9tYXhXID0gZWxlLnBzdHlsZSgndGV4dC1tYXgtd2lkdGgnKS5wZlZhbHVlO1xuICAgICAgdmFyIGVsbGlwc2l6ZWQgPSAnJztcbiAgICAgIHZhciBlbGxpcHNpcyA9IFwiXFx1MjAyNlwiO1xuICAgICAgdmFyIGluY0xhc3RDaCA9IGZhbHNlO1xuXG4gICAgICBpZiAodGhpcy5jYWxjdWxhdGVMYWJlbERpbWVuc2lvbnMoZWxlLCB0ZXh0KS53aWR0aCA8IF9tYXhXKSB7XG4gICAgICAgIC8vIHRoZSBsYWJlbCBhbHJlYWR5IGZpdHNcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgd2lkdGhXaXRoTmV4dENoID0gdGhpcy5jYWxjdWxhdGVMYWJlbERpbWVuc2lvbnMoZWxlLCBlbGxpcHNpemVkICsgdGV4dFtpXSArIGVsbGlwc2lzKS53aWR0aDtcblxuICAgICAgICBpZiAod2lkdGhXaXRoTmV4dENoID4gX21heFcpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGVsbGlwc2l6ZWQgKz0gdGV4dFtpXTtcblxuICAgICAgICBpZiAoaSA9PT0gdGV4dC5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgaW5jTGFzdENoID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWluY0xhc3RDaCkge1xuICAgICAgICBlbGxpcHNpemVkICs9IGVsbGlwc2lzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZWxsaXBzaXplZDtcbiAgICB9IC8vIGlmIGVsbGlwc2l6ZVxuXG5cbiAgICByZXR1cm4gdGV4dDtcbiAgfTtcblxuICBCUnAkOS5nZXRMYWJlbEp1c3RpZmljYXRpb24gPSBmdW5jdGlvbiAoZWxlKSB7XG4gICAgdmFyIGp1c3RpZmljYXRpb24gPSBlbGUucHN0eWxlKCd0ZXh0LWp1c3RpZmljYXRpb24nKS5zdHJWYWx1ZTtcbiAgICB2YXIgdGV4dEhhbGlnbiA9IGVsZS5wc3R5bGUoJ3RleHQtaGFsaWduJykuc3RyVmFsdWU7XG5cbiAgICBpZiAoanVzdGlmaWNhdGlvbiA9PT0gJ2F1dG8nKSB7XG4gICAgICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgICAgIHN3aXRjaCAodGV4dEhhbGlnbikge1xuICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgcmV0dXJuICdyaWdodCc7XG5cbiAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICByZXR1cm4gJ2xlZnQnO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAnY2VudGVyJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICdjZW50ZXInO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ganVzdGlmaWNhdGlvbjtcbiAgICB9XG4gIH07XG5cbiAgQlJwJDkuY2FsY3VsYXRlTGFiZWxEaW1lbnNpb25zID0gZnVuY3Rpb24gKGVsZSwgdGV4dCkge1xuICAgIHZhciByID0gdGhpcztcbiAgICB2YXIgY2FjaGVLZXkgPSBoYXNoU3RyaW5nKHRleHQsIGVsZS5fcHJpdmF0ZS5sYWJlbERpbXNLZXkpO1xuICAgIHZhciBjYWNoZSA9IHIubGFiZWxEaW1DYWNoZSB8fCAoci5sYWJlbERpbUNhY2hlID0gW10pO1xuICAgIHZhciBleGlzdGluZ1ZhbCA9IGNhY2hlW2NhY2hlS2V5XTtcblxuICAgIGlmIChleGlzdGluZ1ZhbCAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gZXhpc3RpbmdWYWw7XG4gICAgfVxuXG4gICAgdmFyIHBhZGRpbmcgPSAwOyAvLyBhZGQgcGFkZGluZyBhcm91bmQgdGV4dCBkaW1zLCBhcyB0aGUgbWVhc3VyZW1lbnQgaXNuJ3QgdGhhdCBhY2N1cmF0ZVxuXG4gICAgdmFyIGZTdHlsZSA9IGVsZS5wc3R5bGUoJ2ZvbnQtc3R5bGUnKS5zdHJWYWx1ZTtcbiAgICB2YXIgc2l6ZSA9IGVsZS5wc3R5bGUoJ2ZvbnQtc2l6ZScpLnBmVmFsdWU7XG4gICAgdmFyIGZhbWlseSA9IGVsZS5wc3R5bGUoJ2ZvbnQtZmFtaWx5Jykuc3RyVmFsdWU7XG4gICAgdmFyIHdlaWdodCA9IGVsZS5wc3R5bGUoJ2ZvbnQtd2VpZ2h0Jykuc3RyVmFsdWU7XG4gICAgdmFyIGNhbnZhcyA9IHRoaXMubGFiZWxDYWxjQ2FudmFzO1xuICAgIHZhciBjMmQgPSB0aGlzLmxhYmVsQ2FsY0NhbnZhc0NvbnRleHQ7XG5cbiAgICBpZiAoIWNhbnZhcykge1xuICAgICAgY2FudmFzID0gdGhpcy5sYWJlbENhbGNDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgIGMyZCA9IHRoaXMubGFiZWxDYWxjQ2FudmFzQ29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgdmFyIGRzID0gY2FudmFzLnN0eWxlO1xuICAgICAgZHMucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgZHMubGVmdCA9ICctOTk5OXB4JztcbiAgICAgIGRzLnRvcCA9ICctOTk5OXB4JztcbiAgICAgIGRzLnpJbmRleCA9ICctMSc7XG4gICAgICBkcy52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICBkcy5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICAgIH1cblxuICAgIGMyZC5mb250ID0gXCJcIi5jb25jYXQoZlN0eWxlLCBcIiBcIikuY29uY2F0KHdlaWdodCwgXCIgXCIpLmNvbmNhdChzaXplLCBcInB4IFwiKS5jb25jYXQoZmFtaWx5KTtcbiAgICB2YXIgd2lkdGggPSAwO1xuICAgIHZhciBoZWlnaHQgPSAwO1xuICAgIHZhciBsaW5lcyA9IHRleHQuc3BsaXQoJ1xcbicpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGxpbmUgPSBsaW5lc1tpXTtcbiAgICAgIHZhciBtZXRyaWNzID0gYzJkLm1lYXN1cmVUZXh0KGxpbmUpO1xuICAgICAgdmFyIHcgPSBNYXRoLmNlaWwobWV0cmljcy53aWR0aCk7XG4gICAgICB2YXIgaCA9IHNpemU7XG4gICAgICB3aWR0aCA9IE1hdGgubWF4KHcsIHdpZHRoKTtcbiAgICAgIGhlaWdodCArPSBoO1xuICAgIH1cblxuICAgIHdpZHRoICs9IHBhZGRpbmc7XG4gICAgaGVpZ2h0ICs9IHBhZGRpbmc7XG4gICAgcmV0dXJuIGNhY2hlW2NhY2hlS2V5XSA9IHtcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgfTtcbiAgfTtcblxuICBCUnAkOS5jYWxjdWxhdGVMYWJlbEFuZ2xlID0gZnVuY3Rpb24gKGVsZSwgcHJlZml4KSB7XG4gICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgIHZhciBycyA9IF9wLnJzY3JhdGNoO1xuICAgIHZhciBpc0VkZ2UgPSBlbGUuaXNFZGdlKCk7XG4gICAgdmFyIHByZWZpeERhc2ggPSBwcmVmaXggPyBwcmVmaXggKyAnLScgOiAnJztcbiAgICB2YXIgcm90ID0gZWxlLnBzdHlsZShwcmVmaXhEYXNoICsgJ3RleHQtcm90YXRpb24nKTtcbiAgICB2YXIgcm90U3RyID0gcm90LnN0clZhbHVlO1xuXG4gICAgaWYgKHJvdFN0ciA9PT0gJ25vbmUnKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2UgaWYgKGlzRWRnZSAmJiByb3RTdHIgPT09ICdhdXRvcm90YXRlJykge1xuICAgICAgcmV0dXJuIHJzLmxhYmVsQXV0b0FuZ2xlO1xuICAgIH0gZWxzZSBpZiAocm90U3RyID09PSAnYXV0b3JvdGF0ZScpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcm90LnBmVmFsdWU7XG4gICAgfVxuICB9O1xuXG4gIEJScCQ5LmNhbGN1bGF0ZUxhYmVsQW5nbGVzID0gZnVuY3Rpb24gKGVsZSkge1xuICAgIHZhciByID0gdGhpcztcbiAgICB2YXIgaXNFZGdlID0gZWxlLmlzRWRnZSgpO1xuICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICB2YXIgcnMgPSBfcC5yc2NyYXRjaDtcbiAgICBycy5sYWJlbEFuZ2xlID0gci5jYWxjdWxhdGVMYWJlbEFuZ2xlKGVsZSk7XG5cbiAgICBpZiAoaXNFZGdlKSB7XG4gICAgICBycy5zb3VyY2VMYWJlbEFuZ2xlID0gci5jYWxjdWxhdGVMYWJlbEFuZ2xlKGVsZSwgJ3NvdXJjZScpO1xuICAgICAgcnMudGFyZ2V0TGFiZWxBbmdsZSA9IHIuY2FsY3VsYXRlTGFiZWxBbmdsZShlbGUsICd0YXJnZXQnKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIEJScCQ4ID0ge307XG4gIHZhciBUT09fU01BTExfQ1VUX1JFQ1QgPSAyODtcbiAgdmFyIHdhcm5lZEN1dFJlY3QgPSBmYWxzZTtcblxuICBCUnAkOC5nZXROb2RlU2hhcGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIHZhciByID0gdGhpcztcbiAgICB2YXIgc2hhcGUgPSBub2RlLnBzdHlsZSgnc2hhcGUnKS52YWx1ZTtcblxuICAgIGlmIChzaGFwZSA9PT0gJ2N1dHJlY3RhbmdsZScgJiYgKG5vZGUud2lkdGgoKSA8IFRPT19TTUFMTF9DVVRfUkVDVCB8fCBub2RlLmhlaWdodCgpIDwgVE9PX1NNQUxMX0NVVF9SRUNUKSkge1xuICAgICAgaWYgKCF3YXJuZWRDdXRSZWN0KSB7XG4gICAgICAgIHdhcm4oJ1RoZSBgY3V0cmVjdGFuZ2xlYCBub2RlIHNoYXBlIGNhbiBub3QgYmUgdXNlZCBhdCBzbWFsbCBzaXplcyBzbyBgcmVjdGFuZ2xlYCBpcyB1c2VkIGluc3RlYWQnKTtcbiAgICAgICAgd2FybmVkQ3V0UmVjdCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAncmVjdGFuZ2xlJztcbiAgICB9XG5cbiAgICBpZiAobm9kZS5pc1BhcmVudCgpKSB7XG4gICAgICBpZiAoc2hhcGUgPT09ICdyZWN0YW5nbGUnIHx8IHNoYXBlID09PSAncm91bmRyZWN0YW5nbGUnIHx8IHNoYXBlID09PSAncm91bmQtcmVjdGFuZ2xlJyB8fCBzaGFwZSA9PT0gJ2N1dHJlY3RhbmdsZScgfHwgc2hhcGUgPT09ICdjdXQtcmVjdGFuZ2xlJyB8fCBzaGFwZSA9PT0gJ2JhcnJlbCcpIHtcbiAgICAgICAgcmV0dXJuIHNoYXBlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICdyZWN0YW5nbGUnO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzaGFwZSA9PT0gJ3BvbHlnb24nKSB7XG4gICAgICB2YXIgcG9pbnRzID0gbm9kZS5wc3R5bGUoJ3NoYXBlLXBvbHlnb24tcG9pbnRzJykudmFsdWU7XG4gICAgICByZXR1cm4gci5ub2RlU2hhcGVzLm1ha2VQb2x5Z29uKHBvaW50cykubmFtZTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2hhcGU7XG4gIH07XG5cbiAgdmFyIEJScCQ3ID0ge307XG5cbiAgQlJwJDcucmVnaXN0ZXJDYWxjdWxhdGlvbkxpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY3kgPSB0aGlzLmN5O1xuICAgIHZhciBlbGVzVG9VcGRhdGUgPSBjeS5jb2xsZWN0aW9uKCk7XG4gICAgdmFyIHIgPSB0aGlzO1xuXG4gICAgdmFyIGVucXVldWUgPSBmdW5jdGlvbiBlbnF1ZXVlKGVsZXMpIHtcbiAgICAgIHZhciBkaXJ0eVN0eWxlQ2FjaGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICAgICAgZWxlc1RvVXBkYXRlLm1lcmdlKGVsZXMpO1xuXG4gICAgICBpZiAoZGlydHlTdHlsZUNhY2hlcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgICAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgICAgICAgdmFyIHJzdHlsZSA9IF9wLnJzdHlsZTtcbiAgICAgICAgICByc3R5bGUuY2xlYW4gPSBmYWxzZTtcbiAgICAgICAgICByc3R5bGUuY2xlYW5Db25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICByLmJpbmRlcihjeSkub24oJ2JvdW5kcy4qIGRpcnR5LionLCBmdW5jdGlvbiBvbkRpcnR5Qm91bmRzKGUpIHtcbiAgICAgIHZhciBlbGUgPSBlLnRhcmdldDtcbiAgICAgIGVucXVldWUoZWxlKTtcbiAgICB9KS5vbignc3R5bGUuKiBiYWNrZ3JvdW5kLionLCBmdW5jdGlvbiBvbkRpcnR5U3R5bGUoZSkge1xuICAgICAgdmFyIGVsZSA9IGUudGFyZ2V0O1xuICAgICAgZW5xdWV1ZShlbGUsIGZhbHNlKTtcbiAgICB9KTtcblxuICAgIHZhciB1cGRhdGVFbGVDYWxjcyA9IGZ1bmN0aW9uIHVwZGF0ZUVsZUNhbGNzKHdpbGxEcmF3KSB7XG4gICAgICBpZiAod2lsbERyYXcpIHtcbiAgICAgICAgdmFyIGZucyA9IHIub25VcGRhdGVFbGVDYWxjc0ZuczsgLy8gYmVjYXVzZSB3ZSBuZWVkIHRvIGhhdmUgdXAtdG8tZGF0ZSBzdHlsZSAoZS5nLiBzdHlsZXNoZWV0IG1hcHBlcnMpXG4gICAgICAgIC8vIGJlZm9yZSBjYWxjdWxhdGluZyByZW5kZXJlZCBzdHlsZSAoYW5kIHBzdHlsZSBtaWdodCBub3QgYmUgY2FsbGVkIHlldClcblxuICAgICAgICBlbGVzVG9VcGRhdGUuY2xlYW5TdHlsZSgpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlc1RvVXBkYXRlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVsZSA9IGVsZXNUb1VwZGF0ZVtpXTtcbiAgICAgICAgICB2YXIgcnN0eWxlID0gZWxlLl9wcml2YXRlLnJzdHlsZTtcblxuICAgICAgICAgIGlmIChlbGUuaXNOb2RlKCkgJiYgIXJzdHlsZS5jbGVhbkNvbm5lY3RlZCkge1xuICAgICAgICAgICAgZW5xdWV1ZShlbGUuY29ubmVjdGVkRWRnZXMoKSk7XG4gICAgICAgICAgICByc3R5bGUuY2xlYW5Db25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmbnMpIHtcbiAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgZm5zLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGZuID0gZm5zW19pXTtcbiAgICAgICAgICAgIGZuKHdpbGxEcmF3LCBlbGVzVG9VcGRhdGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHIucmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlKGVsZXNUb1VwZGF0ZSk7XG4gICAgICAgIGVsZXNUb1VwZGF0ZSA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgci5mbHVzaFJlbmRlcmVkU3R5bGVRdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHVwZGF0ZUVsZUNhbGNzKHRydWUpO1xuICAgIH07XG5cbiAgICByLmJlZm9yZVJlbmRlcih1cGRhdGVFbGVDYWxjcywgci5iZWZvcmVSZW5kZXJQcmlvcml0aWVzLmVsZUNhbGNzKTtcbiAgfTtcblxuICBCUnAkNy5vblVwZGF0ZUVsZUNhbGNzID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgdmFyIGZucyA9IHRoaXMub25VcGRhdGVFbGVDYWxjc0ZucyA9IHRoaXMub25VcGRhdGVFbGVDYWxjc0ZucyB8fCBbXTtcbiAgICBmbnMucHVzaChmbik7XG4gIH07XG5cbiAgQlJwJDcucmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlID0gZnVuY3Rpb24gKGVsZXMsIHVzZUNhY2hlKSB7XG4gICAgdmFyIGlzQ2xlYW5Db25uZWN0ZWQgPSBmdW5jdGlvbiBpc0NsZWFuQ29ubmVjdGVkKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5fcHJpdmF0ZS5yc3R5bGUuY2xlYW5Db25uZWN0ZWQ7XG4gICAgfTtcblxuICAgIHZhciBlZGdlcyA9IFtdO1xuICAgIHZhciBub2RlcyA9IFtdOyAvLyB0aGUgcmVuZGVyZXIgY2FuJ3QgYmUgdXNlZCBmb3IgY2FsY3Mgd2hlbiBkZXN0cm95ZWQsIGUuZy4gZWxlLmJvdW5kaW5nQm94KClcblxuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gdXNlIGNhY2hlIGJ5IGRlZmF1bHQgZm9yIHBlcmZcblxuXG4gICAgaWYgKHVzZUNhY2hlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHVzZUNhY2hlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgICAgdmFyIHJzdHlsZSA9IF9wLnJzdHlsZTsgLy8gYW4gZWRnZSBtYXkgYmUgaW1wbGljaXRseSBkaXJ0eSBiL2Mgb2Ygb25lIG9mIGl0cyBjb25uZWN0ZWQgbm9kZXNcbiAgICAgIC8vIChhbmQgYSByZXF1ZXN0IGZvciByZWNhbGMgbWF5IGNvbWUgaW4gYmV0d2VlbiBmcmFtZXMpXG5cbiAgICAgIGlmIChlbGUuaXNFZGdlKCkgJiYgKCFpc0NsZWFuQ29ubmVjdGVkKGVsZS5zb3VyY2UoKSkgfHwgIWlzQ2xlYW5Db25uZWN0ZWQoZWxlLnRhcmdldCgpKSkpIHtcbiAgICAgICAgcnN0eWxlLmNsZWFuID0gZmFsc2U7XG4gICAgICB9IC8vIG9ubHkgdXBkYXRlIGlmIGRpcnR5IGFuZCBpbiBncmFwaFxuXG5cbiAgICAgIGlmICh1c2VDYWNoZSAmJiByc3R5bGUuY2xlYW4gfHwgZWxlLnJlbW92ZWQoKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8gb25seSB1cGRhdGUgaWYgbm90IGRpc3BsYXk6IG5vbmVcblxuXG4gICAgICBpZiAoZWxlLnBzdHlsZSgnZGlzcGxheScpLnZhbHVlID09PSAnbm9uZScpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChfcC5ncm91cCA9PT0gJ25vZGVzJykge1xuICAgICAgICBub2Rlcy5wdXNoKGVsZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBlZGdlc1xuICAgICAgICBlZGdlcy5wdXNoKGVsZSk7XG4gICAgICB9XG5cbiAgICAgIHJzdHlsZS5jbGVhbiA9IHRydWU7XG4gICAgfSAvLyB1cGRhdGUgbm9kZSBkYXRhIGZyb20gcHJvamVjdGlvbnNcblxuXG4gICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbm9kZXMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgdmFyIF9lbGUgPSBub2Rlc1tfaTJdO1xuICAgICAgdmFyIF9wMiA9IF9lbGUuX3ByaXZhdGU7XG4gICAgICB2YXIgX3JzdHlsZSA9IF9wMi5yc3R5bGU7XG5cbiAgICAgIHZhciBwb3MgPSBfZWxlLnBvc2l0aW9uKCk7XG5cbiAgICAgIHRoaXMucmVjYWxjdWxhdGVOb2RlTGFiZWxQcm9qZWN0aW9uKF9lbGUpO1xuICAgICAgX3JzdHlsZS5ub2RlWCA9IHBvcy54O1xuICAgICAgX3JzdHlsZS5ub2RlWSA9IHBvcy55O1xuICAgICAgX3JzdHlsZS5ub2RlVyA9IF9lbGUucHN0eWxlKCd3aWR0aCcpLnBmVmFsdWU7XG4gICAgICBfcnN0eWxlLm5vZGVIID0gX2VsZS5wc3R5bGUoJ2hlaWdodCcpLnBmVmFsdWU7XG4gICAgfVxuXG4gICAgdGhpcy5yZWNhbGN1bGF0ZUVkZ2VQcm9qZWN0aW9ucyhlZGdlcyk7IC8vIHVwZGF0ZSBlZGdlIGRhdGEgZnJvbSBwcm9qZWN0aW9uc1xuXG4gICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgZWRnZXMubGVuZ3RoOyBfaTMrKykge1xuICAgICAgdmFyIF9lbGUyID0gZWRnZXNbX2kzXTtcbiAgICAgIHZhciBfcDMgPSBfZWxlMi5fcHJpdmF0ZTtcbiAgICAgIHZhciBfcnN0eWxlMiA9IF9wMy5yc3R5bGU7XG4gICAgICB2YXIgcnMgPSBfcDMucnNjcmF0Y2g7IC8vIHVwZGF0ZSByc3R5bGUgcG9zaXRpb25zXG5cbiAgICAgIF9yc3R5bGUyLnNyY1ggPSBycy5hcnJvd1N0YXJ0WDtcbiAgICAgIF9yc3R5bGUyLnNyY1kgPSBycy5hcnJvd1N0YXJ0WTtcbiAgICAgIF9yc3R5bGUyLnRndFggPSBycy5hcnJvd0VuZFg7XG4gICAgICBfcnN0eWxlMi50Z3RZID0gcnMuYXJyb3dFbmRZO1xuICAgICAgX3JzdHlsZTIubWlkWCA9IHJzLm1pZFg7XG4gICAgICBfcnN0eWxlMi5taWRZID0gcnMubWlkWTtcbiAgICAgIF9yc3R5bGUyLmxhYmVsQW5nbGUgPSBycy5sYWJlbEFuZ2xlO1xuICAgICAgX3JzdHlsZTIuc291cmNlTGFiZWxBbmdsZSA9IHJzLnNvdXJjZUxhYmVsQW5nbGU7XG4gICAgICBfcnN0eWxlMi50YXJnZXRMYWJlbEFuZ2xlID0gcnMudGFyZ2V0TGFiZWxBbmdsZTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIEJScCQ2ID0ge307XG5cbiAgQlJwJDYudXBkYXRlQ2FjaGVkR3JhYmJlZEVsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVsZXMgPSB0aGlzLmNhY2hlZFpTb3J0ZWRFbGVzO1xuXG4gICAgaWYgKCFlbGVzKSB7XG4gICAgICAvLyBqdXN0IGxldCB0aGlzIGJlIHJlY2FsY3VsYXRlZCBvbiB0aGUgbmV4dCB6IHNvcnQgdGlja1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZXMuZHJhZyA9IFtdO1xuICAgIGVsZXMubm9uZHJhZyA9IFtdO1xuICAgIHZhciBncmFiVGFyZ2V0cyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgIHZhciBycyA9IGVsZS5fcHJpdmF0ZS5yc2NyYXRjaDtcblxuICAgICAgaWYgKGVsZS5ncmFiYmVkKCkgJiYgIWVsZS5pc1BhcmVudCgpKSB7XG4gICAgICAgIGdyYWJUYXJnZXRzLnB1c2goZWxlKTtcbiAgICAgIH0gZWxzZSBpZiAocnMuaW5EcmFnTGF5ZXIpIHtcbiAgICAgICAgZWxlcy5kcmFnLnB1c2goZWxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZXMubm9uZHJhZy5wdXNoKGVsZSk7XG4gICAgICB9XG4gICAgfSAvLyBwdXQgdGhlIGdyYWIgdGFyZ2V0IG5vZGVzIGxhc3Qgc28gaXQncyBvbiB0b3Agb2YgaXRzIG5laWdoYm91cmhvb2RcblxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncmFiVGFyZ2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IGdyYWJUYXJnZXRzW2ldO1xuICAgICAgZWxlcy5kcmFnLnB1c2goZWxlKTtcbiAgICB9XG4gIH07XG5cbiAgQlJwJDYuaW52YWxpZGF0ZUNhY2hlZFpTb3J0ZWRFbGVzID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY2FjaGVkWlNvcnRlZEVsZXMgPSBudWxsO1xuICB9O1xuXG4gIEJScCQ2LmdldENhY2hlZFpTb3J0ZWRFbGVzID0gZnVuY3Rpb24gKGZvcmNlUmVjYWxjKSB7XG4gICAgaWYgKGZvcmNlUmVjYWxjIHx8ICF0aGlzLmNhY2hlZFpTb3J0ZWRFbGVzKSB7XG4gICAgICB2YXIgZWxlcyA9IHRoaXMuY3kubXV0YWJsZUVsZW1lbnRzKCkudG9BcnJheSgpO1xuICAgICAgZWxlcy5zb3J0KHpJbmRleFNvcnQpO1xuICAgICAgZWxlcy5pbnRlcmFjdGl2ZSA9IGVsZXMuZmlsdGVyKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgcmV0dXJuIGVsZS5pbnRlcmFjdGl2ZSgpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmNhY2hlZFpTb3J0ZWRFbGVzID0gZWxlcztcbiAgICAgIHRoaXMudXBkYXRlQ2FjaGVkR3JhYmJlZEVsZXMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlcyA9IHRoaXMuY2FjaGVkWlNvcnRlZEVsZXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZXM7XG4gIH07XG5cbiAgdmFyIEJScCQ1ID0ge307XG4gIFtCUnAkZSwgQlJwJGQsIEJScCRjLCBCUnAkYiwgQlJwJGEsIEJScCQ5LCBCUnAkOCwgQlJwJDcsIEJScCQ2XS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wcykge1xuICAgIGV4dGVuZChCUnAkNSwgcHJvcHMpO1xuICB9KTtcblxuICB2YXIgQlJwJDQgPSB7fTtcblxuICBCUnAkNC5nZXRDYWNoZWRJbWFnZSA9IGZ1bmN0aW9uICh1cmwsIGNyb3NzT3JpZ2luLCBvbkxvYWQpIHtcbiAgICB2YXIgciA9IHRoaXM7XG4gICAgdmFyIGltYWdlQ2FjaGUgPSByLmltYWdlQ2FjaGUgPSByLmltYWdlQ2FjaGUgfHwge307XG4gICAgdmFyIGNhY2hlID0gaW1hZ2VDYWNoZVt1cmxdO1xuXG4gICAgaWYgKGNhY2hlKSB7XG4gICAgICBpZiAoIWNhY2hlLmltYWdlLmNvbXBsZXRlKSB7XG4gICAgICAgIGNhY2hlLmltYWdlLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBvbkxvYWQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2FjaGUuaW1hZ2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhY2hlID0gaW1hZ2VDYWNoZVt1cmxdID0gaW1hZ2VDYWNoZVt1cmxdIHx8IHt9O1xuICAgICAgdmFyIGltYWdlID0gY2FjaGUuaW1hZ2UgPSBuZXcgSW1hZ2UoKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4gICAgICBpbWFnZS5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgb25Mb2FkKTtcbiAgICAgIGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBpbWFnZS5lcnJvciA9IHRydWU7XG4gICAgICB9KTsgLy8gIzE1ODIgc2FmYXJpIGRvZXNuJ3QgbG9hZCBkYXRhIHVyaXMgd2l0aCBjcm9zc09yaWdpbiBwcm9wZXJseVxuICAgICAgLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEyMzk3OFxuXG4gICAgICB2YXIgZGF0YVVyaVByZWZpeCA9ICdkYXRhOic7XG4gICAgICB2YXIgaXNEYXRhVXJpID0gdXJsLnN1YnN0cmluZygwLCBkYXRhVXJpUHJlZml4Lmxlbmd0aCkudG9Mb3dlckNhc2UoKSA9PT0gZGF0YVVyaVByZWZpeDtcblxuICAgICAgaWYgKCFpc0RhdGFVcmkpIHtcbiAgICAgICAgLy8gaWYgY3Jvc3NvcmlnaW4gaXMgJ251bGwnKHN0cmluZ2lmaWVkKSwgdGhlbiBtYW51YWxseSBzZXQgaXQgdG8gbnVsbCBcbiAgICAgICAgY3Jvc3NPcmlnaW4gPSBjcm9zc09yaWdpbiA9PT0gJ251bGwnID8gbnVsbCA6IGNyb3NzT3JpZ2luO1xuICAgICAgICBpbWFnZS5jcm9zc09yaWdpbiA9IGNyb3NzT3JpZ2luOyAvLyBwcmV2ZW50IHRhaW50ZWQgY2FudmFzXG4gICAgICB9XG5cbiAgICAgIGltYWdlLnNyYyA9IHVybDtcbiAgICAgIHJldHVybiBpbWFnZTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIEJScCQzID0ge307XG4gIC8qIGdsb2JhbCBkb2N1bWVudCwgd2luZG93LCBSZXNpemVPYnNlcnZlciwgTXV0YXRpb25PYnNlcnZlciAqL1xuXG4gIEJScCQzLnJlZ2lzdGVyQmluZGluZyA9IGZ1bmN0aW9uICh0YXJnZXQsIGV2ZW50LCBoYW5kbGVyLCB1c2VDYXB0dXJlKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGFyZ3VtZW50cywgWzFdKTsgLy8gY29weVxuXG4gICAgdmFyIGIgPSB0aGlzLmJpbmRlcih0YXJnZXQpO1xuICAgIHJldHVybiBiLm9uLmFwcGx5KGIsIGFyZ3MpO1xuICB9O1xuXG4gIEJScCQzLmJpbmRlciA9IGZ1bmN0aW9uICh0Z3QpIHtcbiAgICB2YXIgciA9IHRoaXM7XG4gICAgdmFyIHRndElzRG9tID0gdGd0ID09PSB3aW5kb3cgfHwgdGd0ID09PSBkb2N1bWVudCB8fCB0Z3QgPT09IGRvY3VtZW50LmJvZHkgfHwgZG9tRWxlbWVudCh0Z3QpO1xuXG4gICAgaWYgKHIuc3VwcG9ydHNQYXNzaXZlRXZlbnRzID09IG51bGwpIHtcbiAgICAgIC8vIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL1dJQ0cvRXZlbnRMaXN0ZW5lck9wdGlvbnMvYmxvYi9naC1wYWdlcy9leHBsYWluZXIubWQjZmVhdHVyZS1kZXRlY3Rpb25cbiAgICAgIHZhciBzdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIG9wdHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdwYXNzaXZlJywge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgc3VwcG9ydHNQYXNzaXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0JywgbnVsbCwgb3B0cyk7XG4gICAgICB9IGNhdGNoIChlcnIpIHsvLyBub3Qgc3VwcG9ydGVkXG4gICAgICB9XG5cbiAgICAgIHIuc3VwcG9ydHNQYXNzaXZlRXZlbnRzID0gc3VwcG9ydHNQYXNzaXZlO1xuICAgIH1cblxuICAgIHZhciBvbiA9IGZ1bmN0aW9uIG9uKGV2ZW50LCBoYW5kbGVyLCB1c2VDYXB0dXJlKSB7XG4gICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgICAgIGlmICh0Z3RJc0RvbSAmJiByLnN1cHBvcnRzUGFzc2l2ZUV2ZW50cykge1xuICAgICAgICAvLyByZXBsYWNlIHVzZUNhcHR1cmUgdy8gb3B0cyBvYmpcbiAgICAgICAgYXJnc1syXSA9IHtcbiAgICAgICAgICBjYXB0dXJlOiB1c2VDYXB0dXJlICE9IG51bGwgPyB1c2VDYXB0dXJlIDogZmFsc2UsXG4gICAgICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICAgICAgb25jZTogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgci5iaW5kaW5ncy5wdXNoKHtcbiAgICAgICAgdGFyZ2V0OiB0Z3QsXG4gICAgICAgIGFyZ3M6IGFyZ3NcbiAgICAgIH0pO1xuICAgICAgKHRndC5hZGRFdmVudExpc3RlbmVyIHx8IHRndC5vbikuYXBwbHkodGd0LCBhcmdzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICByZXR1cm4ge1xuICAgICAgb246IG9uLFxuICAgICAgYWRkRXZlbnRMaXN0ZW5lcjogb24sXG4gICAgICBhZGRMaXN0ZW5lcjogb24sXG4gICAgICBiaW5kOiBvblxuICAgIH07XG4gIH07XG5cbiAgQlJwJDMubm9kZUlzRHJhZ2dhYmxlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZSAmJiBub2RlLmlzTm9kZSgpICYmICFub2RlLmxvY2tlZCgpICYmIG5vZGUuZ3JhYmJhYmxlKCk7XG4gIH07XG5cbiAgQlJwJDMubm9kZUlzR3JhYmJhYmxlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlSXNEcmFnZ2FibGUobm9kZSkgJiYgbm9kZS5pbnRlcmFjdGl2ZSgpO1xuICB9O1xuXG4gIEJScCQzLmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHIgPSB0aGlzO1xuXG4gICAgdmFyIGlzU2VsZWN0ZWQgPSBmdW5jdGlvbiBpc1NlbGVjdGVkKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5zZWxlY3RlZCgpO1xuICAgIH07XG5cbiAgICB2YXIgdHJpZ2dlckV2ZW50cyA9IGZ1bmN0aW9uIHRyaWdnZXJFdmVudHModGFyZ2V0LCBuYW1lcywgZSwgcG9zaXRpb24pIHtcbiAgICAgIGlmICh0YXJnZXQgPT0gbnVsbCkge1xuICAgICAgICB0YXJnZXQgPSByLmN5O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBuYW1lID0gbmFtZXNbaV07XG4gICAgICAgIHRhcmdldC5lbWl0KHtcbiAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgIHR5cGU6IG5hbWUsXG4gICAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgaXNNdWx0U2VsS2V5RG93biA9IGZ1bmN0aW9uIGlzTXVsdFNlbEtleURvd24oZSkge1xuICAgICAgcmV0dXJuIGUuc2hpZnRLZXkgfHwgZS5tZXRhS2V5IHx8IGUuY3RybEtleTsgLy8gbWF5YmUgZS5hbHRLZXlcbiAgICB9O1xuXG4gICAgdmFyIGFsbG93UGFubmluZ1Bhc3N0aHJvdWdoID0gZnVuY3Rpb24gYWxsb3dQYW5uaW5nUGFzc3Rocm91Z2goZG93biwgZG93bnMpIHtcbiAgICAgIHZhciBhbGxvd1Bhc3N0aHJvdWdoID0gdHJ1ZTtcblxuICAgICAgaWYgKHIuY3kuaGFzQ29tcG91bmROb2RlcygpICYmIGRvd24gJiYgZG93bi5wYW5uYWJsZSgpKSB7XG4gICAgICAgIC8vIGEgZ3JhYmJhYmxlIGNvbXBvdW5kIG5vZGUgYmVsb3cgdGhlIGVsZSA9PiBubyBwYXNzdGhyb3VnaCBwYW5uaW5nXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBkb3ducyAmJiBpIDwgZG93bnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZG93biA9IGRvd25zW2ldOyAvL2lmIGFueSBwYXJlbnQgbm9kZSBpbiBldmVudCBoaWVyYXJjaHkgaXNuJ3QgcGFubmFibGUsIHJlamVjdCBwYXNzdGhyb3VnaFxuXG4gICAgICAgICAgaWYgKGRvd24uaXNOb2RlKCkgJiYgZG93bi5pc1BhcmVudCgpICYmICFkb3duLnBhbm5hYmxlKCkpIHtcbiAgICAgICAgICAgIGFsbG93UGFzc3Rocm91Z2ggPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWxsb3dQYXNzdGhyb3VnaCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhbGxvd1Bhc3N0aHJvdWdoO1xuICAgIH07XG5cbiAgICB2YXIgc2V0R3JhYmJlZCA9IGZ1bmN0aW9uIHNldEdyYWJiZWQoZWxlKSB7XG4gICAgICBlbGVbMF0uX3ByaXZhdGUuZ3JhYmJlZCA9IHRydWU7XG4gICAgfTtcblxuICAgIHZhciBzZXRGcmVlZCA9IGZ1bmN0aW9uIHNldEZyZWVkKGVsZSkge1xuICAgICAgZWxlWzBdLl9wcml2YXRlLmdyYWJiZWQgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgdmFyIHNldEluRHJhZ0xheWVyID0gZnVuY3Rpb24gc2V0SW5EcmFnTGF5ZXIoZWxlKSB7XG4gICAgICBlbGVbMF0uX3ByaXZhdGUucnNjcmF0Y2guaW5EcmFnTGF5ZXIgPSB0cnVlO1xuICAgIH07XG5cbiAgICB2YXIgc2V0T3V0RHJhZ0xheWVyID0gZnVuY3Rpb24gc2V0T3V0RHJhZ0xheWVyKGVsZSkge1xuICAgICAgZWxlWzBdLl9wcml2YXRlLnJzY3JhdGNoLmluRHJhZ0xheWVyID0gZmFsc2U7XG4gICAgfTtcblxuICAgIHZhciBzZXRHcmFiVGFyZ2V0ID0gZnVuY3Rpb24gc2V0R3JhYlRhcmdldChlbGUpIHtcbiAgICAgIGVsZVswXS5fcHJpdmF0ZS5yc2NyYXRjaC5pc0dyYWJUYXJnZXQgPSB0cnVlO1xuICAgIH07XG5cbiAgICB2YXIgcmVtb3ZlR3JhYlRhcmdldCA9IGZ1bmN0aW9uIHJlbW92ZUdyYWJUYXJnZXQoZWxlKSB7XG4gICAgICBlbGVbMF0uX3ByaXZhdGUucnNjcmF0Y2guaXNHcmFiVGFyZ2V0ID0gZmFsc2U7XG4gICAgfTtcblxuICAgIHZhciBhZGRUb0RyYWdMaXN0ID0gZnVuY3Rpb24gYWRkVG9EcmFnTGlzdChlbGUsIG9wdHMpIHtcbiAgICAgIHZhciBsaXN0ID0gb3B0cy5hZGRUb0xpc3Q7XG4gICAgICB2YXIgbGlzdEhhc0VsZSA9IGxpc3QuaGFzKGVsZSk7XG5cbiAgICAgIGlmICghbGlzdEhhc0VsZSAmJiBlbGUuZ3JhYmJhYmxlKCkgJiYgIWVsZS5sb2NrZWQoKSkge1xuICAgICAgICBsaXN0Lm1lcmdlKGVsZSk7XG4gICAgICAgIHNldEdyYWJiZWQoZWxlKTtcbiAgICAgIH1cbiAgICB9OyAvLyBoZWxwZXIgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIHdoaWNoIGNoaWxkIG5vZGVzIGFuZCBpbm5lciBlZGdlc1xuICAgIC8vIG9mIGEgY29tcG91bmQgbm9kZSB0byBiZSBkcmFnZ2VkIGFzIHdlbGwgYXMgdGhlIGdyYWJiZWQgYW5kIHNlbGVjdGVkIG5vZGVzXG5cblxuICAgIHZhciBhZGREZXNjZW5kYW50c1RvRHJhZyA9IGZ1bmN0aW9uIGFkZERlc2NlbmRhbnRzVG9EcmFnKG5vZGUsIG9wdHMpIHtcbiAgICAgIGlmICghbm9kZS5jeSgpLmhhc0NvbXBvdW5kTm9kZXMoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRzLmluRHJhZ0xheWVyID09IG51bGwgJiYgb3B0cy5hZGRUb0xpc3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIG5vdGhpbmcgdG8gZG9cblxuXG4gICAgICB2YXIgaW5uZXJOb2RlcyA9IG5vZGUuZGVzY2VuZGFudHMoKTtcblxuICAgICAgaWYgKG9wdHMuaW5EcmFnTGF5ZXIpIHtcbiAgICAgICAgaW5uZXJOb2Rlcy5mb3JFYWNoKHNldEluRHJhZ0xheWVyKTtcbiAgICAgICAgaW5uZXJOb2Rlcy5jb25uZWN0ZWRFZGdlcygpLmZvckVhY2goc2V0SW5EcmFnTGF5ZXIpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0cy5hZGRUb0xpc3QpIHtcbiAgICAgICAgYWRkVG9EcmFnTGlzdChpbm5lck5vZGVzLCBvcHRzKTtcbiAgICAgIH1cbiAgICB9OyAvLyBhZGRzIHRoZSBnaXZlbiBub2RlcyBhbmQgaXRzIG5laWdoYm91cmhvb2QgdG8gdGhlIGRyYWcgbGF5ZXJcblxuXG4gICAgdmFyIGFkZE5vZGVzVG9EcmFnID0gZnVuY3Rpb24gYWRkTm9kZXNUb0RyYWcobm9kZXMsIG9wdHMpIHtcbiAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgICAgdmFyIGhhc0NvbXBvdW5kTm9kZXMgPSBub2Rlcy5jeSgpLmhhc0NvbXBvdW5kTm9kZXMoKTtcblxuICAgICAgaWYgKG9wdHMuaW5EcmFnTGF5ZXIpIHtcbiAgICAgICAgbm9kZXMuZm9yRWFjaChzZXRJbkRyYWdMYXllcik7XG4gICAgICAgIG5vZGVzLm5laWdoYm9yaG9vZCgpLnN0ZEZpbHRlcihmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgICAgcmV0dXJuICFoYXNDb21wb3VuZE5vZGVzIHx8IGVsZS5pc0VkZ2UoKTtcbiAgICAgICAgfSkuZm9yRWFjaChzZXRJbkRyYWdMYXllcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRzLmFkZFRvTGlzdCkge1xuICAgICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgICBhZGRUb0RyYWdMaXN0KGVsZSwgb3B0cyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBhZGREZXNjZW5kYW50c1RvRHJhZyhub2Rlcywgb3B0cyk7IC8vIGFsd2F5cyBhZGQgdG8gZHJhZ1xuICAgICAgLy8gYWxzbyBhZGQgbm9kZXMgYW5kIGVkZ2VzIHJlbGF0ZWQgdG8gdGhlIHRvcG1vc3QgYW5jZXN0b3JcblxuICAgICAgdXBkYXRlQW5jZXN0b3JzSW5EcmFnTGF5ZXIobm9kZXMsIHtcbiAgICAgICAgaW5EcmFnTGF5ZXI6IG9wdHMuaW5EcmFnTGF5ZXJcbiAgICAgIH0pO1xuICAgICAgci51cGRhdGVDYWNoZWRHcmFiYmVkRWxlcygpO1xuICAgIH07XG5cbiAgICB2YXIgYWRkTm9kZVRvRHJhZyA9IGFkZE5vZGVzVG9EcmFnO1xuXG4gICAgdmFyIGZyZWVEcmFnZ2VkRWxlbWVudHMgPSBmdW5jdGlvbiBmcmVlRHJhZ2dlZEVsZW1lbnRzKGdyYWJiZWRFbGVzKSB7XG4gICAgICBpZiAoIWdyYWJiZWRFbGVzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8ganVzdCBnbyBvdmVyIGFsbCBlbGVtZW50cyByYXRoZXIgdGhhbiBkb2luZyBhIGJ1bmNoIG9mIChwb3NzaWJseSBleHBlbnNpdmUpIHRyYXZlcnNhbHNcblxuXG4gICAgICByLmdldENhY2hlZFpTb3J0ZWRFbGVzKCkuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgIHNldEZyZWVkKGVsZSk7XG4gICAgICAgIHNldE91dERyYWdMYXllcihlbGUpO1xuICAgICAgICByZW1vdmVHcmFiVGFyZ2V0KGVsZSk7XG4gICAgICB9KTtcbiAgICAgIHIudXBkYXRlQ2FjaGVkR3JhYmJlZEVsZXMoKTtcbiAgICB9OyAvLyBoZWxwZXIgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIHdoaWNoIGFuY2VzdG9yIG5vZGVzIGFuZCBlZGdlcyBzaG91bGQgZ29cbiAgICAvLyB0byB0aGUgZHJhZyBsYXllciAob3Igc2hvdWxkIGJlIHJlbW92ZWQgZnJvbSBkcmFnIGxheWVyKS5cblxuXG4gICAgdmFyIHVwZGF0ZUFuY2VzdG9yc0luRHJhZ0xheWVyID0gZnVuY3Rpb24gdXBkYXRlQW5jZXN0b3JzSW5EcmFnTGF5ZXIobm9kZSwgb3B0cykge1xuICAgICAgaWYgKG9wdHMuaW5EcmFnTGF5ZXIgPT0gbnVsbCAmJiBvcHRzLmFkZFRvTGlzdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gbm90aGluZyB0byBkb1xuXG5cbiAgICAgIGlmICghbm9kZS5jeSgpLmhhc0NvbXBvdW5kTm9kZXMoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIGZpbmQgdG9wLWxldmVsIHBhcmVudFxuXG5cbiAgICAgIHZhciBwYXJlbnQgPSBub2RlLmFuY2VzdG9ycygpLm9ycGhhbnMoKTsgLy8gbm8gcGFyZW50IG5vZGU6IG5vIG5vZGVzIHRvIGFkZCB0byB0aGUgZHJhZyBsYXllclxuXG4gICAgICBpZiAocGFyZW50LnNhbWUobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgbm9kZXMgPSBwYXJlbnQuZGVzY2VuZGFudHMoKS5zcGF3blNlbGYoKS5tZXJnZShwYXJlbnQpLnVubWVyZ2Uobm9kZSkudW5tZXJnZShub2RlLmRlc2NlbmRhbnRzKCkpO1xuICAgICAgdmFyIGVkZ2VzID0gbm9kZXMuY29ubmVjdGVkRWRnZXMoKTtcblxuICAgICAgaWYgKG9wdHMuaW5EcmFnTGF5ZXIpIHtcbiAgICAgICAgZWRnZXMuZm9yRWFjaChzZXRJbkRyYWdMYXllcik7XG4gICAgICAgIG5vZGVzLmZvckVhY2goc2V0SW5EcmFnTGF5ZXIpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0cy5hZGRUb0xpc3QpIHtcbiAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgICAgYWRkVG9EcmFnTGlzdChlbGUsIG9wdHMpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGJsdXJBY3RpdmVEb21FbGVtZW50ID0gZnVuY3Rpb24gYmx1ckFjdGl2ZURvbUVsZW1lbnQoKSB7XG4gICAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPSBudWxsICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1ciAhPSBudWxsKSB7XG4gICAgICAgIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1cigpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgaGF2ZU11dGF0aW9uc0FwaSA9IHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyICE9PSAndW5kZWZpbmVkJztcbiAgICB2YXIgaGF2ZVJlc2l6ZU9ic2VydmVyQXBpID0gdHlwZW9mIFJlc2l6ZU9ic2VydmVyICE9PSAndW5kZWZpbmVkJzsgLy8gd2F0Y2ggZm9yIHdoZW4gdGhlIGN5IGNvbnRhaW5lciBpcyByZW1vdmVkIGZyb20gdGhlIGRvbVxuXG4gICAgaWYgKGhhdmVNdXRhdGlvbnNBcGkpIHtcbiAgICAgIHIucmVtb3ZlT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbiAobXV0bnMpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG11dG5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIG11dG4gPSBtdXRuc1tpXTtcbiAgICAgICAgICB2YXIgck5vZGVzID0gbXV0bi5yZW1vdmVkTm9kZXM7XG5cbiAgICAgICAgICBpZiAock5vZGVzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJOb2Rlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICB2YXIgck5vZGUgPSByTm9kZXNbal07XG5cbiAgICAgICAgICAgICAgaWYgKHJOb2RlID09PSByLmNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIHIuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKHIuY29udGFpbmVyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgci5yZW1vdmVPYnNlcnZlci5vYnNlcnZlKHIuY29udGFpbmVyLnBhcmVudE5vZGUsIHtcbiAgICAgICAgICBjaGlsZExpc3Q6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAnRE9NTm9kZVJlbW92ZWQnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICAgIHIuZGVzdHJveSgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIG9uUmVzaXplID0gZGVib3VuY2VfMShmdW5jdGlvbiAoKSB7XG4gICAgICByLmN5LnJlc2l6ZSgpO1xuICAgIH0sIDEwMCk7XG5cbiAgICBpZiAoaGF2ZU11dGF0aW9uc0FwaSkge1xuICAgICAgci5zdHlsZU9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIob25SZXNpemUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cbiAgICAgIHIuc3R5bGVPYnNlcnZlci5vYnNlcnZlKHIuY29udGFpbmVyLCB7XG4gICAgICAgIGF0dHJpYnV0ZXM6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gLy8gYXV0byByZXNpemVcblxuXG4gICAgci5yZWdpc3RlckJpbmRpbmcod2luZG93LCAncmVzaXplJywgb25SZXNpemUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cbiAgICBpZiAoaGF2ZVJlc2l6ZU9ic2VydmVyQXBpKSB7XG4gICAgICByLnJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKG9uUmVzaXplKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4gICAgICByLnJlc2l6ZU9ic2VydmVyLm9ic2VydmUoci5jb250YWluZXIpO1xuICAgIH1cblxuICAgIHZhciBmb3JFYWNoVXAgPSBmdW5jdGlvbiBmb3JFYWNoVXAoZG9tRWxlLCBmbikge1xuICAgICAgd2hpbGUgKGRvbUVsZSAhPSBudWxsKSB7XG4gICAgICAgIGZuKGRvbUVsZSk7XG4gICAgICAgIGRvbUVsZSA9IGRvbUVsZS5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgaW52YWxpZGF0ZUNvb3JkcyA9IGZ1bmN0aW9uIGludmFsaWRhdGVDb29yZHMoKSB7XG4gICAgICByLmludmFsaWRhdGVDb250YWluZXJDbGllbnRDb29yZHNDYWNoZSgpO1xuICAgIH07XG5cbiAgICBmb3JFYWNoVXAoci5jb250YWluZXIsIGZ1bmN0aW9uIChkb21FbGUpIHtcbiAgICAgIHIucmVnaXN0ZXJCaW5kaW5nKGRvbUVsZSwgJ3RyYW5zaXRpb25lbmQnLCBpbnZhbGlkYXRlQ29vcmRzKTtcbiAgICAgIHIucmVnaXN0ZXJCaW5kaW5nKGRvbUVsZSwgJ2FuaW1hdGlvbmVuZCcsIGludmFsaWRhdGVDb29yZHMpO1xuICAgICAgci5yZWdpc3RlckJpbmRpbmcoZG9tRWxlLCAnc2Nyb2xsJywgaW52YWxpZGF0ZUNvb3Jkcyk7XG4gICAgfSk7IC8vIHN0b3AgcmlnaHQgY2xpY2sgbWVudSBmcm9tIGFwcGVhcmluZyBvbiBjeVxuXG4gICAgci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICdjb250ZXh0bWVudScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSk7XG5cbiAgICB2YXIgaW5Cb3hTZWxlY3Rpb24gPSBmdW5jdGlvbiBpbkJveFNlbGVjdGlvbigpIHtcbiAgICAgIHJldHVybiByLnNlbGVjdGlvbls0XSAhPT0gMDtcbiAgICB9O1xuXG4gICAgdmFyIGV2ZW50SW5Db250YWluZXIgPSBmdW5jdGlvbiBldmVudEluQ29udGFpbmVyKGUpIHtcbiAgICAgIC8vIHNhdmUgY3ljbGVzIGlmIG1vdXNlIGV2ZW50cyBhcmVuJ3QgdG8gYmUgY2FwdHVyZWRcbiAgICAgIHZhciBjb250YWluZXJQYWdlQ29vcmRzID0gci5maW5kQ29udGFpbmVyQ2xpZW50Q29vcmRzKCk7XG4gICAgICB2YXIgeCA9IGNvbnRhaW5lclBhZ2VDb29yZHNbMF07XG4gICAgICB2YXIgeSA9IGNvbnRhaW5lclBhZ2VDb29yZHNbMV07XG4gICAgICB2YXIgd2lkdGggPSBjb250YWluZXJQYWdlQ29vcmRzWzJdO1xuICAgICAgdmFyIGhlaWdodCA9IGNvbnRhaW5lclBhZ2VDb29yZHNbM107XG4gICAgICB2YXIgcG9zaXRpb25zID0gZS50b3VjaGVzID8gZS50b3VjaGVzIDogW2VdO1xuICAgICAgdmFyIGF0TGVhc3RPbmVQb3NJbnNpZGUgPSBmYWxzZTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb3NpdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHAgPSBwb3NpdGlvbnNbaV07XG5cbiAgICAgICAgaWYgKHggPD0gcC5jbGllbnRYICYmIHAuY2xpZW50WCA8PSB4ICsgd2lkdGggJiYgeSA8PSBwLmNsaWVudFkgJiYgcC5jbGllbnRZIDw9IHkgKyBoZWlnaHQpIHtcbiAgICAgICAgICBhdExlYXN0T25lUG9zSW5zaWRlID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWF0TGVhc3RPbmVQb3NJbnNpZGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGFpbmVyID0gci5jb250YWluZXI7XG4gICAgICB2YXIgdGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgICB2YXIgdFBhcmVudCA9IHRhcmdldC5wYXJlbnROb2RlO1xuICAgICAgdmFyIGNvbnRhaW5lcklzVGFyZ2V0ID0gZmFsc2U7XG5cbiAgICAgIHdoaWxlICh0UGFyZW50KSB7XG4gICAgICAgIGlmICh0UGFyZW50ID09PSBjb250YWluZXIpIHtcbiAgICAgICAgICBjb250YWluZXJJc1RhcmdldCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB0UGFyZW50ID0gdFBhcmVudC5wYXJlbnROb2RlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWNvbnRhaW5lcklzVGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gLy8gaWYgdGFyZ2V0IGlzIG91dGlzZGUgY3kgY29udGFpbmVyLCB0aGVuIHRoaXMgZXZlbnQgaXMgbm90IGZvciB1c1xuXG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07IC8vIFByaW1hcnkga2V5XG5cblxuICAgIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAnbW91c2Vkb3duJywgZnVuY3Rpb24gbW91c2Vkb3duSGFuZGxlcihlKSB7XG4gICAgICBpZiAoIWV2ZW50SW5Db250YWluZXIoZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBibHVyQWN0aXZlRG9tRWxlbWVudCgpO1xuICAgICAgci5ob3ZlckRhdGEuY2FwdHVyZSA9IHRydWU7XG4gICAgICByLmhvdmVyRGF0YS53aGljaCA9IGUud2hpY2g7XG4gICAgICB2YXIgY3kgPSByLmN5O1xuICAgICAgdmFyIGdwb3MgPSBbZS5jbGllbnRYLCBlLmNsaWVudFldO1xuICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChncG9zWzBdLCBncG9zWzFdKTtcbiAgICAgIHZhciBzZWxlY3QgPSByLnNlbGVjdGlvbjtcbiAgICAgIHZhciBuZWFycyA9IHIuZmluZE5lYXJlc3RFbGVtZW50cyhwb3NbMF0sIHBvc1sxXSwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgdmFyIG5lYXIgPSBuZWFyc1swXTtcbiAgICAgIHZhciBkcmFnZ2VkRWxlbWVudHMgPSByLmRyYWdEYXRhLnBvc3NpYmxlRHJhZ0VsZW1lbnRzO1xuICAgICAgci5ob3ZlckRhdGEubWRvd25Qb3MgPSBwb3M7XG4gICAgICByLmhvdmVyRGF0YS5tZG93bkdQb3MgPSBncG9zO1xuXG4gICAgICB2YXIgY2hlY2tGb3JUYXBob2xkID0gZnVuY3Rpb24gY2hlY2tGb3JUYXBob2xkKCkge1xuICAgICAgICByLmhvdmVyRGF0YS50YXBob2xkQ2FuY2VsbGVkID0gZmFsc2U7XG4gICAgICAgIGNsZWFyVGltZW91dChyLmhvdmVyRGF0YS50YXBob2xkVGltZW91dCk7XG4gICAgICAgIHIuaG92ZXJEYXRhLnRhcGhvbGRUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHIuaG92ZXJEYXRhLnRhcGhvbGRDYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGVsZSA9IHIuaG92ZXJEYXRhLmRvd247XG5cbiAgICAgICAgICAgIGlmIChlbGUpIHtcbiAgICAgICAgICAgICAgZWxlLmVtaXQoe1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3RhcGhvbGQnLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY3kuZW1pdCh7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICAgICAgICB0eXBlOiAndGFwaG9sZCcsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCByLnRhcGhvbGREdXJhdGlvbik7XG4gICAgICB9OyAvLyBSaWdodCBjbGljayBidXR0b25cblxuXG4gICAgICBpZiAoZS53aGljaCA9PSAzKSB7XG4gICAgICAgIHIuaG92ZXJEYXRhLmN4dFN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICB2YXIgY3h0RXZ0ID0ge1xuICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgICAgdHlwZTogJ2N4dHRhcHN0YXJ0JyxcbiAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChuZWFyKSB7XG4gICAgICAgICAgbmVhci5hY3RpdmF0ZSgpO1xuICAgICAgICAgIG5lYXIuZW1pdChjeHRFdnQpO1xuICAgICAgICAgIHIuaG92ZXJEYXRhLmRvd24gPSBuZWFyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN5LmVtaXQoY3h0RXZ0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHIuaG92ZXJEYXRhLmRvd25UaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIHIuaG92ZXJEYXRhLmN4dERyYWdnZWQgPSBmYWxzZTsgLy8gUHJpbWFyeSBidXR0b25cbiAgICAgIH0gZWxzZSBpZiAoZS53aGljaCA9PSAxKSB7XG4gICAgICAgIGlmIChuZWFyKSB7XG4gICAgICAgICAgbmVhci5hY3RpdmF0ZSgpO1xuICAgICAgICB9IC8vIEVsZW1lbnQgZHJhZ2dpbmdcblxuXG4gICAgICAgIHtcbiAgICAgICAgICAvLyBJZiBzb21ldGhpbmcgaXMgdW5kZXIgdGhlIGN1cnNvciBhbmQgaXQgaXMgZHJhZ2dhYmxlLCBwcmVwYXJlIHRvIGdyYWIgaXRcbiAgICAgICAgICBpZiAobmVhciAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoci5ub2RlSXNHcmFiYmFibGUobmVhcikpIHtcbiAgICAgICAgICAgICAgdmFyIG1ha2VFdmVudCA9IGZ1bmN0aW9uIG1ha2VFdmVudCh0eXBlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgICAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIHZhciB0cmlnZ2VyR3JhYiA9IGZ1bmN0aW9uIHRyaWdnZXJHcmFiKGVsZSkge1xuICAgICAgICAgICAgICAgIGVsZS5lbWl0KG1ha2VFdmVudCgnZ3JhYicpKTtcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICBzZXRHcmFiVGFyZ2V0KG5lYXIpO1xuXG4gICAgICAgICAgICAgIGlmICghbmVhci5zZWxlY3RlZCgpKSB7XG4gICAgICAgICAgICAgICAgZHJhZ2dlZEVsZW1lbnRzID0gci5kcmFnRGF0YS5wb3NzaWJsZURyYWdFbGVtZW50cyA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICBhZGROb2RlVG9EcmFnKG5lYXIsIHtcbiAgICAgICAgICAgICAgICAgIGFkZFRvTGlzdDogZHJhZ2dlZEVsZW1lbnRzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbmVhci5lbWl0KG1ha2VFdmVudCgnZ3JhYm9uJykpLmVtaXQobWFrZUV2ZW50KCdncmFiJykpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRyYWdnZWRFbGVtZW50cyA9IHIuZHJhZ0RhdGEucG9zc2libGVEcmFnRWxlbWVudHMgPSBjeS5jb2xsZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGVjdGVkTm9kZXMgPSBjeS4kKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBlbGUuaXNOb2RlKCkgJiYgZWxlLnNlbGVjdGVkKCkgJiYgci5ub2RlSXNHcmFiYmFibGUoZWxlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBhZGROb2Rlc1RvRHJhZyhzZWxlY3RlZE5vZGVzLCB7XG4gICAgICAgICAgICAgICAgICBhZGRUb0xpc3Q6IGRyYWdnZWRFbGVtZW50c1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG5lYXIuZW1pdChtYWtlRXZlbnQoJ2dyYWJvbicpKTtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZE5vZGVzLmZvckVhY2godHJpZ2dlckdyYWIpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgICAgICAgIHIucmVkcmF3SGludCgnZHJhZycsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHIuaG92ZXJEYXRhLmRvd24gPSBuZWFyO1xuICAgICAgICAgIHIuaG92ZXJEYXRhLmRvd25zID0gbmVhcnM7XG4gICAgICAgICAgci5ob3ZlckRhdGEuZG93blRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgfVxuICAgICAgICB0cmlnZ2VyRXZlbnRzKG5lYXIsIFsnbW91c2Vkb3duJywgJ3RhcHN0YXJ0JywgJ3Ztb3VzZWRvd24nXSwgZSwge1xuICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKG5lYXIgPT0gbnVsbCkge1xuICAgICAgICAgIHNlbGVjdFs0XSA9IDE7XG4gICAgICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0ge1xuICAgICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgICAgfTtcbiAgICAgICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICAgICAgICAgIHIucmVkcmF3KCk7XG4gICAgICAgIH0gZWxzZSBpZiAobmVhci5wYW5uYWJsZSgpKSB7XG4gICAgICAgICAgc2VsZWN0WzRdID0gMTsgLy8gZm9yIGZ1dHVyZSBwYW5cbiAgICAgICAgfVxuXG4gICAgICAgIGNoZWNrRm9yVGFwaG9sZCgpO1xuICAgICAgfSAvLyBJbml0aWFsaXplIHNlbGVjdGlvbiBib3ggY29vcmRpbmF0ZXNcblxuXG4gICAgICBzZWxlY3RbMF0gPSBzZWxlY3RbMl0gPSBwb3NbMF07XG4gICAgICBzZWxlY3RbMV0gPSBzZWxlY3RbM10gPSBwb3NbMV07XG4gICAgfSwgZmFsc2UpO1xuICAgIHIucmVnaXN0ZXJCaW5kaW5nKHdpbmRvdywgJ21vdXNlbW92ZScsIGZ1bmN0aW9uIG1vdXNlbW92ZUhhbmRsZXIoZSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgICAgdmFyIGNhcHR1cmUgPSByLmhvdmVyRGF0YS5jYXB0dXJlO1xuXG4gICAgICBpZiAoIWNhcHR1cmUgJiYgIWV2ZW50SW5Db250YWluZXIoZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJldmVudERlZmF1bHQgPSBmYWxzZTtcbiAgICAgIHZhciBjeSA9IHIuY3k7XG4gICAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcbiAgICAgIHZhciBncG9zID0gW2UuY2xpZW50WCwgZS5jbGllbnRZXTtcbiAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZ3Bvc1swXSwgZ3Bvc1sxXSk7XG4gICAgICB2YXIgbWRvd25Qb3MgPSByLmhvdmVyRGF0YS5tZG93blBvcztcbiAgICAgIHZhciBtZG93bkdQb3MgPSByLmhvdmVyRGF0YS5tZG93bkdQb3M7XG4gICAgICB2YXIgc2VsZWN0ID0gci5zZWxlY3Rpb247XG4gICAgICB2YXIgbmVhciA9IG51bGw7XG5cbiAgICAgIGlmICghci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzICYmICFyLmhvdmVyRGF0YS5kcmFnZ2luZyAmJiAhci5ob3ZlckRhdGEuc2VsZWN0aW5nKSB7XG4gICAgICAgIG5lYXIgPSByLmZpbmROZWFyZXN0RWxlbWVudChwb3NbMF0sIHBvc1sxXSwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGFzdCA9IHIuaG92ZXJEYXRhLmxhc3Q7XG4gICAgICB2YXIgZG93biA9IHIuaG92ZXJEYXRhLmRvd247XG4gICAgICB2YXIgZGlzcCA9IFtwb3NbMF0gLSBzZWxlY3RbMl0sIHBvc1sxXSAtIHNlbGVjdFszXV07XG4gICAgICB2YXIgZHJhZ2dlZEVsZW1lbnRzID0gci5kcmFnRGF0YS5wb3NzaWJsZURyYWdFbGVtZW50cztcbiAgICAgIHZhciBpc092ZXJUaHJlc2hvbGREcmFnO1xuXG4gICAgICBpZiAobWRvd25HUG9zKSB7XG4gICAgICAgIHZhciBkeCA9IGdwb3NbMF0gLSBtZG93bkdQb3NbMF07XG4gICAgICAgIHZhciBkeDIgPSBkeCAqIGR4O1xuICAgICAgICB2YXIgZHkgPSBncG9zWzFdIC0gbWRvd25HUG9zWzFdO1xuICAgICAgICB2YXIgZHkyID0gZHkgKiBkeTtcbiAgICAgICAgdmFyIGRpc3QyID0gZHgyICsgZHkyO1xuICAgICAgICByLmhvdmVyRGF0YS5pc092ZXJUaHJlc2hvbGREcmFnID0gaXNPdmVyVGhyZXNob2xkRHJhZyA9IGRpc3QyID49IHIuZGVza3RvcFRhcFRocmVzaG9sZDI7XG4gICAgICB9XG5cbiAgICAgIHZhciBtdWx0U2VsS2V5RG93biA9IGlzTXVsdFNlbEtleURvd24oZSk7XG5cbiAgICAgIGlmIChpc092ZXJUaHJlc2hvbGREcmFnKSB7XG4gICAgICAgIHIuaG92ZXJEYXRhLnRhcGhvbGRDYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgdXBkYXRlRHJhZ0RlbHRhID0gZnVuY3Rpb24gdXBkYXRlRHJhZ0RlbHRhKCkge1xuICAgICAgICB2YXIgZHJhZ0RlbHRhID0gci5ob3ZlckRhdGEuZHJhZ0RlbHRhID0gci5ob3ZlckRhdGEuZHJhZ0RlbHRhIHx8IFtdO1xuXG4gICAgICAgIGlmIChkcmFnRGVsdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgZHJhZ0RlbHRhLnB1c2goZGlzcFswXSk7XG4gICAgICAgICAgZHJhZ0RlbHRhLnB1c2goZGlzcFsxXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZHJhZ0RlbHRhWzBdICs9IGRpc3BbMF07XG4gICAgICAgICAgZHJhZ0RlbHRhWzFdICs9IGRpc3BbMV07XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHByZXZlbnREZWZhdWx0ID0gdHJ1ZTtcbiAgICAgIHRyaWdnZXJFdmVudHMobmVhciwgWydtb3VzZW1vdmUnLCAndm1vdXNlbW92ZScsICd0YXBkcmFnJ10sIGUsIHtcbiAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICB5OiBwb3NbMV1cbiAgICAgIH0pO1xuXG4gICAgICB2YXIgZ29JbnRvQm94TW9kZSA9IGZ1bmN0aW9uIGdvSW50b0JveE1vZGUoKSB7XG4gICAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAoIXIuaG92ZXJEYXRhLnNlbGVjdGluZykge1xuICAgICAgICAgIGN5LmVtaXQoe1xuICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICAgIHR5cGU6ICdib3hzdGFydCcsXG4gICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZWN0WzRdID0gMTtcbiAgICAgICAgci5ob3ZlckRhdGEuc2VsZWN0aW5nID0gdHJ1ZTtcbiAgICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgIH07IC8vIHRyaWdnZXIgY29udGV4dCBkcmFnIGlmIHJtb3VzZSBkb3duXG5cblxuICAgICAgaWYgKHIuaG92ZXJEYXRhLndoaWNoID09PSAzKSB7XG4gICAgICAgIC8vIGJ1dCBvbmx5IGlmIG92ZXIgdGhyZXNob2xkXG4gICAgICAgIGlmIChpc092ZXJUaHJlc2hvbGREcmFnKSB7XG4gICAgICAgICAgdmFyIGN4dEV2dCA9IHtcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgICAgICB0eXBlOiAnY3h0ZHJhZycsXG4gICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAoZG93bikge1xuICAgICAgICAgICAgZG93bi5lbWl0KGN4dEV2dCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN5LmVtaXQoY3h0RXZ0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByLmhvdmVyRGF0YS5jeHREcmFnZ2VkID0gdHJ1ZTtcblxuICAgICAgICAgIGlmICghci5ob3ZlckRhdGEuY3h0T3ZlciB8fCBuZWFyICE9PSByLmhvdmVyRGF0YS5jeHRPdmVyKSB7XG4gICAgICAgICAgICBpZiAoci5ob3ZlckRhdGEuY3h0T3Zlcikge1xuICAgICAgICAgICAgICByLmhvdmVyRGF0YS5jeHRPdmVyLmVtaXQoe1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2N4dGRyYWdvdXQnLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByLmhvdmVyRGF0YS5jeHRPdmVyID0gbmVhcjtcblxuICAgICAgICAgICAgaWYgKG5lYXIpIHtcbiAgICAgICAgICAgICAgbmVhci5lbWl0KHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdjeHRkcmFnb3ZlcicsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIENoZWNrIGlmIHdlIGFyZSBkcmFnIHBhbm5pbmcgdGhlIGVudGlyZSBncmFwaFxuXG4gICAgICB9IGVsc2UgaWYgKHIuaG92ZXJEYXRhLmRyYWdnaW5nKSB7XG4gICAgICAgIHByZXZlbnREZWZhdWx0ID0gdHJ1ZTtcblxuICAgICAgICBpZiAoY3kucGFubmluZ0VuYWJsZWQoKSAmJiBjeS51c2VyUGFubmluZ0VuYWJsZWQoKSkge1xuICAgICAgICAgIHZhciBkZWx0YVA7XG5cbiAgICAgICAgICBpZiAoci5ob3ZlckRhdGEuanVzdFN0YXJ0ZWRQYW4pIHtcbiAgICAgICAgICAgIHZhciBtZFBvcyA9IHIuaG92ZXJEYXRhLm1kb3duUG9zO1xuICAgICAgICAgICAgZGVsdGFQID0ge1xuICAgICAgICAgICAgICB4OiAocG9zWzBdIC0gbWRQb3NbMF0pICogem9vbSxcbiAgICAgICAgICAgICAgeTogKHBvc1sxXSAtIG1kUG9zWzFdKSAqIHpvb21cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByLmhvdmVyRGF0YS5qdXN0U3RhcnRlZFBhbiA9IGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWx0YVAgPSB7XG4gICAgICAgICAgICAgIHg6IGRpc3BbMF0gKiB6b29tLFxuICAgICAgICAgICAgICB5OiBkaXNwWzFdICogem9vbVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjeS5wYW5CeShkZWx0YVApO1xuICAgICAgICAgIGN5LmVtaXQoJ2RyYWdwYW4nKTtcbiAgICAgICAgICByLmhvdmVyRGF0YS5kcmFnZ2VkID0gdHJ1ZTtcbiAgICAgICAgfSAvLyBOZWVkcyByZXByb2plY3QgZHVlIHRvIHBhbiBjaGFuZ2luZyB2aWV3cG9ydFxuXG5cbiAgICAgICAgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUuY2xpZW50WCwgZS5jbGllbnRZKTsgLy8gQ2hlY2tzIHByaW1hcnkgYnV0dG9uIGRvd24gJiBvdXQgb2YgdGltZSAmIG1vdXNlIG5vdCBtb3ZlZCBtdWNoXG4gICAgICB9IGVsc2UgaWYgKHNlbGVjdFs0XSA9PSAxICYmIChkb3duID09IG51bGwgfHwgZG93bi5wYW5uYWJsZSgpKSkge1xuICAgICAgICBpZiAoaXNPdmVyVGhyZXNob2xkRHJhZykge1xuICAgICAgICAgIGlmICghci5ob3ZlckRhdGEuZHJhZ2dpbmcgJiYgY3kuYm94U2VsZWN0aW9uRW5hYmxlZCgpICYmIChtdWx0U2VsS2V5RG93biB8fCAhY3kucGFubmluZ0VuYWJsZWQoKSB8fCAhY3kudXNlclBhbm5pbmdFbmFibGVkKCkpKSB7XG4gICAgICAgICAgICBnb0ludG9Cb3hNb2RlKCk7XG4gICAgICAgICAgfSBlbHNlIGlmICghci5ob3ZlckRhdGEuc2VsZWN0aW5nICYmIGN5LnBhbm5pbmdFbmFibGVkKCkgJiYgY3kudXNlclBhbm5pbmdFbmFibGVkKCkpIHtcbiAgICAgICAgICAgIHZhciBhbGxvd1Bhc3N0aHJvdWdoID0gYWxsb3dQYW5uaW5nUGFzc3Rocm91Z2goZG93biwgci5ob3ZlckRhdGEuZG93bnMpO1xuXG4gICAgICAgICAgICBpZiAoYWxsb3dQYXNzdGhyb3VnaCkge1xuICAgICAgICAgICAgICByLmhvdmVyRGF0YS5kcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICAgIHIuaG92ZXJEYXRhLmp1c3RTdGFydGVkUGFuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgc2VsZWN0WzRdID0gMDtcbiAgICAgICAgICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gYXJyYXkycG9pbnQobWRvd25Qb3MpO1xuICAgICAgICAgICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICAgICAgICAgICAgICByLnJlZHJhdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChkb3duICYmIGRvd24ucGFubmFibGUoKSAmJiBkb3duLmFjdGl2ZSgpKSB7XG4gICAgICAgICAgICBkb3duLnVuYWN0aXZhdGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChkb3duICYmIGRvd24ucGFubmFibGUoKSAmJiBkb3duLmFjdGl2ZSgpKSB7XG4gICAgICAgICAgZG93bi51bmFjdGl2YXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKCFkb3duIHx8ICFkb3duLmdyYWJiZWQoKSkgJiYgbmVhciAhPSBsYXN0KSB7XG4gICAgICAgICAgaWYgKGxhc3QpIHtcbiAgICAgICAgICAgIHRyaWdnZXJFdmVudHMobGFzdCwgWydtb3VzZW91dCcsICd0YXBkcmFnb3V0J10sIGUsIHtcbiAgICAgICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChuZWFyKSB7XG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnRzKG5lYXIsIFsnbW91c2VvdmVyJywgJ3RhcGRyYWdvdmVyJ10sIGUsIHtcbiAgICAgICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHIuaG92ZXJEYXRhLmxhc3QgPSBuZWFyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRvd24pIHtcbiAgICAgICAgICBpZiAoaXNPdmVyVGhyZXNob2xkRHJhZykge1xuICAgICAgICAgICAgLy8gdGhlbiB3ZSBjYW4gdGFrZSBhY3Rpb25cbiAgICAgICAgICAgIGlmIChjeS5ib3hTZWxlY3Rpb25FbmFibGVkKCkgJiYgbXVsdFNlbEtleURvd24pIHtcbiAgICAgICAgICAgICAgLy8gdGhlbiBzZWxlY3Rpb24gb3ZlcnJpZGVzXG4gICAgICAgICAgICAgIGlmIChkb3duICYmIGRvd24uZ3JhYmJlZCgpKSB7XG4gICAgICAgICAgICAgICAgZnJlZURyYWdnZWRFbGVtZW50cyhkcmFnZ2VkRWxlbWVudHMpO1xuICAgICAgICAgICAgICAgIGRvd24uZW1pdCgnZnJlZW9uJyk7XG4gICAgICAgICAgICAgICAgZHJhZ2dlZEVsZW1lbnRzLmVtaXQoJ2ZyZWUnKTtcblxuICAgICAgICAgICAgICAgIGlmIChyLmRyYWdEYXRhLmRpZERyYWcpIHtcbiAgICAgICAgICAgICAgICAgIGRvd24uZW1pdCgnZHJhZ2ZyZWVvbicpO1xuICAgICAgICAgICAgICAgICAgZHJhZ2dlZEVsZW1lbnRzLmVtaXQoJ2RyYWdmcmVlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZ29JbnRvQm94TW9kZSgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkb3duICYmIGRvd24uZ3JhYmJlZCgpICYmIHIubm9kZUlzRHJhZ2dhYmxlKGRvd24pKSB7XG4gICAgICAgICAgICAgIC8vIGRyYWcgbm9kZVxuICAgICAgICAgICAgICB2YXIganVzdFN0YXJ0ZWREcmFnID0gIXIuZHJhZ0RhdGEuZGlkRHJhZztcblxuICAgICAgICAgICAgICBpZiAoanVzdFN0YXJ0ZWREcmFnKSB7XG4gICAgICAgICAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByLmRyYWdEYXRhLmRpZERyYWcgPSB0cnVlOyAvLyBpbmRpY2F0ZSB0aGF0IHdlIGFjdHVhbGx5IGRpZCBkcmFnIHRoZSBub2RlXG4gICAgICAgICAgICAgIC8vIG5vdywgYWRkIHRoZSBlbGVtZW50cyB0byB0aGUgZHJhZyBsYXllciBpZiBub3QgZG9uZSBhbHJlYWR5XG5cbiAgICAgICAgICAgICAgaWYgKCFyLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMpIHtcbiAgICAgICAgICAgICAgICBhZGROb2Rlc1RvRHJhZyhkcmFnZ2VkRWxlbWVudHMsIHtcbiAgICAgICAgICAgICAgICAgIGluRHJhZ0xheWVyOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgdG90YWxTaGlmdCA9IHtcbiAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgIHk6IDBcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICBpZiAobnVtYmVyJDEoZGlzcFswXSkgJiYgbnVtYmVyJDEoZGlzcFsxXSkpIHtcbiAgICAgICAgICAgICAgICB0b3RhbFNoaWZ0LnggKz0gZGlzcFswXTtcbiAgICAgICAgICAgICAgICB0b3RhbFNoaWZ0LnkgKz0gZGlzcFsxXTtcblxuICAgICAgICAgICAgICAgIGlmIChqdXN0U3RhcnRlZERyYWcpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBkcmFnRGVsdGEgPSByLmhvdmVyRGF0YS5kcmFnRGVsdGE7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChkcmFnRGVsdGEgJiYgbnVtYmVyJDEoZHJhZ0RlbHRhWzBdKSAmJiBudW1iZXIkMShkcmFnRGVsdGFbMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvdGFsU2hpZnQueCArPSBkcmFnRGVsdGFbMF07XG4gICAgICAgICAgICAgICAgICAgIHRvdGFsU2hpZnQueSArPSBkcmFnRGVsdGFbMV07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgZHJhZ2dlZEVsZW1lbnRzLnNpbGVudFNoaWZ0KHRvdGFsU2hpZnQpLmVtaXQoJ3Bvc2l0aW9uIGRyYWcnKTtcbiAgICAgICAgICAgICAgci5yZWRyYXdIaW50KCdkcmFnJywgdHJ1ZSk7XG4gICAgICAgICAgICAgIHIucmVkcmF3KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSBzYXZlIGRyYWcgZGVsdGEgZm9yIHdoZW4gd2UgYWN0dWFsbHkgc3RhcnQgZHJhZ2dpbmcgc28gdGhlIHJlbGF0aXZlIGdyYWIgcG9zIGlzIGNvbnN0YW50XG4gICAgICAgICAgICB1cGRhdGVEcmFnRGVsdGEoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gcHJldmVudCB0aGUgZHJhZ2dpbmcgZnJvbSB0cmlnZ2VyaW5nIHRleHQgc2VsZWN0aW9uIG9uIHRoZSBwYWdlXG5cblxuICAgICAgICBwcmV2ZW50RGVmYXVsdCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHNlbGVjdFsyXSA9IHBvc1swXTtcbiAgICAgIHNlbGVjdFszXSA9IHBvc1sxXTtcblxuICAgICAgaWYgKHByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgIGlmIChlLnN0b3BQcm9wYWdhdGlvbikgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgaWYgKGUucHJldmVudERlZmF1bHQpIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0sIGZhbHNlKTtcbiAgICB2YXIgY2xpY2tUaW1lb3V0LCBkaWREb3VibGVDbGljaywgcHJldkNsaWNrVGltZVN0YW1wO1xuICAgIHIucmVnaXN0ZXJCaW5kaW5nKHdpbmRvdywgJ21vdXNldXAnLCBmdW5jdGlvbiBtb3VzZXVwSGFuZGxlcihlKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gICAgICB2YXIgY2FwdHVyZSA9IHIuaG92ZXJEYXRhLmNhcHR1cmU7XG5cbiAgICAgIGlmICghY2FwdHVyZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHIuaG92ZXJEYXRhLmNhcHR1cmUgPSBmYWxzZTtcbiAgICAgIHZhciBjeSA9IHIuY3k7XG4gICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUuY2xpZW50WCwgZS5jbGllbnRZKTtcbiAgICAgIHZhciBzZWxlY3QgPSByLnNlbGVjdGlvbjtcbiAgICAgIHZhciBuZWFyID0gci5maW5kTmVhcmVzdEVsZW1lbnQocG9zWzBdLCBwb3NbMV0sIHRydWUsIGZhbHNlKTtcbiAgICAgIHZhciBkcmFnZ2VkRWxlbWVudHMgPSByLmRyYWdEYXRhLnBvc3NpYmxlRHJhZ0VsZW1lbnRzO1xuICAgICAgdmFyIGRvd24gPSByLmhvdmVyRGF0YS5kb3duO1xuICAgICAgdmFyIG11bHRTZWxLZXlEb3duID0gaXNNdWx0U2VsS2V5RG93bihlKTtcblxuICAgICAgaWYgKHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbikge1xuICAgICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICAgICAgICByLnJlZHJhdygpO1xuICAgICAgfVxuXG4gICAgICByLmhvdmVyRGF0YS50YXBob2xkQ2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDsgLy8gbm90IGFjdGl2ZSBiZyBub3dcblxuICAgICAgaWYgKGRvd24pIHtcbiAgICAgICAgZG93bi51bmFjdGl2YXRlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyLmhvdmVyRGF0YS53aGljaCA9PT0gMykge1xuICAgICAgICB2YXIgY3h0RXZ0ID0ge1xuICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgICAgdHlwZTogJ2N4dHRhcGVuZCcsXG4gICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZG93bikge1xuICAgICAgICAgIGRvd24uZW1pdChjeHRFdnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN5LmVtaXQoY3h0RXZ0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghci5ob3ZlckRhdGEuY3h0RHJhZ2dlZCkge1xuICAgICAgICAgIHZhciBjeHRUYXAgPSB7XG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgICAgdHlwZTogJ2N4dHRhcCcsXG4gICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAoZG93bikge1xuICAgICAgICAgICAgZG93bi5lbWl0KGN4dFRhcCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN5LmVtaXQoY3h0VGFwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByLmhvdmVyRGF0YS5jeHREcmFnZ2VkID0gZmFsc2U7XG4gICAgICAgIHIuaG92ZXJEYXRhLndoaWNoID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAoci5ob3ZlckRhdGEud2hpY2ggPT09IDEpIHtcbiAgICAgICAgdHJpZ2dlckV2ZW50cyhuZWFyLCBbJ21vdXNldXAnLCAndGFwZW5kJywgJ3Ztb3VzZXVwJ10sIGUsIHtcbiAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghci5kcmFnRGF0YS5kaWREcmFnICYmIC8vIGRpZG4ndCBtb3ZlIGEgbm9kZSBhcm91bmRcbiAgICAgICAgIXIuaG92ZXJEYXRhLmRyYWdnZWQgJiYgLy8gZGlkbid0IHBhblxuICAgICAgICAhci5ob3ZlckRhdGEuc2VsZWN0aW5nICYmIC8vIG5vdCBib3ggc2VsZWN0aW9uXG4gICAgICAgICFyLmhvdmVyRGF0YS5pc092ZXJUaHJlc2hvbGREcmFnIC8vIGRpZG4ndCBtb3ZlIHRvbyBtdWNoXG4gICAgICAgICkge1xuICAgICAgICAgIHRyaWdnZXJFdmVudHMoZG93biwgW1wiY2xpY2tcIiwgXCJ0YXBcIiwgXCJ2Y2xpY2tcIl0sIGUsIHtcbiAgICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGRpZERvdWJsZUNsaWNrID0gZmFsc2U7XG5cbiAgICAgICAgICBpZiAoZS50aW1lU3RhbXAgLSBwcmV2Q2xpY2tUaW1lU3RhbXAgPD0gY3kubXVsdGlDbGlja0RlYm91bmNlVGltZSgpKSB7XG4gICAgICAgICAgICBjbGlja1RpbWVvdXQgJiYgY2xlYXJUaW1lb3V0KGNsaWNrVGltZW91dCk7XG4gICAgICAgICAgICBkaWREb3VibGVDbGljayA9IHRydWU7XG4gICAgICAgICAgICBwcmV2Q2xpY2tUaW1lU3RhbXAgPSBudWxsO1xuICAgICAgICAgICAgdHJpZ2dlckV2ZW50cyhkb3duLCBbXCJkYmxjbGlja1wiLCBcImRibHRhcFwiLCBcInZkYmxjbGlja1wiXSwgZSwge1xuICAgICAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNsaWNrVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAoZGlkRG91YmxlQ2xpY2spIHJldHVybjtcbiAgICAgICAgICAgICAgdHJpZ2dlckV2ZW50cyhkb3duLCBbXCJvbmVjbGlja1wiLCBcIm9uZXRhcFwiLCBcInZvbmVjbGlja1wiXSwgZSwge1xuICAgICAgICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCBjeS5tdWx0aUNsaWNrRGVib3VuY2VUaW1lKCkpO1xuICAgICAgICAgICAgcHJldkNsaWNrVGltZVN0YW1wID0gZS50aW1lU3RhbXA7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIERlc2VsZWN0IGFsbCBlbGVtZW50cyBpZiBub3RoaW5nIGlzIGN1cnJlbnRseSB1bmRlciB0aGUgbW91c2UgY3Vyc29yIGFuZCB3ZSBhcmVuJ3QgZHJhZ2dpbmcgc29tZXRoaW5nXG5cblxuICAgICAgICBpZiAoZG93biA9PSBudWxsIC8vIG5vdCBtb3VzZWRvd24gb24gbm9kZVxuICAgICAgICAmJiAhci5kcmFnRGF0YS5kaWREcmFnIC8vIGRpZG4ndCBtb3ZlIHRoZSBub2RlIGFyb3VuZFxuICAgICAgICAmJiAhci5ob3ZlckRhdGEuc2VsZWN0aW5nIC8vIG5vdCBib3ggc2VsZWN0aW9uXG4gICAgICAgICYmICFyLmhvdmVyRGF0YS5kcmFnZ2VkIC8vIGRpZG4ndCBwYW5cbiAgICAgICAgJiYgIWlzTXVsdFNlbEtleURvd24oZSkpIHtcbiAgICAgICAgICBjeS4kKGlzU2VsZWN0ZWQpLnVuc2VsZWN0KFsndGFwdW5zZWxlY3QnXSk7XG5cbiAgICAgICAgICBpZiAoZHJhZ2dlZEVsZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHIuZHJhZ0RhdGEucG9zc2libGVEcmFnRWxlbWVudHMgPSBkcmFnZ2VkRWxlbWVudHMgPSBjeS5jb2xsZWN0aW9uKCk7XG4gICAgICAgIH0gLy8gU2luZ2xlIHNlbGVjdGlvblxuXG5cbiAgICAgICAgaWYgKG5lYXIgPT0gZG93biAmJiAhci5kcmFnRGF0YS5kaWREcmFnICYmICFyLmhvdmVyRGF0YS5zZWxlY3RpbmcpIHtcbiAgICAgICAgICBpZiAobmVhciAhPSBudWxsICYmIG5lYXIuX3ByaXZhdGUuc2VsZWN0YWJsZSkge1xuICAgICAgICAgICAgaWYgKHIuaG92ZXJEYXRhLmRyYWdnaW5nKSA7IGVsc2UgaWYgKGN5LnNlbGVjdGlvblR5cGUoKSA9PT0gJ2FkZGl0aXZlJyB8fCBtdWx0U2VsS2V5RG93bikge1xuICAgICAgICAgICAgICBpZiAobmVhci5zZWxlY3RlZCgpKSB7XG4gICAgICAgICAgICAgICAgbmVhci51bnNlbGVjdChbJ3RhcHVuc2VsZWN0J10pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5lYXIuc2VsZWN0KFsndGFwc2VsZWN0J10pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoIW11bHRTZWxLZXlEb3duKSB7XG4gICAgICAgICAgICAgICAgY3kuJChpc1NlbGVjdGVkKS51bm1lcmdlKG5lYXIpLnVuc2VsZWN0KFsndGFwdW5zZWxlY3QnXSk7XG4gICAgICAgICAgICAgICAgbmVhci5zZWxlY3QoWyd0YXBzZWxlY3QnXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHIuaG92ZXJEYXRhLnNlbGVjdGluZykge1xuICAgICAgICAgIHZhciBib3ggPSBjeS5jb2xsZWN0aW9uKHIuZ2V0QWxsSW5Cb3goc2VsZWN0WzBdLCBzZWxlY3RbMV0sIHNlbGVjdFsyXSwgc2VsZWN0WzNdKSk7XG4gICAgICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcblxuICAgICAgICAgIGlmIChib3gubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3kuZW1pdCh7XG4gICAgICAgICAgICB0eXBlOiAnYm94ZW5kJyxcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIGVsZVdvdWxkQmVTZWxlY3RlZCA9IGZ1bmN0aW9uIGVsZVdvdWxkQmVTZWxlY3RlZChlbGUpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGUuc2VsZWN0YWJsZSgpICYmICFlbGUuc2VsZWN0ZWQoKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKGN5LnNlbGVjdGlvblR5cGUoKSA9PT0gJ2FkZGl0aXZlJykge1xuICAgICAgICAgICAgYm94LmVtaXQoJ2JveCcpLnN0ZEZpbHRlcihlbGVXb3VsZEJlU2VsZWN0ZWQpLnNlbGVjdCgpLmVtaXQoJ2JveHNlbGVjdCcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIW11bHRTZWxLZXlEb3duKSB7XG4gICAgICAgICAgICAgIGN5LiQoaXNTZWxlY3RlZCkudW5tZXJnZShib3gpLnVuc2VsZWN0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJveC5lbWl0KCdib3gnKS5zdGRGaWx0ZXIoZWxlV291bGRCZVNlbGVjdGVkKS5zZWxlY3QoKS5lbWl0KCdib3hzZWxlY3QnKTtcbiAgICAgICAgICB9IC8vIGFsd2F5cyBuZWVkIHJlZHJhdyBpbiBjYXNlIGVsZXMgdW5zZWxlY3RhYmxlXG5cblxuICAgICAgICAgIHIucmVkcmF3KCk7XG4gICAgICAgIH0gLy8gQ2FuY2VsIGRyYWcgcGFuXG5cblxuICAgICAgICBpZiAoci5ob3ZlckRhdGEuZHJhZ2dpbmcpIHtcbiAgICAgICAgICByLmhvdmVyRGF0YS5kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG4gICAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc2VsZWN0WzRdKSB7XG4gICAgICAgICAgci5yZWRyYXdIaW50KCdkcmFnJywgdHJ1ZSk7XG4gICAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgICAgdmFyIGRvd25XYXNHcmFiYmVkID0gZG93biAmJiBkb3duLmdyYWJiZWQoKTtcbiAgICAgICAgICBmcmVlRHJhZ2dlZEVsZW1lbnRzKGRyYWdnZWRFbGVtZW50cyk7XG5cbiAgICAgICAgICBpZiAoZG93bldhc0dyYWJiZWQpIHtcbiAgICAgICAgICAgIGRvd24uZW1pdCgnZnJlZW9uJyk7XG4gICAgICAgICAgICBkcmFnZ2VkRWxlbWVudHMuZW1pdCgnZnJlZScpO1xuXG4gICAgICAgICAgICBpZiAoci5kcmFnRGF0YS5kaWREcmFnKSB7XG4gICAgICAgICAgICAgIGRvd24uZW1pdCgnZHJhZ2ZyZWVvbicpO1xuICAgICAgICAgICAgICBkcmFnZ2VkRWxlbWVudHMuZW1pdCgnZHJhZ2ZyZWUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gZWxzZSBub3QgcmlnaHQgbW91c2VcblxuXG4gICAgICBzZWxlY3RbNF0gPSAwO1xuICAgICAgci5ob3ZlckRhdGEuZG93biA9IG51bGw7XG4gICAgICByLmhvdmVyRGF0YS5jeHRTdGFydGVkID0gZmFsc2U7XG4gICAgICByLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgPSBmYWxzZTtcbiAgICAgIHIuaG92ZXJEYXRhLnNlbGVjdGluZyA9IGZhbHNlO1xuICAgICAgci5ob3ZlckRhdGEuaXNPdmVyVGhyZXNob2xkRHJhZyA9IGZhbHNlO1xuICAgICAgci5kcmFnRGF0YS5kaWREcmFnID0gZmFsc2U7XG4gICAgICByLmhvdmVyRGF0YS5kcmFnZ2VkID0gZmFsc2U7XG4gICAgICByLmhvdmVyRGF0YS5kcmFnRGVsdGEgPSBbXTtcbiAgICAgIHIuaG92ZXJEYXRhLm1kb3duUG9zID0gbnVsbDtcbiAgICAgIHIuaG92ZXJEYXRhLm1kb3duR1BvcyA9IG51bGw7XG4gICAgfSwgZmFsc2UpO1xuXG4gICAgdmFyIHdoZWVsSGFuZGxlciA9IGZ1bmN0aW9uIHdoZWVsSGFuZGxlcihlKSB7XG4gICAgICBpZiAoci5zY3JvbGxpbmdQYWdlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gd2hpbGUgc2Nyb2xsaW5nLCBpZ25vcmUgd2hlZWwtdG8tem9vbVxuXG5cbiAgICAgIHZhciBjeSA9IHIuY3k7XG4gICAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcbiAgICAgIHZhciBwYW4gPSBjeS5wYW4oKTtcbiAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS5jbGllbnRYLCBlLmNsaWVudFkpO1xuICAgICAgdmFyIHJwb3MgPSBbcG9zWzBdICogem9vbSArIHBhbi54LCBwb3NbMV0gKiB6b29tICsgcGFuLnldO1xuXG4gICAgICBpZiAoci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzIHx8IHIuaG92ZXJEYXRhLmRyYWdnaW5nIHx8IHIuaG92ZXJEYXRhLmN4dFN0YXJ0ZWQgfHwgaW5Cb3hTZWxlY3Rpb24oKSkge1xuICAgICAgICAvLyBpZiBwYW4gZHJhZ2dpbmcgb3IgY3h0IGRyYWdnaW5nLCB3aGVlbCBtb3ZlbWVudHMgbWFrZSBubyB6b29tXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoY3kucGFubmluZ0VuYWJsZWQoKSAmJiBjeS51c2VyUGFubmluZ0VuYWJsZWQoKSAmJiBjeS56b29taW5nRW5hYmxlZCgpICYmIGN5LnVzZXJab29taW5nRW5hYmxlZCgpKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgci5kYXRhLndoZWVsWm9vbWluZyA9IHRydWU7XG4gICAgICAgIGNsZWFyVGltZW91dChyLmRhdGEud2hlZWxUaW1lb3V0KTtcbiAgICAgICAgci5kYXRhLndoZWVsVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHIuZGF0YS53aGVlbFpvb21pbmcgPSBmYWxzZTtcbiAgICAgICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgICAgICAgICByLnJlZHJhdygpO1xuICAgICAgICB9LCAxNTApO1xuICAgICAgICB2YXIgZGlmZjtcblxuICAgICAgICBpZiAoZS5kZWx0YVkgIT0gbnVsbCkge1xuICAgICAgICAgIGRpZmYgPSBlLmRlbHRhWSAvIC0yNTA7XG4gICAgICAgIH0gZWxzZSBpZiAoZS53aGVlbERlbHRhWSAhPSBudWxsKSB7XG4gICAgICAgICAgZGlmZiA9IGUud2hlZWxEZWx0YVkgLyAxMDAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRpZmYgPSBlLndoZWVsRGVsdGEgLyAxMDAwO1xuICAgICAgICB9XG5cbiAgICAgICAgZGlmZiA9IGRpZmYgKiByLndoZWVsU2Vuc2l0aXZpdHk7XG4gICAgICAgIHZhciBuZWVkc1doZWVsRml4ID0gZS5kZWx0YU1vZGUgPT09IDE7XG5cbiAgICAgICAgaWYgKG5lZWRzV2hlZWxGaXgpIHtcbiAgICAgICAgICAvLyBmaXhlcyBzbG93IHdoZWVsIGV2ZW50cyBvbiBmZi9saW51eCBhbmQgZmYvd2luZG93c1xuICAgICAgICAgIGRpZmYgKj0gMzM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmV3Wm9vbSA9IGN5Lnpvb20oKSAqIE1hdGgucG93KDEwLCBkaWZmKTtcblxuICAgICAgICBpZiAoZS50eXBlID09PSAnZ2VzdHVyZWNoYW5nZScpIHtcbiAgICAgICAgICBuZXdab29tID0gci5nZXN0dXJlU3RhcnRab29tICogZS5zY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN5Lnpvb20oe1xuICAgICAgICAgIGxldmVsOiBuZXdab29tLFxuICAgICAgICAgIHJlbmRlcmVkUG9zaXRpb246IHtcbiAgICAgICAgICAgIHg6IHJwb3NbMF0sXG4gICAgICAgICAgICB5OiBycG9zWzFdXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY3kuZW1pdChlLnR5cGUgPT09ICdnZXN0dXJlY2hhbmdlJyA/ICdwaW5jaHpvb20nIDogJ3Njcm9sbHpvb20nKTtcbiAgICAgIH1cbiAgICB9OyAvLyBGdW5jdGlvbnMgdG8gaGVscCB3aXRoIHdoZXRoZXIgbW91c2Ugd2hlZWwgc2hvdWxkIHRyaWdnZXIgem9vbWluZ1xuICAgIC8vIC0tXG5cblxuICAgIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAnd2hlZWwnLCB3aGVlbEhhbmRsZXIsIHRydWUpOyAvLyBkaXNhYmxlIG5vbnN0YW5kYXJkIHdoZWVsIGV2ZW50c1xuICAgIC8vIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAnbW91c2V3aGVlbCcsIHdoZWVsSGFuZGxlciwgdHJ1ZSk7XG4gICAgLy8gci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICdET01Nb3VzZVNjcm9sbCcsIHdoZWVsSGFuZGxlciwgdHJ1ZSk7XG4gICAgLy8gci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICdNb3pNb3VzZVBpeGVsU2Nyb2xsJywgd2hlZWxIYW5kbGVyLCB0cnVlKTsgLy8gb2xkZXIgZmlyZWZveFxuXG4gICAgci5yZWdpc3RlckJpbmRpbmcod2luZG93LCAnc2Nyb2xsJywgZnVuY3Rpb24gc2Nyb2xsSGFuZGxlcihlKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByLnNjcm9sbGluZ1BhZ2UgPSB0cnVlO1xuICAgICAgY2xlYXJUaW1lb3V0KHIuc2Nyb2xsaW5nUGFnZVRpbWVvdXQpO1xuICAgICAgci5zY3JvbGxpbmdQYWdlVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICByLnNjcm9sbGluZ1BhZ2UgPSBmYWxzZTtcbiAgICAgIH0sIDI1MCk7XG4gICAgfSwgdHJ1ZSk7IC8vIGRlc2t0b3Agc2FmYXJpIHBpbmNoIHRvIHpvb20gc3RhcnRcblxuICAgIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAnZ2VzdHVyZXN0YXJ0JywgZnVuY3Rpb24gZ2VzdHVyZVN0YXJ0SGFuZGxlcihlKSB7XG4gICAgICByLmdlc3R1cmVTdGFydFpvb20gPSByLmN5Lnpvb20oKTtcblxuICAgICAgaWYgKCFyLmhhc1RvdWNoU3RhcnRlZCkge1xuICAgICAgICAvLyBkb24ndCBhZmZlY3QgdG91Y2ggZGV2aWNlcyBsaWtlIGlwaG9uZVxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfSwgdHJ1ZSk7XG4gICAgci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICdnZXN0dXJlY2hhbmdlJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmICghci5oYXNUb3VjaFN0YXJ0ZWQpIHtcbiAgICAgICAgLy8gZG9uJ3QgYWZmZWN0IHRvdWNoIGRldmljZXMgbGlrZSBpcGhvbmVcbiAgICAgICAgd2hlZWxIYW5kbGVyKGUpO1xuICAgICAgfVxuICAgIH0sIHRydWUpOyAvLyBGdW5jdGlvbnMgdG8gaGVscCB3aXRoIGhhbmRsaW5nIG1vdXNlb3V0L21vdXNlb3ZlciBvbiB0aGUgQ3l0b3NjYXBlIGNvbnRhaW5lclxuICAgIC8vIEhhbmRsZSBtb3VzZW91dCBvbiBDeXRvc2NhcGUgY29udGFpbmVyXG5cbiAgICByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ21vdXNlb3V0JywgZnVuY3Rpb24gbW91c2VPdXRIYW5kbGVyKGUpIHtcbiAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS5jbGllbnRYLCBlLmNsaWVudFkpO1xuICAgICAgci5jeS5lbWl0KHtcbiAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgdHlwZTogJ21vdXNlb3V0JyxcbiAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sIGZhbHNlKTtcbiAgICByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ21vdXNlb3ZlcicsIGZ1bmN0aW9uIG1vdXNlT3ZlckhhbmRsZXIoZSkge1xuICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLmNsaWVudFgsIGUuY2xpZW50WSk7XG4gICAgICByLmN5LmVtaXQoe1xuICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICB0eXBlOiAnbW91c2VvdmVyJyxcbiAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sIGZhbHNlKTtcbiAgICB2YXIgZjF4MSwgZjF5MSwgZjJ4MSwgZjJ5MTsgLy8gc3RhcnRpbmcgcG9pbnRzIGZvciBwaW5jaC10by16b29tXG5cbiAgICB2YXIgZGlzdGFuY2UxLCBkaXN0YW5jZTFTcTsgLy8gaW5pdGlhbCBkaXN0YW5jZSBiZXR3ZWVuIGZpbmdlciAxIGFuZCBmaW5nZXIgMiBmb3IgcGluY2gtdG8tem9vbVxuXG4gICAgdmFyIGNlbnRlcjEsIG1vZGVsQ2VudGVyMTsgLy8gY2VudGVyIHBvaW50IG9uIHN0YXJ0IHBpbmNoIHRvIHpvb21cblxuICAgIHZhciBvZmZzZXRMZWZ0LCBvZmZzZXRUb3A7XG4gICAgdmFyIGNvbnRhaW5lcldpZHRoLCBjb250YWluZXJIZWlnaHQ7XG4gICAgdmFyIHR3b0ZpbmdlcnNTdGFydEluc2lkZTtcblxuICAgIHZhciBkaXN0YW5jZSA9IGZ1bmN0aW9uIGRpc3RhbmNlKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgICByZXR1cm4gTWF0aC5zcXJ0KCh4MiAtIHgxKSAqICh4MiAtIHgxKSArICh5MiAtIHkxKSAqICh5MiAtIHkxKSk7XG4gICAgfTtcblxuICAgIHZhciBkaXN0YW5jZVNxID0gZnVuY3Rpb24gZGlzdGFuY2VTcSh4MSwgeTEsIHgyLCB5Mikge1xuICAgICAgcmV0dXJuICh4MiAtIHgxKSAqICh4MiAtIHgxKSArICh5MiAtIHkxKSAqICh5MiAtIHkxKTtcbiAgICB9O1xuXG4gICAgdmFyIHRvdWNoc3RhcnRIYW5kbGVyO1xuICAgIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAndG91Y2hzdGFydCcsIHRvdWNoc3RhcnRIYW5kbGVyID0gZnVuY3Rpb24gdG91Y2hzdGFydEhhbmRsZXIoZSkge1xuICAgICAgci5oYXNUb3VjaFN0YXJ0ZWQgPSB0cnVlO1xuXG4gICAgICBpZiAoIWV2ZW50SW5Db250YWluZXIoZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBibHVyQWN0aXZlRG9tRWxlbWVudCgpO1xuICAgICAgci50b3VjaERhdGEuY2FwdHVyZSA9IHRydWU7XG4gICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICB2YXIgY3kgPSByLmN5O1xuICAgICAgdmFyIG5vdyA9IHIudG91Y2hEYXRhLm5vdztcbiAgICAgIHZhciBlYXJsaWVyID0gci50b3VjaERhdGEuZWFybGllcjtcblxuICAgICAgaWYgKGUudG91Y2hlc1swXSkge1xuICAgICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1swXS5jbGllbnRYLCBlLnRvdWNoZXNbMF0uY2xpZW50WSk7XG4gICAgICAgIG5vd1swXSA9IHBvc1swXTtcbiAgICAgICAgbm93WzFdID0gcG9zWzFdO1xuICAgICAgfVxuXG4gICAgICBpZiAoZS50b3VjaGVzWzFdKSB7XG4gICAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzFdLmNsaWVudFgsIGUudG91Y2hlc1sxXS5jbGllbnRZKTtcbiAgICAgICAgbm93WzJdID0gcG9zWzBdO1xuICAgICAgICBub3dbM10gPSBwb3NbMV07XG4gICAgICB9XG5cbiAgICAgIGlmIChlLnRvdWNoZXNbMl0pIHtcbiAgICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMl0uY2xpZW50WCwgZS50b3VjaGVzWzJdLmNsaWVudFkpO1xuICAgICAgICBub3dbNF0gPSBwb3NbMF07XG4gICAgICAgIG5vd1s1XSA9IHBvc1sxXTtcbiAgICAgIH0gLy8gcmVjb3JkIHN0YXJ0aW5nIHBvaW50cyBmb3IgcGluY2gtdG8tem9vbVxuXG5cbiAgICAgIGlmIChlLnRvdWNoZXNbMV0pIHtcbiAgICAgICAgci50b3VjaERhdGEuc2luZ2xlVG91Y2hNb3ZlZCA9IHRydWU7XG4gICAgICAgIGZyZWVEcmFnZ2VkRWxlbWVudHMoci5kcmFnRGF0YS50b3VjaERyYWdFbGVzKTtcbiAgICAgICAgdmFyIG9mZnNldHMgPSByLmZpbmRDb250YWluZXJDbGllbnRDb29yZHMoKTtcbiAgICAgICAgb2Zmc2V0TGVmdCA9IG9mZnNldHNbMF07XG4gICAgICAgIG9mZnNldFRvcCA9IG9mZnNldHNbMV07XG4gICAgICAgIGNvbnRhaW5lcldpZHRoID0gb2Zmc2V0c1syXTtcbiAgICAgICAgY29udGFpbmVySGVpZ2h0ID0gb2Zmc2V0c1szXTtcbiAgICAgICAgZjF4MSA9IGUudG91Y2hlc1swXS5jbGllbnRYIC0gb2Zmc2V0TGVmdDtcbiAgICAgICAgZjF5MSA9IGUudG91Y2hlc1swXS5jbGllbnRZIC0gb2Zmc2V0VG9wO1xuICAgICAgICBmMngxID0gZS50b3VjaGVzWzFdLmNsaWVudFggLSBvZmZzZXRMZWZ0O1xuICAgICAgICBmMnkxID0gZS50b3VjaGVzWzFdLmNsaWVudFkgLSBvZmZzZXRUb3A7XG4gICAgICAgIHR3b0ZpbmdlcnNTdGFydEluc2lkZSA9IDAgPD0gZjF4MSAmJiBmMXgxIDw9IGNvbnRhaW5lcldpZHRoICYmIDAgPD0gZjJ4MSAmJiBmMngxIDw9IGNvbnRhaW5lcldpZHRoICYmIDAgPD0gZjF5MSAmJiBmMXkxIDw9IGNvbnRhaW5lckhlaWdodCAmJiAwIDw9IGYyeTEgJiYgZjJ5MSA8PSBjb250YWluZXJIZWlnaHQ7XG4gICAgICAgIHZhciBwYW4gPSBjeS5wYW4oKTtcbiAgICAgICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgICAgIGRpc3RhbmNlMSA9IGRpc3RhbmNlKGYxeDEsIGYxeTEsIGYyeDEsIGYyeTEpO1xuICAgICAgICBkaXN0YW5jZTFTcSA9IGRpc3RhbmNlU3EoZjF4MSwgZjF5MSwgZjJ4MSwgZjJ5MSk7XG4gICAgICAgIGNlbnRlcjEgPSBbKGYxeDEgKyBmMngxKSAvIDIsIChmMXkxICsgZjJ5MSkgLyAyXTtcbiAgICAgICAgbW9kZWxDZW50ZXIxID0gWyhjZW50ZXIxWzBdIC0gcGFuLngpIC8gem9vbSwgKGNlbnRlcjFbMV0gLSBwYW4ueSkgLyB6b29tXTsgLy8gY29uc2lkZXIgY29udGV4dCB0YXBcblxuICAgICAgICB2YXIgY3h0RGlzdFRocmVzaG9sZCA9IDIwMDtcbiAgICAgICAgdmFyIGN4dERpc3RUaHJlc2hvbGRTcSA9IGN4dERpc3RUaHJlc2hvbGQgKiBjeHREaXN0VGhyZXNob2xkO1xuXG4gICAgICAgIGlmIChkaXN0YW5jZTFTcSA8IGN4dERpc3RUaHJlc2hvbGRTcSAmJiAhZS50b3VjaGVzWzJdKSB7XG4gICAgICAgICAgdmFyIG5lYXIxID0gci5maW5kTmVhcmVzdEVsZW1lbnQobm93WzBdLCBub3dbMV0sIHRydWUsIHRydWUpO1xuICAgICAgICAgIHZhciBuZWFyMiA9IHIuZmluZE5lYXJlc3RFbGVtZW50KG5vd1syXSwgbm93WzNdLCB0cnVlLCB0cnVlKTtcblxuICAgICAgICAgIGlmIChuZWFyMSAmJiBuZWFyMS5pc05vZGUoKSkge1xuICAgICAgICAgICAgbmVhcjEuYWN0aXZhdGUoKS5lbWl0KHtcbiAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICAgICAgdHlwZTogJ2N4dHRhcHN0YXJ0JyxcbiAgICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgICAgICAgeTogbm93WzFdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgci50b3VjaERhdGEuc3RhcnQgPSBuZWFyMTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG5lYXIyICYmIG5lYXIyLmlzTm9kZSgpKSB7XG4gICAgICAgICAgICBuZWFyMi5hY3RpdmF0ZSgpLmVtaXQoe1xuICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgICAgICB0eXBlOiAnY3h0dGFwc3RhcnQnLFxuICAgICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgICAgICAgICB5OiBub3dbMV1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydCA9IG5lYXIyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjeS5lbWl0KHtcbiAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICAgICAgdHlwZTogJ2N4dHRhcHN0YXJ0JyxcbiAgICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgICAgICAgeTogbm93WzFdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChyLnRvdWNoRGF0YS5zdGFydCkge1xuICAgICAgICAgICAgci50b3VjaERhdGEuc3RhcnQuX3ByaXZhdGUuZ3JhYmJlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHIudG91Y2hEYXRhLmN4dCA9IHRydWU7XG4gICAgICAgICAgci50b3VjaERhdGEuY3h0RHJhZ2dlZCA9IGZhbHNlO1xuICAgICAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICByLnJlZHJhdygpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZS50b3VjaGVzWzJdKSB7XG4gICAgICAgIC8vIGlnbm9yZVxuICAgICAgICAvLyBzYWZhcmkgb24gaW9zIHBhbnMgdGhlIHBhZ2Ugb3RoZXJ3aXNlIChub3JtYWxseSB5b3Ugc2hvdWxkIGJlIGFibGUgdG8gcHJldmVudGRlZmF1bHQgb24gdG91Y2htb3ZlLi4uKVxuICAgICAgICBpZiAoY3kuYm94U2VsZWN0aW9uRW5hYmxlZCgpKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGUudG91Y2hlc1sxXSkgOyBlbHNlIGlmIChlLnRvdWNoZXNbMF0pIHtcbiAgICAgICAgdmFyIG5lYXJzID0gci5maW5kTmVhcmVzdEVsZW1lbnRzKG5vd1swXSwgbm93WzFdLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgdmFyIG5lYXIgPSBuZWFyc1swXTtcblxuICAgICAgICBpZiAobmVhciAhPSBudWxsKSB7XG4gICAgICAgICAgbmVhci5hY3RpdmF0ZSgpO1xuICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0ID0gbmVhcjtcbiAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydHMgPSBuZWFycztcblxuICAgICAgICAgIGlmIChyLm5vZGVJc0dyYWJiYWJsZShuZWFyKSkge1xuICAgICAgICAgICAgdmFyIGRyYWdnZWRFbGVzID0gci5kcmFnRGF0YS50b3VjaERyYWdFbGVzID0gY3kuY29sbGVjdGlvbigpO1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkTm9kZXMgPSBudWxsO1xuICAgICAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgICAgICByLnJlZHJhd0hpbnQoJ2RyYWcnLCB0cnVlKTtcblxuICAgICAgICAgICAgaWYgKG5lYXIuc2VsZWN0ZWQoKSkge1xuICAgICAgICAgICAgICAvLyByZXNldCBkcmFnIGVsZW1lbnRzLCBzaW5jZSBuZWFyIHdpbGwgYmUgYWRkZWQgYWdhaW5cbiAgICAgICAgICAgICAgc2VsZWN0ZWROb2RlcyA9IGN5LiQoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbGUuc2VsZWN0ZWQoKSAmJiByLm5vZGVJc0dyYWJiYWJsZShlbGUpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYWRkTm9kZXNUb0RyYWcoc2VsZWN0ZWROb2Rlcywge1xuICAgICAgICAgICAgICAgIGFkZFRvTGlzdDogZHJhZ2dlZEVsZXNcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhZGROb2RlVG9EcmFnKG5lYXIsIHtcbiAgICAgICAgICAgICAgICBhZGRUb0xpc3Q6IGRyYWdnZWRFbGVzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZXRHcmFiVGFyZ2V0KG5lYXIpO1xuXG4gICAgICAgICAgICB2YXIgbWFrZUV2ZW50ID0gZnVuY3Rpb24gbWFrZUV2ZW50KHR5cGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIG5lYXIuZW1pdChtYWtlRXZlbnQoJ2dyYWJvbicpKTtcblxuICAgICAgICAgICAgaWYgKHNlbGVjdGVkTm9kZXMpIHtcbiAgICAgICAgICAgICAgc2VsZWN0ZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICAgICAgbi5lbWl0KG1ha2VFdmVudCgnZ3JhYicpKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZWFyLmVtaXQobWFrZUV2ZW50KCdncmFiJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRyaWdnZXJFdmVudHMobmVhciwgWyd0b3VjaHN0YXJ0JywgJ3RhcHN0YXJ0JywgJ3Ztb3VzZWRvd24nXSwgZSwge1xuICAgICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgICB5OiBub3dbMV1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKG5lYXIgPT0gbnVsbCkge1xuICAgICAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHtcbiAgICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICAgIH07XG4gICAgICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgICAgICAgICByLnJlZHJhdygpO1xuICAgICAgICB9IC8vIFRhcCwgdGFwaG9sZFxuICAgICAgICAvLyAtLS0tLVxuXG5cbiAgICAgICAgci50b3VjaERhdGEuc2luZ2xlVG91Y2hNb3ZlZCA9IGZhbHNlO1xuICAgICAgICByLnRvdWNoRGF0YS5zaW5nbGVUb3VjaFN0YXJ0VGltZSA9ICtuZXcgRGF0ZSgpO1xuICAgICAgICBjbGVhclRpbWVvdXQoci50b3VjaERhdGEudGFwaG9sZFRpbWVvdXQpO1xuICAgICAgICByLnRvdWNoRGF0YS50YXBob2xkVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChyLnRvdWNoRGF0YS5zaW5nbGVUb3VjaE1vdmVkID09PSBmYWxzZSAmJiAhci5waW5jaGluZyAvLyBpZiBwaW5jaGluZywgdGhlbiB0YXBob2xkIHVuc2VsZWN0IHNob3VsZG4ndCB0YWtlIGVmZmVjdFxuICAgICAgICAgICYmICFyLnRvdWNoRGF0YS5zZWxlY3RpbmcgLy8gYm94IHNlbGVjdGlvbiBzaG91bGRuJ3QgYWxsb3cgdGFwaG9sZCB0aHJvdWdoXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnRzKHIudG91Y2hEYXRhLnN0YXJ0LCBbJ3RhcGhvbGQnXSwgZSwge1xuICAgICAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCByLnRhcGhvbGREdXJhdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoID49IDEpIHtcbiAgICAgICAgdmFyIHNQb3MgPSByLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub3cubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBzUG9zW2ldID0gZWFybGllcltpXSA9IG5vd1tpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0b3VjaDAgPSBlLnRvdWNoZXNbMF07XG4gICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0R1Bvc2l0aW9uID0gW3RvdWNoMC5jbGllbnRYLCB0b3VjaDAuY2xpZW50WV07XG4gICAgICB9XG4gICAgfSwgZmFsc2UpO1xuICAgIHZhciB0b3VjaG1vdmVIYW5kbGVyO1xuICAgIHIucmVnaXN0ZXJCaW5kaW5nKHdpbmRvdywgJ3RvdWNobW92ZScsIHRvdWNobW92ZUhhbmRsZXIgPSBmdW5jdGlvbiB0b3VjaG1vdmVIYW5kbGVyKGUpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgICAgIHZhciBjYXB0dXJlID0gci50b3VjaERhdGEuY2FwdHVyZTtcblxuICAgICAgaWYgKCFjYXB0dXJlICYmICFldmVudEluQ29udGFpbmVyKGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHNlbGVjdCA9IHIuc2VsZWN0aW9uO1xuICAgICAgdmFyIGN5ID0gci5jeTtcbiAgICAgIHZhciBub3cgPSByLnRvdWNoRGF0YS5ub3c7XG4gICAgICB2YXIgZWFybGllciA9IHIudG91Y2hEYXRhLmVhcmxpZXI7XG4gICAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcblxuICAgICAgaWYgKGUudG91Y2hlc1swXSkge1xuICAgICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1swXS5jbGllbnRYLCBlLnRvdWNoZXNbMF0uY2xpZW50WSk7XG4gICAgICAgIG5vd1swXSA9IHBvc1swXTtcbiAgICAgICAgbm93WzFdID0gcG9zWzFdO1xuICAgICAgfVxuXG4gICAgICBpZiAoZS50b3VjaGVzWzFdKSB7XG4gICAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzFdLmNsaWVudFgsIGUudG91Y2hlc1sxXS5jbGllbnRZKTtcbiAgICAgICAgbm93WzJdID0gcG9zWzBdO1xuICAgICAgICBub3dbM10gPSBwb3NbMV07XG4gICAgICB9XG5cbiAgICAgIGlmIChlLnRvdWNoZXNbMl0pIHtcbiAgICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMl0uY2xpZW50WCwgZS50b3VjaGVzWzJdLmNsaWVudFkpO1xuICAgICAgICBub3dbNF0gPSBwb3NbMF07XG4gICAgICAgIG5vd1s1XSA9IHBvc1sxXTtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0YXJ0R1BvcyA9IHIudG91Y2hEYXRhLnN0YXJ0R1Bvc2l0aW9uO1xuICAgICAgdmFyIGlzT3ZlclRocmVzaG9sZERyYWc7XG5cbiAgICAgIGlmIChjYXB0dXJlICYmIGUudG91Y2hlc1swXSAmJiBzdGFydEdQb3MpIHtcbiAgICAgICAgdmFyIGRpc3AgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5vdy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGRpc3Bbal0gPSBub3dbal0gLSBlYXJsaWVyW2pdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGR4ID0gZS50b3VjaGVzWzBdLmNsaWVudFggLSBzdGFydEdQb3NbMF07XG4gICAgICAgIHZhciBkeDIgPSBkeCAqIGR4O1xuICAgICAgICB2YXIgZHkgPSBlLnRvdWNoZXNbMF0uY2xpZW50WSAtIHN0YXJ0R1Bvc1sxXTtcbiAgICAgICAgdmFyIGR5MiA9IGR5ICogZHk7XG4gICAgICAgIHZhciBkaXN0MiA9IGR4MiArIGR5MjtcbiAgICAgICAgaXNPdmVyVGhyZXNob2xkRHJhZyA9IGRpc3QyID49IHIudG91Y2hUYXBUaHJlc2hvbGQyO1xuICAgICAgfSAvLyBjb250ZXh0IHN3aXBlIGNhbmNlbGxpbmdcblxuXG4gICAgICBpZiAoY2FwdHVyZSAmJiByLnRvdWNoRGF0YS5jeHQpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB2YXIgZjF4MiA9IGUudG91Y2hlc1swXS5jbGllbnRYIC0gb2Zmc2V0TGVmdCxcbiAgICAgICAgICAgIGYxeTIgPSBlLnRvdWNoZXNbMF0uY2xpZW50WSAtIG9mZnNldFRvcDtcbiAgICAgICAgdmFyIGYyeDIgPSBlLnRvdWNoZXNbMV0uY2xpZW50WCAtIG9mZnNldExlZnQsXG4gICAgICAgICAgICBmMnkyID0gZS50b3VjaGVzWzFdLmNsaWVudFkgLSBvZmZzZXRUb3A7IC8vIHZhciBkaXN0YW5jZTIgPSBkaXN0YW5jZSggZjF4MiwgZjF5MiwgZjJ4MiwgZjJ5MiApO1xuXG4gICAgICAgIHZhciBkaXN0YW5jZTJTcSA9IGRpc3RhbmNlU3EoZjF4MiwgZjF5MiwgZjJ4MiwgZjJ5Mik7XG4gICAgICAgIHZhciBmYWN0b3JTcSA9IGRpc3RhbmNlMlNxIC8gZGlzdGFuY2UxU3E7XG4gICAgICAgIHZhciBkaXN0VGhyZXNob2xkID0gMTUwO1xuICAgICAgICB2YXIgZGlzdFRocmVzaG9sZFNxID0gZGlzdFRocmVzaG9sZCAqIGRpc3RUaHJlc2hvbGQ7XG4gICAgICAgIHZhciBmYWN0b3JUaHJlc2hvbGQgPSAxLjU7XG4gICAgICAgIHZhciBmYWN0b3JUaHJlc2hvbGRTcSA9IGZhY3RvclRocmVzaG9sZCAqIGZhY3RvclRocmVzaG9sZDsgLy8gY2FuY2VsIGN0eCBnZXN0dXJlcyBpZiB0aGUgZGlzdGFuY2UgYi90IHRoZSBmaW5nZXJzIGluY3JlYXNlc1xuXG4gICAgICAgIGlmIChmYWN0b3JTcSA+PSBmYWN0b3JUaHJlc2hvbGRTcSB8fCBkaXN0YW5jZTJTcSA+PSBkaXN0VGhyZXNob2xkU3EpIHtcbiAgICAgICAgICByLnRvdWNoRGF0YS5jeHQgPSBmYWxzZTtcbiAgICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgICAgICAgICB2YXIgY3h0RXZ0ID0ge1xuICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICAgIHR5cGU6ICdjeHR0YXBlbmQnLFxuICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgICAgICB5OiBub3dbMV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKHIudG91Y2hEYXRhLnN0YXJ0KSB7XG4gICAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydC51bmFjdGl2YXRlKCkuZW1pdChjeHRFdnQpO1xuICAgICAgICAgICAgci50b3VjaERhdGEuc3RhcnQgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjeS5lbWl0KGN4dEV2dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIGNvbnRleHQgc3dpcGVcblxuXG4gICAgICBpZiAoY2FwdHVyZSAmJiByLnRvdWNoRGF0YS5jeHQpIHtcbiAgICAgICAgdmFyIGN4dEV2dCA9IHtcbiAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgIHR5cGU6ICdjeHRkcmFnJyxcbiAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgICAgeTogbm93WzFdXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKHIudG91Y2hEYXRhLnN0YXJ0KSB7XG4gICAgICAgICAgci50b3VjaERhdGEuc3RhcnQuZW1pdChjeHRFdnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN5LmVtaXQoY3h0RXZ0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyLnRvdWNoRGF0YS5zdGFydCkge1xuICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0Ll9wcml2YXRlLmdyYWJiZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHIudG91Y2hEYXRhLmN4dERyYWdnZWQgPSB0cnVlO1xuICAgICAgICB2YXIgbmVhciA9IHIuZmluZE5lYXJlc3RFbGVtZW50KG5vd1swXSwgbm93WzFdLCB0cnVlLCB0cnVlKTtcblxuICAgICAgICBpZiAoIXIudG91Y2hEYXRhLmN4dE92ZXIgfHwgbmVhciAhPT0gci50b3VjaERhdGEuY3h0T3Zlcikge1xuICAgICAgICAgIGlmIChyLnRvdWNoRGF0YS5jeHRPdmVyKSB7XG4gICAgICAgICAgICByLnRvdWNoRGF0YS5jeHRPdmVyLmVtaXQoe1xuICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgICAgICB0eXBlOiAnY3h0ZHJhZ291dCcsXG4gICAgICAgICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByLnRvdWNoRGF0YS5jeHRPdmVyID0gbmVhcjtcblxuICAgICAgICAgIGlmIChuZWFyKSB7XG4gICAgICAgICAgICBuZWFyLmVtaXQoe1xuICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgICAgICB0eXBlOiAnY3h0ZHJhZ292ZXInLFxuICAgICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgICAgICAgICB5OiBub3dbMV1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIGJveCBzZWxlY3Rpb25cblxuICAgICAgfSBlbHNlIGlmIChjYXB0dXJlICYmIGUudG91Y2hlc1syXSAmJiBjeS5ib3hTZWxlY3Rpb25FbmFibGVkKCkpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMubGFzdFRocmVlVG91Y2ggPSArbmV3IERhdGUoKTtcblxuICAgICAgICBpZiAoIXIudG91Y2hEYXRhLnNlbGVjdGluZykge1xuICAgICAgICAgIGN5LmVtaXQoe1xuICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICAgIHR5cGU6ICdib3hzdGFydCcsXG4gICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgci50b3VjaERhdGEuc2VsZWN0aW5nID0gdHJ1ZTtcbiAgICAgICAgci50b3VjaERhdGEuZGlkU2VsZWN0ID0gdHJ1ZTtcbiAgICAgICAgc2VsZWN0WzRdID0gMTtcblxuICAgICAgICBpZiAoIXNlbGVjdCB8fCBzZWxlY3QubGVuZ3RoID09PSAwIHx8IHNlbGVjdFswXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgc2VsZWN0WzBdID0gKG5vd1swXSArIG5vd1syXSArIG5vd1s0XSkgLyAzO1xuICAgICAgICAgIHNlbGVjdFsxXSA9IChub3dbMV0gKyBub3dbM10gKyBub3dbNV0pIC8gMztcbiAgICAgICAgICBzZWxlY3RbMl0gPSAobm93WzBdICsgbm93WzJdICsgbm93WzRdKSAvIDMgKyAxO1xuICAgICAgICAgIHNlbGVjdFszXSA9IChub3dbMV0gKyBub3dbM10gKyBub3dbNV0pIC8gMyArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VsZWN0WzJdID0gKG5vd1swXSArIG5vd1syXSArIG5vd1s0XSkgLyAzO1xuICAgICAgICAgIHNlbGVjdFszXSA9IChub3dbMV0gKyBub3dbM10gKyBub3dbNV0pIC8gMztcbiAgICAgICAgfVxuXG4gICAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG4gICAgICAgIHIucmVkcmF3KCk7IC8vIHBpbmNoIHRvIHpvb21cbiAgICAgIH0gZWxzZSBpZiAoY2FwdHVyZSAmJiBlLnRvdWNoZXNbMV0gJiYgIXIudG91Y2hEYXRhLmRpZFNlbGVjdCAvLyBkb24ndCBhbGxvdyBib3ggc2VsZWN0aW9uIHRvIGRlZ3JhZGUgdG8gcGluY2gtdG8tem9vbVxuICAgICAgJiYgY3kuem9vbWluZ0VuYWJsZWQoKSAmJiBjeS5wYW5uaW5nRW5hYmxlZCgpICYmIGN5LnVzZXJab29taW5nRW5hYmxlZCgpICYmIGN5LnVzZXJQYW5uaW5nRW5hYmxlZCgpKSB7XG4gICAgICAgIC8vIHR3byBmaW5nZXJzID0+IHBpbmNoIHRvIHpvb21cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG4gICAgICAgIHZhciBkcmFnZ2VkRWxlcyA9IHIuZHJhZ0RhdGEudG91Y2hEcmFnRWxlcztcblxuICAgICAgICBpZiAoZHJhZ2dlZEVsZXMpIHtcbiAgICAgICAgICByLnJlZHJhd0hpbnQoJ2RyYWcnLCB0cnVlKTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZHJhZ2dlZEVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBkZV9wID0gZHJhZ2dlZEVsZXNbaV0uX3ByaXZhdGU7XG4gICAgICAgICAgICBkZV9wLmdyYWJiZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGRlX3AucnNjcmF0Y2guaW5EcmFnTGF5ZXIgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX3N0YXJ0ID0gci50b3VjaERhdGEuc3RhcnQ7IC8vICh4MiwgeTIpIGZvciBmaW5nZXJzIDEgYW5kIDJcblxuICAgICAgICB2YXIgZjF4MiA9IGUudG91Y2hlc1swXS5jbGllbnRYIC0gb2Zmc2V0TGVmdCxcbiAgICAgICAgICAgIGYxeTIgPSBlLnRvdWNoZXNbMF0uY2xpZW50WSAtIG9mZnNldFRvcDtcbiAgICAgICAgdmFyIGYyeDIgPSBlLnRvdWNoZXNbMV0uY2xpZW50WCAtIG9mZnNldExlZnQsXG4gICAgICAgICAgICBmMnkyID0gZS50b3VjaGVzWzFdLmNsaWVudFkgLSBvZmZzZXRUb3A7XG4gICAgICAgIHZhciBkaXN0YW5jZTIgPSBkaXN0YW5jZShmMXgyLCBmMXkyLCBmMngyLCBmMnkyKTsgLy8gdmFyIGRpc3RhbmNlMlNxID0gZGlzdGFuY2VTcSggZjF4MiwgZjF5MiwgZjJ4MiwgZjJ5MiApO1xuICAgICAgICAvLyB2YXIgZmFjdG9yID0gTWF0aC5zcXJ0KCBkaXN0YW5jZTJTcSApIC8gTWF0aC5zcXJ0KCBkaXN0YW5jZTFTcSApO1xuXG4gICAgICAgIHZhciBmYWN0b3IgPSBkaXN0YW5jZTIgLyBkaXN0YW5jZTE7XG5cbiAgICAgICAgaWYgKHR3b0ZpbmdlcnNTdGFydEluc2lkZSkge1xuICAgICAgICAgIC8vIGRlbHRhIGZpbmdlcjFcbiAgICAgICAgICB2YXIgZGYxeCA9IGYxeDIgLSBmMXgxO1xuICAgICAgICAgIHZhciBkZjF5ID0gZjF5MiAtIGYxeTE7IC8vIGRlbHRhIGZpbmdlciAyXG5cbiAgICAgICAgICB2YXIgZGYyeCA9IGYyeDIgLSBmMngxO1xuICAgICAgICAgIHZhciBkZjJ5ID0gZjJ5MiAtIGYyeTE7IC8vIHRyYW5zbGF0aW9uIGlzIHRoZSBub3JtYWxpc2VkIHZlY3RvciBvZiB0aGUgdHdvIGZpbmdlcnMgbW92ZW1lbnRcbiAgICAgICAgICAvLyBpLmUuIHNvIHBpbmNoaW5nIGNhbmNlbHMgb3V0IGFuZCBtb3ZpbmcgdG9nZXRoZXIgcGFuc1xuXG4gICAgICAgICAgdmFyIHR4ID0gKGRmMXggKyBkZjJ4KSAvIDI7XG4gICAgICAgICAgdmFyIHR5ID0gKGRmMXkgKyBkZjJ5KSAvIDI7IC8vIG5vdyBjYWxjdWxhdGUgdGhlIHpvb21cblxuICAgICAgICAgIHZhciB6b29tMSA9IGN5Lnpvb20oKTtcbiAgICAgICAgICB2YXIgem9vbTIgPSB6b29tMSAqIGZhY3RvcjtcbiAgICAgICAgICB2YXIgcGFuMSA9IGN5LnBhbigpOyAvLyB0aGUgbW9kZWwgY2VudGVyIHBvaW50IGNvbnZlcnRlZCB0byB0aGUgY3VycmVudCByZW5kZXJlZCBwb3NcblxuICAgICAgICAgIHZhciBjdHJ4ID0gbW9kZWxDZW50ZXIxWzBdICogem9vbTEgKyBwYW4xLng7XG4gICAgICAgICAgdmFyIGN0cnkgPSBtb2RlbENlbnRlcjFbMV0gKiB6b29tMSArIHBhbjEueTtcbiAgICAgICAgICB2YXIgcGFuMiA9IHtcbiAgICAgICAgICAgIHg6IC16b29tMiAvIHpvb20xICogKGN0cnggLSBwYW4xLnggLSB0eCkgKyBjdHJ4LFxuICAgICAgICAgICAgeTogLXpvb20yIC8gem9vbTEgKiAoY3RyeSAtIHBhbjEueSAtIHR5KSArIGN0cnlcbiAgICAgICAgICB9OyAvLyByZW1vdmUgZHJhZ2dlZCBlbGVzXG5cbiAgICAgICAgICBpZiAoX3N0YXJ0ICYmIF9zdGFydC5hY3RpdmUoKSkge1xuICAgICAgICAgICAgdmFyIGRyYWdnZWRFbGVzID0gci5kcmFnRGF0YS50b3VjaERyYWdFbGVzO1xuICAgICAgICAgICAgZnJlZURyYWdnZWRFbGVtZW50cyhkcmFnZ2VkRWxlcyk7XG4gICAgICAgICAgICByLnJlZHJhd0hpbnQoJ2RyYWcnLCB0cnVlKTtcbiAgICAgICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuXG4gICAgICAgICAgICBfc3RhcnQudW5hY3RpdmF0ZSgpLmVtaXQoJ2ZyZWVvbicpO1xuXG4gICAgICAgICAgICBkcmFnZ2VkRWxlcy5lbWl0KCdmcmVlJyk7XG5cbiAgICAgICAgICAgIGlmIChyLmRyYWdEYXRhLmRpZERyYWcpIHtcbiAgICAgICAgICAgICAgX3N0YXJ0LmVtaXQoJ2RyYWdmcmVlb24nKTtcblxuICAgICAgICAgICAgICBkcmFnZ2VkRWxlcy5lbWl0KCdkcmFnZnJlZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGN5LnZpZXdwb3J0KHtcbiAgICAgICAgICAgIHpvb206IHpvb20yLFxuICAgICAgICAgICAgcGFuOiBwYW4yLFxuICAgICAgICAgICAgY2FuY2VsT25GYWlsZWRab29tOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY3kuZW1pdCgncGluY2h6b29tJyk7XG4gICAgICAgICAgZGlzdGFuY2UxID0gZGlzdGFuY2UyO1xuICAgICAgICAgIGYxeDEgPSBmMXgyO1xuICAgICAgICAgIGYxeTEgPSBmMXkyO1xuICAgICAgICAgIGYyeDEgPSBmMngyO1xuICAgICAgICAgIGYyeTEgPSBmMnkyO1xuICAgICAgICAgIHIucGluY2hpbmcgPSB0cnVlO1xuICAgICAgICB9IC8vIFJlLXByb2plY3RcblxuXG4gICAgICAgIGlmIChlLnRvdWNoZXNbMF0pIHtcbiAgICAgICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1swXS5jbGllbnRYLCBlLnRvdWNoZXNbMF0uY2xpZW50WSk7XG4gICAgICAgICAgbm93WzBdID0gcG9zWzBdO1xuICAgICAgICAgIG5vd1sxXSA9IHBvc1sxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlLnRvdWNoZXNbMV0pIHtcbiAgICAgICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1sxXS5jbGllbnRYLCBlLnRvdWNoZXNbMV0uY2xpZW50WSk7XG4gICAgICAgICAgbm93WzJdID0gcG9zWzBdO1xuICAgICAgICAgIG5vd1szXSA9IHBvc1sxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlLnRvdWNoZXNbMl0pIHtcbiAgICAgICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1syXS5jbGllbnRYLCBlLnRvdWNoZXNbMl0uY2xpZW50WSk7XG4gICAgICAgICAgbm93WzRdID0gcG9zWzBdO1xuICAgICAgICAgIG5vd1s1XSA9IHBvc1sxXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChlLnRvdWNoZXNbMF0gJiYgIXIudG91Y2hEYXRhLmRpZFNlbGVjdCAvLyBkb24ndCBhbGxvdyBib3ggc2VsZWN0aW9uIHRvIGRlZ3JhZGUgdG8gc2luZ2xlIGZpbmdlciBldmVudHMgbGlrZSBwYW5uaW5nXG4gICAgICApIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gci50b3VjaERhdGEuc3RhcnQ7XG4gICAgICAgIHZhciBsYXN0ID0gci50b3VjaERhdGEubGFzdDtcbiAgICAgICAgdmFyIG5lYXI7XG5cbiAgICAgICAgaWYgKCFyLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgJiYgIXIuc3dpcGVQYW5uaW5nKSB7XG4gICAgICAgICAgbmVhciA9IHIuZmluZE5lYXJlc3RFbGVtZW50KG5vd1swXSwgbm93WzFdLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjYXB0dXJlICYmIHN0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0gLy8gZHJhZ2dpbmcgbm9kZXNcblxuXG4gICAgICAgIGlmIChjYXB0dXJlICYmIHN0YXJ0ICE9IG51bGwgJiYgci5ub2RlSXNEcmFnZ2FibGUoc3RhcnQpKSB7XG4gICAgICAgICAgaWYgKGlzT3ZlclRocmVzaG9sZERyYWcpIHtcbiAgICAgICAgICAgIC8vIHRoZW4gZHJhZ2dpbmcgY2FuIGhhcHBlblxuICAgICAgICAgICAgdmFyIGRyYWdnZWRFbGVzID0gci5kcmFnRGF0YS50b3VjaERyYWdFbGVzO1xuICAgICAgICAgICAgdmFyIGp1c3RTdGFydGVkRHJhZyA9ICFyLmRyYWdEYXRhLmRpZERyYWc7XG5cbiAgICAgICAgICAgIGlmIChqdXN0U3RhcnRlZERyYWcpIHtcbiAgICAgICAgICAgICAgYWRkTm9kZXNUb0RyYWcoZHJhZ2dlZEVsZXMsIHtcbiAgICAgICAgICAgICAgICBpbkRyYWdMYXllcjogdHJ1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgci5kcmFnRGF0YS5kaWREcmFnID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciB0b3RhbFNoaWZ0ID0ge1xuICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICB5OiAwXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAobnVtYmVyJDEoZGlzcFswXSkgJiYgbnVtYmVyJDEoZGlzcFsxXSkpIHtcbiAgICAgICAgICAgICAgdG90YWxTaGlmdC54ICs9IGRpc3BbMF07XG4gICAgICAgICAgICAgIHRvdGFsU2hpZnQueSArPSBkaXNwWzFdO1xuXG4gICAgICAgICAgICAgIGlmIChqdXN0U3RhcnRlZERyYWcpIHtcbiAgICAgICAgICAgICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB2YXIgZHJhZ0RlbHRhID0gci50b3VjaERhdGEuZHJhZ0RlbHRhO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRyYWdEZWx0YSAmJiBudW1iZXIkMShkcmFnRGVsdGFbMF0pICYmIG51bWJlciQxKGRyYWdEZWx0YVsxXSkpIHtcbiAgICAgICAgICAgICAgICAgIHRvdGFsU2hpZnQueCArPSBkcmFnRGVsdGFbMF07XG4gICAgICAgICAgICAgICAgICB0b3RhbFNoaWZ0LnkgKz0gZHJhZ0RlbHRhWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgPSB0cnVlO1xuICAgICAgICAgICAgZHJhZ2dlZEVsZXMuc2lsZW50U2hpZnQodG90YWxTaGlmdCkuZW1pdCgncG9zaXRpb24gZHJhZycpO1xuICAgICAgICAgICAgci5yZWRyYXdIaW50KCdkcmFnJywgdHJ1ZSk7XG5cbiAgICAgICAgICAgIGlmIChyLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uWzBdID09IGVhcmxpZXJbMF0gJiYgci50b3VjaERhdGEuc3RhcnRQb3NpdGlvblsxXSA9PSBlYXJsaWVyWzFdKSB7XG4gICAgICAgICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByLnJlZHJhdygpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBvdGhlcndpc2Uga2VlcCB0cmFjayBvZiBkcmFnIGRlbHRhIGZvciBsYXRlclxuICAgICAgICAgICAgdmFyIGRyYWdEZWx0YSA9IHIudG91Y2hEYXRhLmRyYWdEZWx0YSA9IHIudG91Y2hEYXRhLmRyYWdEZWx0YSB8fCBbXTtcblxuICAgICAgICAgICAgaWYgKGRyYWdEZWx0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgZHJhZ0RlbHRhLnB1c2goZGlzcFswXSk7XG4gICAgICAgICAgICAgIGRyYWdEZWx0YS5wdXNoKGRpc3BbMV0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZHJhZ0RlbHRhWzBdICs9IGRpc3BbMF07XG4gICAgICAgICAgICAgIGRyYWdEZWx0YVsxXSArPSBkaXNwWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyB0b3VjaG1vdmVcblxuXG4gICAgICAgIHtcbiAgICAgICAgICB0cmlnZ2VyRXZlbnRzKHN0YXJ0IHx8IG5lYXIsIFsndG91Y2htb3ZlJywgJ3RhcGRyYWcnLCAndm1vdXNlbW92ZSddLCBlLCB7XG4gICAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgICB5OiBub3dbMV1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICgoIXN0YXJ0IHx8ICFzdGFydC5ncmFiYmVkKCkpICYmIG5lYXIgIT0gbGFzdCkge1xuICAgICAgICAgICAgaWYgKGxhc3QpIHtcbiAgICAgICAgICAgICAgbGFzdC5lbWl0KHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgICAgICAgIHR5cGU6ICd0YXBkcmFnb3V0JyxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgICAgICAgICAgeTogbm93WzFdXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5lYXIpIHtcbiAgICAgICAgICAgICAgbmVhci5lbWl0KHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgICAgICAgIHR5cGU6ICd0YXBkcmFnb3ZlcicsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgci50b3VjaERhdGEubGFzdCA9IG5lYXI7XG4gICAgICAgIH0gLy8gY2hlY2sgdG8gY2FuY2VsIHRhcGhvbGRcblxuICAgICAgICBpZiAoY2FwdHVyZSkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm93Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobm93W2ldICYmIHIudG91Y2hEYXRhLnN0YXJ0UG9zaXRpb25baV0gJiYgaXNPdmVyVGhyZXNob2xkRHJhZykge1xuICAgICAgICAgICAgICByLnRvdWNoRGF0YS5zaW5nbGVUb3VjaE1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gcGFubmluZ1xuXG5cbiAgICAgICAgaWYgKGNhcHR1cmUgJiYgKHN0YXJ0ID09IG51bGwgfHwgc3RhcnQucGFubmFibGUoKSkgJiYgY3kucGFubmluZ0VuYWJsZWQoKSAmJiBjeS51c2VyUGFubmluZ0VuYWJsZWQoKSkge1xuICAgICAgICAgIHZhciBhbGxvd1Bhc3N0aHJvdWdoID0gYWxsb3dQYW5uaW5nUGFzc3Rocm91Z2goc3RhcnQsIHIudG91Y2hEYXRhLnN0YXJ0cyk7XG5cbiAgICAgICAgICBpZiAoYWxsb3dQYXNzdGhyb3VnaCkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICBpZiAoIXIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbikge1xuICAgICAgICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSBhcnJheTJwb2ludChyLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHIuc3dpcGVQYW5uaW5nKSB7XG4gICAgICAgICAgICAgIGN5LnBhbkJ5KHtcbiAgICAgICAgICAgICAgICB4OiBkaXNwWzBdICogem9vbSxcbiAgICAgICAgICAgICAgICB5OiBkaXNwWzFdICogem9vbVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY3kuZW1pdCgnZHJhZ3BhbicpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc092ZXJUaHJlc2hvbGREcmFnKSB7XG4gICAgICAgICAgICAgIHIuc3dpcGVQYW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgY3kucGFuQnkoe1xuICAgICAgICAgICAgICAgIHg6IGR4ICogem9vbSxcbiAgICAgICAgICAgICAgICB5OiBkeSAqIHpvb21cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGN5LmVtaXQoJ2RyYWdwYW4nKTtcblxuICAgICAgICAgICAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgICAgICAgICBzdGFydC51bmFjdGl2YXRlKCk7XG4gICAgICAgICAgICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydCA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIFJlLXByb2plY3RcblxuXG4gICAgICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMF0uY2xpZW50WCwgZS50b3VjaGVzWzBdLmNsaWVudFkpO1xuICAgICAgICAgIG5vd1swXSA9IHBvc1swXTtcbiAgICAgICAgICBub3dbMV0gPSBwb3NbMV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBub3cubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgZWFybGllcltqXSA9IG5vd1tqXTtcbiAgICAgIH0gLy8gdGhlIGFjdGl2ZSBiZyBpbmRpY2F0b3Igc2hvdWxkIGJlIHJlbW92ZWQgd2hlbiBtYWtpbmcgYSBzd2lwZSB0aGF0IGlzIG5laXRoZXIgZm9yIGRyYWdnaW5nIG5vZGVzIG9yIHBhbm5pbmdcblxuXG4gICAgICBpZiAoY2FwdHVyZSAmJiBlLnRvdWNoZXMubGVuZ3RoID4gMCAmJiAhci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzICYmICFyLnN3aXBlUGFubmluZyAmJiByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gIT0gbnVsbCkge1xuICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG4gICAgICAgIHIucmVkcmF3KCk7XG4gICAgICB9XG4gICAgfSwgZmFsc2UpO1xuICAgIHZhciB0b3VjaGNhbmNlbEhhbmRsZXI7XG4gICAgci5yZWdpc3RlckJpbmRpbmcod2luZG93LCAndG91Y2hjYW5jZWwnLCB0b3VjaGNhbmNlbEhhbmRsZXIgPSBmdW5jdGlvbiB0b3VjaGNhbmNlbEhhbmRsZXIoZSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgdmFyIHN0YXJ0ID0gci50b3VjaERhdGEuc3RhcnQ7XG4gICAgICByLnRvdWNoRGF0YS5jYXB0dXJlID0gZmFsc2U7XG5cbiAgICAgIGlmIChzdGFydCkge1xuICAgICAgICBzdGFydC51bmFjdGl2YXRlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdmFyIHRvdWNoZW5kSGFuZGxlciwgZGlkRG91YmxlVG91Y2gsIHRvdWNoVGltZW91dCwgcHJldlRvdWNoVGltZVN0YW1wO1xuICAgIHIucmVnaXN0ZXJCaW5kaW5nKHdpbmRvdywgJ3RvdWNoZW5kJywgdG91Y2hlbmRIYW5kbGVyID0gZnVuY3Rpb24gdG91Y2hlbmRIYW5kbGVyKGUpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHZhciBzdGFydCA9IHIudG91Y2hEYXRhLnN0YXJ0O1xuICAgICAgdmFyIGNhcHR1cmUgPSByLnRvdWNoRGF0YS5jYXB0dXJlO1xuXG4gICAgICBpZiAoY2FwdHVyZSkge1xuICAgICAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHIudG91Y2hEYXRhLmNhcHR1cmUgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHNlbGVjdCA9IHIuc2VsZWN0aW9uO1xuICAgICAgci5zd2lwZVBhbm5pbmcgPSBmYWxzZTtcbiAgICAgIHIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcyA9IGZhbHNlO1xuICAgICAgdmFyIGN5ID0gci5jeTtcbiAgICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuICAgICAgdmFyIG5vdyA9IHIudG91Y2hEYXRhLm5vdztcbiAgICAgIHZhciBlYXJsaWVyID0gci50b3VjaERhdGEuZWFybGllcjtcblxuICAgICAgaWYgKGUudG91Y2hlc1swXSkge1xuICAgICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1swXS5jbGllbnRYLCBlLnRvdWNoZXNbMF0uY2xpZW50WSk7XG4gICAgICAgIG5vd1swXSA9IHBvc1swXTtcbiAgICAgICAgbm93WzFdID0gcG9zWzFdO1xuICAgICAgfVxuXG4gICAgICBpZiAoZS50b3VjaGVzWzFdKSB7XG4gICAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzFdLmNsaWVudFgsIGUudG91Y2hlc1sxXS5jbGllbnRZKTtcbiAgICAgICAgbm93WzJdID0gcG9zWzBdO1xuICAgICAgICBub3dbM10gPSBwb3NbMV07XG4gICAgICB9XG5cbiAgICAgIGlmIChlLnRvdWNoZXNbMl0pIHtcbiAgICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMl0uY2xpZW50WCwgZS50b3VjaGVzWzJdLmNsaWVudFkpO1xuICAgICAgICBub3dbNF0gPSBwb3NbMF07XG4gICAgICAgIG5vd1s1XSA9IHBvc1sxXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXJ0KSB7XG4gICAgICAgIHN0YXJ0LnVuYWN0aXZhdGUoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGN0eFRhcGVuZDtcblxuICAgICAgaWYgKHIudG91Y2hEYXRhLmN4dCkge1xuICAgICAgICBjdHhUYXBlbmQgPSB7XG4gICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICB0eXBlOiAnY3h0dGFwZW5kJyxcbiAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgICAgeTogbm93WzFdXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChzdGFydCkge1xuICAgICAgICAgIHN0YXJ0LmVtaXQoY3R4VGFwZW5kKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjeS5lbWl0KGN0eFRhcGVuZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXIudG91Y2hEYXRhLmN4dERyYWdnZWQpIHtcbiAgICAgICAgICB2YXIgY3R4VGFwID0ge1xuICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgICAgIHR5cGU6ICdjeHR0YXAnLFxuICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgICAgICB5OiBub3dbMV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKHN0YXJ0KSB7XG4gICAgICAgICAgICBzdGFydC5lbWl0KGN0eFRhcCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN5LmVtaXQoY3R4VGFwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoci50b3VjaERhdGEuc3RhcnQpIHtcbiAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydC5fcHJpdmF0ZS5ncmFiYmVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByLnRvdWNoRGF0YS5jeHQgPSBmYWxzZTtcbiAgICAgICAgci50b3VjaERhdGEuc3RhcnQgPSBudWxsO1xuICAgICAgICByLnJlZHJhdygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIG5vIG1vcmUgYm94IHNlbGVjdGlvbiBpZiB3ZSBkb24ndCBoYXZlIHRocmVlIGZpbmdlcnNcblxuXG4gICAgICBpZiAoIWUudG91Y2hlc1syXSAmJiBjeS5ib3hTZWxlY3Rpb25FbmFibGVkKCkgJiYgci50b3VjaERhdGEuc2VsZWN0aW5nKSB7XG4gICAgICAgIHIudG91Y2hEYXRhLnNlbGVjdGluZyA9IGZhbHNlO1xuICAgICAgICB2YXIgYm94ID0gY3kuY29sbGVjdGlvbihyLmdldEFsbEluQm94KHNlbGVjdFswXSwgc2VsZWN0WzFdLCBzZWxlY3RbMl0sIHNlbGVjdFszXSkpO1xuICAgICAgICBzZWxlY3RbMF0gPSB1bmRlZmluZWQ7XG4gICAgICAgIHNlbGVjdFsxXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgc2VsZWN0WzJdID0gdW5kZWZpbmVkO1xuICAgICAgICBzZWxlY3RbM10gPSB1bmRlZmluZWQ7XG4gICAgICAgIHNlbGVjdFs0XSA9IDA7XG4gICAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG4gICAgICAgIGN5LmVtaXQoe1xuICAgICAgICAgIHR5cGU6ICdib3hlbmQnLFxuICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGVsZVdvdWxkQmVTZWxlY3RlZCA9IGZ1bmN0aW9uIGVsZVdvdWxkQmVTZWxlY3RlZChlbGUpIHtcbiAgICAgICAgICByZXR1cm4gZWxlLnNlbGVjdGFibGUoKSAmJiAhZWxlLnNlbGVjdGVkKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgYm94LmVtaXQoJ2JveCcpLnN0ZEZpbHRlcihlbGVXb3VsZEJlU2VsZWN0ZWQpLnNlbGVjdCgpLmVtaXQoJ2JveHNlbGVjdCcpO1xuXG4gICAgICAgIGlmIChib3gubm9uZW1wdHkoKSkge1xuICAgICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgc3RhcnQudW5hY3RpdmF0ZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZS50b3VjaGVzWzJdKSB7XG4gICAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoZS50b3VjaGVzWzFdKSA7IGVsc2UgaWYgKGUudG91Y2hlc1swXSkgOyBlbHNlIGlmICghZS50b3VjaGVzWzBdKSB7XG4gICAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgICAgICAgdmFyIGRyYWdnZWRFbGVzID0gci5kcmFnRGF0YS50b3VjaERyYWdFbGVzO1xuXG4gICAgICAgIGlmIChzdGFydCAhPSBudWxsKSB7XG4gICAgICAgICAgdmFyIHN0YXJ0V2FzR3JhYmJlZCA9IHN0YXJ0Ll9wcml2YXRlLmdyYWJiZWQ7XG4gICAgICAgICAgZnJlZURyYWdnZWRFbGVtZW50cyhkcmFnZ2VkRWxlcyk7XG4gICAgICAgICAgci5yZWRyYXdIaW50KCdkcmFnJywgdHJ1ZSk7XG4gICAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG5cbiAgICAgICAgICBpZiAoc3RhcnRXYXNHcmFiYmVkKSB7XG4gICAgICAgICAgICBzdGFydC5lbWl0KCdmcmVlb24nKTtcbiAgICAgICAgICAgIGRyYWdnZWRFbGVzLmVtaXQoJ2ZyZWUnKTtcblxuICAgICAgICAgICAgaWYgKHIuZHJhZ0RhdGEuZGlkRHJhZykge1xuICAgICAgICAgICAgICBzdGFydC5lbWl0KCdkcmFnZnJlZW9uJyk7XG4gICAgICAgICAgICAgIGRyYWdnZWRFbGVzLmVtaXQoJ2RyYWdmcmVlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdHJpZ2dlckV2ZW50cyhzdGFydCwgWyd0b3VjaGVuZCcsICd0YXBlbmQnLCAndm1vdXNldXAnLCAndGFwZHJhZ291dCddLCBlLCB7XG4gICAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgICB5OiBub3dbMV1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzdGFydC51bmFjdGl2YXRlKCk7XG4gICAgICAgICAgci50b3VjaERhdGEuc3RhcnQgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBuZWFyID0gci5maW5kTmVhcmVzdEVsZW1lbnQobm93WzBdLCBub3dbMV0sIHRydWUsIHRydWUpO1xuICAgICAgICAgIHRyaWdnZXJFdmVudHMobmVhciwgWyd0b3VjaGVuZCcsICd0YXBlbmQnLCAndm1vdXNldXAnLCAndGFwZHJhZ291dCddLCBlLCB7XG4gICAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgICB5OiBub3dbMV1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkeCA9IHIudG91Y2hEYXRhLnN0YXJ0UG9zaXRpb25bMF0gLSBub3dbMF07XG4gICAgICAgIHZhciBkeDIgPSBkeCAqIGR4O1xuICAgICAgICB2YXIgZHkgPSByLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uWzFdIC0gbm93WzFdO1xuICAgICAgICB2YXIgZHkyID0gZHkgKiBkeTtcbiAgICAgICAgdmFyIGRpc3QyID0gZHgyICsgZHkyO1xuICAgICAgICB2YXIgcmRpc3QyID0gZGlzdDIgKiB6b29tICogem9vbTsgLy8gVGFwIGV2ZW50LCByb3VnaGx5IHNhbWUgYXMgbW91c2UgY2xpY2sgZXZlbnQgZm9yIHRvdWNoXG5cbiAgICAgICAgaWYgKCFyLnRvdWNoRGF0YS5zaW5nbGVUb3VjaE1vdmVkKSB7XG4gICAgICAgICAgaWYgKCFzdGFydCkge1xuICAgICAgICAgICAgY3kuJCgnOnNlbGVjdGVkJykudW5zZWxlY3QoWyd0YXB1bnNlbGVjdCddKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0cmlnZ2VyRXZlbnRzKHN0YXJ0LCBbJ3RhcCcsICd2Y2xpY2snXSwgZSwge1xuICAgICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgICAgeTogbm93WzFdXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZGlkRG91YmxlVG91Y2ggPSBmYWxzZTtcblxuICAgICAgICAgIGlmIChlLnRpbWVTdGFtcCAtIHByZXZUb3VjaFRpbWVTdGFtcCA8PSBjeS5tdWx0aUNsaWNrRGVib3VuY2VUaW1lKCkpIHtcbiAgICAgICAgICAgIHRvdWNoVGltZW91dCAmJiBjbGVhclRpbWVvdXQodG91Y2hUaW1lb3V0KTtcbiAgICAgICAgICAgIGRpZERvdWJsZVRvdWNoID0gdHJ1ZTtcbiAgICAgICAgICAgIHByZXZUb3VjaFRpbWVTdGFtcCA9IG51bGw7XG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnRzKHN0YXJ0LCBbJ2RibHRhcCcsICd2ZGJsY2xpY2snXSwgZSwge1xuICAgICAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRvdWNoVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAoZGlkRG91YmxlVG91Y2gpIHJldHVybjtcbiAgICAgICAgICAgICAgdHJpZ2dlckV2ZW50cyhzdGFydCwgWydvbmV0YXAnLCAndm9uZWNsaWNrJ10sIGUsIHtcbiAgICAgICAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgICAgICAgeTogbm93WzFdXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgY3kubXVsdGlDbGlja0RlYm91bmNlVGltZSgpKTtcbiAgICAgICAgICAgIHByZXZUb3VjaFRpbWVTdGFtcCA9IGUudGltZVN0YW1wO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBQcmVwYXJlIHRvIHNlbGVjdCB0aGUgY3VycmVudGx5IHRvdWNoZWQgbm9kZSwgb25seSBpZiBpdCBoYXNuJ3QgYmVlbiBkcmFnZ2VkIHBhc3QgYSBjZXJ0YWluIGRpc3RhbmNlXG5cblxuICAgICAgICBpZiAoc3RhcnQgIT0gbnVsbCAmJiAhci5kcmFnRGF0YS5kaWREcmFnIC8vIGRpZG4ndCBkcmFnIG5vZGVzIGFyb3VuZFxuICAgICAgICAmJiBzdGFydC5fcHJpdmF0ZS5zZWxlY3RhYmxlICYmIHJkaXN0MiA8IHIudG91Y2hUYXBUaHJlc2hvbGQyICYmICFyLnBpbmNoaW5nIC8vIHBpbmNoIHRvIHpvb20gc2hvdWxkIG5vdCBhZmZlY3Qgc2VsZWN0aW9uXG4gICAgICAgICkge1xuICAgICAgICAgIGlmIChjeS5zZWxlY3Rpb25UeXBlKCkgPT09ICdzaW5nbGUnKSB7XG4gICAgICAgICAgICBjeS4kKGlzU2VsZWN0ZWQpLnVubWVyZ2Uoc3RhcnQpLnVuc2VsZWN0KFsndGFwdW5zZWxlY3QnXSk7XG4gICAgICAgICAgICBzdGFydC5zZWxlY3QoWyd0YXBzZWxlY3QnXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzdGFydC5zZWxlY3RlZCgpKSB7XG4gICAgICAgICAgICAgIHN0YXJ0LnVuc2VsZWN0KFsndGFwdW5zZWxlY3QnXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdGFydC5zZWxlY3QoWyd0YXBzZWxlY3QnXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByLnRvdWNoRGF0YS5zaW5nbGVUb3VjaE1vdmVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBub3cubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgZWFybGllcltqXSA9IG5vd1tqXTtcbiAgICAgIH1cblxuICAgICAgci5kcmFnRGF0YS5kaWREcmFnID0gZmFsc2U7IC8vIHJlc2V0IGZvciBuZXh0IHRvdWNoc3RhcnRcblxuICAgICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgci50b3VjaERhdGEuZHJhZ0RlbHRhID0gW107XG4gICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0UG9zaXRpb24gPSBudWxsO1xuICAgICAgICByLnRvdWNoRGF0YS5zdGFydEdQb3NpdGlvbiA9IG51bGw7XG4gICAgICAgIHIudG91Y2hEYXRhLmRpZFNlbGVjdCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAvLyB0aGUgb2xkIHN0YXJ0IGdsb2JhbCBwb3MnbiBtYXkgbm90IGJlIHRoZSBzYW1lIGZpbmdlciB0aGF0IHJlbWFpbnNcbiAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydEdQb3NpdGlvbiA9IFtlLnRvdWNoZXNbMF0uY2xpZW50WCwgZS50b3VjaGVzWzBdLmNsaWVudFldO1xuICAgICAgICB9XG5cbiAgICAgICAgci5waW5jaGluZyA9IGZhbHNlO1xuICAgICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgIH0gLy9yLnJlZHJhdygpO1xuXG4gICAgfSwgZmFsc2UpOyAvLyBmYWxsYmFjayBjb21wYXRpYmlsaXR5IGxheWVyIGZvciBtcyBwb2ludGVyIGV2ZW50c1xuXG4gICAgaWYgKHR5cGVvZiBUb3VjaEV2ZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdmFyIHBvaW50ZXJzID0gW107XG5cbiAgICAgIHZhciBtYWtlVG91Y2ggPSBmdW5jdGlvbiBtYWtlVG91Y2goZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNsaWVudFg6IGUuY2xpZW50WCxcbiAgICAgICAgICBjbGllbnRZOiBlLmNsaWVudFksXG4gICAgICAgICAgZm9yY2U6IDEsXG4gICAgICAgICAgaWRlbnRpZmllcjogZS5wb2ludGVySWQsXG4gICAgICAgICAgcGFnZVg6IGUucGFnZVgsXG4gICAgICAgICAgcGFnZVk6IGUucGFnZVksXG4gICAgICAgICAgcmFkaXVzWDogZS53aWR0aCAvIDIsXG4gICAgICAgICAgcmFkaXVzWTogZS5oZWlnaHQgLyAyLFxuICAgICAgICAgIHNjcmVlblg6IGUuc2NyZWVuWCxcbiAgICAgICAgICBzY3JlZW5ZOiBlLnNjcmVlblksXG4gICAgICAgICAgdGFyZ2V0OiBlLnRhcmdldFxuICAgICAgICB9O1xuICAgICAgfTtcblxuICAgICAgdmFyIG1ha2VQb2ludGVyID0gZnVuY3Rpb24gbWFrZVBvaW50ZXIoZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGV2ZW50OiBlLFxuICAgICAgICAgIHRvdWNoOiBtYWtlVG91Y2goZSlcbiAgICAgICAgfTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBhZGRQb2ludGVyID0gZnVuY3Rpb24gYWRkUG9pbnRlcihlKSB7XG4gICAgICAgIHBvaW50ZXJzLnB1c2gobWFrZVBvaW50ZXIoZSkpO1xuICAgICAgfTtcblxuICAgICAgdmFyIHJlbW92ZVBvaW50ZXIgPSBmdW5jdGlvbiByZW1vdmVQb2ludGVyKGUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBwID0gcG9pbnRlcnNbaV07XG5cbiAgICAgICAgICBpZiAocC5ldmVudC5wb2ludGVySWQgPT09IGUucG9pbnRlcklkKSB7XG4gICAgICAgICAgICBwb2ludGVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgdXBkYXRlUG9pbnRlciA9IGZ1bmN0aW9uIHVwZGF0ZVBvaW50ZXIoZSkge1xuICAgICAgICB2YXIgcCA9IHBvaW50ZXJzLmZpbHRlcihmdW5jdGlvbiAocCkge1xuICAgICAgICAgIHJldHVybiBwLmV2ZW50LnBvaW50ZXJJZCA9PT0gZS5wb2ludGVySWQ7XG4gICAgICAgIH0pWzBdO1xuICAgICAgICBwLmV2ZW50ID0gZTtcbiAgICAgICAgcC50b3VjaCA9IG1ha2VUb3VjaChlKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBhZGRUb3VjaGVzVG9FdmVudCA9IGZ1bmN0aW9uIGFkZFRvdWNoZXNUb0V2ZW50KGUpIHtcbiAgICAgICAgZS50b3VjaGVzID0gcG9pbnRlcnMubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgcmV0dXJuIHAudG91Y2g7XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgdmFyIHBvaW50ZXJJc01vdXNlID0gZnVuY3Rpb24gcG9pbnRlcklzTW91c2UoZSkge1xuICAgICAgICByZXR1cm4gZS5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJyB8fCBlLnBvaW50ZXJUeXBlID09PSA0O1xuICAgICAgfTtcblxuICAgICAgci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICdwb2ludGVyZG93bicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChwb2ludGVySXNNb3VzZShlKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBtb3VzZSBhbHJlYWR5IGhhbmRsZWRcblxuXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgYWRkUG9pbnRlcihlKTtcbiAgICAgICAgYWRkVG91Y2hlc1RvRXZlbnQoZSk7XG4gICAgICAgIHRvdWNoc3RhcnRIYW5kbGVyKGUpO1xuICAgICAgfSk7XG4gICAgICByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ3BvaW50ZXJ1cCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChwb2ludGVySXNNb3VzZShlKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBtb3VzZSBhbHJlYWR5IGhhbmRsZWRcblxuXG4gICAgICAgIHJlbW92ZVBvaW50ZXIoZSk7XG4gICAgICAgIGFkZFRvdWNoZXNUb0V2ZW50KGUpO1xuICAgICAgICB0b3VjaGVuZEhhbmRsZXIoZSk7XG4gICAgICB9KTtcbiAgICAgIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAncG9pbnRlcmNhbmNlbCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChwb2ludGVySXNNb3VzZShlKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBtb3VzZSBhbHJlYWR5IGhhbmRsZWRcblxuXG4gICAgICAgIHJlbW92ZVBvaW50ZXIoZSk7XG4gICAgICAgIGFkZFRvdWNoZXNUb0V2ZW50KGUpO1xuICAgICAgICB0b3VjaGNhbmNlbEhhbmRsZXIoZSk7XG4gICAgICB9KTtcbiAgICAgIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAncG9pbnRlcm1vdmUnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAocG9pbnRlcklzTW91c2UoZSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gbW91c2UgYWxyZWFkeSBoYW5kbGVkXG5cblxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHVwZGF0ZVBvaW50ZXIoZSk7XG4gICAgICAgIGFkZFRvdWNoZXNUb0V2ZW50KGUpO1xuICAgICAgICB0b3VjaG1vdmVIYW5kbGVyKGUpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBCUnAkMiA9IHt9O1xuXG4gIEJScCQyLmdlbmVyYXRlUG9seWdvbiA9IGZ1bmN0aW9uIChuYW1lLCBwb2ludHMpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlU2hhcGVzW25hbWVdID0ge1xuICAgICAgcmVuZGVyZXI6IHRoaXMsXG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgcG9pbnRzOiBwb2ludHMsXG4gICAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5ub2RlU2hhcGVJbXBsKCdwb2x5Z29uJywgY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgdGhpcy5wb2ludHMpO1xuICAgICAgfSxcbiAgICAgIGludGVyc2VjdExpbmU6IGZ1bmN0aW9uIGludGVyc2VjdExpbmUobm9kZVgsIG5vZGVZLCB3aWR0aCwgaGVpZ2h0LCB4LCB5LCBwYWRkaW5nKSB7XG4gICAgICAgIHJldHVybiBwb2x5Z29uSW50ZXJzZWN0TGluZSh4LCB5LCB0aGlzLnBvaW50cywgbm9kZVgsIG5vZGVZLCB3aWR0aCAvIDIsIGhlaWdodCAvIDIsIHBhZGRpbmcpO1xuICAgICAgfSxcbiAgICAgIGNoZWNrUG9pbnQ6IGZ1bmN0aW9uIGNoZWNrUG9pbnQoeCwgeSwgcGFkZGluZywgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSkge1xuICAgICAgICByZXR1cm4gcG9pbnRJbnNpZGVQb2x5Z29uKHgsIHksIHRoaXMucG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBbMCwgLTFdLCBwYWRkaW5nKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIEJScCQyLmdlbmVyYXRlRWxsaXBzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlU2hhcGVzWydlbGxpcHNlJ10gPSB7XG4gICAgICByZW5kZXJlcjogdGhpcyxcbiAgICAgIG5hbWU6ICdlbGxpcHNlJyxcbiAgICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLm5vZGVTaGFwZUltcGwodGhpcy5uYW1lLCBjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH0sXG4gICAgICBpbnRlcnNlY3RMaW5lOiBmdW5jdGlvbiBpbnRlcnNlY3RMaW5lKG5vZGVYLCBub2RlWSwgd2lkdGgsIGhlaWdodCwgeCwgeSwgcGFkZGluZykge1xuICAgICAgICByZXR1cm4gaW50ZXJzZWN0TGluZUVsbGlwc2UoeCwgeSwgbm9kZVgsIG5vZGVZLCB3aWR0aCAvIDIgKyBwYWRkaW5nLCBoZWlnaHQgLyAyICsgcGFkZGluZyk7XG4gICAgICB9LFxuICAgICAgY2hlY2tQb2ludDogZnVuY3Rpb24gY2hlY2tQb2ludCh4LCB5LCBwYWRkaW5nLCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZKSB7XG4gICAgICAgIHJldHVybiBjaGVja0luRWxsaXBzZSh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZLCBwYWRkaW5nKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIEJScCQyLmdlbmVyYXRlUm91bmRQb2x5Z29uID0gZnVuY3Rpb24gKG5hbWUsIHBvaW50cykge1xuICAgIC8vIFByZS1jb21wdXRlIGNvbnRyb2wgcG9pbnRzXG4gICAgLy8gU2luY2UgdGhlc2UgcG9pbnRzIGRlcGVuZCBvbiB0aGUgcmFkaXVzIGxlbmd0aCAod2hpY2ggaW4gdHVybnMgZGVwZW5kIG9uIHRoZSB3aWR0aC9oZWlnaHQgb2YgdGhlIG5vZGUpIHdlIHdpbGwgb25seSBwcmUtY29tcHV0ZVxuICAgIC8vIHRoZSB1bml0IHZlY3RvcnMuXG4gICAgLy8gRm9yIHNpbXBsaWNpdHkgdGhlIGxheW91dCB3aWxsIGJlOlxuICAgIC8vIFsgcDAsIFVuaXRWZWN0b3JQMFAxLCBwMSwgVW5pVmVjdG9yUDFQMiwgLi4uLCBwbiwgVW5pdFZlY3RvclBuUDAgXVxuICAgIHZhciBhbGxQb2ludHMgPSBuZXcgQXJyYXkocG9pbnRzLmxlbmd0aCAqIDIpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlSW5kZXggPSBpICogMjtcbiAgICAgIHZhciBkZXN0SW5kZXggPSB2b2lkIDA7XG5cbiAgICAgIGlmIChpIDwgcG9pbnRzLmxlbmd0aCAvIDIgLSAxKSB7XG4gICAgICAgIGRlc3RJbmRleCA9IChpICsgMSkgKiAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVzdEluZGV4ID0gMDtcbiAgICAgIH1cblxuICAgICAgYWxsUG9pbnRzW2kgKiA0XSA9IHBvaW50c1tzb3VyY2VJbmRleF07XG4gICAgICBhbGxQb2ludHNbaSAqIDQgKyAxXSA9IHBvaW50c1tzb3VyY2VJbmRleCArIDFdO1xuICAgICAgdmFyIHhEZXN0ID0gcG9pbnRzW2Rlc3RJbmRleF0gLSBwb2ludHNbc291cmNlSW5kZXhdO1xuICAgICAgdmFyIHlEZXN0ID0gcG9pbnRzW2Rlc3RJbmRleCArIDFdIC0gcG9pbnRzW3NvdXJjZUluZGV4ICsgMV07XG4gICAgICB2YXIgbm9ybSA9IE1hdGguc3FydCh4RGVzdCAqIHhEZXN0ICsgeURlc3QgKiB5RGVzdCk7XG4gICAgICBhbGxQb2ludHNbaSAqIDQgKyAyXSA9IHhEZXN0IC8gbm9ybTtcbiAgICAgIGFsbFBvaW50c1tpICogNCArIDNdID0geURlc3QgLyBub3JtO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLm5vZGVTaGFwZXNbbmFtZV0gPSB7XG4gICAgICByZW5kZXJlcjogdGhpcyxcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBwb2ludHM6IGFsbFBvaW50cyxcbiAgICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLm5vZGVTaGFwZUltcGwoJ3JvdW5kLXBvbHlnb24nLCBjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCB0aGlzLnBvaW50cyk7XG4gICAgICB9LFxuICAgICAgaW50ZXJzZWN0TGluZTogZnVuY3Rpb24gaW50ZXJzZWN0TGluZShub2RlWCwgbm9kZVksIHdpZHRoLCBoZWlnaHQsIHgsIHksIHBhZGRpbmcpIHtcbiAgICAgICAgcmV0dXJuIHJvdW5kUG9seWdvbkludGVyc2VjdExpbmUoeCwgeSwgdGhpcy5wb2ludHMsIG5vZGVYLCBub2RlWSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB9LFxuICAgICAgY2hlY2tQb2ludDogZnVuY3Rpb24gY2hlY2tQb2ludCh4LCB5LCBwYWRkaW5nLCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZKSB7XG4gICAgICAgIHJldHVybiBwb2ludEluc2lkZVJvdW5kUG9seWdvbih4LCB5LCB0aGlzLnBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICBCUnAkMi5nZW5lcmF0ZVJvdW5kUmVjdGFuZ2xlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm5vZGVTaGFwZXNbJ3JvdW5kLXJlY3RhbmdsZSddID0gdGhpcy5ub2RlU2hhcGVzWydyb3VuZHJlY3RhbmdsZSddID0ge1xuICAgICAgcmVuZGVyZXI6IHRoaXMsXG4gICAgICBuYW1lOiAncm91bmQtcmVjdGFuZ2xlJyxcbiAgICAgIHBvaW50czogZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDQsIDApLFxuICAgICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIubm9kZVNoYXBlSW1wbCh0aGlzLm5hbWUsIGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfSxcbiAgICAgIGludGVyc2VjdExpbmU6IGZ1bmN0aW9uIGludGVyc2VjdExpbmUobm9kZVgsIG5vZGVZLCB3aWR0aCwgaGVpZ2h0LCB4LCB5LCBwYWRkaW5nKSB7XG4gICAgICAgIHJldHVybiByb3VuZFJlY3RhbmdsZUludGVyc2VjdExpbmUoeCwgeSwgbm9kZVgsIG5vZGVZLCB3aWR0aCwgaGVpZ2h0LCBwYWRkaW5nKTtcbiAgICAgIH0sXG4gICAgICBjaGVja1BvaW50OiBmdW5jdGlvbiBjaGVja1BvaW50KHgsIHksIHBhZGRpbmcsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclkpIHtcbiAgICAgICAgdmFyIGNvcm5lclJhZGl1cyA9IGdldFJvdW5kUmVjdGFuZ2xlUmFkaXVzKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB2YXIgZGlhbSA9IGNvcm5lclJhZGl1cyAqIDI7IC8vIENoZWNrIGhCb3hcblxuICAgICAgICBpZiAocG9pbnRJbnNpZGVQb2x5Z29uKHgsIHksIHRoaXMucG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0IC0gZGlhbSwgWzAsIC0xXSwgcGFkZGluZykpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSAvLyBDaGVjayB2Qm94XG5cblxuICAgICAgICBpZiAocG9pbnRJbnNpZGVQb2x5Z29uKHgsIHksIHRoaXMucG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCAtIGRpYW0sIGhlaWdodCwgWzAsIC0xXSwgcGFkZGluZykpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSAvLyBDaGVjayB0b3AgbGVmdCBxdWFydGVyIGNpcmNsZVxuXG5cbiAgICAgICAgaWYgKGNoZWNrSW5FbGxpcHNlKHgsIHksIGRpYW0sIGRpYW0sIGNlbnRlclggLSB3aWR0aCAvIDIgKyBjb3JuZXJSYWRpdXMsIGNlbnRlclkgLSBoZWlnaHQgLyAyICsgY29ybmVyUmFkaXVzLCBwYWRkaW5nKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IC8vIENoZWNrIHRvcCByaWdodCBxdWFydGVyIGNpcmNsZVxuXG5cbiAgICAgICAgaWYgKGNoZWNrSW5FbGxpcHNlKHgsIHksIGRpYW0sIGRpYW0sIGNlbnRlclggKyB3aWR0aCAvIDIgLSBjb3JuZXJSYWRpdXMsIGNlbnRlclkgLSBoZWlnaHQgLyAyICsgY29ybmVyUmFkaXVzLCBwYWRkaW5nKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IC8vIENoZWNrIGJvdHRvbSByaWdodCBxdWFydGVyIGNpcmNsZVxuXG5cbiAgICAgICAgaWYgKGNoZWNrSW5FbGxpcHNlKHgsIHksIGRpYW0sIGRpYW0sIGNlbnRlclggKyB3aWR0aCAvIDIgLSBjb3JuZXJSYWRpdXMsIGNlbnRlclkgKyBoZWlnaHQgLyAyIC0gY29ybmVyUmFkaXVzLCBwYWRkaW5nKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IC8vIENoZWNrIGJvdHRvbSBsZWZ0IHF1YXJ0ZXIgY2lyY2xlXG5cblxuICAgICAgICBpZiAoY2hlY2tJbkVsbGlwc2UoeCwgeSwgZGlhbSwgZGlhbSwgY2VudGVyWCAtIHdpZHRoIC8gMiArIGNvcm5lclJhZGl1cywgY2VudGVyWSArIGhlaWdodCAvIDIgLSBjb3JuZXJSYWRpdXMsIHBhZGRpbmcpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICBCUnAkMi5nZW5lcmF0ZUN1dFJlY3RhbmdsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlU2hhcGVzWydjdXQtcmVjdGFuZ2xlJ10gPSB0aGlzLm5vZGVTaGFwZXNbJ2N1dHJlY3RhbmdsZSddID0ge1xuICAgICAgcmVuZGVyZXI6IHRoaXMsXG4gICAgICBuYW1lOiAnY3V0LXJlY3RhbmdsZScsXG4gICAgICBjb3JuZXJMZW5ndGg6IGdldEN1dFJlY3RhbmdsZUNvcm5lckxlbmd0aCgpLFxuICAgICAgcG9pbnRzOiBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoNCwgMCksXG4gICAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5ub2RlU2hhcGVJbXBsKHRoaXMubmFtZSwgY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB9LFxuICAgICAgZ2VuZXJhdGVDdXRUcmlhbmdsZVB0czogZnVuY3Rpb24gZ2VuZXJhdGVDdXRUcmlhbmdsZVB0cyh3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZKSB7XG4gICAgICAgIHZhciBjbCA9IHRoaXMuY29ybmVyTGVuZ3RoO1xuICAgICAgICB2YXIgaGggPSBoZWlnaHQgLyAyO1xuICAgICAgICB2YXIgaHcgPSB3aWR0aCAvIDI7XG4gICAgICAgIHZhciB4QmVnaW4gPSBjZW50ZXJYIC0gaHc7XG4gICAgICAgIHZhciB4RW5kID0gY2VudGVyWCArIGh3O1xuICAgICAgICB2YXIgeUJlZ2luID0gY2VudGVyWSAtIGhoO1xuICAgICAgICB2YXIgeUVuZCA9IGNlbnRlclkgKyBoaDsgLy8gcG9pbnRzIGFyZSBpbiBjbG9ja3dpc2Ugb3JkZXIsIGlubmVyIChpbWFnaW5hcnkpIHRyaWFuZ2xlIHB0IG9uIFs0LCA1XVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdG9wTGVmdDogW3hCZWdpbiwgeUJlZ2luICsgY2wsIHhCZWdpbiArIGNsLCB5QmVnaW4sIHhCZWdpbiArIGNsLCB5QmVnaW4gKyBjbF0sXG4gICAgICAgICAgdG9wUmlnaHQ6IFt4RW5kIC0gY2wsIHlCZWdpbiwgeEVuZCwgeUJlZ2luICsgY2wsIHhFbmQgLSBjbCwgeUJlZ2luICsgY2xdLFxuICAgICAgICAgIGJvdHRvbVJpZ2h0OiBbeEVuZCwgeUVuZCAtIGNsLCB4RW5kIC0gY2wsIHlFbmQsIHhFbmQgLSBjbCwgeUVuZCAtIGNsXSxcbiAgICAgICAgICBib3R0b21MZWZ0OiBbeEJlZ2luICsgY2wsIHlFbmQsIHhCZWdpbiwgeUVuZCAtIGNsLCB4QmVnaW4gKyBjbCwgeUVuZCAtIGNsXVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGludGVyc2VjdExpbmU6IGZ1bmN0aW9uIGludGVyc2VjdExpbmUobm9kZVgsIG5vZGVZLCB3aWR0aCwgaGVpZ2h0LCB4LCB5LCBwYWRkaW5nKSB7XG4gICAgICAgIHZhciBjUHRzID0gdGhpcy5nZW5lcmF0ZUN1dFRyaWFuZ2xlUHRzKHdpZHRoICsgMiAqIHBhZGRpbmcsIGhlaWdodCArIDIgKiBwYWRkaW5nLCBub2RlWCwgbm9kZVkpO1xuICAgICAgICB2YXIgcHRzID0gW10uY29uY2F0LmFwcGx5KFtdLCBbY1B0cy50b3BMZWZ0LnNwbGljZSgwLCA0KSwgY1B0cy50b3BSaWdodC5zcGxpY2UoMCwgNCksIGNQdHMuYm90dG9tUmlnaHQuc3BsaWNlKDAsIDQpLCBjUHRzLmJvdHRvbUxlZnQuc3BsaWNlKDAsIDQpXSk7XG4gICAgICAgIHJldHVybiBwb2x5Z29uSW50ZXJzZWN0TGluZSh4LCB5LCBwdHMsIG5vZGVYLCBub2RlWSk7XG4gICAgICB9LFxuICAgICAgY2hlY2tQb2ludDogZnVuY3Rpb24gY2hlY2tQb2ludCh4LCB5LCBwYWRkaW5nLCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZKSB7XG4gICAgICAgIC8vIENoZWNrIGhCb3hcbiAgICAgICAgaWYgKHBvaW50SW5zaWRlUG9seWdvbih4LCB5LCB0aGlzLnBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCAtIDIgKiB0aGlzLmNvcm5lckxlbmd0aCwgWzAsIC0xXSwgcGFkZGluZykpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSAvLyBDaGVjayB2Qm94XG5cblxuICAgICAgICBpZiAocG9pbnRJbnNpZGVQb2x5Z29uKHgsIHksIHRoaXMucG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCAtIDIgKiB0aGlzLmNvcm5lckxlbmd0aCwgaGVpZ2h0LCBbMCwgLTFdLCBwYWRkaW5nKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGN1dFRyaWFuZ2xlUHRzID0gdGhpcy5nZW5lcmF0ZUN1dFRyaWFuZ2xlUHRzKHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclkpO1xuICAgICAgICByZXR1cm4gcG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKHgsIHksIGN1dFRyaWFuZ2xlUHRzLnRvcExlZnQpIHx8IHBvaW50SW5zaWRlUG9seWdvblBvaW50cyh4LCB5LCBjdXRUcmlhbmdsZVB0cy50b3BSaWdodCkgfHwgcG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKHgsIHksIGN1dFRyaWFuZ2xlUHRzLmJvdHRvbVJpZ2h0KSB8fCBwb2ludEluc2lkZVBvbHlnb25Qb2ludHMoeCwgeSwgY3V0VHJpYW5nbGVQdHMuYm90dG9tTGVmdCk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICBCUnAkMi5nZW5lcmF0ZUJhcnJlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlU2hhcGVzWydiYXJyZWwnXSA9IHtcbiAgICAgIHJlbmRlcmVyOiB0aGlzLFxuICAgICAgbmFtZTogJ2JhcnJlbCcsXG4gICAgICBwb2ludHM6IGdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSg0LCAwKSxcbiAgICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLm5vZGVTaGFwZUltcGwodGhpcy5uYW1lLCBjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH0sXG4gICAgICBpbnRlcnNlY3RMaW5lOiBmdW5jdGlvbiBpbnRlcnNlY3RMaW5lKG5vZGVYLCBub2RlWSwgd2lkdGgsIGhlaWdodCwgeCwgeSwgcGFkZGluZykge1xuICAgICAgICAvLyB1c2UgdHdvIGZpeGVkIHQgdmFsdWVzIGZvciB0aGUgYmV6aWVyIGN1cnZlIGFwcHJveGltYXRpb25cbiAgICAgICAgdmFyIHQwID0gMC4xNTtcbiAgICAgICAgdmFyIHQxID0gMC41O1xuICAgICAgICB2YXIgdDIgPSAwLjg1O1xuICAgICAgICB2YXIgYlB0cyA9IHRoaXMuZ2VuZXJhdGVCYXJyZWxCZXppZXJQdHMod2lkdGggKyAyICogcGFkZGluZywgaGVpZ2h0ICsgMiAqIHBhZGRpbmcsIG5vZGVYLCBub2RlWSk7XG5cbiAgICAgICAgdmFyIGFwcHJveGltYXRlQmFycmVsQ3VydmVQdHMgPSBmdW5jdGlvbiBhcHByb3hpbWF0ZUJhcnJlbEN1cnZlUHRzKHB0cykge1xuICAgICAgICAgIC8vIGFwcHJveGltYXRlIGN1cnZlIHB0cyBiYXNlZCBvbiB0aGUgdHdvIHQgdmFsdWVzXG4gICAgICAgICAgdmFyIG0wID0gcWJlemllclB0QXQoe1xuICAgICAgICAgICAgeDogcHRzWzBdLFxuICAgICAgICAgICAgeTogcHRzWzFdXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgeDogcHRzWzJdLFxuICAgICAgICAgICAgeTogcHRzWzNdXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgeDogcHRzWzRdLFxuICAgICAgICAgICAgeTogcHRzWzVdXG4gICAgICAgICAgfSwgdDApO1xuICAgICAgICAgIHZhciBtMSA9IHFiZXppZXJQdEF0KHtcbiAgICAgICAgICAgIHg6IHB0c1swXSxcbiAgICAgICAgICAgIHk6IHB0c1sxXVxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIHg6IHB0c1syXSxcbiAgICAgICAgICAgIHk6IHB0c1szXVxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIHg6IHB0c1s0XSxcbiAgICAgICAgICAgIHk6IHB0c1s1XVxuICAgICAgICAgIH0sIHQxKTtcbiAgICAgICAgICB2YXIgbTIgPSBxYmV6aWVyUHRBdCh7XG4gICAgICAgICAgICB4OiBwdHNbMF0sXG4gICAgICAgICAgICB5OiBwdHNbMV1cbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICB4OiBwdHNbMl0sXG4gICAgICAgICAgICB5OiBwdHNbM11cbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICB4OiBwdHNbNF0sXG4gICAgICAgICAgICB5OiBwdHNbNV1cbiAgICAgICAgICB9LCB0Mik7XG4gICAgICAgICAgcmV0dXJuIFtwdHNbMF0sIHB0c1sxXSwgbTAueCwgbTAueSwgbTEueCwgbTEueSwgbTIueCwgbTIueSwgcHRzWzRdLCBwdHNbNV1dO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBwdHMgPSBbXS5jb25jYXQoYXBwcm94aW1hdGVCYXJyZWxDdXJ2ZVB0cyhiUHRzLnRvcExlZnQpLCBhcHByb3hpbWF0ZUJhcnJlbEN1cnZlUHRzKGJQdHMudG9wUmlnaHQpLCBhcHByb3hpbWF0ZUJhcnJlbEN1cnZlUHRzKGJQdHMuYm90dG9tUmlnaHQpLCBhcHByb3hpbWF0ZUJhcnJlbEN1cnZlUHRzKGJQdHMuYm90dG9tTGVmdCkpO1xuICAgICAgICByZXR1cm4gcG9seWdvbkludGVyc2VjdExpbmUoeCwgeSwgcHRzLCBub2RlWCwgbm9kZVkpO1xuICAgICAgfSxcbiAgICAgIGdlbmVyYXRlQmFycmVsQmV6aWVyUHRzOiBmdW5jdGlvbiBnZW5lcmF0ZUJhcnJlbEJlemllclB0cyh3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZKSB7XG4gICAgICAgIHZhciBoaCA9IGhlaWdodCAvIDI7XG4gICAgICAgIHZhciBodyA9IHdpZHRoIC8gMjtcbiAgICAgICAgdmFyIHhCZWdpbiA9IGNlbnRlclggLSBodztcbiAgICAgICAgdmFyIHhFbmQgPSBjZW50ZXJYICsgaHc7XG4gICAgICAgIHZhciB5QmVnaW4gPSBjZW50ZXJZIC0gaGg7XG4gICAgICAgIHZhciB5RW5kID0gY2VudGVyWSArIGhoO1xuICAgICAgICB2YXIgY3VydmVDb25zdGFudHMgPSBnZXRCYXJyZWxDdXJ2ZUNvbnN0YW50cyh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdmFyIGhPZmZzZXQgPSBjdXJ2ZUNvbnN0YW50cy5oZWlnaHRPZmZzZXQ7XG4gICAgICAgIHZhciB3T2Zmc2V0ID0gY3VydmVDb25zdGFudHMud2lkdGhPZmZzZXQ7XG4gICAgICAgIHZhciBjdHJsUHRYT2Zmc2V0ID0gY3VydmVDb25zdGFudHMuY3RybFB0T2Zmc2V0UGN0ICogd2lkdGg7IC8vIHBvaW50cyBhcmUgaW4gY2xvY2t3aXNlIG9yZGVyLCBpbm5lciAoaW1hZ2luYXJ5KSBjb250cm9sIHB0IG9uIFs0LCA1XVxuXG4gICAgICAgIHZhciBwdHMgPSB7XG4gICAgICAgICAgdG9wTGVmdDogW3hCZWdpbiwgeUJlZ2luICsgaE9mZnNldCwgeEJlZ2luICsgY3RybFB0WE9mZnNldCwgeUJlZ2luLCB4QmVnaW4gKyB3T2Zmc2V0LCB5QmVnaW5dLFxuICAgICAgICAgIHRvcFJpZ2h0OiBbeEVuZCAtIHdPZmZzZXQsIHlCZWdpbiwgeEVuZCAtIGN0cmxQdFhPZmZzZXQsIHlCZWdpbiwgeEVuZCwgeUJlZ2luICsgaE9mZnNldF0sXG4gICAgICAgICAgYm90dG9tUmlnaHQ6IFt4RW5kLCB5RW5kIC0gaE9mZnNldCwgeEVuZCAtIGN0cmxQdFhPZmZzZXQsIHlFbmQsIHhFbmQgLSB3T2Zmc2V0LCB5RW5kXSxcbiAgICAgICAgICBib3R0b21MZWZ0OiBbeEJlZ2luICsgd09mZnNldCwgeUVuZCwgeEJlZ2luICsgY3RybFB0WE9mZnNldCwgeUVuZCwgeEJlZ2luLCB5RW5kIC0gaE9mZnNldF1cbiAgICAgICAgfTtcbiAgICAgICAgcHRzLnRvcExlZnQuaXNUb3AgPSB0cnVlO1xuICAgICAgICBwdHMudG9wUmlnaHQuaXNUb3AgPSB0cnVlO1xuICAgICAgICBwdHMuYm90dG9tTGVmdC5pc0JvdHRvbSA9IHRydWU7XG4gICAgICAgIHB0cy5ib3R0b21SaWdodC5pc0JvdHRvbSA9IHRydWU7XG4gICAgICAgIHJldHVybiBwdHM7XG4gICAgICB9LFxuICAgICAgY2hlY2tQb2ludDogZnVuY3Rpb24gY2hlY2tQb2ludCh4LCB5LCBwYWRkaW5nLCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZKSB7XG4gICAgICAgIHZhciBjdXJ2ZUNvbnN0YW50cyA9IGdldEJhcnJlbEN1cnZlQ29uc3RhbnRzKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB2YXIgaE9mZnNldCA9IGN1cnZlQ29uc3RhbnRzLmhlaWdodE9mZnNldDtcbiAgICAgICAgdmFyIHdPZmZzZXQgPSBjdXJ2ZUNvbnN0YW50cy53aWR0aE9mZnNldDsgLy8gQ2hlY2sgaEJveFxuXG4gICAgICAgIGlmIChwb2ludEluc2lkZVBvbHlnb24oeCwgeSwgdGhpcy5wb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQgLSAyICogaE9mZnNldCwgWzAsIC0xXSwgcGFkZGluZykpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSAvLyBDaGVjayB2Qm94XG5cblxuICAgICAgICBpZiAocG9pbnRJbnNpZGVQb2x5Z29uKHgsIHksIHRoaXMucG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCAtIDIgKiB3T2Zmc2V0LCBoZWlnaHQsIFswLCAtMV0sIHBhZGRpbmcpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYmFycmVsQ3VydmVQdHMgPSB0aGlzLmdlbmVyYXRlQmFycmVsQmV6aWVyUHRzKHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclkpO1xuXG4gICAgICAgIHZhciBnZXRDdXJ2ZVQgPSBmdW5jdGlvbiBnZXRDdXJ2ZVQoeCwgeSwgY3VydmVQdHMpIHtcbiAgICAgICAgICB2YXIgeDAgPSBjdXJ2ZVB0c1s0XTtcbiAgICAgICAgICB2YXIgeDEgPSBjdXJ2ZVB0c1syXTtcbiAgICAgICAgICB2YXIgeDIgPSBjdXJ2ZVB0c1swXTtcbiAgICAgICAgICB2YXIgeTAgPSBjdXJ2ZVB0c1s1XTsgLy8gdmFyIHkxID0gY3VydmVQdHNbIDMgXTtcblxuICAgICAgICAgIHZhciB5MiA9IGN1cnZlUHRzWzFdO1xuICAgICAgICAgIHZhciB4TWluID0gTWF0aC5taW4oeDAsIHgyKTtcbiAgICAgICAgICB2YXIgeE1heCA9IE1hdGgubWF4KHgwLCB4Mik7XG4gICAgICAgICAgdmFyIHlNaW4gPSBNYXRoLm1pbih5MCwgeTIpO1xuICAgICAgICAgIHZhciB5TWF4ID0gTWF0aC5tYXgoeTAsIHkyKTtcblxuICAgICAgICAgIGlmICh4TWluIDw9IHggJiYgeCA8PSB4TWF4ICYmIHlNaW4gPD0geSAmJiB5IDw9IHlNYXgpIHtcbiAgICAgICAgICAgIHZhciBjb2VmZiA9IGJlemllclB0c1RvUXVhZENvZWZmKHgwLCB4MSwgeDIpO1xuICAgICAgICAgICAgdmFyIHJvb3RzID0gc29sdmVRdWFkcmF0aWMoY29lZmZbMF0sIGNvZWZmWzFdLCBjb2VmZlsyXSwgeCk7XG4gICAgICAgICAgICB2YXIgdmFsaWRSb290cyA9IHJvb3RzLmZpbHRlcihmdW5jdGlvbiAocikge1xuICAgICAgICAgICAgICByZXR1cm4gMCA8PSByICYmIHIgPD0gMTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAodmFsaWRSb290cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiB2YWxpZFJvb3RzWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBjdXJ2ZVJlZ2lvbnMgPSBPYmplY3Qua2V5cyhiYXJyZWxDdXJ2ZVB0cyk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdXJ2ZVJlZ2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgY29ybmVyID0gY3VydmVSZWdpb25zW2ldO1xuICAgICAgICAgIHZhciBjb3JuZXJQdHMgPSBiYXJyZWxDdXJ2ZVB0c1tjb3JuZXJdO1xuICAgICAgICAgIHZhciB0ID0gZ2V0Q3VydmVUKHgsIHksIGNvcm5lclB0cyk7XG5cbiAgICAgICAgICBpZiAodCA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgeTAgPSBjb3JuZXJQdHNbNV07XG4gICAgICAgICAgdmFyIHkxID0gY29ybmVyUHRzWzNdO1xuICAgICAgICAgIHZhciB5MiA9IGNvcm5lclB0c1sxXTtcbiAgICAgICAgICB2YXIgYmV6WSA9IHFiZXppZXJBdCh5MCwgeTEsIHkyLCB0KTtcblxuICAgICAgICAgIGlmIChjb3JuZXJQdHMuaXNUb3AgJiYgYmV6WSA8PSB5KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY29ybmVyUHRzLmlzQm90dG9tICYmIHkgPD0gYmV6WSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgQlJwJDIuZ2VuZXJhdGVCb3R0b21Sb3VuZHJlY3RhbmdsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlU2hhcGVzWydib3R0b20tcm91bmQtcmVjdGFuZ2xlJ10gPSB0aGlzLm5vZGVTaGFwZXNbJ2JvdHRvbXJvdW5kcmVjdGFuZ2xlJ10gPSB7XG4gICAgICByZW5kZXJlcjogdGhpcyxcbiAgICAgIG5hbWU6ICdib3R0b20tcm91bmQtcmVjdGFuZ2xlJyxcbiAgICAgIHBvaW50czogZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDQsIDApLFxuICAgICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIubm9kZVNoYXBlSW1wbCh0aGlzLm5hbWUsIGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfSxcbiAgICAgIGludGVyc2VjdExpbmU6IGZ1bmN0aW9uIGludGVyc2VjdExpbmUobm9kZVgsIG5vZGVZLCB3aWR0aCwgaGVpZ2h0LCB4LCB5LCBwYWRkaW5nKSB7XG4gICAgICAgIHZhciB0b3BTdGFydFggPSBub2RlWCAtICh3aWR0aCAvIDIgKyBwYWRkaW5nKTtcbiAgICAgICAgdmFyIHRvcFN0YXJ0WSA9IG5vZGVZIC0gKGhlaWdodCAvIDIgKyBwYWRkaW5nKTtcbiAgICAgICAgdmFyIHRvcEVuZFkgPSB0b3BTdGFydFk7XG4gICAgICAgIHZhciB0b3BFbmRYID0gbm9kZVggKyAod2lkdGggLyAyICsgcGFkZGluZyk7XG4gICAgICAgIHZhciB0b3BJbnRlcnNlY3Rpb25zID0gZmluaXRlTGluZXNJbnRlcnNlY3QoeCwgeSwgbm9kZVgsIG5vZGVZLCB0b3BTdGFydFgsIHRvcFN0YXJ0WSwgdG9wRW5kWCwgdG9wRW5kWSwgZmFsc2UpO1xuXG4gICAgICAgIGlmICh0b3BJbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICByZXR1cm4gdG9wSW50ZXJzZWN0aW9ucztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByb3VuZFJlY3RhbmdsZUludGVyc2VjdExpbmUoeCwgeSwgbm9kZVgsIG5vZGVZLCB3aWR0aCwgaGVpZ2h0LCBwYWRkaW5nKTtcbiAgICAgIH0sXG4gICAgICBjaGVja1BvaW50OiBmdW5jdGlvbiBjaGVja1BvaW50KHgsIHksIHBhZGRpbmcsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclkpIHtcbiAgICAgICAgdmFyIGNvcm5lclJhZGl1cyA9IGdldFJvdW5kUmVjdGFuZ2xlUmFkaXVzKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB2YXIgZGlhbSA9IDIgKiBjb3JuZXJSYWRpdXM7IC8vIENoZWNrIGhCb3hcblxuICAgICAgICBpZiAocG9pbnRJbnNpZGVQb2x5Z29uKHgsIHksIHRoaXMucG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0IC0gZGlhbSwgWzAsIC0xXSwgcGFkZGluZykpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSAvLyBDaGVjayB2Qm94XG5cblxuICAgICAgICBpZiAocG9pbnRJbnNpZGVQb2x5Z29uKHgsIHksIHRoaXMucG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCAtIGRpYW0sIGhlaWdodCwgWzAsIC0xXSwgcGFkZGluZykpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSAvLyBjaGVjayBub24tcm91bmRlZCB0b3Agc2lkZVxuXG5cbiAgICAgICAgdmFyIG91dGVyV2lkdGggPSB3aWR0aCAvIDIgKyAyICogcGFkZGluZztcbiAgICAgICAgdmFyIG91dGVySGVpZ2h0ID0gaGVpZ2h0IC8gMiArIDIgKiBwYWRkaW5nO1xuICAgICAgICB2YXIgcG9pbnRzID0gW2NlbnRlclggLSBvdXRlcldpZHRoLCBjZW50ZXJZIC0gb3V0ZXJIZWlnaHQsIGNlbnRlclggLSBvdXRlcldpZHRoLCBjZW50ZXJZLCBjZW50ZXJYICsgb3V0ZXJXaWR0aCwgY2VudGVyWSwgY2VudGVyWCArIG91dGVyV2lkdGgsIGNlbnRlclkgLSBvdXRlckhlaWdodF07XG5cbiAgICAgICAgaWYgKHBvaW50SW5zaWRlUG9seWdvblBvaW50cyh4LCB5LCBwb2ludHMpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gLy8gQ2hlY2sgYm90dG9tIHJpZ2h0IHF1YXJ0ZXIgY2lyY2xlXG5cblxuICAgICAgICBpZiAoY2hlY2tJbkVsbGlwc2UoeCwgeSwgZGlhbSwgZGlhbSwgY2VudGVyWCArIHdpZHRoIC8gMiAtIGNvcm5lclJhZGl1cywgY2VudGVyWSArIGhlaWdodCAvIDIgLSBjb3JuZXJSYWRpdXMsIHBhZGRpbmcpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gLy8gQ2hlY2sgYm90dG9tIGxlZnQgcXVhcnRlciBjaXJjbGVcblxuXG4gICAgICAgIGlmIChjaGVja0luRWxsaXBzZSh4LCB5LCBkaWFtLCBkaWFtLCBjZW50ZXJYIC0gd2lkdGggLyAyICsgY29ybmVyUmFkaXVzLCBjZW50ZXJZICsgaGVpZ2h0IC8gMiAtIGNvcm5lclJhZGl1cywgcGFkZGluZykpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIEJScCQyLnJlZ2lzdGVyTm9kZVNoYXBlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbm9kZVNoYXBlcyA9IHRoaXMubm9kZVNoYXBlcyA9IHt9O1xuICAgIHZhciByZW5kZXJlciA9IHRoaXM7XG4gICAgdGhpcy5nZW5lcmF0ZUVsbGlwc2UoKTtcbiAgICB0aGlzLmdlbmVyYXRlUG9seWdvbigndHJpYW5nbGUnLCBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoMywgMCkpO1xuICAgIHRoaXMuZ2VuZXJhdGVSb3VuZFBvbHlnb24oJ3JvdW5kLXRyaWFuZ2xlJywgZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDMsIDApKTtcbiAgICB0aGlzLmdlbmVyYXRlUG9seWdvbigncmVjdGFuZ2xlJywgZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDQsIDApKTtcbiAgICBub2RlU2hhcGVzWydzcXVhcmUnXSA9IG5vZGVTaGFwZXNbJ3JlY3RhbmdsZSddO1xuICAgIHRoaXMuZ2VuZXJhdGVSb3VuZFJlY3RhbmdsZSgpO1xuICAgIHRoaXMuZ2VuZXJhdGVDdXRSZWN0YW5nbGUoKTtcbiAgICB0aGlzLmdlbmVyYXRlQmFycmVsKCk7XG4gICAgdGhpcy5nZW5lcmF0ZUJvdHRvbVJvdW5kcmVjdGFuZ2xlKCk7XG4gICAge1xuICAgICAgdmFyIGRpYW1vbmRQb2ludHMgPSBbMCwgMSwgMSwgMCwgMCwgLTEsIC0xLCAwXTtcbiAgICAgIHRoaXMuZ2VuZXJhdGVQb2x5Z29uKCdkaWFtb25kJywgZGlhbW9uZFBvaW50cyk7XG4gICAgICB0aGlzLmdlbmVyYXRlUm91bmRQb2x5Z29uKCdyb3VuZC1kaWFtb25kJywgZGlhbW9uZFBvaW50cyk7XG4gICAgfVxuICAgIHRoaXMuZ2VuZXJhdGVQb2x5Z29uKCdwZW50YWdvbicsIGdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSg1LCAwKSk7XG4gICAgdGhpcy5nZW5lcmF0ZVJvdW5kUG9seWdvbigncm91bmQtcGVudGFnb24nLCBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoNSwgMCkpO1xuICAgIHRoaXMuZ2VuZXJhdGVQb2x5Z29uKCdoZXhhZ29uJywgZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDYsIDApKTtcbiAgICB0aGlzLmdlbmVyYXRlUm91bmRQb2x5Z29uKCdyb3VuZC1oZXhhZ29uJywgZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDYsIDApKTtcbiAgICB0aGlzLmdlbmVyYXRlUG9seWdvbignaGVwdGFnb24nLCBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoNywgMCkpO1xuICAgIHRoaXMuZ2VuZXJhdGVSb3VuZFBvbHlnb24oJ3JvdW5kLWhlcHRhZ29uJywgZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDcsIDApKTtcbiAgICB0aGlzLmdlbmVyYXRlUG9seWdvbignb2N0YWdvbicsIGdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSg4LCAwKSk7XG4gICAgdGhpcy5nZW5lcmF0ZVJvdW5kUG9seWdvbigncm91bmQtb2N0YWdvbicsIGdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSg4LCAwKSk7XG4gICAgdmFyIHN0YXI1UG9pbnRzID0gbmV3IEFycmF5KDIwKTtcbiAgICB7XG4gICAgICB2YXIgb3V0ZXJQb2ludHMgPSBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzKDUsIDApO1xuICAgICAgdmFyIGlubmVyUG9pbnRzID0gZ2VuZXJhdGVVbml0TmdvblBvaW50cyg1LCBNYXRoLlBJIC8gNSk7IC8vIE91dGVyIHJhZGl1cyBpcyAxOyBpbm5lciByYWRpdXMgb2Ygc3RhciBpcyBzbWFsbGVyXG5cbiAgICAgIHZhciBpbm5lclJhZGl1cyA9IDAuNSAqICgzIC0gTWF0aC5zcXJ0KDUpKTtcbiAgICAgIGlubmVyUmFkaXVzICo9IDEuNTc7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5uZXJQb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgICAgIGlubmVyUG9pbnRzW2kgKiAyXSAqPSBpbm5lclJhZGl1cztcbiAgICAgICAgaW5uZXJQb2ludHNbaSAqIDIgKyAxXSAqPSBpbm5lclJhZGl1cztcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyMCAvIDQ7IGkrKykge1xuICAgICAgICBzdGFyNVBvaW50c1tpICogNF0gPSBvdXRlclBvaW50c1tpICogMl07XG4gICAgICAgIHN0YXI1UG9pbnRzW2kgKiA0ICsgMV0gPSBvdXRlclBvaW50c1tpICogMiArIDFdO1xuICAgICAgICBzdGFyNVBvaW50c1tpICogNCArIDJdID0gaW5uZXJQb2ludHNbaSAqIDJdO1xuICAgICAgICBzdGFyNVBvaW50c1tpICogNCArIDNdID0gaW5uZXJQb2ludHNbaSAqIDIgKyAxXTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3RhcjVQb2ludHMgPSBmaXRQb2x5Z29uVG9TcXVhcmUoc3RhcjVQb2ludHMpO1xuICAgIHRoaXMuZ2VuZXJhdGVQb2x5Z29uKCdzdGFyJywgc3RhcjVQb2ludHMpO1xuICAgIHRoaXMuZ2VuZXJhdGVQb2x5Z29uKCd2ZWUnLCBbLTEsIC0xLCAwLCAtMC4zMzMsIDEsIC0xLCAwLCAxXSk7XG4gICAgdGhpcy5nZW5lcmF0ZVBvbHlnb24oJ3Job21ib2lkJywgWy0xLCAtMSwgMC4zMzMsIC0xLCAxLCAxLCAtMC4zMzMsIDFdKTtcbiAgICB0aGlzLm5vZGVTaGFwZXNbJ2NvbmNhdmVoZXhhZ29uJ10gPSB0aGlzLmdlbmVyYXRlUG9seWdvbignY29uY2F2ZS1oZXhhZ29uJywgWy0xLCAtMC45NSwgLTAuNzUsIDAsIC0xLCAwLjk1LCAxLCAwLjk1LCAwLjc1LCAwLCAxLCAtMC45NV0pO1xuICAgIHtcbiAgICAgIHZhciB0YWdQb2ludHMgPSBbLTEsIC0xLCAwLjI1LCAtMSwgMSwgMCwgMC4yNSwgMSwgLTEsIDFdO1xuICAgICAgdGhpcy5nZW5lcmF0ZVBvbHlnb24oJ3RhZycsIHRhZ1BvaW50cyk7XG4gICAgICB0aGlzLmdlbmVyYXRlUm91bmRQb2x5Z29uKCdyb3VuZC10YWcnLCB0YWdQb2ludHMpO1xuICAgIH1cblxuICAgIG5vZGVTaGFwZXMubWFrZVBvbHlnb24gPSBmdW5jdGlvbiAocG9pbnRzKSB7XG4gICAgICAvLyB1c2UgY2FjaGluZyBvbiB1c2VyLXNwZWNpZmllZCBwb2x5Z29ucyBzbyB0aGV5IGFyZSBhcyBmYXN0IGFzIG5hdGl2ZSBzaGFwZXNcbiAgICAgIHZhciBrZXkgPSBwb2ludHMuam9pbignJCcpO1xuICAgICAgdmFyIG5hbWUgPSAncG9seWdvbi0nICsga2V5O1xuICAgICAgdmFyIHNoYXBlO1xuXG4gICAgICBpZiAoc2hhcGUgPSB0aGlzW25hbWVdKSB7XG4gICAgICAgIC8vIGdvdCBjYWNoZWQgc2hhcGVcbiAgICAgICAgcmV0dXJuIHNoYXBlO1xuICAgICAgfSAvLyBjcmVhdGUgYW5kIGNhY2hlIG5ldyBzaGFwZVxuXG5cbiAgICAgIHJldHVybiByZW5kZXJlci5nZW5lcmF0ZVBvbHlnb24obmFtZSwgcG9pbnRzKTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBCUnAkMSA9IHt9O1xuXG4gIEJScCQxLnRpbWVUb1JlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWRyYXdUb3RhbFRpbWUgLyB0aGlzLnJlZHJhd0NvdW50O1xuICB9O1xuXG4gIEJScCQxLnJlZHJhdyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgc3RhdGljRW1wdHlPYmplY3QoKTtcbiAgICB2YXIgciA9IHRoaXM7XG5cbiAgICBpZiAoci5hdmVyYWdlUmVkcmF3VGltZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByLmF2ZXJhZ2VSZWRyYXdUaW1lID0gMDtcbiAgICB9XG5cbiAgICBpZiAoci5sYXN0UmVkcmF3VGltZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByLmxhc3RSZWRyYXdUaW1lID0gMDtcbiAgICB9XG5cbiAgICBpZiAoci5sYXN0RHJhd1RpbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgci5sYXN0RHJhd1RpbWUgPSAwO1xuICAgIH1cblxuICAgIHIucmVxdWVzdGVkRnJhbWUgPSB0cnVlO1xuICAgIHIucmVuZGVyT3B0aW9ucyA9IG9wdGlvbnM7XG4gIH07XG5cbiAgQlJwJDEuYmVmb3JlUmVuZGVyID0gZnVuY3Rpb24gKGZuLCBwcmlvcml0eSkge1xuICAgIC8vIHRoZSByZW5kZXJlciBjYW4ndCBhZGQgdGljayBjYWxsYmFja3Mgd2hlbiBkZXN0cm95ZWRcbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJpb3JpdHkgPT0gbnVsbCkge1xuICAgICAgZXJyb3IoJ1ByaW9yaXR5IGlzIG5vdCBvcHRpb25hbCBmb3IgYmVmb3JlUmVuZGVyJyk7XG4gICAgfVxuXG4gICAgdmFyIGNicyA9IHRoaXMuYmVmb3JlUmVuZGVyQ2FsbGJhY2tzO1xuICAgIGNicy5wdXNoKHtcbiAgICAgIGZuOiBmbixcbiAgICAgIHByaW9yaXR5OiBwcmlvcml0eVxuICAgIH0pOyAvLyBoaWdoZXIgcHJpb3JpdHkgY2FsbGJhY2tzIGV4ZWN1dGVkIGZpcnN0XG5cbiAgICBjYnMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGIucHJpb3JpdHkgLSBhLnByaW9yaXR5O1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBiZWZvcmVSZW5kZXJDYWxsYmFja3MgPSBmdW5jdGlvbiBiZWZvcmVSZW5kZXJDYWxsYmFja3Mociwgd2lsbERyYXcsIHN0YXJ0VGltZSkge1xuICAgIHZhciBjYnMgPSByLmJlZm9yZVJlbmRlckNhbGxiYWNrcztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjYnNbaV0uZm4od2lsbERyYXcsIHN0YXJ0VGltZSk7XG4gICAgfVxuICB9O1xuXG4gIEJScCQxLnN0YXJ0UmVuZGVyTG9vcCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgciA9IHRoaXM7XG4gICAgdmFyIGN5ID0gci5jeTtcblxuICAgIGlmIChyLnJlbmRlckxvb3BTdGFydGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIHIucmVuZGVyTG9vcFN0YXJ0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciByZW5kZXJGbiA9IGZ1bmN0aW9uIHJlbmRlckZuKHJlcXVlc3RUaW1lKSB7XG4gICAgICBpZiAoci5kZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoY3kuYmF0Y2hpbmcoKSkgOyBlbHNlIGlmIChyLnJlcXVlc3RlZEZyYW1lICYmICFyLnNraXBGcmFtZSkge1xuICAgICAgICBiZWZvcmVSZW5kZXJDYWxsYmFja3MociwgdHJ1ZSwgcmVxdWVzdFRpbWUpO1xuICAgICAgICB2YXIgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2VOb3coKTtcbiAgICAgICAgci5yZW5kZXIoci5yZW5kZXJPcHRpb25zKTtcbiAgICAgICAgdmFyIGVuZFRpbWUgPSByLmxhc3REcmF3VGltZSA9IHBlcmZvcm1hbmNlTm93KCk7XG5cbiAgICAgICAgaWYgKHIuYXZlcmFnZVJlZHJhd1RpbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHIuYXZlcmFnZVJlZHJhd1RpbWUgPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHIucmVkcmF3Q291bnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHIucmVkcmF3Q291bnQgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgci5yZWRyYXdDb3VudCsrO1xuXG4gICAgICAgIGlmIChyLnJlZHJhd1RvdGFsVGltZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgci5yZWRyYXdUb3RhbFRpbWUgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGR1cmF0aW9uID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcbiAgICAgICAgci5yZWRyYXdUb3RhbFRpbWUgKz0gZHVyYXRpb247XG4gICAgICAgIHIubGFzdFJlZHJhd1RpbWUgPSBkdXJhdGlvbjsgLy8gdXNlIGEgd2VpZ2h0ZWQgYXZlcmFnZSB3aXRoIGEgYmlhcyBmcm9tIHRoZSBwcmV2aW91cyBhdmVyYWdlIHNvIHdlIGRvbid0IHNwaWtlIHNvIGVhc2lseVxuXG4gICAgICAgIHIuYXZlcmFnZVJlZHJhd1RpbWUgPSByLmF2ZXJhZ2VSZWRyYXdUaW1lIC8gMiArIGR1cmF0aW9uIC8gMjtcbiAgICAgICAgci5yZXF1ZXN0ZWRGcmFtZSA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmVmb3JlUmVuZGVyQ2FsbGJhY2tzKHIsIGZhbHNlLCByZXF1ZXN0VGltZSk7XG4gICAgICB9XG5cbiAgICAgIHIuc2tpcEZyYW1lID0gZmFsc2U7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmVuZGVyRm4pO1xuICAgIH07XG5cbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmVuZGVyRm4pO1xuICB9O1xuXG4gIHZhciBCYXNlUmVuZGVyZXIgPSBmdW5jdGlvbiBCYXNlUmVuZGVyZXIob3B0aW9ucykge1xuICAgIHRoaXMuaW5pdChvcHRpb25zKTtcbiAgfTtcblxuICB2YXIgQlIgPSBCYXNlUmVuZGVyZXI7XG4gIHZhciBCUnAgPSBCUi5wcm90b3R5cGU7XG4gIEJScC5jbGllbnRGdW5jdGlvbnMgPSBbJ3JlZHJhd0hpbnQnLCAncmVuZGVyJywgJ3JlbmRlclRvJywgJ21hdGNoQ2FudmFzU2l6ZScsICdub2RlU2hhcGVJbXBsJywgJ2Fycm93U2hhcGVJbXBsJ107XG5cbiAgQlJwLmluaXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciByID0gdGhpcztcbiAgICByLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHIuY3kgPSBvcHRpb25zLmN5O1xuICAgIHZhciBjdHIgPSByLmNvbnRhaW5lciA9IG9wdGlvbnMuY3kuY29udGFpbmVyKCk7IC8vIHByZXBlbmQgYSBzdHlsZXNoZWV0IGluIHRoZSBoZWFkIHN1Y2ggdGhhdFxuXG4gICAgaWYgKHdpbmRvdyQxKSB7XG4gICAgICB2YXIgZG9jdW1lbnQgPSB3aW5kb3ckMS5kb2N1bWVudDtcbiAgICAgIHZhciBoZWFkID0gZG9jdW1lbnQuaGVhZDtcbiAgICAgIHZhciBzdHlsZXNoZWV0SWQgPSAnX19fX19fX19fX2N5dG9zY2FwZV9zdHlsZXNoZWV0JztcbiAgICAgIHZhciBjbGFzc05hbWUgPSAnX19fX19fX19fX2N5dG9zY2FwZV9jb250YWluZXInO1xuICAgICAgdmFyIHN0eWxlc2hlZXRBbHJlYWR5RXhpc3RzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoc3R5bGVzaGVldElkKSAhPSBudWxsO1xuXG4gICAgICBpZiAoY3RyLmNsYXNzTmFtZS5pbmRleE9mKGNsYXNzTmFtZSkgPCAwKSB7XG4gICAgICAgIGN0ci5jbGFzc05hbWUgPSAoY3RyLmNsYXNzTmFtZSB8fCAnJykgKyAnICcgKyBjbGFzc05hbWU7XG4gICAgICB9XG5cbiAgICAgIGlmICghc3R5bGVzaGVldEFscmVhZHlFeGlzdHMpIHtcbiAgICAgICAgdmFyIHN0eWxlc2hlZXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgICBzdHlsZXNoZWV0LmlkID0gc3R5bGVzaGVldElkO1xuICAgICAgICBzdHlsZXNoZWV0LmlubmVySFRNTCA9ICcuJyArIGNsYXNzTmFtZSArICcgeyBwb3NpdGlvbjogcmVsYXRpdmU7IH0nO1xuICAgICAgICBoZWFkLmluc2VydEJlZm9yZShzdHlsZXNoZWV0LCBoZWFkLmNoaWxkcmVuWzBdKTsgLy8gZmlyc3Qgc28gbG93ZXN0IHByaW9yaXR5XG4gICAgICB9XG5cbiAgICAgIHZhciBjb21wdXRlZFN0eWxlID0gd2luZG93JDEuZ2V0Q29tcHV0ZWRTdHlsZShjdHIpO1xuICAgICAgdmFyIHBvc2l0aW9uID0gY29tcHV0ZWRTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdwb3NpdGlvbicpO1xuXG4gICAgICBpZiAocG9zaXRpb24gPT09ICdzdGF0aWMnKSB7XG4gICAgICAgIHdhcm4oJ0EgQ3l0b3NjYXBlIGNvbnRhaW5lciBoYXMgc3R5bGUgcG9zaXRpb246c3RhdGljIGFuZCBzbyBjYW4gbm90IHVzZSBVSSBleHRlbnNpb25zIHByb3Blcmx5Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgci5zZWxlY3Rpb24gPSBbdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCAwXTsgLy8gQ29vcmRpbmF0ZXMgZm9yIHNlbGVjdGlvbiBib3gsIHBsdXMgZW5hYmxlZCBmbGFnXG5cbiAgICByLmJlemllclByb2pQY3RzID0gWzAuMDUsIDAuMjI1LCAwLjQsIDAuNSwgMC42LCAwLjc3NSwgMC45NV07IC8vLS1Qb2ludGVyLXJlbGF0ZWQgZGF0YVxuXG4gICAgci5ob3ZlckRhdGEgPSB7XG4gICAgICBkb3duOiBudWxsLFxuICAgICAgbGFzdDogbnVsbCxcbiAgICAgIGRvd25UaW1lOiBudWxsLFxuICAgICAgdHJpZ2dlck1vZGU6IG51bGwsXG4gICAgICBkcmFnZ2luZzogZmFsc2UsXG4gICAgICBpbml0aWFsUGFuOiBbbnVsbCwgbnVsbF0sXG4gICAgICBjYXB0dXJlOiBmYWxzZVxuICAgIH07XG4gICAgci5kcmFnRGF0YSA9IHtcbiAgICAgIHBvc3NpYmxlRHJhZ0VsZW1lbnRzOiBbXVxuICAgIH07XG4gICAgci50b3VjaERhdGEgPSB7XG4gICAgICBzdGFydDogbnVsbCxcbiAgICAgIGNhcHR1cmU6IGZhbHNlLFxuICAgICAgLy8gVGhlc2UgMyBmaWVsZHMgcmVsYXRlZCB0byB0YXAsIHRhcGhvbGQgZXZlbnRzXG4gICAgICBzdGFydFBvc2l0aW9uOiBbbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbF0sXG4gICAgICBzaW5nbGVUb3VjaFN0YXJ0VGltZTogbnVsbCxcbiAgICAgIHNpbmdsZVRvdWNoTW92ZWQ6IHRydWUsXG4gICAgICBub3c6IFtudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsXSxcbiAgICAgIGVhcmxpZXI6IFtudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsXVxuICAgIH07XG4gICAgci5yZWRyYXdzID0gMDtcbiAgICByLnNob3dGcHMgPSBvcHRpb25zLnNob3dGcHM7XG4gICAgci5kZWJ1ZyA9IG9wdGlvbnMuZGVidWc7XG4gICAgci5oaWRlRWRnZXNPblZpZXdwb3J0ID0gb3B0aW9ucy5oaWRlRWRnZXNPblZpZXdwb3J0O1xuICAgIHIudGV4dHVyZU9uVmlld3BvcnQgPSBvcHRpb25zLnRleHR1cmVPblZpZXdwb3J0O1xuICAgIHIud2hlZWxTZW5zaXRpdml0eSA9IG9wdGlvbnMud2hlZWxTZW5zaXRpdml0eTtcbiAgICByLm1vdGlvbkJsdXJFbmFibGVkID0gb3B0aW9ucy5tb3Rpb25CbHVyOyAvLyBvbiBieSBkZWZhdWx0XG5cbiAgICByLmZvcmNlZFBpeGVsUmF0aW8gPSBudW1iZXIkMShvcHRpb25zLnBpeGVsUmF0aW8pID8gb3B0aW9ucy5waXhlbFJhdGlvIDogbnVsbDtcbiAgICByLm1vdGlvbkJsdXIgPSBvcHRpb25zLm1vdGlvbkJsdXI7IC8vIGZvciBpbml0aWFsIGtpY2sgb2ZmXG5cbiAgICByLm1vdGlvbkJsdXJPcGFjaXR5ID0gb3B0aW9ucy5tb3Rpb25CbHVyT3BhY2l0eTtcbiAgICByLm1vdGlvbkJsdXJUcmFuc3BhcmVuY3kgPSAxIC0gci5tb3Rpb25CbHVyT3BhY2l0eTtcbiAgICByLm1vdGlvbkJsdXJQeFJhdGlvID0gMTtcbiAgICByLm1iUHhSQmx1cnJ5ID0gMTsgLy8wLjg7XG5cbiAgICByLm1pbk1iTG93UXVhbEZyYW1lcyA9IDQ7XG4gICAgci5mdWxsUXVhbGl0eU1iID0gZmFsc2U7XG4gICAgci5jbGVhcmVkRm9yTW90aW9uQmx1ciA9IFtdO1xuICAgIHIuZGVza3RvcFRhcFRocmVzaG9sZCA9IG9wdGlvbnMuZGVza3RvcFRhcFRocmVzaG9sZDtcbiAgICByLmRlc2t0b3BUYXBUaHJlc2hvbGQyID0gb3B0aW9ucy5kZXNrdG9wVGFwVGhyZXNob2xkICogb3B0aW9ucy5kZXNrdG9wVGFwVGhyZXNob2xkO1xuICAgIHIudG91Y2hUYXBUaHJlc2hvbGQgPSBvcHRpb25zLnRvdWNoVGFwVGhyZXNob2xkO1xuICAgIHIudG91Y2hUYXBUaHJlc2hvbGQyID0gb3B0aW9ucy50b3VjaFRhcFRocmVzaG9sZCAqIG9wdGlvbnMudG91Y2hUYXBUaHJlc2hvbGQ7XG4gICAgci50YXBob2xkRHVyYXRpb24gPSA1MDA7XG4gICAgci5iaW5kaW5ncyA9IFtdO1xuICAgIHIuYmVmb3JlUmVuZGVyQ2FsbGJhY2tzID0gW107XG4gICAgci5iZWZvcmVSZW5kZXJQcmlvcml0aWVzID0ge1xuICAgICAgLy8gaGlnaGVyIHByaW9yaXR5IGV4ZWNzIGJlZm9yZSBsb3dlciBvbmVcbiAgICAgIGFuaW1hdGlvbnM6IDQwMCxcbiAgICAgIGVsZUNhbGNzOiAzMDAsXG4gICAgICBlbGVUeHJEZXE6IDIwMCxcbiAgICAgIGx5clR4ckRlcTogMTUwLFxuICAgICAgbHlyVHhyU2tpcDogMTAwXG4gICAgfTtcbiAgICByLnJlZ2lzdGVyTm9kZVNoYXBlcygpO1xuICAgIHIucmVnaXN0ZXJBcnJvd1NoYXBlcygpO1xuICAgIHIucmVnaXN0ZXJDYWxjdWxhdGlvbkxpc3RlbmVycygpO1xuICB9O1xuXG4gIEJScC5ub3RpZnkgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBlbGVzKSB7XG4gICAgdmFyIHIgPSB0aGlzO1xuICAgIHZhciBjeSA9IHIuY3k7IC8vIHRoZSByZW5kZXJlciBjYW4ndCBiZSBub3RpZmllZCBhZnRlciBpdCdzIGRlc3Ryb3llZFxuXG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50TmFtZSA9PT0gJ2luaXQnKSB7XG4gICAgICByLmxvYWQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnROYW1lID09PSAnZGVzdHJveScpIHtcbiAgICAgIHIuZGVzdHJveSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChldmVudE5hbWUgPT09ICdhZGQnIHx8IGV2ZW50TmFtZSA9PT0gJ3JlbW92ZScgfHwgZXZlbnROYW1lID09PSAnbW92ZScgJiYgY3kuaGFzQ29tcG91bmROb2RlcygpIHx8IGV2ZW50TmFtZSA9PT0gJ2xvYWQnIHx8IGV2ZW50TmFtZSA9PT0gJ3pvcmRlcicgfHwgZXZlbnROYW1lID09PSAnbW91bnQnKSB7XG4gICAgICByLmludmFsaWRhdGVDYWNoZWRaU29ydGVkRWxlcygpO1xuICAgIH1cblxuICAgIGlmIChldmVudE5hbWUgPT09ICd2aWV3cG9ydCcpIHtcbiAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50TmFtZSA9PT0gJ2xvYWQnIHx8IGV2ZW50TmFtZSA9PT0gJ3Jlc2l6ZScgfHwgZXZlbnROYW1lID09PSAnbW91bnQnKSB7XG4gICAgICByLmludmFsaWRhdGVDb250YWluZXJDbGllbnRDb29yZHNDYWNoZSgpO1xuICAgICAgci5tYXRjaENhbnZhc1NpemUoci5jb250YWluZXIpO1xuICAgIH1cblxuICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgIHIucmVkcmF3SGludCgnZHJhZycsIHRydWUpO1xuICAgIHRoaXMuc3RhcnRSZW5kZXJMb29wKCk7XG4gICAgdGhpcy5yZWRyYXcoKTtcbiAgfTtcblxuICBCUnAuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgciA9IHRoaXM7XG4gICAgci5kZXN0cm95ZWQgPSB0cnVlO1xuICAgIHIuY3kuc3RvcEFuaW1hdGlvbkxvb3AoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgci5iaW5kaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGJpbmRpbmcgPSByLmJpbmRpbmdzW2ldO1xuICAgICAgdmFyIGIgPSBiaW5kaW5nO1xuICAgICAgdmFyIHRndCA9IGIudGFyZ2V0O1xuICAgICAgKHRndC5vZmYgfHwgdGd0LnJlbW92ZUV2ZW50TGlzdGVuZXIpLmFwcGx5KHRndCwgYi5hcmdzKTtcbiAgICB9XG5cbiAgICByLmJpbmRpbmdzID0gW107XG4gICAgci5iZWZvcmVSZW5kZXJDYWxsYmFja3MgPSBbXTtcbiAgICByLm9uVXBkYXRlRWxlQ2FsY3NGbnMgPSBbXTtcblxuICAgIGlmIChyLnJlbW92ZU9ic2VydmVyKSB7XG4gICAgICByLnJlbW92ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICB9XG5cbiAgICBpZiAoci5zdHlsZU9ic2VydmVyKSB7XG4gICAgICByLnN0eWxlT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIH1cblxuICAgIGlmIChyLnJlc2l6ZU9ic2VydmVyKSB7XG4gICAgICByLnJlc2l6ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICB9XG5cbiAgICBpZiAoci5sYWJlbENhbGNEaXYpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoci5sYWJlbENhbGNEaXYpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gICAgICB9IGNhdGNoIChlKSB7Ly8gaWUxMCBpc3N1ZSAjMTAxNFxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBCUnAuaXNIZWFkbGVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgW0JScCRmLCBCUnAkNSwgQlJwJDQsIEJScCQzLCBCUnAkMiwgQlJwJDFdLmZvckVhY2goZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgZXh0ZW5kKEJScCwgcHJvcHMpO1xuICB9KTtcblxuICB2YXIgZnVsbEZwc1RpbWUgPSAxMDAwIC8gNjA7IC8vIGFzc3VtZSA2MCBmcmFtZXMgcGVyIHNlY29uZFxuXG4gIHZhciBkZWZzID0ge1xuICAgIHNldHVwRGVxdWV1ZWluZzogZnVuY3Rpb24gc2V0dXBEZXF1ZXVlaW5nKG9wdHMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBzZXR1cERlcXVldWVpbmdJbXBsKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciByID0gdGhpcy5yZW5kZXJlcjtcblxuICAgICAgICBpZiAoc2VsZi5kZXF1ZXVlaW5nU2V0dXApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VsZi5kZXF1ZXVlaW5nU2V0dXAgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHF1ZXVlUmVkcmF3ID0gZGVib3VuY2VfMShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgICAgci5yZWRyYXdIaW50KCdkcmFnJywgdHJ1ZSk7XG4gICAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgICAgfSwgb3B0cy5kZXFSZWRyYXdUaHJlc2hvbGQpO1xuXG4gICAgICAgIHZhciBkZXF1ZXVlID0gZnVuY3Rpb24gZGVxdWV1ZSh3aWxsRHJhdywgZnJhbWVTdGFydFRpbWUpIHtcbiAgICAgICAgICB2YXIgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2VOb3coKTtcbiAgICAgICAgICB2YXIgYXZnUmVuZGVyVGltZSA9IHIuYXZlcmFnZVJlZHJhd1RpbWU7XG4gICAgICAgICAgdmFyIHJlbmRlclRpbWUgPSByLmxhc3RSZWRyYXdUaW1lO1xuICAgICAgICAgIHZhciBkZXFkID0gW107XG4gICAgICAgICAgdmFyIGV4dGVudCA9IHIuY3kuZXh0ZW50KCk7XG4gICAgICAgICAgdmFyIHBpeGVsUmF0aW8gPSByLmdldFBpeGVsUmF0aW8oKTsgLy8gaWYgd2UgYXJlbid0IGluIGEgdGljayB0aGF0IGNhdXNlcyBhIGRyYXcsIHRoZW4gdGhlIHJlbmRlcmVkIHN0eWxlXG4gICAgICAgICAgLy8gcXVldWUgd29uJ3QgYXV0b21hdGljYWxseSBiZSBmbHVzaGVkIGJlZm9yZSBkZXF1ZXVlaW5nIHN0YXJ0c1xuXG4gICAgICAgICAgaWYgKCF3aWxsRHJhdykge1xuICAgICAgICAgICAgci5mbHVzaFJlbmRlcmVkU3R5bGVRdWV1ZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICAgICAgICAgICAgdmFyIG5vdyA9IHBlcmZvcm1hbmNlTm93KCk7XG4gICAgICAgICAgICB2YXIgZHVyYXRpb24gPSBub3cgLSBzdGFydFRpbWU7XG4gICAgICAgICAgICB2YXIgZnJhbWVEdXJhdGlvbiA9IG5vdyAtIGZyYW1lU3RhcnRUaW1lO1xuXG4gICAgICAgICAgICBpZiAocmVuZGVyVGltZSA8IGZ1bGxGcHNUaW1lKSB7XG4gICAgICAgICAgICAgIC8vIGlmIHdlJ3JlIHJlbmRlcmluZyBmYXN0ZXIgdGhhbiB0aGUgaWRlYWwgZnBzLCB0aGVuIGRvIGRlcXVldWVpbmdcbiAgICAgICAgICAgICAgLy8gZHVyaW5nIGFsbCBvZiB0aGUgcmVtYWluaW5nIGZyYW1lIHRpbWVcbiAgICAgICAgICAgICAgdmFyIHRpbWVBdmFpbGFibGUgPSBmdWxsRnBzVGltZSAtICh3aWxsRHJhdyA/IGF2Z1JlbmRlclRpbWUgOiAwKTtcblxuICAgICAgICAgICAgICBpZiAoZnJhbWVEdXJhdGlvbiA+PSBvcHRzLmRlcUZhc3RDb3N0ICogdGltZUF2YWlsYWJsZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAod2lsbERyYXcpIHtcbiAgICAgICAgICAgICAgICBpZiAoZHVyYXRpb24gPj0gb3B0cy5kZXFDb3N0ICogcmVuZGVyVGltZSB8fCBkdXJhdGlvbiA+PSBvcHRzLmRlcUF2Z0Nvc3QgKiBhdmdSZW5kZXJUaW1lKSB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoZnJhbWVEdXJhdGlvbiA+PSBvcHRzLmRlcU5vRHJhd0Nvc3QgKiBmdWxsRnBzVGltZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0aGlzRGVxZCA9IG9wdHMuZGVxKHNlbGYsIHBpeGVsUmF0aW8sIGV4dGVudCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzRGVxZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpc0RlcWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkZXFkLnB1c2godGhpc0RlcWRbaV0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIGNhbGxiYWNrcyBvbiBkZXF1ZXVlXG5cblxuICAgICAgICAgIGlmIChkZXFkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIG9wdHMub25EZXFkKHNlbGYsIGRlcWQpO1xuXG4gICAgICAgICAgICBpZiAoIXdpbGxEcmF3ICYmIG9wdHMuc2hvdWxkUmVkcmF3KHNlbGYsIGRlcWQsIHBpeGVsUmF0aW8sIGV4dGVudCkpIHtcbiAgICAgICAgICAgICAgcXVldWVSZWRyYXcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHByaW9yaXR5ID0gb3B0cy5wcmlvcml0eSB8fCBub29wJDE7XG4gICAgICAgIHIuYmVmb3JlUmVuZGVyKGRlcXVldWUsIHByaW9yaXR5KHNlbGYpKTtcbiAgICAgIH07XG4gICAgfVxuICB9O1xuXG4gIC8vIFVzZXMga2V5cyBzbyBlbGVtZW50cyBtYXkgc2hhcmUgdGhlIHNhbWUgY2FjaGUuXG5cbiAgdmFyIEVsZW1lbnRUZXh0dXJlQ2FjaGVMb29rdXAgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEVsZW1lbnRUZXh0dXJlQ2FjaGVMb29rdXAoZ2V0S2V5KSB7XG4gICAgICB2YXIgZG9lc0VsZUludmFsaWRhdGVLZXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNpZnk7XG5cbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFbGVtZW50VGV4dHVyZUNhY2hlTG9va3VwKTtcblxuICAgICAgdGhpcy5pZHNCeUtleSA9IG5ldyBNYXAkMigpO1xuICAgICAgdGhpcy5rZXlGb3JJZCA9IG5ldyBNYXAkMigpO1xuICAgICAgdGhpcy5jYWNoZXNCeUx2bCA9IG5ldyBNYXAkMigpO1xuICAgICAgdGhpcy5sdmxzID0gW107XG4gICAgICB0aGlzLmdldEtleSA9IGdldEtleTtcbiAgICAgIHRoaXMuZG9lc0VsZUludmFsaWRhdGVLZXkgPSBkb2VzRWxlSW52YWxpZGF0ZUtleTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoRWxlbWVudFRleHR1cmVDYWNoZUxvb2t1cCwgW3tcbiAgICAgIGtleTogXCJnZXRJZHNGb3JcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJZHNGb3Ioa2V5KSB7XG4gICAgICAgIGlmIChrZXkgPT0gbnVsbCkge1xuICAgICAgICAgIGVycm9yKFwiQ2FuIG5vdCBnZXQgaWQgbGlzdCBmb3IgbnVsbCBrZXlcIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaWRzQnlLZXkgPSB0aGlzLmlkc0J5S2V5O1xuICAgICAgICB2YXIgaWRzID0gdGhpcy5pZHNCeUtleS5nZXQoa2V5KTtcblxuICAgICAgICBpZiAoIWlkcykge1xuICAgICAgICAgIGlkcyA9IG5ldyBTZXQkMSgpO1xuICAgICAgICAgIGlkc0J5S2V5LnNldChrZXksIGlkcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaWRzO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJhZGRJZEZvcktleVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZElkRm9yS2V5KGtleSwgaWQpIHtcbiAgICAgICAgaWYgKGtleSAhPSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5nZXRJZHNGb3Ioa2V5KS5hZGQoaWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImRlbGV0ZUlkRm9yS2V5XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVsZXRlSWRGb3JLZXkoa2V5LCBpZCkge1xuICAgICAgICBpZiAoa2V5ICE9IG51bGwpIHtcbiAgICAgICAgICB0aGlzLmdldElkc0ZvcihrZXkpW1wiZGVsZXRlXCJdKGlkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXROdW1iZXJPZklkc0ZvcktleVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldE51bWJlck9mSWRzRm9yS2V5KGtleSkge1xuICAgICAgICBpZiAoa2V5ID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXRJZHNGb3Ioa2V5KS5zaXplO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInVwZGF0ZUtleU1hcHBpbmdGb3JcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVLZXlNYXBwaW5nRm9yKGVsZSkge1xuICAgICAgICB2YXIgaWQgPSBlbGUuaWQoKTtcbiAgICAgICAgdmFyIHByZXZLZXkgPSB0aGlzLmtleUZvcklkLmdldChpZCk7XG4gICAgICAgIHZhciBjdXJyS2V5ID0gdGhpcy5nZXRLZXkoZWxlKTtcbiAgICAgICAgdGhpcy5kZWxldGVJZEZvcktleShwcmV2S2V5LCBpZCk7XG4gICAgICAgIHRoaXMuYWRkSWRGb3JLZXkoY3VycktleSwgaWQpO1xuICAgICAgICB0aGlzLmtleUZvcklkLnNldChpZCwgY3VycktleSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImRlbGV0ZUtleU1hcHBpbmdGb3JcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZWxldGVLZXlNYXBwaW5nRm9yKGVsZSkge1xuICAgICAgICB2YXIgaWQgPSBlbGUuaWQoKTtcbiAgICAgICAgdmFyIHByZXZLZXkgPSB0aGlzLmtleUZvcklkLmdldChpZCk7XG4gICAgICAgIHRoaXMuZGVsZXRlSWRGb3JLZXkocHJldktleSwgaWQpO1xuICAgICAgICB0aGlzLmtleUZvcklkW1wiZGVsZXRlXCJdKGlkKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwia2V5SGFzQ2hhbmdlZEZvclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGtleUhhc0NoYW5nZWRGb3IoZWxlKSB7XG4gICAgICAgIHZhciBpZCA9IGVsZS5pZCgpO1xuICAgICAgICB2YXIgcHJldktleSA9IHRoaXMua2V5Rm9ySWQuZ2V0KGlkKTtcbiAgICAgICAgdmFyIG5ld0tleSA9IHRoaXMuZ2V0S2V5KGVsZSk7XG4gICAgICAgIHJldHVybiBwcmV2S2V5ICE9PSBuZXdLZXk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImlzSW52YWxpZFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzSW52YWxpZChlbGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5SGFzQ2hhbmdlZEZvcihlbGUpIHx8IHRoaXMuZG9lc0VsZUludmFsaWRhdGVLZXkoZWxlKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0Q2FjaGVzQXRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDYWNoZXNBdChsdmwpIHtcbiAgICAgICAgdmFyIGNhY2hlc0J5THZsID0gdGhpcy5jYWNoZXNCeUx2bCxcbiAgICAgICAgICAgIGx2bHMgPSB0aGlzLmx2bHM7XG4gICAgICAgIHZhciBjYWNoZXMgPSBjYWNoZXNCeUx2bC5nZXQobHZsKTtcblxuICAgICAgICBpZiAoIWNhY2hlcykge1xuICAgICAgICAgIGNhY2hlcyA9IG5ldyBNYXAkMigpO1xuICAgICAgICAgIGNhY2hlc0J5THZsLnNldChsdmwsIGNhY2hlcyk7XG4gICAgICAgICAgbHZscy5wdXNoKGx2bCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2FjaGVzO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRDYWNoZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldENhY2hlKGtleSwgbHZsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENhY2hlc0F0KGx2bCkuZ2V0KGtleSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdldFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldChlbGUsIGx2bCkge1xuICAgICAgICB2YXIga2V5ID0gdGhpcy5nZXRLZXkoZWxlKTtcbiAgICAgICAgdmFyIGNhY2hlID0gdGhpcy5nZXRDYWNoZShrZXksIGx2bCk7IC8vIGdldHRpbmcgZm9yIGFuIGVsZW1lbnQgbWF5IG5lZWQgdG8gYWRkIHRvIHRoZSBpZCBsaXN0IGIvYyBlbGVzIGNhbiBzaGFyZSBrZXlzXG5cbiAgICAgICAgaWYgKGNhY2hlICE9IG51bGwpIHtcbiAgICAgICAgICB0aGlzLnVwZGF0ZUtleU1hcHBpbmdGb3IoZWxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjYWNoZTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZ2V0Rm9yQ2FjaGVkS2V5XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Rm9yQ2FjaGVkS2V5KGVsZSwgbHZsKSB7XG4gICAgICAgIHZhciBrZXkgPSB0aGlzLmtleUZvcklkLmdldChlbGUuaWQoKSk7IC8vIG4uYi4gdXNlIGNhY2hlZCBrZXksIG5vdCBuZXdseSBjb21wdXRlZCBrZXlcblxuICAgICAgICB2YXIgY2FjaGUgPSB0aGlzLmdldENhY2hlKGtleSwgbHZsKTtcbiAgICAgICAgcmV0dXJuIGNhY2hlO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJoYXNDYWNoZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhc0NhY2hlKGtleSwgbHZsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENhY2hlc0F0KGx2bCkuaGFzKGtleSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImhhc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhcyhlbGUsIGx2bCkge1xuICAgICAgICB2YXIga2V5ID0gdGhpcy5nZXRLZXkoZWxlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzQ2FjaGUoa2V5LCBsdmwpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzZXRDYWNoZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldENhY2hlKGtleSwgbHZsLCBjYWNoZSkge1xuICAgICAgICBjYWNoZS5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMuZ2V0Q2FjaGVzQXQobHZsKS5zZXQoa2V5LCBjYWNoZSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInNldFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldChlbGUsIGx2bCwgY2FjaGUpIHtcbiAgICAgICAgdmFyIGtleSA9IHRoaXMuZ2V0S2V5KGVsZSk7XG4gICAgICAgIHRoaXMuc2V0Q2FjaGUoa2V5LCBsdmwsIGNhY2hlKTtcbiAgICAgICAgdGhpcy51cGRhdGVLZXlNYXBwaW5nRm9yKGVsZSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImRlbGV0ZUNhY2hlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVsZXRlQ2FjaGUoa2V5LCBsdmwpIHtcbiAgICAgICAgdGhpcy5nZXRDYWNoZXNBdChsdmwpW1wiZGVsZXRlXCJdKGtleSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImRlbGV0ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9kZWxldGUoZWxlLCBsdmwpIHtcbiAgICAgICAgdmFyIGtleSA9IHRoaXMuZ2V0S2V5KGVsZSk7XG4gICAgICAgIHRoaXMuZGVsZXRlQ2FjaGUoa2V5LCBsdmwpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJpbnZhbGlkYXRlS2V5XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gaW52YWxpZGF0ZUtleShrZXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICB0aGlzLmx2bHMuZm9yRWFjaChmdW5jdGlvbiAobHZsKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLmRlbGV0ZUNhY2hlKGtleSwgbHZsKTtcbiAgICAgICAgfSk7XG4gICAgICB9IC8vIHJldHVybnMgdHJ1ZSBpZiBubyBvdGhlciBlbGVzIHJlZmVyZW5jZSB0aGUgaW52YWxpZGF0ZWQgY2FjaGUgKG4uYi4gb3RoZXIgZWxlcyBtYXkgbmVlZCB0aGUgY2FjaGUgd2l0aCB0aGUgc2FtZSBrZXkpXG5cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiaW52YWxpZGF0ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGludmFsaWRhdGUoZWxlKSB7XG4gICAgICAgIHZhciBpZCA9IGVsZS5pZCgpO1xuICAgICAgICB2YXIga2V5ID0gdGhpcy5rZXlGb3JJZC5nZXQoaWQpOyAvLyBuLmIuIHVzZSBzdG9yZWQga2V5IHJhdGhlciB0aGFuIGN1cnJlbnQgKHBvdGVudGlhbCBrZXkpXG5cbiAgICAgICAgdGhpcy5kZWxldGVLZXlNYXBwaW5nRm9yKGVsZSk7XG4gICAgICAgIHZhciBlbnRpcmVLZXlJbnZhbGlkYXRlZCA9IHRoaXMuZG9lc0VsZUludmFsaWRhdGVLZXkoZWxlKTtcblxuICAgICAgICBpZiAoZW50aXJlS2V5SW52YWxpZGF0ZWQpIHtcbiAgICAgICAgICAvLyBjbGVhciBtYXBwaW5nIGZvciBjdXJyZW50IGtleVxuICAgICAgICAgIHRoaXMuaW52YWxpZGF0ZUtleShrZXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVudGlyZUtleUludmFsaWRhdGVkIHx8IHRoaXMuZ2V0TnVtYmVyT2ZJZHNGb3JLZXkoa2V5KSA9PT0gMDtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gRWxlbWVudFRleHR1cmVDYWNoZUxvb2t1cDtcbiAgfSgpO1xuXG4gIHZhciBtaW5UeHJIID0gMjU7IC8vIHRoZSBzaXplIG9mIHRoZSB0ZXh0dXJlIGNhY2hlIGZvciBzbWFsbCBoZWlnaHQgZWxlcyAoc3BlY2lhbCBjYXNlKVxuXG4gIHZhciB0eHJTdGVwSCA9IDUwOyAvLyB0aGUgbWluIHNpemUgb2YgdGhlIHJlZ3VsYXIgY2FjaGUsIGFuZCB0aGUgc2l6ZSBpdCBpbmNyZWFzZXMgd2l0aCBlYWNoIHN0ZXAgdXBcblxuICB2YXIgbWluTHZsJDEgPSAtNDsgLy8gd2hlbiBzY2FsaW5nIHNtYWxsZXIgdGhhbiB0aGF0IHdlIGRvbid0IG5lZWQgdG8gcmUtcmVuZGVyXG5cbiAgdmFyIG1heEx2bCQxID0gMzsgLy8gd2hlbiBsYXJnZXIgdGhhbiB0aGlzIHNjYWxlIGp1c3QgcmVuZGVyIGRpcmVjdGx5IChjYWNoaW5nIGlzIG5vdCBoZWxwZnVsKVxuXG4gIHZhciBtYXhab29tJDEgPSA3Ljk5OyAvLyBiZXlvbmQgdGhpcyB6b29tIGxldmVsLCBsYXllcmVkIHRleHR1cmVzIGFyZSBub3QgdXNlZFxuXG4gIHZhciBlbGVUeHJTcGFjaW5nID0gODsgLy8gc3BhY2luZyBiZXR3ZWVuIGVsZW1lbnRzIG9uIHRleHR1cmVzIHRvIGF2b2lkIGJsaXR0aW5nIG92ZXJsYXBzXG5cbiAgdmFyIGRlZlR4cldpZHRoID0gMTAyNDsgLy8gZGVmYXVsdC9taW5pbXVtIHRleHR1cmUgd2lkdGhcblxuICB2YXIgbWF4VHhyVyA9IDEwMjQ7IC8vIHRoZSBtYXhpbXVtIHdpZHRoIG9mIGEgdGV4dHVyZVxuXG4gIHZhciBtYXhUeHJIID0gMTAyNDsgLy8gdGhlIG1heGltdW0gaGVpZ2h0IG9mIGEgdGV4dHVyZVxuXG4gIHZhciBtaW5VdGlsaXR5ID0gMC4yOyAvLyBpZiB1c2FnZSBvZiB0ZXh0dXJlIGlzIGxlc3MgdGhhbiB0aGlzLCBpdCBpcyByZXRpcmVkXG5cbiAgdmFyIG1heEZ1bGxuZXNzID0gMC44OyAvLyBmdWxsbmVzcyBvZiB0ZXh0dXJlIGFmdGVyIHdoaWNoIHF1ZXVlIHJlbW92YWwgaXMgY2hlY2tlZFxuXG4gIHZhciBtYXhGdWxsbmVzc0NoZWNrcyA9IDEwOyAvLyBkZXF1ZXVlZCBhZnRlciB0aGlzIG1hbnkgY2hlY2tzXG5cbiAgdmFyIGRlcUNvc3QkMSA9IDAuMTU7IC8vICUgb2YgYWRkJ2wgcmVuZGVyaW5nIGNvc3QgYWxsb3dlZCBmb3IgZGVxdWV1aW5nIGVsZSBjYWNoZXMgZWFjaCBmcmFtZVxuXG4gIHZhciBkZXFBdmdDb3N0JDEgPSAwLjE7IC8vICUgb2YgYWRkJ2wgcmVuZGVyaW5nIGNvc3QgY29tcGFyZWQgdG8gYXZlcmFnZSBvdmVyYWxsIHJlZHJhdyB0aW1lXG5cbiAgdmFyIGRlcU5vRHJhd0Nvc3QkMSA9IDAuOTsgLy8gJSBvZiBhdmcgZnJhbWUgdGltZSB0aGF0IGNhbiBiZSB1c2VkIGZvciBkZXF1ZXVlaW5nIHdoZW4gbm90IGRyYXdpbmdcblxuICB2YXIgZGVxRmFzdENvc3QkMSA9IDAuOTsgLy8gJSBvZiBmcmFtZSB0aW1lIHRvIGJlIHVzZWQgd2hlbiA+NjBmcHNcblxuICB2YXIgZGVxUmVkcmF3VGhyZXNob2xkJDEgPSAxMDA7IC8vIHRpbWUgdG8gYmF0Y2ggcmVkcmF3cyB0b2dldGhlciBmcm9tIGRlcXVldWVpbmcgdG8gYWxsb3cgbW9yZSBkZXF1ZXVlaW5nIGNhbGNzIHRvIGhhcHBlbiBpbiB0aGUgbWVhbndoaWxlXG5cbiAgdmFyIG1heERlcVNpemUkMSA9IDE7IC8vIG51bWJlciBvZiBlbGVzIHRvIGRlcXVldWUgYW5kIHJlbmRlciBhdCBoaWdoZXIgdGV4dHVyZSBpbiBlYWNoIGJhdGNoXG5cbiAgdmFyIGdldFR4clJlYXNvbnMgPSB7XG4gICAgZGVxdWV1ZTogJ2RlcXVldWUnLFxuICAgIGRvd25zY2FsZTogJ2Rvd25zY2FsZScsXG4gICAgaGlnaFF1YWxpdHk6ICdoaWdoUXVhbGl0eSdcbiAgfTtcbiAgdmFyIGluaXREZWZhdWx0cyA9IGRlZmF1bHRzJGcoe1xuICAgIGdldEtleTogbnVsbCxcbiAgICBkb2VzRWxlSW52YWxpZGF0ZUtleTogZmFsc2lmeSxcbiAgICBkcmF3RWxlbWVudDogbnVsbCxcbiAgICBnZXRCb3VuZGluZ0JveDogbnVsbCxcbiAgICBnZXRSb3RhdGlvblBvaW50OiBudWxsLFxuICAgIGdldFJvdGF0aW9uT2Zmc2V0OiBudWxsLFxuICAgIGlzVmlzaWJsZTogdHJ1ZWlmeSxcbiAgICBhbGxvd0VkZ2VUeHJDYWNoaW5nOiB0cnVlLFxuICAgIGFsbG93UGFyZW50VHhyQ2FjaGluZzogdHJ1ZVxuICB9KTtcblxuICB2YXIgRWxlbWVudFRleHR1cmVDYWNoZSA9IGZ1bmN0aW9uIEVsZW1lbnRUZXh0dXJlQ2FjaGUocmVuZGVyZXIsIGluaXRPcHRpb25zKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNlbGYucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICBzZWxmLm9uRGVxdWV1ZXMgPSBbXTtcbiAgICB2YXIgb3B0cyA9IGluaXREZWZhdWx0cyhpbml0T3B0aW9ucyk7XG4gICAgZXh0ZW5kKHNlbGYsIG9wdHMpO1xuICAgIHNlbGYubG9va3VwID0gbmV3IEVsZW1lbnRUZXh0dXJlQ2FjaGVMb29rdXAob3B0cy5nZXRLZXksIG9wdHMuZG9lc0VsZUludmFsaWRhdGVLZXkpO1xuICAgIHNlbGYuc2V0dXBEZXF1ZXVlaW5nKCk7XG4gIH07XG5cbiAgdmFyIEVUQ3AgPSBFbGVtZW50VGV4dHVyZUNhY2hlLnByb3RvdHlwZTtcbiAgRVRDcC5yZWFzb25zID0gZ2V0VHhyUmVhc29uczsgLy8gdGhlIGxpc3Qgb2YgdGV4dHVyZXMgaW4gd2hpY2ggbmV3IHN1YnRleHR1cmVzIGZvciBlbGVtZW50cyBjYW4gYmUgcGxhY2VkXG5cbiAgRVRDcC5nZXRUZXh0dXJlUXVldWUgPSBmdW5jdGlvbiAodHhySCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZWxmLmVsZUltZ0NhY2hlcyA9IHNlbGYuZWxlSW1nQ2FjaGVzIHx8IHt9O1xuICAgIHJldHVybiBzZWxmLmVsZUltZ0NhY2hlc1t0eHJIXSA9IHNlbGYuZWxlSW1nQ2FjaGVzW3R4ckhdIHx8IFtdO1xuICB9OyAvLyB0aGUgbGlzdCBvZiB1c3VzZWQgdGV4dHVyZXMgd2hpY2ggY2FuIGJlIHJlY3ljbGVkIChpbiB1c2UgaW4gdGV4dHVyZSBxdWV1ZSlcblxuXG4gIEVUQ3AuZ2V0UmV0aXJlZFRleHR1cmVRdWV1ZSA9IGZ1bmN0aW9uICh0eHJIKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBydHh0clFzID0gc2VsZi5lbGVJbWdDYWNoZXMucmV0aXJlZCA9IHNlbGYuZWxlSW1nQ2FjaGVzLnJldGlyZWQgfHwge307XG4gICAgdmFyIHJ0eHRyUSA9IHJ0eHRyUXNbdHhySF0gPSBydHh0clFzW3R4ckhdIHx8IFtdO1xuICAgIHJldHVybiBydHh0clE7XG4gIH07IC8vIHF1ZXVlIG9mIGVsZW1lbnQgZHJhdyByZXF1ZXN0cyBhdCBkaWZmZXJlbnQgc2NhbGUgbGV2ZWxzXG5cblxuICBFVENwLmdldEVsZW1lbnRRdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHEgPSBzZWxmLmVsZUNhY2hlUXVldWUgPSBzZWxmLmVsZUNhY2hlUXVldWUgfHwgbmV3IGhlYXAoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBiLnJlcXMgLSBhLnJlcXM7XG4gICAgfSk7XG4gICAgcmV0dXJuIHE7XG4gIH07IC8vIHF1ZXVlIG9mIGVsZW1lbnQgZHJhdyByZXF1ZXN0cyBhdCBkaWZmZXJlbnQgc2NhbGUgbGV2ZWxzIChlbGVtZW50IGlkIGxvb2t1cClcblxuXG4gIEVUQ3AuZ2V0RWxlbWVudEtleVRvUXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBrMnEgPSBzZWxmLmVsZUtleVRvQ2FjaGVRdWV1ZSA9IHNlbGYuZWxlS2V5VG9DYWNoZVF1ZXVlIHx8IHt9O1xuICAgIHJldHVybiBrMnE7XG4gIH07XG5cbiAgRVRDcC5nZXRFbGVtZW50ID0gZnVuY3Rpb24gKGVsZSwgYmIsIHB4UmF0aW8sIGx2bCwgcmVhc29uKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciByID0gdGhpcy5yZW5kZXJlcjtcbiAgICB2YXIgem9vbSA9IHIuY3kuem9vbSgpO1xuICAgIHZhciBsb29rdXAgPSB0aGlzLmxvb2t1cDtcblxuICAgIGlmICghYmIgfHwgYmIudyA9PT0gMCB8fCBiYi5oID09PSAwIHx8IGlzTmFOKGJiLncpIHx8IGlzTmFOKGJiLmgpIHx8ICFlbGUudmlzaWJsZSgpIHx8IGVsZS5yZW1vdmVkKCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICghc2VsZi5hbGxvd0VkZ2VUeHJDYWNoaW5nICYmIGVsZS5pc0VkZ2UoKSB8fCAhc2VsZi5hbGxvd1BhcmVudFR4ckNhY2hpbmcgJiYgZWxlLmlzUGFyZW50KCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChsdmwgPT0gbnVsbCkge1xuICAgICAgbHZsID0gTWF0aC5jZWlsKGxvZzIoem9vbSAqIHB4UmF0aW8pKTtcbiAgICB9XG5cbiAgICBpZiAobHZsIDwgbWluTHZsJDEpIHtcbiAgICAgIGx2bCA9IG1pbkx2bCQxO1xuICAgIH0gZWxzZSBpZiAoem9vbSA+PSBtYXhab29tJDEgfHwgbHZsID4gbWF4THZsJDEpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBzY2FsZSA9IE1hdGgucG93KDIsIGx2bCk7XG4gICAgdmFyIGVsZVNjYWxlZEggPSBiYi5oICogc2NhbGU7XG4gICAgdmFyIGVsZVNjYWxlZFcgPSBiYi53ICogc2NhbGU7XG4gICAgdmFyIHNjYWxlZExhYmVsU2hvd24gPSByLmVsZVRleHRCaWdnZXJUaGFuTWluKGVsZSwgc2NhbGUpO1xuXG4gICAgaWYgKCF0aGlzLmlzVmlzaWJsZShlbGUsIHNjYWxlZExhYmVsU2hvd24pKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgZWxlQ2FjaGUgPSBsb29rdXAuZ2V0KGVsZSwgbHZsKTsgLy8gaWYgdGhpcyBnZXQgd2FzIG9uIGFuIHVudXNlZC9pbnZhbGlkYXRlZCBjYWNoZSwgdGhlbiByZXN0b3JlIHRoZSB0ZXh0dXJlIHVzYWdlIG1ldHJpY1xuXG4gICAgaWYgKGVsZUNhY2hlICYmIGVsZUNhY2hlLmludmFsaWRhdGVkKSB7XG4gICAgICBlbGVDYWNoZS5pbnZhbGlkYXRlZCA9IGZhbHNlO1xuICAgICAgZWxlQ2FjaGUudGV4dHVyZS5pbnZhbGlkYXRlZFdpZHRoIC09IGVsZUNhY2hlLndpZHRoO1xuICAgIH1cblxuICAgIGlmIChlbGVDYWNoZSkge1xuICAgICAgcmV0dXJuIGVsZUNhY2hlO1xuICAgIH1cblxuICAgIHZhciB0eHJIOyAvLyB3aGljaCB0ZXh0dXJlIGhlaWdodCB0aGlzIGVsZSBiZWxvbmdzIHRvXG5cbiAgICBpZiAoZWxlU2NhbGVkSCA8PSBtaW5UeHJIKSB7XG4gICAgICB0eHJIID0gbWluVHhySDtcbiAgICB9IGVsc2UgaWYgKGVsZVNjYWxlZEggPD0gdHhyU3RlcEgpIHtcbiAgICAgIHR4ckggPSB0eHJTdGVwSDtcbiAgICB9IGVsc2Uge1xuICAgICAgdHhySCA9IE1hdGguY2VpbChlbGVTY2FsZWRIIC8gdHhyU3RlcEgpICogdHhyU3RlcEg7XG4gICAgfVxuXG4gICAgaWYgKGVsZVNjYWxlZEggPiBtYXhUeHJIIHx8IGVsZVNjYWxlZFcgPiBtYXhUeHJXKSB7XG4gICAgICByZXR1cm4gbnVsbDsgLy8gY2FjaGluZyBsYXJnZSBlbGVtZW50cyBpcyBub3QgZWZmaWNpZW50XG4gICAgfVxuXG4gICAgdmFyIHR4clEgPSBzZWxmLmdldFRleHR1cmVRdWV1ZSh0eHJIKTsgLy8gZmlyc3QgdHJ5IHRoZSBzZWNvbmQgbGFzdCBvbmUgaW4gY2FzZSBpdCBoYXMgc3BhY2UgYXQgdGhlIGVuZFxuXG4gICAgdmFyIHR4ciA9IHR4clFbdHhyUS5sZW5ndGggLSAyXTtcblxuICAgIHZhciBhZGROZXdUeHIgPSBmdW5jdGlvbiBhZGROZXdUeHIoKSB7XG4gICAgICByZXR1cm4gc2VsZi5yZWN5Y2xlVGV4dHVyZSh0eHJILCBlbGVTY2FsZWRXKSB8fCBzZWxmLmFkZFRleHR1cmUodHhySCwgZWxlU2NhbGVkVyk7XG4gICAgfTsgLy8gdHJ5IHRoZSBsYXN0IG9uZSBpZiB0aGVyZSBpcyBubyBzZWNvbmQgbGFzdCBvbmVcblxuXG4gICAgaWYgKCF0eHIpIHtcbiAgICAgIHR4ciA9IHR4clFbdHhyUS5sZW5ndGggLSAxXTtcbiAgICB9IC8vIGlmIHRoZSBsYXN0IG9uZSBkb2Vzbid0IGV4aXN0LCB3ZSBuZWVkIGEgZmlyc3Qgb25lXG5cblxuICAgIGlmICghdHhyKSB7XG4gICAgICB0eHIgPSBhZGROZXdUeHIoKTtcbiAgICB9IC8vIGlmIHRoZXJlJ3Mgbm8gcm9vbSBpbiB0aGUgY3VycmVudCB0ZXh0dXJlLCB3ZSBuZWVkIGEgbmV3IG9uZVxuXG5cbiAgICBpZiAodHhyLndpZHRoIC0gdHhyLnVzZWRXaWR0aCA8IGVsZVNjYWxlZFcpIHtcbiAgICAgIHR4ciA9IGFkZE5ld1R4cigpO1xuICAgIH1cblxuICAgIHZhciBzY2FsYWJsZUZyb20gPSBmdW5jdGlvbiBzY2FsYWJsZUZyb20ob3RoZXJDYWNoZSkge1xuICAgICAgcmV0dXJuIG90aGVyQ2FjaGUgJiYgb3RoZXJDYWNoZS5zY2FsZWRMYWJlbFNob3duID09PSBzY2FsZWRMYWJlbFNob3duO1xuICAgIH07XG5cbiAgICB2YXIgZGVxaW5nID0gcmVhc29uICYmIHJlYXNvbiA9PT0gZ2V0VHhyUmVhc29ucy5kZXF1ZXVlO1xuICAgIHZhciBoaWdoUXVhbGl0eVJlcSA9IHJlYXNvbiAmJiByZWFzb24gPT09IGdldFR4clJlYXNvbnMuaGlnaFF1YWxpdHk7XG4gICAgdmFyIGRvd25zY2FsZVJlcSA9IHJlYXNvbiAmJiByZWFzb24gPT09IGdldFR4clJlYXNvbnMuZG93bnNjYWxlO1xuICAgIHZhciBoaWdoZXJDYWNoZTsgLy8gdGhlIG5lYXJlc3QgY2FjaGUgd2l0aCBhIGhpZ2hlciBsZXZlbFxuXG4gICAgZm9yICh2YXIgbCA9IGx2bCArIDE7IGwgPD0gbWF4THZsJDE7IGwrKykge1xuICAgICAgdmFyIGMgPSBsb29rdXAuZ2V0KGVsZSwgbCk7XG5cbiAgICAgIGlmIChjKSB7XG4gICAgICAgIGhpZ2hlckNhY2hlID0gYztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG9uZVVwQ2FjaGUgPSBoaWdoZXJDYWNoZSAmJiBoaWdoZXJDYWNoZS5sZXZlbCA9PT0gbHZsICsgMSA/IGhpZ2hlckNhY2hlIDogbnVsbDtcblxuICAgIHZhciBkb3duc2NhbGUgPSBmdW5jdGlvbiBkb3duc2NhbGUoKSB7XG4gICAgICB0eHIuY29udGV4dC5kcmF3SW1hZ2Uob25lVXBDYWNoZS50ZXh0dXJlLmNhbnZhcywgb25lVXBDYWNoZS54LCAwLCBvbmVVcENhY2hlLndpZHRoLCBvbmVVcENhY2hlLmhlaWdodCwgdHhyLnVzZWRXaWR0aCwgMCwgZWxlU2NhbGVkVywgZWxlU2NhbGVkSCk7XG4gICAgfTsgLy8gcmVzZXQgZWxlIGFyZWEgaW4gdGV4dHVyZVxuXG5cbiAgICB0eHIuY29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgdHhyLmNvbnRleHQuY2xlYXJSZWN0KHR4ci51c2VkV2lkdGgsIDAsIGVsZVNjYWxlZFcsIHR4ckgpO1xuXG4gICAgaWYgKHNjYWxhYmxlRnJvbShvbmVVcENhY2hlKSkge1xuICAgICAgLy8gdGhlbiB3ZSBjYW4gcmVsYXRpdmVseSBjaGVhcGx5IHJlc2NhbGUgdGhlIGV4aXN0aW5nIGltYWdlIHcvbyByZXJlbmRlcmluZ1xuICAgICAgZG93bnNjYWxlKCk7XG4gICAgfSBlbHNlIGlmIChzY2FsYWJsZUZyb20oaGlnaGVyQ2FjaGUpKSB7XG4gICAgICAvLyB0aGVuIHVzZSB0aGUgaGlnaGVyIGNhY2hlIGZvciBub3cgYW5kIHF1ZXVlIHRoZSBuZXh0IGxldmVsIGRvd25cbiAgICAgIC8vIHRvIGNoZWFwbHkgc2NhbGUgdG93YXJkcyB0aGUgc21hbGxlciBsZXZlbFxuICAgICAgaWYgKGhpZ2hRdWFsaXR5UmVxKSB7XG4gICAgICAgIGZvciAodmFyIF9sID0gaGlnaGVyQ2FjaGUubGV2ZWw7IF9sID4gbHZsOyBfbC0tKSB7XG4gICAgICAgICAgb25lVXBDYWNoZSA9IHNlbGYuZ2V0RWxlbWVudChlbGUsIGJiLCBweFJhdGlvLCBfbCwgZ2V0VHhyUmVhc29ucy5kb3duc2NhbGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZG93bnNjYWxlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLnF1ZXVlRWxlbWVudChlbGUsIGhpZ2hlckNhY2hlLmxldmVsIC0gMSk7XG4gICAgICAgIHJldHVybiBoaWdoZXJDYWNoZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGxvd2VyQ2FjaGU7IC8vIHRoZSBuZWFyZXN0IGNhY2hlIHdpdGggYSBsb3dlciBsZXZlbFxuXG4gICAgICBpZiAoIWRlcWluZyAmJiAhaGlnaFF1YWxpdHlSZXEgJiYgIWRvd25zY2FsZVJlcSkge1xuICAgICAgICBmb3IgKHZhciBfbDIgPSBsdmwgLSAxOyBfbDIgPj0gbWluTHZsJDE7IF9sMi0tKSB7XG4gICAgICAgICAgdmFyIF9jID0gbG9va3VwLmdldChlbGUsIF9sMik7XG5cbiAgICAgICAgICBpZiAoX2MpIHtcbiAgICAgICAgICAgIGxvd2VyQ2FjaGUgPSBfYztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc2NhbGFibGVGcm9tKGxvd2VyQ2FjaGUpKSB7XG4gICAgICAgIC8vIHRoZW4gdXNlIHRoZSBsb3dlciBxdWFsaXR5IGNhY2hlIGZvciBub3cgYW5kIHF1ZXVlIHRoZSBiZXR0ZXIgb25lIGZvciBsYXRlclxuICAgICAgICBzZWxmLnF1ZXVlRWxlbWVudChlbGUsIGx2bCk7XG4gICAgICAgIHJldHVybiBsb3dlckNhY2hlO1xuICAgICAgfVxuXG4gICAgICB0eHIuY29udGV4dC50cmFuc2xhdGUodHhyLnVzZWRXaWR0aCwgMCk7XG4gICAgICB0eHIuY29udGV4dC5zY2FsZShzY2FsZSwgc2NhbGUpO1xuICAgICAgdGhpcy5kcmF3RWxlbWVudCh0eHIuY29udGV4dCwgZWxlLCBiYiwgc2NhbGVkTGFiZWxTaG93biwgZmFsc2UpO1xuICAgICAgdHhyLmNvbnRleHQuc2NhbGUoMSAvIHNjYWxlLCAxIC8gc2NhbGUpO1xuICAgICAgdHhyLmNvbnRleHQudHJhbnNsYXRlKC10eHIudXNlZFdpZHRoLCAwKTtcbiAgICB9XG5cbiAgICBlbGVDYWNoZSA9IHtcbiAgICAgIHg6IHR4ci51c2VkV2lkdGgsXG4gICAgICB0ZXh0dXJlOiB0eHIsXG4gICAgICBsZXZlbDogbHZsLFxuICAgICAgc2NhbGU6IHNjYWxlLFxuICAgICAgd2lkdGg6IGVsZVNjYWxlZFcsXG4gICAgICBoZWlnaHQ6IGVsZVNjYWxlZEgsXG4gICAgICBzY2FsZWRMYWJlbFNob3duOiBzY2FsZWRMYWJlbFNob3duXG4gICAgfTtcbiAgICB0eHIudXNlZFdpZHRoICs9IE1hdGguY2VpbChlbGVTY2FsZWRXICsgZWxlVHhyU3BhY2luZyk7XG4gICAgdHhyLmVsZUNhY2hlcy5wdXNoKGVsZUNhY2hlKTtcbiAgICBsb29rdXAuc2V0KGVsZSwgbHZsLCBlbGVDYWNoZSk7XG4gICAgc2VsZi5jaGVja1RleHR1cmVGdWxsbmVzcyh0eHIpO1xuICAgIHJldHVybiBlbGVDYWNoZTtcbiAgfTtcblxuICBFVENwLmludmFsaWRhdGVFbGVtZW50cyA9IGZ1bmN0aW9uIChlbGVzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLmludmFsaWRhdGVFbGVtZW50KGVsZXNbaV0pO1xuICAgIH1cbiAgfTtcblxuICBFVENwLmludmFsaWRhdGVFbGVtZW50ID0gZnVuY3Rpb24gKGVsZSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgbG9va3VwID0gc2VsZi5sb29rdXA7XG4gICAgdmFyIGNhY2hlcyA9IFtdO1xuICAgIHZhciBpbnZhbGlkID0gbG9va3VwLmlzSW52YWxpZChlbGUpO1xuXG4gICAgaWYgKCFpbnZhbGlkKSB7XG4gICAgICByZXR1cm47IC8vIG92ZXJyaWRlIHRoZSBpbnZhbGlkYXRpb24gcmVxdWVzdCBpZiB0aGUgZWxlbWVudCBrZXkgaGFzIG5vdCBjaGFuZ2VkXG4gICAgfVxuXG4gICAgZm9yICh2YXIgbHZsID0gbWluTHZsJDE7IGx2bCA8PSBtYXhMdmwkMTsgbHZsKyspIHtcbiAgICAgIHZhciBjYWNoZSA9IGxvb2t1cC5nZXRGb3JDYWNoZWRLZXkoZWxlLCBsdmwpO1xuXG4gICAgICBpZiAoY2FjaGUpIHtcbiAgICAgICAgY2FjaGVzLnB1c2goY2FjaGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBub090aGVyRWxlc1VzZUNhY2hlID0gbG9va3VwLmludmFsaWRhdGUoZWxlKTtcblxuICAgIGlmIChub090aGVyRWxlc1VzZUNhY2hlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhY2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgX2NhY2hlID0gY2FjaGVzW2ldO1xuICAgICAgICB2YXIgdHhyID0gX2NhY2hlLnRleHR1cmU7IC8vIHJlbW92ZSBzcGFjZSBmcm9tIHRoZSB0ZXh0dXJlIGl0IGJlbG9uZ3MgdG9cblxuICAgICAgICB0eHIuaW52YWxpZGF0ZWRXaWR0aCArPSBfY2FjaGUud2lkdGg7IC8vIG1hcmsgdGhlIGNhY2hlIGFzIGludmFsaWRhdGVkXG5cbiAgICAgICAgX2NhY2hlLmludmFsaWRhdGVkID0gdHJ1ZTsgLy8gcmV0aXJlIHRoZSB0ZXh0dXJlIGlmIGl0cyB1dGlsaXR5IGlzIGxvd1xuXG4gICAgICAgIHNlbGYuY2hlY2tUZXh0dXJlVXRpbGl0eSh0eHIpO1xuICAgICAgfVxuICAgIH0gLy8gcmVtb3ZlIGZyb20gcXVldWUgc2luY2UgdGhlIG9sZCByZXEgd2FzIGZvciB0aGUgb2xkIHN0YXRlXG5cblxuICAgIHNlbGYucmVtb3ZlRnJvbVF1ZXVlKGVsZSk7XG4gIH07XG5cbiAgRVRDcC5jaGVja1RleHR1cmVVdGlsaXR5ID0gZnVuY3Rpb24gKHR4cikge1xuICAgIC8vIGludmFsaWRhdGUgYWxsIGVudHJpZXMgaW4gdGhlIGNhY2hlIGlmIHRoZSBjYWNoZSBzaXplIGlzIHNtYWxsXG4gICAgaWYgKHR4ci5pbnZhbGlkYXRlZFdpZHRoID49IG1pblV0aWxpdHkgKiB0eHIud2lkdGgpIHtcbiAgICAgIHRoaXMucmV0aXJlVGV4dHVyZSh0eHIpO1xuICAgIH1cbiAgfTtcblxuICBFVENwLmNoZWNrVGV4dHVyZUZ1bGxuZXNzID0gZnVuY3Rpb24gKHR4cikge1xuICAgIC8vIGlmIHRleHR1cmUgaGFzIGJlZW4gbW9zdGx5IGZpbGxlZCBhbmQgcGFzc2VkIG92ZXIgc2V2ZXJhbCB0aW1lcywgcmVtb3ZlXG4gICAgLy8gaXQgZnJvbSB0aGUgcXVldWUgc28gd2UgZG9uJ3QgbmVlZCB0byB3YXN0ZSB0aW1lIGxvb2tpbmcgYXQgaXQgdG8gcHV0IG5ldyB0aGluZ3NcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHR4clEgPSBzZWxmLmdldFRleHR1cmVRdWV1ZSh0eHIuaGVpZ2h0KTtcblxuICAgIGlmICh0eHIudXNlZFdpZHRoIC8gdHhyLndpZHRoID4gbWF4RnVsbG5lc3MgJiYgdHhyLmZ1bGxuZXNzQ2hlY2tzID49IG1heEZ1bGxuZXNzQ2hlY2tzKSB7XG4gICAgICByZW1vdmVGcm9tQXJyYXkodHhyUSwgdHhyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHhyLmZ1bGxuZXNzQ2hlY2tzKys7XG4gICAgfVxuICB9O1xuXG4gIEVUQ3AucmV0aXJlVGV4dHVyZSA9IGZ1bmN0aW9uICh0eHIpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHR4ckggPSB0eHIuaGVpZ2h0O1xuICAgIHZhciB0eHJRID0gc2VsZi5nZXRUZXh0dXJlUXVldWUodHhySCk7XG4gICAgdmFyIGxvb2t1cCA9IHRoaXMubG9va3VwOyAvLyByZXRpcmUgdGhlIHRleHR1cmUgZnJvbSB0aGUgYWN0aXZlIC8gc2VhcmNoYWJsZSBxdWV1ZTpcblxuICAgIHJlbW92ZUZyb21BcnJheSh0eHJRLCB0eHIpO1xuICAgIHR4ci5yZXRpcmVkID0gdHJ1ZTsgLy8gcmVtb3ZlIHRoZSByZWZzIGZyb20gdGhlIGVsZXMgdG8gdGhlIGNhY2hlczpcblxuICAgIHZhciBlbGVDYWNoZXMgPSB0eHIuZWxlQ2FjaGVzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVDYWNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGVDYWNoZSA9IGVsZUNhY2hlc1tpXTtcbiAgICAgIGxvb2t1cC5kZWxldGVDYWNoZShlbGVDYWNoZS5rZXksIGVsZUNhY2hlLmxldmVsKTtcbiAgICB9XG5cbiAgICBjbGVhckFycmF5KGVsZUNhY2hlcyk7IC8vIGFkZCB0aGUgdGV4dHVyZSB0byBhIHJldGlyZWQgcXVldWUgc28gaXQgY2FuIGJlIHJlY3ljbGVkIGluIGZ1dHVyZTpcblxuICAgIHZhciBydHh0clEgPSBzZWxmLmdldFJldGlyZWRUZXh0dXJlUXVldWUodHhySCk7XG4gICAgcnR4dHJRLnB1c2godHhyKTtcbiAgfTtcblxuICBFVENwLmFkZFRleHR1cmUgPSBmdW5jdGlvbiAodHhySCwgbWluVykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgdHhyUSA9IHNlbGYuZ2V0VGV4dHVyZVF1ZXVlKHR4ckgpO1xuICAgIHZhciB0eHIgPSB7fTtcbiAgICB0eHJRLnB1c2godHhyKTtcbiAgICB0eHIuZWxlQ2FjaGVzID0gW107XG4gICAgdHhyLmhlaWdodCA9IHR4ckg7XG4gICAgdHhyLndpZHRoID0gTWF0aC5tYXgoZGVmVHhyV2lkdGgsIG1pblcpO1xuICAgIHR4ci51c2VkV2lkdGggPSAwO1xuICAgIHR4ci5pbnZhbGlkYXRlZFdpZHRoID0gMDtcbiAgICB0eHIuZnVsbG5lc3NDaGVja3MgPSAwO1xuICAgIHR4ci5jYW52YXMgPSBzZWxmLnJlbmRlcmVyLm1ha2VPZmZzY3JlZW5DYW52YXModHhyLndpZHRoLCB0eHIuaGVpZ2h0KTtcbiAgICB0eHIuY29udGV4dCA9IHR4ci5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICByZXR1cm4gdHhyO1xuICB9O1xuXG4gIEVUQ3AucmVjeWNsZVRleHR1cmUgPSBmdW5jdGlvbiAodHhySCwgbWluVykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgdHhyUSA9IHNlbGYuZ2V0VGV4dHVyZVF1ZXVlKHR4ckgpO1xuICAgIHZhciBydHh0clEgPSBzZWxmLmdldFJldGlyZWRUZXh0dXJlUXVldWUodHhySCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJ0eHRyUS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHR4ciA9IHJ0eHRyUVtpXTtcblxuICAgICAgaWYgKHR4ci53aWR0aCA+PSBtaW5XKSB7XG4gICAgICAgIHR4ci5yZXRpcmVkID0gZmFsc2U7XG4gICAgICAgIHR4ci51c2VkV2lkdGggPSAwO1xuICAgICAgICB0eHIuaW52YWxpZGF0ZWRXaWR0aCA9IDA7XG4gICAgICAgIHR4ci5mdWxsbmVzc0NoZWNrcyA9IDA7XG4gICAgICAgIGNsZWFyQXJyYXkodHhyLmVsZUNhY2hlcyk7XG4gICAgICAgIHR4ci5jb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgICAgdHhyLmNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHR4ci53aWR0aCwgdHhyLmhlaWdodCk7XG4gICAgICAgIHJlbW92ZUZyb21BcnJheShydHh0clEsIHR4cik7XG4gICAgICAgIHR4clEucHVzaCh0eHIpO1xuICAgICAgICByZXR1cm4gdHhyO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBFVENwLnF1ZXVlRWxlbWVudCA9IGZ1bmN0aW9uIChlbGUsIGx2bCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgcSA9IHNlbGYuZ2V0RWxlbWVudFF1ZXVlKCk7XG4gICAgdmFyIGsycSA9IHNlbGYuZ2V0RWxlbWVudEtleVRvUXVldWUoKTtcbiAgICB2YXIga2V5ID0gdGhpcy5nZXRLZXkoZWxlKTtcbiAgICB2YXIgZXhpc3RpbmdSZXEgPSBrMnFba2V5XTtcblxuICAgIGlmIChleGlzdGluZ1JlcSkge1xuICAgICAgLy8gdXNlIHRoZSBtYXggbHZsIGIvYyBpbiBiZXR3ZWVuIGx2bHMgYXJlIGNoZWFwIHRvIG1ha2VcbiAgICAgIGV4aXN0aW5nUmVxLmxldmVsID0gTWF0aC5tYXgoZXhpc3RpbmdSZXEubGV2ZWwsIGx2bCk7XG4gICAgICBleGlzdGluZ1JlcS5lbGVzLm1lcmdlKGVsZSk7XG4gICAgICBleGlzdGluZ1JlcS5yZXFzKys7XG4gICAgICBxLnVwZGF0ZUl0ZW0oZXhpc3RpbmdSZXEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcmVxID0ge1xuICAgICAgICBlbGVzOiBlbGUuc3Bhd24oKS5tZXJnZShlbGUpLFxuICAgICAgICBsZXZlbDogbHZsLFxuICAgICAgICByZXFzOiAxLFxuICAgICAgICBrZXk6IGtleVxuICAgICAgfTtcbiAgICAgIHEucHVzaChyZXEpO1xuICAgICAgazJxW2tleV0gPSByZXE7XG4gICAgfVxuICB9O1xuXG4gIEVUQ3AuZGVxdWV1ZSA9IGZ1bmN0aW9uIChweFJhdGlvXG4gIC8qLCBleHRlbnQqL1xuICApIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHEgPSBzZWxmLmdldEVsZW1lbnRRdWV1ZSgpO1xuICAgIHZhciBrMnEgPSBzZWxmLmdldEVsZW1lbnRLZXlUb1F1ZXVlKCk7XG4gICAgdmFyIGRlcXVldWVkID0gW107XG4gICAgdmFyIGxvb2t1cCA9IHNlbGYubG9va3VwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXhEZXFTaXplJDE7IGkrKykge1xuICAgICAgaWYgKHEuc2l6ZSgpID4gMCkge1xuICAgICAgICB2YXIgcmVxID0gcS5wb3AoKTtcbiAgICAgICAgdmFyIGtleSA9IHJlcS5rZXk7XG4gICAgICAgIHZhciBlbGUgPSByZXEuZWxlc1swXTsgLy8gYWxsIGVsZXMgaGF2ZSB0aGUgc2FtZSBrZXlcblxuICAgICAgICB2YXIgY2FjaGVFeGlzdHMgPSBsb29rdXAuaGFzQ2FjaGUoZWxlLCByZXEubGV2ZWwpOyAvLyBjbGVhciBvdXQgdGhlIGtleSB0byByZXEgbG9va3VwXG5cbiAgICAgICAgazJxW2tleV0gPSBudWxsOyAvLyBkZXF1ZXVlaW5nIGlzbid0IG5lY2Vzc2FyeSB3aXRoIGFuIGV4aXN0aW5nIGNhY2hlXG5cbiAgICAgICAgaWYgKGNhY2hlRXhpc3RzKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBkZXF1ZXVlZC5wdXNoKHJlcSk7XG4gICAgICAgIHZhciBiYiA9IHNlbGYuZ2V0Qm91bmRpbmdCb3goZWxlKTtcbiAgICAgICAgc2VsZi5nZXRFbGVtZW50KGVsZSwgYmIsIHB4UmF0aW8sIHJlcS5sZXZlbCwgZ2V0VHhyUmVhc29ucy5kZXF1ZXVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkZXF1ZXVlZDtcbiAgfTtcblxuICBFVENwLnJlbW92ZUZyb21RdWV1ZSA9IGZ1bmN0aW9uIChlbGUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHEgPSBzZWxmLmdldEVsZW1lbnRRdWV1ZSgpO1xuICAgIHZhciBrMnEgPSBzZWxmLmdldEVsZW1lbnRLZXlUb1F1ZXVlKCk7XG4gICAgdmFyIGtleSA9IHRoaXMuZ2V0S2V5KGVsZSk7XG4gICAgdmFyIHJlcSA9IGsycVtrZXldO1xuXG4gICAgaWYgKHJlcSAhPSBudWxsKSB7XG4gICAgICBpZiAocmVxLmVsZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIC8vIHJlbW92ZSBpZiBsYXN0IGVsZSBpbiB0aGUgcmVxXG4gICAgICAgIC8vIGJyaW5nIHRvIGZyb250IG9mIHF1ZXVlXG4gICAgICAgIHJlcS5yZXFzID0gTUFYX0lOVCQxO1xuICAgICAgICBxLnVwZGF0ZUl0ZW0ocmVxKTtcbiAgICAgICAgcS5wb3AoKTsgLy8gcmVtb3ZlIGZyb20gcXVldWVcblxuICAgICAgICBrMnFba2V5XSA9IG51bGw7IC8vIHJlbW92ZSBmcm9tIGxvb2t1cCBtYXBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG90aGVyd2lzZSBqdXN0IHJlbW92ZSBlbGUgZnJvbSByZXFcbiAgICAgICAgcmVxLmVsZXMudW5tZXJnZShlbGUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBFVENwLm9uRGVxdWV1ZSA9IGZ1bmN0aW9uIChmbikge1xuICAgIHRoaXMub25EZXF1ZXVlcy5wdXNoKGZuKTtcbiAgfTtcblxuICBFVENwLm9mZkRlcXVldWUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICByZW1vdmVGcm9tQXJyYXkodGhpcy5vbkRlcXVldWVzLCBmbik7XG4gIH07XG5cbiAgRVRDcC5zZXR1cERlcXVldWVpbmcgPSBkZWZzLnNldHVwRGVxdWV1ZWluZyh7XG4gICAgZGVxUmVkcmF3VGhyZXNob2xkOiBkZXFSZWRyYXdUaHJlc2hvbGQkMSxcbiAgICBkZXFDb3N0OiBkZXFDb3N0JDEsXG4gICAgZGVxQXZnQ29zdDogZGVxQXZnQ29zdCQxLFxuICAgIGRlcU5vRHJhd0Nvc3Q6IGRlcU5vRHJhd0Nvc3QkMSxcbiAgICBkZXFGYXN0Q29zdDogZGVxRmFzdENvc3QkMSxcbiAgICBkZXE6IGZ1bmN0aW9uIGRlcShzZWxmLCBweFJhdGlvLCBleHRlbnQpIHtcbiAgICAgIHJldHVybiBzZWxmLmRlcXVldWUocHhSYXRpbywgZXh0ZW50KTtcbiAgICB9LFxuICAgIG9uRGVxZDogZnVuY3Rpb24gb25EZXFkKHNlbGYsIGRlcWQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5vbkRlcXVldWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBmbiA9IHNlbGYub25EZXF1ZXVlc1tpXTtcbiAgICAgICAgZm4oZGVxZCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBzaG91bGRSZWRyYXc6IGZ1bmN0aW9uIHNob3VsZFJlZHJhdyhzZWxmLCBkZXFkLCBweFJhdGlvLCBleHRlbnQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVxZC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlcyA9IGRlcWRbaV0uZWxlcztcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGVsZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB2YXIgYmIgPSBlbGVzW2pdLmJvdW5kaW5nQm94KCk7XG5cbiAgICAgICAgICBpZiAoYm91bmRpbmdCb3hlc0ludGVyc2VjdChiYiwgZXh0ZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIHByaW9yaXR5OiBmdW5jdGlvbiBwcmlvcml0eShzZWxmKSB7XG4gICAgICByZXR1cm4gc2VsZi5yZW5kZXJlci5iZWZvcmVSZW5kZXJQcmlvcml0aWVzLmVsZVR4ckRlcTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBkZWZOdW1MYXllcnMgPSAxOyAvLyBkZWZhdWx0IG51bWJlciBvZiBsYXllcnMgdG8gdXNlXG5cbiAgdmFyIG1pbkx2bCA9IC00OyAvLyB3aGVuIHNjYWxpbmcgc21hbGxlciB0aGFuIHRoYXQgd2UgZG9uJ3QgbmVlZCB0byByZS1yZW5kZXJcblxuICB2YXIgbWF4THZsID0gMjsgLy8gd2hlbiBsYXJnZXIgdGhhbiB0aGlzIHNjYWxlIGp1c3QgcmVuZGVyIGRpcmVjdGx5IChjYWNoaW5nIGlzIG5vdCBoZWxwZnVsKVxuXG4gIHZhciBtYXhab29tID0gMy45OTsgLy8gYmV5b25kIHRoaXMgem9vbSBsZXZlbCwgbGF5ZXJlZCB0ZXh0dXJlcyBhcmUgbm90IHVzZWRcblxuICB2YXIgZGVxUmVkcmF3VGhyZXNob2xkID0gNTA7IC8vIHRpbWUgdG8gYmF0Y2ggcmVkcmF3cyB0b2dldGhlciBmcm9tIGRlcXVldWVpbmcgdG8gYWxsb3cgbW9yZSBkZXF1ZXVlaW5nIGNhbGNzIHRvIGhhcHBlbiBpbiB0aGUgbWVhbndoaWxlXG5cbiAgdmFyIHJlZmluZUVsZURlYm91bmNlVGltZSA9IDUwOyAvLyB0aW1lIHRvIGRlYm91bmNlIHNoYXJwZXIgZWxlIHRleHR1cmUgdXBkYXRlc1xuXG4gIHZhciBkZXFDb3N0ID0gMC4xNTsgLy8gJSBvZiBhZGQnbCByZW5kZXJpbmcgY29zdCBhbGxvd2VkIGZvciBkZXF1ZXVpbmcgZWxlIGNhY2hlcyBlYWNoIGZyYW1lXG5cbiAgdmFyIGRlcUF2Z0Nvc3QgPSAwLjE7IC8vICUgb2YgYWRkJ2wgcmVuZGVyaW5nIGNvc3QgY29tcGFyZWQgdG8gYXZlcmFnZSBvdmVyYWxsIHJlZHJhdyB0aW1lXG5cbiAgdmFyIGRlcU5vRHJhd0Nvc3QgPSAwLjk7IC8vICUgb2YgYXZnIGZyYW1lIHRpbWUgdGhhdCBjYW4gYmUgdXNlZCBmb3IgZGVxdWV1ZWluZyB3aGVuIG5vdCBkcmF3aW5nXG5cbiAgdmFyIGRlcUZhc3RDb3N0ID0gMC45OyAvLyAlIG9mIGZyYW1lIHRpbWUgdG8gYmUgdXNlZCB3aGVuID42MGZwc1xuXG4gIHZhciBtYXhEZXFTaXplID0gMTsgLy8gbnVtYmVyIG9mIGVsZXMgdG8gZGVxdWV1ZSBhbmQgcmVuZGVyIGF0IGhpZ2hlciB0ZXh0dXJlIGluIGVhY2ggYmF0Y2hcblxuICB2YXIgaW52YWxpZFRocmVzaG9sZCA9IDI1MDsgLy8gdGltZSB0aHJlc2hvbGQgZm9yIGRpc2FibGluZyBiL2Mgb2YgaW52YWxpZGF0aW9uc1xuXG4gIHZhciBtYXhMYXllckFyZWEgPSA0MDAwICogNDAwMDsgLy8gbGF5ZXJzIGNhbid0IGJlIGJpZ2dlciB0aGFuIHRoaXNcblxuICB2YXIgdXNlSGlnaFF1YWxpdHlFbGVUeHJSZXFzID0gdHJ1ZTsgLy8gd2hldGhlciB0byB1c2UgaGlnaCBxdWFsaXR5IGVsZSB0eHIgcmVxdWVzdHMgKGdlbmVyYWxseSBmYXN0ZXIgYW5kIGNoZWFwZXIgaW4gdGhlIGxvbmd0ZXJtKVxuICAvLyB2YXIgbG9nID0gZnVuY3Rpb24oKXsgY29uc29sZS5sb2cuYXBwbHkoIGNvbnNvbGUsIGFyZ3VtZW50cyApOyB9O1xuXG4gIHZhciBMYXllcmVkVGV4dHVyZUNhY2hlID0gZnVuY3Rpb24gTGF5ZXJlZFRleHR1cmVDYWNoZShyZW5kZXJlcikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgciA9IHNlbGYucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICB2YXIgY3kgPSByLmN5O1xuICAgIHNlbGYubGF5ZXJzQnlMZXZlbCA9IHt9OyAvLyBlLmcuIDIgPT4gWyBsYXllcjEsIGxheWVyMiwgLi4uLCBsYXllck4gXVxuXG4gICAgc2VsZi5maXJzdEdldCA9IHRydWU7XG4gICAgc2VsZi5sYXN0SW52YWxpZGF0aW9uVGltZSA9IHBlcmZvcm1hbmNlTm93KCkgLSAyICogaW52YWxpZFRocmVzaG9sZDtcbiAgICBzZWxmLnNraXBwaW5nID0gZmFsc2U7XG4gICAgc2VsZi5lbGVUeHJEZXFzID0gY3kuY29sbGVjdGlvbigpO1xuICAgIHNlbGYuc2NoZWR1bGVFbGVtZW50UmVmaW5lbWVudCA9IGRlYm91bmNlXzEoZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5yZWZpbmVFbGVtZW50VGV4dHVyZXMoc2VsZi5lbGVUeHJEZXFzKTtcbiAgICAgIHNlbGYuZWxlVHhyRGVxcy51bm1lcmdlKHNlbGYuZWxlVHhyRGVxcyk7XG4gICAgfSwgcmVmaW5lRWxlRGVib3VuY2VUaW1lKTtcbiAgICByLmJlZm9yZVJlbmRlcihmdW5jdGlvbiAod2lsbERyYXcsIG5vdykge1xuICAgICAgaWYgKG5vdyAtIHNlbGYubGFzdEludmFsaWRhdGlvblRpbWUgPD0gaW52YWxpZFRocmVzaG9sZCkge1xuICAgICAgICBzZWxmLnNraXBwaW5nID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuc2tpcHBpbmcgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9LCByLmJlZm9yZVJlbmRlclByaW9yaXRpZXMubHlyVHhyU2tpcCk7XG5cbiAgICB2YXIgcVNvcnQgPSBmdW5jdGlvbiBxU29ydChhLCBiKSB7XG4gICAgICByZXR1cm4gYi5yZXFzIC0gYS5yZXFzO1xuICAgIH07XG5cbiAgICBzZWxmLmxheWVyc1F1ZXVlID0gbmV3IGhlYXAocVNvcnQpO1xuICAgIHNlbGYuc2V0dXBEZXF1ZXVlaW5nKCk7XG4gIH07XG5cbiAgdmFyIExUQ3AgPSBMYXllcmVkVGV4dHVyZUNhY2hlLnByb3RvdHlwZTtcbiAgdmFyIGxheWVySWRQb29sID0gMDtcbiAgdmFyIE1BWF9JTlQgPSBNYXRoLnBvdygyLCA1MykgLSAxO1xuXG4gIExUQ3AubWFrZUxheWVyID0gZnVuY3Rpb24gKGJiLCBsdmwpIHtcbiAgICB2YXIgc2NhbGUgPSBNYXRoLnBvdygyLCBsdmwpO1xuICAgIHZhciB3ID0gTWF0aC5jZWlsKGJiLncgKiBzY2FsZSk7XG4gICAgdmFyIGggPSBNYXRoLmNlaWwoYmIuaCAqIHNjYWxlKTtcbiAgICB2YXIgY2FudmFzID0gdGhpcy5yZW5kZXJlci5tYWtlT2Zmc2NyZWVuQ2FudmFzKHcsIGgpO1xuICAgIHZhciBsYXllciA9IHtcbiAgICAgIGlkOiBsYXllcklkUG9vbCA9ICsrbGF5ZXJJZFBvb2wgJSBNQVhfSU5ULFxuICAgICAgYmI6IGJiLFxuICAgICAgbGV2ZWw6IGx2bCxcbiAgICAgIHdpZHRoOiB3LFxuICAgICAgaGVpZ2h0OiBoLFxuICAgICAgY2FudmFzOiBjYW52YXMsXG4gICAgICBjb250ZXh0OiBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKSxcbiAgICAgIGVsZXM6IFtdLFxuICAgICAgZWxlc1F1ZXVlOiBbXSxcbiAgICAgIHJlcXM6IDBcbiAgICB9OyAvLyBsb2coJ21ha2UgbGF5ZXIgJXMgd2l0aCB3ICVzIGFuZCBoICVzIGFuZCBsdmwgJXMnLCBsYXllci5pZCwgbGF5ZXIud2lkdGgsIGxheWVyLmhlaWdodCwgbGF5ZXIubGV2ZWwpO1xuXG4gICAgdmFyIGN4dCA9IGxheWVyLmNvbnRleHQ7XG4gICAgdmFyIGR4ID0gLWxheWVyLmJiLngxO1xuICAgIHZhciBkeSA9IC1sYXllci5iYi55MTsgLy8gZG8gdGhlIHRyYW5zZm9ybSBvbiBjcmVhdGlvbiB0byBzYXZlIGN5Y2xlcyAoaXQncyB0aGUgc2FtZSBmb3IgYWxsIGVsZXMpXG5cbiAgICBjeHQuc2NhbGUoc2NhbGUsIHNjYWxlKTtcbiAgICBjeHQudHJhbnNsYXRlKGR4LCBkeSk7XG4gICAgcmV0dXJuIGxheWVyO1xuICB9O1xuXG4gIExUQ3AuZ2V0TGF5ZXJzID0gZnVuY3Rpb24gKGVsZXMsIHB4UmF0aW8sIGx2bCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgciA9IHNlbGYucmVuZGVyZXI7XG4gICAgdmFyIGN5ID0gci5jeTtcbiAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcbiAgICB2YXIgZmlyc3RHZXQgPSBzZWxmLmZpcnN0R2V0O1xuICAgIHNlbGYuZmlyc3RHZXQgPSBmYWxzZTsgLy8gbG9nKCctLVxcbmdldCBsYXllcnMgd2l0aCAlcyBlbGVzJywgZWxlcy5sZW5ndGgpO1xuICAgIC8vbG9nIGVsZXMubWFwKGZ1bmN0aW9uKGVsZSl7IHJldHVybiBlbGUuaWQoKSB9KSApO1xuXG4gICAgaWYgKGx2bCA9PSBudWxsKSB7XG4gICAgICBsdmwgPSBNYXRoLmNlaWwobG9nMih6b29tICogcHhSYXRpbykpO1xuXG4gICAgICBpZiAobHZsIDwgbWluTHZsKSB7XG4gICAgICAgIGx2bCA9IG1pbkx2bDtcbiAgICAgIH0gZWxzZSBpZiAoem9vbSA+PSBtYXhab29tIHx8IGx2bCA+IG1heEx2bCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmLnZhbGlkYXRlTGF5ZXJzRWxlc09yZGVyaW5nKGx2bCwgZWxlcyk7XG4gICAgdmFyIGxheWVyc0J5THZsID0gc2VsZi5sYXllcnNCeUxldmVsO1xuICAgIHZhciBzY2FsZSA9IE1hdGgucG93KDIsIGx2bCk7XG4gICAgdmFyIGxheWVycyA9IGxheWVyc0J5THZsW2x2bF0gPSBsYXllcnNCeUx2bFtsdmxdIHx8IFtdO1xuICAgIHZhciBiYjtcbiAgICB2YXIgbHZsQ29tcGxldGUgPSBzZWxmLmxldmVsSXNDb21wbGV0ZShsdmwsIGVsZXMpO1xuICAgIHZhciB0bXBMYXllcnM7XG5cbiAgICB2YXIgY2hlY2tUZW1wTGV2ZWxzID0gZnVuY3Rpb24gY2hlY2tUZW1wTGV2ZWxzKCkge1xuICAgICAgdmFyIGNhblVzZUFzVG1wTHZsID0gZnVuY3Rpb24gY2FuVXNlQXNUbXBMdmwobCkge1xuICAgICAgICBzZWxmLnZhbGlkYXRlTGF5ZXJzRWxlc09yZGVyaW5nKGwsIGVsZXMpO1xuXG4gICAgICAgIGlmIChzZWxmLmxldmVsSXNDb21wbGV0ZShsLCBlbGVzKSkge1xuICAgICAgICAgIHRtcExheWVycyA9IGxheWVyc0J5THZsW2xdO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgY2hlY2tMdmxzID0gZnVuY3Rpb24gY2hlY2tMdmxzKGRpcikge1xuICAgICAgICBpZiAodG1wTGF5ZXJzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgbCA9IGx2bCArIGRpcjsgbWluTHZsIDw9IGwgJiYgbCA8PSBtYXhMdmw7IGwgKz0gZGlyKSB7XG4gICAgICAgICAgaWYgKGNhblVzZUFzVG1wTHZsKGwpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGNoZWNrTHZscygrMSk7XG4gICAgICBjaGVja0x2bHMoLTEpOyAvLyByZW1vdmUgdGhlIGludmFsaWQgbGF5ZXJzOyB0aGV5IHdpbGwgYmUgcmVwbGFjZWQgYXMgbmVlZGVkIGxhdGVyIGluIHRoaXMgZnVuY3Rpb25cblxuICAgICAgZm9yICh2YXIgaSA9IGxheWVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgbGF5ZXIgPSBsYXllcnNbaV07XG5cbiAgICAgICAgaWYgKGxheWVyLmludmFsaWQpIHtcbiAgICAgICAgICByZW1vdmVGcm9tQXJyYXkobGF5ZXJzLCBsYXllcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKCFsdmxDb21wbGV0ZSkge1xuICAgICAgLy8gaWYgdGhlIGN1cnJlbnQgbGV2ZWwgaXMgaW5jb21wbGV0ZSwgdGhlbiB1c2UgdGhlIGNsb3Nlc3QsIGJlc3QgcXVhbGl0eSBsYXllcnNldCB0ZW1wb3JhcmlseVxuICAgICAgLy8gYW5kIGxhdGVyIHF1ZXVlIHRoZSBjdXJyZW50IGxheWVyc2V0IHNvIHdlIGNhbiBnZXQgdGhlIHByb3BlciBxdWFsaXR5IGxldmVsIHNvb25cbiAgICAgIGNoZWNrVGVtcExldmVscygpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBsb2coJ2xldmVsIGNvbXBsZXRlLCB1c2luZyBleGlzdGluZyBsYXllcnNcXG4tLScpO1xuICAgICAgcmV0dXJuIGxheWVycztcbiAgICB9XG5cbiAgICB2YXIgZ2V0QmIgPSBmdW5jdGlvbiBnZXRCYigpIHtcbiAgICAgIGlmICghYmIpIHtcbiAgICAgICAgYmIgPSBtYWtlQm91bmRpbmdCb3goKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB1cGRhdGVCb3VuZGluZ0JveChiYiwgZWxlc1tpXS5ib3VuZGluZ0JveCgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYmI7XG4gICAgfTtcblxuICAgIHZhciBtYWtlTGF5ZXIgPSBmdW5jdGlvbiBtYWtlTGF5ZXIob3B0cykge1xuICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICB2YXIgYWZ0ZXIgPSBvcHRzLmFmdGVyO1xuICAgICAgZ2V0QmIoKTtcbiAgICAgIHZhciBhcmVhID0gYmIudyAqIHNjYWxlICogKGJiLmggKiBzY2FsZSk7XG5cbiAgICAgIGlmIChhcmVhID4gbWF4TGF5ZXJBcmVhKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGF5ZXIgPSBzZWxmLm1ha2VMYXllcihiYiwgbHZsKTtcblxuICAgICAgaWYgKGFmdGVyICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gbGF5ZXJzLmluZGV4T2YoYWZ0ZXIpICsgMTtcbiAgICAgICAgbGF5ZXJzLnNwbGljZShpbmRleCwgMCwgbGF5ZXIpO1xuICAgICAgfSBlbHNlIGlmIChvcHRzLmluc2VydCA9PT0gdW5kZWZpbmVkIHx8IG9wdHMuaW5zZXJ0KSB7XG4gICAgICAgIC8vIG5vIGFmdGVyIHNwZWNpZmllZCA9PiBmaXJzdCBsYXllciBtYWRlIHNvIHB1dCBhdCBzdGFydFxuICAgICAgICBsYXllcnMudW5zaGlmdChsYXllcik7XG4gICAgICB9IC8vIGlmKCB0bXBMYXllcnMgKXtcbiAgICAgIC8vc2VsZi5xdWV1ZUxheWVyKCBsYXllciApO1xuICAgICAgLy8gfVxuXG5cbiAgICAgIHJldHVybiBsYXllcjtcbiAgICB9O1xuXG4gICAgaWYgKHNlbGYuc2tpcHBpbmcgJiYgIWZpcnN0R2V0KSB7XG4gICAgICAvLyBsb2coJ3NraXAgbGF5ZXJzJyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IC8vIGxvZygnZG8gbGF5ZXJzJyk7XG5cblxuICAgIHZhciBsYXllciA9IG51bGw7XG4gICAgdmFyIG1heEVsZXNQZXJMYXllciA9IGVsZXMubGVuZ3RoIC8gZGVmTnVtTGF5ZXJzO1xuICAgIHZhciBhbGxvd0xhenlRdWV1ZWluZyA9ICFmaXJzdEdldDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICB2YXIgcnMgPSBlbGUuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgICB2YXIgY2FjaGVzID0gcnMuaW1nTGF5ZXJDYWNoZXMgPSBycy5pbWdMYXllckNhY2hlcyB8fCB7fTsgLy8gbG9nKCdsb29rIGF0IGVsZScsIGVsZS5pZCgpKTtcblxuICAgICAgdmFyIGV4aXN0aW5nTGF5ZXIgPSBjYWNoZXNbbHZsXTtcblxuICAgICAgaWYgKGV4aXN0aW5nTGF5ZXIpIHtcbiAgICAgICAgLy8gcmV1c2UgbGF5ZXIgZm9yIGxhdGVyIGVsZXNcbiAgICAgICAgLy8gbG9nKCdyZXVzZSBsYXllciBmb3InLCBlbGUuaWQoKSk7XG4gICAgICAgIGxheWVyID0gZXhpc3RpbmdMYXllcjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICghbGF5ZXIgfHwgbGF5ZXIuZWxlcy5sZW5ndGggPj0gbWF4RWxlc1BlckxheWVyIHx8ICFib3VuZGluZ0JveEluQm91bmRpbmdCb3gobGF5ZXIuYmIsIGVsZS5ib3VuZGluZ0JveCgpKSkge1xuICAgICAgICAvLyBsb2coJ21ha2UgbmV3IGxheWVyIGZvciBlbGUgJXMnLCBlbGUuaWQoKSk7XG4gICAgICAgIGxheWVyID0gbWFrZUxheWVyKHtcbiAgICAgICAgICBpbnNlcnQ6IHRydWUsXG4gICAgICAgICAgYWZ0ZXI6IGxheWVyXG4gICAgICAgIH0pOyAvLyBpZiBub3cgbGF5ZXIgY2FuIGJlIGJ1aWx0IHRoZW4gd2UgY2FuJ3QgdXNlIGxheWVycyBhdCB0aGlzIGxldmVsXG5cbiAgICAgICAgaWYgKCFsYXllcikge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9IC8vIGxvZygnbmV3IGxheWVyIHdpdGggaWQgJXMnLCBsYXllci5pZCk7XG5cbiAgICAgIH1cblxuICAgICAgaWYgKHRtcExheWVycyB8fCBhbGxvd0xhenlRdWV1ZWluZykge1xuICAgICAgICAvLyBsb2coJ3F1ZXVlIGVsZSAlcyBpbiBsYXllciAlcycsIGVsZS5pZCgpLCBsYXllci5pZCk7XG4gICAgICAgIHNlbGYucXVldWVMYXllcihsYXllciwgZWxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGxvZygnZHJhdyBlbGUgJXMgaW4gbGF5ZXIgJXMnLCBlbGUuaWQoKSwgbGF5ZXIuaWQpO1xuICAgICAgICBzZWxmLmRyYXdFbGVJbkxheWVyKGxheWVyLCBlbGUsIGx2bCwgcHhSYXRpbyk7XG4gICAgICB9XG5cbiAgICAgIGxheWVyLmVsZXMucHVzaChlbGUpO1xuICAgICAgY2FjaGVzW2x2bF0gPSBsYXllcjtcbiAgICB9IC8vIGxvZygnLS0nKTtcblxuXG4gICAgaWYgKHRtcExheWVycykge1xuICAgICAgLy8gdGhlbiB3ZSBvbmx5IHF1ZXVlZCB0aGUgY3VycmVudCBsYXllcnNldCBhbmQgY2FuJ3QgZHJhdyBpdCB5ZXRcbiAgICAgIHJldHVybiB0bXBMYXllcnM7XG4gICAgfVxuXG4gICAgaWYgKGFsbG93TGF6eVF1ZXVlaW5nKSB7XG4gICAgICAvLyBsb2coJ2xhenkgcXVldWUgbGV2ZWwnLCBsdmwpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxheWVycztcbiAgfTsgLy8gYSBsYXllciBtYXkgd2FudCB0byB1c2UgYW4gZWxlIGNhY2hlIG9mIGEgaGlnaGVyIGxldmVsIHRvIGF2b2lkIGJsdXJyaW5lc3NcbiAgLy8gc28gdGhlIGxheWVyIGxldmVsIG1pZ2h0IG5vdCBlcXVhbCB0aGUgZWxlIGxldmVsXG5cblxuICBMVENwLmdldEVsZUxldmVsRm9yTGF5ZXJMZXZlbCA9IGZ1bmN0aW9uIChsdmwsIHB4UmF0aW8pIHtcbiAgICByZXR1cm4gbHZsO1xuICB9O1xuXG4gIExUQ3AuZHJhd0VsZUluTGF5ZXIgPSBmdW5jdGlvbiAobGF5ZXIsIGVsZSwgbHZsLCBweFJhdGlvKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciByID0gdGhpcy5yZW5kZXJlcjtcbiAgICB2YXIgY29udGV4dCA9IGxheWVyLmNvbnRleHQ7XG4gICAgdmFyIGJiID0gZWxlLmJvdW5kaW5nQm94KCk7XG5cbiAgICBpZiAoYmIudyA9PT0gMCB8fCBiYi5oID09PSAwIHx8ICFlbGUudmlzaWJsZSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbHZsID0gc2VsZi5nZXRFbGVMZXZlbEZvckxheWVyTGV2ZWwobHZsLCBweFJhdGlvKTtcblxuICAgIHtcbiAgICAgIHIuc2V0SW1nU21vb3RoaW5nKGNvbnRleHQsIGZhbHNlKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICByLmRyYXdDYWNoZWRFbGVtZW50KGNvbnRleHQsIGVsZSwgbnVsbCwgbnVsbCwgbHZsLCB1c2VIaWdoUXVhbGl0eUVsZVR4clJlcXMpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIHIuc2V0SW1nU21vb3RoaW5nKGNvbnRleHQsIHRydWUpO1xuICAgIH1cbiAgfTtcblxuICBMVENwLmxldmVsSXNDb21wbGV0ZSA9IGZ1bmN0aW9uIChsdmwsIGVsZXMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGxheWVycyA9IHNlbGYubGF5ZXJzQnlMZXZlbFtsdmxdO1xuXG4gICAgaWYgKCFsYXllcnMgfHwgbGF5ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBudW1FbGVzSW5MYXllcnMgPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBsYXllciA9IGxheWVyc1tpXTsgLy8gaWYgdGhlcmUgYXJlIGFueSBlbGVzIG5lZWRlZCB0byBiZSBkcmF3biB5ZXQsIHRoZSBsZXZlbCBpcyBub3QgY29tcGxldGVcblxuICAgICAgaWYgKGxheWVyLnJlcXMgPiAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gLy8gaWYgdGhlIGxheWVyIGlzIGludmFsaWQsIHRoZSBsZXZlbCBpcyBub3QgY29tcGxldGVcblxuXG4gICAgICBpZiAobGF5ZXIuaW52YWxpZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIG51bUVsZXNJbkxheWVycyArPSBsYXllci5lbGVzLmxlbmd0aDtcbiAgICB9IC8vIHdlIHNob3VsZCBoYXZlIGV4YWN0bHkgdGhlIG51bWJlciBvZiBlbGVzIHBhc3NlZCBpbiB0byBiZSBjb21wbGV0ZVxuXG5cbiAgICBpZiAobnVtRWxlc0luTGF5ZXJzICE9PSBlbGVzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIExUQ3AudmFsaWRhdGVMYXllcnNFbGVzT3JkZXJpbmcgPSBmdW5jdGlvbiAobHZsLCBlbGVzKSB7XG4gICAgdmFyIGxheWVycyA9IHRoaXMubGF5ZXJzQnlMZXZlbFtsdmxdO1xuXG4gICAgaWYgKCFsYXllcnMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGlmIGluIGEgbGF5ZXIgdGhlIGVsZXMgYXJlIG5vdCBpbiB0aGUgc2FtZSBvcmRlciwgdGhlbiB0aGUgbGF5ZXIgaXMgaW52YWxpZFxuICAgIC8vIChpLmUuIHRoZXJlIGlzIGFuIGVsZSBpbiBiZXR3ZWVuIHRoZSBlbGVzIGluIHRoZSBsYXllcilcblxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBsYXllciA9IGxheWVyc1tpXTtcbiAgICAgIHZhciBvZmZzZXQgPSAtMTsgLy8gZmluZCB0aGUgb2Zmc2V0XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZWxlcy5sZW5ndGg7IGorKykge1xuICAgICAgICBpZiAobGF5ZXIuZWxlc1swXSA9PT0gZWxlc1tqXSkge1xuICAgICAgICAgIG9mZnNldCA9IGo7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgLy8gdGhlbiB0aGUgbGF5ZXIgaGFzIG5vbmV4aXN0ZW50IGVsZW1lbnRzIGFuZCBpcyBpbnZhbGlkXG4gICAgICAgIHRoaXMuaW52YWxpZGF0ZUxheWVyKGxheWVyKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIHRoZSBlbGVzIGluIHRoZSBsYXllciBtdXN0IGJlIGluIHRoZSBzYW1lIGNvbnRpbnVvdXMgb3JkZXIsIGVsc2UgdGhlIGxheWVyIGlzIGludmFsaWRcblxuXG4gICAgICB2YXIgbyA9IG9mZnNldDtcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsYXllci5lbGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChsYXllci5lbGVzW2pdICE9PSBlbGVzW28gKyBqXSkge1xuICAgICAgICAgIC8vIGxvZygnaW52YWxpZGF0ZSBiYXNlZCBvbiBvcmRlcmluZycsIGxheWVyLmlkKTtcbiAgICAgICAgICB0aGlzLmludmFsaWRhdGVMYXllcihsYXllcik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgTFRDcC51cGRhdGVFbGVtZW50c0luTGF5ZXJzID0gZnVuY3Rpb24gKGVsZXMsIHVwZGF0ZSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgaXNFbGVzID0gZWxlbWVudChlbGVzWzBdKTsgLy8gY29sbGVjdCB1ZHBhdGVkIGVsZW1lbnRzIChjYXNjYWRlZCBmcm9tIHRoZSBsYXllcnMpIGFuZCB1cGRhdGUgZWFjaFxuICAgIC8vIGxheWVyIGl0c2VsZiBhbG9uZyB0aGUgd2F5XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciByZXEgPSBpc0VsZXMgPyBudWxsIDogZWxlc1tpXTtcbiAgICAgIHZhciBlbGUgPSBpc0VsZXMgPyBlbGVzW2ldIDogZWxlc1tpXS5lbGU7XG4gICAgICB2YXIgcnMgPSBlbGUuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgICB2YXIgY2FjaGVzID0gcnMuaW1nTGF5ZXJDYWNoZXMgPSBycy5pbWdMYXllckNhY2hlcyB8fCB7fTtcblxuICAgICAgZm9yICh2YXIgbCA9IG1pbkx2bDsgbCA8PSBtYXhMdmw7IGwrKykge1xuICAgICAgICB2YXIgbGF5ZXIgPSBjYWNoZXNbbF07XG5cbiAgICAgICAgaWYgKCFsYXllcikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIGlmIHVwZGF0ZSBpcyBhIHJlcXVlc3QgZnJvbSB0aGUgZWxlIGNhY2hlLCB0aGVuIGl0IGFmZmVjdHMgb25seVxuICAgICAgICAvLyB0aGUgbWF0Y2hpbmcgbGV2ZWxcblxuXG4gICAgICAgIGlmIChyZXEgJiYgc2VsZi5nZXRFbGVMZXZlbEZvckxheWVyTGV2ZWwobGF5ZXIubGV2ZWwpICE9PSByZXEubGV2ZWwpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHVwZGF0ZShsYXllciwgZWxlLCByZXEpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBMVENwLmhhdmVMYXllcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBoYXZlTGF5ZXJzID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBsID0gbWluTHZsOyBsIDw9IG1heEx2bDsgbCsrKSB7XG4gICAgICB2YXIgbGF5ZXJzID0gc2VsZi5sYXllcnNCeUxldmVsW2xdO1xuXG4gICAgICBpZiAobGF5ZXJzICYmIGxheWVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGhhdmVMYXllcnMgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaGF2ZUxheWVycztcbiAgfTtcblxuICBMVENwLmludmFsaWRhdGVFbGVtZW50cyA9IGZ1bmN0aW9uIChlbGVzKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYgKGVsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2VsZi5sYXN0SW52YWxpZGF0aW9uVGltZSA9IHBlcmZvcm1hbmNlTm93KCk7IC8vIGxvZygndXBkYXRlIGludmFsaWRhdGUgbGF5ZXIgdGltZSBmcm9tIGVsZXMnKTtcblxuICAgIGlmIChlbGVzLmxlbmd0aCA9PT0gMCB8fCAhc2VsZi5oYXZlTGF5ZXJzKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzZWxmLnVwZGF0ZUVsZW1lbnRzSW5MYXllcnMoZWxlcywgZnVuY3Rpb24gaW52YWxBc3NvY0xheWVycyhsYXllciwgZWxlLCByZXEpIHtcbiAgICAgIHNlbGYuaW52YWxpZGF0ZUxheWVyKGxheWVyKTtcbiAgICB9KTtcbiAgfTtcblxuICBMVENwLmludmFsaWRhdGVMYXllciA9IGZ1bmN0aW9uIChsYXllcikge1xuICAgIC8vIGxvZygndXBkYXRlIGludmFsaWRhdGUgbGF5ZXIgdGltZScpO1xuICAgIHRoaXMubGFzdEludmFsaWRhdGlvblRpbWUgPSBwZXJmb3JtYW5jZU5vdygpO1xuXG4gICAgaWYgKGxheWVyLmludmFsaWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIHNhdmUgY3ljbGVzXG5cblxuICAgIHZhciBsdmwgPSBsYXllci5sZXZlbDtcbiAgICB2YXIgZWxlcyA9IGxheWVyLmVsZXM7XG4gICAgdmFyIGxheWVycyA9IHRoaXMubGF5ZXJzQnlMZXZlbFtsdmxdOyAvLyBsb2coJ2ludmFsaWRhdGUgbGF5ZXInLCBsYXllci5pZCApO1xuXG4gICAgcmVtb3ZlRnJvbUFycmF5KGxheWVycywgbGF5ZXIpOyAvLyBsYXllci5lbGVzID0gW107XG5cbiAgICBsYXllci5lbGVzUXVldWUgPSBbXTtcbiAgICBsYXllci5pbnZhbGlkID0gdHJ1ZTtcblxuICAgIGlmIChsYXllci5yZXBsYWNlbWVudCkge1xuICAgICAgbGF5ZXIucmVwbGFjZW1lbnQuaW52YWxpZCA9IHRydWU7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2FjaGVzID0gZWxlc1tpXS5fcHJpdmF0ZS5yc2NyYXRjaC5pbWdMYXllckNhY2hlcztcblxuICAgICAgaWYgKGNhY2hlcykge1xuICAgICAgICBjYWNoZXNbbHZsXSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIExUQ3AucmVmaW5lRWxlbWVudFRleHR1cmVzID0gZnVuY3Rpb24gKGVsZXMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7IC8vIGxvZygncmVmaW5lJywgZWxlcy5sZW5ndGgpO1xuXG4gICAgc2VsZi51cGRhdGVFbGVtZW50c0luTGF5ZXJzKGVsZXMsIGZ1bmN0aW9uIHJlZmluZUVhY2hFbGUobGF5ZXIsIGVsZSwgcmVxKSB7XG4gICAgICB2YXIgckx5ciA9IGxheWVyLnJlcGxhY2VtZW50O1xuXG4gICAgICBpZiAoIXJMeXIpIHtcbiAgICAgICAgckx5ciA9IGxheWVyLnJlcGxhY2VtZW50ID0gc2VsZi5tYWtlTGF5ZXIobGF5ZXIuYmIsIGxheWVyLmxldmVsKTtcbiAgICAgICAgckx5ci5yZXBsYWNlcyA9IGxheWVyO1xuICAgICAgICByTHlyLmVsZXMgPSBsYXllci5lbGVzOyAvLyBsb2coJ21ha2UgcmVwbGFjZW1lbnQgbGF5ZXIgJXMgZm9yICVzIHdpdGggbGV2ZWwgJXMnLCByTHlyLmlkLCBsYXllci5pZCwgckx5ci5sZXZlbCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghckx5ci5yZXFzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgckx5ci5lbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgc2VsZi5xdWV1ZUxheWVyKHJMeXIsIHJMeXIuZWxlc1tpXSk7XG4gICAgICAgIH0gLy8gbG9nKCdxdWV1ZSByZXBsYWNlbWVudCBsYXllciByZWZpbmVtZW50Jywgckx5ci5pZCk7XG5cbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBMVENwLmVucXVldWVFbGVtZW50UmVmaW5lbWVudCA9IGZ1bmN0aW9uIChlbGUpIHtcblxuICAgIHRoaXMuZWxlVHhyRGVxcy5tZXJnZShlbGUpO1xuICAgIHRoaXMuc2NoZWR1bGVFbGVtZW50UmVmaW5lbWVudCgpO1xuICB9O1xuXG4gIExUQ3AucXVldWVMYXllciA9IGZ1bmN0aW9uIChsYXllciwgZWxlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBxID0gc2VsZi5sYXllcnNRdWV1ZTtcbiAgICB2YXIgZWxlc1EgPSBsYXllci5lbGVzUXVldWU7XG4gICAgdmFyIGhhc0lkID0gZWxlc1EuaGFzSWQgPSBlbGVzUS5oYXNJZCB8fCB7fTsgLy8gaWYgYSBsYXllciBpcyBnb2luZyB0byBiZSByZXBsYWNlZCwgcXVldWluZyBpcyBhIHdhc3RlIG9mIHRpbWVcblxuICAgIGlmIChsYXllci5yZXBsYWNlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChlbGUpIHtcbiAgICAgIGlmIChoYXNJZFtlbGUuaWQoKV0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBlbGVzUS5wdXNoKGVsZSk7XG4gICAgICBoYXNJZFtlbGUuaWQoKV0gPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChsYXllci5yZXFzKSB7XG4gICAgICBsYXllci5yZXFzKys7XG4gICAgICBxLnVwZGF0ZUl0ZW0obGF5ZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXllci5yZXFzID0gMTtcbiAgICAgIHEucHVzaChsYXllcik7XG4gICAgfVxuICB9O1xuXG4gIExUQ3AuZGVxdWV1ZSA9IGZ1bmN0aW9uIChweFJhdGlvKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBxID0gc2VsZi5sYXllcnNRdWV1ZTtcbiAgICB2YXIgZGVxZCA9IFtdO1xuICAgIHZhciBlbGVEZXFzID0gMDtcblxuICAgIHdoaWxlIChlbGVEZXFzIDwgbWF4RGVxU2l6ZSkge1xuICAgICAgaWYgKHEuc2l6ZSgpID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGF5ZXIgPSBxLnBlZWsoKTsgLy8gaWYgYSBsYXllciBoYXMgYmVlbiBvciB3aWxsIGJlIHJlcGxhY2VkLCB0aGVuIGRvbid0IHdhc3RlIHRpbWUgd2l0aCBpdFxuXG4gICAgICBpZiAobGF5ZXIucmVwbGFjZW1lbnQpIHtcbiAgICAgICAgLy8gbG9nKCdsYXllciAlcyBpbiBxdWV1ZSBza2lwcGVkIGIvYyBpdCBhbHJlYWR5IGhhcyBhIHJlcGxhY2VtZW50JywgbGF5ZXIuaWQpO1xuICAgICAgICBxLnBvcCgpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8gaWYgdGhpcyBpcyBhIHJlcGxhY2VtZW50IGxheWVyIHRoYXQgaGFzIGJlZW4gc3VwZXJjZWRlZCwgdGhlbiBmb3JnZXQgaXRcblxuXG4gICAgICBpZiAobGF5ZXIucmVwbGFjZXMgJiYgbGF5ZXIgIT09IGxheWVyLnJlcGxhY2VzLnJlcGxhY2VtZW50KSB7XG4gICAgICAgIC8vIGxvZygnbGF5ZXIgaXMgbm8gbG9uZ2VyIHRoZSBtb3N0IHVwdG9kYXRlIHJlcGxhY2VtZW50OyBkZXF1ZXVlZCcsIGxheWVyLmlkKVxuICAgICAgICBxLnBvcCgpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxheWVyLmludmFsaWQpIHtcbiAgICAgICAgLy8gbG9nKCdyZXBsYWNlbWVudCBsYXllciAlcyBpcyBpbnZhbGlkOyBkZXF1ZXVlZCcsIGxheWVyLmlkKTtcbiAgICAgICAgcS5wb3AoKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBlbGUgPSBsYXllci5lbGVzUXVldWUuc2hpZnQoKTtcblxuICAgICAgaWYgKGVsZSkge1xuICAgICAgICAvLyBsb2coJ2RlcXVldWUgbGF5ZXIgJXMnLCBsYXllci5pZCk7XG4gICAgICAgIHNlbGYuZHJhd0VsZUluTGF5ZXIobGF5ZXIsIGVsZSwgbGF5ZXIubGV2ZWwsIHB4UmF0aW8pO1xuICAgICAgICBlbGVEZXFzKys7XG4gICAgICB9XG5cbiAgICAgIGlmIChkZXFkLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAvLyB3ZSBuZWVkIG9ubHkgb25lIGVudHJ5IGluIGRlcWQgdG8gcXVldWUgcmVkcmF3aW5nIGV0Y1xuICAgICAgICBkZXFkLnB1c2godHJ1ZSk7XG4gICAgICB9IC8vIGlmIHRoZSBsYXllciBoYXMgYWxsIGl0cyBlbGVzIGRvbmUsIHRoZW4gcmVtb3ZlIGZyb20gdGhlIHF1ZXVlXG5cblxuICAgICAgaWYgKGxheWVyLmVsZXNRdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcS5wb3AoKTtcbiAgICAgICAgbGF5ZXIucmVxcyA9IDA7IC8vIGxvZygnZGVxdWV1ZSBvZiBsYXllciAlcyBjb21wbGV0ZScsIGxheWVyLmlkKTtcbiAgICAgICAgLy8gd2hlbiBhIHJlcGxhY2VtZW50IGxheWVyIGlzIGRlcXVldWVkLCBpdCByZXBsYWNlcyB0aGUgb2xkIGxheWVyIGluIHRoZSBsZXZlbFxuXG4gICAgICAgIGlmIChsYXllci5yZXBsYWNlcykge1xuICAgICAgICAgIHNlbGYuYXBwbHlMYXllclJlcGxhY2VtZW50KGxheWVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYucmVxdWVzdFJlZHJhdygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkZXFkO1xuICB9O1xuXG4gIExUQ3AuYXBwbHlMYXllclJlcGxhY2VtZW50ID0gZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBsYXllcnNJbkxldmVsID0gc2VsZi5sYXllcnNCeUxldmVsW2xheWVyLmxldmVsXTtcbiAgICB2YXIgcmVwbGFjZWQgPSBsYXllci5yZXBsYWNlcztcbiAgICB2YXIgaW5kZXggPSBsYXllcnNJbkxldmVsLmluZGV4T2YocmVwbGFjZWQpOyAvLyBpZiB0aGUgcmVwbGFjZWQgbGF5ZXIgaXMgbm90IGluIHRoZSBhY3RpdmUgbGlzdCBmb3IgdGhlIGxldmVsLCB0aGVuIHJlcGxhY2luZ1xuICAgIC8vIHJlZnMgd291bGQgYmUgYSBtaXN0YWtlIChpLmUuIG92ZXJ3cml0aW5nIHRoZSB0cnVlIGFjdGl2ZSBsYXllcilcblxuICAgIGlmIChpbmRleCA8IDAgfHwgcmVwbGFjZWQuaW52YWxpZCkge1xuICAgICAgLy8gbG9nKCdyZXBsYWNlbWVudCBsYXllciB3b3VsZCBoYXZlIG5vIGVmZmVjdCcsIGxheWVyLmlkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsYXllcnNJbkxldmVsW2luZGV4XSA9IGxheWVyOyAvLyByZXBsYWNlIGxldmVsIHJlZlxuICAgIC8vIHJlcGxhY2UgcmVmcyBpbiBlbGVzXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheWVyLmVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBfcCA9IGxheWVyLmVsZXNbaV0uX3ByaXZhdGU7XG4gICAgICB2YXIgY2FjaGUgPSBfcC5pbWdMYXllckNhY2hlcyA9IF9wLmltZ0xheWVyQ2FjaGVzIHx8IHt9O1xuXG4gICAgICBpZiAoY2FjaGUpIHtcbiAgICAgICAgY2FjaGVbbGF5ZXIubGV2ZWxdID0gbGF5ZXI7XG4gICAgICB9XG4gICAgfSAvLyBsb2coJ2FwcGx5IHJlcGxhY2VtZW50IGxheWVyICVzIG92ZXIgJXMnLCBsYXllci5pZCwgcmVwbGFjZWQuaWQpO1xuXG5cbiAgICBzZWxmLnJlcXVlc3RSZWRyYXcoKTtcbiAgfTtcblxuICBMVENwLnJlcXVlc3RSZWRyYXcgPSBkZWJvdW5jZV8xKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgciA9IHRoaXMucmVuZGVyZXI7XG4gICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgci5yZWRyYXdIaW50KCdkcmFnJywgdHJ1ZSk7XG4gICAgci5yZWRyYXcoKTtcbiAgfSwgMTAwKTtcbiAgTFRDcC5zZXR1cERlcXVldWVpbmcgPSBkZWZzLnNldHVwRGVxdWV1ZWluZyh7XG4gICAgZGVxUmVkcmF3VGhyZXNob2xkOiBkZXFSZWRyYXdUaHJlc2hvbGQsXG4gICAgZGVxQ29zdDogZGVxQ29zdCxcbiAgICBkZXFBdmdDb3N0OiBkZXFBdmdDb3N0LFxuICAgIGRlcU5vRHJhd0Nvc3Q6IGRlcU5vRHJhd0Nvc3QsXG4gICAgZGVxRmFzdENvc3Q6IGRlcUZhc3RDb3N0LFxuICAgIGRlcTogZnVuY3Rpb24gZGVxKHNlbGYsIHB4UmF0aW8pIHtcbiAgICAgIHJldHVybiBzZWxmLmRlcXVldWUocHhSYXRpbyk7XG4gICAgfSxcbiAgICBvbkRlcWQ6IG5vb3AkMSxcbiAgICBzaG91bGRSZWRyYXc6IHRydWVpZnksXG4gICAgcHJpb3JpdHk6IGZ1bmN0aW9uIHByaW9yaXR5KHNlbGYpIHtcbiAgICAgIHJldHVybiBzZWxmLnJlbmRlcmVyLmJlZm9yZVJlbmRlclByaW9yaXRpZXMubHlyVHhyRGVxO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIENScCRhID0ge307XG4gIHZhciBpbXBsO1xuXG4gIGZ1bmN0aW9uIHBvbHlnb24oY29udGV4dCwgcG9pbnRzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwdCA9IHBvaW50c1tpXTtcbiAgICAgIGNvbnRleHQubGluZVRvKHB0LngsIHB0LnkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRyaWFuZ2xlQmFja2N1cnZlKGNvbnRleHQsIHBvaW50cywgY29udHJvbFBvaW50KSB7XG4gICAgdmFyIGZpcnN0UHQ7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHB0ID0gcG9pbnRzW2ldO1xuXG4gICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICBmaXJzdFB0ID0gcHQ7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQubGluZVRvKHB0LngsIHB0LnkpO1xuICAgIH1cblxuICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyhjb250cm9sUG9pbnQueCwgY29udHJvbFBvaW50LnksIGZpcnN0UHQueCwgZmlyc3RQdC55KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyaWFuZ2xlVGVlKGNvbnRleHQsIHRyaWFuZ2xlUG9pbnRzLCB0ZWVQb2ludHMpIHtcbiAgICBpZiAoY29udGV4dC5iZWdpblBhdGgpIHtcbiAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgfVxuXG4gICAgdmFyIHRyaVB0cyA9IHRyaWFuZ2xlUG9pbnRzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmlQdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwdCA9IHRyaVB0c1tpXTtcbiAgICAgIGNvbnRleHQubGluZVRvKHB0LngsIHB0LnkpO1xuICAgIH1cblxuICAgIHZhciB0ZWVQdHMgPSB0ZWVQb2ludHM7XG4gICAgdmFyIGZpcnN0VGVlUHQgPSB0ZWVQb2ludHNbMF07XG4gICAgY29udGV4dC5tb3ZlVG8oZmlyc3RUZWVQdC54LCBmaXJzdFRlZVB0LnkpO1xuXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0ZWVQdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwdCA9IHRlZVB0c1tpXTtcbiAgICAgIGNvbnRleHQubGluZVRvKHB0LngsIHB0LnkpO1xuICAgIH1cblxuICAgIGlmIChjb250ZXh0LmNsb3NlUGF0aCkge1xuICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaXJjbGVUcmlhbmdsZShjb250ZXh0LCB0cmlhbmdsZVBvaW50cywgcngsIHJ5LCByKSB7XG4gICAgaWYgKGNvbnRleHQuYmVnaW5QYXRoKSB7XG4gICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIH1cblxuICAgIGNvbnRleHQuYXJjKHJ4LCByeSwgciwgMCwgTWF0aC5QSSAqIDIsIGZhbHNlKTtcbiAgICB2YXIgdHJpUHRzID0gdHJpYW5nbGVQb2ludHM7XG4gICAgdmFyIGZpcnN0VHJQdCA9IHRyaVB0c1swXTtcbiAgICBjb250ZXh0Lm1vdmVUbyhmaXJzdFRyUHQueCwgZmlyc3RUclB0LnkpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmlQdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwdCA9IHRyaVB0c1tpXTtcbiAgICAgIGNvbnRleHQubGluZVRvKHB0LngsIHB0LnkpO1xuICAgIH1cblxuICAgIGlmIChjb250ZXh0LmNsb3NlUGF0aCkge1xuICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaXJjbGUoY29udGV4dCwgcngsIHJ5LCByKSB7XG4gICAgY29udGV4dC5hcmMocngsIHJ5LCByLCAwLCBNYXRoLlBJICogMiwgZmFsc2UpO1xuICB9XG5cbiAgQ1JwJGEuYXJyb3dTaGFwZUltcGwgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiAoaW1wbCB8fCAoaW1wbCA9IHtcbiAgICAgICdwb2x5Z29uJzogcG9seWdvbixcbiAgICAgICd0cmlhbmdsZS1iYWNrY3VydmUnOiB0cmlhbmdsZUJhY2tjdXJ2ZSxcbiAgICAgICd0cmlhbmdsZS10ZWUnOiB0cmlhbmdsZVRlZSxcbiAgICAgICdjaXJjbGUtdHJpYW5nbGUnOiBjaXJjbGVUcmlhbmdsZSxcbiAgICAgICd0cmlhbmdsZS1jcm9zcyc6IHRyaWFuZ2xlVGVlLFxuICAgICAgJ2NpcmNsZSc6IGNpcmNsZVxuICAgIH0pKVtuYW1lXTtcbiAgfTtcblxuICB2YXIgQ1JwJDkgPSB7fTtcblxuICBDUnAkOS5kcmF3RWxlbWVudCA9IGZ1bmN0aW9uIChjb250ZXh0LCBlbGUsIHNoaWZ0VG9PcmlnaW5XaXRoQmIsIHNob3dMYWJlbCwgc2hvd092ZXJsYXksIHNob3dPcGFjaXR5KSB7XG4gICAgdmFyIHIgPSB0aGlzO1xuXG4gICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgci5kcmF3Tm9kZShjb250ZXh0LCBlbGUsIHNoaWZ0VG9PcmlnaW5XaXRoQmIsIHNob3dMYWJlbCwgc2hvd092ZXJsYXksIHNob3dPcGFjaXR5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgci5kcmF3RWRnZShjb250ZXh0LCBlbGUsIHNoaWZ0VG9PcmlnaW5XaXRoQmIsIHNob3dMYWJlbCwgc2hvd092ZXJsYXksIHNob3dPcGFjaXR5KTtcbiAgICB9XG4gIH07XG5cbiAgQ1JwJDkuZHJhd0VsZW1lbnRPdmVybGF5ID0gZnVuY3Rpb24gKGNvbnRleHQsIGVsZSkge1xuICAgIHZhciByID0gdGhpcztcblxuICAgIGlmIChlbGUuaXNOb2RlKCkpIHtcbiAgICAgIHIuZHJhd05vZGVPdmVybGF5KGNvbnRleHQsIGVsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHIuZHJhd0VkZ2VPdmVybGF5KGNvbnRleHQsIGVsZSk7XG4gICAgfVxuICB9O1xuXG4gIENScCQ5LmRyYXdFbGVtZW50VW5kZXJsYXkgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlKSB7XG4gICAgdmFyIHIgPSB0aGlzO1xuXG4gICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgci5kcmF3Tm9kZVVuZGVybGF5KGNvbnRleHQsIGVsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHIuZHJhd0VkZ2VVbmRlcmxheShjb250ZXh0LCBlbGUpO1xuICAgIH1cbiAgfTtcblxuICBDUnAkOS5kcmF3Q2FjaGVkRWxlbWVudFBvcnRpb24gPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlLCBlbGVUeHJDYWNoZSwgcHhSYXRpbywgbHZsLCByZWFzb24sIGdldFJvdGF0aW9uLCBnZXRPcGFjaXR5KSB7XG4gICAgdmFyIHIgPSB0aGlzO1xuICAgIHZhciBiYiA9IGVsZVR4ckNhY2hlLmdldEJvdW5kaW5nQm94KGVsZSk7XG5cbiAgICBpZiAoYmIudyA9PT0gMCB8fCBiYi5oID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBpZ25vcmUgemVybyBzaXplIGNhc2VcblxuXG4gICAgdmFyIGVsZUNhY2hlID0gZWxlVHhyQ2FjaGUuZ2V0RWxlbWVudChlbGUsIGJiLCBweFJhdGlvLCBsdmwsIHJlYXNvbik7XG5cbiAgICBpZiAoZWxlQ2FjaGUgIT0gbnVsbCkge1xuICAgICAgdmFyIG9wYWNpdHkgPSBnZXRPcGFjaXR5KHIsIGVsZSk7XG5cbiAgICAgIGlmIChvcGFjaXR5ID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHRoZXRhID0gZ2V0Um90YXRpb24ociwgZWxlKTtcbiAgICAgIHZhciB4MSA9IGJiLngxLFxuICAgICAgICAgIHkxID0gYmIueTEsXG4gICAgICAgICAgdyA9IGJiLncsXG4gICAgICAgICAgaCA9IGJiLmg7XG4gICAgICB2YXIgeCwgeSwgc3gsIHN5LCBzbW9vdGg7XG5cbiAgICAgIGlmICh0aGV0YSAhPT0gMCkge1xuICAgICAgICB2YXIgcm90UHQgPSBlbGVUeHJDYWNoZS5nZXRSb3RhdGlvblBvaW50KGVsZSk7XG4gICAgICAgIHN4ID0gcm90UHQueDtcbiAgICAgICAgc3kgPSByb3RQdC55O1xuICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZShzeCwgc3kpO1xuICAgICAgICBjb250ZXh0LnJvdGF0ZSh0aGV0YSk7XG4gICAgICAgIHNtb290aCA9IHIuZ2V0SW1nU21vb3RoaW5nKGNvbnRleHQpO1xuXG4gICAgICAgIGlmICghc21vb3RoKSB7XG4gICAgICAgICAgci5zZXRJbWdTbW9vdGhpbmcoY29udGV4dCwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb2ZmID0gZWxlVHhyQ2FjaGUuZ2V0Um90YXRpb25PZmZzZXQoZWxlKTtcbiAgICAgICAgeCA9IG9mZi54O1xuICAgICAgICB5ID0gb2ZmLnk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4ID0geDE7XG4gICAgICAgIHkgPSB5MTtcbiAgICAgIH1cblxuICAgICAgdmFyIG9sZEdsb2JhbEFscGhhO1xuXG4gICAgICBpZiAob3BhY2l0eSAhPT0gMSkge1xuICAgICAgICBvbGRHbG9iYWxBbHBoYSA9IGNvbnRleHQuZ2xvYmFsQWxwaGE7XG4gICAgICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSBvbGRHbG9iYWxBbHBoYSAqIG9wYWNpdHk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGVsZUNhY2hlLnRleHR1cmUuY2FudmFzLCBlbGVDYWNoZS54LCAwLCBlbGVDYWNoZS53aWR0aCwgZWxlQ2FjaGUuaGVpZ2h0LCB4LCB5LCB3LCBoKTtcblxuICAgICAgaWYgKG9wYWNpdHkgIT09IDEpIHtcbiAgICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IG9sZEdsb2JhbEFscGhhO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhldGEgIT09IDApIHtcbiAgICAgICAgY29udGV4dC5yb3RhdGUoLXRoZXRhKTtcbiAgICAgICAgY29udGV4dC50cmFuc2xhdGUoLXN4LCAtc3kpO1xuXG4gICAgICAgIGlmICghc21vb3RoKSB7XG4gICAgICAgICAgci5zZXRJbWdTbW9vdGhpbmcoY29udGV4dCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZVR4ckNhY2hlLmRyYXdFbGVtZW50KGNvbnRleHQsIGVsZSk7IC8vIGRpcmVjdCBkcmF3IGZhbGxiYWNrXG4gICAgfVxuICB9O1xuXG4gIHZhciBnZXRaZXJvUm90YXRpb24gPSBmdW5jdGlvbiBnZXRaZXJvUm90YXRpb24oKSB7XG4gICAgcmV0dXJuIDA7XG4gIH07XG5cbiAgdmFyIGdldExhYmVsUm90YXRpb24gPSBmdW5jdGlvbiBnZXRMYWJlbFJvdGF0aW9uKHIsIGVsZSkge1xuICAgIHJldHVybiByLmdldFRleHRBbmdsZShlbGUsIG51bGwpO1xuICB9O1xuXG4gIHZhciBnZXRTb3VyY2VMYWJlbFJvdGF0aW9uID0gZnVuY3Rpb24gZ2V0U291cmNlTGFiZWxSb3RhdGlvbihyLCBlbGUpIHtcbiAgICByZXR1cm4gci5nZXRUZXh0QW5nbGUoZWxlLCAnc291cmNlJyk7XG4gIH07XG5cbiAgdmFyIGdldFRhcmdldExhYmVsUm90YXRpb24gPSBmdW5jdGlvbiBnZXRUYXJnZXRMYWJlbFJvdGF0aW9uKHIsIGVsZSkge1xuICAgIHJldHVybiByLmdldFRleHRBbmdsZShlbGUsICd0YXJnZXQnKTtcbiAgfTtcblxuICB2YXIgZ2V0T3BhY2l0eSA9IGZ1bmN0aW9uIGdldE9wYWNpdHkociwgZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5lZmZlY3RpdmVPcGFjaXR5KCk7XG4gIH07XG5cbiAgdmFyIGdldFRleHRPcGFjaXR5ID0gZnVuY3Rpb24gZ2V0VGV4dE9wYWNpdHkoZSwgZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5wc3R5bGUoJ3RleHQtb3BhY2l0eScpLnBmVmFsdWUgKiBlbGUuZWZmZWN0aXZlT3BhY2l0eSgpO1xuICB9O1xuXG4gIENScCQ5LmRyYXdDYWNoZWRFbGVtZW50ID0gZnVuY3Rpb24gKGNvbnRleHQsIGVsZSwgcHhSYXRpbywgZXh0ZW50LCBsdmwsIHJlcXVlc3RIaWdoUXVhbGl0eSkge1xuICAgIHZhciByID0gdGhpcztcbiAgICB2YXIgX3IkZGF0YSA9IHIuZGF0YSxcbiAgICAgICAgZWxlVHhyQ2FjaGUgPSBfciRkYXRhLmVsZVR4ckNhY2hlLFxuICAgICAgICBsYmxUeHJDYWNoZSA9IF9yJGRhdGEubGJsVHhyQ2FjaGUsXG4gICAgICAgIHNsYlR4ckNhY2hlID0gX3IkZGF0YS5zbGJUeHJDYWNoZSxcbiAgICAgICAgdGxiVHhyQ2FjaGUgPSBfciRkYXRhLnRsYlR4ckNhY2hlO1xuICAgIHZhciBiYiA9IGVsZS5ib3VuZGluZ0JveCgpO1xuICAgIHZhciByZWFzb24gPSByZXF1ZXN0SGlnaFF1YWxpdHkgPT09IHRydWUgPyBlbGVUeHJDYWNoZS5yZWFzb25zLmhpZ2hRdWFsaXR5IDogbnVsbDtcblxuICAgIGlmIChiYi53ID09PSAwIHx8IGJiLmggPT09IDAgfHwgIWVsZS52aXNpYmxlKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWV4dGVudCB8fCBib3VuZGluZ0JveGVzSW50ZXJzZWN0KGJiLCBleHRlbnQpKSB7XG4gICAgICB2YXIgaXNFZGdlID0gZWxlLmlzRWRnZSgpO1xuXG4gICAgICB2YXIgYmFkTGluZSA9IGVsZS5lbGVtZW50KCkuX3ByaXZhdGUucnNjcmF0Y2guYmFkTGluZTtcblxuICAgICAgci5kcmF3RWxlbWVudFVuZGVybGF5KGNvbnRleHQsIGVsZSk7XG4gICAgICByLmRyYXdDYWNoZWRFbGVtZW50UG9ydGlvbihjb250ZXh0LCBlbGUsIGVsZVR4ckNhY2hlLCBweFJhdGlvLCBsdmwsIHJlYXNvbiwgZ2V0WmVyb1JvdGF0aW9uLCBnZXRPcGFjaXR5KTtcblxuICAgICAgaWYgKCFpc0VkZ2UgfHwgIWJhZExpbmUpIHtcbiAgICAgICAgci5kcmF3Q2FjaGVkRWxlbWVudFBvcnRpb24oY29udGV4dCwgZWxlLCBsYmxUeHJDYWNoZSwgcHhSYXRpbywgbHZsLCByZWFzb24sIGdldExhYmVsUm90YXRpb24sIGdldFRleHRPcGFjaXR5KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRWRnZSAmJiAhYmFkTGluZSkge1xuICAgICAgICByLmRyYXdDYWNoZWRFbGVtZW50UG9ydGlvbihjb250ZXh0LCBlbGUsIHNsYlR4ckNhY2hlLCBweFJhdGlvLCBsdmwsIHJlYXNvbiwgZ2V0U291cmNlTGFiZWxSb3RhdGlvbiwgZ2V0VGV4dE9wYWNpdHkpO1xuICAgICAgICByLmRyYXdDYWNoZWRFbGVtZW50UG9ydGlvbihjb250ZXh0LCBlbGUsIHRsYlR4ckNhY2hlLCBweFJhdGlvLCBsdmwsIHJlYXNvbiwgZ2V0VGFyZ2V0TGFiZWxSb3RhdGlvbiwgZ2V0VGV4dE9wYWNpdHkpO1xuICAgICAgfVxuXG4gICAgICByLmRyYXdFbGVtZW50T3ZlcmxheShjb250ZXh0LCBlbGUpO1xuICAgIH1cbiAgfTtcblxuICBDUnAkOS5kcmF3RWxlbWVudHMgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlcykge1xuICAgIHZhciByID0gdGhpcztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICByLmRyYXdFbGVtZW50KGNvbnRleHQsIGVsZSk7XG4gICAgfVxuICB9O1xuXG4gIENScCQ5LmRyYXdDYWNoZWRFbGVtZW50cyA9IGZ1bmN0aW9uIChjb250ZXh0LCBlbGVzLCBweFJhdGlvLCBleHRlbnQpIHtcbiAgICB2YXIgciA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgci5kcmF3Q2FjaGVkRWxlbWVudChjb250ZXh0LCBlbGUsIHB4UmF0aW8sIGV4dGVudCk7XG4gICAgfVxuICB9O1xuXG4gIENScCQ5LmRyYXdDYWNoZWROb2RlcyA9IGZ1bmN0aW9uIChjb250ZXh0LCBlbGVzLCBweFJhdGlvLCBleHRlbnQpIHtcbiAgICB2YXIgciA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuXG4gICAgICBpZiAoIWVsZS5pc05vZGUoKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgci5kcmF3Q2FjaGVkRWxlbWVudChjb250ZXh0LCBlbGUsIHB4UmF0aW8sIGV4dGVudCk7XG4gICAgfVxuICB9O1xuXG4gIENScCQ5LmRyYXdMYXllcmVkRWxlbWVudHMgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlcywgcHhSYXRpbywgZXh0ZW50KSB7XG4gICAgdmFyIHIgPSB0aGlzO1xuICAgIHZhciBsYXllcnMgPSByLmRhdGEubHlyVHhyQ2FjaGUuZ2V0TGF5ZXJzKGVsZXMsIHB4UmF0aW8pO1xuXG4gICAgaWYgKGxheWVycykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGxheWVyID0gbGF5ZXJzW2ldO1xuICAgICAgICB2YXIgYmIgPSBsYXllci5iYjtcblxuICAgICAgICBpZiAoYmIudyA9PT0gMCB8fCBiYi5oID09PSAwKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShsYXllci5jYW52YXMsIGJiLngxLCBiYi55MSwgYmIudywgYmIuaCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGZhbGwgYmFjayBvbiBwbGFpbiBjYWNoaW5nIGlmIG5vIGxheWVyc1xuICAgICAgci5kcmF3Q2FjaGVkRWxlbWVudHMoY29udGV4dCwgZWxlcywgcHhSYXRpbywgZXh0ZW50KTtcbiAgICB9XG4gIH07XG5cbiAgLyogZ2xvYmFsIFBhdGgyRCAqL1xuICB2YXIgQ1JwJDggPSB7fTtcblxuICBDUnAkOC5kcmF3RWRnZSA9IGZ1bmN0aW9uIChjb250ZXh0LCBlZGdlLCBzaGlmdFRvT3JpZ2luV2l0aEJiKSB7XG4gICAgdmFyIGRyYXdMYWJlbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogdHJ1ZTtcbiAgICB2YXIgc2hvdWxkRHJhd092ZXJsYXkgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IHRydWU7XG4gICAgdmFyIHNob3VsZERyYXdPcGFjaXR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiB0cnVlO1xuICAgIHZhciByID0gdGhpcztcbiAgICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuXG4gICAgaWYgKHNob3VsZERyYXdPcGFjaXR5ICYmICFlZGdlLnZpc2libGUoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gaWYgYmV6aWVyIGN0cmwgcHRzIGNhbiBub3QgYmUgY2FsY3VsYXRlZCwgdGhlbiBkaWVcblxuXG4gICAgaWYgKHJzLmJhZExpbmUgfHwgcnMuYWxscHRzID09IG51bGwgfHwgaXNOYU4ocnMuYWxscHRzWzBdKSkge1xuICAgICAgLy8gaXNOYU4gaW4gY2FzZSBlZGdlIGlzIGltcG9zc2libGUgYW5kIGJyb3dzZXIgYnVncyAoZS5nLiBzYWZhcmkpXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGJiO1xuXG4gICAgaWYgKHNoaWZ0VG9PcmlnaW5XaXRoQmIpIHtcbiAgICAgIGJiID0gc2hpZnRUb09yaWdpbldpdGhCYjtcbiAgICAgIGNvbnRleHQudHJhbnNsYXRlKC1iYi54MSwgLWJiLnkxKTtcbiAgICB9XG5cbiAgICB2YXIgb3BhY2l0eSA9IHNob3VsZERyYXdPcGFjaXR5ID8gZWRnZS5wc3R5bGUoJ29wYWNpdHknKS52YWx1ZSA6IDE7XG4gICAgdmFyIGxpbmVPcGFjaXR5ID0gc2hvdWxkRHJhd09wYWNpdHkgPyBlZGdlLnBzdHlsZSgnbGluZS1vcGFjaXR5JykudmFsdWUgOiAxO1xuICAgIHZhciBjdXJ2ZVN0eWxlID0gZWRnZS5wc3R5bGUoJ2N1cnZlLXN0eWxlJykudmFsdWU7XG4gICAgdmFyIGxpbmVTdHlsZSA9IGVkZ2UucHN0eWxlKCdsaW5lLXN0eWxlJykudmFsdWU7XG4gICAgdmFyIGVkZ2VXaWR0aCA9IGVkZ2UucHN0eWxlKCd3aWR0aCcpLnBmVmFsdWU7XG4gICAgdmFyIGxpbmVDYXAgPSBlZGdlLnBzdHlsZSgnbGluZS1jYXAnKS52YWx1ZTtcbiAgICB2YXIgZWZmZWN0aXZlTGluZU9wYWNpdHkgPSBvcGFjaXR5ICogbGluZU9wYWNpdHk7IC8vIHNlcGFyYXRlIGFycm93IG9wYWNpdHkgd291bGQgcmVxdWlyZSBhcnJvdy1vcGFjaXR5IHByb3BlcnR5XG5cbiAgICB2YXIgZWZmZWN0aXZlQXJyb3dPcGFjaXR5ID0gb3BhY2l0eSAqIGxpbmVPcGFjaXR5O1xuXG4gICAgdmFyIGRyYXdMaW5lID0gZnVuY3Rpb24gZHJhd0xpbmUoKSB7XG4gICAgICB2YXIgc3Ryb2tlT3BhY2l0eSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZWZmZWN0aXZlTGluZU9wYWNpdHk7XG5cbiAgICAgIGlmIChjdXJ2ZVN0eWxlID09PSAnc3RyYWlnaHQtdHJpYW5nbGUnKSB7XG4gICAgICAgIHIuZWxlU3Ryb2tlU3R5bGUoY29udGV4dCwgZWRnZSwgc3Ryb2tlT3BhY2l0eSk7XG4gICAgICAgIHIuZHJhd0VkZ2VUcmlhbmdsZVBhdGgoZWRnZSwgY29udGV4dCwgcnMuYWxscHRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gZWRnZVdpZHRoO1xuICAgICAgICBjb250ZXh0LmxpbmVDYXAgPSBsaW5lQ2FwO1xuICAgICAgICByLmVsZVN0cm9rZVN0eWxlKGNvbnRleHQsIGVkZ2UsIHN0cm9rZU9wYWNpdHkpO1xuICAgICAgICByLmRyYXdFZGdlUGF0aChlZGdlLCBjb250ZXh0LCBycy5hbGxwdHMsIGxpbmVTdHlsZSk7XG4gICAgICAgIGNvbnRleHQubGluZUNhcCA9ICdidXR0JzsgLy8gcmVzZXQgZm9yIG90aGVyIGRyYXdpbmcgZnVuY3Rpb25zXG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBkcmF3T3ZlcmxheSA9IGZ1bmN0aW9uIGRyYXdPdmVybGF5KCkge1xuICAgICAgaWYgKCFzaG91bGREcmF3T3ZlcmxheSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHIuZHJhd0VkZ2VPdmVybGF5KGNvbnRleHQsIGVkZ2UpO1xuICAgIH07XG5cbiAgICB2YXIgZHJhd1VuZGVybGF5ID0gZnVuY3Rpb24gZHJhd1VuZGVybGF5KCkge1xuICAgICAgaWYgKCFzaG91bGREcmF3T3ZlcmxheSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHIuZHJhd0VkZ2VVbmRlcmxheShjb250ZXh0LCBlZGdlKTtcbiAgICB9O1xuXG4gICAgdmFyIGRyYXdBcnJvd3MgPSBmdW5jdGlvbiBkcmF3QXJyb3dzKCkge1xuICAgICAgdmFyIGFycm93T3BhY2l0eSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZWZmZWN0aXZlQXJyb3dPcGFjaXR5O1xuICAgICAgci5kcmF3QXJyb3doZWFkcyhjb250ZXh0LCBlZGdlLCBhcnJvd09wYWNpdHkpO1xuICAgIH07XG5cbiAgICB2YXIgZHJhd1RleHQgPSBmdW5jdGlvbiBkcmF3VGV4dCgpIHtcbiAgICAgIHIuZHJhd0VsZW1lbnRUZXh0KGNvbnRleHQsIGVkZ2UsIG51bGwsIGRyYXdMYWJlbCk7XG4gICAgfTtcblxuICAgIGNvbnRleHQubGluZUpvaW4gPSAncm91bmQnO1xuICAgIHZhciBnaG9zdCA9IGVkZ2UucHN0eWxlKCdnaG9zdCcpLnZhbHVlID09PSAneWVzJztcblxuICAgIGlmIChnaG9zdCkge1xuICAgICAgdmFyIGd4ID0gZWRnZS5wc3R5bGUoJ2dob3N0LW9mZnNldC14JykucGZWYWx1ZTtcbiAgICAgIHZhciBneSA9IGVkZ2UucHN0eWxlKCdnaG9zdC1vZmZzZXQteScpLnBmVmFsdWU7XG4gICAgICB2YXIgZ2hvc3RPcGFjaXR5ID0gZWRnZS5wc3R5bGUoJ2dob3N0LW9wYWNpdHknKS52YWx1ZTtcbiAgICAgIHZhciBlZmZlY3RpdmVHaG9zdE9wYWNpdHkgPSBlZmZlY3RpdmVMaW5lT3BhY2l0eSAqIGdob3N0T3BhY2l0eTtcbiAgICAgIGNvbnRleHQudHJhbnNsYXRlKGd4LCBneSk7XG4gICAgICBkcmF3TGluZShlZmZlY3RpdmVHaG9zdE9wYWNpdHkpO1xuICAgICAgZHJhd0Fycm93cyhlZmZlY3RpdmVHaG9zdE9wYWNpdHkpO1xuICAgICAgY29udGV4dC50cmFuc2xhdGUoLWd4LCAtZ3kpO1xuICAgIH1cblxuICAgIGRyYXdVbmRlcmxheSgpO1xuICAgIGRyYXdMaW5lKCk7XG4gICAgZHJhd0Fycm93cygpO1xuICAgIGRyYXdPdmVybGF5KCk7XG4gICAgZHJhd1RleHQoKTtcblxuICAgIGlmIChzaGlmdFRvT3JpZ2luV2l0aEJiKSB7XG4gICAgICBjb250ZXh0LnRyYW5zbGF0ZShiYi54MSwgYmIueTEpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgZHJhd0VkZ2VPdmVybGF5VW5kZXJsYXkgPSBmdW5jdGlvbiBkcmF3RWRnZU92ZXJsYXlVbmRlcmxheShvdmVybGF5T3JVbmRlcmxheSkge1xuICAgIGlmICghWydvdmVybGF5JywgJ3VuZGVybGF5J10uaW5jbHVkZXMob3ZlcmxheU9yVW5kZXJsYXkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RhdGUnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKGNvbnRleHQsIGVkZ2UpIHtcbiAgICAgIGlmICghZWRnZS52aXNpYmxlKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3BhY2l0eSA9IGVkZ2UucHN0eWxlKFwiXCIuY29uY2F0KG92ZXJsYXlPclVuZGVybGF5LCBcIi1vcGFjaXR5XCIpKS52YWx1ZTtcblxuICAgICAgaWYgKG9wYWNpdHkgPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgciA9IHRoaXM7XG4gICAgICB2YXIgdXNlUGF0aHMgPSByLnVzZVBhdGhzKCk7XG4gICAgICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICAgICAgdmFyIHBhZGRpbmcgPSBlZGdlLnBzdHlsZShcIlwiLmNvbmNhdChvdmVybGF5T3JVbmRlcmxheSwgXCItcGFkZGluZ1wiKSkucGZWYWx1ZTtcbiAgICAgIHZhciB3aWR0aCA9IDIgKiBwYWRkaW5nO1xuICAgICAgdmFyIGNvbG9yID0gZWRnZS5wc3R5bGUoXCJcIi5jb25jYXQob3ZlcmxheU9yVW5kZXJsYXksIFwiLWNvbG9yXCIpKS52YWx1ZTtcbiAgICAgIGNvbnRleHQubGluZVdpZHRoID0gd2lkdGg7XG5cbiAgICAgIGlmIChycy5lZGdlVHlwZSA9PT0gJ3NlbGYnICYmICF1c2VQYXRocykge1xuICAgICAgICBjb250ZXh0LmxpbmVDYXAgPSAnYnV0dCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZXh0LmxpbmVDYXAgPSAncm91bmQnO1xuICAgICAgfVxuXG4gICAgICByLmNvbG9yU3Ryb2tlU3R5bGUoY29udGV4dCwgY29sb3JbMF0sIGNvbG9yWzFdLCBjb2xvclsyXSwgb3BhY2l0eSk7XG4gICAgICByLmRyYXdFZGdlUGF0aChlZGdlLCBjb250ZXh0LCBycy5hbGxwdHMsICdzb2xpZCcpO1xuICAgIH07XG4gIH07XG5cbiAgQ1JwJDguZHJhd0VkZ2VPdmVybGF5ID0gZHJhd0VkZ2VPdmVybGF5VW5kZXJsYXkoJ292ZXJsYXknKTtcbiAgQ1JwJDguZHJhd0VkZ2VVbmRlcmxheSA9IGRyYXdFZGdlT3ZlcmxheVVuZGVybGF5KCd1bmRlcmxheScpO1xuXG4gIENScCQ4LmRyYXdFZGdlUGF0aCA9IGZ1bmN0aW9uIChlZGdlLCBjb250ZXh0LCBwdHMsIHR5cGUpIHtcbiAgICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICAgIHZhciBjYW52YXNDeHQgPSBjb250ZXh0O1xuICAgIHZhciBwYXRoO1xuICAgIHZhciBwYXRoQ2FjaGVIaXQgPSBmYWxzZTtcbiAgICB2YXIgdXNlUGF0aHMgPSB0aGlzLnVzZVBhdGhzKCk7XG4gICAgdmFyIGxpbmVEYXNoUGF0dGVybiA9IGVkZ2UucHN0eWxlKCdsaW5lLWRhc2gtcGF0dGVybicpLnBmVmFsdWU7XG4gICAgdmFyIGxpbmVEYXNoT2Zmc2V0ID0gZWRnZS5wc3R5bGUoJ2xpbmUtZGFzaC1vZmZzZXQnKS5wZlZhbHVlO1xuXG4gICAgaWYgKHVzZVBhdGhzKSB7XG4gICAgICB2YXIgcGF0aENhY2hlS2V5ID0gcHRzLmpvaW4oJyQnKTtcbiAgICAgIHZhciBrZXlNYXRjaGVzID0gcnMucGF0aENhY2hlS2V5ICYmIHJzLnBhdGhDYWNoZUtleSA9PT0gcGF0aENhY2hlS2V5O1xuXG4gICAgICBpZiAoa2V5TWF0Y2hlcykge1xuICAgICAgICBwYXRoID0gY29udGV4dCA9IHJzLnBhdGhDYWNoZTtcbiAgICAgICAgcGF0aENhY2hlSGl0ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdGggPSBjb250ZXh0ID0gbmV3IFBhdGgyRCgpO1xuICAgICAgICBycy5wYXRoQ2FjaGVLZXkgPSBwYXRoQ2FjaGVLZXk7XG4gICAgICAgIHJzLnBhdGhDYWNoZSA9IHBhdGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNhbnZhc0N4dC5zZXRMaW5lRGFzaCkge1xuICAgICAgLy8gZm9yIHZlcnkgb3V0b2ZkYXRlIGJyb3dzZXJzXG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnZG90dGVkJzpcbiAgICAgICAgICBjYW52YXNDeHQuc2V0TGluZURhc2goWzEsIDFdKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdkYXNoZWQnOlxuICAgICAgICAgIGNhbnZhc0N4dC5zZXRMaW5lRGFzaChsaW5lRGFzaFBhdHRlcm4pO1xuICAgICAgICAgIGNhbnZhc0N4dC5saW5lRGFzaE9mZnNldCA9IGxpbmVEYXNoT2Zmc2V0O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3NvbGlkJzpcbiAgICAgICAgICBjYW52YXNDeHQuc2V0TGluZURhc2goW10pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghcGF0aENhY2hlSGl0ICYmICFycy5iYWRMaW5lKSB7XG4gICAgICBpZiAoY29udGV4dC5iZWdpblBhdGgpIHtcbiAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5tb3ZlVG8ocHRzWzBdLCBwdHNbMV0pO1xuXG4gICAgICBzd2l0Y2ggKHJzLmVkZ2VUeXBlKSB7XG4gICAgICAgIGNhc2UgJ2Jlemllcic6XG4gICAgICAgIGNhc2UgJ3NlbGYnOlxuICAgICAgICBjYXNlICdjb21wb3VuZCc6XG4gICAgICAgIGNhc2UgJ211bHRpYmV6aWVyJzpcbiAgICAgICAgICBmb3IgKHZhciBpID0gMjsgaSArIDMgPCBwdHMubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgICAgICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyhwdHNbaV0sIHB0c1tpICsgMV0sIHB0c1tpICsgMl0sIHB0c1tpICsgM10pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3N0cmFpZ2h0JzpcbiAgICAgICAgY2FzZSAnc2VnbWVudHMnOlxuICAgICAgICBjYXNlICdoYXlzdGFjayc6XG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAyOyBfaSArIDEgPCBwdHMubGVuZ3RoOyBfaSArPSAyKSB7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhwdHNbX2ldLCBwdHNbX2kgKyAxXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29udGV4dCA9IGNhbnZhc0N4dDtcblxuICAgIGlmICh1c2VQYXRocykge1xuICAgICAgY29udGV4dC5zdHJva2UocGF0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgfSAvLyByZXNldCBhbnkgbGluZSBkYXNoZXNcblxuXG4gICAgaWYgKGNvbnRleHQuc2V0TGluZURhc2gpIHtcbiAgICAgIC8vIGZvciB2ZXJ5IG91dG9mZGF0ZSBicm93c2Vyc1xuICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChbXSk7XG4gICAgfVxuICB9O1xuXG4gIENScCQ4LmRyYXdFZGdlVHJpYW5nbGVQYXRoID0gZnVuY3Rpb24gKGVkZ2UsIGNvbnRleHQsIHB0cykge1xuICAgIC8vIHVzZSBsaW5lIHN0cm9rZSBzdHlsZSBmb3IgdHJpYW5nbGUgZmlsbCBzdHlsZVxuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gY29udGV4dC5zdHJva2VTdHlsZTtcbiAgICB2YXIgZWRnZVdpZHRoID0gZWRnZS5wc3R5bGUoJ3dpZHRoJykucGZWYWx1ZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpICsgMSA8IHB0cy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgdmFyIHZlY3RvciA9IFtwdHNbaSArIDJdIC0gcHRzW2ldLCBwdHNbaSArIDNdIC0gcHRzW2kgKyAxXV07XG4gICAgICB2YXIgbGVuZ3RoID0gTWF0aC5zcXJ0KHZlY3RvclswXSAqIHZlY3RvclswXSArIHZlY3RvclsxXSAqIHZlY3RvclsxXSk7XG4gICAgICB2YXIgbm9ybWFsID0gW3ZlY3RvclsxXSAvIGxlbmd0aCwgLXZlY3RvclswXSAvIGxlbmd0aF07XG4gICAgICB2YXIgdHJpYW5nbGVIZWFkID0gW25vcm1hbFswXSAqIGVkZ2VXaWR0aCAvIDIsIG5vcm1hbFsxXSAqIGVkZ2VXaWR0aCAvIDJdO1xuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgIGNvbnRleHQubW92ZVRvKHB0c1tpXSAtIHRyaWFuZ2xlSGVhZFswXSwgcHRzW2kgKyAxXSAtIHRyaWFuZ2xlSGVhZFsxXSk7XG4gICAgICBjb250ZXh0LmxpbmVUbyhwdHNbaV0gKyB0cmlhbmdsZUhlYWRbMF0sIHB0c1tpICsgMV0gKyB0cmlhbmdsZUhlYWRbMV0pO1xuICAgICAgY29udGV4dC5saW5lVG8ocHRzW2kgKyAyXSwgcHRzW2kgKyAzXSk7XG4gICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgfVxuICB9O1xuXG4gIENScCQ4LmRyYXdBcnJvd2hlYWRzID0gZnVuY3Rpb24gKGNvbnRleHQsIGVkZ2UsIG9wYWNpdHkpIHtcbiAgICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICAgIHZhciBpc0hheXN0YWNrID0gcnMuZWRnZVR5cGUgPT09ICdoYXlzdGFjayc7XG5cbiAgICBpZiAoIWlzSGF5c3RhY2spIHtcbiAgICAgIHRoaXMuZHJhd0Fycm93aGVhZChjb250ZXh0LCBlZGdlLCAnc291cmNlJywgcnMuYXJyb3dTdGFydFgsIHJzLmFycm93U3RhcnRZLCBycy5zcmNBcnJvd0FuZ2xlLCBvcGFjaXR5KTtcbiAgICB9XG5cbiAgICB0aGlzLmRyYXdBcnJvd2hlYWQoY29udGV4dCwgZWRnZSwgJ21pZC10YXJnZXQnLCBycy5taWRYLCBycy5taWRZLCBycy5taWR0Z3RBcnJvd0FuZ2xlLCBvcGFjaXR5KTtcbiAgICB0aGlzLmRyYXdBcnJvd2hlYWQoY29udGV4dCwgZWRnZSwgJ21pZC1zb3VyY2UnLCBycy5taWRYLCBycy5taWRZLCBycy5taWRzcmNBcnJvd0FuZ2xlLCBvcGFjaXR5KTtcblxuICAgIGlmICghaXNIYXlzdGFjaykge1xuICAgICAgdGhpcy5kcmF3QXJyb3doZWFkKGNvbnRleHQsIGVkZ2UsICd0YXJnZXQnLCBycy5hcnJvd0VuZFgsIHJzLmFycm93RW5kWSwgcnMudGd0QXJyb3dBbmdsZSwgb3BhY2l0eSk7XG4gICAgfVxuICB9O1xuXG4gIENScCQ4LmRyYXdBcnJvd2hlYWQgPSBmdW5jdGlvbiAoY29udGV4dCwgZWRnZSwgcHJlZml4LCB4LCB5LCBhbmdsZSwgb3BhY2l0eSkge1xuICAgIGlmIChpc05hTih4KSB8fCB4ID09IG51bGwgfHwgaXNOYU4oeSkgfHwgeSA9PSBudWxsIHx8IGlzTmFOKGFuZ2xlKSB8fCBhbmdsZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBhcnJvd1NoYXBlID0gZWRnZS5wc3R5bGUocHJlZml4ICsgJy1hcnJvdy1zaGFwZScpLnZhbHVlO1xuXG4gICAgaWYgKGFycm93U2hhcGUgPT09ICdub25lJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBhcnJvd0NsZWFyRmlsbCA9IGVkZ2UucHN0eWxlKHByZWZpeCArICctYXJyb3ctZmlsbCcpLnZhbHVlID09PSAnaG9sbG93JyA/ICdib3RoJyA6ICdmaWxsZWQnO1xuICAgIHZhciBhcnJvd0ZpbGwgPSBlZGdlLnBzdHlsZShwcmVmaXggKyAnLWFycm93LWZpbGwnKS52YWx1ZTtcbiAgICB2YXIgZWRnZVdpZHRoID0gZWRnZS5wc3R5bGUoJ3dpZHRoJykucGZWYWx1ZTtcbiAgICB2YXIgZWRnZU9wYWNpdHkgPSBlZGdlLnBzdHlsZSgnb3BhY2l0eScpLnZhbHVlO1xuXG4gICAgaWYgKG9wYWNpdHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgb3BhY2l0eSA9IGVkZ2VPcGFjaXR5O1xuICAgIH1cblxuICAgIHZhciBnY28gPSBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbjtcblxuICAgIGlmIChvcGFjaXR5ICE9PSAxIHx8IGFycm93RmlsbCA9PT0gJ2hvbGxvdycpIHtcbiAgICAgIC8vIHRoZW4gZXh0cmEgY2xlYXIgaXMgbmVlZGVkXG4gICAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdkZXN0aW5hdGlvbi1vdXQnO1xuICAgICAgc2VsZi5jb2xvckZpbGxTdHlsZShjb250ZXh0LCAyNTUsIDI1NSwgMjU1LCAxKTtcbiAgICAgIHNlbGYuY29sb3JTdHJva2VTdHlsZShjb250ZXh0LCAyNTUsIDI1NSwgMjU1LCAxKTtcbiAgICAgIHNlbGYuZHJhd0Fycm93U2hhcGUoZWRnZSwgY29udGV4dCwgYXJyb3dDbGVhckZpbGwsIGVkZ2VXaWR0aCwgYXJyb3dTaGFwZSwgeCwgeSwgYW5nbGUpO1xuICAgICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBnY287XG4gICAgfSAvLyBvdGhlcndpc2UsIHRoZSBvcGFxdWUgYXJyb3cgY2xlYXJzIGl0IGZvciBmcmVlIDopXG5cblxuICAgIHZhciBjb2xvciA9IGVkZ2UucHN0eWxlKHByZWZpeCArICctYXJyb3ctY29sb3InKS52YWx1ZTtcbiAgICBzZWxmLmNvbG9yRmlsbFN0eWxlKGNvbnRleHQsIGNvbG9yWzBdLCBjb2xvclsxXSwgY29sb3JbMl0sIG9wYWNpdHkpO1xuICAgIHNlbGYuY29sb3JTdHJva2VTdHlsZShjb250ZXh0LCBjb2xvclswXSwgY29sb3JbMV0sIGNvbG9yWzJdLCBvcGFjaXR5KTtcbiAgICBzZWxmLmRyYXdBcnJvd1NoYXBlKGVkZ2UsIGNvbnRleHQsIGFycm93RmlsbCwgZWRnZVdpZHRoLCBhcnJvd1NoYXBlLCB4LCB5LCBhbmdsZSk7XG4gIH07XG5cbiAgQ1JwJDguZHJhd0Fycm93U2hhcGUgPSBmdW5jdGlvbiAoZWRnZSwgY29udGV4dCwgZmlsbCwgZWRnZVdpZHRoLCBzaGFwZSwgeCwgeSwgYW5nbGUpIHtcbiAgICB2YXIgciA9IHRoaXM7XG4gICAgdmFyIHVzZVBhdGhzID0gdGhpcy51c2VQYXRocygpICYmIHNoYXBlICE9PSAndHJpYW5nbGUtY3Jvc3MnO1xuICAgIHZhciBwYXRoQ2FjaGVIaXQgPSBmYWxzZTtcbiAgICB2YXIgcGF0aDtcbiAgICB2YXIgY2FudmFzQ29udGV4dCA9IGNvbnRleHQ7XG4gICAgdmFyIHRyYW5zbGF0aW9uID0ge1xuICAgICAgeDogeCxcbiAgICAgIHk6IHlcbiAgICB9O1xuICAgIHZhciBzY2FsZSA9IGVkZ2UucHN0eWxlKCdhcnJvdy1zY2FsZScpLnZhbHVlO1xuICAgIHZhciBzaXplID0gdGhpcy5nZXRBcnJvd1dpZHRoKGVkZ2VXaWR0aCwgc2NhbGUpO1xuICAgIHZhciBzaGFwZUltcGwgPSByLmFycm93U2hhcGVzW3NoYXBlXTtcblxuICAgIGlmICh1c2VQYXRocykge1xuICAgICAgdmFyIGNhY2hlID0gci5hcnJvd1BhdGhDYWNoZSA9IHIuYXJyb3dQYXRoQ2FjaGUgfHwgW107XG4gICAgICB2YXIga2V5ID0gaGFzaFN0cmluZyhzaGFwZSk7XG4gICAgICB2YXIgY2FjaGVkUGF0aCA9IGNhY2hlW2tleV07XG5cbiAgICAgIGlmIChjYWNoZWRQYXRoICE9IG51bGwpIHtcbiAgICAgICAgcGF0aCA9IGNvbnRleHQgPSBjYWNoZWRQYXRoO1xuICAgICAgICBwYXRoQ2FjaGVIaXQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGF0aCA9IGNvbnRleHQgPSBuZXcgUGF0aDJEKCk7XG4gICAgICAgIGNhY2hlW2tleV0gPSBwYXRoO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghcGF0aENhY2hlSGl0KSB7XG4gICAgICBpZiAoY29udGV4dC5iZWdpblBhdGgpIHtcbiAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHVzZVBhdGhzKSB7XG4gICAgICAgIC8vIHN0b3JlIGluIHRoZSBwYXRoIGNhY2hlIHdpdGggdmFsdWVzIGVhc2lseSBtYW5pcHVsYXRlZCBsYXRlclxuICAgICAgICBzaGFwZUltcGwuZHJhdyhjb250ZXh0LCAxLCAwLCB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH0sIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2hhcGVJbXBsLmRyYXcoY29udGV4dCwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uLCBlZGdlV2lkdGgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29udGV4dC5jbG9zZVBhdGgpIHtcbiAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb250ZXh0ID0gY2FudmFzQ29udGV4dDtcblxuICAgIGlmICh1c2VQYXRocykge1xuICAgICAgLy8gc2V0IHRyYW5zZm9ybSB0byBhcnJvdyBwb3NpdGlvbi9vcmllbnRhdGlvblxuICAgICAgY29udGV4dC50cmFuc2xhdGUoeCwgeSk7XG4gICAgICBjb250ZXh0LnJvdGF0ZShhbmdsZSk7XG4gICAgICBjb250ZXh0LnNjYWxlKHNpemUsIHNpemUpO1xuICAgIH1cblxuICAgIGlmIChmaWxsID09PSAnZmlsbGVkJyB8fCBmaWxsID09PSAnYm90aCcpIHtcbiAgICAgIGlmICh1c2VQYXRocykge1xuICAgICAgICBjb250ZXh0LmZpbGwocGF0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZmlsbCA9PT0gJ2hvbGxvdycgfHwgZmlsbCA9PT0gJ2JvdGgnKSB7XG4gICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IChzaGFwZUltcGwubWF0Y2hFZGdlV2lkdGggPyBlZGdlV2lkdGggOiAxKSAvICh1c2VQYXRocyA/IHNpemUgOiAxKTtcbiAgICAgIGNvbnRleHQubGluZUpvaW4gPSAnbWl0ZXInO1xuXG4gICAgICBpZiAodXNlUGF0aHMpIHtcbiAgICAgICAgY29udGV4dC5zdHJva2UocGF0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh1c2VQYXRocykge1xuICAgICAgLy8gcmVzZXQgdHJhbnNmb3JtIGJ5IGFwcGx5aW5nIGludmVyc2VcbiAgICAgIGNvbnRleHQuc2NhbGUoMSAvIHNpemUsIDEgLyBzaXplKTtcbiAgICAgIGNvbnRleHQucm90YXRlKC1hbmdsZSk7XG4gICAgICBjb250ZXh0LnRyYW5zbGF0ZSgteCwgLXkpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgQ1JwJDcgPSB7fTtcblxuICBDUnAkNy5zYWZlRHJhd0ltYWdlID0gZnVuY3Rpb24gKGNvbnRleHQsIGltZywgaXgsIGl5LCBpdywgaWgsIHgsIHksIHcsIGgpIHtcbiAgICAvLyBkZXRlY3QgcHJvYmxlbWF0aWMgY2FzZXMgZm9yIG9sZCBicm93c2VycyB3aXRoIGJhZCBpbWFnZXMgKGNoZWFwZXIgdGhhbiB0cnktY2F0Y2gpXG4gICAgaWYgKGl3IDw9IDAgfHwgaWggPD0gMCB8fCB3IDw9IDAgfHwgaCA8PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGltZywgaXgsIGl5LCBpdywgaWgsIHgsIHksIHcsIGgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHdhcm4oZSk7XG4gICAgfVxuICB9O1xuXG4gIENScCQ3LmRyYXdJbnNjcmliZWRJbWFnZSA9IGZ1bmN0aW9uIChjb250ZXh0LCBpbWcsIG5vZGUsIGluZGV4LCBub2RlT3BhY2l0eSkge1xuICAgIHZhciByID0gdGhpcztcbiAgICB2YXIgcG9zID0gbm9kZS5wb3NpdGlvbigpO1xuICAgIHZhciBub2RlWCA9IHBvcy54O1xuICAgIHZhciBub2RlWSA9IHBvcy55O1xuICAgIHZhciBzdHlsZU9iaiA9IG5vZGUuY3koKS5zdHlsZSgpO1xuICAgIHZhciBnZXRJbmRleGVkU3R5bGUgPSBzdHlsZU9iai5nZXRJbmRleGVkU3R5bGUuYmluZChzdHlsZU9iaik7XG4gICAgdmFyIGZpdCA9IGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1maXQnLCAndmFsdWUnLCBpbmRleCk7XG4gICAgdmFyIHJlcGVhdCA9IGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1yZXBlYXQnLCAndmFsdWUnLCBpbmRleCk7XG4gICAgdmFyIG5vZGVXID0gbm9kZS53aWR0aCgpO1xuICAgIHZhciBub2RlSCA9IG5vZGUuaGVpZ2h0KCk7XG4gICAgdmFyIHBhZGRpbmdYMiA9IG5vZGUucGFkZGluZygpICogMjtcbiAgICB2YXIgbm9kZVRXID0gbm9kZVcgKyAoZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLXdpZHRoLXJlbGF0aXZlLXRvJywgJ3ZhbHVlJywgaW5kZXgpID09PSAnaW5uZXInID8gMCA6IHBhZGRpbmdYMik7XG4gICAgdmFyIG5vZGVUSCA9IG5vZGVIICsgKGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1oZWlnaHQtcmVsYXRpdmUtdG8nLCAndmFsdWUnLCBpbmRleCkgPT09ICdpbm5lcicgPyAwIDogcGFkZGluZ1gyKTtcbiAgICB2YXIgcnMgPSBub2RlLl9wcml2YXRlLnJzY3JhdGNoO1xuICAgIHZhciBjbGlwID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLWNsaXAnLCAndmFsdWUnLCBpbmRleCk7XG4gICAgdmFyIHNob3VsZENsaXAgPSBjbGlwID09PSAnbm9kZSc7XG4gICAgdmFyIGltZ09wYWNpdHkgPSBnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtaW1hZ2Utb3BhY2l0eScsICd2YWx1ZScsIGluZGV4KSAqIG5vZGVPcGFjaXR5O1xuICAgIHZhciBzbW9vdGggPSBnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtaW1hZ2Utc21vb3RoaW5nJywgJ3ZhbHVlJywgaW5kZXgpO1xuICAgIHZhciBpbWdXID0gaW1nLndpZHRoIHx8IGltZy5jYWNoZWRXO1xuICAgIHZhciBpbWdIID0gaW1nLmhlaWdodCB8fCBpbWcuY2FjaGVkSDsgLy8gd29ya2Fyb3VuZCBmb3IgYnJva2VuIGJyb3dzZXJzIGxpa2UgaWVcblxuICAgIGlmIChudWxsID09IGltZ1cgfHwgbnVsbCA9PSBpbWdIKSB7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGltZyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuICAgICAgaW1nVyA9IGltZy5jYWNoZWRXID0gaW1nLndpZHRoIHx8IGltZy5vZmZzZXRXaWR0aDtcbiAgICAgIGltZ0ggPSBpbWcuY2FjaGVkSCA9IGltZy5oZWlnaHQgfHwgaW1nLm9mZnNldEhlaWdodDtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoaW1nKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgIH1cblxuICAgIHZhciB3ID0gaW1nVztcbiAgICB2YXIgaCA9IGltZ0g7XG5cbiAgICBpZiAoZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLXdpZHRoJywgJ3ZhbHVlJywgaW5kZXgpICE9PSAnYXV0bycpIHtcbiAgICAgIGlmIChnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtd2lkdGgnLCAndW5pdHMnLCBpbmRleCkgPT09ICclJykge1xuICAgICAgICB3ID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLXdpZHRoJywgJ3BmVmFsdWUnLCBpbmRleCkgKiBub2RlVFc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3ID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLXdpZHRoJywgJ3BmVmFsdWUnLCBpbmRleCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1oZWlnaHQnLCAndmFsdWUnLCBpbmRleCkgIT09ICdhdXRvJykge1xuICAgICAgaWYgKGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1oZWlnaHQnLCAndW5pdHMnLCBpbmRleCkgPT09ICclJykge1xuICAgICAgICBoID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLWhlaWdodCcsICdwZlZhbHVlJywgaW5kZXgpICogbm9kZVRIO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaCA9IGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1oZWlnaHQnLCAncGZWYWx1ZScsIGluZGV4KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodyA9PT0gMCB8fCBoID09PSAwKSB7XG4gICAgICByZXR1cm47IC8vIG5vIHBvaW50IGluIGRyYXdpbmcgZW1wdHkgaW1hZ2UgKGFuZCBjaHJvbWUgaXMgYnJva2VuIGluIHRoaXMgY2FzZSlcbiAgICB9XG5cbiAgICBpZiAoZml0ID09PSAnY29udGFpbicpIHtcbiAgICAgIHZhciBzY2FsZSA9IE1hdGgubWluKG5vZGVUVyAvIHcsIG5vZGVUSCAvIGgpO1xuICAgICAgdyAqPSBzY2FsZTtcbiAgICAgIGggKj0gc2NhbGU7XG4gICAgfSBlbHNlIGlmIChmaXQgPT09ICdjb3ZlcicpIHtcbiAgICAgIHZhciBzY2FsZSA9IE1hdGgubWF4KG5vZGVUVyAvIHcsIG5vZGVUSCAvIGgpO1xuICAgICAgdyAqPSBzY2FsZTtcbiAgICAgIGggKj0gc2NhbGU7XG4gICAgfVxuXG4gICAgdmFyIHggPSBub2RlWCAtIG5vZGVUVyAvIDI7IC8vIGxlZnRcblxuICAgIHZhciBwb3NYVW5pdHMgPSBnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtcG9zaXRpb24teCcsICd1bml0cycsIGluZGV4KTtcbiAgICB2YXIgcG9zWFBmVmFsID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLXBvc2l0aW9uLXgnLCAncGZWYWx1ZScsIGluZGV4KTtcblxuICAgIGlmIChwb3NYVW5pdHMgPT09ICclJykge1xuICAgICAgeCArPSAobm9kZVRXIC0gdykgKiBwb3NYUGZWYWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHggKz0gcG9zWFBmVmFsO1xuICAgIH1cblxuICAgIHZhciBvZmZYVW5pdHMgPSBnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtb2Zmc2V0LXgnLCAndW5pdHMnLCBpbmRleCk7XG4gICAgdmFyIG9mZlhQZlZhbCA9IGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1vZmZzZXQteCcsICdwZlZhbHVlJywgaW5kZXgpO1xuXG4gICAgaWYgKG9mZlhVbml0cyA9PT0gJyUnKSB7XG4gICAgICB4ICs9IChub2RlVFcgLSB3KSAqIG9mZlhQZlZhbDtcbiAgICB9IGVsc2Uge1xuICAgICAgeCArPSBvZmZYUGZWYWw7XG4gICAgfVxuXG4gICAgdmFyIHkgPSBub2RlWSAtIG5vZGVUSCAvIDI7IC8vIHRvcFxuXG4gICAgdmFyIHBvc1lVbml0cyA9IGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1wb3NpdGlvbi15JywgJ3VuaXRzJywgaW5kZXgpO1xuICAgIHZhciBwb3NZUGZWYWwgPSBnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtcG9zaXRpb24teScsICdwZlZhbHVlJywgaW5kZXgpO1xuXG4gICAgaWYgKHBvc1lVbml0cyA9PT0gJyUnKSB7XG4gICAgICB5ICs9IChub2RlVEggLSBoKSAqIHBvc1lQZlZhbDtcbiAgICB9IGVsc2Uge1xuICAgICAgeSArPSBwb3NZUGZWYWw7XG4gICAgfVxuXG4gICAgdmFyIG9mZllVbml0cyA9IGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1vZmZzZXQteScsICd1bml0cycsIGluZGV4KTtcbiAgICB2YXIgb2ZmWVBmVmFsID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLW9mZnNldC15JywgJ3BmVmFsdWUnLCBpbmRleCk7XG5cbiAgICBpZiAob2ZmWVVuaXRzID09PSAnJScpIHtcbiAgICAgIHkgKz0gKG5vZGVUSCAtIGgpICogb2ZmWVBmVmFsO1xuICAgIH0gZWxzZSB7XG4gICAgICB5ICs9IG9mZllQZlZhbDtcbiAgICB9XG5cbiAgICBpZiAocnMucGF0aENhY2hlKSB7XG4gICAgICB4IC09IG5vZGVYO1xuICAgICAgeSAtPSBub2RlWTtcbiAgICAgIG5vZGVYID0gMDtcbiAgICAgIG5vZGVZID0gMDtcbiAgICB9XG5cbiAgICB2YXIgZ0FscGhhID0gY29udGV4dC5nbG9iYWxBbHBoYTtcbiAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gaW1nT3BhY2l0eTtcbiAgICB2YXIgc21vb3RoaW5nRW5hYmxlZCA9IHIuZ2V0SW1nU21vb3RoaW5nKGNvbnRleHQpO1xuICAgIHZhciBpc1Ntb290aGluZ1N3aXRjaGVkID0gZmFsc2U7XG5cbiAgICBpZiAoc21vb3RoID09PSAnbm8nICYmIHNtb290aGluZ0VuYWJsZWQpIHtcbiAgICAgIHIuc2V0SW1nU21vb3RoaW5nKGNvbnRleHQsIGZhbHNlKTtcbiAgICAgIGlzU21vb3RoaW5nU3dpdGNoZWQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoc21vb3RoID09PSAneWVzJyAmJiAhc21vb3RoaW5nRW5hYmxlZCkge1xuICAgICAgci5zZXRJbWdTbW9vdGhpbmcoY29udGV4dCwgdHJ1ZSk7XG4gICAgICBpc1Ntb290aGluZ1N3aXRjaGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAocmVwZWF0ID09PSAnbm8tcmVwZWF0Jykge1xuICAgICAgaWYgKHNob3VsZENsaXApIHtcbiAgICAgICAgY29udGV4dC5zYXZlKCk7XG5cbiAgICAgICAgaWYgKHJzLnBhdGhDYWNoZSkge1xuICAgICAgICAgIGNvbnRleHQuY2xpcChycy5wYXRoQ2FjaGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHIubm9kZVNoYXBlc1tyLmdldE5vZGVTaGFwZShub2RlKV0uZHJhdyhjb250ZXh0LCBub2RlWCwgbm9kZVksIG5vZGVUVywgbm9kZVRIKTtcbiAgICAgICAgICBjb250ZXh0LmNsaXAoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByLnNhZmVEcmF3SW1hZ2UoY29udGV4dCwgaW1nLCAwLCAwLCBpbWdXLCBpbWdILCB4LCB5LCB3LCBoKTtcblxuICAgICAgaWYgKHNob3VsZENsaXApIHtcbiAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwYXR0ZXJuID0gY29udGV4dC5jcmVhdGVQYXR0ZXJuKGltZywgcmVwZWF0KTtcbiAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gcGF0dGVybjtcbiAgICAgIHIubm9kZVNoYXBlc1tyLmdldE5vZGVTaGFwZShub2RlKV0uZHJhdyhjb250ZXh0LCBub2RlWCwgbm9kZVksIG5vZGVUVywgbm9kZVRIKTtcbiAgICAgIGNvbnRleHQudHJhbnNsYXRlKHgsIHkpO1xuICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgICBjb250ZXh0LnRyYW5zbGF0ZSgteCwgLXkpO1xuICAgIH1cblxuICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSBnQWxwaGE7XG5cbiAgICBpZiAoaXNTbW9vdGhpbmdTd2l0Y2hlZCkge1xuICAgICAgci5zZXRJbWdTbW9vdGhpbmcoY29udGV4dCwgc21vb3RoaW5nRW5hYmxlZCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBDUnAkNiA9IHt9O1xuXG4gIENScCQ2LmVsZVRleHRCaWdnZXJUaGFuTWluID0gZnVuY3Rpb24gKGVsZSwgc2NhbGUpIHtcbiAgICBpZiAoIXNjYWxlKSB7XG4gICAgICB2YXIgem9vbSA9IGVsZS5jeSgpLnpvb20oKTtcbiAgICAgIHZhciBweFJhdGlvID0gdGhpcy5nZXRQaXhlbFJhdGlvKCk7XG4gICAgICB2YXIgbHZsID0gTWF0aC5jZWlsKGxvZzIoem9vbSAqIHB4UmF0aW8pKTsgLy8gdGhlIGVmZmVjdGl2ZSB0ZXh0dXJlIGxldmVsXG5cbiAgICAgIHNjYWxlID0gTWF0aC5wb3coMiwgbHZsKTtcbiAgICB9XG5cbiAgICB2YXIgY29tcHV0ZWRTaXplID0gZWxlLnBzdHlsZSgnZm9udC1zaXplJykucGZWYWx1ZSAqIHNjYWxlO1xuICAgIHZhciBtaW5TaXplID0gZWxlLnBzdHlsZSgnbWluLXpvb21lZC1mb250LXNpemUnKS5wZlZhbHVlO1xuXG4gICAgaWYgKGNvbXB1dGVkU2l6ZSA8IG1pblNpemUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBDUnAkNi5kcmF3RWxlbWVudFRleHQgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlLCBzaGlmdFRvT3JpZ2luV2l0aEJiLCBmb3JjZSwgcHJlZml4KSB7XG4gICAgdmFyIHVzZUVsZU9wYWNpdHkgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IHRydWU7XG4gICAgdmFyIHIgPSB0aGlzO1xuXG4gICAgaWYgKGZvcmNlID09IG51bGwpIHtcbiAgICAgIGlmICh1c2VFbGVPcGFjaXR5ICYmICFyLmVsZVRleHRCaWdnZXJUaGFuTWluKGVsZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZm9yY2UgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgdmFyIGxhYmVsID0gZWxlLnBzdHlsZSgnbGFiZWwnKTtcblxuICAgICAgaWYgKCFsYWJlbCB8fCAhbGFiZWwudmFsdWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIganVzdGlmaWNhdGlvbiA9IHIuZ2V0TGFiZWxKdXN0aWZpY2F0aW9uKGVsZSk7XG4gICAgICBjb250ZXh0LnRleHRBbGlnbiA9IGp1c3RpZmljYXRpb247XG4gICAgICBjb250ZXh0LnRleHRCYXNlbGluZSA9ICdib3R0b20nO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYmFkTGluZSA9IGVsZS5lbGVtZW50KCkuX3ByaXZhdGUucnNjcmF0Y2guYmFkTGluZTtcblxuICAgICAgdmFyIF9sYWJlbCA9IGVsZS5wc3R5bGUoJ2xhYmVsJyk7XG5cbiAgICAgIHZhciBzcmNMYWJlbCA9IGVsZS5wc3R5bGUoJ3NvdXJjZS1sYWJlbCcpO1xuICAgICAgdmFyIHRndExhYmVsID0gZWxlLnBzdHlsZSgndGFyZ2V0LWxhYmVsJyk7XG5cbiAgICAgIGlmIChiYWRMaW5lIHx8ICghX2xhYmVsIHx8ICFfbGFiZWwudmFsdWUpICYmICghc3JjTGFiZWwgfHwgIXNyY0xhYmVsLnZhbHVlKSAmJiAoIXRndExhYmVsIHx8ICF0Z3RMYWJlbC52YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgY29udGV4dC50ZXh0QmFzZWxpbmUgPSAnYm90dG9tJztcbiAgICB9XG5cbiAgICB2YXIgYXBwbHlSb3RhdGlvbiA9ICFzaGlmdFRvT3JpZ2luV2l0aEJiO1xuICAgIHZhciBiYjtcblxuICAgIGlmIChzaGlmdFRvT3JpZ2luV2l0aEJiKSB7XG4gICAgICBiYiA9IHNoaWZ0VG9PcmlnaW5XaXRoQmI7XG4gICAgICBjb250ZXh0LnRyYW5zbGF0ZSgtYmIueDEsIC1iYi55MSk7XG4gICAgfVxuXG4gICAgaWYgKHByZWZpeCA9PSBudWxsKSB7XG4gICAgICByLmRyYXdUZXh0KGNvbnRleHQsIGVsZSwgbnVsbCwgYXBwbHlSb3RhdGlvbiwgdXNlRWxlT3BhY2l0eSk7XG5cbiAgICAgIGlmIChlbGUuaXNFZGdlKCkpIHtcbiAgICAgICAgci5kcmF3VGV4dChjb250ZXh0LCBlbGUsICdzb3VyY2UnLCBhcHBseVJvdGF0aW9uLCB1c2VFbGVPcGFjaXR5KTtcbiAgICAgICAgci5kcmF3VGV4dChjb250ZXh0LCBlbGUsICd0YXJnZXQnLCBhcHBseVJvdGF0aW9uLCB1c2VFbGVPcGFjaXR5KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgci5kcmF3VGV4dChjb250ZXh0LCBlbGUsIHByZWZpeCwgYXBwbHlSb3RhdGlvbiwgdXNlRWxlT3BhY2l0eSk7XG4gICAgfVxuXG4gICAgaWYgKHNoaWZ0VG9PcmlnaW5XaXRoQmIpIHtcbiAgICAgIGNvbnRleHQudHJhbnNsYXRlKGJiLngxLCBiYi55MSk7XG4gICAgfVxuICB9O1xuXG4gIENScCQ2LmdldEZvbnRDYWNoZSA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgdmFyIGNhY2hlO1xuICAgIHRoaXMuZm9udENhY2hlcyA9IHRoaXMuZm9udENhY2hlcyB8fCBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5mb250Q2FjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjYWNoZSA9IHRoaXMuZm9udENhY2hlc1tpXTtcblxuICAgICAgaWYgKGNhY2hlLmNvbnRleHQgPT09IGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNhY2hlID0ge1xuICAgICAgY29udGV4dDogY29udGV4dFxuICAgIH07XG4gICAgdGhpcy5mb250Q2FjaGVzLnB1c2goY2FjaGUpO1xuICAgIHJldHVybiBjYWNoZTtcbiAgfTsgLy8gc2V0IHVwIGNhbnZhcyBjb250ZXh0IHdpdGggZm9udFxuICAvLyByZXR1cm5zIHRyYW5zZm9ybWVkIHRleHQgc3RyaW5nXG5cblxuICBDUnAkNi5zZXR1cFRleHRTdHlsZSA9IGZ1bmN0aW9uIChjb250ZXh0LCBlbGUpIHtcbiAgICB2YXIgdXNlRWxlT3BhY2l0eSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdHJ1ZTtcbiAgICAvLyBGb250IHN0eWxlXG4gICAgdmFyIGxhYmVsU3R5bGUgPSBlbGUucHN0eWxlKCdmb250LXN0eWxlJykuc3RyVmFsdWU7XG4gICAgdmFyIGxhYmVsU2l6ZSA9IGVsZS5wc3R5bGUoJ2ZvbnQtc2l6ZScpLnBmVmFsdWUgKyAncHgnO1xuICAgIHZhciBsYWJlbEZhbWlseSA9IGVsZS5wc3R5bGUoJ2ZvbnQtZmFtaWx5Jykuc3RyVmFsdWU7XG4gICAgdmFyIGxhYmVsV2VpZ2h0ID0gZWxlLnBzdHlsZSgnZm9udC13ZWlnaHQnKS5zdHJWYWx1ZTtcbiAgICB2YXIgb3BhY2l0eSA9IHVzZUVsZU9wYWNpdHkgPyBlbGUuZWZmZWN0aXZlT3BhY2l0eSgpICogZWxlLnBzdHlsZSgndGV4dC1vcGFjaXR5JykudmFsdWUgOiAxO1xuICAgIHZhciBvdXRsaW5lT3BhY2l0eSA9IGVsZS5wc3R5bGUoJ3RleHQtb3V0bGluZS1vcGFjaXR5JykudmFsdWUgKiBvcGFjaXR5O1xuICAgIHZhciBjb2xvciA9IGVsZS5wc3R5bGUoJ2NvbG9yJykudmFsdWU7XG4gICAgdmFyIG91dGxpbmVDb2xvciA9IGVsZS5wc3R5bGUoJ3RleHQtb3V0bGluZS1jb2xvcicpLnZhbHVlO1xuICAgIGNvbnRleHQuZm9udCA9IGxhYmVsU3R5bGUgKyAnICcgKyBsYWJlbFdlaWdodCArICcgJyArIGxhYmVsU2l6ZSArICcgJyArIGxhYmVsRmFtaWx5O1xuICAgIGNvbnRleHQubGluZUpvaW4gPSAncm91bmQnOyAvLyBzbyB0ZXh0IG91dGxpbmVzIGFyZW4ndCBqYWdnZWRcblxuICAgIHRoaXMuY29sb3JGaWxsU3R5bGUoY29udGV4dCwgY29sb3JbMF0sIGNvbG9yWzFdLCBjb2xvclsyXSwgb3BhY2l0eSk7XG4gICAgdGhpcy5jb2xvclN0cm9rZVN0eWxlKGNvbnRleHQsIG91dGxpbmVDb2xvclswXSwgb3V0bGluZUNvbG9yWzFdLCBvdXRsaW5lQ29sb3JbMl0sIG91dGxpbmVPcGFjaXR5KTtcbiAgfTsgLy8gVE9ETyBlbnN1cmUgcmUtdXNlZFxuXG5cbiAgZnVuY3Rpb24gcm91bmRSZWN0KGN0eCwgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgIHZhciByYWRpdXMgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IDU7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5tb3ZlVG8oeCArIHJhZGl1cywgeSk7XG4gICAgY3R4LmxpbmVUbyh4ICsgd2lkdGggLSByYWRpdXMsIHkpO1xuICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSwgeCArIHdpZHRoLCB5ICsgcmFkaXVzKTtcbiAgICBjdHgubGluZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCAtIHJhZGl1cyk7XG4gICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0LCB4ICsgd2lkdGggLSByYWRpdXMsIHkgKyBoZWlnaHQpO1xuICAgIGN0eC5saW5lVG8oeCArIHJhZGl1cywgeSArIGhlaWdodCk7XG4gICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSArIGhlaWdodCwgeCwgeSArIGhlaWdodCAtIHJhZGl1cyk7XG4gICAgY3R4LmxpbmVUbyh4LCB5ICsgcmFkaXVzKTtcbiAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5LCB4ICsgcmFkaXVzLCB5KTtcbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgY3R4LmZpbGwoKTtcbiAgfVxuXG4gIENScCQ2LmdldFRleHRBbmdsZSA9IGZ1bmN0aW9uIChlbGUsIHByZWZpeCkge1xuICAgIHZhciB0aGV0YTtcbiAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgdmFyIHJzY3JhdGNoID0gX3AucnNjcmF0Y2g7XG4gICAgdmFyIHBkYXNoID0gcHJlZml4ID8gcHJlZml4ICsgJy0nIDogJyc7XG4gICAgdmFyIHJvdGF0aW9uID0gZWxlLnBzdHlsZShwZGFzaCArICd0ZXh0LXJvdGF0aW9uJyk7XG4gICAgdmFyIHRleHRBbmdsZSA9IGdldFByZWZpeGVkUHJvcGVydHkocnNjcmF0Y2gsICdsYWJlbEFuZ2xlJywgcHJlZml4KTtcblxuICAgIGlmIChyb3RhdGlvbi5zdHJWYWx1ZSA9PT0gJ2F1dG9yb3RhdGUnKSB7XG4gICAgICB0aGV0YSA9IGVsZS5pc0VkZ2UoKSA/IHRleHRBbmdsZSA6IDA7XG4gICAgfSBlbHNlIGlmIChyb3RhdGlvbi5zdHJWYWx1ZSA9PT0gJ25vbmUnKSB7XG4gICAgICB0aGV0YSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoZXRhID0gcm90YXRpb24ucGZWYWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhldGE7XG4gIH07XG5cbiAgQ1JwJDYuZHJhd1RleHQgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlLCBwcmVmaXgpIHtcbiAgICB2YXIgYXBwbHlSb3RhdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogdHJ1ZTtcbiAgICB2YXIgdXNlRWxlT3BhY2l0eSA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogdHJ1ZTtcbiAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgdmFyIHJzY3JhdGNoID0gX3AucnNjcmF0Y2g7XG4gICAgdmFyIHBhcmVudE9wYWNpdHkgPSB1c2VFbGVPcGFjaXR5ID8gZWxlLmVmZmVjdGl2ZU9wYWNpdHkoKSA6IDE7XG5cbiAgICBpZiAodXNlRWxlT3BhY2l0eSAmJiAocGFyZW50T3BhY2l0eSA9PT0gMCB8fCBlbGUucHN0eWxlKCd0ZXh0LW9wYWNpdHknKS52YWx1ZSA9PT0gMCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIHVzZSAnbWFpbicgYXMgYW4gYWxpYXMgZm9yIHRoZSBtYWluIGxhYmVsIChpLmUuIG51bGwgcHJlZml4KVxuXG5cbiAgICBpZiAocHJlZml4ID09PSAnbWFpbicpIHtcbiAgICAgIHByZWZpeCA9IG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHRleHRYID0gZ2V0UHJlZml4ZWRQcm9wZXJ0eShyc2NyYXRjaCwgJ2xhYmVsWCcsIHByZWZpeCk7XG4gICAgdmFyIHRleHRZID0gZ2V0UHJlZml4ZWRQcm9wZXJ0eShyc2NyYXRjaCwgJ2xhYmVsWScsIHByZWZpeCk7XG4gICAgdmFyIG9yZ1RleHRYLCBvcmdUZXh0WTsgLy8gdXNlZCBmb3Igcm90YXRpb25cblxuICAgIHZhciB0ZXh0ID0gdGhpcy5nZXRMYWJlbFRleHQoZWxlLCBwcmVmaXgpO1xuXG4gICAgaWYgKHRleHQgIT0gbnVsbCAmJiB0ZXh0ICE9PSAnJyAmJiAhaXNOYU4odGV4dFgpICYmICFpc05hTih0ZXh0WSkpIHtcbiAgICAgIHRoaXMuc2V0dXBUZXh0U3R5bGUoY29udGV4dCwgZWxlLCB1c2VFbGVPcGFjaXR5KTtcbiAgICAgIHZhciBwZGFzaCA9IHByZWZpeCA/IHByZWZpeCArICctJyA6ICcnO1xuICAgICAgdmFyIHRleHRXID0gZ2V0UHJlZml4ZWRQcm9wZXJ0eShyc2NyYXRjaCwgJ2xhYmVsV2lkdGgnLCBwcmVmaXgpO1xuICAgICAgdmFyIHRleHRIID0gZ2V0UHJlZml4ZWRQcm9wZXJ0eShyc2NyYXRjaCwgJ2xhYmVsSGVpZ2h0JywgcHJlZml4KTtcbiAgICAgIHZhciBtYXJnaW5YID0gZWxlLnBzdHlsZShwZGFzaCArICd0ZXh0LW1hcmdpbi14JykucGZWYWx1ZTtcbiAgICAgIHZhciBtYXJnaW5ZID0gZWxlLnBzdHlsZShwZGFzaCArICd0ZXh0LW1hcmdpbi15JykucGZWYWx1ZTtcbiAgICAgIHZhciBpc0VkZ2UgPSBlbGUuaXNFZGdlKCk7XG4gICAgICB2YXIgaGFsaWduID0gZWxlLnBzdHlsZSgndGV4dC1oYWxpZ24nKS52YWx1ZTtcbiAgICAgIHZhciB2YWxpZ24gPSBlbGUucHN0eWxlKCd0ZXh0LXZhbGlnbicpLnZhbHVlO1xuXG4gICAgICBpZiAoaXNFZGdlKSB7XG4gICAgICAgIGhhbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICB2YWxpZ24gPSAnY2VudGVyJztcbiAgICAgIH1cblxuICAgICAgdGV4dFggKz0gbWFyZ2luWDtcbiAgICAgIHRleHRZICs9IG1hcmdpblk7XG4gICAgICB2YXIgdGhldGE7XG5cbiAgICAgIGlmICghYXBwbHlSb3RhdGlvbikge1xuICAgICAgICB0aGV0YSA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGV0YSA9IHRoaXMuZ2V0VGV4dEFuZ2xlKGVsZSwgcHJlZml4KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoZXRhICE9PSAwKSB7XG4gICAgICAgIG9yZ1RleHRYID0gdGV4dFg7XG4gICAgICAgIG9yZ1RleHRZID0gdGV4dFk7XG4gICAgICAgIGNvbnRleHQudHJhbnNsYXRlKG9yZ1RleHRYLCBvcmdUZXh0WSk7XG4gICAgICAgIGNvbnRleHQucm90YXRlKHRoZXRhKTtcbiAgICAgICAgdGV4dFggPSAwO1xuICAgICAgICB0ZXh0WSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAodmFsaWduKSB7XG4gICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICB0ZXh0WSArPSB0ZXh0SCAvIDI7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICB0ZXh0WSArPSB0ZXh0SDtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgdmFyIGJhY2tncm91bmRPcGFjaXR5ID0gZWxlLnBzdHlsZSgndGV4dC1iYWNrZ3JvdW5kLW9wYWNpdHknKS52YWx1ZTtcbiAgICAgIHZhciBib3JkZXJPcGFjaXR5ID0gZWxlLnBzdHlsZSgndGV4dC1ib3JkZXItb3BhY2l0eScpLnZhbHVlO1xuICAgICAgdmFyIHRleHRCb3JkZXJXaWR0aCA9IGVsZS5wc3R5bGUoJ3RleHQtYm9yZGVyLXdpZHRoJykucGZWYWx1ZTtcbiAgICAgIHZhciBiYWNrZ3JvdW5kUGFkZGluZyA9IGVsZS5wc3R5bGUoJ3RleHQtYmFja2dyb3VuZC1wYWRkaW5nJykucGZWYWx1ZTtcblxuICAgICAgaWYgKGJhY2tncm91bmRPcGFjaXR5ID4gMCB8fCB0ZXh0Qm9yZGVyV2lkdGggPiAwICYmIGJvcmRlck9wYWNpdHkgPiAwKSB7XG4gICAgICAgIHZhciBiZ1ggPSB0ZXh0WCAtIGJhY2tncm91bmRQYWRkaW5nO1xuXG4gICAgICAgIHN3aXRjaCAoaGFsaWduKSB7XG4gICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICBiZ1ggLT0gdGV4dFc7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgICBiZ1ggLT0gdGV4dFcgLyAyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYmdZID0gdGV4dFkgLSB0ZXh0SCAtIGJhY2tncm91bmRQYWRkaW5nO1xuICAgICAgICB2YXIgYmdXID0gdGV4dFcgKyAyICogYmFja2dyb3VuZFBhZGRpbmc7XG4gICAgICAgIHZhciBiZ0ggPSB0ZXh0SCArIDIgKiBiYWNrZ3JvdW5kUGFkZGluZztcblxuICAgICAgICBpZiAoYmFja2dyb3VuZE9wYWNpdHkgPiAwKSB7XG4gICAgICAgICAgdmFyIHRleHRGaWxsID0gY29udGV4dC5maWxsU3R5bGU7XG4gICAgICAgICAgdmFyIHRleHRCYWNrZ3JvdW5kQ29sb3IgPSBlbGUucHN0eWxlKCd0ZXh0LWJhY2tncm91bmQtY29sb3InKS52YWx1ZTtcbiAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICdyZ2JhKCcgKyB0ZXh0QmFja2dyb3VuZENvbG9yWzBdICsgJywnICsgdGV4dEJhY2tncm91bmRDb2xvclsxXSArICcsJyArIHRleHRCYWNrZ3JvdW5kQ29sb3JbMl0gKyAnLCcgKyBiYWNrZ3JvdW5kT3BhY2l0eSAqIHBhcmVudE9wYWNpdHkgKyAnKSc7XG4gICAgICAgICAgdmFyIHN0eWxlU2hhcGUgPSBlbGUucHN0eWxlKCd0ZXh0LWJhY2tncm91bmQtc2hhcGUnKS5zdHJWYWx1ZTtcblxuICAgICAgICAgIGlmIChzdHlsZVNoYXBlLmluZGV4T2YoJ3JvdW5kJykgPT09IDApIHtcbiAgICAgICAgICAgIHJvdW5kUmVjdChjb250ZXh0LCBiZ1gsIGJnWSwgYmdXLCBiZ0gsIDIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250ZXh0LmZpbGxSZWN0KGJnWCwgYmdZLCBiZ1csIGJnSCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSB0ZXh0RmlsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0ZXh0Qm9yZGVyV2lkdGggPiAwICYmIGJvcmRlck9wYWNpdHkgPiAwKSB7XG4gICAgICAgICAgdmFyIHRleHRTdHJva2UgPSBjb250ZXh0LnN0cm9rZVN0eWxlO1xuICAgICAgICAgIHZhciB0ZXh0TGluZVdpZHRoID0gY29udGV4dC5saW5lV2lkdGg7XG4gICAgICAgICAgdmFyIHRleHRCb3JkZXJDb2xvciA9IGVsZS5wc3R5bGUoJ3RleHQtYm9yZGVyLWNvbG9yJykudmFsdWU7XG4gICAgICAgICAgdmFyIHRleHRCb3JkZXJTdHlsZSA9IGVsZS5wc3R5bGUoJ3RleHQtYm9yZGVyLXN0eWxlJykudmFsdWU7XG4gICAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9ICdyZ2JhKCcgKyB0ZXh0Qm9yZGVyQ29sb3JbMF0gKyAnLCcgKyB0ZXh0Qm9yZGVyQ29sb3JbMV0gKyAnLCcgKyB0ZXh0Qm9yZGVyQ29sb3JbMl0gKyAnLCcgKyBib3JkZXJPcGFjaXR5ICogcGFyZW50T3BhY2l0eSArICcpJztcbiAgICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHRleHRCb3JkZXJXaWR0aDtcblxuICAgICAgICAgIGlmIChjb250ZXh0LnNldExpbmVEYXNoKSB7XG4gICAgICAgICAgICAvLyBmb3IgdmVyeSBvdXRvZmRhdGUgYnJvd3NlcnNcbiAgICAgICAgICAgIHN3aXRjaCAodGV4dEJvcmRlclN0eWxlKSB7XG4gICAgICAgICAgICAgIGNhc2UgJ2RvdHRlZCc6XG4gICAgICAgICAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChbMSwgMV0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgJ2Rhc2hlZCc6XG4gICAgICAgICAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChbNCwgMl0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgJ2RvdWJsZSc6XG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSB0ZXh0Qm9yZGVyV2lkdGggLyA0OyAvLyA1MCUgcmVzZXJ2ZWQgZm9yIHdoaXRlIGJldHdlZW4gdGhlIHR3byBib3JkZXJzXG5cbiAgICAgICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFtdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlICdzb2xpZCc6XG4gICAgICAgICAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChbXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5zdHJva2VSZWN0KGJnWCwgYmdZLCBiZ1csIGJnSCk7XG5cbiAgICAgICAgICBpZiAodGV4dEJvcmRlclN0eWxlID09PSAnZG91YmxlJykge1xuICAgICAgICAgICAgdmFyIHdoaXRlV2lkdGggPSB0ZXh0Qm9yZGVyV2lkdGggLyAyO1xuICAgICAgICAgICAgY29udGV4dC5zdHJva2VSZWN0KGJnWCArIHdoaXRlV2lkdGgsIGJnWSArIHdoaXRlV2lkdGgsIGJnVyAtIHdoaXRlV2lkdGggKiAyLCBiZ0ggLSB3aGl0ZVdpZHRoICogMik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNvbnRleHQuc2V0TGluZURhc2gpIHtcbiAgICAgICAgICAgIC8vIGZvciB2ZXJ5IG91dG9mZGF0ZSBicm93c2Vyc1xuICAgICAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChbXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSB0ZXh0TGluZVdpZHRoO1xuICAgICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSB0ZXh0U3Ryb2tlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBsaW5lV2lkdGggPSAyICogZWxlLnBzdHlsZSgndGV4dC1vdXRsaW5lLXdpZHRoJykucGZWYWx1ZTsgLy8gKjIgYi9jIHRoZSBzdHJva2UgaXMgZHJhd24gY2VudHJlZCBvbiB0aGUgbWlkZGxlXG5cbiAgICAgIGlmIChsaW5lV2lkdGggPiAwKSB7XG4gICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWxlLnBzdHlsZSgndGV4dC13cmFwJykudmFsdWUgPT09ICd3cmFwJykge1xuICAgICAgICB2YXIgbGluZXMgPSBnZXRQcmVmaXhlZFByb3BlcnR5KHJzY3JhdGNoLCAnbGFiZWxXcmFwQ2FjaGVkTGluZXMnLCBwcmVmaXgpO1xuICAgICAgICB2YXIgbGluZUhlaWdodCA9IGdldFByZWZpeGVkUHJvcGVydHkocnNjcmF0Y2gsICdsYWJlbExpbmVIZWlnaHQnLCBwcmVmaXgpO1xuICAgICAgICB2YXIgaGFsZlRleHRXID0gdGV4dFcgLyAyO1xuICAgICAgICB2YXIganVzdGlmaWNhdGlvbiA9IHRoaXMuZ2V0TGFiZWxKdXN0aWZpY2F0aW9uKGVsZSk7XG5cbiAgICAgICAgaWYgKGp1c3RpZmljYXRpb24gPT09ICdhdXRvJykgOyBlbHNlIGlmIChoYWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgICAgIC8vIGF1dG8ganVzdGlmaWNhdGlvbiA6IHJpZ2h0XG4gICAgICAgICAgaWYgKGp1c3RpZmljYXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgdGV4dFggKz0gLXRleHRXO1xuICAgICAgICAgIH0gZWxzZSBpZiAoanVzdGlmaWNhdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgIHRleHRYICs9IC1oYWxmVGV4dFc7XG4gICAgICAgICAgfSAvLyBlbHNlIHNhbWUgYXMgYXV0b1xuXG4gICAgICAgIH0gZWxzZSBpZiAoaGFsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgIC8vIGF1dG8ganVzdGZpY2F0aW9uIDogY2VudGVyXG4gICAgICAgICAgaWYgKGp1c3RpZmljYXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgdGV4dFggKz0gLWhhbGZUZXh0VztcbiAgICAgICAgICB9IGVsc2UgaWYgKGp1c3RpZmljYXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgIHRleHRYICs9IGhhbGZUZXh0VztcbiAgICAgICAgICB9IC8vIGVsc2Ugc2FtZSBhcyBhdXRvXG5cbiAgICAgICAgfSBlbHNlIGlmIChoYWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAvLyBhdXRvIGp1c3RpZmljYXRpb24gOiBsZWZ0XG4gICAgICAgICAgaWYgKGp1c3RpZmljYXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICB0ZXh0WCArPSBoYWxmVGV4dFc7XG4gICAgICAgICAgfSBlbHNlIGlmIChqdXN0aWZpY2F0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICB0ZXh0WCArPSB0ZXh0VztcbiAgICAgICAgICB9IC8vIGVsc2Ugc2FtZSBhcyBhdXRvXG5cbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAodmFsaWduKSB7XG4gICAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgIHRleHRZIC09IChsaW5lcy5sZW5ndGggLSAxKSAqIGxpbmVIZWlnaHQ7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgIHRleHRZIC09IChsaW5lcy5sZW5ndGggLSAxKSAqIGxpbmVIZWlnaHQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgbGluZXMubGVuZ3RoOyBsKyspIHtcbiAgICAgICAgICBpZiAobGluZVdpZHRoID4gMCkge1xuICAgICAgICAgICAgY29udGV4dC5zdHJva2VUZXh0KGxpbmVzW2xdLCB0ZXh0WCwgdGV4dFkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZmlsbFRleHQobGluZXNbbF0sIHRleHRYLCB0ZXh0WSk7XG4gICAgICAgICAgdGV4dFkgKz0gbGluZUhlaWdodDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGxpbmVXaWR0aCA+IDApIHtcbiAgICAgICAgICBjb250ZXh0LnN0cm9rZVRleHQodGV4dCwgdGV4dFgsIHRleHRZKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQuZmlsbFRleHQodGV4dCwgdGV4dFgsIHRleHRZKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoZXRhICE9PSAwKSB7XG4gICAgICAgIGNvbnRleHQucm90YXRlKC10aGV0YSk7XG4gICAgICAgIGNvbnRleHQudHJhbnNsYXRlKC1vcmdUZXh0WCwgLW9yZ1RleHRZKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyogZ2xvYmFsIFBhdGgyRCAqL1xuICB2YXIgQ1JwJDUgPSB7fTtcblxuICBDUnAkNS5kcmF3Tm9kZSA9IGZ1bmN0aW9uIChjb250ZXh0LCBub2RlLCBzaGlmdFRvT3JpZ2luV2l0aEJiKSB7XG4gICAgdmFyIGRyYXdMYWJlbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogdHJ1ZTtcbiAgICB2YXIgc2hvdWxkRHJhd092ZXJsYXkgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IHRydWU7XG4gICAgdmFyIHNob3VsZERyYXdPcGFjaXR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiB0cnVlO1xuICAgIHZhciByID0gdGhpcztcbiAgICB2YXIgbm9kZVdpZHRoLCBub2RlSGVpZ2h0O1xuICAgIHZhciBfcCA9IG5vZGUuX3ByaXZhdGU7XG4gICAgdmFyIHJzID0gX3AucnNjcmF0Y2g7XG4gICAgdmFyIHBvcyA9IG5vZGUucG9zaXRpb24oKTtcblxuICAgIGlmICghbnVtYmVyJDEocG9zLngpIHx8ICFudW1iZXIkMShwb3MueSkpIHtcbiAgICAgIHJldHVybjsgLy8gY2FuJ3QgZHJhdyBub2RlIHdpdGggdW5kZWZpbmVkIHBvc2l0aW9uXG4gICAgfVxuXG4gICAgaWYgKHNob3VsZERyYXdPcGFjaXR5ICYmICFub2RlLnZpc2libGUoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBlbGVPcGFjaXR5ID0gc2hvdWxkRHJhd09wYWNpdHkgPyBub2RlLmVmZmVjdGl2ZU9wYWNpdHkoKSA6IDE7XG4gICAgdmFyIHVzZVBhdGhzID0gci51c2VQYXRocygpO1xuICAgIHZhciBwYXRoO1xuICAgIHZhciBwYXRoQ2FjaGVIaXQgPSBmYWxzZTtcbiAgICB2YXIgcGFkZGluZyA9IG5vZGUucGFkZGluZygpO1xuICAgIG5vZGVXaWR0aCA9IG5vZGUud2lkdGgoKSArIDIgKiBwYWRkaW5nO1xuICAgIG5vZGVIZWlnaHQgPSBub2RlLmhlaWdodCgpICsgMiAqIHBhZGRpbmc7IC8vXG4gICAgLy8gc2V0dXAgc2hpZnRcblxuICAgIHZhciBiYjtcblxuICAgIGlmIChzaGlmdFRvT3JpZ2luV2l0aEJiKSB7XG4gICAgICBiYiA9IHNoaWZ0VG9PcmlnaW5XaXRoQmI7XG4gICAgICBjb250ZXh0LnRyYW5zbGF0ZSgtYmIueDEsIC1iYi55MSk7XG4gICAgfSAvL1xuICAgIC8vIGxvYWQgYmcgaW1hZ2VcblxuXG4gICAgdmFyIGJnSW1nUHJvcCA9IG5vZGUucHN0eWxlKCdiYWNrZ3JvdW5kLWltYWdlJyk7XG4gICAgdmFyIHVybHMgPSBiZ0ltZ1Byb3AudmFsdWU7XG4gICAgdmFyIHVybERlZmluZWQgPSBuZXcgQXJyYXkodXJscy5sZW5ndGgpO1xuICAgIHZhciBpbWFnZSA9IG5ldyBBcnJheSh1cmxzLmxlbmd0aCk7XG4gICAgdmFyIG51bUltYWdlcyA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVybHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB1cmwgPSB1cmxzW2ldO1xuICAgICAgdmFyIGRlZmQgPSB1cmxEZWZpbmVkW2ldID0gdXJsICE9IG51bGwgJiYgdXJsICE9PSAnbm9uZSc7XG5cbiAgICAgIGlmIChkZWZkKSB7XG4gICAgICAgIHZhciBiZ0ltZ0Nyb3NzT3JpZ2luID0gbm9kZS5jeSgpLnN0eWxlKCkuZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLWltYWdlLWNyb3Nzb3JpZ2luJywgJ3ZhbHVlJywgaSk7XG4gICAgICAgIG51bUltYWdlcysrOyAvLyBnZXQgaW1hZ2UsIGFuZCBpZiBub3QgbG9hZGVkIHRoZW4gYXNrIHRvIHJlZHJhdyB3aGVuIGxhdGVyIGxvYWRlZFxuXG4gICAgICAgIGltYWdlW2ldID0gci5nZXRDYWNoZWRJbWFnZSh1cmwsIGJnSW1nQ3Jvc3NPcmlnaW4sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfcC5iYWNrZ3JvdW5kVGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICBub2RlLmVtaXRBbmROb3RpZnkoJ2JhY2tncm91bmQnKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSAvL1xuICAgIC8vIHNldHVwIHN0eWxlc1xuXG5cbiAgICB2YXIgZGFya25lc3MgPSBub2RlLnBzdHlsZSgnYmFja2dyb3VuZC1ibGFja2VuJykudmFsdWU7XG4gICAgdmFyIGJvcmRlcldpZHRoID0gbm9kZS5wc3R5bGUoJ2JvcmRlci13aWR0aCcpLnBmVmFsdWU7XG4gICAgdmFyIGJnT3BhY2l0eSA9IG5vZGUucHN0eWxlKCdiYWNrZ3JvdW5kLW9wYWNpdHknKS52YWx1ZSAqIGVsZU9wYWNpdHk7XG4gICAgdmFyIGJvcmRlckNvbG9yID0gbm9kZS5wc3R5bGUoJ2JvcmRlci1jb2xvcicpLnZhbHVlO1xuICAgIHZhciBib3JkZXJTdHlsZSA9IG5vZGUucHN0eWxlKCdib3JkZXItc3R5bGUnKS52YWx1ZTtcbiAgICB2YXIgYm9yZGVyT3BhY2l0eSA9IG5vZGUucHN0eWxlKCdib3JkZXItb3BhY2l0eScpLnZhbHVlICogZWxlT3BhY2l0eTtcbiAgICBjb250ZXh0LmxpbmVKb2luID0gJ21pdGVyJzsgLy8gc28gYm9yZGVycyBhcmUgc3F1YXJlIHdpdGggdGhlIG5vZGUgc2hhcGVcblxuICAgIHZhciBzZXR1cFNoYXBlQ29sb3IgPSBmdW5jdGlvbiBzZXR1cFNoYXBlQ29sb3IoKSB7XG4gICAgICB2YXIgYmdPcHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGJnT3BhY2l0eTtcbiAgICAgIHIuZWxlRmlsbFN0eWxlKGNvbnRleHQsIG5vZGUsIGJnT3B5KTtcbiAgICB9O1xuXG4gICAgdmFyIHNldHVwQm9yZGVyQ29sb3IgPSBmdW5jdGlvbiBzZXR1cEJvcmRlckNvbG9yKCkge1xuICAgICAgdmFyIGJkck9weSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogYm9yZGVyT3BhY2l0eTtcbiAgICAgIHIuY29sb3JTdHJva2VTdHlsZShjb250ZXh0LCBib3JkZXJDb2xvclswXSwgYm9yZGVyQ29sb3JbMV0sIGJvcmRlckNvbG9yWzJdLCBiZHJPcHkpO1xuICAgIH07IC8vXG4gICAgLy8gc2V0dXAgc2hhcGVcblxuXG4gICAgdmFyIHN0eWxlU2hhcGUgPSBub2RlLnBzdHlsZSgnc2hhcGUnKS5zdHJWYWx1ZTtcbiAgICB2YXIgc2hhcGVQdHMgPSBub2RlLnBzdHlsZSgnc2hhcGUtcG9seWdvbi1wb2ludHMnKS5wZlZhbHVlO1xuXG4gICAgaWYgKHVzZVBhdGhzKSB7XG4gICAgICBjb250ZXh0LnRyYW5zbGF0ZShwb3MueCwgcG9zLnkpO1xuICAgICAgdmFyIHBhdGhDYWNoZSA9IHIubm9kZVBhdGhDYWNoZSA9IHIubm9kZVBhdGhDYWNoZSB8fCBbXTtcbiAgICAgIHZhciBrZXkgPSBoYXNoU3RyaW5ncyhzdHlsZVNoYXBlID09PSAncG9seWdvbicgPyBzdHlsZVNoYXBlICsgJywnICsgc2hhcGVQdHMuam9pbignLCcpIDogc3R5bGVTaGFwZSwgJycgKyBub2RlSGVpZ2h0LCAnJyArIG5vZGVXaWR0aCk7XG4gICAgICB2YXIgY2FjaGVkUGF0aCA9IHBhdGhDYWNoZVtrZXldO1xuXG4gICAgICBpZiAoY2FjaGVkUGF0aCAhPSBudWxsKSB7XG4gICAgICAgIHBhdGggPSBjYWNoZWRQYXRoO1xuICAgICAgICBwYXRoQ2FjaGVIaXQgPSB0cnVlO1xuICAgICAgICBycy5wYXRoQ2FjaGUgPSBwYXRoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGF0aCA9IG5ldyBQYXRoMkQoKTtcbiAgICAgICAgcGF0aENhY2hlW2tleV0gPSBycy5wYXRoQ2FjaGUgPSBwYXRoO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkcmF3U2hhcGUgPSBmdW5jdGlvbiBkcmF3U2hhcGUoKSB7XG4gICAgICBpZiAoIXBhdGhDYWNoZUhpdCkge1xuICAgICAgICB2YXIgbnBvcyA9IHBvcztcblxuICAgICAgICBpZiAodXNlUGF0aHMpIHtcbiAgICAgICAgICBucG9zID0ge1xuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDBcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgci5ub2RlU2hhcGVzW3IuZ2V0Tm9kZVNoYXBlKG5vZGUpXS5kcmF3KHBhdGggfHwgY29udGV4dCwgbnBvcy54LCBucG9zLnksIG5vZGVXaWR0aCwgbm9kZUhlaWdodCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh1c2VQYXRocykge1xuICAgICAgICBjb250ZXh0LmZpbGwocGF0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGRyYXdJbWFnZXMgPSBmdW5jdGlvbiBkcmF3SW1hZ2VzKCkge1xuICAgICAgdmFyIG5vZGVPcGFjaXR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBlbGVPcGFjaXR5O1xuICAgICAgdmFyIGluc2lkZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICAgIHZhciBwcmV2QmdpbmcgPSBfcC5iYWNrZ3JvdW5kaW5nO1xuICAgICAgdmFyIHRvdGFsQ29tcGxldGVkID0gMDtcblxuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGltYWdlLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgYmdDb250YWlubWVudCA9IG5vZGUuY3koKS5zdHlsZSgpLmdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1pbWFnZS1jb250YWlubWVudCcsICd2YWx1ZScsIF9pKTtcblxuICAgICAgICBpZiAoaW5zaWRlICYmIGJnQ29udGFpbm1lbnQgPT09ICdvdmVyJyB8fCAhaW5zaWRlICYmIGJnQ29udGFpbm1lbnQgPT09ICdpbnNpZGUnKSB7XG4gICAgICAgICAgdG90YWxDb21wbGV0ZWQrKztcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1cmxEZWZpbmVkW19pXSAmJiBpbWFnZVtfaV0uY29tcGxldGUgJiYgIWltYWdlW19pXS5lcnJvcikge1xuICAgICAgICAgIHRvdGFsQ29tcGxldGVkKys7XG4gICAgICAgICAgci5kcmF3SW5zY3JpYmVkSW1hZ2UoY29udGV4dCwgaW1hZ2VbX2ldLCBub2RlLCBfaSwgbm9kZU9wYWNpdHkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIF9wLmJhY2tncm91bmRpbmcgPSAhKHRvdGFsQ29tcGxldGVkID09PSBudW1JbWFnZXMpO1xuXG4gICAgICBpZiAocHJldkJnaW5nICE9PSBfcC5iYWNrZ3JvdW5kaW5nKSB7XG4gICAgICAgIC8vIHVwZGF0ZSBzdHlsZSBiL2MgOmJhY2tncm91bmRpbmcgc3RhdGUgY2hhbmdlZFxuICAgICAgICBub2RlLnVwZGF0ZVN0eWxlKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGRyYXdQaWUgPSBmdW5jdGlvbiBkcmF3UGllKCkge1xuICAgICAgdmFyIHJlZHJhd1NoYXBlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcbiAgICAgIHZhciBwaWVPcGFjaXR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBlbGVPcGFjaXR5O1xuXG4gICAgICBpZiAoci5oYXNQaWUobm9kZSkpIHtcbiAgICAgICAgci5kcmF3UGllKGNvbnRleHQsIG5vZGUsIHBpZU9wYWNpdHkpOyAvLyByZWRyYXcvcmVzdG9yZSBwYXRoIGlmIHN0ZXBzIGFmdGVyIHBpZSBuZWVkIGl0XG5cbiAgICAgICAgaWYgKHJlZHJhd1NoYXBlKSB7XG4gICAgICAgICAgaWYgKCF1c2VQYXRocykge1xuICAgICAgICAgICAgci5ub2RlU2hhcGVzW3IuZ2V0Tm9kZVNoYXBlKG5vZGUpXS5kcmF3KGNvbnRleHQsIHBvcy54LCBwb3MueSwgbm9kZVdpZHRoLCBub2RlSGVpZ2h0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGRhcmtlbiA9IGZ1bmN0aW9uIGRhcmtlbigpIHtcbiAgICAgIHZhciBkYXJrZW5PcGFjaXR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBlbGVPcGFjaXR5O1xuICAgICAgdmFyIG9wYWNpdHkgPSAoZGFya25lc3MgPiAwID8gZGFya25lc3MgOiAtZGFya25lc3MpICogZGFya2VuT3BhY2l0eTtcbiAgICAgIHZhciBjID0gZGFya25lc3MgPiAwID8gMCA6IDI1NTtcblxuICAgICAgaWYgKGRhcmtuZXNzICE9PSAwKSB7XG4gICAgICAgIHIuY29sb3JGaWxsU3R5bGUoY29udGV4dCwgYywgYywgYywgb3BhY2l0eSk7XG5cbiAgICAgICAgaWYgKHVzZVBhdGhzKSB7XG4gICAgICAgICAgY29udGV4dC5maWxsKHBhdGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBkcmF3Qm9yZGVyID0gZnVuY3Rpb24gZHJhd0JvcmRlcigpIHtcbiAgICAgIGlmIChib3JkZXJXaWR0aCA+IDApIHtcbiAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSBib3JkZXJXaWR0aDtcbiAgICAgICAgY29udGV4dC5saW5lQ2FwID0gJ2J1dHQnO1xuXG4gICAgICAgIGlmIChjb250ZXh0LnNldExpbmVEYXNoKSB7XG4gICAgICAgICAgLy8gZm9yIHZlcnkgb3V0b2ZkYXRlIGJyb3dzZXJzXG4gICAgICAgICAgc3dpdGNoIChib3JkZXJTdHlsZSkge1xuICAgICAgICAgICAgY2FzZSAnZG90dGVkJzpcbiAgICAgICAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChbMSwgMV0pO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnZGFzaGVkJzpcbiAgICAgICAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChbNCwgMl0pO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnc29saWQnOlxuICAgICAgICAgICAgY2FzZSAnZG91YmxlJzpcbiAgICAgICAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChbXSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1c2VQYXRocykge1xuICAgICAgICAgIGNvbnRleHQuc3Ryb2tlKHBhdGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYm9yZGVyU3R5bGUgPT09ICdkb3VibGUnKSB7XG4gICAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSBib3JkZXJXaWR0aCAvIDM7XG4gICAgICAgICAgdmFyIGdjbyA9IGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uO1xuICAgICAgICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLW91dCc7XG5cbiAgICAgICAgICBpZiAodXNlUGF0aHMpIHtcbiAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlKHBhdGgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gZ2NvO1xuICAgICAgICB9IC8vIHJlc2V0IGluIGNhc2Ugd2UgY2hhbmdlZCB0aGUgYm9yZGVyIHN0eWxlXG5cblxuICAgICAgICBpZiAoY29udGV4dC5zZXRMaW5lRGFzaCkge1xuICAgICAgICAgIC8vIGZvciB2ZXJ5IG91dG9mZGF0ZSBicm93c2Vyc1xuICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goW10pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBkcmF3T3ZlcmxheSA9IGZ1bmN0aW9uIGRyYXdPdmVybGF5KCkge1xuICAgICAgaWYgKHNob3VsZERyYXdPdmVybGF5KSB7XG4gICAgICAgIHIuZHJhd05vZGVPdmVybGF5KGNvbnRleHQsIG5vZGUsIHBvcywgbm9kZVdpZHRoLCBub2RlSGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGRyYXdVbmRlcmxheSA9IGZ1bmN0aW9uIGRyYXdVbmRlcmxheSgpIHtcbiAgICAgIGlmIChzaG91bGREcmF3T3ZlcmxheSkge1xuICAgICAgICByLmRyYXdOb2RlVW5kZXJsYXkoY29udGV4dCwgbm9kZSwgcG9zLCBub2RlV2lkdGgsIG5vZGVIZWlnaHQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgZHJhd1RleHQgPSBmdW5jdGlvbiBkcmF3VGV4dCgpIHtcbiAgICAgIHIuZHJhd0VsZW1lbnRUZXh0KGNvbnRleHQsIG5vZGUsIG51bGwsIGRyYXdMYWJlbCk7XG4gICAgfTtcblxuICAgIHZhciBnaG9zdCA9IG5vZGUucHN0eWxlKCdnaG9zdCcpLnZhbHVlID09PSAneWVzJztcblxuICAgIGlmIChnaG9zdCkge1xuICAgICAgdmFyIGd4ID0gbm9kZS5wc3R5bGUoJ2dob3N0LW9mZnNldC14JykucGZWYWx1ZTtcbiAgICAgIHZhciBneSA9IG5vZGUucHN0eWxlKCdnaG9zdC1vZmZzZXQteScpLnBmVmFsdWU7XG4gICAgICB2YXIgZ2hvc3RPcGFjaXR5ID0gbm9kZS5wc3R5bGUoJ2dob3N0LW9wYWNpdHknKS52YWx1ZTtcbiAgICAgIHZhciBlZmZHaG9zdE9wYWNpdHkgPSBnaG9zdE9wYWNpdHkgKiBlbGVPcGFjaXR5O1xuICAgICAgY29udGV4dC50cmFuc2xhdGUoZ3gsIGd5KTtcbiAgICAgIHNldHVwU2hhcGVDb2xvcihnaG9zdE9wYWNpdHkgKiBiZ09wYWNpdHkpO1xuICAgICAgZHJhd1NoYXBlKCk7XG4gICAgICBkcmF3SW1hZ2VzKGVmZkdob3N0T3BhY2l0eSwgdHJ1ZSk7XG4gICAgICBzZXR1cEJvcmRlckNvbG9yKGdob3N0T3BhY2l0eSAqIGJvcmRlck9wYWNpdHkpO1xuICAgICAgZHJhd0JvcmRlcigpO1xuICAgICAgZHJhd1BpZShkYXJrbmVzcyAhPT0gMCB8fCBib3JkZXJXaWR0aCAhPT0gMCk7XG4gICAgICBkcmF3SW1hZ2VzKGVmZkdob3N0T3BhY2l0eSwgZmFsc2UpO1xuICAgICAgZGFya2VuKGVmZkdob3N0T3BhY2l0eSk7XG4gICAgICBjb250ZXh0LnRyYW5zbGF0ZSgtZ3gsIC1neSk7XG4gICAgfVxuXG4gICAgaWYgKHVzZVBhdGhzKSB7XG4gICAgICBjb250ZXh0LnRyYW5zbGF0ZSgtcG9zLngsIC1wb3MueSk7XG4gICAgfVxuXG4gICAgZHJhd1VuZGVybGF5KCk7XG5cbiAgICBpZiAodXNlUGF0aHMpIHtcbiAgICAgIGNvbnRleHQudHJhbnNsYXRlKHBvcy54LCBwb3MueSk7XG4gICAgfVxuXG4gICAgc2V0dXBTaGFwZUNvbG9yKCk7XG4gICAgZHJhd1NoYXBlKCk7XG4gICAgZHJhd0ltYWdlcyhlbGVPcGFjaXR5LCB0cnVlKTtcbiAgICBzZXR1cEJvcmRlckNvbG9yKCk7XG4gICAgZHJhd0JvcmRlcigpO1xuICAgIGRyYXdQaWUoZGFya25lc3MgIT09IDAgfHwgYm9yZGVyV2lkdGggIT09IDApO1xuICAgIGRyYXdJbWFnZXMoZWxlT3BhY2l0eSwgZmFsc2UpO1xuICAgIGRhcmtlbigpO1xuXG4gICAgaWYgKHVzZVBhdGhzKSB7XG4gICAgICBjb250ZXh0LnRyYW5zbGF0ZSgtcG9zLngsIC1wb3MueSk7XG4gICAgfVxuXG4gICAgZHJhd1RleHQoKTtcbiAgICBkcmF3T3ZlcmxheSgpOyAvL1xuICAgIC8vIGNsZWFuIHVwIHNoaWZ0XG5cbiAgICBpZiAoc2hpZnRUb09yaWdpbldpdGhCYikge1xuICAgICAgY29udGV4dC50cmFuc2xhdGUoYmIueDEsIGJiLnkxKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGRyYXdOb2RlT3ZlcmxheVVuZGVybGF5ID0gZnVuY3Rpb24gZHJhd05vZGVPdmVybGF5VW5kZXJsYXkob3ZlcmxheU9yVW5kZXJsYXkpIHtcbiAgICBpZiAoIVsnb3ZlcmxheScsICd1bmRlcmxheSddLmluY2x1ZGVzKG92ZXJsYXlPclVuZGVybGF5KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0YXRlJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjb250ZXh0LCBub2RlLCBwb3MsIG5vZGVXaWR0aCwgbm9kZUhlaWdodCkge1xuICAgICAgdmFyIHIgPSB0aGlzO1xuXG4gICAgICBpZiAoIW5vZGUudmlzaWJsZSgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHBhZGRpbmcgPSBub2RlLnBzdHlsZShcIlwiLmNvbmNhdChvdmVybGF5T3JVbmRlcmxheSwgXCItcGFkZGluZ1wiKSkucGZWYWx1ZTtcbiAgICAgIHZhciBvcGFjaXR5ID0gbm9kZS5wc3R5bGUoXCJcIi5jb25jYXQob3ZlcmxheU9yVW5kZXJsYXksIFwiLW9wYWNpdHlcIikpLnZhbHVlO1xuICAgICAgdmFyIGNvbG9yID0gbm9kZS5wc3R5bGUoXCJcIi5jb25jYXQob3ZlcmxheU9yVW5kZXJsYXksIFwiLWNvbG9yXCIpKS52YWx1ZTtcbiAgICAgIHZhciBzaGFwZSA9IG5vZGUucHN0eWxlKFwiXCIuY29uY2F0KG92ZXJsYXlPclVuZGVybGF5LCBcIi1zaGFwZVwiKSkudmFsdWU7XG5cbiAgICAgIGlmIChvcGFjaXR5ID4gMCkge1xuICAgICAgICBwb3MgPSBwb3MgfHwgbm9kZS5wb3NpdGlvbigpO1xuXG4gICAgICAgIGlmIChub2RlV2lkdGggPT0gbnVsbCB8fCBub2RlSGVpZ2h0ID09IG51bGwpIHtcbiAgICAgICAgICB2YXIgX3BhZGRpbmcgPSBub2RlLnBhZGRpbmcoKTtcblxuICAgICAgICAgIG5vZGVXaWR0aCA9IG5vZGUud2lkdGgoKSArIDIgKiBfcGFkZGluZztcbiAgICAgICAgICBub2RlSGVpZ2h0ID0gbm9kZS5oZWlnaHQoKSArIDIgKiBfcGFkZGluZztcbiAgICAgICAgfVxuXG4gICAgICAgIHIuY29sb3JGaWxsU3R5bGUoY29udGV4dCwgY29sb3JbMF0sIGNvbG9yWzFdLCBjb2xvclsyXSwgb3BhY2l0eSk7XG4gICAgICAgIHIubm9kZVNoYXBlc1tzaGFwZV0uZHJhdyhjb250ZXh0LCBwb3MueCwgcG9zLnksIG5vZGVXaWR0aCArIHBhZGRpbmcgKiAyLCBub2RlSGVpZ2h0ICsgcGFkZGluZyAqIDIpO1xuICAgICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIENScCQ1LmRyYXdOb2RlT3ZlcmxheSA9IGRyYXdOb2RlT3ZlcmxheVVuZGVybGF5KCdvdmVybGF5Jyk7XG4gIENScCQ1LmRyYXdOb2RlVW5kZXJsYXkgPSBkcmF3Tm9kZU92ZXJsYXlVbmRlcmxheSgndW5kZXJsYXknKTsgLy8gZG9lcyB0aGUgbm9kZSBoYXZlIGF0IGxlYXN0IG9uZSBwaWUgcGllY2U/XG5cbiAgQ1JwJDUuaGFzUGllID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBub2RlID0gbm9kZVswXTsgLy8gZW5zdXJlIGVsZSByZWZcblxuICAgIHJldHVybiBub2RlLl9wcml2YXRlLmhhc1BpZTtcbiAgfTtcblxuICBDUnAkNS5kcmF3UGllID0gZnVuY3Rpb24gKGNvbnRleHQsIG5vZGUsIG5vZGVPcGFjaXR5LCBwb3MpIHtcbiAgICBub2RlID0gbm9kZVswXTsgLy8gZW5zdXJlIGVsZSByZWZcblxuICAgIHBvcyA9IHBvcyB8fCBub2RlLnBvc2l0aW9uKCk7XG4gICAgdmFyIGN5U3R5bGUgPSBub2RlLmN5KCkuc3R5bGUoKTtcbiAgICB2YXIgcGllU2l6ZSA9IG5vZGUucHN0eWxlKCdwaWUtc2l6ZScpO1xuICAgIHZhciB4ID0gcG9zLng7XG4gICAgdmFyIHkgPSBwb3MueTtcbiAgICB2YXIgbm9kZVcgPSBub2RlLndpZHRoKCk7XG4gICAgdmFyIG5vZGVIID0gbm9kZS5oZWlnaHQoKTtcbiAgICB2YXIgcmFkaXVzID0gTWF0aC5taW4obm9kZVcsIG5vZGVIKSAvIDI7IC8vIG11c3QgZml0IGluIG5vZGVcblxuICAgIHZhciBsYXN0UGVyY2VudCA9IDA7IC8vIHdoYXQgJSB0byBjb250aW51ZSBkcmF3aW5nIHBpZSBzbGljZXMgZnJvbSBvbiBbMCwgMV1cblxuICAgIHZhciB1c2VQYXRocyA9IHRoaXMudXNlUGF0aHMoKTtcblxuICAgIGlmICh1c2VQYXRocykge1xuICAgICAgeCA9IDA7XG4gICAgICB5ID0gMDtcbiAgICB9XG5cbiAgICBpZiAocGllU2l6ZS51bml0cyA9PT0gJyUnKSB7XG4gICAgICByYWRpdXMgPSByYWRpdXMgKiBwaWVTaXplLnBmVmFsdWU7XG4gICAgfSBlbHNlIGlmIChwaWVTaXplLnBmVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmFkaXVzID0gcGllU2l6ZS5wZlZhbHVlIC8gMjtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBjeVN0eWxlLnBpZUJhY2tncm91bmROOyBpKyspIHtcbiAgICAgIC8vIDEuLk5cbiAgICAgIHZhciBzaXplID0gbm9kZS5wc3R5bGUoJ3BpZS0nICsgaSArICctYmFja2dyb3VuZC1zaXplJykudmFsdWU7XG4gICAgICB2YXIgY29sb3IgPSBub2RlLnBzdHlsZSgncGllLScgKyBpICsgJy1iYWNrZ3JvdW5kLWNvbG9yJykudmFsdWU7XG4gICAgICB2YXIgb3BhY2l0eSA9IG5vZGUucHN0eWxlKCdwaWUtJyArIGkgKyAnLWJhY2tncm91bmQtb3BhY2l0eScpLnZhbHVlICogbm9kZU9wYWNpdHk7XG4gICAgICB2YXIgcGVyY2VudCA9IHNpemUgLyAxMDA7IC8vIG1hcCBpbnRlZ2VyIHJhbmdlIFswLCAxMDBdIHRvIFswLCAxXVxuICAgICAgLy8gcGVyY2VudCBjYW4ndCBwdXNoIGJleW9uZCAxXG5cbiAgICAgIGlmIChwZXJjZW50ICsgbGFzdFBlcmNlbnQgPiAxKSB7XG4gICAgICAgIHBlcmNlbnQgPSAxIC0gbGFzdFBlcmNlbnQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBhbmdsZVN0YXJ0ID0gMS41ICogTWF0aC5QSSArIDIgKiBNYXRoLlBJICogbGFzdFBlcmNlbnQ7IC8vIHN0YXJ0IGF0IDEyIG8nY2xvY2sgYW5kIGdvIGNsb2Nrd2lzZVxuXG4gICAgICB2YXIgYW5nbGVEZWx0YSA9IDIgKiBNYXRoLlBJICogcGVyY2VudDtcbiAgICAgIHZhciBhbmdsZUVuZCA9IGFuZ2xlU3RhcnQgKyBhbmdsZURlbHRhOyAvLyBpZ25vcmUgaWZcbiAgICAgIC8vIC0gemVybyBzaXplXG4gICAgICAvLyAtIHdlJ3JlIGFscmVhZHkgYmV5b25kIHRoZSBmdWxsIGNpcmNsZVxuICAgICAgLy8gLSBhZGRpbmcgdGhlIGN1cnJlbnQgc2xpY2Ugd291bGQgZ28gYmV5b25kIHRoZSBmdWxsIGNpcmNsZVxuXG4gICAgICBpZiAoc2l6ZSA9PT0gMCB8fCBsYXN0UGVyY2VudCA+PSAxIHx8IGxhc3RQZXJjZW50ICsgcGVyY2VudCA+IDEpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICBjb250ZXh0Lm1vdmVUbyh4LCB5KTtcbiAgICAgIGNvbnRleHQuYXJjKHgsIHksIHJhZGl1cywgYW5nbGVTdGFydCwgYW5nbGVFbmQpO1xuICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgIHRoaXMuY29sb3JGaWxsU3R5bGUoY29udGV4dCwgY29sb3JbMF0sIGNvbG9yWzFdLCBjb2xvclsyXSwgb3BhY2l0eSk7XG4gICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICAgIGxhc3RQZXJjZW50ICs9IHBlcmNlbnQ7XG4gICAgfVxuICB9O1xuXG4gIHZhciBDUnAkNCA9IHt9O1xuICB2YXIgbW90aW9uQmx1ckRlbGF5ID0gMTAwOyAvLyB2YXIgaXNGaXJlZm94ID0gdHlwZW9mIEluc3RhbGxUcmlnZ2VyICE9PSAndW5kZWZpbmVkJztcblxuICBDUnAkNC5nZXRQaXhlbFJhdGlvID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjb250ZXh0ID0gdGhpcy5kYXRhLmNvbnRleHRzWzBdO1xuXG4gICAgaWYgKHRoaXMuZm9yY2VkUGl4ZWxSYXRpbyAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcy5mb3JjZWRQaXhlbFJhdGlvO1xuICAgIH1cblxuICAgIHZhciBiYWNraW5nU3RvcmUgPSBjb250ZXh0LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY29udGV4dC53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGNvbnRleHQubW96QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjb250ZXh0Lm1zQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjb250ZXh0Lm9CYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGNvbnRleHQuYmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCAxO1xuICAgIHJldHVybiAod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSkgLyBiYWNraW5nU3RvcmU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgfTtcblxuICBDUnAkNC5wYWludENhY2hlID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICB2YXIgY2FjaGVzID0gdGhpcy5wYWludENhY2hlcyA9IHRoaXMucGFpbnRDYWNoZXMgfHwgW107XG4gICAgdmFyIG5lZWRUb0NyZWF0ZUNhY2hlID0gdHJ1ZTtcbiAgICB2YXIgY2FjaGU7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhY2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY2FjaGUgPSBjYWNoZXNbaV07XG5cbiAgICAgIGlmIChjYWNoZS5jb250ZXh0ID09PSBjb250ZXh0KSB7XG4gICAgICAgIG5lZWRUb0NyZWF0ZUNhY2hlID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChuZWVkVG9DcmVhdGVDYWNoZSkge1xuICAgICAgY2FjaGUgPSB7XG4gICAgICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgICAgIH07XG4gICAgICBjYWNoZXMucHVzaChjYWNoZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNhY2hlO1xuICB9O1xuXG4gIENScCQ0LmNyZWF0ZUdyYWRpZW50U3R5bGVGb3IgPSBmdW5jdGlvbiAoY29udGV4dCwgc2hhcGVTdHlsZU5hbWUsIGVsZSwgZmlsbCwgb3BhY2l0eSkge1xuICAgIHZhciBncmFkaWVudFN0eWxlO1xuICAgIHZhciB1c2VQYXRocyA9IHRoaXMudXNlUGF0aHMoKTtcbiAgICB2YXIgY29sb3JzID0gZWxlLnBzdHlsZShzaGFwZVN0eWxlTmFtZSArICctZ3JhZGllbnQtc3RvcC1jb2xvcnMnKS52YWx1ZSxcbiAgICAgICAgcG9zaXRpb25zID0gZWxlLnBzdHlsZShzaGFwZVN0eWxlTmFtZSArICctZ3JhZGllbnQtc3RvcC1wb3NpdGlvbnMnKS5wZlZhbHVlO1xuXG4gICAgaWYgKGZpbGwgPT09ICdyYWRpYWwtZ3JhZGllbnQnKSB7XG4gICAgICBpZiAoZWxlLmlzRWRnZSgpKSB7XG4gICAgICAgIHZhciBzdGFydCA9IGVsZS5zb3VyY2VFbmRwb2ludCgpLFxuICAgICAgICAgICAgZW5kID0gZWxlLnRhcmdldEVuZHBvaW50KCksXG4gICAgICAgICAgICBtaWQgPSBlbGUubWlkcG9pbnQoKTtcbiAgICAgICAgdmFyIGQxID0gZGlzdChzdGFydCwgbWlkKTtcbiAgICAgICAgdmFyIGQyID0gZGlzdChlbmQsIG1pZCk7XG4gICAgICAgIGdyYWRpZW50U3R5bGUgPSBjb250ZXh0LmNyZWF0ZVJhZGlhbEdyYWRpZW50KG1pZC54LCBtaWQueSwgMCwgbWlkLngsIG1pZC55LCBNYXRoLm1heChkMSwgZDIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwb3MgPSB1c2VQYXRocyA/IHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDBcbiAgICAgICAgfSA6IGVsZS5wb3NpdGlvbigpLFxuICAgICAgICAgICAgd2lkdGggPSBlbGUucGFkZGVkV2lkdGgoKSxcbiAgICAgICAgICAgIGhlaWdodCA9IGVsZS5wYWRkZWRIZWlnaHQoKTtcbiAgICAgICAgZ3JhZGllbnRTdHlsZSA9IGNvbnRleHQuY3JlYXRlUmFkaWFsR3JhZGllbnQocG9zLngsIHBvcy55LCAwLCBwb3MueCwgcG9zLnksIE1hdGgubWF4KHdpZHRoLCBoZWlnaHQpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGVsZS5pc0VkZ2UoKSkge1xuICAgICAgICB2YXIgX3N0YXJ0ID0gZWxlLnNvdXJjZUVuZHBvaW50KCksXG4gICAgICAgICAgICBfZW5kID0gZWxlLnRhcmdldEVuZHBvaW50KCk7XG5cbiAgICAgICAgZ3JhZGllbnRTdHlsZSA9IGNvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQoX3N0YXJ0LngsIF9zdGFydC55LCBfZW5kLngsIF9lbmQueSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX3BvcyA9IHVzZVBhdGhzID8ge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMFxuICAgICAgICB9IDogZWxlLnBvc2l0aW9uKCksXG4gICAgICAgICAgICBfd2lkdGggPSBlbGUucGFkZGVkV2lkdGgoKSxcbiAgICAgICAgICAgIF9oZWlnaHQgPSBlbGUucGFkZGVkSGVpZ2h0KCksXG4gICAgICAgICAgICBoYWxmV2lkdGggPSBfd2lkdGggLyAyLFxuICAgICAgICAgICAgaGFsZkhlaWdodCA9IF9oZWlnaHQgLyAyO1xuXG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSBlbGUucHN0eWxlKCdiYWNrZ3JvdW5kLWdyYWRpZW50LWRpcmVjdGlvbicpLnZhbHVlO1xuXG4gICAgICAgIHN3aXRjaCAoZGlyZWN0aW9uKSB7XG4gICAgICAgICAgY2FzZSAndG8tYm90dG9tJzpcbiAgICAgICAgICAgIGdyYWRpZW50U3R5bGUgPSBjb250ZXh0LmNyZWF0ZUxpbmVhckdyYWRpZW50KF9wb3MueCwgX3Bvcy55IC0gaGFsZkhlaWdodCwgX3Bvcy54LCBfcG9zLnkgKyBoYWxmSGVpZ2h0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAndG8tdG9wJzpcbiAgICAgICAgICAgIGdyYWRpZW50U3R5bGUgPSBjb250ZXh0LmNyZWF0ZUxpbmVhckdyYWRpZW50KF9wb3MueCwgX3Bvcy55ICsgaGFsZkhlaWdodCwgX3Bvcy54LCBfcG9zLnkgLSBoYWxmSGVpZ2h0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAndG8tbGVmdCc6XG4gICAgICAgICAgICBncmFkaWVudFN0eWxlID0gY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudChfcG9zLnggKyBoYWxmV2lkdGgsIF9wb3MueSwgX3Bvcy54IC0gaGFsZldpZHRoLCBfcG9zLnkpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd0by1yaWdodCc6XG4gICAgICAgICAgICBncmFkaWVudFN0eWxlID0gY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudChfcG9zLnggLSBoYWxmV2lkdGgsIF9wb3MueSwgX3Bvcy54ICsgaGFsZldpZHRoLCBfcG9zLnkpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd0by1ib3R0b20tcmlnaHQnOlxuICAgICAgICAgIGNhc2UgJ3RvLXJpZ2h0LWJvdHRvbSc6XG4gICAgICAgICAgICBncmFkaWVudFN0eWxlID0gY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudChfcG9zLnggLSBoYWxmV2lkdGgsIF9wb3MueSAtIGhhbGZIZWlnaHQsIF9wb3MueCArIGhhbGZXaWR0aCwgX3Bvcy55ICsgaGFsZkhlaWdodCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3RvLXRvcC1yaWdodCc6XG4gICAgICAgICAgY2FzZSAndG8tcmlnaHQtdG9wJzpcbiAgICAgICAgICAgIGdyYWRpZW50U3R5bGUgPSBjb250ZXh0LmNyZWF0ZUxpbmVhckdyYWRpZW50KF9wb3MueCAtIGhhbGZXaWR0aCwgX3Bvcy55ICsgaGFsZkhlaWdodCwgX3Bvcy54ICsgaGFsZldpZHRoLCBfcG9zLnkgLSBoYWxmSGVpZ2h0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAndG8tYm90dG9tLWxlZnQnOlxuICAgICAgICAgIGNhc2UgJ3RvLWxlZnQtYm90dG9tJzpcbiAgICAgICAgICAgIGdyYWRpZW50U3R5bGUgPSBjb250ZXh0LmNyZWF0ZUxpbmVhckdyYWRpZW50KF9wb3MueCArIGhhbGZXaWR0aCwgX3Bvcy55IC0gaGFsZkhlaWdodCwgX3Bvcy54IC0gaGFsZldpZHRoLCBfcG9zLnkgKyBoYWxmSGVpZ2h0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAndG8tdG9wLWxlZnQnOlxuICAgICAgICAgIGNhc2UgJ3RvLWxlZnQtdG9wJzpcbiAgICAgICAgICAgIGdyYWRpZW50U3R5bGUgPSBjb250ZXh0LmNyZWF0ZUxpbmVhckdyYWRpZW50KF9wb3MueCArIGhhbGZXaWR0aCwgX3Bvcy55ICsgaGFsZkhlaWdodCwgX3Bvcy54IC0gaGFsZldpZHRoLCBfcG9zLnkgLSBoYWxmSGVpZ2h0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFncmFkaWVudFN0eWxlKSByZXR1cm4gbnVsbDsgLy8gaW52YWxpZCBncmFkaWVudCBzdHlsZVxuXG4gICAgdmFyIGhhc1Bvc2l0aW9ucyA9IHBvc2l0aW9ucy5sZW5ndGggPT09IGNvbG9ycy5sZW5ndGg7XG4gICAgdmFyIGxlbmd0aCA9IGNvbG9ycy5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBncmFkaWVudFN0eWxlLmFkZENvbG9yU3RvcChoYXNQb3NpdGlvbnMgPyBwb3NpdGlvbnNbaV0gOiBpIC8gKGxlbmd0aCAtIDEpLCAncmdiYSgnICsgY29sb3JzW2ldWzBdICsgJywnICsgY29sb3JzW2ldWzFdICsgJywnICsgY29sb3JzW2ldWzJdICsgJywnICsgb3BhY2l0eSArICcpJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdyYWRpZW50U3R5bGU7XG4gIH07XG5cbiAgQ1JwJDQuZ3JhZGllbnRGaWxsU3R5bGUgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlLCBmaWxsLCBvcGFjaXR5KSB7XG4gICAgdmFyIGdyYWRpZW50U3R5bGUgPSB0aGlzLmNyZWF0ZUdyYWRpZW50U3R5bGVGb3IoY29udGV4dCwgJ2JhY2tncm91bmQnLCBlbGUsIGZpbGwsIG9wYWNpdHkpO1xuICAgIGlmICghZ3JhZGllbnRTdHlsZSkgcmV0dXJuIG51bGw7IC8vIGVycm9yXG5cbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGdyYWRpZW50U3R5bGU7XG4gIH07XG5cbiAgQ1JwJDQuY29sb3JGaWxsU3R5bGUgPSBmdW5jdGlvbiAoY29udGV4dCwgciwgZywgYiwgYSkge1xuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJ3JnYmEoJyArIHIgKyAnLCcgKyBnICsgJywnICsgYiArICcsJyArIGEgKyAnKSc7IC8vIHR1cm4gb2ZmIGZvciBub3csIHNlZW1zIGNvbnRleHQgZG9lcyBpdHMgb3duIGNhY2hpbmdcbiAgICAvLyB2YXIgY2FjaGUgPSB0aGlzLnBhaW50Q2FjaGUoY29udGV4dCk7XG4gICAgLy8gdmFyIGZpbGxTdHlsZSA9ICdyZ2JhKCcgKyByICsgJywnICsgZyArICcsJyArIGIgKyAnLCcgKyBhICsgJyknO1xuICAgIC8vIGlmKCBjYWNoZS5maWxsU3R5bGUgIT09IGZpbGxTdHlsZSApe1xuICAgIC8vICAgY29udGV4dC5maWxsU3R5bGUgPSBjYWNoZS5maWxsU3R5bGUgPSBmaWxsU3R5bGU7XG4gICAgLy8gfVxuICB9O1xuXG4gIENScCQ0LmVsZUZpbGxTdHlsZSA9IGZ1bmN0aW9uIChjb250ZXh0LCBlbGUsIG9wYWNpdHkpIHtcbiAgICB2YXIgYmFja2dyb3VuZEZpbGwgPSBlbGUucHN0eWxlKCdiYWNrZ3JvdW5kLWZpbGwnKS52YWx1ZTtcblxuICAgIGlmIChiYWNrZ3JvdW5kRmlsbCA9PT0gJ2xpbmVhci1ncmFkaWVudCcgfHwgYmFja2dyb3VuZEZpbGwgPT09ICdyYWRpYWwtZ3JhZGllbnQnKSB7XG4gICAgICB0aGlzLmdyYWRpZW50RmlsbFN0eWxlKGNvbnRleHQsIGVsZSwgYmFja2dyb3VuZEZpbGwsIG9wYWNpdHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYmFja2dyb3VuZENvbG9yID0gZWxlLnBzdHlsZSgnYmFja2dyb3VuZC1jb2xvcicpLnZhbHVlO1xuICAgICAgdGhpcy5jb2xvckZpbGxTdHlsZShjb250ZXh0LCBiYWNrZ3JvdW5kQ29sb3JbMF0sIGJhY2tncm91bmRDb2xvclsxXSwgYmFja2dyb3VuZENvbG9yWzJdLCBvcGFjaXR5KTtcbiAgICB9XG4gIH07XG5cbiAgQ1JwJDQuZ3JhZGllbnRTdHJva2VTdHlsZSA9IGZ1bmN0aW9uIChjb250ZXh0LCBlbGUsIGZpbGwsIG9wYWNpdHkpIHtcbiAgICB2YXIgZ3JhZGllbnRTdHlsZSA9IHRoaXMuY3JlYXRlR3JhZGllbnRTdHlsZUZvcihjb250ZXh0LCAnbGluZScsIGVsZSwgZmlsbCwgb3BhY2l0eSk7XG4gICAgaWYgKCFncmFkaWVudFN0eWxlKSByZXR1cm4gbnVsbDsgLy8gZXJyb3JcblxuICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBncmFkaWVudFN0eWxlO1xuICB9O1xuXG4gIENScCQ0LmNvbG9yU3Ryb2tlU3R5bGUgPSBmdW5jdGlvbiAoY29udGV4dCwgciwgZywgYiwgYSkge1xuICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAncmdiYSgnICsgciArICcsJyArIGcgKyAnLCcgKyBiICsgJywnICsgYSArICcpJzsgLy8gdHVybiBvZmYgZm9yIG5vdywgc2VlbXMgY29udGV4dCBkb2VzIGl0cyBvd24gY2FjaGluZ1xuICAgIC8vIHZhciBjYWNoZSA9IHRoaXMucGFpbnRDYWNoZShjb250ZXh0KTtcbiAgICAvLyB2YXIgc3Ryb2tlU3R5bGUgPSAncmdiYSgnICsgciArICcsJyArIGcgKyAnLCcgKyBiICsgJywnICsgYSArICcpJztcbiAgICAvLyBpZiggY2FjaGUuc3Ryb2tlU3R5bGUgIT09IHN0cm9rZVN0eWxlICl7XG4gICAgLy8gICBjb250ZXh0LnN0cm9rZVN0eWxlID0gY2FjaGUuc3Ryb2tlU3R5bGUgPSBzdHJva2VTdHlsZTtcbiAgICAvLyB9XG4gIH07XG5cbiAgQ1JwJDQuZWxlU3Ryb2tlU3R5bGUgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlLCBvcGFjaXR5KSB7XG4gICAgdmFyIGxpbmVGaWxsID0gZWxlLnBzdHlsZSgnbGluZS1maWxsJykudmFsdWU7XG5cbiAgICBpZiAobGluZUZpbGwgPT09ICdsaW5lYXItZ3JhZGllbnQnIHx8IGxpbmVGaWxsID09PSAncmFkaWFsLWdyYWRpZW50Jykge1xuICAgICAgdGhpcy5ncmFkaWVudFN0cm9rZVN0eWxlKGNvbnRleHQsIGVsZSwgbGluZUZpbGwsIG9wYWNpdHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbGluZUNvbG9yID0gZWxlLnBzdHlsZSgnbGluZS1jb2xvcicpLnZhbHVlO1xuICAgICAgdGhpcy5jb2xvclN0cm9rZVN0eWxlKGNvbnRleHQsIGxpbmVDb2xvclswXSwgbGluZUNvbG9yWzFdLCBsaW5lQ29sb3JbMl0sIG9wYWNpdHkpO1xuICAgIH1cbiAgfTsgLy8gUmVzaXplIGNhbnZhc1xuXG5cbiAgQ1JwJDQubWF0Y2hDYW52YXNTaXplID0gZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgIHZhciByID0gdGhpcztcbiAgICB2YXIgZGF0YSA9IHIuZGF0YTtcbiAgICB2YXIgYmIgPSByLmZpbmRDb250YWluZXJDbGllbnRDb29yZHMoKTtcbiAgICB2YXIgd2lkdGggPSBiYlsyXTtcbiAgICB2YXIgaGVpZ2h0ID0gYmJbM107XG4gICAgdmFyIHBpeGVsUmF0aW8gPSByLmdldFBpeGVsUmF0aW8oKTtcbiAgICB2YXIgbWJQeFJhdGlvID0gci5tb3Rpb25CbHVyUHhSYXRpbztcblxuICAgIGlmIChjb250YWluZXIgPT09IHIuZGF0YS5idWZmZXJDYW52YXNlc1tyLk1PVElPTkJMVVJfQlVGRkVSX05PREVdIHx8IGNvbnRhaW5lciA9PT0gci5kYXRhLmJ1ZmZlckNhbnZhc2VzW3IuTU9USU9OQkxVUl9CVUZGRVJfRFJBR10pIHtcbiAgICAgIHBpeGVsUmF0aW8gPSBtYlB4UmF0aW87XG4gICAgfVxuXG4gICAgdmFyIGNhbnZhc1dpZHRoID0gd2lkdGggKiBwaXhlbFJhdGlvO1xuICAgIHZhciBjYW52YXNIZWlnaHQgPSBoZWlnaHQgKiBwaXhlbFJhdGlvO1xuICAgIHZhciBjYW52YXM7XG5cbiAgICBpZiAoY2FudmFzV2lkdGggPT09IHIuY2FudmFzV2lkdGggJiYgY2FudmFzSGVpZ2h0ID09PSByLmNhbnZhc0hlaWdodCkge1xuICAgICAgcmV0dXJuOyAvLyBzYXZlIGN5Y2xlcyBpZiBzYW1lXG4gICAgfVxuXG4gICAgci5mb250Q2FjaGVzID0gbnVsbDsgLy8gcmVzaXppbmcgcmVzZXRzIHRoZSBzdHlsZVxuXG4gICAgdmFyIGNhbnZhc0NvbnRhaW5lciA9IGRhdGEuY2FudmFzQ29udGFpbmVyO1xuICAgIGNhbnZhc0NvbnRhaW5lci5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICBjYW52YXNDb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgci5DQU5WQVNfTEFZRVJTOyBpKyspIHtcbiAgICAgIGNhbnZhcyA9IGRhdGEuY2FudmFzZXNbaV07XG4gICAgICBjYW52YXMud2lkdGggPSBjYW52YXNXaWR0aDtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXNIZWlnaHQ7XG4gICAgICBjYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHIuQlVGRkVSX0NPVU5UOyBpKyspIHtcbiAgICAgIGNhbnZhcyA9IGRhdGEuYnVmZmVyQ2FudmFzZXNbaV07XG4gICAgICBjYW52YXMud2lkdGggPSBjYW52YXNXaWR0aDtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXNIZWlnaHQ7XG4gICAgICBjYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgICB9XG5cbiAgICByLnRleHR1cmVNdWx0ID0gMTtcblxuICAgIGlmIChwaXhlbFJhdGlvIDw9IDEpIHtcbiAgICAgIGNhbnZhcyA9IGRhdGEuYnVmZmVyQ2FudmFzZXNbci5URVhUVVJFX0JVRkZFUl07XG4gICAgICByLnRleHR1cmVNdWx0ID0gMjtcbiAgICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhc1dpZHRoICogci50ZXh0dXJlTXVsdDtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXNIZWlnaHQgKiByLnRleHR1cmVNdWx0O1xuICAgIH1cblxuICAgIHIuY2FudmFzV2lkdGggPSBjYW52YXNXaWR0aDtcbiAgICByLmNhbnZhc0hlaWdodCA9IGNhbnZhc0hlaWdodDtcbiAgfTtcblxuICBDUnAkNC5yZW5kZXJUbyA9IGZ1bmN0aW9uIChjeHQsIHpvb20sIHBhbiwgcHhSYXRpbykge1xuICAgIHRoaXMucmVuZGVyKHtcbiAgICAgIGZvcmNlZENvbnRleHQ6IGN4dCxcbiAgICAgIGZvcmNlZFpvb206IHpvb20sXG4gICAgICBmb3JjZWRQYW46IHBhbixcbiAgICAgIGRyYXdBbGxMYXllcnM6IHRydWUsXG4gICAgICBmb3JjZWRQeFJhdGlvOiBweFJhdGlvXG4gICAgfSk7XG4gIH07XG5cbiAgQ1JwJDQucmVuZGVyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCBzdGF0aWNFbXB0eU9iamVjdCgpO1xuICAgIHZhciBmb3JjZWRDb250ZXh0ID0gb3B0aW9ucy5mb3JjZWRDb250ZXh0O1xuICAgIHZhciBkcmF3QWxsTGF5ZXJzID0gb3B0aW9ucy5kcmF3QWxsTGF5ZXJzO1xuICAgIHZhciBkcmF3T25seU5vZGVMYXllciA9IG9wdGlvbnMuZHJhd09ubHlOb2RlTGF5ZXI7XG4gICAgdmFyIGZvcmNlZFpvb20gPSBvcHRpb25zLmZvcmNlZFpvb207XG4gICAgdmFyIGZvcmNlZFBhbiA9IG9wdGlvbnMuZm9yY2VkUGFuO1xuICAgIHZhciByID0gdGhpcztcbiAgICB2YXIgcGl4ZWxSYXRpbyA9IG9wdGlvbnMuZm9yY2VkUHhSYXRpbyA9PT0gdW5kZWZpbmVkID8gdGhpcy5nZXRQaXhlbFJhdGlvKCkgOiBvcHRpb25zLmZvcmNlZFB4UmF0aW87XG4gICAgdmFyIGN5ID0gci5jeTtcbiAgICB2YXIgZGF0YSA9IHIuZGF0YTtcbiAgICB2YXIgbmVlZERyYXcgPSBkYXRhLmNhbnZhc05lZWRzUmVkcmF3O1xuICAgIHZhciB0ZXh0dXJlRHJhdyA9IHIudGV4dHVyZU9uVmlld3BvcnQgJiYgIWZvcmNlZENvbnRleHQgJiYgKHIucGluY2hpbmcgfHwgci5ob3ZlckRhdGEuZHJhZ2dpbmcgfHwgci5zd2lwZVBhbm5pbmcgfHwgci5kYXRhLndoZWVsWm9vbWluZyk7XG4gICAgdmFyIG1vdGlvbkJsdXIgPSBvcHRpb25zLm1vdGlvbkJsdXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubW90aW9uQmx1ciA6IHIubW90aW9uQmx1cjtcbiAgICB2YXIgbWJQeFJhdGlvID0gci5tb3Rpb25CbHVyUHhSYXRpbztcbiAgICB2YXIgaGFzQ29tcG91bmROb2RlcyA9IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcbiAgICB2YXIgaW5Ob2RlRHJhZ0dlc3R1cmUgPSByLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXM7XG4gICAgdmFyIGluQm94U2VsZWN0aW9uID0gci5ob3ZlckRhdGEuc2VsZWN0aW5nIHx8IHIudG91Y2hEYXRhLnNlbGVjdGluZyA/IHRydWUgOiBmYWxzZTtcbiAgICBtb3Rpb25CbHVyID0gbW90aW9uQmx1ciAmJiAhZm9yY2VkQ29udGV4dCAmJiByLm1vdGlvbkJsdXJFbmFibGVkICYmICFpbkJveFNlbGVjdGlvbjtcbiAgICB2YXIgbW90aW9uQmx1ckZhZGVFZmZlY3QgPSBtb3Rpb25CbHVyO1xuXG4gICAgaWYgKCFmb3JjZWRDb250ZXh0KSB7XG4gICAgICBpZiAoci5wcmV2UHhSYXRpbyAhPT0gcGl4ZWxSYXRpbykge1xuICAgICAgICByLmludmFsaWRhdGVDb250YWluZXJDbGllbnRDb29yZHNDYWNoZSgpO1xuICAgICAgICByLm1hdGNoQ2FudmFzU2l6ZShyLmNvbnRhaW5lcik7XG4gICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgICByLnJlZHJhd0hpbnQoJ2RyYWcnLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgci5wcmV2UHhSYXRpbyA9IHBpeGVsUmF0aW87XG4gICAgfVxuXG4gICAgaWYgKCFmb3JjZWRDb250ZXh0ICYmIHIubW90aW9uQmx1clRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dChyLm1vdGlvbkJsdXJUaW1lb3V0KTtcbiAgICB9XG5cbiAgICBpZiAobW90aW9uQmx1cikge1xuICAgICAgaWYgKHIubWJGcmFtZXMgPT0gbnVsbCkge1xuICAgICAgICByLm1iRnJhbWVzID0gMDtcbiAgICAgIH1cblxuICAgICAgci5tYkZyYW1lcysrO1xuXG4gICAgICBpZiAoci5tYkZyYW1lcyA8IDMpIHtcbiAgICAgICAgLy8gbmVlZCBzZXZlcmFsIGZyYW1lcyBiZWZvcmUgZXZlbiBoaWdoIHF1YWxpdHkgbW90aW9uYmx1clxuICAgICAgICBtb3Rpb25CbHVyRmFkZUVmZmVjdCA9IGZhbHNlO1xuICAgICAgfSAvLyBnbyB0byBsb3dlciBxdWFsaXR5IGJsdXJyeSBmcmFtZXMgd2hlbiBzZXZlcmFsIG0vYiBmcmFtZXMgaGF2ZSBiZWVuIHJlbmRlcmVkIChhdm9pZHMgZmxhc2hpbmcpXG5cblxuICAgICAgaWYgKHIubWJGcmFtZXMgPiByLm1pbk1iTG93UXVhbEZyYW1lcykge1xuICAgICAgICAvL3IuZnVsbFF1YWxpdHlNYiA9IGZhbHNlO1xuICAgICAgICByLm1vdGlvbkJsdXJQeFJhdGlvID0gci5tYlB4UkJsdXJyeTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoci5jbGVhcmluZ01vdGlvbkJsdXIpIHtcbiAgICAgIHIubW90aW9uQmx1clB4UmF0aW8gPSAxO1xuICAgIH0gLy8gYi9jIGRyYXdUb0NvbnRleHQoKSBtYXkgYmUgYXN5bmMgdy5yLnQuIHJlZHJhdygpLCBrZWVwIHRyYWNrIG9mIGxhc3QgdGV4dHVyZSBmcmFtZVxuICAgIC8vIGJlY2F1c2UgYSByb2d1ZSBhc3luYyB0ZXh0dXJlIGZyYW1lIHdvdWxkIGNsZWFyIG5lZWREcmF3XG5cblxuICAgIGlmIChyLnRleHR1cmVEcmF3TGFzdEZyYW1lICYmICF0ZXh0dXJlRHJhdykge1xuICAgICAgbmVlZERyYXdbci5OT0RFXSA9IHRydWU7XG4gICAgICBuZWVkRHJhd1tyLlNFTEVDVF9CT1hdID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgc3R5bGUgPSBjeS5zdHlsZSgpO1xuICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuICAgIHZhciBlZmZlY3RpdmVab29tID0gZm9yY2VkWm9vbSAhPT0gdW5kZWZpbmVkID8gZm9yY2VkWm9vbSA6IHpvb207XG4gICAgdmFyIHBhbiA9IGN5LnBhbigpO1xuICAgIHZhciBlZmZlY3RpdmVQYW4gPSB7XG4gICAgICB4OiBwYW4ueCxcbiAgICAgIHk6IHBhbi55XG4gICAgfTtcbiAgICB2YXIgdnAgPSB7XG4gICAgICB6b29tOiB6b29tLFxuICAgICAgcGFuOiB7XG4gICAgICAgIHg6IHBhbi54LFxuICAgICAgICB5OiBwYW4ueVxuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHByZXZWcCA9IHIucHJldlZpZXdwb3J0O1xuICAgIHZhciB2aWV3cG9ydElzRGlmZiA9IHByZXZWcCA9PT0gdW5kZWZpbmVkIHx8IHZwLnpvb20gIT09IHByZXZWcC56b29tIHx8IHZwLnBhbi54ICE9PSBwcmV2VnAucGFuLnggfHwgdnAucGFuLnkgIT09IHByZXZWcC5wYW4ueTsgLy8gd2Ugd2FudCB0aGUgbG93IHF1YWxpdHkgbW90aW9uYmx1ciBvbmx5IHdoZW4gdGhlIHZpZXdwb3J0IGlzIGJlaW5nIG1hbmlwdWxhdGVkIGV0YyAod2hlcmUgaXQncyBub3Qgbm90aWNlZClcblxuICAgIGlmICghdmlld3BvcnRJc0RpZmYgJiYgIShpbk5vZGVEcmFnR2VzdHVyZSAmJiAhaGFzQ29tcG91bmROb2RlcykpIHtcbiAgICAgIHIubW90aW9uQmx1clB4UmF0aW8gPSAxO1xuICAgIH1cblxuICAgIGlmIChmb3JjZWRQYW4pIHtcbiAgICAgIGVmZmVjdGl2ZVBhbiA9IGZvcmNlZFBhbjtcbiAgICB9IC8vIGFwcGx5IHBpeGVsIHJhdGlvXG5cblxuICAgIGVmZmVjdGl2ZVpvb20gKj0gcGl4ZWxSYXRpbztcbiAgICBlZmZlY3RpdmVQYW4ueCAqPSBwaXhlbFJhdGlvO1xuICAgIGVmZmVjdGl2ZVBhbi55ICo9IHBpeGVsUmF0aW87XG4gICAgdmFyIGVsZXMgPSByLmdldENhY2hlZFpTb3J0ZWRFbGVzKCk7XG5cbiAgICBmdW5jdGlvbiBtYmNsZWFyKGNvbnRleHQsIHgsIHksIHcsIGgpIHtcbiAgICAgIHZhciBnY28gPSBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbjtcbiAgICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLW91dCc7XG4gICAgICByLmNvbG9yRmlsbFN0eWxlKGNvbnRleHQsIDI1NSwgMjU1LCAyNTUsIHIubW90aW9uQmx1clRyYW5zcGFyZW5jeSk7XG4gICAgICBjb250ZXh0LmZpbGxSZWN0KHgsIHksIHcsIGgpO1xuICAgICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBnY287XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0Q29udGV4dFRyYW5zZm9ybShjb250ZXh0LCBjbGVhcikge1xuICAgICAgdmFyIGVQYW4sIGVab29tLCB3LCBoO1xuXG4gICAgICBpZiAoIXIuY2xlYXJpbmdNb3Rpb25CbHVyICYmIChjb250ZXh0ID09PSBkYXRhLmJ1ZmZlckNvbnRleHRzW3IuTU9USU9OQkxVUl9CVUZGRVJfTk9ERV0gfHwgY29udGV4dCA9PT0gZGF0YS5idWZmZXJDb250ZXh0c1tyLk1PVElPTkJMVVJfQlVGRkVSX0RSQUddKSkge1xuICAgICAgICBlUGFuID0ge1xuICAgICAgICAgIHg6IHBhbi54ICogbWJQeFJhdGlvLFxuICAgICAgICAgIHk6IHBhbi55ICogbWJQeFJhdGlvXG4gICAgICAgIH07XG4gICAgICAgIGVab29tID0gem9vbSAqIG1iUHhSYXRpbztcbiAgICAgICAgdyA9IHIuY2FudmFzV2lkdGggKiBtYlB4UmF0aW87XG4gICAgICAgIGggPSByLmNhbnZhc0hlaWdodCAqIG1iUHhSYXRpbztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVQYW4gPSBlZmZlY3RpdmVQYW47XG4gICAgICAgIGVab29tID0gZWZmZWN0aXZlWm9vbTtcbiAgICAgICAgdyA9IHIuY2FudmFzV2lkdGg7XG4gICAgICAgIGggPSByLmNhbnZhc0hlaWdodDtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG5cbiAgICAgIGlmIChjbGVhciA9PT0gJ21vdGlvbkJsdXInKSB7XG4gICAgICAgIG1iY2xlYXIoY29udGV4dCwgMCwgMCwgdywgaCk7XG4gICAgICB9IGVsc2UgaWYgKCFmb3JjZWRDb250ZXh0ICYmIChjbGVhciA9PT0gdW5kZWZpbmVkIHx8IGNsZWFyKSkge1xuICAgICAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB3LCBoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFkcmF3QWxsTGF5ZXJzKSB7XG4gICAgICAgIGNvbnRleHQudHJhbnNsYXRlKGVQYW4ueCwgZVBhbi55KTtcbiAgICAgICAgY29udGV4dC5zY2FsZShlWm9vbSwgZVpvb20pO1xuICAgICAgfVxuXG4gICAgICBpZiAoZm9yY2VkUGFuKSB7XG4gICAgICAgIGNvbnRleHQudHJhbnNsYXRlKGZvcmNlZFBhbi54LCBmb3JjZWRQYW4ueSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChmb3JjZWRab29tKSB7XG4gICAgICAgIGNvbnRleHQuc2NhbGUoZm9yY2VkWm9vbSwgZm9yY2VkWm9vbSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0ZXh0dXJlRHJhdykge1xuICAgICAgci50ZXh0dXJlRHJhd0xhc3RGcmFtZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0ZXh0dXJlRHJhdykge1xuICAgICAgci50ZXh0dXJlRHJhd0xhc3RGcmFtZSA9IHRydWU7XG5cbiAgICAgIGlmICghci50ZXh0dXJlQ2FjaGUpIHtcbiAgICAgICAgci50ZXh0dXJlQ2FjaGUgPSB7fTtcbiAgICAgICAgci50ZXh0dXJlQ2FjaGUuYmIgPSBjeS5tdXRhYmxlRWxlbWVudHMoKS5ib3VuZGluZ0JveCgpO1xuICAgICAgICByLnRleHR1cmVDYWNoZS50ZXh0dXJlID0gci5kYXRhLmJ1ZmZlckNhbnZhc2VzW3IuVEVYVFVSRV9CVUZGRVJdO1xuICAgICAgICB2YXIgY3h0ID0gci5kYXRhLmJ1ZmZlckNvbnRleHRzW3IuVEVYVFVSRV9CVUZGRVJdO1xuICAgICAgICBjeHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgICBjeHQuY2xlYXJSZWN0KDAsIDAsIHIuY2FudmFzV2lkdGggKiByLnRleHR1cmVNdWx0LCByLmNhbnZhc0hlaWdodCAqIHIudGV4dHVyZU11bHQpO1xuICAgICAgICByLnJlbmRlcih7XG4gICAgICAgICAgZm9yY2VkQ29udGV4dDogY3h0LFxuICAgICAgICAgIGRyYXdPbmx5Tm9kZUxheWVyOiB0cnVlLFxuICAgICAgICAgIGZvcmNlZFB4UmF0aW86IHBpeGVsUmF0aW8gKiByLnRleHR1cmVNdWx0XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgdnAgPSByLnRleHR1cmVDYWNoZS52aWV3cG9ydCA9IHtcbiAgICAgICAgICB6b29tOiBjeS56b29tKCksXG4gICAgICAgICAgcGFuOiBjeS5wYW4oKSxcbiAgICAgICAgICB3aWR0aDogci5jYW52YXNXaWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IHIuY2FudmFzSGVpZ2h0XG4gICAgICAgIH07XG4gICAgICAgIHZwLm1wYW4gPSB7XG4gICAgICAgICAgeDogKDAgLSB2cC5wYW4ueCkgLyB2cC56b29tLFxuICAgICAgICAgIHk6ICgwIC0gdnAucGFuLnkpIC8gdnAuem9vbVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBuZWVkRHJhd1tyLkRSQUddID0gZmFsc2U7XG4gICAgICBuZWVkRHJhd1tyLk5PREVdID0gZmFsc2U7XG4gICAgICB2YXIgY29udGV4dCA9IGRhdGEuY29udGV4dHNbci5OT0RFXTtcbiAgICAgIHZhciB0ZXh0dXJlID0gci50ZXh0dXJlQ2FjaGUudGV4dHVyZTtcbiAgICAgIHZhciB2cCA9IHIudGV4dHVyZUNhY2hlLnZpZXdwb3J0O1xuICAgICAgY29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG5cbiAgICAgIGlmIChtb3Rpb25CbHVyKSB7XG4gICAgICAgIG1iY2xlYXIoY29udGV4dCwgMCwgMCwgdnAud2lkdGgsIHZwLmhlaWdodCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB2cC53aWR0aCwgdnAuaGVpZ2h0KTtcbiAgICAgIH1cblxuICAgICAgdmFyIG91dHNpZGVCZ0NvbG9yID0gc3R5bGUuY29yZSgnb3V0c2lkZS10ZXh0dXJlLWJnLWNvbG9yJykudmFsdWU7XG4gICAgICB2YXIgb3V0c2lkZUJnT3BhY2l0eSA9IHN0eWxlLmNvcmUoJ291dHNpZGUtdGV4dHVyZS1iZy1vcGFjaXR5JykudmFsdWU7XG4gICAgICByLmNvbG9yRmlsbFN0eWxlKGNvbnRleHQsIG91dHNpZGVCZ0NvbG9yWzBdLCBvdXRzaWRlQmdDb2xvclsxXSwgb3V0c2lkZUJnQ29sb3JbMl0sIG91dHNpZGVCZ09wYWNpdHkpO1xuICAgICAgY29udGV4dC5maWxsUmVjdCgwLCAwLCB2cC53aWR0aCwgdnAuaGVpZ2h0KTtcbiAgICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuICAgICAgc2V0Q29udGV4dFRyYW5zZm9ybShjb250ZXh0LCBmYWxzZSk7XG4gICAgICBjb250ZXh0LmNsZWFyUmVjdCh2cC5tcGFuLngsIHZwLm1wYW4ueSwgdnAud2lkdGggLyB2cC56b29tIC8gcGl4ZWxSYXRpbywgdnAuaGVpZ2h0IC8gdnAuem9vbSAvIHBpeGVsUmF0aW8pO1xuICAgICAgY29udGV4dC5kcmF3SW1hZ2UodGV4dHVyZSwgdnAubXBhbi54LCB2cC5tcGFuLnksIHZwLndpZHRoIC8gdnAuem9vbSAvIHBpeGVsUmF0aW8sIHZwLmhlaWdodCAvIHZwLnpvb20gLyBwaXhlbFJhdGlvKTtcbiAgICB9IGVsc2UgaWYgKHIudGV4dHVyZU9uVmlld3BvcnQgJiYgIWZvcmNlZENvbnRleHQpIHtcbiAgICAgIC8vIGNsZWFyIHRoZSBjYWNoZSBzaW5jZSB3ZSBkb24ndCBuZWVkIGl0XG4gICAgICByLnRleHR1cmVDYWNoZSA9IG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGV4dGVudCA9IGN5LmV4dGVudCgpO1xuICAgIHZhciB2cE1hbmlwID0gci5waW5jaGluZyB8fCByLmhvdmVyRGF0YS5kcmFnZ2luZyB8fCByLnN3aXBlUGFubmluZyB8fCByLmRhdGEud2hlZWxab29taW5nIHx8IHIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcyB8fCByLmN5LmFuaW1hdGVkKCk7XG4gICAgdmFyIGhpZGVFZGdlcyA9IHIuaGlkZUVkZ2VzT25WaWV3cG9ydCAmJiB2cE1hbmlwO1xuICAgIHZhciBuZWVkTWJDbGVhciA9IFtdO1xuICAgIG5lZWRNYkNsZWFyW3IuTk9ERV0gPSAhbmVlZERyYXdbci5OT0RFXSAmJiBtb3Rpb25CbHVyICYmICFyLmNsZWFyZWRGb3JNb3Rpb25CbHVyW3IuTk9ERV0gfHwgci5jbGVhcmluZ01vdGlvbkJsdXI7XG5cbiAgICBpZiAobmVlZE1iQ2xlYXJbci5OT0RFXSkge1xuICAgICAgci5jbGVhcmVkRm9yTW90aW9uQmx1cltyLk5PREVdID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBuZWVkTWJDbGVhcltyLkRSQUddID0gIW5lZWREcmF3W3IuRFJBR10gJiYgbW90aW9uQmx1ciAmJiAhci5jbGVhcmVkRm9yTW90aW9uQmx1cltyLkRSQUddIHx8IHIuY2xlYXJpbmdNb3Rpb25CbHVyO1xuXG4gICAgaWYgKG5lZWRNYkNsZWFyW3IuRFJBR10pIHtcbiAgICAgIHIuY2xlYXJlZEZvck1vdGlvbkJsdXJbci5EUkFHXSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG5lZWREcmF3W3IuTk9ERV0gfHwgZHJhd0FsbExheWVycyB8fCBkcmF3T25seU5vZGVMYXllciB8fCBuZWVkTWJDbGVhcltyLk5PREVdKSB7XG4gICAgICB2YXIgdXNlQnVmZmVyID0gbW90aW9uQmx1ciAmJiAhbmVlZE1iQ2xlYXJbci5OT0RFXSAmJiBtYlB4UmF0aW8gIT09IDE7XG4gICAgICB2YXIgY29udGV4dCA9IGZvcmNlZENvbnRleHQgfHwgKHVzZUJ1ZmZlciA/IHIuZGF0YS5idWZmZXJDb250ZXh0c1tyLk1PVElPTkJMVVJfQlVGRkVSX05PREVdIDogZGF0YS5jb250ZXh0c1tyLk5PREVdKTtcbiAgICAgIHZhciBjbGVhciA9IG1vdGlvbkJsdXIgJiYgIXVzZUJ1ZmZlciA/ICdtb3Rpb25CbHVyJyA6IHVuZGVmaW5lZDtcbiAgICAgIHNldENvbnRleHRUcmFuc2Zvcm0oY29udGV4dCwgY2xlYXIpO1xuXG4gICAgICBpZiAoaGlkZUVkZ2VzKSB7XG4gICAgICAgIHIuZHJhd0NhY2hlZE5vZGVzKGNvbnRleHQsIGVsZXMubm9uZHJhZywgcGl4ZWxSYXRpbywgZXh0ZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHIuZHJhd0xheWVyZWRFbGVtZW50cyhjb250ZXh0LCBlbGVzLm5vbmRyYWcsIHBpeGVsUmF0aW8sIGV4dGVudCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyLmRlYnVnKSB7XG4gICAgICAgIHIuZHJhd0RlYnVnUG9pbnRzKGNvbnRleHQsIGVsZXMubm9uZHJhZyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghZHJhd0FsbExheWVycyAmJiAhbW90aW9uQmx1cikge1xuICAgICAgICBuZWVkRHJhd1tyLk5PREVdID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFkcmF3T25seU5vZGVMYXllciAmJiAobmVlZERyYXdbci5EUkFHXSB8fCBkcmF3QWxsTGF5ZXJzIHx8IG5lZWRNYkNsZWFyW3IuRFJBR10pKSB7XG4gICAgICB2YXIgdXNlQnVmZmVyID0gbW90aW9uQmx1ciAmJiAhbmVlZE1iQ2xlYXJbci5EUkFHXSAmJiBtYlB4UmF0aW8gIT09IDE7XG4gICAgICB2YXIgY29udGV4dCA9IGZvcmNlZENvbnRleHQgfHwgKHVzZUJ1ZmZlciA/IHIuZGF0YS5idWZmZXJDb250ZXh0c1tyLk1PVElPTkJMVVJfQlVGRkVSX0RSQUddIDogZGF0YS5jb250ZXh0c1tyLkRSQUddKTtcbiAgICAgIHNldENvbnRleHRUcmFuc2Zvcm0oY29udGV4dCwgbW90aW9uQmx1ciAmJiAhdXNlQnVmZmVyID8gJ21vdGlvbkJsdXInIDogdW5kZWZpbmVkKTtcblxuICAgICAgaWYgKGhpZGVFZGdlcykge1xuICAgICAgICByLmRyYXdDYWNoZWROb2Rlcyhjb250ZXh0LCBlbGVzLmRyYWcsIHBpeGVsUmF0aW8sIGV4dGVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByLmRyYXdDYWNoZWRFbGVtZW50cyhjb250ZXh0LCBlbGVzLmRyYWcsIHBpeGVsUmF0aW8sIGV4dGVudCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyLmRlYnVnKSB7XG4gICAgICAgIHIuZHJhd0RlYnVnUG9pbnRzKGNvbnRleHQsIGVsZXMuZHJhZyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghZHJhd0FsbExheWVycyAmJiAhbW90aW9uQmx1cikge1xuICAgICAgICBuZWVkRHJhd1tyLkRSQUddID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHIuc2hvd0ZwcyB8fCAhZHJhd09ubHlOb2RlTGF5ZXIgJiYgbmVlZERyYXdbci5TRUxFQ1RfQk9YXSAmJiAhZHJhd0FsbExheWVycykge1xuICAgICAgdmFyIGNvbnRleHQgPSBmb3JjZWRDb250ZXh0IHx8IGRhdGEuY29udGV4dHNbci5TRUxFQ1RfQk9YXTtcbiAgICAgIHNldENvbnRleHRUcmFuc2Zvcm0oY29udGV4dCk7XG5cbiAgICAgIGlmIChyLnNlbGVjdGlvbls0XSA9PSAxICYmIChyLmhvdmVyRGF0YS5zZWxlY3RpbmcgfHwgci50b3VjaERhdGEuc2VsZWN0aW5nKSkge1xuICAgICAgICB2YXIgem9vbSA9IHIuY3kuem9vbSgpO1xuICAgICAgICB2YXIgYm9yZGVyV2lkdGggPSBzdHlsZS5jb3JlKCdzZWxlY3Rpb24tYm94LWJvcmRlci13aWR0aCcpLnZhbHVlIC8gem9vbTtcbiAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSBib3JkZXJXaWR0aDtcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSAncmdiYSgnICsgc3R5bGUuY29yZSgnc2VsZWN0aW9uLWJveC1jb2xvcicpLnZhbHVlWzBdICsgJywnICsgc3R5bGUuY29yZSgnc2VsZWN0aW9uLWJveC1jb2xvcicpLnZhbHVlWzFdICsgJywnICsgc3R5bGUuY29yZSgnc2VsZWN0aW9uLWJveC1jb2xvcicpLnZhbHVlWzJdICsgJywnICsgc3R5bGUuY29yZSgnc2VsZWN0aW9uLWJveC1vcGFjaXR5JykudmFsdWUgKyAnKSc7XG4gICAgICAgIGNvbnRleHQuZmlsbFJlY3Qoci5zZWxlY3Rpb25bMF0sIHIuc2VsZWN0aW9uWzFdLCByLnNlbGVjdGlvblsyXSAtIHIuc2VsZWN0aW9uWzBdLCByLnNlbGVjdGlvblszXSAtIHIuc2VsZWN0aW9uWzFdKTtcblxuICAgICAgICBpZiAoYm9yZGVyV2lkdGggPiAwKSB7XG4gICAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9ICdyZ2JhKCcgKyBzdHlsZS5jb3JlKCdzZWxlY3Rpb24tYm94LWJvcmRlci1jb2xvcicpLnZhbHVlWzBdICsgJywnICsgc3R5bGUuY29yZSgnc2VsZWN0aW9uLWJveC1ib3JkZXItY29sb3InKS52YWx1ZVsxXSArICcsJyArIHN0eWxlLmNvcmUoJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLWNvbG9yJykudmFsdWVbMl0gKyAnLCcgKyBzdHlsZS5jb3JlKCdzZWxlY3Rpb24tYm94LW9wYWNpdHknKS52YWx1ZSArICcpJztcbiAgICAgICAgICBjb250ZXh0LnN0cm9rZVJlY3Qoci5zZWxlY3Rpb25bMF0sIHIuc2VsZWN0aW9uWzFdLCByLnNlbGVjdGlvblsyXSAtIHIuc2VsZWN0aW9uWzBdLCByLnNlbGVjdGlvblszXSAtIHIuc2VsZWN0aW9uWzFdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiAmJiAhci5ob3ZlckRhdGEuc2VsZWN0aW5nKSB7XG4gICAgICAgIHZhciB6b29tID0gci5jeS56b29tKCk7XG4gICAgICAgIHZhciBwb3MgPSBkYXRhLmJnQWN0aXZlUG9zaXN0aW9uO1xuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICdyZ2JhKCcgKyBzdHlsZS5jb3JlKCdhY3RpdmUtYmctY29sb3InKS52YWx1ZVswXSArICcsJyArIHN0eWxlLmNvcmUoJ2FjdGl2ZS1iZy1jb2xvcicpLnZhbHVlWzFdICsgJywnICsgc3R5bGUuY29yZSgnYWN0aXZlLWJnLWNvbG9yJykudmFsdWVbMl0gKyAnLCcgKyBzdHlsZS5jb3JlKCdhY3RpdmUtYmctb3BhY2l0eScpLnZhbHVlICsgJyknO1xuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICBjb250ZXh0LmFyYyhwb3MueCwgcG9zLnksIHN0eWxlLmNvcmUoJ2FjdGl2ZS1iZy1zaXplJykucGZWYWx1ZSAvIHpvb20sIDAsIDIgKiBNYXRoLlBJKTtcbiAgICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0aW1lVG9SZW5kZXIgPSByLmxhc3RSZWRyYXdUaW1lO1xuXG4gICAgICBpZiAoci5zaG93RnBzICYmIHRpbWVUb1JlbmRlcikge1xuICAgICAgICB0aW1lVG9SZW5kZXIgPSBNYXRoLnJvdW5kKHRpbWVUb1JlbmRlcik7XG4gICAgICAgIHZhciBmcHMgPSBNYXRoLnJvdW5kKDEwMDAgLyB0aW1lVG9SZW5kZXIpO1xuICAgICAgICBjb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSAncmdiYSgyNTUsIDAsIDAsIDAuNzUpJztcbiAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9ICdyZ2JhKDI1NSwgMCwgMCwgMC43NSknO1xuICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IDE7XG4gICAgICAgIGNvbnRleHQuZmlsbFRleHQoJzEgZnJhbWUgPSAnICsgdGltZVRvUmVuZGVyICsgJyBtcyA9ICcgKyBmcHMgKyAnIGZwcycsIDAsIDIwKTtcbiAgICAgICAgdmFyIG1heEZwcyA9IDYwO1xuICAgICAgICBjb250ZXh0LnN0cm9rZVJlY3QoMCwgMzAsIDI1MCwgMjApO1xuICAgICAgICBjb250ZXh0LmZpbGxSZWN0KDAsIDMwLCAyNTAgKiBNYXRoLm1pbihmcHMgLyBtYXhGcHMsIDEpLCAyMCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghZHJhd0FsbExheWVycykge1xuICAgICAgICBuZWVkRHJhd1tyLlNFTEVDVF9CT1hdID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSAvLyBtb3Rpb25ibHVyOiBibGl0IHJlbmRlcmVkIGJsdXJyeSBmcmFtZXNcblxuXG4gICAgaWYgKG1vdGlvbkJsdXIgJiYgbWJQeFJhdGlvICE9PSAxKSB7XG4gICAgICB2YXIgY3h0Tm9kZSA9IGRhdGEuY29udGV4dHNbci5OT0RFXTtcbiAgICAgIHZhciB0eHROb2RlID0gci5kYXRhLmJ1ZmZlckNhbnZhc2VzW3IuTU9USU9OQkxVUl9CVUZGRVJfTk9ERV07XG4gICAgICB2YXIgY3h0RHJhZyA9IGRhdGEuY29udGV4dHNbci5EUkFHXTtcbiAgICAgIHZhciB0eHREcmFnID0gci5kYXRhLmJ1ZmZlckNhbnZhc2VzW3IuTU9USU9OQkxVUl9CVUZGRVJfRFJBR107XG5cbiAgICAgIHZhciBkcmF3TW90aW9uQmx1ciA9IGZ1bmN0aW9uIGRyYXdNb3Rpb25CbHVyKGN4dCwgdHh0LCBuZWVkQ2xlYXIpIHtcbiAgICAgICAgY3h0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcblxuICAgICAgICBpZiAobmVlZENsZWFyIHx8ICFtb3Rpb25CbHVyRmFkZUVmZmVjdCkge1xuICAgICAgICAgIGN4dC5jbGVhclJlY3QoMCwgMCwgci5jYW52YXNXaWR0aCwgci5jYW52YXNIZWlnaHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1iY2xlYXIoY3h0LCAwLCAwLCByLmNhbnZhc1dpZHRoLCByLmNhbnZhc0hlaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHhyID0gbWJQeFJhdGlvO1xuICAgICAgICBjeHQuZHJhd0ltYWdlKHR4dCwgLy8gaW1nXG4gICAgICAgIDAsIDAsIC8vIHN4LCBzeVxuICAgICAgICByLmNhbnZhc1dpZHRoICogcHhyLCByLmNhbnZhc0hlaWdodCAqIHB4ciwgLy8gc3csIHNoXG4gICAgICAgIDAsIDAsIC8vIHgsIHlcbiAgICAgICAgci5jYW52YXNXaWR0aCwgci5jYW52YXNIZWlnaHQgLy8gdywgaFxuICAgICAgICApO1xuICAgICAgfTtcblxuICAgICAgaWYgKG5lZWREcmF3W3IuTk9ERV0gfHwgbmVlZE1iQ2xlYXJbci5OT0RFXSkge1xuICAgICAgICBkcmF3TW90aW9uQmx1cihjeHROb2RlLCB0eHROb2RlLCBuZWVkTWJDbGVhcltyLk5PREVdKTtcbiAgICAgICAgbmVlZERyYXdbci5OT0RFXSA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAobmVlZERyYXdbci5EUkFHXSB8fCBuZWVkTWJDbGVhcltyLkRSQUddKSB7XG4gICAgICAgIGRyYXdNb3Rpb25CbHVyKGN4dERyYWcsIHR4dERyYWcsIG5lZWRNYkNsZWFyW3IuRFJBR10pO1xuICAgICAgICBuZWVkRHJhd1tyLkRSQUddID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgci5wcmV2Vmlld3BvcnQgPSB2cDtcblxuICAgIGlmIChyLmNsZWFyaW5nTW90aW9uQmx1cikge1xuICAgICAgci5jbGVhcmluZ01vdGlvbkJsdXIgPSBmYWxzZTtcbiAgICAgIHIubW90aW9uQmx1ckNsZWFyZWQgPSB0cnVlO1xuICAgICAgci5tb3Rpb25CbHVyID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobW90aW9uQmx1cikge1xuICAgICAgci5tb3Rpb25CbHVyVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICByLm1vdGlvbkJsdXJUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgci5jbGVhcmVkRm9yTW90aW9uQmx1cltyLk5PREVdID0gZmFsc2U7XG4gICAgICAgIHIuY2xlYXJlZEZvck1vdGlvbkJsdXJbci5EUkFHXSA9IGZhbHNlO1xuICAgICAgICByLm1vdGlvbkJsdXIgPSBmYWxzZTtcbiAgICAgICAgci5jbGVhcmluZ01vdGlvbkJsdXIgPSAhdGV4dHVyZURyYXc7XG4gICAgICAgIHIubWJGcmFtZXMgPSAwO1xuICAgICAgICBuZWVkRHJhd1tyLk5PREVdID0gdHJ1ZTtcbiAgICAgICAgbmVlZERyYXdbci5EUkFHXSA9IHRydWU7XG4gICAgICAgIHIucmVkcmF3KCk7XG4gICAgICB9LCBtb3Rpb25CbHVyRGVsYXkpO1xuICAgIH1cblxuICAgIGlmICghZm9yY2VkQ29udGV4dCkge1xuICAgICAgY3kuZW1pdCgncmVuZGVyJyk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBDUnAkMyA9IHt9OyAvLyBATyBQb2x5Z29uIGRyYXdpbmdcblxuICBDUnAkMy5kcmF3UG9seWdvblBhdGggPSBmdW5jdGlvbiAoY29udGV4dCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgcG9pbnRzKSB7XG4gICAgdmFyIGhhbGZXID0gd2lkdGggLyAyO1xuICAgIHZhciBoYWxmSCA9IGhlaWdodCAvIDI7XG5cbiAgICBpZiAoY29udGV4dC5iZWdpblBhdGgpIHtcbiAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgfVxuXG4gICAgY29udGV4dC5tb3ZlVG8oeCArIGhhbGZXICogcG9pbnRzWzBdLCB5ICsgaGFsZkggKiBwb2ludHNbMV0pO1xuXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBwb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgICBjb250ZXh0LmxpbmVUbyh4ICsgaGFsZlcgKiBwb2ludHNbaSAqIDJdLCB5ICsgaGFsZkggKiBwb2ludHNbaSAqIDIgKyAxXSk7XG4gICAgfVxuXG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfTtcblxuICBDUnAkMy5kcmF3Um91bmRQb2x5Z29uUGF0aCA9IGZ1bmN0aW9uIChjb250ZXh0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBwb2ludHMpIHtcbiAgICB2YXIgaGFsZlcgPSB3aWR0aCAvIDI7XG4gICAgdmFyIGhhbGZIID0gaGVpZ2h0IC8gMjtcbiAgICB2YXIgY29ybmVyUmFkaXVzID0gZ2V0Um91bmRQb2x5Z29uUmFkaXVzKHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgaWYgKGNvbnRleHQuYmVnaW5QYXRoKSB7XG4gICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIH1cblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBwb2ludHMubGVuZ3RoIC8gNDsgX2krKykge1xuICAgICAgdmFyIHNvdXJjZVV2ID0gdm9pZCAwLFxuICAgICAgICAgIGRlc3RVdiA9IHZvaWQgMDtcblxuICAgICAgaWYgKF9pID09PSAwKSB7XG4gICAgICAgIHNvdXJjZVV2ID0gcG9pbnRzLmxlbmd0aCAtIDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzb3VyY2VVdiA9IF9pICogNCAtIDI7XG4gICAgICB9XG5cbiAgICAgIGRlc3RVdiA9IF9pICogNCArIDI7XG4gICAgICB2YXIgcHggPSB4ICsgaGFsZlcgKiBwb2ludHNbX2kgKiA0XTtcbiAgICAgIHZhciBweSA9IHkgKyBoYWxmSCAqIHBvaW50c1tfaSAqIDQgKyAxXTtcbiAgICAgIHZhciBjb3NUaGV0YSA9IC1wb2ludHNbc291cmNlVXZdICogcG9pbnRzW2Rlc3RVdl0gLSBwb2ludHNbc291cmNlVXYgKyAxXSAqIHBvaW50c1tkZXN0VXYgKyAxXTtcbiAgICAgIHZhciBvZmZzZXQgPSBjb3JuZXJSYWRpdXMgLyBNYXRoLnRhbihNYXRoLmFjb3MoY29zVGhldGEpIC8gMik7XG4gICAgICB2YXIgY3AweCA9IHB4IC0gb2Zmc2V0ICogcG9pbnRzW3NvdXJjZVV2XTtcbiAgICAgIHZhciBjcDB5ID0gcHkgLSBvZmZzZXQgKiBwb2ludHNbc291cmNlVXYgKyAxXTtcbiAgICAgIHZhciBjcDF4ID0gcHggKyBvZmZzZXQgKiBwb2ludHNbZGVzdFV2XTtcbiAgICAgIHZhciBjcDF5ID0gcHkgKyBvZmZzZXQgKiBwb2ludHNbZGVzdFV2ICsgMV07XG5cbiAgICAgIGlmIChfaSA9PT0gMCkge1xuICAgICAgICBjb250ZXh0Lm1vdmVUbyhjcDB4LCBjcDB5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRleHQubGluZVRvKGNwMHgsIGNwMHkpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0LmFyY1RvKHB4LCBweSwgY3AxeCwgY3AxeSwgY29ybmVyUmFkaXVzKTtcbiAgICB9XG5cbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9OyAvLyBSb3VuZCByZWN0YW5nbGUgZHJhd2luZ1xuXG5cbiAgQ1JwJDMuZHJhd1JvdW5kUmVjdGFuZ2xlUGF0aCA9IGZ1bmN0aW9uIChjb250ZXh0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdmFyIGhhbGZXaWR0aCA9IHdpZHRoIC8gMjtcbiAgICB2YXIgaGFsZkhlaWdodCA9IGhlaWdodCAvIDI7XG4gICAgdmFyIGNvcm5lclJhZGl1cyA9IGdldFJvdW5kUmVjdGFuZ2xlUmFkaXVzKHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgaWYgKGNvbnRleHQuYmVnaW5QYXRoKSB7XG4gICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIH0gLy8gU3RhcnQgYXQgdG9wIG1pZGRsZVxuXG5cbiAgICBjb250ZXh0Lm1vdmVUbyh4LCB5IC0gaGFsZkhlaWdodCk7IC8vIEFyYyBmcm9tIG1pZGRsZSB0b3AgdG8gcmlnaHQgc2lkZVxuXG4gICAgY29udGV4dC5hcmNUbyh4ICsgaGFsZldpZHRoLCB5IC0gaGFsZkhlaWdodCwgeCArIGhhbGZXaWR0aCwgeSwgY29ybmVyUmFkaXVzKTsgLy8gQXJjIGZyb20gcmlnaHQgc2lkZSB0byBib3R0b21cblxuICAgIGNvbnRleHQuYXJjVG8oeCArIGhhbGZXaWR0aCwgeSArIGhhbGZIZWlnaHQsIHgsIHkgKyBoYWxmSGVpZ2h0LCBjb3JuZXJSYWRpdXMpOyAvLyBBcmMgZnJvbSBib3R0b20gdG8gbGVmdCBzaWRlXG5cbiAgICBjb250ZXh0LmFyY1RvKHggLSBoYWxmV2lkdGgsIHkgKyBoYWxmSGVpZ2h0LCB4IC0gaGFsZldpZHRoLCB5LCBjb3JuZXJSYWRpdXMpOyAvLyBBcmMgZnJvbSBsZWZ0IHNpZGUgdG8gdG9wQm9yZGVyXG5cbiAgICBjb250ZXh0LmFyY1RvKHggLSBoYWxmV2lkdGgsIHkgLSBoYWxmSGVpZ2h0LCB4LCB5IC0gaGFsZkhlaWdodCwgY29ybmVyUmFkaXVzKTsgLy8gSm9pbiBsaW5lXG5cbiAgICBjb250ZXh0LmxpbmVUbyh4LCB5IC0gaGFsZkhlaWdodCk7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfTtcblxuICBDUnAkMy5kcmF3Qm90dG9tUm91bmRSZWN0YW5nbGVQYXRoID0gZnVuY3Rpb24gKGNvbnRleHQsIHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICB2YXIgaGFsZldpZHRoID0gd2lkdGggLyAyO1xuICAgIHZhciBoYWxmSGVpZ2h0ID0gaGVpZ2h0IC8gMjtcbiAgICB2YXIgY29ybmVyUmFkaXVzID0gZ2V0Um91bmRSZWN0YW5nbGVSYWRpdXMod2lkdGgsIGhlaWdodCk7XG5cbiAgICBpZiAoY29udGV4dC5iZWdpblBhdGgpIHtcbiAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgfSAvLyBTdGFydCBhdCB0b3AgbWlkZGxlXG5cblxuICAgIGNvbnRleHQubW92ZVRvKHgsIHkgLSBoYWxmSGVpZ2h0KTtcbiAgICBjb250ZXh0LmxpbmVUbyh4ICsgaGFsZldpZHRoLCB5IC0gaGFsZkhlaWdodCk7XG4gICAgY29udGV4dC5saW5lVG8oeCArIGhhbGZXaWR0aCwgeSk7XG4gICAgY29udGV4dC5hcmNUbyh4ICsgaGFsZldpZHRoLCB5ICsgaGFsZkhlaWdodCwgeCwgeSArIGhhbGZIZWlnaHQsIGNvcm5lclJhZGl1cyk7XG4gICAgY29udGV4dC5hcmNUbyh4IC0gaGFsZldpZHRoLCB5ICsgaGFsZkhlaWdodCwgeCAtIGhhbGZXaWR0aCwgeSwgY29ybmVyUmFkaXVzKTtcbiAgICBjb250ZXh0LmxpbmVUbyh4IC0gaGFsZldpZHRoLCB5IC0gaGFsZkhlaWdodCk7XG4gICAgY29udGV4dC5saW5lVG8oeCwgeSAtIGhhbGZIZWlnaHQpO1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH07XG5cbiAgQ1JwJDMuZHJhd0N1dFJlY3RhbmdsZVBhdGggPSBmdW5jdGlvbiAoY29udGV4dCwgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgIHZhciBoYWxmV2lkdGggPSB3aWR0aCAvIDI7XG4gICAgdmFyIGhhbGZIZWlnaHQgPSBoZWlnaHQgLyAyO1xuICAgIHZhciBjb3JuZXJMZW5ndGggPSBnZXRDdXRSZWN0YW5nbGVDb3JuZXJMZW5ndGgoKTtcblxuICAgIGlmIChjb250ZXh0LmJlZ2luUGF0aCkge1xuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICB9XG5cbiAgICBjb250ZXh0Lm1vdmVUbyh4IC0gaGFsZldpZHRoICsgY29ybmVyTGVuZ3RoLCB5IC0gaGFsZkhlaWdodCk7XG4gICAgY29udGV4dC5saW5lVG8oeCArIGhhbGZXaWR0aCAtIGNvcm5lckxlbmd0aCwgeSAtIGhhbGZIZWlnaHQpO1xuICAgIGNvbnRleHQubGluZVRvKHggKyBoYWxmV2lkdGgsIHkgLSBoYWxmSGVpZ2h0ICsgY29ybmVyTGVuZ3RoKTtcbiAgICBjb250ZXh0LmxpbmVUbyh4ICsgaGFsZldpZHRoLCB5ICsgaGFsZkhlaWdodCAtIGNvcm5lckxlbmd0aCk7XG4gICAgY29udGV4dC5saW5lVG8oeCArIGhhbGZXaWR0aCAtIGNvcm5lckxlbmd0aCwgeSArIGhhbGZIZWlnaHQpO1xuICAgIGNvbnRleHQubGluZVRvKHggLSBoYWxmV2lkdGggKyBjb3JuZXJMZW5ndGgsIHkgKyBoYWxmSGVpZ2h0KTtcbiAgICBjb250ZXh0LmxpbmVUbyh4IC0gaGFsZldpZHRoLCB5ICsgaGFsZkhlaWdodCAtIGNvcm5lckxlbmd0aCk7XG4gICAgY29udGV4dC5saW5lVG8oeCAtIGhhbGZXaWR0aCwgeSAtIGhhbGZIZWlnaHQgKyBjb3JuZXJMZW5ndGgpO1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH07XG5cbiAgQ1JwJDMuZHJhd0JhcnJlbFBhdGggPSBmdW5jdGlvbiAoY29udGV4dCwgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgIHZhciBoYWxmV2lkdGggPSB3aWR0aCAvIDI7XG4gICAgdmFyIGhhbGZIZWlnaHQgPSBoZWlnaHQgLyAyO1xuICAgIHZhciB4QmVnaW4gPSB4IC0gaGFsZldpZHRoO1xuICAgIHZhciB4RW5kID0geCArIGhhbGZXaWR0aDtcbiAgICB2YXIgeUJlZ2luID0geSAtIGhhbGZIZWlnaHQ7XG4gICAgdmFyIHlFbmQgPSB5ICsgaGFsZkhlaWdodDtcbiAgICB2YXIgYmFycmVsQ3VydmVDb25zdGFudHMgPSBnZXRCYXJyZWxDdXJ2ZUNvbnN0YW50cyh3aWR0aCwgaGVpZ2h0KTtcbiAgICB2YXIgd09mZnNldCA9IGJhcnJlbEN1cnZlQ29uc3RhbnRzLndpZHRoT2Zmc2V0O1xuICAgIHZhciBoT2Zmc2V0ID0gYmFycmVsQ3VydmVDb25zdGFudHMuaGVpZ2h0T2Zmc2V0O1xuICAgIHZhciBjdHJsUHRYT2Zmc2V0ID0gYmFycmVsQ3VydmVDb25zdGFudHMuY3RybFB0T2Zmc2V0UGN0ICogd09mZnNldDtcblxuICAgIGlmIChjb250ZXh0LmJlZ2luUGF0aCkge1xuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICB9XG5cbiAgICBjb250ZXh0Lm1vdmVUbyh4QmVnaW4sIHlCZWdpbiArIGhPZmZzZXQpO1xuICAgIGNvbnRleHQubGluZVRvKHhCZWdpbiwgeUVuZCAtIGhPZmZzZXQpO1xuICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyh4QmVnaW4gKyBjdHJsUHRYT2Zmc2V0LCB5RW5kLCB4QmVnaW4gKyB3T2Zmc2V0LCB5RW5kKTtcbiAgICBjb250ZXh0LmxpbmVUbyh4RW5kIC0gd09mZnNldCwgeUVuZCk7XG4gICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKHhFbmQgLSBjdHJsUHRYT2Zmc2V0LCB5RW5kLCB4RW5kLCB5RW5kIC0gaE9mZnNldCk7XG4gICAgY29udGV4dC5saW5lVG8oeEVuZCwgeUJlZ2luICsgaE9mZnNldCk7XG4gICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKHhFbmQgLSBjdHJsUHRYT2Zmc2V0LCB5QmVnaW4sIHhFbmQgLSB3T2Zmc2V0LCB5QmVnaW4pO1xuICAgIGNvbnRleHQubGluZVRvKHhCZWdpbiArIHdPZmZzZXQsIHlCZWdpbik7XG4gICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKHhCZWdpbiArIGN0cmxQdFhPZmZzZXQsIHlCZWdpbiwgeEJlZ2luLCB5QmVnaW4gKyBoT2Zmc2V0KTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9O1xuXG4gIHZhciBzaW4wID0gTWF0aC5zaW4oMCk7XG4gIHZhciBjb3MwID0gTWF0aC5jb3MoMCk7XG4gIHZhciBzaW4gPSB7fTtcbiAgdmFyIGNvcyA9IHt9O1xuICB2YXIgZWxsaXBzZVN0ZXBTaXplID0gTWF0aC5QSSAvIDQwO1xuXG4gIGZvciAodmFyIGkgPSAwICogTWF0aC5QSTsgaSA8IDIgKiBNYXRoLlBJOyBpICs9IGVsbGlwc2VTdGVwU2l6ZSkge1xuICAgIHNpbltpXSA9IE1hdGguc2luKGkpO1xuICAgIGNvc1tpXSA9IE1hdGguY29zKGkpO1xuICB9XG5cbiAgQ1JwJDMuZHJhd0VsbGlwc2VQYXRoID0gZnVuY3Rpb24gKGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICBpZiAoY29udGV4dC5iZWdpblBhdGgpIHtcbiAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRleHQuZWxsaXBzZSkge1xuICAgICAgY29udGV4dC5lbGxpcHNlKGNlbnRlclgsIGNlbnRlclksIHdpZHRoIC8gMiwgaGVpZ2h0IC8gMiwgMCwgMCwgMiAqIE1hdGguUEkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgeFBvcywgeVBvcztcbiAgICAgIHZhciBydyA9IHdpZHRoIC8gMjtcbiAgICAgIHZhciByaCA9IGhlaWdodCAvIDI7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwICogTWF0aC5QSTsgaSA8IDIgKiBNYXRoLlBJOyBpICs9IGVsbGlwc2VTdGVwU2l6ZSkge1xuICAgICAgICB4UG9zID0gY2VudGVyWCAtIHJ3ICogc2luW2ldICogc2luMCArIHJ3ICogY29zW2ldICogY29zMDtcbiAgICAgICAgeVBvcyA9IGNlbnRlclkgKyByaCAqIGNvc1tpXSAqIHNpbjAgKyByaCAqIHNpbltpXSAqIGNvczA7XG5cbiAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICBjb250ZXh0Lm1vdmVUbyh4UG9zLCB5UG9zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0LmxpbmVUbyh4UG9zLCB5UG9zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH07XG5cbiAgLyogZ2xvYmFsIGF0b2IsIEFycmF5QnVmZmVyLCBVaW50OEFycmF5LCBCbG9iICovXG4gIHZhciBDUnAkMiA9IHt9O1xuXG4gIENScCQyLmNyZWF0ZUJ1ZmZlciA9IGZ1bmN0aW9uICh3LCBoKSB7XG4gICAgdmFyIGJ1ZmZlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cbiAgICBidWZmZXIud2lkdGggPSB3O1xuICAgIGJ1ZmZlci5oZWlnaHQgPSBoO1xuICAgIHJldHVybiBbYnVmZmVyLCBidWZmZXIuZ2V0Q29udGV4dCgnMmQnKV07XG4gIH07XG5cbiAgQ1JwJDIuYnVmZmVyQ2FudmFzSW1hZ2UgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciBjeSA9IHRoaXMuY3k7XG4gICAgdmFyIGVsZXMgPSBjeS5tdXRhYmxlRWxlbWVudHMoKTtcbiAgICB2YXIgYmIgPSBlbGVzLmJvdW5kaW5nQm94KCk7XG4gICAgdmFyIGN0clJlY3QgPSB0aGlzLmZpbmRDb250YWluZXJDbGllbnRDb29yZHMoKTtcbiAgICB2YXIgd2lkdGggPSBvcHRpb25zLmZ1bGwgPyBNYXRoLmNlaWwoYmIudykgOiBjdHJSZWN0WzJdO1xuICAgIHZhciBoZWlnaHQgPSBvcHRpb25zLmZ1bGwgPyBNYXRoLmNlaWwoYmIuaCkgOiBjdHJSZWN0WzNdO1xuICAgIHZhciBzcGVjZE1heERpbXMgPSBudW1iZXIkMShvcHRpb25zLm1heFdpZHRoKSB8fCBudW1iZXIkMShvcHRpb25zLm1heEhlaWdodCk7XG4gICAgdmFyIHB4UmF0aW8gPSB0aGlzLmdldFBpeGVsUmF0aW8oKTtcbiAgICB2YXIgc2NhbGUgPSAxO1xuXG4gICAgaWYgKG9wdGlvbnMuc2NhbGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgd2lkdGggKj0gb3B0aW9ucy5zY2FsZTtcbiAgICAgIGhlaWdodCAqPSBvcHRpb25zLnNjYWxlO1xuICAgICAgc2NhbGUgPSBvcHRpb25zLnNjYWxlO1xuICAgIH0gZWxzZSBpZiAoc3BlY2RNYXhEaW1zKSB7XG4gICAgICB2YXIgbWF4U2NhbGVXID0gSW5maW5pdHk7XG4gICAgICB2YXIgbWF4U2NhbGVIID0gSW5maW5pdHk7XG5cbiAgICAgIGlmIChudW1iZXIkMShvcHRpb25zLm1heFdpZHRoKSkge1xuICAgICAgICBtYXhTY2FsZVcgPSBzY2FsZSAqIG9wdGlvbnMubWF4V2lkdGggLyB3aWR0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKG51bWJlciQxKG9wdGlvbnMubWF4SGVpZ2h0KSkge1xuICAgICAgICBtYXhTY2FsZUggPSBzY2FsZSAqIG9wdGlvbnMubWF4SGVpZ2h0IC8gaGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICBzY2FsZSA9IE1hdGgubWluKG1heFNjYWxlVywgbWF4U2NhbGVIKTtcbiAgICAgIHdpZHRoICo9IHNjYWxlO1xuICAgICAgaGVpZ2h0ICo9IHNjYWxlO1xuICAgIH1cblxuICAgIGlmICghc3BlY2RNYXhEaW1zKSB7XG4gICAgICB3aWR0aCAqPSBweFJhdGlvO1xuICAgICAgaGVpZ2h0ICo9IHB4UmF0aW87XG4gICAgICBzY2FsZSAqPSBweFJhdGlvO1xuICAgIH1cblxuICAgIHZhciBidWZmQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuICAgIGJ1ZmZDYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICBidWZmQ2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICBidWZmQ2FudmFzLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgIGJ1ZmZDYW52YXMuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgICB2YXIgYnVmZkN4dCA9IGJ1ZmZDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTsgLy8gUmFzdGVyaXplIHRoZSBsYXllcnMsIGJ1dCBvbmx5IGlmIGNvbnRhaW5lciBoYXMgbm9uemVybyBzaXplXG5cbiAgICBpZiAod2lkdGggPiAwICYmIGhlaWdodCA+IDApIHtcbiAgICAgIGJ1ZmZDeHQuY2xlYXJSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgYnVmZkN4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnc291cmNlLW92ZXInO1xuICAgICAgdmFyIHpzb3J0ZWRFbGVzID0gdGhpcy5nZXRDYWNoZWRaU29ydGVkRWxlcygpO1xuXG4gICAgICBpZiAob3B0aW9ucy5mdWxsKSB7XG4gICAgICAgIC8vIGRyYXcgdGhlIGZ1bGwgYm91bmRzIG9mIHRoZSBncmFwaFxuICAgICAgICBidWZmQ3h0LnRyYW5zbGF0ZSgtYmIueDEgKiBzY2FsZSwgLWJiLnkxICogc2NhbGUpO1xuICAgICAgICBidWZmQ3h0LnNjYWxlKHNjYWxlLCBzY2FsZSk7XG4gICAgICAgIHRoaXMuZHJhd0VsZW1lbnRzKGJ1ZmZDeHQsIHpzb3J0ZWRFbGVzKTtcbiAgICAgICAgYnVmZkN4dC5zY2FsZSgxIC8gc2NhbGUsIDEgLyBzY2FsZSk7XG4gICAgICAgIGJ1ZmZDeHQudHJhbnNsYXRlKGJiLngxICogc2NhbGUsIGJiLnkxICogc2NhbGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZHJhdyB0aGUgY3VycmVudCB2aWV3XG4gICAgICAgIHZhciBwYW4gPSBjeS5wYW4oKTtcbiAgICAgICAgdmFyIHRyYW5zbGF0aW9uID0ge1xuICAgICAgICAgIHg6IHBhbi54ICogc2NhbGUsXG4gICAgICAgICAgeTogcGFuLnkgKiBzY2FsZVxuICAgICAgICB9O1xuICAgICAgICBzY2FsZSAqPSBjeS56b29tKCk7XG4gICAgICAgIGJ1ZmZDeHQudHJhbnNsYXRlKHRyYW5zbGF0aW9uLngsIHRyYW5zbGF0aW9uLnkpO1xuICAgICAgICBidWZmQ3h0LnNjYWxlKHNjYWxlLCBzY2FsZSk7XG4gICAgICAgIHRoaXMuZHJhd0VsZW1lbnRzKGJ1ZmZDeHQsIHpzb3J0ZWRFbGVzKTtcbiAgICAgICAgYnVmZkN4dC5zY2FsZSgxIC8gc2NhbGUsIDEgLyBzY2FsZSk7XG4gICAgICAgIGJ1ZmZDeHQudHJhbnNsYXRlKC10cmFuc2xhdGlvbi54LCAtdHJhbnNsYXRpb24ueSk7XG4gICAgICB9IC8vIG5lZWQgdG8gZmlsbCBiZyBhdCBlbmQgbGlrZSB0aGlzIGluIG9yZGVyIHRvIGZpbGwgY2xlYXJlZCB0cmFuc3BhcmVudCBwaXhlbHMgaW4ganBnc1xuXG5cbiAgICAgIGlmIChvcHRpb25zLmJnKSB7XG4gICAgICAgIGJ1ZmZDeHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLW92ZXInO1xuICAgICAgICBidWZmQ3h0LmZpbGxTdHlsZSA9IG9wdGlvbnMuYmc7XG4gICAgICAgIGJ1ZmZDeHQucmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgYnVmZkN4dC5maWxsKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZmZDYW52YXM7XG4gIH07XG5cbiAgZnVuY3Rpb24gYjY0VG9CbG9iKGI2NCwgbWltZVR5cGUpIHtcbiAgICB2YXIgYnl0ZXMgPSBhdG9iKGI2NCk7XG4gICAgdmFyIGJ1ZmYgPSBuZXcgQXJyYXlCdWZmZXIoYnl0ZXMubGVuZ3RoKTtcbiAgICB2YXIgYnVmZlVpbnQ4ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZik7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBidWZmVWludDhbaV0gPSBieXRlcy5jaGFyQ29kZUF0KGkpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQmxvYihbYnVmZl0sIHtcbiAgICAgIHR5cGU6IG1pbWVUeXBlXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBiNjRVcmlUb0I2NChiNjR1cmkpIHtcbiAgICB2YXIgaSA9IGI2NHVyaS5pbmRleE9mKCcsJyk7XG4gICAgcmV0dXJuIGI2NHVyaS5zdWJzdHIoaSArIDEpO1xuICB9XG5cbiAgZnVuY3Rpb24gb3V0cHV0KG9wdGlvbnMsIGNhbnZhcywgbWltZVR5cGUpIHtcbiAgICB2YXIgZ2V0QjY0VXJpID0gZnVuY3Rpb24gZ2V0QjY0VXJpKCkge1xuICAgICAgcmV0dXJuIGNhbnZhcy50b0RhdGFVUkwobWltZVR5cGUsIG9wdGlvbnMucXVhbGl0eSk7XG4gICAgfTtcblxuICAgIHN3aXRjaCAob3B0aW9ucy5vdXRwdXQpIHtcbiAgICAgIGNhc2UgJ2Jsb2ItcHJvbWlzZSc6XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY2FudmFzLnRvQmxvYihmdW5jdGlvbiAoYmxvYikge1xuICAgICAgICAgICAgICBpZiAoYmxvYiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShibG9iKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdgY2FudmFzLnRvQmxvYigpYCBzZW50IGEgbnVsbCB2YWx1ZSBpbiBpdHMgY2FsbGJhY2snKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIG1pbWVUeXBlLCBvcHRpb25zLnF1YWxpdHkpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgY2FzZSAnYmxvYic6XG4gICAgICAgIHJldHVybiBiNjRUb0Jsb2IoYjY0VXJpVG9CNjQoZ2V0QjY0VXJpKCkpLCBtaW1lVHlwZSk7XG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiNjRVcmlUb0I2NChnZXRCNjRVcmkoKSk7XG5cbiAgICAgIGNhc2UgJ2Jhc2U2NHVyaSc6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZ2V0QjY0VXJpKCk7XG4gICAgfVxuICB9XG5cbiAgQ1JwJDIucG5nID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3V0cHV0KG9wdGlvbnMsIHRoaXMuYnVmZmVyQ2FudmFzSW1hZ2Uob3B0aW9ucyksICdpbWFnZS9wbmcnKTtcbiAgfTtcblxuICBDUnAkMi5qcGcgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHJldHVybiBvdXRwdXQob3B0aW9ucywgdGhpcy5idWZmZXJDYW52YXNJbWFnZShvcHRpb25zKSwgJ2ltYWdlL2pwZWcnKTtcbiAgfTtcblxuICB2YXIgQ1JwJDEgPSB7fTtcblxuICBDUnAkMS5ub2RlU2hhcGVJbXBsID0gZnVuY3Rpb24gKG5hbWUsIGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIHBvaW50cykge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnZWxsaXBzZSc6XG4gICAgICAgIHJldHVybiB0aGlzLmRyYXdFbGxpcHNlUGF0aChjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgY2FzZSAncG9seWdvbic6XG4gICAgICAgIHJldHVybiB0aGlzLmRyYXdQb2x5Z29uUGF0aChjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBwb2ludHMpO1xuXG4gICAgICBjYXNlICdyb3VuZC1wb2x5Z29uJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhd1JvdW5kUG9seWdvblBhdGgoY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgcG9pbnRzKTtcblxuICAgICAgY2FzZSAncm91bmRyZWN0YW5nbGUnOlxuICAgICAgY2FzZSAncm91bmQtcmVjdGFuZ2xlJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhd1JvdW5kUmVjdGFuZ2xlUGF0aChjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgY2FzZSAnY3V0cmVjdGFuZ2xlJzpcbiAgICAgIGNhc2UgJ2N1dC1yZWN0YW5nbGUnOlxuICAgICAgICByZXR1cm4gdGhpcy5kcmF3Q3V0UmVjdGFuZ2xlUGF0aChjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgY2FzZSAnYm90dG9tcm91bmRyZWN0YW5nbGUnOlxuICAgICAgY2FzZSAnYm90dG9tLXJvdW5kLXJlY3RhbmdsZSc6XG4gICAgICAgIHJldHVybiB0aGlzLmRyYXdCb3R0b21Sb3VuZFJlY3RhbmdsZVBhdGgoY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICAgIGNhc2UgJ2JhcnJlbCc6XG4gICAgICAgIHJldHVybiB0aGlzLmRyYXdCYXJyZWxQYXRoKGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgQ1IgPSBDYW52YXNSZW5kZXJlcjtcbiAgdmFyIENScCA9IENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZTtcbiAgQ1JwLkNBTlZBU19MQVlFUlMgPSAzOyAvL1xuXG4gIENScC5TRUxFQ1RfQk9YID0gMDtcbiAgQ1JwLkRSQUcgPSAxO1xuICBDUnAuTk9ERSA9IDI7XG4gIENScC5CVUZGRVJfQ09VTlQgPSAzOyAvL1xuXG4gIENScC5URVhUVVJFX0JVRkZFUiA9IDA7XG4gIENScC5NT1RJT05CTFVSX0JVRkZFUl9OT0RFID0gMTtcbiAgQ1JwLk1PVElPTkJMVVJfQlVGRkVSX0RSQUcgPSAyO1xuXG4gIGZ1bmN0aW9uIENhbnZhc1JlbmRlcmVyKG9wdGlvbnMpIHtcbiAgICB2YXIgciA9IHRoaXM7XG4gICAgci5kYXRhID0ge1xuICAgICAgY2FudmFzZXM6IG5ldyBBcnJheShDUnAuQ0FOVkFTX0xBWUVSUyksXG4gICAgICBjb250ZXh0czogbmV3IEFycmF5KENScC5DQU5WQVNfTEFZRVJTKSxcbiAgICAgIGNhbnZhc05lZWRzUmVkcmF3OiBuZXcgQXJyYXkoQ1JwLkNBTlZBU19MQVlFUlMpLFxuICAgICAgYnVmZmVyQ2FudmFzZXM6IG5ldyBBcnJheShDUnAuQlVGRkVSX0NPVU5UKSxcbiAgICAgIGJ1ZmZlckNvbnRleHRzOiBuZXcgQXJyYXkoQ1JwLkNBTlZBU19MQVlFUlMpXG4gICAgfTtcbiAgICB2YXIgdGFwSGxPZmZBdHRyID0gJy13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcic7XG4gICAgdmFyIHRhcEhsT2ZmU3R5bGUgPSAncmdiYSgwLDAsMCwwKSc7XG4gICAgci5kYXRhLmNhbnZhc0NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cbiAgICB2YXIgY29udGFpbmVyU3R5bGUgPSByLmRhdGEuY2FudmFzQ29udGFpbmVyLnN0eWxlO1xuICAgIHIuZGF0YS5jYW52YXNDb250YWluZXIuc3R5bGVbdGFwSGxPZmZBdHRyXSA9IHRhcEhsT2ZmU3R5bGU7XG4gICAgY29udGFpbmVyU3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgIGNvbnRhaW5lclN0eWxlLnpJbmRleCA9ICcwJztcbiAgICBjb250YWluZXJTdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgIHZhciBjb250YWluZXIgPSBvcHRpb25zLmN5LmNvbnRhaW5lcigpO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChyLmRhdGEuY2FudmFzQ29udGFpbmVyKTtcbiAgICBjb250YWluZXIuc3R5bGVbdGFwSGxPZmZBdHRyXSA9IHRhcEhsT2ZmU3R5bGU7XG4gICAgdmFyIHN0eWxlTWFwID0ge1xuICAgICAgJy13ZWJraXQtdXNlci1zZWxlY3QnOiAnbm9uZScsXG4gICAgICAnLW1vei11c2VyLXNlbGVjdCc6ICctbW96LW5vbmUnLFxuICAgICAgJ3VzZXItc2VsZWN0JzogJ25vbmUnLFxuICAgICAgJy13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcic6ICdyZ2JhKDAsMCwwLDApJyxcbiAgICAgICdvdXRsaW5lLXN0eWxlJzogJ25vbmUnXG4gICAgfTtcblxuICAgIGlmIChtcygpKSB7XG4gICAgICBzdHlsZU1hcFsnLW1zLXRvdWNoLWFjdGlvbiddID0gJ25vbmUnO1xuICAgICAgc3R5bGVNYXBbJ3RvdWNoLWFjdGlvbiddID0gJ25vbmUnO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgQ1JwLkNBTlZBU19MQVlFUlM7IGkrKykge1xuICAgICAgdmFyIGNhbnZhcyA9IHIuZGF0YS5jYW52YXNlc1tpXSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cbiAgICAgIHIuZGF0YS5jb250ZXh0c1tpXSA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgT2JqZWN0LmtleXMoc3R5bGVNYXApLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgY2FudmFzLnN0eWxlW2tdID0gc3R5bGVNYXBba107XG4gICAgICB9KTtcbiAgICAgIGNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICBjYW52YXMuc2V0QXR0cmlidXRlKCdkYXRhLWlkJywgJ2xheWVyJyArIGkpO1xuICAgICAgY2FudmFzLnN0eWxlLnpJbmRleCA9IFN0cmluZyhDUnAuQ0FOVkFTX0xBWUVSUyAtIGkpO1xuICAgICAgci5kYXRhLmNhbnZhc0NvbnRhaW5lci5hcHBlbmRDaGlsZChjYW52YXMpO1xuICAgICAgci5kYXRhLmNhbnZhc05lZWRzUmVkcmF3W2ldID0gZmFsc2U7XG4gICAgfVxuXG4gICAgci5kYXRhLnRvcENhbnZhcyA9IHIuZGF0YS5jYW52YXNlc1swXTtcbiAgICByLmRhdGEuY2FudmFzZXNbQ1JwLk5PREVdLnNldEF0dHJpYnV0ZSgnZGF0YS1pZCcsICdsYXllcicgKyBDUnAuTk9ERSArICctbm9kZScpO1xuICAgIHIuZGF0YS5jYW52YXNlc1tDUnAuU0VMRUNUX0JPWF0uc2V0QXR0cmlidXRlKCdkYXRhLWlkJywgJ2xheWVyJyArIENScC5TRUxFQ1RfQk9YICsgJy1zZWxlY3Rib3gnKTtcbiAgICByLmRhdGEuY2FudmFzZXNbQ1JwLkRSQUddLnNldEF0dHJpYnV0ZSgnZGF0YS1pZCcsICdsYXllcicgKyBDUnAuRFJBRyArICctZHJhZycpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBDUnAuQlVGRkVSX0NPVU5UOyBpKyspIHtcbiAgICAgIHIuZGF0YS5idWZmZXJDYW52YXNlc1tpXSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cbiAgICAgIHIuZGF0YS5idWZmZXJDb250ZXh0c1tpXSA9IHIuZGF0YS5idWZmZXJDYW52YXNlc1tpXS5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgci5kYXRhLmJ1ZmZlckNhbnZhc2VzW2ldLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgIHIuZGF0YS5idWZmZXJDYW52YXNlc1tpXS5zZXRBdHRyaWJ1dGUoJ2RhdGEtaWQnLCAnYnVmZmVyJyArIGkpO1xuICAgICAgci5kYXRhLmJ1ZmZlckNhbnZhc2VzW2ldLnN0eWxlLnpJbmRleCA9IFN0cmluZygtaSAtIDEpO1xuICAgICAgci5kYXRhLmJ1ZmZlckNhbnZhc2VzW2ldLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJzsgLy9yLmRhdGEuY2FudmFzQ29udGFpbmVyLmFwcGVuZENoaWxkKHIuZGF0YS5idWZmZXJDYW52YXNlc1tpXSk7XG4gICAgfVxuXG4gICAgci5wYXRoc0VuYWJsZWQgPSB0cnVlO1xuICAgIHZhciBlbXB0eUJiID0gbWFrZUJvdW5kaW5nQm94KCk7XG5cbiAgICB2YXIgZ2V0Qm94Q2VudGVyID0gZnVuY3Rpb24gZ2V0Qm94Q2VudGVyKGJiKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiAoYmIueDEgKyBiYi54MikgLyAyLFxuICAgICAgICB5OiAoYmIueTEgKyBiYi55MikgLyAyXG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgZ2V0Q2VudGVyT2Zmc2V0ID0gZnVuY3Rpb24gZ2V0Q2VudGVyT2Zmc2V0KGJiKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiAtYmIudyAvIDIsXG4gICAgICAgIHk6IC1iYi5oIC8gMlxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGJhY2tncm91bmRUaW1lc3RhbXBIYXNDaGFuZ2VkID0gZnVuY3Rpb24gYmFja2dyb3VuZFRpbWVzdGFtcEhhc0NoYW5nZWQoZWxlKSB7XG4gICAgICB2YXIgX3AgPSBlbGVbMF0uX3ByaXZhdGU7XG4gICAgICB2YXIgc2FtZSA9IF9wLm9sZEJhY2tncm91bmRUaW1lc3RhbXAgPT09IF9wLmJhY2tncm91bmRUaW1lc3RhbXA7XG4gICAgICByZXR1cm4gIXNhbWU7XG4gICAgfTtcblxuICAgIHZhciBnZXRTdHlsZUtleSA9IGZ1bmN0aW9uIGdldFN0eWxlS2V5KGVsZSkge1xuICAgICAgcmV0dXJuIGVsZVswXS5fcHJpdmF0ZS5ub2RlS2V5O1xuICAgIH07XG5cbiAgICB2YXIgZ2V0TGFiZWxLZXkgPSBmdW5jdGlvbiBnZXRMYWJlbEtleShlbGUpIHtcbiAgICAgIHJldHVybiBlbGVbMF0uX3ByaXZhdGUubGFiZWxTdHlsZUtleTtcbiAgICB9O1xuXG4gICAgdmFyIGdldFNvdXJjZUxhYmVsS2V5ID0gZnVuY3Rpb24gZ2V0U291cmNlTGFiZWxLZXkoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlWzBdLl9wcml2YXRlLnNvdXJjZUxhYmVsU3R5bGVLZXk7XG4gICAgfTtcblxuICAgIHZhciBnZXRUYXJnZXRMYWJlbEtleSA9IGZ1bmN0aW9uIGdldFRhcmdldExhYmVsS2V5KGVsZSkge1xuICAgICAgcmV0dXJuIGVsZVswXS5fcHJpdmF0ZS50YXJnZXRMYWJlbFN0eWxlS2V5O1xuICAgIH07XG5cbiAgICB2YXIgZHJhd0VsZW1lbnQgPSBmdW5jdGlvbiBkcmF3RWxlbWVudChjb250ZXh0LCBlbGUsIGJiLCBzY2FsZWRMYWJlbFNob3duLCB1c2VFbGVPcGFjaXR5KSB7XG4gICAgICByZXR1cm4gci5kcmF3RWxlbWVudChjb250ZXh0LCBlbGUsIGJiLCBmYWxzZSwgZmFsc2UsIHVzZUVsZU9wYWNpdHkpO1xuICAgIH07XG5cbiAgICB2YXIgZHJhd0xhYmVsID0gZnVuY3Rpb24gZHJhd0xhYmVsKGNvbnRleHQsIGVsZSwgYmIsIHNjYWxlZExhYmVsU2hvd24sIHVzZUVsZU9wYWNpdHkpIHtcbiAgICAgIHJldHVybiByLmRyYXdFbGVtZW50VGV4dChjb250ZXh0LCBlbGUsIGJiLCBzY2FsZWRMYWJlbFNob3duLCAnbWFpbicsIHVzZUVsZU9wYWNpdHkpO1xuICAgIH07XG5cbiAgICB2YXIgZHJhd1NvdXJjZUxhYmVsID0gZnVuY3Rpb24gZHJhd1NvdXJjZUxhYmVsKGNvbnRleHQsIGVsZSwgYmIsIHNjYWxlZExhYmVsU2hvd24sIHVzZUVsZU9wYWNpdHkpIHtcbiAgICAgIHJldHVybiByLmRyYXdFbGVtZW50VGV4dChjb250ZXh0LCBlbGUsIGJiLCBzY2FsZWRMYWJlbFNob3duLCAnc291cmNlJywgdXNlRWxlT3BhY2l0eSk7XG4gICAgfTtcblxuICAgIHZhciBkcmF3VGFyZ2V0TGFiZWwgPSBmdW5jdGlvbiBkcmF3VGFyZ2V0TGFiZWwoY29udGV4dCwgZWxlLCBiYiwgc2NhbGVkTGFiZWxTaG93biwgdXNlRWxlT3BhY2l0eSkge1xuICAgICAgcmV0dXJuIHIuZHJhd0VsZW1lbnRUZXh0KGNvbnRleHQsIGVsZSwgYmIsIHNjYWxlZExhYmVsU2hvd24sICd0YXJnZXQnLCB1c2VFbGVPcGFjaXR5KTtcbiAgICB9O1xuXG4gICAgdmFyIGdldEVsZW1lbnRCb3ggPSBmdW5jdGlvbiBnZXRFbGVtZW50Qm94KGVsZSkge1xuICAgICAgZWxlLmJvdW5kaW5nQm94KCk7XG4gICAgICByZXR1cm4gZWxlWzBdLl9wcml2YXRlLmJvZHlCb3VuZHM7XG4gICAgfTtcblxuICAgIHZhciBnZXRMYWJlbEJveCA9IGZ1bmN0aW9uIGdldExhYmVsQm94KGVsZSkge1xuICAgICAgZWxlLmJvdW5kaW5nQm94KCk7XG4gICAgICByZXR1cm4gZWxlWzBdLl9wcml2YXRlLmxhYmVsQm91bmRzLm1haW4gfHwgZW1wdHlCYjtcbiAgICB9O1xuXG4gICAgdmFyIGdldFNvdXJjZUxhYmVsQm94ID0gZnVuY3Rpb24gZ2V0U291cmNlTGFiZWxCb3goZWxlKSB7XG4gICAgICBlbGUuYm91bmRpbmdCb3goKTtcbiAgICAgIHJldHVybiBlbGVbMF0uX3ByaXZhdGUubGFiZWxCb3VuZHMuc291cmNlIHx8IGVtcHR5QmI7XG4gICAgfTtcblxuICAgIHZhciBnZXRUYXJnZXRMYWJlbEJveCA9IGZ1bmN0aW9uIGdldFRhcmdldExhYmVsQm94KGVsZSkge1xuICAgICAgZWxlLmJvdW5kaW5nQm94KCk7XG4gICAgICByZXR1cm4gZWxlWzBdLl9wcml2YXRlLmxhYmVsQm91bmRzLnRhcmdldCB8fCBlbXB0eUJiO1xuICAgIH07XG5cbiAgICB2YXIgaXNMYWJlbFZpc2libGVBdFNjYWxlID0gZnVuY3Rpb24gaXNMYWJlbFZpc2libGVBdFNjYWxlKGVsZSwgc2NhbGVkTGFiZWxTaG93bikge1xuICAgICAgcmV0dXJuIHNjYWxlZExhYmVsU2hvd247XG4gICAgfTtcblxuICAgIHZhciBnZXRFbGVtZW50Um90YXRpb25Qb2ludCA9IGZ1bmN0aW9uIGdldEVsZW1lbnRSb3RhdGlvblBvaW50KGVsZSkge1xuICAgICAgcmV0dXJuIGdldEJveENlbnRlcihnZXRFbGVtZW50Qm94KGVsZSkpO1xuICAgIH07XG5cbiAgICB2YXIgYWRkVGV4dE1hcmdpbiA9IGZ1bmN0aW9uIGFkZFRleHRNYXJnaW4ocHJlZml4LCBwdCwgZWxlKSB7XG4gICAgICB2YXIgcHJlID0gcHJlZml4ID8gcHJlZml4ICsgJy0nIDogJyc7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBwdC54ICsgZWxlLnBzdHlsZShwcmUgKyAndGV4dC1tYXJnaW4teCcpLnBmVmFsdWUsXG4gICAgICAgIHk6IHB0LnkgKyBlbGUucHN0eWxlKHByZSArICd0ZXh0LW1hcmdpbi15JykucGZWYWx1ZVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGdldFJzUHQgPSBmdW5jdGlvbiBnZXRSc1B0KGVsZSwgeCwgeSkge1xuICAgICAgdmFyIHJzID0gZWxlWzBdLl9wcml2YXRlLnJzY3JhdGNoO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogcnNbeF0sXG4gICAgICAgIHk6IHJzW3ldXG4gICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgZ2V0TGFiZWxSb3RhdGlvblBvaW50ID0gZnVuY3Rpb24gZ2V0TGFiZWxSb3RhdGlvblBvaW50KGVsZSkge1xuICAgICAgcmV0dXJuIGFkZFRleHRNYXJnaW4oJycsIGdldFJzUHQoZWxlLCAnbGFiZWxYJywgJ2xhYmVsWScpLCBlbGUpO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0U291cmNlTGFiZWxSb3RhdGlvblBvaW50ID0gZnVuY3Rpb24gZ2V0U291cmNlTGFiZWxSb3RhdGlvblBvaW50KGVsZSkge1xuICAgICAgcmV0dXJuIGFkZFRleHRNYXJnaW4oJ3NvdXJjZScsIGdldFJzUHQoZWxlLCAnc291cmNlTGFiZWxYJywgJ3NvdXJjZUxhYmVsWScpLCBlbGUpO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0VGFyZ2V0TGFiZWxSb3RhdGlvblBvaW50ID0gZnVuY3Rpb24gZ2V0VGFyZ2V0TGFiZWxSb3RhdGlvblBvaW50KGVsZSkge1xuICAgICAgcmV0dXJuIGFkZFRleHRNYXJnaW4oJ3RhcmdldCcsIGdldFJzUHQoZWxlLCAndGFyZ2V0TGFiZWxYJywgJ3RhcmdldExhYmVsWScpLCBlbGUpO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0RWxlbWVudFJvdGF0aW9uT2Zmc2V0ID0gZnVuY3Rpb24gZ2V0RWxlbWVudFJvdGF0aW9uT2Zmc2V0KGVsZSkge1xuICAgICAgcmV0dXJuIGdldENlbnRlck9mZnNldChnZXRFbGVtZW50Qm94KGVsZSkpO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0U291cmNlTGFiZWxSb3RhdGlvbk9mZnNldCA9IGZ1bmN0aW9uIGdldFNvdXJjZUxhYmVsUm90YXRpb25PZmZzZXQoZWxlKSB7XG4gICAgICByZXR1cm4gZ2V0Q2VudGVyT2Zmc2V0KGdldFNvdXJjZUxhYmVsQm94KGVsZSkpO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0VGFyZ2V0TGFiZWxSb3RhdGlvbk9mZnNldCA9IGZ1bmN0aW9uIGdldFRhcmdldExhYmVsUm90YXRpb25PZmZzZXQoZWxlKSB7XG4gICAgICByZXR1cm4gZ2V0Q2VudGVyT2Zmc2V0KGdldFRhcmdldExhYmVsQm94KGVsZSkpO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0TGFiZWxSb3RhdGlvbk9mZnNldCA9IGZ1bmN0aW9uIGdldExhYmVsUm90YXRpb25PZmZzZXQoZWxlKSB7XG4gICAgICB2YXIgYmIgPSBnZXRMYWJlbEJveChlbGUpO1xuICAgICAgdmFyIHAgPSBnZXRDZW50ZXJPZmZzZXQoZ2V0TGFiZWxCb3goZWxlKSk7XG5cbiAgICAgIGlmIChlbGUuaXNOb2RlKCkpIHtcbiAgICAgICAgc3dpdGNoIChlbGUucHN0eWxlKCd0ZXh0LWhhbGlnbicpLnZhbHVlKSB7XG4gICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICBwLnggPSAtYmIudztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgcC54ID0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChlbGUucHN0eWxlKCd0ZXh0LXZhbGlnbicpLnZhbHVlKSB7XG4gICAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgIHAueSA9IC1iYi5oO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgcC55ID0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwO1xuICAgIH07XG5cbiAgICB2YXIgZWxlVHhyQ2FjaGUgPSByLmRhdGEuZWxlVHhyQ2FjaGUgPSBuZXcgRWxlbWVudFRleHR1cmVDYWNoZShyLCB7XG4gICAgICBnZXRLZXk6IGdldFN0eWxlS2V5LFxuICAgICAgZG9lc0VsZUludmFsaWRhdGVLZXk6IGJhY2tncm91bmRUaW1lc3RhbXBIYXNDaGFuZ2VkLFxuICAgICAgZHJhd0VsZW1lbnQ6IGRyYXdFbGVtZW50LFxuICAgICAgZ2V0Qm91bmRpbmdCb3g6IGdldEVsZW1lbnRCb3gsXG4gICAgICBnZXRSb3RhdGlvblBvaW50OiBnZXRFbGVtZW50Um90YXRpb25Qb2ludCxcbiAgICAgIGdldFJvdGF0aW9uT2Zmc2V0OiBnZXRFbGVtZW50Um90YXRpb25PZmZzZXQsXG4gICAgICBhbGxvd0VkZ2VUeHJDYWNoaW5nOiBmYWxzZSxcbiAgICAgIGFsbG93UGFyZW50VHhyQ2FjaGluZzogZmFsc2VcbiAgICB9KTtcbiAgICB2YXIgbGJsVHhyQ2FjaGUgPSByLmRhdGEubGJsVHhyQ2FjaGUgPSBuZXcgRWxlbWVudFRleHR1cmVDYWNoZShyLCB7XG4gICAgICBnZXRLZXk6IGdldExhYmVsS2V5LFxuICAgICAgZHJhd0VsZW1lbnQ6IGRyYXdMYWJlbCxcbiAgICAgIGdldEJvdW5kaW5nQm94OiBnZXRMYWJlbEJveCxcbiAgICAgIGdldFJvdGF0aW9uUG9pbnQ6IGdldExhYmVsUm90YXRpb25Qb2ludCxcbiAgICAgIGdldFJvdGF0aW9uT2Zmc2V0OiBnZXRMYWJlbFJvdGF0aW9uT2Zmc2V0LFxuICAgICAgaXNWaXNpYmxlOiBpc0xhYmVsVmlzaWJsZUF0U2NhbGVcbiAgICB9KTtcbiAgICB2YXIgc2xiVHhyQ2FjaGUgPSByLmRhdGEuc2xiVHhyQ2FjaGUgPSBuZXcgRWxlbWVudFRleHR1cmVDYWNoZShyLCB7XG4gICAgICBnZXRLZXk6IGdldFNvdXJjZUxhYmVsS2V5LFxuICAgICAgZHJhd0VsZW1lbnQ6IGRyYXdTb3VyY2VMYWJlbCxcbiAgICAgIGdldEJvdW5kaW5nQm94OiBnZXRTb3VyY2VMYWJlbEJveCxcbiAgICAgIGdldFJvdGF0aW9uUG9pbnQ6IGdldFNvdXJjZUxhYmVsUm90YXRpb25Qb2ludCxcbiAgICAgIGdldFJvdGF0aW9uT2Zmc2V0OiBnZXRTb3VyY2VMYWJlbFJvdGF0aW9uT2Zmc2V0LFxuICAgICAgaXNWaXNpYmxlOiBpc0xhYmVsVmlzaWJsZUF0U2NhbGVcbiAgICB9KTtcbiAgICB2YXIgdGxiVHhyQ2FjaGUgPSByLmRhdGEudGxiVHhyQ2FjaGUgPSBuZXcgRWxlbWVudFRleHR1cmVDYWNoZShyLCB7XG4gICAgICBnZXRLZXk6IGdldFRhcmdldExhYmVsS2V5LFxuICAgICAgZHJhd0VsZW1lbnQ6IGRyYXdUYXJnZXRMYWJlbCxcbiAgICAgIGdldEJvdW5kaW5nQm94OiBnZXRUYXJnZXRMYWJlbEJveCxcbiAgICAgIGdldFJvdGF0aW9uUG9pbnQ6IGdldFRhcmdldExhYmVsUm90YXRpb25Qb2ludCxcbiAgICAgIGdldFJvdGF0aW9uT2Zmc2V0OiBnZXRUYXJnZXRMYWJlbFJvdGF0aW9uT2Zmc2V0LFxuICAgICAgaXNWaXNpYmxlOiBpc0xhYmVsVmlzaWJsZUF0U2NhbGVcbiAgICB9KTtcbiAgICB2YXIgbHlyVHhyQ2FjaGUgPSByLmRhdGEubHlyVHhyQ2FjaGUgPSBuZXcgTGF5ZXJlZFRleHR1cmVDYWNoZShyKTtcbiAgICByLm9uVXBkYXRlRWxlQ2FsY3MoZnVuY3Rpb24gaW52YWxpZGF0ZVRleHR1cmVDYWNoZXMod2lsbERyYXcsIGVsZXMpIHtcbiAgICAgIC8vIGVhY2ggY2FjaGUgc2hvdWxkIGNoZWNrIGZvciBzdWIta2V5IGRpZmYgdG8gc2VlIHRoYXQgdGhlIHVwZGF0ZSBhZmZlY3RzIHRoYXQgY2FjaGUgcGFydGljdWxhcmx5XG4gICAgICBlbGVUeHJDYWNoZS5pbnZhbGlkYXRlRWxlbWVudHMoZWxlcyk7XG4gICAgICBsYmxUeHJDYWNoZS5pbnZhbGlkYXRlRWxlbWVudHMoZWxlcyk7XG4gICAgICBzbGJUeHJDYWNoZS5pbnZhbGlkYXRlRWxlbWVudHMoZWxlcyk7XG4gICAgICB0bGJUeHJDYWNoZS5pbnZhbGlkYXRlRWxlbWVudHMoZWxlcyk7IC8vIGFueSBjaGFuZ2UgaW52YWxpZGF0ZXMgdGhlIGxheWVyc1xuXG4gICAgICBseXJUeHJDYWNoZS5pbnZhbGlkYXRlRWxlbWVudHMoZWxlcyk7IC8vIHVwZGF0ZSB0aGUgb2xkIGJnIHRpbWVzdGFtcCBzbyBkaWZmcyBjYW4gYmUgZG9uZSBpbiB0aGUgZWxlIHR4ciBjYWNoZXNcblxuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGVsZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBfcCA9IGVsZXNbX2ldLl9wcml2YXRlO1xuICAgICAgICBfcC5vbGRCYWNrZ3JvdW5kVGltZXN0YW1wID0gX3AuYmFja2dyb3VuZFRpbWVzdGFtcDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciByZWZpbmVJbkxheWVycyA9IGZ1bmN0aW9uIHJlZmluZUluTGF5ZXJzKHJlcXMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVxcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBseXJUeHJDYWNoZS5lbnF1ZXVlRWxlbWVudFJlZmluZW1lbnQocmVxc1tpXS5lbGUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBlbGVUeHJDYWNoZS5vbkRlcXVldWUocmVmaW5lSW5MYXllcnMpO1xuICAgIGxibFR4ckNhY2hlLm9uRGVxdWV1ZShyZWZpbmVJbkxheWVycyk7XG4gICAgc2xiVHhyQ2FjaGUub25EZXF1ZXVlKHJlZmluZUluTGF5ZXJzKTtcbiAgICB0bGJUeHJDYWNoZS5vbkRlcXVldWUocmVmaW5lSW5MYXllcnMpO1xuICB9XG5cbiAgQ1JwLnJlZHJhd0hpbnQgPSBmdW5jdGlvbiAoZ3JvdXAsIGJvb2wpIHtcbiAgICB2YXIgciA9IHRoaXM7XG5cbiAgICBzd2l0Y2ggKGdyb3VwKSB7XG4gICAgICBjYXNlICdlbGVzJzpcbiAgICAgICAgci5kYXRhLmNhbnZhc05lZWRzUmVkcmF3W0NScC5OT0RFXSA9IGJvb2w7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdkcmFnJzpcbiAgICAgICAgci5kYXRhLmNhbnZhc05lZWRzUmVkcmF3W0NScC5EUkFHXSA9IGJvb2w7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbQ1JwLlNFTEVDVF9CT1hdID0gYm9vbDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9OyAvLyB3aGV0aGVyIHRvIHVzZSBQYXRoMkQgY2FjaGluZyBmb3IgZHJhd2luZ1xuXG5cbiAgdmFyIHBhdGhzSW1wbGQgPSB0eXBlb2YgUGF0aDJEICE9PSAndW5kZWZpbmVkJztcblxuICBDUnAucGF0aDJkRW5hYmxlZCA9IGZ1bmN0aW9uIChvbikge1xuICAgIGlmIChvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXRoc0VuYWJsZWQ7XG4gICAgfVxuXG4gICAgdGhpcy5wYXRoc0VuYWJsZWQgPSBvbiA/IHRydWUgOiBmYWxzZTtcbiAgfTtcblxuICBDUnAudXNlUGF0aHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHBhdGhzSW1wbGQgJiYgdGhpcy5wYXRoc0VuYWJsZWQ7XG4gIH07XG5cbiAgQ1JwLnNldEltZ1Ntb290aGluZyA9IGZ1bmN0aW9uIChjb250ZXh0LCBib29sKSB7XG4gICAgaWYgKGNvbnRleHQuaW1hZ2VTbW9vdGhpbmdFbmFibGVkICE9IG51bGwpIHtcbiAgICAgIGNvbnRleHQuaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gYm9vbDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC53ZWJraXRJbWFnZVNtb290aGluZ0VuYWJsZWQgPSBib29sO1xuICAgICAgY29udGV4dC5tb3pJbWFnZVNtb290aGluZ0VuYWJsZWQgPSBib29sO1xuICAgICAgY29udGV4dC5tc0ltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGJvb2w7XG4gICAgfVxuICB9O1xuXG4gIENScC5nZXRJbWdTbW9vdGhpbmcgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIGlmIChjb250ZXh0LmltYWdlU21vb3RoaW5nRW5hYmxlZCAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gY29udGV4dC5pbWFnZVNtb290aGluZ0VuYWJsZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjb250ZXh0LndlYmtpdEltYWdlU21vb3RoaW5nRW5hYmxlZCB8fCBjb250ZXh0Lm1vekltYWdlU21vb3RoaW5nRW5hYmxlZCB8fCBjb250ZXh0Lm1zSW1hZ2VTbW9vdGhpbmdFbmFibGVkO1xuICAgIH1cbiAgfTtcblxuICBDUnAubWFrZU9mZnNjcmVlbkNhbnZhcyA9IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdmFyIGNhbnZhcztcblxuICAgIGlmICgodHlwZW9mIE9mZnNjcmVlbkNhbnZhcyA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKE9mZnNjcmVlbkNhbnZhcykpICE9PSAoXCJ1bmRlZmluZWRcIiApKSB7XG4gICAgICBjYW52YXMgPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKHdpZHRoLCBoZWlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4gICAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNhbnZhcztcbiAgfTtcblxuICBbQ1JwJGEsIENScCQ5LCBDUnAkOCwgQ1JwJDcsIENScCQ2LCBDUnAkNSwgQ1JwJDQsIENScCQzLCBDUnAkMiwgQ1JwJDFdLmZvckVhY2goZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgZXh0ZW5kKENScCwgcHJvcHMpO1xuICB9KTtcblxuICB2YXIgcmVuZGVyZXIgPSBbe1xuICAgIG5hbWU6ICdudWxsJyxcbiAgICBpbXBsOiBOdWxsUmVuZGVyZXJcbiAgfSwge1xuICAgIG5hbWU6ICdiYXNlJyxcbiAgICBpbXBsOiBCUlxuICB9LCB7XG4gICAgbmFtZTogJ2NhbnZhcycsXG4gICAgaW1wbDogQ1JcbiAgfV07XG5cbiAgdmFyIGluY0V4dHMgPSBbe1xuICAgIHR5cGU6ICdsYXlvdXQnLFxuICAgIGV4dGVuc2lvbnM6IGxheW91dFxuICB9LCB7XG4gICAgdHlwZTogJ3JlbmRlcmVyJyxcbiAgICBleHRlbnNpb25zOiByZW5kZXJlclxuICB9XTtcblxuICB2YXIgZXh0ZW5zaW9ucyA9IHt9OyAvLyByZWdpc3RlcmVkIG1vZHVsZXMgZm9yIGV4dGVuc2lvbnMsIGluZGV4ZWQgYnkgbmFtZVxuXG4gIHZhciBtb2R1bGVzID0ge307XG5cbiAgZnVuY3Rpb24gc2V0RXh0ZW5zaW9uKHR5cGUsIG5hbWUsIHJlZ2lzdHJhbnQpIHtcbiAgICB2YXIgZXh0ID0gcmVnaXN0cmFudDtcblxuICAgIHZhciBvdmVycmlkZUVyciA9IGZ1bmN0aW9uIG92ZXJyaWRlRXJyKGZpZWxkKSB7XG4gICAgICB3YXJuKCdDYW4gbm90IHJlZ2lzdGVyIGAnICsgbmFtZSArICdgIGZvciBgJyArIHR5cGUgKyAnYCBzaW5jZSBgJyArIGZpZWxkICsgJ2AgYWxyZWFkeSBleGlzdHMgaW4gdGhlIHByb3RvdHlwZSBhbmQgY2FuIG5vdCBiZSBvdmVycmlkZGVuJyk7XG4gICAgfTtcblxuICAgIGlmICh0eXBlID09PSAnY29yZScpIHtcbiAgICAgIGlmIChDb3JlLnByb3RvdHlwZVtuYW1lXSkge1xuICAgICAgICByZXR1cm4gb3ZlcnJpZGVFcnIobmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBDb3JlLnByb3RvdHlwZVtuYW1lXSA9IHJlZ2lzdHJhbnQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnY29sbGVjdGlvbicpIHtcbiAgICAgIGlmIChDb2xsZWN0aW9uLnByb3RvdHlwZVtuYW1lXSkge1xuICAgICAgICByZXR1cm4gb3ZlcnJpZGVFcnIobmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZVtuYW1lXSA9IHJlZ2lzdHJhbnQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnbGF5b3V0Jykge1xuICAgICAgLy8gZmlsbCBpbiBtaXNzaW5nIGxheW91dCBmdW5jdGlvbnMgaW4gdGhlIHByb3RvdHlwZVxuICAgICAgdmFyIExheW91dCA9IGZ1bmN0aW9uIExheW91dChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHJlZ2lzdHJhbnQuY2FsbCh0aGlzLCBvcHRpb25zKTsgLy8gbWFrZSBzdXJlIGxheW91dCBoYXMgX3ByaXZhdGUgZm9yIHVzZSB3LyBzdGQgYXBpcyBsaWtlIC5vbigpXG5cbiAgICAgICAgaWYgKCFwbGFpbk9iamVjdCh0aGlzLl9wcml2YXRlKSkge1xuICAgICAgICAgIHRoaXMuX3ByaXZhdGUgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3ByaXZhdGUuY3kgPSBvcHRpb25zLmN5O1xuICAgICAgICB0aGlzLl9wcml2YXRlLmxpc3RlbmVycyA9IFtdO1xuICAgICAgICB0aGlzLmNyZWF0ZUVtaXR0ZXIoKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBsYXlvdXRQcm90byA9IExheW91dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHJlZ2lzdHJhbnQucHJvdG90eXBlKTtcbiAgICAgIHZhciBvcHRMYXlvdXRGbnMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHRMYXlvdXRGbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGZuTmFtZSA9IG9wdExheW91dEZuc1tpXTtcblxuICAgICAgICBsYXlvdXRQcm90b1tmbk5hbWVdID0gbGF5b3V0UHJvdG9bZm5OYW1lXSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICB9IC8vIGVpdGhlciAuc3RhcnQoKSBvciAucnVuKCkgaXMgZGVmaW5lZCwgc28gYXV0b2dlbiB0aGUgb3RoZXJcblxuXG4gICAgICBpZiAobGF5b3V0UHJvdG8uc3RhcnQgJiYgIWxheW91dFByb3RvLnJ1bikge1xuICAgICAgICBsYXlvdXRQcm90by5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmICghbGF5b3V0UHJvdG8uc3RhcnQgJiYgbGF5b3V0UHJvdG8ucnVuKSB7XG4gICAgICAgIGxheW91dFByb3RvLnN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMucnVuKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHZhciByZWdTdG9wID0gcmVnaXN0cmFudC5wcm90b3R5cGUuc3RvcDtcblxuICAgICAgbGF5b3V0UHJvdG8uc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9wdHMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICAgICAgaWYgKG9wdHMgJiYgb3B0cy5hbmltYXRlKSB7XG4gICAgICAgICAgdmFyIGFuaXMgPSB0aGlzLmFuaW1hdGlvbnM7XG5cbiAgICAgICAgICBpZiAoYW5pcykge1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFuaXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgIGFuaXNbX2ldLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVnU3RvcCkge1xuICAgICAgICAgIHJlZ1N0b3AuY2FsbCh0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmVtaXQoJ2xheW91dHN0b3AnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcblxuICAgICAgaWYgKCFsYXlvdXRQcm90by5kZXN0cm95KSB7XG4gICAgICAgIGxheW91dFByb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGxheW91dFByb3RvLmN5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBnZXRDeSA9IGZ1bmN0aW9uIGdldEN5KGxheW91dCkge1xuICAgICAgICByZXR1cm4gbGF5b3V0Ll9wcml2YXRlLmN5O1xuICAgICAgfTtcblxuICAgICAgdmFyIGVtaXR0ZXJPcHRzID0ge1xuICAgICAgICBhZGRFdmVudEZpZWxkczogZnVuY3Rpb24gYWRkRXZlbnRGaWVsZHMobGF5b3V0LCBldnQpIHtcbiAgICAgICAgICBldnQubGF5b3V0ID0gbGF5b3V0O1xuICAgICAgICAgIGV2dC5jeSA9IGdldEN5KGxheW91dCk7XG4gICAgICAgICAgZXZ0LnRhcmdldCA9IGxheW91dDtcbiAgICAgICAgfSxcbiAgICAgICAgYnViYmxlOiBmdW5jdGlvbiBidWJibGUoKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIHBhcmVudDogZnVuY3Rpb24gcGFyZW50KGxheW91dCkge1xuICAgICAgICAgIHJldHVybiBnZXRDeShsYXlvdXQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZXh0ZW5kKGxheW91dFByb3RvLCB7XG4gICAgICAgIGNyZWF0ZUVtaXR0ZXI6IGZ1bmN0aW9uIGNyZWF0ZUVtaXR0ZXIoKSB7XG4gICAgICAgICAgdGhpcy5fcHJpdmF0ZS5lbWl0dGVyID0gbmV3IEVtaXR0ZXIoZW1pdHRlck9wdHMsIHRoaXMpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBlbWl0dGVyOiBmdW5jdGlvbiBlbWl0dGVyKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmVtaXR0ZXI7XG4gICAgICAgIH0sXG4gICAgICAgIG9uOiBmdW5jdGlvbiBvbihldnQsIGNiKSB7XG4gICAgICAgICAgdGhpcy5lbWl0dGVyKCkub24oZXZ0LCBjYik7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIG9uZTogZnVuY3Rpb24gb25lKGV2dCwgY2IpIHtcbiAgICAgICAgICB0aGlzLmVtaXR0ZXIoKS5vbmUoZXZ0LCBjYik7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIG9uY2U6IGZ1bmN0aW9uIG9uY2UoZXZ0LCBjYikge1xuICAgICAgICAgIHRoaXMuZW1pdHRlcigpLm9uZShldnQsIGNiKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlTGlzdGVuZXI6IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKGV2dCwgY2IpIHtcbiAgICAgICAgICB0aGlzLmVtaXR0ZXIoKS5yZW1vdmVMaXN0ZW5lcihldnQsIGNiKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlQWxsTGlzdGVuZXJzOiBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnMoKSB7XG4gICAgICAgICAgdGhpcy5lbWl0dGVyKCkucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIGVtaXQ6IGZ1bmN0aW9uIGVtaXQoZXZ0LCBwYXJhbXMpIHtcbiAgICAgICAgICB0aGlzLmVtaXR0ZXIoKS5lbWl0KGV2dCwgcGFyYW1zKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBkZWZpbmUuZXZlbnRBbGlhc2VzT24obGF5b3V0UHJvdG8pO1xuICAgICAgZXh0ID0gTGF5b3V0OyAvLyByZXBsYWNlIHdpdGggb3VyIHdyYXBwZWQgbGF5b3V0XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAncmVuZGVyZXInICYmIG5hbWUgIT09ICdudWxsJyAmJiBuYW1lICE9PSAnYmFzZScpIHtcbiAgICAgIC8vIHVzZXIgcmVnaXN0ZXJlZCByZW5kZXJlcnMgaW5oZXJpdCBmcm9tIGJhc2VcbiAgICAgIHZhciBCYXNlUmVuZGVyZXIgPSBnZXRFeHRlbnNpb24oJ3JlbmRlcmVyJywgJ2Jhc2UnKTtcbiAgICAgIHZhciBiUHJvdG8gPSBCYXNlUmVuZGVyZXIucHJvdG90eXBlO1xuICAgICAgdmFyIFJlZ2lzdHJhbnRSZW5kZXJlciA9IHJlZ2lzdHJhbnQ7XG4gICAgICB2YXIgclByb3RvID0gcmVnaXN0cmFudC5wcm90b3R5cGU7XG5cbiAgICAgIHZhciBSZW5kZXJlciA9IGZ1bmN0aW9uIFJlbmRlcmVyKCkge1xuICAgICAgICBCYXNlUmVuZGVyZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgUmVnaXN0cmFudFJlbmRlcmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgcHJvdG8gPSBSZW5kZXJlci5wcm90b3R5cGU7XG5cbiAgICAgIGZvciAodmFyIHBOYW1lIGluIGJQcm90bykge1xuICAgICAgICB2YXIgcFZhbCA9IGJQcm90b1twTmFtZV07XG4gICAgICAgIHZhciBleGlzdHNJblIgPSByUHJvdG9bcE5hbWVdICE9IG51bGw7XG5cbiAgICAgICAgaWYgKGV4aXN0c0luUikge1xuICAgICAgICAgIHJldHVybiBvdmVycmlkZUVycihwTmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBwcm90b1twTmFtZV0gPSBwVmFsOyAvLyB0YWtlIGltcGwgZnJvbSBiYXNlXG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIF9wTmFtZSBpbiByUHJvdG8pIHtcbiAgICAgICAgcHJvdG9bX3BOYW1lXSA9IHJQcm90b1tfcE5hbWVdOyAvLyB0YWtlIGltcGwgZnJvbSByZWdpc3RyYW50XG4gICAgICB9XG5cbiAgICAgIGJQcm90by5jbGllbnRGdW5jdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBwcm90b1tuYW1lXSA9IHByb3RvW25hbWVdIHx8IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlcnJvcignUmVuZGVyZXIgZG9lcyBub3QgaW1wbGVtZW50IGByZW5kZXJlci4nICsgbmFtZSArICcoKWAgb24gaXRzIHByb3RvdHlwZScpO1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICBleHQgPSBSZW5kZXJlcjtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdfX3Byb3RvX18nIHx8IHR5cGUgPT09ICdjb25zdHJ1Y3RvcicgfHwgdHlwZSA9PT0gJ3Byb3RvdHlwZScpIHtcbiAgICAgIC8vIHRvIGF2b2lkIHBvdGVudGlhbCBwcm90b3R5cGUgcG9sbHV0aW9uXG4gICAgICByZXR1cm4gZXJyb3IodHlwZSArICcgaXMgYW4gaWxsZWdhbCB0eXBlIHRvIGJlIHJlZ2lzdGVyZWQsIHBvc3NpYmx5IGxlYWQgdG8gcHJvdG90eXBlIHBvbGx1dGlvbnMnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2V0TWFwKHtcbiAgICAgIG1hcDogZXh0ZW5zaW9ucyxcbiAgICAgIGtleXM6IFt0eXBlLCBuYW1lXSxcbiAgICAgIHZhbHVlOiBleHRcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEV4dGVuc2lvbih0eXBlLCBuYW1lKSB7XG4gICAgcmV0dXJuIGdldE1hcCh7XG4gICAgICBtYXA6IGV4dGVuc2lvbnMsXG4gICAgICBrZXlzOiBbdHlwZSwgbmFtZV1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldE1vZHVsZSh0eXBlLCBuYW1lLCBtb2R1bGVUeXBlLCBtb2R1bGVOYW1lLCByZWdpc3RyYW50KSB7XG4gICAgcmV0dXJuIHNldE1hcCh7XG4gICAgICBtYXA6IG1vZHVsZXMsXG4gICAgICBrZXlzOiBbdHlwZSwgbmFtZSwgbW9kdWxlVHlwZSwgbW9kdWxlTmFtZV0sXG4gICAgICB2YWx1ZTogcmVnaXN0cmFudFxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TW9kdWxlKHR5cGUsIG5hbWUsIG1vZHVsZVR5cGUsIG1vZHVsZU5hbWUpIHtcbiAgICByZXR1cm4gZ2V0TWFwKHtcbiAgICAgIG1hcDogbW9kdWxlcyxcbiAgICAgIGtleXM6IFt0eXBlLCBuYW1lLCBtb2R1bGVUeXBlLCBtb2R1bGVOYW1lXVxuICAgIH0pO1xuICB9XG5cbiAgdmFyIGV4dGVuc2lvbiA9IGZ1bmN0aW9uIGV4dGVuc2lvbigpIHtcbiAgICAvLyBlLmcuIGV4dGVuc2lvbigncmVuZGVyZXInLCAnc3ZnJylcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgcmV0dXJuIGdldEV4dGVuc2lvbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0gLy8gZS5nLiBleHRlbnNpb24oJ3JlbmRlcmVyJywgJ3N2ZycsIHsgLi4uIH0pXG4gICAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgcmV0dXJuIHNldEV4dGVuc2lvbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0gLy8gZS5nLiBleHRlbnNpb24oJ3JlbmRlcmVyJywgJ3N2ZycsICdub2RlU2hhcGUnLCAnZWxsaXBzZScpXG4gICAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCkge1xuICAgICAgcmV0dXJuIGdldE1vZHVsZS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0gLy8gZS5nLiBleHRlbnNpb24oJ3JlbmRlcmVyJywgJ3N2ZycsICdub2RlU2hhcGUnLCAnZWxsaXBzZScsIHsgLi4uIH0pXG4gICAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNSkge1xuICAgICAgcmV0dXJuIHNldE1vZHVsZS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlcnJvcignSW52YWxpZCBleHRlbnNpb24gYWNjZXNzIHN5bnRheCcpO1xuICAgIH1cbiAgfTsgLy8gYWxsb3dzIGEgY29yZSBpbnN0YW5jZSB0byBhY2Nlc3MgZXh0ZW5zaW9ucyBpbnRlcm5hbGx5XG5cblxuICBDb3JlLnByb3RvdHlwZS5leHRlbnNpb24gPSBleHRlbnNpb247IC8vIGluY2x1ZGVkIGV4dGVuc2lvbnNcblxuICBpbmNFeHRzLmZvckVhY2goZnVuY3Rpb24gKGdyb3VwKSB7XG4gICAgZ3JvdXAuZXh0ZW5zaW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChleHQpIHtcbiAgICAgIHNldEV4dGVuc2lvbihncm91cC50eXBlLCBleHQubmFtZSwgZXh0LmltcGwpO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyAodXNlZnVsIGZvciBpbml0KVxuXG4gIHZhciBTdHlsZXNoZWV0ID0gZnVuY3Rpb24gU3R5bGVzaGVldCgpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU3R5bGVzaGVldCkpIHtcbiAgICAgIHJldHVybiBuZXcgU3R5bGVzaGVldCgpO1xuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgfTtcblxuICB2YXIgc2hlZXRmbiA9IFN0eWxlc2hlZXQucHJvdG90eXBlO1xuXG4gIHNoZWV0Zm4uaW5zdGFuY2VTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICdzdHlsZXNoZWV0JztcbiAgfTsgLy8ganVzdCBzdG9yZSB0aGUgc2VsZWN0b3IgdG8gYmUgcGFyc2VkIGxhdGVyXG5cblxuICBzaGVldGZuLnNlbGVjdG9yID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgdmFyIGkgPSB0aGlzLmxlbmd0aCsrO1xuICAgIHRoaXNbaV0gPSB7XG4gICAgICBzZWxlY3Rvcjogc2VsZWN0b3IsXG4gICAgICBwcm9wZXJ0aWVzOiBbXVxuICAgIH07XG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH07IC8vIGp1c3Qgc3RvcmUgdGhlIHByb3BlcnR5IHRvIGJlIHBhcnNlZCBsYXRlclxuXG5cbiAgc2hlZXRmbi5jc3MgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTtcblxuICAgIGlmIChzdHJpbmcobmFtZSkpIHtcbiAgICAgIHRoaXNbaV0ucHJvcGVydGllcy5wdXNoKHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHBsYWluT2JqZWN0KG5hbWUpKSB7XG4gICAgICB2YXIgbWFwID0gbmFtZTtcbiAgICAgIHZhciBwcm9wTmFtZXMgPSBPYmplY3Qua2V5cyhtYXApO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHByb3BOYW1lcy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIga2V5ID0gcHJvcE5hbWVzW2pdO1xuICAgICAgICB2YXIgbWFwVmFsID0gbWFwW2tleV07XG5cbiAgICAgICAgaWYgKG1hcFZhbCA9PSBudWxsKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJvcCA9IFN0eWxlLnByb3BlcnRpZXNba2V5XSB8fCBTdHlsZS5wcm9wZXJ0aWVzW2Rhc2gyY2FtZWwoa2V5KV07XG5cbiAgICAgICAgaWYgKHByb3AgPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9uYW1lID0gcHJvcC5uYW1lO1xuICAgICAgICB2YXIgX3ZhbHVlID0gbWFwVmFsO1xuICAgICAgICB0aGlzW2ldLnByb3BlcnRpZXMucHVzaCh7XG4gICAgICAgICAgbmFtZTogX25hbWUsXG4gICAgICAgICAgdmFsdWU6IF92YWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfTtcblxuICBzaGVldGZuLnN0eWxlID0gc2hlZXRmbi5jc3M7IC8vIGdlbmVyYXRlIGEgcmVhbCBzdHlsZSBvYmplY3QgZnJvbSB0aGUgZHVtbXkgc3R5bGVzaGVldFxuXG4gIHNoZWV0Zm4uZ2VuZXJhdGVTdHlsZSA9IGZ1bmN0aW9uIChjeSkge1xuICAgIHZhciBzdHlsZSA9IG5ldyBTdHlsZShjeSk7XG4gICAgcmV0dXJuIHRoaXMuYXBwZW5kVG9TdHlsZShzdHlsZSk7XG4gIH07IC8vIGFwcGVuZCBhIGR1bW15IHN0eWxlc2hlZXQgb2JqZWN0IG9uIGEgcmVhbCBzdHlsZSBvYmplY3RcblxuXG4gIHNoZWV0Zm4uYXBwZW5kVG9TdHlsZSA9IGZ1bmN0aW9uIChzdHlsZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzW2ldO1xuICAgICAgdmFyIHNlbGVjdG9yID0gY29udGV4dC5zZWxlY3RvcjtcbiAgICAgIHZhciBwcm9wcyA9IGNvbnRleHQucHJvcGVydGllcztcbiAgICAgIHN0eWxlLnNlbGVjdG9yKHNlbGVjdG9yKTsgLy8gYXBwbHkgc2VsZWN0b3JcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwcm9wcy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgcHJvcCA9IHByb3BzW2pdO1xuICAgICAgICBzdHlsZS5jc3MocHJvcC5uYW1lLCBwcm9wLnZhbHVlKTsgLy8gYXBwbHkgcHJvcGVydHlcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3R5bGU7XG4gIH07XG5cbiAgdmFyIHZlcnNpb24gPSBcIjMuMjQuMFwiO1xuXG4gIHZhciBjeXRvc2NhcGUgPSBmdW5jdGlvbiBjeXRvc2NhcGUob3B0aW9ucykge1xuICAgIC8vIGlmIG5vIG9wdGlvbnMgc3BlY2lmaWVkLCB1c2UgZGVmYXVsdFxuICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9IC8vIGNyZWF0ZSBpbnN0YW5jZVxuXG5cbiAgICBpZiAocGxhaW5PYmplY3Qob3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBuZXcgQ29yZShvcHRpb25zKTtcbiAgICB9IC8vIGFsbG93IGZvciByZWdpc3RyYXRpb24gb2YgZXh0ZW5zaW9uc1xuICAgIGVsc2UgaWYgKHN0cmluZyhvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIGV4dGVuc2lvbi5hcHBseShleHRlbnNpb24sIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9OyAvLyBlLmcuIGN5dG9zY2FwZS51c2UoIHJlcXVpcmUoJ2N5dG9zY2FwZS1mb28nKSwgYmFyIClcblxuXG4gIGN5dG9zY2FwZS51c2UgPSBmdW5jdGlvbiAoZXh0KSB7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpOyAvLyBhcmdzIHRvIHBhc3MgdG8gZXh0XG5cbiAgICBhcmdzLnVuc2hpZnQoY3l0b3NjYXBlKTsgLy8gY3l0b3NjYXBlIGlzIGZpcnN0IGFyZyB0byBleHRcblxuICAgIGV4dC5hcHBseShudWxsLCBhcmdzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBjeXRvc2NhcGUud2FybmluZ3MgPSBmdW5jdGlvbiAoYm9vbCkge1xuICAgIHJldHVybiB3YXJuaW5ncyhib29sKTtcbiAgfTsgLy8gcmVwbGFjZWQgYnkgYnVpbGQgc3lzdGVtXG5cblxuICBjeXRvc2NhcGUudmVyc2lvbiA9IHZlcnNpb247IC8vIGV4cG9zZSBwdWJsaWMgYXBpcyAobW9zdGx5IGZvciBleHRlbnNpb25zKVxuXG4gIGN5dG9zY2FwZS5zdHlsZXNoZWV0ID0gY3l0b3NjYXBlLlN0eWxlc2hlZXQgPSBTdHlsZXNoZWV0O1xuXG4gIHJldHVybiBjeXRvc2NhcGU7XG5cbn0pKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/cytoscape/dist/cytoscape.umd.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/layout-base/layout-base.js":
/*!*************************************************!*\
  !*** ./node_modules/layout-base/layout-base.js ***!
  \*************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_543__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_543__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__nested_webpack_require_543__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__nested_webpack_require_543__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__nested_webpack_require_543__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__nested_webpack_require_543__.d = function(exports, name, getter) {\n/******/ \t\tif(!__nested_webpack_require_543__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__nested_webpack_require_543__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__nested_webpack_require_543__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__nested_webpack_require_543__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__nested_webpack_require_543__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __nested_webpack_require_543__(__nested_webpack_require_543__.s = 26);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction LayoutConstants() {}\n\n/**\r\n * Layout Quality: 0:draft, 1:default, 2:proof\r\n */\nLayoutConstants.QUALITY = 1;\n\n/**\r\n * Default parameters\r\n */\nLayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED = false;\nLayoutConstants.DEFAULT_INCREMENTAL = false;\nLayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT = true;\nLayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT = false;\nLayoutConstants.DEFAULT_ANIMATION_PERIOD = 50;\nLayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES = false;\n\n// -----------------------------------------------------------------------------\n// Section: General other constants\n// -----------------------------------------------------------------------------\n/*\r\n * Margins of a graph to be applied on bouding rectangle of its contents. We\r\n * assume margins on all four sides to be uniform.\r\n */\nLayoutConstants.DEFAULT_GRAPH_MARGIN = 15;\n\n/*\r\n * Whether to consider labels in node dimensions or not\r\n */\nLayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = false;\n\n/*\r\n * Default dimension of a non-compound node.\r\n */\nLayoutConstants.SIMPLE_NODE_SIZE = 40;\n\n/*\r\n * Default dimension of a non-compound node.\r\n */\nLayoutConstants.SIMPLE_NODE_HALF_SIZE = LayoutConstants.SIMPLE_NODE_SIZE / 2;\n\n/*\r\n * Empty compound node size. When a compound node is empty, its both\r\n * dimensions should be of this value.\r\n */\nLayoutConstants.EMPTY_COMPOUND_NODE_SIZE = 40;\n\n/*\r\n * Minimum length that an edge should take during layout\r\n */\nLayoutConstants.MIN_EDGE_LENGTH = 1;\n\n/*\r\n * World boundaries that layout operates on\r\n */\nLayoutConstants.WORLD_BOUNDARY = 1000000;\n\n/*\r\n * World boundaries that random positioning can be performed with\r\n */\nLayoutConstants.INITIAL_WORLD_BOUNDARY = LayoutConstants.WORLD_BOUNDARY / 1000;\n\n/*\r\n * Coordinates of the world center\r\n */\nLayoutConstants.WORLD_CENTER_X = 1200;\nLayoutConstants.WORLD_CENTER_Y = 900;\n\nmodule.exports = LayoutConstants;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __nested_webpack_require_4947__) {\n\n\"use strict\";\n\n\nvar LGraphObject = __nested_webpack_require_4947__(2);\nvar IGeometry = __nested_webpack_require_4947__(8);\nvar IMath = __nested_webpack_require_4947__(9);\n\nfunction LEdge(source, target, vEdge) {\n  LGraphObject.call(this, vEdge);\n\n  this.isOverlapingSourceAndTarget = false;\n  this.vGraphObject = vEdge;\n  this.bendpoints = [];\n  this.source = source;\n  this.target = target;\n}\n\nLEdge.prototype = Object.create(LGraphObject.prototype);\n\nfor (var prop in LGraphObject) {\n  LEdge[prop] = LGraphObject[prop];\n}\n\nLEdge.prototype.getSource = function () {\n  return this.source;\n};\n\nLEdge.prototype.getTarget = function () {\n  return this.target;\n};\n\nLEdge.prototype.isInterGraph = function () {\n  return this.isInterGraph;\n};\n\nLEdge.prototype.getLength = function () {\n  return this.length;\n};\n\nLEdge.prototype.isOverlapingSourceAndTarget = function () {\n  return this.isOverlapingSourceAndTarget;\n};\n\nLEdge.prototype.getBendpoints = function () {\n  return this.bendpoints;\n};\n\nLEdge.prototype.getLca = function () {\n  return this.lca;\n};\n\nLEdge.prototype.getSourceInLca = function () {\n  return this.sourceInLca;\n};\n\nLEdge.prototype.getTargetInLca = function () {\n  return this.targetInLca;\n};\n\nLEdge.prototype.getOtherEnd = function (node) {\n  if (this.source === node) {\n    return this.target;\n  } else if (this.target === node) {\n    return this.source;\n  } else {\n    throw \"Node is not incident with this edge\";\n  }\n};\n\nLEdge.prototype.getOtherEndInGraph = function (node, graph) {\n  var otherEnd = this.getOtherEnd(node);\n  var root = graph.getGraphManager().getRoot();\n\n  while (true) {\n    if (otherEnd.getOwner() == graph) {\n      return otherEnd;\n    }\n\n    if (otherEnd.getOwner() == root) {\n      break;\n    }\n\n    otherEnd = otherEnd.getOwner().getParent();\n  }\n\n  return null;\n};\n\nLEdge.prototype.updateLength = function () {\n  var clipPointCoordinates = new Array(4);\n\n  this.isOverlapingSourceAndTarget = IGeometry.getIntersection(this.target.getRect(), this.source.getRect(), clipPointCoordinates);\n\n  if (!this.isOverlapingSourceAndTarget) {\n    this.lengthX = clipPointCoordinates[0] - clipPointCoordinates[2];\n    this.lengthY = clipPointCoordinates[1] - clipPointCoordinates[3];\n\n    if (Math.abs(this.lengthX) < 1.0) {\n      this.lengthX = IMath.sign(this.lengthX);\n    }\n\n    if (Math.abs(this.lengthY) < 1.0) {\n      this.lengthY = IMath.sign(this.lengthY);\n    }\n\n    this.length = Math.sqrt(this.lengthX * this.lengthX + this.lengthY * this.lengthY);\n  }\n};\n\nLEdge.prototype.updateLengthSimple = function () {\n  this.lengthX = this.target.getCenterX() - this.source.getCenterX();\n  this.lengthY = this.target.getCenterY() - this.source.getCenterY();\n\n  if (Math.abs(this.lengthX) < 1.0) {\n    this.lengthX = IMath.sign(this.lengthX);\n  }\n\n  if (Math.abs(this.lengthY) < 1.0) {\n    this.lengthY = IMath.sign(this.lengthY);\n  }\n\n  this.length = Math.sqrt(this.lengthX * this.lengthX + this.lengthY * this.lengthY);\n};\n\nmodule.exports = LEdge;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction LGraphObject(vGraphObject) {\n  this.vGraphObject = vGraphObject;\n}\n\nmodule.exports = LGraphObject;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __nested_webpack_require_8167__) {\n\n\"use strict\";\n\n\nvar LGraphObject = __nested_webpack_require_8167__(2);\nvar Integer = __nested_webpack_require_8167__(10);\nvar RectangleD = __nested_webpack_require_8167__(13);\nvar LayoutConstants = __nested_webpack_require_8167__(0);\nvar RandomSeed = __nested_webpack_require_8167__(16);\nvar PointD = __nested_webpack_require_8167__(4);\n\nfunction LNode(gm, loc, size, vNode) {\n  //Alternative constructor 1 : LNode(LGraphManager gm, Point loc, Dimension size, Object vNode)\n  if (size == null && vNode == null) {\n    vNode = loc;\n  }\n\n  LGraphObject.call(this, vNode);\n\n  //Alternative constructor 2 : LNode(Layout layout, Object vNode)\n  if (gm.graphManager != null) gm = gm.graphManager;\n\n  this.estimatedSize = Integer.MIN_VALUE;\n  this.inclusionTreeDepth = Integer.MAX_VALUE;\n  this.vGraphObject = vNode;\n  this.edges = [];\n  this.graphManager = gm;\n\n  if (size != null && loc != null) this.rect = new RectangleD(loc.x, loc.y, size.width, size.height);else this.rect = new RectangleD();\n}\n\nLNode.prototype = Object.create(LGraphObject.prototype);\nfor (var prop in LGraphObject) {\n  LNode[prop] = LGraphObject[prop];\n}\n\nLNode.prototype.getEdges = function () {\n  return this.edges;\n};\n\nLNode.prototype.getChild = function () {\n  return this.child;\n};\n\nLNode.prototype.getOwner = function () {\n  //  if (this.owner != null) {\n  //    if (!(this.owner == null || this.owner.getNodes().indexOf(this) > -1)) {\n  //      throw \"assert failed\";\n  //    }\n  //  }\n\n  return this.owner;\n};\n\nLNode.prototype.getWidth = function () {\n  return this.rect.width;\n};\n\nLNode.prototype.setWidth = function (width) {\n  this.rect.width = width;\n};\n\nLNode.prototype.getHeight = function () {\n  return this.rect.height;\n};\n\nLNode.prototype.setHeight = function (height) {\n  this.rect.height = height;\n};\n\nLNode.prototype.getCenterX = function () {\n  return this.rect.x + this.rect.width / 2;\n};\n\nLNode.prototype.getCenterY = function () {\n  return this.rect.y + this.rect.height / 2;\n};\n\nLNode.prototype.getCenter = function () {\n  return new PointD(this.rect.x + this.rect.width / 2, this.rect.y + this.rect.height / 2);\n};\n\nLNode.prototype.getLocation = function () {\n  return new PointD(this.rect.x, this.rect.y);\n};\n\nLNode.prototype.getRect = function () {\n  return this.rect;\n};\n\nLNode.prototype.getDiagonal = function () {\n  return Math.sqrt(this.rect.width * this.rect.width + this.rect.height * this.rect.height);\n};\n\n/**\n * This method returns half the diagonal length of this node.\n */\nLNode.prototype.getHalfTheDiagonal = function () {\n  return Math.sqrt(this.rect.height * this.rect.height + this.rect.width * this.rect.width) / 2;\n};\n\nLNode.prototype.setRect = function (upperLeft, dimension) {\n  this.rect.x = upperLeft.x;\n  this.rect.y = upperLeft.y;\n  this.rect.width = dimension.width;\n  this.rect.height = dimension.height;\n};\n\nLNode.prototype.setCenter = function (cx, cy) {\n  this.rect.x = cx - this.rect.width / 2;\n  this.rect.y = cy - this.rect.height / 2;\n};\n\nLNode.prototype.setLocation = function (x, y) {\n  this.rect.x = x;\n  this.rect.y = y;\n};\n\nLNode.prototype.moveBy = function (dx, dy) {\n  this.rect.x += dx;\n  this.rect.y += dy;\n};\n\nLNode.prototype.getEdgeListToNode = function (to) {\n  var edgeList = [];\n  var edge;\n  var self = this;\n\n  self.edges.forEach(function (edge) {\n\n    if (edge.target == to) {\n      if (edge.source != self) throw \"Incorrect edge source!\";\n\n      edgeList.push(edge);\n    }\n  });\n\n  return edgeList;\n};\n\nLNode.prototype.getEdgesBetween = function (other) {\n  var edgeList = [];\n  var edge;\n\n  var self = this;\n  self.edges.forEach(function (edge) {\n\n    if (!(edge.source == self || edge.target == self)) throw \"Incorrect edge source and/or target\";\n\n    if (edge.target == other || edge.source == other) {\n      edgeList.push(edge);\n    }\n  });\n\n  return edgeList;\n};\n\nLNode.prototype.getNeighborsList = function () {\n  var neighbors = new Set();\n\n  var self = this;\n  self.edges.forEach(function (edge) {\n\n    if (edge.source == self) {\n      neighbors.add(edge.target);\n    } else {\n      if (edge.target != self) {\n        throw \"Incorrect incidency!\";\n      }\n\n      neighbors.add(edge.source);\n    }\n  });\n\n  return neighbors;\n};\n\nLNode.prototype.withChildren = function () {\n  var withNeighborsList = new Set();\n  var childNode;\n  var children;\n\n  withNeighborsList.add(this);\n\n  if (this.child != null) {\n    var nodes = this.child.getNodes();\n    for (var i = 0; i < nodes.length; i++) {\n      childNode = nodes[i];\n      children = childNode.withChildren();\n      children.forEach(function (node) {\n        withNeighborsList.add(node);\n      });\n    }\n  }\n\n  return withNeighborsList;\n};\n\nLNode.prototype.getNoOfChildren = function () {\n  var noOfChildren = 0;\n  var childNode;\n\n  if (this.child == null) {\n    noOfChildren = 1;\n  } else {\n    var nodes = this.child.getNodes();\n    for (var i = 0; i < nodes.length; i++) {\n      childNode = nodes[i];\n\n      noOfChildren += childNode.getNoOfChildren();\n    }\n  }\n\n  if (noOfChildren == 0) {\n    noOfChildren = 1;\n  }\n  return noOfChildren;\n};\n\nLNode.prototype.getEstimatedSize = function () {\n  if (this.estimatedSize == Integer.MIN_VALUE) {\n    throw \"assert failed\";\n  }\n  return this.estimatedSize;\n};\n\nLNode.prototype.calcEstimatedSize = function () {\n  if (this.child == null) {\n    return this.estimatedSize = (this.rect.width + this.rect.height) / 2;\n  } else {\n    this.estimatedSize = this.child.calcEstimatedSize();\n    this.rect.width = this.estimatedSize;\n    this.rect.height = this.estimatedSize;\n\n    return this.estimatedSize;\n  }\n};\n\nLNode.prototype.scatter = function () {\n  var randomCenterX;\n  var randomCenterY;\n\n  var minX = -LayoutConstants.INITIAL_WORLD_BOUNDARY;\n  var maxX = LayoutConstants.INITIAL_WORLD_BOUNDARY;\n  randomCenterX = LayoutConstants.WORLD_CENTER_X + RandomSeed.nextDouble() * (maxX - minX) + minX;\n\n  var minY = -LayoutConstants.INITIAL_WORLD_BOUNDARY;\n  var maxY = LayoutConstants.INITIAL_WORLD_BOUNDARY;\n  randomCenterY = LayoutConstants.WORLD_CENTER_Y + RandomSeed.nextDouble() * (maxY - minY) + minY;\n\n  this.rect.x = randomCenterX;\n  this.rect.y = randomCenterY;\n};\n\nLNode.prototype.updateBounds = function () {\n  if (this.getChild() == null) {\n    throw \"assert failed\";\n  }\n  if (this.getChild().getNodes().length != 0) {\n    // wrap the children nodes by re-arranging the boundaries\n    var childGraph = this.getChild();\n    childGraph.updateBounds(true);\n\n    this.rect.x = childGraph.getLeft();\n    this.rect.y = childGraph.getTop();\n\n    this.setWidth(childGraph.getRight() - childGraph.getLeft());\n    this.setHeight(childGraph.getBottom() - childGraph.getTop());\n\n    // Update compound bounds considering its label properties    \n    if (LayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS) {\n\n      var width = childGraph.getRight() - childGraph.getLeft();\n      var height = childGraph.getBottom() - childGraph.getTop();\n\n      if (this.labelWidth > width) {\n        this.rect.x -= (this.labelWidth - width) / 2;\n        this.setWidth(this.labelWidth);\n      }\n\n      if (this.labelHeight > height) {\n        if (this.labelPos == \"center\") {\n          this.rect.y -= (this.labelHeight - height) / 2;\n        } else if (this.labelPos == \"top\") {\n          this.rect.y -= this.labelHeight - height;\n        }\n        this.setHeight(this.labelHeight);\n      }\n    }\n  }\n};\n\nLNode.prototype.getInclusionTreeDepth = function () {\n  if (this.inclusionTreeDepth == Integer.MAX_VALUE) {\n    throw \"assert failed\";\n  }\n  return this.inclusionTreeDepth;\n};\n\nLNode.prototype.transform = function (trans) {\n  var left = this.rect.x;\n\n  if (left > LayoutConstants.WORLD_BOUNDARY) {\n    left = LayoutConstants.WORLD_BOUNDARY;\n  } else if (left < -LayoutConstants.WORLD_BOUNDARY) {\n    left = -LayoutConstants.WORLD_BOUNDARY;\n  }\n\n  var top = this.rect.y;\n\n  if (top > LayoutConstants.WORLD_BOUNDARY) {\n    top = LayoutConstants.WORLD_BOUNDARY;\n  } else if (top < -LayoutConstants.WORLD_BOUNDARY) {\n    top = -LayoutConstants.WORLD_BOUNDARY;\n  }\n\n  var leftTop = new PointD(left, top);\n  var vLeftTop = trans.inverseTransformPoint(leftTop);\n\n  this.setLocation(vLeftTop.x, vLeftTop.y);\n};\n\nLNode.prototype.getLeft = function () {\n  return this.rect.x;\n};\n\nLNode.prototype.getRight = function () {\n  return this.rect.x + this.rect.width;\n};\n\nLNode.prototype.getTop = function () {\n  return this.rect.y;\n};\n\nLNode.prototype.getBottom = function () {\n  return this.rect.y + this.rect.height;\n};\n\nLNode.prototype.getParent = function () {\n  if (this.owner == null) {\n    return null;\n  }\n\n  return this.owner.getParent();\n};\n\nmodule.exports = LNode;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction PointD(x, y) {\n  if (x == null && y == null) {\n    this.x = 0;\n    this.y = 0;\n  } else {\n    this.x = x;\n    this.y = y;\n  }\n}\n\nPointD.prototype.getX = function () {\n  return this.x;\n};\n\nPointD.prototype.getY = function () {\n  return this.y;\n};\n\nPointD.prototype.setX = function (x) {\n  this.x = x;\n};\n\nPointD.prototype.setY = function (y) {\n  this.y = y;\n};\n\nPointD.prototype.getDifference = function (pt) {\n  return new DimensionD(this.x - pt.x, this.y - pt.y);\n};\n\nPointD.prototype.getCopy = function () {\n  return new PointD(this.x, this.y);\n};\n\nPointD.prototype.translate = function (dim) {\n  this.x += dim.width;\n  this.y += dim.height;\n  return this;\n};\n\nmodule.exports = PointD;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __nested_webpack_require_17549__) {\n\n\"use strict\";\n\n\nvar LGraphObject = __nested_webpack_require_17549__(2);\nvar Integer = __nested_webpack_require_17549__(10);\nvar LayoutConstants = __nested_webpack_require_17549__(0);\nvar LGraphManager = __nested_webpack_require_17549__(6);\nvar LNode = __nested_webpack_require_17549__(3);\nvar LEdge = __nested_webpack_require_17549__(1);\nvar RectangleD = __nested_webpack_require_17549__(13);\nvar Point = __nested_webpack_require_17549__(12);\nvar LinkedList = __nested_webpack_require_17549__(11);\n\nfunction LGraph(parent, obj2, vGraph) {\n  LGraphObject.call(this, vGraph);\n  this.estimatedSize = Integer.MIN_VALUE;\n  this.margin = LayoutConstants.DEFAULT_GRAPH_MARGIN;\n  this.edges = [];\n  this.nodes = [];\n  this.isConnected = false;\n  this.parent = parent;\n\n  if (obj2 != null && obj2 instanceof LGraphManager) {\n    this.graphManager = obj2;\n  } else if (obj2 != null && obj2 instanceof Layout) {\n    this.graphManager = obj2.graphManager;\n  }\n}\n\nLGraph.prototype = Object.create(LGraphObject.prototype);\nfor (var prop in LGraphObject) {\n  LGraph[prop] = LGraphObject[prop];\n}\n\nLGraph.prototype.getNodes = function () {\n  return this.nodes;\n};\n\nLGraph.prototype.getEdges = function () {\n  return this.edges;\n};\n\nLGraph.prototype.getGraphManager = function () {\n  return this.graphManager;\n};\n\nLGraph.prototype.getParent = function () {\n  return this.parent;\n};\n\nLGraph.prototype.getLeft = function () {\n  return this.left;\n};\n\nLGraph.prototype.getRight = function () {\n  return this.right;\n};\n\nLGraph.prototype.getTop = function () {\n  return this.top;\n};\n\nLGraph.prototype.getBottom = function () {\n  return this.bottom;\n};\n\nLGraph.prototype.isConnected = function () {\n  return this.isConnected;\n};\n\nLGraph.prototype.add = function (obj1, sourceNode, targetNode) {\n  if (sourceNode == null && targetNode == null) {\n    var newNode = obj1;\n    if (this.graphManager == null) {\n      throw \"Graph has no graph mgr!\";\n    }\n    if (this.getNodes().indexOf(newNode) > -1) {\n      throw \"Node already in graph!\";\n    }\n    newNode.owner = this;\n    this.getNodes().push(newNode);\n\n    return newNode;\n  } else {\n    var newEdge = obj1;\n    if (!(this.getNodes().indexOf(sourceNode) > -1 && this.getNodes().indexOf(targetNode) > -1)) {\n      throw \"Source or target not in graph!\";\n    }\n\n    if (!(sourceNode.owner == targetNode.owner && sourceNode.owner == this)) {\n      throw \"Both owners must be this graph!\";\n    }\n\n    if (sourceNode.owner != targetNode.owner) {\n      return null;\n    }\n\n    // set source and target\n    newEdge.source = sourceNode;\n    newEdge.target = targetNode;\n\n    // set as intra-graph edge\n    newEdge.isInterGraph = false;\n\n    // add to graph edge list\n    this.getEdges().push(newEdge);\n\n    // add to incidency lists\n    sourceNode.edges.push(newEdge);\n\n    if (targetNode != sourceNode) {\n      targetNode.edges.push(newEdge);\n    }\n\n    return newEdge;\n  }\n};\n\nLGraph.prototype.remove = function (obj) {\n  var node = obj;\n  if (obj instanceof LNode) {\n    if (node == null) {\n      throw \"Node is null!\";\n    }\n    if (!(node.owner != null && node.owner == this)) {\n      throw \"Owner graph is invalid!\";\n    }\n    if (this.graphManager == null) {\n      throw \"Owner graph manager is invalid!\";\n    }\n    // remove incident edges first (make a copy to do it safely)\n    var edgesToBeRemoved = node.edges.slice();\n    var edge;\n    var s = edgesToBeRemoved.length;\n    for (var i = 0; i < s; i++) {\n      edge = edgesToBeRemoved[i];\n\n      if (edge.isInterGraph) {\n        this.graphManager.remove(edge);\n      } else {\n        edge.source.owner.remove(edge);\n      }\n    }\n\n    // now the node itself\n    var index = this.nodes.indexOf(node);\n    if (index == -1) {\n      throw \"Node not in owner node list!\";\n    }\n\n    this.nodes.splice(index, 1);\n  } else if (obj instanceof LEdge) {\n    var edge = obj;\n    if (edge == null) {\n      throw \"Edge is null!\";\n    }\n    if (!(edge.source != null && edge.target != null)) {\n      throw \"Source and/or target is null!\";\n    }\n    if (!(edge.source.owner != null && edge.target.owner != null && edge.source.owner == this && edge.target.owner == this)) {\n      throw \"Source and/or target owner is invalid!\";\n    }\n\n    var sourceIndex = edge.source.edges.indexOf(edge);\n    var targetIndex = edge.target.edges.indexOf(edge);\n    if (!(sourceIndex > -1 && targetIndex > -1)) {\n      throw \"Source and/or target doesn't know this edge!\";\n    }\n\n    edge.source.edges.splice(sourceIndex, 1);\n\n    if (edge.target != edge.source) {\n      edge.target.edges.splice(targetIndex, 1);\n    }\n\n    var index = edge.source.owner.getEdges().indexOf(edge);\n    if (index == -1) {\n      throw \"Not in owner's edge list!\";\n    }\n\n    edge.source.owner.getEdges().splice(index, 1);\n  }\n};\n\nLGraph.prototype.updateLeftTop = function () {\n  var top = Integer.MAX_VALUE;\n  var left = Integer.MAX_VALUE;\n  var nodeTop;\n  var nodeLeft;\n  var margin;\n\n  var nodes = this.getNodes();\n  var s = nodes.length;\n\n  for (var i = 0; i < s; i++) {\n    var lNode = nodes[i];\n    nodeTop = lNode.getTop();\n    nodeLeft = lNode.getLeft();\n\n    if (top > nodeTop) {\n      top = nodeTop;\n    }\n\n    if (left > nodeLeft) {\n      left = nodeLeft;\n    }\n  }\n\n  // Do we have any nodes in this graph?\n  if (top == Integer.MAX_VALUE) {\n    return null;\n  }\n\n  if (nodes[0].getParent().paddingLeft != undefined) {\n    margin = nodes[0].getParent().paddingLeft;\n  } else {\n    margin = this.margin;\n  }\n\n  this.left = left - margin;\n  this.top = top - margin;\n\n  // Apply the margins and return the result\n  return new Point(this.left, this.top);\n};\n\nLGraph.prototype.updateBounds = function (recursive) {\n  // calculate bounds\n  var left = Integer.MAX_VALUE;\n  var right = -Integer.MAX_VALUE;\n  var top = Integer.MAX_VALUE;\n  var bottom = -Integer.MAX_VALUE;\n  var nodeLeft;\n  var nodeRight;\n  var nodeTop;\n  var nodeBottom;\n  var margin;\n\n  var nodes = this.nodes;\n  var s = nodes.length;\n  for (var i = 0; i < s; i++) {\n    var lNode = nodes[i];\n\n    if (recursive && lNode.child != null) {\n      lNode.updateBounds();\n    }\n    nodeLeft = lNode.getLeft();\n    nodeRight = lNode.getRight();\n    nodeTop = lNode.getTop();\n    nodeBottom = lNode.getBottom();\n\n    if (left > nodeLeft) {\n      left = nodeLeft;\n    }\n\n    if (right < nodeRight) {\n      right = nodeRight;\n    }\n\n    if (top > nodeTop) {\n      top = nodeTop;\n    }\n\n    if (bottom < nodeBottom) {\n      bottom = nodeBottom;\n    }\n  }\n\n  var boundingRect = new RectangleD(left, top, right - left, bottom - top);\n  if (left == Integer.MAX_VALUE) {\n    this.left = this.parent.getLeft();\n    this.right = this.parent.getRight();\n    this.top = this.parent.getTop();\n    this.bottom = this.parent.getBottom();\n  }\n\n  if (nodes[0].getParent().paddingLeft != undefined) {\n    margin = nodes[0].getParent().paddingLeft;\n  } else {\n    margin = this.margin;\n  }\n\n  this.left = boundingRect.x - margin;\n  this.right = boundingRect.x + boundingRect.width + margin;\n  this.top = boundingRect.y - margin;\n  this.bottom = boundingRect.y + boundingRect.height + margin;\n};\n\nLGraph.calculateBounds = function (nodes) {\n  var left = Integer.MAX_VALUE;\n  var right = -Integer.MAX_VALUE;\n  var top = Integer.MAX_VALUE;\n  var bottom = -Integer.MAX_VALUE;\n  var nodeLeft;\n  var nodeRight;\n  var nodeTop;\n  var nodeBottom;\n\n  var s = nodes.length;\n\n  for (var i = 0; i < s; i++) {\n    var lNode = nodes[i];\n    nodeLeft = lNode.getLeft();\n    nodeRight = lNode.getRight();\n    nodeTop = lNode.getTop();\n    nodeBottom = lNode.getBottom();\n\n    if (left > nodeLeft) {\n      left = nodeLeft;\n    }\n\n    if (right < nodeRight) {\n      right = nodeRight;\n    }\n\n    if (top > nodeTop) {\n      top = nodeTop;\n    }\n\n    if (bottom < nodeBottom) {\n      bottom = nodeBottom;\n    }\n  }\n\n  var boundingRect = new RectangleD(left, top, right - left, bottom - top);\n\n  return boundingRect;\n};\n\nLGraph.prototype.getInclusionTreeDepth = function () {\n  if (this == this.graphManager.getRoot()) {\n    return 1;\n  } else {\n    return this.parent.getInclusionTreeDepth();\n  }\n};\n\nLGraph.prototype.getEstimatedSize = function () {\n  if (this.estimatedSize == Integer.MIN_VALUE) {\n    throw \"assert failed\";\n  }\n  return this.estimatedSize;\n};\n\nLGraph.prototype.calcEstimatedSize = function () {\n  var size = 0;\n  var nodes = this.nodes;\n  var s = nodes.length;\n\n  for (var i = 0; i < s; i++) {\n    var lNode = nodes[i];\n    size += lNode.calcEstimatedSize();\n  }\n\n  if (size == 0) {\n    this.estimatedSize = LayoutConstants.EMPTY_COMPOUND_NODE_SIZE;\n  } else {\n    this.estimatedSize = size / Math.sqrt(this.nodes.length);\n  }\n\n  return this.estimatedSize;\n};\n\nLGraph.prototype.updateConnected = function () {\n  var self = this;\n  if (this.nodes.length == 0) {\n    this.isConnected = true;\n    return;\n  }\n\n  var queue = new LinkedList();\n  var visited = new Set();\n  var currentNode = this.nodes[0];\n  var neighborEdges;\n  var currentNeighbor;\n  var childrenOfNode = currentNode.withChildren();\n  childrenOfNode.forEach(function (node) {\n    queue.push(node);\n    visited.add(node);\n  });\n\n  while (queue.length !== 0) {\n    currentNode = queue.shift();\n\n    // Traverse all neighbors of this node\n    neighborEdges = currentNode.getEdges();\n    var size = neighborEdges.length;\n    for (var i = 0; i < size; i++) {\n      var neighborEdge = neighborEdges[i];\n      currentNeighbor = neighborEdge.getOtherEndInGraph(currentNode, this);\n\n      // Add unvisited neighbors to the list to visit\n      if (currentNeighbor != null && !visited.has(currentNeighbor)) {\n        var childrenOfNeighbor = currentNeighbor.withChildren();\n\n        childrenOfNeighbor.forEach(function (node) {\n          queue.push(node);\n          visited.add(node);\n        });\n      }\n    }\n  }\n\n  this.isConnected = false;\n\n  if (visited.size >= this.nodes.length) {\n    var noOfVisitedInThisGraph = 0;\n\n    visited.forEach(function (visitedNode) {\n      if (visitedNode.owner == self) {\n        noOfVisitedInThisGraph++;\n      }\n    });\n\n    if (noOfVisitedInThisGraph == this.nodes.length) {\n      this.isConnected = true;\n    }\n  }\n};\n\nmodule.exports = LGraph;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __nested_webpack_require_27617__) {\n\n\"use strict\";\n\n\nvar LGraph;\nvar LEdge = __nested_webpack_require_27617__(1);\n\nfunction LGraphManager(layout) {\n  LGraph = __nested_webpack_require_27617__(5); // It may be better to initilize this out of this function but it gives an error (Right-hand side of 'instanceof' is not callable) now.\n  this.layout = layout;\n\n  this.graphs = [];\n  this.edges = [];\n}\n\nLGraphManager.prototype.addRoot = function () {\n  var ngraph = this.layout.newGraph();\n  var nnode = this.layout.newNode(null);\n  var root = this.add(ngraph, nnode);\n  this.setRootGraph(root);\n  return this.rootGraph;\n};\n\nLGraphManager.prototype.add = function (newGraph, parentNode, newEdge, sourceNode, targetNode) {\n  //there are just 2 parameters are passed then it adds an LGraph else it adds an LEdge\n  if (newEdge == null && sourceNode == null && targetNode == null) {\n    if (newGraph == null) {\n      throw \"Graph is null!\";\n    }\n    if (parentNode == null) {\n      throw \"Parent node is null!\";\n    }\n    if (this.graphs.indexOf(newGraph) > -1) {\n      throw \"Graph already in this graph mgr!\";\n    }\n\n    this.graphs.push(newGraph);\n\n    if (newGraph.parent != null) {\n      throw \"Already has a parent!\";\n    }\n    if (parentNode.child != null) {\n      throw \"Already has a child!\";\n    }\n\n    newGraph.parent = parentNode;\n    parentNode.child = newGraph;\n\n    return newGraph;\n  } else {\n    //change the order of the parameters\n    targetNode = newEdge;\n    sourceNode = parentNode;\n    newEdge = newGraph;\n    var sourceGraph = sourceNode.getOwner();\n    var targetGraph = targetNode.getOwner();\n\n    if (!(sourceGraph != null && sourceGraph.getGraphManager() == this)) {\n      throw \"Source not in this graph mgr!\";\n    }\n    if (!(targetGraph != null && targetGraph.getGraphManager() == this)) {\n      throw \"Target not in this graph mgr!\";\n    }\n\n    if (sourceGraph == targetGraph) {\n      newEdge.isInterGraph = false;\n      return sourceGraph.add(newEdge, sourceNode, targetNode);\n    } else {\n      newEdge.isInterGraph = true;\n\n      // set source and target\n      newEdge.source = sourceNode;\n      newEdge.target = targetNode;\n\n      // add edge to inter-graph edge list\n      if (this.edges.indexOf(newEdge) > -1) {\n        throw \"Edge already in inter-graph edge list!\";\n      }\n\n      this.edges.push(newEdge);\n\n      // add edge to source and target incidency lists\n      if (!(newEdge.source != null && newEdge.target != null)) {\n        throw \"Edge source and/or target is null!\";\n      }\n\n      if (!(newEdge.source.edges.indexOf(newEdge) == -1 && newEdge.target.edges.indexOf(newEdge) == -1)) {\n        throw \"Edge already in source and/or target incidency list!\";\n      }\n\n      newEdge.source.edges.push(newEdge);\n      newEdge.target.edges.push(newEdge);\n\n      return newEdge;\n    }\n  }\n};\n\nLGraphManager.prototype.remove = function (lObj) {\n  if (lObj instanceof LGraph) {\n    var graph = lObj;\n    if (graph.getGraphManager() != this) {\n      throw \"Graph not in this graph mgr\";\n    }\n    if (!(graph == this.rootGraph || graph.parent != null && graph.parent.graphManager == this)) {\n      throw \"Invalid parent node!\";\n    }\n\n    // first the edges (make a copy to do it safely)\n    var edgesToBeRemoved = [];\n\n    edgesToBeRemoved = edgesToBeRemoved.concat(graph.getEdges());\n\n    var edge;\n    var s = edgesToBeRemoved.length;\n    for (var i = 0; i < s; i++) {\n      edge = edgesToBeRemoved[i];\n      graph.remove(edge);\n    }\n\n    // then the nodes (make a copy to do it safely)\n    var nodesToBeRemoved = [];\n\n    nodesToBeRemoved = nodesToBeRemoved.concat(graph.getNodes());\n\n    var node;\n    s = nodesToBeRemoved.length;\n    for (var i = 0; i < s; i++) {\n      node = nodesToBeRemoved[i];\n      graph.remove(node);\n    }\n\n    // check if graph is the root\n    if (graph == this.rootGraph) {\n      this.setRootGraph(null);\n    }\n\n    // now remove the graph itself\n    var index = this.graphs.indexOf(graph);\n    this.graphs.splice(index, 1);\n\n    // also reset the parent of the graph\n    graph.parent = null;\n  } else if (lObj instanceof LEdge) {\n    edge = lObj;\n    if (edge == null) {\n      throw \"Edge is null!\";\n    }\n    if (!edge.isInterGraph) {\n      throw \"Not an inter-graph edge!\";\n    }\n    if (!(edge.source != null && edge.target != null)) {\n      throw \"Source and/or target is null!\";\n    }\n\n    // remove edge from source and target nodes' incidency lists\n\n    if (!(edge.source.edges.indexOf(edge) != -1 && edge.target.edges.indexOf(edge) != -1)) {\n      throw \"Source and/or target doesn't know this edge!\";\n    }\n\n    var index = edge.source.edges.indexOf(edge);\n    edge.source.edges.splice(index, 1);\n    index = edge.target.edges.indexOf(edge);\n    edge.target.edges.splice(index, 1);\n\n    // remove edge from owner graph manager's inter-graph edge list\n\n    if (!(edge.source.owner != null && edge.source.owner.getGraphManager() != null)) {\n      throw \"Edge owner graph or owner graph manager is null!\";\n    }\n    if (edge.source.owner.getGraphManager().edges.indexOf(edge) == -1) {\n      throw \"Not in owner graph manager's edge list!\";\n    }\n\n    var index = edge.source.owner.getGraphManager().edges.indexOf(edge);\n    edge.source.owner.getGraphManager().edges.splice(index, 1);\n  }\n};\n\nLGraphManager.prototype.updateBounds = function () {\n  this.rootGraph.updateBounds(true);\n};\n\nLGraphManager.prototype.getGraphs = function () {\n  return this.graphs;\n};\n\nLGraphManager.prototype.getAllNodes = function () {\n  if (this.allNodes == null) {\n    var nodeList = [];\n    var graphs = this.getGraphs();\n    var s = graphs.length;\n    for (var i = 0; i < s; i++) {\n      nodeList = nodeList.concat(graphs[i].getNodes());\n    }\n    this.allNodes = nodeList;\n  }\n  return this.allNodes;\n};\n\nLGraphManager.prototype.resetAllNodes = function () {\n  this.allNodes = null;\n};\n\nLGraphManager.prototype.resetAllEdges = function () {\n  this.allEdges = null;\n};\n\nLGraphManager.prototype.resetAllNodesToApplyGravitation = function () {\n  this.allNodesToApplyGravitation = null;\n};\n\nLGraphManager.prototype.getAllEdges = function () {\n  if (this.allEdges == null) {\n    var edgeList = [];\n    var graphs = this.getGraphs();\n    var s = graphs.length;\n    for (var i = 0; i < graphs.length; i++) {\n      edgeList = edgeList.concat(graphs[i].getEdges());\n    }\n\n    edgeList = edgeList.concat(this.edges);\n\n    this.allEdges = edgeList;\n  }\n  return this.allEdges;\n};\n\nLGraphManager.prototype.getAllNodesToApplyGravitation = function () {\n  return this.allNodesToApplyGravitation;\n};\n\nLGraphManager.prototype.setAllNodesToApplyGravitation = function (nodeList) {\n  if (this.allNodesToApplyGravitation != null) {\n    throw \"assert failed\";\n  }\n\n  this.allNodesToApplyGravitation = nodeList;\n};\n\nLGraphManager.prototype.getRoot = function () {\n  return this.rootGraph;\n};\n\nLGraphManager.prototype.setRootGraph = function (graph) {\n  if (graph.getGraphManager() != this) {\n    throw \"Root not in this graph mgr!\";\n  }\n\n  this.rootGraph = graph;\n  // root graph must have a root node associated with it for convenience\n  if (graph.parent == null) {\n    graph.parent = this.layout.newNode(\"Root node\");\n  }\n};\n\nLGraphManager.prototype.getLayout = function () {\n  return this.layout;\n};\n\nLGraphManager.prototype.isOneAncestorOfOther = function (firstNode, secondNode) {\n  if (!(firstNode != null && secondNode != null)) {\n    throw \"assert failed\";\n  }\n\n  if (firstNode == secondNode) {\n    return true;\n  }\n  // Is second node an ancestor of the first one?\n  var ownerGraph = firstNode.getOwner();\n  var parentNode;\n\n  do {\n    parentNode = ownerGraph.getParent();\n\n    if (parentNode == null) {\n      break;\n    }\n\n    if (parentNode == secondNode) {\n      return true;\n    }\n\n    ownerGraph = parentNode.getOwner();\n    if (ownerGraph == null) {\n      break;\n    }\n  } while (true);\n  // Is first node an ancestor of the second one?\n  ownerGraph = secondNode.getOwner();\n\n  do {\n    parentNode = ownerGraph.getParent();\n\n    if (parentNode == null) {\n      break;\n    }\n\n    if (parentNode == firstNode) {\n      return true;\n    }\n\n    ownerGraph = parentNode.getOwner();\n    if (ownerGraph == null) {\n      break;\n    }\n  } while (true);\n\n  return false;\n};\n\nLGraphManager.prototype.calcLowestCommonAncestors = function () {\n  var edge;\n  var sourceNode;\n  var targetNode;\n  var sourceAncestorGraph;\n  var targetAncestorGraph;\n\n  var edges = this.getAllEdges();\n  var s = edges.length;\n  for (var i = 0; i < s; i++) {\n    edge = edges[i];\n\n    sourceNode = edge.source;\n    targetNode = edge.target;\n    edge.lca = null;\n    edge.sourceInLca = sourceNode;\n    edge.targetInLca = targetNode;\n\n    if (sourceNode == targetNode) {\n      edge.lca = sourceNode.getOwner();\n      continue;\n    }\n\n    sourceAncestorGraph = sourceNode.getOwner();\n\n    while (edge.lca == null) {\n      edge.targetInLca = targetNode;\n      targetAncestorGraph = targetNode.getOwner();\n\n      while (edge.lca == null) {\n        if (targetAncestorGraph == sourceAncestorGraph) {\n          edge.lca = targetAncestorGraph;\n          break;\n        }\n\n        if (targetAncestorGraph == this.rootGraph) {\n          break;\n        }\n\n        if (edge.lca != null) {\n          throw \"assert failed\";\n        }\n        edge.targetInLca = targetAncestorGraph.getParent();\n        targetAncestorGraph = edge.targetInLca.getOwner();\n      }\n\n      if (sourceAncestorGraph == this.rootGraph) {\n        break;\n      }\n\n      if (edge.lca == null) {\n        edge.sourceInLca = sourceAncestorGraph.getParent();\n        sourceAncestorGraph = edge.sourceInLca.getOwner();\n      }\n    }\n\n    if (edge.lca == null) {\n      throw \"assert failed\";\n    }\n  }\n};\n\nLGraphManager.prototype.calcLowestCommonAncestor = function (firstNode, secondNode) {\n  if (firstNode == secondNode) {\n    return firstNode.getOwner();\n  }\n  var firstOwnerGraph = firstNode.getOwner();\n\n  do {\n    if (firstOwnerGraph == null) {\n      break;\n    }\n    var secondOwnerGraph = secondNode.getOwner();\n\n    do {\n      if (secondOwnerGraph == null) {\n        break;\n      }\n\n      if (secondOwnerGraph == firstOwnerGraph) {\n        return secondOwnerGraph;\n      }\n      secondOwnerGraph = secondOwnerGraph.getParent().getOwner();\n    } while (true);\n\n    firstOwnerGraph = firstOwnerGraph.getParent().getOwner();\n  } while (true);\n\n  return firstOwnerGraph;\n};\n\nLGraphManager.prototype.calcInclusionTreeDepths = function (graph, depth) {\n  if (graph == null && depth == null) {\n    graph = this.rootGraph;\n    depth = 1;\n  }\n  var node;\n\n  var nodes = graph.getNodes();\n  var s = nodes.length;\n  for (var i = 0; i < s; i++) {\n    node = nodes[i];\n    node.inclusionTreeDepth = depth;\n\n    if (node.child != null) {\n      this.calcInclusionTreeDepths(node.child, depth + 1);\n    }\n  }\n};\n\nLGraphManager.prototype.includesInvalidEdge = function () {\n  var edge;\n\n  var s = this.edges.length;\n  for (var i = 0; i < s; i++) {\n    edge = this.edges[i];\n\n    if (this.isOneAncestorOfOther(edge.source, edge.target)) {\n      return true;\n    }\n  }\n  return false;\n};\n\nmodule.exports = LGraphManager;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __nested_webpack_require_38707__) {\n\n\"use strict\";\n\n\nvar LayoutConstants = __nested_webpack_require_38707__(0);\n\nfunction FDLayoutConstants() {}\n\n//FDLayoutConstants inherits static props in LayoutConstants\nfor (var prop in LayoutConstants) {\n  FDLayoutConstants[prop] = LayoutConstants[prop];\n}\n\nFDLayoutConstants.MAX_ITERATIONS = 2500;\n\nFDLayoutConstants.DEFAULT_EDGE_LENGTH = 50;\nFDLayoutConstants.DEFAULT_SPRING_STRENGTH = 0.45;\nFDLayoutConstants.DEFAULT_REPULSION_STRENGTH = 4500.0;\nFDLayoutConstants.DEFAULT_GRAVITY_STRENGTH = 0.4;\nFDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = 1.0;\nFDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR = 3.8;\nFDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = 1.5;\nFDLayoutConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION = true;\nFDLayoutConstants.DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION = true;\nFDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = 0.3;\nFDLayoutConstants.COOLING_ADAPTATION_FACTOR = 0.33;\nFDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT = 1000;\nFDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT = 5000;\nFDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL = 100.0;\nFDLayoutConstants.MAX_NODE_DISPLACEMENT = FDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL * 3;\nFDLayoutConstants.MIN_REPULSION_DIST = FDLayoutConstants.DEFAULT_EDGE_LENGTH / 10.0;\nFDLayoutConstants.CONVERGENCE_CHECK_PERIOD = 100;\nFDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = 0.1;\nFDLayoutConstants.MIN_EDGE_LENGTH = 1;\nFDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD = 10;\n\nmodule.exports = FDLayoutConstants;\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __nested_webpack_require_40298__) {\n\n\"use strict\";\n\n\n/**\n * This class maintains a list of static geometry related utility methods.\n *\n *\n * Copyright: i-Vis Research Group, Bilkent University, 2007 - present\n */\n\nvar Point = __nested_webpack_require_40298__(12);\n\nfunction IGeometry() {}\n\n/**\n * This method calculates *half* the amount in x and y directions of the two\n * input rectangles needed to separate them keeping their respective\n * positioning, and returns the result in the input array. An input\n * separation buffer added to the amount in both directions. We assume that\n * the two rectangles do intersect.\n */\nIGeometry.calcSeparationAmount = function (rectA, rectB, overlapAmount, separationBuffer) {\n  if (!rectA.intersects(rectB)) {\n    throw \"assert failed\";\n  }\n\n  var directions = new Array(2);\n\n  this.decideDirectionsForOverlappingNodes(rectA, rectB, directions);\n\n  overlapAmount[0] = Math.min(rectA.getRight(), rectB.getRight()) - Math.max(rectA.x, rectB.x);\n  overlapAmount[1] = Math.min(rectA.getBottom(), rectB.getBottom()) - Math.max(rectA.y, rectB.y);\n\n  // update the overlapping amounts for the following cases:\n  if (rectA.getX() <= rectB.getX() && rectA.getRight() >= rectB.getRight()) {\n    /* Case x.1:\n    *\n    * rectA\n    * \t|                       |\n    * \t|        _________      |\n    * \t|        |       |      |\n    * \t|________|_______|______|\n    * \t\t\t |       |\n    *           |       |\n    *        rectB\n    */\n    overlapAmount[0] += Math.min(rectB.getX() - rectA.getX(), rectA.getRight() - rectB.getRight());\n  } else if (rectB.getX() <= rectA.getX() && rectB.getRight() >= rectA.getRight()) {\n    /* Case x.2:\n    *\n    * rectB\n    * \t|                       |\n    * \t|        _________      |\n    * \t|        |       |      |\n    * \t|________|_______|______|\n    * \t\t\t |       |\n    *           |       |\n    *        rectA\n    */\n    overlapAmount[0] += Math.min(rectA.getX() - rectB.getX(), rectB.getRight() - rectA.getRight());\n  }\n  if (rectA.getY() <= rectB.getY() && rectA.getBottom() >= rectB.getBottom()) {\n    /* Case y.1:\n     *          ________ rectA\n     *         |\n     *         |\n     *   ______|____  rectB\n     *         |    |\n     *         |    |\n     *   ______|____|\n     *         |\n     *         |\n     *         |________\n     *\n     */\n    overlapAmount[1] += Math.min(rectB.getY() - rectA.getY(), rectA.getBottom() - rectB.getBottom());\n  } else if (rectB.getY() <= rectA.getY() && rectB.getBottom() >= rectA.getBottom()) {\n    /* Case y.2:\n    *          ________ rectB\n    *         |\n    *         |\n    *   ______|____  rectA\n    *         |    |\n    *         |    |\n    *   ______|____|\n    *         |\n    *         |\n    *         |________\n    *\n    */\n    overlapAmount[1] += Math.min(rectA.getY() - rectB.getY(), rectB.getBottom() - rectA.getBottom());\n  }\n\n  // find slope of the line passes two centers\n  var slope = Math.abs((rectB.getCenterY() - rectA.getCenterY()) / (rectB.getCenterX() - rectA.getCenterX()));\n  // if centers are overlapped\n  if (rectB.getCenterY() === rectA.getCenterY() && rectB.getCenterX() === rectA.getCenterX()) {\n    // assume the slope is 1 (45 degree)\n    slope = 1.0;\n  }\n\n  var moveByY = slope * overlapAmount[0];\n  var moveByX = overlapAmount[1] / slope;\n  if (overlapAmount[0] < moveByX) {\n    moveByX = overlapAmount[0];\n  } else {\n    moveByY = overlapAmount[1];\n  }\n  // return half the amount so that if each rectangle is moved by these\n  // amounts in opposite directions, overlap will be resolved\n  overlapAmount[0] = -1 * directions[0] * (moveByX / 2 + separationBuffer);\n  overlapAmount[1] = -1 * directions[1] * (moveByY / 2 + separationBuffer);\n};\n\n/**\n * This method decides the separation direction of overlapping nodes\n *\n * if directions[0] = -1, then rectA goes left\n * if directions[0] = 1,  then rectA goes right\n * if directions[1] = -1, then rectA goes up\n * if directions[1] = 1,  then rectA goes down\n */\nIGeometry.decideDirectionsForOverlappingNodes = function (rectA, rectB, directions) {\n  if (rectA.getCenterX() < rectB.getCenterX()) {\n    directions[0] = -1;\n  } else {\n    directions[0] = 1;\n  }\n\n  if (rectA.getCenterY() < rectB.getCenterY()) {\n    directions[1] = -1;\n  } else {\n    directions[1] = 1;\n  }\n};\n\n/**\n * This method calculates the intersection (clipping) points of the two\n * input rectangles with line segment defined by the centers of these two\n * rectangles. The clipping points are saved in the input double array and\n * whether or not the two rectangles overlap is returned.\n */\nIGeometry.getIntersection2 = function (rectA, rectB, result) {\n  //result[0-1] will contain clipPoint of rectA, result[2-3] will contain clipPoint of rectB\n  var p1x = rectA.getCenterX();\n  var p1y = rectA.getCenterY();\n  var p2x = rectB.getCenterX();\n  var p2y = rectB.getCenterY();\n\n  //if two rectangles intersect, then clipping points are centers\n  if (rectA.intersects(rectB)) {\n    result[0] = p1x;\n    result[1] = p1y;\n    result[2] = p2x;\n    result[3] = p2y;\n    return true;\n  }\n  //variables for rectA\n  var topLeftAx = rectA.getX();\n  var topLeftAy = rectA.getY();\n  var topRightAx = rectA.getRight();\n  var bottomLeftAx = rectA.getX();\n  var bottomLeftAy = rectA.getBottom();\n  var bottomRightAx = rectA.getRight();\n  var halfWidthA = rectA.getWidthHalf();\n  var halfHeightA = rectA.getHeightHalf();\n  //variables for rectB\n  var topLeftBx = rectB.getX();\n  var topLeftBy = rectB.getY();\n  var topRightBx = rectB.getRight();\n  var bottomLeftBx = rectB.getX();\n  var bottomLeftBy = rectB.getBottom();\n  var bottomRightBx = rectB.getRight();\n  var halfWidthB = rectB.getWidthHalf();\n  var halfHeightB = rectB.getHeightHalf();\n\n  //flag whether clipping points are found\n  var clipPointAFound = false;\n  var clipPointBFound = false;\n\n  // line is vertical\n  if (p1x === p2x) {\n    if (p1y > p2y) {\n      result[0] = p1x;\n      result[1] = topLeftAy;\n      result[2] = p2x;\n      result[3] = bottomLeftBy;\n      return false;\n    } else if (p1y < p2y) {\n      result[0] = p1x;\n      result[1] = bottomLeftAy;\n      result[2] = p2x;\n      result[3] = topLeftBy;\n      return false;\n    } else {\n      //not line, return null;\n    }\n  }\n  // line is horizontal\n  else if (p1y === p2y) {\n      if (p1x > p2x) {\n        result[0] = topLeftAx;\n        result[1] = p1y;\n        result[2] = topRightBx;\n        result[3] = p2y;\n        return false;\n      } else if (p1x < p2x) {\n        result[0] = topRightAx;\n        result[1] = p1y;\n        result[2] = topLeftBx;\n        result[3] = p2y;\n        return false;\n      } else {\n        //not valid line, return null;\n      }\n    } else {\n      //slopes of rectA's and rectB's diagonals\n      var slopeA = rectA.height / rectA.width;\n      var slopeB = rectB.height / rectB.width;\n\n      //slope of line between center of rectA and center of rectB\n      var slopePrime = (p2y - p1y) / (p2x - p1x);\n      var cardinalDirectionA = void 0;\n      var cardinalDirectionB = void 0;\n      var tempPointAx = void 0;\n      var tempPointAy = void 0;\n      var tempPointBx = void 0;\n      var tempPointBy = void 0;\n\n      //determine whether clipping point is the corner of nodeA\n      if (-slopeA === slopePrime) {\n        if (p1x > p2x) {\n          result[0] = bottomLeftAx;\n          result[1] = bottomLeftAy;\n          clipPointAFound = true;\n        } else {\n          result[0] = topRightAx;\n          result[1] = topLeftAy;\n          clipPointAFound = true;\n        }\n      } else if (slopeA === slopePrime) {\n        if (p1x > p2x) {\n          result[0] = topLeftAx;\n          result[1] = topLeftAy;\n          clipPointAFound = true;\n        } else {\n          result[0] = bottomRightAx;\n          result[1] = bottomLeftAy;\n          clipPointAFound = true;\n        }\n      }\n\n      //determine whether clipping point is the corner of nodeB\n      if (-slopeB === slopePrime) {\n        if (p2x > p1x) {\n          result[2] = bottomLeftBx;\n          result[3] = bottomLeftBy;\n          clipPointBFound = true;\n        } else {\n          result[2] = topRightBx;\n          result[3] = topLeftBy;\n          clipPointBFound = true;\n        }\n      } else if (slopeB === slopePrime) {\n        if (p2x > p1x) {\n          result[2] = topLeftBx;\n          result[3] = topLeftBy;\n          clipPointBFound = true;\n        } else {\n          result[2] = bottomRightBx;\n          result[3] = bottomLeftBy;\n          clipPointBFound = true;\n        }\n      }\n\n      //if both clipping points are corners\n      if (clipPointAFound && clipPointBFound) {\n        return false;\n      }\n\n      //determine Cardinal Direction of rectangles\n      if (p1x > p2x) {\n        if (p1y > p2y) {\n          cardinalDirectionA = this.getCardinalDirection(slopeA, slopePrime, 4);\n          cardinalDirectionB = this.getCardinalDirection(slopeB, slopePrime, 2);\n        } else {\n          cardinalDirectionA = this.getCardinalDirection(-slopeA, slopePrime, 3);\n          cardinalDirectionB = this.getCardinalDirection(-slopeB, slopePrime, 1);\n        }\n      } else {\n        if (p1y > p2y) {\n          cardinalDirectionA = this.getCardinalDirection(-slopeA, slopePrime, 1);\n          cardinalDirectionB = this.getCardinalDirection(-slopeB, slopePrime, 3);\n        } else {\n          cardinalDirectionA = this.getCardinalDirection(slopeA, slopePrime, 2);\n          cardinalDirectionB = this.getCardinalDirection(slopeB, slopePrime, 4);\n        }\n      }\n      //calculate clipping Point if it is not found before\n      if (!clipPointAFound) {\n        switch (cardinalDirectionA) {\n          case 1:\n            tempPointAy = topLeftAy;\n            tempPointAx = p1x + -halfHeightA / slopePrime;\n            result[0] = tempPointAx;\n            result[1] = tempPointAy;\n            break;\n          case 2:\n            tempPointAx = bottomRightAx;\n            tempPointAy = p1y + halfWidthA * slopePrime;\n            result[0] = tempPointAx;\n            result[1] = tempPointAy;\n            break;\n          case 3:\n            tempPointAy = bottomLeftAy;\n            tempPointAx = p1x + halfHeightA / slopePrime;\n            result[0] = tempPointAx;\n            result[1] = tempPointAy;\n            break;\n          case 4:\n            tempPointAx = bottomLeftAx;\n            tempPointAy = p1y + -halfWidthA * slopePrime;\n            result[0] = tempPointAx;\n            result[1] = tempPointAy;\n            break;\n        }\n      }\n      if (!clipPointBFound) {\n        switch (cardinalDirectionB) {\n          case 1:\n            tempPointBy = topLeftBy;\n            tempPointBx = p2x + -halfHeightB / slopePrime;\n            result[2] = tempPointBx;\n            result[3] = tempPointBy;\n            break;\n          case 2:\n            tempPointBx = bottomRightBx;\n            tempPointBy = p2y + halfWidthB * slopePrime;\n            result[2] = tempPointBx;\n            result[3] = tempPointBy;\n            break;\n          case 3:\n            tempPointBy = bottomLeftBy;\n            tempPointBx = p2x + halfHeightB / slopePrime;\n            result[2] = tempPointBx;\n            result[3] = tempPointBy;\n            break;\n          case 4:\n            tempPointBx = bottomLeftBx;\n            tempPointBy = p2y + -halfWidthB * slopePrime;\n            result[2] = tempPointBx;\n            result[3] = tempPointBy;\n            break;\n        }\n      }\n    }\n  return false;\n};\n\n/**\n * This method returns in which cardinal direction does input point stays\n * 1: North\n * 2: East\n * 3: South\n * 4: West\n */\nIGeometry.getCardinalDirection = function (slope, slopePrime, line) {\n  if (slope > slopePrime) {\n    return line;\n  } else {\n    return 1 + line % 4;\n  }\n};\n\n/**\n * This method calculates the intersection of the two lines defined by\n * point pairs (s1,s2) and (f1,f2).\n */\nIGeometry.getIntersection = function (s1, s2, f1, f2) {\n  if (f2 == null) {\n    return this.getIntersection2(s1, s2, f1);\n  }\n\n  var x1 = s1.x;\n  var y1 = s1.y;\n  var x2 = s2.x;\n  var y2 = s2.y;\n  var x3 = f1.x;\n  var y3 = f1.y;\n  var x4 = f2.x;\n  var y4 = f2.y;\n  var x = void 0,\n      y = void 0; // intersection point\n  var a1 = void 0,\n      a2 = void 0,\n      b1 = void 0,\n      b2 = void 0,\n      c1 = void 0,\n      c2 = void 0; // coefficients of line eqns.\n  var denom = void 0;\n\n  a1 = y2 - y1;\n  b1 = x1 - x2;\n  c1 = x2 * y1 - x1 * y2; // { a1*x + b1*y + c1 = 0 is line 1 }\n\n  a2 = y4 - y3;\n  b2 = x3 - x4;\n  c2 = x4 * y3 - x3 * y4; // { a2*x + b2*y + c2 = 0 is line 2 }\n\n  denom = a1 * b2 - a2 * b1;\n\n  if (denom === 0) {\n    return null;\n  }\n\n  x = (b1 * c2 - b2 * c1) / denom;\n  y = (a2 * c1 - a1 * c2) / denom;\n\n  return new Point(x, y);\n};\n\n/**\n * This method finds and returns the angle of the vector from the + x-axis\n * in clockwise direction (compatible w/ Java coordinate system!).\n */\nIGeometry.angleOfVector = function (Cx, Cy, Nx, Ny) {\n  var C_angle = void 0;\n\n  if (Cx !== Nx) {\n    C_angle = Math.atan((Ny - Cy) / (Nx - Cx));\n\n    if (Nx < Cx) {\n      C_angle += Math.PI;\n    } else if (Ny < Cy) {\n      C_angle += this.TWO_PI;\n    }\n  } else if (Ny < Cy) {\n    C_angle = this.ONE_AND_HALF_PI; // 270 degrees\n  } else {\n    C_angle = this.HALF_PI; // 90 degrees\n  }\n\n  return C_angle;\n};\n\n/**\n * This method checks whether the given two line segments (one with point\n * p1 and p2, the other with point p3 and p4) intersect at a point other\n * than these points.\n */\nIGeometry.doIntersect = function (p1, p2, p3, p4) {\n  var a = p1.x;\n  var b = p1.y;\n  var c = p2.x;\n  var d = p2.y;\n  var p = p3.x;\n  var q = p3.y;\n  var r = p4.x;\n  var s = p4.y;\n  var det = (c - a) * (s - q) - (r - p) * (d - b);\n\n  if (det === 0) {\n    return false;\n  } else {\n    var lambda = ((s - q) * (r - a) + (p - r) * (s - b)) / det;\n    var gamma = ((b - d) * (r - a) + (c - a) * (s - b)) / det;\n    return 0 < lambda && lambda < 1 && 0 < gamma && gamma < 1;\n  }\n};\n\n// -----------------------------------------------------------------------------\n// Section: Class Constants\n// -----------------------------------------------------------------------------\n/**\n * Some useful pre-calculated constants\n */\nIGeometry.HALF_PI = 0.5 * Math.PI;\nIGeometry.ONE_AND_HALF_PI = 1.5 * Math.PI;\nIGeometry.TWO_PI = 2.0 * Math.PI;\nIGeometry.THREE_PI = 3.0 * Math.PI;\n\nmodule.exports = IGeometry;\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction IMath() {}\n\n/**\n * This method returns the sign of the input value.\n */\nIMath.sign = function (value) {\n  if (value > 0) {\n    return 1;\n  } else if (value < 0) {\n    return -1;\n  } else {\n    return 0;\n  }\n};\n\nIMath.floor = function (value) {\n  return value < 0 ? Math.ceil(value) : Math.floor(value);\n};\n\nIMath.ceil = function (value) {\n  return value < 0 ? Math.floor(value) : Math.ceil(value);\n};\n\nmodule.exports = IMath;\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction Integer() {}\n\nInteger.MAX_VALUE = 2147483647;\nInteger.MIN_VALUE = -2147483648;\n\nmodule.exports = Integer;\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar nodeFrom = function nodeFrom(value) {\n  return { value: value, next: null, prev: null };\n};\n\nvar add = function add(prev, node, next, list) {\n  if (prev !== null) {\n    prev.next = node;\n  } else {\n    list.head = node;\n  }\n\n  if (next !== null) {\n    next.prev = node;\n  } else {\n    list.tail = node;\n  }\n\n  node.prev = prev;\n  node.next = next;\n\n  list.length++;\n\n  return node;\n};\n\nvar _remove = function _remove(node, list) {\n  var prev = node.prev,\n      next = node.next;\n\n\n  if (prev !== null) {\n    prev.next = next;\n  } else {\n    list.head = next;\n  }\n\n  if (next !== null) {\n    next.prev = prev;\n  } else {\n    list.tail = prev;\n  }\n\n  node.prev = node.next = null;\n\n  list.length--;\n\n  return node;\n};\n\nvar LinkedList = function () {\n  function LinkedList(vals) {\n    var _this = this;\n\n    _classCallCheck(this, LinkedList);\n\n    this.length = 0;\n    this.head = null;\n    this.tail = null;\n\n    if (vals != null) {\n      vals.forEach(function (v) {\n        return _this.push(v);\n      });\n    }\n  }\n\n  _createClass(LinkedList, [{\n    key: \"size\",\n    value: function size() {\n      return this.length;\n    }\n  }, {\n    key: \"insertBefore\",\n    value: function insertBefore(val, otherNode) {\n      return add(otherNode.prev, nodeFrom(val), otherNode, this);\n    }\n  }, {\n    key: \"insertAfter\",\n    value: function insertAfter(val, otherNode) {\n      return add(otherNode, nodeFrom(val), otherNode.next, this);\n    }\n  }, {\n    key: \"insertNodeBefore\",\n    value: function insertNodeBefore(newNode, otherNode) {\n      return add(otherNode.prev, newNode, otherNode, this);\n    }\n  }, {\n    key: \"insertNodeAfter\",\n    value: function insertNodeAfter(newNode, otherNode) {\n      return add(otherNode, newNode, otherNode.next, this);\n    }\n  }, {\n    key: \"push\",\n    value: function push(val) {\n      return add(this.tail, nodeFrom(val), null, this);\n    }\n  }, {\n    key: \"unshift\",\n    value: function unshift(val) {\n      return add(null, nodeFrom(val), this.head, this);\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(node) {\n      return _remove(node, this);\n    }\n  }, {\n    key: \"pop\",\n    value: function pop() {\n      return _remove(this.tail, this).value;\n    }\n  }, {\n    key: \"popNode\",\n    value: function popNode() {\n      return _remove(this.tail, this);\n    }\n  }, {\n    key: \"shift\",\n    value: function shift() {\n      return _remove(this.head, this).value;\n    }\n  }, {\n    key: \"shiftNode\",\n    value: function shiftNode() {\n      return _remove(this.head, this);\n    }\n  }, {\n    key: \"get_object_at\",\n    value: function get_object_at(index) {\n      if (index <= this.length()) {\n        var i = 1;\n        var current = this.head;\n        while (i < index) {\n          current = current.next;\n          i++;\n        }\n        return current.value;\n      }\n    }\n  }, {\n    key: \"set_object_at\",\n    value: function set_object_at(index, value) {\n      if (index <= this.length()) {\n        var i = 1;\n        var current = this.head;\n        while (i < index) {\n          current = current.next;\n          i++;\n        }\n        current.value = value;\n      }\n    }\n  }]);\n\n  return LinkedList;\n}();\n\nmodule.exports = LinkedList;\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/*\r\n *This class is the javascript implementation of the Point.java class in jdk\r\n */\nfunction Point(x, y, p) {\n  this.x = null;\n  this.y = null;\n  if (x == null && y == null && p == null) {\n    this.x = 0;\n    this.y = 0;\n  } else if (typeof x == 'number' && typeof y == 'number' && p == null) {\n    this.x = x;\n    this.y = y;\n  } else if (x.constructor.name == 'Point' && y == null && p == null) {\n    p = x;\n    this.x = p.x;\n    this.y = p.y;\n  }\n}\n\nPoint.prototype.getX = function () {\n  return this.x;\n};\n\nPoint.prototype.getY = function () {\n  return this.y;\n};\n\nPoint.prototype.getLocation = function () {\n  return new Point(this.x, this.y);\n};\n\nPoint.prototype.setLocation = function (x, y, p) {\n  if (x.constructor.name == 'Point' && y == null && p == null) {\n    p = x;\n    this.setLocation(p.x, p.y);\n  } else if (typeof x == 'number' && typeof y == 'number' && p == null) {\n    //if both parameters are integer just move (x,y) location\n    if (parseInt(x) == x && parseInt(y) == y) {\n      this.move(x, y);\n    } else {\n      this.x = Math.floor(x + 0.5);\n      this.y = Math.floor(y + 0.5);\n    }\n  }\n};\n\nPoint.prototype.move = function (x, y) {\n  this.x = x;\n  this.y = y;\n};\n\nPoint.prototype.translate = function (dx, dy) {\n  this.x += dx;\n  this.y += dy;\n};\n\nPoint.prototype.equals = function (obj) {\n  if (obj.constructor.name == \"Point\") {\n    var pt = obj;\n    return this.x == pt.x && this.y == pt.y;\n  }\n  return this == obj;\n};\n\nPoint.prototype.toString = function () {\n  return new Point().constructor.name + \"[x=\" + this.x + \",y=\" + this.y + \"]\";\n};\n\nmodule.exports = Point;\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction RectangleD(x, y, width, height) {\n  this.x = 0;\n  this.y = 0;\n  this.width = 0;\n  this.height = 0;\n\n  if (x != null && y != null && width != null && height != null) {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n  }\n}\n\nRectangleD.prototype.getX = function () {\n  return this.x;\n};\n\nRectangleD.prototype.setX = function (x) {\n  this.x = x;\n};\n\nRectangleD.prototype.getY = function () {\n  return this.y;\n};\n\nRectangleD.prototype.setY = function (y) {\n  this.y = y;\n};\n\nRectangleD.prototype.getWidth = function () {\n  return this.width;\n};\n\nRectangleD.prototype.setWidth = function (width) {\n  this.width = width;\n};\n\nRectangleD.prototype.getHeight = function () {\n  return this.height;\n};\n\nRectangleD.prototype.setHeight = function (height) {\n  this.height = height;\n};\n\nRectangleD.prototype.getRight = function () {\n  return this.x + this.width;\n};\n\nRectangleD.prototype.getBottom = function () {\n  return this.y + this.height;\n};\n\nRectangleD.prototype.intersects = function (a) {\n  if (this.getRight() < a.x) {\n    return false;\n  }\n\n  if (this.getBottom() < a.y) {\n    return false;\n  }\n\n  if (a.getRight() < this.x) {\n    return false;\n  }\n\n  if (a.getBottom() < this.y) {\n    return false;\n  }\n\n  return true;\n};\n\nRectangleD.prototype.getCenterX = function () {\n  return this.x + this.width / 2;\n};\n\nRectangleD.prototype.getMinX = function () {\n  return this.getX();\n};\n\nRectangleD.prototype.getMaxX = function () {\n  return this.getX() + this.width;\n};\n\nRectangleD.prototype.getCenterY = function () {\n  return this.y + this.height / 2;\n};\n\nRectangleD.prototype.getMinY = function () {\n  return this.getY();\n};\n\nRectangleD.prototype.getMaxY = function () {\n  return this.getY() + this.height;\n};\n\nRectangleD.prototype.getWidthHalf = function () {\n  return this.width / 2;\n};\n\nRectangleD.prototype.getHeightHalf = function () {\n  return this.height / 2;\n};\n\nmodule.exports = RectangleD;\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction UniqueIDGeneretor() {}\n\nUniqueIDGeneretor.lastID = 0;\n\nUniqueIDGeneretor.createID = function (obj) {\n  if (UniqueIDGeneretor.isPrimitive(obj)) {\n    return obj;\n  }\n  if (obj.uniqueID != null) {\n    return obj.uniqueID;\n  }\n  obj.uniqueID = UniqueIDGeneretor.getString();\n  UniqueIDGeneretor.lastID++;\n  return obj.uniqueID;\n};\n\nUniqueIDGeneretor.getString = function (id) {\n  if (id == null) id = UniqueIDGeneretor.lastID;\n  return \"Object#\" + id + \"\";\n};\n\nUniqueIDGeneretor.isPrimitive = function (arg) {\n  var type = typeof arg === \"undefined\" ? \"undefined\" : _typeof(arg);\n  return arg == null || type != \"object\" && type != \"function\";\n};\n\nmodule.exports = UniqueIDGeneretor;\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __nested_webpack_require_64072__) {\n\n\"use strict\";\n\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar LayoutConstants = __nested_webpack_require_64072__(0);\nvar LGraphManager = __nested_webpack_require_64072__(6);\nvar LNode = __nested_webpack_require_64072__(3);\nvar LEdge = __nested_webpack_require_64072__(1);\nvar LGraph = __nested_webpack_require_64072__(5);\nvar PointD = __nested_webpack_require_64072__(4);\nvar Transform = __nested_webpack_require_64072__(17);\nvar Emitter = __nested_webpack_require_64072__(27);\n\nfunction Layout(isRemoteUse) {\n  Emitter.call(this);\n\n  //Layout Quality: 0:draft, 1:default, 2:proof\n  this.layoutQuality = LayoutConstants.QUALITY;\n  //Whether layout should create bendpoints as needed or not\n  this.createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\n  //Whether layout should be incremental or not\n  this.incremental = LayoutConstants.DEFAULT_INCREMENTAL;\n  //Whether we animate from before to after layout node positions\n  this.animationOnLayout = LayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT;\n  //Whether we animate the layout process or not\n  this.animationDuringLayout = LayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT;\n  //Number iterations that should be done between two successive animations\n  this.animationPeriod = LayoutConstants.DEFAULT_ANIMATION_PERIOD;\n  /**\r\n   * Whether or not leaf nodes (non-compound nodes) are of uniform sizes. When\r\n   * they are, both spring and repulsion forces between two leaf nodes can be\r\n   * calculated without the expensive clipping point calculations, resulting\r\n   * in major speed-up.\r\n   */\n  this.uniformLeafNodeSizes = LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES;\n  /**\r\n   * This is used for creation of bendpoints by using dummy nodes and edges.\r\n   * Maps an LEdge to its dummy bendpoint path.\r\n   */\n  this.edgeToDummyNodes = new Map();\n  this.graphManager = new LGraphManager(this);\n  this.isLayoutFinished = false;\n  this.isSubLayout = false;\n  this.isRemoteUse = false;\n\n  if (isRemoteUse != null) {\n    this.isRemoteUse = isRemoteUse;\n  }\n}\n\nLayout.RANDOM_SEED = 1;\n\nLayout.prototype = Object.create(Emitter.prototype);\n\nLayout.prototype.getGraphManager = function () {\n  return this.graphManager;\n};\n\nLayout.prototype.getAllNodes = function () {\n  return this.graphManager.getAllNodes();\n};\n\nLayout.prototype.getAllEdges = function () {\n  return this.graphManager.getAllEdges();\n};\n\nLayout.prototype.getAllNodesToApplyGravitation = function () {\n  return this.graphManager.getAllNodesToApplyGravitation();\n};\n\nLayout.prototype.newGraphManager = function () {\n  var gm = new LGraphManager(this);\n  this.graphManager = gm;\n  return gm;\n};\n\nLayout.prototype.newGraph = function (vGraph) {\n  return new LGraph(null, this.graphManager, vGraph);\n};\n\nLayout.prototype.newNode = function (vNode) {\n  return new LNode(this.graphManager, vNode);\n};\n\nLayout.prototype.newEdge = function (vEdge) {\n  return new LEdge(null, null, vEdge);\n};\n\nLayout.prototype.checkLayoutSuccess = function () {\n  return this.graphManager.getRoot() == null || this.graphManager.getRoot().getNodes().length == 0 || this.graphManager.includesInvalidEdge();\n};\n\nLayout.prototype.runLayout = function () {\n  this.isLayoutFinished = false;\n\n  if (this.tilingPreLayout) {\n    this.tilingPreLayout();\n  }\n\n  this.initParameters();\n  var isLayoutSuccessfull;\n\n  if (this.checkLayoutSuccess()) {\n    isLayoutSuccessfull = false;\n  } else {\n    isLayoutSuccessfull = this.layout();\n  }\n\n  if (LayoutConstants.ANIMATE === 'during') {\n    // If this is a 'during' layout animation. Layout is not finished yet. \n    // We need to perform these in index.js when layout is really finished.\n    return false;\n  }\n\n  if (isLayoutSuccessfull) {\n    if (!this.isSubLayout) {\n      this.doPostLayout();\n    }\n  }\n\n  if (this.tilingPostLayout) {\n    this.tilingPostLayout();\n  }\n\n  this.isLayoutFinished = true;\n\n  return isLayoutSuccessfull;\n};\n\n/**\r\n * This method performs the operations required after layout.\r\n */\nLayout.prototype.doPostLayout = function () {\n  //assert !isSubLayout : \"Should not be called on sub-layout!\";\n  // Propagate geometric changes to v-level objects\n  if (!this.incremental) {\n    this.transform();\n  }\n  this.update();\n};\n\n/**\r\n * This method updates the geometry of the target graph according to\r\n * calculated layout.\r\n */\nLayout.prototype.update2 = function () {\n  // update bend points\n  if (this.createBendsAsNeeded) {\n    this.createBendpointsFromDummyNodes();\n\n    // reset all edges, since the topology has changed\n    this.graphManager.resetAllEdges();\n  }\n\n  // perform edge, node and root updates if layout is not called\n  // remotely\n  if (!this.isRemoteUse) {\n    // update all edges\n    var edge;\n    var allEdges = this.graphManager.getAllEdges();\n    for (var i = 0; i < allEdges.length; i++) {\n      edge = allEdges[i];\n      //      this.update(edge);\n    }\n\n    // recursively update nodes\n    var node;\n    var nodes = this.graphManager.getRoot().getNodes();\n    for (var i = 0; i < nodes.length; i++) {\n      node = nodes[i];\n      //      this.update(node);\n    }\n\n    // update root graph\n    this.update(this.graphManager.getRoot());\n  }\n};\n\nLayout.prototype.update = function (obj) {\n  if (obj == null) {\n    this.update2();\n  } else if (obj instanceof LNode) {\n    var node = obj;\n    if (node.getChild() != null) {\n      // since node is compound, recursively update child nodes\n      var nodes = node.getChild().getNodes();\n      for (var i = 0; i < nodes.length; i++) {\n        update(nodes[i]);\n      }\n    }\n\n    // if the l-level node is associated with a v-level graph object,\n    // then it is assumed that the v-level node implements the\n    // interface Updatable.\n    if (node.vGraphObject != null) {\n      // cast to Updatable without any type check\n      var vNode = node.vGraphObject;\n\n      // call the update method of the interface\n      vNode.update(node);\n    }\n  } else if (obj instanceof LEdge) {\n    var edge = obj;\n    // if the l-level edge is associated with a v-level graph object,\n    // then it is assumed that the v-level edge implements the\n    // interface Updatable.\n\n    if (edge.vGraphObject != null) {\n      // cast to Updatable without any type check\n      var vEdge = edge.vGraphObject;\n\n      // call the update method of the interface\n      vEdge.update(edge);\n    }\n  } else if (obj instanceof LGraph) {\n    var graph = obj;\n    // if the l-level graph is associated with a v-level graph object,\n    // then it is assumed that the v-level object implements the\n    // interface Updatable.\n\n    if (graph.vGraphObject != null) {\n      // cast to Updatable without any type check\n      var vGraph = graph.vGraphObject;\n\n      // call the update method of the interface\n      vGraph.update(graph);\n    }\n  }\n};\n\n/**\r\n * This method is used to set all layout parameters to default values\r\n * determined at compile time.\r\n */\nLayout.prototype.initParameters = function () {\n  if (!this.isSubLayout) {\n    this.layoutQuality = LayoutConstants.QUALITY;\n    this.animationDuringLayout = LayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT;\n    this.animationPeriod = LayoutConstants.DEFAULT_ANIMATION_PERIOD;\n    this.animationOnLayout = LayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT;\n    this.incremental = LayoutConstants.DEFAULT_INCREMENTAL;\n    this.createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\n    this.uniformLeafNodeSizes = LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES;\n  }\n\n  if (this.animationDuringLayout) {\n    this.animationOnLayout = false;\n  }\n};\n\nLayout.prototype.transform = function (newLeftTop) {\n  if (newLeftTop == undefined) {\n    this.transform(new PointD(0, 0));\n  } else {\n    // create a transformation object (from Eclipse to layout). When an\n    // inverse transform is applied, we get upper-left coordinate of the\n    // drawing or the root graph at given input coordinate (some margins\n    // already included in calculation of left-top).\n\n    var trans = new Transform();\n    var leftTop = this.graphManager.getRoot().updateLeftTop();\n\n    if (leftTop != null) {\n      trans.setWorldOrgX(newLeftTop.x);\n      trans.setWorldOrgY(newLeftTop.y);\n\n      trans.setDeviceOrgX(leftTop.x);\n      trans.setDeviceOrgY(leftTop.y);\n\n      var nodes = this.getAllNodes();\n      var node;\n\n      for (var i = 0; i < nodes.length; i++) {\n        node = nodes[i];\n        node.transform(trans);\n      }\n    }\n  }\n};\n\nLayout.prototype.positionNodesRandomly = function (graph) {\n\n  if (graph == undefined) {\n    //assert !this.incremental;\n    this.positionNodesRandomly(this.getGraphManager().getRoot());\n    this.getGraphManager().getRoot().updateBounds(true);\n  } else {\n    var lNode;\n    var childGraph;\n\n    var nodes = graph.getNodes();\n    for (var i = 0; i < nodes.length; i++) {\n      lNode = nodes[i];\n      childGraph = lNode.getChild();\n\n      if (childGraph == null) {\n        lNode.scatter();\n      } else if (childGraph.getNodes().length == 0) {\n        lNode.scatter();\n      } else {\n        this.positionNodesRandomly(childGraph);\n        lNode.updateBounds();\n      }\n    }\n  }\n};\n\n/**\r\n * This method returns a list of trees where each tree is represented as a\r\n * list of l-nodes. The method returns a list of size 0 when:\r\n * - The graph is not flat or\r\n * - One of the component(s) of the graph is not a tree.\r\n */\nLayout.prototype.getFlatForest = function () {\n  var flatForest = [];\n  var isForest = true;\n\n  // Quick reference for all nodes in the graph manager associated with\n  // this layout. The list should not be changed.\n  var allNodes = this.graphManager.getRoot().getNodes();\n\n  // First be sure that the graph is flat\n  var isFlat = true;\n\n  for (var i = 0; i < allNodes.length; i++) {\n    if (allNodes[i].getChild() != null) {\n      isFlat = false;\n    }\n  }\n\n  // Return empty forest if the graph is not flat.\n  if (!isFlat) {\n    return flatForest;\n  }\n\n  // Run BFS for each component of the graph.\n\n  var visited = new Set();\n  var toBeVisited = [];\n  var parents = new Map();\n  var unProcessedNodes = [];\n\n  unProcessedNodes = unProcessedNodes.concat(allNodes);\n\n  // Each iteration of this loop finds a component of the graph and\n  // decides whether it is a tree or not. If it is a tree, adds it to the\n  // forest and continued with the next component.\n\n  while (unProcessedNodes.length > 0 && isForest) {\n    toBeVisited.push(unProcessedNodes[0]);\n\n    // Start the BFS. Each iteration of this loop visits a node in a\n    // BFS manner.\n    while (toBeVisited.length > 0 && isForest) {\n      //pool operation\n      var currentNode = toBeVisited[0];\n      toBeVisited.splice(0, 1);\n      visited.add(currentNode);\n\n      // Traverse all neighbors of this node\n      var neighborEdges = currentNode.getEdges();\n\n      for (var i = 0; i < neighborEdges.length; i++) {\n        var currentNeighbor = neighborEdges[i].getOtherEnd(currentNode);\n\n        // If BFS is not growing from this neighbor.\n        if (parents.get(currentNode) != currentNeighbor) {\n          // We haven't previously visited this neighbor.\n          if (!visited.has(currentNeighbor)) {\n            toBeVisited.push(currentNeighbor);\n            parents.set(currentNeighbor, currentNode);\n          }\n          // Since we have previously visited this neighbor and\n          // this neighbor is not parent of currentNode, given\n          // graph contains a component that is not tree, hence\n          // it is not a forest.\n          else {\n              isForest = false;\n              break;\n            }\n        }\n      }\n    }\n\n    // The graph contains a component that is not a tree. Empty\n    // previously found trees. The method will end.\n    if (!isForest) {\n      flatForest = [];\n    }\n    // Save currently visited nodes as a tree in our forest. Reset\n    // visited and parents lists. Continue with the next component of\n    // the graph, if any.\n    else {\n        var temp = [].concat(_toConsumableArray(visited));\n        flatForest.push(temp);\n        //flatForest = flatForest.concat(temp);\n        //unProcessedNodes.removeAll(visited);\n        for (var i = 0; i < temp.length; i++) {\n          var value = temp[i];\n          var index = unProcessedNodes.indexOf(value);\n          if (index > -1) {\n            unProcessedNodes.splice(index, 1);\n          }\n        }\n        visited = new Set();\n        parents = new Map();\n      }\n  }\n\n  return flatForest;\n};\n\n/**\r\n * This method creates dummy nodes (an l-level node with minimal dimensions)\r\n * for the given edge (one per bendpoint). The existing l-level structure\r\n * is updated accordingly.\r\n */\nLayout.prototype.createDummyNodesForBendpoints = function (edge) {\n  var dummyNodes = [];\n  var prev = edge.source;\n\n  var graph = this.graphManager.calcLowestCommonAncestor(edge.source, edge.target);\n\n  for (var i = 0; i < edge.bendpoints.length; i++) {\n    // create new dummy node\n    var dummyNode = this.newNode(null);\n    dummyNode.setRect(new Point(0, 0), new Dimension(1, 1));\n\n    graph.add(dummyNode);\n\n    // create new dummy edge between prev and dummy node\n    var dummyEdge = this.newEdge(null);\n    this.graphManager.add(dummyEdge, prev, dummyNode);\n\n    dummyNodes.add(dummyNode);\n    prev = dummyNode;\n  }\n\n  var dummyEdge = this.newEdge(null);\n  this.graphManager.add(dummyEdge, prev, edge.target);\n\n  this.edgeToDummyNodes.set(edge, dummyNodes);\n\n  // remove real edge from graph manager if it is inter-graph\n  if (edge.isInterGraph()) {\n    this.graphManager.remove(edge);\n  }\n  // else, remove the edge from the current graph\n  else {\n      graph.remove(edge);\n    }\n\n  return dummyNodes;\n};\n\n/**\r\n * This method creates bendpoints for edges from the dummy nodes\r\n * at l-level.\r\n */\nLayout.prototype.createBendpointsFromDummyNodes = function () {\n  var edges = [];\n  edges = edges.concat(this.graphManager.getAllEdges());\n  edges = [].concat(_toConsumableArray(this.edgeToDummyNodes.keys())).concat(edges);\n\n  for (var k = 0; k < edges.length; k++) {\n    var lEdge = edges[k];\n\n    if (lEdge.bendpoints.length > 0) {\n      var path = this.edgeToDummyNodes.get(lEdge);\n\n      for (var i = 0; i < path.length; i++) {\n        var dummyNode = path[i];\n        var p = new PointD(dummyNode.getCenterX(), dummyNode.getCenterY());\n\n        // update bendpoint's location according to dummy node\n        var ebp = lEdge.bendpoints.get(i);\n        ebp.x = p.x;\n        ebp.y = p.y;\n\n        // remove the dummy node, dummy edges incident with this\n        // dummy node is also removed (within the remove method)\n        dummyNode.getOwner().remove(dummyNode);\n      }\n\n      // add the real edge to graph\n      this.graphManager.add(lEdge, lEdge.source, lEdge.target);\n    }\n  }\n};\n\nLayout.transform = function (sliderValue, defaultValue, minDiv, maxMul) {\n  if (minDiv != undefined && maxMul != undefined) {\n    var value = defaultValue;\n\n    if (sliderValue <= 50) {\n      var minValue = defaultValue / minDiv;\n      value -= (defaultValue - minValue) / 50 * (50 - sliderValue);\n    } else {\n      var maxValue = defaultValue * maxMul;\n      value += (maxValue - defaultValue) / 50 * (sliderValue - 50);\n    }\n\n    return value;\n  } else {\n    var a, b;\n\n    if (sliderValue <= 50) {\n      a = 9.0 * defaultValue / 500.0;\n      b = defaultValue / 10.0;\n    } else {\n      a = 9.0 * defaultValue / 50.0;\n      b = -8 * defaultValue;\n    }\n\n    return a * sliderValue + b;\n  }\n};\n\n/**\r\n * This method finds and returns the center of the given nodes, assuming\r\n * that the given nodes form a tree in themselves.\r\n */\nLayout.findCenterOfTree = function (nodes) {\n  var list = [];\n  list = list.concat(nodes);\n\n  var removedNodes = [];\n  var remainingDegrees = new Map();\n  var foundCenter = false;\n  var centerNode = null;\n\n  if (list.length == 1 || list.length == 2) {\n    foundCenter = true;\n    centerNode = list[0];\n  }\n\n  for (var i = 0; i < list.length; i++) {\n    var node = list[i];\n    var degree = node.getNeighborsList().size;\n    remainingDegrees.set(node, node.getNeighborsList().size);\n\n    if (degree == 1) {\n      removedNodes.push(node);\n    }\n  }\n\n  var tempList = [];\n  tempList = tempList.concat(removedNodes);\n\n  while (!foundCenter) {\n    var tempList2 = [];\n    tempList2 = tempList2.concat(tempList);\n    tempList = [];\n\n    for (var i = 0; i < list.length; i++) {\n      var node = list[i];\n\n      var index = list.indexOf(node);\n      if (index >= 0) {\n        list.splice(index, 1);\n      }\n\n      var neighbours = node.getNeighborsList();\n\n      neighbours.forEach(function (neighbour) {\n        if (removedNodes.indexOf(neighbour) < 0) {\n          var otherDegree = remainingDegrees.get(neighbour);\n          var newDegree = otherDegree - 1;\n\n          if (newDegree == 1) {\n            tempList.push(neighbour);\n          }\n\n          remainingDegrees.set(neighbour, newDegree);\n        }\n      });\n    }\n\n    removedNodes = removedNodes.concat(tempList);\n\n    if (list.length == 1 || list.length == 2) {\n      foundCenter = true;\n      centerNode = list[0];\n    }\n  }\n\n  return centerNode;\n};\n\n/**\r\n * During the coarsening process, this layout may be referenced by two graph managers\r\n * this setter function grants access to change the currently being used graph manager\r\n */\nLayout.prototype.setGraphManager = function (gm) {\n  this.graphManager = gm;\n};\n\nmodule.exports = Layout;\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction RandomSeed() {}\n// adapted from: https://stackoverflow.com/a/19303725\nRandomSeed.seed = 1;\nRandomSeed.x = 0;\n\nRandomSeed.nextDouble = function () {\n  RandomSeed.x = Math.sin(RandomSeed.seed++) * 10000;\n  return RandomSeed.x - Math.floor(RandomSeed.x);\n};\n\nmodule.exports = RandomSeed;\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __nested_webpack_require_81860__) {\n\n\"use strict\";\n\n\nvar PointD = __nested_webpack_require_81860__(4);\n\nfunction Transform(x, y) {\n  this.lworldOrgX = 0.0;\n  this.lworldOrgY = 0.0;\n  this.ldeviceOrgX = 0.0;\n  this.ldeviceOrgY = 0.0;\n  this.lworldExtX = 1.0;\n  this.lworldExtY = 1.0;\n  this.ldeviceExtX = 1.0;\n  this.ldeviceExtY = 1.0;\n}\n\nTransform.prototype.getWorldOrgX = function () {\n  return this.lworldOrgX;\n};\n\nTransform.prototype.setWorldOrgX = function (wox) {\n  this.lworldOrgX = wox;\n};\n\nTransform.prototype.getWorldOrgY = function () {\n  return this.lworldOrgY;\n};\n\nTransform.prototype.setWorldOrgY = function (woy) {\n  this.lworldOrgY = woy;\n};\n\nTransform.prototype.getWorldExtX = function () {\n  return this.lworldExtX;\n};\n\nTransform.prototype.setWorldExtX = function (wex) {\n  this.lworldExtX = wex;\n};\n\nTransform.prototype.getWorldExtY = function () {\n  return this.lworldExtY;\n};\n\nTransform.prototype.setWorldExtY = function (wey) {\n  this.lworldExtY = wey;\n};\n\n/* Device related */\n\nTransform.prototype.getDeviceOrgX = function () {\n  return this.ldeviceOrgX;\n};\n\nTransform.prototype.setDeviceOrgX = function (dox) {\n  this.ldeviceOrgX = dox;\n};\n\nTransform.prototype.getDeviceOrgY = function () {\n  return this.ldeviceOrgY;\n};\n\nTransform.prototype.setDeviceOrgY = function (doy) {\n  this.ldeviceOrgY = doy;\n};\n\nTransform.prototype.getDeviceExtX = function () {\n  return this.ldeviceExtX;\n};\n\nTransform.prototype.setDeviceExtX = function (dex) {\n  this.ldeviceExtX = dex;\n};\n\nTransform.prototype.getDeviceExtY = function () {\n  return this.ldeviceExtY;\n};\n\nTransform.prototype.setDeviceExtY = function (dey) {\n  this.ldeviceExtY = dey;\n};\n\nTransform.prototype.transformX = function (x) {\n  var xDevice = 0.0;\n  var worldExtX = this.lworldExtX;\n  if (worldExtX != 0.0) {\n    xDevice = this.ldeviceOrgX + (x - this.lworldOrgX) * this.ldeviceExtX / worldExtX;\n  }\n\n  return xDevice;\n};\n\nTransform.prototype.transformY = function (y) {\n  var yDevice = 0.0;\n  var worldExtY = this.lworldExtY;\n  if (worldExtY != 0.0) {\n    yDevice = this.ldeviceOrgY + (y - this.lworldOrgY) * this.ldeviceExtY / worldExtY;\n  }\n\n  return yDevice;\n};\n\nTransform.prototype.inverseTransformX = function (x) {\n  var xWorld = 0.0;\n  var deviceExtX = this.ldeviceExtX;\n  if (deviceExtX != 0.0) {\n    xWorld = this.lworldOrgX + (x - this.ldeviceOrgX) * this.lworldExtX / deviceExtX;\n  }\n\n  return xWorld;\n};\n\nTransform.prototype.inverseTransformY = function (y) {\n  var yWorld = 0.0;\n  var deviceExtY = this.ldeviceExtY;\n  if (deviceExtY != 0.0) {\n    yWorld = this.lworldOrgY + (y - this.ldeviceOrgY) * this.lworldExtY / deviceExtY;\n  }\n  return yWorld;\n};\n\nTransform.prototype.inverseTransformPoint = function (inPoint) {\n  var outPoint = new PointD(this.inverseTransformX(inPoint.x), this.inverseTransformY(inPoint.y));\n  return outPoint;\n};\n\nmodule.exports = Transform;\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __nested_webpack_require_84747__) {\n\n\"use strict\";\n\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar Layout = __nested_webpack_require_84747__(15);\nvar FDLayoutConstants = __nested_webpack_require_84747__(7);\nvar LayoutConstants = __nested_webpack_require_84747__(0);\nvar IGeometry = __nested_webpack_require_84747__(8);\nvar IMath = __nested_webpack_require_84747__(9);\n\nfunction FDLayout() {\n  Layout.call(this);\n\n  this.useSmartIdealEdgeLengthCalculation = FDLayoutConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION;\n  this.idealEdgeLength = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\n  this.springConstant = FDLayoutConstants.DEFAULT_SPRING_STRENGTH;\n  this.repulsionConstant = FDLayoutConstants.DEFAULT_REPULSION_STRENGTH;\n  this.gravityConstant = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH;\n  this.compoundGravityConstant = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH;\n  this.gravityRangeFactor = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR;\n  this.compoundGravityRangeFactor = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR;\n  this.displacementThresholdPerNode = 3.0 * FDLayoutConstants.DEFAULT_EDGE_LENGTH / 100;\n  this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;\n  this.initialCoolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;\n  this.totalDisplacement = 0.0;\n  this.oldTotalDisplacement = 0.0;\n  this.maxIterations = FDLayoutConstants.MAX_ITERATIONS;\n}\n\nFDLayout.prototype = Object.create(Layout.prototype);\n\nfor (var prop in Layout) {\n  FDLayout[prop] = Layout[prop];\n}\n\nFDLayout.prototype.initParameters = function () {\n  Layout.prototype.initParameters.call(this, arguments);\n\n  this.totalIterations = 0;\n  this.notAnimatedIterations = 0;\n\n  this.useFRGridVariant = FDLayoutConstants.DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION;\n\n  this.grid = [];\n};\n\nFDLayout.prototype.calcIdealEdgeLengths = function () {\n  var edge;\n  var lcaDepth;\n  var source;\n  var target;\n  var sizeOfSourceInLca;\n  var sizeOfTargetInLca;\n\n  var allEdges = this.getGraphManager().getAllEdges();\n  for (var i = 0; i < allEdges.length; i++) {\n    edge = allEdges[i];\n\n    edge.idealLength = this.idealEdgeLength;\n\n    if (edge.isInterGraph) {\n      source = edge.getSource();\n      target = edge.getTarget();\n\n      sizeOfSourceInLca = edge.getSourceInLca().getEstimatedSize();\n      sizeOfTargetInLca = edge.getTargetInLca().getEstimatedSize();\n\n      if (this.useSmartIdealEdgeLengthCalculation) {\n        edge.idealLength += sizeOfSourceInLca + sizeOfTargetInLca - 2 * LayoutConstants.SIMPLE_NODE_SIZE;\n      }\n\n      lcaDepth = edge.getLca().getInclusionTreeDepth();\n\n      edge.idealLength += FDLayoutConstants.DEFAULT_EDGE_LENGTH * FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR * (source.getInclusionTreeDepth() + target.getInclusionTreeDepth() - 2 * lcaDepth);\n    }\n  }\n};\n\nFDLayout.prototype.initSpringEmbedder = function () {\n\n  var s = this.getAllNodes().length;\n  if (this.incremental) {\n    if (s > FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) {\n      this.coolingFactor = Math.max(this.coolingFactor * FDLayoutConstants.COOLING_ADAPTATION_FACTOR, this.coolingFactor - (s - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) / (FDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) * this.coolingFactor * (1 - FDLayoutConstants.COOLING_ADAPTATION_FACTOR));\n    }\n    this.maxNodeDisplacement = FDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL;\n  } else {\n    if (s > FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) {\n      this.coolingFactor = Math.max(FDLayoutConstants.COOLING_ADAPTATION_FACTOR, 1.0 - (s - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) / (FDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) * (1 - FDLayoutConstants.COOLING_ADAPTATION_FACTOR));\n    } else {\n      this.coolingFactor = 1.0;\n    }\n    this.initialCoolingFactor = this.coolingFactor;\n    this.maxNodeDisplacement = FDLayoutConstants.MAX_NODE_DISPLACEMENT;\n  }\n\n  this.maxIterations = Math.max(this.getAllNodes().length * 5, this.maxIterations);\n\n  this.totalDisplacementThreshold = this.displacementThresholdPerNode * this.getAllNodes().length;\n\n  this.repulsionRange = this.calcRepulsionRange();\n};\n\nFDLayout.prototype.calcSpringForces = function () {\n  var lEdges = this.getAllEdges();\n  var edge;\n\n  for (var i = 0; i < lEdges.length; i++) {\n    edge = lEdges[i];\n\n    this.calcSpringForce(edge, edge.idealLength);\n  }\n};\n\nFDLayout.prototype.calcRepulsionForces = function () {\n  var gridUpdateAllowed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n  var forceToNodeSurroundingUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  var i, j;\n  var nodeA, nodeB;\n  var lNodes = this.getAllNodes();\n  var processedNodeSet;\n\n  if (this.useFRGridVariant) {\n    if (this.totalIterations % FDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD == 1 && gridUpdateAllowed) {\n      this.updateGrid();\n    }\n\n    processedNodeSet = new Set();\n\n    // calculate repulsion forces between each nodes and its surrounding\n    for (i = 0; i < lNodes.length; i++) {\n      nodeA = lNodes[i];\n      this.calculateRepulsionForceOfANode(nodeA, processedNodeSet, gridUpdateAllowed, forceToNodeSurroundingUpdate);\n      processedNodeSet.add(nodeA);\n    }\n  } else {\n    for (i = 0; i < lNodes.length; i++) {\n      nodeA = lNodes[i];\n\n      for (j = i + 1; j < lNodes.length; j++) {\n        nodeB = lNodes[j];\n\n        // If both nodes are not members of the same graph, skip.\n        if (nodeA.getOwner() != nodeB.getOwner()) {\n          continue;\n        }\n\n        this.calcRepulsionForce(nodeA, nodeB);\n      }\n    }\n  }\n};\n\nFDLayout.prototype.calcGravitationalForces = function () {\n  var node;\n  var lNodes = this.getAllNodesToApplyGravitation();\n\n  for (var i = 0; i < lNodes.length; i++) {\n    node = lNodes[i];\n    this.calcGravitationalForce(node);\n  }\n};\n\nFDLayout.prototype.moveNodes = function () {\n  var lNodes = this.getAllNodes();\n  var node;\n\n  for (var i = 0; i < lNodes.length; i++) {\n    node = lNodes[i];\n    node.move();\n  }\n};\n\nFDLayout.prototype.calcSpringForce = function (edge, idealLength) {\n  var sourceNode = edge.getSource();\n  var targetNode = edge.getTarget();\n\n  var length;\n  var springForce;\n  var springForceX;\n  var springForceY;\n\n  // Update edge length\n  if (this.uniformLeafNodeSizes && sourceNode.getChild() == null && targetNode.getChild() == null) {\n    edge.updateLengthSimple();\n  } else {\n    edge.updateLength();\n\n    if (edge.isOverlapingSourceAndTarget) {\n      return;\n    }\n  }\n\n  length = edge.getLength();\n\n  if (length == 0) return;\n\n  // Calculate spring forces\n  springForce = this.springConstant * (length - idealLength);\n\n  // Project force onto x and y axes\n  springForceX = springForce * (edge.lengthX / length);\n  springForceY = springForce * (edge.lengthY / length);\n\n  // Apply forces on the end nodes\n  sourceNode.springForceX += springForceX;\n  sourceNode.springForceY += springForceY;\n  targetNode.springForceX -= springForceX;\n  targetNode.springForceY -= springForceY;\n};\n\nFDLayout.prototype.calcRepulsionForce = function (nodeA, nodeB) {\n  var rectA = nodeA.getRect();\n  var rectB = nodeB.getRect();\n  var overlapAmount = new Array(2);\n  var clipPoints = new Array(4);\n  var distanceX;\n  var distanceY;\n  var distanceSquared;\n  var distance;\n  var repulsionForce;\n  var repulsionForceX;\n  var repulsionForceY;\n\n  if (rectA.intersects(rectB)) // two nodes overlap\n    {\n      // calculate separation amount in x and y directions\n      IGeometry.calcSeparationAmount(rectA, rectB, overlapAmount, FDLayoutConstants.DEFAULT_EDGE_LENGTH / 2.0);\n\n      repulsionForceX = 2 * overlapAmount[0];\n      repulsionForceY = 2 * overlapAmount[1];\n\n      var childrenConstant = nodeA.noOfChildren * nodeB.noOfChildren / (nodeA.noOfChildren + nodeB.noOfChildren);\n\n      // Apply forces on the two nodes\n      nodeA.repulsionForceX -= childrenConstant * repulsionForceX;\n      nodeA.repulsionForceY -= childrenConstant * repulsionForceY;\n      nodeB.repulsionForceX += childrenConstant * repulsionForceX;\n      nodeB.repulsionForceY += childrenConstant * repulsionForceY;\n    } else // no overlap\n    {\n      // calculate distance\n\n      if (this.uniformLeafNodeSizes && nodeA.getChild() == null && nodeB.getChild() == null) // simply base repulsion on distance of node centers\n        {\n          distanceX = rectB.getCenterX() - rectA.getCenterX();\n          distanceY = rectB.getCenterY() - rectA.getCenterY();\n        } else // use clipping points\n        {\n          IGeometry.getIntersection(rectA, rectB, clipPoints);\n\n          distanceX = clipPoints[2] - clipPoints[0];\n          distanceY = clipPoints[3] - clipPoints[1];\n        }\n\n      // No repulsion range. FR grid variant should take care of this.\n      if (Math.abs(distanceX) < FDLayoutConstants.MIN_REPULSION_DIST) {\n        distanceX = IMath.sign(distanceX) * FDLayoutConstants.MIN_REPULSION_DIST;\n      }\n\n      if (Math.abs(distanceY) < FDLayoutConstants.MIN_REPULSION_DIST) {\n        distanceY = IMath.sign(distanceY) * FDLayoutConstants.MIN_REPULSION_DIST;\n      }\n\n      distanceSquared = distanceX * distanceX + distanceY * distanceY;\n      distance = Math.sqrt(distanceSquared);\n\n      repulsionForce = this.repulsionConstant * nodeA.noOfChildren * nodeB.noOfChildren / distanceSquared;\n\n      // Project force onto x and y axes\n      repulsionForceX = repulsionForce * distanceX / distance;\n      repulsionForceY = repulsionForce * distanceY / distance;\n\n      // Apply forces on the two nodes    \n      nodeA.repulsionForceX -= repulsionForceX;\n      nodeA.repulsionForceY -= repulsionForceY;\n      nodeB.repulsionForceX += repulsionForceX;\n      nodeB.repulsionForceY += repulsionForceY;\n    }\n};\n\nFDLayout.prototype.calcGravitationalForce = function (node) {\n  var ownerGraph;\n  var ownerCenterX;\n  var ownerCenterY;\n  var distanceX;\n  var distanceY;\n  var absDistanceX;\n  var absDistanceY;\n  var estimatedSize;\n  ownerGraph = node.getOwner();\n\n  ownerCenterX = (ownerGraph.getRight() + ownerGraph.getLeft()) / 2;\n  ownerCenterY = (ownerGraph.getTop() + ownerGraph.getBottom()) / 2;\n  distanceX = node.getCenterX() - ownerCenterX;\n  distanceY = node.getCenterY() - ownerCenterY;\n  absDistanceX = Math.abs(distanceX) + node.getWidth() / 2;\n  absDistanceY = Math.abs(distanceY) + node.getHeight() / 2;\n\n  if (node.getOwner() == this.graphManager.getRoot()) // in the root graph\n    {\n      estimatedSize = ownerGraph.getEstimatedSize() * this.gravityRangeFactor;\n\n      if (absDistanceX > estimatedSize || absDistanceY > estimatedSize) {\n        node.gravitationForceX = -this.gravityConstant * distanceX;\n        node.gravitationForceY = -this.gravityConstant * distanceY;\n      }\n    } else // inside a compound\n    {\n      estimatedSize = ownerGraph.getEstimatedSize() * this.compoundGravityRangeFactor;\n\n      if (absDistanceX > estimatedSize || absDistanceY > estimatedSize) {\n        node.gravitationForceX = -this.gravityConstant * distanceX * this.compoundGravityConstant;\n        node.gravitationForceY = -this.gravityConstant * distanceY * this.compoundGravityConstant;\n      }\n    }\n};\n\nFDLayout.prototype.isConverged = function () {\n  var converged;\n  var oscilating = false;\n\n  if (this.totalIterations > this.maxIterations / 3) {\n    oscilating = Math.abs(this.totalDisplacement - this.oldTotalDisplacement) < 2;\n  }\n\n  converged = this.totalDisplacement < this.totalDisplacementThreshold;\n\n  this.oldTotalDisplacement = this.totalDisplacement;\n\n  return converged || oscilating;\n};\n\nFDLayout.prototype.animate = function () {\n  if (this.animationDuringLayout && !this.isSubLayout) {\n    if (this.notAnimatedIterations == this.animationPeriod) {\n      this.update();\n      this.notAnimatedIterations = 0;\n    } else {\n      this.notAnimatedIterations++;\n    }\n  }\n};\n\n//This method calculates the number of children (weight) for all nodes\nFDLayout.prototype.calcNoOfChildrenForAllNodes = function () {\n  var node;\n  var allNodes = this.graphManager.getAllNodes();\n\n  for (var i = 0; i < allNodes.length; i++) {\n    node = allNodes[i];\n    node.noOfChildren = node.getNoOfChildren();\n  }\n};\n\n// -----------------------------------------------------------------------------\n// Section: FR-Grid Variant Repulsion Force Calculation\n// -----------------------------------------------------------------------------\n\nFDLayout.prototype.calcGrid = function (graph) {\n\n  var sizeX = 0;\n  var sizeY = 0;\n\n  sizeX = parseInt(Math.ceil((graph.getRight() - graph.getLeft()) / this.repulsionRange));\n  sizeY = parseInt(Math.ceil((graph.getBottom() - graph.getTop()) / this.repulsionRange));\n\n  var grid = new Array(sizeX);\n\n  for (var i = 0; i < sizeX; i++) {\n    grid[i] = new Array(sizeY);\n  }\n\n  for (var i = 0; i < sizeX; i++) {\n    for (var j = 0; j < sizeY; j++) {\n      grid[i][j] = new Array();\n    }\n  }\n\n  return grid;\n};\n\nFDLayout.prototype.addNodeToGrid = function (v, left, top) {\n\n  var startX = 0;\n  var finishX = 0;\n  var startY = 0;\n  var finishY = 0;\n\n  startX = parseInt(Math.floor((v.getRect().x - left) / this.repulsionRange));\n  finishX = parseInt(Math.floor((v.getRect().width + v.getRect().x - left) / this.repulsionRange));\n  startY = parseInt(Math.floor((v.getRect().y - top) / this.repulsionRange));\n  finishY = parseInt(Math.floor((v.getRect().height + v.getRect().y - top) / this.repulsionRange));\n\n  for (var i = startX; i <= finishX; i++) {\n    for (var j = startY; j <= finishY; j++) {\n      this.grid[i][j].push(v);\n      v.setGridCoordinates(startX, finishX, startY, finishY);\n    }\n  }\n};\n\nFDLayout.prototype.updateGrid = function () {\n  var i;\n  var nodeA;\n  var lNodes = this.getAllNodes();\n\n  this.grid = this.calcGrid(this.graphManager.getRoot());\n\n  // put all nodes to proper grid cells\n  for (i = 0; i < lNodes.length; i++) {\n    nodeA = lNodes[i];\n    this.addNodeToGrid(nodeA, this.graphManager.getRoot().getLeft(), this.graphManager.getRoot().getTop());\n  }\n};\n\nFDLayout.prototype.calculateRepulsionForceOfANode = function (nodeA, processedNodeSet, gridUpdateAllowed, forceToNodeSurroundingUpdate) {\n\n  if (this.totalIterations % FDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD == 1 && gridUpdateAllowed || forceToNodeSurroundingUpdate) {\n    var surrounding = new Set();\n    nodeA.surrounding = new Array();\n    var nodeB;\n    var grid = this.grid;\n\n    for (var i = nodeA.startX - 1; i < nodeA.finishX + 2; i++) {\n      for (var j = nodeA.startY - 1; j < nodeA.finishY + 2; j++) {\n        if (!(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length)) {\n          for (var k = 0; k < grid[i][j].length; k++) {\n            nodeB = grid[i][j][k];\n\n            // If both nodes are not members of the same graph, \n            // or both nodes are the same, skip.\n            if (nodeA.getOwner() != nodeB.getOwner() || nodeA == nodeB) {\n              continue;\n            }\n\n            // check if the repulsion force between\n            // nodeA and nodeB has already been calculated\n            if (!processedNodeSet.has(nodeB) && !surrounding.has(nodeB)) {\n              var distanceX = Math.abs(nodeA.getCenterX() - nodeB.getCenterX()) - (nodeA.getWidth() / 2 + nodeB.getWidth() / 2);\n              var distanceY = Math.abs(nodeA.getCenterY() - nodeB.getCenterY()) - (nodeA.getHeight() / 2 + nodeB.getHeight() / 2);\n\n              // if the distance between nodeA and nodeB \n              // is less then calculation range\n              if (distanceX <= this.repulsionRange && distanceY <= this.repulsionRange) {\n                //then add nodeB to surrounding of nodeA\n                surrounding.add(nodeB);\n              }\n            }\n          }\n        }\n      }\n    }\n\n    nodeA.surrounding = [].concat(_toConsumableArray(surrounding));\n  }\n  for (i = 0; i < nodeA.surrounding.length; i++) {\n    this.calcRepulsionForce(nodeA, nodeA.surrounding[i]);\n  }\n};\n\nFDLayout.prototype.calcRepulsionRange = function () {\n  return 0.0;\n};\n\nmodule.exports = FDLayout;\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __nested_webpack_require_100902__) {\n\n\"use strict\";\n\n\nvar LEdge = __nested_webpack_require_100902__(1);\nvar FDLayoutConstants = __nested_webpack_require_100902__(7);\n\nfunction FDLayoutEdge(source, target, vEdge) {\n  LEdge.call(this, source, target, vEdge);\n  this.idealLength = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\n}\n\nFDLayoutEdge.prototype = Object.create(LEdge.prototype);\n\nfor (var prop in LEdge) {\n  FDLayoutEdge[prop] = LEdge[prop];\n}\n\nmodule.exports = FDLayoutEdge;\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __nested_webpack_require_101387__) {\n\n\"use strict\";\n\n\nvar LNode = __nested_webpack_require_101387__(3);\n\nfunction FDLayoutNode(gm, loc, size, vNode) {\n  // alternative constructor is handled inside LNode\n  LNode.call(this, gm, loc, size, vNode);\n  //Spring, repulsion and gravitational forces acting on this node\n  this.springForceX = 0;\n  this.springForceY = 0;\n  this.repulsionForceX = 0;\n  this.repulsionForceY = 0;\n  this.gravitationForceX = 0;\n  this.gravitationForceY = 0;\n  //Amount by which this node is to be moved in this iteration\n  this.displacementX = 0;\n  this.displacementY = 0;\n\n  //Start and finish grid coordinates that this node is fallen into\n  this.startX = 0;\n  this.finishX = 0;\n  this.startY = 0;\n  this.finishY = 0;\n\n  //Geometric neighbors of this node\n  this.surrounding = [];\n}\n\nFDLayoutNode.prototype = Object.create(LNode.prototype);\n\nfor (var prop in LNode) {\n  FDLayoutNode[prop] = LNode[prop];\n}\n\nFDLayoutNode.prototype.setGridCoordinates = function (_startX, _finishX, _startY, _finishY) {\n  this.startX = _startX;\n  this.finishX = _finishX;\n  this.startY = _startY;\n  this.finishY = _finishY;\n};\n\nmodule.exports = FDLayoutNode;\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction DimensionD(width, height) {\n  this.width = 0;\n  this.height = 0;\n  if (width !== null && height !== null) {\n    this.height = height;\n    this.width = width;\n  }\n}\n\nDimensionD.prototype.getWidth = function () {\n  return this.width;\n};\n\nDimensionD.prototype.setWidth = function (width) {\n  this.width = width;\n};\n\nDimensionD.prototype.getHeight = function () {\n  return this.height;\n};\n\nDimensionD.prototype.setHeight = function (height) {\n  this.height = height;\n};\n\nmodule.exports = DimensionD;\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __nested_webpack_require_103173__) {\n\n\"use strict\";\n\n\nvar UniqueIDGeneretor = __nested_webpack_require_103173__(14);\n\nfunction HashMap() {\n  this.map = {};\n  this.keys = [];\n}\n\nHashMap.prototype.put = function (key, value) {\n  var theId = UniqueIDGeneretor.createID(key);\n  if (!this.contains(theId)) {\n    this.map[theId] = value;\n    this.keys.push(key);\n  }\n};\n\nHashMap.prototype.contains = function (key) {\n  var theId = UniqueIDGeneretor.createID(key);\n  return this.map[key] != null;\n};\n\nHashMap.prototype.get = function (key) {\n  var theId = UniqueIDGeneretor.createID(key);\n  return this.map[theId];\n};\n\nHashMap.prototype.keySet = function () {\n  return this.keys;\n};\n\nmodule.exports = HashMap;\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __nested_webpack_require_103901__) {\n\n\"use strict\";\n\n\nvar UniqueIDGeneretor = __nested_webpack_require_103901__(14);\n\nfunction HashSet() {\n  this.set = {};\n}\n;\n\nHashSet.prototype.add = function (obj) {\n  var theId = UniqueIDGeneretor.createID(obj);\n  if (!this.contains(theId)) this.set[theId] = obj;\n};\n\nHashSet.prototype.remove = function (obj) {\n  delete this.set[UniqueIDGeneretor.createID(obj)];\n};\n\nHashSet.prototype.clear = function () {\n  this.set = {};\n};\n\nHashSet.prototype.contains = function (obj) {\n  return this.set[UniqueIDGeneretor.createID(obj)] == obj;\n};\n\nHashSet.prototype.isEmpty = function () {\n  return this.size() === 0;\n};\n\nHashSet.prototype.size = function () {\n  return Object.keys(this.set).length;\n};\n\n//concats this.set to the given list\nHashSet.prototype.addAllTo = function (list) {\n  var keys = Object.keys(this.set);\n  var length = keys.length;\n  for (var i = 0; i < length; i++) {\n    list.push(this.set[keys[i]]);\n  }\n};\n\nHashSet.prototype.size = function () {\n  return Object.keys(this.set).length;\n};\n\nHashSet.prototype.addAll = function (list) {\n  var s = list.length;\n  for (var i = 0; i < s; i++) {\n    var v = list[i];\n    this.add(v);\n  }\n};\n\nmodule.exports = HashSet;\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __nested_webpack_require_105138__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * A classic Quicksort algorithm with Hoare's partition\n * - Works also on LinkedList objects\n *\n * Copyright: i-Vis Research Group, Bilkent University, 2007 - present\n */\n\nvar LinkedList = __nested_webpack_require_105138__(11);\n\nvar Quicksort = function () {\n    function Quicksort(A, compareFunction) {\n        _classCallCheck(this, Quicksort);\n\n        if (compareFunction !== null || compareFunction !== undefined) this.compareFunction = this._defaultCompareFunction;\n\n        var length = void 0;\n        if (A instanceof LinkedList) length = A.size();else length = A.length;\n\n        this._quicksort(A, 0, length - 1);\n    }\n\n    _createClass(Quicksort, [{\n        key: '_quicksort',\n        value: function _quicksort(A, p, r) {\n            if (p < r) {\n                var q = this._partition(A, p, r);\n                this._quicksort(A, p, q);\n                this._quicksort(A, q + 1, r);\n            }\n        }\n    }, {\n        key: '_partition',\n        value: function _partition(A, p, r) {\n            var x = this._get(A, p);\n            var i = p;\n            var j = r;\n            while (true) {\n                while (this.compareFunction(x, this._get(A, j))) {\n                    j--;\n                }while (this.compareFunction(this._get(A, i), x)) {\n                    i++;\n                }if (i < j) {\n                    this._swap(A, i, j);\n                    i++;\n                    j--;\n                } else return j;\n            }\n        }\n    }, {\n        key: '_get',\n        value: function _get(object, index) {\n            if (object instanceof LinkedList) return object.get_object_at(index);else return object[index];\n        }\n    }, {\n        key: '_set',\n        value: function _set(object, index, value) {\n            if (object instanceof LinkedList) object.set_object_at(index, value);else object[index] = value;\n        }\n    }, {\n        key: '_swap',\n        value: function _swap(A, i, j) {\n            var temp = this._get(A, i);\n            this._set(A, i, this._get(A, j));\n            this._set(A, j, temp);\n        }\n    }, {\n        key: '_defaultCompareFunction',\n        value: function _defaultCompareFunction(a, b) {\n            return b > a;\n        }\n    }]);\n\n    return Quicksort;\n}();\n\nmodule.exports = Quicksort;\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n *   Needleman-Wunsch algorithm is an procedure to compute the optimal global alignment of two string\n *   sequences by S.B.Needleman and C.D.Wunsch (1970).\n *\n *   Aside from the inputs, you can assign the scores for,\n *   - Match: The two characters at the current index are same.\n *   - Mismatch: The two characters at the current index are different.\n *   - Insertion/Deletion(gaps): The best alignment involves one letter aligning to a gap in the other string.\n */\n\nvar NeedlemanWunsch = function () {\n    function NeedlemanWunsch(sequence1, sequence2) {\n        var match_score = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n        var mismatch_penalty = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -1;\n        var gap_penalty = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : -1;\n\n        _classCallCheck(this, NeedlemanWunsch);\n\n        this.sequence1 = sequence1;\n        this.sequence2 = sequence2;\n        this.match_score = match_score;\n        this.mismatch_penalty = mismatch_penalty;\n        this.gap_penalty = gap_penalty;\n\n        // Just the remove redundancy\n        this.iMax = sequence1.length + 1;\n        this.jMax = sequence2.length + 1;\n\n        // Grid matrix of scores\n        this.grid = new Array(this.iMax);\n        for (var i = 0; i < this.iMax; i++) {\n            this.grid[i] = new Array(this.jMax);\n\n            for (var j = 0; j < this.jMax; j++) {\n                this.grid[i][j] = 0;\n            }\n        }\n\n        // Traceback matrix (2D array, each cell is an array of boolean values for [`Diag`, `Up`, `Left`] positions)\n        this.tracebackGrid = new Array(this.iMax);\n        for (var _i = 0; _i < this.iMax; _i++) {\n            this.tracebackGrid[_i] = new Array(this.jMax);\n\n            for (var _j = 0; _j < this.jMax; _j++) {\n                this.tracebackGrid[_i][_j] = [null, null, null];\n            }\n        }\n\n        // The aligned sequences (return multiple possibilities)\n        this.alignments = [];\n\n        // Final alignment score\n        this.score = -1;\n\n        // Calculate scores and tracebacks\n        this.computeGrids();\n    }\n\n    _createClass(NeedlemanWunsch, [{\n        key: \"getScore\",\n        value: function getScore() {\n            return this.score;\n        }\n    }, {\n        key: \"getAlignments\",\n        value: function getAlignments() {\n            return this.alignments;\n        }\n\n        // Main dynamic programming procedure\n\n    }, {\n        key: \"computeGrids\",\n        value: function computeGrids() {\n            // Fill in the first row\n            for (var j = 1; j < this.jMax; j++) {\n                this.grid[0][j] = this.grid[0][j - 1] + this.gap_penalty;\n                this.tracebackGrid[0][j] = [false, false, true];\n            }\n\n            // Fill in the first column\n            for (var i = 1; i < this.iMax; i++) {\n                this.grid[i][0] = this.grid[i - 1][0] + this.gap_penalty;\n                this.tracebackGrid[i][0] = [false, true, false];\n            }\n\n            // Fill the rest of the grid\n            for (var _i2 = 1; _i2 < this.iMax; _i2++) {\n                for (var _j2 = 1; _j2 < this.jMax; _j2++) {\n                    // Find the max score(s) among [`Diag`, `Up`, `Left`]\n                    var diag = void 0;\n                    if (this.sequence1[_i2 - 1] === this.sequence2[_j2 - 1]) diag = this.grid[_i2 - 1][_j2 - 1] + this.match_score;else diag = this.grid[_i2 - 1][_j2 - 1] + this.mismatch_penalty;\n\n                    var up = this.grid[_i2 - 1][_j2] + this.gap_penalty;\n                    var left = this.grid[_i2][_j2 - 1] + this.gap_penalty;\n\n                    // If there exists multiple max values, capture them for multiple paths\n                    var maxOf = [diag, up, left];\n                    var indices = this.arrayAllMaxIndexes(maxOf);\n\n                    // Update Grids\n                    this.grid[_i2][_j2] = maxOf[indices[0]];\n                    this.tracebackGrid[_i2][_j2] = [indices.includes(0), indices.includes(1), indices.includes(2)];\n                }\n            }\n\n            // Update alignment score\n            this.score = this.grid[this.iMax - 1][this.jMax - 1];\n        }\n\n        // Gets all possible valid sequence combinations\n\n    }, {\n        key: \"alignmentTraceback\",\n        value: function alignmentTraceback() {\n            var inProcessAlignments = [];\n\n            inProcessAlignments.push({ pos: [this.sequence1.length, this.sequence2.length],\n                seq1: \"\",\n                seq2: \"\"\n            });\n\n            while (inProcessAlignments[0]) {\n                var current = inProcessAlignments[0];\n                var directions = this.tracebackGrid[current.pos[0]][current.pos[1]];\n\n                if (directions[0]) {\n                    inProcessAlignments.push({ pos: [current.pos[0] - 1, current.pos[1] - 1],\n                        seq1: this.sequence1[current.pos[0] - 1] + current.seq1,\n                        seq2: this.sequence2[current.pos[1] - 1] + current.seq2\n                    });\n                }\n                if (directions[1]) {\n                    inProcessAlignments.push({ pos: [current.pos[0] - 1, current.pos[1]],\n                        seq1: this.sequence1[current.pos[0] - 1] + current.seq1,\n                        seq2: '-' + current.seq2\n                    });\n                }\n                if (directions[2]) {\n                    inProcessAlignments.push({ pos: [current.pos[0], current.pos[1] - 1],\n                        seq1: '-' + current.seq1,\n                        seq2: this.sequence2[current.pos[1] - 1] + current.seq2\n                    });\n                }\n\n                if (current.pos[0] === 0 && current.pos[1] === 0) this.alignments.push({ sequence1: current.seq1,\n                    sequence2: current.seq2\n                });\n\n                inProcessAlignments.shift();\n            }\n\n            return this.alignments;\n        }\n\n        // Helper Functions\n\n    }, {\n        key: \"getAllIndexes\",\n        value: function getAllIndexes(arr, val) {\n            var indexes = [],\n                i = -1;\n            while ((i = arr.indexOf(val, i + 1)) !== -1) {\n                indexes.push(i);\n            }\n            return indexes;\n        }\n    }, {\n        key: \"arrayAllMaxIndexes\",\n        value: function arrayAllMaxIndexes(array) {\n            return this.getAllIndexes(array, Math.max.apply(null, array));\n        }\n    }]);\n\n    return NeedlemanWunsch;\n}();\n\nmodule.exports = NeedlemanWunsch;\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __nested_webpack_require_115611__) {\n\n\"use strict\";\n\n\nvar layoutBase = function layoutBase() {\n  return;\n};\n\nlayoutBase.FDLayout = __nested_webpack_require_115611__(18);\nlayoutBase.FDLayoutConstants = __nested_webpack_require_115611__(7);\nlayoutBase.FDLayoutEdge = __nested_webpack_require_115611__(19);\nlayoutBase.FDLayoutNode = __nested_webpack_require_115611__(20);\nlayoutBase.DimensionD = __nested_webpack_require_115611__(21);\nlayoutBase.HashMap = __nested_webpack_require_115611__(22);\nlayoutBase.HashSet = __nested_webpack_require_115611__(23);\nlayoutBase.IGeometry = __nested_webpack_require_115611__(8);\nlayoutBase.IMath = __nested_webpack_require_115611__(9);\nlayoutBase.Integer = __nested_webpack_require_115611__(10);\nlayoutBase.Point = __nested_webpack_require_115611__(12);\nlayoutBase.PointD = __nested_webpack_require_115611__(4);\nlayoutBase.RandomSeed = __nested_webpack_require_115611__(16);\nlayoutBase.RectangleD = __nested_webpack_require_115611__(13);\nlayoutBase.Transform = __nested_webpack_require_115611__(17);\nlayoutBase.UniqueIDGeneretor = __nested_webpack_require_115611__(14);\nlayoutBase.Quicksort = __nested_webpack_require_115611__(24);\nlayoutBase.LinkedList = __nested_webpack_require_115611__(11);\nlayoutBase.LGraphObject = __nested_webpack_require_115611__(2);\nlayoutBase.LGraph = __nested_webpack_require_115611__(5);\nlayoutBase.LEdge = __nested_webpack_require_115611__(1);\nlayoutBase.LGraphManager = __nested_webpack_require_115611__(6);\nlayoutBase.LNode = __nested_webpack_require_115611__(3);\nlayoutBase.Layout = __nested_webpack_require_115611__(15);\nlayoutBase.LayoutConstants = __nested_webpack_require_115611__(0);\nlayoutBase.NeedlemanWunsch = __nested_webpack_require_115611__(25);\n\nmodule.exports = layoutBase;\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction Emitter() {\n  this.listeners = [];\n}\n\nvar p = Emitter.prototype;\n\np.addListener = function (event, callback) {\n  this.listeners.push({\n    event: event,\n    callback: callback\n  });\n};\n\np.removeListener = function (event, callback) {\n  for (var i = this.listeners.length; i >= 0; i--) {\n    var l = this.listeners[i];\n\n    if (l.event === event && l.callback === callback) {\n      this.listeners.splice(i, 1);\n    }\n  }\n};\n\np.emit = function (event, data) {\n  for (var i = 0; i < this.listeners.length; i++) {\n    var l = this.listeners[i];\n\n    if (event === l.event) {\n      l.callback(data);\n    }\n  }\n};\n\nmodule.exports = Emitter;\n\n/***/ })\n/******/ ]);\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL2xheW91dC1iYXNlL2xheW91dC1iYXNlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsSUFBSSxJQUF5RDtBQUM3RDtBQUNBLE1BQU0sRUFLMkI7QUFDakMsQ0FBQztBQUNELHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw4QkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsOEJBQW1CO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7QUFDN0I7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQix1QkFBdUI7QUFDcEQ7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCLGVBQWUsOEJBQW1CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7QUFDN0I7QUFDQSxvQ0FBb0MsNEJBQTRCO0FBQ2hFLDBDQUEwQztBQUMxQyxXQUFXLDhCQUFtQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOEJBQW1CLGtDQUFrQztBQUMvRDtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7QUFDN0I7QUFDQTtBQUNBLGlCQUFpQiw4QkFBbUIsQ0FBQyw4QkFBbUI7QUFDeEQsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLCtCQUFtQjs7QUFFcEQ7OztBQUdBLG1CQUFtQiwrQkFBbUI7QUFDdEMsZ0JBQWdCLCtCQUFtQjtBQUNuQyxZQUFZLCtCQUFtQjs7QUFFL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLE9BQU87QUFDUDtBQUNBLGlDQUFpQywrQkFBbUI7O0FBRXBEOzs7QUFHQSxtQkFBbUIsK0JBQW1CO0FBQ3RDLGNBQWMsK0JBQW1CO0FBQ2pDLGlCQUFpQiwrQkFBbUI7QUFDcEMsc0JBQXNCLCtCQUFtQjtBQUN6QyxpQkFBaUIsK0JBQW1CO0FBQ3BDLGFBQWEsK0JBQW1COztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxR0FBcUc7QUFDckc7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLG9CQUFvQixrQkFBa0I7QUFD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O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGdDQUFtQjs7QUFFcEQ7OztBQUdBO0FBQ0EsWUFBWSxnQ0FBbUI7O0FBRS9CO0FBQ0EsV0FBVyxnQ0FBbUIsS0FBSztBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsT0FBTztBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGdDQUFtQjs7QUFFcEQ7OztBQUdBLHNCQUFzQixnQ0FBbUI7O0FBRXpDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGdDQUFtQjs7QUFFcEQ7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLGdDQUFtQjs7QUFFL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLEtBQUs7O0FBRS9CO0FBQ0E7QUFDQSwwQkFBMEIsS0FBSzs7QUFFL0I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0osb0NBQW9DO0FBQ3BDLElBQUk7QUFDSiw0QkFBNEI7QUFDNUI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBLGlDQUFpQywyQ0FBMkMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RCwrREFBK0QseURBQXlELHFFQUFxRSw2REFBNkQsd0JBQXdCOztBQUVqakIsa0RBQWtELDBDQUEwQzs7QUFFNUY7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtB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bUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtC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LHdCQUF3QixpQ0FBbUI7QUFDM0Msd0JBQXdCLGlDQUFtQjtBQUMzQyx1QkFBdUIsaUNBQW1CO0FBQzFDLCtCQUErQixpQ0FBbUI7QUFDbEQsdUJBQXVCLGlDQUFtQjtBQUMxQyx3QkFBd0IsaUNBQW1CO0FBQzNDLDBCQUEwQixpQ0FBbUI7QUFDN0Msb0JBQW9CLGlDQUFtQjtBQUN2QyxtQkFBbUIsaUNBQW1CO0FBQ3RDLDJCQUEyQixpQ0FBbUI7QUFDOUMsbUJBQW1CLGlDQUFtQjtBQUN0QyxvQkFBb0IsaUNBQW1CO0FBQ3ZDLDZCQUE2QixpQ0FBbUI7QUFDaEQsNkJBQTZCLGlDQUFtQjs7QUFFaEQ7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsMkJBQTJCO0FBQzdDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbGF5b3V0LWJhc2UvbGF5b3V0LWJhc2UuanM/ZWIxYSJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJsYXlvdXRCYXNlXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcImxheW91dEJhc2VcIl0gPSBmYWN0b3J5KCk7XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gaWRlbnRpdHkgZnVuY3Rpb24gZm9yIGNhbGxpbmcgaGFybW9ueSBpbXBvcnRzIHdpdGggdGhlIGNvcnJlY3QgY29udGV4dFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmkgPSBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbi8qKioqKiovIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbi8qKioqKiovIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbi8qKioqKiovIFx0XHRcdH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAyNik7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIExheW91dENvbnN0YW50cygpIHt9XG5cbi8qKlxyXG4gKiBMYXlvdXQgUXVhbGl0eTogMDpkcmFmdCwgMTpkZWZhdWx0LCAyOnByb29mXHJcbiAqL1xuTGF5b3V0Q29uc3RhbnRzLlFVQUxJVFkgPSAxO1xuXG4vKipcclxuICogRGVmYXVsdCBwYXJhbWV0ZXJzXHJcbiAqL1xuTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQ1JFQVRFX0JFTkRTX0FTX05FRURFRCA9IGZhbHNlO1xuTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfSU5DUkVNRU5UQUwgPSBmYWxzZTtcbkxheW91dENvbnN0YW50cy5ERUZBVUxUX0FOSU1BVElPTl9PTl9MQVlPVVQgPSB0cnVlO1xuTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQU5JTUFUSU9OX0RVUklOR19MQVlPVVQgPSBmYWxzZTtcbkxheW91dENvbnN0YW50cy5ERUZBVUxUX0FOSU1BVElPTl9QRVJJT0QgPSA1MDtcbkxheW91dENvbnN0YW50cy5ERUZBVUxUX1VOSUZPUk1fTEVBRl9OT0RFX1NJWkVTID0gZmFsc2U7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBTZWN0aW9uOiBHZW5lcmFsIG90aGVyIGNvbnN0YW50c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8qXHJcbiAqIE1hcmdpbnMgb2YgYSBncmFwaCB0byBiZSBhcHBsaWVkIG9uIGJvdWRpbmcgcmVjdGFuZ2xlIG9mIGl0cyBjb250ZW50cy4gV2VcclxuICogYXNzdW1lIG1hcmdpbnMgb24gYWxsIGZvdXIgc2lkZXMgdG8gYmUgdW5pZm9ybS5cclxuICovXG5MYXlvdXRDb25zdGFudHMuREVGQVVMVF9HUkFQSF9NQVJHSU4gPSAxNTtcblxuLypcclxuICogV2hldGhlciB0byBjb25zaWRlciBsYWJlbHMgaW4gbm9kZSBkaW1lbnNpb25zIG9yIG5vdFxyXG4gKi9cbkxheW91dENvbnN0YW50cy5OT0RFX0RJTUVOU0lPTlNfSU5DTFVERV9MQUJFTFMgPSBmYWxzZTtcblxuLypcclxuICogRGVmYXVsdCBkaW1lbnNpb24gb2YgYSBub24tY29tcG91bmQgbm9kZS5cclxuICovXG5MYXlvdXRDb25zdGFudHMuU0lNUExFX05PREVfU0laRSA9IDQwO1xuXG4vKlxyXG4gKiBEZWZhdWx0IGRpbWVuc2lvbiBvZiBhIG5vbi1jb21wb3VuZCBub2RlLlxyXG4gKi9cbkxheW91dENvbnN0YW50cy5TSU1QTEVfTk9ERV9IQUxGX1NJWkUgPSBMYXlvdXRDb25zdGFudHMuU0lNUExFX05PREVfU0laRSAvIDI7XG5cbi8qXHJcbiAqIEVtcHR5IGNvbXBvdW5kIG5vZGUgc2l6ZS4gV2hlbiBhIGNvbXBvdW5kIG5vZGUgaXMgZW1wdHksIGl0cyBib3RoXHJcbiAqIGRpbWVuc2lvbnMgc2hvdWxkIGJlIG9mIHRoaXMgdmFsdWUuXHJcbiAqL1xuTGF5b3V0Q29uc3RhbnRzLkVNUFRZX0NPTVBPVU5EX05PREVfU0laRSA9IDQwO1xuXG4vKlxyXG4gKiBNaW5pbXVtIGxlbmd0aCB0aGF0IGFuIGVkZ2Ugc2hvdWxkIHRha2UgZHVyaW5nIGxheW91dFxyXG4gKi9cbkxheW91dENvbnN0YW50cy5NSU5fRURHRV9MRU5HVEggPSAxO1xuXG4vKlxyXG4gKiBXb3JsZCBib3VuZGFyaWVzIHRoYXQgbGF5b3V0IG9wZXJhdGVzIG9uXHJcbiAqL1xuTGF5b3V0Q29uc3RhbnRzLldPUkxEX0JPVU5EQVJZID0gMTAwMDAwMDtcblxuLypcclxuICogV29ybGQgYm91bmRhcmllcyB0aGF0IHJhbmRvbSBwb3NpdGlvbmluZyBjYW4gYmUgcGVyZm9ybWVkIHdpdGhcclxuICovXG5MYXlvdXRDb25zdGFudHMuSU5JVElBTF9XT1JMRF9CT1VOREFSWSA9IExheW91dENvbnN0YW50cy5XT1JMRF9CT1VOREFSWSAvIDEwMDA7XG5cbi8qXHJcbiAqIENvb3JkaW5hdGVzIG9mIHRoZSB3b3JsZCBjZW50ZXJcclxuICovXG5MYXlvdXRDb25zdGFudHMuV09STERfQ0VOVEVSX1ggPSAxMjAwO1xuTGF5b3V0Q29uc3RhbnRzLldPUkxEX0NFTlRFUl9ZID0gOTAwO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExheW91dENvbnN0YW50cztcblxuLyoqKi8gfSksXG4vKiAxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBMR3JhcGhPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xudmFyIElHZW9tZXRyeSA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG52YXIgSU1hdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXG5mdW5jdGlvbiBMRWRnZShzb3VyY2UsIHRhcmdldCwgdkVkZ2UpIHtcbiAgTEdyYXBoT2JqZWN0LmNhbGwodGhpcywgdkVkZ2UpO1xuXG4gIHRoaXMuaXNPdmVybGFwaW5nU291cmNlQW5kVGFyZ2V0ID0gZmFsc2U7XG4gIHRoaXMudkdyYXBoT2JqZWN0ID0gdkVkZ2U7XG4gIHRoaXMuYmVuZHBvaW50cyA9IFtdO1xuICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG59XG5cbkxFZGdlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTEdyYXBoT2JqZWN0LnByb3RvdHlwZSk7XG5cbmZvciAodmFyIHByb3AgaW4gTEdyYXBoT2JqZWN0KSB7XG4gIExFZGdlW3Byb3BdID0gTEdyYXBoT2JqZWN0W3Byb3BdO1xufVxuXG5MRWRnZS5wcm90b3R5cGUuZ2V0U291cmNlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5zb3VyY2U7XG59O1xuXG5MRWRnZS5wcm90b3R5cGUuZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy50YXJnZXQ7XG59O1xuXG5MRWRnZS5wcm90b3R5cGUuaXNJbnRlckdyYXBoID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5pc0ludGVyR3JhcGg7XG59O1xuXG5MRWRnZS5wcm90b3R5cGUuZ2V0TGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sZW5ndGg7XG59O1xuXG5MRWRnZS5wcm90b3R5cGUuaXNPdmVybGFwaW5nU291cmNlQW5kVGFyZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5pc092ZXJsYXBpbmdTb3VyY2VBbmRUYXJnZXQ7XG59O1xuXG5MRWRnZS5wcm90b3R5cGUuZ2V0QmVuZHBvaW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuYmVuZHBvaW50cztcbn07XG5cbkxFZGdlLnByb3RvdHlwZS5nZXRMY2EgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmxjYTtcbn07XG5cbkxFZGdlLnByb3RvdHlwZS5nZXRTb3VyY2VJbkxjYSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuc291cmNlSW5MY2E7XG59O1xuXG5MRWRnZS5wcm90b3R5cGUuZ2V0VGFyZ2V0SW5MY2EgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnRhcmdldEluTGNhO1xufTtcblxuTEVkZ2UucHJvdG90eXBlLmdldE90aGVyRW5kID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgaWYgKHRoaXMuc291cmNlID09PSBub2RlKSB7XG4gICAgcmV0dXJuIHRoaXMudGFyZ2V0O1xuICB9IGVsc2UgaWYgKHRoaXMudGFyZ2V0ID09PSBub2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuc291cmNlO1xuICB9IGVsc2Uge1xuICAgIHRocm93IFwiTm9kZSBpcyBub3QgaW5jaWRlbnQgd2l0aCB0aGlzIGVkZ2VcIjtcbiAgfVxufTtcblxuTEVkZ2UucHJvdG90eXBlLmdldE90aGVyRW5kSW5HcmFwaCA9IGZ1bmN0aW9uIChub2RlLCBncmFwaCkge1xuICB2YXIgb3RoZXJFbmQgPSB0aGlzLmdldE90aGVyRW5kKG5vZGUpO1xuICB2YXIgcm9vdCA9IGdyYXBoLmdldEdyYXBoTWFuYWdlcigpLmdldFJvb3QoKTtcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmIChvdGhlckVuZC5nZXRPd25lcigpID09IGdyYXBoKSB7XG4gICAgICByZXR1cm4gb3RoZXJFbmQ7XG4gICAgfVxuXG4gICAgaWYgKG90aGVyRW5kLmdldE93bmVyKCkgPT0gcm9vdCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgb3RoZXJFbmQgPSBvdGhlckVuZC5nZXRPd25lcigpLmdldFBhcmVudCgpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5MRWRnZS5wcm90b3R5cGUudXBkYXRlTGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY2xpcFBvaW50Q29vcmRpbmF0ZXMgPSBuZXcgQXJyYXkoNCk7XG5cbiAgdGhpcy5pc092ZXJsYXBpbmdTb3VyY2VBbmRUYXJnZXQgPSBJR2VvbWV0cnkuZ2V0SW50ZXJzZWN0aW9uKHRoaXMudGFyZ2V0LmdldFJlY3QoKSwgdGhpcy5zb3VyY2UuZ2V0UmVjdCgpLCBjbGlwUG9pbnRDb29yZGluYXRlcyk7XG5cbiAgaWYgKCF0aGlzLmlzT3ZlcmxhcGluZ1NvdXJjZUFuZFRhcmdldCkge1xuICAgIHRoaXMubGVuZ3RoWCA9IGNsaXBQb2ludENvb3JkaW5hdGVzWzBdIC0gY2xpcFBvaW50Q29vcmRpbmF0ZXNbMl07XG4gICAgdGhpcy5sZW5ndGhZID0gY2xpcFBvaW50Q29vcmRpbmF0ZXNbMV0gLSBjbGlwUG9pbnRDb29yZGluYXRlc1szXTtcblxuICAgIGlmIChNYXRoLmFicyh0aGlzLmxlbmd0aFgpIDwgMS4wKSB7XG4gICAgICB0aGlzLmxlbmd0aFggPSBJTWF0aC5zaWduKHRoaXMubGVuZ3RoWCk7XG4gICAgfVxuXG4gICAgaWYgKE1hdGguYWJzKHRoaXMubGVuZ3RoWSkgPCAxLjApIHtcbiAgICAgIHRoaXMubGVuZ3RoWSA9IElNYXRoLnNpZ24odGhpcy5sZW5ndGhZKTtcbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IE1hdGguc3FydCh0aGlzLmxlbmd0aFggKiB0aGlzLmxlbmd0aFggKyB0aGlzLmxlbmd0aFkgKiB0aGlzLmxlbmd0aFkpO1xuICB9XG59O1xuXG5MRWRnZS5wcm90b3R5cGUudXBkYXRlTGVuZ3RoU2ltcGxlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmxlbmd0aFggPSB0aGlzLnRhcmdldC5nZXRDZW50ZXJYKCkgLSB0aGlzLnNvdXJjZS5nZXRDZW50ZXJYKCk7XG4gIHRoaXMubGVuZ3RoWSA9IHRoaXMudGFyZ2V0LmdldENlbnRlclkoKSAtIHRoaXMuc291cmNlLmdldENlbnRlclkoKTtcblxuICBpZiAoTWF0aC5hYnModGhpcy5sZW5ndGhYKSA8IDEuMCkge1xuICAgIHRoaXMubGVuZ3RoWCA9IElNYXRoLnNpZ24odGhpcy5sZW5ndGhYKTtcbiAgfVxuXG4gIGlmIChNYXRoLmFicyh0aGlzLmxlbmd0aFkpIDwgMS4wKSB7XG4gICAgdGhpcy5sZW5ndGhZID0gSU1hdGguc2lnbih0aGlzLmxlbmd0aFkpO1xuICB9XG5cbiAgdGhpcy5sZW5ndGggPSBNYXRoLnNxcnQodGhpcy5sZW5ndGhYICogdGhpcy5sZW5ndGhYICsgdGhpcy5sZW5ndGhZICogdGhpcy5sZW5ndGhZKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTEVkZ2U7XG5cbi8qKiovIH0pLFxuLyogMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBMR3JhcGhPYmplY3QodkdyYXBoT2JqZWN0KSB7XG4gIHRoaXMudkdyYXBoT2JqZWN0ID0gdkdyYXBoT2JqZWN0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IExHcmFwaE9iamVjdDtcblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBMR3JhcGhPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xudmFyIEludGVnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcbnZhciBSZWN0YW5nbGVEID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG52YXIgTGF5b3V0Q29uc3RhbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBSYW5kb21TZWVkID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XG52YXIgUG9pbnREID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxuZnVuY3Rpb24gTE5vZGUoZ20sIGxvYywgc2l6ZSwgdk5vZGUpIHtcbiAgLy9BbHRlcm5hdGl2ZSBjb25zdHJ1Y3RvciAxIDogTE5vZGUoTEdyYXBoTWFuYWdlciBnbSwgUG9pbnQgbG9jLCBEaW1lbnNpb24gc2l6ZSwgT2JqZWN0IHZOb2RlKVxuICBpZiAoc2l6ZSA9PSBudWxsICYmIHZOb2RlID09IG51bGwpIHtcbiAgICB2Tm9kZSA9IGxvYztcbiAgfVxuXG4gIExHcmFwaE9iamVjdC5jYWxsKHRoaXMsIHZOb2RlKTtcblxuICAvL0FsdGVybmF0aXZlIGNvbnN0cnVjdG9yIDIgOiBMTm9kZShMYXlvdXQgbGF5b3V0LCBPYmplY3Qgdk5vZGUpXG4gIGlmIChnbS5ncmFwaE1hbmFnZXIgIT0gbnVsbCkgZ20gPSBnbS5ncmFwaE1hbmFnZXI7XG5cbiAgdGhpcy5lc3RpbWF0ZWRTaXplID0gSW50ZWdlci5NSU5fVkFMVUU7XG4gIHRoaXMuaW5jbHVzaW9uVHJlZURlcHRoID0gSW50ZWdlci5NQVhfVkFMVUU7XG4gIHRoaXMudkdyYXBoT2JqZWN0ID0gdk5vZGU7XG4gIHRoaXMuZWRnZXMgPSBbXTtcbiAgdGhpcy5ncmFwaE1hbmFnZXIgPSBnbTtcblxuICBpZiAoc2l6ZSAhPSBudWxsICYmIGxvYyAhPSBudWxsKSB0aGlzLnJlY3QgPSBuZXcgUmVjdGFuZ2xlRChsb2MueCwgbG9jLnksIHNpemUud2lkdGgsIHNpemUuaGVpZ2h0KTtlbHNlIHRoaXMucmVjdCA9IG5ldyBSZWN0YW5nbGVEKCk7XG59XG5cbkxOb2RlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTEdyYXBoT2JqZWN0LnByb3RvdHlwZSk7XG5mb3IgKHZhciBwcm9wIGluIExHcmFwaE9iamVjdCkge1xuICBMTm9kZVtwcm9wXSA9IExHcmFwaE9iamVjdFtwcm9wXTtcbn1cblxuTE5vZGUucHJvdG90eXBlLmdldEVkZ2VzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5lZGdlcztcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXRDaGlsZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY2hpbGQ7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0T3duZXIgPSBmdW5jdGlvbiAoKSB7XG4gIC8vICBpZiAodGhpcy5vd25lciAhPSBudWxsKSB7XG4gIC8vICAgIGlmICghKHRoaXMub3duZXIgPT0gbnVsbCB8fCB0aGlzLm93bmVyLmdldE5vZGVzKCkuaW5kZXhPZih0aGlzKSA+IC0xKSkge1xuICAvLyAgICAgIHRocm93IFwiYXNzZXJ0IGZhaWxlZFwiO1xuICAvLyAgICB9XG4gIC8vICB9XG5cbiAgcmV0dXJuIHRoaXMub3duZXI7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0V2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnJlY3Qud2lkdGg7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuc2V0V2lkdGggPSBmdW5jdGlvbiAod2lkdGgpIHtcbiAgdGhpcy5yZWN0LndpZHRoID0gd2lkdGg7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5yZWN0LmhlaWdodDtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5zZXRIZWlnaHQgPSBmdW5jdGlvbiAoaGVpZ2h0KSB7XG4gIHRoaXMucmVjdC5oZWlnaHQgPSBoZWlnaHQ7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0Q2VudGVyWCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucmVjdC54ICsgdGhpcy5yZWN0LndpZHRoIC8gMjtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXRDZW50ZXJZID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5yZWN0LnkgKyB0aGlzLnJlY3QuaGVpZ2h0IC8gMjtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXRDZW50ZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuZXcgUG9pbnREKHRoaXMucmVjdC54ICsgdGhpcy5yZWN0LndpZHRoIC8gMiwgdGhpcy5yZWN0LnkgKyB0aGlzLnJlY3QuaGVpZ2h0IC8gMik7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0TG9jYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuZXcgUG9pbnREKHRoaXMucmVjdC54LCB0aGlzLnJlY3QueSk7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0UmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucmVjdDtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXREaWFnb25hbCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE1hdGguc3FydCh0aGlzLnJlY3Qud2lkdGggKiB0aGlzLnJlY3Qud2lkdGggKyB0aGlzLnJlY3QuaGVpZ2h0ICogdGhpcy5yZWN0LmhlaWdodCk7XG59O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgaGFsZiB0aGUgZGlhZ29uYWwgbGVuZ3RoIG9mIHRoaXMgbm9kZS5cbiAqL1xuTE5vZGUucHJvdG90eXBlLmdldEhhbGZUaGVEaWFnb25hbCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE1hdGguc3FydCh0aGlzLnJlY3QuaGVpZ2h0ICogdGhpcy5yZWN0LmhlaWdodCArIHRoaXMucmVjdC53aWR0aCAqIHRoaXMucmVjdC53aWR0aCkgLyAyO1xufTtcblxuTE5vZGUucHJvdG90eXBlLnNldFJlY3QgPSBmdW5jdGlvbiAodXBwZXJMZWZ0LCBkaW1lbnNpb24pIHtcbiAgdGhpcy5yZWN0LnggPSB1cHBlckxlZnQueDtcbiAgdGhpcy5yZWN0LnkgPSB1cHBlckxlZnQueTtcbiAgdGhpcy5yZWN0LndpZHRoID0gZGltZW5zaW9uLndpZHRoO1xuICB0aGlzLnJlY3QuaGVpZ2h0ID0gZGltZW5zaW9uLmhlaWdodDtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5zZXRDZW50ZXIgPSBmdW5jdGlvbiAoY3gsIGN5KSB7XG4gIHRoaXMucmVjdC54ID0gY3ggLSB0aGlzLnJlY3Qud2lkdGggLyAyO1xuICB0aGlzLnJlY3QueSA9IGN5IC0gdGhpcy5yZWN0LmhlaWdodCAvIDI7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuc2V0TG9jYXRpb24gPSBmdW5jdGlvbiAoeCwgeSkge1xuICB0aGlzLnJlY3QueCA9IHg7XG4gIHRoaXMucmVjdC55ID0geTtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5tb3ZlQnkgPSBmdW5jdGlvbiAoZHgsIGR5KSB7XG4gIHRoaXMucmVjdC54ICs9IGR4O1xuICB0aGlzLnJlY3QueSArPSBkeTtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXRFZGdlTGlzdFRvTm9kZSA9IGZ1bmN0aW9uICh0bykge1xuICB2YXIgZWRnZUxpc3QgPSBbXTtcbiAgdmFyIGVkZ2U7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBzZWxmLmVkZ2VzLmZvckVhY2goZnVuY3Rpb24gKGVkZ2UpIHtcblxuICAgIGlmIChlZGdlLnRhcmdldCA9PSB0bykge1xuICAgICAgaWYgKGVkZ2Uuc291cmNlICE9IHNlbGYpIHRocm93IFwiSW5jb3JyZWN0IGVkZ2Ugc291cmNlIVwiO1xuXG4gICAgICBlZGdlTGlzdC5wdXNoKGVkZ2UpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGVkZ2VMaXN0O1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldEVkZ2VzQmV0d2VlbiA9IGZ1bmN0aW9uIChvdGhlcikge1xuICB2YXIgZWRnZUxpc3QgPSBbXTtcbiAgdmFyIGVkZ2U7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLmVkZ2VzLmZvckVhY2goZnVuY3Rpb24gKGVkZ2UpIHtcblxuICAgIGlmICghKGVkZ2Uuc291cmNlID09IHNlbGYgfHwgZWRnZS50YXJnZXQgPT0gc2VsZikpIHRocm93IFwiSW5jb3JyZWN0IGVkZ2Ugc291cmNlIGFuZC9vciB0YXJnZXRcIjtcblxuICAgIGlmIChlZGdlLnRhcmdldCA9PSBvdGhlciB8fCBlZGdlLnNvdXJjZSA9PSBvdGhlcikge1xuICAgICAgZWRnZUxpc3QucHVzaChlZGdlKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBlZGdlTGlzdDtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXROZWlnaGJvcnNMaXN0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbmVpZ2hib3JzID0gbmV3IFNldCgpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgc2VsZi5lZGdlcy5mb3JFYWNoKGZ1bmN0aW9uIChlZGdlKSB7XG5cbiAgICBpZiAoZWRnZS5zb3VyY2UgPT0gc2VsZikge1xuICAgICAgbmVpZ2hib3JzLmFkZChlZGdlLnRhcmdldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChlZGdlLnRhcmdldCAhPSBzZWxmKSB7XG4gICAgICAgIHRocm93IFwiSW5jb3JyZWN0IGluY2lkZW5jeSFcIjtcbiAgICAgIH1cblxuICAgICAgbmVpZ2hib3JzLmFkZChlZGdlLnNvdXJjZSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gbmVpZ2hib3JzO1xufTtcblxuTE5vZGUucHJvdG90eXBlLndpdGhDaGlsZHJlbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHdpdGhOZWlnaGJvcnNMaXN0ID0gbmV3IFNldCgpO1xuICB2YXIgY2hpbGROb2RlO1xuICB2YXIgY2hpbGRyZW47XG5cbiAgd2l0aE5laWdoYm9yc0xpc3QuYWRkKHRoaXMpO1xuXG4gIGlmICh0aGlzLmNoaWxkICE9IG51bGwpIHtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLmNoaWxkLmdldE5vZGVzKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGROb2RlID0gbm9kZXNbaV07XG4gICAgICBjaGlsZHJlbiA9IGNoaWxkTm9kZS53aXRoQ2hpbGRyZW4oKTtcbiAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgd2l0aE5laWdoYm9yc0xpc3QuYWRkKG5vZGUpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHdpdGhOZWlnaGJvcnNMaXN0O1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldE5vT2ZDaGlsZHJlbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vT2ZDaGlsZHJlbiA9IDA7XG4gIHZhciBjaGlsZE5vZGU7XG5cbiAgaWYgKHRoaXMuY2hpbGQgPT0gbnVsbCkge1xuICAgIG5vT2ZDaGlsZHJlbiA9IDE7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5jaGlsZC5nZXROb2RlcygpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkTm9kZSA9IG5vZGVzW2ldO1xuXG4gICAgICBub09mQ2hpbGRyZW4gKz0gY2hpbGROb2RlLmdldE5vT2ZDaGlsZHJlbigpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChub09mQ2hpbGRyZW4gPT0gMCkge1xuICAgIG5vT2ZDaGlsZHJlbiA9IDE7XG4gIH1cbiAgcmV0dXJuIG5vT2ZDaGlsZHJlbjtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXRFc3RpbWF0ZWRTaXplID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5lc3RpbWF0ZWRTaXplID09IEludGVnZXIuTUlOX1ZBTFVFKSB7XG4gICAgdGhyb3cgXCJhc3NlcnQgZmFpbGVkXCI7XG4gIH1cbiAgcmV0dXJuIHRoaXMuZXN0aW1hdGVkU2l6ZTtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5jYWxjRXN0aW1hdGVkU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuY2hpbGQgPT0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLmVzdGltYXRlZFNpemUgPSAodGhpcy5yZWN0LndpZHRoICsgdGhpcy5yZWN0LmhlaWdodCkgLyAyO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZXN0aW1hdGVkU2l6ZSA9IHRoaXMuY2hpbGQuY2FsY0VzdGltYXRlZFNpemUoKTtcbiAgICB0aGlzLnJlY3Qud2lkdGggPSB0aGlzLmVzdGltYXRlZFNpemU7XG4gICAgdGhpcy5yZWN0LmhlaWdodCA9IHRoaXMuZXN0aW1hdGVkU2l6ZTtcblxuICAgIHJldHVybiB0aGlzLmVzdGltYXRlZFNpemU7XG4gIH1cbn07XG5cbkxOb2RlLnByb3RvdHlwZS5zY2F0dGVyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcmFuZG9tQ2VudGVyWDtcbiAgdmFyIHJhbmRvbUNlbnRlclk7XG5cbiAgdmFyIG1pblggPSAtTGF5b3V0Q29uc3RhbnRzLklOSVRJQUxfV09STERfQk9VTkRBUlk7XG4gIHZhciBtYXhYID0gTGF5b3V0Q29uc3RhbnRzLklOSVRJQUxfV09STERfQk9VTkRBUlk7XG4gIHJhbmRvbUNlbnRlclggPSBMYXlvdXRDb25zdGFudHMuV09STERfQ0VOVEVSX1ggKyBSYW5kb21TZWVkLm5leHREb3VibGUoKSAqIChtYXhYIC0gbWluWCkgKyBtaW5YO1xuXG4gIHZhciBtaW5ZID0gLUxheW91dENvbnN0YW50cy5JTklUSUFMX1dPUkxEX0JPVU5EQVJZO1xuICB2YXIgbWF4WSA9IExheW91dENvbnN0YW50cy5JTklUSUFMX1dPUkxEX0JPVU5EQVJZO1xuICByYW5kb21DZW50ZXJZID0gTGF5b3V0Q29uc3RhbnRzLldPUkxEX0NFTlRFUl9ZICsgUmFuZG9tU2VlZC5uZXh0RG91YmxlKCkgKiAobWF4WSAtIG1pblkpICsgbWluWTtcblxuICB0aGlzLnJlY3QueCA9IHJhbmRvbUNlbnRlclg7XG4gIHRoaXMucmVjdC55ID0gcmFuZG9tQ2VudGVyWTtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS51cGRhdGVCb3VuZHMgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmdldENoaWxkKCkgPT0gbnVsbCkge1xuICAgIHRocm93IFwiYXNzZXJ0IGZhaWxlZFwiO1xuICB9XG4gIGlmICh0aGlzLmdldENoaWxkKCkuZ2V0Tm9kZXMoKS5sZW5ndGggIT0gMCkge1xuICAgIC8vIHdyYXAgdGhlIGNoaWxkcmVuIG5vZGVzIGJ5IHJlLWFycmFuZ2luZyB0aGUgYm91bmRhcmllc1xuICAgIHZhciBjaGlsZEdyYXBoID0gdGhpcy5nZXRDaGlsZCgpO1xuICAgIGNoaWxkR3JhcGgudXBkYXRlQm91bmRzKHRydWUpO1xuXG4gICAgdGhpcy5yZWN0LnggPSBjaGlsZEdyYXBoLmdldExlZnQoKTtcbiAgICB0aGlzLnJlY3QueSA9IGNoaWxkR3JhcGguZ2V0VG9wKCk7XG5cbiAgICB0aGlzLnNldFdpZHRoKGNoaWxkR3JhcGguZ2V0UmlnaHQoKSAtIGNoaWxkR3JhcGguZ2V0TGVmdCgpKTtcbiAgICB0aGlzLnNldEhlaWdodChjaGlsZEdyYXBoLmdldEJvdHRvbSgpIC0gY2hpbGRHcmFwaC5nZXRUb3AoKSk7XG5cbiAgICAvLyBVcGRhdGUgY29tcG91bmQgYm91bmRzIGNvbnNpZGVyaW5nIGl0cyBsYWJlbCBwcm9wZXJ0aWVzICAgIFxuICAgIGlmIChMYXlvdXRDb25zdGFudHMuTk9ERV9ESU1FTlNJT05TX0lOQ0xVREVfTEFCRUxTKSB7XG5cbiAgICAgIHZhciB3aWR0aCA9IGNoaWxkR3JhcGguZ2V0UmlnaHQoKSAtIGNoaWxkR3JhcGguZ2V0TGVmdCgpO1xuICAgICAgdmFyIGhlaWdodCA9IGNoaWxkR3JhcGguZ2V0Qm90dG9tKCkgLSBjaGlsZEdyYXBoLmdldFRvcCgpO1xuXG4gICAgICBpZiAodGhpcy5sYWJlbFdpZHRoID4gd2lkdGgpIHtcbiAgICAgICAgdGhpcy5yZWN0LnggLT0gKHRoaXMubGFiZWxXaWR0aCAtIHdpZHRoKSAvIDI7XG4gICAgICAgIHRoaXMuc2V0V2lkdGgodGhpcy5sYWJlbFdpZHRoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMubGFiZWxIZWlnaHQgPiBoZWlnaHQpIHtcbiAgICAgICAgaWYgKHRoaXMubGFiZWxQb3MgPT0gXCJjZW50ZXJcIikge1xuICAgICAgICAgIHRoaXMucmVjdC55IC09ICh0aGlzLmxhYmVsSGVpZ2h0IC0gaGVpZ2h0KSAvIDI7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5sYWJlbFBvcyA9PSBcInRvcFwiKSB7XG4gICAgICAgICAgdGhpcy5yZWN0LnkgLT0gdGhpcy5sYWJlbEhlaWdodCAtIGhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldEhlaWdodCh0aGlzLmxhYmVsSGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXRJbmNsdXNpb25UcmVlRGVwdGggPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmluY2x1c2lvblRyZWVEZXB0aCA9PSBJbnRlZ2VyLk1BWF9WQUxVRSkge1xuICAgIHRocm93IFwiYXNzZXJ0IGZhaWxlZFwiO1xuICB9XG4gIHJldHVybiB0aGlzLmluY2x1c2lvblRyZWVEZXB0aDtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAodHJhbnMpIHtcbiAgdmFyIGxlZnQgPSB0aGlzLnJlY3QueDtcblxuICBpZiAobGVmdCA+IExheW91dENvbnN0YW50cy5XT1JMRF9CT1VOREFSWSkge1xuICAgIGxlZnQgPSBMYXlvdXRDb25zdGFudHMuV09STERfQk9VTkRBUlk7XG4gIH0gZWxzZSBpZiAobGVmdCA8IC1MYXlvdXRDb25zdGFudHMuV09STERfQk9VTkRBUlkpIHtcbiAgICBsZWZ0ID0gLUxheW91dENvbnN0YW50cy5XT1JMRF9CT1VOREFSWTtcbiAgfVxuXG4gIHZhciB0b3AgPSB0aGlzLnJlY3QueTtcblxuICBpZiAodG9wID4gTGF5b3V0Q29uc3RhbnRzLldPUkxEX0JPVU5EQVJZKSB7XG4gICAgdG9wID0gTGF5b3V0Q29uc3RhbnRzLldPUkxEX0JPVU5EQVJZO1xuICB9IGVsc2UgaWYgKHRvcCA8IC1MYXlvdXRDb25zdGFudHMuV09STERfQk9VTkRBUlkpIHtcbiAgICB0b3AgPSAtTGF5b3V0Q29uc3RhbnRzLldPUkxEX0JPVU5EQVJZO1xuICB9XG5cbiAgdmFyIGxlZnRUb3AgPSBuZXcgUG9pbnREKGxlZnQsIHRvcCk7XG4gIHZhciB2TGVmdFRvcCA9IHRyYW5zLmludmVyc2VUcmFuc2Zvcm1Qb2ludChsZWZ0VG9wKTtcblxuICB0aGlzLnNldExvY2F0aW9uKHZMZWZ0VG9wLngsIHZMZWZ0VG9wLnkpO1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldExlZnQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnJlY3QueDtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXRSaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucmVjdC54ICsgdGhpcy5yZWN0LndpZHRoO1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldFRvcCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucmVjdC55O1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldEJvdHRvbSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucmVjdC55ICsgdGhpcy5yZWN0LmhlaWdodDtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXRQYXJlbnQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLm93bmVyID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiB0aGlzLm93bmVyLmdldFBhcmVudCgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBMTm9kZTtcblxuLyoqKi8gfSksXG4vKiA0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIFBvaW50RCh4LCB5KSB7XG4gIGlmICh4ID09IG51bGwgJiYgeSA9PSBudWxsKSB7XG4gICAgdGhpcy54ID0gMDtcbiAgICB0aGlzLnkgPSAwO1xuICB9IGVsc2Uge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgfVxufVxuXG5Qb2ludEQucHJvdG90eXBlLmdldFggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLng7XG59O1xuXG5Qb2ludEQucHJvdG90eXBlLmdldFkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnk7XG59O1xuXG5Qb2ludEQucHJvdG90eXBlLnNldFggPSBmdW5jdGlvbiAoeCkge1xuICB0aGlzLnggPSB4O1xufTtcblxuUG9pbnRELnByb3RvdHlwZS5zZXRZID0gZnVuY3Rpb24gKHkpIHtcbiAgdGhpcy55ID0geTtcbn07XG5cblBvaW50RC5wcm90b3R5cGUuZ2V0RGlmZmVyZW5jZSA9IGZ1bmN0aW9uIChwdCkge1xuICByZXR1cm4gbmV3IERpbWVuc2lvbkQodGhpcy54IC0gcHQueCwgdGhpcy55IC0gcHQueSk7XG59O1xuXG5Qb2ludEQucHJvdG90eXBlLmdldENvcHkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuZXcgUG9pbnREKHRoaXMueCwgdGhpcy55KTtcbn07XG5cblBvaW50RC5wcm90b3R5cGUudHJhbnNsYXRlID0gZnVuY3Rpb24gKGRpbSkge1xuICB0aGlzLnggKz0gZGltLndpZHRoO1xuICB0aGlzLnkgKz0gZGltLmhlaWdodDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvaW50RDtcblxuLyoqKi8gfSksXG4vKiA1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBMR3JhcGhPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xudmFyIEludGVnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcbnZhciBMYXlvdXRDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIExHcmFwaE1hbmFnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xudmFyIExOb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbnZhciBMRWRnZSA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG52YXIgUmVjdGFuZ2xlRCA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xudmFyIFBvaW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG52YXIgTGlua2VkTGlzdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXG5mdW5jdGlvbiBMR3JhcGgocGFyZW50LCBvYmoyLCB2R3JhcGgpIHtcbiAgTEdyYXBoT2JqZWN0LmNhbGwodGhpcywgdkdyYXBoKTtcbiAgdGhpcy5lc3RpbWF0ZWRTaXplID0gSW50ZWdlci5NSU5fVkFMVUU7XG4gIHRoaXMubWFyZ2luID0gTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfR1JBUEhfTUFSR0lOO1xuICB0aGlzLmVkZ2VzID0gW107XG4gIHRoaXMubm9kZXMgPSBbXTtcbiAgdGhpcy5pc0Nvbm5lY3RlZCA9IGZhbHNlO1xuICB0aGlzLnBhcmVudCA9IHBhcmVudDtcblxuICBpZiAob2JqMiAhPSBudWxsICYmIG9iajIgaW5zdGFuY2VvZiBMR3JhcGhNYW5hZ2VyKSB7XG4gICAgdGhpcy5ncmFwaE1hbmFnZXIgPSBvYmoyO1xuICB9IGVsc2UgaWYgKG9iajIgIT0gbnVsbCAmJiBvYmoyIGluc3RhbmNlb2YgTGF5b3V0KSB7XG4gICAgdGhpcy5ncmFwaE1hbmFnZXIgPSBvYmoyLmdyYXBoTWFuYWdlcjtcbiAgfVxufVxuXG5MR3JhcGgucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShMR3JhcGhPYmplY3QucHJvdG90eXBlKTtcbmZvciAodmFyIHByb3AgaW4gTEdyYXBoT2JqZWN0KSB7XG4gIExHcmFwaFtwcm9wXSA9IExHcmFwaE9iamVjdFtwcm9wXTtcbn1cblxuTEdyYXBoLnByb3RvdHlwZS5nZXROb2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubm9kZXM7XG59O1xuXG5MR3JhcGgucHJvdG90eXBlLmdldEVkZ2VzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5lZGdlcztcbn07XG5cbkxHcmFwaC5wcm90b3R5cGUuZ2V0R3JhcGhNYW5hZ2VyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ncmFwaE1hbmFnZXI7XG59O1xuXG5MR3JhcGgucHJvdG90eXBlLmdldFBhcmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucGFyZW50O1xufTtcblxuTEdyYXBoLnByb3RvdHlwZS5nZXRMZWZ0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sZWZ0O1xufTtcblxuTEdyYXBoLnByb3RvdHlwZS5nZXRSaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucmlnaHQ7XG59O1xuXG5MR3JhcGgucHJvdG90eXBlLmdldFRvcCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMudG9wO1xufTtcblxuTEdyYXBoLnByb3RvdHlwZS5nZXRCb3R0b20gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmJvdHRvbTtcbn07XG5cbkxHcmFwaC5wcm90b3R5cGUuaXNDb25uZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmlzQ29ubmVjdGVkO1xufTtcblxuTEdyYXBoLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAob2JqMSwgc291cmNlTm9kZSwgdGFyZ2V0Tm9kZSkge1xuICBpZiAoc291cmNlTm9kZSA9PSBudWxsICYmIHRhcmdldE5vZGUgPT0gbnVsbCkge1xuICAgIHZhciBuZXdOb2RlID0gb2JqMTtcbiAgICBpZiAodGhpcy5ncmFwaE1hbmFnZXIgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgXCJHcmFwaCBoYXMgbm8gZ3JhcGggbWdyIVwiO1xuICAgIH1cbiAgICBpZiAodGhpcy5nZXROb2RlcygpLmluZGV4T2YobmV3Tm9kZSkgPiAtMSkge1xuICAgICAgdGhyb3cgXCJOb2RlIGFscmVhZHkgaW4gZ3JhcGghXCI7XG4gICAgfVxuICAgIG5ld05vZGUub3duZXIgPSB0aGlzO1xuICAgIHRoaXMuZ2V0Tm9kZXMoKS5wdXNoKG5ld05vZGUpO1xuXG4gICAgcmV0dXJuIG5ld05vZGU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG5ld0VkZ2UgPSBvYmoxO1xuICAgIGlmICghKHRoaXMuZ2V0Tm9kZXMoKS5pbmRleE9mKHNvdXJjZU5vZGUpID4gLTEgJiYgdGhpcy5nZXROb2RlcygpLmluZGV4T2YodGFyZ2V0Tm9kZSkgPiAtMSkpIHtcbiAgICAgIHRocm93IFwiU291cmNlIG9yIHRhcmdldCBub3QgaW4gZ3JhcGghXCI7XG4gICAgfVxuXG4gICAgaWYgKCEoc291cmNlTm9kZS5vd25lciA9PSB0YXJnZXROb2RlLm93bmVyICYmIHNvdXJjZU5vZGUub3duZXIgPT0gdGhpcykpIHtcbiAgICAgIHRocm93IFwiQm90aCBvd25lcnMgbXVzdCBiZSB0aGlzIGdyYXBoIVwiO1xuICAgIH1cblxuICAgIGlmIChzb3VyY2VOb2RlLm93bmVyICE9IHRhcmdldE5vZGUub3duZXIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIHNldCBzb3VyY2UgYW5kIHRhcmdldFxuICAgIG5ld0VkZ2Uuc291cmNlID0gc291cmNlTm9kZTtcbiAgICBuZXdFZGdlLnRhcmdldCA9IHRhcmdldE5vZGU7XG5cbiAgICAvLyBzZXQgYXMgaW50cmEtZ3JhcGggZWRnZVxuICAgIG5ld0VkZ2UuaXNJbnRlckdyYXBoID0gZmFsc2U7XG5cbiAgICAvLyBhZGQgdG8gZ3JhcGggZWRnZSBsaXN0XG4gICAgdGhpcy5nZXRFZGdlcygpLnB1c2gobmV3RWRnZSk7XG5cbiAgICAvLyBhZGQgdG8gaW5jaWRlbmN5IGxpc3RzXG4gICAgc291cmNlTm9kZS5lZGdlcy5wdXNoKG5ld0VkZ2UpO1xuXG4gICAgaWYgKHRhcmdldE5vZGUgIT0gc291cmNlTm9kZSkge1xuICAgICAgdGFyZ2V0Tm9kZS5lZGdlcy5wdXNoKG5ld0VkZ2UpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXdFZGdlO1xuICB9XG59O1xuXG5MR3JhcGgucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIG5vZGUgPSBvYmo7XG4gIGlmIChvYmogaW5zdGFuY2VvZiBMTm9kZSkge1xuICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgIHRocm93IFwiTm9kZSBpcyBudWxsIVwiO1xuICAgIH1cbiAgICBpZiAoIShub2RlLm93bmVyICE9IG51bGwgJiYgbm9kZS5vd25lciA9PSB0aGlzKSkge1xuICAgICAgdGhyb3cgXCJPd25lciBncmFwaCBpcyBpbnZhbGlkIVwiO1xuICAgIH1cbiAgICBpZiAodGhpcy5ncmFwaE1hbmFnZXIgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgXCJPd25lciBncmFwaCBtYW5hZ2VyIGlzIGludmFsaWQhXCI7XG4gICAgfVxuICAgIC8vIHJlbW92ZSBpbmNpZGVudCBlZGdlcyBmaXJzdCAobWFrZSBhIGNvcHkgdG8gZG8gaXQgc2FmZWx5KVxuICAgIHZhciBlZGdlc1RvQmVSZW1vdmVkID0gbm9kZS5lZGdlcy5zbGljZSgpO1xuICAgIHZhciBlZGdlO1xuICAgIHZhciBzID0gZWRnZXNUb0JlUmVtb3ZlZC5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICAgIGVkZ2UgPSBlZGdlc1RvQmVSZW1vdmVkW2ldO1xuXG4gICAgICBpZiAoZWRnZS5pc0ludGVyR3JhcGgpIHtcbiAgICAgICAgdGhpcy5ncmFwaE1hbmFnZXIucmVtb3ZlKGVkZ2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWRnZS5zb3VyY2Uub3duZXIucmVtb3ZlKGVkZ2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIG5vdyB0aGUgbm9kZSBpdHNlbGZcbiAgICB2YXIgaW5kZXggPSB0aGlzLm5vZGVzLmluZGV4T2Yobm9kZSk7XG4gICAgaWYgKGluZGV4ID09IC0xKSB7XG4gICAgICB0aHJvdyBcIk5vZGUgbm90IGluIG93bmVyIG5vZGUgbGlzdCFcIjtcbiAgICB9XG5cbiAgICB0aGlzLm5vZGVzLnNwbGljZShpbmRleCwgMSk7XG4gIH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgTEVkZ2UpIHtcbiAgICB2YXIgZWRnZSA9IG9iajtcbiAgICBpZiAoZWRnZSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBcIkVkZ2UgaXMgbnVsbCFcIjtcbiAgICB9XG4gICAgaWYgKCEoZWRnZS5zb3VyY2UgIT0gbnVsbCAmJiBlZGdlLnRhcmdldCAhPSBudWxsKSkge1xuICAgICAgdGhyb3cgXCJTb3VyY2UgYW5kL29yIHRhcmdldCBpcyBudWxsIVwiO1xuICAgIH1cbiAgICBpZiAoIShlZGdlLnNvdXJjZS5vd25lciAhPSBudWxsICYmIGVkZ2UudGFyZ2V0Lm93bmVyICE9IG51bGwgJiYgZWRnZS5zb3VyY2Uub3duZXIgPT0gdGhpcyAmJiBlZGdlLnRhcmdldC5vd25lciA9PSB0aGlzKSkge1xuICAgICAgdGhyb3cgXCJTb3VyY2UgYW5kL29yIHRhcmdldCBvd25lciBpcyBpbnZhbGlkIVwiO1xuICAgIH1cblxuICAgIHZhciBzb3VyY2VJbmRleCA9IGVkZ2Uuc291cmNlLmVkZ2VzLmluZGV4T2YoZWRnZSk7XG4gICAgdmFyIHRhcmdldEluZGV4ID0gZWRnZS50YXJnZXQuZWRnZXMuaW5kZXhPZihlZGdlKTtcbiAgICBpZiAoIShzb3VyY2VJbmRleCA+IC0xICYmIHRhcmdldEluZGV4ID4gLTEpKSB7XG4gICAgICB0aHJvdyBcIlNvdXJjZSBhbmQvb3IgdGFyZ2V0IGRvZXNuJ3Qga25vdyB0aGlzIGVkZ2UhXCI7XG4gICAgfVxuXG4gICAgZWRnZS5zb3VyY2UuZWRnZXMuc3BsaWNlKHNvdXJjZUluZGV4LCAxKTtcblxuICAgIGlmIChlZGdlLnRhcmdldCAhPSBlZGdlLnNvdXJjZSkge1xuICAgICAgZWRnZS50YXJnZXQuZWRnZXMuc3BsaWNlKHRhcmdldEluZGV4LCAxKTtcbiAgICB9XG5cbiAgICB2YXIgaW5kZXggPSBlZGdlLnNvdXJjZS5vd25lci5nZXRFZGdlcygpLmluZGV4T2YoZWRnZSk7XG4gICAgaWYgKGluZGV4ID09IC0xKSB7XG4gICAgICB0aHJvdyBcIk5vdCBpbiBvd25lcidzIGVkZ2UgbGlzdCFcIjtcbiAgICB9XG5cbiAgICBlZGdlLnNvdXJjZS5vd25lci5nZXRFZGdlcygpLnNwbGljZShpbmRleCwgMSk7XG4gIH1cbn07XG5cbkxHcmFwaC5wcm90b3R5cGUudXBkYXRlTGVmdFRvcCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRvcCA9IEludGVnZXIuTUFYX1ZBTFVFO1xuICB2YXIgbGVmdCA9IEludGVnZXIuTUFYX1ZBTFVFO1xuICB2YXIgbm9kZVRvcDtcbiAgdmFyIG5vZGVMZWZ0O1xuICB2YXIgbWFyZ2luO1xuXG4gIHZhciBub2RlcyA9IHRoaXMuZ2V0Tm9kZXMoKTtcbiAgdmFyIHMgPSBub2Rlcy5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICB2YXIgbE5vZGUgPSBub2Rlc1tpXTtcbiAgICBub2RlVG9wID0gbE5vZGUuZ2V0VG9wKCk7XG4gICAgbm9kZUxlZnQgPSBsTm9kZS5nZXRMZWZ0KCk7XG5cbiAgICBpZiAodG9wID4gbm9kZVRvcCkge1xuICAgICAgdG9wID0gbm9kZVRvcDtcbiAgICB9XG5cbiAgICBpZiAobGVmdCA+IG5vZGVMZWZ0KSB7XG4gICAgICBsZWZ0ID0gbm9kZUxlZnQ7XG4gICAgfVxuICB9XG5cbiAgLy8gRG8gd2UgaGF2ZSBhbnkgbm9kZXMgaW4gdGhpcyBncmFwaD9cbiAgaWYgKHRvcCA9PSBJbnRlZ2VyLk1BWF9WQUxVRSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKG5vZGVzWzBdLmdldFBhcmVudCgpLnBhZGRpbmdMZWZ0ICE9IHVuZGVmaW5lZCkge1xuICAgIG1hcmdpbiA9IG5vZGVzWzBdLmdldFBhcmVudCgpLnBhZGRpbmdMZWZ0O1xuICB9IGVsc2Uge1xuICAgIG1hcmdpbiA9IHRoaXMubWFyZ2luO1xuICB9XG5cbiAgdGhpcy5sZWZ0ID0gbGVmdCAtIG1hcmdpbjtcbiAgdGhpcy50b3AgPSB0b3AgLSBtYXJnaW47XG5cbiAgLy8gQXBwbHkgdGhlIG1hcmdpbnMgYW5kIHJldHVybiB0aGUgcmVzdWx0XG4gIHJldHVybiBuZXcgUG9pbnQodGhpcy5sZWZ0LCB0aGlzLnRvcCk7XG59O1xuXG5MR3JhcGgucHJvdG90eXBlLnVwZGF0ZUJvdW5kcyA9IGZ1bmN0aW9uIChyZWN1cnNpdmUpIHtcbiAgLy8gY2FsY3VsYXRlIGJvdW5kc1xuICB2YXIgbGVmdCA9IEludGVnZXIuTUFYX1ZBTFVFO1xuICB2YXIgcmlnaHQgPSAtSW50ZWdlci5NQVhfVkFMVUU7XG4gIHZhciB0b3AgPSBJbnRlZ2VyLk1BWF9WQUxVRTtcbiAgdmFyIGJvdHRvbSA9IC1JbnRlZ2VyLk1BWF9WQUxVRTtcbiAgdmFyIG5vZGVMZWZ0O1xuICB2YXIgbm9kZVJpZ2h0O1xuICB2YXIgbm9kZVRvcDtcbiAgdmFyIG5vZGVCb3R0b207XG4gIHZhciBtYXJnaW47XG5cbiAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcztcbiAgdmFyIHMgPSBub2Rlcy5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgdmFyIGxOb2RlID0gbm9kZXNbaV07XG5cbiAgICBpZiAocmVjdXJzaXZlICYmIGxOb2RlLmNoaWxkICE9IG51bGwpIHtcbiAgICAgIGxOb2RlLnVwZGF0ZUJvdW5kcygpO1xuICAgIH1cbiAgICBub2RlTGVmdCA9IGxOb2RlLmdldExlZnQoKTtcbiAgICBub2RlUmlnaHQgPSBsTm9kZS5nZXRSaWdodCgpO1xuICAgIG5vZGVUb3AgPSBsTm9kZS5nZXRUb3AoKTtcbiAgICBub2RlQm90dG9tID0gbE5vZGUuZ2V0Qm90dG9tKCk7XG5cbiAgICBpZiAobGVmdCA+IG5vZGVMZWZ0KSB7XG4gICAgICBsZWZ0ID0gbm9kZUxlZnQ7XG4gICAgfVxuXG4gICAgaWYgKHJpZ2h0IDwgbm9kZVJpZ2h0KSB7XG4gICAgICByaWdodCA9IG5vZGVSaWdodDtcbiAgICB9XG5cbiAgICBpZiAodG9wID4gbm9kZVRvcCkge1xuICAgICAgdG9wID0gbm9kZVRvcDtcbiAgICB9XG5cbiAgICBpZiAoYm90dG9tIDwgbm9kZUJvdHRvbSkge1xuICAgICAgYm90dG9tID0gbm9kZUJvdHRvbTtcbiAgICB9XG4gIH1cblxuICB2YXIgYm91bmRpbmdSZWN0ID0gbmV3IFJlY3RhbmdsZUQobGVmdCwgdG9wLCByaWdodCAtIGxlZnQsIGJvdHRvbSAtIHRvcCk7XG4gIGlmIChsZWZ0ID09IEludGVnZXIuTUFYX1ZBTFVFKSB7XG4gICAgdGhpcy5sZWZ0ID0gdGhpcy5wYXJlbnQuZ2V0TGVmdCgpO1xuICAgIHRoaXMucmlnaHQgPSB0aGlzLnBhcmVudC5nZXRSaWdodCgpO1xuICAgIHRoaXMudG9wID0gdGhpcy5wYXJlbnQuZ2V0VG9wKCk7XG4gICAgdGhpcy5ib3R0b20gPSB0aGlzLnBhcmVudC5nZXRCb3R0b20oKTtcbiAgfVxuXG4gIGlmIChub2Rlc1swXS5nZXRQYXJlbnQoKS5wYWRkaW5nTGVmdCAhPSB1bmRlZmluZWQpIHtcbiAgICBtYXJnaW4gPSBub2Rlc1swXS5nZXRQYXJlbnQoKS5wYWRkaW5nTGVmdDtcbiAgfSBlbHNlIHtcbiAgICBtYXJnaW4gPSB0aGlzLm1hcmdpbjtcbiAgfVxuXG4gIHRoaXMubGVmdCA9IGJvdW5kaW5nUmVjdC54IC0gbWFyZ2luO1xuICB0aGlzLnJpZ2h0ID0gYm91bmRpbmdSZWN0LnggKyBib3VuZGluZ1JlY3Qud2lkdGggKyBtYXJnaW47XG4gIHRoaXMudG9wID0gYm91bmRpbmdSZWN0LnkgLSBtYXJnaW47XG4gIHRoaXMuYm90dG9tID0gYm91bmRpbmdSZWN0LnkgKyBib3VuZGluZ1JlY3QuaGVpZ2h0ICsgbWFyZ2luO1xufTtcblxuTEdyYXBoLmNhbGN1bGF0ZUJvdW5kcyA9IGZ1bmN0aW9uIChub2Rlcykge1xuICB2YXIgbGVmdCA9IEludGVnZXIuTUFYX1ZBTFVFO1xuICB2YXIgcmlnaHQgPSAtSW50ZWdlci5NQVhfVkFMVUU7XG4gIHZhciB0b3AgPSBJbnRlZ2VyLk1BWF9WQUxVRTtcbiAgdmFyIGJvdHRvbSA9IC1JbnRlZ2VyLk1BWF9WQUxVRTtcbiAgdmFyIG5vZGVMZWZ0O1xuICB2YXIgbm9kZVJpZ2h0O1xuICB2YXIgbm9kZVRvcDtcbiAgdmFyIG5vZGVCb3R0b207XG5cbiAgdmFyIHMgPSBub2Rlcy5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICB2YXIgbE5vZGUgPSBub2Rlc1tpXTtcbiAgICBub2RlTGVmdCA9IGxOb2RlLmdldExlZnQoKTtcbiAgICBub2RlUmlnaHQgPSBsTm9kZS5nZXRSaWdodCgpO1xuICAgIG5vZGVUb3AgPSBsTm9kZS5nZXRUb3AoKTtcbiAgICBub2RlQm90dG9tID0gbE5vZGUuZ2V0Qm90dG9tKCk7XG5cbiAgICBpZiAobGVmdCA+IG5vZGVMZWZ0KSB7XG4gICAgICBsZWZ0ID0gbm9kZUxlZnQ7XG4gICAgfVxuXG4gICAgaWYgKHJpZ2h0IDwgbm9kZVJpZ2h0KSB7XG4gICAgICByaWdodCA9IG5vZGVSaWdodDtcbiAgICB9XG5cbiAgICBpZiAodG9wID4gbm9kZVRvcCkge1xuICAgICAgdG9wID0gbm9kZVRvcDtcbiAgICB9XG5cbiAgICBpZiAoYm90dG9tIDwgbm9kZUJvdHRvbSkge1xuICAgICAgYm90dG9tID0gbm9kZUJvdHRvbTtcbiAgICB9XG4gIH1cblxuICB2YXIgYm91bmRpbmdSZWN0ID0gbmV3IFJlY3RhbmdsZUQobGVmdCwgdG9wLCByaWdodCAtIGxlZnQsIGJvdHRvbSAtIHRvcCk7XG5cbiAgcmV0dXJuIGJvdW5kaW5nUmVjdDtcbn07XG5cbkxHcmFwaC5wcm90b3R5cGUuZ2V0SW5jbHVzaW9uVHJlZURlcHRoID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcyA9PSB0aGlzLmdyYXBoTWFuYWdlci5nZXRSb290KCkpIHtcbiAgICByZXR1cm4gMTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnQuZ2V0SW5jbHVzaW9uVHJlZURlcHRoKCk7XG4gIH1cbn07XG5cbkxHcmFwaC5wcm90b3R5cGUuZ2V0RXN0aW1hdGVkU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuZXN0aW1hdGVkU2l6ZSA9PSBJbnRlZ2VyLk1JTl9WQUxVRSkge1xuICAgIHRocm93IFwiYXNzZXJ0IGZhaWxlZFwiO1xuICB9XG4gIHJldHVybiB0aGlzLmVzdGltYXRlZFNpemU7XG59O1xuXG5MR3JhcGgucHJvdG90eXBlLmNhbGNFc3RpbWF0ZWRTaXplID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2l6ZSA9IDA7XG4gIHZhciBub2RlcyA9IHRoaXMubm9kZXM7XG4gIHZhciBzID0gbm9kZXMubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgdmFyIGxOb2RlID0gbm9kZXNbaV07XG4gICAgc2l6ZSArPSBsTm9kZS5jYWxjRXN0aW1hdGVkU2l6ZSgpO1xuICB9XG5cbiAgaWYgKHNpemUgPT0gMCkge1xuICAgIHRoaXMuZXN0aW1hdGVkU2l6ZSA9IExheW91dENvbnN0YW50cy5FTVBUWV9DT01QT1VORF9OT0RFX1NJWkU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5lc3RpbWF0ZWRTaXplID0gc2l6ZSAvIE1hdGguc3FydCh0aGlzLm5vZGVzLmxlbmd0aCk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5lc3RpbWF0ZWRTaXplO1xufTtcblxuTEdyYXBoLnByb3RvdHlwZS51cGRhdGVDb25uZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKHRoaXMubm9kZXMubGVuZ3RoID09IDApIHtcbiAgICB0aGlzLmlzQ29ubmVjdGVkID0gdHJ1ZTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcXVldWUgPSBuZXcgTGlua2VkTGlzdCgpO1xuICB2YXIgdmlzaXRlZCA9IG5ldyBTZXQoKTtcbiAgdmFyIGN1cnJlbnROb2RlID0gdGhpcy5ub2Rlc1swXTtcbiAgdmFyIG5laWdoYm9yRWRnZXM7XG4gIHZhciBjdXJyZW50TmVpZ2hib3I7XG4gIHZhciBjaGlsZHJlbk9mTm9kZSA9IGN1cnJlbnROb2RlLndpdGhDaGlsZHJlbigpO1xuICBjaGlsZHJlbk9mTm9kZS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgcXVldWUucHVzaChub2RlKTtcbiAgICB2aXNpdGVkLmFkZChub2RlKTtcbiAgfSk7XG5cbiAgd2hpbGUgKHF1ZXVlLmxlbmd0aCAhPT0gMCkge1xuICAgIGN1cnJlbnROb2RlID0gcXVldWUuc2hpZnQoKTtcblxuICAgIC8vIFRyYXZlcnNlIGFsbCBuZWlnaGJvcnMgb2YgdGhpcyBub2RlXG4gICAgbmVpZ2hib3JFZGdlcyA9IGN1cnJlbnROb2RlLmdldEVkZ2VzKCk7XG4gICAgdmFyIHNpemUgPSBuZWlnaGJvckVkZ2VzLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgdmFyIG5laWdoYm9yRWRnZSA9IG5laWdoYm9yRWRnZXNbaV07XG4gICAgICBjdXJyZW50TmVpZ2hib3IgPSBuZWlnaGJvckVkZ2UuZ2V0T3RoZXJFbmRJbkdyYXBoKGN1cnJlbnROb2RlLCB0aGlzKTtcblxuICAgICAgLy8gQWRkIHVudmlzaXRlZCBuZWlnaGJvcnMgdG8gdGhlIGxpc3QgdG8gdmlzaXRcbiAgICAgIGlmIChjdXJyZW50TmVpZ2hib3IgIT0gbnVsbCAmJiAhdmlzaXRlZC5oYXMoY3VycmVudE5laWdoYm9yKSkge1xuICAgICAgICB2YXIgY2hpbGRyZW5PZk5laWdoYm9yID0gY3VycmVudE5laWdoYm9yLndpdGhDaGlsZHJlbigpO1xuXG4gICAgICAgIGNoaWxkcmVuT2ZOZWlnaGJvci5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgcXVldWUucHVzaChub2RlKTtcbiAgICAgICAgICB2aXNpdGVkLmFkZChub2RlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGhpcy5pc0Nvbm5lY3RlZCA9IGZhbHNlO1xuXG4gIGlmICh2aXNpdGVkLnNpemUgPj0gdGhpcy5ub2Rlcy5sZW5ndGgpIHtcbiAgICB2YXIgbm9PZlZpc2l0ZWRJblRoaXNHcmFwaCA9IDA7XG5cbiAgICB2aXNpdGVkLmZvckVhY2goZnVuY3Rpb24gKHZpc2l0ZWROb2RlKSB7XG4gICAgICBpZiAodmlzaXRlZE5vZGUub3duZXIgPT0gc2VsZikge1xuICAgICAgICBub09mVmlzaXRlZEluVGhpc0dyYXBoKys7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAobm9PZlZpc2l0ZWRJblRoaXNHcmFwaCA9PSB0aGlzLm5vZGVzLmxlbmd0aCkge1xuICAgICAgdGhpcy5pc0Nvbm5lY3RlZCA9IHRydWU7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExHcmFwaDtcblxuLyoqKi8gfSksXG4vKiA2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBMR3JhcGg7XG52YXIgTEVkZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG5mdW5jdGlvbiBMR3JhcGhNYW5hZ2VyKGxheW91dCkge1xuICBMR3JhcGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpOyAvLyBJdCBtYXkgYmUgYmV0dGVyIHRvIGluaXRpbGl6ZSB0aGlzIG91dCBvZiB0aGlzIGZ1bmN0aW9uIGJ1dCBpdCBnaXZlcyBhbiBlcnJvciAoUmlnaHQtaGFuZCBzaWRlIG9mICdpbnN0YW5jZW9mJyBpcyBub3QgY2FsbGFibGUpIG5vdy5cbiAgdGhpcy5sYXlvdXQgPSBsYXlvdXQ7XG5cbiAgdGhpcy5ncmFwaHMgPSBbXTtcbiAgdGhpcy5lZGdlcyA9IFtdO1xufVxuXG5MR3JhcGhNYW5hZ2VyLnByb3RvdHlwZS5hZGRSb290ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbmdyYXBoID0gdGhpcy5sYXlvdXQubmV3R3JhcGgoKTtcbiAgdmFyIG5ub2RlID0gdGhpcy5sYXlvdXQubmV3Tm9kZShudWxsKTtcbiAgdmFyIHJvb3QgPSB0aGlzLmFkZChuZ3JhcGgsIG5ub2RlKTtcbiAgdGhpcy5zZXRSb290R3JhcGgocm9vdCk7XG4gIHJldHVybiB0aGlzLnJvb3RHcmFwaDtcbn07XG5cbkxHcmFwaE1hbmFnZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChuZXdHcmFwaCwgcGFyZW50Tm9kZSwgbmV3RWRnZSwgc291cmNlTm9kZSwgdGFyZ2V0Tm9kZSkge1xuICAvL3RoZXJlIGFyZSBqdXN0IDIgcGFyYW1ldGVycyBhcmUgcGFzc2VkIHRoZW4gaXQgYWRkcyBhbiBMR3JhcGggZWxzZSBpdCBhZGRzIGFuIExFZGdlXG4gIGlmIChuZXdFZGdlID09IG51bGwgJiYgc291cmNlTm9kZSA9PSBudWxsICYmIHRhcmdldE5vZGUgPT0gbnVsbCkge1xuICAgIGlmIChuZXdHcmFwaCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBcIkdyYXBoIGlzIG51bGwhXCI7XG4gICAgfVxuICAgIGlmIChwYXJlbnROb2RlID09IG51bGwpIHtcbiAgICAgIHRocm93IFwiUGFyZW50IG5vZGUgaXMgbnVsbCFcIjtcbiAgICB9XG4gICAgaWYgKHRoaXMuZ3JhcGhzLmluZGV4T2YobmV3R3JhcGgpID4gLTEpIHtcbiAgICAgIHRocm93IFwiR3JhcGggYWxyZWFkeSBpbiB0aGlzIGdyYXBoIG1nciFcIjtcbiAgICB9XG5cbiAgICB0aGlzLmdyYXBocy5wdXNoKG5ld0dyYXBoKTtcblxuICAgIGlmIChuZXdHcmFwaC5wYXJlbnQgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgXCJBbHJlYWR5IGhhcyBhIHBhcmVudCFcIjtcbiAgICB9XG4gICAgaWYgKHBhcmVudE5vZGUuY2hpbGQgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgXCJBbHJlYWR5IGhhcyBhIGNoaWxkIVwiO1xuICAgIH1cblxuICAgIG5ld0dyYXBoLnBhcmVudCA9IHBhcmVudE5vZGU7XG4gICAgcGFyZW50Tm9kZS5jaGlsZCA9IG5ld0dyYXBoO1xuXG4gICAgcmV0dXJuIG5ld0dyYXBoO1xuICB9IGVsc2Uge1xuICAgIC8vY2hhbmdlIHRoZSBvcmRlciBvZiB0aGUgcGFyYW1ldGVyc1xuICAgIHRhcmdldE5vZGUgPSBuZXdFZGdlO1xuICAgIHNvdXJjZU5vZGUgPSBwYXJlbnROb2RlO1xuICAgIG5ld0VkZ2UgPSBuZXdHcmFwaDtcbiAgICB2YXIgc291cmNlR3JhcGggPSBzb3VyY2VOb2RlLmdldE93bmVyKCk7XG4gICAgdmFyIHRhcmdldEdyYXBoID0gdGFyZ2V0Tm9kZS5nZXRPd25lcigpO1xuXG4gICAgaWYgKCEoc291cmNlR3JhcGggIT0gbnVsbCAmJiBzb3VyY2VHcmFwaC5nZXRHcmFwaE1hbmFnZXIoKSA9PSB0aGlzKSkge1xuICAgICAgdGhyb3cgXCJTb3VyY2Ugbm90IGluIHRoaXMgZ3JhcGggbWdyIVwiO1xuICAgIH1cbiAgICBpZiAoISh0YXJnZXRHcmFwaCAhPSBudWxsICYmIHRhcmdldEdyYXBoLmdldEdyYXBoTWFuYWdlcigpID09IHRoaXMpKSB7XG4gICAgICB0aHJvdyBcIlRhcmdldCBub3QgaW4gdGhpcyBncmFwaCBtZ3IhXCI7XG4gICAgfVxuXG4gICAgaWYgKHNvdXJjZUdyYXBoID09IHRhcmdldEdyYXBoKSB7XG4gICAgICBuZXdFZGdlLmlzSW50ZXJHcmFwaCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHNvdXJjZUdyYXBoLmFkZChuZXdFZGdlLCBzb3VyY2VOb2RlLCB0YXJnZXROb2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3RWRnZS5pc0ludGVyR3JhcGggPSB0cnVlO1xuXG4gICAgICAvLyBzZXQgc291cmNlIGFuZCB0YXJnZXRcbiAgICAgIG5ld0VkZ2Uuc291cmNlID0gc291cmNlTm9kZTtcbiAgICAgIG5ld0VkZ2UudGFyZ2V0ID0gdGFyZ2V0Tm9kZTtcblxuICAgICAgLy8gYWRkIGVkZ2UgdG8gaW50ZXItZ3JhcGggZWRnZSBsaXN0XG4gICAgICBpZiAodGhpcy5lZGdlcy5pbmRleE9mKG5ld0VkZ2UpID4gLTEpIHtcbiAgICAgICAgdGhyb3cgXCJFZGdlIGFscmVhZHkgaW4gaW50ZXItZ3JhcGggZWRnZSBsaXN0IVwiO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmVkZ2VzLnB1c2gobmV3RWRnZSk7XG5cbiAgICAgIC8vIGFkZCBlZGdlIHRvIHNvdXJjZSBhbmQgdGFyZ2V0IGluY2lkZW5jeSBsaXN0c1xuICAgICAgaWYgKCEobmV3RWRnZS5zb3VyY2UgIT0gbnVsbCAmJiBuZXdFZGdlLnRhcmdldCAhPSBudWxsKSkge1xuICAgICAgICB0aHJvdyBcIkVkZ2Ugc291cmNlIGFuZC9vciB0YXJnZXQgaXMgbnVsbCFcIjtcbiAgICAgIH1cblxuICAgICAgaWYgKCEobmV3RWRnZS5zb3VyY2UuZWRnZXMuaW5kZXhPZihuZXdFZGdlKSA9PSAtMSAmJiBuZXdFZGdlLnRhcmdldC5lZGdlcy5pbmRleE9mKG5ld0VkZ2UpID09IC0xKSkge1xuICAgICAgICB0aHJvdyBcIkVkZ2UgYWxyZWFkeSBpbiBzb3VyY2UgYW5kL29yIHRhcmdldCBpbmNpZGVuY3kgbGlzdCFcIjtcbiAgICAgIH1cblxuICAgICAgbmV3RWRnZS5zb3VyY2UuZWRnZXMucHVzaChuZXdFZGdlKTtcbiAgICAgIG5ld0VkZ2UudGFyZ2V0LmVkZ2VzLnB1c2gobmV3RWRnZSk7XG5cbiAgICAgIHJldHVybiBuZXdFZGdlO1xuICAgIH1cbiAgfVxufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGxPYmopIHtcbiAgaWYgKGxPYmogaW5zdGFuY2VvZiBMR3JhcGgpIHtcbiAgICB2YXIgZ3JhcGggPSBsT2JqO1xuICAgIGlmIChncmFwaC5nZXRHcmFwaE1hbmFnZXIoKSAhPSB0aGlzKSB7XG4gICAgICB0aHJvdyBcIkdyYXBoIG5vdCBpbiB0aGlzIGdyYXBoIG1nclwiO1xuICAgIH1cbiAgICBpZiAoIShncmFwaCA9PSB0aGlzLnJvb3RHcmFwaCB8fCBncmFwaC5wYXJlbnQgIT0gbnVsbCAmJiBncmFwaC5wYXJlbnQuZ3JhcGhNYW5hZ2VyID09IHRoaXMpKSB7XG4gICAgICB0aHJvdyBcIkludmFsaWQgcGFyZW50IG5vZGUhXCI7XG4gICAgfVxuXG4gICAgLy8gZmlyc3QgdGhlIGVkZ2VzIChtYWtlIGEgY29weSB0byBkbyBpdCBzYWZlbHkpXG4gICAgdmFyIGVkZ2VzVG9CZVJlbW92ZWQgPSBbXTtcblxuICAgIGVkZ2VzVG9CZVJlbW92ZWQgPSBlZGdlc1RvQmVSZW1vdmVkLmNvbmNhdChncmFwaC5nZXRFZGdlcygpKTtcblxuICAgIHZhciBlZGdlO1xuICAgIHZhciBzID0gZWRnZXNUb0JlUmVtb3ZlZC5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICAgIGVkZ2UgPSBlZGdlc1RvQmVSZW1vdmVkW2ldO1xuICAgICAgZ3JhcGgucmVtb3ZlKGVkZ2UpO1xuICAgIH1cblxuICAgIC8vIHRoZW4gdGhlIG5vZGVzIChtYWtlIGEgY29weSB0byBkbyBpdCBzYWZlbHkpXG4gICAgdmFyIG5vZGVzVG9CZVJlbW92ZWQgPSBbXTtcblxuICAgIG5vZGVzVG9CZVJlbW92ZWQgPSBub2Rlc1RvQmVSZW1vdmVkLmNvbmNhdChncmFwaC5nZXROb2RlcygpKTtcblxuICAgIHZhciBub2RlO1xuICAgIHMgPSBub2Rlc1RvQmVSZW1vdmVkLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKykge1xuICAgICAgbm9kZSA9IG5vZGVzVG9CZVJlbW92ZWRbaV07XG4gICAgICBncmFwaC5yZW1vdmUobm9kZSk7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgaWYgZ3JhcGggaXMgdGhlIHJvb3RcbiAgICBpZiAoZ3JhcGggPT0gdGhpcy5yb290R3JhcGgpIHtcbiAgICAgIHRoaXMuc2V0Um9vdEdyYXBoKG51bGwpO1xuICAgIH1cblxuICAgIC8vIG5vdyByZW1vdmUgdGhlIGdyYXBoIGl0c2VsZlxuICAgIHZhciBpbmRleCA9IHRoaXMuZ3JhcGhzLmluZGV4T2YoZ3JhcGgpO1xuICAgIHRoaXMuZ3JhcGhzLnNwbGljZShpbmRleCwgMSk7XG5cbiAgICAvLyBhbHNvIHJlc2V0IHRoZSBwYXJlbnQgb2YgdGhlIGdyYXBoXG4gICAgZ3JhcGgucGFyZW50ID0gbnVsbDtcbiAgfSBlbHNlIGlmIChsT2JqIGluc3RhbmNlb2YgTEVkZ2UpIHtcbiAgICBlZGdlID0gbE9iajtcbiAgICBpZiAoZWRnZSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBcIkVkZ2UgaXMgbnVsbCFcIjtcbiAgICB9XG4gICAgaWYgKCFlZGdlLmlzSW50ZXJHcmFwaCkge1xuICAgICAgdGhyb3cgXCJOb3QgYW4gaW50ZXItZ3JhcGggZWRnZSFcIjtcbiAgICB9XG4gICAgaWYgKCEoZWRnZS5zb3VyY2UgIT0gbnVsbCAmJiBlZGdlLnRhcmdldCAhPSBudWxsKSkge1xuICAgICAgdGhyb3cgXCJTb3VyY2UgYW5kL29yIHRhcmdldCBpcyBudWxsIVwiO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSBlZGdlIGZyb20gc291cmNlIGFuZCB0YXJnZXQgbm9kZXMnIGluY2lkZW5jeSBsaXN0c1xuXG4gICAgaWYgKCEoZWRnZS5zb3VyY2UuZWRnZXMuaW5kZXhPZihlZGdlKSAhPSAtMSAmJiBlZGdlLnRhcmdldC5lZGdlcy5pbmRleE9mKGVkZ2UpICE9IC0xKSkge1xuICAgICAgdGhyb3cgXCJTb3VyY2UgYW5kL29yIHRhcmdldCBkb2Vzbid0IGtub3cgdGhpcyBlZGdlIVwiO1xuICAgIH1cblxuICAgIHZhciBpbmRleCA9IGVkZ2Uuc291cmNlLmVkZ2VzLmluZGV4T2YoZWRnZSk7XG4gICAgZWRnZS5zb3VyY2UuZWRnZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICBpbmRleCA9IGVkZ2UudGFyZ2V0LmVkZ2VzLmluZGV4T2YoZWRnZSk7XG4gICAgZWRnZS50YXJnZXQuZWRnZXMuc3BsaWNlKGluZGV4LCAxKTtcblxuICAgIC8vIHJlbW92ZSBlZGdlIGZyb20gb3duZXIgZ3JhcGggbWFuYWdlcidzIGludGVyLWdyYXBoIGVkZ2UgbGlzdFxuXG4gICAgaWYgKCEoZWRnZS5zb3VyY2Uub3duZXIgIT0gbnVsbCAmJiBlZGdlLnNvdXJjZS5vd25lci5nZXRHcmFwaE1hbmFnZXIoKSAhPSBudWxsKSkge1xuICAgICAgdGhyb3cgXCJFZGdlIG93bmVyIGdyYXBoIG9yIG93bmVyIGdyYXBoIG1hbmFnZXIgaXMgbnVsbCFcIjtcbiAgICB9XG4gICAgaWYgKGVkZ2Uuc291cmNlLm93bmVyLmdldEdyYXBoTWFuYWdlcigpLmVkZ2VzLmluZGV4T2YoZWRnZSkgPT0gLTEpIHtcbiAgICAgIHRocm93IFwiTm90IGluIG93bmVyIGdyYXBoIG1hbmFnZXIncyBlZGdlIGxpc3QhXCI7XG4gICAgfVxuXG4gICAgdmFyIGluZGV4ID0gZWRnZS5zb3VyY2Uub3duZXIuZ2V0R3JhcGhNYW5hZ2VyKCkuZWRnZXMuaW5kZXhPZihlZGdlKTtcbiAgICBlZGdlLnNvdXJjZS5vd25lci5nZXRHcmFwaE1hbmFnZXIoKS5lZGdlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICB9XG59O1xuXG5MR3JhcGhNYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVCb3VuZHMgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucm9vdEdyYXBoLnVwZGF0ZUJvdW5kcyh0cnVlKTtcbn07XG5cbkxHcmFwaE1hbmFnZXIucHJvdG90eXBlLmdldEdyYXBocyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZ3JhcGhzO1xufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUuZ2V0QWxsTm9kZXMgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmFsbE5vZGVzID09IG51bGwpIHtcbiAgICB2YXIgbm9kZUxpc3QgPSBbXTtcbiAgICB2YXIgZ3JhcGhzID0gdGhpcy5nZXRHcmFwaHMoKTtcbiAgICB2YXIgcyA9IGdyYXBocy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICAgIG5vZGVMaXN0ID0gbm9kZUxpc3QuY29uY2F0KGdyYXBoc1tpXS5nZXROb2RlcygpKTtcbiAgICB9XG4gICAgdGhpcy5hbGxOb2RlcyA9IG5vZGVMaXN0O1xuICB9XG4gIHJldHVybiB0aGlzLmFsbE5vZGVzO1xufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUucmVzZXRBbGxOb2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5hbGxOb2RlcyA9IG51bGw7XG59O1xuXG5MR3JhcGhNYW5hZ2VyLnByb3RvdHlwZS5yZXNldEFsbEVkZ2VzID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmFsbEVkZ2VzID0gbnVsbDtcbn07XG5cbkxHcmFwaE1hbmFnZXIucHJvdG90eXBlLnJlc2V0QWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuYWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24gPSBudWxsO1xufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUuZ2V0QWxsRWRnZXMgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmFsbEVkZ2VzID09IG51bGwpIHtcbiAgICB2YXIgZWRnZUxpc3QgPSBbXTtcbiAgICB2YXIgZ3JhcGhzID0gdGhpcy5nZXRHcmFwaHMoKTtcbiAgICB2YXIgcyA9IGdyYXBocy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncmFwaHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGVkZ2VMaXN0ID0gZWRnZUxpc3QuY29uY2F0KGdyYXBoc1tpXS5nZXRFZGdlcygpKTtcbiAgICB9XG5cbiAgICBlZGdlTGlzdCA9IGVkZ2VMaXN0LmNvbmNhdCh0aGlzLmVkZ2VzKTtcblxuICAgIHRoaXMuYWxsRWRnZXMgPSBlZGdlTGlzdDtcbiAgfVxuICByZXR1cm4gdGhpcy5hbGxFZGdlcztcbn07XG5cbkxHcmFwaE1hbmFnZXIucHJvdG90eXBlLmdldEFsbE5vZGVzVG9BcHBseUdyYXZpdGF0aW9uID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5hbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbjtcbn07XG5cbkxHcmFwaE1hbmFnZXIucHJvdG90eXBlLnNldEFsbE5vZGVzVG9BcHBseUdyYXZpdGF0aW9uID0gZnVuY3Rpb24gKG5vZGVMaXN0KSB7XG4gIGlmICh0aGlzLmFsbE5vZGVzVG9BcHBseUdyYXZpdGF0aW9uICE9IG51bGwpIHtcbiAgICB0aHJvdyBcImFzc2VydCBmYWlsZWRcIjtcbiAgfVxuXG4gIHRoaXMuYWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24gPSBub2RlTGlzdDtcbn07XG5cbkxHcmFwaE1hbmFnZXIucHJvdG90eXBlLmdldFJvb3QgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnJvb3RHcmFwaDtcbn07XG5cbkxHcmFwaE1hbmFnZXIucHJvdG90eXBlLnNldFJvb3RHcmFwaCA9IGZ1bmN0aW9uIChncmFwaCkge1xuICBpZiAoZ3JhcGguZ2V0R3JhcGhNYW5hZ2VyKCkgIT0gdGhpcykge1xuICAgIHRocm93IFwiUm9vdCBub3QgaW4gdGhpcyBncmFwaCBtZ3IhXCI7XG4gIH1cblxuICB0aGlzLnJvb3RHcmFwaCA9IGdyYXBoO1xuICAvLyByb290IGdyYXBoIG11c3QgaGF2ZSBhIHJvb3Qgbm9kZSBhc3NvY2lhdGVkIHdpdGggaXQgZm9yIGNvbnZlbmllbmNlXG4gIGlmIChncmFwaC5wYXJlbnQgPT0gbnVsbCkge1xuICAgIGdyYXBoLnBhcmVudCA9IHRoaXMubGF5b3V0Lm5ld05vZGUoXCJSb290IG5vZGVcIik7XG4gIH1cbn07XG5cbkxHcmFwaE1hbmFnZXIucHJvdG90eXBlLmdldExheW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubGF5b3V0O1xufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUuaXNPbmVBbmNlc3Rvck9mT3RoZXIgPSBmdW5jdGlvbiAoZmlyc3ROb2RlLCBzZWNvbmROb2RlKSB7XG4gIGlmICghKGZpcnN0Tm9kZSAhPSBudWxsICYmIHNlY29uZE5vZGUgIT0gbnVsbCkpIHtcbiAgICB0aHJvdyBcImFzc2VydCBmYWlsZWRcIjtcbiAgfVxuXG4gIGlmIChmaXJzdE5vZGUgPT0gc2Vjb25kTm9kZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8vIElzIHNlY29uZCBub2RlIGFuIGFuY2VzdG9yIG9mIHRoZSBmaXJzdCBvbmU/XG4gIHZhciBvd25lckdyYXBoID0gZmlyc3ROb2RlLmdldE93bmVyKCk7XG4gIHZhciBwYXJlbnROb2RlO1xuXG4gIGRvIHtcbiAgICBwYXJlbnROb2RlID0gb3duZXJHcmFwaC5nZXRQYXJlbnQoKTtcblxuICAgIGlmIChwYXJlbnROb2RlID09IG51bGwpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChwYXJlbnROb2RlID09IHNlY29uZE5vZGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIG93bmVyR3JhcGggPSBwYXJlbnROb2RlLmdldE93bmVyKCk7XG4gICAgaWYgKG93bmVyR3JhcGggPT0gbnVsbCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9IHdoaWxlICh0cnVlKTtcbiAgLy8gSXMgZmlyc3Qgbm9kZSBhbiBhbmNlc3RvciBvZiB0aGUgc2Vjb25kIG9uZT9cbiAgb3duZXJHcmFwaCA9IHNlY29uZE5vZGUuZ2V0T3duZXIoKTtcblxuICBkbyB7XG4gICAgcGFyZW50Tm9kZSA9IG93bmVyR3JhcGguZ2V0UGFyZW50KCk7XG5cbiAgICBpZiAocGFyZW50Tm9kZSA9PSBudWxsKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAocGFyZW50Tm9kZSA9PSBmaXJzdE5vZGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIG93bmVyR3JhcGggPSBwYXJlbnROb2RlLmdldE93bmVyKCk7XG4gICAgaWYgKG93bmVyR3JhcGggPT0gbnVsbCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9IHdoaWxlICh0cnVlKTtcblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5MR3JhcGhNYW5hZ2VyLnByb3RvdHlwZS5jYWxjTG93ZXN0Q29tbW9uQW5jZXN0b3JzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZWRnZTtcbiAgdmFyIHNvdXJjZU5vZGU7XG4gIHZhciB0YXJnZXROb2RlO1xuICB2YXIgc291cmNlQW5jZXN0b3JHcmFwaDtcbiAgdmFyIHRhcmdldEFuY2VzdG9yR3JhcGg7XG5cbiAgdmFyIGVkZ2VzID0gdGhpcy5nZXRBbGxFZGdlcygpO1xuICB2YXIgcyA9IGVkZ2VzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICBlZGdlID0gZWRnZXNbaV07XG5cbiAgICBzb3VyY2VOb2RlID0gZWRnZS5zb3VyY2U7XG4gICAgdGFyZ2V0Tm9kZSA9IGVkZ2UudGFyZ2V0O1xuICAgIGVkZ2UubGNhID0gbnVsbDtcbiAgICBlZGdlLnNvdXJjZUluTGNhID0gc291cmNlTm9kZTtcbiAgICBlZGdlLnRhcmdldEluTGNhID0gdGFyZ2V0Tm9kZTtcblxuICAgIGlmIChzb3VyY2VOb2RlID09IHRhcmdldE5vZGUpIHtcbiAgICAgIGVkZ2UubGNhID0gc291cmNlTm9kZS5nZXRPd25lcigpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgc291cmNlQW5jZXN0b3JHcmFwaCA9IHNvdXJjZU5vZGUuZ2V0T3duZXIoKTtcblxuICAgIHdoaWxlIChlZGdlLmxjYSA9PSBudWxsKSB7XG4gICAgICBlZGdlLnRhcmdldEluTGNhID0gdGFyZ2V0Tm9kZTtcbiAgICAgIHRhcmdldEFuY2VzdG9yR3JhcGggPSB0YXJnZXROb2RlLmdldE93bmVyKCk7XG5cbiAgICAgIHdoaWxlIChlZGdlLmxjYSA9PSBudWxsKSB7XG4gICAgICAgIGlmICh0YXJnZXRBbmNlc3RvckdyYXBoID09IHNvdXJjZUFuY2VzdG9yR3JhcGgpIHtcbiAgICAgICAgICBlZGdlLmxjYSA9IHRhcmdldEFuY2VzdG9yR3JhcGg7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGFyZ2V0QW5jZXN0b3JHcmFwaCA9PSB0aGlzLnJvb3RHcmFwaCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVkZ2UubGNhICE9IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBcImFzc2VydCBmYWlsZWRcIjtcbiAgICAgICAgfVxuICAgICAgICBlZGdlLnRhcmdldEluTGNhID0gdGFyZ2V0QW5jZXN0b3JHcmFwaC5nZXRQYXJlbnQoKTtcbiAgICAgICAgdGFyZ2V0QW5jZXN0b3JHcmFwaCA9IGVkZ2UudGFyZ2V0SW5MY2EuZ2V0T3duZXIoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNvdXJjZUFuY2VzdG9yR3JhcGggPT0gdGhpcy5yb290R3JhcGgpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChlZGdlLmxjYSA9PSBudWxsKSB7XG4gICAgICAgIGVkZ2Uuc291cmNlSW5MY2EgPSBzb3VyY2VBbmNlc3RvckdyYXBoLmdldFBhcmVudCgpO1xuICAgICAgICBzb3VyY2VBbmNlc3RvckdyYXBoID0gZWRnZS5zb3VyY2VJbkxjYS5nZXRPd25lcigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlZGdlLmxjYSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBcImFzc2VydCBmYWlsZWRcIjtcbiAgICB9XG4gIH1cbn07XG5cbkxHcmFwaE1hbmFnZXIucHJvdG90eXBlLmNhbGNMb3dlc3RDb21tb25BbmNlc3RvciA9IGZ1bmN0aW9uIChmaXJzdE5vZGUsIHNlY29uZE5vZGUpIHtcbiAgaWYgKGZpcnN0Tm9kZSA9PSBzZWNvbmROb2RlKSB7XG4gICAgcmV0dXJuIGZpcnN0Tm9kZS5nZXRPd25lcigpO1xuICB9XG4gIHZhciBmaXJzdE93bmVyR3JhcGggPSBmaXJzdE5vZGUuZ2V0T3duZXIoKTtcblxuICBkbyB7XG4gICAgaWYgKGZpcnN0T3duZXJHcmFwaCA9PSBudWxsKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdmFyIHNlY29uZE93bmVyR3JhcGggPSBzZWNvbmROb2RlLmdldE93bmVyKCk7XG5cbiAgICBkbyB7XG4gICAgICBpZiAoc2Vjb25kT3duZXJHcmFwaCA9PSBudWxsKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2Vjb25kT3duZXJHcmFwaCA9PSBmaXJzdE93bmVyR3JhcGgpIHtcbiAgICAgICAgcmV0dXJuIHNlY29uZE93bmVyR3JhcGg7XG4gICAgICB9XG4gICAgICBzZWNvbmRPd25lckdyYXBoID0gc2Vjb25kT3duZXJHcmFwaC5nZXRQYXJlbnQoKS5nZXRPd25lcigpO1xuICAgIH0gd2hpbGUgKHRydWUpO1xuXG4gICAgZmlyc3RPd25lckdyYXBoID0gZmlyc3RPd25lckdyYXBoLmdldFBhcmVudCgpLmdldE93bmVyKCk7XG4gIH0gd2hpbGUgKHRydWUpO1xuXG4gIHJldHVybiBmaXJzdE93bmVyR3JhcGg7XG59O1xuXG5MR3JhcGhNYW5hZ2VyLnByb3RvdHlwZS5jYWxjSW5jbHVzaW9uVHJlZURlcHRocyA9IGZ1bmN0aW9uIChncmFwaCwgZGVwdGgpIHtcbiAgaWYgKGdyYXBoID09IG51bGwgJiYgZGVwdGggPT0gbnVsbCkge1xuICAgIGdyYXBoID0gdGhpcy5yb290R3JhcGg7XG4gICAgZGVwdGggPSAxO1xuICB9XG4gIHZhciBub2RlO1xuXG4gIHZhciBub2RlcyA9IGdyYXBoLmdldE5vZGVzKCk7XG4gIHZhciBzID0gbm9kZXMubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKykge1xuICAgIG5vZGUgPSBub2Rlc1tpXTtcbiAgICBub2RlLmluY2x1c2lvblRyZWVEZXB0aCA9IGRlcHRoO1xuXG4gICAgaWYgKG5vZGUuY2hpbGQgIT0gbnVsbCkge1xuICAgICAgdGhpcy5jYWxjSW5jbHVzaW9uVHJlZURlcHRocyhub2RlLmNoaWxkLCBkZXB0aCArIDEpO1xuICAgIH1cbiAgfVxufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUuaW5jbHVkZXNJbnZhbGlkRWRnZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVkZ2U7XG5cbiAgdmFyIHMgPSB0aGlzLmVkZ2VzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICBlZGdlID0gdGhpcy5lZGdlc1tpXTtcblxuICAgIGlmICh0aGlzLmlzT25lQW5jZXN0b3JPZk90aGVyKGVkZ2Uuc291cmNlLCBlZGdlLnRhcmdldCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExHcmFwaE1hbmFnZXI7XG5cbi8qKiovIH0pLFxuLyogNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgTGF5b3V0Q29uc3RhbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuZnVuY3Rpb24gRkRMYXlvdXRDb25zdGFudHMoKSB7fVxuXG4vL0ZETGF5b3V0Q29uc3RhbnRzIGluaGVyaXRzIHN0YXRpYyBwcm9wcyBpbiBMYXlvdXRDb25zdGFudHNcbmZvciAodmFyIHByb3AgaW4gTGF5b3V0Q29uc3RhbnRzKSB7XG4gIEZETGF5b3V0Q29uc3RhbnRzW3Byb3BdID0gTGF5b3V0Q29uc3RhbnRzW3Byb3BdO1xufVxuXG5GRExheW91dENvbnN0YW50cy5NQVhfSVRFUkFUSU9OUyA9IDI1MDA7XG5cbkZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggPSA1MDtcbkZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfU1BSSU5HX1NUUkVOR1RIID0gMC40NTtcbkZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfUkVQVUxTSU9OX1NUUkVOR1RIID0gNDUwMC4wO1xuRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9HUkFWSVRZX1NUUkVOR1RIID0gMC40O1xuRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9DT01QT1VORF9HUkFWSVRZX1NUUkVOR1RIID0gMS4wO1xuRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9HUkFWSVRZX1JBTkdFX0ZBQ1RPUiA9IDMuODtcbkZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQ09NUE9VTkRfR1JBVklUWV9SQU5HRV9GQUNUT1IgPSAxLjU7XG5GRExheW91dENvbnN0YW50cy5ERUZBVUxUX1VTRV9TTUFSVF9JREVBTF9FREdFX0xFTkdUSF9DQUxDVUxBVElPTiA9IHRydWU7XG5GRExheW91dENvbnN0YW50cy5ERUZBVUxUX1VTRV9TTUFSVF9SRVBVTFNJT05fUkFOR0VfQ0FMQ1VMQVRJT04gPSB0cnVlO1xuRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9DT09MSU5HX0ZBQ1RPUl9JTkNSRU1FTlRBTCA9IDAuMztcbkZETGF5b3V0Q29uc3RhbnRzLkNPT0xJTkdfQURBUFRBVElPTl9GQUNUT1IgPSAwLjMzO1xuRkRMYXlvdXRDb25zdGFudHMuQURBUFRBVElPTl9MT1dFUl9OT0RFX0xJTUlUID0gMTAwMDtcbkZETGF5b3V0Q29uc3RhbnRzLkFEQVBUQVRJT05fVVBQRVJfTk9ERV9MSU1JVCA9IDUwMDA7XG5GRExheW91dENvbnN0YW50cy5NQVhfTk9ERV9ESVNQTEFDRU1FTlRfSU5DUkVNRU5UQUwgPSAxMDAuMDtcbkZETGF5b3V0Q29uc3RhbnRzLk1BWF9OT0RFX0RJU1BMQUNFTUVOVCA9IEZETGF5b3V0Q29uc3RhbnRzLk1BWF9OT0RFX0RJU1BMQUNFTUVOVF9JTkNSRU1FTlRBTCAqIDM7XG5GRExheW91dENvbnN0YW50cy5NSU5fUkVQVUxTSU9OX0RJU1QgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIIC8gMTAuMDtcbkZETGF5b3V0Q29uc3RhbnRzLkNPTlZFUkdFTkNFX0NIRUNLX1BFUklPRCA9IDEwMDtcbkZETGF5b3V0Q29uc3RhbnRzLlBFUl9MRVZFTF9JREVBTF9FREdFX0xFTkdUSF9GQUNUT1IgPSAwLjE7XG5GRExheW91dENvbnN0YW50cy5NSU5fRURHRV9MRU5HVEggPSAxO1xuRkRMYXlvdXRDb25zdGFudHMuR1JJRF9DQUxDVUxBVElPTl9DSEVDS19QRVJJT0QgPSAxMDtcblxubW9kdWxlLmV4cG9ydHMgPSBGRExheW91dENvbnN0YW50cztcblxuLyoqKi8gfSksXG4vKiA4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qKlxuICogVGhpcyBjbGFzcyBtYWludGFpbnMgYSBsaXN0IG9mIHN0YXRpYyBnZW9tZXRyeSByZWxhdGVkIHV0aWxpdHkgbWV0aG9kcy5cbiAqXG4gKlxuICogQ29weXJpZ2h0OiBpLVZpcyBSZXNlYXJjaCBHcm91cCwgQmlsa2VudCBVbml2ZXJzaXR5LCAyMDA3IC0gcHJlc2VudFxuICovXG5cbnZhciBQb2ludCA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xuXG5mdW5jdGlvbiBJR2VvbWV0cnkoKSB7fVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGNhbGN1bGF0ZXMgKmhhbGYqIHRoZSBhbW91bnQgaW4geCBhbmQgeSBkaXJlY3Rpb25zIG9mIHRoZSB0d29cbiAqIGlucHV0IHJlY3RhbmdsZXMgbmVlZGVkIHRvIHNlcGFyYXRlIHRoZW0ga2VlcGluZyB0aGVpciByZXNwZWN0aXZlXG4gKiBwb3NpdGlvbmluZywgYW5kIHJldHVybnMgdGhlIHJlc3VsdCBpbiB0aGUgaW5wdXQgYXJyYXkuIEFuIGlucHV0XG4gKiBzZXBhcmF0aW9uIGJ1ZmZlciBhZGRlZCB0byB0aGUgYW1vdW50IGluIGJvdGggZGlyZWN0aW9ucy4gV2UgYXNzdW1lIHRoYXRcbiAqIHRoZSB0d28gcmVjdGFuZ2xlcyBkbyBpbnRlcnNlY3QuXG4gKi9cbklHZW9tZXRyeS5jYWxjU2VwYXJhdGlvbkFtb3VudCA9IGZ1bmN0aW9uIChyZWN0QSwgcmVjdEIsIG92ZXJsYXBBbW91bnQsIHNlcGFyYXRpb25CdWZmZXIpIHtcbiAgaWYgKCFyZWN0QS5pbnRlcnNlY3RzKHJlY3RCKSkge1xuICAgIHRocm93IFwiYXNzZXJ0IGZhaWxlZFwiO1xuICB9XG5cbiAgdmFyIGRpcmVjdGlvbnMgPSBuZXcgQXJyYXkoMik7XG5cbiAgdGhpcy5kZWNpZGVEaXJlY3Rpb25zRm9yT3ZlcmxhcHBpbmdOb2RlcyhyZWN0QSwgcmVjdEIsIGRpcmVjdGlvbnMpO1xuXG4gIG92ZXJsYXBBbW91bnRbMF0gPSBNYXRoLm1pbihyZWN0QS5nZXRSaWdodCgpLCByZWN0Qi5nZXRSaWdodCgpKSAtIE1hdGgubWF4KHJlY3RBLngsIHJlY3RCLngpO1xuICBvdmVybGFwQW1vdW50WzFdID0gTWF0aC5taW4ocmVjdEEuZ2V0Qm90dG9tKCksIHJlY3RCLmdldEJvdHRvbSgpKSAtIE1hdGgubWF4KHJlY3RBLnksIHJlY3RCLnkpO1xuXG4gIC8vIHVwZGF0ZSB0aGUgb3ZlcmxhcHBpbmcgYW1vdW50cyBmb3IgdGhlIGZvbGxvd2luZyBjYXNlczpcbiAgaWYgKHJlY3RBLmdldFgoKSA8PSByZWN0Qi5nZXRYKCkgJiYgcmVjdEEuZ2V0UmlnaHQoKSA+PSByZWN0Qi5nZXRSaWdodCgpKSB7XG4gICAgLyogQ2FzZSB4LjE6XG4gICAgKlxuICAgICogcmVjdEFcbiAgICAqIFx0fCAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICogXHR8ICAgICAgICBfX19fX19fX18gICAgICB8XG4gICAgKiBcdHwgICAgICAgIHwgICAgICAgfCAgICAgIHxcbiAgICAqIFx0fF9fX19fX19ffF9fX19fX198X19fX19ffFxuICAgICogXHRcdFx0IHwgICAgICAgfFxuICAgICogICAgICAgICAgIHwgICAgICAgfFxuICAgICogICAgICAgIHJlY3RCXG4gICAgKi9cbiAgICBvdmVybGFwQW1vdW50WzBdICs9IE1hdGgubWluKHJlY3RCLmdldFgoKSAtIHJlY3RBLmdldFgoKSwgcmVjdEEuZ2V0UmlnaHQoKSAtIHJlY3RCLmdldFJpZ2h0KCkpO1xuICB9IGVsc2UgaWYgKHJlY3RCLmdldFgoKSA8PSByZWN0QS5nZXRYKCkgJiYgcmVjdEIuZ2V0UmlnaHQoKSA+PSByZWN0QS5nZXRSaWdodCgpKSB7XG4gICAgLyogQ2FzZSB4LjI6XG4gICAgKlxuICAgICogcmVjdEJcbiAgICAqIFx0fCAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICogXHR8ICAgICAgICBfX19fX19fX18gICAgICB8XG4gICAgKiBcdHwgICAgICAgIHwgICAgICAgfCAgICAgIHxcbiAgICAqIFx0fF9fX19fX19ffF9fX19fX198X19fX19ffFxuICAgICogXHRcdFx0IHwgICAgICAgfFxuICAgICogICAgICAgICAgIHwgICAgICAgfFxuICAgICogICAgICAgIHJlY3RBXG4gICAgKi9cbiAgICBvdmVybGFwQW1vdW50WzBdICs9IE1hdGgubWluKHJlY3RBLmdldFgoKSAtIHJlY3RCLmdldFgoKSwgcmVjdEIuZ2V0UmlnaHQoKSAtIHJlY3RBLmdldFJpZ2h0KCkpO1xuICB9XG4gIGlmIChyZWN0QS5nZXRZKCkgPD0gcmVjdEIuZ2V0WSgpICYmIHJlY3RBLmdldEJvdHRvbSgpID49IHJlY3RCLmdldEJvdHRvbSgpKSB7XG4gICAgLyogQ2FzZSB5LjE6XG4gICAgICogICAgICAgICAgX19fX19fX18gcmVjdEFcbiAgICAgKiAgICAgICAgIHxcbiAgICAgKiAgICAgICAgIHxcbiAgICAgKiAgIF9fX19fX3xfX19fICByZWN0QlxuICAgICAqICAgICAgICAgfCAgICB8XG4gICAgICogICAgICAgICB8ICAgIHxcbiAgICAgKiAgIF9fX19fX3xfX19ffFxuICAgICAqICAgICAgICAgfFxuICAgICAqICAgICAgICAgfFxuICAgICAqICAgICAgICAgfF9fX19fX19fXG4gICAgICpcbiAgICAgKi9cbiAgICBvdmVybGFwQW1vdW50WzFdICs9IE1hdGgubWluKHJlY3RCLmdldFkoKSAtIHJlY3RBLmdldFkoKSwgcmVjdEEuZ2V0Qm90dG9tKCkgLSByZWN0Qi5nZXRCb3R0b20oKSk7XG4gIH0gZWxzZSBpZiAocmVjdEIuZ2V0WSgpIDw9IHJlY3RBLmdldFkoKSAmJiByZWN0Qi5nZXRCb3R0b20oKSA+PSByZWN0QS5nZXRCb3R0b20oKSkge1xuICAgIC8qIENhc2UgeS4yOlxuICAgICogICAgICAgICAgX19fX19fX18gcmVjdEJcbiAgICAqICAgICAgICAgfFxuICAgICogICAgICAgICB8XG4gICAgKiAgIF9fX19fX3xfX19fICByZWN0QVxuICAgICogICAgICAgICB8ICAgIHxcbiAgICAqICAgICAgICAgfCAgICB8XG4gICAgKiAgIF9fX19fX3xfX19ffFxuICAgICogICAgICAgICB8XG4gICAgKiAgICAgICAgIHxcbiAgICAqICAgICAgICAgfF9fX19fX19fXG4gICAgKlxuICAgICovXG4gICAgb3ZlcmxhcEFtb3VudFsxXSArPSBNYXRoLm1pbihyZWN0QS5nZXRZKCkgLSByZWN0Qi5nZXRZKCksIHJlY3RCLmdldEJvdHRvbSgpIC0gcmVjdEEuZ2V0Qm90dG9tKCkpO1xuICB9XG5cbiAgLy8gZmluZCBzbG9wZSBvZiB0aGUgbGluZSBwYXNzZXMgdHdvIGNlbnRlcnNcbiAgdmFyIHNsb3BlID0gTWF0aC5hYnMoKHJlY3RCLmdldENlbnRlclkoKSAtIHJlY3RBLmdldENlbnRlclkoKSkgLyAocmVjdEIuZ2V0Q2VudGVyWCgpIC0gcmVjdEEuZ2V0Q2VudGVyWCgpKSk7XG4gIC8vIGlmIGNlbnRlcnMgYXJlIG92ZXJsYXBwZWRcbiAgaWYgKHJlY3RCLmdldENlbnRlclkoKSA9PT0gcmVjdEEuZ2V0Q2VudGVyWSgpICYmIHJlY3RCLmdldENlbnRlclgoKSA9PT0gcmVjdEEuZ2V0Q2VudGVyWCgpKSB7XG4gICAgLy8gYXNzdW1lIHRoZSBzbG9wZSBpcyAxICg0NSBkZWdyZWUpXG4gICAgc2xvcGUgPSAxLjA7XG4gIH1cblxuICB2YXIgbW92ZUJ5WSA9IHNsb3BlICogb3ZlcmxhcEFtb3VudFswXTtcbiAgdmFyIG1vdmVCeVggPSBvdmVybGFwQW1vdW50WzFdIC8gc2xvcGU7XG4gIGlmIChvdmVybGFwQW1vdW50WzBdIDwgbW92ZUJ5WCkge1xuICAgIG1vdmVCeVggPSBvdmVybGFwQW1vdW50WzBdO1xuICB9IGVsc2Uge1xuICAgIG1vdmVCeVkgPSBvdmVybGFwQW1vdW50WzFdO1xuICB9XG4gIC8vIHJldHVybiBoYWxmIHRoZSBhbW91bnQgc28gdGhhdCBpZiBlYWNoIHJlY3RhbmdsZSBpcyBtb3ZlZCBieSB0aGVzZVxuICAvLyBhbW91bnRzIGluIG9wcG9zaXRlIGRpcmVjdGlvbnMsIG92ZXJsYXAgd2lsbCBiZSByZXNvbHZlZFxuICBvdmVybGFwQW1vdW50WzBdID0gLTEgKiBkaXJlY3Rpb25zWzBdICogKG1vdmVCeVggLyAyICsgc2VwYXJhdGlvbkJ1ZmZlcik7XG4gIG92ZXJsYXBBbW91bnRbMV0gPSAtMSAqIGRpcmVjdGlvbnNbMV0gKiAobW92ZUJ5WSAvIDIgKyBzZXBhcmF0aW9uQnVmZmVyKTtcbn07XG5cbi8qKlxuICogVGhpcyBtZXRob2QgZGVjaWRlcyB0aGUgc2VwYXJhdGlvbiBkaXJlY3Rpb24gb2Ygb3ZlcmxhcHBpbmcgbm9kZXNcbiAqXG4gKiBpZiBkaXJlY3Rpb25zWzBdID0gLTEsIHRoZW4gcmVjdEEgZ29lcyBsZWZ0XG4gKiBpZiBkaXJlY3Rpb25zWzBdID0gMSwgIHRoZW4gcmVjdEEgZ29lcyByaWdodFxuICogaWYgZGlyZWN0aW9uc1sxXSA9IC0xLCB0aGVuIHJlY3RBIGdvZXMgdXBcbiAqIGlmIGRpcmVjdGlvbnNbMV0gPSAxLCAgdGhlbiByZWN0QSBnb2VzIGRvd25cbiAqL1xuSUdlb21ldHJ5LmRlY2lkZURpcmVjdGlvbnNGb3JPdmVybGFwcGluZ05vZGVzID0gZnVuY3Rpb24gKHJlY3RBLCByZWN0QiwgZGlyZWN0aW9ucykge1xuICBpZiAocmVjdEEuZ2V0Q2VudGVyWCgpIDwgcmVjdEIuZ2V0Q2VudGVyWCgpKSB7XG4gICAgZGlyZWN0aW9uc1swXSA9IC0xO1xuICB9IGVsc2Uge1xuICAgIGRpcmVjdGlvbnNbMF0gPSAxO1xuICB9XG5cbiAgaWYgKHJlY3RBLmdldENlbnRlclkoKSA8IHJlY3RCLmdldENlbnRlclkoKSkge1xuICAgIGRpcmVjdGlvbnNbMV0gPSAtMTtcbiAgfSBlbHNlIHtcbiAgICBkaXJlY3Rpb25zWzFdID0gMTtcbiAgfVxufTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBjYWxjdWxhdGVzIHRoZSBpbnRlcnNlY3Rpb24gKGNsaXBwaW5nKSBwb2ludHMgb2YgdGhlIHR3b1xuICogaW5wdXQgcmVjdGFuZ2xlcyB3aXRoIGxpbmUgc2VnbWVudCBkZWZpbmVkIGJ5IHRoZSBjZW50ZXJzIG9mIHRoZXNlIHR3b1xuICogcmVjdGFuZ2xlcy4gVGhlIGNsaXBwaW5nIHBvaW50cyBhcmUgc2F2ZWQgaW4gdGhlIGlucHV0IGRvdWJsZSBhcnJheSBhbmRcbiAqIHdoZXRoZXIgb3Igbm90IHRoZSB0d28gcmVjdGFuZ2xlcyBvdmVybGFwIGlzIHJldHVybmVkLlxuICovXG5JR2VvbWV0cnkuZ2V0SW50ZXJzZWN0aW9uMiA9IGZ1bmN0aW9uIChyZWN0QSwgcmVjdEIsIHJlc3VsdCkge1xuICAvL3Jlc3VsdFswLTFdIHdpbGwgY29udGFpbiBjbGlwUG9pbnQgb2YgcmVjdEEsIHJlc3VsdFsyLTNdIHdpbGwgY29udGFpbiBjbGlwUG9pbnQgb2YgcmVjdEJcbiAgdmFyIHAxeCA9IHJlY3RBLmdldENlbnRlclgoKTtcbiAgdmFyIHAxeSA9IHJlY3RBLmdldENlbnRlclkoKTtcbiAgdmFyIHAyeCA9IHJlY3RCLmdldENlbnRlclgoKTtcbiAgdmFyIHAyeSA9IHJlY3RCLmdldENlbnRlclkoKTtcblxuICAvL2lmIHR3byByZWN0YW5nbGVzIGludGVyc2VjdCwgdGhlbiBjbGlwcGluZyBwb2ludHMgYXJlIGNlbnRlcnNcbiAgaWYgKHJlY3RBLmludGVyc2VjdHMocmVjdEIpKSB7XG4gICAgcmVzdWx0WzBdID0gcDF4O1xuICAgIHJlc3VsdFsxXSA9IHAxeTtcbiAgICByZXN1bHRbMl0gPSBwMng7XG4gICAgcmVzdWx0WzNdID0gcDJ5O1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8vdmFyaWFibGVzIGZvciByZWN0QVxuICB2YXIgdG9wTGVmdEF4ID0gcmVjdEEuZ2V0WCgpO1xuICB2YXIgdG9wTGVmdEF5ID0gcmVjdEEuZ2V0WSgpO1xuICB2YXIgdG9wUmlnaHRBeCA9IHJlY3RBLmdldFJpZ2h0KCk7XG4gIHZhciBib3R0b21MZWZ0QXggPSByZWN0QS5nZXRYKCk7XG4gIHZhciBib3R0b21MZWZ0QXkgPSByZWN0QS5nZXRCb3R0b20oKTtcbiAgdmFyIGJvdHRvbVJpZ2h0QXggPSByZWN0QS5nZXRSaWdodCgpO1xuICB2YXIgaGFsZldpZHRoQSA9IHJlY3RBLmdldFdpZHRoSGFsZigpO1xuICB2YXIgaGFsZkhlaWdodEEgPSByZWN0QS5nZXRIZWlnaHRIYWxmKCk7XG4gIC8vdmFyaWFibGVzIGZvciByZWN0QlxuICB2YXIgdG9wTGVmdEJ4ID0gcmVjdEIuZ2V0WCgpO1xuICB2YXIgdG9wTGVmdEJ5ID0gcmVjdEIuZ2V0WSgpO1xuICB2YXIgdG9wUmlnaHRCeCA9IHJlY3RCLmdldFJpZ2h0KCk7XG4gIHZhciBib3R0b21MZWZ0QnggPSByZWN0Qi5nZXRYKCk7XG4gIHZhciBib3R0b21MZWZ0QnkgPSByZWN0Qi5nZXRCb3R0b20oKTtcbiAgdmFyIGJvdHRvbVJpZ2h0QnggPSByZWN0Qi5nZXRSaWdodCgpO1xuICB2YXIgaGFsZldpZHRoQiA9IHJlY3RCLmdldFdpZHRoSGFsZigpO1xuICB2YXIgaGFsZkhlaWdodEIgPSByZWN0Qi5nZXRIZWlnaHRIYWxmKCk7XG5cbiAgLy9mbGFnIHdoZXRoZXIgY2xpcHBpbmcgcG9pbnRzIGFyZSBmb3VuZFxuICB2YXIgY2xpcFBvaW50QUZvdW5kID0gZmFsc2U7XG4gIHZhciBjbGlwUG9pbnRCRm91bmQgPSBmYWxzZTtcblxuICAvLyBsaW5lIGlzIHZlcnRpY2FsXG4gIGlmIChwMXggPT09IHAyeCkge1xuICAgIGlmIChwMXkgPiBwMnkpIHtcbiAgICAgIHJlc3VsdFswXSA9IHAxeDtcbiAgICAgIHJlc3VsdFsxXSA9IHRvcExlZnRBeTtcbiAgICAgIHJlc3VsdFsyXSA9IHAyeDtcbiAgICAgIHJlc3VsdFszXSA9IGJvdHRvbUxlZnRCeTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKHAxeSA8IHAyeSkge1xuICAgICAgcmVzdWx0WzBdID0gcDF4O1xuICAgICAgcmVzdWx0WzFdID0gYm90dG9tTGVmdEF5O1xuICAgICAgcmVzdWx0WzJdID0gcDJ4O1xuICAgICAgcmVzdWx0WzNdID0gdG9wTGVmdEJ5O1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvL25vdCBsaW5lLCByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgLy8gbGluZSBpcyBob3Jpem9udGFsXG4gIGVsc2UgaWYgKHAxeSA9PT0gcDJ5KSB7XG4gICAgICBpZiAocDF4ID4gcDJ4KSB7XG4gICAgICAgIHJlc3VsdFswXSA9IHRvcExlZnRBeDtcbiAgICAgICAgcmVzdWx0WzFdID0gcDF5O1xuICAgICAgICByZXN1bHRbMl0gPSB0b3BSaWdodEJ4O1xuICAgICAgICByZXN1bHRbM10gPSBwMnk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAocDF4IDwgcDJ4KSB7XG4gICAgICAgIHJlc3VsdFswXSA9IHRvcFJpZ2h0QXg7XG4gICAgICAgIHJlc3VsdFsxXSA9IHAxeTtcbiAgICAgICAgcmVzdWx0WzJdID0gdG9wTGVmdEJ4O1xuICAgICAgICByZXN1bHRbM10gPSBwMnk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vbm90IHZhbGlkIGxpbmUsIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvL3Nsb3BlcyBvZiByZWN0QSdzIGFuZCByZWN0QidzIGRpYWdvbmFsc1xuICAgICAgdmFyIHNsb3BlQSA9IHJlY3RBLmhlaWdodCAvIHJlY3RBLndpZHRoO1xuICAgICAgdmFyIHNsb3BlQiA9IHJlY3RCLmhlaWdodCAvIHJlY3RCLndpZHRoO1xuXG4gICAgICAvL3Nsb3BlIG9mIGxpbmUgYmV0d2VlbiBjZW50ZXIgb2YgcmVjdEEgYW5kIGNlbnRlciBvZiByZWN0QlxuICAgICAgdmFyIHNsb3BlUHJpbWUgPSAocDJ5IC0gcDF5KSAvIChwMnggLSBwMXgpO1xuICAgICAgdmFyIGNhcmRpbmFsRGlyZWN0aW9uQSA9IHZvaWQgMDtcbiAgICAgIHZhciBjYXJkaW5hbERpcmVjdGlvbkIgPSB2b2lkIDA7XG4gICAgICB2YXIgdGVtcFBvaW50QXggPSB2b2lkIDA7XG4gICAgICB2YXIgdGVtcFBvaW50QXkgPSB2b2lkIDA7XG4gICAgICB2YXIgdGVtcFBvaW50QnggPSB2b2lkIDA7XG4gICAgICB2YXIgdGVtcFBvaW50QnkgPSB2b2lkIDA7XG5cbiAgICAgIC8vZGV0ZXJtaW5lIHdoZXRoZXIgY2xpcHBpbmcgcG9pbnQgaXMgdGhlIGNvcm5lciBvZiBub2RlQVxuICAgICAgaWYgKC1zbG9wZUEgPT09IHNsb3BlUHJpbWUpIHtcbiAgICAgICAgaWYgKHAxeCA+IHAyeCkge1xuICAgICAgICAgIHJlc3VsdFswXSA9IGJvdHRvbUxlZnRBeDtcbiAgICAgICAgICByZXN1bHRbMV0gPSBib3R0b21MZWZ0QXk7XG4gICAgICAgICAgY2xpcFBvaW50QUZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHRbMF0gPSB0b3BSaWdodEF4O1xuICAgICAgICAgIHJlc3VsdFsxXSA9IHRvcExlZnRBeTtcbiAgICAgICAgICBjbGlwUG9pbnRBRm91bmQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHNsb3BlQSA9PT0gc2xvcGVQcmltZSkge1xuICAgICAgICBpZiAocDF4ID4gcDJ4KSB7XG4gICAgICAgICAgcmVzdWx0WzBdID0gdG9wTGVmdEF4O1xuICAgICAgICAgIHJlc3VsdFsxXSA9IHRvcExlZnRBeTtcbiAgICAgICAgICBjbGlwUG9pbnRBRm91bmQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdFswXSA9IGJvdHRvbVJpZ2h0QXg7XG4gICAgICAgICAgcmVzdWx0WzFdID0gYm90dG9tTGVmdEF5O1xuICAgICAgICAgIGNsaXBQb2ludEFGb3VuZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy9kZXRlcm1pbmUgd2hldGhlciBjbGlwcGluZyBwb2ludCBpcyB0aGUgY29ybmVyIG9mIG5vZGVCXG4gICAgICBpZiAoLXNsb3BlQiA9PT0gc2xvcGVQcmltZSkge1xuICAgICAgICBpZiAocDJ4ID4gcDF4KSB7XG4gICAgICAgICAgcmVzdWx0WzJdID0gYm90dG9tTGVmdEJ4O1xuICAgICAgICAgIHJlc3VsdFszXSA9IGJvdHRvbUxlZnRCeTtcbiAgICAgICAgICBjbGlwUG9pbnRCRm91bmQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdFsyXSA9IHRvcFJpZ2h0Qng7XG4gICAgICAgICAgcmVzdWx0WzNdID0gdG9wTGVmdEJ5O1xuICAgICAgICAgIGNsaXBQb2ludEJGb3VuZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc2xvcGVCID09PSBzbG9wZVByaW1lKSB7XG4gICAgICAgIGlmIChwMnggPiBwMXgpIHtcbiAgICAgICAgICByZXN1bHRbMl0gPSB0b3BMZWZ0Qng7XG4gICAgICAgICAgcmVzdWx0WzNdID0gdG9wTGVmdEJ5O1xuICAgICAgICAgIGNsaXBQb2ludEJGb3VuZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0WzJdID0gYm90dG9tUmlnaHRCeDtcbiAgICAgICAgICByZXN1bHRbM10gPSBib3R0b21MZWZ0Qnk7XG4gICAgICAgICAgY2xpcFBvaW50QkZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvL2lmIGJvdGggY2xpcHBpbmcgcG9pbnRzIGFyZSBjb3JuZXJzXG4gICAgICBpZiAoY2xpcFBvaW50QUZvdW5kICYmIGNsaXBQb2ludEJGb3VuZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vZGV0ZXJtaW5lIENhcmRpbmFsIERpcmVjdGlvbiBvZiByZWN0YW5nbGVzXG4gICAgICBpZiAocDF4ID4gcDJ4KSB7XG4gICAgICAgIGlmIChwMXkgPiBwMnkpIHtcbiAgICAgICAgICBjYXJkaW5hbERpcmVjdGlvbkEgPSB0aGlzLmdldENhcmRpbmFsRGlyZWN0aW9uKHNsb3BlQSwgc2xvcGVQcmltZSwgNCk7XG4gICAgICAgICAgY2FyZGluYWxEaXJlY3Rpb25CID0gdGhpcy5nZXRDYXJkaW5hbERpcmVjdGlvbihzbG9wZUIsIHNsb3BlUHJpbWUsIDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhcmRpbmFsRGlyZWN0aW9uQSA9IHRoaXMuZ2V0Q2FyZGluYWxEaXJlY3Rpb24oLXNsb3BlQSwgc2xvcGVQcmltZSwgMyk7XG4gICAgICAgICAgY2FyZGluYWxEaXJlY3Rpb25CID0gdGhpcy5nZXRDYXJkaW5hbERpcmVjdGlvbigtc2xvcGVCLCBzbG9wZVByaW1lLCAxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHAxeSA+IHAyeSkge1xuICAgICAgICAgIGNhcmRpbmFsRGlyZWN0aW9uQSA9IHRoaXMuZ2V0Q2FyZGluYWxEaXJlY3Rpb24oLXNsb3BlQSwgc2xvcGVQcmltZSwgMSk7XG4gICAgICAgICAgY2FyZGluYWxEaXJlY3Rpb25CID0gdGhpcy5nZXRDYXJkaW5hbERpcmVjdGlvbigtc2xvcGVCLCBzbG9wZVByaW1lLCAzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYXJkaW5hbERpcmVjdGlvbkEgPSB0aGlzLmdldENhcmRpbmFsRGlyZWN0aW9uKHNsb3BlQSwgc2xvcGVQcmltZSwgMik7XG4gICAgICAgICAgY2FyZGluYWxEaXJlY3Rpb25CID0gdGhpcy5nZXRDYXJkaW5hbERpcmVjdGlvbihzbG9wZUIsIHNsb3BlUHJpbWUsIDQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvL2NhbGN1bGF0ZSBjbGlwcGluZyBQb2ludCBpZiBpdCBpcyBub3QgZm91bmQgYmVmb3JlXG4gICAgICBpZiAoIWNsaXBQb2ludEFGb3VuZCkge1xuICAgICAgICBzd2l0Y2ggKGNhcmRpbmFsRGlyZWN0aW9uQSkge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHRlbXBQb2ludEF5ID0gdG9wTGVmdEF5O1xuICAgICAgICAgICAgdGVtcFBvaW50QXggPSBwMXggKyAtaGFsZkhlaWdodEEgLyBzbG9wZVByaW1lO1xuICAgICAgICAgICAgcmVzdWx0WzBdID0gdGVtcFBvaW50QXg7XG4gICAgICAgICAgICByZXN1bHRbMV0gPSB0ZW1wUG9pbnRBeTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHRlbXBQb2ludEF4ID0gYm90dG9tUmlnaHRBeDtcbiAgICAgICAgICAgIHRlbXBQb2ludEF5ID0gcDF5ICsgaGFsZldpZHRoQSAqIHNsb3BlUHJpbWU7XG4gICAgICAgICAgICByZXN1bHRbMF0gPSB0ZW1wUG9pbnRBeDtcbiAgICAgICAgICAgIHJlc3VsdFsxXSA9IHRlbXBQb2ludEF5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgdGVtcFBvaW50QXkgPSBib3R0b21MZWZ0QXk7XG4gICAgICAgICAgICB0ZW1wUG9pbnRBeCA9IHAxeCArIGhhbGZIZWlnaHRBIC8gc2xvcGVQcmltZTtcbiAgICAgICAgICAgIHJlc3VsdFswXSA9IHRlbXBQb2ludEF4O1xuICAgICAgICAgICAgcmVzdWx0WzFdID0gdGVtcFBvaW50QXk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICB0ZW1wUG9pbnRBeCA9IGJvdHRvbUxlZnRBeDtcbiAgICAgICAgICAgIHRlbXBQb2ludEF5ID0gcDF5ICsgLWhhbGZXaWR0aEEgKiBzbG9wZVByaW1lO1xuICAgICAgICAgICAgcmVzdWx0WzBdID0gdGVtcFBvaW50QXg7XG4gICAgICAgICAgICByZXN1bHRbMV0gPSB0ZW1wUG9pbnRBeTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWNsaXBQb2ludEJGb3VuZCkge1xuICAgICAgICBzd2l0Y2ggKGNhcmRpbmFsRGlyZWN0aW9uQikge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHRlbXBQb2ludEJ5ID0gdG9wTGVmdEJ5O1xuICAgICAgICAgICAgdGVtcFBvaW50QnggPSBwMnggKyAtaGFsZkhlaWdodEIgLyBzbG9wZVByaW1lO1xuICAgICAgICAgICAgcmVzdWx0WzJdID0gdGVtcFBvaW50Qng7XG4gICAgICAgICAgICByZXN1bHRbM10gPSB0ZW1wUG9pbnRCeTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHRlbXBQb2ludEJ4ID0gYm90dG9tUmlnaHRCeDtcbiAgICAgICAgICAgIHRlbXBQb2ludEJ5ID0gcDJ5ICsgaGFsZldpZHRoQiAqIHNsb3BlUHJpbWU7XG4gICAgICAgICAgICByZXN1bHRbMl0gPSB0ZW1wUG9pbnRCeDtcbiAgICAgICAgICAgIHJlc3VsdFszXSA9IHRlbXBQb2ludEJ5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgdGVtcFBvaW50QnkgPSBib3R0b21MZWZ0Qnk7XG4gICAgICAgICAgICB0ZW1wUG9pbnRCeCA9IHAyeCArIGhhbGZIZWlnaHRCIC8gc2xvcGVQcmltZTtcbiAgICAgICAgICAgIHJlc3VsdFsyXSA9IHRlbXBQb2ludEJ4O1xuICAgICAgICAgICAgcmVzdWx0WzNdID0gdGVtcFBvaW50Qnk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICB0ZW1wUG9pbnRCeCA9IGJvdHRvbUxlZnRCeDtcbiAgICAgICAgICAgIHRlbXBQb2ludEJ5ID0gcDJ5ICsgLWhhbGZXaWR0aEIgKiBzbG9wZVByaW1lO1xuICAgICAgICAgICAgcmVzdWx0WzJdID0gdGVtcFBvaW50Qng7XG4gICAgICAgICAgICByZXN1bHRbM10gPSB0ZW1wUG9pbnRCeTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgaW4gd2hpY2ggY2FyZGluYWwgZGlyZWN0aW9uIGRvZXMgaW5wdXQgcG9pbnQgc3RheXNcbiAqIDE6IE5vcnRoXG4gKiAyOiBFYXN0XG4gKiAzOiBTb3V0aFxuICogNDogV2VzdFxuICovXG5JR2VvbWV0cnkuZ2V0Q2FyZGluYWxEaXJlY3Rpb24gPSBmdW5jdGlvbiAoc2xvcGUsIHNsb3BlUHJpbWUsIGxpbmUpIHtcbiAgaWYgKHNsb3BlID4gc2xvcGVQcmltZSkge1xuICAgIHJldHVybiBsaW5lO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAxICsgbGluZSAlIDQ7XG4gIH1cbn07XG5cbi8qKlxuICogVGhpcyBtZXRob2QgY2FsY3VsYXRlcyB0aGUgaW50ZXJzZWN0aW9uIG9mIHRoZSB0d28gbGluZXMgZGVmaW5lZCBieVxuICogcG9pbnQgcGFpcnMgKHMxLHMyKSBhbmQgKGYxLGYyKS5cbiAqL1xuSUdlb21ldHJ5LmdldEludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIChzMSwgczIsIGYxLCBmMikge1xuICBpZiAoZjIgPT0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLmdldEludGVyc2VjdGlvbjIoczEsIHMyLCBmMSk7XG4gIH1cblxuICB2YXIgeDEgPSBzMS54O1xuICB2YXIgeTEgPSBzMS55O1xuICB2YXIgeDIgPSBzMi54O1xuICB2YXIgeTIgPSBzMi55O1xuICB2YXIgeDMgPSBmMS54O1xuICB2YXIgeTMgPSBmMS55O1xuICB2YXIgeDQgPSBmMi54O1xuICB2YXIgeTQgPSBmMi55O1xuICB2YXIgeCA9IHZvaWQgMCxcbiAgICAgIHkgPSB2b2lkIDA7IC8vIGludGVyc2VjdGlvbiBwb2ludFxuICB2YXIgYTEgPSB2b2lkIDAsXG4gICAgICBhMiA9IHZvaWQgMCxcbiAgICAgIGIxID0gdm9pZCAwLFxuICAgICAgYjIgPSB2b2lkIDAsXG4gICAgICBjMSA9IHZvaWQgMCxcbiAgICAgIGMyID0gdm9pZCAwOyAvLyBjb2VmZmljaWVudHMgb2YgbGluZSBlcW5zLlxuICB2YXIgZGVub20gPSB2b2lkIDA7XG5cbiAgYTEgPSB5MiAtIHkxO1xuICBiMSA9IHgxIC0geDI7XG4gIGMxID0geDIgKiB5MSAtIHgxICogeTI7IC8vIHsgYTEqeCArIGIxKnkgKyBjMSA9IDAgaXMgbGluZSAxIH1cblxuICBhMiA9IHk0IC0geTM7XG4gIGIyID0geDMgLSB4NDtcbiAgYzIgPSB4NCAqIHkzIC0geDMgKiB5NDsgLy8geyBhMip4ICsgYjIqeSArIGMyID0gMCBpcyBsaW5lIDIgfVxuXG4gIGRlbm9tID0gYTEgKiBiMiAtIGEyICogYjE7XG5cbiAgaWYgKGRlbm9tID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB4ID0gKGIxICogYzIgLSBiMiAqIGMxKSAvIGRlbm9tO1xuICB5ID0gKGEyICogYzEgLSBhMSAqIGMyKSAvIGRlbm9tO1xuXG4gIHJldHVybiBuZXcgUG9pbnQoeCwgeSk7XG59O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGZpbmRzIGFuZCByZXR1cm5zIHRoZSBhbmdsZSBvZiB0aGUgdmVjdG9yIGZyb20gdGhlICsgeC1heGlzXG4gKiBpbiBjbG9ja3dpc2UgZGlyZWN0aW9uIChjb21wYXRpYmxlIHcvIEphdmEgY29vcmRpbmF0ZSBzeXN0ZW0hKS5cbiAqL1xuSUdlb21ldHJ5LmFuZ2xlT2ZWZWN0b3IgPSBmdW5jdGlvbiAoQ3gsIEN5LCBOeCwgTnkpIHtcbiAgdmFyIENfYW5nbGUgPSB2b2lkIDA7XG5cbiAgaWYgKEN4ICE9PSBOeCkge1xuICAgIENfYW5nbGUgPSBNYXRoLmF0YW4oKE55IC0gQ3kpIC8gKE54IC0gQ3gpKTtcblxuICAgIGlmIChOeCA8IEN4KSB7XG4gICAgICBDX2FuZ2xlICs9IE1hdGguUEk7XG4gICAgfSBlbHNlIGlmIChOeSA8IEN5KSB7XG4gICAgICBDX2FuZ2xlICs9IHRoaXMuVFdPX1BJO1xuICAgIH1cbiAgfSBlbHNlIGlmIChOeSA8IEN5KSB7XG4gICAgQ19hbmdsZSA9IHRoaXMuT05FX0FORF9IQUxGX1BJOyAvLyAyNzAgZGVncmVlc1xuICB9IGVsc2Uge1xuICAgIENfYW5nbGUgPSB0aGlzLkhBTEZfUEk7IC8vIDkwIGRlZ3JlZXNcbiAgfVxuXG4gIHJldHVybiBDX2FuZ2xlO1xufTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBjaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gdHdvIGxpbmUgc2VnbWVudHMgKG9uZSB3aXRoIHBvaW50XG4gKiBwMSBhbmQgcDIsIHRoZSBvdGhlciB3aXRoIHBvaW50IHAzIGFuZCBwNCkgaW50ZXJzZWN0IGF0IGEgcG9pbnQgb3RoZXJcbiAqIHRoYW4gdGhlc2UgcG9pbnRzLlxuICovXG5JR2VvbWV0cnkuZG9JbnRlcnNlY3QgPSBmdW5jdGlvbiAocDEsIHAyLCBwMywgcDQpIHtcbiAgdmFyIGEgPSBwMS54O1xuICB2YXIgYiA9IHAxLnk7XG4gIHZhciBjID0gcDIueDtcbiAgdmFyIGQgPSBwMi55O1xuICB2YXIgcCA9IHAzLng7XG4gIHZhciBxID0gcDMueTtcbiAgdmFyIHIgPSBwNC54O1xuICB2YXIgcyA9IHA0Lnk7XG4gIHZhciBkZXQgPSAoYyAtIGEpICogKHMgLSBxKSAtIChyIC0gcCkgKiAoZCAtIGIpO1xuXG4gIGlmIChkZXQgPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxhbWJkYSA9ICgocyAtIHEpICogKHIgLSBhKSArIChwIC0gcikgKiAocyAtIGIpKSAvIGRldDtcbiAgICB2YXIgZ2FtbWEgPSAoKGIgLSBkKSAqIChyIC0gYSkgKyAoYyAtIGEpICogKHMgLSBiKSkgLyBkZXQ7XG4gICAgcmV0dXJuIDAgPCBsYW1iZGEgJiYgbGFtYmRhIDwgMSAmJiAwIDwgZ2FtbWEgJiYgZ2FtbWEgPCAxO1xuICB9XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gU2VjdGlvbjogQ2xhc3MgQ29uc3RhbnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLyoqXG4gKiBTb21lIHVzZWZ1bCBwcmUtY2FsY3VsYXRlZCBjb25zdGFudHNcbiAqL1xuSUdlb21ldHJ5LkhBTEZfUEkgPSAwLjUgKiBNYXRoLlBJO1xuSUdlb21ldHJ5Lk9ORV9BTkRfSEFMRl9QSSA9IDEuNSAqIE1hdGguUEk7XG5JR2VvbWV0cnkuVFdPX1BJID0gMi4wICogTWF0aC5QSTtcbklHZW9tZXRyeS5USFJFRV9QSSA9IDMuMCAqIE1hdGguUEk7XG5cbm1vZHVsZS5leHBvcnRzID0gSUdlb21ldHJ5O1xuXG4vKioqLyB9KSxcbi8qIDkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gSU1hdGgoKSB7fVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIHNpZ24gb2YgdGhlIGlucHV0IHZhbHVlLlxuICovXG5JTWF0aC5zaWduID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA+IDApIHtcbiAgICByZXR1cm4gMTtcbiAgfSBlbHNlIGlmICh2YWx1ZSA8IDApIHtcbiAgICByZXR1cm4gLTE7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbn07XG5cbklNYXRoLmZsb29yID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA8IDAgPyBNYXRoLmNlaWwodmFsdWUpIDogTWF0aC5mbG9vcih2YWx1ZSk7XG59O1xuXG5JTWF0aC5jZWlsID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA8IDAgPyBNYXRoLmZsb29yKHZhbHVlKSA6IE1hdGguY2VpbCh2YWx1ZSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IElNYXRoO1xuXG4vKioqLyB9KSxcbi8qIDEwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIEludGVnZXIoKSB7fVxuXG5JbnRlZ2VyLk1BWF9WQUxVRSA9IDIxNDc0ODM2NDc7XG5JbnRlZ2VyLk1JTl9WQUxVRSA9IC0yMTQ3NDgzNjQ4O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEludGVnZXI7XG5cbi8qKiovIH0pLFxuLyogMTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIG5vZGVGcm9tID0gZnVuY3Rpb24gbm9kZUZyb20odmFsdWUpIHtcbiAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlLCBuZXh0OiBudWxsLCBwcmV2OiBudWxsIH07XG59O1xuXG52YXIgYWRkID0gZnVuY3Rpb24gYWRkKHByZXYsIG5vZGUsIG5leHQsIGxpc3QpIHtcbiAgaWYgKHByZXYgIT09IG51bGwpIHtcbiAgICBwcmV2Lm5leHQgPSBub2RlO1xuICB9IGVsc2Uge1xuICAgIGxpc3QuaGVhZCA9IG5vZGU7XG4gIH1cblxuICBpZiAobmV4dCAhPT0gbnVsbCkge1xuICAgIG5leHQucHJldiA9IG5vZGU7XG4gIH0gZWxzZSB7XG4gICAgbGlzdC50YWlsID0gbm9kZTtcbiAgfVxuXG4gIG5vZGUucHJldiA9IHByZXY7XG4gIG5vZGUubmV4dCA9IG5leHQ7XG5cbiAgbGlzdC5sZW5ndGgrKztcblxuICByZXR1cm4gbm9kZTtcbn07XG5cbnZhciBfcmVtb3ZlID0gZnVuY3Rpb24gX3JlbW92ZShub2RlLCBsaXN0KSB7XG4gIHZhciBwcmV2ID0gbm9kZS5wcmV2LFxuICAgICAgbmV4dCA9IG5vZGUubmV4dDtcblxuXG4gIGlmIChwcmV2ICE9PSBudWxsKSB7XG4gICAgcHJldi5uZXh0ID0gbmV4dDtcbiAgfSBlbHNlIHtcbiAgICBsaXN0LmhlYWQgPSBuZXh0O1xuICB9XG5cbiAgaWYgKG5leHQgIT09IG51bGwpIHtcbiAgICBuZXh0LnByZXYgPSBwcmV2O1xuICB9IGVsc2Uge1xuICAgIGxpc3QudGFpbCA9IHByZXY7XG4gIH1cblxuICBub2RlLnByZXYgPSBub2RlLm5leHQgPSBudWxsO1xuXG4gIGxpc3QubGVuZ3RoLS07XG5cbiAgcmV0dXJuIG5vZGU7XG59O1xuXG52YXIgTGlua2VkTGlzdCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTGlua2VkTGlzdCh2YWxzKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMaW5rZWRMaXN0KTtcblxuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICB0aGlzLmhlYWQgPSBudWxsO1xuICAgIHRoaXMudGFpbCA9IG51bGw7XG5cbiAgICBpZiAodmFscyAhPSBudWxsKSB7XG4gICAgICB2YWxzLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLnB1c2godik7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTGlua2VkTGlzdCwgW3tcbiAgICBrZXk6IFwic2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaXplKCkge1xuICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnNlcnRCZWZvcmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0QmVmb3JlKHZhbCwgb3RoZXJOb2RlKSB7XG4gICAgICByZXR1cm4gYWRkKG90aGVyTm9kZS5wcmV2LCBub2RlRnJvbSh2YWwpLCBvdGhlck5vZGUsIHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnNlcnRBZnRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnNlcnRBZnRlcih2YWwsIG90aGVyTm9kZSkge1xuICAgICAgcmV0dXJuIGFkZChvdGhlck5vZGUsIG5vZGVGcm9tKHZhbCksIG90aGVyTm9kZS5uZXh0LCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5zZXJ0Tm9kZUJlZm9yZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnNlcnROb2RlQmVmb3JlKG5ld05vZGUsIG90aGVyTm9kZSkge1xuICAgICAgcmV0dXJuIGFkZChvdGhlck5vZGUucHJldiwgbmV3Tm9kZSwgb3RoZXJOb2RlLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5zZXJ0Tm9kZUFmdGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydE5vZGVBZnRlcihuZXdOb2RlLCBvdGhlck5vZGUpIHtcbiAgICAgIHJldHVybiBhZGQob3RoZXJOb2RlLCBuZXdOb2RlLCBvdGhlck5vZGUubmV4dCwgdGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInB1c2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHVzaCh2YWwpIHtcbiAgICAgIHJldHVybiBhZGQodGhpcy50YWlsLCBub2RlRnJvbSh2YWwpLCBudWxsLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidW5zaGlmdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bnNoaWZ0KHZhbCkge1xuICAgICAgcmV0dXJuIGFkZChudWxsLCBub2RlRnJvbSh2YWwpLCB0aGlzLmhlYWQsIHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKG5vZGUpIHtcbiAgICAgIHJldHVybiBfcmVtb3ZlKG5vZGUsIHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwb3BcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcG9wKCkge1xuICAgICAgcmV0dXJuIF9yZW1vdmUodGhpcy50YWlsLCB0aGlzKS52YWx1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicG9wTm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwb3BOb2RlKCkge1xuICAgICAgcmV0dXJuIF9yZW1vdmUodGhpcy50YWlsLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2hpZnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hpZnQoKSB7XG4gICAgICByZXR1cm4gX3JlbW92ZSh0aGlzLmhlYWQsIHRoaXMpLnZhbHVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzaGlmdE5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hpZnROb2RlKCkge1xuICAgICAgcmV0dXJuIF9yZW1vdmUodGhpcy5oZWFkLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0X29iamVjdF9hdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRfb2JqZWN0X2F0KGluZGV4KSB7XG4gICAgICBpZiAoaW5kZXggPD0gdGhpcy5sZW5ndGgoKSkge1xuICAgICAgICB2YXIgaSA9IDE7XG4gICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5oZWFkO1xuICAgICAgICB3aGlsZSAoaSA8IGluZGV4KSB7XG4gICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnJlbnQudmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldF9vYmplY3RfYXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0X29iamVjdF9hdChpbmRleCwgdmFsdWUpIHtcbiAgICAgIGlmIChpbmRleCA8PSB0aGlzLmxlbmd0aCgpKSB7XG4gICAgICAgIHZhciBpID0gMTtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmhlYWQ7XG4gICAgICAgIHdoaWxlIChpIDwgaW5kZXgpIHtcbiAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50LnZhbHVlID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIExpbmtlZExpc3Q7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gTGlua2VkTGlzdDtcblxuLyoqKi8gfSksXG4vKiAxMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKlxyXG4gKlRoaXMgY2xhc3MgaXMgdGhlIGphdmFzY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFBvaW50LmphdmEgY2xhc3MgaW4gamRrXHJcbiAqL1xuZnVuY3Rpb24gUG9pbnQoeCwgeSwgcCkge1xuICB0aGlzLnggPSBudWxsO1xuICB0aGlzLnkgPSBudWxsO1xuICBpZiAoeCA9PSBudWxsICYmIHkgPT0gbnVsbCAmJiBwID09IG51bGwpIHtcbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMueSA9IDA7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHggPT0gJ251bWJlcicgJiYgdHlwZW9mIHkgPT0gJ251bWJlcicgJiYgcCA9PSBudWxsKSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICB9IGVsc2UgaWYgKHguY29uc3RydWN0b3IubmFtZSA9PSAnUG9pbnQnICYmIHkgPT0gbnVsbCAmJiBwID09IG51bGwpIHtcbiAgICBwID0geDtcbiAgICB0aGlzLnggPSBwLng7XG4gICAgdGhpcy55ID0gcC55O1xuICB9XG59XG5cblBvaW50LnByb3RvdHlwZS5nZXRYID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy54O1xufTtcblxuUG9pbnQucHJvdG90eXBlLmdldFkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZ2V0TG9jYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuZXcgUG9pbnQodGhpcy54LCB0aGlzLnkpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLnNldExvY2F0aW9uID0gZnVuY3Rpb24gKHgsIHksIHApIHtcbiAgaWYgKHguY29uc3RydWN0b3IubmFtZSA9PSAnUG9pbnQnICYmIHkgPT0gbnVsbCAmJiBwID09IG51bGwpIHtcbiAgICBwID0geDtcbiAgICB0aGlzLnNldExvY2F0aW9uKHAueCwgcC55KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgeCA9PSAnbnVtYmVyJyAmJiB0eXBlb2YgeSA9PSAnbnVtYmVyJyAmJiBwID09IG51bGwpIHtcbiAgICAvL2lmIGJvdGggcGFyYW1ldGVycyBhcmUgaW50ZWdlciBqdXN0IG1vdmUgKHgseSkgbG9jYXRpb25cbiAgICBpZiAocGFyc2VJbnQoeCkgPT0geCAmJiBwYXJzZUludCh5KSA9PSB5KSB7XG4gICAgICB0aGlzLm1vdmUoeCwgeSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMueCA9IE1hdGguZmxvb3IoeCArIDAuNSk7XG4gICAgICB0aGlzLnkgPSBNYXRoLmZsb29yKHkgKyAwLjUpO1xuICAgIH1cbiAgfVxufTtcblxuUG9pbnQucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbiAoeCwgeSkge1xuICB0aGlzLnggPSB4O1xuICB0aGlzLnkgPSB5O1xufTtcblxuUG9pbnQucHJvdG90eXBlLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uIChkeCwgZHkpIHtcbiAgdGhpcy54ICs9IGR4O1xuICB0aGlzLnkgKz0gZHk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKG9iaikge1xuICBpZiAob2JqLmNvbnN0cnVjdG9yLm5hbWUgPT0gXCJQb2ludFwiKSB7XG4gICAgdmFyIHB0ID0gb2JqO1xuICAgIHJldHVybiB0aGlzLnggPT0gcHQueCAmJiB0aGlzLnkgPT0gcHQueTtcbiAgfVxuICByZXR1cm4gdGhpcyA9PSBvYmo7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuZXcgUG9pbnQoKS5jb25zdHJ1Y3Rvci5uYW1lICsgXCJbeD1cIiArIHRoaXMueCArIFwiLHk9XCIgKyB0aGlzLnkgKyBcIl1cIjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUG9pbnQ7XG5cbi8qKiovIH0pLFxuLyogMTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gUmVjdGFuZ2xlRCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gIHRoaXMueCA9IDA7XG4gIHRoaXMueSA9IDA7XG4gIHRoaXMud2lkdGggPSAwO1xuICB0aGlzLmhlaWdodCA9IDA7XG5cbiAgaWYgKHggIT0gbnVsbCAmJiB5ICE9IG51bGwgJiYgd2lkdGggIT0gbnVsbCAmJiBoZWlnaHQgIT0gbnVsbCkge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gIH1cbn1cblxuUmVjdGFuZ2xlRC5wcm90b3R5cGUuZ2V0WCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMueDtcbn07XG5cblJlY3RhbmdsZUQucHJvdG90eXBlLnNldFggPSBmdW5jdGlvbiAoeCkge1xuICB0aGlzLnggPSB4O1xufTtcblxuUmVjdGFuZ2xlRC5wcm90b3R5cGUuZ2V0WSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMueTtcbn07XG5cblJlY3RhbmdsZUQucHJvdG90eXBlLnNldFkgPSBmdW5jdGlvbiAoeSkge1xuICB0aGlzLnkgPSB5O1xufTtcblxuUmVjdGFuZ2xlRC5wcm90b3R5cGUuZ2V0V2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLndpZHRoO1xufTtcblxuUmVjdGFuZ2xlRC5wcm90b3R5cGUuc2V0V2lkdGggPSBmdW5jdGlvbiAod2lkdGgpIHtcbiAgdGhpcy53aWR0aCA9IHdpZHRoO1xufTtcblxuUmVjdGFuZ2xlRC5wcm90b3R5cGUuZ2V0SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5oZWlnaHQ7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5zZXRIZWlnaHQgPSBmdW5jdGlvbiAoaGVpZ2h0KSB7XG4gIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xufTtcblxuUmVjdGFuZ2xlRC5wcm90b3R5cGUuZ2V0UmlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnggKyB0aGlzLndpZHRoO1xufTtcblxuUmVjdGFuZ2xlRC5wcm90b3R5cGUuZ2V0Qm90dG9tID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy55ICsgdGhpcy5oZWlnaHQ7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5pbnRlcnNlY3RzID0gZnVuY3Rpb24gKGEpIHtcbiAgaWYgKHRoaXMuZ2V0UmlnaHQoKSA8IGEueCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aGlzLmdldEJvdHRvbSgpIDwgYS55KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGEuZ2V0UmlnaHQoKSA8IHRoaXMueCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChhLmdldEJvdHRvbSgpIDwgdGhpcy55KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5nZXRDZW50ZXJYID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy54ICsgdGhpcy53aWR0aCAvIDI7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5nZXRNaW5YID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5nZXRYKCk7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5nZXRNYXhYID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5nZXRYKCkgKyB0aGlzLndpZHRoO1xufTtcblxuUmVjdGFuZ2xlRC5wcm90b3R5cGUuZ2V0Q2VudGVyWSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMueSArIHRoaXMuaGVpZ2h0IC8gMjtcbn07XG5cblJlY3RhbmdsZUQucHJvdG90eXBlLmdldE1pblkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmdldFkoKTtcbn07XG5cblJlY3RhbmdsZUQucHJvdG90eXBlLmdldE1heFkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmdldFkoKSArIHRoaXMuaGVpZ2h0O1xufTtcblxuUmVjdGFuZ2xlRC5wcm90b3R5cGUuZ2V0V2lkdGhIYWxmID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy53aWR0aCAvIDI7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5nZXRIZWlnaHRIYWxmID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5oZWlnaHQgLyAyO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWN0YW5nbGVEO1xuXG4vKioqLyB9KSxcbi8qIDE0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZnVuY3Rpb24gVW5pcXVlSURHZW5lcmV0b3IoKSB7fVxuXG5VbmlxdWVJREdlbmVyZXRvci5sYXN0SUQgPSAwO1xuXG5VbmlxdWVJREdlbmVyZXRvci5jcmVhdGVJRCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgaWYgKFVuaXF1ZUlER2VuZXJldG9yLmlzUHJpbWl0aXZlKG9iaikpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG4gIGlmIChvYmoudW5pcXVlSUQgIT0gbnVsbCkge1xuICAgIHJldHVybiBvYmoudW5pcXVlSUQ7XG4gIH1cbiAgb2JqLnVuaXF1ZUlEID0gVW5pcXVlSURHZW5lcmV0b3IuZ2V0U3RyaW5nKCk7XG4gIFVuaXF1ZUlER2VuZXJldG9yLmxhc3RJRCsrO1xuICByZXR1cm4gb2JqLnVuaXF1ZUlEO1xufTtcblxuVW5pcXVlSURHZW5lcmV0b3IuZ2V0U3RyaW5nID0gZnVuY3Rpb24gKGlkKSB7XG4gIGlmIChpZCA9PSBudWxsKSBpZCA9IFVuaXF1ZUlER2VuZXJldG9yLmxhc3RJRDtcbiAgcmV0dXJuIFwiT2JqZWN0I1wiICsgaWQgKyBcIlwiO1xufTtcblxuVW5pcXVlSURHZW5lcmV0b3IuaXNQcmltaXRpdmUgPSBmdW5jdGlvbiAoYXJnKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIGFyZyA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKGFyZyk7XG4gIHJldHVybiBhcmcgPT0gbnVsbCB8fCB0eXBlICE9IFwib2JqZWN0XCIgJiYgdHlwZSAhPSBcImZ1bmN0aW9uXCI7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVuaXF1ZUlER2VuZXJldG9yO1xuXG4vKioqLyB9KSxcbi8qIDE1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH0gZWxzZSB7IHJldHVybiBBcnJheS5mcm9tKGFycik7IH0gfVxuXG52YXIgTGF5b3V0Q29uc3RhbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBMR3JhcGhNYW5hZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcbnZhciBMTm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG52YXIgTEVkZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xudmFyIExHcmFwaCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgUG9pbnREID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcbnZhciBUcmFuc2Zvcm0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KTtcbnZhciBFbWl0dGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNyk7XG5cbmZ1bmN0aW9uIExheW91dChpc1JlbW90ZVVzZSkge1xuICBFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgLy9MYXlvdXQgUXVhbGl0eTogMDpkcmFmdCwgMTpkZWZhdWx0LCAyOnByb29mXG4gIHRoaXMubGF5b3V0UXVhbGl0eSA9IExheW91dENvbnN0YW50cy5RVUFMSVRZO1xuICAvL1doZXRoZXIgbGF5b3V0IHNob3VsZCBjcmVhdGUgYmVuZHBvaW50cyBhcyBuZWVkZWQgb3Igbm90XG4gIHRoaXMuY3JlYXRlQmVuZHNBc05lZWRlZCA9IExheW91dENvbnN0YW50cy5ERUZBVUxUX0NSRUFURV9CRU5EU19BU19ORUVERUQ7XG4gIC8vV2hldGhlciBsYXlvdXQgc2hvdWxkIGJlIGluY3JlbWVudGFsIG9yIG5vdFxuICB0aGlzLmluY3JlbWVudGFsID0gTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfSU5DUkVNRU5UQUw7XG4gIC8vV2hldGhlciB3ZSBhbmltYXRlIGZyb20gYmVmb3JlIHRvIGFmdGVyIGxheW91dCBub2RlIHBvc2l0aW9uc1xuICB0aGlzLmFuaW1hdGlvbk9uTGF5b3V0ID0gTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQU5JTUFUSU9OX09OX0xBWU9VVDtcbiAgLy9XaGV0aGVyIHdlIGFuaW1hdGUgdGhlIGxheW91dCBwcm9jZXNzIG9yIG5vdFxuICB0aGlzLmFuaW1hdGlvbkR1cmluZ0xheW91dCA9IExheW91dENvbnN0YW50cy5ERUZBVUxUX0FOSU1BVElPTl9EVVJJTkdfTEFZT1VUO1xuICAvL051bWJlciBpdGVyYXRpb25zIHRoYXQgc2hvdWxkIGJlIGRvbmUgYmV0d2VlbiB0d28gc3VjY2Vzc2l2ZSBhbmltYXRpb25zXG4gIHRoaXMuYW5pbWF0aW9uUGVyaW9kID0gTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQU5JTUFUSU9OX1BFUklPRDtcbiAgLyoqXHJcbiAgICogV2hldGhlciBvciBub3QgbGVhZiBub2RlcyAobm9uLWNvbXBvdW5kIG5vZGVzKSBhcmUgb2YgdW5pZm9ybSBzaXplcy4gV2hlblxyXG4gICAqIHRoZXkgYXJlLCBib3RoIHNwcmluZyBhbmQgcmVwdWxzaW9uIGZvcmNlcyBiZXR3ZWVuIHR3byBsZWFmIG5vZGVzIGNhbiBiZVxyXG4gICAqIGNhbGN1bGF0ZWQgd2l0aG91dCB0aGUgZXhwZW5zaXZlIGNsaXBwaW5nIHBvaW50IGNhbGN1bGF0aW9ucywgcmVzdWx0aW5nXHJcbiAgICogaW4gbWFqb3Igc3BlZWQtdXAuXHJcbiAgICovXG4gIHRoaXMudW5pZm9ybUxlYWZOb2RlU2l6ZXMgPSBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9VTklGT1JNX0xFQUZfTk9ERV9TSVpFUztcbiAgLyoqXHJcbiAgICogVGhpcyBpcyB1c2VkIGZvciBjcmVhdGlvbiBvZiBiZW5kcG9pbnRzIGJ5IHVzaW5nIGR1bW15IG5vZGVzIGFuZCBlZGdlcy5cclxuICAgKiBNYXBzIGFuIExFZGdlIHRvIGl0cyBkdW1teSBiZW5kcG9pbnQgcGF0aC5cclxuICAgKi9cbiAgdGhpcy5lZGdlVG9EdW1teU5vZGVzID0gbmV3IE1hcCgpO1xuICB0aGlzLmdyYXBoTWFuYWdlciA9IG5ldyBMR3JhcGhNYW5hZ2VyKHRoaXMpO1xuICB0aGlzLmlzTGF5b3V0RmluaXNoZWQgPSBmYWxzZTtcbiAgdGhpcy5pc1N1YkxheW91dCA9IGZhbHNlO1xuICB0aGlzLmlzUmVtb3RlVXNlID0gZmFsc2U7XG5cbiAgaWYgKGlzUmVtb3RlVXNlICE9IG51bGwpIHtcbiAgICB0aGlzLmlzUmVtb3RlVXNlID0gaXNSZW1vdGVVc2U7XG4gIH1cbn1cblxuTGF5b3V0LlJBTkRPTV9TRUVEID0gMTtcblxuTGF5b3V0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRW1pdHRlci5wcm90b3R5cGUpO1xuXG5MYXlvdXQucHJvdG90eXBlLmdldEdyYXBoTWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZ3JhcGhNYW5hZ2VyO1xufTtcblxuTGF5b3V0LnByb3RvdHlwZS5nZXRBbGxOb2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZ3JhcGhNYW5hZ2VyLmdldEFsbE5vZGVzKCk7XG59O1xuXG5MYXlvdXQucHJvdG90eXBlLmdldEFsbEVkZ2VzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ncmFwaE1hbmFnZXIuZ2V0QWxsRWRnZXMoKTtcbn07XG5cbkxheW91dC5wcm90b3R5cGUuZ2V0QWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmdyYXBoTWFuYWdlci5nZXRBbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbigpO1xufTtcblxuTGF5b3V0LnByb3RvdHlwZS5uZXdHcmFwaE1hbmFnZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBnbSA9IG5ldyBMR3JhcGhNYW5hZ2VyKHRoaXMpO1xuICB0aGlzLmdyYXBoTWFuYWdlciA9IGdtO1xuICByZXR1cm4gZ207XG59O1xuXG5MYXlvdXQucHJvdG90eXBlLm5ld0dyYXBoID0gZnVuY3Rpb24gKHZHcmFwaCkge1xuICByZXR1cm4gbmV3IExHcmFwaChudWxsLCB0aGlzLmdyYXBoTWFuYWdlciwgdkdyYXBoKTtcbn07XG5cbkxheW91dC5wcm90b3R5cGUubmV3Tm9kZSA9IGZ1bmN0aW9uICh2Tm9kZSkge1xuICByZXR1cm4gbmV3IExOb2RlKHRoaXMuZ3JhcGhNYW5hZ2VyLCB2Tm9kZSk7XG59O1xuXG5MYXlvdXQucHJvdG90eXBlLm5ld0VkZ2UgPSBmdW5jdGlvbiAodkVkZ2UpIHtcbiAgcmV0dXJuIG5ldyBMRWRnZShudWxsLCBudWxsLCB2RWRnZSk7XG59O1xuXG5MYXlvdXQucHJvdG90eXBlLmNoZWNrTGF5b3V0U3VjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZ3JhcGhNYW5hZ2VyLmdldFJvb3QoKSA9PSBudWxsIHx8IHRoaXMuZ3JhcGhNYW5hZ2VyLmdldFJvb3QoKS5nZXROb2RlcygpLmxlbmd0aCA9PSAwIHx8IHRoaXMuZ3JhcGhNYW5hZ2VyLmluY2x1ZGVzSW52YWxpZEVkZ2UoKTtcbn07XG5cbkxheW91dC5wcm90b3R5cGUucnVuTGF5b3V0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmlzTGF5b3V0RmluaXNoZWQgPSBmYWxzZTtcblxuICBpZiAodGhpcy50aWxpbmdQcmVMYXlvdXQpIHtcbiAgICB0aGlzLnRpbGluZ1ByZUxheW91dCgpO1xuICB9XG5cbiAgdGhpcy5pbml0UGFyYW1ldGVycygpO1xuICB2YXIgaXNMYXlvdXRTdWNjZXNzZnVsbDtcblxuICBpZiAodGhpcy5jaGVja0xheW91dFN1Y2Nlc3MoKSkge1xuICAgIGlzTGF5b3V0U3VjY2Vzc2Z1bGwgPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICBpc0xheW91dFN1Y2Nlc3NmdWxsID0gdGhpcy5sYXlvdXQoKTtcbiAgfVxuXG4gIGlmIChMYXlvdXRDb25zdGFudHMuQU5JTUFURSA9PT0gJ2R1cmluZycpIHtcbiAgICAvLyBJZiB0aGlzIGlzIGEgJ2R1cmluZycgbGF5b3V0IGFuaW1hdGlvbi4gTGF5b3V0IGlzIG5vdCBmaW5pc2hlZCB5ZXQuIFxuICAgIC8vIFdlIG5lZWQgdG8gcGVyZm9ybSB0aGVzZSBpbiBpbmRleC5qcyB3aGVuIGxheW91dCBpcyByZWFsbHkgZmluaXNoZWQuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGlzTGF5b3V0U3VjY2Vzc2Z1bGwpIHtcbiAgICBpZiAoIXRoaXMuaXNTdWJMYXlvdXQpIHtcbiAgICAgIHRoaXMuZG9Qb3N0TGF5b3V0KCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMudGlsaW5nUG9zdExheW91dCkge1xuICAgIHRoaXMudGlsaW5nUG9zdExheW91dCgpO1xuICB9XG5cbiAgdGhpcy5pc0xheW91dEZpbmlzaGVkID0gdHJ1ZTtcblxuICByZXR1cm4gaXNMYXlvdXRTdWNjZXNzZnVsbDtcbn07XG5cbi8qKlxyXG4gKiBUaGlzIG1ldGhvZCBwZXJmb3JtcyB0aGUgb3BlcmF0aW9ucyByZXF1aXJlZCBhZnRlciBsYXlvdXQuXHJcbiAqL1xuTGF5b3V0LnByb3RvdHlwZS5kb1Bvc3RMYXlvdXQgPSBmdW5jdGlvbiAoKSB7XG4gIC8vYXNzZXJ0ICFpc1N1YkxheW91dCA6IFwiU2hvdWxkIG5vdCBiZSBjYWxsZWQgb24gc3ViLWxheW91dCFcIjtcbiAgLy8gUHJvcGFnYXRlIGdlb21ldHJpYyBjaGFuZ2VzIHRvIHYtbGV2ZWwgb2JqZWN0c1xuICBpZiAoIXRoaXMuaW5jcmVtZW50YWwpIHtcbiAgICB0aGlzLnRyYW5zZm9ybSgpO1xuICB9XG4gIHRoaXMudXBkYXRlKCk7XG59O1xuXG4vKipcclxuICogVGhpcyBtZXRob2QgdXBkYXRlcyB0aGUgZ2VvbWV0cnkgb2YgdGhlIHRhcmdldCBncmFwaCBhY2NvcmRpbmcgdG9cclxuICogY2FsY3VsYXRlZCBsYXlvdXQuXHJcbiAqL1xuTGF5b3V0LnByb3RvdHlwZS51cGRhdGUyID0gZnVuY3Rpb24gKCkge1xuICAvLyB1cGRhdGUgYmVuZCBwb2ludHNcbiAgaWYgKHRoaXMuY3JlYXRlQmVuZHNBc05lZWRlZCkge1xuICAgIHRoaXMuY3JlYXRlQmVuZHBvaW50c0Zyb21EdW1teU5vZGVzKCk7XG5cbiAgICAvLyByZXNldCBhbGwgZWRnZXMsIHNpbmNlIHRoZSB0b3BvbG9neSBoYXMgY2hhbmdlZFxuICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnJlc2V0QWxsRWRnZXMoKTtcbiAgfVxuXG4gIC8vIHBlcmZvcm0gZWRnZSwgbm9kZSBhbmQgcm9vdCB1cGRhdGVzIGlmIGxheW91dCBpcyBub3QgY2FsbGVkXG4gIC8vIHJlbW90ZWx5XG4gIGlmICghdGhpcy5pc1JlbW90ZVVzZSkge1xuICAgIC8vIHVwZGF0ZSBhbGwgZWRnZXNcbiAgICB2YXIgZWRnZTtcbiAgICB2YXIgYWxsRWRnZXMgPSB0aGlzLmdyYXBoTWFuYWdlci5nZXRBbGxFZGdlcygpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsRWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGVkZ2UgPSBhbGxFZGdlc1tpXTtcbiAgICAgIC8vICAgICAgdGhpcy51cGRhdGUoZWRnZSk7XG4gICAgfVxuXG4gICAgLy8gcmVjdXJzaXZlbHkgdXBkYXRlIG5vZGVzXG4gICAgdmFyIG5vZGU7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5ncmFwaE1hbmFnZXIuZ2V0Um9vdCgpLmdldE5vZGVzKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgLy8gICAgICB0aGlzLnVwZGF0ZShub2RlKTtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgcm9vdCBncmFwaFxuICAgIHRoaXMudXBkYXRlKHRoaXMuZ3JhcGhNYW5hZ2VyLmdldFJvb3QoKSk7XG4gIH1cbn07XG5cbkxheW91dC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKG9iaikge1xuICBpZiAob2JqID09IG51bGwpIHtcbiAgICB0aGlzLnVwZGF0ZTIoKTtcbiAgfSBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBMTm9kZSkge1xuICAgIHZhciBub2RlID0gb2JqO1xuICAgIGlmIChub2RlLmdldENoaWxkKCkgIT0gbnVsbCkge1xuICAgICAgLy8gc2luY2Ugbm9kZSBpcyBjb21wb3VuZCwgcmVjdXJzaXZlbHkgdXBkYXRlIGNoaWxkIG5vZGVzXG4gICAgICB2YXIgbm9kZXMgPSBub2RlLmdldENoaWxkKCkuZ2V0Tm9kZXMoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdXBkYXRlKG5vZGVzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiB0aGUgbC1sZXZlbCBub2RlIGlzIGFzc29jaWF0ZWQgd2l0aCBhIHYtbGV2ZWwgZ3JhcGggb2JqZWN0LFxuICAgIC8vIHRoZW4gaXQgaXMgYXNzdW1lZCB0aGF0IHRoZSB2LWxldmVsIG5vZGUgaW1wbGVtZW50cyB0aGVcbiAgICAvLyBpbnRlcmZhY2UgVXBkYXRhYmxlLlxuICAgIGlmIChub2RlLnZHcmFwaE9iamVjdCAhPSBudWxsKSB7XG4gICAgICAvLyBjYXN0IHRvIFVwZGF0YWJsZSB3aXRob3V0IGFueSB0eXBlIGNoZWNrXG4gICAgICB2YXIgdk5vZGUgPSBub2RlLnZHcmFwaE9iamVjdDtcblxuICAgICAgLy8gY2FsbCB0aGUgdXBkYXRlIG1ldGhvZCBvZiB0aGUgaW50ZXJmYWNlXG4gICAgICB2Tm9kZS51cGRhdGUobm9kZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIExFZGdlKSB7XG4gICAgdmFyIGVkZ2UgPSBvYmo7XG4gICAgLy8gaWYgdGhlIGwtbGV2ZWwgZWRnZSBpcyBhc3NvY2lhdGVkIHdpdGggYSB2LWxldmVsIGdyYXBoIG9iamVjdCxcbiAgICAvLyB0aGVuIGl0IGlzIGFzc3VtZWQgdGhhdCB0aGUgdi1sZXZlbCBlZGdlIGltcGxlbWVudHMgdGhlXG4gICAgLy8gaW50ZXJmYWNlIFVwZGF0YWJsZS5cblxuICAgIGlmIChlZGdlLnZHcmFwaE9iamVjdCAhPSBudWxsKSB7XG4gICAgICAvLyBjYXN0IHRvIFVwZGF0YWJsZSB3aXRob3V0IGFueSB0eXBlIGNoZWNrXG4gICAgICB2YXIgdkVkZ2UgPSBlZGdlLnZHcmFwaE9iamVjdDtcblxuICAgICAgLy8gY2FsbCB0aGUgdXBkYXRlIG1ldGhvZCBvZiB0aGUgaW50ZXJmYWNlXG4gICAgICB2RWRnZS51cGRhdGUoZWRnZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIExHcmFwaCkge1xuICAgIHZhciBncmFwaCA9IG9iajtcbiAgICAvLyBpZiB0aGUgbC1sZXZlbCBncmFwaCBpcyBhc3NvY2lhdGVkIHdpdGggYSB2LWxldmVsIGdyYXBoIG9iamVjdCxcbiAgICAvLyB0aGVuIGl0IGlzIGFzc3VtZWQgdGhhdCB0aGUgdi1sZXZlbCBvYmplY3QgaW1wbGVtZW50cyB0aGVcbiAgICAvLyBpbnRlcmZhY2UgVXBkYXRhYmxlLlxuXG4gICAgaWYgKGdyYXBoLnZHcmFwaE9iamVjdCAhPSBudWxsKSB7XG4gICAgICAvLyBjYXN0IHRvIFVwZGF0YWJsZSB3aXRob3V0IGFueSB0eXBlIGNoZWNrXG4gICAgICB2YXIgdkdyYXBoID0gZ3JhcGgudkdyYXBoT2JqZWN0O1xuXG4gICAgICAvLyBjYWxsIHRoZSB1cGRhdGUgbWV0aG9kIG9mIHRoZSBpbnRlcmZhY2VcbiAgICAgIHZHcmFwaC51cGRhdGUoZ3JhcGgpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXHJcbiAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgdG8gc2V0IGFsbCBsYXlvdXQgcGFyYW1ldGVycyB0byBkZWZhdWx0IHZhbHVlc1xyXG4gKiBkZXRlcm1pbmVkIGF0IGNvbXBpbGUgdGltZS5cclxuICovXG5MYXlvdXQucHJvdG90eXBlLmluaXRQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuaXNTdWJMYXlvdXQpIHtcbiAgICB0aGlzLmxheW91dFF1YWxpdHkgPSBMYXlvdXRDb25zdGFudHMuUVVBTElUWTtcbiAgICB0aGlzLmFuaW1hdGlvbkR1cmluZ0xheW91dCA9IExheW91dENvbnN0YW50cy5ERUZBVUxUX0FOSU1BVElPTl9EVVJJTkdfTEFZT1VUO1xuICAgIHRoaXMuYW5pbWF0aW9uUGVyaW9kID0gTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQU5JTUFUSU9OX1BFUklPRDtcbiAgICB0aGlzLmFuaW1hdGlvbk9uTGF5b3V0ID0gTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQU5JTUFUSU9OX09OX0xBWU9VVDtcbiAgICB0aGlzLmluY3JlbWVudGFsID0gTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfSU5DUkVNRU5UQUw7XG4gICAgdGhpcy5jcmVhdGVCZW5kc0FzTmVlZGVkID0gTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQ1JFQVRFX0JFTkRTX0FTX05FRURFRDtcbiAgICB0aGlzLnVuaWZvcm1MZWFmTm9kZVNpemVzID0gTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfVU5JRk9STV9MRUFGX05PREVfU0laRVM7XG4gIH1cblxuICBpZiAodGhpcy5hbmltYXRpb25EdXJpbmdMYXlvdXQpIHtcbiAgICB0aGlzLmFuaW1hdGlvbk9uTGF5b3V0ID0gZmFsc2U7XG4gIH1cbn07XG5cbkxheW91dC5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24gKG5ld0xlZnRUb3ApIHtcbiAgaWYgKG5ld0xlZnRUb3AgPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy50cmFuc2Zvcm0obmV3IFBvaW50RCgwLCAwKSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gY3JlYXRlIGEgdHJhbnNmb3JtYXRpb24gb2JqZWN0IChmcm9tIEVjbGlwc2UgdG8gbGF5b3V0KS4gV2hlbiBhblxuICAgIC8vIGludmVyc2UgdHJhbnNmb3JtIGlzIGFwcGxpZWQsIHdlIGdldCB1cHBlci1sZWZ0IGNvb3JkaW5hdGUgb2YgdGhlXG4gICAgLy8gZHJhd2luZyBvciB0aGUgcm9vdCBncmFwaCBhdCBnaXZlbiBpbnB1dCBjb29yZGluYXRlIChzb21lIG1hcmdpbnNcbiAgICAvLyBhbHJlYWR5IGluY2x1ZGVkIGluIGNhbGN1bGF0aW9uIG9mIGxlZnQtdG9wKS5cblxuICAgIHZhciB0cmFucyA9IG5ldyBUcmFuc2Zvcm0oKTtcbiAgICB2YXIgbGVmdFRvcCA9IHRoaXMuZ3JhcGhNYW5hZ2VyLmdldFJvb3QoKS51cGRhdGVMZWZ0VG9wKCk7XG5cbiAgICBpZiAobGVmdFRvcCAhPSBudWxsKSB7XG4gICAgICB0cmFucy5zZXRXb3JsZE9yZ1gobmV3TGVmdFRvcC54KTtcbiAgICAgIHRyYW5zLnNldFdvcmxkT3JnWShuZXdMZWZ0VG9wLnkpO1xuXG4gICAgICB0cmFucy5zZXREZXZpY2VPcmdYKGxlZnRUb3AueCk7XG4gICAgICB0cmFucy5zZXREZXZpY2VPcmdZKGxlZnRUb3AueSk7XG5cbiAgICAgIHZhciBub2RlcyA9IHRoaXMuZ2V0QWxsTm9kZXMoKTtcbiAgICAgIHZhciBub2RlO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgbm9kZS50cmFuc2Zvcm0odHJhbnMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuTGF5b3V0LnByb3RvdHlwZS5wb3NpdGlvbk5vZGVzUmFuZG9tbHkgPSBmdW5jdGlvbiAoZ3JhcGgpIHtcblxuICBpZiAoZ3JhcGggPT0gdW5kZWZpbmVkKSB7XG4gICAgLy9hc3NlcnQgIXRoaXMuaW5jcmVtZW50YWw7XG4gICAgdGhpcy5wb3NpdGlvbk5vZGVzUmFuZG9tbHkodGhpcy5nZXRHcmFwaE1hbmFnZXIoKS5nZXRSb290KCkpO1xuICAgIHRoaXMuZ2V0R3JhcGhNYW5hZ2VyKCkuZ2V0Um9vdCgpLnVwZGF0ZUJvdW5kcyh0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbE5vZGU7XG4gICAgdmFyIGNoaWxkR3JhcGg7XG5cbiAgICB2YXIgbm9kZXMgPSBncmFwaC5nZXROb2RlcygpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxOb2RlID0gbm9kZXNbaV07XG4gICAgICBjaGlsZEdyYXBoID0gbE5vZGUuZ2V0Q2hpbGQoKTtcblxuICAgICAgaWYgKGNoaWxkR3JhcGggPT0gbnVsbCkge1xuICAgICAgICBsTm9kZS5zY2F0dGVyKCk7XG4gICAgICB9IGVsc2UgaWYgKGNoaWxkR3JhcGguZ2V0Tm9kZXMoKS5sZW5ndGggPT0gMCkge1xuICAgICAgICBsTm9kZS5zY2F0dGVyKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBvc2l0aW9uTm9kZXNSYW5kb21seShjaGlsZEdyYXBoKTtcbiAgICAgICAgbE5vZGUudXBkYXRlQm91bmRzKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcclxuICogVGhpcyBtZXRob2QgcmV0dXJucyBhIGxpc3Qgb2YgdHJlZXMgd2hlcmUgZWFjaCB0cmVlIGlzIHJlcHJlc2VudGVkIGFzIGFcclxuICogbGlzdCBvZiBsLW5vZGVzLiBUaGUgbWV0aG9kIHJldHVybnMgYSBsaXN0IG9mIHNpemUgMCB3aGVuOlxyXG4gKiAtIFRoZSBncmFwaCBpcyBub3QgZmxhdCBvclxyXG4gKiAtIE9uZSBvZiB0aGUgY29tcG9uZW50KHMpIG9mIHRoZSBncmFwaCBpcyBub3QgYSB0cmVlLlxyXG4gKi9cbkxheW91dC5wcm90b3R5cGUuZ2V0RmxhdEZvcmVzdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGZsYXRGb3Jlc3QgPSBbXTtcbiAgdmFyIGlzRm9yZXN0ID0gdHJ1ZTtcblxuICAvLyBRdWljayByZWZlcmVuY2UgZm9yIGFsbCBub2RlcyBpbiB0aGUgZ3JhcGggbWFuYWdlciBhc3NvY2lhdGVkIHdpdGhcbiAgLy8gdGhpcyBsYXlvdXQuIFRoZSBsaXN0IHNob3VsZCBub3QgYmUgY2hhbmdlZC5cbiAgdmFyIGFsbE5vZGVzID0gdGhpcy5ncmFwaE1hbmFnZXIuZ2V0Um9vdCgpLmdldE5vZGVzKCk7XG5cbiAgLy8gRmlyc3QgYmUgc3VyZSB0aGF0IHRoZSBncmFwaCBpcyBmbGF0XG4gIHZhciBpc0ZsYXQgPSB0cnVlO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYWxsTm9kZXNbaV0uZ2V0Q2hpbGQoKSAhPSBudWxsKSB7XG4gICAgICBpc0ZsYXQgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvLyBSZXR1cm4gZW1wdHkgZm9yZXN0IGlmIHRoZSBncmFwaCBpcyBub3QgZmxhdC5cbiAgaWYgKCFpc0ZsYXQpIHtcbiAgICByZXR1cm4gZmxhdEZvcmVzdDtcbiAgfVxuXG4gIC8vIFJ1biBCRlMgZm9yIGVhY2ggY29tcG9uZW50IG9mIHRoZSBncmFwaC5cblxuICB2YXIgdmlzaXRlZCA9IG5ldyBTZXQoKTtcbiAgdmFyIHRvQmVWaXNpdGVkID0gW107XG4gIHZhciBwYXJlbnRzID0gbmV3IE1hcCgpO1xuICB2YXIgdW5Qcm9jZXNzZWROb2RlcyA9IFtdO1xuXG4gIHVuUHJvY2Vzc2VkTm9kZXMgPSB1blByb2Nlc3NlZE5vZGVzLmNvbmNhdChhbGxOb2Rlcyk7XG5cbiAgLy8gRWFjaCBpdGVyYXRpb24gb2YgdGhpcyBsb29wIGZpbmRzIGEgY29tcG9uZW50IG9mIHRoZSBncmFwaCBhbmRcbiAgLy8gZGVjaWRlcyB3aGV0aGVyIGl0IGlzIGEgdHJlZSBvciBub3QuIElmIGl0IGlzIGEgdHJlZSwgYWRkcyBpdCB0byB0aGVcbiAgLy8gZm9yZXN0IGFuZCBjb250aW51ZWQgd2l0aCB0aGUgbmV4dCBjb21wb25lbnQuXG5cbiAgd2hpbGUgKHVuUHJvY2Vzc2VkTm9kZXMubGVuZ3RoID4gMCAmJiBpc0ZvcmVzdCkge1xuICAgIHRvQmVWaXNpdGVkLnB1c2godW5Qcm9jZXNzZWROb2Rlc1swXSk7XG5cbiAgICAvLyBTdGFydCB0aGUgQkZTLiBFYWNoIGl0ZXJhdGlvbiBvZiB0aGlzIGxvb3AgdmlzaXRzIGEgbm9kZSBpbiBhXG4gICAgLy8gQkZTIG1hbm5lci5cbiAgICB3aGlsZSAodG9CZVZpc2l0ZWQubGVuZ3RoID4gMCAmJiBpc0ZvcmVzdCkge1xuICAgICAgLy9wb29sIG9wZXJhdGlvblxuICAgICAgdmFyIGN1cnJlbnROb2RlID0gdG9CZVZpc2l0ZWRbMF07XG4gICAgICB0b0JlVmlzaXRlZC5zcGxpY2UoMCwgMSk7XG4gICAgICB2aXNpdGVkLmFkZChjdXJyZW50Tm9kZSk7XG5cbiAgICAgIC8vIFRyYXZlcnNlIGFsbCBuZWlnaGJvcnMgb2YgdGhpcyBub2RlXG4gICAgICB2YXIgbmVpZ2hib3JFZGdlcyA9IGN1cnJlbnROb2RlLmdldEVkZ2VzKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmVpZ2hib3JFZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY3VycmVudE5laWdoYm9yID0gbmVpZ2hib3JFZGdlc1tpXS5nZXRPdGhlckVuZChjdXJyZW50Tm9kZSk7XG5cbiAgICAgICAgLy8gSWYgQkZTIGlzIG5vdCBncm93aW5nIGZyb20gdGhpcyBuZWlnaGJvci5cbiAgICAgICAgaWYgKHBhcmVudHMuZ2V0KGN1cnJlbnROb2RlKSAhPSBjdXJyZW50TmVpZ2hib3IpIHtcbiAgICAgICAgICAvLyBXZSBoYXZlbid0IHByZXZpb3VzbHkgdmlzaXRlZCB0aGlzIG5laWdoYm9yLlxuICAgICAgICAgIGlmICghdmlzaXRlZC5oYXMoY3VycmVudE5laWdoYm9yKSkge1xuICAgICAgICAgICAgdG9CZVZpc2l0ZWQucHVzaChjdXJyZW50TmVpZ2hib3IpO1xuICAgICAgICAgICAgcGFyZW50cy5zZXQoY3VycmVudE5laWdoYm9yLCBjdXJyZW50Tm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFNpbmNlIHdlIGhhdmUgcHJldmlvdXNseSB2aXNpdGVkIHRoaXMgbmVpZ2hib3IgYW5kXG4gICAgICAgICAgLy8gdGhpcyBuZWlnaGJvciBpcyBub3QgcGFyZW50IG9mIGN1cnJlbnROb2RlLCBnaXZlblxuICAgICAgICAgIC8vIGdyYXBoIGNvbnRhaW5zIGEgY29tcG9uZW50IHRoYXQgaXMgbm90IHRyZWUsIGhlbmNlXG4gICAgICAgICAgLy8gaXQgaXMgbm90IGEgZm9yZXN0LlxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBpc0ZvcmVzdCA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoZSBncmFwaCBjb250YWlucyBhIGNvbXBvbmVudCB0aGF0IGlzIG5vdCBhIHRyZWUuIEVtcHR5XG4gICAgLy8gcHJldmlvdXNseSBmb3VuZCB0cmVlcy4gVGhlIG1ldGhvZCB3aWxsIGVuZC5cbiAgICBpZiAoIWlzRm9yZXN0KSB7XG4gICAgICBmbGF0Rm9yZXN0ID0gW107XG4gICAgfVxuICAgIC8vIFNhdmUgY3VycmVudGx5IHZpc2l0ZWQgbm9kZXMgYXMgYSB0cmVlIGluIG91ciBmb3Jlc3QuIFJlc2V0XG4gICAgLy8gdmlzaXRlZCBhbmQgcGFyZW50cyBsaXN0cy4gQ29udGludWUgd2l0aCB0aGUgbmV4dCBjb21wb25lbnQgb2ZcbiAgICAvLyB0aGUgZ3JhcGgsIGlmIGFueS5cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIHRlbXAgPSBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHZpc2l0ZWQpKTtcbiAgICAgICAgZmxhdEZvcmVzdC5wdXNoKHRlbXApO1xuICAgICAgICAvL2ZsYXRGb3Jlc3QgPSBmbGF0Rm9yZXN0LmNvbmNhdCh0ZW1wKTtcbiAgICAgICAgLy91blByb2Nlc3NlZE5vZGVzLnJlbW92ZUFsbCh2aXNpdGVkKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZW1wLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gdGVtcFtpXTtcbiAgICAgICAgICB2YXIgaW5kZXggPSB1blByb2Nlc3NlZE5vZGVzLmluZGV4T2YodmFsdWUpO1xuICAgICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICB1blByb2Nlc3NlZE5vZGVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZpc2l0ZWQgPSBuZXcgU2V0KCk7XG4gICAgICAgIHBhcmVudHMgPSBuZXcgTWFwKCk7XG4gICAgICB9XG4gIH1cblxuICByZXR1cm4gZmxhdEZvcmVzdDtcbn07XG5cbi8qKlxyXG4gKiBUaGlzIG1ldGhvZCBjcmVhdGVzIGR1bW15IG5vZGVzIChhbiBsLWxldmVsIG5vZGUgd2l0aCBtaW5pbWFsIGRpbWVuc2lvbnMpXHJcbiAqIGZvciB0aGUgZ2l2ZW4gZWRnZSAob25lIHBlciBiZW5kcG9pbnQpLiBUaGUgZXhpc3RpbmcgbC1sZXZlbCBzdHJ1Y3R1cmVcclxuICogaXMgdXBkYXRlZCBhY2NvcmRpbmdseS5cclxuICovXG5MYXlvdXQucHJvdG90eXBlLmNyZWF0ZUR1bW15Tm9kZXNGb3JCZW5kcG9pbnRzID0gZnVuY3Rpb24gKGVkZ2UpIHtcbiAgdmFyIGR1bW15Tm9kZXMgPSBbXTtcbiAgdmFyIHByZXYgPSBlZGdlLnNvdXJjZTtcblxuICB2YXIgZ3JhcGggPSB0aGlzLmdyYXBoTWFuYWdlci5jYWxjTG93ZXN0Q29tbW9uQW5jZXN0b3IoZWRnZS5zb3VyY2UsIGVkZ2UudGFyZ2V0KTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2UuYmVuZHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgIC8vIGNyZWF0ZSBuZXcgZHVtbXkgbm9kZVxuICAgIHZhciBkdW1teU5vZGUgPSB0aGlzLm5ld05vZGUobnVsbCk7XG4gICAgZHVtbXlOb2RlLnNldFJlY3QobmV3IFBvaW50KDAsIDApLCBuZXcgRGltZW5zaW9uKDEsIDEpKTtcblxuICAgIGdyYXBoLmFkZChkdW1teU5vZGUpO1xuXG4gICAgLy8gY3JlYXRlIG5ldyBkdW1teSBlZGdlIGJldHdlZW4gcHJldiBhbmQgZHVtbXkgbm9kZVxuICAgIHZhciBkdW1teUVkZ2UgPSB0aGlzLm5ld0VkZ2UobnVsbCk7XG4gICAgdGhpcy5ncmFwaE1hbmFnZXIuYWRkKGR1bW15RWRnZSwgcHJldiwgZHVtbXlOb2RlKTtcblxuICAgIGR1bW15Tm9kZXMuYWRkKGR1bW15Tm9kZSk7XG4gICAgcHJldiA9IGR1bW15Tm9kZTtcbiAgfVxuXG4gIHZhciBkdW1teUVkZ2UgPSB0aGlzLm5ld0VkZ2UobnVsbCk7XG4gIHRoaXMuZ3JhcGhNYW5hZ2VyLmFkZChkdW1teUVkZ2UsIHByZXYsIGVkZ2UudGFyZ2V0KTtcblxuICB0aGlzLmVkZ2VUb0R1bW15Tm9kZXMuc2V0KGVkZ2UsIGR1bW15Tm9kZXMpO1xuXG4gIC8vIHJlbW92ZSByZWFsIGVkZ2UgZnJvbSBncmFwaCBtYW5hZ2VyIGlmIGl0IGlzIGludGVyLWdyYXBoXG4gIGlmIChlZGdlLmlzSW50ZXJHcmFwaCgpKSB7XG4gICAgdGhpcy5ncmFwaE1hbmFnZXIucmVtb3ZlKGVkZ2UpO1xuICB9XG4gIC8vIGVsc2UsIHJlbW92ZSB0aGUgZWRnZSBmcm9tIHRoZSBjdXJyZW50IGdyYXBoXG4gIGVsc2Uge1xuICAgICAgZ3JhcGgucmVtb3ZlKGVkZ2UpO1xuICAgIH1cblxuICByZXR1cm4gZHVtbXlOb2Rlcztcbn07XG5cbi8qKlxyXG4gKiBUaGlzIG1ldGhvZCBjcmVhdGVzIGJlbmRwb2ludHMgZm9yIGVkZ2VzIGZyb20gdGhlIGR1bW15IG5vZGVzXHJcbiAqIGF0IGwtbGV2ZWwuXHJcbiAqL1xuTGF5b3V0LnByb3RvdHlwZS5jcmVhdGVCZW5kcG9pbnRzRnJvbUR1bW15Tm9kZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBlZGdlcyA9IFtdO1xuICBlZGdlcyA9IGVkZ2VzLmNvbmNhdCh0aGlzLmdyYXBoTWFuYWdlci5nZXRBbGxFZGdlcygpKTtcbiAgZWRnZXMgPSBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHRoaXMuZWRnZVRvRHVtbXlOb2Rlcy5rZXlzKCkpKS5jb25jYXQoZWRnZXMpO1xuXG4gIGZvciAodmFyIGsgPSAwOyBrIDwgZWRnZXMubGVuZ3RoOyBrKyspIHtcbiAgICB2YXIgbEVkZ2UgPSBlZGdlc1trXTtcblxuICAgIGlmIChsRWRnZS5iZW5kcG9pbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBwYXRoID0gdGhpcy5lZGdlVG9EdW1teU5vZGVzLmdldChsRWRnZSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZHVtbXlOb2RlID0gcGF0aFtpXTtcbiAgICAgICAgdmFyIHAgPSBuZXcgUG9pbnREKGR1bW15Tm9kZS5nZXRDZW50ZXJYKCksIGR1bW15Tm9kZS5nZXRDZW50ZXJZKCkpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSBiZW5kcG9pbnQncyBsb2NhdGlvbiBhY2NvcmRpbmcgdG8gZHVtbXkgbm9kZVxuICAgICAgICB2YXIgZWJwID0gbEVkZ2UuYmVuZHBvaW50cy5nZXQoaSk7XG4gICAgICAgIGVicC54ID0gcC54O1xuICAgICAgICBlYnAueSA9IHAueTtcblxuICAgICAgICAvLyByZW1vdmUgdGhlIGR1bW15IG5vZGUsIGR1bW15IGVkZ2VzIGluY2lkZW50IHdpdGggdGhpc1xuICAgICAgICAvLyBkdW1teSBub2RlIGlzIGFsc28gcmVtb3ZlZCAod2l0aGluIHRoZSByZW1vdmUgbWV0aG9kKVxuICAgICAgICBkdW1teU5vZGUuZ2V0T3duZXIoKS5yZW1vdmUoZHVtbXlOb2RlKTtcbiAgICAgIH1cblxuICAgICAgLy8gYWRkIHRoZSByZWFsIGVkZ2UgdG8gZ3JhcGhcbiAgICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLmFkZChsRWRnZSwgbEVkZ2Uuc291cmNlLCBsRWRnZS50YXJnZXQpO1xuICAgIH1cbiAgfVxufTtcblxuTGF5b3V0LnRyYW5zZm9ybSA9IGZ1bmN0aW9uIChzbGlkZXJWYWx1ZSwgZGVmYXVsdFZhbHVlLCBtaW5EaXYsIG1heE11bCkge1xuICBpZiAobWluRGl2ICE9IHVuZGVmaW5lZCAmJiBtYXhNdWwgIT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHZhbHVlID0gZGVmYXVsdFZhbHVlO1xuXG4gICAgaWYgKHNsaWRlclZhbHVlIDw9IDUwKSB7XG4gICAgICB2YXIgbWluVmFsdWUgPSBkZWZhdWx0VmFsdWUgLyBtaW5EaXY7XG4gICAgICB2YWx1ZSAtPSAoZGVmYXVsdFZhbHVlIC0gbWluVmFsdWUpIC8gNTAgKiAoNTAgLSBzbGlkZXJWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBtYXhWYWx1ZSA9IGRlZmF1bHRWYWx1ZSAqIG1heE11bDtcbiAgICAgIHZhbHVlICs9IChtYXhWYWx1ZSAtIGRlZmF1bHRWYWx1ZSkgLyA1MCAqIChzbGlkZXJWYWx1ZSAtIDUwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGEsIGI7XG5cbiAgICBpZiAoc2xpZGVyVmFsdWUgPD0gNTApIHtcbiAgICAgIGEgPSA5LjAgKiBkZWZhdWx0VmFsdWUgLyA1MDAuMDtcbiAgICAgIGIgPSBkZWZhdWx0VmFsdWUgLyAxMC4wO1xuICAgIH0gZWxzZSB7XG4gICAgICBhID0gOS4wICogZGVmYXVsdFZhbHVlIC8gNTAuMDtcbiAgICAgIGIgPSAtOCAqIGRlZmF1bHRWYWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gYSAqIHNsaWRlclZhbHVlICsgYjtcbiAgfVxufTtcblxuLyoqXHJcbiAqIFRoaXMgbWV0aG9kIGZpbmRzIGFuZCByZXR1cm5zIHRoZSBjZW50ZXIgb2YgdGhlIGdpdmVuIG5vZGVzLCBhc3N1bWluZ1xyXG4gKiB0aGF0IHRoZSBnaXZlbiBub2RlcyBmb3JtIGEgdHJlZSBpbiB0aGVtc2VsdmVzLlxyXG4gKi9cbkxheW91dC5maW5kQ2VudGVyT2ZUcmVlID0gZnVuY3Rpb24gKG5vZGVzKSB7XG4gIHZhciBsaXN0ID0gW107XG4gIGxpc3QgPSBsaXN0LmNvbmNhdChub2Rlcyk7XG5cbiAgdmFyIHJlbW92ZWROb2RlcyA9IFtdO1xuICB2YXIgcmVtYWluaW5nRGVncmVlcyA9IG5ldyBNYXAoKTtcbiAgdmFyIGZvdW5kQ2VudGVyID0gZmFsc2U7XG4gIHZhciBjZW50ZXJOb2RlID0gbnVsbDtcblxuICBpZiAobGlzdC5sZW5ndGggPT0gMSB8fCBsaXN0Lmxlbmd0aCA9PSAyKSB7XG4gICAgZm91bmRDZW50ZXIgPSB0cnVlO1xuICAgIGNlbnRlck5vZGUgPSBsaXN0WzBdO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5vZGUgPSBsaXN0W2ldO1xuICAgIHZhciBkZWdyZWUgPSBub2RlLmdldE5laWdoYm9yc0xpc3QoKS5zaXplO1xuICAgIHJlbWFpbmluZ0RlZ3JlZXMuc2V0KG5vZGUsIG5vZGUuZ2V0TmVpZ2hib3JzTGlzdCgpLnNpemUpO1xuXG4gICAgaWYgKGRlZ3JlZSA9PSAxKSB7XG4gICAgICByZW1vdmVkTm9kZXMucHVzaChub2RlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgdGVtcExpc3QgPSBbXTtcbiAgdGVtcExpc3QgPSB0ZW1wTGlzdC5jb25jYXQocmVtb3ZlZE5vZGVzKTtcblxuICB3aGlsZSAoIWZvdW5kQ2VudGVyKSB7XG4gICAgdmFyIHRlbXBMaXN0MiA9IFtdO1xuICAgIHRlbXBMaXN0MiA9IHRlbXBMaXN0Mi5jb25jYXQodGVtcExpc3QpO1xuICAgIHRlbXBMaXN0ID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBub2RlID0gbGlzdFtpXTtcblxuICAgICAgdmFyIGluZGV4ID0gbGlzdC5pbmRleE9mKG5vZGUpO1xuICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgbGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmVpZ2hib3VycyA9IG5vZGUuZ2V0TmVpZ2hib3JzTGlzdCgpO1xuXG4gICAgICBuZWlnaGJvdXJzLmZvckVhY2goZnVuY3Rpb24gKG5laWdoYm91cikge1xuICAgICAgICBpZiAocmVtb3ZlZE5vZGVzLmluZGV4T2YobmVpZ2hib3VyKSA8IDApIHtcbiAgICAgICAgICB2YXIgb3RoZXJEZWdyZWUgPSByZW1haW5pbmdEZWdyZWVzLmdldChuZWlnaGJvdXIpO1xuICAgICAgICAgIHZhciBuZXdEZWdyZWUgPSBvdGhlckRlZ3JlZSAtIDE7XG5cbiAgICAgICAgICBpZiAobmV3RGVncmVlID09IDEpIHtcbiAgICAgICAgICAgIHRlbXBMaXN0LnB1c2gobmVpZ2hib3VyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZW1haW5pbmdEZWdyZWVzLnNldChuZWlnaGJvdXIsIG5ld0RlZ3JlZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJlbW92ZWROb2RlcyA9IHJlbW92ZWROb2Rlcy5jb25jYXQodGVtcExpc3QpO1xuXG4gICAgaWYgKGxpc3QubGVuZ3RoID09IDEgfHwgbGlzdC5sZW5ndGggPT0gMikge1xuICAgICAgZm91bmRDZW50ZXIgPSB0cnVlO1xuICAgICAgY2VudGVyTm9kZSA9IGxpc3RbMF07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNlbnRlck5vZGU7XG59O1xuXG4vKipcclxuICogRHVyaW5nIHRoZSBjb2Fyc2VuaW5nIHByb2Nlc3MsIHRoaXMgbGF5b3V0IG1heSBiZSByZWZlcmVuY2VkIGJ5IHR3byBncmFwaCBtYW5hZ2Vyc1xyXG4gKiB0aGlzIHNldHRlciBmdW5jdGlvbiBncmFudHMgYWNjZXNzIHRvIGNoYW5nZSB0aGUgY3VycmVudGx5IGJlaW5nIHVzZWQgZ3JhcGggbWFuYWdlclxyXG4gKi9cbkxheW91dC5wcm90b3R5cGUuc2V0R3JhcGhNYW5hZ2VyID0gZnVuY3Rpb24gKGdtKSB7XG4gIHRoaXMuZ3JhcGhNYW5hZ2VyID0gZ207XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExheW91dDtcblxuLyoqKi8gfSksXG4vKiAxNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBSYW5kb21TZWVkKCkge31cbi8vIGFkYXB0ZWQgZnJvbTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE5MzAzNzI1XG5SYW5kb21TZWVkLnNlZWQgPSAxO1xuUmFuZG9tU2VlZC54ID0gMDtcblxuUmFuZG9tU2VlZC5uZXh0RG91YmxlID0gZnVuY3Rpb24gKCkge1xuICBSYW5kb21TZWVkLnggPSBNYXRoLnNpbihSYW5kb21TZWVkLnNlZWQrKykgKiAxMDAwMDtcbiAgcmV0dXJuIFJhbmRvbVNlZWQueCAtIE1hdGguZmxvb3IoUmFuZG9tU2VlZC54KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmFuZG9tU2VlZDtcblxuLyoqKi8gfSksXG4vKiAxNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgUG9pbnREID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxuZnVuY3Rpb24gVHJhbnNmb3JtKHgsIHkpIHtcbiAgdGhpcy5sd29ybGRPcmdYID0gMC4wO1xuICB0aGlzLmx3b3JsZE9yZ1kgPSAwLjA7XG4gIHRoaXMubGRldmljZU9yZ1ggPSAwLjA7XG4gIHRoaXMubGRldmljZU9yZ1kgPSAwLjA7XG4gIHRoaXMubHdvcmxkRXh0WCA9IDEuMDtcbiAgdGhpcy5sd29ybGRFeHRZID0gMS4wO1xuICB0aGlzLmxkZXZpY2VFeHRYID0gMS4wO1xuICB0aGlzLmxkZXZpY2VFeHRZID0gMS4wO1xufVxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLmdldFdvcmxkT3JnWCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubHdvcmxkT3JnWDtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuc2V0V29ybGRPcmdYID0gZnVuY3Rpb24gKHdveCkge1xuICB0aGlzLmx3b3JsZE9yZ1ggPSB3b3g7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLmdldFdvcmxkT3JnWSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubHdvcmxkT3JnWTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuc2V0V29ybGRPcmdZID0gZnVuY3Rpb24gKHdveSkge1xuICB0aGlzLmx3b3JsZE9yZ1kgPSB3b3k7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLmdldFdvcmxkRXh0WCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubHdvcmxkRXh0WDtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuc2V0V29ybGRFeHRYID0gZnVuY3Rpb24gKHdleCkge1xuICB0aGlzLmx3b3JsZEV4dFggPSB3ZXg7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLmdldFdvcmxkRXh0WSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubHdvcmxkRXh0WTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuc2V0V29ybGRFeHRZID0gZnVuY3Rpb24gKHdleSkge1xuICB0aGlzLmx3b3JsZEV4dFkgPSB3ZXk7XG59O1xuXG4vKiBEZXZpY2UgcmVsYXRlZCAqL1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLmdldERldmljZU9yZ1ggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmxkZXZpY2VPcmdYO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5zZXREZXZpY2VPcmdYID0gZnVuY3Rpb24gKGRveCkge1xuICB0aGlzLmxkZXZpY2VPcmdYID0gZG94O1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5nZXREZXZpY2VPcmdZID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sZGV2aWNlT3JnWTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuc2V0RGV2aWNlT3JnWSA9IGZ1bmN0aW9uIChkb3kpIHtcbiAgdGhpcy5sZGV2aWNlT3JnWSA9IGRveTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuZ2V0RGV2aWNlRXh0WCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubGRldmljZUV4dFg7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnNldERldmljZUV4dFggPSBmdW5jdGlvbiAoZGV4KSB7XG4gIHRoaXMubGRldmljZUV4dFggPSBkZXg7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLmdldERldmljZUV4dFkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmxkZXZpY2VFeHRZO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5zZXREZXZpY2VFeHRZID0gZnVuY3Rpb24gKGRleSkge1xuICB0aGlzLmxkZXZpY2VFeHRZID0gZGV5O1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS50cmFuc2Zvcm1YID0gZnVuY3Rpb24gKHgpIHtcbiAgdmFyIHhEZXZpY2UgPSAwLjA7XG4gIHZhciB3b3JsZEV4dFggPSB0aGlzLmx3b3JsZEV4dFg7XG4gIGlmICh3b3JsZEV4dFggIT0gMC4wKSB7XG4gICAgeERldmljZSA9IHRoaXMubGRldmljZU9yZ1ggKyAoeCAtIHRoaXMubHdvcmxkT3JnWCkgKiB0aGlzLmxkZXZpY2VFeHRYIC8gd29ybGRFeHRYO1xuICB9XG5cbiAgcmV0dXJuIHhEZXZpY2U7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnRyYW5zZm9ybVkgPSBmdW5jdGlvbiAoeSkge1xuICB2YXIgeURldmljZSA9IDAuMDtcbiAgdmFyIHdvcmxkRXh0WSA9IHRoaXMubHdvcmxkRXh0WTtcbiAgaWYgKHdvcmxkRXh0WSAhPSAwLjApIHtcbiAgICB5RGV2aWNlID0gdGhpcy5sZGV2aWNlT3JnWSArICh5IC0gdGhpcy5sd29ybGRPcmdZKSAqIHRoaXMubGRldmljZUV4dFkgLyB3b3JsZEV4dFk7XG4gIH1cblxuICByZXR1cm4geURldmljZTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuaW52ZXJzZVRyYW5zZm9ybVggPSBmdW5jdGlvbiAoeCkge1xuICB2YXIgeFdvcmxkID0gMC4wO1xuICB2YXIgZGV2aWNlRXh0WCA9IHRoaXMubGRldmljZUV4dFg7XG4gIGlmIChkZXZpY2VFeHRYICE9IDAuMCkge1xuICAgIHhXb3JsZCA9IHRoaXMubHdvcmxkT3JnWCArICh4IC0gdGhpcy5sZGV2aWNlT3JnWCkgKiB0aGlzLmx3b3JsZEV4dFggLyBkZXZpY2VFeHRYO1xuICB9XG5cbiAgcmV0dXJuIHhXb3JsZDtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuaW52ZXJzZVRyYW5zZm9ybVkgPSBmdW5jdGlvbiAoeSkge1xuICB2YXIgeVdvcmxkID0gMC4wO1xuICB2YXIgZGV2aWNlRXh0WSA9IHRoaXMubGRldmljZUV4dFk7XG4gIGlmIChkZXZpY2VFeHRZICE9IDAuMCkge1xuICAgIHlXb3JsZCA9IHRoaXMubHdvcmxkT3JnWSArICh5IC0gdGhpcy5sZGV2aWNlT3JnWSkgKiB0aGlzLmx3b3JsZEV4dFkgLyBkZXZpY2VFeHRZO1xuICB9XG4gIHJldHVybiB5V29ybGQ7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLmludmVyc2VUcmFuc2Zvcm1Qb2ludCA9IGZ1bmN0aW9uIChpblBvaW50KSB7XG4gIHZhciBvdXRQb2ludCA9IG5ldyBQb2ludEQodGhpcy5pbnZlcnNlVHJhbnNmb3JtWChpblBvaW50LngpLCB0aGlzLmludmVyc2VUcmFuc2Zvcm1ZKGluUG9pbnQueSkpO1xuICByZXR1cm4gb3V0UG9pbnQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcblxuLyoqKi8gfSksXG4vKiAxOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9IGVsc2UgeyByZXR1cm4gQXJyYXkuZnJvbShhcnIpOyB9IH1cblxudmFyIExheW91dCA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xudmFyIEZETGF5b3V0Q29uc3RhbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcbnZhciBMYXlvdXRDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIElHZW9tZXRyeSA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG52YXIgSU1hdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXG5mdW5jdGlvbiBGRExheW91dCgpIHtcbiAgTGF5b3V0LmNhbGwodGhpcyk7XG5cbiAgdGhpcy51c2VTbWFydElkZWFsRWRnZUxlbmd0aENhbGN1bGF0aW9uID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9VU0VfU01BUlRfSURFQUxfRURHRV9MRU5HVEhfQ0FMQ1VMQVRJT047XG4gIHRoaXMuaWRlYWxFZGdlTGVuZ3RoID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSDtcbiAgdGhpcy5zcHJpbmdDb25zdGFudCA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfU1BSSU5HX1NUUkVOR1RIO1xuICB0aGlzLnJlcHVsc2lvbkNvbnN0YW50ID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9SRVBVTFNJT05fU1RSRU5HVEg7XG4gIHRoaXMuZ3Jhdml0eUNvbnN0YW50ID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9HUkFWSVRZX1NUUkVOR1RIO1xuICB0aGlzLmNvbXBvdW5kR3Jhdml0eUNvbnN0YW50ID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9DT01QT1VORF9HUkFWSVRZX1NUUkVOR1RIO1xuICB0aGlzLmdyYXZpdHlSYW5nZUZhY3RvciA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfR1JBVklUWV9SQU5HRV9GQUNUT1I7XG4gIHRoaXMuY29tcG91bmRHcmF2aXR5UmFuZ2VGYWN0b3IgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0NPTVBPVU5EX0dSQVZJVFlfUkFOR0VfRkFDVE9SO1xuICB0aGlzLmRpc3BsYWNlbWVudFRocmVzaG9sZFBlck5vZGUgPSAzLjAgKiBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIIC8gMTAwO1xuICB0aGlzLmNvb2xpbmdGYWN0b3IgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0NPT0xJTkdfRkFDVE9SX0lOQ1JFTUVOVEFMO1xuICB0aGlzLmluaXRpYWxDb29saW5nRmFjdG9yID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9DT09MSU5HX0ZBQ1RPUl9JTkNSRU1FTlRBTDtcbiAgdGhpcy50b3RhbERpc3BsYWNlbWVudCA9IDAuMDtcbiAgdGhpcy5vbGRUb3RhbERpc3BsYWNlbWVudCA9IDAuMDtcbiAgdGhpcy5tYXhJdGVyYXRpb25zID0gRkRMYXlvdXRDb25zdGFudHMuTUFYX0lURVJBVElPTlM7XG59XG5cbkZETGF5b3V0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTGF5b3V0LnByb3RvdHlwZSk7XG5cbmZvciAodmFyIHByb3AgaW4gTGF5b3V0KSB7XG4gIEZETGF5b3V0W3Byb3BdID0gTGF5b3V0W3Byb3BdO1xufVxuXG5GRExheW91dC5wcm90b3R5cGUuaW5pdFBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7XG4gIExheW91dC5wcm90b3R5cGUuaW5pdFBhcmFtZXRlcnMuY2FsbCh0aGlzLCBhcmd1bWVudHMpO1xuXG4gIHRoaXMudG90YWxJdGVyYXRpb25zID0gMDtcbiAgdGhpcy5ub3RBbmltYXRlZEl0ZXJhdGlvbnMgPSAwO1xuXG4gIHRoaXMudXNlRlJHcmlkVmFyaWFudCA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfVVNFX1NNQVJUX1JFUFVMU0lPTl9SQU5HRV9DQUxDVUxBVElPTjtcblxuICB0aGlzLmdyaWQgPSBbXTtcbn07XG5cbkZETGF5b3V0LnByb3RvdHlwZS5jYWxjSWRlYWxFZGdlTGVuZ3RocyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVkZ2U7XG4gIHZhciBsY2FEZXB0aDtcbiAgdmFyIHNvdXJjZTtcbiAgdmFyIHRhcmdldDtcbiAgdmFyIHNpemVPZlNvdXJjZUluTGNhO1xuICB2YXIgc2l6ZU9mVGFyZ2V0SW5MY2E7XG5cbiAgdmFyIGFsbEVkZ2VzID0gdGhpcy5nZXRHcmFwaE1hbmFnZXIoKS5nZXRBbGxFZGdlcygpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbEVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgZWRnZSA9IGFsbEVkZ2VzW2ldO1xuXG4gICAgZWRnZS5pZGVhbExlbmd0aCA9IHRoaXMuaWRlYWxFZGdlTGVuZ3RoO1xuXG4gICAgaWYgKGVkZ2UuaXNJbnRlckdyYXBoKSB7XG4gICAgICBzb3VyY2UgPSBlZGdlLmdldFNvdXJjZSgpO1xuICAgICAgdGFyZ2V0ID0gZWRnZS5nZXRUYXJnZXQoKTtcblxuICAgICAgc2l6ZU9mU291cmNlSW5MY2EgPSBlZGdlLmdldFNvdXJjZUluTGNhKCkuZ2V0RXN0aW1hdGVkU2l6ZSgpO1xuICAgICAgc2l6ZU9mVGFyZ2V0SW5MY2EgPSBlZGdlLmdldFRhcmdldEluTGNhKCkuZ2V0RXN0aW1hdGVkU2l6ZSgpO1xuXG4gICAgICBpZiAodGhpcy51c2VTbWFydElkZWFsRWRnZUxlbmd0aENhbGN1bGF0aW9uKSB7XG4gICAgICAgIGVkZ2UuaWRlYWxMZW5ndGggKz0gc2l6ZU9mU291cmNlSW5MY2EgKyBzaXplT2ZUYXJnZXRJbkxjYSAtIDIgKiBMYXlvdXRDb25zdGFudHMuU0lNUExFX05PREVfU0laRTtcbiAgICAgIH1cblxuICAgICAgbGNhRGVwdGggPSBlZGdlLmdldExjYSgpLmdldEluY2x1c2lvblRyZWVEZXB0aCgpO1xuXG4gICAgICBlZGdlLmlkZWFsTGVuZ3RoICs9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggKiBGRExheW91dENvbnN0YW50cy5QRVJfTEVWRUxfSURFQUxfRURHRV9MRU5HVEhfRkFDVE9SICogKHNvdXJjZS5nZXRJbmNsdXNpb25UcmVlRGVwdGgoKSArIHRhcmdldC5nZXRJbmNsdXNpb25UcmVlRGVwdGgoKSAtIDIgKiBsY2FEZXB0aCk7XG4gICAgfVxuICB9XG59O1xuXG5GRExheW91dC5wcm90b3R5cGUuaW5pdFNwcmluZ0VtYmVkZGVyID0gZnVuY3Rpb24gKCkge1xuXG4gIHZhciBzID0gdGhpcy5nZXRBbGxOb2RlcygpLmxlbmd0aDtcbiAgaWYgKHRoaXMuaW5jcmVtZW50YWwpIHtcbiAgICBpZiAocyA+IEZETGF5b3V0Q29uc3RhbnRzLkFEQVBUQVRJT05fTE9XRVJfTk9ERV9MSU1JVCkge1xuICAgICAgdGhpcy5jb29saW5nRmFjdG9yID0gTWF0aC5tYXgodGhpcy5jb29saW5nRmFjdG9yICogRkRMYXlvdXRDb25zdGFudHMuQ09PTElOR19BREFQVEFUSU9OX0ZBQ1RPUiwgdGhpcy5jb29saW5nRmFjdG9yIC0gKHMgLSBGRExheW91dENvbnN0YW50cy5BREFQVEFUSU9OX0xPV0VSX05PREVfTElNSVQpIC8gKEZETGF5b3V0Q29uc3RhbnRzLkFEQVBUQVRJT05fVVBQRVJfTk9ERV9MSU1JVCAtIEZETGF5b3V0Q29uc3RhbnRzLkFEQVBUQVRJT05fTE9XRVJfTk9ERV9MSU1JVCkgKiB0aGlzLmNvb2xpbmdGYWN0b3IgKiAoMSAtIEZETGF5b3V0Q29uc3RhbnRzLkNPT0xJTkdfQURBUFRBVElPTl9GQUNUT1IpKTtcbiAgICB9XG4gICAgdGhpcy5tYXhOb2RlRGlzcGxhY2VtZW50ID0gRkRMYXlvdXRDb25zdGFudHMuTUFYX05PREVfRElTUExBQ0VNRU5UX0lOQ1JFTUVOVEFMO1xuICB9IGVsc2Uge1xuICAgIGlmIChzID4gRkRMYXlvdXRDb25zdGFudHMuQURBUFRBVElPTl9MT1dFUl9OT0RFX0xJTUlUKSB7XG4gICAgICB0aGlzLmNvb2xpbmdGYWN0b3IgPSBNYXRoLm1heChGRExheW91dENvbnN0YW50cy5DT09MSU5HX0FEQVBUQVRJT05fRkFDVE9SLCAxLjAgLSAocyAtIEZETGF5b3V0Q29uc3RhbnRzLkFEQVBUQVRJT05fTE9XRVJfTk9ERV9MSU1JVCkgLyAoRkRMYXlvdXRDb25zdGFudHMuQURBUFRBVElPTl9VUFBFUl9OT0RFX0xJTUlUIC0gRkRMYXlvdXRDb25zdGFudHMuQURBUFRBVElPTl9MT1dFUl9OT0RFX0xJTUlUKSAqICgxIC0gRkRMYXlvdXRDb25zdGFudHMuQ09PTElOR19BREFQVEFUSU9OX0ZBQ1RPUikpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvb2xpbmdGYWN0b3IgPSAxLjA7XG4gICAgfVxuICAgIHRoaXMuaW5pdGlhbENvb2xpbmdGYWN0b3IgPSB0aGlzLmNvb2xpbmdGYWN0b3I7XG4gICAgdGhpcy5tYXhOb2RlRGlzcGxhY2VtZW50ID0gRkRMYXlvdXRDb25zdGFudHMuTUFYX05PREVfRElTUExBQ0VNRU5UO1xuICB9XG5cbiAgdGhpcy5tYXhJdGVyYXRpb25zID0gTWF0aC5tYXgodGhpcy5nZXRBbGxOb2RlcygpLmxlbmd0aCAqIDUsIHRoaXMubWF4SXRlcmF0aW9ucyk7XG5cbiAgdGhpcy50b3RhbERpc3BsYWNlbWVudFRocmVzaG9sZCA9IHRoaXMuZGlzcGxhY2VtZW50VGhyZXNob2xkUGVyTm9kZSAqIHRoaXMuZ2V0QWxsTm9kZXMoKS5sZW5ndGg7XG5cbiAgdGhpcy5yZXB1bHNpb25SYW5nZSA9IHRoaXMuY2FsY1JlcHVsc2lvblJhbmdlKCk7XG59O1xuXG5GRExheW91dC5wcm90b3R5cGUuY2FsY1NwcmluZ0ZvcmNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxFZGdlcyA9IHRoaXMuZ2V0QWxsRWRnZXMoKTtcbiAgdmFyIGVkZ2U7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsRWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICBlZGdlID0gbEVkZ2VzW2ldO1xuXG4gICAgdGhpcy5jYWxjU3ByaW5nRm9yY2UoZWRnZSwgZWRnZS5pZGVhbExlbmd0aCk7XG4gIH1cbn07XG5cbkZETGF5b3V0LnByb3RvdHlwZS5jYWxjUmVwdWxzaW9uRm9yY2VzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZ3JpZFVwZGF0ZUFsbG93ZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRydWU7XG4gIHZhciBmb3JjZVRvTm9kZVN1cnJvdW5kaW5nVXBkYXRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICB2YXIgaSwgajtcbiAgdmFyIG5vZGVBLCBub2RlQjtcbiAgdmFyIGxOb2RlcyA9IHRoaXMuZ2V0QWxsTm9kZXMoKTtcbiAgdmFyIHByb2Nlc3NlZE5vZGVTZXQ7XG5cbiAgaWYgKHRoaXMudXNlRlJHcmlkVmFyaWFudCkge1xuICAgIGlmICh0aGlzLnRvdGFsSXRlcmF0aW9ucyAlIEZETGF5b3V0Q29uc3RhbnRzLkdSSURfQ0FMQ1VMQVRJT05fQ0hFQ0tfUEVSSU9EID09IDEgJiYgZ3JpZFVwZGF0ZUFsbG93ZWQpIHtcbiAgICAgIHRoaXMudXBkYXRlR3JpZCgpO1xuICAgIH1cblxuICAgIHByb2Nlc3NlZE5vZGVTZXQgPSBuZXcgU2V0KCk7XG5cbiAgICAvLyBjYWxjdWxhdGUgcmVwdWxzaW9uIGZvcmNlcyBiZXR3ZWVuIGVhY2ggbm9kZXMgYW5kIGl0cyBzdXJyb3VuZGluZ1xuICAgIGZvciAoaSA9IDA7IGkgPCBsTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5vZGVBID0gbE5vZGVzW2ldO1xuICAgICAgdGhpcy5jYWxjdWxhdGVSZXB1bHNpb25Gb3JjZU9mQU5vZGUobm9kZUEsIHByb2Nlc3NlZE5vZGVTZXQsIGdyaWRVcGRhdGVBbGxvd2VkLCBmb3JjZVRvTm9kZVN1cnJvdW5kaW5nVXBkYXRlKTtcbiAgICAgIHByb2Nlc3NlZE5vZGVTZXQuYWRkKG5vZGVBKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGxOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgbm9kZUEgPSBsTm9kZXNbaV07XG5cbiAgICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgbE5vZGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIG5vZGVCID0gbE5vZGVzW2pdO1xuXG4gICAgICAgIC8vIElmIGJvdGggbm9kZXMgYXJlIG5vdCBtZW1iZXJzIG9mIHRoZSBzYW1lIGdyYXBoLCBza2lwLlxuICAgICAgICBpZiAobm9kZUEuZ2V0T3duZXIoKSAhPSBub2RlQi5nZXRPd25lcigpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhbGNSZXB1bHNpb25Gb3JjZShub2RlQSwgbm9kZUIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuRkRMYXlvdXQucHJvdG90eXBlLmNhbGNHcmF2aXRhdGlvbmFsRm9yY2VzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm9kZTtcbiAgdmFyIGxOb2RlcyA9IHRoaXMuZ2V0QWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24oKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIG5vZGUgPSBsTm9kZXNbaV07XG4gICAgdGhpcy5jYWxjR3Jhdml0YXRpb25hbEZvcmNlKG5vZGUpO1xuICB9XG59O1xuXG5GRExheW91dC5wcm90b3R5cGUubW92ZU5vZGVzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbE5vZGVzID0gdGhpcy5nZXRBbGxOb2RlcygpO1xuICB2YXIgbm9kZTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIG5vZGUgPSBsTm9kZXNbaV07XG4gICAgbm9kZS5tb3ZlKCk7XG4gIH1cbn07XG5cbkZETGF5b3V0LnByb3RvdHlwZS5jYWxjU3ByaW5nRm9yY2UgPSBmdW5jdGlvbiAoZWRnZSwgaWRlYWxMZW5ndGgpIHtcbiAgdmFyIHNvdXJjZU5vZGUgPSBlZGdlLmdldFNvdXJjZSgpO1xuICB2YXIgdGFyZ2V0Tm9kZSA9IGVkZ2UuZ2V0VGFyZ2V0KCk7XG5cbiAgdmFyIGxlbmd0aDtcbiAgdmFyIHNwcmluZ0ZvcmNlO1xuICB2YXIgc3ByaW5nRm9yY2VYO1xuICB2YXIgc3ByaW5nRm9yY2VZO1xuXG4gIC8vIFVwZGF0ZSBlZGdlIGxlbmd0aFxuICBpZiAodGhpcy51bmlmb3JtTGVhZk5vZGVTaXplcyAmJiBzb3VyY2VOb2RlLmdldENoaWxkKCkgPT0gbnVsbCAmJiB0YXJnZXROb2RlLmdldENoaWxkKCkgPT0gbnVsbCkge1xuICAgIGVkZ2UudXBkYXRlTGVuZ3RoU2ltcGxlKCk7XG4gIH0gZWxzZSB7XG4gICAgZWRnZS51cGRhdGVMZW5ndGgoKTtcblxuICAgIGlmIChlZGdlLmlzT3ZlcmxhcGluZ1NvdXJjZUFuZFRhcmdldCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGxlbmd0aCA9IGVkZ2UuZ2V0TGVuZ3RoKCk7XG5cbiAgaWYgKGxlbmd0aCA9PSAwKSByZXR1cm47XG5cbiAgLy8gQ2FsY3VsYXRlIHNwcmluZyBmb3JjZXNcbiAgc3ByaW5nRm9yY2UgPSB0aGlzLnNwcmluZ0NvbnN0YW50ICogKGxlbmd0aCAtIGlkZWFsTGVuZ3RoKTtcblxuICAvLyBQcm9qZWN0IGZvcmNlIG9udG8geCBhbmQgeSBheGVzXG4gIHNwcmluZ0ZvcmNlWCA9IHNwcmluZ0ZvcmNlICogKGVkZ2UubGVuZ3RoWCAvIGxlbmd0aCk7XG4gIHNwcmluZ0ZvcmNlWSA9IHNwcmluZ0ZvcmNlICogKGVkZ2UubGVuZ3RoWSAvIGxlbmd0aCk7XG5cbiAgLy8gQXBwbHkgZm9yY2VzIG9uIHRoZSBlbmQgbm9kZXNcbiAgc291cmNlTm9kZS5zcHJpbmdGb3JjZVggKz0gc3ByaW5nRm9yY2VYO1xuICBzb3VyY2VOb2RlLnNwcmluZ0ZvcmNlWSArPSBzcHJpbmdGb3JjZVk7XG4gIHRhcmdldE5vZGUuc3ByaW5nRm9yY2VYIC09IHNwcmluZ0ZvcmNlWDtcbiAgdGFyZ2V0Tm9kZS5zcHJpbmdGb3JjZVkgLT0gc3ByaW5nRm9yY2VZO1xufTtcblxuRkRMYXlvdXQucHJvdG90eXBlLmNhbGNSZXB1bHNpb25Gb3JjZSA9IGZ1bmN0aW9uIChub2RlQSwgbm9kZUIpIHtcbiAgdmFyIHJlY3RBID0gbm9kZUEuZ2V0UmVjdCgpO1xuICB2YXIgcmVjdEIgPSBub2RlQi5nZXRSZWN0KCk7XG4gIHZhciBvdmVybGFwQW1vdW50ID0gbmV3IEFycmF5KDIpO1xuICB2YXIgY2xpcFBvaW50cyA9IG5ldyBBcnJheSg0KTtcbiAgdmFyIGRpc3RhbmNlWDtcbiAgdmFyIGRpc3RhbmNlWTtcbiAgdmFyIGRpc3RhbmNlU3F1YXJlZDtcbiAgdmFyIGRpc3RhbmNlO1xuICB2YXIgcmVwdWxzaW9uRm9yY2U7XG4gIHZhciByZXB1bHNpb25Gb3JjZVg7XG4gIHZhciByZXB1bHNpb25Gb3JjZVk7XG5cbiAgaWYgKHJlY3RBLmludGVyc2VjdHMocmVjdEIpKSAvLyB0d28gbm9kZXMgb3ZlcmxhcFxuICAgIHtcbiAgICAgIC8vIGNhbGN1bGF0ZSBzZXBhcmF0aW9uIGFtb3VudCBpbiB4IGFuZCB5IGRpcmVjdGlvbnNcbiAgICAgIElHZW9tZXRyeS5jYWxjU2VwYXJhdGlvbkFtb3VudChyZWN0QSwgcmVjdEIsIG92ZXJsYXBBbW91bnQsIEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggLyAyLjApO1xuXG4gICAgICByZXB1bHNpb25Gb3JjZVggPSAyICogb3ZlcmxhcEFtb3VudFswXTtcbiAgICAgIHJlcHVsc2lvbkZvcmNlWSA9IDIgKiBvdmVybGFwQW1vdW50WzFdO1xuXG4gICAgICB2YXIgY2hpbGRyZW5Db25zdGFudCA9IG5vZGVBLm5vT2ZDaGlsZHJlbiAqIG5vZGVCLm5vT2ZDaGlsZHJlbiAvIChub2RlQS5ub09mQ2hpbGRyZW4gKyBub2RlQi5ub09mQ2hpbGRyZW4pO1xuXG4gICAgICAvLyBBcHBseSBmb3JjZXMgb24gdGhlIHR3byBub2Rlc1xuICAgICAgbm9kZUEucmVwdWxzaW9uRm9yY2VYIC09IGNoaWxkcmVuQ29uc3RhbnQgKiByZXB1bHNpb25Gb3JjZVg7XG4gICAgICBub2RlQS5yZXB1bHNpb25Gb3JjZVkgLT0gY2hpbGRyZW5Db25zdGFudCAqIHJlcHVsc2lvbkZvcmNlWTtcbiAgICAgIG5vZGVCLnJlcHVsc2lvbkZvcmNlWCArPSBjaGlsZHJlbkNvbnN0YW50ICogcmVwdWxzaW9uRm9yY2VYO1xuICAgICAgbm9kZUIucmVwdWxzaW9uRm9yY2VZICs9IGNoaWxkcmVuQ29uc3RhbnQgKiByZXB1bHNpb25Gb3JjZVk7XG4gICAgfSBlbHNlIC8vIG5vIG92ZXJsYXBcbiAgICB7XG4gICAgICAvLyBjYWxjdWxhdGUgZGlzdGFuY2VcblxuICAgICAgaWYgKHRoaXMudW5pZm9ybUxlYWZOb2RlU2l6ZXMgJiYgbm9kZUEuZ2V0Q2hpbGQoKSA9PSBudWxsICYmIG5vZGVCLmdldENoaWxkKCkgPT0gbnVsbCkgLy8gc2ltcGx5IGJhc2UgcmVwdWxzaW9uIG9uIGRpc3RhbmNlIG9mIG5vZGUgY2VudGVyc1xuICAgICAgICB7XG4gICAgICAgICAgZGlzdGFuY2VYID0gcmVjdEIuZ2V0Q2VudGVyWCgpIC0gcmVjdEEuZ2V0Q2VudGVyWCgpO1xuICAgICAgICAgIGRpc3RhbmNlWSA9IHJlY3RCLmdldENlbnRlclkoKSAtIHJlY3RBLmdldENlbnRlclkoKTtcbiAgICAgICAgfSBlbHNlIC8vIHVzZSBjbGlwcGluZyBwb2ludHNcbiAgICAgICAge1xuICAgICAgICAgIElHZW9tZXRyeS5nZXRJbnRlcnNlY3Rpb24ocmVjdEEsIHJlY3RCLCBjbGlwUG9pbnRzKTtcblxuICAgICAgICAgIGRpc3RhbmNlWCA9IGNsaXBQb2ludHNbMl0gLSBjbGlwUG9pbnRzWzBdO1xuICAgICAgICAgIGRpc3RhbmNlWSA9IGNsaXBQb2ludHNbM10gLSBjbGlwUG9pbnRzWzFdO1xuICAgICAgICB9XG5cbiAgICAgIC8vIE5vIHJlcHVsc2lvbiByYW5nZS4gRlIgZ3JpZCB2YXJpYW50IHNob3VsZCB0YWtlIGNhcmUgb2YgdGhpcy5cbiAgICAgIGlmIChNYXRoLmFicyhkaXN0YW5jZVgpIDwgRkRMYXlvdXRDb25zdGFudHMuTUlOX1JFUFVMU0lPTl9ESVNUKSB7XG4gICAgICAgIGRpc3RhbmNlWCA9IElNYXRoLnNpZ24oZGlzdGFuY2VYKSAqIEZETGF5b3V0Q29uc3RhbnRzLk1JTl9SRVBVTFNJT05fRElTVDtcbiAgICAgIH1cblxuICAgICAgaWYgKE1hdGguYWJzKGRpc3RhbmNlWSkgPCBGRExheW91dENvbnN0YW50cy5NSU5fUkVQVUxTSU9OX0RJU1QpIHtcbiAgICAgICAgZGlzdGFuY2VZID0gSU1hdGguc2lnbihkaXN0YW5jZVkpICogRkRMYXlvdXRDb25zdGFudHMuTUlOX1JFUFVMU0lPTl9ESVNUO1xuICAgICAgfVxuXG4gICAgICBkaXN0YW5jZVNxdWFyZWQgPSBkaXN0YW5jZVggKiBkaXN0YW5jZVggKyBkaXN0YW5jZVkgKiBkaXN0YW5jZVk7XG4gICAgICBkaXN0YW5jZSA9IE1hdGguc3FydChkaXN0YW5jZVNxdWFyZWQpO1xuXG4gICAgICByZXB1bHNpb25Gb3JjZSA9IHRoaXMucmVwdWxzaW9uQ29uc3RhbnQgKiBub2RlQS5ub09mQ2hpbGRyZW4gKiBub2RlQi5ub09mQ2hpbGRyZW4gLyBkaXN0YW5jZVNxdWFyZWQ7XG5cbiAgICAgIC8vIFByb2plY3QgZm9yY2Ugb250byB4IGFuZCB5IGF4ZXNcbiAgICAgIHJlcHVsc2lvbkZvcmNlWCA9IHJlcHVsc2lvbkZvcmNlICogZGlzdGFuY2VYIC8gZGlzdGFuY2U7XG4gICAgICByZXB1bHNpb25Gb3JjZVkgPSByZXB1bHNpb25Gb3JjZSAqIGRpc3RhbmNlWSAvIGRpc3RhbmNlO1xuXG4gICAgICAvLyBBcHBseSBmb3JjZXMgb24gdGhlIHR3byBub2RlcyAgICBcbiAgICAgIG5vZGVBLnJlcHVsc2lvbkZvcmNlWCAtPSByZXB1bHNpb25Gb3JjZVg7XG4gICAgICBub2RlQS5yZXB1bHNpb25Gb3JjZVkgLT0gcmVwdWxzaW9uRm9yY2VZO1xuICAgICAgbm9kZUIucmVwdWxzaW9uRm9yY2VYICs9IHJlcHVsc2lvbkZvcmNlWDtcbiAgICAgIG5vZGVCLnJlcHVsc2lvbkZvcmNlWSArPSByZXB1bHNpb25Gb3JjZVk7XG4gICAgfVxufTtcblxuRkRMYXlvdXQucHJvdG90eXBlLmNhbGNHcmF2aXRhdGlvbmFsRm9yY2UgPSBmdW5jdGlvbiAobm9kZSkge1xuICB2YXIgb3duZXJHcmFwaDtcbiAgdmFyIG93bmVyQ2VudGVyWDtcbiAgdmFyIG93bmVyQ2VudGVyWTtcbiAgdmFyIGRpc3RhbmNlWDtcbiAgdmFyIGRpc3RhbmNlWTtcbiAgdmFyIGFic0Rpc3RhbmNlWDtcbiAgdmFyIGFic0Rpc3RhbmNlWTtcbiAgdmFyIGVzdGltYXRlZFNpemU7XG4gIG93bmVyR3JhcGggPSBub2RlLmdldE93bmVyKCk7XG5cbiAgb3duZXJDZW50ZXJYID0gKG93bmVyR3JhcGguZ2V0UmlnaHQoKSArIG93bmVyR3JhcGguZ2V0TGVmdCgpKSAvIDI7XG4gIG93bmVyQ2VudGVyWSA9IChvd25lckdyYXBoLmdldFRvcCgpICsgb3duZXJHcmFwaC5nZXRCb3R0b20oKSkgLyAyO1xuICBkaXN0YW5jZVggPSBub2RlLmdldENlbnRlclgoKSAtIG93bmVyQ2VudGVyWDtcbiAgZGlzdGFuY2VZID0gbm9kZS5nZXRDZW50ZXJZKCkgLSBvd25lckNlbnRlclk7XG4gIGFic0Rpc3RhbmNlWCA9IE1hdGguYWJzKGRpc3RhbmNlWCkgKyBub2RlLmdldFdpZHRoKCkgLyAyO1xuICBhYnNEaXN0YW5jZVkgPSBNYXRoLmFicyhkaXN0YW5jZVkpICsgbm9kZS5nZXRIZWlnaHQoKSAvIDI7XG5cbiAgaWYgKG5vZGUuZ2V0T3duZXIoKSA9PSB0aGlzLmdyYXBoTWFuYWdlci5nZXRSb290KCkpIC8vIGluIHRoZSByb290IGdyYXBoXG4gICAge1xuICAgICAgZXN0aW1hdGVkU2l6ZSA9IG93bmVyR3JhcGguZ2V0RXN0aW1hdGVkU2l6ZSgpICogdGhpcy5ncmF2aXR5UmFuZ2VGYWN0b3I7XG5cbiAgICAgIGlmIChhYnNEaXN0YW5jZVggPiBlc3RpbWF0ZWRTaXplIHx8IGFic0Rpc3RhbmNlWSA+IGVzdGltYXRlZFNpemUpIHtcbiAgICAgICAgbm9kZS5ncmF2aXRhdGlvbkZvcmNlWCA9IC10aGlzLmdyYXZpdHlDb25zdGFudCAqIGRpc3RhbmNlWDtcbiAgICAgICAgbm9kZS5ncmF2aXRhdGlvbkZvcmNlWSA9IC10aGlzLmdyYXZpdHlDb25zdGFudCAqIGRpc3RhbmNlWTtcbiAgICAgIH1cbiAgICB9IGVsc2UgLy8gaW5zaWRlIGEgY29tcG91bmRcbiAgICB7XG4gICAgICBlc3RpbWF0ZWRTaXplID0gb3duZXJHcmFwaC5nZXRFc3RpbWF0ZWRTaXplKCkgKiB0aGlzLmNvbXBvdW5kR3Jhdml0eVJhbmdlRmFjdG9yO1xuXG4gICAgICBpZiAoYWJzRGlzdGFuY2VYID4gZXN0aW1hdGVkU2l6ZSB8fCBhYnNEaXN0YW5jZVkgPiBlc3RpbWF0ZWRTaXplKSB7XG4gICAgICAgIG5vZGUuZ3Jhdml0YXRpb25Gb3JjZVggPSAtdGhpcy5ncmF2aXR5Q29uc3RhbnQgKiBkaXN0YW5jZVggKiB0aGlzLmNvbXBvdW5kR3Jhdml0eUNvbnN0YW50O1xuICAgICAgICBub2RlLmdyYXZpdGF0aW9uRm9yY2VZID0gLXRoaXMuZ3Jhdml0eUNvbnN0YW50ICogZGlzdGFuY2VZICogdGhpcy5jb21wb3VuZEdyYXZpdHlDb25zdGFudDtcbiAgICAgIH1cbiAgICB9XG59O1xuXG5GRExheW91dC5wcm90b3R5cGUuaXNDb252ZXJnZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjb252ZXJnZWQ7XG4gIHZhciBvc2NpbGF0aW5nID0gZmFsc2U7XG5cbiAgaWYgKHRoaXMudG90YWxJdGVyYXRpb25zID4gdGhpcy5tYXhJdGVyYXRpb25zIC8gMykge1xuICAgIG9zY2lsYXRpbmcgPSBNYXRoLmFicyh0aGlzLnRvdGFsRGlzcGxhY2VtZW50IC0gdGhpcy5vbGRUb3RhbERpc3BsYWNlbWVudCkgPCAyO1xuICB9XG5cbiAgY29udmVyZ2VkID0gdGhpcy50b3RhbERpc3BsYWNlbWVudCA8IHRoaXMudG90YWxEaXNwbGFjZW1lbnRUaHJlc2hvbGQ7XG5cbiAgdGhpcy5vbGRUb3RhbERpc3BsYWNlbWVudCA9IHRoaXMudG90YWxEaXNwbGFjZW1lbnQ7XG5cbiAgcmV0dXJuIGNvbnZlcmdlZCB8fCBvc2NpbGF0aW5nO1xufTtcblxuRkRMYXlvdXQucHJvdG90eXBlLmFuaW1hdGUgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmFuaW1hdGlvbkR1cmluZ0xheW91dCAmJiAhdGhpcy5pc1N1YkxheW91dCkge1xuICAgIGlmICh0aGlzLm5vdEFuaW1hdGVkSXRlcmF0aW9ucyA9PSB0aGlzLmFuaW1hdGlvblBlcmlvZCkge1xuICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgIHRoaXMubm90QW5pbWF0ZWRJdGVyYXRpb25zID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ub3RBbmltYXRlZEl0ZXJhdGlvbnMrKztcbiAgICB9XG4gIH1cbn07XG5cbi8vVGhpcyBtZXRob2QgY2FsY3VsYXRlcyB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuICh3ZWlnaHQpIGZvciBhbGwgbm9kZXNcbkZETGF5b3V0LnByb3RvdHlwZS5jYWxjTm9PZkNoaWxkcmVuRm9yQWxsTm9kZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBub2RlO1xuICB2YXIgYWxsTm9kZXMgPSB0aGlzLmdyYXBoTWFuYWdlci5nZXRBbGxOb2RlcygpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBub2RlID0gYWxsTm9kZXNbaV07XG4gICAgbm9kZS5ub09mQ2hpbGRyZW4gPSBub2RlLmdldE5vT2ZDaGlsZHJlbigpO1xuICB9XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gU2VjdGlvbjogRlItR3JpZCBWYXJpYW50IFJlcHVsc2lvbiBGb3JjZSBDYWxjdWxhdGlvblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuRkRMYXlvdXQucHJvdG90eXBlLmNhbGNHcmlkID0gZnVuY3Rpb24gKGdyYXBoKSB7XG5cbiAgdmFyIHNpemVYID0gMDtcbiAgdmFyIHNpemVZID0gMDtcblxuICBzaXplWCA9IHBhcnNlSW50KE1hdGguY2VpbCgoZ3JhcGguZ2V0UmlnaHQoKSAtIGdyYXBoLmdldExlZnQoKSkgLyB0aGlzLnJlcHVsc2lvblJhbmdlKSk7XG4gIHNpemVZID0gcGFyc2VJbnQoTWF0aC5jZWlsKChncmFwaC5nZXRCb3R0b20oKSAtIGdyYXBoLmdldFRvcCgpKSAvIHRoaXMucmVwdWxzaW9uUmFuZ2UpKTtcblxuICB2YXIgZ3JpZCA9IG5ldyBBcnJheShzaXplWCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplWDsgaSsrKSB7XG4gICAgZ3JpZFtpXSA9IG5ldyBBcnJheShzaXplWSk7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemVYOyBpKyspIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNpemVZOyBqKyspIHtcbiAgICAgIGdyaWRbaV1bal0gPSBuZXcgQXJyYXkoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZ3JpZDtcbn07XG5cbkZETGF5b3V0LnByb3RvdHlwZS5hZGROb2RlVG9HcmlkID0gZnVuY3Rpb24gKHYsIGxlZnQsIHRvcCkge1xuXG4gIHZhciBzdGFydFggPSAwO1xuICB2YXIgZmluaXNoWCA9IDA7XG4gIHZhciBzdGFydFkgPSAwO1xuICB2YXIgZmluaXNoWSA9IDA7XG5cbiAgc3RhcnRYID0gcGFyc2VJbnQoTWF0aC5mbG9vcigodi5nZXRSZWN0KCkueCAtIGxlZnQpIC8gdGhpcy5yZXB1bHNpb25SYW5nZSkpO1xuICBmaW5pc2hYID0gcGFyc2VJbnQoTWF0aC5mbG9vcigodi5nZXRSZWN0KCkud2lkdGggKyB2LmdldFJlY3QoKS54IC0gbGVmdCkgLyB0aGlzLnJlcHVsc2lvblJhbmdlKSk7XG4gIHN0YXJ0WSA9IHBhcnNlSW50KE1hdGguZmxvb3IoKHYuZ2V0UmVjdCgpLnkgLSB0b3ApIC8gdGhpcy5yZXB1bHNpb25SYW5nZSkpO1xuICBmaW5pc2hZID0gcGFyc2VJbnQoTWF0aC5mbG9vcigodi5nZXRSZWN0KCkuaGVpZ2h0ICsgdi5nZXRSZWN0KCkueSAtIHRvcCkgLyB0aGlzLnJlcHVsc2lvblJhbmdlKSk7XG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0WDsgaSA8PSBmaW5pc2hYOyBpKyspIHtcbiAgICBmb3IgKHZhciBqID0gc3RhcnRZOyBqIDw9IGZpbmlzaFk7IGorKykge1xuICAgICAgdGhpcy5ncmlkW2ldW2pdLnB1c2godik7XG4gICAgICB2LnNldEdyaWRDb29yZGluYXRlcyhzdGFydFgsIGZpbmlzaFgsIHN0YXJ0WSwgZmluaXNoWSk7XG4gICAgfVxuICB9XG59O1xuXG5GRExheW91dC5wcm90b3R5cGUudXBkYXRlR3JpZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGk7XG4gIHZhciBub2RlQTtcbiAgdmFyIGxOb2RlcyA9IHRoaXMuZ2V0QWxsTm9kZXMoKTtcblxuICB0aGlzLmdyaWQgPSB0aGlzLmNhbGNHcmlkKHRoaXMuZ3JhcGhNYW5hZ2VyLmdldFJvb3QoKSk7XG5cbiAgLy8gcHV0IGFsbCBub2RlcyB0byBwcm9wZXIgZ3JpZCBjZWxsc1xuICBmb3IgKGkgPSAwOyBpIDwgbE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgbm9kZUEgPSBsTm9kZXNbaV07XG4gICAgdGhpcy5hZGROb2RlVG9HcmlkKG5vZGVBLCB0aGlzLmdyYXBoTWFuYWdlci5nZXRSb290KCkuZ2V0TGVmdCgpLCB0aGlzLmdyYXBoTWFuYWdlci5nZXRSb290KCkuZ2V0VG9wKCkpO1xuICB9XG59O1xuXG5GRExheW91dC5wcm90b3R5cGUuY2FsY3VsYXRlUmVwdWxzaW9uRm9yY2VPZkFOb2RlID0gZnVuY3Rpb24gKG5vZGVBLCBwcm9jZXNzZWROb2RlU2V0LCBncmlkVXBkYXRlQWxsb3dlZCwgZm9yY2VUb05vZGVTdXJyb3VuZGluZ1VwZGF0ZSkge1xuXG4gIGlmICh0aGlzLnRvdGFsSXRlcmF0aW9ucyAlIEZETGF5b3V0Q29uc3RhbnRzLkdSSURfQ0FMQ1VMQVRJT05fQ0hFQ0tfUEVSSU9EID09IDEgJiYgZ3JpZFVwZGF0ZUFsbG93ZWQgfHwgZm9yY2VUb05vZGVTdXJyb3VuZGluZ1VwZGF0ZSkge1xuICAgIHZhciBzdXJyb3VuZGluZyA9IG5ldyBTZXQoKTtcbiAgICBub2RlQS5zdXJyb3VuZGluZyA9IG5ldyBBcnJheSgpO1xuICAgIHZhciBub2RlQjtcbiAgICB2YXIgZ3JpZCA9IHRoaXMuZ3JpZDtcblxuICAgIGZvciAodmFyIGkgPSBub2RlQS5zdGFydFggLSAxOyBpIDwgbm9kZUEuZmluaXNoWCArIDI7IGkrKykge1xuICAgICAgZm9yICh2YXIgaiA9IG5vZGVBLnN0YXJ0WSAtIDE7IGogPCBub2RlQS5maW5pc2hZICsgMjsgaisrKSB7XG4gICAgICAgIGlmICghKGkgPCAwIHx8IGogPCAwIHx8IGkgPj0gZ3JpZC5sZW5ndGggfHwgaiA+PSBncmlkWzBdLmxlbmd0aCkpIHtcbiAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGdyaWRbaV1bal0ubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIG5vZGVCID0gZ3JpZFtpXVtqXVtrXTtcblxuICAgICAgICAgICAgLy8gSWYgYm90aCBub2RlcyBhcmUgbm90IG1lbWJlcnMgb2YgdGhlIHNhbWUgZ3JhcGgsIFxuICAgICAgICAgICAgLy8gb3IgYm90aCBub2RlcyBhcmUgdGhlIHNhbWUsIHNraXAuXG4gICAgICAgICAgICBpZiAobm9kZUEuZ2V0T3duZXIoKSAhPSBub2RlQi5nZXRPd25lcigpIHx8IG5vZGVBID09IG5vZGVCKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjaGVjayBpZiB0aGUgcmVwdWxzaW9uIGZvcmNlIGJldHdlZW5cbiAgICAgICAgICAgIC8vIG5vZGVBIGFuZCBub2RlQiBoYXMgYWxyZWFkeSBiZWVuIGNhbGN1bGF0ZWRcbiAgICAgICAgICAgIGlmICghcHJvY2Vzc2VkTm9kZVNldC5oYXMobm9kZUIpICYmICFzdXJyb3VuZGluZy5oYXMobm9kZUIpKSB7XG4gICAgICAgICAgICAgIHZhciBkaXN0YW5jZVggPSBNYXRoLmFicyhub2RlQS5nZXRDZW50ZXJYKCkgLSBub2RlQi5nZXRDZW50ZXJYKCkpIC0gKG5vZGVBLmdldFdpZHRoKCkgLyAyICsgbm9kZUIuZ2V0V2lkdGgoKSAvIDIpO1xuICAgICAgICAgICAgICB2YXIgZGlzdGFuY2VZID0gTWF0aC5hYnMobm9kZUEuZ2V0Q2VudGVyWSgpIC0gbm9kZUIuZ2V0Q2VudGVyWSgpKSAtIChub2RlQS5nZXRIZWlnaHQoKSAvIDIgKyBub2RlQi5nZXRIZWlnaHQoKSAvIDIpO1xuXG4gICAgICAgICAgICAgIC8vIGlmIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIG5vZGVBIGFuZCBub2RlQiBcbiAgICAgICAgICAgICAgLy8gaXMgbGVzcyB0aGVuIGNhbGN1bGF0aW9uIHJhbmdlXG4gICAgICAgICAgICAgIGlmIChkaXN0YW5jZVggPD0gdGhpcy5yZXB1bHNpb25SYW5nZSAmJiBkaXN0YW5jZVkgPD0gdGhpcy5yZXB1bHNpb25SYW5nZSkge1xuICAgICAgICAgICAgICAgIC8vdGhlbiBhZGQgbm9kZUIgdG8gc3Vycm91bmRpbmcgb2Ygbm9kZUFcbiAgICAgICAgICAgICAgICBzdXJyb3VuZGluZy5hZGQobm9kZUIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbm9kZUEuc3Vycm91bmRpbmcgPSBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHN1cnJvdW5kaW5nKSk7XG4gIH1cbiAgZm9yIChpID0gMDsgaSA8IG5vZGVBLnN1cnJvdW5kaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5jYWxjUmVwdWxzaW9uRm9yY2Uobm9kZUEsIG5vZGVBLnN1cnJvdW5kaW5nW2ldKTtcbiAgfVxufTtcblxuRkRMYXlvdXQucHJvdG90eXBlLmNhbGNSZXB1bHNpb25SYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIDAuMDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRkRMYXlvdXQ7XG5cbi8qKiovIH0pLFxuLyogMTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIExFZGdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbnZhciBGRExheW91dENvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cbmZ1bmN0aW9uIEZETGF5b3V0RWRnZShzb3VyY2UsIHRhcmdldCwgdkVkZ2UpIHtcbiAgTEVkZ2UuY2FsbCh0aGlzLCBzb3VyY2UsIHRhcmdldCwgdkVkZ2UpO1xuICB0aGlzLmlkZWFsTGVuZ3RoID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSDtcbn1cblxuRkRMYXlvdXRFZGdlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTEVkZ2UucHJvdG90eXBlKTtcblxuZm9yICh2YXIgcHJvcCBpbiBMRWRnZSkge1xuICBGRExheW91dEVkZ2VbcHJvcF0gPSBMRWRnZVtwcm9wXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBGRExheW91dEVkZ2U7XG5cbi8qKiovIH0pLFxuLyogMjAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIExOb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxuZnVuY3Rpb24gRkRMYXlvdXROb2RlKGdtLCBsb2MsIHNpemUsIHZOb2RlKSB7XG4gIC8vIGFsdGVybmF0aXZlIGNvbnN0cnVjdG9yIGlzIGhhbmRsZWQgaW5zaWRlIExOb2RlXG4gIExOb2RlLmNhbGwodGhpcywgZ20sIGxvYywgc2l6ZSwgdk5vZGUpO1xuICAvL1NwcmluZywgcmVwdWxzaW9uIGFuZCBncmF2aXRhdGlvbmFsIGZvcmNlcyBhY3Rpbmcgb24gdGhpcyBub2RlXG4gIHRoaXMuc3ByaW5nRm9yY2VYID0gMDtcbiAgdGhpcy5zcHJpbmdGb3JjZVkgPSAwO1xuICB0aGlzLnJlcHVsc2lvbkZvcmNlWCA9IDA7XG4gIHRoaXMucmVwdWxzaW9uRm9yY2VZID0gMDtcbiAgdGhpcy5ncmF2aXRhdGlvbkZvcmNlWCA9IDA7XG4gIHRoaXMuZ3Jhdml0YXRpb25Gb3JjZVkgPSAwO1xuICAvL0Ftb3VudCBieSB3aGljaCB0aGlzIG5vZGUgaXMgdG8gYmUgbW92ZWQgaW4gdGhpcyBpdGVyYXRpb25cbiAgdGhpcy5kaXNwbGFjZW1lbnRYID0gMDtcbiAgdGhpcy5kaXNwbGFjZW1lbnRZID0gMDtcblxuICAvL1N0YXJ0IGFuZCBmaW5pc2ggZ3JpZCBjb29yZGluYXRlcyB0aGF0IHRoaXMgbm9kZSBpcyBmYWxsZW4gaW50b1xuICB0aGlzLnN0YXJ0WCA9IDA7XG4gIHRoaXMuZmluaXNoWCA9IDA7XG4gIHRoaXMuc3RhcnRZID0gMDtcbiAgdGhpcy5maW5pc2hZID0gMDtcblxuICAvL0dlb21ldHJpYyBuZWlnaGJvcnMgb2YgdGhpcyBub2RlXG4gIHRoaXMuc3Vycm91bmRpbmcgPSBbXTtcbn1cblxuRkRMYXlvdXROb2RlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTE5vZGUucHJvdG90eXBlKTtcblxuZm9yICh2YXIgcHJvcCBpbiBMTm9kZSkge1xuICBGRExheW91dE5vZGVbcHJvcF0gPSBMTm9kZVtwcm9wXTtcbn1cblxuRkRMYXlvdXROb2RlLnByb3RvdHlwZS5zZXRHcmlkQ29vcmRpbmF0ZXMgPSBmdW5jdGlvbiAoX3N0YXJ0WCwgX2ZpbmlzaFgsIF9zdGFydFksIF9maW5pc2hZKSB7XG4gIHRoaXMuc3RhcnRYID0gX3N0YXJ0WDtcbiAgdGhpcy5maW5pc2hYID0gX2ZpbmlzaFg7XG4gIHRoaXMuc3RhcnRZID0gX3N0YXJ0WTtcbiAgdGhpcy5maW5pc2hZID0gX2ZpbmlzaFk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZETGF5b3V0Tm9kZTtcblxuLyoqKi8gfSksXG4vKiAyMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBEaW1lbnNpb25EKHdpZHRoLCBoZWlnaHQpIHtcbiAgdGhpcy53aWR0aCA9IDA7XG4gIHRoaXMuaGVpZ2h0ID0gMDtcbiAgaWYgKHdpZHRoICE9PSBudWxsICYmIGhlaWdodCAhPT0gbnVsbCkge1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgfVxufVxuXG5EaW1lbnNpb25ELnByb3RvdHlwZS5nZXRXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMud2lkdGg7XG59O1xuXG5EaW1lbnNpb25ELnByb3RvdHlwZS5zZXRXaWR0aCA9IGZ1bmN0aW9uICh3aWR0aCkge1xuICB0aGlzLndpZHRoID0gd2lkdGg7XG59O1xuXG5EaW1lbnNpb25ELnByb3RvdHlwZS5nZXRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmhlaWdodDtcbn07XG5cbkRpbWVuc2lvbkQucHJvdG90eXBlLnNldEhlaWdodCA9IGZ1bmN0aW9uIChoZWlnaHQpIHtcbiAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERpbWVuc2lvbkQ7XG5cbi8qKiovIH0pLFxuLyogMjIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIFVuaXF1ZUlER2VuZXJldG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG5cbmZ1bmN0aW9uIEhhc2hNYXAoKSB7XG4gIHRoaXMubWFwID0ge307XG4gIHRoaXMua2V5cyA9IFtdO1xufVxuXG5IYXNoTWFwLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICB2YXIgdGhlSWQgPSBVbmlxdWVJREdlbmVyZXRvci5jcmVhdGVJRChrZXkpO1xuICBpZiAoIXRoaXMuY29udGFpbnModGhlSWQpKSB7XG4gICAgdGhpcy5tYXBbdGhlSWRdID0gdmFsdWU7XG4gICAgdGhpcy5rZXlzLnB1c2goa2V5KTtcbiAgfVxufTtcblxuSGFzaE1hcC5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHZhciB0aGVJZCA9IFVuaXF1ZUlER2VuZXJldG9yLmNyZWF0ZUlEKGtleSk7XG4gIHJldHVybiB0aGlzLm1hcFtrZXldICE9IG51bGw7XG59O1xuXG5IYXNoTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHZhciB0aGVJZCA9IFVuaXF1ZUlER2VuZXJldG9yLmNyZWF0ZUlEKGtleSk7XG4gIHJldHVybiB0aGlzLm1hcFt0aGVJZF07XG59O1xuXG5IYXNoTWFwLnByb3RvdHlwZS5rZXlTZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmtleXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhhc2hNYXA7XG5cbi8qKiovIH0pLFxuLyogMjMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIFVuaXF1ZUlER2VuZXJldG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG5cbmZ1bmN0aW9uIEhhc2hTZXQoKSB7XG4gIHRoaXMuc2V0ID0ge307XG59XG47XG5cbkhhc2hTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIHRoZUlkID0gVW5pcXVlSURHZW5lcmV0b3IuY3JlYXRlSUQob2JqKTtcbiAgaWYgKCF0aGlzLmNvbnRhaW5zKHRoZUlkKSkgdGhpcy5zZXRbdGhlSWRdID0gb2JqO1xufTtcblxuSGFzaFNldC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKG9iaikge1xuICBkZWxldGUgdGhpcy5zZXRbVW5pcXVlSURHZW5lcmV0b3IuY3JlYXRlSUQob2JqKV07XG59O1xuXG5IYXNoU2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZXQgPSB7fTtcbn07XG5cbkhhc2hTZXQucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gdGhpcy5zZXRbVW5pcXVlSURHZW5lcmV0b3IuY3JlYXRlSUQob2JqKV0gPT0gb2JqO1xufTtcblxuSGFzaFNldC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuc2l6ZSgpID09PSAwO1xufTtcblxuSGFzaFNldC5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuc2V0KS5sZW5ndGg7XG59O1xuXG4vL2NvbmNhdHMgdGhpcy5zZXQgdG8gdGhlIGdpdmVuIGxpc3Rcbkhhc2hTZXQucHJvdG90eXBlLmFkZEFsbFRvID0gZnVuY3Rpb24gKGxpc3QpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLnNldCk7XG4gIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGxpc3QucHVzaCh0aGlzLnNldFtrZXlzW2ldXSk7XG4gIH1cbn07XG5cbkhhc2hTZXQucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnNldCkubGVuZ3RoO1xufTtcblxuSGFzaFNldC5wcm90b3R5cGUuYWRkQWxsID0gZnVuY3Rpb24gKGxpc3QpIHtcbiAgdmFyIHMgPSBsaXN0Lmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICB2YXIgdiA9IGxpc3RbaV07XG4gICAgdGhpcy5hZGQodik7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSGFzaFNldDtcblxuLyoqKi8gfSksXG4vKiAyNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqIEEgY2xhc3NpYyBRdWlja3NvcnQgYWxnb3JpdGhtIHdpdGggSG9hcmUncyBwYXJ0aXRpb25cbiAqIC0gV29ya3MgYWxzbyBvbiBMaW5rZWRMaXN0IG9iamVjdHNcbiAqXG4gKiBDb3B5cmlnaHQ6IGktVmlzIFJlc2VhcmNoIEdyb3VwLCBCaWxrZW50IFVuaXZlcnNpdHksIDIwMDcgLSBwcmVzZW50XG4gKi9cblxudmFyIExpbmtlZExpc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblxudmFyIFF1aWNrc29ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBRdWlja3NvcnQoQSwgY29tcGFyZUZ1bmN0aW9uKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBRdWlja3NvcnQpO1xuXG4gICAgICAgIGlmIChjb21wYXJlRnVuY3Rpb24gIT09IG51bGwgfHwgY29tcGFyZUZ1bmN0aW9uICE9PSB1bmRlZmluZWQpIHRoaXMuY29tcGFyZUZ1bmN0aW9uID0gdGhpcy5fZGVmYXVsdENvbXBhcmVGdW5jdGlvbjtcblxuICAgICAgICB2YXIgbGVuZ3RoID0gdm9pZCAwO1xuICAgICAgICBpZiAoQSBpbnN0YW5jZW9mIExpbmtlZExpc3QpIGxlbmd0aCA9IEEuc2l6ZSgpO2Vsc2UgbGVuZ3RoID0gQS5sZW5ndGg7XG5cbiAgICAgICAgdGhpcy5fcXVpY2tzb3J0KEEsIDAsIGxlbmd0aCAtIDEpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhRdWlja3NvcnQsIFt7XG4gICAgICAgIGtleTogJ19xdWlja3NvcnQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3F1aWNrc29ydChBLCBwLCByKSB7XG4gICAgICAgICAgICBpZiAocCA8IHIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcSA9IHRoaXMuX3BhcnRpdGlvbihBLCBwLCByKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9xdWlja3NvcnQoQSwgcCwgcSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcXVpY2tzb3J0KEEsIHEgKyAxLCByKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX3BhcnRpdGlvbicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcGFydGl0aW9uKEEsIHAsIHIpIHtcbiAgICAgICAgICAgIHZhciB4ID0gdGhpcy5fZ2V0KEEsIHApO1xuICAgICAgICAgICAgdmFyIGkgPSBwO1xuICAgICAgICAgICAgdmFyIGogPSByO1xuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5jb21wYXJlRnVuY3Rpb24oeCwgdGhpcy5fZ2V0KEEsIGopKSkge1xuICAgICAgICAgICAgICAgICAgICBqLS07XG4gICAgICAgICAgICAgICAgfXdoaWxlICh0aGlzLmNvbXBhcmVGdW5jdGlvbih0aGlzLl9nZXQoQSwgaSksIHgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICB9aWYgKGkgPCBqKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N3YXAoQSwgaSwgaik7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgICAgIH0gZWxzZSByZXR1cm4gajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX2dldCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0KG9iamVjdCwgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBMaW5rZWRMaXN0KSByZXR1cm4gb2JqZWN0LmdldF9vYmplY3RfYXQoaW5kZXgpO2Vsc2UgcmV0dXJuIG9iamVjdFtpbmRleF07XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ19zZXQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3NldChvYmplY3QsIGluZGV4LCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIExpbmtlZExpc3QpIG9iamVjdC5zZXRfb2JqZWN0X2F0KGluZGV4LCB2YWx1ZSk7ZWxzZSBvYmplY3RbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ19zd2FwJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zd2FwKEEsIGksIGopIHtcbiAgICAgICAgICAgIHZhciB0ZW1wID0gdGhpcy5fZ2V0KEEsIGkpO1xuICAgICAgICAgICAgdGhpcy5fc2V0KEEsIGksIHRoaXMuX2dldChBLCBqKSk7XG4gICAgICAgICAgICB0aGlzLl9zZXQoQSwgaiwgdGVtcCk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ19kZWZhdWx0Q29tcGFyZUZ1bmN0aW9uJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9kZWZhdWx0Q29tcGFyZUZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBiID4gYTtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBRdWlja3NvcnQ7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gUXVpY2tzb3J0O1xuXG4vKioqLyB9KSxcbi8qIDI1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogICBOZWVkbGVtYW4tV3Vuc2NoIGFsZ29yaXRobSBpcyBhbiBwcm9jZWR1cmUgdG8gY29tcHV0ZSB0aGUgb3B0aW1hbCBnbG9iYWwgYWxpZ25tZW50IG9mIHR3byBzdHJpbmdcbiAqICAgc2VxdWVuY2VzIGJ5IFMuQi5OZWVkbGVtYW4gYW5kIEMuRC5XdW5zY2ggKDE5NzApLlxuICpcbiAqICAgQXNpZGUgZnJvbSB0aGUgaW5wdXRzLCB5b3UgY2FuIGFzc2lnbiB0aGUgc2NvcmVzIGZvcixcbiAqICAgLSBNYXRjaDogVGhlIHR3byBjaGFyYWN0ZXJzIGF0IHRoZSBjdXJyZW50IGluZGV4IGFyZSBzYW1lLlxuICogICAtIE1pc21hdGNoOiBUaGUgdHdvIGNoYXJhY3RlcnMgYXQgdGhlIGN1cnJlbnQgaW5kZXggYXJlIGRpZmZlcmVudC5cbiAqICAgLSBJbnNlcnRpb24vRGVsZXRpb24oZ2Fwcyk6IFRoZSBiZXN0IGFsaWdubWVudCBpbnZvbHZlcyBvbmUgbGV0dGVyIGFsaWduaW5nIHRvIGEgZ2FwIGluIHRoZSBvdGhlciBzdHJpbmcuXG4gKi9cblxudmFyIE5lZWRsZW1hbld1bnNjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOZWVkbGVtYW5XdW5zY2goc2VxdWVuY2UxLCBzZXF1ZW5jZTIpIHtcbiAgICAgICAgdmFyIG1hdGNoX3Njb3JlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAxO1xuICAgICAgICB2YXIgbWlzbWF0Y2hfcGVuYWx0eSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogLTE7XG4gICAgICAgIHZhciBnYXBfcGVuYWx0eSA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogLTE7XG5cbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE5lZWRsZW1hbld1bnNjaCk7XG5cbiAgICAgICAgdGhpcy5zZXF1ZW5jZTEgPSBzZXF1ZW5jZTE7XG4gICAgICAgIHRoaXMuc2VxdWVuY2UyID0gc2VxdWVuY2UyO1xuICAgICAgICB0aGlzLm1hdGNoX3Njb3JlID0gbWF0Y2hfc2NvcmU7XG4gICAgICAgIHRoaXMubWlzbWF0Y2hfcGVuYWx0eSA9IG1pc21hdGNoX3BlbmFsdHk7XG4gICAgICAgIHRoaXMuZ2FwX3BlbmFsdHkgPSBnYXBfcGVuYWx0eTtcblxuICAgICAgICAvLyBKdXN0IHRoZSByZW1vdmUgcmVkdW5kYW5jeVxuICAgICAgICB0aGlzLmlNYXggPSBzZXF1ZW5jZTEubGVuZ3RoICsgMTtcbiAgICAgICAgdGhpcy5qTWF4ID0gc2VxdWVuY2UyLmxlbmd0aCArIDE7XG5cbiAgICAgICAgLy8gR3JpZCBtYXRyaXggb2Ygc2NvcmVzXG4gICAgICAgIHRoaXMuZ3JpZCA9IG5ldyBBcnJheSh0aGlzLmlNYXgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaU1heDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmdyaWRbaV0gPSBuZXcgQXJyYXkodGhpcy5qTWF4KTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmpNYXg7IGorKykge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JpZFtpXVtqXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUcmFjZWJhY2sgbWF0cml4ICgyRCBhcnJheSwgZWFjaCBjZWxsIGlzIGFuIGFycmF5IG9mIGJvb2xlYW4gdmFsdWVzIGZvciBbYERpYWdgLCBgVXBgLCBgTGVmdGBdIHBvc2l0aW9ucylcbiAgICAgICAgdGhpcy50cmFjZWJhY2tHcmlkID0gbmV3IEFycmF5KHRoaXMuaU1heCk7XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB0aGlzLmlNYXg7IF9pKyspIHtcbiAgICAgICAgICAgIHRoaXMudHJhY2ViYWNrR3JpZFtfaV0gPSBuZXcgQXJyYXkodGhpcy5qTWF4KTtcblxuICAgICAgICAgICAgZm9yICh2YXIgX2ogPSAwOyBfaiA8IHRoaXMuak1heDsgX2orKykge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2ViYWNrR3JpZFtfaV1bX2pdID0gW251bGwsIG51bGwsIG51bGxdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIGFsaWduZWQgc2VxdWVuY2VzIChyZXR1cm4gbXVsdGlwbGUgcG9zc2liaWxpdGllcylcbiAgICAgICAgdGhpcy5hbGlnbm1lbnRzID0gW107XG5cbiAgICAgICAgLy8gRmluYWwgYWxpZ25tZW50IHNjb3JlXG4gICAgICAgIHRoaXMuc2NvcmUgPSAtMTtcblxuICAgICAgICAvLyBDYWxjdWxhdGUgc2NvcmVzIGFuZCB0cmFjZWJhY2tzXG4gICAgICAgIHRoaXMuY29tcHV0ZUdyaWRzKCk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKE5lZWRsZW1hbld1bnNjaCwgW3tcbiAgICAgICAga2V5OiBcImdldFNjb3JlXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTY29yZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNjb3JlO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiZ2V0QWxpZ25tZW50c1wiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QWxpZ25tZW50cygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFsaWdubWVudHM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNYWluIGR5bmFtaWMgcHJvZ3JhbW1pbmcgcHJvY2VkdXJlXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJjb21wdXRlR3JpZHNcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXB1dGVHcmlkcygpIHtcbiAgICAgICAgICAgIC8vIEZpbGwgaW4gdGhlIGZpcnN0IHJvd1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCB0aGlzLmpNYXg7IGorKykge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JpZFswXVtqXSA9IHRoaXMuZ3JpZFswXVtqIC0gMV0gKyB0aGlzLmdhcF9wZW5hbHR5O1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2ViYWNrR3JpZFswXVtqXSA9IFtmYWxzZSwgZmFsc2UsIHRydWVdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGaWxsIGluIHRoZSBmaXJzdCBjb2x1bW5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5pTWF4OyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyaWRbaV1bMF0gPSB0aGlzLmdyaWRbaSAtIDFdWzBdICsgdGhpcy5nYXBfcGVuYWx0eTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlYmFja0dyaWRbaV1bMF0gPSBbZmFsc2UsIHRydWUsIGZhbHNlXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRmlsbCB0aGUgcmVzdCBvZiB0aGUgZ3JpZFxuICAgICAgICAgICAgZm9yICh2YXIgX2kyID0gMTsgX2kyIDwgdGhpcy5pTWF4OyBfaTIrKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9qMiA9IDE7IF9qMiA8IHRoaXMuak1heDsgX2oyKyspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgbWF4IHNjb3JlKHMpIGFtb25nIFtgRGlhZ2AsIGBVcGAsIGBMZWZ0YF1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpYWcgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlcXVlbmNlMVtfaTIgLSAxXSA9PT0gdGhpcy5zZXF1ZW5jZTJbX2oyIC0gMV0pIGRpYWcgPSB0aGlzLmdyaWRbX2kyIC0gMV1bX2oyIC0gMV0gKyB0aGlzLm1hdGNoX3Njb3JlO2Vsc2UgZGlhZyA9IHRoaXMuZ3JpZFtfaTIgLSAxXVtfajIgLSAxXSArIHRoaXMubWlzbWF0Y2hfcGVuYWx0eTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgdXAgPSB0aGlzLmdyaWRbX2kyIC0gMV1bX2oyXSArIHRoaXMuZ2FwX3BlbmFsdHk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsZWZ0ID0gdGhpcy5ncmlkW19pMl1bX2oyIC0gMV0gKyB0aGlzLmdhcF9wZW5hbHR5O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGV4aXN0cyBtdWx0aXBsZSBtYXggdmFsdWVzLCBjYXB0dXJlIHRoZW0gZm9yIG11bHRpcGxlIHBhdGhzXG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXhPZiA9IFtkaWFnLCB1cCwgbGVmdF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRpY2VzID0gdGhpcy5hcnJheUFsbE1heEluZGV4ZXMobWF4T2YpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBHcmlkc1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdyaWRbX2kyXVtfajJdID0gbWF4T2ZbaW5kaWNlc1swXV07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2ViYWNrR3JpZFtfaTJdW19qMl0gPSBbaW5kaWNlcy5pbmNsdWRlcygwKSwgaW5kaWNlcy5pbmNsdWRlcygxKSwgaW5kaWNlcy5pbmNsdWRlcygyKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVcGRhdGUgYWxpZ25tZW50IHNjb3JlXG4gICAgICAgICAgICB0aGlzLnNjb3JlID0gdGhpcy5ncmlkW3RoaXMuaU1heCAtIDFdW3RoaXMuak1heCAtIDFdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2V0cyBhbGwgcG9zc2libGUgdmFsaWQgc2VxdWVuY2UgY29tYmluYXRpb25zXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJhbGlnbm1lbnRUcmFjZWJhY2tcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFsaWdubWVudFRyYWNlYmFjaygpIHtcbiAgICAgICAgICAgIHZhciBpblByb2Nlc3NBbGlnbm1lbnRzID0gW107XG5cbiAgICAgICAgICAgIGluUHJvY2Vzc0FsaWdubWVudHMucHVzaCh7IHBvczogW3RoaXMuc2VxdWVuY2UxLmxlbmd0aCwgdGhpcy5zZXF1ZW5jZTIubGVuZ3RoXSxcbiAgICAgICAgICAgICAgICBzZXExOiBcIlwiLFxuICAgICAgICAgICAgICAgIHNlcTI6IFwiXCJcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB3aGlsZSAoaW5Qcm9jZXNzQWxpZ25tZW50c1swXSkge1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50ID0gaW5Qcm9jZXNzQWxpZ25tZW50c1swXTtcbiAgICAgICAgICAgICAgICB2YXIgZGlyZWN0aW9ucyA9IHRoaXMudHJhY2ViYWNrR3JpZFtjdXJyZW50LnBvc1swXV1bY3VycmVudC5wb3NbMV1dO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbnNbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgaW5Qcm9jZXNzQWxpZ25tZW50cy5wdXNoKHsgcG9zOiBbY3VycmVudC5wb3NbMF0gLSAxLCBjdXJyZW50LnBvc1sxXSAtIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VxMTogdGhpcy5zZXF1ZW5jZTFbY3VycmVudC5wb3NbMF0gLSAxXSArIGN1cnJlbnQuc2VxMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcTI6IHRoaXMuc2VxdWVuY2UyW2N1cnJlbnQucG9zWzFdIC0gMV0gKyBjdXJyZW50LnNlcTJcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb25zWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIGluUHJvY2Vzc0FsaWdubWVudHMucHVzaCh7IHBvczogW2N1cnJlbnQucG9zWzBdIC0gMSwgY3VycmVudC5wb3NbMV1dLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VxMTogdGhpcy5zZXF1ZW5jZTFbY3VycmVudC5wb3NbMF0gLSAxXSArIGN1cnJlbnQuc2VxMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcTI6ICctJyArIGN1cnJlbnQuc2VxMlxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbnNbMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgaW5Qcm9jZXNzQWxpZ25tZW50cy5wdXNoKHsgcG9zOiBbY3VycmVudC5wb3NbMF0sIGN1cnJlbnQucG9zWzFdIC0gMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXExOiAnLScgKyBjdXJyZW50LnNlcTEsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXEyOiB0aGlzLnNlcXVlbmNlMltjdXJyZW50LnBvc1sxXSAtIDFdICsgY3VycmVudC5zZXEyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50LnBvc1swXSA9PT0gMCAmJiBjdXJyZW50LnBvc1sxXSA9PT0gMCkgdGhpcy5hbGlnbm1lbnRzLnB1c2goeyBzZXF1ZW5jZTE6IGN1cnJlbnQuc2VxMSxcbiAgICAgICAgICAgICAgICAgICAgc2VxdWVuY2UyOiBjdXJyZW50LnNlcTJcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGluUHJvY2Vzc0FsaWdubWVudHMuc2hpZnQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWxpZ25tZW50cztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhlbHBlciBGdW5jdGlvbnNcblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImdldEFsbEluZGV4ZXNcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEFsbEluZGV4ZXMoYXJyLCB2YWwpIHtcbiAgICAgICAgICAgIHZhciBpbmRleGVzID0gW10sXG4gICAgICAgICAgICAgICAgaSA9IC0xO1xuICAgICAgICAgICAgd2hpbGUgKChpID0gYXJyLmluZGV4T2YodmFsLCBpICsgMSkpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGluZGV4ZXMucHVzaChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbmRleGVzO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiYXJyYXlBbGxNYXhJbmRleGVzXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhcnJheUFsbE1heEluZGV4ZXMoYXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEFsbEluZGV4ZXMoYXJyYXksIE1hdGgubWF4LmFwcGx5KG51bGwsIGFycmF5KSk7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gTmVlZGxlbWFuV3Vuc2NoO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5lZWRsZW1hbld1bnNjaDtcblxuLyoqKi8gfSksXG4vKiAyNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgbGF5b3V0QmFzZSA9IGZ1bmN0aW9uIGxheW91dEJhc2UoKSB7XG4gIHJldHVybjtcbn07XG5cbmxheW91dEJhc2UuRkRMYXlvdXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcbmxheW91dEJhc2UuRkRMYXlvdXRDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xubGF5b3V0QmFzZS5GRExheW91dEVkZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcbmxheW91dEJhc2UuRkRMYXlvdXROb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG5sYXlvdXRCYXNlLkRpbWVuc2lvbkQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKTtcbmxheW91dEJhc2UuSGFzaE1hcCA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpO1xubGF5b3V0QmFzZS5IYXNoU2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XG5sYXlvdXRCYXNlLklHZW9tZXRyeSA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5sYXlvdXRCYXNlLklNYXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcbmxheW91dEJhc2UuSW50ZWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xubGF5b3V0QmFzZS5Qb2ludCA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xubGF5b3V0QmFzZS5Qb2ludEQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xubGF5b3V0QmFzZS5SYW5kb21TZWVkID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XG5sYXlvdXRCYXNlLlJlY3RhbmdsZUQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcbmxheW91dEJhc2UuVHJhbnNmb3JtID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XG5sYXlvdXRCYXNlLlVuaXF1ZUlER2VuZXJldG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG5sYXlvdXRCYXNlLlF1aWNrc29ydCA9IF9fd2VicGFja19yZXF1aXJlX18oMjQpO1xubGF5b3V0QmFzZS5MaW5rZWRMaXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5sYXlvdXRCYXNlLkxHcmFwaE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5sYXlvdXRCYXNlLkxHcmFwaCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5sYXlvdXRCYXNlLkxFZGdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbmxheW91dEJhc2UuTEdyYXBoTWFuYWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5sYXlvdXRCYXNlLkxOb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbmxheW91dEJhc2UuTGF5b3V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG5sYXlvdXRCYXNlLkxheW91dENvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5sYXlvdXRCYXNlLk5lZWRsZW1hbld1bnNjaCA9IF9fd2VicGFja19yZXF1aXJlX18oMjUpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGxheW91dEJhc2U7XG5cbi8qKiovIH0pLFxuLyogMjcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gRW1pdHRlcigpIHtcbiAgdGhpcy5saXN0ZW5lcnMgPSBbXTtcbn1cblxudmFyIHAgPSBFbWl0dGVyLnByb3RvdHlwZTtcblxucC5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudCwgY2FsbGJhY2spIHtcbiAgdGhpcy5saXN0ZW5lcnMucHVzaCh7XG4gICAgZXZlbnQ6IGV2ZW50LFxuICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICB9KTtcbn07XG5cbnAucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnQsIGNhbGxiYWNrKSB7XG4gIGZvciAodmFyIGkgPSB0aGlzLmxpc3RlbmVycy5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGwgPSB0aGlzLmxpc3RlbmVyc1tpXTtcblxuICAgIGlmIChsLmV2ZW50ID09PSBldmVudCAmJiBsLmNhbGxiYWNrID09PSBjYWxsYmFjaykge1xuICAgICAgdGhpcy5saXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xuICAgIH1cbiAgfVxufTtcblxucC5lbWl0ID0gZnVuY3Rpb24gKGV2ZW50LCBkYXRhKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5saXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbCA9IHRoaXMubGlzdGVuZXJzW2ldO1xuXG4gICAgaWYgKGV2ZW50ID09PSBsLmV2ZW50KSB7XG4gICAgICBsLmNhbGxiYWNrKGRhdGEpO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFbWl0dGVyO1xuXG4vKioqLyB9KVxuLyoqKioqKi8gXSk7XG59KTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/layout-base/layout-base.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/mermaid/dist/createText-aebacdfe.js":
/*!**********************************************************!*\
  !*** ./node_modules/mermaid/dist/createText-aebacdfe.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a: function() { return /* binding */ createText; },\n/* harmony export */   c: function() { return /* binding */ computeDimensionOfText; }\n/* harmony export */ });\n/* harmony import */ var _mermaid_934d9bea_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mermaid-934d9bea.js */ \"(app-client)/./node_modules/mermaid/dist/mermaid-934d9bea.js\");\n/* harmony import */ var mdast_util_from_markdown__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! mdast-util-from-markdown */ \"(app-client)/./node_modules/mdast-util-from-markdown/dev/lib/index.js\");\n/* harmony import */ var ts_dedent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ts-dedent */ \"(app-client)/./node_modules/ts-dedent/esm/index.js\");\n\n\n\nfunction preprocessMarkdown(markdown) {\n  const withoutMultipleNewlines = markdown.replace(/\\n{2,}/g, \"\\n\");\n  const withoutExtraSpaces = (0,ts_dedent__WEBPACK_IMPORTED_MODULE_0__.dedent)(withoutMultipleNewlines);\n  return withoutExtraSpaces;\n}\nfunction markdownToLines(markdown) {\n  const preprocessedMarkdown = preprocessMarkdown(markdown);\n  const { children } = (0,mdast_util_from_markdown__WEBPACK_IMPORTED_MODULE_1__.fromMarkdown)(preprocessedMarkdown);\n  const lines = [[]];\n  let currentLine = 0;\n  function processNode(node, parentType = \"normal\") {\n    if (node.type === \"text\") {\n      const textLines = node.value.split(\"\\n\");\n      textLines.forEach((textLine, index) => {\n        if (index !== 0) {\n          currentLine++;\n          lines.push([]);\n        }\n        textLine.split(\" \").forEach((word) => {\n          if (word) {\n            lines[currentLine].push({ content: word, type: parentType });\n          }\n        });\n      });\n    } else if (node.type === \"strong\" || node.type === \"emphasis\") {\n      node.children.forEach((contentNode) => {\n        processNode(contentNode, node.type);\n      });\n    }\n  }\n  children.forEach((treeNode) => {\n    if (treeNode.type === \"paragraph\") {\n      treeNode.children.forEach((contentNode) => {\n        processNode(contentNode);\n      });\n    }\n  });\n  return lines;\n}\nfunction markdownToHTML(markdown) {\n  const { children } = (0,mdast_util_from_markdown__WEBPACK_IMPORTED_MODULE_1__.fromMarkdown)(markdown);\n  function output(node) {\n    if (node.type === \"text\") {\n      return node.value.replace(/\\n/g, \"<br/>\");\n    } else if (node.type === \"strong\") {\n      return `<strong>${node.children.map(output).join(\"\")}</strong>`;\n    } else if (node.type === \"emphasis\") {\n      return `<em>${node.children.map(output).join(\"\")}</em>`;\n    } else if (node.type === \"paragraph\") {\n      return `<p>${node.children.map(output).join(\"\")}</p>`;\n    }\n    return `Unsupported markdown: ${node.type}`;\n  }\n  return children.map(output).join(\"\");\n}\nfunction splitTextToChars(text) {\n  if (Intl.Segmenter) {\n    return [...new Intl.Segmenter().segment(text)].map((s) => s.segment);\n  }\n  return [...text];\n}\nfunction splitWordToFitWidth(checkFit, word) {\n  const characters = splitTextToChars(word.content);\n  return splitWordToFitWidthRecursion(checkFit, [], characters, word.type);\n}\nfunction splitWordToFitWidthRecursion(checkFit, usedChars, remainingChars, type) {\n  if (remainingChars.length === 0) {\n    return [\n      { content: usedChars.join(\"\"), type },\n      { content: \"\", type }\n    ];\n  }\n  const [nextChar, ...rest] = remainingChars;\n  const newWord = [...usedChars, nextChar];\n  if (checkFit([{ content: newWord.join(\"\"), type }])) {\n    return splitWordToFitWidthRecursion(checkFit, newWord, rest, type);\n  }\n  if (usedChars.length === 0 && nextChar) {\n    usedChars.push(nextChar);\n    remainingChars.shift();\n  }\n  return [\n    { content: usedChars.join(\"\"), type },\n    { content: remainingChars.join(\"\"), type }\n  ];\n}\nfunction splitLineToFitWidth(line, checkFit) {\n  if (line.some(({ content }) => content.includes(\"\\n\"))) {\n    throw new Error(\"splitLineToFitWidth does not support newlines in the line\");\n  }\n  return splitLineToFitWidthRecursion(line, checkFit);\n}\nfunction splitLineToFitWidthRecursion(words, checkFit, lines = [], newLine = []) {\n  if (words.length === 0) {\n    if (newLine.length > 0) {\n      lines.push(newLine);\n    }\n    return lines.length > 0 ? lines : [];\n  }\n  let joiner = \"\";\n  if (words[0].content === \" \") {\n    joiner = \" \";\n    words.shift();\n  }\n  const nextWord = words.shift() ?? { content: \" \", type: \"normal\" };\n  const lineWithNextWord = [...newLine];\n  if (joiner !== \"\") {\n    lineWithNextWord.push({ content: joiner, type: \"normal\" });\n  }\n  lineWithNextWord.push(nextWord);\n  if (checkFit(lineWithNextWord)) {\n    return splitLineToFitWidthRecursion(words, checkFit, lines, lineWithNextWord);\n  }\n  if (newLine.length > 0) {\n    lines.push(newLine);\n    words.unshift(nextWord);\n  } else if (nextWord.content) {\n    const [line, rest] = splitWordToFitWidth(checkFit, nextWord);\n    lines.push([line]);\n    if (rest.content) {\n      words.unshift(rest);\n    }\n  }\n  return splitLineToFitWidthRecursion(words, checkFit, lines);\n}\nfunction applyStyle(dom, styleFn) {\n  if (styleFn) {\n    dom.attr(\"style\", styleFn);\n  }\n}\nfunction addHtmlSpan(element, node, width, classes, addBackground = false) {\n  const fo = element.append(\"foreignObject\");\n  const div = fo.append(\"xhtml:div\");\n  const label = node.label;\n  const labelClass = node.isNode ? \"nodeLabel\" : \"edgeLabel\";\n  div.html(\n    `\n    <span class=\"${labelClass} ${classes}\" ` + (node.labelStyle ? 'style=\"' + node.labelStyle + '\"' : \"\") + \">\" + label + \"</span>\"\n  );\n  applyStyle(div, node.labelStyle);\n  div.style(\"display\", \"table-cell\");\n  div.style(\"white-space\", \"nowrap\");\n  div.style(\"max-width\", width + \"px\");\n  div.attr(\"xmlns\", \"http://www.w3.org/1999/xhtml\");\n  if (addBackground) {\n    div.attr(\"class\", \"labelBkg\");\n  }\n  let bbox = div.node().getBoundingClientRect();\n  if (bbox.width === width) {\n    div.style(\"display\", \"table\");\n    div.style(\"white-space\", \"break-spaces\");\n    div.style(\"width\", width + \"px\");\n    bbox = div.node().getBoundingClientRect();\n  }\n  fo.style(\"width\", bbox.width);\n  fo.style(\"height\", bbox.height);\n  return fo.node();\n}\nfunction createTspan(textElement, lineIndex, lineHeight) {\n  return textElement.append(\"tspan\").attr(\"class\", \"text-outer-tspan\").attr(\"x\", 0).attr(\"y\", lineIndex * lineHeight - 0.1 + \"em\").attr(\"dy\", lineHeight + \"em\");\n}\nfunction computeWidthOfText(parentNode, lineHeight, line) {\n  const testElement = parentNode.append(\"text\");\n  const testSpan = createTspan(testElement, 1, lineHeight);\n  updateTextContentAndStyles(testSpan, line);\n  const textLength = testSpan.node().getComputedTextLength();\n  testElement.remove();\n  return textLength;\n}\nfunction computeDimensionOfText(parentNode, lineHeight, text) {\n  var _a;\n  const testElement = parentNode.append(\"text\");\n  const testSpan = createTspan(testElement, 1, lineHeight);\n  updateTextContentAndStyles(testSpan, [{ content: text, type: \"normal\" }]);\n  const textDimension = (_a = testSpan.node()) == null ? void 0 : _a.getBoundingClientRect();\n  if (textDimension) {\n    testElement.remove();\n  }\n  return textDimension;\n}\nfunction createFormattedText(width, g, structuredText, addBackground = false) {\n  const lineHeight = 1.1;\n  const labelGroup = g.append(\"g\");\n  const bkg = labelGroup.insert(\"rect\").attr(\"class\", \"background\");\n  const textElement = labelGroup.append(\"text\").attr(\"y\", \"-10.1\");\n  let lineIndex = 0;\n  for (const line of structuredText) {\n    const checkWidth = (line2) => computeWidthOfText(labelGroup, lineHeight, line2) <= width;\n    const linesUnderWidth = checkWidth(line) ? [line] : splitLineToFitWidth(line, checkWidth);\n    for (const preparedLine of linesUnderWidth) {\n      const tspan = createTspan(textElement, lineIndex, lineHeight);\n      updateTextContentAndStyles(tspan, preparedLine);\n      lineIndex++;\n    }\n  }\n  if (addBackground) {\n    const bbox = textElement.node().getBBox();\n    const padding = 2;\n    bkg.attr(\"x\", -padding).attr(\"y\", -padding).attr(\"width\", bbox.width + 2 * padding).attr(\"height\", bbox.height + 2 * padding);\n    return labelGroup.node();\n  } else {\n    return textElement.node();\n  }\n}\nfunction updateTextContentAndStyles(tspan, wrappedLine) {\n  tspan.text(\"\");\n  wrappedLine.forEach((word, index) => {\n    const innerTspan = tspan.append(\"tspan\").attr(\"font-style\", word.type === \"emphasis\" ? \"italic\" : \"normal\").attr(\"class\", \"text-inner-tspan\").attr(\"font-weight\", word.type === \"strong\" ? \"bold\" : \"normal\");\n    if (index === 0) {\n      innerTspan.text(word.content);\n    } else {\n      innerTspan.text(\" \" + word.content);\n    }\n  });\n}\nconst createText = (el, text = \"\", {\n  style = \"\",\n  isTitle = false,\n  classes = \"\",\n  useHtmlLabels = true,\n  isNode = true,\n  width = 200,\n  addSvgBackground = false\n} = {}) => {\n  _mermaid_934d9bea_js__WEBPACK_IMPORTED_MODULE_2__.l.info(\"createText\", text, style, isTitle, classes, useHtmlLabels, isNode, addSvgBackground);\n  if (useHtmlLabels) {\n    const htmlText = markdownToHTML(text);\n    const node = {\n      isNode,\n      label: (0,_mermaid_934d9bea_js__WEBPACK_IMPORTED_MODULE_2__.J)(htmlText).replace(\n        /fa[blrs]?:fa-[\\w-]+/g,\n        (s) => `<i class='${s.replace(\":\", \" \")}'></i>`\n      ),\n      labelStyle: style.replace(\"fill:\", \"color:\")\n    };\n    const vertexNode = addHtmlSpan(el, node, width, classes, addSvgBackground);\n    return vertexNode;\n  } else {\n    const structuredText = markdownToLines(text);\n    const svgLabel = createFormattedText(width, el, structuredText, addSvgBackground);\n    return svgLabel;\n  }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL21lcm1haWQvZGlzdC9jcmVhdGVUZXh0LWFlYmFjZGZlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQXNFO0FBQ2Q7QUFDckI7QUFDbkM7QUFDQSx1REFBdUQsR0FBRztBQUMxRCw2QkFBNkIsaURBQU07QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFdBQVcsRUFBRSxzRUFBWTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsaUNBQWlDO0FBQ3ZFO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsVUFBVSxXQUFXLEVBQUUsc0VBQVk7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHdCQUF3QixtQ0FBbUM7QUFDM0QsTUFBTTtBQUNOLG9CQUFvQixtQ0FBbUM7QUFDdkQsTUFBTTtBQUNOLG1CQUFtQixtQ0FBbUM7QUFDdEQ7QUFDQSxvQ0FBb0MsVUFBVTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsbUNBQW1DO0FBQzNDLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQ0FBaUM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLG1DQUFtQztBQUN6QyxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBLDRCQUE0QixpQ0FBaUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFlBQVksRUFBRSxRQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsK0JBQStCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJO0FBQ04sRUFBRSxtREFBRztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx1REFBYztBQUMzQjtBQUNBLDRCQUE0QixvQkFBb0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL21lcm1haWQvZGlzdC9jcmVhdGVUZXh0LWFlYmFjZGZlLmpzPzU5MzQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbCBhcyBsb2csIEogYXMgZGVjb2RlRW50aXRpZXMgfSBmcm9tIFwiLi9tZXJtYWlkLTkzNGQ5YmVhLmpzXCI7XG5pbXBvcnQgeyBmcm9tTWFya2Rvd24gfSBmcm9tIFwibWRhc3QtdXRpbC1mcm9tLW1hcmtkb3duXCI7XG5pbXBvcnQgeyBkZWRlbnQgfSBmcm9tIFwidHMtZGVkZW50XCI7XG5mdW5jdGlvbiBwcmVwcm9jZXNzTWFya2Rvd24obWFya2Rvd24pIHtcbiAgY29uc3Qgd2l0aG91dE11bHRpcGxlTmV3bGluZXMgPSBtYXJrZG93bi5yZXBsYWNlKC9cXG57Mix9L2csIFwiXFxuXCIpO1xuICBjb25zdCB3aXRob3V0RXh0cmFTcGFjZXMgPSBkZWRlbnQod2l0aG91dE11bHRpcGxlTmV3bGluZXMpO1xuICByZXR1cm4gd2l0aG91dEV4dHJhU3BhY2VzO1xufVxuZnVuY3Rpb24gbWFya2Rvd25Ub0xpbmVzKG1hcmtkb3duKSB7XG4gIGNvbnN0IHByZXByb2Nlc3NlZE1hcmtkb3duID0gcHJlcHJvY2Vzc01hcmtkb3duKG1hcmtkb3duKTtcbiAgY29uc3QgeyBjaGlsZHJlbiB9ID0gZnJvbU1hcmtkb3duKHByZXByb2Nlc3NlZE1hcmtkb3duKTtcbiAgY29uc3QgbGluZXMgPSBbW11dO1xuICBsZXQgY3VycmVudExpbmUgPSAwO1xuICBmdW5jdGlvbiBwcm9jZXNzTm9kZShub2RlLCBwYXJlbnRUeXBlID0gXCJub3JtYWxcIikge1xuICAgIGlmIChub2RlLnR5cGUgPT09IFwidGV4dFwiKSB7XG4gICAgICBjb25zdCB0ZXh0TGluZXMgPSBub2RlLnZhbHVlLnNwbGl0KFwiXFxuXCIpO1xuICAgICAgdGV4dExpbmVzLmZvckVhY2goKHRleHRMaW5lLCBpbmRleCkgPT4ge1xuICAgICAgICBpZiAoaW5kZXggIT09IDApIHtcbiAgICAgICAgICBjdXJyZW50TGluZSsrO1xuICAgICAgICAgIGxpbmVzLnB1c2goW10pO1xuICAgICAgICB9XG4gICAgICAgIHRleHRMaW5lLnNwbGl0KFwiIFwiKS5mb3JFYWNoKCh3b3JkKSA9PiB7XG4gICAgICAgICAgaWYgKHdvcmQpIHtcbiAgICAgICAgICAgIGxpbmVzW2N1cnJlbnRMaW5lXS5wdXNoKHsgY29udGVudDogd29yZCwgdHlwZTogcGFyZW50VHlwZSB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IFwic3Ryb25nXCIgfHwgbm9kZS50eXBlID09PSBcImVtcGhhc2lzXCIpIHtcbiAgICAgIG5vZGUuY2hpbGRyZW4uZm9yRWFjaCgoY29udGVudE5vZGUpID0+IHtcbiAgICAgICAgcHJvY2Vzc05vZGUoY29udGVudE5vZGUsIG5vZGUudHlwZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgY2hpbGRyZW4uZm9yRWFjaCgodHJlZU5vZGUpID0+IHtcbiAgICBpZiAodHJlZU5vZGUudHlwZSA9PT0gXCJwYXJhZ3JhcGhcIikge1xuICAgICAgdHJlZU5vZGUuY2hpbGRyZW4uZm9yRWFjaCgoY29udGVudE5vZGUpID0+IHtcbiAgICAgICAgcHJvY2Vzc05vZGUoY29udGVudE5vZGUpO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGxpbmVzO1xufVxuZnVuY3Rpb24gbWFya2Rvd25Ub0hUTUwobWFya2Rvd24pIHtcbiAgY29uc3QgeyBjaGlsZHJlbiB9ID0gZnJvbU1hcmtkb3duKG1hcmtkb3duKTtcbiAgZnVuY3Rpb24gb3V0cHV0KG5vZGUpIHtcbiAgICBpZiAobm9kZS50eXBlID09PSBcInRleHRcIikge1xuICAgICAgcmV0dXJuIG5vZGUudmFsdWUucmVwbGFjZSgvXFxuL2csIFwiPGJyLz5cIik7XG4gICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IFwic3Ryb25nXCIpIHtcbiAgICAgIHJldHVybiBgPHN0cm9uZz4ke25vZGUuY2hpbGRyZW4ubWFwKG91dHB1dCkuam9pbihcIlwiKX08L3N0cm9uZz5gO1xuICAgIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSBcImVtcGhhc2lzXCIpIHtcbiAgICAgIHJldHVybiBgPGVtPiR7bm9kZS5jaGlsZHJlbi5tYXAob3V0cHV0KS5qb2luKFwiXCIpfTwvZW0+YDtcbiAgICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gXCJwYXJhZ3JhcGhcIikge1xuICAgICAgcmV0dXJuIGA8cD4ke25vZGUuY2hpbGRyZW4ubWFwKG91dHB1dCkuam9pbihcIlwiKX08L3A+YDtcbiAgICB9XG4gICAgcmV0dXJuIGBVbnN1cHBvcnRlZCBtYXJrZG93bjogJHtub2RlLnR5cGV9YDtcbiAgfVxuICByZXR1cm4gY2hpbGRyZW4ubWFwKG91dHB1dCkuam9pbihcIlwiKTtcbn1cbmZ1bmN0aW9uIHNwbGl0VGV4dFRvQ2hhcnModGV4dCkge1xuICBpZiAoSW50bC5TZWdtZW50ZXIpIHtcbiAgICByZXR1cm4gWy4uLm5ldyBJbnRsLlNlZ21lbnRlcigpLnNlZ21lbnQodGV4dCldLm1hcCgocykgPT4gcy5zZWdtZW50KTtcbiAgfVxuICByZXR1cm4gWy4uLnRleHRdO1xufVxuZnVuY3Rpb24gc3BsaXRXb3JkVG9GaXRXaWR0aChjaGVja0ZpdCwgd29yZCkge1xuICBjb25zdCBjaGFyYWN0ZXJzID0gc3BsaXRUZXh0VG9DaGFycyh3b3JkLmNvbnRlbnQpO1xuICByZXR1cm4gc3BsaXRXb3JkVG9GaXRXaWR0aFJlY3Vyc2lvbihjaGVja0ZpdCwgW10sIGNoYXJhY3RlcnMsIHdvcmQudHlwZSk7XG59XG5mdW5jdGlvbiBzcGxpdFdvcmRUb0ZpdFdpZHRoUmVjdXJzaW9uKGNoZWNrRml0LCB1c2VkQ2hhcnMsIHJlbWFpbmluZ0NoYXJzLCB0eXBlKSB7XG4gIGlmIChyZW1haW5pbmdDaGFycy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gW1xuICAgICAgeyBjb250ZW50OiB1c2VkQ2hhcnMuam9pbihcIlwiKSwgdHlwZSB9LFxuICAgICAgeyBjb250ZW50OiBcIlwiLCB0eXBlIH1cbiAgICBdO1xuICB9XG4gIGNvbnN0IFtuZXh0Q2hhciwgLi4ucmVzdF0gPSByZW1haW5pbmdDaGFycztcbiAgY29uc3QgbmV3V29yZCA9IFsuLi51c2VkQ2hhcnMsIG5leHRDaGFyXTtcbiAgaWYgKGNoZWNrRml0KFt7IGNvbnRlbnQ6IG5ld1dvcmQuam9pbihcIlwiKSwgdHlwZSB9XSkpIHtcbiAgICByZXR1cm4gc3BsaXRXb3JkVG9GaXRXaWR0aFJlY3Vyc2lvbihjaGVja0ZpdCwgbmV3V29yZCwgcmVzdCwgdHlwZSk7XG4gIH1cbiAgaWYgKHVzZWRDaGFycy5sZW5ndGggPT09IDAgJiYgbmV4dENoYXIpIHtcbiAgICB1c2VkQ2hhcnMucHVzaChuZXh0Q2hhcik7XG4gICAgcmVtYWluaW5nQ2hhcnMuc2hpZnQoKTtcbiAgfVxuICByZXR1cm4gW1xuICAgIHsgY29udGVudDogdXNlZENoYXJzLmpvaW4oXCJcIiksIHR5cGUgfSxcbiAgICB7IGNvbnRlbnQ6IHJlbWFpbmluZ0NoYXJzLmpvaW4oXCJcIiksIHR5cGUgfVxuICBdO1xufVxuZnVuY3Rpb24gc3BsaXRMaW5lVG9GaXRXaWR0aChsaW5lLCBjaGVja0ZpdCkge1xuICBpZiAobGluZS5zb21lKCh7IGNvbnRlbnQgfSkgPT4gY29udGVudC5pbmNsdWRlcyhcIlxcblwiKSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJzcGxpdExpbmVUb0ZpdFdpZHRoIGRvZXMgbm90IHN1cHBvcnQgbmV3bGluZXMgaW4gdGhlIGxpbmVcIik7XG4gIH1cbiAgcmV0dXJuIHNwbGl0TGluZVRvRml0V2lkdGhSZWN1cnNpb24obGluZSwgY2hlY2tGaXQpO1xufVxuZnVuY3Rpb24gc3BsaXRMaW5lVG9GaXRXaWR0aFJlY3Vyc2lvbih3b3JkcywgY2hlY2tGaXQsIGxpbmVzID0gW10sIG5ld0xpbmUgPSBbXSkge1xuICBpZiAod29yZHMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKG5ld0xpbmUubGVuZ3RoID4gMCkge1xuICAgICAgbGluZXMucHVzaChuZXdMaW5lKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpbmVzLmxlbmd0aCA+IDAgPyBsaW5lcyA6IFtdO1xuICB9XG4gIGxldCBqb2luZXIgPSBcIlwiO1xuICBpZiAod29yZHNbMF0uY29udGVudCA9PT0gXCIgXCIpIHtcbiAgICBqb2luZXIgPSBcIiBcIjtcbiAgICB3b3Jkcy5zaGlmdCgpO1xuICB9XG4gIGNvbnN0IG5leHRXb3JkID0gd29yZHMuc2hpZnQoKSA/PyB7IGNvbnRlbnQ6IFwiIFwiLCB0eXBlOiBcIm5vcm1hbFwiIH07XG4gIGNvbnN0IGxpbmVXaXRoTmV4dFdvcmQgPSBbLi4ubmV3TGluZV07XG4gIGlmIChqb2luZXIgIT09IFwiXCIpIHtcbiAgICBsaW5lV2l0aE5leHRXb3JkLnB1c2goeyBjb250ZW50OiBqb2luZXIsIHR5cGU6IFwibm9ybWFsXCIgfSk7XG4gIH1cbiAgbGluZVdpdGhOZXh0V29yZC5wdXNoKG5leHRXb3JkKTtcbiAgaWYgKGNoZWNrRml0KGxpbmVXaXRoTmV4dFdvcmQpKSB7XG4gICAgcmV0dXJuIHNwbGl0TGluZVRvRml0V2lkdGhSZWN1cnNpb24od29yZHMsIGNoZWNrRml0LCBsaW5lcywgbGluZVdpdGhOZXh0V29yZCk7XG4gIH1cbiAgaWYgKG5ld0xpbmUubGVuZ3RoID4gMCkge1xuICAgIGxpbmVzLnB1c2gobmV3TGluZSk7XG4gICAgd29yZHMudW5zaGlmdChuZXh0V29yZCk7XG4gIH0gZWxzZSBpZiAobmV4dFdvcmQuY29udGVudCkge1xuICAgIGNvbnN0IFtsaW5lLCByZXN0XSA9IHNwbGl0V29yZFRvRml0V2lkdGgoY2hlY2tGaXQsIG5leHRXb3JkKTtcbiAgICBsaW5lcy5wdXNoKFtsaW5lXSk7XG4gICAgaWYgKHJlc3QuY29udGVudCkge1xuICAgICAgd29yZHMudW5zaGlmdChyZXN0KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNwbGl0TGluZVRvRml0V2lkdGhSZWN1cnNpb24od29yZHMsIGNoZWNrRml0LCBsaW5lcyk7XG59XG5mdW5jdGlvbiBhcHBseVN0eWxlKGRvbSwgc3R5bGVGbikge1xuICBpZiAoc3R5bGVGbikge1xuICAgIGRvbS5hdHRyKFwic3R5bGVcIiwgc3R5bGVGbik7XG4gIH1cbn1cbmZ1bmN0aW9uIGFkZEh0bWxTcGFuKGVsZW1lbnQsIG5vZGUsIHdpZHRoLCBjbGFzc2VzLCBhZGRCYWNrZ3JvdW5kID0gZmFsc2UpIHtcbiAgY29uc3QgZm8gPSBlbGVtZW50LmFwcGVuZChcImZvcmVpZ25PYmplY3RcIik7XG4gIGNvbnN0IGRpdiA9IGZvLmFwcGVuZChcInhodG1sOmRpdlwiKTtcbiAgY29uc3QgbGFiZWwgPSBub2RlLmxhYmVsO1xuICBjb25zdCBsYWJlbENsYXNzID0gbm9kZS5pc05vZGUgPyBcIm5vZGVMYWJlbFwiIDogXCJlZGdlTGFiZWxcIjtcbiAgZGl2Lmh0bWwoXG4gICAgYFxuICAgIDxzcGFuIGNsYXNzPVwiJHtsYWJlbENsYXNzfSAke2NsYXNzZXN9XCIgYCArIChub2RlLmxhYmVsU3R5bGUgPyAnc3R5bGU9XCInICsgbm9kZS5sYWJlbFN0eWxlICsgJ1wiJyA6IFwiXCIpICsgXCI+XCIgKyBsYWJlbCArIFwiPC9zcGFuPlwiXG4gICk7XG4gIGFwcGx5U3R5bGUoZGl2LCBub2RlLmxhYmVsU3R5bGUpO1xuICBkaXYuc3R5bGUoXCJkaXNwbGF5XCIsIFwidGFibGUtY2VsbFwiKTtcbiAgZGl2LnN0eWxlKFwid2hpdGUtc3BhY2VcIiwgXCJub3dyYXBcIik7XG4gIGRpdi5zdHlsZShcIm1heC13aWR0aFwiLCB3aWR0aCArIFwicHhcIik7XG4gIGRpdi5hdHRyKFwieG1sbnNcIiwgXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCIpO1xuICBpZiAoYWRkQmFja2dyb3VuZCkge1xuICAgIGRpdi5hdHRyKFwiY2xhc3NcIiwgXCJsYWJlbEJrZ1wiKTtcbiAgfVxuICBsZXQgYmJveCA9IGRpdi5ub2RlKCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGlmIChiYm94LndpZHRoID09PSB3aWR0aCkge1xuICAgIGRpdi5zdHlsZShcImRpc3BsYXlcIiwgXCJ0YWJsZVwiKTtcbiAgICBkaXYuc3R5bGUoXCJ3aGl0ZS1zcGFjZVwiLCBcImJyZWFrLXNwYWNlc1wiKTtcbiAgICBkaXYuc3R5bGUoXCJ3aWR0aFwiLCB3aWR0aCArIFwicHhcIik7XG4gICAgYmJveCA9IGRpdi5ub2RlKCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIH1cbiAgZm8uc3R5bGUoXCJ3aWR0aFwiLCBiYm94LndpZHRoKTtcbiAgZm8uc3R5bGUoXCJoZWlnaHRcIiwgYmJveC5oZWlnaHQpO1xuICByZXR1cm4gZm8ubm9kZSgpO1xufVxuZnVuY3Rpb24gY3JlYXRlVHNwYW4odGV4dEVsZW1lbnQsIGxpbmVJbmRleCwgbGluZUhlaWdodCkge1xuICByZXR1cm4gdGV4dEVsZW1lbnQuYXBwZW5kKFwidHNwYW5cIikuYXR0cihcImNsYXNzXCIsIFwidGV4dC1vdXRlci10c3BhblwiKS5hdHRyKFwieFwiLCAwKS5hdHRyKFwieVwiLCBsaW5lSW5kZXggKiBsaW5lSGVpZ2h0IC0gMC4xICsgXCJlbVwiKS5hdHRyKFwiZHlcIiwgbGluZUhlaWdodCArIFwiZW1cIik7XG59XG5mdW5jdGlvbiBjb21wdXRlV2lkdGhPZlRleHQocGFyZW50Tm9kZSwgbGluZUhlaWdodCwgbGluZSkge1xuICBjb25zdCB0ZXN0RWxlbWVudCA9IHBhcmVudE5vZGUuYXBwZW5kKFwidGV4dFwiKTtcbiAgY29uc3QgdGVzdFNwYW4gPSBjcmVhdGVUc3Bhbih0ZXN0RWxlbWVudCwgMSwgbGluZUhlaWdodCk7XG4gIHVwZGF0ZVRleHRDb250ZW50QW5kU3R5bGVzKHRlc3RTcGFuLCBsaW5lKTtcbiAgY29uc3QgdGV4dExlbmd0aCA9IHRlc3RTcGFuLm5vZGUoKS5nZXRDb21wdXRlZFRleHRMZW5ndGgoKTtcbiAgdGVzdEVsZW1lbnQucmVtb3ZlKCk7XG4gIHJldHVybiB0ZXh0TGVuZ3RoO1xufVxuZnVuY3Rpb24gY29tcHV0ZURpbWVuc2lvbk9mVGV4dChwYXJlbnROb2RlLCBsaW5lSGVpZ2h0LCB0ZXh0KSB7XG4gIHZhciBfYTtcbiAgY29uc3QgdGVzdEVsZW1lbnQgPSBwYXJlbnROb2RlLmFwcGVuZChcInRleHRcIik7XG4gIGNvbnN0IHRlc3RTcGFuID0gY3JlYXRlVHNwYW4odGVzdEVsZW1lbnQsIDEsIGxpbmVIZWlnaHQpO1xuICB1cGRhdGVUZXh0Q29udGVudEFuZFN0eWxlcyh0ZXN0U3BhbiwgW3sgY29udGVudDogdGV4dCwgdHlwZTogXCJub3JtYWxcIiB9XSk7XG4gIGNvbnN0IHRleHREaW1lbnNpb24gPSAoX2EgPSB0ZXN0U3Bhbi5ub2RlKCkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgaWYgKHRleHREaW1lbnNpb24pIHtcbiAgICB0ZXN0RWxlbWVudC5yZW1vdmUoKTtcbiAgfVxuICByZXR1cm4gdGV4dERpbWVuc2lvbjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZvcm1hdHRlZFRleHQod2lkdGgsIGcsIHN0cnVjdHVyZWRUZXh0LCBhZGRCYWNrZ3JvdW5kID0gZmFsc2UpIHtcbiAgY29uc3QgbGluZUhlaWdodCA9IDEuMTtcbiAgY29uc3QgbGFiZWxHcm91cCA9IGcuYXBwZW5kKFwiZ1wiKTtcbiAgY29uc3QgYmtnID0gbGFiZWxHcm91cC5pbnNlcnQoXCJyZWN0XCIpLmF0dHIoXCJjbGFzc1wiLCBcImJhY2tncm91bmRcIik7XG4gIGNvbnN0IHRleHRFbGVtZW50ID0gbGFiZWxHcm91cC5hcHBlbmQoXCJ0ZXh0XCIpLmF0dHIoXCJ5XCIsIFwiLTEwLjFcIik7XG4gIGxldCBsaW5lSW5kZXggPSAwO1xuICBmb3IgKGNvbnN0IGxpbmUgb2Ygc3RydWN0dXJlZFRleHQpIHtcbiAgICBjb25zdCBjaGVja1dpZHRoID0gKGxpbmUyKSA9PiBjb21wdXRlV2lkdGhPZlRleHQobGFiZWxHcm91cCwgbGluZUhlaWdodCwgbGluZTIpIDw9IHdpZHRoO1xuICAgIGNvbnN0IGxpbmVzVW5kZXJXaWR0aCA9IGNoZWNrV2lkdGgobGluZSkgPyBbbGluZV0gOiBzcGxpdExpbmVUb0ZpdFdpZHRoKGxpbmUsIGNoZWNrV2lkdGgpO1xuICAgIGZvciAoY29uc3QgcHJlcGFyZWRMaW5lIG9mIGxpbmVzVW5kZXJXaWR0aCkge1xuICAgICAgY29uc3QgdHNwYW4gPSBjcmVhdGVUc3Bhbih0ZXh0RWxlbWVudCwgbGluZUluZGV4LCBsaW5lSGVpZ2h0KTtcbiAgICAgIHVwZGF0ZVRleHRDb250ZW50QW5kU3R5bGVzKHRzcGFuLCBwcmVwYXJlZExpbmUpO1xuICAgICAgbGluZUluZGV4Kys7XG4gICAgfVxuICB9XG4gIGlmIChhZGRCYWNrZ3JvdW5kKSB7XG4gICAgY29uc3QgYmJveCA9IHRleHRFbGVtZW50Lm5vZGUoKS5nZXRCQm94KCk7XG4gICAgY29uc3QgcGFkZGluZyA9IDI7XG4gICAgYmtnLmF0dHIoXCJ4XCIsIC1wYWRkaW5nKS5hdHRyKFwieVwiLCAtcGFkZGluZykuYXR0cihcIndpZHRoXCIsIGJib3gud2lkdGggKyAyICogcGFkZGluZykuYXR0cihcImhlaWdodFwiLCBiYm94LmhlaWdodCArIDIgKiBwYWRkaW5nKTtcbiAgICByZXR1cm4gbGFiZWxHcm91cC5ub2RlKCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRleHRFbGVtZW50Lm5vZGUoKTtcbiAgfVxufVxuZnVuY3Rpb24gdXBkYXRlVGV4dENvbnRlbnRBbmRTdHlsZXModHNwYW4sIHdyYXBwZWRMaW5lKSB7XG4gIHRzcGFuLnRleHQoXCJcIik7XG4gIHdyYXBwZWRMaW5lLmZvckVhY2goKHdvcmQsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgaW5uZXJUc3BhbiA9IHRzcGFuLmFwcGVuZChcInRzcGFuXCIpLmF0dHIoXCJmb250LXN0eWxlXCIsIHdvcmQudHlwZSA9PT0gXCJlbXBoYXNpc1wiID8gXCJpdGFsaWNcIiA6IFwibm9ybWFsXCIpLmF0dHIoXCJjbGFzc1wiLCBcInRleHQtaW5uZXItdHNwYW5cIikuYXR0cihcImZvbnQtd2VpZ2h0XCIsIHdvcmQudHlwZSA9PT0gXCJzdHJvbmdcIiA/IFwiYm9sZFwiIDogXCJub3JtYWxcIik7XG4gICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICBpbm5lclRzcGFuLnRleHQod29yZC5jb250ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5uZXJUc3Bhbi50ZXh0KFwiIFwiICsgd29yZC5jb250ZW50KTtcbiAgICB9XG4gIH0pO1xufVxuY29uc3QgY3JlYXRlVGV4dCA9IChlbCwgdGV4dCA9IFwiXCIsIHtcbiAgc3R5bGUgPSBcIlwiLFxuICBpc1RpdGxlID0gZmFsc2UsXG4gIGNsYXNzZXMgPSBcIlwiLFxuICB1c2VIdG1sTGFiZWxzID0gdHJ1ZSxcbiAgaXNOb2RlID0gdHJ1ZSxcbiAgd2lkdGggPSAyMDAsXG4gIGFkZFN2Z0JhY2tncm91bmQgPSBmYWxzZVxufSA9IHt9KSA9PiB7XG4gIGxvZy5pbmZvKFwiY3JlYXRlVGV4dFwiLCB0ZXh0LCBzdHlsZSwgaXNUaXRsZSwgY2xhc3NlcywgdXNlSHRtbExhYmVscywgaXNOb2RlLCBhZGRTdmdCYWNrZ3JvdW5kKTtcbiAgaWYgKHVzZUh0bWxMYWJlbHMpIHtcbiAgICBjb25zdCBodG1sVGV4dCA9IG1hcmtkb3duVG9IVE1MKHRleHQpO1xuICAgIGNvbnN0IG5vZGUgPSB7XG4gICAgICBpc05vZGUsXG4gICAgICBsYWJlbDogZGVjb2RlRW50aXRpZXMoaHRtbFRleHQpLnJlcGxhY2UoXG4gICAgICAgIC9mYVtibHJzXT86ZmEtW1xcdy1dKy9nLFxuICAgICAgICAocykgPT4gYDxpIGNsYXNzPScke3MucmVwbGFjZShcIjpcIiwgXCIgXCIpfSc+PC9pPmBcbiAgICAgICksXG4gICAgICBsYWJlbFN0eWxlOiBzdHlsZS5yZXBsYWNlKFwiZmlsbDpcIiwgXCJjb2xvcjpcIilcbiAgICB9O1xuICAgIGNvbnN0IHZlcnRleE5vZGUgPSBhZGRIdG1sU3BhbihlbCwgbm9kZSwgd2lkdGgsIGNsYXNzZXMsIGFkZFN2Z0JhY2tncm91bmQpO1xuICAgIHJldHVybiB2ZXJ0ZXhOb2RlO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHN0cnVjdHVyZWRUZXh0ID0gbWFya2Rvd25Ub0xpbmVzKHRleHQpO1xuICAgIGNvbnN0IHN2Z0xhYmVsID0gY3JlYXRlRm9ybWF0dGVkVGV4dCh3aWR0aCwgZWwsIHN0cnVjdHVyZWRUZXh0LCBhZGRTdmdCYWNrZ3JvdW5kKTtcbiAgICByZXR1cm4gc3ZnTGFiZWw7XG4gIH1cbn07XG5leHBvcnQge1xuICBjcmVhdGVUZXh0IGFzIGEsXG4gIGNvbXB1dGVEaW1lbnNpb25PZlRleHQgYXMgY1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/mermaid/dist/createText-aebacdfe.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/mermaid/dist/mindmap-definition-617cf8dd.js":
/*!******************************************************************!*\
  !*** ./node_modules/mermaid/dist/mindmap-definition-617cf8dd.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   diagram: function() { return /* binding */ diagram; }\n/* harmony export */ });\n/* harmony import */ var _mermaid_934d9bea_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./mermaid-934d9bea.js */ \"(app-client)/./node_modules/mermaid/dist/mermaid-934d9bea.js\");\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"(app-client)/./node_modules/d3/src/index.js\");\n/* harmony import */ var _createText_aebacdfe_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./createText-aebacdfe.js */ \"(app-client)/./node_modules/mermaid/dist/createText-aebacdfe.js\");\n/* harmony import */ var cytoscape_dist_cytoscape_umd_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cytoscape/dist/cytoscape.umd.js */ \"(app-client)/./node_modules/cytoscape/dist/cytoscape.umd.js\");\n/* harmony import */ var cytoscape_cose_bilkent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cytoscape-cose-bilkent */ \"(app-client)/./node_modules/cytoscape-cose-bilkent/cytoscape-cose-bilkent.js\");\n/* harmony import */ var khroma__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! khroma */ \"(app-client)/./node_modules/khroma/dist/methods/is_dark.js\");\n/* harmony import */ var khroma__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! khroma */ \"(app-client)/./node_modules/khroma/dist/methods/lighten.js\");\n/* harmony import */ var khroma__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! khroma */ \"(app-client)/./node_modules/khroma/dist/methods/darken.js\");\n/* harmony import */ var ts_dedent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ts-dedent */ \"(app-client)/./node_modules/ts-dedent/esm/index.js\");\n/* harmony import */ var dayjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! dayjs */ \"(app-client)/./node_modules/dayjs/dayjs.min.js\");\n/* harmony import */ var _braintree_sanitize_url__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @braintree/sanitize-url */ \"(app-client)/./node_modules/@braintree/sanitize-url/dist/index.js\");\n/* harmony import */ var dompurify__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! dompurify */ \"(app-client)/./node_modules/dompurify/dist/purify.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar parser = function() {\n  var o = function(k, v, o2, l) {\n    for (o2 = o2 || {}, l = k.length; l--; o2[k[l]] = v)\n      ;\n    return o2;\n  }, $V0 = [1, 4], $V1 = [1, 13], $V2 = [1, 12], $V3 = [1, 15], $V4 = [1, 16], $V5 = [1, 20], $V6 = [1, 19], $V7 = [6, 7, 8], $V8 = [1, 26], $V9 = [1, 24], $Va = [1, 25], $Vb = [6, 7, 11], $Vc = [1, 6, 13, 15, 16, 19, 22], $Vd = [1, 33], $Ve = [1, 34], $Vf = [1, 6, 7, 11, 13, 15, 16, 19, 22];\n  var parser2 = {\n    trace: function trace() {\n    },\n    yy: {},\n    symbols_: { \"error\": 2, \"start\": 3, \"mindMap\": 4, \"spaceLines\": 5, \"SPACELINE\": 6, \"NL\": 7, \"MINDMAP\": 8, \"document\": 9, \"stop\": 10, \"EOF\": 11, \"statement\": 12, \"SPACELIST\": 13, \"node\": 14, \"ICON\": 15, \"CLASS\": 16, \"nodeWithId\": 17, \"nodeWithoutId\": 18, \"NODE_DSTART\": 19, \"NODE_DESCR\": 20, \"NODE_DEND\": 21, \"NODE_ID\": 22, \"$accept\": 0, \"$end\": 1 },\n    terminals_: { 2: \"error\", 6: \"SPACELINE\", 7: \"NL\", 8: \"MINDMAP\", 11: \"EOF\", 13: \"SPACELIST\", 15: \"ICON\", 16: \"CLASS\", 19: \"NODE_DSTART\", 20: \"NODE_DESCR\", 21: \"NODE_DEND\", 22: \"NODE_ID\" },\n    productions_: [0, [3, 1], [3, 2], [5, 1], [5, 2], [5, 2], [4, 2], [4, 3], [10, 1], [10, 1], [10, 1], [10, 2], [10, 2], [9, 3], [9, 2], [12, 2], [12, 2], [12, 2], [12, 1], [12, 1], [12, 1], [12, 1], [12, 1], [14, 1], [14, 1], [18, 3], [17, 1], [17, 4]],\n    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {\n      var $0 = $$.length - 1;\n      switch (yystate) {\n        case 6:\n        case 7:\n          return yy;\n        case 8:\n          yy.getLogger().trace(\"Stop NL \");\n          break;\n        case 9:\n          yy.getLogger().trace(\"Stop EOF \");\n          break;\n        case 11:\n          yy.getLogger().trace(\"Stop NL2 \");\n          break;\n        case 12:\n          yy.getLogger().trace(\"Stop EOF2 \");\n          break;\n        case 15:\n          yy.getLogger().info(\"Node: \", $$[$0].id);\n          yy.addNode($$[$0 - 1].length, $$[$0].id, $$[$0].descr, $$[$0].type);\n          break;\n        case 16:\n          yy.getLogger().trace(\"Icon: \", $$[$0]);\n          yy.decorateNode({ icon: $$[$0] });\n          break;\n        case 17:\n        case 21:\n          yy.decorateNode({ class: $$[$0] });\n          break;\n        case 18:\n          yy.getLogger().trace(\"SPACELIST\");\n          break;\n        case 19:\n          yy.getLogger().trace(\"Node: \", $$[$0].id);\n          yy.addNode(0, $$[$0].id, $$[$0].descr, $$[$0].type);\n          break;\n        case 20:\n          yy.decorateNode({ icon: $$[$0] });\n          break;\n        case 25:\n          yy.getLogger().trace(\"node found ..\", $$[$0 - 2]);\n          this.$ = { id: $$[$0 - 1], descr: $$[$0 - 1], type: yy.getType($$[$0 - 2], $$[$0]) };\n          break;\n        case 26:\n          this.$ = { id: $$[$0], descr: $$[$0], type: yy.nodeType.DEFAULT };\n          break;\n        case 27:\n          yy.getLogger().trace(\"node found ..\", $$[$0 - 3]);\n          this.$ = { id: $$[$0 - 3], descr: $$[$0 - 1], type: yy.getType($$[$0 - 2], $$[$0]) };\n          break;\n      }\n    },\n    table: [{ 3: 1, 4: 2, 5: 3, 6: [1, 5], 8: $V0 }, { 1: [3] }, { 1: [2, 1] }, { 4: 6, 6: [1, 7], 7: [1, 8], 8: $V0 }, { 6: $V1, 7: [1, 10], 9: 9, 12: 11, 13: $V2, 14: 14, 15: $V3, 16: $V4, 17: 17, 18: 18, 19: $V5, 22: $V6 }, o($V7, [2, 3]), { 1: [2, 2] }, o($V7, [2, 4]), o($V7, [2, 5]), { 1: [2, 6], 6: $V1, 12: 21, 13: $V2, 14: 14, 15: $V3, 16: $V4, 17: 17, 18: 18, 19: $V5, 22: $V6 }, { 6: $V1, 9: 22, 12: 11, 13: $V2, 14: 14, 15: $V3, 16: $V4, 17: 17, 18: 18, 19: $V5, 22: $V6 }, { 6: $V8, 7: $V9, 10: 23, 11: $Va }, o($Vb, [2, 22], { 17: 17, 18: 18, 14: 27, 15: [1, 28], 16: [1, 29], 19: $V5, 22: $V6 }), o($Vb, [2, 18]), o($Vb, [2, 19]), o($Vb, [2, 20]), o($Vb, [2, 21]), o($Vb, [2, 23]), o($Vb, [2, 24]), o($Vb, [2, 26], { 19: [1, 30] }), { 20: [1, 31] }, { 6: $V8, 7: $V9, 10: 32, 11: $Va }, { 1: [2, 7], 6: $V1, 12: 21, 13: $V2, 14: 14, 15: $V3, 16: $V4, 17: 17, 18: 18, 19: $V5, 22: $V6 }, o($Vc, [2, 14], { 7: $Vd, 11: $Ve }), o($Vf, [2, 8]), o($Vf, [2, 9]), o($Vf, [2, 10]), o($Vb, [2, 15]), o($Vb, [2, 16]), o($Vb, [2, 17]), { 20: [1, 35] }, { 21: [1, 36] }, o($Vc, [2, 13], { 7: $Vd, 11: $Ve }), o($Vf, [2, 11]), o($Vf, [2, 12]), { 21: [1, 37] }, o($Vb, [2, 25]), o($Vb, [2, 27])],\n    defaultActions: { 2: [2, 1], 6: [2, 2] },\n    parseError: function parseError2(str, hash) {\n      if (hash.recoverable) {\n        this.trace(str);\n      } else {\n        var error = new Error(str);\n        error.hash = hash;\n        throw error;\n      }\n    },\n    parse: function parse(input) {\n      var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = \"\", yylineno = 0, yyleng = 0, TERROR = 2, EOF = 1;\n      var args = lstack.slice.call(arguments, 1);\n      var lexer2 = Object.create(this.lexer);\n      var sharedState = { yy: {} };\n      for (var k in this.yy) {\n        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {\n          sharedState.yy[k] = this.yy[k];\n        }\n      }\n      lexer2.setInput(input, sharedState.yy);\n      sharedState.yy.lexer = lexer2;\n      sharedState.yy.parser = this;\n      if (typeof lexer2.yylloc == \"undefined\") {\n        lexer2.yylloc = {};\n      }\n      var yyloc = lexer2.yylloc;\n      lstack.push(yyloc);\n      var ranges = lexer2.options && lexer2.options.ranges;\n      if (typeof sharedState.yy.parseError === \"function\") {\n        this.parseError = sharedState.yy.parseError;\n      } else {\n        this.parseError = Object.getPrototypeOf(this).parseError;\n      }\n      function lex() {\n        var token;\n        token = tstack.pop() || lexer2.lex() || EOF;\n        if (typeof token !== \"number\") {\n          if (token instanceof Array) {\n            tstack = token;\n            token = tstack.pop();\n          }\n          token = self.symbols_[token] || token;\n        }\n        return token;\n      }\n      var symbol, state, action, r, yyval = {}, p, len, newState, expected;\n      while (true) {\n        state = stack[stack.length - 1];\n        if (this.defaultActions[state]) {\n          action = this.defaultActions[state];\n        } else {\n          if (symbol === null || typeof symbol == \"undefined\") {\n            symbol = lex();\n          }\n          action = table[state] && table[state][symbol];\n        }\n        if (typeof action === \"undefined\" || !action.length || !action[0]) {\n          var errStr = \"\";\n          expected = [];\n          for (p in table[state]) {\n            if (this.terminals_[p] && p > TERROR) {\n              expected.push(\"'\" + this.terminals_[p] + \"'\");\n            }\n          }\n          if (lexer2.showPosition) {\n            errStr = \"Parse error on line \" + (yylineno + 1) + \":\\n\" + lexer2.showPosition() + \"\\nExpecting \" + expected.join(\", \") + \", got '\" + (this.terminals_[symbol] || symbol) + \"'\";\n          } else {\n            errStr = \"Parse error on line \" + (yylineno + 1) + \": Unexpected \" + (symbol == EOF ? \"end of input\" : \"'\" + (this.terminals_[symbol] || symbol) + \"'\");\n          }\n          this.parseError(errStr, {\n            text: lexer2.match,\n            token: this.terminals_[symbol] || symbol,\n            line: lexer2.yylineno,\n            loc: yyloc,\n            expected\n          });\n        }\n        if (action[0] instanceof Array && action.length > 1) {\n          throw new Error(\"Parse Error: multiple actions possible at state: \" + state + \", token: \" + symbol);\n        }\n        switch (action[0]) {\n          case 1:\n            stack.push(symbol);\n            vstack.push(lexer2.yytext);\n            lstack.push(lexer2.yylloc);\n            stack.push(action[1]);\n            symbol = null;\n            {\n              yyleng = lexer2.yyleng;\n              yytext = lexer2.yytext;\n              yylineno = lexer2.yylineno;\n              yyloc = lexer2.yylloc;\n            }\n            break;\n          case 2:\n            len = this.productions_[action[1]][1];\n            yyval.$ = vstack[vstack.length - len];\n            yyval._$ = {\n              first_line: lstack[lstack.length - (len || 1)].first_line,\n              last_line: lstack[lstack.length - 1].last_line,\n              first_column: lstack[lstack.length - (len || 1)].first_column,\n              last_column: lstack[lstack.length - 1].last_column\n            };\n            if (ranges) {\n              yyval._$.range = [\n                lstack[lstack.length - (len || 1)].range[0],\n                lstack[lstack.length - 1].range[1]\n              ];\n            }\n            r = this.performAction.apply(yyval, [\n              yytext,\n              yyleng,\n              yylineno,\n              sharedState.yy,\n              action[1],\n              vstack,\n              lstack\n            ].concat(args));\n            if (typeof r !== \"undefined\") {\n              return r;\n            }\n            if (len) {\n              stack = stack.slice(0, -1 * len * 2);\n              vstack = vstack.slice(0, -1 * len);\n              lstack = lstack.slice(0, -1 * len);\n            }\n            stack.push(this.productions_[action[1]][0]);\n            vstack.push(yyval.$);\n            lstack.push(yyval._$);\n            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];\n            stack.push(newState);\n            break;\n          case 3:\n            return true;\n        }\n      }\n      return true;\n    }\n  };\n  var lexer = function() {\n    var lexer2 = {\n      EOF: 1,\n      parseError: function parseError2(str, hash) {\n        if (this.yy.parser) {\n          this.yy.parser.parseError(str, hash);\n        } else {\n          throw new Error(str);\n        }\n      },\n      // resets the lexer, sets new input\n      setInput: function(input, yy) {\n        this.yy = yy || this.yy || {};\n        this._input = input;\n        this._more = this._backtrack = this.done = false;\n        this.yylineno = this.yyleng = 0;\n        this.yytext = this.matched = this.match = \"\";\n        this.conditionStack = [\"INITIAL\"];\n        this.yylloc = {\n          first_line: 1,\n          first_column: 0,\n          last_line: 1,\n          last_column: 0\n        };\n        if (this.options.ranges) {\n          this.yylloc.range = [0, 0];\n        }\n        this.offset = 0;\n        return this;\n      },\n      // consumes and returns one char from the input\n      input: function() {\n        var ch = this._input[0];\n        this.yytext += ch;\n        this.yyleng++;\n        this.offset++;\n        this.match += ch;\n        this.matched += ch;\n        var lines = ch.match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n          this.yylineno++;\n          this.yylloc.last_line++;\n        } else {\n          this.yylloc.last_column++;\n        }\n        if (this.options.ranges) {\n          this.yylloc.range[1]++;\n        }\n        this._input = this._input.slice(1);\n        return ch;\n      },\n      // unshifts one char (or a string) into the input\n      unput: function(ch) {\n        var len = ch.length;\n        var lines = ch.split(/(?:\\r\\n?|\\n)/g);\n        this._input = ch + this._input;\n        this.yytext = this.yytext.substr(0, this.yytext.length - len);\n        this.offset -= len;\n        var oldLines = this.match.split(/(?:\\r\\n?|\\n)/g);\n        this.match = this.match.substr(0, this.match.length - 1);\n        this.matched = this.matched.substr(0, this.matched.length - 1);\n        if (lines.length - 1) {\n          this.yylineno -= lines.length - 1;\n        }\n        var r = this.yylloc.range;\n        this.yylloc = {\n          first_line: this.yylloc.first_line,\n          last_line: this.yylineno + 1,\n          first_column: this.yylloc.first_column,\n          last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len\n        };\n        if (this.options.ranges) {\n          this.yylloc.range = [r[0], r[0] + this.yyleng - len];\n        }\n        this.yyleng = this.yytext.length;\n        return this;\n      },\n      // When called from action, caches matched text and appends it on next action\n      more: function() {\n        this._more = true;\n        return this;\n      },\n      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.\n      reject: function() {\n        if (this.options.backtrack_lexer) {\n          this._backtrack = true;\n        } else {\n          return this.parseError(\"Lexical error on line \" + (this.yylineno + 1) + \". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\\n\" + this.showPosition(), {\n            text: \"\",\n            token: null,\n            line: this.yylineno\n          });\n        }\n        return this;\n      },\n      // retain first n characters of the match\n      less: function(n) {\n        this.unput(this.match.slice(n));\n      },\n      // displays already matched input, i.e. for error messages\n      pastInput: function() {\n        var past = this.matched.substr(0, this.matched.length - this.match.length);\n        return (past.length > 20 ? \"...\" : \"\") + past.substr(-20).replace(/\\n/g, \"\");\n      },\n      // displays upcoming input, i.e. for error messages\n      upcomingInput: function() {\n        var next = this.match;\n        if (next.length < 20) {\n          next += this._input.substr(0, 20 - next.length);\n        }\n        return (next.substr(0, 20) + (next.length > 20 ? \"...\" : \"\")).replace(/\\n/g, \"\");\n      },\n      // displays the character position where the lexing error occurred, i.e. for error messages\n      showPosition: function() {\n        var pre = this.pastInput();\n        var c = new Array(pre.length + 1).join(\"-\");\n        return pre + this.upcomingInput() + \"\\n\" + c + \"^\";\n      },\n      // test the lexed token: return FALSE when not a match, otherwise return token\n      test_match: function(match, indexed_rule) {\n        var token, lines, backup;\n        if (this.options.backtrack_lexer) {\n          backup = {\n            yylineno: this.yylineno,\n            yylloc: {\n              first_line: this.yylloc.first_line,\n              last_line: this.last_line,\n              first_column: this.yylloc.first_column,\n              last_column: this.yylloc.last_column\n            },\n            yytext: this.yytext,\n            match: this.match,\n            matches: this.matches,\n            matched: this.matched,\n            yyleng: this.yyleng,\n            offset: this.offset,\n            _more: this._more,\n            _input: this._input,\n            yy: this.yy,\n            conditionStack: this.conditionStack.slice(0),\n            done: this.done\n          };\n          if (this.options.ranges) {\n            backup.yylloc.range = this.yylloc.range.slice(0);\n          }\n        }\n        lines = match[0].match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n          this.yylineno += lines.length;\n        }\n        this.yylloc = {\n          first_line: this.yylloc.last_line,\n          last_line: this.yylineno + 1,\n          first_column: this.yylloc.last_column,\n          last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\\r?\\n?/)[0].length : this.yylloc.last_column + match[0].length\n        };\n        this.yytext += match[0];\n        this.match += match[0];\n        this.matches = match;\n        this.yyleng = this.yytext.length;\n        if (this.options.ranges) {\n          this.yylloc.range = [this.offset, this.offset += this.yyleng];\n        }\n        this._more = false;\n        this._backtrack = false;\n        this._input = this._input.slice(match[0].length);\n        this.matched += match[0];\n        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);\n        if (this.done && this._input) {\n          this.done = false;\n        }\n        if (token) {\n          return token;\n        } else if (this._backtrack) {\n          for (var k in backup) {\n            this[k] = backup[k];\n          }\n          return false;\n        }\n        return false;\n      },\n      // return next match in input\n      next: function() {\n        if (this.done) {\n          return this.EOF;\n        }\n        if (!this._input) {\n          this.done = true;\n        }\n        var token, match, tempMatch, index;\n        if (!this._more) {\n          this.yytext = \"\";\n          this.match = \"\";\n        }\n        var rules = this._currentRules();\n        for (var i = 0; i < rules.length; i++) {\n          tempMatch = this._input.match(this.rules[rules[i]]);\n          if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\n            match = tempMatch;\n            index = i;\n            if (this.options.backtrack_lexer) {\n              token = this.test_match(tempMatch, rules[i]);\n              if (token !== false) {\n                return token;\n              } else if (this._backtrack) {\n                match = false;\n                continue;\n              } else {\n                return false;\n              }\n            } else if (!this.options.flex) {\n              break;\n            }\n          }\n        }\n        if (match) {\n          token = this.test_match(match, rules[index]);\n          if (token !== false) {\n            return token;\n          }\n          return false;\n        }\n        if (this._input === \"\") {\n          return this.EOF;\n        } else {\n          return this.parseError(\"Lexical error on line \" + (this.yylineno + 1) + \". Unrecognized text.\\n\" + this.showPosition(), {\n            text: \"\",\n            token: null,\n            line: this.yylineno\n          });\n        }\n      },\n      // return next match that has a token\n      lex: function lex() {\n        var r = this.next();\n        if (r) {\n          return r;\n        } else {\n          return this.lex();\n        }\n      },\n      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)\n      begin: function begin(condition) {\n        this.conditionStack.push(condition);\n      },\n      // pop the previously active lexer condition state off the condition stack\n      popState: function popState() {\n        var n = this.conditionStack.length - 1;\n        if (n > 0) {\n          return this.conditionStack.pop();\n        } else {\n          return this.conditionStack[0];\n        }\n      },\n      // produce the lexer rule set which is active for the currently active lexer condition state\n      _currentRules: function _currentRules() {\n        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {\n          return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;\n        } else {\n          return this.conditions[\"INITIAL\"].rules;\n        }\n      },\n      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available\n      topState: function topState(n) {\n        n = this.conditionStack.length - 1 - Math.abs(n || 0);\n        if (n >= 0) {\n          return this.conditionStack[n];\n        } else {\n          return \"INITIAL\";\n        }\n      },\n      // alias for begin(condition)\n      pushState: function pushState(condition) {\n        this.begin(condition);\n      },\n      // return the number of states currently on the stack\n      stateStackSize: function stateStackSize() {\n        return this.conditionStack.length;\n      },\n      options: { \"case-insensitive\": true },\n      performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {\n        switch ($avoiding_name_collisions) {\n          case 0:\n            yy.getLogger().trace(\"Found comment\", yy_.yytext);\n            return 6;\n          case 1:\n            return 8;\n          case 2:\n            this.begin(\"CLASS\");\n            break;\n          case 3:\n            this.popState();\n            return 16;\n          case 4:\n            this.popState();\n            break;\n          case 5:\n            yy.getLogger().trace(\"Begin icon\");\n            this.begin(\"ICON\");\n            break;\n          case 6:\n            yy.getLogger().trace(\"SPACELINE\");\n            return 6;\n          case 7:\n            return 7;\n          case 8:\n            return 15;\n          case 9:\n            yy.getLogger().trace(\"end icon\");\n            this.popState();\n            break;\n          case 10:\n            yy.getLogger().trace(\"Exploding node\");\n            this.begin(\"NODE\");\n            return 19;\n          case 11:\n            yy.getLogger().trace(\"Cloud\");\n            this.begin(\"NODE\");\n            return 19;\n          case 12:\n            yy.getLogger().trace(\"Explosion Bang\");\n            this.begin(\"NODE\");\n            return 19;\n          case 13:\n            yy.getLogger().trace(\"Cloud Bang\");\n            this.begin(\"NODE\");\n            return 19;\n          case 14:\n            this.begin(\"NODE\");\n            return 19;\n          case 15:\n            this.begin(\"NODE\");\n            return 19;\n          case 16:\n            this.begin(\"NODE\");\n            return 19;\n          case 17:\n            this.begin(\"NODE\");\n            return 19;\n          case 18:\n            return 13;\n          case 19:\n            return 22;\n          case 20:\n            return 11;\n          case 21:\n            this.begin(\"NSTR2\");\n            break;\n          case 22:\n            return \"NODE_DESCR\";\n          case 23:\n            this.popState();\n            break;\n          case 24:\n            yy.getLogger().trace(\"Starting NSTR\");\n            this.begin(\"NSTR\");\n            break;\n          case 25:\n            yy.getLogger().trace(\"description:\", yy_.yytext);\n            return \"NODE_DESCR\";\n          case 26:\n            this.popState();\n            break;\n          case 27:\n            this.popState();\n            yy.getLogger().trace(\"node end ))\");\n            return \"NODE_DEND\";\n          case 28:\n            this.popState();\n            yy.getLogger().trace(\"node end )\");\n            return \"NODE_DEND\";\n          case 29:\n            this.popState();\n            yy.getLogger().trace(\"node end ...\", yy_.yytext);\n            return \"NODE_DEND\";\n          case 30:\n            this.popState();\n            yy.getLogger().trace(\"node end ((\");\n            return \"NODE_DEND\";\n          case 31:\n            this.popState();\n            yy.getLogger().trace(\"node end (-\");\n            return \"NODE_DEND\";\n          case 32:\n            this.popState();\n            yy.getLogger().trace(\"node end (-\");\n            return \"NODE_DEND\";\n          case 33:\n            this.popState();\n            yy.getLogger().trace(\"node end ((\");\n            return \"NODE_DEND\";\n          case 34:\n            this.popState();\n            yy.getLogger().trace(\"node end ((\");\n            return \"NODE_DEND\";\n          case 35:\n            yy.getLogger().trace(\"Long description:\", yy_.yytext);\n            return 20;\n          case 36:\n            yy.getLogger().trace(\"Long description:\", yy_.yytext);\n            return 20;\n        }\n      },\n      rules: [/^(?:\\s*%%.*)/i, /^(?:mindmap\\b)/i, /^(?::::)/i, /^(?:.+)/i, /^(?:\\n)/i, /^(?:::icon\\()/i, /^(?:[\\s]+[\\n])/i, /^(?:[\\n]+)/i, /^(?:[^\\)]+)/i, /^(?:\\))/i, /^(?:-\\))/i, /^(?:\\(-)/i, /^(?:\\)\\))/i, /^(?:\\))/i, /^(?:\\(\\()/i, /^(?:\\{\\{)/i, /^(?:\\()/i, /^(?:\\[)/i, /^(?:[\\s]+)/i, /^(?:[^\\(\\[\\n\\)\\{\\}]+)/i, /^(?:$)/i, /^(?:[\"][`])/i, /^(?:[^`\"]+)/i, /^(?:[`][\"])/i, /^(?:[\"])/i, /^(?:[^\"]+)/i, /^(?:[\"])/i, /^(?:[\\)]\\))/i, /^(?:[\\)])/i, /^(?:[\\]])/i, /^(?:\\}\\})/i, /^(?:\\(-)/i, /^(?:-\\))/i, /^(?:\\(\\()/i, /^(?:\\()/i, /^(?:[^\\)\\]\\(\\}]+)/i, /^(?:.+(?!\\(\\())/i],\n      conditions: { \"CLASS\": { \"rules\": [3, 4], \"inclusive\": false }, \"ICON\": { \"rules\": [8, 9], \"inclusive\": false }, \"NSTR2\": { \"rules\": [22, 23], \"inclusive\": false }, \"NSTR\": { \"rules\": [25, 26], \"inclusive\": false }, \"NODE\": { \"rules\": [21, 24, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36], \"inclusive\": false }, \"INITIAL\": { \"rules\": [0, 1, 2, 5, 6, 7, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20], \"inclusive\": true } }\n    };\n    return lexer2;\n  }();\n  parser2.lexer = lexer;\n  function Parser() {\n    this.yy = {};\n  }\n  Parser.prototype = parser2;\n  parser2.Parser = Parser;\n  return new Parser();\n}();\nparser.parser = parser;\nconst mindmapParser = parser;\nconst sanitizeText = (text) => (0,_mermaid_934d9bea_js__WEBPACK_IMPORTED_MODULE_7__.d)(text, (0,_mermaid_934d9bea_js__WEBPACK_IMPORTED_MODULE_7__.c)());\nlet nodes = [];\nlet cnt = 0;\nlet elements = {};\nconst clear = () => {\n  nodes = [];\n  cnt = 0;\n  elements = {};\n};\nconst getParent = function(level) {\n  for (let i = nodes.length - 1; i >= 0; i--) {\n    if (nodes[i].level < level) {\n      return nodes[i];\n    }\n  }\n  return null;\n};\nconst getMindmap = () => {\n  return nodes.length > 0 ? nodes[0] : null;\n};\nconst addNode = (level, id, descr, type) => {\n  _mermaid_934d9bea_js__WEBPACK_IMPORTED_MODULE_7__.l.info(\"addNode\", level, id, descr, type);\n  const conf = (0,_mermaid_934d9bea_js__WEBPACK_IMPORTED_MODULE_7__.c)();\n  const node = {\n    id: cnt++,\n    nodeId: sanitizeText(id),\n    level,\n    descr: sanitizeText(descr),\n    type,\n    children: [],\n    width: (0,_mermaid_934d9bea_js__WEBPACK_IMPORTED_MODULE_7__.c)().mindmap.maxNodeWidth\n  };\n  switch (node.type) {\n    case nodeType.ROUNDED_RECT:\n      node.padding = 2 * conf.mindmap.padding;\n      break;\n    case nodeType.RECT:\n      node.padding = 2 * conf.mindmap.padding;\n      break;\n    case nodeType.HEXAGON:\n      node.padding = 2 * conf.mindmap.padding;\n      break;\n    default:\n      node.padding = conf.mindmap.padding;\n  }\n  const parent = getParent(level);\n  if (parent) {\n    parent.children.push(node);\n    nodes.push(node);\n  } else {\n    if (nodes.length === 0) {\n      nodes.push(node);\n    } else {\n      let error = new Error(\n        'There can be only one root. No parent could be found for (\"' + node.descr + '\")'\n      );\n      error.hash = {\n        text: \"branch \" + name,\n        token: \"branch \" + name,\n        line: \"1\",\n        loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },\n        expected: ['\"checkout ' + name + '\"']\n      };\n      throw error;\n    }\n  }\n};\nconst nodeType = {\n  DEFAULT: 0,\n  NO_BORDER: 0,\n  ROUNDED_RECT: 1,\n  RECT: 2,\n  CIRCLE: 3,\n  CLOUD: 4,\n  BANG: 5,\n  HEXAGON: 6\n};\nconst getType = (startStr, endStr) => {\n  _mermaid_934d9bea_js__WEBPACK_IMPORTED_MODULE_7__.l.debug(\"In get type\", startStr, endStr);\n  switch (startStr) {\n    case \"[\":\n      return nodeType.RECT;\n    case \"(\":\n      return endStr === \")\" ? nodeType.ROUNDED_RECT : nodeType.CLOUD;\n    case \"((\":\n      return nodeType.CIRCLE;\n    case \")\":\n      return nodeType.CLOUD;\n    case \"))\":\n      return nodeType.BANG;\n    case \"{{\":\n      return nodeType.HEXAGON;\n    default:\n      return nodeType.DEFAULT;\n  }\n};\nconst setElementForId = (id, element) => {\n  elements[id] = element;\n};\nconst decorateNode = (decoration) => {\n  const node = nodes[nodes.length - 1];\n  if (decoration && decoration.icon) {\n    node.icon = sanitizeText(decoration.icon);\n  }\n  if (decoration && decoration.class) {\n    node.class = sanitizeText(decoration.class);\n  }\n};\nconst type2Str = (type) => {\n  switch (type) {\n    case nodeType.DEFAULT:\n      return \"no-border\";\n    case nodeType.RECT:\n      return \"rect\";\n    case nodeType.ROUNDED_RECT:\n      return \"rounded-rect\";\n    case nodeType.CIRCLE:\n      return \"circle\";\n    case nodeType.CLOUD:\n      return \"cloud\";\n    case nodeType.BANG:\n      return \"bang\";\n    case nodeType.HEXAGON:\n      return \"hexgon\";\n    default:\n      return \"no-border\";\n  }\n};\nlet parseError;\nconst setErrorHandler = (handler) => {\n  parseError = handler;\n};\nconst getLogger = () => _mermaid_934d9bea_js__WEBPACK_IMPORTED_MODULE_7__.l;\nconst getNodeById = (id) => nodes[id];\nconst getElementById = (id) => elements[id];\nconst mindmapDb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  addNode,\n  clear,\n  decorateNode,\n  getElementById,\n  getLogger,\n  getMindmap,\n  getNodeById,\n  getType,\n  nodeType,\n  get parseError() {\n    return parseError;\n  },\n  sanitizeText,\n  setElementForId,\n  setErrorHandler,\n  type2Str\n}, Symbol.toStringTag, { value: \"Module\" }));\nconst MAX_SECTIONS = 12;\nconst defaultBkg = function(elem, node, section) {\n  const rd = 5;\n  elem.append(\"path\").attr(\"id\", \"node-\" + node.id).attr(\"class\", \"node-bkg node-\" + type2Str(node.type)).attr(\n    \"d\",\n    `M0 ${node.height - rd} v${-node.height + 2 * rd} q0,-5 5,-5 h${node.width - 2 * rd} q5,0 5,5 v${node.height - rd} H0 Z`\n  );\n  elem.append(\"line\").attr(\"class\", \"node-line-\" + section).attr(\"x1\", 0).attr(\"y1\", node.height).attr(\"x2\", node.width).attr(\"y2\", node.height);\n};\nconst rectBkg = function(elem, node) {\n  elem.append(\"rect\").attr(\"id\", \"node-\" + node.id).attr(\"class\", \"node-bkg node-\" + type2Str(node.type)).attr(\"height\", node.height).attr(\"width\", node.width);\n};\nconst cloudBkg = function(elem, node) {\n  const w = node.width;\n  const h = node.height;\n  const r1 = 0.15 * w;\n  const r2 = 0.25 * w;\n  const r3 = 0.35 * w;\n  const r4 = 0.2 * w;\n  elem.append(\"path\").attr(\"id\", \"node-\" + node.id).attr(\"class\", \"node-bkg node-\" + type2Str(node.type)).attr(\n    \"d\",\n    `M0 0 a${r1},${r1} 0 0,1 ${w * 0.25},${-1 * w * 0.1}\n      a${r3},${r3} 1 0,1 ${w * 0.4},${-1 * w * 0.1}\n      a${r2},${r2} 1 0,1 ${w * 0.35},${1 * w * 0.2}\n\n      a${r1},${r1} 1 0,1 ${w * 0.15},${1 * h * 0.35}\n      a${r4},${r4} 1 0,1 ${-1 * w * 0.15},${1 * h * 0.65}\n\n      a${r2},${r1} 1 0,1 ${-1 * w * 0.25},${w * 0.15}\n      a${r3},${r3} 1 0,1 ${-1 * w * 0.5},${0}\n      a${r1},${r1} 1 0,1 ${-1 * w * 0.25},${-1 * w * 0.15}\n\n      a${r1},${r1} 1 0,1 ${-1 * w * 0.1},${-1 * h * 0.35}\n      a${r4},${r4} 1 0,1 ${w * 0.1},${-1 * h * 0.65}\n\n    H0 V0 Z`\n  );\n};\nconst bangBkg = function(elem, node) {\n  const w = node.width;\n  const h = node.height;\n  const r = 0.15 * w;\n  elem.append(\"path\").attr(\"id\", \"node-\" + node.id).attr(\"class\", \"node-bkg node-\" + type2Str(node.type)).attr(\n    \"d\",\n    `M0 0 a${r},${r} 1 0,0 ${w * 0.25},${-1 * h * 0.1}\n      a${r},${r} 1 0,0 ${w * 0.25},${0}\n      a${r},${r} 1 0,0 ${w * 0.25},${0}\n      a${r},${r} 1 0,0 ${w * 0.25},${1 * h * 0.1}\n\n      a${r},${r} 1 0,0 ${w * 0.15},${1 * h * 0.33}\n      a${r * 0.8},${r * 0.8} 1 0,0 ${0},${1 * h * 0.34}\n      a${r},${r} 1 0,0 ${-1 * w * 0.15},${1 * h * 0.33}\n\n      a${r},${r} 1 0,0 ${-1 * w * 0.25},${h * 0.15}\n      a${r},${r} 1 0,0 ${-1 * w * 0.25},${0}\n      a${r},${r} 1 0,0 ${-1 * w * 0.25},${0}\n      a${r},${r} 1 0,0 ${-1 * w * 0.25},${-1 * h * 0.15}\n\n      a${r},${r} 1 0,0 ${-1 * w * 0.1},${-1 * h * 0.33}\n      a${r * 0.8},${r * 0.8} 1 0,0 ${0},${-1 * h * 0.34}\n      a${r},${r} 1 0,0 ${w * 0.1},${-1 * h * 0.33}\n\n    H0 V0 Z`\n  );\n};\nconst circleBkg = function(elem, node) {\n  elem.append(\"circle\").attr(\"id\", \"node-\" + node.id).attr(\"class\", \"node-bkg node-\" + type2Str(node.type)).attr(\"r\", node.width / 2);\n};\nfunction insertPolygonShape(parent, w, h, points, node) {\n  return parent.insert(\"polygon\", \":first-child\").attr(\n    \"points\",\n    points.map(function(d) {\n      return d.x + \",\" + d.y;\n    }).join(\" \")\n  ).attr(\"transform\", \"translate(\" + (node.width - w) / 2 + \", \" + h + \")\");\n}\nconst hexagonBkg = function(elem, node) {\n  const h = node.height;\n  const f = 4;\n  const m = h / f;\n  const w = node.width - node.padding + 2 * m;\n  const points = [\n    { x: m, y: 0 },\n    { x: w - m, y: 0 },\n    { x: w, y: -h / 2 },\n    { x: w - m, y: -h },\n    { x: m, y: -h },\n    { x: 0, y: -h / 2 }\n  ];\n  insertPolygonShape(elem, w, h, points, node);\n};\nconst roundedRectBkg = function(elem, node) {\n  elem.append(\"rect\").attr(\"id\", \"node-\" + node.id).attr(\"class\", \"node-bkg node-\" + type2Str(node.type)).attr(\"height\", node.height).attr(\"rx\", node.padding).attr(\"ry\", node.padding).attr(\"width\", node.width);\n};\nconst drawNode = function(elem, node, fullSection, conf) {\n  const htmlLabels = conf.htmlLabels;\n  const section = fullSection % (MAX_SECTIONS - 1);\n  const nodeElem = elem.append(\"g\");\n  node.section = section;\n  let sectionClass = \"section-\" + section;\n  if (section < 0) {\n    sectionClass += \" section-root\";\n  }\n  nodeElem.attr(\"class\", (node.class ? node.class + \" \" : \"\") + \"mindmap-node \" + sectionClass);\n  const bkgElem = nodeElem.append(\"g\");\n  const textElem = nodeElem.append(\"g\");\n  const description = node.descr.replace(/(<br\\/*>)/g, \"\\n\");\n  (0,_createText_aebacdfe_js__WEBPACK_IMPORTED_MODULE_8__.a)(textElem, description, {\n    useHtmlLabels: htmlLabels,\n    width: node.width,\n    classes: \"mindmap-node-label\"\n  });\n  if (!htmlLabels) {\n    textElem.attr(\"dy\", \"1em\").attr(\"alignment-baseline\", \"middle\").attr(\"dominant-baseline\", \"middle\").attr(\"text-anchor\", \"middle\");\n  }\n  const bbox = textElem.node().getBBox();\n  const fontSize = conf.fontSize.replace ? conf.fontSize.replace(\"px\", \"\") : conf.fontSize;\n  node.height = bbox.height + fontSize * 1.1 * 0.5 + node.padding;\n  node.width = bbox.width + 2 * node.padding;\n  if (node.icon) {\n    if (node.type === nodeType.CIRCLE) {\n      node.height += 50;\n      node.width += 50;\n      const icon = nodeElem.append(\"foreignObject\").attr(\"height\", \"50px\").attr(\"width\", node.width).attr(\"style\", \"text-align: center;\");\n      icon.append(\"div\").attr(\"class\", \"icon-container\").append(\"i\").attr(\"class\", \"node-icon-\" + section + \" \" + node.icon);\n      textElem.attr(\n        \"transform\",\n        \"translate(\" + node.width / 2 + \", \" + (node.height / 2 - 1.5 * node.padding) + \")\"\n      );\n    } else {\n      node.width += 50;\n      const orgHeight = node.height;\n      node.height = Math.max(orgHeight, 60);\n      const heightDiff = Math.abs(node.height - orgHeight);\n      const icon = nodeElem.append(\"foreignObject\").attr(\"width\", \"60px\").attr(\"height\", node.height).attr(\"style\", \"text-align: center;margin-top:\" + heightDiff / 2 + \"px;\");\n      icon.append(\"div\").attr(\"class\", \"icon-container\").append(\"i\").attr(\"class\", \"node-icon-\" + section + \" \" + node.icon);\n      textElem.attr(\n        \"transform\",\n        \"translate(\" + (25 + node.width / 2) + \", \" + (heightDiff / 2 + node.padding / 2) + \")\"\n      );\n    }\n  } else {\n    if (!htmlLabels) {\n      const dx = node.width / 2;\n      const dy = node.padding / 2;\n      textElem.attr(\"transform\", \"translate(\" + dx + \", \" + dy + \")\");\n    } else {\n      const dx = (node.width - bbox.width) / 2;\n      const dy = (node.height - bbox.height) / 2;\n      textElem.attr(\"transform\", \"translate(\" + dx + \", \" + dy + \")\");\n    }\n  }\n  switch (node.type) {\n    case nodeType.DEFAULT:\n      defaultBkg(bkgElem, node, section);\n      break;\n    case nodeType.ROUNDED_RECT:\n      roundedRectBkg(bkgElem, node);\n      break;\n    case nodeType.RECT:\n      rectBkg(bkgElem, node);\n      break;\n    case nodeType.CIRCLE:\n      bkgElem.attr(\"transform\", \"translate(\" + node.width / 2 + \", \" + +node.height / 2 + \")\");\n      circleBkg(bkgElem, node);\n      break;\n    case nodeType.CLOUD:\n      cloudBkg(bkgElem, node);\n      break;\n    case nodeType.BANG:\n      bangBkg(bkgElem, node);\n      break;\n    case nodeType.HEXAGON:\n      hexagonBkg(bkgElem, node);\n      break;\n  }\n  setElementForId(node.id, nodeElem);\n  return node.height;\n};\nconst drawEdge = function drawEdge2(edgesElem, mindmap, parent, depth, fullSection) {\n  const section = fullSection % (MAX_SECTIONS - 1);\n  const sx = parent.x + parent.width / 2;\n  const sy = parent.y + parent.height / 2;\n  const ex = mindmap.x + mindmap.width / 2;\n  const ey = mindmap.y + mindmap.height / 2;\n  const mx = ex > sx ? sx + Math.abs(sx - ex) / 2 : sx - Math.abs(sx - ex) / 2;\n  const my = ey > sy ? sy + Math.abs(sy - ey) / 2 : sy - Math.abs(sy - ey) / 2;\n  const qx = ex > sx ? Math.abs(sx - mx) / 2 + sx : -Math.abs(sx - mx) / 2 + sx;\n  const qy = ey > sy ? Math.abs(sy - my) / 2 + sy : -Math.abs(sy - my) / 2 + sy;\n  edgesElem.append(\"path\").attr(\n    \"d\",\n    parent.direction === \"TB\" || parent.direction === \"BT\" ? `M${sx},${sy} Q${sx},${qy} ${mx},${my} T${ex},${ey}` : `M${sx},${sy} Q${qx},${sy} ${mx},${my} T${ex},${ey}`\n  ).attr(\"class\", \"edge section-edge-\" + section + \" edge-depth-\" + depth);\n};\nconst positionNode = function(node) {\n  const nodeElem = getElementById(node.id);\n  const x = node.x || 0;\n  const y = node.y || 0;\n  nodeElem.attr(\"transform\", \"translate(\" + x + \",\" + y + \")\");\n};\nconst svgDraw = { drawNode, positionNode, drawEdge };\ncytoscape_dist_cytoscape_umd_js__WEBPACK_IMPORTED_MODULE_1__.use(cytoscape_cose_bilkent__WEBPACK_IMPORTED_MODULE_2__);\nfunction drawNodes(svg, mindmap, section, conf) {\n  svgDraw.drawNode(svg, mindmap, section, conf);\n  if (mindmap.children) {\n    mindmap.children.forEach((child, index) => {\n      drawNodes(svg, child, section < 0 ? index : section, conf);\n    });\n  }\n}\nfunction drawEdges(edgesEl, cy) {\n  cy.edges().map((edge, id) => {\n    const data = edge.data();\n    if (edge[0]._private.bodyBounds) {\n      const bounds = edge[0]._private.rscratch;\n      _mermaid_934d9bea_js__WEBPACK_IMPORTED_MODULE_7__.l.trace(\"Edge: \", id, data);\n      edgesEl.insert(\"path\").attr(\n        \"d\",\n        `M ${bounds.startX},${bounds.startY} L ${bounds.midX},${bounds.midY} L${bounds.endX},${bounds.endY} `\n      ).attr(\"class\", \"edge section-edge-\" + data.section + \" edge-depth-\" + data.depth);\n    }\n  });\n}\nfunction addNodes(mindmap, cy, conf, level) {\n  cy.add({\n    group: \"nodes\",\n    data: {\n      id: mindmap.id,\n      labelText: mindmap.descr,\n      height: mindmap.height,\n      width: mindmap.width,\n      level,\n      nodeId: mindmap.id,\n      padding: mindmap.padding,\n      type: mindmap.type\n    },\n    position: {\n      x: mindmap.x,\n      y: mindmap.y\n    }\n  });\n  if (mindmap.children) {\n    mindmap.children.forEach((child) => {\n      addNodes(child, cy, conf, level + 1);\n      cy.add({\n        group: \"edges\",\n        data: {\n          id: `${mindmap.id}_${child.id}`,\n          source: mindmap.id,\n          target: child.id,\n          depth: level,\n          section: child.section\n        }\n      });\n    });\n  }\n}\nfunction layoutMindmap(node, conf) {\n  return new Promise((resolve) => {\n    const renderEl = (0,d3__WEBPACK_IMPORTED_MODULE_0__.select)(\"body\").append(\"div\").attr(\"id\", \"cy\").attr(\"style\", \"display:none\");\n    const cy = cytoscape_dist_cytoscape_umd_js__WEBPACK_IMPORTED_MODULE_1__({\n      container: document.getElementById(\"cy\"),\n      // container to render in\n      style: [\n        {\n          selector: \"edge\",\n          style: {\n            \"curve-style\": \"bezier\"\n          }\n        }\n      ]\n    });\n    renderEl.remove();\n    addNodes(node, cy, conf, 0);\n    cy.nodes().forEach(function(n) {\n      n.layoutDimensions = () => {\n        const data = n.data();\n        return { w: data.width, h: data.height };\n      };\n    });\n    cy.layout({\n      name: \"cose-bilkent\",\n      quality: \"proof\",\n      // headless: true,\n      styleEnabled: false,\n      animate: false\n    }).run();\n    cy.ready((e) => {\n      _mermaid_934d9bea_js__WEBPACK_IMPORTED_MODULE_7__.l.info(\"Ready\", e);\n      resolve(cy);\n    });\n  });\n}\nfunction positionNodes(cy) {\n  cy.nodes().map((node, id) => {\n    const data = node.data();\n    data.x = node.position().x;\n    data.y = node.position().y;\n    svgDraw.positionNode(data);\n    const el = getElementById(data.nodeId);\n    _mermaid_934d9bea_js__WEBPACK_IMPORTED_MODULE_7__.l.info(\"Id:\", id, \"Position: (\", node.position().x, \", \", node.position().y, \")\", data);\n    el.attr(\n      \"transform\",\n      `translate(${node.position().x - data.width / 2}, ${node.position().y - data.height / 2})`\n    );\n    el.attr(\"attr\", `apa-${id})`);\n  });\n}\nconst draw = async (text, id, version, diagObj) => {\n  const conf = (0,_mermaid_934d9bea_js__WEBPACK_IMPORTED_MODULE_7__.c)();\n  conf.htmlLabels = false;\n  _mermaid_934d9bea_js__WEBPACK_IMPORTED_MODULE_7__.l.debug(\"Rendering mindmap diagram\\n\" + text, diagObj.parser);\n  const securityLevel = (0,_mermaid_934d9bea_js__WEBPACK_IMPORTED_MODULE_7__.c)().securityLevel;\n  let sandboxElement;\n  if (securityLevel === \"sandbox\") {\n    sandboxElement = (0,d3__WEBPACK_IMPORTED_MODULE_0__.select)(\"#i\" + id);\n  }\n  const root = securityLevel === \"sandbox\" ? (0,d3__WEBPACK_IMPORTED_MODULE_0__.select)(sandboxElement.nodes()[0].contentDocument.body) : (0,d3__WEBPACK_IMPORTED_MODULE_0__.select)(\"body\");\n  const svg = root.select(\"#\" + id);\n  svg.append(\"g\");\n  const mm = diagObj.db.getMindmap();\n  const edgesElem = svg.append(\"g\");\n  edgesElem.attr(\"class\", \"mindmap-edges\");\n  const nodesElem = svg.append(\"g\");\n  nodesElem.attr(\"class\", \"mindmap-nodes\");\n  drawNodes(nodesElem, mm, -1, conf);\n  const cy = await layoutMindmap(mm, conf);\n  drawEdges(edgesElem, cy);\n  positionNodes(cy);\n  (0,_mermaid_934d9bea_js__WEBPACK_IMPORTED_MODULE_7__.o)(void 0, svg, conf.mindmap.padding, conf.mindmap.useMaxWidth);\n};\nconst mindmapRenderer = {\n  draw\n};\nconst genSections = (options) => {\n  let sections = \"\";\n  for (let i = 0; i < options.THEME_COLOR_LIMIT; i++) {\n    options[\"lineColor\" + i] = options[\"lineColor\" + i] || options[\"cScaleInv\" + i];\n    if ((0,khroma__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(options[\"lineColor\" + i])) {\n      options[\"lineColor\" + i] = (0,khroma__WEBPACK_IMPORTED_MODULE_10__[\"default\"])(options[\"lineColor\" + i], 20);\n    } else {\n      options[\"lineColor\" + i] = (0,khroma__WEBPACK_IMPORTED_MODULE_11__[\"default\"])(options[\"lineColor\" + i], 20);\n    }\n  }\n  for (let i = 0; i < options.THEME_COLOR_LIMIT; i++) {\n    const sw = \"\" + (17 - 3 * i);\n    sections += `\n    .section-${i - 1} rect, .section-${i - 1} path, .section-${i - 1} circle, .section-${i - 1} polygon, .section-${i - 1} path  {\n      fill: ${options[\"cScale\" + i]};\n    }\n    .section-${i - 1} text {\n     fill: ${options[\"cScaleLabel\" + i]};\n    }\n    .node-icon-${i - 1} {\n      font-size: 40px;\n      color: ${options[\"cScaleLabel\" + i]};\n    }\n    .section-edge-${i - 1}{\n      stroke: ${options[\"cScale\" + i]};\n    }\n    .edge-depth-${i - 1}{\n      stroke-width: ${sw};\n    }\n    .section-${i - 1} line {\n      stroke: ${options[\"cScaleInv\" + i]} ;\n      stroke-width: 3;\n    }\n\n    .disabled, .disabled circle, .disabled text {\n      fill: lightgray;\n    }\n    .disabled text {\n      fill: #efefef;\n    }\n    `;\n  }\n  return sections;\n};\nconst getStyles = (options) => `\n  .edge {\n    stroke-width: 3;\n  }\n  ${genSections(options)}\n  .section-root rect, .section-root path, .section-root circle, .section-root polygon  {\n    fill: ${options.git0};\n  }\n  .section-root text {\n    fill: ${options.gitBranchLabel0};\n  }\n  .icon-container {\n    height:100%;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n  }\n  .edge {\n    fill: none;\n  }\n  .mindmap-node-label {\n    dy: 1em;\n    alignment-baseline: middle;\n    text-anchor: middle;\n    dominant-baseline: middle;\n    text-align: center;\n  }\n`;\nconst mindmapStyles = getStyles;\nconst diagram = {\n  db: mindmapDb,\n  renderer: mindmapRenderer,\n  parser: mindmapParser,\n  styles: mindmapStyles\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL21lcm1haWQvZGlzdC9taW5kbWFwLWRlZmluaXRpb24tNjE3Y2Y4ZGQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUE4RztBQUNsRjtBQUMrQjtBQUNIO0FBQ1A7QUFDQTtBQUM5QjtBQUNKO0FBQ2tCO0FBQ2Q7QUFDVztBQUNGO0FBQ1o7QUFDYztBQUNJO0FBQ2xDO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCLEtBQUs7QUFDM0M7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMLFVBQVU7QUFDVixnQkFBZ0IsZ1ZBQWdWO0FBQ2hXLGtCQUFrQiw2S0FBNks7QUFDL0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsY0FBYztBQUMxQztBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZUFBZTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsY0FBYztBQUMxQztBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLEtBQUs7QUFDTCxjQUFjLHFDQUFxQyxJQUFJLFFBQVEsSUFBSSxXQUFXLElBQUksb0NBQW9DLElBQUksdUdBQXVHLG9CQUFvQixXQUFXLG9DQUFvQyxnR0FBZ0csSUFBSSw0RkFBNEYsSUFBSSxpQ0FBaUMsb0JBQW9CLG9FQUFvRSwySEFBMkgsYUFBYSxLQUFLLGFBQWEsSUFBSSxpQ0FBaUMsSUFBSSxnR0FBZ0csb0JBQW9CLGlCQUFpQix5R0FBeUcsYUFBYSxJQUFJLGFBQWEsb0JBQW9CLGlCQUFpQix1Q0FBdUMsYUFBYTtBQUN6b0Msc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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LElBQUksUUFBUSxjQUFjLEdBQUc7QUFDNUMsU0FBUyxHQUFHLEdBQUcsSUFBSSxRQUFRLGFBQWEsR0FBRztBQUMzQyxTQUFTLEdBQUcsR0FBRyxJQUFJLFFBQVEsY0FBYyxHQUFHOztBQUU1QyxTQUFTLEdBQUcsR0FBRyxJQUFJLFFBQVEsYUFBYSxHQUFHO0FBQzNDLFNBQVMsR0FBRyxHQUFHLElBQUksUUFBUSxRQUFRLEdBQUc7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsRUFBRSxHQUFHLEdBQUcsUUFBUSxTQUFTLEdBQUc7QUFDekMsU0FBUyxFQUFFLEdBQUcsR0FBRyxRQUFRLFNBQVMsR0FBRztBQUNyQyxTQUFTLEVBQUUsR0FBRyxHQUFHLFFBQVEsU0FBUyxHQUFHO0FBQ3JDLFNBQVMsRUFBRSxHQUFHLEdBQUcsUUFBUSxTQUFTLEdBQUc7O0FBRXJDLFNBQVMsRUFBRSxHQUFHLEdBQUcsUUFBUSxTQUFTLEdBQUc7QUFDckMsU0FBUyxRQUFRLEdBQUcsU0FBUyxRQUFRLEVBQUUsR0FBRztBQUMxQyxTQUFTLEVBQUUsR0FBRyxHQUFHLFFBQVEsY0FBYyxHQUFHOztBQUUxQyxTQUFTLEVBQUUsR0FBRyxHQUFHLFFBQVEsY0FBYyxHQUFHO0FBQzFDLFNBQVMsRUFBRSxHQUFHLEdBQUcsUUFBUSxjQUFjLEdBQUc7QUFDMUMsU0FBUyxFQUFFLEdBQUcsR0FBRyxRQUFRLGNBQWMsR0FBRztBQUMxQyxTQUFTLEVBQUUsR0FBRyxHQUFHLFFBQVEsY0FBYyxHQUFHOztBQUUxQyxTQUFTLEVBQUUsR0FBRyxHQUFHLFFBQVEsYUFBYSxHQUFHO0FBQ3pDLFNBQVMsUUFBUSxHQUFHLFNBQVMsUUFBUSxFQUFFLEdBQUc7QUFDMUMsU0FBUyxFQUFFLEdBQUcsR0FBRyxRQUFRLFFBQVEsR0FBRzs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNB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QjtBQUNBLDZDQUE2QywwQ0FBTSxtREFBbUQsMENBQU07QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsdURBQWlCO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwrQkFBK0I7QUFDakQ7QUFDQSxRQUFRLGtEQUFNO0FBQ2QsaUNBQWlDLG1EQUFPO0FBQ3hDLE1BQU07QUFDTixpQ0FBaUMsbURBQU07QUFDdkM7QUFDQTtBQUNBLGtCQUFrQiwrQkFBK0I7QUFDakQ7QUFDQTtBQUNBLGVBQWUsT0FBTyxpQkFBaUIsT0FBTyxpQkFBaUIsT0FBTyxtQkFBbUIsT0FBTyxvQkFBb0IsT0FBTztBQUMzSCxjQUFjO0FBQ2Q7QUFDQSxlQUFlLE9BQU87QUFDdEIsYUFBYTtBQUNiO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsZUFBZTtBQUNmO0FBQ0Esb0JBQW9CO0FBQ3BCLGdCQUFnQjtBQUNoQjtBQUNBLGtCQUFrQjtBQUNsQixzQkFBc0I7QUFDdEI7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL21lcm1haWQvZGlzdC9taW5kbWFwLWRlZmluaXRpb24tNjE3Y2Y4ZGQuanM/MmE5NiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkIGFzIHNhbml0aXplVGV4dCQxLCBjIGFzIGdldENvbmZpZywgbCBhcyBsb2csIG8gYXMgc2V0dXBHcmFwaFZpZXdib3ggfSBmcm9tIFwiLi9tZXJtYWlkLTkzNGQ5YmVhLmpzXCI7XG5pbXBvcnQgeyBzZWxlY3QgfSBmcm9tIFwiZDNcIjtcbmltcG9ydCB7IGEgYXMgY3JlYXRlVGV4dCB9IGZyb20gXCIuL2NyZWF0ZVRleHQtYWViYWNkZmUuanNcIjtcbmltcG9ydCBjeXRvc2NhcGUgZnJvbSBcImN5dG9zY2FwZS9kaXN0L2N5dG9zY2FwZS51bWQuanNcIjtcbmltcG9ydCBjb3NlQmlsa2VudCBmcm9tIFwiY3l0b3NjYXBlLWNvc2UtYmlsa2VudFwiO1xuaW1wb3J0IHsgaXNEYXJrLCBsaWdodGVuLCBkYXJrZW4gfSBmcm9tIFwia2hyb21hXCI7XG5pbXBvcnQgXCJ0cy1kZWRlbnRcIjtcbmltcG9ydCBcImRheWpzXCI7XG5pbXBvcnQgXCJAYnJhaW50cmVlL3Nhbml0aXplLXVybFwiO1xuaW1wb3J0IFwiZG9tcHVyaWZ5XCI7XG5pbXBvcnQgXCJsb2Rhc2gtZXMvbWVtb2l6ZS5qc1wiO1xuaW1wb3J0IFwibG9kYXNoLWVzL21lcmdlLmpzXCI7XG5pbXBvcnQgXCJzdHlsaXNcIjtcbmltcG9ydCBcImxvZGFzaC1lcy9pc0VtcHR5LmpzXCI7XG5pbXBvcnQgXCJtZGFzdC11dGlsLWZyb20tbWFya2Rvd25cIjtcbnZhciBwYXJzZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG8gPSBmdW5jdGlvbihrLCB2LCBvMiwgbCkge1xuICAgIGZvciAobzIgPSBvMiB8fCB7fSwgbCA9IGsubGVuZ3RoOyBsLS07IG8yW2tbbF1dID0gdilcbiAgICAgIDtcbiAgICByZXR1cm4gbzI7XG4gIH0sICRWMCA9IFsxLCA0XSwgJFYxID0gWzEsIDEzXSwgJFYyID0gWzEsIDEyXSwgJFYzID0gWzEsIDE1XSwgJFY0ID0gWzEsIDE2XSwgJFY1ID0gWzEsIDIwXSwgJFY2ID0gWzEsIDE5XSwgJFY3ID0gWzYsIDcsIDhdLCAkVjggPSBbMSwgMjZdLCAkVjkgPSBbMSwgMjRdLCAkVmEgPSBbMSwgMjVdLCAkVmIgPSBbNiwgNywgMTFdLCAkVmMgPSBbMSwgNiwgMTMsIDE1LCAxNiwgMTksIDIyXSwgJFZkID0gWzEsIDMzXSwgJFZlID0gWzEsIDM0XSwgJFZmID0gWzEsIDYsIDcsIDExLCAxMywgMTUsIDE2LCAxOSwgMjJdO1xuICB2YXIgcGFyc2VyMiA9IHtcbiAgICB0cmFjZTogZnVuY3Rpb24gdHJhY2UoKSB7XG4gICAgfSxcbiAgICB5eToge30sXG4gICAgc3ltYm9sc186IHsgXCJlcnJvclwiOiAyLCBcInN0YXJ0XCI6IDMsIFwibWluZE1hcFwiOiA0LCBcInNwYWNlTGluZXNcIjogNSwgXCJTUEFDRUxJTkVcIjogNiwgXCJOTFwiOiA3LCBcIk1JTkRNQVBcIjogOCwgXCJkb2N1bWVudFwiOiA5LCBcInN0b3BcIjogMTAsIFwiRU9GXCI6IDExLCBcInN0YXRlbWVudFwiOiAxMiwgXCJTUEFDRUxJU1RcIjogMTMsIFwibm9kZVwiOiAxNCwgXCJJQ09OXCI6IDE1LCBcIkNMQVNTXCI6IDE2LCBcIm5vZGVXaXRoSWRcIjogMTcsIFwibm9kZVdpdGhvdXRJZFwiOiAxOCwgXCJOT0RFX0RTVEFSVFwiOiAxOSwgXCJOT0RFX0RFU0NSXCI6IDIwLCBcIk5PREVfREVORFwiOiAyMSwgXCJOT0RFX0lEXCI6IDIyLCBcIiRhY2NlcHRcIjogMCwgXCIkZW5kXCI6IDEgfSxcbiAgICB0ZXJtaW5hbHNfOiB7IDI6IFwiZXJyb3JcIiwgNjogXCJTUEFDRUxJTkVcIiwgNzogXCJOTFwiLCA4OiBcIk1JTkRNQVBcIiwgMTE6IFwiRU9GXCIsIDEzOiBcIlNQQUNFTElTVFwiLCAxNTogXCJJQ09OXCIsIDE2OiBcIkNMQVNTXCIsIDE5OiBcIk5PREVfRFNUQVJUXCIsIDIwOiBcIk5PREVfREVTQ1JcIiwgMjE6IFwiTk9ERV9ERU5EXCIsIDIyOiBcIk5PREVfSURcIiB9LFxuICAgIHByb2R1Y3Rpb25zXzogWzAsIFszLCAxXSwgWzMsIDJdLCBbNSwgMV0sIFs1LCAyXSwgWzUsIDJdLCBbNCwgMl0sIFs0LCAzXSwgWzEwLCAxXSwgWzEwLCAxXSwgWzEwLCAxXSwgWzEwLCAyXSwgWzEwLCAyXSwgWzksIDNdLCBbOSwgMl0sIFsxMiwgMl0sIFsxMiwgMl0sIFsxMiwgMl0sIFsxMiwgMV0sIFsxMiwgMV0sIFsxMiwgMV0sIFsxMiwgMV0sIFsxMiwgMV0sIFsxNCwgMV0sIFsxNCwgMV0sIFsxOCwgM10sIFsxNywgMV0sIFsxNywgNF1dLFxuICAgIHBlcmZvcm1BY3Rpb246IGZ1bmN0aW9uIGFub255bW91cyh5eXRleHQsIHl5bGVuZywgeXlsaW5lbm8sIHl5LCB5eXN0YXRlLCAkJCwgXyQpIHtcbiAgICAgIHZhciAkMCA9ICQkLmxlbmd0aCAtIDE7XG4gICAgICBzd2l0Y2ggKHl5c3RhdGUpIHtcbiAgICAgICAgY2FzZSA2OlxuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgcmV0dXJuIHl5O1xuICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgeXkuZ2V0TG9nZ2VyKCkudHJhY2UoXCJTdG9wIE5MIFwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA5OlxuICAgICAgICAgIHl5LmdldExvZ2dlcigpLnRyYWNlKFwiU3RvcCBFT0YgXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDExOlxuICAgICAgICAgIHl5LmdldExvZ2dlcigpLnRyYWNlKFwiU3RvcCBOTDIgXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgIHl5LmdldExvZ2dlcigpLnRyYWNlKFwiU3RvcCBFT0YyIFwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICB5eS5nZXRMb2dnZXIoKS5pbmZvKFwiTm9kZTogXCIsICQkWyQwXS5pZCk7XG4gICAgICAgICAgeXkuYWRkTm9kZSgkJFskMCAtIDFdLmxlbmd0aCwgJCRbJDBdLmlkLCAkJFskMF0uZGVzY3IsICQkWyQwXS50eXBlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICB5eS5nZXRMb2dnZXIoKS50cmFjZShcIkljb246IFwiLCAkJFskMF0pO1xuICAgICAgICAgIHl5LmRlY29yYXRlTm9kZSh7IGljb246ICQkWyQwXSB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgY2FzZSAyMTpcbiAgICAgICAgICB5eS5kZWNvcmF0ZU5vZGUoeyBjbGFzczogJCRbJDBdIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgIHl5LmdldExvZ2dlcigpLnRyYWNlKFwiU1BBQ0VMSVNUXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgIHl5LmdldExvZ2dlcigpLnRyYWNlKFwiTm9kZTogXCIsICQkWyQwXS5pZCk7XG4gICAgICAgICAgeXkuYWRkTm9kZSgwLCAkJFskMF0uaWQsICQkWyQwXS5kZXNjciwgJCRbJDBdLnR5cGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIwOlxuICAgICAgICAgIHl5LmRlY29yYXRlTm9kZSh7IGljb246ICQkWyQwXSB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyNTpcbiAgICAgICAgICB5eS5nZXRMb2dnZXIoKS50cmFjZShcIm5vZGUgZm91bmQgLi5cIiwgJCRbJDAgLSAyXSk7XG4gICAgICAgICAgdGhpcy4kID0geyBpZDogJCRbJDAgLSAxXSwgZGVzY3I6ICQkWyQwIC0gMV0sIHR5cGU6IHl5LmdldFR5cGUoJCRbJDAgLSAyXSwgJCRbJDBdKSB9O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI2OlxuICAgICAgICAgIHRoaXMuJCA9IHsgaWQ6ICQkWyQwXSwgZGVzY3I6ICQkWyQwXSwgdHlwZTogeXkubm9kZVR5cGUuREVGQVVMVCB9O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgIHl5LmdldExvZ2dlcigpLnRyYWNlKFwibm9kZSBmb3VuZCAuLlwiLCAkJFskMCAtIDNdKTtcbiAgICAgICAgICB0aGlzLiQgPSB7IGlkOiAkJFskMCAtIDNdLCBkZXNjcjogJCRbJDAgLSAxXSwgdHlwZTogeXkuZ2V0VHlwZSgkJFskMCAtIDJdLCAkJFskMF0pIH07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSxcbiAgICB0YWJsZTogW3sgMzogMSwgNDogMiwgNTogMywgNjogWzEsIDVdLCA4OiAkVjAgfSwgeyAxOiBbM10gfSwgeyAxOiBbMiwgMV0gfSwgeyA0OiA2LCA2OiBbMSwgN10sIDc6IFsxLCA4XSwgODogJFYwIH0sIHsgNjogJFYxLCA3OiBbMSwgMTBdLCA5OiA5LCAxMjogMTEsIDEzOiAkVjIsIDE0OiAxNCwgMTU6ICRWMywgMTY6ICRWNCwgMTc6IDE3LCAxODogMTgsIDE5OiAkVjUsIDIyOiAkVjYgfSwgbygkVjcsIFsyLCAzXSksIHsgMTogWzIsIDJdIH0sIG8oJFY3LCBbMiwgNF0pLCBvKCRWNywgWzIsIDVdKSwgeyAxOiBbMiwgNl0sIDY6ICRWMSwgMTI6IDIxLCAxMzogJFYyLCAxNDogMTQsIDE1OiAkVjMsIDE2OiAkVjQsIDE3OiAxNywgMTg6IDE4LCAxOTogJFY1LCAyMjogJFY2IH0sIHsgNjogJFYxLCA5OiAyMiwgMTI6IDExLCAxMzogJFYyLCAxNDogMTQsIDE1OiAkVjMsIDE2OiAkVjQsIDE3OiAxNywgMTg6IDE4LCAxOTogJFY1LCAyMjogJFY2IH0sIHsgNjogJFY4LCA3OiAkVjksIDEwOiAyMywgMTE6ICRWYSB9LCBvKCRWYiwgWzIsIDIyXSwgeyAxNzogMTcsIDE4OiAxOCwgMTQ6IDI3LCAxNTogWzEsIDI4XSwgMTY6IFsxLCAyOV0sIDE5OiAkVjUsIDIyOiAkVjYgfSksIG8oJFZiLCBbMiwgMThdKSwgbygkVmIsIFsyLCAxOV0pLCBvKCRWYiwgWzIsIDIwXSksIG8oJFZiLCBbMiwgMjFdKSwgbygkVmIsIFsyLCAyM10pLCBvKCRWYiwgWzIsIDI0XSksIG8oJFZiLCBbMiwgMjZdLCB7IDE5OiBbMSwgMzBdIH0pLCB7IDIwOiBbMSwgMzFdIH0sIHsgNjogJFY4LCA3OiAkVjksIDEwOiAzMiwgMTE6ICRWYSB9LCB7IDE6IFsyLCA3XSwgNjogJFYxLCAxMjogMjEsIDEzOiAkVjIsIDE0OiAxNCwgMTU6ICRWMywgMTY6ICRWNCwgMTc6IDE3LCAxODogMTgsIDE5OiAkVjUsIDIyOiAkVjYgfSwgbygkVmMsIFsyLCAxNF0sIHsgNzogJFZkLCAxMTogJFZlIH0pLCBvKCRWZiwgWzIsIDhdKSwgbygkVmYsIFsyLCA5XSksIG8oJFZmLCBbMiwgMTBdKSwgbygkVmIsIFsyLCAxNV0pLCBvKCRWYiwgWzIsIDE2XSksIG8oJFZiLCBbMiwgMTddKSwgeyAyMDogWzEsIDM1XSB9LCB7IDIxOiBbMSwgMzZdIH0sIG8oJFZjLCBbMiwgMTNdLCB7IDc6ICRWZCwgMTE6ICRWZSB9KSwgbygkVmYsIFsyLCAxMV0pLCBvKCRWZiwgWzIsIDEyXSksIHsgMjE6IFsxLCAzN10gfSwgbygkVmIsIFsyLCAyNV0pLCBvKCRWYiwgWzIsIDI3XSldLFxuICAgIGRlZmF1bHRBY3Rpb25zOiB7IDI6IFsyLCAxXSwgNjogWzIsIDJdIH0sXG4gICAgcGFyc2VFcnJvcjogZnVuY3Rpb24gcGFyc2VFcnJvcjIoc3RyLCBoYXNoKSB7XG4gICAgICBpZiAoaGFzaC5yZWNvdmVyYWJsZSkge1xuICAgICAgICB0aGlzLnRyYWNlKHN0cik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3Ioc3RyKTtcbiAgICAgICAgZXJyb3IuaGFzaCA9IGhhc2g7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH0sXG4gICAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlKGlucHV0KSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXMsIHN0YWNrID0gWzBdLCB0c3RhY2sgPSBbXSwgdnN0YWNrID0gW251bGxdLCBsc3RhY2sgPSBbXSwgdGFibGUgPSB0aGlzLnRhYmxlLCB5eXRleHQgPSBcIlwiLCB5eWxpbmVubyA9IDAsIHl5bGVuZyA9IDAsIFRFUlJPUiA9IDIsIEVPRiA9IDE7XG4gICAgICB2YXIgYXJncyA9IGxzdGFjay5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICB2YXIgbGV4ZXIyID0gT2JqZWN0LmNyZWF0ZSh0aGlzLmxleGVyKTtcbiAgICAgIHZhciBzaGFyZWRTdGF0ZSA9IHsgeXk6IHt9IH07XG4gICAgICBmb3IgKHZhciBrIGluIHRoaXMueXkpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLnl5LCBrKSkge1xuICAgICAgICAgIHNoYXJlZFN0YXRlLnl5W2tdID0gdGhpcy55eVtrXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV4ZXIyLnNldElucHV0KGlucHV0LCBzaGFyZWRTdGF0ZS55eSk7XG4gICAgICBzaGFyZWRTdGF0ZS55eS5sZXhlciA9IGxleGVyMjtcbiAgICAgIHNoYXJlZFN0YXRlLnl5LnBhcnNlciA9IHRoaXM7XG4gICAgICBpZiAodHlwZW9mIGxleGVyMi55eWxsb2MgPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBsZXhlcjIueXlsbG9jID0ge307XG4gICAgICB9XG4gICAgICB2YXIgeXlsb2MgPSBsZXhlcjIueXlsbG9jO1xuICAgICAgbHN0YWNrLnB1c2goeXlsb2MpO1xuICAgICAgdmFyIHJhbmdlcyA9IGxleGVyMi5vcHRpb25zICYmIGxleGVyMi5vcHRpb25zLnJhbmdlcztcbiAgICAgIGlmICh0eXBlb2Ygc2hhcmVkU3RhdGUueXkucGFyc2VFcnJvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRoaXMucGFyc2VFcnJvciA9IHNoYXJlZFN0YXRlLnl5LnBhcnNlRXJyb3I7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBhcnNlRXJyb3IgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykucGFyc2VFcnJvcjtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGxleCgpIHtcbiAgICAgICAgdmFyIHRva2VuO1xuICAgICAgICB0b2tlbiA9IHRzdGFjay5wb3AoKSB8fCBsZXhlcjIubGV4KCkgfHwgRU9GO1xuICAgICAgICBpZiAodHlwZW9mIHRva2VuICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgaWYgKHRva2VuIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIHRzdGFjayA9IHRva2VuO1xuICAgICAgICAgICAgdG9rZW4gPSB0c3RhY2sucG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRva2VuID0gc2VsZi5zeW1ib2xzX1t0b2tlbl0gfHwgdG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgfVxuICAgICAgdmFyIHN5bWJvbCwgc3RhdGUsIGFjdGlvbiwgciwgeXl2YWwgPSB7fSwgcCwgbGVuLCBuZXdTdGF0ZSwgZXhwZWN0ZWQ7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBzdGF0ZSA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAodGhpcy5kZWZhdWx0QWN0aW9uc1tzdGF0ZV0pIHtcbiAgICAgICAgICBhY3Rpb24gPSB0aGlzLmRlZmF1bHRBY3Rpb25zW3N0YXRlXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoc3ltYm9sID09PSBudWxsIHx8IHR5cGVvZiBzeW1ib2wgPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgc3ltYm9sID0gbGV4KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFjdGlvbiA9IHRhYmxlW3N0YXRlXSAmJiB0YWJsZVtzdGF0ZV1bc3ltYm9sXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGFjdGlvbiA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhYWN0aW9uLmxlbmd0aCB8fCAhYWN0aW9uWzBdKSB7XG4gICAgICAgICAgdmFyIGVyclN0ciA9IFwiXCI7XG4gICAgICAgICAgZXhwZWN0ZWQgPSBbXTtcbiAgICAgICAgICBmb3IgKHAgaW4gdGFibGVbc3RhdGVdKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50ZXJtaW5hbHNfW3BdICYmIHAgPiBURVJST1IpIHtcbiAgICAgICAgICAgICAgZXhwZWN0ZWQucHVzaChcIidcIiArIHRoaXMudGVybWluYWxzX1twXSArIFwiJ1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGxleGVyMi5zaG93UG9zaXRpb24pIHtcbiAgICAgICAgICAgIGVyclN0ciA9IFwiUGFyc2UgZXJyb3Igb24gbGluZSBcIiArICh5eWxpbmVubyArIDEpICsgXCI6XFxuXCIgKyBsZXhlcjIuc2hvd1Bvc2l0aW9uKCkgKyBcIlxcbkV4cGVjdGluZyBcIiArIGV4cGVjdGVkLmpvaW4oXCIsIFwiKSArIFwiLCBnb3QgJ1wiICsgKHRoaXMudGVybWluYWxzX1tzeW1ib2xdIHx8IHN5bWJvbCkgKyBcIidcIjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyU3RyID0gXCJQYXJzZSBlcnJvciBvbiBsaW5lIFwiICsgKHl5bGluZW5vICsgMSkgKyBcIjogVW5leHBlY3RlZCBcIiArIChzeW1ib2wgPT0gRU9GID8gXCJlbmQgb2YgaW5wdXRcIiA6IFwiJ1wiICsgKHRoaXMudGVybWluYWxzX1tzeW1ib2xdIHx8IHN5bWJvbCkgKyBcIidcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMucGFyc2VFcnJvcihlcnJTdHIsIHtcbiAgICAgICAgICAgIHRleHQ6IGxleGVyMi5tYXRjaCxcbiAgICAgICAgICAgIHRva2VuOiB0aGlzLnRlcm1pbmFsc19bc3ltYm9sXSB8fCBzeW1ib2wsXG4gICAgICAgICAgICBsaW5lOiBsZXhlcjIueXlsaW5lbm8sXG4gICAgICAgICAgICBsb2M6IHl5bG9jLFxuICAgICAgICAgICAgZXhwZWN0ZWRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWN0aW9uWzBdIGluc3RhbmNlb2YgQXJyYXkgJiYgYWN0aW9uLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJzZSBFcnJvcjogbXVsdGlwbGUgYWN0aW9ucyBwb3NzaWJsZSBhdCBzdGF0ZTogXCIgKyBzdGF0ZSArIFwiLCB0b2tlbjogXCIgKyBzeW1ib2wpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoYWN0aW9uWzBdKSB7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgc3RhY2sucHVzaChzeW1ib2wpO1xuICAgICAgICAgICAgdnN0YWNrLnB1c2gobGV4ZXIyLnl5dGV4dCk7XG4gICAgICAgICAgICBsc3RhY2sucHVzaChsZXhlcjIueXlsbG9jKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goYWN0aW9uWzFdKTtcbiAgICAgICAgICAgIHN5bWJvbCA9IG51bGw7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHl5bGVuZyA9IGxleGVyMi55eWxlbmc7XG4gICAgICAgICAgICAgIHl5dGV4dCA9IGxleGVyMi55eXRleHQ7XG4gICAgICAgICAgICAgIHl5bGluZW5vID0gbGV4ZXIyLnl5bGluZW5vO1xuICAgICAgICAgICAgICB5eWxvYyA9IGxleGVyMi55eWxsb2M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBsZW4gPSB0aGlzLnByb2R1Y3Rpb25zX1thY3Rpb25bMV1dWzFdO1xuICAgICAgICAgICAgeXl2YWwuJCA9IHZzdGFja1t2c3RhY2subGVuZ3RoIC0gbGVuXTtcbiAgICAgICAgICAgIHl5dmFsLl8kID0ge1xuICAgICAgICAgICAgICBmaXJzdF9saW5lOiBsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIChsZW4gfHwgMSldLmZpcnN0X2xpbmUsXG4gICAgICAgICAgICAgIGxhc3RfbGluZTogbHN0YWNrW2xzdGFjay5sZW5ndGggLSAxXS5sYXN0X2xpbmUsXG4gICAgICAgICAgICAgIGZpcnN0X2NvbHVtbjogbHN0YWNrW2xzdGFjay5sZW5ndGggLSAobGVuIHx8IDEpXS5maXJzdF9jb2x1bW4sXG4gICAgICAgICAgICAgIGxhc3RfY29sdW1uOiBsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIDFdLmxhc3RfY29sdW1uXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHJhbmdlcykge1xuICAgICAgICAgICAgICB5eXZhbC5fJC5yYW5nZSA9IFtcbiAgICAgICAgICAgICAgICBsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIChsZW4gfHwgMSldLnJhbmdlWzBdLFxuICAgICAgICAgICAgICAgIGxzdGFja1tsc3RhY2subGVuZ3RoIC0gMV0ucmFuZ2VbMV1cbiAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHIgPSB0aGlzLnBlcmZvcm1BY3Rpb24uYXBwbHkoeXl2YWwsIFtcbiAgICAgICAgICAgICAgeXl0ZXh0LFxuICAgICAgICAgICAgICB5eWxlbmcsXG4gICAgICAgICAgICAgIHl5bGluZW5vLFxuICAgICAgICAgICAgICBzaGFyZWRTdGF0ZS55eSxcbiAgICAgICAgICAgICAgYWN0aW9uWzFdLFxuICAgICAgICAgICAgICB2c3RhY2ssXG4gICAgICAgICAgICAgIGxzdGFja1xuICAgICAgICAgICAgXS5jb25jYXQoYXJncykpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgICBzdGFjayA9IHN0YWNrLnNsaWNlKDAsIC0xICogbGVuICogMik7XG4gICAgICAgICAgICAgIHZzdGFjayA9IHZzdGFjay5zbGljZSgwLCAtMSAqIGxlbik7XG4gICAgICAgICAgICAgIGxzdGFjayA9IGxzdGFjay5zbGljZSgwLCAtMSAqIGxlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFjay5wdXNoKHRoaXMucHJvZHVjdGlvbnNfW2FjdGlvblsxXV1bMF0pO1xuICAgICAgICAgICAgdnN0YWNrLnB1c2goeXl2YWwuJCk7XG4gICAgICAgICAgICBsc3RhY2sucHVzaCh5eXZhbC5fJCk7XG4gICAgICAgICAgICBuZXdTdGF0ZSA9IHRhYmxlW3N0YWNrW3N0YWNrLmxlbmd0aCAtIDJdXVtzdGFja1tzdGFjay5sZW5ndGggLSAxXV07XG4gICAgICAgICAgICBzdGFjay5wdXNoKG5ld1N0YXRlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH07XG4gIHZhciBsZXhlciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBsZXhlcjIgPSB7XG4gICAgICBFT0Y6IDEsXG4gICAgICBwYXJzZUVycm9yOiBmdW5jdGlvbiBwYXJzZUVycm9yMihzdHIsIGhhc2gpIHtcbiAgICAgICAgaWYgKHRoaXMueXkucGFyc2VyKSB7XG4gICAgICAgICAgdGhpcy55eS5wYXJzZXIucGFyc2VFcnJvcihzdHIsIGhhc2gpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihzdHIpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gcmVzZXRzIHRoZSBsZXhlciwgc2V0cyBuZXcgaW5wdXRcbiAgICAgIHNldElucHV0OiBmdW5jdGlvbihpbnB1dCwgeXkpIHtcbiAgICAgICAgdGhpcy55eSA9IHl5IHx8IHRoaXMueXkgfHwge307XG4gICAgICAgIHRoaXMuX2lucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMuX21vcmUgPSB0aGlzLl9iYWNrdHJhY2sgPSB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy55eWxpbmVubyA9IHRoaXMueXlsZW5nID0gMDtcbiAgICAgICAgdGhpcy55eXRleHQgPSB0aGlzLm1hdGNoZWQgPSB0aGlzLm1hdGNoID0gXCJcIjtcbiAgICAgICAgdGhpcy5jb25kaXRpb25TdGFjayA9IFtcIklOSVRJQUxcIl07XG4gICAgICAgIHRoaXMueXlsbG9jID0ge1xuICAgICAgICAgIGZpcnN0X2xpbmU6IDEsXG4gICAgICAgICAgZmlyc3RfY29sdW1uOiAwLFxuICAgICAgICAgIGxhc3RfbGluZTogMSxcbiAgICAgICAgICBsYXN0X2NvbHVtbjogMFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJhbmdlcykge1xuICAgICAgICAgIHRoaXMueXlsbG9jLnJhbmdlID0gWzAsIDBdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgLy8gY29uc3VtZXMgYW5kIHJldHVybnMgb25lIGNoYXIgZnJvbSB0aGUgaW5wdXRcbiAgICAgIGlucHV0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNoID0gdGhpcy5faW5wdXRbMF07XG4gICAgICAgIHRoaXMueXl0ZXh0ICs9IGNoO1xuICAgICAgICB0aGlzLnl5bGVuZysrO1xuICAgICAgICB0aGlzLm9mZnNldCsrO1xuICAgICAgICB0aGlzLm1hdGNoICs9IGNoO1xuICAgICAgICB0aGlzLm1hdGNoZWQgKz0gY2g7XG4gICAgICAgIHZhciBsaW5lcyA9IGNoLm1hdGNoKC8oPzpcXHJcXG4/fFxcbikuKi9nKTtcbiAgICAgICAgaWYgKGxpbmVzKSB7XG4gICAgICAgICAgdGhpcy55eWxpbmVubysrO1xuICAgICAgICAgIHRoaXMueXlsbG9jLmxhc3RfbGluZSsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMueXlsbG9jLmxhc3RfY29sdW1uKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yYW5nZXMpIHtcbiAgICAgICAgICB0aGlzLnl5bGxvYy5yYW5nZVsxXSsrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lucHV0ID0gdGhpcy5faW5wdXQuc2xpY2UoMSk7XG4gICAgICAgIHJldHVybiBjaDtcbiAgICAgIH0sXG4gICAgICAvLyB1bnNoaWZ0cyBvbmUgY2hhciAob3IgYSBzdHJpbmcpIGludG8gdGhlIGlucHV0XG4gICAgICB1bnB1dDogZnVuY3Rpb24oY2gpIHtcbiAgICAgICAgdmFyIGxlbiA9IGNoLmxlbmd0aDtcbiAgICAgICAgdmFyIGxpbmVzID0gY2guc3BsaXQoLyg/Olxcclxcbj98XFxuKS9nKTtcbiAgICAgICAgdGhpcy5faW5wdXQgPSBjaCArIHRoaXMuX2lucHV0O1xuICAgICAgICB0aGlzLnl5dGV4dCA9IHRoaXMueXl0ZXh0LnN1YnN0cigwLCB0aGlzLnl5dGV4dC5sZW5ndGggLSBsZW4pO1xuICAgICAgICB0aGlzLm9mZnNldCAtPSBsZW47XG4gICAgICAgIHZhciBvbGRMaW5lcyA9IHRoaXMubWF0Y2guc3BsaXQoLyg/Olxcclxcbj98XFxuKS9nKTtcbiAgICAgICAgdGhpcy5tYXRjaCA9IHRoaXMubWF0Y2guc3Vic3RyKDAsIHRoaXMubWF0Y2gubGVuZ3RoIC0gMSk7XG4gICAgICAgIHRoaXMubWF0Y2hlZCA9IHRoaXMubWF0Y2hlZC5zdWJzdHIoMCwgdGhpcy5tYXRjaGVkLmxlbmd0aCAtIDEpO1xuICAgICAgICBpZiAobGluZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIHRoaXMueXlsaW5lbm8gLT0gbGluZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgciA9IHRoaXMueXlsbG9jLnJhbmdlO1xuICAgICAgICB0aGlzLnl5bGxvYyA9IHtcbiAgICAgICAgICBmaXJzdF9saW5lOiB0aGlzLnl5bGxvYy5maXJzdF9saW5lLFxuICAgICAgICAgIGxhc3RfbGluZTogdGhpcy55eWxpbmVubyArIDEsXG4gICAgICAgICAgZmlyc3RfY29sdW1uOiB0aGlzLnl5bGxvYy5maXJzdF9jb2x1bW4sXG4gICAgICAgICAgbGFzdF9jb2x1bW46IGxpbmVzID8gKGxpbmVzLmxlbmd0aCA9PT0gb2xkTGluZXMubGVuZ3RoID8gdGhpcy55eWxsb2MuZmlyc3RfY29sdW1uIDogMCkgKyBvbGRMaW5lc1tvbGRMaW5lcy5sZW5ndGggLSBsaW5lcy5sZW5ndGhdLmxlbmd0aCAtIGxpbmVzWzBdLmxlbmd0aCA6IHRoaXMueXlsbG9jLmZpcnN0X2NvbHVtbiAtIGxlblxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJhbmdlcykge1xuICAgICAgICAgIHRoaXMueXlsbG9jLnJhbmdlID0gW3JbMF0sIHJbMF0gKyB0aGlzLnl5bGVuZyAtIGxlbl07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy55eWxlbmcgPSB0aGlzLnl5dGV4dC5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIC8vIFdoZW4gY2FsbGVkIGZyb20gYWN0aW9uLCBjYWNoZXMgbWF0Y2hlZCB0ZXh0IGFuZCBhcHBlbmRzIGl0IG9uIG5leHQgYWN0aW9uXG4gICAgICBtb3JlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fbW9yZSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIC8vIFdoZW4gY2FsbGVkIGZyb20gYWN0aW9uLCBzaWduYWxzIHRoZSBsZXhlciB0aGF0IHRoaXMgcnVsZSBmYWlscyB0byBtYXRjaCB0aGUgaW5wdXQsIHNvIHRoZSBuZXh0IG1hdGNoaW5nIHJ1bGUgKHJlZ2V4KSBzaG91bGQgYmUgdGVzdGVkIGluc3RlYWQuXG4gICAgICByZWplY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJhY2t0cmFja19sZXhlcikge1xuICAgICAgICAgIHRoaXMuX2JhY2t0cmFjayA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VFcnJvcihcIkxleGljYWwgZXJyb3Igb24gbGluZSBcIiArICh0aGlzLnl5bGluZW5vICsgMSkgKyBcIi4gWW91IGNhbiBvbmx5IGludm9rZSByZWplY3QoKSBpbiB0aGUgbGV4ZXIgd2hlbiB0aGUgbGV4ZXIgaXMgb2YgdGhlIGJhY2t0cmFja2luZyBwZXJzdWFzaW9uIChvcHRpb25zLmJhY2t0cmFja19sZXhlciA9IHRydWUpLlxcblwiICsgdGhpcy5zaG93UG9zaXRpb24oKSwge1xuICAgICAgICAgICAgdGV4dDogXCJcIixcbiAgICAgICAgICAgIHRva2VuOiBudWxsLFxuICAgICAgICAgICAgbGluZTogdGhpcy55eWxpbmVub1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIC8vIHJldGFpbiBmaXJzdCBuIGNoYXJhY3RlcnMgb2YgdGhlIG1hdGNoXG4gICAgICBsZXNzOiBmdW5jdGlvbihuKSB7XG4gICAgICAgIHRoaXMudW5wdXQodGhpcy5tYXRjaC5zbGljZShuKSk7XG4gICAgICB9LFxuICAgICAgLy8gZGlzcGxheXMgYWxyZWFkeSBtYXRjaGVkIGlucHV0LCBpLmUuIGZvciBlcnJvciBtZXNzYWdlc1xuICAgICAgcGFzdElucHV0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhc3QgPSB0aGlzLm1hdGNoZWQuc3Vic3RyKDAsIHRoaXMubWF0Y2hlZC5sZW5ndGggLSB0aGlzLm1hdGNoLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiAocGFzdC5sZW5ndGggPiAyMCA/IFwiLi4uXCIgOiBcIlwiKSArIHBhc3Quc3Vic3RyKC0yMCkucmVwbGFjZSgvXFxuL2csIFwiXCIpO1xuICAgICAgfSxcbiAgICAgIC8vIGRpc3BsYXlzIHVwY29taW5nIGlucHV0LCBpLmUuIGZvciBlcnJvciBtZXNzYWdlc1xuICAgICAgdXBjb21pbmdJbnB1dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBuZXh0ID0gdGhpcy5tYXRjaDtcbiAgICAgICAgaWYgKG5leHQubGVuZ3RoIDwgMjApIHtcbiAgICAgICAgICBuZXh0ICs9IHRoaXMuX2lucHV0LnN1YnN0cigwLCAyMCAtIG5leHQubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKG5leHQuc3Vic3RyKDAsIDIwKSArIChuZXh0Lmxlbmd0aCA+IDIwID8gXCIuLi5cIiA6IFwiXCIpKS5yZXBsYWNlKC9cXG4vZywgXCJcIik7XG4gICAgICB9LFxuICAgICAgLy8gZGlzcGxheXMgdGhlIGNoYXJhY3RlciBwb3NpdGlvbiB3aGVyZSB0aGUgbGV4aW5nIGVycm9yIG9jY3VycmVkLCBpLmUuIGZvciBlcnJvciBtZXNzYWdlc1xuICAgICAgc2hvd1Bvc2l0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHByZSA9IHRoaXMucGFzdElucHV0KCk7XG4gICAgICAgIHZhciBjID0gbmV3IEFycmF5KHByZS5sZW5ndGggKyAxKS5qb2luKFwiLVwiKTtcbiAgICAgICAgcmV0dXJuIHByZSArIHRoaXMudXBjb21pbmdJbnB1dCgpICsgXCJcXG5cIiArIGMgKyBcIl5cIjtcbiAgICAgIH0sXG4gICAgICAvLyB0ZXN0IHRoZSBsZXhlZCB0b2tlbjogcmV0dXJuIEZBTFNFIHdoZW4gbm90IGEgbWF0Y2gsIG90aGVyd2lzZSByZXR1cm4gdG9rZW5cbiAgICAgIHRlc3RfbWF0Y2g6IGZ1bmN0aW9uKG1hdGNoLCBpbmRleGVkX3J1bGUpIHtcbiAgICAgICAgdmFyIHRva2VuLCBsaW5lcywgYmFja3VwO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJhY2t0cmFja19sZXhlcikge1xuICAgICAgICAgIGJhY2t1cCA9IHtcbiAgICAgICAgICAgIHl5bGluZW5vOiB0aGlzLnl5bGluZW5vLFxuICAgICAgICAgICAgeXlsbG9jOiB7XG4gICAgICAgICAgICAgIGZpcnN0X2xpbmU6IHRoaXMueXlsbG9jLmZpcnN0X2xpbmUsXG4gICAgICAgICAgICAgIGxhc3RfbGluZTogdGhpcy5sYXN0X2xpbmUsXG4gICAgICAgICAgICAgIGZpcnN0X2NvbHVtbjogdGhpcy55eWxsb2MuZmlyc3RfY29sdW1uLFxuICAgICAgICAgICAgICBsYXN0X2NvbHVtbjogdGhpcy55eWxsb2MubGFzdF9jb2x1bW5cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB5eXRleHQ6IHRoaXMueXl0ZXh0LFxuICAgICAgICAgICAgbWF0Y2g6IHRoaXMubWF0Y2gsXG4gICAgICAgICAgICBtYXRjaGVzOiB0aGlzLm1hdGNoZXMsXG4gICAgICAgICAgICBtYXRjaGVkOiB0aGlzLm1hdGNoZWQsXG4gICAgICAgICAgICB5eWxlbmc6IHRoaXMueXlsZW5nLFxuICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgIF9tb3JlOiB0aGlzLl9tb3JlLFxuICAgICAgICAgICAgX2lucHV0OiB0aGlzLl9pbnB1dCxcbiAgICAgICAgICAgIHl5OiB0aGlzLnl5LFxuICAgICAgICAgICAgY29uZGl0aW9uU3RhY2s6IHRoaXMuY29uZGl0aW9uU3RhY2suc2xpY2UoMCksXG4gICAgICAgICAgICBkb25lOiB0aGlzLmRvbmVcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKSB7XG4gICAgICAgICAgICBiYWNrdXAueXlsbG9jLnJhbmdlID0gdGhpcy55eWxsb2MucmFuZ2Uuc2xpY2UoMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxpbmVzID0gbWF0Y2hbMF0ubWF0Y2goLyg/Olxcclxcbj98XFxuKS4qL2cpO1xuICAgICAgICBpZiAobGluZXMpIHtcbiAgICAgICAgICB0aGlzLnl5bGluZW5vICs9IGxpbmVzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnl5bGxvYyA9IHtcbiAgICAgICAgICBmaXJzdF9saW5lOiB0aGlzLnl5bGxvYy5sYXN0X2xpbmUsXG4gICAgICAgICAgbGFzdF9saW5lOiB0aGlzLnl5bGluZW5vICsgMSxcbiAgICAgICAgICBmaXJzdF9jb2x1bW46IHRoaXMueXlsbG9jLmxhc3RfY29sdW1uLFxuICAgICAgICAgIGxhc3RfY29sdW1uOiBsaW5lcyA/IGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdLmxlbmd0aCAtIGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdLm1hdGNoKC9cXHI/XFxuPy8pWzBdLmxlbmd0aCA6IHRoaXMueXlsbG9jLmxhc3RfY29sdW1uICsgbWF0Y2hbMF0ubGVuZ3RoXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMueXl0ZXh0ICs9IG1hdGNoWzBdO1xuICAgICAgICB0aGlzLm1hdGNoICs9IG1hdGNoWzBdO1xuICAgICAgICB0aGlzLm1hdGNoZXMgPSBtYXRjaDtcbiAgICAgICAgdGhpcy55eWxlbmcgPSB0aGlzLnl5dGV4dC5sZW5ndGg7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKSB7XG4gICAgICAgICAgdGhpcy55eWxsb2MucmFuZ2UgPSBbdGhpcy5vZmZzZXQsIHRoaXMub2Zmc2V0ICs9IHRoaXMueXlsZW5nXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tb3JlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2JhY2t0cmFjayA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pbnB1dCA9IHRoaXMuX2lucHV0LnNsaWNlKG1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgIHRoaXMubWF0Y2hlZCArPSBtYXRjaFswXTtcbiAgICAgICAgdG9rZW4gPSB0aGlzLnBlcmZvcm1BY3Rpb24uY2FsbCh0aGlzLCB0aGlzLnl5LCB0aGlzLCBpbmRleGVkX3J1bGUsIHRoaXMuY29uZGl0aW9uU3RhY2tbdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggLSAxXSk7XG4gICAgICAgIGlmICh0aGlzLmRvbmUgJiYgdGhpcy5faW5wdXQpIHtcbiAgICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYmFja3RyYWNrKSB7XG4gICAgICAgICAgZm9yICh2YXIgayBpbiBiYWNrdXApIHtcbiAgICAgICAgICAgIHRoaXNba10gPSBiYWNrdXBba107XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9LFxuICAgICAgLy8gcmV0dXJuIG5leHQgbWF0Y2ggaW4gaW5wdXRcbiAgICAgIG5leHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuRU9GO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5faW5wdXQpIHtcbiAgICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0b2tlbiwgbWF0Y2gsIHRlbXBNYXRjaCwgaW5kZXg7XG4gICAgICAgIGlmICghdGhpcy5fbW9yZSkge1xuICAgICAgICAgIHRoaXMueXl0ZXh0ID0gXCJcIjtcbiAgICAgICAgICB0aGlzLm1hdGNoID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcnVsZXMgPSB0aGlzLl9jdXJyZW50UnVsZXMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRlbXBNYXRjaCA9IHRoaXMuX2lucHV0Lm1hdGNoKHRoaXMucnVsZXNbcnVsZXNbaV1dKTtcbiAgICAgICAgICBpZiAodGVtcE1hdGNoICYmICghbWF0Y2ggfHwgdGVtcE1hdGNoWzBdLmxlbmd0aCA+IG1hdGNoWzBdLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIG1hdGNoID0gdGVtcE1hdGNoO1xuICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5iYWNrdHJhY2tfbGV4ZXIpIHtcbiAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRlc3RfbWF0Y2godGVtcE1hdGNoLCBydWxlc1tpXSk7XG4gICAgICAgICAgICAgIGlmICh0b2tlbiAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYmFja3RyYWNrKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMub3B0aW9ucy5mbGV4KSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICB0b2tlbiA9IHRoaXMudGVzdF9tYXRjaChtYXRjaCwgcnVsZXNbaW5kZXhdKTtcbiAgICAgICAgICBpZiAodG9rZW4gIT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faW5wdXQgPT09IFwiXCIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5FT0Y7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VFcnJvcihcIkxleGljYWwgZXJyb3Igb24gbGluZSBcIiArICh0aGlzLnl5bGluZW5vICsgMSkgKyBcIi4gVW5yZWNvZ25pemVkIHRleHQuXFxuXCIgKyB0aGlzLnNob3dQb3NpdGlvbigpLCB7XG4gICAgICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICAgICAgdG9rZW46IG51bGwsXG4gICAgICAgICAgICBsaW5lOiB0aGlzLnl5bGluZW5vXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyByZXR1cm4gbmV4dCBtYXRjaCB0aGF0IGhhcyBhIHRva2VuXG4gICAgICBsZXg6IGZ1bmN0aW9uIGxleCgpIHtcbiAgICAgICAgdmFyIHIgPSB0aGlzLm5leHQoKTtcbiAgICAgICAgaWYgKHIpIHtcbiAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5sZXgoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIGFjdGl2YXRlcyBhIG5ldyBsZXhlciBjb25kaXRpb24gc3RhdGUgKHB1c2hlcyB0aGUgbmV3IGxleGVyIGNvbmRpdGlvbiBzdGF0ZSBvbnRvIHRoZSBjb25kaXRpb24gc3RhY2spXG4gICAgICBiZWdpbjogZnVuY3Rpb24gYmVnaW4oY29uZGl0aW9uKSB7XG4gICAgICAgIHRoaXMuY29uZGl0aW9uU3RhY2sucHVzaChjb25kaXRpb24pO1xuICAgICAgfSxcbiAgICAgIC8vIHBvcCB0aGUgcHJldmlvdXNseSBhY3RpdmUgbGV4ZXIgY29uZGl0aW9uIHN0YXRlIG9mZiB0aGUgY29uZGl0aW9uIHN0YWNrXG4gICAgICBwb3BTdGF0ZTogZnVuY3Rpb24gcG9wU3RhdGUoKSB7XG4gICAgICAgIHZhciBuID0gdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggLSAxO1xuICAgICAgICBpZiAobiA+IDApIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25TdGFjay5wb3AoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25TdGFja1swXTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIHByb2R1Y2UgdGhlIGxleGVyIHJ1bGUgc2V0IHdoaWNoIGlzIGFjdGl2ZSBmb3IgdGhlIGN1cnJlbnRseSBhY3RpdmUgbGV4ZXIgY29uZGl0aW9uIHN0YXRlXG4gICAgICBfY3VycmVudFJ1bGVzOiBmdW5jdGlvbiBfY3VycmVudFJ1bGVzKCkge1xuICAgICAgICBpZiAodGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggJiYgdGhpcy5jb25kaXRpb25TdGFja1t0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uc1t0aGlzLmNvbmRpdGlvblN0YWNrW3RoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoIC0gMV1dLnJ1bGVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvbnNbXCJJTklUSUFMXCJdLnJ1bGVzO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gcmV0dXJuIHRoZSBjdXJyZW50bHkgYWN0aXZlIGxleGVyIGNvbmRpdGlvbiBzdGF0ZTsgd2hlbiBhbiBpbmRleCBhcmd1bWVudCBpcyBwcm92aWRlZCBpdCBwcm9kdWNlcyB0aGUgTi10aCBwcmV2aW91cyBjb25kaXRpb24gc3RhdGUsIGlmIGF2YWlsYWJsZVxuICAgICAgdG9wU3RhdGU6IGZ1bmN0aW9uIHRvcFN0YXRlKG4pIHtcbiAgICAgICAgbiA9IHRoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoIC0gMSAtIE1hdGguYWJzKG4gfHwgMCk7XG4gICAgICAgIGlmIChuID49IDApIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25TdGFja1tuXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gXCJJTklUSUFMXCI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBhbGlhcyBmb3IgYmVnaW4oY29uZGl0aW9uKVxuICAgICAgcHVzaFN0YXRlOiBmdW5jdGlvbiBwdXNoU3RhdGUoY29uZGl0aW9uKSB7XG4gICAgICAgIHRoaXMuYmVnaW4oY29uZGl0aW9uKTtcbiAgICAgIH0sXG4gICAgICAvLyByZXR1cm4gdGhlIG51bWJlciBvZiBzdGF0ZXMgY3VycmVudGx5IG9uIHRoZSBzdGFja1xuICAgICAgc3RhdGVTdGFja1NpemU6IGZ1bmN0aW9uIHN0YXRlU3RhY2tTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGg7XG4gICAgICB9LFxuICAgICAgb3B0aW9uczogeyBcImNhc2UtaW5zZW5zaXRpdmVcIjogdHJ1ZSB9LFxuICAgICAgcGVyZm9ybUFjdGlvbjogZnVuY3Rpb24gYW5vbnltb3VzKHl5LCB5eV8sICRhdm9pZGluZ19uYW1lX2NvbGxpc2lvbnMsIFlZX1NUQVJUKSB7XG4gICAgICAgIHN3aXRjaCAoJGF2b2lkaW5nX25hbWVfY29sbGlzaW9ucykge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHl5LmdldExvZ2dlcigpLnRyYWNlKFwiRm91bmQgY29tbWVudFwiLCB5eV8ueXl0ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiA2O1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJldHVybiA4O1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHRoaXMuYmVnaW4oXCJDTEFTU1wiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHRoaXMucG9wU3RhdGUoKTtcbiAgICAgICAgICAgIHJldHVybiAxNjtcbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICB0aGlzLnBvcFN0YXRlKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICB5eS5nZXRMb2dnZXIoKS50cmFjZShcIkJlZ2luIGljb25cIik7XG4gICAgICAgICAgICB0aGlzLmJlZ2luKFwiSUNPTlwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIHl5LmdldExvZ2dlcigpLnRyYWNlKFwiU1BBQ0VMSU5FXCIpO1xuICAgICAgICAgICAgcmV0dXJuIDY7XG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgcmV0dXJuIDc7XG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgcmV0dXJuIDE1O1xuICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIHl5LmdldExvZ2dlcigpLnRyYWNlKFwiZW5kIGljb25cIik7XG4gICAgICAgICAgICB0aGlzLnBvcFN0YXRlKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgeXkuZ2V0TG9nZ2VyKCkudHJhY2UoXCJFeHBsb2Rpbmcgbm9kZVwiKTtcbiAgICAgICAgICAgIHRoaXMuYmVnaW4oXCJOT0RFXCIpO1xuICAgICAgICAgICAgcmV0dXJuIDE5O1xuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICB5eS5nZXRMb2dnZXIoKS50cmFjZShcIkNsb3VkXCIpO1xuICAgICAgICAgICAgdGhpcy5iZWdpbihcIk5PREVcIik7XG4gICAgICAgICAgICByZXR1cm4gMTk7XG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgIHl5LmdldExvZ2dlcigpLnRyYWNlKFwiRXhwbG9zaW9uIEJhbmdcIik7XG4gICAgICAgICAgICB0aGlzLmJlZ2luKFwiTk9ERVwiKTtcbiAgICAgICAgICAgIHJldHVybiAxOTtcbiAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgeXkuZ2V0TG9nZ2VyKCkudHJhY2UoXCJDbG91ZCBCYW5nXCIpO1xuICAgICAgICAgICAgdGhpcy5iZWdpbihcIk5PREVcIik7XG4gICAgICAgICAgICByZXR1cm4gMTk7XG4gICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgIHRoaXMuYmVnaW4oXCJOT0RFXCIpO1xuICAgICAgICAgICAgcmV0dXJuIDE5O1xuICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICB0aGlzLmJlZ2luKFwiTk9ERVwiKTtcbiAgICAgICAgICAgIHJldHVybiAxOTtcbiAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgdGhpcy5iZWdpbihcIk5PREVcIik7XG4gICAgICAgICAgICByZXR1cm4gMTk7XG4gICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgIHRoaXMuYmVnaW4oXCJOT0RFXCIpO1xuICAgICAgICAgICAgcmV0dXJuIDE5O1xuICAgICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgICByZXR1cm4gMTM7XG4gICAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICAgIHJldHVybiAyMjtcbiAgICAgICAgICBjYXNlIDIwOlxuICAgICAgICAgICAgcmV0dXJuIDExO1xuICAgICAgICAgIGNhc2UgMjE6XG4gICAgICAgICAgICB0aGlzLmJlZ2luKFwiTlNUUjJcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgICAgcmV0dXJuIFwiTk9ERV9ERVNDUlwiO1xuICAgICAgICAgIGNhc2UgMjM6XG4gICAgICAgICAgICB0aGlzLnBvcFN0YXRlKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgICAgeXkuZ2V0TG9nZ2VyKCkudHJhY2UoXCJTdGFydGluZyBOU1RSXCIpO1xuICAgICAgICAgICAgdGhpcy5iZWdpbihcIk5TVFJcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI1OlxuICAgICAgICAgICAgeXkuZ2V0TG9nZ2VyKCkudHJhY2UoXCJkZXNjcmlwdGlvbjpcIiwgeXlfLnl5dGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gXCJOT0RFX0RFU0NSXCI7XG4gICAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICAgIHRoaXMucG9wU3RhdGUoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgICB0aGlzLnBvcFN0YXRlKCk7XG4gICAgICAgICAgICB5eS5nZXRMb2dnZXIoKS50cmFjZShcIm5vZGUgZW5kICkpXCIpO1xuICAgICAgICAgICAgcmV0dXJuIFwiTk9ERV9ERU5EXCI7XG4gICAgICAgICAgY2FzZSAyODpcbiAgICAgICAgICAgIHRoaXMucG9wU3RhdGUoKTtcbiAgICAgICAgICAgIHl5LmdldExvZ2dlcigpLnRyYWNlKFwibm9kZSBlbmQgKVwiKTtcbiAgICAgICAgICAgIHJldHVybiBcIk5PREVfREVORFwiO1xuICAgICAgICAgIGNhc2UgMjk6XG4gICAgICAgICAgICB0aGlzLnBvcFN0YXRlKCk7XG4gICAgICAgICAgICB5eS5nZXRMb2dnZXIoKS50cmFjZShcIm5vZGUgZW5kIC4uLlwiLCB5eV8ueXl0ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBcIk5PREVfREVORFwiO1xuICAgICAgICAgIGNhc2UgMzA6XG4gICAgICAgICAgICB0aGlzLnBvcFN0YXRlKCk7XG4gICAgICAgICAgICB5eS5nZXRMb2dnZXIoKS50cmFjZShcIm5vZGUgZW5kICgoXCIpO1xuICAgICAgICAgICAgcmV0dXJuIFwiTk9ERV9ERU5EXCI7XG4gICAgICAgICAgY2FzZSAzMTpcbiAgICAgICAgICAgIHRoaXMucG9wU3RhdGUoKTtcbiAgICAgICAgICAgIHl5LmdldExvZ2dlcigpLnRyYWNlKFwibm9kZSBlbmQgKC1cIik7XG4gICAgICAgICAgICByZXR1cm4gXCJOT0RFX0RFTkRcIjtcbiAgICAgICAgICBjYXNlIDMyOlxuICAgICAgICAgICAgdGhpcy5wb3BTdGF0ZSgpO1xuICAgICAgICAgICAgeXkuZ2V0TG9nZ2VyKCkudHJhY2UoXCJub2RlIGVuZCAoLVwiKTtcbiAgICAgICAgICAgIHJldHVybiBcIk5PREVfREVORFwiO1xuICAgICAgICAgIGNhc2UgMzM6XG4gICAgICAgICAgICB0aGlzLnBvcFN0YXRlKCk7XG4gICAgICAgICAgICB5eS5nZXRMb2dnZXIoKS50cmFjZShcIm5vZGUgZW5kICgoXCIpO1xuICAgICAgICAgICAgcmV0dXJuIFwiTk9ERV9ERU5EXCI7XG4gICAgICAgICAgY2FzZSAzNDpcbiAgICAgICAgICAgIHRoaXMucG9wU3RhdGUoKTtcbiAgICAgICAgICAgIHl5LmdldExvZ2dlcigpLnRyYWNlKFwibm9kZSBlbmQgKChcIik7XG4gICAgICAgICAgICByZXR1cm4gXCJOT0RFX0RFTkRcIjtcbiAgICAgICAgICBjYXNlIDM1OlxuICAgICAgICAgICAgeXkuZ2V0TG9nZ2VyKCkudHJhY2UoXCJMb25nIGRlc2NyaXB0aW9uOlwiLCB5eV8ueXl0ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiAyMDtcbiAgICAgICAgICBjYXNlIDM2OlxuICAgICAgICAgICAgeXkuZ2V0TG9nZ2VyKCkudHJhY2UoXCJMb25nIGRlc2NyaXB0aW9uOlwiLCB5eV8ueXl0ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiAyMDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJ1bGVzOiBbL14oPzpcXHMqJSUuKikvaSwgL14oPzptaW5kbWFwXFxiKS9pLCAvXig/Ojo6OikvaSwgL14oPzouKykvaSwgL14oPzpcXG4pL2ksIC9eKD86OjppY29uXFwoKS9pLCAvXig/OltcXHNdK1tcXG5dKS9pLCAvXig/OltcXG5dKykvaSwgL14oPzpbXlxcKV0rKS9pLCAvXig/OlxcKSkvaSwgL14oPzotXFwpKS9pLCAvXig/OlxcKC0pL2ksIC9eKD86XFwpXFwpKS9pLCAvXig/OlxcKSkvaSwgL14oPzpcXChcXCgpL2ksIC9eKD86XFx7XFx7KS9pLCAvXig/OlxcKCkvaSwgL14oPzpcXFspL2ksIC9eKD86W1xcc10rKS9pLCAvXig/OlteXFwoXFxbXFxuXFwpXFx7XFx9XSspL2ksIC9eKD86JCkvaSwgL14oPzpbXCJdW2BdKS9pLCAvXig/OlteYFwiXSspL2ksIC9eKD86W2BdW1wiXSkvaSwgL14oPzpbXCJdKS9pLCAvXig/OlteXCJdKykvaSwgL14oPzpbXCJdKS9pLCAvXig/OltcXCldXFwpKS9pLCAvXig/OltcXCldKS9pLCAvXig/OltcXF1dKS9pLCAvXig/OlxcfVxcfSkvaSwgL14oPzpcXCgtKS9pLCAvXig/Oi1cXCkpL2ksIC9eKD86XFwoXFwoKS9pLCAvXig/OlxcKCkvaSwgL14oPzpbXlxcKVxcXVxcKFxcfV0rKS9pLCAvXig/Oi4rKD8hXFwoXFwoKSkvaV0sXG4gICAgICBjb25kaXRpb25zOiB7IFwiQ0xBU1NcIjogeyBcInJ1bGVzXCI6IFszLCA0XSwgXCJpbmNsdXNpdmVcIjogZmFsc2UgfSwgXCJJQ09OXCI6IHsgXCJydWxlc1wiOiBbOCwgOV0sIFwiaW5jbHVzaXZlXCI6IGZhbHNlIH0sIFwiTlNUUjJcIjogeyBcInJ1bGVzXCI6IFsyMiwgMjNdLCBcImluY2x1c2l2ZVwiOiBmYWxzZSB9LCBcIk5TVFJcIjogeyBcInJ1bGVzXCI6IFsyNSwgMjZdLCBcImluY2x1c2l2ZVwiOiBmYWxzZSB9LCBcIk5PREVcIjogeyBcInJ1bGVzXCI6IFsyMSwgMjQsIDI3LCAyOCwgMjksIDMwLCAzMSwgMzIsIDMzLCAzNCwgMzUsIDM2XSwgXCJpbmNsdXNpdmVcIjogZmFsc2UgfSwgXCJJTklUSUFMXCI6IHsgXCJydWxlc1wiOiBbMCwgMSwgMiwgNSwgNiwgNywgMTAsIDExLCAxMiwgMTMsIDE0LCAxNSwgMTYsIDE3LCAxOCwgMTksIDIwXSwgXCJpbmNsdXNpdmVcIjogdHJ1ZSB9IH1cbiAgICB9O1xuICAgIHJldHVybiBsZXhlcjI7XG4gIH0oKTtcbiAgcGFyc2VyMi5sZXhlciA9IGxleGVyO1xuICBmdW5jdGlvbiBQYXJzZXIoKSB7XG4gICAgdGhpcy55eSA9IHt9O1xuICB9XG4gIFBhcnNlci5wcm90b3R5cGUgPSBwYXJzZXIyO1xuICBwYXJzZXIyLlBhcnNlciA9IFBhcnNlcjtcbiAgcmV0dXJuIG5ldyBQYXJzZXIoKTtcbn0oKTtcbnBhcnNlci5wYXJzZXIgPSBwYXJzZXI7XG5jb25zdCBtaW5kbWFwUGFyc2VyID0gcGFyc2VyO1xuY29uc3Qgc2FuaXRpemVUZXh0ID0gKHRleHQpID0+IHNhbml0aXplVGV4dCQxKHRleHQsIGdldENvbmZpZygpKTtcbmxldCBub2RlcyA9IFtdO1xubGV0IGNudCA9IDA7XG5sZXQgZWxlbWVudHMgPSB7fTtcbmNvbnN0IGNsZWFyID0gKCkgPT4ge1xuICBub2RlcyA9IFtdO1xuICBjbnQgPSAwO1xuICBlbGVtZW50cyA9IHt9O1xufTtcbmNvbnN0IGdldFBhcmVudCA9IGZ1bmN0aW9uKGxldmVsKSB7XG4gIGZvciAobGV0IGkgPSBub2Rlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChub2Rlc1tpXS5sZXZlbCA8IGxldmVsKSB7XG4gICAgICByZXR1cm4gbm9kZXNbaV07XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufTtcbmNvbnN0IGdldE1pbmRtYXAgPSAoKSA9PiB7XG4gIHJldHVybiBub2Rlcy5sZW5ndGggPiAwID8gbm9kZXNbMF0gOiBudWxsO1xufTtcbmNvbnN0IGFkZE5vZGUgPSAobGV2ZWwsIGlkLCBkZXNjciwgdHlwZSkgPT4ge1xuICBsb2cuaW5mbyhcImFkZE5vZGVcIiwgbGV2ZWwsIGlkLCBkZXNjciwgdHlwZSk7XG4gIGNvbnN0IGNvbmYgPSBnZXRDb25maWcoKTtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICBpZDogY250KyssXG4gICAgbm9kZUlkOiBzYW5pdGl6ZVRleHQoaWQpLFxuICAgIGxldmVsLFxuICAgIGRlc2NyOiBzYW5pdGl6ZVRleHQoZGVzY3IpLFxuICAgIHR5cGUsXG4gICAgY2hpbGRyZW46IFtdLFxuICAgIHdpZHRoOiBnZXRDb25maWcoKS5taW5kbWFwLm1heE5vZGVXaWR0aFxuICB9O1xuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2Ugbm9kZVR5cGUuUk9VTkRFRF9SRUNUOlxuICAgICAgbm9kZS5wYWRkaW5nID0gMiAqIGNvbmYubWluZG1hcC5wYWRkaW5nO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBub2RlVHlwZS5SRUNUOlxuICAgICAgbm9kZS5wYWRkaW5nID0gMiAqIGNvbmYubWluZG1hcC5wYWRkaW5nO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBub2RlVHlwZS5IRVhBR09OOlxuICAgICAgbm9kZS5wYWRkaW5nID0gMiAqIGNvbmYubWluZG1hcC5wYWRkaW5nO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIG5vZGUucGFkZGluZyA9IGNvbmYubWluZG1hcC5wYWRkaW5nO1xuICB9XG4gIGNvbnN0IHBhcmVudCA9IGdldFBhcmVudChsZXZlbCk7XG4gIGlmIChwYXJlbnQpIHtcbiAgICBwYXJlbnQuY2hpbGRyZW4ucHVzaChub2RlKTtcbiAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICB9IGVsc2Uge1xuICAgIGlmIChub2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgJ1RoZXJlIGNhbiBiZSBvbmx5IG9uZSByb290LiBObyBwYXJlbnQgY291bGQgYmUgZm91bmQgZm9yIChcIicgKyBub2RlLmRlc2NyICsgJ1wiKSdcbiAgICAgICk7XG4gICAgICBlcnJvci5oYXNoID0ge1xuICAgICAgICB0ZXh0OiBcImJyYW5jaCBcIiArIG5hbWUsXG4gICAgICAgIHRva2VuOiBcImJyYW5jaCBcIiArIG5hbWUsXG4gICAgICAgIGxpbmU6IFwiMVwiLFxuICAgICAgICBsb2M6IHsgZmlyc3RfbGluZTogMSwgbGFzdF9saW5lOiAxLCBmaXJzdF9jb2x1bW46IDEsIGxhc3RfY29sdW1uOiAxIH0sXG4gICAgICAgIGV4cGVjdGVkOiBbJ1wiY2hlY2tvdXQgJyArIG5hbWUgKyAnXCInXVxuICAgICAgfTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxufTtcbmNvbnN0IG5vZGVUeXBlID0ge1xuICBERUZBVUxUOiAwLFxuICBOT19CT1JERVI6IDAsXG4gIFJPVU5ERURfUkVDVDogMSxcbiAgUkVDVDogMixcbiAgQ0lSQ0xFOiAzLFxuICBDTE9VRDogNCxcbiAgQkFORzogNSxcbiAgSEVYQUdPTjogNlxufTtcbmNvbnN0IGdldFR5cGUgPSAoc3RhcnRTdHIsIGVuZFN0cikgPT4ge1xuICBsb2cuZGVidWcoXCJJbiBnZXQgdHlwZVwiLCBzdGFydFN0ciwgZW5kU3RyKTtcbiAgc3dpdGNoIChzdGFydFN0cikge1xuICAgIGNhc2UgXCJbXCI6XG4gICAgICByZXR1cm4gbm9kZVR5cGUuUkVDVDtcbiAgICBjYXNlIFwiKFwiOlxuICAgICAgcmV0dXJuIGVuZFN0ciA9PT0gXCIpXCIgPyBub2RlVHlwZS5ST1VOREVEX1JFQ1QgOiBub2RlVHlwZS5DTE9VRDtcbiAgICBjYXNlIFwiKChcIjpcbiAgICAgIHJldHVybiBub2RlVHlwZS5DSVJDTEU7XG4gICAgY2FzZSBcIilcIjpcbiAgICAgIHJldHVybiBub2RlVHlwZS5DTE9VRDtcbiAgICBjYXNlIFwiKSlcIjpcbiAgICAgIHJldHVybiBub2RlVHlwZS5CQU5HO1xuICAgIGNhc2UgXCJ7e1wiOlxuICAgICAgcmV0dXJuIG5vZGVUeXBlLkhFWEFHT047XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBub2RlVHlwZS5ERUZBVUxUO1xuICB9XG59O1xuY29uc3Qgc2V0RWxlbWVudEZvcklkID0gKGlkLCBlbGVtZW50KSA9PiB7XG4gIGVsZW1lbnRzW2lkXSA9IGVsZW1lbnQ7XG59O1xuY29uc3QgZGVjb3JhdGVOb2RlID0gKGRlY29yYXRpb24pID0+IHtcbiAgY29uc3Qgbm9kZSA9IG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdO1xuICBpZiAoZGVjb3JhdGlvbiAmJiBkZWNvcmF0aW9uLmljb24pIHtcbiAgICBub2RlLmljb24gPSBzYW5pdGl6ZVRleHQoZGVjb3JhdGlvbi5pY29uKTtcbiAgfVxuICBpZiAoZGVjb3JhdGlvbiAmJiBkZWNvcmF0aW9uLmNsYXNzKSB7XG4gICAgbm9kZS5jbGFzcyA9IHNhbml0aXplVGV4dChkZWNvcmF0aW9uLmNsYXNzKTtcbiAgfVxufTtcbmNvbnN0IHR5cGUyU3RyID0gKHR5cGUpID0+IHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBub2RlVHlwZS5ERUZBVUxUOlxuICAgICAgcmV0dXJuIFwibm8tYm9yZGVyXCI7XG4gICAgY2FzZSBub2RlVHlwZS5SRUNUOlxuICAgICAgcmV0dXJuIFwicmVjdFwiO1xuICAgIGNhc2Ugbm9kZVR5cGUuUk9VTkRFRF9SRUNUOlxuICAgICAgcmV0dXJuIFwicm91bmRlZC1yZWN0XCI7XG4gICAgY2FzZSBub2RlVHlwZS5DSVJDTEU6XG4gICAgICByZXR1cm4gXCJjaXJjbGVcIjtcbiAgICBjYXNlIG5vZGVUeXBlLkNMT1VEOlxuICAgICAgcmV0dXJuIFwiY2xvdWRcIjtcbiAgICBjYXNlIG5vZGVUeXBlLkJBTkc6XG4gICAgICByZXR1cm4gXCJiYW5nXCI7XG4gICAgY2FzZSBub2RlVHlwZS5IRVhBR09OOlxuICAgICAgcmV0dXJuIFwiaGV4Z29uXCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBcIm5vLWJvcmRlclwiO1xuICB9XG59O1xubGV0IHBhcnNlRXJyb3I7XG5jb25zdCBzZXRFcnJvckhhbmRsZXIgPSAoaGFuZGxlcikgPT4ge1xuICBwYXJzZUVycm9yID0gaGFuZGxlcjtcbn07XG5jb25zdCBnZXRMb2dnZXIgPSAoKSA9PiBsb2c7XG5jb25zdCBnZXROb2RlQnlJZCA9IChpZCkgPT4gbm9kZXNbaWRdO1xuY29uc3QgZ2V0RWxlbWVudEJ5SWQgPSAoaWQpID0+IGVsZW1lbnRzW2lkXTtcbmNvbnN0IG1pbmRtYXBEYiA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGFkZE5vZGUsXG4gIGNsZWFyLFxuICBkZWNvcmF0ZU5vZGUsXG4gIGdldEVsZW1lbnRCeUlkLFxuICBnZXRMb2dnZXIsXG4gIGdldE1pbmRtYXAsXG4gIGdldE5vZGVCeUlkLFxuICBnZXRUeXBlLFxuICBub2RlVHlwZSxcbiAgZ2V0IHBhcnNlRXJyb3IoKSB7XG4gICAgcmV0dXJuIHBhcnNlRXJyb3I7XG4gIH0sXG4gIHNhbml0aXplVGV4dCxcbiAgc2V0RWxlbWVudEZvcklkLFxuICBzZXRFcnJvckhhbmRsZXIsXG4gIHR5cGUyU3RyXG59LCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSkpO1xuY29uc3QgTUFYX1NFQ1RJT05TID0gMTI7XG5jb25zdCBkZWZhdWx0QmtnID0gZnVuY3Rpb24oZWxlbSwgbm9kZSwgc2VjdGlvbikge1xuICBjb25zdCByZCA9IDU7XG4gIGVsZW0uYXBwZW5kKFwicGF0aFwiKS5hdHRyKFwiaWRcIiwgXCJub2RlLVwiICsgbm9kZS5pZCkuYXR0cihcImNsYXNzXCIsIFwibm9kZS1ia2cgbm9kZS1cIiArIHR5cGUyU3RyKG5vZGUudHlwZSkpLmF0dHIoXG4gICAgXCJkXCIsXG4gICAgYE0wICR7bm9kZS5oZWlnaHQgLSByZH0gdiR7LW5vZGUuaGVpZ2h0ICsgMiAqIHJkfSBxMCwtNSA1LC01IGgke25vZGUud2lkdGggLSAyICogcmR9IHE1LDAgNSw1IHYke25vZGUuaGVpZ2h0IC0gcmR9IEgwIFpgXG4gICk7XG4gIGVsZW0uYXBwZW5kKFwibGluZVwiKS5hdHRyKFwiY2xhc3NcIiwgXCJub2RlLWxpbmUtXCIgKyBzZWN0aW9uKS5hdHRyKFwieDFcIiwgMCkuYXR0cihcInkxXCIsIG5vZGUuaGVpZ2h0KS5hdHRyKFwieDJcIiwgbm9kZS53aWR0aCkuYXR0cihcInkyXCIsIG5vZGUuaGVpZ2h0KTtcbn07XG5jb25zdCByZWN0QmtnID0gZnVuY3Rpb24oZWxlbSwgbm9kZSkge1xuICBlbGVtLmFwcGVuZChcInJlY3RcIikuYXR0cihcImlkXCIsIFwibm9kZS1cIiArIG5vZGUuaWQpLmF0dHIoXCJjbGFzc1wiLCBcIm5vZGUtYmtnIG5vZGUtXCIgKyB0eXBlMlN0cihub2RlLnR5cGUpKS5hdHRyKFwiaGVpZ2h0XCIsIG5vZGUuaGVpZ2h0KS5hdHRyKFwid2lkdGhcIiwgbm9kZS53aWR0aCk7XG59O1xuY29uc3QgY2xvdWRCa2cgPSBmdW5jdGlvbihlbGVtLCBub2RlKSB7XG4gIGNvbnN0IHcgPSBub2RlLndpZHRoO1xuICBjb25zdCBoID0gbm9kZS5oZWlnaHQ7XG4gIGNvbnN0IHIxID0gMC4xNSAqIHc7XG4gIGNvbnN0IHIyID0gMC4yNSAqIHc7XG4gIGNvbnN0IHIzID0gMC4zNSAqIHc7XG4gIGNvbnN0IHI0ID0gMC4yICogdztcbiAgZWxlbS5hcHBlbmQoXCJwYXRoXCIpLmF0dHIoXCJpZFwiLCBcIm5vZGUtXCIgKyBub2RlLmlkKS5hdHRyKFwiY2xhc3NcIiwgXCJub2RlLWJrZyBub2RlLVwiICsgdHlwZTJTdHIobm9kZS50eXBlKSkuYXR0cihcbiAgICBcImRcIixcbiAgICBgTTAgMCBhJHtyMX0sJHtyMX0gMCAwLDEgJHt3ICogMC4yNX0sJHstMSAqIHcgKiAwLjF9XG4gICAgICBhJHtyM30sJHtyM30gMSAwLDEgJHt3ICogMC40fSwkey0xICogdyAqIDAuMX1cbiAgICAgIGEke3IyfSwke3IyfSAxIDAsMSAke3cgKiAwLjM1fSwkezEgKiB3ICogMC4yfVxuXG4gICAgICBhJHtyMX0sJHtyMX0gMSAwLDEgJHt3ICogMC4xNX0sJHsxICogaCAqIDAuMzV9XG4gICAgICBhJHtyNH0sJHtyNH0gMSAwLDEgJHstMSAqIHcgKiAwLjE1fSwkezEgKiBoICogMC42NX1cblxuICAgICAgYSR7cjJ9LCR7cjF9IDEgMCwxICR7LTEgKiB3ICogMC4yNX0sJHt3ICogMC4xNX1cbiAgICAgIGEke3IzfSwke3IzfSAxIDAsMSAkey0xICogdyAqIDAuNX0sJHswfVxuICAgICAgYSR7cjF9LCR7cjF9IDEgMCwxICR7LTEgKiB3ICogMC4yNX0sJHstMSAqIHcgKiAwLjE1fVxuXG4gICAgICBhJHtyMX0sJHtyMX0gMSAwLDEgJHstMSAqIHcgKiAwLjF9LCR7LTEgKiBoICogMC4zNX1cbiAgICAgIGEke3I0fSwke3I0fSAxIDAsMSAke3cgKiAwLjF9LCR7LTEgKiBoICogMC42NX1cblxuICAgIEgwIFYwIFpgXG4gICk7XG59O1xuY29uc3QgYmFuZ0JrZyA9IGZ1bmN0aW9uKGVsZW0sIG5vZGUpIHtcbiAgY29uc3QgdyA9IG5vZGUud2lkdGg7XG4gIGNvbnN0IGggPSBub2RlLmhlaWdodDtcbiAgY29uc3QgciA9IDAuMTUgKiB3O1xuICBlbGVtLmFwcGVuZChcInBhdGhcIikuYXR0cihcImlkXCIsIFwibm9kZS1cIiArIG5vZGUuaWQpLmF0dHIoXCJjbGFzc1wiLCBcIm5vZGUtYmtnIG5vZGUtXCIgKyB0eXBlMlN0cihub2RlLnR5cGUpKS5hdHRyKFxuICAgIFwiZFwiLFxuICAgIGBNMCAwIGEke3J9LCR7cn0gMSAwLDAgJHt3ICogMC4yNX0sJHstMSAqIGggKiAwLjF9XG4gICAgICBhJHtyfSwke3J9IDEgMCwwICR7dyAqIDAuMjV9LCR7MH1cbiAgICAgIGEke3J9LCR7cn0gMSAwLDAgJHt3ICogMC4yNX0sJHswfVxuICAgICAgYSR7cn0sJHtyfSAxIDAsMCAke3cgKiAwLjI1fSwkezEgKiBoICogMC4xfVxuXG4gICAgICBhJHtyfSwke3J9IDEgMCwwICR7dyAqIDAuMTV9LCR7MSAqIGggKiAwLjMzfVxuICAgICAgYSR7ciAqIDAuOH0sJHtyICogMC44fSAxIDAsMCAkezB9LCR7MSAqIGggKiAwLjM0fVxuICAgICAgYSR7cn0sJHtyfSAxIDAsMCAkey0xICogdyAqIDAuMTV9LCR7MSAqIGggKiAwLjMzfVxuXG4gICAgICBhJHtyfSwke3J9IDEgMCwwICR7LTEgKiB3ICogMC4yNX0sJHtoICogMC4xNX1cbiAgICAgIGEke3J9LCR7cn0gMSAwLDAgJHstMSAqIHcgKiAwLjI1fSwkezB9XG4gICAgICBhJHtyfSwke3J9IDEgMCwwICR7LTEgKiB3ICogMC4yNX0sJHswfVxuICAgICAgYSR7cn0sJHtyfSAxIDAsMCAkey0xICogdyAqIDAuMjV9LCR7LTEgKiBoICogMC4xNX1cblxuICAgICAgYSR7cn0sJHtyfSAxIDAsMCAkey0xICogdyAqIDAuMX0sJHstMSAqIGggKiAwLjMzfVxuICAgICAgYSR7ciAqIDAuOH0sJHtyICogMC44fSAxIDAsMCAkezB9LCR7LTEgKiBoICogMC4zNH1cbiAgICAgIGEke3J9LCR7cn0gMSAwLDAgJHt3ICogMC4xfSwkey0xICogaCAqIDAuMzN9XG5cbiAgICBIMCBWMCBaYFxuICApO1xufTtcbmNvbnN0IGNpcmNsZUJrZyA9IGZ1bmN0aW9uKGVsZW0sIG5vZGUpIHtcbiAgZWxlbS5hcHBlbmQoXCJjaXJjbGVcIikuYXR0cihcImlkXCIsIFwibm9kZS1cIiArIG5vZGUuaWQpLmF0dHIoXCJjbGFzc1wiLCBcIm5vZGUtYmtnIG5vZGUtXCIgKyB0eXBlMlN0cihub2RlLnR5cGUpKS5hdHRyKFwiclwiLCBub2RlLndpZHRoIC8gMik7XG59O1xuZnVuY3Rpb24gaW5zZXJ0UG9seWdvblNoYXBlKHBhcmVudCwgdywgaCwgcG9pbnRzLCBub2RlKSB7XG4gIHJldHVybiBwYXJlbnQuaW5zZXJ0KFwicG9seWdvblwiLCBcIjpmaXJzdC1jaGlsZFwiKS5hdHRyKFxuICAgIFwicG9pbnRzXCIsXG4gICAgcG9pbnRzLm1hcChmdW5jdGlvbihkKSB7XG4gICAgICByZXR1cm4gZC54ICsgXCIsXCIgKyBkLnk7XG4gICAgfSkuam9pbihcIiBcIilcbiAgKS5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgKG5vZGUud2lkdGggLSB3KSAvIDIgKyBcIiwgXCIgKyBoICsgXCIpXCIpO1xufVxuY29uc3QgaGV4YWdvbkJrZyA9IGZ1bmN0aW9uKGVsZW0sIG5vZGUpIHtcbiAgY29uc3QgaCA9IG5vZGUuaGVpZ2h0O1xuICBjb25zdCBmID0gNDtcbiAgY29uc3QgbSA9IGggLyBmO1xuICBjb25zdCB3ID0gbm9kZS53aWR0aCAtIG5vZGUucGFkZGluZyArIDIgKiBtO1xuICBjb25zdCBwb2ludHMgPSBbXG4gICAgeyB4OiBtLCB5OiAwIH0sXG4gICAgeyB4OiB3IC0gbSwgeTogMCB9LFxuICAgIHsgeDogdywgeTogLWggLyAyIH0sXG4gICAgeyB4OiB3IC0gbSwgeTogLWggfSxcbiAgICB7IHg6IG0sIHk6IC1oIH0sXG4gICAgeyB4OiAwLCB5OiAtaCAvIDIgfVxuICBdO1xuICBpbnNlcnRQb2x5Z29uU2hhcGUoZWxlbSwgdywgaCwgcG9pbnRzLCBub2RlKTtcbn07XG5jb25zdCByb3VuZGVkUmVjdEJrZyA9IGZ1bmN0aW9uKGVsZW0sIG5vZGUpIHtcbiAgZWxlbS5hcHBlbmQoXCJyZWN0XCIpLmF0dHIoXCJpZFwiLCBcIm5vZGUtXCIgKyBub2RlLmlkKS5hdHRyKFwiY2xhc3NcIiwgXCJub2RlLWJrZyBub2RlLVwiICsgdHlwZTJTdHIobm9kZS50eXBlKSkuYXR0cihcImhlaWdodFwiLCBub2RlLmhlaWdodCkuYXR0cihcInJ4XCIsIG5vZGUucGFkZGluZykuYXR0cihcInJ5XCIsIG5vZGUucGFkZGluZykuYXR0cihcIndpZHRoXCIsIG5vZGUud2lkdGgpO1xufTtcbmNvbnN0IGRyYXdOb2RlID0gZnVuY3Rpb24oZWxlbSwgbm9kZSwgZnVsbFNlY3Rpb24sIGNvbmYpIHtcbiAgY29uc3QgaHRtbExhYmVscyA9IGNvbmYuaHRtbExhYmVscztcbiAgY29uc3Qgc2VjdGlvbiA9IGZ1bGxTZWN0aW9uICUgKE1BWF9TRUNUSU9OUyAtIDEpO1xuICBjb25zdCBub2RlRWxlbSA9IGVsZW0uYXBwZW5kKFwiZ1wiKTtcbiAgbm9kZS5zZWN0aW9uID0gc2VjdGlvbjtcbiAgbGV0IHNlY3Rpb25DbGFzcyA9IFwic2VjdGlvbi1cIiArIHNlY3Rpb247XG4gIGlmIChzZWN0aW9uIDwgMCkge1xuICAgIHNlY3Rpb25DbGFzcyArPSBcIiBzZWN0aW9uLXJvb3RcIjtcbiAgfVxuICBub2RlRWxlbS5hdHRyKFwiY2xhc3NcIiwgKG5vZGUuY2xhc3MgPyBub2RlLmNsYXNzICsgXCIgXCIgOiBcIlwiKSArIFwibWluZG1hcC1ub2RlIFwiICsgc2VjdGlvbkNsYXNzKTtcbiAgY29uc3QgYmtnRWxlbSA9IG5vZGVFbGVtLmFwcGVuZChcImdcIik7XG4gIGNvbnN0IHRleHRFbGVtID0gbm9kZUVsZW0uYXBwZW5kKFwiZ1wiKTtcbiAgY29uc3QgZGVzY3JpcHRpb24gPSBub2RlLmRlc2NyLnJlcGxhY2UoLyg8YnJcXC8qPikvZywgXCJcXG5cIik7XG4gIGNyZWF0ZVRleHQodGV4dEVsZW0sIGRlc2NyaXB0aW9uLCB7XG4gICAgdXNlSHRtbExhYmVsczogaHRtbExhYmVscyxcbiAgICB3aWR0aDogbm9kZS53aWR0aCxcbiAgICBjbGFzc2VzOiBcIm1pbmRtYXAtbm9kZS1sYWJlbFwiXG4gIH0pO1xuICBpZiAoIWh0bWxMYWJlbHMpIHtcbiAgICB0ZXh0RWxlbS5hdHRyKFwiZHlcIiwgXCIxZW1cIikuYXR0cihcImFsaWdubWVudC1iYXNlbGluZVwiLCBcIm1pZGRsZVwiKS5hdHRyKFwiZG9taW5hbnQtYmFzZWxpbmVcIiwgXCJtaWRkbGVcIikuYXR0cihcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpO1xuICB9XG4gIGNvbnN0IGJib3ggPSB0ZXh0RWxlbS5ub2RlKCkuZ2V0QkJveCgpO1xuICBjb25zdCBmb250U2l6ZSA9IGNvbmYuZm9udFNpemUucmVwbGFjZSA/IGNvbmYuZm9udFNpemUucmVwbGFjZShcInB4XCIsIFwiXCIpIDogY29uZi5mb250U2l6ZTtcbiAgbm9kZS5oZWlnaHQgPSBiYm94LmhlaWdodCArIGZvbnRTaXplICogMS4xICogMC41ICsgbm9kZS5wYWRkaW5nO1xuICBub2RlLndpZHRoID0gYmJveC53aWR0aCArIDIgKiBub2RlLnBhZGRpbmc7XG4gIGlmIChub2RlLmljb24pIHtcbiAgICBpZiAobm9kZS50eXBlID09PSBub2RlVHlwZS5DSVJDTEUpIHtcbiAgICAgIG5vZGUuaGVpZ2h0ICs9IDUwO1xuICAgICAgbm9kZS53aWR0aCArPSA1MDtcbiAgICAgIGNvbnN0IGljb24gPSBub2RlRWxlbS5hcHBlbmQoXCJmb3JlaWduT2JqZWN0XCIpLmF0dHIoXCJoZWlnaHRcIiwgXCI1MHB4XCIpLmF0dHIoXCJ3aWR0aFwiLCBub2RlLndpZHRoKS5hdHRyKFwic3R5bGVcIiwgXCJ0ZXh0LWFsaWduOiBjZW50ZXI7XCIpO1xuICAgICAgaWNvbi5hcHBlbmQoXCJkaXZcIikuYXR0cihcImNsYXNzXCIsIFwiaWNvbi1jb250YWluZXJcIikuYXBwZW5kKFwiaVwiKS5hdHRyKFwiY2xhc3NcIiwgXCJub2RlLWljb24tXCIgKyBzZWN0aW9uICsgXCIgXCIgKyBub2RlLmljb24pO1xuICAgICAgdGV4dEVsZW0uYXR0cihcbiAgICAgICAgXCJ0cmFuc2Zvcm1cIixcbiAgICAgICAgXCJ0cmFuc2xhdGUoXCIgKyBub2RlLndpZHRoIC8gMiArIFwiLCBcIiArIChub2RlLmhlaWdodCAvIDIgLSAxLjUgKiBub2RlLnBhZGRpbmcpICsgXCIpXCJcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUud2lkdGggKz0gNTA7XG4gICAgICBjb25zdCBvcmdIZWlnaHQgPSBub2RlLmhlaWdodDtcbiAgICAgIG5vZGUuaGVpZ2h0ID0gTWF0aC5tYXgob3JnSGVpZ2h0LCA2MCk7XG4gICAgICBjb25zdCBoZWlnaHREaWZmID0gTWF0aC5hYnMobm9kZS5oZWlnaHQgLSBvcmdIZWlnaHQpO1xuICAgICAgY29uc3QgaWNvbiA9IG5vZGVFbGVtLmFwcGVuZChcImZvcmVpZ25PYmplY3RcIikuYXR0cihcIndpZHRoXCIsIFwiNjBweFwiKS5hdHRyKFwiaGVpZ2h0XCIsIG5vZGUuaGVpZ2h0KS5hdHRyKFwic3R5bGVcIiwgXCJ0ZXh0LWFsaWduOiBjZW50ZXI7bWFyZ2luLXRvcDpcIiArIGhlaWdodERpZmYgLyAyICsgXCJweDtcIik7XG4gICAgICBpY29uLmFwcGVuZChcImRpdlwiKS5hdHRyKFwiY2xhc3NcIiwgXCJpY29uLWNvbnRhaW5lclwiKS5hcHBlbmQoXCJpXCIpLmF0dHIoXCJjbGFzc1wiLCBcIm5vZGUtaWNvbi1cIiArIHNlY3Rpb24gKyBcIiBcIiArIG5vZGUuaWNvbik7XG4gICAgICB0ZXh0RWxlbS5hdHRyKFxuICAgICAgICBcInRyYW5zZm9ybVwiLFxuICAgICAgICBcInRyYW5zbGF0ZShcIiArICgyNSArIG5vZGUud2lkdGggLyAyKSArIFwiLCBcIiArIChoZWlnaHREaWZmIC8gMiArIG5vZGUucGFkZGluZyAvIDIpICsgXCIpXCJcbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICghaHRtbExhYmVscykge1xuICAgICAgY29uc3QgZHggPSBub2RlLndpZHRoIC8gMjtcbiAgICAgIGNvbnN0IGR5ID0gbm9kZS5wYWRkaW5nIC8gMjtcbiAgICAgIHRleHRFbGVtLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyBkeCArIFwiLCBcIiArIGR5ICsgXCIpXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBkeCA9IChub2RlLndpZHRoIC0gYmJveC53aWR0aCkgLyAyO1xuICAgICAgY29uc3QgZHkgPSAobm9kZS5oZWlnaHQgLSBiYm94LmhlaWdodCkgLyAyO1xuICAgICAgdGV4dEVsZW0uYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIGR4ICsgXCIsIFwiICsgZHkgKyBcIilcIik7XG4gICAgfVxuICB9XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBub2RlVHlwZS5ERUZBVUxUOlxuICAgICAgZGVmYXVsdEJrZyhia2dFbGVtLCBub2RlLCBzZWN0aW9uKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2Ugbm9kZVR5cGUuUk9VTkRFRF9SRUNUOlxuICAgICAgcm91bmRlZFJlY3RCa2coYmtnRWxlbSwgbm9kZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIG5vZGVUeXBlLlJFQ1Q6XG4gICAgICByZWN0QmtnKGJrZ0VsZW0sIG5vZGUpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBub2RlVHlwZS5DSVJDTEU6XG4gICAgICBia2dFbGVtLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyBub2RlLndpZHRoIC8gMiArIFwiLCBcIiArICtub2RlLmhlaWdodCAvIDIgKyBcIilcIik7XG4gICAgICBjaXJjbGVCa2coYmtnRWxlbSwgbm9kZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIG5vZGVUeXBlLkNMT1VEOlxuICAgICAgY2xvdWRCa2coYmtnRWxlbSwgbm9kZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIG5vZGVUeXBlLkJBTkc6XG4gICAgICBiYW5nQmtnKGJrZ0VsZW0sIG5vZGUpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBub2RlVHlwZS5IRVhBR09OOlxuICAgICAgaGV4YWdvbkJrZyhia2dFbGVtLCBub2RlKTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHNldEVsZW1lbnRGb3JJZChub2RlLmlkLCBub2RlRWxlbSk7XG4gIHJldHVybiBub2RlLmhlaWdodDtcbn07XG5jb25zdCBkcmF3RWRnZSA9IGZ1bmN0aW9uIGRyYXdFZGdlMihlZGdlc0VsZW0sIG1pbmRtYXAsIHBhcmVudCwgZGVwdGgsIGZ1bGxTZWN0aW9uKSB7XG4gIGNvbnN0IHNlY3Rpb24gPSBmdWxsU2VjdGlvbiAlIChNQVhfU0VDVElPTlMgLSAxKTtcbiAgY29uc3Qgc3ggPSBwYXJlbnQueCArIHBhcmVudC53aWR0aCAvIDI7XG4gIGNvbnN0IHN5ID0gcGFyZW50LnkgKyBwYXJlbnQuaGVpZ2h0IC8gMjtcbiAgY29uc3QgZXggPSBtaW5kbWFwLnggKyBtaW5kbWFwLndpZHRoIC8gMjtcbiAgY29uc3QgZXkgPSBtaW5kbWFwLnkgKyBtaW5kbWFwLmhlaWdodCAvIDI7XG4gIGNvbnN0IG14ID0gZXggPiBzeCA/IHN4ICsgTWF0aC5hYnMoc3ggLSBleCkgLyAyIDogc3ggLSBNYXRoLmFicyhzeCAtIGV4KSAvIDI7XG4gIGNvbnN0IG15ID0gZXkgPiBzeSA/IHN5ICsgTWF0aC5hYnMoc3kgLSBleSkgLyAyIDogc3kgLSBNYXRoLmFicyhzeSAtIGV5KSAvIDI7XG4gIGNvbnN0IHF4ID0gZXggPiBzeCA/IE1hdGguYWJzKHN4IC0gbXgpIC8gMiArIHN4IDogLU1hdGguYWJzKHN4IC0gbXgpIC8gMiArIHN4O1xuICBjb25zdCBxeSA9IGV5ID4gc3kgPyBNYXRoLmFicyhzeSAtIG15KSAvIDIgKyBzeSA6IC1NYXRoLmFicyhzeSAtIG15KSAvIDIgKyBzeTtcbiAgZWRnZXNFbGVtLmFwcGVuZChcInBhdGhcIikuYXR0cihcbiAgICBcImRcIixcbiAgICBwYXJlbnQuZGlyZWN0aW9uID09PSBcIlRCXCIgfHwgcGFyZW50LmRpcmVjdGlvbiA9PT0gXCJCVFwiID8gYE0ke3N4fSwke3N5fSBRJHtzeH0sJHtxeX0gJHtteH0sJHtteX0gVCR7ZXh9LCR7ZXl9YCA6IGBNJHtzeH0sJHtzeX0gUSR7cXh9LCR7c3l9ICR7bXh9LCR7bXl9IFQke2V4fSwke2V5fWBcbiAgKS5hdHRyKFwiY2xhc3NcIiwgXCJlZGdlIHNlY3Rpb24tZWRnZS1cIiArIHNlY3Rpb24gKyBcIiBlZGdlLWRlcHRoLVwiICsgZGVwdGgpO1xufTtcbmNvbnN0IHBvc2l0aW9uTm9kZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgY29uc3Qgbm9kZUVsZW0gPSBnZXRFbGVtZW50QnlJZChub2RlLmlkKTtcbiAgY29uc3QgeCA9IG5vZGUueCB8fCAwO1xuICBjb25zdCB5ID0gbm9kZS55IHx8IDA7XG4gIG5vZGVFbGVtLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyB4ICsgXCIsXCIgKyB5ICsgXCIpXCIpO1xufTtcbmNvbnN0IHN2Z0RyYXcgPSB7IGRyYXdOb2RlLCBwb3NpdGlvbk5vZGUsIGRyYXdFZGdlIH07XG5jeXRvc2NhcGUudXNlKGNvc2VCaWxrZW50KTtcbmZ1bmN0aW9uIGRyYXdOb2RlcyhzdmcsIG1pbmRtYXAsIHNlY3Rpb24sIGNvbmYpIHtcbiAgc3ZnRHJhdy5kcmF3Tm9kZShzdmcsIG1pbmRtYXAsIHNlY3Rpb24sIGNvbmYpO1xuICBpZiAobWluZG1hcC5jaGlsZHJlbikge1xuICAgIG1pbmRtYXAuY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQsIGluZGV4KSA9PiB7XG4gICAgICBkcmF3Tm9kZXMoc3ZnLCBjaGlsZCwgc2VjdGlvbiA8IDAgPyBpbmRleCA6IHNlY3Rpb24sIGNvbmYpO1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBkcmF3RWRnZXMoZWRnZXNFbCwgY3kpIHtcbiAgY3kuZWRnZXMoKS5tYXAoKGVkZ2UsIGlkKSA9PiB7XG4gICAgY29uc3QgZGF0YSA9IGVkZ2UuZGF0YSgpO1xuICAgIGlmIChlZGdlWzBdLl9wcml2YXRlLmJvZHlCb3VuZHMpIHtcbiAgICAgIGNvbnN0IGJvdW5kcyA9IGVkZ2VbMF0uX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgICBsb2cudHJhY2UoXCJFZGdlOiBcIiwgaWQsIGRhdGEpO1xuICAgICAgZWRnZXNFbC5pbnNlcnQoXCJwYXRoXCIpLmF0dHIoXG4gICAgICAgIFwiZFwiLFxuICAgICAgICBgTSAke2JvdW5kcy5zdGFydFh9LCR7Ym91bmRzLnN0YXJ0WX0gTCAke2JvdW5kcy5taWRYfSwke2JvdW5kcy5taWRZfSBMJHtib3VuZHMuZW5kWH0sJHtib3VuZHMuZW5kWX0gYFxuICAgICAgKS5hdHRyKFwiY2xhc3NcIiwgXCJlZGdlIHNlY3Rpb24tZWRnZS1cIiArIGRhdGEuc2VjdGlvbiArIFwiIGVkZ2UtZGVwdGgtXCIgKyBkYXRhLmRlcHRoKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gYWRkTm9kZXMobWluZG1hcCwgY3ksIGNvbmYsIGxldmVsKSB7XG4gIGN5LmFkZCh7XG4gICAgZ3JvdXA6IFwibm9kZXNcIixcbiAgICBkYXRhOiB7XG4gICAgICBpZDogbWluZG1hcC5pZCxcbiAgICAgIGxhYmVsVGV4dDogbWluZG1hcC5kZXNjcixcbiAgICAgIGhlaWdodDogbWluZG1hcC5oZWlnaHQsXG4gICAgICB3aWR0aDogbWluZG1hcC53aWR0aCxcbiAgICAgIGxldmVsLFxuICAgICAgbm9kZUlkOiBtaW5kbWFwLmlkLFxuICAgICAgcGFkZGluZzogbWluZG1hcC5wYWRkaW5nLFxuICAgICAgdHlwZTogbWluZG1hcC50eXBlXG4gICAgfSxcbiAgICBwb3NpdGlvbjoge1xuICAgICAgeDogbWluZG1hcC54LFxuICAgICAgeTogbWluZG1hcC55XG4gICAgfVxuICB9KTtcbiAgaWYgKG1pbmRtYXAuY2hpbGRyZW4pIHtcbiAgICBtaW5kbWFwLmNoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICBhZGROb2RlcyhjaGlsZCwgY3ksIGNvbmYsIGxldmVsICsgMSk7XG4gICAgICBjeS5hZGQoe1xuICAgICAgICBncm91cDogXCJlZGdlc1wiLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgaWQ6IGAke21pbmRtYXAuaWR9XyR7Y2hpbGQuaWR9YCxcbiAgICAgICAgICBzb3VyY2U6IG1pbmRtYXAuaWQsXG4gICAgICAgICAgdGFyZ2V0OiBjaGlsZC5pZCxcbiAgICAgICAgICBkZXB0aDogbGV2ZWwsXG4gICAgICAgICAgc2VjdGlvbjogY2hpbGQuc2VjdGlvblxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gbGF5b3V0TWluZG1hcChub2RlLCBjb25mKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIGNvbnN0IHJlbmRlckVsID0gc2VsZWN0KFwiYm9keVwiKS5hcHBlbmQoXCJkaXZcIikuYXR0cihcImlkXCIsIFwiY3lcIikuYXR0cihcInN0eWxlXCIsIFwiZGlzcGxheTpub25lXCIpO1xuICAgIGNvbnN0IGN5ID0gY3l0b3NjYXBlKHtcbiAgICAgIGNvbnRhaW5lcjogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjeVwiKSxcbiAgICAgIC8vIGNvbnRhaW5lciB0byByZW5kZXIgaW5cbiAgICAgIHN0eWxlOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBzZWxlY3RvcjogXCJlZGdlXCIsXG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIFwiY3VydmUtc3R5bGVcIjogXCJiZXppZXJcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0pO1xuICAgIHJlbmRlckVsLnJlbW92ZSgpO1xuICAgIGFkZE5vZGVzKG5vZGUsIGN5LCBjb25mLCAwKTtcbiAgICBjeS5ub2RlcygpLmZvckVhY2goZnVuY3Rpb24obikge1xuICAgICAgbi5sYXlvdXREaW1lbnNpb25zID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBkYXRhID0gbi5kYXRhKCk7XG4gICAgICAgIHJldHVybiB7IHc6IGRhdGEud2lkdGgsIGg6IGRhdGEuaGVpZ2h0IH07XG4gICAgICB9O1xuICAgIH0pO1xuICAgIGN5LmxheW91dCh7XG4gICAgICBuYW1lOiBcImNvc2UtYmlsa2VudFwiLFxuICAgICAgcXVhbGl0eTogXCJwcm9vZlwiLFxuICAgICAgLy8gaGVhZGxlc3M6IHRydWUsXG4gICAgICBzdHlsZUVuYWJsZWQ6IGZhbHNlLFxuICAgICAgYW5pbWF0ZTogZmFsc2VcbiAgICB9KS5ydW4oKTtcbiAgICBjeS5yZWFkeSgoZSkgPT4ge1xuICAgICAgbG9nLmluZm8oXCJSZWFkeVwiLCBlKTtcbiAgICAgIHJlc29sdmUoY3kpO1xuICAgIH0pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHBvc2l0aW9uTm9kZXMoY3kpIHtcbiAgY3kubm9kZXMoKS5tYXAoKG5vZGUsIGlkKSA9PiB7XG4gICAgY29uc3QgZGF0YSA9IG5vZGUuZGF0YSgpO1xuICAgIGRhdGEueCA9IG5vZGUucG9zaXRpb24oKS54O1xuICAgIGRhdGEueSA9IG5vZGUucG9zaXRpb24oKS55O1xuICAgIHN2Z0RyYXcucG9zaXRpb25Ob2RlKGRhdGEpO1xuICAgIGNvbnN0IGVsID0gZ2V0RWxlbWVudEJ5SWQoZGF0YS5ub2RlSWQpO1xuICAgIGxvZy5pbmZvKFwiSWQ6XCIsIGlkLCBcIlBvc2l0aW9uOiAoXCIsIG5vZGUucG9zaXRpb24oKS54LCBcIiwgXCIsIG5vZGUucG9zaXRpb24oKS55LCBcIilcIiwgZGF0YSk7XG4gICAgZWwuYXR0cihcbiAgICAgIFwidHJhbnNmb3JtXCIsXG4gICAgICBgdHJhbnNsYXRlKCR7bm9kZS5wb3NpdGlvbigpLnggLSBkYXRhLndpZHRoIC8gMn0sICR7bm9kZS5wb3NpdGlvbigpLnkgLSBkYXRhLmhlaWdodCAvIDJ9KWBcbiAgICApO1xuICAgIGVsLmF0dHIoXCJhdHRyXCIsIGBhcGEtJHtpZH0pYCk7XG4gIH0pO1xufVxuY29uc3QgZHJhdyA9IGFzeW5jICh0ZXh0LCBpZCwgdmVyc2lvbiwgZGlhZ09iaikgPT4ge1xuICBjb25zdCBjb25mID0gZ2V0Q29uZmlnKCk7XG4gIGNvbmYuaHRtbExhYmVscyA9IGZhbHNlO1xuICBsb2cuZGVidWcoXCJSZW5kZXJpbmcgbWluZG1hcCBkaWFncmFtXFxuXCIgKyB0ZXh0LCBkaWFnT2JqLnBhcnNlcik7XG4gIGNvbnN0IHNlY3VyaXR5TGV2ZWwgPSBnZXRDb25maWcoKS5zZWN1cml0eUxldmVsO1xuICBsZXQgc2FuZGJveEVsZW1lbnQ7XG4gIGlmIChzZWN1cml0eUxldmVsID09PSBcInNhbmRib3hcIikge1xuICAgIHNhbmRib3hFbGVtZW50ID0gc2VsZWN0KFwiI2lcIiArIGlkKTtcbiAgfVxuICBjb25zdCByb290ID0gc2VjdXJpdHlMZXZlbCA9PT0gXCJzYW5kYm94XCIgPyBzZWxlY3Qoc2FuZGJveEVsZW1lbnQubm9kZXMoKVswXS5jb250ZW50RG9jdW1lbnQuYm9keSkgOiBzZWxlY3QoXCJib2R5XCIpO1xuICBjb25zdCBzdmcgPSByb290LnNlbGVjdChcIiNcIiArIGlkKTtcbiAgc3ZnLmFwcGVuZChcImdcIik7XG4gIGNvbnN0IG1tID0gZGlhZ09iai5kYi5nZXRNaW5kbWFwKCk7XG4gIGNvbnN0IGVkZ2VzRWxlbSA9IHN2Zy5hcHBlbmQoXCJnXCIpO1xuICBlZGdlc0VsZW0uYXR0cihcImNsYXNzXCIsIFwibWluZG1hcC1lZGdlc1wiKTtcbiAgY29uc3Qgbm9kZXNFbGVtID0gc3ZnLmFwcGVuZChcImdcIik7XG4gIG5vZGVzRWxlbS5hdHRyKFwiY2xhc3NcIiwgXCJtaW5kbWFwLW5vZGVzXCIpO1xuICBkcmF3Tm9kZXMobm9kZXNFbGVtLCBtbSwgLTEsIGNvbmYpO1xuICBjb25zdCBjeSA9IGF3YWl0IGxheW91dE1pbmRtYXAobW0sIGNvbmYpO1xuICBkcmF3RWRnZXMoZWRnZXNFbGVtLCBjeSk7XG4gIHBvc2l0aW9uTm9kZXMoY3kpO1xuICBzZXR1cEdyYXBoVmlld2JveCh2b2lkIDAsIHN2ZywgY29uZi5taW5kbWFwLnBhZGRpbmcsIGNvbmYubWluZG1hcC51c2VNYXhXaWR0aCk7XG59O1xuY29uc3QgbWluZG1hcFJlbmRlcmVyID0ge1xuICBkcmF3XG59O1xuY29uc3QgZ2VuU2VjdGlvbnMgPSAob3B0aW9ucykgPT4ge1xuICBsZXQgc2VjdGlvbnMgPSBcIlwiO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG9wdGlvbnMuVEhFTUVfQ09MT1JfTElNSVQ7IGkrKykge1xuICAgIG9wdGlvbnNbXCJsaW5lQ29sb3JcIiArIGldID0gb3B0aW9uc1tcImxpbmVDb2xvclwiICsgaV0gfHwgb3B0aW9uc1tcImNTY2FsZUludlwiICsgaV07XG4gICAgaWYgKGlzRGFyayhvcHRpb25zW1wibGluZUNvbG9yXCIgKyBpXSkpIHtcbiAgICAgIG9wdGlvbnNbXCJsaW5lQ29sb3JcIiArIGldID0gbGlnaHRlbihvcHRpb25zW1wibGluZUNvbG9yXCIgKyBpXSwgMjApO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zW1wibGluZUNvbG9yXCIgKyBpXSA9IGRhcmtlbihvcHRpb25zW1wibGluZUNvbG9yXCIgKyBpXSwgMjApO1xuICAgIH1cbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IG9wdGlvbnMuVEhFTUVfQ09MT1JfTElNSVQ7IGkrKykge1xuICAgIGNvbnN0IHN3ID0gXCJcIiArICgxNyAtIDMgKiBpKTtcbiAgICBzZWN0aW9ucyArPSBgXG4gICAgLnNlY3Rpb24tJHtpIC0gMX0gcmVjdCwgLnNlY3Rpb24tJHtpIC0gMX0gcGF0aCwgLnNlY3Rpb24tJHtpIC0gMX0gY2lyY2xlLCAuc2VjdGlvbi0ke2kgLSAxfSBwb2x5Z29uLCAuc2VjdGlvbi0ke2kgLSAxfSBwYXRoICB7XG4gICAgICBmaWxsOiAke29wdGlvbnNbXCJjU2NhbGVcIiArIGldfTtcbiAgICB9XG4gICAgLnNlY3Rpb24tJHtpIC0gMX0gdGV4dCB7XG4gICAgIGZpbGw6ICR7b3B0aW9uc1tcImNTY2FsZUxhYmVsXCIgKyBpXX07XG4gICAgfVxuICAgIC5ub2RlLWljb24tJHtpIC0gMX0ge1xuICAgICAgZm9udC1zaXplOiA0MHB4O1xuICAgICAgY29sb3I6ICR7b3B0aW9uc1tcImNTY2FsZUxhYmVsXCIgKyBpXX07XG4gICAgfVxuICAgIC5zZWN0aW9uLWVkZ2UtJHtpIC0gMX17XG4gICAgICBzdHJva2U6ICR7b3B0aW9uc1tcImNTY2FsZVwiICsgaV19O1xuICAgIH1cbiAgICAuZWRnZS1kZXB0aC0ke2kgLSAxfXtcbiAgICAgIHN0cm9rZS13aWR0aDogJHtzd307XG4gICAgfVxuICAgIC5zZWN0aW9uLSR7aSAtIDF9IGxpbmUge1xuICAgICAgc3Ryb2tlOiAke29wdGlvbnNbXCJjU2NhbGVJbnZcIiArIGldfSA7XG4gICAgICBzdHJva2Utd2lkdGg6IDM7XG4gICAgfVxuXG4gICAgLmRpc2FibGVkLCAuZGlzYWJsZWQgY2lyY2xlLCAuZGlzYWJsZWQgdGV4dCB7XG4gICAgICBmaWxsOiBsaWdodGdyYXk7XG4gICAgfVxuICAgIC5kaXNhYmxlZCB0ZXh0IHtcbiAgICAgIGZpbGw6ICNlZmVmZWY7XG4gICAgfVxuICAgIGA7XG4gIH1cbiAgcmV0dXJuIHNlY3Rpb25zO1xufTtcbmNvbnN0IGdldFN0eWxlcyA9IChvcHRpb25zKSA9PiBgXG4gIC5lZGdlIHtcbiAgICBzdHJva2Utd2lkdGg6IDM7XG4gIH1cbiAgJHtnZW5TZWN0aW9ucyhvcHRpb25zKX1cbiAgLnNlY3Rpb24tcm9vdCByZWN0LCAuc2VjdGlvbi1yb290IHBhdGgsIC5zZWN0aW9uLXJvb3QgY2lyY2xlLCAuc2VjdGlvbi1yb290IHBvbHlnb24gIHtcbiAgICBmaWxsOiAke29wdGlvbnMuZ2l0MH07XG4gIH1cbiAgLnNlY3Rpb24tcm9vdCB0ZXh0IHtcbiAgICBmaWxsOiAke29wdGlvbnMuZ2l0QnJhbmNoTGFiZWwwfTtcbiAgfVxuICAuaWNvbi1jb250YWluZXIge1xuICAgIGhlaWdodDoxMDAlO1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgfVxuICAuZWRnZSB7XG4gICAgZmlsbDogbm9uZTtcbiAgfVxuICAubWluZG1hcC1ub2RlLWxhYmVsIHtcbiAgICBkeTogMWVtO1xuICAgIGFsaWdubWVudC1iYXNlbGluZTogbWlkZGxlO1xuICAgIHRleHQtYW5jaG9yOiBtaWRkbGU7XG4gICAgZG9taW5hbnQtYmFzZWxpbmU6IG1pZGRsZTtcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gIH1cbmA7XG5jb25zdCBtaW5kbWFwU3R5bGVzID0gZ2V0U3R5bGVzO1xuY29uc3QgZGlhZ3JhbSA9IHtcbiAgZGI6IG1pbmRtYXBEYixcbiAgcmVuZGVyZXI6IG1pbmRtYXBSZW5kZXJlcixcbiAgcGFyc2VyOiBtaW5kbWFwUGFyc2VyLFxuICBzdHlsZXM6IG1pbmRtYXBTdHlsZXNcbn07XG5leHBvcnQge1xuICBkaWFncmFtXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/mermaid/dist/mindmap-definition-617cf8dd.js\n"));

/***/ })

}]);