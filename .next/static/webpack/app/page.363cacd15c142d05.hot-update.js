"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-client)/./app/client/platforms/openai.ts":
/*!****************************************!*\
  !*** ./app/client/platforms/openai.ts ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChatGPTApi: function() { return /* binding */ ChatGPTApi; },\n/* harmony export */   OpenaiPath: function() { return /* reexport safe */ _app_constant__WEBPACK_IMPORTED_MODULE_0__.OpenaiPath; }\n/* harmony export */ });\n/* harmony import */ var _app_constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/app/constant */ \"(app-client)/./app/constant.ts\");\n/* harmony import */ var _app_store__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/app/store */ \"(app-client)/./app/store/index.ts\");\n/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../api */ \"(app-client)/./app/client/api.ts\");\n/* harmony import */ var _locales__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../locales */ \"(app-client)/./app/locales/index.ts\");\n/* harmony import */ var _fortaine_fetch_event_source__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @fortaine/fetch-event-source */ \"(app-client)/./node_modules/@fortaine/fetch-event-source/lib/esm/fetch.js\");\n/* harmony import */ var _app_utils_format__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/app/utils/format */ \"(app-client)/./app/utils/format.ts\");\n/* harmony import */ var _app_config_client__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/app/config/client */ \"(app-client)/./app/config/client.ts\");\n/* harmony import */ var _app_azure__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/app/azure */ \"(app-client)/./app/azure.ts\");\n\n\n\n\n\n\n\n\nclass ChatGPTApi {\n    path(path) {\n        debugger;\n        const accessStore = _app_store__WEBPACK_IMPORTED_MODULE_1__.useAccessStore.getState();\n        const isAzure = accessStore.provider === _app_constant__WEBPACK_IMPORTED_MODULE_0__.ServiceProvider.Azure;\n        if (isAzure && !accessStore.isValidAzure()) {\n            throw Error(\"incomplete azure config, please check it in your settings page\");\n        }\n        let baseUrl = isAzure ? accessStore.azureUrl : accessStore.openaiUrl;\n        if (baseUrl.length === 0) {\n            var _getClientConfig;\n            const isApp = !!((_getClientConfig = (0,_app_config_client__WEBPACK_IMPORTED_MODULE_5__.getClientConfig)()) === null || _getClientConfig === void 0 ? void 0 : _getClientConfig.isApp);\n            baseUrl = isApp ? _app_constant__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_API_HOST : _app_constant__WEBPACK_IMPORTED_MODULE_0__.ApiPath.OpenAI;\n        }\n        if (baseUrl.endsWith(\"/\")) {\n            baseUrl = baseUrl.slice(0, baseUrl.length - 1);\n        }\n        if (!baseUrl.startsWith(\"http\") && !baseUrl.startsWith(_app_constant__WEBPACK_IMPORTED_MODULE_0__.ApiPath.OpenAI)) {\n            baseUrl = \"https://\" + baseUrl;\n        }\n        if (isAzure) {\n            path = (0,_app_azure__WEBPACK_IMPORTED_MODULE_6__.makeAzurePath)(path, accessStore.azureApiVersion);\n        }\n        return [\n            baseUrl,\n            path\n        ].join(\"/\");\n    }\n    extractMessage(res) {\n        var _res_choices_at_message, _res_choices_at, _res_choices;\n        var _res_choices_at_message_content;\n        return (_res_choices_at_message_content = (_res_choices = res.choices) === null || _res_choices === void 0 ? void 0 : (_res_choices_at = _res_choices.at(0)) === null || _res_choices_at === void 0 ? void 0 : (_res_choices_at_message = _res_choices_at.message) === null || _res_choices_at_message === void 0 ? void 0 : _res_choices_at_message.content) !== null && _res_choices_at_message_content !== void 0 ? _res_choices_at_message_content : \"\";\n    }\n    async chat(options) {\n        var _options_onController, _options;\n        const messages = options.messages.map((v)=>({\n                role: v.role,\n                content: v.content\n            }));\n        const modelConfig = {\n            ..._app_store__WEBPACK_IMPORTED_MODULE_1__.useAppConfig.getState().modelConfig,\n            ..._app_store__WEBPACK_IMPORTED_MODULE_1__.useChatStore.getState().currentSession().mask.modelConfig,\n            ...{\n                model: options.config.model\n            }\n        };\n        const requestPayload = {\n            messages,\n            stream: options.config.stream,\n            model: modelConfig.model,\n            temperature: modelConfig.temperature,\n            presence_penalty: modelConfig.presence_penalty,\n            frequency_penalty: modelConfig.frequency_penalty,\n            top_p: modelConfig.top_p\n        };\n        console.log(\"[Request] openai payload: \", requestPayload);\n        const shouldStream = !!options.config.stream;\n        const controller = new AbortController();\n        (_options_onController = (_options = options).onController) === null || _options_onController === void 0 ? void 0 : _options_onController.call(_options, controller);\n        try {\n            const chatPath = this.path(_app_constant__WEBPACK_IMPORTED_MODULE_0__.OpenaiPath.ChatPath);\n            const chatPayload = {\n                method: \"POST\",\n                body: JSON.stringify(requestPayload),\n                signal: controller.signal,\n                headers: (0,_api__WEBPACK_IMPORTED_MODULE_2__.getHeaders)()\n            };\n            // make a fetch request\n            const requestTimeoutId = setTimeout(()=>controller.abort(), _app_constant__WEBPACK_IMPORTED_MODULE_0__.REQUEST_TIMEOUT_MS);\n            if (shouldStream) {\n                let responseText = \"\";\n                let remainText = \"\";\n                let finished = false;\n                // animate response to make it looks smooth\n                function animateResponseText() {\n                    if (finished || controller.signal.aborted) {\n                        responseText += remainText;\n                        console.log(\"[Response Animation] finished\");\n                        return;\n                    }\n                    if (remainText.length > 0) {\n                        var _options_onUpdate, _options;\n                        const fetchCount = Math.max(1, Math.round(remainText.length / 60));\n                        const fetchText = remainText.slice(0, fetchCount);\n                        responseText += fetchText;\n                        remainText = remainText.slice(fetchCount);\n                        (_options_onUpdate = (_options = options).onUpdate) === null || _options_onUpdate === void 0 ? void 0 : _options_onUpdate.call(_options, responseText, fetchText);\n                    }\n                    requestAnimationFrame(animateResponseText);\n                }\n                // start animaion\n                animateResponseText();\n                const finish = ()=>{\n                    if (!finished) {\n                        finished = true;\n                        options.onFinish(responseText + remainText);\n                    }\n                };\n                controller.signal.onabort = finish;\n                (0,_fortaine_fetch_event_source__WEBPACK_IMPORTED_MODULE_7__.fetchEventSource)(chatPath, {\n                    ...chatPayload,\n                    async onopen (res) {\n                        var _contentType, _res_headers_get;\n                        clearTimeout(requestTimeoutId);\n                        const contentType = res.headers.get(\"content-type\");\n                        console.log(\"[OpenAI] request response content type: \", contentType);\n                        if ((_contentType = contentType) === null || _contentType === void 0 ? void 0 : _contentType.startsWith(\"text/plain\")) {\n                            responseText = await res.clone().text();\n                            return finish();\n                        }\n                        if (!res.ok || !((_res_headers_get = res.headers.get(\"content-type\")) === null || _res_headers_get === void 0 ? void 0 : _res_headers_get.startsWith(_fortaine_fetch_event_source__WEBPACK_IMPORTED_MODULE_7__.EventStreamContentType)) || res.status !== 200) {\n                            const responseTexts = [\n                                responseText\n                            ];\n                            let extraInfo = await res.clone().text();\n                            try {\n                                const resJson = await res.clone().json();\n                                extraInfo = (0,_app_utils_format__WEBPACK_IMPORTED_MODULE_4__.prettyObject)(resJson);\n                            } catch (e) {}\n                            if (res.status === 401) {\n                                responseTexts.push(_locales__WEBPACK_IMPORTED_MODULE_3__[\"default\"].Error.Unauthorized);\n                            }\n                            if (extraInfo) {\n                                responseTexts.push(extraInfo);\n                            }\n                            responseText = responseTexts.join(\"\\n\\n\");\n                            return finish();\n                        }\n                    },\n                    onmessage (msg) {\n                        if (msg.data === \"[DONE]\" || finished) {\n                            return finish();\n                        }\n                        const text = msg.data;\n                        try {\n                            var _json_choices__delta, _json_choices_;\n                            const json = JSON.parse(text);\n                            const delta = (_json_choices_ = json.choices[0]) === null || _json_choices_ === void 0 ? void 0 : (_json_choices__delta = _json_choices_.delta) === null || _json_choices__delta === void 0 ? void 0 : _json_choices__delta.content;\n                            if (delta) {\n                                remainText += delta;\n                            }\n                        } catch (e) {\n                            console.error(\"[Request] parse error\", text);\n                        }\n                    },\n                    onclose () {\n                        finish();\n                    },\n                    onerror (e) {\n                        var _options_onError, _options;\n                        (_options_onError = (_options = options).onError) === null || _options_onError === void 0 ? void 0 : _options_onError.call(_options, e);\n                        throw e;\n                    },\n                    openWhenHidden: true\n                });\n            } else {\n                const res = await fetch(chatPath, chatPayload);\n                clearTimeout(requestTimeoutId);\n                const resJson = await res.json();\n                const message = this.extractMessage(resJson);\n                options.onFinish(message);\n            }\n        } catch (e) {\n            var _options_onError, _options1;\n            console.log(\"[Request] failed to make a chat request\", e);\n            (_options_onError = (_options1 = options).onError) === null || _options_onError === void 0 ? void 0 : _options_onError.call(_options1, e);\n        }\n    }\n    async usage() {\n        const formatDate = (d)=>\"\".concat(d.getFullYear(), \"-\").concat((d.getMonth() + 1).toString().padStart(2, \"0\"), \"-\").concat(d.getDate().toString().padStart(2, \"0\"));\n        const ONE_DAY = 1 * 24 * 60 * 60 * 1000;\n        const now = new Date();\n        const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);\n        const startDate = formatDate(startOfMonth);\n        const endDate = formatDate(new Date(Date.now() + ONE_DAY));\n        const [used, subs] = await Promise.all([\n            fetch(this.path(\"\".concat(_app_constant__WEBPACK_IMPORTED_MODULE_0__.OpenaiPath.UsagePath, \"?start_date=\").concat(startDate, \"&end_date=\").concat(endDate)), {\n                method: \"GET\",\n                headers: (0,_api__WEBPACK_IMPORTED_MODULE_2__.getHeaders)()\n            }),\n            fetch(this.path(_app_constant__WEBPACK_IMPORTED_MODULE_0__.OpenaiPath.SubsPath), {\n                method: \"GET\",\n                headers: (0,_api__WEBPACK_IMPORTED_MODULE_2__.getHeaders)()\n            })\n        ]);\n        if (used.status === 401) {\n            throw new Error(_locales__WEBPACK_IMPORTED_MODULE_3__[\"default\"].Error.Unauthorized);\n        }\n        if (!used.ok || !subs.ok) {\n            throw new Error(\"Failed to query usage from openai\");\n        }\n        const response = await used.json();\n        const total = await subs.json();\n        if (response.error && response.error.type) {\n            throw Error(response.error.message);\n        }\n        if (response.total_usage) {\n            response.total_usage = Math.round(response.total_usage) / 100;\n        }\n        if (total.hard_limit_usd) {\n            total.hard_limit_usd = Math.round(total.hard_limit_usd * 100) / 100;\n        }\n        return {\n            used: response.total_usage,\n            total: total.hard_limit_usd\n        };\n    }\n    async models() {\n        var _resJson_data;\n        if (this.disableListModels) {\n            return _app_constant__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_MODELS.slice();\n        }\n        const res = await fetch(this.path(_app_constant__WEBPACK_IMPORTED_MODULE_0__.OpenaiPath.ListModelPath), {\n            method: \"GET\",\n            headers: {\n                ...(0,_api__WEBPACK_IMPORTED_MODULE_2__.getHeaders)()\n            }\n        });\n        const resJson = await res.json();\n        const chatModels = (_resJson_data = resJson.data) === null || _resJson_data === void 0 ? void 0 : _resJson_data.filter((m)=>m.id.startsWith(\"gpt-\"));\n        console.log(\"[Models]\", chatModels);\n        if (!chatModels) {\n            return [];\n        }\n        return chatModels.map((m)=>({\n                name: m.id,\n                available: true\n            }));\n    }\n    constructor(){\n        this.disableListModels = true;\n    }\n}\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vYXBwL2NsaWVudC9wbGF0Zm9ybXMvb3BlbmFpLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFPd0I7QUFDaUQ7QUFFSTtBQUMxQztBQUlHO0FBQ1k7QUFDSTtBQUNWO0FBV3JDLE1BQU1nQjtJQUdYQyxLQUFLQSxJQUFZLEVBQVU7UUFDekIsUUFBUztRQUNULE1BQU1DLGNBQWNaLHNEQUFjQSxDQUFDYSxRQUFRO1FBRTNDLE1BQU1DLFVBQVVGLFlBQVlHLFFBQVEsS0FBS2hCLDBEQUFlQSxDQUFDaUIsS0FBSztRQUU5RCxJQUFJRixXQUFXLENBQUNGLFlBQVlLLFlBQVksSUFBSTtZQUMxQyxNQUFNQyxNQUNKO1FBRUo7UUFFQSxJQUFJQyxVQUFVTCxVQUFVRixZQUFZUSxRQUFRLEdBQUdSLFlBQVlTLFNBQVM7UUFFcEUsSUFBSUYsUUFBUUcsTUFBTSxLQUFLLEdBQUc7Z0JBQ1JkO1lBQWhCLE1BQU1lLFFBQVEsQ0FBQyxHQUFDZixtQkFBQUEsbUVBQWVBLGdCQUFmQSx1Q0FBQUEsaUJBQW1CZSxLQUFLO1lBQ3hDSixVQUFVSSxRQUFRNUIsMkRBQWdCQSxHQUFHRCxrREFBT0EsQ0FBQzhCLE1BQU07UUFDckQ7UUFFQSxJQUFJTCxRQUFRTSxRQUFRLENBQUMsTUFBTTtZQUN6Qk4sVUFBVUEsUUFBUU8sS0FBSyxDQUFDLEdBQUdQLFFBQVFHLE1BQU0sR0FBRztRQUM5QztRQUNBLElBQUksQ0FBQ0gsUUFBUVEsVUFBVSxDQUFDLFdBQVcsQ0FBQ1IsUUFBUVEsVUFBVSxDQUFDakMsa0RBQU9BLENBQUM4QixNQUFNLEdBQUc7WUFDdEVMLFVBQVUsYUFBYUE7UUFDekI7UUFFQSxJQUFJTCxTQUFTO1lBQ1hILE9BQU9GLHlEQUFhQSxDQUFDRSxNQUFNQyxZQUFZZ0IsZUFBZTtRQUN4RDtRQUVBLE9BQU87WUFBQ1Q7WUFBU1I7U0FBSyxDQUFDa0IsSUFBSSxDQUFDO0lBQzlCO0lBRUFDLGVBQWVDLEdBQVEsRUFBRTtZQUNoQkEseUJBQUFB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WUFDYjtJQUNGOzthQXpTUVAsb0JBQW9COztBQTBTOUI7QUFDc0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL2NsaWVudC9wbGF0Zm9ybXMvb3BlbmFpLnRzP2FkZmEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQXBpUGF0aCxcbiAgREVGQVVMVF9BUElfSE9TVCxcbiAgREVGQVVMVF9NT0RFTFMsXG4gIE9wZW5haVBhdGgsXG4gIFJFUVVFU1RfVElNRU9VVF9NUyxcbiAgU2VydmljZVByb3ZpZGVyLFxufSBmcm9tIFwiQC9hcHAvY29uc3RhbnRcIjtcbmltcG9ydCB7IHVzZUFjY2Vzc1N0b3JlLCB1c2VBcHBDb25maWcsIHVzZUNoYXRTdG9yZSB9IGZyb20gXCJAL2FwcC9zdG9yZVwiO1xuXG5pbXBvcnQgeyBDaGF0T3B0aW9ucywgZ2V0SGVhZGVycywgTExNQXBpLCBMTE1Nb2RlbCwgTExNVXNhZ2UgfSBmcm9tIFwiLi4vYXBpXCI7XG5pbXBvcnQgTG9jYWxlIGZyb20gXCIuLi8uLi9sb2NhbGVzXCI7XG5pbXBvcnQge1xuICBFdmVudFN0cmVhbUNvbnRlbnRUeXBlLFxuICBmZXRjaEV2ZW50U291cmNlLFxufSBmcm9tIFwiQGZvcnRhaW5lL2ZldGNoLWV2ZW50LXNvdXJjZVwiO1xuaW1wb3J0IHsgcHJldHR5T2JqZWN0IH0gZnJvbSBcIkAvYXBwL3V0aWxzL2Zvcm1hdFwiO1xuaW1wb3J0IHsgZ2V0Q2xpZW50Q29uZmlnIH0gZnJvbSBcIkAvYXBwL2NvbmZpZy9jbGllbnRcIjtcbmltcG9ydCB7IG1ha2VBenVyZVBhdGggfSBmcm9tIFwiQC9hcHAvYXp1cmVcIjtcblxuZXhwb3J0IGludGVyZmFjZSBPcGVuQUlMaXN0TW9kZWxSZXNwb25zZSB7XG4gIG9iamVjdDogc3RyaW5nO1xuICBkYXRhOiBBcnJheTx7XG4gICAgaWQ6IHN0cmluZztcbiAgICBvYmplY3Q6IHN0cmluZztcbiAgICByb290OiBzdHJpbmc7XG4gIH0+O1xufVxuXG5leHBvcnQgY2xhc3MgQ2hhdEdQVEFwaSBpbXBsZW1lbnRzIExMTUFwaSB7XG4gIHByaXZhdGUgZGlzYWJsZUxpc3RNb2RlbHMgPSB0cnVlO1xuXG4gIHBhdGgocGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBkZWJ1Z2dlcjtcbiAgICBjb25zdCBhY2Nlc3NTdG9yZSA9IHVzZUFjY2Vzc1N0b3JlLmdldFN0YXRlKCk7XG5cbiAgICBjb25zdCBpc0F6dXJlID0gYWNjZXNzU3RvcmUucHJvdmlkZXIgPT09IFNlcnZpY2VQcm92aWRlci5BenVyZTtcblxuICAgIGlmIChpc0F6dXJlICYmICFhY2Nlc3NTdG9yZS5pc1ZhbGlkQXp1cmUoKSkge1xuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgIFwiaW5jb21wbGV0ZSBhenVyZSBjb25maWcsIHBsZWFzZSBjaGVjayBpdCBpbiB5b3VyIHNldHRpbmdzIHBhZ2VcIixcbiAgICAgICk7XG4gICAgfVxuXG4gICAgbGV0IGJhc2VVcmwgPSBpc0F6dXJlID8gYWNjZXNzU3RvcmUuYXp1cmVVcmwgOiBhY2Nlc3NTdG9yZS5vcGVuYWlVcmw7XG5cbiAgICBpZiAoYmFzZVVybC5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnN0IGlzQXBwID0gISFnZXRDbGllbnRDb25maWcoKT8uaXNBcHA7XG4gICAgICBiYXNlVXJsID0gaXNBcHAgPyBERUZBVUxUX0FQSV9IT1NUIDogQXBpUGF0aC5PcGVuQUk7XG4gICAgfVxuXG4gICAgaWYgKGJhc2VVcmwuZW5kc1dpdGgoXCIvXCIpKSB7XG4gICAgICBiYXNlVXJsID0gYmFzZVVybC5zbGljZSgwLCBiYXNlVXJsLmxlbmd0aCAtIDEpO1xuICAgIH1cbiAgICBpZiAoIWJhc2VVcmwuc3RhcnRzV2l0aChcImh0dHBcIikgJiYgIWJhc2VVcmwuc3RhcnRzV2l0aChBcGlQYXRoLk9wZW5BSSkpIHtcbiAgICAgIGJhc2VVcmwgPSBcImh0dHBzOi8vXCIgKyBiYXNlVXJsO1xuICAgIH1cblxuICAgIGlmIChpc0F6dXJlKSB7XG4gICAgICBwYXRoID0gbWFrZUF6dXJlUGF0aChwYXRoLCBhY2Nlc3NTdG9yZS5henVyZUFwaVZlcnNpb24pO1xuICAgIH1cblxuICAgIHJldHVybiBbYmFzZVVybCwgcGF0aF0uam9pbihcIi9cIik7XG4gIH1cblxuICBleHRyYWN0TWVzc2FnZShyZXM6IGFueSkge1xuICAgIHJldHVybiByZXMuY2hvaWNlcz8uYXQoMCk/Lm1lc3NhZ2U/LmNvbnRlbnQgPz8gXCJcIjtcbiAgfVxuXG4gIGFzeW5jIGNoYXQob3B0aW9uczogQ2hhdE9wdGlvbnMpIHtcbiAgICBjb25zdCBtZXNzYWdlcyA9IG9wdGlvbnMubWVzc2FnZXMubWFwKCh2KSA9PiAoe1xuICAgICAgcm9sZTogdi5yb2xlLFxuICAgICAgY29udGVudDogdi5jb250ZW50LFxuICAgIH0pKTtcblxuICAgIGNvbnN0IG1vZGVsQ29uZmlnID0ge1xuICAgICAgLi4udXNlQXBwQ29uZmlnLmdldFN0YXRlKCkubW9kZWxDb25maWcsXG4gICAgICAuLi51c2VDaGF0U3RvcmUuZ2V0U3RhdGUoKS5jdXJyZW50U2Vzc2lvbigpLm1hc2subW9kZWxDb25maWcsXG4gICAgICAuLi57XG4gICAgICAgIG1vZGVsOiBvcHRpb25zLmNvbmZpZy5tb2RlbCxcbiAgICAgIH0sXG4gICAgfTtcblxuICAgIGNvbnN0IHJlcXVlc3RQYXlsb2FkID0ge1xuICAgICAgbWVzc2FnZXMsXG4gICAgICBzdHJlYW06IG9wdGlvbnMuY29uZmlnLnN0cmVhbSxcbiAgICAgIG1vZGVsOiBtb2RlbENvbmZpZy5tb2RlbCxcbiAgICAgIHRlbXBlcmF0dXJlOiBtb2RlbENvbmZpZy50ZW1wZXJhdHVyZSxcbiAgICAgIHByZXNlbmNlX3BlbmFsdHk6IG1vZGVsQ29uZmlnLnByZXNlbmNlX3BlbmFsdHksXG4gICAgICBmcmVxdWVuY3lfcGVuYWx0eTogbW9kZWxDb25maWcuZnJlcXVlbmN5X3BlbmFsdHksXG4gICAgICB0b3BfcDogbW9kZWxDb25maWcudG9wX3AsXG4gICAgICAvLyBtYXhfdG9rZW5zOiBNYXRoLm1heChtb2RlbENvbmZpZy5tYXhfdG9rZW5zLCAxMDI0KSxcbiAgICAgIC8vIFBsZWFzZSBkbyBub3QgYXNrIG1lIHdoeSBub3Qgc2VuZCBtYXhfdG9rZW5zLCBubyByZWFzb24sIHRoaXMgcGFyYW0gaXMganVzdCBzaGl0LCBJIGRvbnQgd2FudCB0byBleHBsYWluIGFueW1vcmUuXG4gICAgfTtcblxuICAgIGNvbnNvbGUubG9nKFwiW1JlcXVlc3RdIG9wZW5haSBwYXlsb2FkOiBcIiwgcmVxdWVzdFBheWxvYWQpO1xuXG4gICAgY29uc3Qgc2hvdWxkU3RyZWFtID0gISFvcHRpb25zLmNvbmZpZy5zdHJlYW07XG4gICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBvcHRpb25zLm9uQ29udHJvbGxlcj8uKGNvbnRyb2xsZXIpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNoYXRQYXRoID0gdGhpcy5wYXRoKE9wZW5haVBhdGguQ2hhdFBhdGgpO1xuICAgICAgY29uc3QgY2hhdFBheWxvYWQgPSB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJlcXVlc3RQYXlsb2FkKSxcbiAgICAgICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbCxcbiAgICAgICAgaGVhZGVyczogZ2V0SGVhZGVycygpLFxuICAgICAgfTtcblxuICAgICAgLy8gbWFrZSBhIGZldGNoIHJlcXVlc3RcbiAgICAgIGNvbnN0IHJlcXVlc3RUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KFxuICAgICAgICAoKSA9PiBjb250cm9sbGVyLmFib3J0KCksXG4gICAgICAgIFJFUVVFU1RfVElNRU9VVF9NUyxcbiAgICAgICk7XG5cbiAgICAgIGlmIChzaG91bGRTdHJlYW0pIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlVGV4dCA9IFwiXCI7XG4gICAgICAgIGxldCByZW1haW5UZXh0ID0gXCJcIjtcbiAgICAgICAgbGV0IGZpbmlzaGVkID0gZmFsc2U7XG5cbiAgICAgICAgLy8gYW5pbWF0ZSByZXNwb25zZSB0byBtYWtlIGl0IGxvb2tzIHNtb290aFxuICAgICAgICBmdW5jdGlvbiBhbmltYXRlUmVzcG9uc2VUZXh0KCkge1xuICAgICAgICAgIGlmIChmaW5pc2hlZCB8fCBjb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICByZXNwb25zZVRleHQgKz0gcmVtYWluVGV4dDtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiW1Jlc3BvbnNlIEFuaW1hdGlvbl0gZmluaXNoZWRcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHJlbWFpblRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgZmV0Y2hDb3VudCA9IE1hdGgubWF4KDEsIE1hdGgucm91bmQocmVtYWluVGV4dC5sZW5ndGggLyA2MCkpO1xuICAgICAgICAgICAgY29uc3QgZmV0Y2hUZXh0ID0gcmVtYWluVGV4dC5zbGljZSgwLCBmZXRjaENvdW50KTtcbiAgICAgICAgICAgIHJlc3BvbnNlVGV4dCArPSBmZXRjaFRleHQ7XG4gICAgICAgICAgICByZW1haW5UZXh0ID0gcmVtYWluVGV4dC5zbGljZShmZXRjaENvdW50KTtcbiAgICAgICAgICAgIG9wdGlvbnMub25VcGRhdGU/LihyZXNwb25zZVRleHQsIGZldGNoVGV4dCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGVSZXNwb25zZVRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc3RhcnQgYW5pbWFpb25cbiAgICAgICAgYW5pbWF0ZVJlc3BvbnNlVGV4dCgpO1xuXG4gICAgICAgIGNvbnN0IGZpbmlzaCA9ICgpID0+IHtcbiAgICAgICAgICBpZiAoIWZpbmlzaGVkKSB7XG4gICAgICAgICAgICBmaW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgICBvcHRpb25zLm9uRmluaXNoKHJlc3BvbnNlVGV4dCArIHJlbWFpblRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBjb250cm9sbGVyLnNpZ25hbC5vbmFib3J0ID0gZmluaXNoO1xuXG4gICAgICAgIGZldGNoRXZlbnRTb3VyY2UoY2hhdFBhdGgsIHtcbiAgICAgICAgICAuLi5jaGF0UGF5bG9hZCxcbiAgICAgICAgICBhc3luYyBvbm9wZW4ocmVzKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQocmVxdWVzdFRpbWVvdXRJZCk7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9IHJlcy5oZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICBcIltPcGVuQUldIHJlcXVlc3QgcmVzcG9uc2UgY29udGVudCB0eXBlOiBcIixcbiAgICAgICAgICAgICAgY29udGVudFR5cGUsXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBpZiAoY29udGVudFR5cGU/LnN0YXJ0c1dpdGgoXCJ0ZXh0L3BsYWluXCIpKSB7XG4gICAgICAgICAgICAgIHJlc3BvbnNlVGV4dCA9IGF3YWl0IHJlcy5jbG9uZSgpLnRleHQoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZpbmlzaCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICFyZXMub2sgfHxcbiAgICAgICAgICAgICAgIXJlcy5oZWFkZXJzXG4gICAgICAgICAgICAgICAgLmdldChcImNvbnRlbnQtdHlwZVwiKVxuICAgICAgICAgICAgICAgID8uc3RhcnRzV2l0aChFdmVudFN0cmVhbUNvbnRlbnRUeXBlKSB8fFxuICAgICAgICAgICAgICByZXMuc3RhdHVzICE9PSAyMDBcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBjb25zdCByZXNwb25zZVRleHRzID0gW3Jlc3BvbnNlVGV4dF07XG4gICAgICAgICAgICAgIGxldCBleHRyYUluZm8gPSBhd2FpdCByZXMuY2xvbmUoKS50ZXh0KCk7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzSnNvbiA9IGF3YWl0IHJlcy5jbG9uZSgpLmpzb24oKTtcbiAgICAgICAgICAgICAgICBleHRyYUluZm8gPSBwcmV0dHlPYmplY3QocmVzSnNvbik7XG4gICAgICAgICAgICAgIH0gY2F0Y2gge31cblxuICAgICAgICAgICAgICBpZiAocmVzLnN0YXR1cyA9PT0gNDAxKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VUZXh0cy5wdXNoKExvY2FsZS5FcnJvci5VbmF1dGhvcml6ZWQpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGV4dHJhSW5mbykge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlVGV4dHMucHVzaChleHRyYUluZm8pO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmVzcG9uc2VUZXh0ID0gcmVzcG9uc2VUZXh0cy5qb2luKFwiXFxuXFxuXCIpO1xuXG4gICAgICAgICAgICAgIHJldHVybiBmaW5pc2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIG9ubWVzc2FnZShtc2cpIHtcbiAgICAgICAgICAgIGlmIChtc2cuZGF0YSA9PT0gXCJbRE9ORV1cIiB8fCBmaW5pc2hlZCkge1xuICAgICAgICAgICAgICByZXR1cm4gZmluaXNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0ZXh0ID0gbXNnLmRhdGE7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCBqc29uID0gSlNPTi5wYXJzZSh0ZXh0KSBhcyB7XG4gICAgICAgICAgICAgICAgY2hvaWNlczogQXJyYXk8e1xuICAgICAgICAgICAgICAgICAgZGVsdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogc3RyaW5nO1xuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9PjtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgY29uc3QgZGVsdGEgPSBqc29uLmNob2ljZXNbMF0/LmRlbHRhPy5jb250ZW50O1xuICAgICAgICAgICAgICBpZiAoZGVsdGEpIHtcbiAgICAgICAgICAgICAgICByZW1haW5UZXh0ICs9IGRlbHRhO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJbUmVxdWVzdF0gcGFyc2UgZXJyb3JcIiwgdGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbmNsb3NlKCkge1xuICAgICAgICAgICAgZmluaXNoKCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbmVycm9yKGUpIHtcbiAgICAgICAgICAgIG9wdGlvbnMub25FcnJvcj8uKGUpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9wZW5XaGVuSGlkZGVuOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGNoYXRQYXRoLCBjaGF0UGF5bG9hZCk7XG4gICAgICAgIGNsZWFyVGltZW91dChyZXF1ZXN0VGltZW91dElkKTtcblxuICAgICAgICBjb25zdCByZXNKc29uID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IHRoaXMuZXh0cmFjdE1lc3NhZ2UocmVzSnNvbik7XG4gICAgICAgIG9wdGlvbnMub25GaW5pc2gobWVzc2FnZSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5sb2coXCJbUmVxdWVzdF0gZmFpbGVkIHRvIG1ha2UgYSBjaGF0IHJlcXVlc3RcIiwgZSk7XG4gICAgICBvcHRpb25zLm9uRXJyb3I/LihlIGFzIEVycm9yKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgdXNhZ2UoKSB7XG4gICAgY29uc3QgZm9ybWF0RGF0ZSA9IChkOiBEYXRlKSA9PlxuICAgICAgYCR7ZC5nZXRGdWxsWWVhcigpfS0keyhkLmdldE1vbnRoKCkgKyAxKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsIFwiMFwiKX0tJHtkXG4gICAgICAgIC5nZXREYXRlKClcbiAgICAgICAgLnRvU3RyaW5nKClcbiAgICAgICAgLnBhZFN0YXJ0KDIsIFwiMFwiKX1gO1xuICAgIGNvbnN0IE9ORV9EQVkgPSAxICogMjQgKiA2MCAqIDYwICogMTAwMDtcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgIGNvbnN0IHN0YXJ0T2ZNb250aCA9IG5ldyBEYXRlKG5vdy5nZXRGdWxsWWVhcigpLCBub3cuZ2V0TW9udGgoKSwgMSk7XG4gICAgY29uc3Qgc3RhcnREYXRlID0gZm9ybWF0RGF0ZShzdGFydE9mTW9udGgpO1xuICAgIGNvbnN0IGVuZERhdGUgPSBmb3JtYXREYXRlKG5ldyBEYXRlKERhdGUubm93KCkgKyBPTkVfREFZKSk7XG5cbiAgICBjb25zdCBbdXNlZCwgc3Vic10gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICBmZXRjaChcbiAgICAgICAgdGhpcy5wYXRoKFxuICAgICAgICAgIGAke09wZW5haVBhdGguVXNhZ2VQYXRofT9zdGFydF9kYXRlPSR7c3RhcnREYXRlfSZlbmRfZGF0ZT0ke2VuZERhdGV9YCxcbiAgICAgICAgKSxcbiAgICAgICAge1xuICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICBoZWFkZXJzOiBnZXRIZWFkZXJzKCksXG4gICAgICAgIH0sXG4gICAgICApLFxuICAgICAgZmV0Y2godGhpcy5wYXRoKE9wZW5haVBhdGguU3Vic1BhdGgpLCB7XG4gICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgaGVhZGVyczogZ2V0SGVhZGVycygpLFxuICAgICAgfSksXG4gICAgXSk7XG5cbiAgICBpZiAodXNlZC5zdGF0dXMgPT09IDQwMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKExvY2FsZS5FcnJvci5VbmF1dGhvcml6ZWQpO1xuICAgIH1cblxuICAgIGlmICghdXNlZC5vayB8fCAhc3Vicy5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIHF1ZXJ5IHVzYWdlIGZyb20gb3BlbmFpXCIpO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3BvbnNlID0gKGF3YWl0IHVzZWQuanNvbigpKSBhcyB7XG4gICAgICB0b3RhbF91c2FnZT86IG51bWJlcjtcbiAgICAgIGVycm9yPzoge1xuICAgICAgICB0eXBlOiBzdHJpbmc7XG4gICAgICAgIG1lc3NhZ2U6IHN0cmluZztcbiAgICAgIH07XG4gICAgfTtcblxuICAgIGNvbnN0IHRvdGFsID0gKGF3YWl0IHN1YnMuanNvbigpKSBhcyB7XG4gICAgICBoYXJkX2xpbWl0X3VzZD86IG51bWJlcjtcbiAgICB9O1xuXG4gICAgaWYgKHJlc3BvbnNlLmVycm9yICYmIHJlc3BvbnNlLmVycm9yLnR5cGUpIHtcbiAgICAgIHRocm93IEVycm9yKHJlc3BvbnNlLmVycm9yLm1lc3NhZ2UpO1xuICAgIH1cblxuICAgIGlmIChyZXNwb25zZS50b3RhbF91c2FnZSkge1xuICAgICAgcmVzcG9uc2UudG90YWxfdXNhZ2UgPSBNYXRoLnJvdW5kKHJlc3BvbnNlLnRvdGFsX3VzYWdlKSAvIDEwMDtcbiAgICB9XG5cbiAgICBpZiAodG90YWwuaGFyZF9saW1pdF91c2QpIHtcbiAgICAgIHRvdGFsLmhhcmRfbGltaXRfdXNkID0gTWF0aC5yb3VuZCh0b3RhbC5oYXJkX2xpbWl0X3VzZCAqIDEwMCkgLyAxMDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHVzZWQ6IHJlc3BvbnNlLnRvdGFsX3VzYWdlLFxuICAgICAgdG90YWw6IHRvdGFsLmhhcmRfbGltaXRfdXNkLFxuICAgIH0gYXMgTExNVXNhZ2U7XG4gIH1cblxuICBhc3luYyBtb2RlbHMoKTogUHJvbWlzZTxMTE1Nb2RlbFtdPiB7XG4gICAgaWYgKHRoaXMuZGlzYWJsZUxpc3RNb2RlbHMpIHtcbiAgICAgIHJldHVybiBERUZBVUxUX01PREVMUy5zbGljZSgpO1xuICAgIH1cblxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKHRoaXMucGF0aChPcGVuYWlQYXRoLkxpc3RNb2RlbFBhdGgpLCB7XG4gICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIC4uLmdldEhlYWRlcnMoKSxcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBjb25zdCByZXNKc29uID0gKGF3YWl0IHJlcy5qc29uKCkpIGFzIE9wZW5BSUxpc3RNb2RlbFJlc3BvbnNlO1xuICAgIGNvbnN0IGNoYXRNb2RlbHMgPSByZXNKc29uLmRhdGE/LmZpbHRlcigobSkgPT4gbS5pZC5zdGFydHNXaXRoKFwiZ3B0LVwiKSk7XG4gICAgY29uc29sZS5sb2coXCJbTW9kZWxzXVwiLCBjaGF0TW9kZWxzKTtcblxuICAgIGlmICghY2hhdE1vZGVscykge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHJldHVybiBjaGF0TW9kZWxzLm1hcCgobSkgPT4gKHtcbiAgICAgIG5hbWU6IG0uaWQsXG4gICAgICBhdmFpbGFibGU6IHRydWUsXG4gICAgfSkpO1xuICB9XG59XG5leHBvcnQgeyBPcGVuYWlQYXRoIH07XG4iXSwibmFtZXMiOlsiQXBpUGF0aCIsIkRFRkFVTFRfQVBJX0hPU1QiLCJERUZBVUxUX01PREVMUyIsIk9wZW5haVBhdGgiLCJSRVFVRVNUX1RJTUVPVVRfTVMiLCJTZXJ2aWNlUHJvdmlkZXIiLCJ1c2VBY2Nlc3NTdG9yZSIsInVzZUFwcENvbmZpZyIsInVzZUNoYXRTdG9yZSIsImdldEhlYWRlcnMiLCJMb2NhbGUiLCJFdmVudFN0cmVhbUNvbnRlbnRUeXBlIiwiZmV0Y2hFdmVudFNvdXJjZSIsInByZXR0eU9iamVjdCIsImdldENsaWVudENvbmZpZyIsIm1ha2VBenVyZVBhdGgiLCJDaGF0R1BUQXBpIiwicGF0aCIsImFjY2Vzc1N0b3JlIiwiZ2V0U3RhdGUiLCJpc0F6dXJlIiwicHJvdmlkZXIiLCJBenVyZSIsImlzVmFsaWRBenVyZSIsIkVycm9yIiwiYmFzZVVybCIsImF6dXJlVXJsIiwib3BlbmFpVXJsIiwibGVuZ3RoIiwiaXNBcHAiLCJPcGVuQUkiLCJlbmRzV2l0aCIsInNsaWNlIiwic3RhcnRzV2l0aCIsImF6dXJlQXBpVmVyc2lvbiIsImpvaW4iLCJleHRyYWN0TWVzc2FnZSIsInJlcyIsImNob2ljZXMiLCJhdCIsIm1lc3NhZ2UiLCJjb250ZW50IiwiY2hhdCIsIm9wdGlvbnMiLCJtZXNzYWdlcyIsIm1hcCIsInYiLCJyb2xlIiwibW9kZWxDb25maWciLCJjdXJyZW50U2Vzc2lvbiIsIm1hc2siLCJtb2RlbCIsImNvbmZpZyIsInJlcXVlc3RQYXlsb2FkIiwic3RyZWFtIiwidGVtcGVyYXR1cmUiLCJwcmVzZW5jZV9wZW5hbHR5IiwiZnJlcXVlbmN5X3BlbmFsdHkiLCJ0b3BfcCIsImNvbnNvbGUiLCJsb2ciLCJzaG91bGRTdHJlYW0iLCJjb250cm9sbGVyIiwiQWJvcnRDb250cm9sbGVyIiwib25Db250cm9sbGVyIiwiY2hhdFBhdGgiLCJDaGF0UGF0aCIsImNoYXRQYXlsb2FkIiwibWV0aG9kIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJzaWduYWwiLCJoZWFkZXJzIiwicmVxdWVzdFRpbWVvdXRJZCIsInNldFRpbWVvdXQiLCJhYm9ydCIsInJlc3BvbnNlVGV4dCIsInJlbWFpblRleHQiLCJmaW5pc2hlZCIsImFuaW1hdGVSZXNwb25zZVRleHQiLCJhYm9ydGVkIiwiZmV0Y2hDb3VudCIsIk1hdGgiLCJtYXgiLCJyb3VuZCIsImZldGNoVGV4dCIsIm9uVXBkYXRlIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiZmluaXNoIiwib25GaW5pc2giLCJvbmFib3J0Iiwib25vcGVuIiwiY29udGVudFR5cGUiLCJjbGVhclRpbWVvdXQiLCJnZXQiLCJjbG9uZSIsInRleHQiLCJvayIsInN0YXR1cyIsInJlc3BvbnNlVGV4dHMiLCJleHRyYUluZm8iLCJyZXNKc29uIiwianNvbiIsInB1c2giLCJVbmF1dGhvcml6ZWQiLCJvbm1lc3NhZ2UiLCJtc2ciLCJkYXRhIiwicGFyc2UiLCJkZWx0YSIsImUiLCJlcnJvciIsIm9uY2xvc2UiLCJvbmVycm9yIiwib25FcnJvciIsIm9wZW5XaGVuSGlkZGVuIiwiZmV0Y2giLCJ1c2FnZSIsImZvcm1hdERhdGUiLCJkIiwiZ2V0RnVsbFllYXIiLCJnZXRNb250aCIsInRvU3RyaW5nIiwicGFkU3RhcnQiLCJnZXREYXRlIiwiT05FX0RBWSIsIm5vdyIsIkRhdGUiLCJzdGFydE9mTW9udGgiLCJzdGFydERhdGUiLCJlbmREYXRlIiwidXNlZCIsInN1YnMiLCJQcm9taXNlIiwiYWxsIiwiVXNhZ2VQYXRoIiwiU3Vic1BhdGgiLCJyZXNwb25zZSIsInRvdGFsIiwidHlwZSIsInRvdGFsX3VzYWdlIiwiaGFyZF9saW1pdF91c2QiLCJtb2RlbHMiLCJkaXNhYmxlTGlzdE1vZGVscyIsIkxpc3RNb2RlbFBhdGgiLCJjaGF0TW9kZWxzIiwiZmlsdGVyIiwibSIsImlkIiwibmFtZSIsImF2YWlsYWJsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./app/client/platforms/openai.ts\n"));

/***/ })

});